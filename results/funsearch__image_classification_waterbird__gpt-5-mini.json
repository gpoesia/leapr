[
  "def feature(image: np.ndarray) -> float:\n    'Mean intensity in the central image region (robust to very small images)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    start_r = h // 4\n    start_c = w // 4\n    end_r = h - start_r\n    end_c = w - start_c\n    if end_r <= start_r or end_c <= start_c:\n        region = gray\n    else:\n        region = gray[start_r:end_r, start_c:end_c]\n    return float(np.mean(region)) if region.size else 0.0\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Average blue-to-green ratio across the image (higher values indicate bluer images)'\n    import numpy as np\n    eps = 1e-8\n    if len(image.shape) == 2:\n        rgb = np.stack([image, image, image], axis=2).astype(float)\n    else:\n        rgb = image.astype(float)\n    B = rgb[:, :, 2]\n    G = rgb[:, :, 1]\n    ratio = (B + eps) / (G + eps)\n    return float(np.mean(ratio))\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Colorfulness measure (Hasler-S\u00fcsstrunk style): combines rg and yb channels'\n    import numpy as np\n    if len(image.shape) == 2:\n        rgb = np.stack([image, image, image], axis=2).astype(float)\n    else:\n        rgb = image.astype(float)\n    R = rgb[:, :, 0]\n    G = rgb[:, :, 1]\n    B = rgb[:, :, 2]\n    rg = R - G\n    yb = 0.5 * (R + G) - B\n    std_rg = np.std(rg)\n    std_yb = np.std(yb)\n    mean_rg = np.mean(rg)\n    mean_yb = np.mean(yb)\n    colorfulness = np.sqrt(std_rg**2 + std_yb**2) + 0.3 * np.sqrt(mean_rg**2 + mean_yb**2)\n    return float(colorfulness)\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Edge density: proportion of pixels with strong gradient magnitude'\n    import numpy as np\n    eps = 1e-8\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    gy, gx = np.gradient(gray)\n    mag = np.sqrt(gx**2 + gy**2)\n    if mag.size == 0:\n        return 0.0\n    # Threshold using the 75th percentile to adapt to image contrast\n    thr = np.percentile(mag, 75)\n    strong = np.count_nonzero(mag > thr + eps)\n    return float(strong / (h * w + eps))\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Fraction of top-quarter pixels that are distinctly blue (useful for water detection)'\n    import numpy as np\n    eps = 1e-8\n    if len(image.shape) == 2:\n        rgb = np.stack([image, image, image], axis=2).astype(float)\n    else:\n        rgb = image.astype(float)\n    h, w = rgb.shape[:2]\n    top_h = max(1, h // 4)\n    region = rgb[:top_h, :, :]\n    max_val = np.max(region) if np.max(region) > 0 else 1.0\n    norm = region / (max_val + eps)\n    R = norm[:, :, 0]\n    G = norm[:, :, 1]\n    B = norm[:, :, 2]\n    # Blue-dominant where blue is noticeably larger than red and green\n    mask = (B > R * 1.15) & (B > G * 1.15)\n    return float(np.count_nonzero(mask) / (mask.size + eps))\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Mean per-pixel saturation approximated as (max-min)/max'\n    import numpy as np\n    eps = 1e-8\n    if len(image.shape) == 2:\n        rgb = np.stack([image, image, image], axis=2).astype(float)\n    else:\n        rgb = image.astype(float)\n    maxc = np.max(rgb, axis=2)\n    minc = np.min(rgb, axis=2)\n    sat = (maxc - minc) / (maxc + eps)\n    return float(np.mean(sat)) if sat.size else 0.0\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Texture energy: mean squared gradient magnitude (higher -> more texture)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    gy, gx = np.gradient(gray)\n    mag2 = gx**2 + gy**2\n    return float(np.mean(mag2)) if mag2.size else 0.0\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Relative strength of vertical edges (vertical edge energy / total edge energy)'\n    import numpy as np\n    eps = 1e-8\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    gy, gx = np.gradient(gray)\n    vert_energy = np.sum(np.abs(gx))\n    horiz_energy = np.sum(np.abs(gy))\n    return float(vert_energy / (vert_energy + horiz_energy + eps))\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Entropy of grayscale intensity (16-bin histogram) measuring visual complexity'\n    import numpy as np\n    eps = 1e-12\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    flat = gray.flatten()\n    if flat.size == 0:\n        return 0.0\n    hist, _ = np.histogram(flat, bins=16, range=(np.min(flat), np.max(flat) + eps))\n    probs = hist.astype(float) / (flat.size + eps)\n    probs_nonzero = probs[probs > 0]\n    entropy = -np.sum(probs_nonzero * np.log2(probs_nonzero + eps))\n    return float(entropy)\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Fraction of pixels where green channel is dominant (indicator of vegetation/land)'\n    import numpy as np\n    eps = 1e-8\n    if len(image.shape) == 2:\n        rgb = np.stack([image, image, image], axis=2).astype(float)\n    else:\n        rgb = image.astype(float)\n    R = rgb[:, :, 0]\n    G = rgb[:, :, 1]\n    B = rgb[:, :, 2]\n    mask = (G > R * 1.1) & (G > B * 1.1)\n    return float(np.count_nonzero(mask) / (mask.size + eps))\n",
  "def feature(image: np.ndarray) -> float:\n    'Normalized difference between top-quarter and bottom-quarter mean intensities'\n    import numpy as np\n    eps = 1e-8\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    h = gray.shape[0]\n    top_h = max(1, h // 4)\n    bottom_start = max(0, h - top_h)\n    top_mean = float(np.mean(gray[:top_h, :])) if top_h > 0 else 0.0\n    bottom_mean = float(np.mean(gray[bottom_start:, :])) if top_h > 0 else 0.0\n    denom = (abs(top_mean) + abs(bottom_mean) + eps)\n    return float((top_mean - bottom_mean) / denom)\n\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Fraction of pixels that are very bright across all channels (specular highlights)'\n    import numpy as np\n    eps = 1e-8\n    if len(image.shape) == 2:\n        rgb = np.stack([image, image, image], axis=2).astype(float)\n    else:\n        rgb = image.astype(float)\n    if rgb.size == 0:\n        return 0.0\n    global_max = np.max(rgb)\n    if global_max <= 0:\n        return 0.0\n    thr = 0.9 * global_max\n    mask = np.all(rgb >= thr, axis=2)\n    return float(np.count_nonzero(mask) / (mask.size + eps))\n\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Ratio of green-channel texture energy to blue-channel texture energy'\n    import numpy as np\n    eps = 1e-8\n    if len(image.shape) == 2:\n        rgb = np.stack([image, image, image], axis=2).astype(float)\n    else:\n        rgb = image.astype(float)\n    G = rgb[:, :, 1]\n    B = rgb[:, :, 2]\n    gy_g, gx_g = np.gradient(G.astype(float))\n    gy_b, gx_b = np.gradient(B.astype(float))\n    tex_g = np.mean(gx_g**2 + gy_g**2) if G.size else 0.0\n    tex_b = np.mean(gx_b**2 + gy_b**2) if B.size else 0.0\n    return float((tex_g + eps) / (tex_b + eps))\n\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Center mean minus border mean normalized by overall mean'\n    import numpy as np\n    eps = 1e-8\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    # center region\n    sr, sc = max(0, h // 4), max(0, w // 4)\n    er, ec = h - sr, w - sc\n    if er <= sr or ec <= sc:\n        center = gray\n    else:\n        center = gray[sr:er, sc:ec]\n    # border as four edge strips\n    t = max(1, min(h, w) // 8)\n    top = gray[:t, :]\n    bottom = gray[-t:, :]\n    left = gray[:, :t]\n    right = gray[:, -t:]\n    # combine border regions (may overlap at corners)\n    border_concat = np.concatenate([top.flatten(), bottom.flatten(), left.flatten(), right.flatten()]) if gray.size else np.array([0.0])\n    center_mean = float(np.mean(center)) if center.size else 0.0\n    border_mean = float(np.mean(border_concat)) if border_concat.size else 0.0\n    overall_mean = float(np.mean(gray)) if gray.size else 0.0\n    return float((center_mean - border_mean) / (abs(overall_mean) + eps))\n\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Fraction of image variance explained by a 3x3 box blur (low-frequency energy fraction)'\n    import numpy as np\n    eps = 1e-8\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    if gray.size == 0:\n        return 0.0\n    h, w = gray.shape[:2]\n    # pad by one for simple 3x3 average\n    pad = np.pad(gray, ((1, 1), (1, 1)), mode='reflect')\n    # compute 3x3 mean efficiently via summed slices\n    s = (pad[:-2, :-2] + pad[:-2, 1:-1] + pad[:-2, 2:] +\n         pad[1:-1, :-2] + pad[1:-1, 1:-1] + pad[1:-1, 2:] +\n         pad[2:, :-2] + pad[2:, 1:-1] + pad[2:, 2:]) / 9.0\n    blurred = s\n    var_orig = np.var(gray)\n    var_blur = np.var(blurred)\n    if var_orig <= 0:\n        return 0.0\n    return float(var_blur / (var_orig + eps))\n\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Absolute mean R-B difference normalized by its standard deviation (color skew magnitude)'\n    import numpy as np\n    eps = 1e-8\n    if len(image.shape) == 2:\n        R = image.astype(float)\n        B = image.astype(float)\n    else:\n        R = image[:, :, 0].astype(float)\n        B = image[:, :, 2].astype(float)\n    diff = R - B\n    if diff.size == 0:\n        return 0.0\n    mean_diff = float(np.mean(diff))\n    std_diff = float(np.std(diff))\n    return float(abs(mean_diff) / (std_diff + eps))\n\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Entropy of gradient orientation histogram (8 bins) measuring edge direction randomness'\n    import numpy as np\n    eps = 1e-12\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    if gray.size == 0:\n        return 0.0\n    gy, gx = np.gradient(gray)\n    ori = np.arctan2(gy, gx)  # -pi..pi\n    # map to 0..2pi\n    ori = ori + np.pi\n    flat = ori.flatten()\n    hist, _ = np.histogram(flat, bins=8, range=(0.0, 2 * np.pi))\n    probs = hist.astype(float) / (flat.size + eps)\n    probs_nonzero = probs[probs > 0]\n    entropy = -np.sum(probs_nonzero * np.log2(probs_nonzero + eps))\n    return float(entropy)\n\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Fraction of rows whose mean intensity is significantly above the image mean'\n    import numpy as np\n    eps = 1e-8\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    if gray.size == 0:\n        return 0.0\n    row_means = np.mean(gray, axis=1)\n    overall = np.mean(gray)\n    thr = overall * 1.05  # 5% above mean\n    count = np.count_nonzero(row_means > thr)\n    return float(count / (row_means.size + eps))\n\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Ratio of mean variance in 8x8 blocks to mean variance in 32x32 blocks (texture scale)'\n    import numpy as np\n    eps = 1e-8\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    if gray.size == 0:\n        return 0.0\n    def block_mean_var(img, bs):\n        bh = (img.shape[0] // bs) * bs\n        bw = (img.shape[1] // bs) * bs\n        if bh == 0 or bw == 0:\n            return float(np.var(img))\n        trimmed = img[:bh, :bw]\n        # reshape into blocks: (nh, bs, nw, bs) -> (nh, nw, bs, bs)\n        nh = bh // bs\n        nw = bw // bs\n        blocks = trimmed.reshape(nh, bs, nw, bs).swapaxes(1,2)\n        # compute var per block\n        block_vars = np.var(blocks, axis=(2,3))\n        return float(np.mean(block_vars))\n    small = block_mean_var(gray, 8)\n    large = block_mean_var(gray, 32)\n    return float((small + eps) / (large + eps))\n",
  "def feature(image: np.ndarray) -> float:\n    'Fraction of pixels where blue channel strongly dominates (indicative of water/sky)'\n    import numpy as np\n    eps = 1e-8\n    if image.size == 0:\n        return 0.0\n    if len(image.shape) == 2:\n        rgb = np.stack([image, image, image], axis=2).astype(float)\n    else:\n        rgb = image.astype(float)\n    R = rgb[:, :, 0]\n    G = rgb[:, :, 1]\n    B = rgb[:, :, 2]\n    mask = (B > 1.1 * R) & (B > 1.1 * G)\n    return float(np.count_nonzero(mask) / (mask.size + eps))\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Mean per-pixel chroma (max channel - min channel), measures color saturation per pixel'\n    import numpy as np\n    eps = 1e-8\n    if image.size == 0:\n        return 0.0\n    if len(image.shape) == 2:\n        rgb = np.stack([image, image, image], axis=2).astype(float)\n    else:\n        rgb = image.astype(float)\n    mx = np.max(rgb, axis=2)\n    mn = np.min(rgb, axis=2)\n    chroma = mx - mn\n    return float(np.mean(chroma))\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Shannon entropy of grayscale intensity histogram (32 bins), captures texture/contrast complexity'\n    import numpy as np\n    eps = 1e-10\n    if image.size == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    flat = gray.flatten()\n    if flat.size == 0:\n        return 0.0\n    hist, _ = np.histogram(flat, bins=32, density=False)\n    total = float(np.sum(hist))\n    if total <= 0:\n        return 0.0\n    p = hist / (total + eps)\n    entropy = -np.sum(np.where(p > 0, p * np.log(p + eps), 0.0))\n    return float(entropy)\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Horizon strength: ratio of strongest horizontal-edge row energy to mean row horizontal energy'\n    import numpy as np\n    eps = 1e-8\n    if image.size == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    h = gray.shape[0]\n    if h == 0:\n        return 0.0\n    gy, gx = np.gradient(gray)\n    row_energy = np.sum(np.abs(gy), axis=1)  # horizontal edges produce strong gy\n    if row_energy.size == 0:\n        return 0.0\n    max_row = float(np.max(row_energy))\n    mean_row = float(np.mean(row_energy))\n    return float(max_row / (mean_row + eps))\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Fraction of green-dominant pixels in the bottom quarter of the image (vegetation at feet)'\n    import numpy as np\n    eps = 1e-8\n    if image.size == 0:\n        return 0.0\n    if len(image.shape) == 2:\n        rgb = np.stack([image, image, image], axis=2).astype(float)\n    else:\n        rgb = image.astype(float)\n    h = rgb.shape[0]\n    start = max(0, (3 * h) // 4)\n    region = rgb[start:, :, :]\n    if region.size == 0:\n        return 0.0\n    R = region[:, :, 0]\n    G = region[:, :, 1]\n    B = region[:, :, 2]\n    mask = (G > R * 1.1) & (G > B * 1.1)\n    return float(np.count_nonzero(mask) / (mask.size + eps))\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Ratio of mean blue to mean green in the central region (blue vs vegetation center bias)'\n    import numpy as np\n    eps = 1e-8\n    if image.size == 0:\n        return 0.0\n    if len(image.shape) == 2:\n        rgb = np.stack([image, image, image], axis=2).astype(float)\n    else:\n        rgb = image.astype(float)\n    h, w = rgb.shape[:2]\n    sr, sc = h // 4, w // 4\n    er, ec = h - sr, w - sc\n    if er <= sr or ec <= sc:\n        region = rgb\n    else:\n        region = rgb[sr:er, sc:ec, :]\n    if region.size == 0:\n        return 0.0\n    meanB = float(np.mean(region[:, :, 2]))\n    meanG = float(np.mean(region[:, :, 1]))\n    return float(meanB / (meanG + eps))\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Normalized vertical variation: std of row means divided by mean intensity (measures layering)'\n    import numpy as np\n    eps = 1e-8\n    if image.size == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    h = gray.shape[0]\n    if h == 0:\n        return 0.0\n    row_means = np.mean(gray, axis=1)\n    std_rows = float(np.std(row_means))\n    mean_rows = float(np.mean(row_means))\n    return float(std_rows / (abs(mean_rows) + eps))\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Mean per-pixel horizontal-edge orientation fraction: avg(|gy|/magnitude) (1.0 means mostly horizontal edges)'\n    import numpy as np\n    eps = 1e-8\n    if image.size == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    gy, gx = np.gradient(gray)\n    mag = np.sqrt(gx * gx + gy * gy)\n    orient_frac = np.where(mag > 0, np.abs(gy) / (mag + eps), 0.0)\n    if orient_frac.size == 0:\n        return 0.0\n    return float(np.mean(orient_frac))\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Bottom vs top brightness bias normalized by overall mean (positive means bottom brighter)'\n    import numpy as np\n    eps = 1e-8\n    if image.size == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    h = gray.shape[0]\n    top_h = max(1, h // 4)\n    bottom_start = max(0, h - top_h)\n    top_mean = float(np.mean(gray[:top_h, :])) if top_h > 0 else 0.0\n    bottom_mean = float(np.mean(gray[bottom_start:, :])) if top_h > 0 else 0.0\n    overall = float(np.mean(gray)) if gray.size else 0.0\n    return float((bottom_mean - top_mean) / (abs(overall) + eps))\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Fraction of pixels with very low per-pixel color variance (uniform color areas like sky/water)'\n    import numpy as np\n    eps = 1e-8\n    if image.size == 0:\n        return 0.0\n    if len(image.shape) == 2:\n        rgb = np.stack([image, image, image], axis=2).astype(float)\n    else:\n        rgb = image.astype(float)\n    mx = np.max(rgb, axis=2)\n    mn = np.min(rgb, axis=2)\n    per_px_diff = mx - mn\n    global_range = float(np.max(rgb) - np.min(rgb))\n    thr = 0.1 * (global_range + eps)\n    mask = per_px_diff <= thr\n    return float(np.count_nonzero(mask) / (mask.size + eps))\n",
  "def feature(image: np.ndarray) -> float:\n    'Fraction of top-quarter pixels that are strongly blue-dominant (top-sky/water cue)'\n    import numpy as np\n    eps = 1e-8\n    if image.size == 0:\n        return 0.0\n    if len(image.shape) == 2:\n        rgb = np.stack([image, image, image], axis=2).astype(float)\n    else:\n        rgb = image.astype(float)\n    h, w = rgb.shape[:2]\n    top_h = max(1, h // 4)\n    region = rgb[:top_h, :, :]\n    if region.size == 0:\n        return 0.0\n    mean_intensity = np.mean(region, axis=2)\n    # consider blue-dominant and reasonably bright pixels in the top region\n    R = region[:, :, 0]\n    G = region[:, :, 1]\n    B = region[:, :, 2]\n    bright_thresh = np.percentile(mean_intensity.flatten(), 40)\n    mask = (B > 1.05 * R) & (B > 1.05 * G) & (mean_intensity > bright_thresh)\n    return float(np.count_nonzero(mask) / (mask.size + eps))\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Fraction of bottom-quarter pixels that are green-dominant (vegetation/land cue)'\n    import numpy as np\n    eps = 1e-8\n    if image.size == 0:\n        return 0.0\n    if len(image.shape) == 2:\n        rgb = np.stack([image, image, image], axis=2).astype(float)\n    else:\n        rgb = image.astype(float)\n    h, w = rgb.shape[:2]\n    bot_h = max(1, h // 4)\n    region = rgb[-bot_h:, :, :]\n    if region.size == 0:\n        return 0.0\n    R = region[:, :, 0]\n    G = region[:, :, 1]\n    B = region[:, :, 2]\n    mask = (G > 1.05 * R) & (G > 1.05 * B) & (G > np.mean(region))\n    return float(np.count_nonzero(mask) / (mask.size + eps))\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Left-right symmetry score of grayscale (1.0 = perfectly symmetric)'\n    import numpy as np\n    eps = 1e-8\n    if image.size == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    flipped = np.fliplr(gray)\n    diff = np.abs(gray - flipped)\n    mean_diff = float(np.mean(diff)) if diff.size else 0.0\n    mean_intensity = float(np.mean(gray)) if gray.size else 0.0\n    # normalized so value is in (-inf, 1], clamp to [0,1]\n    symmetry = 1.0 - (mean_diff / (mean_intensity + eps))\n    return float(np.clip(symmetry, 0.0, 1.0))\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Colorfulness metric (Hasler & Suesstrunk) combining RG/YB statistics'\n    import numpy as np\n    eps = 1e-8\n    if image.size == 0:\n        return 0.0\n    if len(image.shape) == 2:\n        rgb = np.stack([image, image, image], axis=2).astype(float)\n    else:\n        rgb = image.astype(float)\n    R = rgb[:, :, 0].astype(float)\n    G = rgb[:, :, 1].astype(float)\n    B = rgb[:, :, 2].astype(float)\n    rg = R - G\n    yb = 0.5 * (R + G) - B\n    std_rg = float(np.std(rg))\n    std_yb = float(np.std(yb))\n    mean_rg = float(np.mean(rg))\n    mean_yb = float(np.mean(yb))\n    colorfulness = np.sqrt(std_rg * std_rg + std_yb * std_yb) + 0.3 * np.sqrt(mean_rg * mean_rg + mean_yb * mean_yb)\n    return float(colorfulness + eps)\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Vertical blue bias gradient: normalized difference between top and bottom blue fraction'\n    import numpy as np\n    eps = 1e-8\n    if image.size == 0:\n        return 0.0\n    if len(image.shape) == 2:\n        rgb = np.stack([image, image, image], axis=2).astype(float)\n    else:\n        rgb = image.astype(float)\n    h = rgb.shape[0]\n    t = max(1, h // 3)\n    top = rgb[:t, :, :]\n    bottom = rgb[-t:, :, :]\n    def blue_frac(region):\n        if region.size == 0:\n            return 0.0\n        R = region[:, :, 0]\n        G = region[:, :, 1]\n        B = region[:, :, 2]\n        mask = (B > 1.05 * R) & (B > 1.05 * G)\n        return float(np.count_nonzero(mask) / (mask.size + eps))\n    bf_top = blue_frac(top)\n    bf_bottom = blue_frac(bottom)\n    denom = (bf_top + bf_bottom + eps)\n    return float((bf_top - bf_bottom) / denom)\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Image sharpness proxy: variance of discrete Laplacian (higher = sharper)'\n    import numpy as np\n    eps = 1e-8\n    if image.size == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    if gray.size == 0:\n        return 0.0\n    gy, gx = np.gradient(gray)\n    gxx = np.gradient(gx, axis=1)\n    gyy = np.gradient(gy, axis=0)\n    lap = gxx + gyy\n    return float(np.var(lap) + eps)\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Density of vertical color-dominance transitions per column (how often dominant color changes)'\n    import numpy as np\n    eps = 1e-8\n    if image.size == 0:\n        return 0.0\n    if len(image.shape) == 2:\n        rgb = np.stack([image, image, image], axis=2).astype(float)\n    else:\n        rgb = image.astype(float)\n    h, w = rgb.shape[:2]\n    if w <= 1:\n        return 0.0\n    # per-column mean color\n    col_means = np.mean(np.mean(rgb, axis=0), axis=1)  # shape (3,) but incorrect; fix by computing correctly\n    # corrected: compute (w,3)\n    col_means = np.mean(rgb, axis=0)  # shape (w,3)\n    dominant = np.argmax(col_means, axis=1)\n    transitions = np.count_nonzero(dominant[1:] != dominant[:-1])\n    return float(transitions / (w - 1 + eps))\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Ratio of mean chroma in center region to mean chroma in border regions'\n    import numpy as np\n    eps = 1e-8\n    if image.size == 0:\n        return 0.0\n    if len(image.shape) == 2:\n        rgb = np.stack([image, image, image], axis=2).astype(float)\n    else:\n        rgb = image.astype(float)\n    h, w = rgb.shape[:2]\n    sr, sc = h // 4, w // 4\n    er, ec = h - sr, w - sc\n    center = rgb[sr:er, sc:ec, :] if (er > sr and ec > sc) else rgb\n    t = max(1, min(h, w) // 8)\n    top = rgb[:t, :, :]\n    bottom = rgb[-t:, :, :]\n    left = rgb[:, :t, :]\n    right = rgb[:, -t:, :]\n    border = np.concatenate([top.reshape(-1,3), bottom.reshape(-1,3), left.reshape(-1,3), right.reshape(-1,3)], axis=0) if rgb.size else np.zeros((1,3))\n    def mean_chroma(arr):\n        if arr.size == 0:\n            return 0.0\n        mx = np.max(arr, axis=1)\n        mn = np.min(arr, axis=1)\n        return float(np.mean(mx - mn))\n    center_chroma = mean_chroma(center.reshape(-1,3))\n    border_chroma = mean_chroma(border)\n    return float(center_chroma / (border_chroma + eps))\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Width-to-height aspect ratio (w/h), useful for scene layout signals'\n    import numpy as np\n    eps = 1e-8\n    if image.size == 0:\n        return 0.0\n    h, w = image.shape[:2]\n    if h <= 0:\n        return 0.0\n    return float(w / (h + eps))\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Enrichment of bright pixels in the central region relative to whole image'\n    import numpy as np\n    eps = 1e-8\n    if image.size == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    if gray.size == 0:\n        return 0.0\n    mean = float(np.mean(gray))\n    std = float(np.std(gray))\n    thresh = mean + std\n    bright_mask = gray > thresh\n    total_bright = float(np.count_nonzero(bright_mask))\n    # central region\n    sr, sc = h // 4, w // 4\n    er, ec = h - sr, w - sc\n    center = gray[sr:er, sc:ec] if (er > sr and ec > sc) else gray\n    center_mask = center > thresh\n    center_bright = float(np.count_nonzero(center_mask))\n    total_pixels = float(gray.size)\n    center_pixels = float(center.size)\n    if total_bright <= 0:\n        return 0.0\n    # enrichment: (center_bright/center_area) / (total_bright/total_area)\n    enrichment = (center_bright / (center_pixels + eps)) / (total_bright / (total_pixels + eps) + eps)\n    return float(enrichment)\n",
  "def feature(image: np.ndarray) -> float:\n    'Overall colorfulness metric (Hasler-S\u00fcsstrunk style) estimating vividness'\n    import numpy as np\n    eps = 1e-8\n    if image.size == 0:\n        return 0.0\n    if len(image.shape) == 2:\n        rgb = np.stack([image, image, image], axis=2).astype(float)\n    else:\n        rgb = image.astype(float)\n    R = rgb[:, :, 0]\n    G = rgb[:, :, 1]\n    B = rgb[:, :, 2]\n    rg = R - G\n    yb = 0.5 * (R + G) - B\n    std_rg = float(np.std(rg))\n    std_yb = float(np.std(yb))\n    mean_rg = float(np.mean(np.abs(rg)))\n    mean_yb = float(np.mean(np.abs(yb)))\n    colorfulness = np.sqrt(std_rg * std_rg + std_yb * std_yb) + 0.3 * np.sqrt(mean_rg * mean_rg + mean_yb * mean_yb)\n    return float(colorfulness + eps)\n\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Left-right symmetry score: low means symmetric (returns normalized difference)'\n    import numpy as np\n    eps = 1e-8\n    if image.size == 0:\n        return 0.0\n    h, w = image.shape[:2]\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    flipped = np.fliplr(gray)\n    diff = np.abs(gray - flipped)\n    norm = float(np.mean(np.abs(gray)) + eps)\n    return float(np.mean(diff) / norm)\n\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Fraction of strongly blue pixels (simple water-color proxy)'\n    import numpy as np\n    eps = 1e-8\n    if image.size == 0:\n        return 0.0\n    if len(image.shape) == 2:\n        rgb = np.stack([image, image, image], axis=2).astype(float)\n    else:\n        rgb = image.astype(float)\n    R = rgb[:, :, 0]\n    G = rgb[:, :, 1]\n    B = rgb[:, :, 2]\n    mask = (B > 1.2 * R) & (B > 1.2 * G) & (B > (np.mean(rgb) + eps) * 0.8)\n    return float(np.count_nonzero(mask) / (mask.size + eps))\n\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Fraction of strongly green pixels (vegetation/land proxy)'\n    import numpy as np\n    eps = 1e-8\n    if image.size == 0:\n        return 0.0\n    if len(image.shape) == 2:\n        rgb = np.stack([image, image, image], axis=2).astype(float)\n    else:\n        rgb = image.astype(float)\n    R = rgb[:, :, 0]\n    G = rgb[:, :, 1]\n    B = rgb[:, :, 2]\n    mask = (G > 1.15 * R) & (G > 1.15 * B)\n    return float(np.count_nonzero(mask) / (mask.size + eps))\n\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Proportion of pixels with high gradient magnitude (edge density)'\n    import numpy as np\n    eps = 1e-8\n    if image.size == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    gy, gx = np.gradient(gray)\n    mag = np.sqrt(gx * gx + gy * gy)\n    if mag.size == 0:\n        return 0.0\n    thr = float(np.percentile(mag.flatten(), 75))\n    count = np.count_nonzero(mag > thr)\n    return float(count / (mag.size + eps))\n\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Vertical centroid (0..1) of blue-weighted pixels (1 = bottom, 0 = top)'\n    import numpy as np\n    eps = 1e-8\n    if image.size == 0:\n        return 0.5\n    if len(image.shape) == 2:\n        rgb = np.stack([image, image, image], axis=2).astype(float)\n    else:\n        rgb = image.astype(float)\n    h = rgb.shape[0]\n    R = rgb[:, :, 0]\n    G = rgb[:, :, 1]\n    B = rgb[:, :, 2]\n    mask = (B > 1.05 * R) & (B > 1.05 * G)\n    weights = mask.astype(float) * B\n    s = float(np.sum(weights))\n    if s <= 0:\n        return 0.5\n    rows = np.arange(h).reshape(h, 1)\n    centroid = float(np.sum(rows * weights) / (s + eps))\n    return float(centroid / max(1, h - 1))\n\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Center vs border contrast normalized by image std (positive when center brighter)'\n    import numpy as np\n    eps = 1e-8\n    if image.size == 0:\n        return 0.0\n    h, w = image.shape[:2]\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    sr, sc = h // 4, w // 4\n    er, ec = h - sr, w - sc\n    center = gray[sr:er, sc:ec] if (er > sr and ec > sc) else gray\n    border_top = gray[:sr, :] if sr > 0 else np.array([])\n    border_bottom = gray[er:, :] if er < h else np.array([])\n    border_left = gray[:, :sc] if sc > 0 else np.array([])\n    border_right = gray[:, ec:] if ec < w else np.array([])\n    border_parts = []\n    for b in (border_top, border_bottom, border_left, border_right):\n        if b.size:\n            border_parts.append(b.reshape(-1))\n    if border_parts:\n        border = np.concatenate(border_parts)\n    else:\n        border = gray.reshape(-1)\n    mean_center = float(np.mean(center)) if center.size else 0.0\n    mean_border = float(np.mean(border)) if border.size else 0.0\n    std_all = float(np.std(gray)) + eps\n    return float((mean_center - mean_border) / std_all)\n\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Fraction of dark pixels (below 15th percentile of image luminance)'\n    import numpy as np\n    eps = 1e-8\n    if image.size == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    flat = gray.flatten()\n    if flat.size == 0:\n        return 0.0\n    thr = float(np.percentile(flat, 15))\n    count = np.count_nonzero(flat < thr)\n    return float(count / (flat.size + eps))\n\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Dominant edge orientation concentration (max histogram bin fraction over 8 bins)'\n    import numpy as np\n    eps = 1e-8\n    if image.size == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    gy, gx = np.gradient(gray)\n    mag = np.sqrt(gx * gx + gy * gy)\n    if mag.size == 0:\n        return 0.0\n    angles = np.arctan2(gy, gx)  # -pi..pi\n    # weight angles by magnitude to focus on strong edges\n    bins = 8\n    # map angles to [0, bins)\n    idx = np.floor(((angles + np.pi) / (2 * np.pi)) * bins).astype(int)\n    idx = np.clip(idx, 0, bins - 1)\n    hist = np.zeros(bins, dtype=float)\n    for b in range(bins):\n        hist[b] = np.sum(mag[idx == b])\n    total = np.sum(hist) + eps\n    best = float(np.max(hist))\n    return float(best / total)\n\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Mean positive blue excess: average of max(B - max(R,G),0) normalized by overall mean brightness'\n    import numpy as np\n    eps = 1e-8\n    if image.size == 0:\n        return 0.0\n    if len(image.shape) == 2:\n        rgb = np.stack([image, image, image], axis=2).astype(float)\n    else:\n        rgb = image.astype(float)\n    R = rgb[:, :, 0]\n    G = rgb[:, :, 1]\n    B = rgb[:, :, 2]\n    excess = B - np.maximum(R, G)\n    pos = np.where(excess > 0, excess, 0.0)\n    mean_pos = float(np.mean(pos)) if pos.size else 0.0\n    mean_brightness = float(np.mean(np.mean(rgb, axis=2))) + eps\n    return float(mean_pos / mean_brightness)\n",
  "def feature(image: np.ndarray) -> float:\n    'Fraction of blue-dominant smooth pixels (blue areas with low local gradient)'\n    import numpy as np\n    eps = 1e-8\n    if image.size == 0:\n        return 0.0\n    if len(image.shape) == 2:\n        rgb = np.stack([image, image, image], axis=2).astype(float)\n    else:\n        rgb = image.astype(float)\n    h, w = rgb.shape[:2]\n    gray = np.mean(rgb, axis=2)\n    gy, gx = np.gradient(gray)\n    mag = np.sqrt(gx * gx + gy * gy)\n    # smooth if gradient magnitude is in the lower 25th percentile\n    grad_thr = np.percentile(mag, 25) if mag.size else 0.0\n    R, G, B = rgb[:, :, 0], rgb[:, :, 1], rgb[:, :, 2]\n    mask = (B > 1.1 * R) & (B > 1.1 * G) & (mag <= grad_thr + eps)\n    return float(np.count_nonzero(mask) / (mask.size + eps))\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Mean per-pixel saturation approximated as (max-min)/max'\n    import numpy as np\n    eps = 1e-8\n    if image.size == 0:\n        return 0.0\n    if len(image.shape) == 2:\n        rgb = np.stack([image, image, image], axis=2).astype(float)\n    else:\n        rgb = image.astype(float)\n    mx = np.max(rgb, axis=2)\n    mn = np.min(rgb, axis=2)\n    sat = (mx - mn) / (mx + eps)\n    return float(np.mean(sat)) if sat.size else 0.0\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Normalized vertical location of peak mean-blue row (0=top, 1=bottom)'\n    import numpy as np\n    if image.size == 0:\n        return 0.0\n    if len(image.shape) == 2:\n        rgb = np.stack([image, image, image], axis=2).astype(float)\n    else:\n        rgb = image.astype(float)\n    h = rgb.shape[0]\n    B = rgb[:, :, 2]\n    row_mean = np.mean(B, axis=1) if B.size else np.zeros((h,))\n    if h <= 1 or row_mean.size == 0:\n        return 0.5\n    peak_row = int(np.argmax(row_mean))\n    return float(peak_row / float(max(1, h - 1)))\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Variance of gradient magnitude inside central region as a center-texture measure'\n    import numpy as np\n    eps = 1e-8\n    if image.size == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    sr, sc = h // 4, w // 4\n    er, ec = h - sr, w - sc\n    center = gray[sr:er, sc:ec] if (er > sr and ec > sc) else gray\n    if center.size == 0:\n        return 0.0\n    gy, gx = np.gradient(center)\n    mag = np.sqrt(gx * gx + gy * gy)\n    return float(np.var(mag) + eps)\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Mean center brightness minus mean border brightness (positive if center brighter)'\n    import numpy as np\n    eps = 1e-8\n    if image.size == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    sr, sc = h // 4, w // 4\n    er, ec = h - sr, w - sc\n    center = gray[sr:er, sc:ec] if (er > sr and ec > sc) else gray\n    t = max(1, min(h, w) // 8)\n    top = gray[:t, :] if t > 0 else np.array([])\n    bottom = gray[-t:, :] if t > 0 else np.array([])\n    left = gray[:, :t] if t > 0 else np.array([])\n    right = gray[:, -t:] if t > 0 else np.array([])\n    border_parts = []\n    for part in (top, bottom, left, right):\n        if part.size:\n            border_parts.append(part.reshape(-1))\n    border = np.concatenate(border_parts) if border_parts else np.array([0.0])\n    center_mean = float(np.mean(center)) if center.size else 0.0\n    border_mean = float(np.mean(border)) if border.size else 0.0\n    return float(center_mean - border_mean)\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Ratio of image rows that contain significant edge pixels (vertical span of detail)'\n    import numpy as np\n    eps = 1e-8\n    if image.size == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    if h == 0:\n        return 0.0\n    gy, gx = np.gradient(gray)\n    mag = np.sqrt(gx * gx + gy * gy)\n    # threshold for strong pixels = 75th percentile\n    thr = np.percentile(mag, 75) if mag.size else 0.0\n    per_row_counts = np.count_nonzero(mag > thr + eps, axis=1)\n    row_pixel_requirement = max(1, int(0.05 * w))\n    rows_with_detail = np.count_nonzero(per_row_counts >= row_pixel_requirement)\n    return float(rows_with_detail / (h + eps))\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Fraction of pixels in the bottom third that are green-dominant (vegetation indicator)'\n    import numpy as np\n    eps = 1e-8\n    if image.size == 0:\n        return 0.0\n    if len(image.shape) == 2:\n        rgb = np.stack([image, image, image], axis=2).astype(float)\n    else:\n        rgb = image.astype(float)\n    h = rgb.shape[0]\n    start = (2 * h) // 3\n    region = rgb[start:, :, :] if start < h else rgb\n    if region.size == 0:\n        return 0.0\n    R, G, B = region[:, :, 0], region[:, :, 1], region[:, :, 2]\n    mask = (G > 1.05 * R) & (G > 1.05 * B)\n    return float(np.count_nonzero(mask) / (mask.size + eps))\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Mean blue prominence: average (B - meanRGB) normalized by per-pixel color std'\n    import numpy as np\n    eps = 1e-8\n    if image.size == 0:\n        return 0.0\n    if len(image.shape) == 2:\n        rgb = np.stack([image, image, image], axis=2).astype(float)\n    else:\n        rgb = image.astype(float)\n    mean_rgb = np.mean(rgb, axis=2)\n    std_rgb = np.std(rgb, axis=2)\n    B = rgb[:, :, 2]\n    prominence = (B - mean_rgb) / (std_rgb + eps)\n    return float(np.mean(prominence)) if prominence.size else 0.0\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Fraction of image columns that contain at least one very bright pixel (vertical specular streaks)'\n    import numpy as np\n    eps = 1e-8\n    if image.size == 0:\n        return 0.0\n    if len(image.shape) == 2:\n        rgb = np.stack([image, image, image], axis=2).astype(float)\n    else:\n        rgb = image.astype(float)\n    h, w = rgb.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    global_max = np.max(rgb)\n    if global_max <= 0:\n        return 0.0\n    thr = 0.95 * global_max\n    bright_mask = np.all(rgb >= thr, axis=2)\n    cols_with_bright = np.count_nonzero(np.any(bright_mask, axis=0))\n    return float(cols_with_bright / (w + eps))\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Estimated foreground coverage: fraction of pixels whose color distance from median is high'\n    import numpy as np\n    import numpy as np2  # local alias to avoid accidental reuse\n    if image.size == 0:\n        return 0.0\n    if len(image.shape) == 2:\n        arr = np.stack([image, image, image], axis=2).astype(float)\n    else:\n        arr = image.astype(float)\n    h, w = arr.shape[:2]\n    pixels = arr.reshape(-1, 3)\n    if pixels.size == 0:\n        return 0.0\n    median_color = np.median(pixels, axis=0)\n    diffs = pixels - median_color.reshape(1, 3)\n    dist = np.linalg.norm(diffs, axis=1)\n    # threshold at 70th percentile of distances to estimate foreground\n    thr = np.percentile(dist, 70) if dist.size else 0.0\n    mask = dist > thr\n    return float(np.count_nonzero(mask) / (dist.size + 1e-8))\n",
  "def feature(image: np.ndarray) -> float:\n    'Fraction of pixels that are strongly bluer than both red and green channels'\n    import numpy as np\n    eps = 1e-8\n    if image.size == 0:\n        return 0.0\n    if len(image.shape) == 2:\n        rgb = np.stack([image, image, image], axis=2).astype(float)\n    else:\n        rgb = image.astype(float)\n    R = rgb[:, :, 0]\n    G = rgb[:, :, 1]\n    B = rgb[:, :, 2]\n    img_range = float(np.max(rgb) - np.min(rgb) + eps)\n    # pixel is \"blue-dominant\" if B exceeds the max(R,G) by a fraction of image range\n    thr = 0.08 * img_range\n    mask = (B - np.maximum(R, G)) > thr\n    return float(np.count_nonzero(mask) / (mask.size + eps))\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Normalized difference between center mean brightness and border mean brightness'\n    import numpy as np\n    eps = 1e-8\n    if image.size == 0:\n        return 0.0\n    h, w = image.shape[:2]\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    sr, sc = h // 4, w // 4\n    er, ec = h - sr, w - sc\n    center = gray[sr:er, sc:ec] if (er > sr and ec > sc) else gray\n    # border is outer band of thickness min(h,w)//8 (at least 1)\n    t = max(1, min(h, w) // 8)\n    top = gray[:t, :]\n    bottom = gray[-t:, :]\n    left = gray[:, :t]\n    right = gray[:, -t:]\n    border = np.concatenate([top.reshape(-1), bottom.reshape(-1), left.reshape(-1), right.reshape(-1)]) if gray.size else np.array([0.0])\n    if center.size == 0 or border.size == 0:\n        return 0.0\n    center_mean = float(np.mean(center))\n    border_mean = float(np.mean(border))\n    denom = float(np.std(gray) + eps)\n    return float((center_mean - border_mean) / denom)\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Vertical reflection similarity: correlation between top half and vertically flipped bottom half'\n    import numpy as np\n    eps = 1e-8\n    if image.size == 0:\n        return 0.0\n    h, w = image.shape[:2]\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    half = h // 2\n    top = gray[:half, :]\n    bottom = gray[-half:, :]\n    if top.size == 0 or bottom.size == 0:\n        return 0.0\n    # crop to same shape if odd\n    if top.shape != bottom.shape:\n        minr = min(top.shape[0], bottom.shape[0])\n        top = top[-minr:, :]\n        bottom = bottom[:minr, :]\n    bottom_flipped = np.flipud(bottom)\n    # flatten and compute Pearson correlation\n    a = top.flatten().astype(float)\n    b = bottom_flipped.flatten().astype(float)\n    a_mean = np.mean(a)\n    b_mean = np.mean(b)\n    num = np.sum((a - a_mean) * (b - b_mean))\n    den = np.sqrt(np.sum((a - a_mean) ** 2) * np.sum((b - b_mean) ** 2)) + eps\n    return float((num / den + 1.0) / 2.0)  # normalized to [0,1]\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Fraction of pixels with strong local gradient magnitude (edge density)'\n    import numpy as np\n    eps = 1e-8\n    if image.size == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    gy, gx = np.gradient(gray)\n    mag = np.sqrt(gx * gx + gy * gy)\n    if mag.size == 0:\n        return 0.0\n    thr = np.percentile(mag, 75)  # strong edges above 75th percentile\n    strong = mag > thr\n    return float(np.count_nonzero(strong) / (strong.size + eps))\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Circular mean hue angle in degrees computed from RGB using arctan2 formula'\n    import numpy as np\n    eps = 1e-8\n    if image.size == 0:\n        return 0.0\n    if len(image.shape) == 2:\n        rgb = np.stack([image, image, image], axis=2).astype(float)\n    else:\n        rgb = image.astype(float)\n    R = rgb[:, :, 0].astype(float)\n    G = rgb[:, :, 1].astype(float)\n    B = rgb[:, :, 2].astype(float)\n    # hue formula: theta = atan2( sqrt(3)*(G-B), 2*R - G - B )\n    y = np.sqrt(3.0) * (G - B)\n    x = 2.0 * R - G - B\n    theta = np.arctan2(y, x)  # -pi..pi\n    # convert to 0..360 degrees\n    deg = (theta + np.pi) * (180.0 / np.pi)\n    flat = deg.flatten()\n    if flat.size == 0:\n        return 0.0\n    # circular mean via vector sum\n    rad = flat * (np.pi / 180.0)\n    mean_sin = np.mean(np.sin(rad))\n    mean_cos = np.mean(np.cos(rad))\n    mean_angle = np.arctan2(mean_sin, mean_cos)\n    mean_deg = (mean_angle + 2 * np.pi) % (2 * np.pi) * (180.0 / np.pi)\n    return float(mean_deg)\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Prominence of a horizontal edge row (max row horizontal-edge energy relative to average)'\n    import numpy as np\n    eps = 1e-8\n    if image.size == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    gy, gx = np.gradient(gray)\n    # horizontal-edge energy measured by absolute vertical gradient (gy)\n    row_energy = np.sum(np.abs(gy), axis=1)\n    if row_energy.size == 0:\n        return 0.0\n    max_e = float(np.max(row_energy))\n    mean_e = float(np.mean(row_energy))\n    std_e = float(np.std(row_energy))\n    # prominence normalized (higher means a strong horizon-like row)\n    return float((max_e - mean_e) / (std_e + eps))\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Normalized difference between mean blue and mean green channels'\n    import numpy as np\n    eps = 1e-8\n    if image.size == 0:\n        return 0.0\n    if len(image.shape) == 2:\n        rgb = np.stack([image, image, image], axis=2).astype(float)\n    else:\n        rgb = image.astype(float)\n    meanB = float(np.mean(rgb[:, :, 2]))\n    meanG = float(np.mean(rgb[:, :, 1]))\n    return float((meanB - meanG) / (meanB + meanG + eps))\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Fraction of tiny specular/bright spots: very bright & low-chroma pixels'\n    import numpy as np\n    eps = 1e-8\n    if image.size == 0:\n        return 0.0\n    if len(image.shape) == 2:\n        rgb = np.stack([image, image, image], axis=2).astype(float)\n    else:\n        rgb = image.astype(float)\n    mx = np.max(rgb, axis=2)\n    mn = np.min(rgb, axis=2)\n    chroma = mx - mn\n    gray = np.mean(rgb, axis=2)\n    # bright threshold: above 99th percentile\n    bright_thr = np.percentile(gray, 99) if gray.size else float(np.max(gray))\n    # chroma low threshold: small fraction of dynamic range\n    dyn = float(np.max(gray) - np.min(gray) + eps)\n    chroma_thr = 0.06 * dyn\n    mask = (gray >= bright_thr) & (chroma <= chroma_thr)\n    return float(np.count_nonzero(mask) / (mask.size + eps))\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Mean variance of per-block average color (16x16 blocks) measuring large-scale color non-uniformity'\n    import numpy as np\n    eps = 1e-8\n    if image.size == 0:\n        return 0.0\n    block = 16\n    if len(image.shape) == 2:\n        arr = np.stack([image, image, image], axis=2).astype(float)\n    else:\n        arr = image.astype(float)\n    h, w = arr.shape[:2]\n    bh = (h // block) * block\n    bw = (w // block) * block\n    if bh == 0 or bw == 0:\n        # fallback: variance of mean color\n        pix = arr.reshape(-1, 3)\n        if pix.size == 0:\n            return 0.0\n        channel_means = np.mean(pix, axis=0)\n        return float(np.var(channel_means))\n    trimmed = arr[:bh, :bw, :]\n    nh = bh // block\n    nw = bw // block\n    # reshape to (nh, block, nw, block, 3) -> (nh, nw, block, block, 3)\n    blocks = trimmed.reshape(nh, block, nw, block, 3).swapaxes(1,2)\n    # compute mean color per block (nh, nw, 3)\n    block_means = np.mean(blocks, axis=(2,3))\n    # variance across blocks per channel, then average channels\n    var_per_channel = np.var(block_means.reshape(-1, 3), axis=0)\n    return float(np.mean(var_per_channel) + eps)\n",
  "def feature(image: np.ndarray) -> float:\n    'Difference in fraction of strongly blue pixels between top and bottom thirds'\n    import numpy as np\n    eps = 1e-8\n    if image.size == 0:\n        return 0.0\n    if len(image.shape) == 2:\n        rgb = np.stack([image, image, image], axis=2).astype(float)\n    else:\n        rgb = image.astype(float)\n    h, w = rgb.shape[:2]\n    third = max(1, h // 3)\n    top = rgb[:third, :, :]\n    bottom = rgb[-third:, :, :]\n    global_mean = np.mean(rgb)\n    def blue_frac(region):\n        if region.size == 0:\n            return 0.0\n        R = region[:, :, 0]\n        G = region[:, :, 1]\n        B = region[:, :, 2]\n        mask = (B > 1.1 * R) & (B > 1.1 * G) & (B > global_mean * 0.6)\n        return float(np.count_nonzero(mask) / (mask.size + eps))\n    return float(blue_frac(top) - blue_frac(bottom))\n\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Fraction of strongly green pixels (vegetation proxy)'\n    import numpy as np\n    eps = 1e-8\n    if image.size == 0:\n        return 0.0\n    if len(image.shape) == 2:\n        rgb = np.stack([image, image, image], axis=2).astype(float)\n    else:\n        rgb = image.astype(float)\n    R = rgb[:, :, 0]\n    G = rgb[:, :, 1]\n    B = rgb[:, :, 2]\n    global_mean = np.mean(rgb)\n    mask = (G > 1.15 * R) & (G > 1.15 * B) & (G > global_mean * 0.6)\n    return float(np.count_nonzero(mask) / (mask.size + eps))\n\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Mean pixel saturation (HSV-style) using (max-min)/max approximation'\n    import numpy as np\n    eps = 1e-8\n    if image.size == 0:\n        return 0.0\n    if len(image.shape) == 2:\n        # grayscale has zero saturation\n        return 0.0\n    rgb = image.astype(float)\n    mx = np.max(rgb, axis=2)\n    mn = np.min(rgb, axis=2)\n    sat = np.where(mx > 0, (mx - mn) / (mx + eps), 0.0)\n    if sat.size == 0:\n        return 0.0\n    return float(np.mean(sat))\n\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Contrast ratio: mean of top 10% brightest pixels divided by mean of bottom 10% darkest'\n    import numpy as np\n    eps = 1e-8\n    if image.size == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    flat = gray.flatten()\n    if flat.size == 0:\n        return 0.0\n    k = max(1, int(0.1 * flat.size))\n    sorted_vals = np.sort(flat)\n    top_mean = np.mean(sorted_vals[-k:]) if k > 0 else np.mean(sorted_vals)\n    bottom_mean = np.mean(sorted_vals[:k]) if k > 0 else np.mean(sorted_vals)\n    return float(top_mean / (bottom_mean + eps))\n\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Image aspect ratio (width / height)'\n    import numpy as np\n    if image.size == 0:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0:\n        return 0.0\n    return float(w / float(h))\n\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Ratio of mean edge magnitude in center region to mean edge magnitude in outer border'\n    import numpy as np\n    eps = 1e-8\n    if image.size == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    gy, gx = np.gradient(gray)\n    mag = np.sqrt(gx * gx + gy * gy)\n    sr, sc = h // 4, w // 4\n    er, ec = h - sr, w - sc\n    if er <= sr or ec <= sc:\n        center = mag\n        outer = np.zeros_like(mag)\n    else:\n        center = mag[sr:er, sc:ec]\n        outer_mask = np.ones_like(mag, dtype=bool)\n        outer_mask[sr:er, sc:ec] = False\n        outer = mag[outer_mask]\n    center_mean = float(np.mean(center)) if center.size else 0.0\n    outer_mean = float(np.mean(outer)) if outer.size else 0.0\n    if outer_mean <= 0:\n        return float(center_mean)\n    return float(center_mean / (outer_mean + eps))\n\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Image colorfulness metric (Hasler & S\u00fcsstrunk inspired)'\n    import numpy as np\n    eps = 1e-8\n    if image.size == 0:\n        return 0.0\n    if len(image.shape) == 2:\n        return 0.0\n    rgb = image.astype(float)\n    R = rgb[:, :, 0].flatten()\n    G = rgb[:, :, 1].flatten()\n    B = rgb[:, :, 2].flatten()\n    rg = R - G\n    yb = 0.5 * (R + G) - B\n    std_rg = np.std(rg)\n    std_yb = np.std(yb)\n    mean_rg = np.mean(rg)\n    mean_yb = np.mean(yb)\n    colorfulness = np.sqrt(std_rg ** 2 + std_yb ** 2) + 0.3 * np.sqrt(mean_rg ** 2 + mean_yb ** 2 + eps)\n    return float(colorfulness)\n\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Normalized row index of strongest horizontal edge (0=top, 1=bottom)'\n    import numpy as np\n    eps = 1e-8\n    if image.size == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    if h == 0:\n        return 0.0\n    gy, gx = np.gradient(gray)\n    mag = np.sqrt(gx * gx + gy * gy)\n    per_row = np.sum(mag, axis=1)\n    idx = int(np.argmax(per_row)) if per_row.size else 0\n    return float(idx / (h - 1 + eps))\n\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Fraction of coarse image blocks that are predominantly blue (coarse water regions)'\n    import numpy as np\n    eps = 1e-8\n    if image.size == 0:\n        return 0.0\n    if len(image.shape) == 2:\n        rgb = np.stack([image, image, image], axis=2).astype(float)\n    else:\n        rgb = image.astype(float)\n    h, w = rgb.shape[:2]\n    bs = max(1, min(h, w) // 16)\n    new_h = (h // bs) * bs\n    new_w = (w // bs) * bs\n    if new_h == 0 or new_w == 0:\n        # fallback to pixel-level test\n        R = rgb[:, :, 0]\n        G = rgb[:, :, 1]\n        B = rgb[:, :, 2]\n        global_mean = np.mean(rgb)\n        mask = (B > R) & (B > G) & (B > global_mean * 0.6)\n        return float(np.count_nonzero(mask) / (mask.size + eps))\n    cropped = rgb[:new_h, :new_w, :].reshape(new_h // bs, bs, new_w // bs, bs, 3)\n    blocks = np.mean(np.mean(cropped, axis=1), axis=2)  # shape (nh_blocks, nw_blocks, 3)\n    Rb = blocks[:, :, 0]\n    Gb = blocks[:, :, 1]\n    Bb = blocks[:, :, 2]\n    global_mean = np.mean(rgb)\n    mask_blocks = (Bb > Rb) & (Bb > Gb) & (Bb > global_mean * 0.6)\n    return float(np.count_nonzero(mask_blocks) / (mask_blocks.size + eps))\n\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Left-right reflection similarity: correlation between left half and horizontally flipped right half'\n    import numpy as np\n    eps = 1e-8\n    if image.size == 0:\n        return 0.0\n    h, w = image.shape[:2]\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    half = w // 2\n    left = gray[:, :half]\n    right = gray[:, -half:]\n    if left.size == 0 or right.size == 0:\n        return 0.0\n    # crop to same shape if odd\n    if left.shape != right.shape:\n        minc = min(left.shape[1], right.shape[1])\n        left = left[:, -minc:]\n        right = right[:, :minc]\n    right_flipped = np.fliplr(right)\n    a = left.flatten().astype(float)\n    b = right_flipped.flatten().astype(float)\n    a_mean = np.mean(a)\n    b_mean = np.mean(b)\n    num = np.sum((a - a_mean) * (b - b_mean))\n    den = np.sqrt(np.sum((a - a_mean) ** 2) * np.sum((b - b_mean) ** 2)) + eps\n    corr = num / den\n    # normalize to [0,1]\n    return float((corr + 1.0) / 2.0)\n",
  "def feature(image: np.ndarray) -> float:\n    'Fraction of pixels where blue channel is clearly dominant (B > G+thr and B > R+thr)'\n    import numpy as np\n    eps = 1e-8\n    if image.size == 0:\n        return 0.0\n    if len(image.shape) == 2:\n        rgb = np.stack([image, image, image], axis=2).astype(float)\n    else:\n        rgb = image.astype(float)\n    R = rgb[:, :, 0]\n    G = rgb[:, :, 1]\n    B = rgb[:, :, 2]\n    # threshold relative to local brightness to be robust across exposures\n    thr = 0.08 * (np.max(rgb) + eps)\n    mask = (B > G + thr) & (B > R + thr)\n    return float(np.count_nonzero(mask) / (mask.size + eps))\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Mean per-pixel saturation estimate ((max-min)/max) averaged over image'\n    import numpy as np\n    eps = 1e-8\n    if image.size == 0:\n        return 0.0\n    if len(image.shape) == 2:\n        arr = np.stack([image, image, image], axis=2).astype(float)\n    else:\n        arr = image.astype(float)\n    mx = np.max(arr, axis=2)\n    mn = np.min(arr, axis=2)\n    sat = np.where(mx > 0, (mx - mn) / (mx + eps), 0.0)\n    return float(np.mean(sat))\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Fraction of top-half pixels likely sky: blue dominant, relatively bright, and not highly saturated'\n    import numpy as np\n    eps = 1e-8\n    if image.size == 0:\n        return 0.0\n    h = image.shape[0]\n    top = image[: max(1, h // 2), ...]\n    if len(top.shape) == 2:\n        rgb = np.stack([top, top, top], axis=2).astype(float)\n    else:\n        rgb = top.astype(float)\n    R = rgb[:, :, 0]; G = rgb[:, :, 1]; B = rgb[:, :, 2]\n    mx = np.max(rgb, axis=2)\n    mn = np.min(rgb, axis=2)\n    sat = np.where(mx > 0, (mx - mn) / (mx + eps), 0.0)\n    bright = mx > (np.mean(mx) * 0.85 + eps)\n    blue_dom = (B > G) & (B > R)\n    mask = blue_dom & bright & (sat < 0.45)\n    return float(np.count_nonzero(mask) / (mask.size + eps))\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Difference in green-dominant pixel fraction between bottom and top halves (bottom - top)'\n    import numpy as np\n    eps = 1e-8\n    if image.size == 0:\n        return 0.0\n    h = image.shape[0]\n    top = image[: max(1, h // 2), ...]\n    bottom = image[h // 2 :, ...]\n    def frac_green(arr):\n        if len(arr.shape) == 2:\n            rgb = np.stack([arr, arr, arr], axis=2).astype(float)\n        else:\n            rgb = arr.astype(float)\n        R = rgb[:, :, 0]; G = rgb[:, :, 1]; B = rgb[:, :, 2]\n        mask = (G > R) & (G > B)\n        return np.count_nonzero(mask) / (mask.size + eps)\n    return float(frac_green(bottom) - frac_green(top))\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Left-right symmetry score on grayscale (1.0 means very symmetric)'\n    import numpy as np\n    eps = 1e-8\n    if image.size == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    mid = w // 2\n    left = gray[:, :mid]\n    # take matching width from right\n    right = gray[:, w - mid :]\n    if left.size == 0 or right.size == 0:\n        return 0.0\n    right_flipped = np.fliplr(right)\n    # resize if shapes differ (possible when odd width); crop to min dims\n    min_h = min(left.shape[0], right_flipped.shape[0])\n    min_w = min(left.shape[1], right_flipped.shape[1])\n    L = left[:min_h, :min_w].astype(float)\n    R = right_flipped[:min_h, :min_w].astype(float)\n    diff = np.mean(np.abs(L - R))\n    denom = np.mean(np.abs(L) + np.abs(R)) / 2.0 + eps\n    score = 1.0 - (diff / denom)\n    # clamp to [0,1]\n    score = max(0.0, min(1.0, score))\n    return float(score)\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Fraction of pixels with strong local gradient (edge density) using 75th percentile threshold'\n    import numpy as np\n    eps = 1e-8\n    if image.size == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    gy, gx = np.gradient(gray)\n    mag = np.sqrt(gx * gx + gy * gy).reshape(-1)\n    if mag.size == 0:\n        return 0.0\n    thr = np.percentile(mag, 75)\n    return float(np.count_nonzero(mag > thr) / (mag.size + eps))\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Ratio of low-frequency variance to high-frequency variance (approximate), >1 means smoother image'\n    import numpy as np\n    eps = 1e-8\n    if image.size == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    bs = max(1, min(h, w) // 16)  # block size\n    bh = (h // bs) * bs\n    bw = (w // bs) * bs\n    if bh == 0 or bw == 0:\n        low = np.full_like(gray, np.mean(gray))\n    else:\n        trimmed = gray[:bh, :bw]\n        nh = bh // bs; nw = bw // bs\n        blocks = trimmed.reshape(nh, bs, nw, bs).swapaxes(1,2)\n        block_means = np.mean(blocks, axis=(2,3))\n        # reconstruct low-frequency approximation\n        low = np.repeat(np.repeat(block_means, bs, axis=0), bs, axis=1)\n        # if original had extra rows/cols, pad with global mean\n        if bh != h or bw != w:\n            pad = np.mean(gray)\n            tmp = np.full((h, w), pad, dtype=float)\n            tmp[:low.shape[0], :low.shape[1]] = low\n            low = tmp\n    high = gray.astype(float) - low\n    var_low = float(np.var(low))\n    var_high = float(np.var(high)) + eps\n    return float(var_low / var_high)\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Dominant color angle from average rg and yb components (arctan2(mean_yb, mean_rg))'\n    import numpy as np\n    eps = 1e-8\n    if image.size == 0:\n        return 0.0\n    if len(image.shape) == 2:\n        rgb = np.stack([image, image, image], axis=2).astype(float)\n    else:\n        rgb = image.astype(float)\n    R = rgb[:, :, 0]; G = rgb[:, :, 1]; B = rgb[:, :, 2]\n    rg = R - G\n    yb = 0.5 * (R + G) - B\n    mean_rg = float(np.mean(rg))\n    mean_yb = float(np.mean(yb))\n    angle = np.arctan2(mean_yb, mean_rg + eps)  # radians between -pi and pi\n    return float(angle)\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Horizontal reflection score of low-frequency content between top and bottom halves (correlation)'\n    import numpy as np\n    eps = 1e-8\n    if image.size == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    # low-frequency by small block averaging\n    bs = max(1, min(h, w) // 32)\n    bh = (h // bs) * bs\n    bw = (w // bs) * bs\n    if bh == 0 or bw == 0:\n        low = gray - np.mean(gray)\n    else:\n        trimmed = gray[:bh, :bw]\n        nh = bh // bs; nw = bw // bs\n        blocks = trimmed.reshape(nh, bs, nw, bs).swapaxes(1,2)\n        block_means = np.mean(blocks, axis=(2,3))\n        low = np.repeat(np.repeat(block_means, bs, axis=0), bs, axis=1)\n        if bh != h or bw != w:\n            pad = np.mean(gray)\n            tmp = np.full((h, w), pad, dtype=float)\n            tmp[:low.shape[0], :low.shape[1]] = low\n            low = tmp\n        low = low - np.mean(low)\n    top = low[: h // 2, :].reshape(-1)\n    bottom = low[h - (h // 2) :, :].reshape(-1)\n    ln = min(top.size, bottom.size)\n    if ln == 0:\n        return 0.0\n    top = top[:ln]; bottom = bottom[-ln:]\n    # correlate\n    num = np.mean((top - np.mean(top)) * (np.flipud(bottom) - np.mean(bottom)))\n    den = (np.std(top) * np.std(bottom) + eps)\n    corr = num / den\n    # normalize to [0,1] by mapping corr in [-1,1] -> (corr+1)/2\n    score = (corr + 1.0) / 2.0\n    return float(max(0.0, min(1.0, score)))\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Fraction of local blocks (16x16) that are very dark (mean intensity below 30% of global max)'\n    import numpy as np\n    eps = 1e-8\n    if image.size == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    bs = 16\n    bh = (h // bs) * bs\n    bw = (w // bs) * bs\n    if bh == 0 or bw == 0:\n        # fallback: single block treated as whole image\n        mean_val = np.mean(gray)\n        return float(1.0 if mean_val < 0.3 * (np.max(gray) + eps) else 0.0)\n    trimmed = gray[:bh, :bw]\n    nh = bh // bs; nw = bw // bs\n    blocks = trimmed.reshape(nh, bs, nw, bs).swapaxes(1,2)\n    block_means = np.mean(blocks, axis=(2,3)).reshape(-1)\n    thr = 0.3 * (np.max(gray) + eps)\n    dark_count = np.count_nonzero(block_means < thr)\n    return float(dark_count / (block_means.size + eps))\n",
  "def feature(image: np.ndarray) -> float:\n    'Normalized difference of mean blue minus mean green in the bottom half'\n    import numpy as np\n    eps = 1e-8\n    if image.size == 0:\n        return 0.0\n    # ensure RGB\n    if len(image.shape) == 2:\n        rgb = np.stack([image, image, image], axis=2).astype(float)\n    else:\n        rgb = image.astype(float)\n    h = rgb.shape[0]\n    bottom = rgb[h//2:, :, :] if h//2 > 0 else rgb\n    if bottom.size == 0:\n        return 0.0\n    meanB = float(np.mean(bottom[:, :, 2]))\n    meanG = float(np.mean(bottom[:, :, 1]))\n    return float((meanB - meanG) / (meanB + meanG + eps))\n\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Fraction of large blocks that are very smooth (low variance) indicating water-like regions'\n    import numpy as np\n    eps = 1e-8\n    if image.size == 0:\n        return 0.0\n    # use grayscale texture\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    bs = min(32, max(1, min(h, w)//4))  # block size adaptive\n    bh = (h // bs) * bs\n    bw = (w // bs) * bs\n    if bh == 0 or bw == 0:\n        return 0.0\n    trimmed = gray[:bh, :bw]\n    nh = bh // bs\n    nw = bw // bs\n    blocks = trimmed.reshape(nh, bs, nw, bs).swapaxes(1,2)\n    block_vars = np.var(blocks, axis=(2,3)).flatten()\n    if block_vars.size == 0:\n        return 0.0\n    global_var = np.var(gray)\n    # consider a block smooth if its variance is much lower than global variance\n    thr = max(1e-6, global_var * 0.08)\n    smooth_count = np.count_nonzero(block_vars < thr)\n    return float(smooth_count / (block_vars.size + eps))\n\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Fraction of strong edge pixels that are near-horizontal (horizon-like edges)'\n    import numpy as np\n    eps = 1e-8\n    if image.size == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    gy, gx = np.gradient(gray)\n    mag = np.sqrt(gx * gx + gy * gy)\n    if mag.size == 0:\n        return 0.0\n    thr = np.percentile(mag, 75) if mag.size else 0.0\n    strong_mask = mag > (thr + eps)\n    if np.count_nonzero(strong_mask) == 0:\n        return 0.0\n    orient_frac = np.where(mag > 0, np.abs(gy) / (mag + eps), 0.0)  # 1.0 -> horizontal\n    horiz_strong = np.count_nonzero((orient_frac > 0.8) & strong_mask)\n    return float(horiz_strong / (np.count_nonzero(strong_mask) + eps))\n\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Proportion of top-region pixels that are strongly blue (sky-like)'\n    import numpy as np\n    eps = 1e-8\n    if image.size == 0:\n        return 0.0\n    if len(image.shape) == 2:\n        rgb = np.stack([image, image, image], axis=2).astype(float)\n    else:\n        rgb = image.astype(float)\n    h, w = rgb.shape[:2]\n    t = max(1, h // 5)\n    top = rgb[:t, :, :]\n    if top.size == 0:\n        return 0.0\n    mean_top = np.mean(top)\n    # blue dominant and reasonably bright compared to top region mean\n    blue = top[:, :, 2]\n    green = top[:, :, 1]\n    red = top[:, :, 0]\n    bright = np.mean(top, axis=2) > (mean_top * 0.6)\n    blue_dom = (blue > green * 1.1) & (blue > red * 1.1) & bright\n    return float(np.count_nonzero(blue_dom) / (top.shape[0] * top.shape[1] + eps))\n\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Mean chroma of green-dominant pixels in the center region (vegetation indicator)'\n    import numpy as np\n    eps = 1e-8\n    if image.size == 0:\n        return 0.0\n    if len(image.shape) == 2:\n        rgb = np.stack([image, image, image], axis=2).astype(float)\n    else:\n        rgb = image.astype(float)\n    h, w = rgb.shape[:2]\n    sr, sc = h // 4, w // 4\n    er, ec = h - sr, w - sc\n    region = rgb[sr:er, sc:ec, :] if (er > sr and ec > sc) else rgb\n    if region.size == 0:\n        return 0.0\n    r = region[:, :, 0].flatten()\n    g = region[:, :, 1].flatten()\n    b = region[:, :, 2].flatten()\n    green_mask = (g > r) & (g > b)\n    if np.count_nonzero(green_mask) == 0:\n        return 0.0\n    mx = np.maximum(np.maximum(r, g), b)\n    mn = np.minimum(np.minimum(r, g), b)\n    chroma = mx - mn\n    mean_chroma_green = float(np.mean(chroma[green_mask]))\n    # normalize by average intensity to keep scale stable\n    mean_intensity = float(np.mean((r + g + b) / 3.0) + eps)\n    return float(mean_chroma_green / mean_intensity)\n\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Absolute contrast between center mean intensity and border mean intensity normalized by image std'\n    import numpy as np\n    eps = 1e-8\n    if image.size == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    sr, sc = h // 4, w // 4\n    er, ec = h - sr, w - sc\n    center = gray[sr:er, sc:ec] if (er > sr and ec > sc) else gray\n    # border as top/bottom/left/right strips\n    t = max(1, min(h, w) // 8)\n    top = gray[:t, :] if t < h else np.array([])\n    bottom = gray[-t:, :] if t < h else np.array([])\n    left = gray[:, :t] if t < w else np.array([])\n    right = gray[:, -t:] if t < w else np.array([])\n    border_parts = []\n    if top.size: border_parts.append(top.flatten())\n    if bottom.size: border_parts.append(bottom.flatten())\n    if left.size: border_parts.append(left.flatten())\n    if right.size: border_parts.append(right.flatten())\n    if len(border_parts) == 0:\n        return 0.0\n    border = np.concatenate(border_parts)\n    if center.size == 0 or border.size == 0:\n        return 0.0\n    mean_center = float(np.mean(center))\n    mean_border = float(np.mean(border))\n    img_std = float(np.std(gray) + eps)\n    return float(abs(mean_center - mean_border) / img_std)\n\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Ratio of variance of vertical gradient to total gradient variance (vertical texture dominance)'\n    import numpy as np\n    eps = 1e-8\n    if image.size == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    gy, gx = np.gradient(gray)\n    var_gx = float(np.var(gx))\n    var_gy = float(np.var(gy))\n    return float(var_gx / (var_gx + var_gy + eps))\n\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Aspect ratio (height/width) of the bounding box of the brightest pixels (95th percentile)'\n    import numpy as np\n    eps = 1e-8\n    if image.size == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 95) if gray.size else 0.0\n    coords = np.argwhere(gray > thr)\n    if coords.size == 0:\n        return 0.0\n    minr, minc = coords.min(axis=0)\n    maxr, maxc = coords.max(axis=0)\n    hspan = float(maxr - minr + 1)\n    wspan = float(maxc - minc + 1)\n    return float(hspan / (wspan + eps))\n\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Image colorfulness metric (std of red-green and yellow-blue axes, higher = more colorful)'\n    import numpy as np\n    eps = 1e-8\n    if image.size == 0:\n        return 0.0\n    if len(image.shape) == 2:\n        rgb = np.stack([image, image, image], axis=2).astype(float)\n    else:\n        rgb = image.astype(float)\n    r = rgb[:, :, 0].flatten()\n    g = rgb[:, :, 1].flatten()\n    b = rgb[:, :, 2].flatten()\n    rg = r - g\n    yb = 0.5 * (r + g) - b\n    std_rg = float(np.std(rg))\n    std_yb = float(np.std(yb))\n    mean_rg = float(np.mean(np.abs(rg)))\n    mean_yb = float(np.mean(np.abs(yb)))\n    colorfulness = np.sqrt(std_rg * std_rg + std_yb * std_yb) + 0.3 * (mean_rg + mean_yb)\n    return float(colorfulness)\n\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Ratio of mean blue in bottom quarter to mean blue in top quarter (water concentration measure)'\n    import numpy as np\n    eps = 1e-8\n    if image.size == 0:\n        return 0.0\n    if len(image.shape) == 2:\n        rgb = np.stack([image, image, image], axis=2).astype(float)\n    else:\n        rgb = image.astype(float)\n    h = rgb.shape[0]\n    q = max(1, h // 4)\n    top = rgb[:q, :, :]\n    bottom = rgb[-q:, :, :]\n    if top.size == 0 or bottom.size == 0:\n        return 0.0\n    meanB_top = float(np.mean(top[:, :, 2]))\n    meanB_bottom = float(np.mean(bottom[:, :, 2]))\n    return float(meanB_bottom / (meanB_top + eps))\n",
  "def feature(image: np.ndarray) -> float:\n    'Fraction of pixels in the lower half that are green-dominant (vegetation indicator)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or image.size == 0:\n        return 0.0\n    # ensure RGB\n    if len(image.shape) == 2:\n        rgb = np.stack([image, image, image], axis=2).astype(float)\n    else:\n        rgb = image.astype(float)\n    h, w = rgb.shape[:2]\n    start = h // 2\n    lower = rgb[start:, :, :]\n    if lower.size == 0:\n        return 0.0\n    r = lower[:, :, 0]\n    g = lower[:, :, 1]\n    b = lower[:, :, 2]\n    # green-dominant relative test, require some brightness to avoid dark noise\n    bright = np.mean(lower, axis=2) > (np.mean(lower) * 0.25 + eps)\n    green_dom = (g > r * 1.05) & (g > b * 1.05) & bright\n    return float(np.count_nonzero(green_dom) / (green_dom.size + eps))\n\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Normalized difference between mean blue in top and bottom regions (top - bottom)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or image.size == 0:\n        return 0.0\n    if len(image.shape) == 2:\n        rgb = np.stack([image, image, image], axis=2).astype(float)\n    else:\n        rgb = image.astype(float)\n    h = rgb.shape[0]\n    t = max(1, h // 6)\n    top = rgb[:t, :, :]\n    bottom = rgb[-t:, :, :]\n    if top.size == 0 or bottom.size == 0:\n        return 0.0\n    mean_top_b = float(np.mean(top[:, :, 2]))\n    mean_bottom_b = float(np.mean(bottom[:, :, 2]))\n    overall_mean = float(np.mean(rgb) + eps)\n    return float((mean_top_b - mean_bottom_b) / overall_mean)\n\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Ratio of average edge magnitude in center region to average edge magnitude overall'\n    import numpy as np\n    eps = 1e-8\n    if image is None or image.size == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    gy, gx = np.gradient(gray)\n    mag = np.sqrt(gx * gx + gy * gy)\n    center_r0, center_c0 = h // 4, w // 4\n    center = mag[center_r0:h - center_r0, center_c0:w - center_c0] if (h > 2 * center_r0 and w > 2 * center_c0) else mag\n    if mag.size == 0:\n        return 0.0\n    avg_center = float(np.mean(center)) if center.size else 0.0\n    avg_total = float(np.mean(mag)) if mag.size else 0.0\n    return float(avg_center / (avg_total + eps))\n\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Variance of mean colors of coarse blocks (low for uniform surfaces like water)'\n    import numpy as np\n    if image is None or image.size == 0:\n        return 0.0\n    if len(image.shape) == 2:\n        rgb = np.stack([image, image, image], axis=2).astype(float)\n    else:\n        rgb = image.astype(float)\n    h, w = rgb.shape[:2]\n    block = max(1, min(h, w) // 16)\n    # partition into non-overlapping blocks and compute block mean intensity\n    bh = (h // block) * block\n    bw = (w // block) * block\n    if bh == 0 or bw == 0:\n        # too small to block; fall back to global variance of color channels\n        flat = rgb.reshape(-1, 3)\n        if flat.size == 0:\n            return 0.0\n        return float(np.mean(np.var(flat, axis=0)))\n    cropped = rgb[:bh, :bw, :].reshape(bh // block, block, bw // block, block, 3)\n    # mean over pixels per block\n    block_means = np.mean(np.mean(cropped, axis=1), axis=2)  # shape (bh//block, bw//block, 3)\n    # convert to intensity per block\n    block_int = np.mean(block_means, axis=2).flatten()\n    return float(np.var(block_int))\n\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Fraction of pixels that are warm-colored (red/orange/yellow)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or image.size == 0:\n        return 0.0\n    if len(image.shape) == 2:\n        # grayscale: infer warmness from intensity (treat as not warm)\n        return 0.0\n    rgb = image.astype(float)\n    r = rgb[:, :, 0]\n    g = rgb[:, :, 1]\n    b = rgb[:, :, 2]\n    # warm if red substantially exceeds others and has a decent chroma\n    warm = (r > g * 1.05) & (r > b * 1.05) & ((r - np.minimum(g, b)) > (np.mean(rgb) * 0.05 + eps))\n    return float(np.count_nonzero(warm) / (warm.size + eps))\n\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Fraction of pixels whose intensity lies within 10% of the global mean (mid-intensity mass)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or image.size == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    flat = gray.flatten()\n    if flat.size == 0:\n        return 0.0\n    mean = float(np.mean(flat))\n    span = max(1e-3, np.max(flat) - np.min(flat) + eps)\n    thr = 0.10 * span\n    mask = np.abs(flat - mean) <= thr\n    return float(np.count_nonzero(mask) / (flat.size + eps))\n\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Normalized vertical offset of green-pixel centroid from image center (positive means green below center)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or image.size == 0:\n        return 0.0\n    if len(image.shape) == 2:\n        rgb = np.stack([image, image, image], axis=2).astype(float)\n    else:\n        rgb = image.astype(float)\n    h, w = rgb.shape[:2]\n    r = rgb[:, :, 0]\n    g = rgb[:, :, 1]\n    b = rgb[:, :, 2]\n    green = (g > r * 1.05) & (g > b * 1.05)\n    if np.count_nonzero(green) == 0:\n        return 0.0\n    rows = np.arange(h)[:, None]\n    centroid_row = float(np.sum(rows * green) / (np.count_nonzero(green) + eps))\n    # normalized offset in range roughly [-0.5, 0.5]\n    offset = (centroid_row - (h / 2.0)) / float(h + eps)\n    return float(offset)\n\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Proportion of coarse blocks that are blue-dominant (coverage of blue regions)'\n    import numpy as np\n    import numpy as _np\n    if image is None or image.size == 0:\n        return 0.0\n    if len(image.shape) == 2:\n        rgb = _np.stack([image, image, image], axis=2).astype(float)\n    else:\n        rgb = image.astype(float)\n    h, w = rgb.shape[:2]\n    block = max(1, min(h, w) // 32)\n    bh = (h // block) * block\n    bw = (w // block) * block\n    if bh == 0 or bw == 0:\n        # fallback: pixel-wise blue dominance\n        b = rgb[:, :, 2]\n        g = rgb[:, :, 1]\n        r = rgb[:, :, 0]\n        blue_dom = (b > g * 1.05) & (b > r * 1.05)\n        return float(_np.count_nonzero(blue_dom) / (blue_dom.size + 1e-8))\n    cropped = rgb[:bh, :bw, :].reshape(bh // block, block, bw // block, block, 3)\n    block_means = _np.mean(_np.mean(cropped, axis=1), axis=2)  # shape (#bh,#bw,3)\n    bmean = block_means[:, :, 2]\n    gmean = block_means[:, :, 1]\n    rmean = block_means[:, :, 0]\n    blue_blocks = (bmean > gmean * 1.05) & (bmean > rmean * 1.05)\n    return float(_np.count_nonzero(blue_blocks) / (blue_blocks.size + 1e-8))\n\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Edge density: fraction of pixels with gradient magnitude above the 75th percentile'\n    import numpy as np\n    eps = 1e-8\n    if image is None or image.size == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    gy, gx = np.gradient(gray)\n    mag = np.sqrt(gx * gx + gy * gy).flatten()\n    if mag.size == 0:\n        return 0.0\n    thr = np.percentile(mag, 75) if mag.size > 0 else 0.0\n    dense = mag > thr\n    return float(np.count_nonzero(dense) / (mag.size + eps))\n\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Image aspect ratio (width divided by height)'\n    import numpy as np\n    if image is None or image.size == 0:\n        return 1.0\n    h, w = image.shape[:2]\n    if h == 0:\n        return 1.0\n    return float(float(w) / float(h))\n",
  "def feature(image: np.ndarray) -> float:\n    'Fraction of pixels in the top quarter that are blue-dominant (sky/water at top)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or image.size == 0:\n        return 0.0\n    if len(image.shape) == 2:\n        rgb = np.stack([image, image, image], axis=2).astype(float)\n    else:\n        rgb = image.astype(float)\n    h = rgb.shape[0]\n    top = rgb[:max(1, h // 4), :, :]\n    if top.size == 0:\n        return 0.0\n    R = top[:, :, 0]\n    G = top[:, :, 1]\n    B = top[:, :, 2]\n    overall_mean = float(np.mean(rgb))\n    bright = np.mean(top, axis=2) > (overall_mean * 0.25 + eps)\n    blue_dom = (B > 1.05 * R) & (B > 1.05 * G) & bright\n    return float(np.count_nonzero(blue_dom) / (blue_dom.size + eps))\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Fraction of pixels that match an \"earth-tone\" brown heuristic (R>G>B with moderate contrast)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or image.size == 0:\n        return 0.0\n    if len(image.shape) == 2:\n        rgb = np.stack([image, image, image], axis=2).astype(float)\n    else:\n        rgb = image.astype(float)\n    R = rgb[:, :, 0]\n    G = rgb[:, :, 1]\n    B = rgb[:, :, 2]\n    maxval = float(np.max(rgb)) if np.max(rgb) > 0 else 1.0\n    # brown if R > G > B and there is some red-blue separation\n    brown_mask = (R > G) & (G > B) & ((R - B) > (0.08 * maxval))\n    return float(np.count_nonzero(brown_mask) / (brown_mask.size + eps))\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Colorfulness metric (Hasler-Suesstrunk): combined rg and yb variability'\n    import numpy as np\n    eps = 1e-8\n    if image is None or image.size == 0:\n        return 0.0\n    if len(image.shape) == 2:\n        rgb = np.stack([image, image, image], axis=2).astype(float)\n    else:\n        rgb = image.astype(float)\n    R = rgb[:, :, 0].astype(float)\n    G = rgb[:, :, 1].astype(float)\n    B = rgb[:, :, 2].astype(float)\n    rg = R - G\n    yb = 0.5 * (R + G) - B\n    std_rg = float(np.std(rg))\n    std_yb = float(np.std(yb))\n    mean_rg = float(np.mean(rg))\n    mean_yb = float(np.mean(yb))\n    colorfulness = np.sqrt(std_rg ** 2 + std_yb ** 2) + 0.3 * np.sqrt(mean_rg ** 2 + mean_yb ** 2)\n    # normalize by dynamic range to keep scale stable\n    maxpix = float(np.max(rgb)) if np.max(rgb) > 0 else 1.0\n    return float(colorfulness / (maxpix + eps))\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Mean local patch variance (8x8 blocks) normalized by global variance (texture measure)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or image.size == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    bs = 8\n    block_vars = []\n    for r in range(0, h, bs):\n        for c in range(0, w, bs):\n            block = gray[r:min(h, r + bs), c:min(w, c + bs)]\n            if block.size == 0:\n                continue\n            block_vars.append(np.var(block))\n    if len(block_vars) == 0:\n        return 0.0\n    mean_block_var = float(np.mean(block_vars))\n    global_var = float(np.var(gray))\n    return float(mean_block_var / (global_var + eps))\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Left-right vertical symmetry score of the grayscale image (1.0 = perfectly symmetric)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or image.size == 0:\n        return 0.5\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    w2 = max(1, w // 2)\n    left = gray[:, :w2]\n    right = gray[:, -w2:]\n    # flip right horizontally to compare\n    right_flipped = right[:, ::-1]\n    if left.size == 0 or right_flipped.size == 0:\n        return 0.5\n    mean_intensity = float(np.mean(gray)) + eps\n    diff = float(np.mean(np.abs(left - right_flipped)))\n    sym = 1.0 - (diff / mean_intensity)\n    sym = max(0.0, min(1.0, sym))\n    return float(sym)\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Fraction of strong edge pixels located in the lower half of the image'\n    import numpy as np\n    eps = 1e-8\n    if image is None or image.size == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    h = gray.shape[0]\n    gy, gx = np.gradient(gray)\n    mag = np.sqrt(gx * gx + gy * gy)\n    if mag.size == 0:\n        return 0.0\n    thr = np.percentile(mag, 75) if mag.size else 0.0\n    strong = mag > (thr + eps)\n    lower = strong[h // 2 :, :]\n    return float(np.count_nonzero(lower) / (strong.size + eps))\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Normalized difference of blue-minus-green between top and bottom quarters (sky vs water/ground)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or image.size == 0:\n        return 0.0\n    if len(image.shape) == 2:\n        rgb = np.stack([image, image, image], axis=2).astype(float)\n    else:\n        rgb = image.astype(float)\n    h = rgb.shape[0]\n    t = max(1, h // 4)\n    top = rgb[:t, :, :]\n    bottom = rgb[-t:, :, :]\n    if top.size == 0 or bottom.size == 0:\n        return 0.0\n    meanB_top = float(np.mean(top[:, :, 2]))\n    meanG_top = float(np.mean(top[:, :, 1]))\n    meanB_bot = float(np.mean(bottom[:, :, 2]))\n    meanG_bot = float(np.mean(bottom[:, :, 1]))\n    diff = (meanB_top - meanG_top) - (meanB_bot - meanG_bot)\n    norm = float(np.mean(rgb) + eps)\n    return float(diff / norm)\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Row-to-row similarity score (1 = rows very similar, indicating horizontal layering like calm water)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or image.size == 0:\n        return 0.5\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    h = gray.shape[0]\n    if h < 2:\n        return 0.5\n    diffs = np.abs(gray[1:, :] - gray[:-1, :])\n    mean_abs_diff = float(np.mean(diffs))\n    mean_intensity = float(np.mean(gray)) + eps\n    sim = 1.0 - (mean_abs_diff / mean_intensity)\n    sim = max(0.0, min(1.0, sim))\n    return float(sim)\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Fraction of pixels that are local maxima and above the 99th percentile (specular highlights)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or image.size == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    if gray.size == 0:\n        return 0.0\n    thr = np.percentile(gray, 99) if gray.size else np.max(gray)\n    # compute max of 8 neighbors\n    pad = np.pad(gray, ((1, 1), (1, 1)), mode='edge')\n    neighbors_max = np.maximum.reduce([\n        pad[0:-2, 0:-2], pad[0:-2, 1:-1], pad[0:-2, 2:],\n        pad[1:-1, 0:-2],                 pad[1:-1, 2:],\n        pad[2:, 0:-2],   pad[2:, 1:-1],   pad[2:, 2:]\n    ])\n    local_max = gray > neighbors_max\n    bright_peak = (gray > (thr + eps)) & local_max\n    return float(np.count_nonzero(bright_peak) / (bright_peak.size + eps))\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Mean saturation of green-dominant pixels (HSV-like saturation normalized to 0..1)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or image.size == 0:\n        return 0.0\n    if len(image.shape) == 2:\n        rgb = np.stack([image, image, image], axis=2).astype(float)\n    else:\n        rgb = image.astype(float)\n    R = rgb[:, :, 0].astype(float)\n    G = rgb[:, :, 1].astype(float)\n    B = rgb[:, :, 2].astype(float)\n    mx = np.maximum(np.maximum(R, G), B)\n    mn = np.minimum(np.minimum(R, G), B)\n    sat = (mx - mn) / (mx + eps)  # 0..1-like (depends on scale)\n    green_dom = (G > R) & (G > B)\n    if np.count_nonzero(green_dom) == 0:\n        return 0.0\n    mean_sat_green = float(np.mean(sat[green_dom]))\n    # clip into [0,1]\n    mean_sat_green = max(0.0, min(1.0, mean_sat_green))\n    return float(mean_sat_green)\n",
  "def feature(image: np.ndarray) -> float:\n    'Fraction of pixels in the top third that are bright blue (sky indicator)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or image.size == 0:\n        return 0.0\n    # ensure RGB\n    if len(image.shape) == 2:\n        rgb = np.stack([image, image, image], axis=2).astype(float)\n    else:\n        rgb = image.astype(float)\n    h, w = rgb.shape[:2]\n    top_h = max(1, h // 3)\n    top = rgb[:top_h, :, :]\n    if top.size == 0:\n        return 0.0\n    R = top[:, :, 0]; G = top[:, :, 1]; B = top[:, :, 2]\n    img_range = float(np.max(rgb) - np.min(rgb) + eps)\n    # blue-dominant and reasonably bright\n    thr = 0.06 * img_range\n    bright_thr = 0.35 * (np.max(rgb) + eps)\n    mask = (B - np.maximum(R, G) > thr) & (np.mean(top, axis=2) > bright_thr)\n    return float(np.count_nonzero(mask) / (mask.size + eps))\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Fraction of pixels in the bottom half that are green-dominant (vegetation/land indicator)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or image.size == 0:\n        return 0.0\n    if len(image.shape) == 2:\n        rgb = np.stack([image, image, image], axis=2).astype(float)\n    else:\n        rgb = image.astype(float)\n    h, w = rgb.shape[:2]\n    start = h // 2\n    bottom = rgb[start:, :, :] if start < h else rgb\n    if bottom.size == 0:\n        return 0.0\n    R = bottom[:, :, 0]; G = bottom[:, :, 1]; B = bottom[:, :, 2]\n    img_range = float(np.max(rgb) - np.min(rgb) + eps)\n    thr = 0.05 * img_range\n    mask = (G - np.maximum(R, B)) > thr\n    return float(np.count_nonzero(mask) / (mask.size + eps))\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Normalized length of the longest low-variance horizontal band that is blue-ish (water/horizon band)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or image.size == 0:\n        return 0.0\n    if len(image.shape) == 2:\n        rgb = np.stack([image, image, image], axis=2).astype(float)\n    else:\n        rgb = image.astype(float)\n    h, w = rgb.shape[:2]\n    # per-row grayscale variance and color means\n    gray_rows = np.mean(rgb, axis=2)\n    row_var = np.var(gray_rows, axis=1)\n    row_mean = np.mean(rgb, axis=(1,2))\n    # per-row channel means\n    row_mean_R = np.mean(rgb[:, :, 0], axis=1)\n    row_mean_G = np.mean(rgb[:, :, 1], axis=1)\n    row_mean_B = np.mean(rgb[:, :, 2], axis=1)\n    max_var = np.max(row_var) if row_var.size else 0.0\n    thr_var = 0.5 * (max_var + eps)\n    blueish = (row_mean_B > row_mean_R) & (row_mean_B > row_mean_G)\n    low_var = row_var < thr_var\n    mask = low_var & blueish\n    # longest consecutive run of True in mask\n    longest = 0\n    cur = 0\n    for v in mask:\n        if v:\n            cur += 1\n            if cur > longest:\n                longest = cur\n        else:\n            cur = 0\n    return float(longest / (h + eps))\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Ratio of blue-channel standard deviation to green-channel standard deviation (blue/green texture ratio)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or image.size == 0:\n        return 0.0\n    if len(image.shape) == 2:\n        rgb = np.stack([image, image, image], axis=2).astype(float)\n    else:\n        rgb = image.astype(float)\n    B = rgb[:, :, 2].flatten()\n    G = rgb[:, :, 1].flatten()\n    stdB = float(np.std(B))\n    stdG = float(np.std(G))\n    return float(stdB / (stdG + eps))\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Normalized global contrast (90th - 10th percentile intensity divided by max)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or image.size == 0:\n        return 0.0\n    gray = None\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    p90 = float(np.percentile(gray, 90))\n    p10 = float(np.percentile(gray, 10))\n    maxv = float(np.max(gray) + eps)\n    return float((p90 - p10) / maxv)\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Entropy of edge orientation distribution (weighted by gradient magnitude)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or image.size == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    gy, gx = np.gradient(gray)\n    mag = np.sqrt(gx * gx + gy * gy)\n    ang = np.arctan2(gy, gx)  # -pi..pi\n    # bin into 16 orientation bins\n    bins = 16\n    hist = np.zeros(bins, dtype=float)\n    if mag.size == 0:\n        return 0.0\n    # map angle to bin index\n    bin_idx = np.floor(((ang + np.pi) / (2 * np.pi)) * bins).astype(int)\n    bin_idx = np.clip(bin_idx, 0, bins - 1)\n    flat_idx = bin_idx.flatten()\n    flat_mag = mag.flatten()\n    for i in range(bins):\n        hist[i] = float(np.sum(flat_mag[flat_idx == i]))\n    total = np.sum(hist) + eps\n    p = hist / total\n    # entropy\n    H = -float(np.sum(np.where(p > 0, p * np.log(p + eps), 0.0)))\n    # normalize by log(bins)\n    H_norm = H / (np.log(bins) + eps)\n    return float(H_norm)\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Fraction of warm (red-dominant) pixels in the center region (bird color cue)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or image.size == 0:\n        return 0.0\n    if len(image.shape) == 2:\n        rgb = np.stack([image, image, image], axis=2).astype(float)\n    else:\n        rgb = image.astype(float)\n    h, w = rgb.shape[:2]\n    sr, sc = h // 4, w // 4\n    er, ec = h - sr, w - sc\n    region = rgb[sr:er, sc:ec, :] if (er > sr and ec > sc) else rgb\n    if region.size == 0:\n        return 0.0\n    R = region[:, :, 0].flatten()\n    G = region[:, :, 1].flatten()\n    B = region[:, :, 2].flatten()\n    mean_int = np.mean((R + G + B) / 3.0) + eps\n    # warm if red exceeds others by fraction of mean intensity\n    thr = 0.15 * mean_int\n    mask = (R - np.maximum(G, B)) > thr\n    return float(np.count_nonzero(mask) / (mask.size + eps))\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Left-right symmetry score (1.0 = perfectly symmetric)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or image.size == 0:\n        return 0.0\n    # use grayscale for symmetry\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    mid = w // 2\n    left = gray[:, :mid]\n    right = gray[:, (w - mid):]  # same width as left\n    if left.size == 0 or right.size == 0:\n        return 0.0\n    # flip right horizontally\n    right_flipped = np.fliplr(right)\n    # compute mean absolute difference normalized by mean intensity\n    diff = np.abs(left - right_flipped)\n    mean_diff = float(np.mean(diff))\n    mean_int = float(np.mean(gray) + eps)\n    # convert to similarity\n    sim = 1.0 - (mean_diff / (mean_int + eps))\n    return float(max(0.0, min(1.0, sim)))\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Fraction of 8x8 blocks with high local texture (high std) indicating small objects/textures'\n    import numpy as np\n    eps = 1e-8\n    if image is None or image.size == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    bs = 8\n    bh = (h // bs) * bs\n    bw = (w // bs) * bs\n    if bh == 0 or bw == 0:\n        # fallback to global std check\n        return float(1.0 if np.std(gray) > 0.1 * (np.max(gray) + eps) else 0.0)\n    trimmed = gray[:bh, :bw]\n    nh = bh // bs; nw = bw // bs\n    blocks = trimmed.reshape(nh, bs, nw, bs).swapaxes(1,2)\n    # blocks shape: (nh, nw, bs, bs)\n    block_stds = np.std(blocks, axis=(2,3)).reshape(-1)\n    global_std = float(np.std(gray) + eps)\n    # count blocks with std > 0.6 * global_std\n    thr = 0.6 * global_std\n    high_tex = np.count_nonzero(block_stds > thr)\n    return float(high_tex / (block_stds.size + eps))\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Mean color distance of center region to border median color (object-background separation)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or image.size == 0:\n        return 0.0\n    if len(image.shape) == 2:\n        rgb = np.stack([image, image, image], axis=2).astype(float)\n    else:\n        rgb = image.astype(float)\n    h, w = rgb.shape[:2]\n    t = max(1, min(h, w) // 12)\n    top = rgb[:t, :, :].reshape(-1, 3)\n    bottom = rgb[-t:, :, :].reshape(-1, 3)\n    left = rgb[:, :t, :].reshape(-1, 3)\n    right = rgb[:, -t:, :].reshape(-1, 3)\n    border = np.concatenate([top, bottom, left, right], axis=0) if rgb.size else np.zeros((1,3))\n    if border.size == 0:\n        return 0.0\n    border_med = np.median(border, axis=0).astype(float)\n    sr, sc = h // 4, w // 4\n    er, ec = h - sr, w - sc\n    center = rgb[sr:er, sc:ec, :].reshape(-1, 3) if (er > sr and ec > sc) else rgb.reshape(-1, 3)\n    if center.size == 0:\n        return 0.0\n    diffs = center - border_med\n    dists = np.sqrt(np.sum(diffs * diffs, axis=1))\n    # normalize by average border brightness to keep scale stable\n    norm = float(np.mean(np.linalg.norm(border.astype(float), axis=1)) + eps)\n    return float(np.mean(dists) / (norm + eps))\n",
  "def feature(image: np.ndarray) -> float:\n    'Ratio of mean blue in the lower half to mean blue in the upper half (water vs sky distribution)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or image.size == 0:\n        return 0.0\n    if len(image.shape) == 2:\n        rgb = np.stack([image, image, image], axis=2).astype(float)\n    else:\n        rgb = image.astype(float)\n    h, w = rgb.shape[:2]\n    mid = h // 2\n    top = rgb[:mid, :, :]\n    bottom = rgb[mid:, :, :]\n    if top.size == 0 or bottom.size == 0:\n        return 0.0\n    meanB_top = float(np.mean(top[:, :, 2]))\n    meanB_bottom = float(np.mean(bottom[:, :, 2]))\n    return float(meanB_bottom / (meanB_top + eps))\n\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Fraction of dark green pixels (vegetation shadows / dense foliage indicator)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or image.size == 0:\n        return 0.0\n    if len(image.shape) == 2:\n        rgb = np.stack([image, image, image], axis=2).astype(float)\n    else:\n        rgb = image.astype(float)\n    R = rgb[:, :, 0]\n    G = rgb[:, :, 1]\n    B = rgb[:, :, 2]\n    mx = np.maximum(np.maximum(R, G), B)\n    mn = np.minimum(np.minimum(R, G), B)\n    chroma = mx - mn\n    gray = np.mean(rgb, axis=2)\n    dyn = float(np.max(gray) - np.min(gray) + eps)\n    # dark threshold relative to dynamic range, green-dominant and reasonably chromatic\n    dark_thr = np.min([np.percentile(gray, 40), np.max(gray) * 0.5])\n    mask = (G > R) & (G > B) & (gray < dark_thr) & (chroma > 0.03 * dyn)\n    return float(np.count_nonzero(mask) / (mask.size + eps))\n\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Low-frequency energy ratio: variance of block means / global variance (scene smoothness scale)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or image.size == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    bs = max(8, min(h, w) // 16 or 8)\n    block_means = []\n    for r in range(0, h, bs):\n        for c in range(0, w, bs):\n            blk = gray[r:min(h, r + bs), c:min(w, c + bs)]\n            if blk.size:\n                block_means.append(np.mean(blk))\n    if len(block_means) == 0:\n        return 0.0\n    mean_block_var = float(np.var(block_means))\n    global_var = float(np.var(gray))\n    return float(mean_block_var / (global_var + eps))\n\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Brightness bimodality score using between-class variance (Otsu-style) normalized by total variance'\n    import numpy as np\n    eps = 1e-8\n    if image is None or image.size == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float).flatten()\n    else:\n        gray = image.astype(float).flatten()\n    if gray.size == 0:\n        return 0.0\n    # histogram\n    bins = 64\n    hist, edges = np.histogram(gray, bins=bins, density=False)\n    prob = hist.astype(float) / (np.sum(hist) + eps)\n    cum_prob = np.cumsum(prob)\n    cum_mean = np.cumsum(prob * (np.arange(len(prob)) + 1))\n    total_mean = cum_mean[-1]\n    between = (total_mean * cum_prob - cum_mean) ** 2 / (cum_prob * (1.0 - cum_prob) + eps)\n    max_between = float(np.nanmax(between))\n    total_var = float(np.var(gray) + eps)\n    return float(max_between / (total_var + eps))\n\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Mean per-pixel saturation estimate ( (max-min)/max ) averaged across image'\n    import numpy as np\n    eps = 1e-8\n    if image is None or image.size == 0:\n        return 0.0\n    if len(image.shape) == 2:\n        return 0.0\n    rgb = image.astype(float)\n    mx = np.max(rgb, axis=2)\n    mn = np.min(rgb, axis=2)\n    sat = (mx - mn) / (mx + eps)\n    return float(np.mean(sat))\n\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Blue dominance in the bottom-center region relative to green (water patch contrast)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or image.size == 0:\n        return 0.0\n    if len(image.shape) == 2:\n        rgb = np.stack([image, image, image], axis=2).astype(float)\n    else:\n        rgb = image.astype(float)\n    h, w = rgb.shape[:2]\n    bh = max(1, h // 3)\n    cw1 = w // 4\n    cw2 = w - cw1\n    region = rgb[h - bh:, cw1:cw2, :]\n    if region.size == 0:\n        return 0.0\n    meanB = float(np.mean(region[:, :, 2]))\n    meanG = float(np.mean(region[:, :, 1]))\n    return float((meanB - meanG) / (meanB + meanG + eps))\n\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Entropy of gradient orientations (magnitude-weighted) - scene structural complexity'\n    import numpy as np\n    eps = 1e-8\n    if image is None or image.size == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    gy, gx = np.gradient(gray)\n    mag = np.sqrt(gx * gx + gy * gy)\n    if mag.size == 0:\n        return 0.0\n    angles = np.arctan2(gy, gx)  # [-pi, pi]\n    bins = 16\n    hist, _ = np.histogram(angles.flatten(), bins=bins, range=(-np.pi, np.pi), weights=mag.flatten())\n    p = hist / (np.sum(hist) + eps)\n    entropy = -np.sum(np.where(p > 0, p * np.log2(p + eps), 0.0))\n    max_entropy = np.log2(bins + eps)\n    return float(entropy / (max_entropy + eps))\n\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Normalized contrast between top 10% brightest and bottom 10% darkest pixels'\n    import numpy as np\n    eps = 1e-8\n    if image is None or image.size == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float).flatten()\n    else:\n        gray = image.astype(float).flatten()\n    if gray.size == 0:\n        return 0.0\n    p90 = np.percentile(gray, 90)\n    p10 = np.percentile(gray, 10)\n    top_mean = np.mean(gray[gray >= p90]) if np.count_nonzero(gray >= p90) > 0 else p90\n    bot_mean = np.mean(gray[gray <= p10]) if np.count_nonzero(gray <= p10) > 0 else p10\n    contrast = top_mean - bot_mean\n    dyn = float(np.max(gray) - np.min(gray) + eps)\n    return float(contrast / (dyn + eps))\n\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Fraction of brown/orange pixels (R>G>B with moderate chroma and medium brightness)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or image.size == 0:\n        return 0.0\n    if len(image.shape) == 2:\n        return 0.0\n    rgb = image.astype(float)\n    R = rgb[:, :, 0]\n    G = rgb[:, :, 1]\n    B = rgb[:, :, 2]\n    mx = np.maximum(np.maximum(R, G), B)\n    mn = np.minimum(np.minimum(R, G), B)\n    chroma = mx - mn\n    gray = np.mean(rgb, axis=2)\n    dyn = float(np.max(gray) - np.min(gray) + eps)\n    # brown/orange: R is largest, G moderate, B smallest, moderate chroma and medium brightness\n    mask = (R > G) & (G > B) & (chroma > 0.04 * dyn) & (gray > np.percentile(gray, 25)) & (gray < np.percentile(gray, 85))\n    return float(np.count_nonzero(mask) / (mask.size + eps))\n\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Center brightness minus border brightness normalized by overall contrast (subject emphasis)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or image.size == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    sr, sc = h // 4, w // 4\n    er, ec = h - sr, w - sc\n    center = gray[sr:er, sc:ec] if (er > sr and ec > sc) else gray\n    # border as 1/8 strips\n    t = max(1, min(h, w) // 8)\n    top = gray[:t, :]\n    bottom = gray[-t:, :]\n    left = gray[:, :t]\n    right = gray[:, -t:]\n    border_pixels = np.concatenate([top.flatten(), bottom.flatten(), left.flatten(), right.flatten()]) if gray.size else np.array([0.0])\n    if center.size == 0 or border_pixels.size == 0:\n        return 0.0\n    center_mean = float(np.mean(center))\n    border_mean = float(np.mean(border_pixels))\n    dyn = float(np.max(gray) - np.min(gray) + eps)\n    return float((center_mean - border_mean) / (dyn + eps))\n",
  "def feature(image: np.ndarray) -> float:\n    'Fraction of pixels in the top third that are blue-dominant (sky indicator)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or image.size == 0:\n        return 0.0\n    # ensure RGB\n    if len(image.shape) == 2:\n        rgb = np.stack([image, image, image], axis=2).astype(float)\n    else:\n        rgb = image.astype(float)\n    h, w = rgb.shape[:2]\n    t = max(1, h // 3)\n    top = rgb[:t, :, :]\n    if top.size == 0:\n        return 0.0\n    r = top[:, :, 0]\n    g = top[:, :, 1]\n    b = top[:, :, 2]\n    # blue-dominant relative test\n    blue_mask = (b > g * 1.05) & (b > r * 1.05)\n    return float(np.count_nonzero(blue_mask) / (top.shape[0] * top.shape[1] + eps))\n\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Ratio of high-frequency energy to low-frequency energy computed via block means'\n    import numpy as np\n    eps = 1e-8\n    if image is None or image.size == 0:\n        return 0.0\n    # convert to grayscale\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    block = max(1, min(h, w) // 16)\n    bh = (h // block) * block\n    bw = (w // block) * block\n    if bh == 0 or bw == 0:\n        # fallback: use global std vs mean absolute deviation\n        return float((np.mean(np.abs(gray - np.mean(gray))) + eps) / (np.std(gray) + eps))\n    cropped = gray[:bh, :bw].reshape(bh // block, block, bw // block, block)\n    block_means = np.mean(np.mean(cropped, axis=1), axis=2)  # shape (bh//block, bw//block)\n    # upsample block means to image region\n    up = np.repeat(np.repeat(block_means, block, axis=0), block, axis=1)\n    hf = np.mean(np.abs(gray[:bh, :bw] - up))\n    lf = np.std(block_means.flatten())\n    return float(hf / (lf + eps))\n\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Left-right symmetry score (1.0 means very symmetric)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or image.size == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    if w < 2:\n        return 1.0\n    left = gray[:, :w // 2]\n    right = gray[:, (w - w // 2):]\n    # flip right for comparison\n    right_flipped = np.fliplr(right)\n    # if sizes mismatch (odd width), crop to min width\n    mw = min(left.shape[1], right_flipped.shape[1])\n    left_c = left[:, :mw]\n    right_c = right_flipped[:, :mw]\n    mean_intensity = np.mean(gray) + eps\n    diff = np.mean(np.abs(left_c - right_c))\n    score = 1.0 - (diff / mean_intensity)\n    return float(score)\n\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Fraction of pixels classified as strong edges (gradient magnitude above median)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or image.size == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    gy, gx = np.gradient(gray)\n    mag = np.sqrt(gx * gx + gy * gy)\n    if mag.size == 0:\n        return 0.0\n    thr = np.median(mag)\n    strong = mag > (thr + eps)\n    return float(np.count_nonzero(strong) / (mag.size + eps))\n\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Ratio of texture (intensity std) inside green regions vs outside (vegetation texture contrast)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or image.size == 0:\n        return 0.0\n    if len(image.shape) == 2:\n        rgb = np.stack([image, image, image], axis=2).astype(float)\n    else:\n        rgb = image.astype(float)\n    r = rgb[:, :, 0]\n    g = rgb[:, :, 1]\n    b = rgb[:, :, 2]\n    green_mask = (g > r * 1.05) & (g > b * 1.05)\n    gray = np.mean(rgb, axis=2)\n    if np.count_nonzero(green_mask) == 0:\n        return 0.0\n    std_green = np.std(gray[green_mask])\n    non_green_mask = ~green_mask\n    if np.count_nonzero(non_green_mask) == 0:\n        return float(std_green / (eps + 1.0))\n    std_non_green = np.std(gray[non_green_mask])\n    return float(std_green / (std_non_green + eps))\n\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Fraction of all blue-dominant pixels that lie in the bottom quarter of the image (water occupancy)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or image.size == 0:\n        return 0.0\n    if len(image.shape) == 2:\n        rgb = np.stack([image, image, image], axis=2).astype(float)\n    else:\n        rgb = image.astype(float)\n    h, w = rgb.shape[:2]\n    r = rgb[:, :, 0]\n    g = rgb[:, :, 1]\n    b = rgb[:, :, 2]\n    blue_mask = (b > g * 1.05) & (b > r * 1.05)\n    total_blue = np.count_nonzero(blue_mask)\n    if total_blue == 0:\n        return 0.0\n    bottom_start = max(0, h - max(1, h // 4))\n    bottom_blue = np.count_nonzero(blue_mask[bottom_start:, :])\n    return float(bottom_blue / (total_blue + eps))\n\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Difference in mean per-pixel chroma between top 20% and bottom 20% of the image'\n    import numpy as np\n    eps = 1e-8\n    if image is None or image.size == 0:\n        return 0.0\n    if len(image.shape) == 2:\n        rgb = np.stack([image, image, image], axis=2).astype(float)\n    else:\n        rgb = image.astype(float)\n    h, w = rgb.shape[:2]\n    t = max(1, h // 5)\n    top = rgb[:t, :, :]\n    bottom = rgb[-t:, :, :]\n    if top.size == 0 or bottom.size == 0:\n        return 0.0\n    def mean_chroma(arr):\n        mx = np.max(arr, axis=2)\n        mn = np.min(arr, axis=2)\n        return np.mean(mx - mn)\n    top_chroma = mean_chroma(top)\n    bottom_chroma = mean_chroma(bottom)\n    return float((top_chroma - bottom_chroma) / (abs(top_chroma) + abs(bottom_chroma) + eps))\n\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Image colorfulness metric (Hasler & S\u00fcsstrunk style)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or image.size == 0:\n        return 0.0\n    if len(image.shape) == 2:\n        r = g = b = image.astype(float)\n    else:\n        r = image[:, :, 0].astype(float)\n        g = image[:, :, 1].astype(float)\n        b = image[:, :, 2].astype(float)\n    rg = r - g\n    yb = 0.5 * (r + g) - b\n    std_rg = np.std(rg)\n    std_yb = np.std(yb)\n    mean_rg = np.mean(rg)\n    mean_yb = np.mean(yb)\n    colorfulness = np.sqrt(std_rg ** 2 + std_yb ** 2) + 0.3 * np.sqrt(mean_rg ** 2 + mean_yb ** 2)\n    return float(colorfulness)\n\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Sharpness proxy: normalized standard deviation of gradient magnitude (higher -> sharper)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or image.size == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    gy, gx = np.gradient(gray)\n    mag = np.sqrt(gx * gx + gy * gy)\n    if mag.size == 0:\n        return 0.0\n    return float(np.std(mag) / (np.mean(mag) + eps))\n\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Fraction of strong vertical edges concentrated in the central vertical strip'\n    import numpy as np\n    eps = 1e-8\n    if image is None or image.size == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    gy, gx = np.gradient(gray)\n    mag = np.sqrt(gx * gx + gy * gy)\n    if mag.size == 0:\n        return 0.0\n    thr = np.median(mag)\n    vertical_mask = (np.abs(gx) > 1.5 * np.abs(gy)) & (mag > (thr + eps))\n    total_vertical = np.count_nonzero(vertical_mask)\n    if total_vertical == 0:\n        return 0.0\n    left = w // 4\n    right = w - left\n    center_mask = np.zeros_like(vertical_mask)\n    center_mask[:, left:right] = True\n    center_vertical = np.count_nonzero(vertical_mask & center_mask)\n    return float(center_vertical / (total_vertical + eps))\n",
  "def feature(image: np.ndarray) -> float:\n    'Fraction of pixels where blue is the dominant saturated channel (blue coverage)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or image.size == 0:\n        return 0.0\n    if len(image.shape) == 2:\n        rgb = np.stack([image, image, image], axis=2).astype(float)\n    else:\n        rgb = image.astype(float)\n    r = rgb[:, :, 0]\n    g = rgb[:, :, 1]\n    b = rgb[:, :, 2]\n    mx = np.maximum(np.maximum(r, g), b) + eps\n    mn = np.minimum(np.minimum(r, g), b)\n    chroma = mx - mn\n    blue_dominant = (b == mx) & (chroma / mx > 0.10)\n    return float(np.count_nonzero(blue_dominant) / (blue_dominant.size + eps))\n\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Mean vertical position (0..1) of blue-dominant pixels (1 => bottom-heavy blue)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or image.size == 0:\n        return 0.5\n    h, w = image.shape[:2]\n    if len(image.shape) == 2:\n        rgb = np.stack([image, image, image], axis=2).astype(float)\n    else:\n        rgb = image.astype(float)\n    r = rgb[:, :, 0]\n    g = rgb[:, :, 1]\n    b = rgb[:, :, 2]\n    mx = np.maximum(np.maximum(r, g), b) + eps\n    mn = np.minimum(np.minimum(r, g), b)\n    chroma = mx - mn\n    mask = (b == mx) & (chroma / mx > 0.10)\n    if np.count_nonzero(mask) == 0:\n        return 0.5\n    rows = np.arange(h).reshape(h, 1)\n    mean_row = float(np.sum(rows * mask) / (np.count_nonzero(mask) + eps))\n    return float(mean_row / (max(1, h - 1) + eps))\n\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Average block-wise standard deviation normalized by global std (lower => smoother)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or image.size == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    block = max(1, min(h, w) // 16)\n    bh = (h // block) * block\n    bw = (w // block) * block\n    global_std = float(np.std(gray) + eps)\n    if bh == 0 or bw == 0:\n        # fallback: mean local std via small sliding windows\n        k = max(1, min(h, w) // 8)\n        if k == 0:\n            return 0.0\n        windows = []\n        for i in range(0, h, k):\n            for j in range(0, w, k):\n                patch = gray[i:i + k, j:j + k]\n                if patch.size:\n                    windows.append(np.std(patch))\n        if len(windows) == 0:\n            return 0.0\n        mean_block_std = float(np.mean(windows))\n        return float(mean_block_std / global_std)\n    cropped = gray[:bh, :bw].reshape(bh // block, block, bw // block, block)\n    block_stds = np.std(np.std(cropped, axis=3), axis=1).flatten()\n    mean_block_std = float(np.mean(block_stds))\n    return float(mean_block_std / global_std)\n\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Mean approximate saturation across image using (max-min)/max per pixel'\n    import numpy as np\n    eps = 1e-8\n    if image is None or image.size == 0:\n        return 0.0\n    if len(image.shape) == 2:\n        rgb = np.stack([image, image, image], axis=2).astype(float)\n    else:\n        rgb = image.astype(float)\n    r = rgb[:, :, 0]\n    g = rgb[:, :, 1]\n    b = rgb[:, :, 2]\n    mx = np.maximum(np.maximum(r, g), b) + eps\n    mn = np.minimum(np.minimum(r, g), b)\n    sat = (mx - mn) / mx\n    return float(np.mean(sat))\n\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Normalized correlation between top half and vertically flipped bottom half (reflection cue)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or image.size == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    if h < 2:\n        return 0.0\n    mid = h // 2\n    top = gray[:mid, :]\n    bottom = gray[-mid:, :]\n    # make same shape\n    min_r = min(top.shape[0], bottom.shape[0])\n    min_c = min(top.shape[1], bottom.shape[1])\n    if min_r == 0 or min_c == 0:\n        return 0.0\n    top_c = top[:min_r, :min_c].flatten()\n    bottom_c = np.flipud(bottom)[:min_r, :min_c].flatten()\n    top_c = top_c - np.mean(top_c)\n    bottom_c = bottom_c - np.mean(bottom_c)\n    num = float(np.sum(top_c * bottom_c))\n    den = float(np.sqrt(np.sum(top_c ** 2) * np.sum(bottom_c ** 2)) + eps)\n    corr = num / den\n    # map from [-1,1] to [0,1]\n    return float((corr + 1.0) / 2.0)\n\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Fraction of pixels that are green-dominant and reasonably saturated (vegetation coverage)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or image.size == 0:\n        return 0.0\n    if len(image.shape) == 2:\n        rgb = np.stack([image, image, image], axis=2).astype(float)\n    else:\n        rgb = image.astype(float)\n    r = rgb[:, :, 0]\n    g = rgb[:, :, 1]\n    b = rgb[:, :, 2]\n    mx = np.maximum(np.maximum(r, g), b) + eps\n    mn = np.minimum(np.minimum(r, g), b)\n    chroma = mx - mn\n    green_mask = (g == mx) & (chroma / mx > 0.08)\n    return float(np.count_nonzero(green_mask) / (green_mask.size + eps))\n\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Entropy of strong-edge orientation distribution (0..1, low => dominated directions)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or image.size == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    gy, gx = np.gradient(gray)\n    mag = np.sqrt(gx * gx + gy * gy)\n    if mag.size == 0:\n        return 0.0\n    thr = float(np.percentile(mag, 50))\n    mask = mag > (thr + eps)\n    if np.count_nonzero(mask) == 0:\n        return 0.0\n    ang = np.arctan2(gy, gx)  # -pi..pi\n    ang = np.mod(ang, np.pi)  # reduce to [0, pi) to treat opposite directions the same\n    ang_sel = ang[mask]\n    nbins = 16\n    hist, _ = np.histogram(ang_sel, bins=nbins, range=(0.0, np.pi))\n    probs = hist.astype(float) / (np.sum(hist) + eps)\n    probs_nonzero = probs[probs > 0]\n    entropy = -np.sum(probs_nonzero * np.log(probs_nonzero + eps))\n    # normalize by log(nbins)\n    return float(entropy / (np.log(nbins) + eps))\n\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Ratio of mean gradient magnitude in the center region to the global mean (center sharpness)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or image.size == 0:\n        return 0.0\n    h, w = image.shape[:2]\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    gy, gx = np.gradient(gray)\n    mag = np.sqrt(gx * gx + gy * gy)\n    overall_mean = float(np.mean(mag) + eps)\n    sr, sc = h // 4, w // 4\n    er, ec = h - sr, w - sc\n    if er <= sr or ec <= sc:\n        center_mean = float(np.mean(mag))\n    else:\n        center_mean = float(np.mean(mag[sr:er, sc:ec]))\n    return float(center_mean / overall_mean)\n\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Normalized red-minus-blue balance ((R-B)/(R+G+B)) indicating warm vs cool tones'\n    import numpy as np\n    eps = 1e-8\n    if image is None or image.size == 0:\n        return 0.0\n    if len(image.shape) == 2:\n        rgb = np.stack([image, image, image], axis=2).astype(float)\n    else:\n        rgb = image.astype(float)\n    meanR = float(np.mean(rgb[:, :, 0]))\n    meanG = float(np.mean(rgb[:, :, 1]))\n    meanB = float(np.mean(rgb[:, :, 2]))\n    denom = (meanR + meanG + meanB + eps)\n    return float((meanR - meanB) / denom)\n\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Fraction of low-saturation pixels that still have high local gradient (textured desaturated areas)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or image.size == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        rgb = image.astype(float)\n        gray = np.mean(rgb, axis=2).astype(float)\n    else:\n        rgb = np.stack([image, image, image], axis=2).astype(float)\n        gray = image.astype(float)\n    r = rgb[:, :, 0]\n    g = rgb[:, :, 1]\n    b = rgb[:, :, 2]\n    mx = np.maximum(np.maximum(r, g), b) + eps\n    mn = np.minimum(np.minimum(r, g), b)\n    sat = (mx - mn) / mx\n    gy, gx = np.gradient(gray)\n    mag = np.sqrt(gx * gx + gy * gy)\n    if mag.size == 0:\n        return 0.0\n    thr = float(np.percentile(mag, 60))\n    low_sat_mask = sat < 0.12\n    if np.count_nonzero(low_sat_mask) == 0:\n        return 0.0\n    high_edge_in_low_sat = np.count_nonzero((mag > thr) & low_sat_mask)\n    return float(high_edge_in_low_sat / (np.count_nonzero(low_sat_mask) + eps))\n",
  "def feature(image: np.ndarray) -> float:\n    'Fraction of smooth blue-dominant pixels (large sky/water regions indicator)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or image.size == 0:\n        return 0.0\n    if len(image.shape) == 2:\n        rgb = np.stack([image, image, image], axis=2).astype(float)\n    else:\n        rgb = image.astype(float)\n    h, w = rgb.shape[:2]\n    B = rgb[:, :, 2]\n    G = rgb[:, :, 1]\n    R = rgb[:, :, 0]\n    gray = np.mean(rgb, axis=2).astype(float)\n    gy, gx = np.gradient(gray)\n    mag = np.sqrt(gx * gx + gy * gy)\n    mean_mag = float(np.mean(mag))\n    # blue-dominant condition\n    blue_dom = (B > G) & (B > R)\n    # smooth condition: gradient magnitude below half the mean (tunable)\n    smooth = mag <= (0.5 * (mean_mag + eps))\n    mask = blue_dom & smooth\n    return float(np.count_nonzero(mask) / (h * w + eps))\n\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Normalized difference of mean blue between top third and bottom third'\n    import numpy as np\n    eps = 1e-8\n    if image is None or image.size == 0:\n        return 0.0\n    if len(image.shape) == 2:\n        rgb = np.stack([image, image, image], axis=2).astype(float)\n    else:\n        rgb = image.astype(float)\n    h, w = rgb.shape[:2]\n    t = max(1, h // 3)\n    top = rgb[:t, :, 2].astype(float)\n    bottom = rgb[-t:, :, 2].astype(float)\n    mean_top = float(np.mean(top)) if top.size else 0.0\n    mean_bottom = float(np.mean(bottom)) if bottom.size else 0.0\n    overall = float(np.mean(rgb)) + eps\n    return float((mean_top - mean_bottom) / overall)\n\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Center region mean brightness divided by border mean brightness (contrast)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or image.size == 0:\n        return 0.0\n    if len(image.shape) == 2:\n        rgb = np.stack([image, image, image], axis=2).astype(float)\n    else:\n        rgb = image.astype(float)\n    h, w = rgb.shape[:2]\n    sr, sc = h // 4, w // 4\n    er, ec = h - sr, w - sc\n    center = rgb[sr:er, sc:ec, :] if (er > sr and ec > sc) else rgb\n    t = max(1, min(h, w) // 8)\n    top = rgb[:t, :, :]\n    bottom = rgb[-t:, :, :]\n    left = rgb[:, :t, :]\n    right = rgb[:, -t:, :]\n    border_parts = []\n    if top.size: border_parts.append(top.reshape(-1, 3))\n    if bottom.size: border_parts.append(bottom.reshape(-1, 3))\n    if left.size: border_parts.append(left.reshape(-1, 3))\n    if right.size: border_parts.append(right.reshape(-1, 3))\n    if border_parts:\n        border = np.concatenate(border_parts, axis=0)\n    else:\n        border = center.reshape(-1, 3)\n    center_brightness = float(np.mean(np.mean(center, axis=2))) if center.size else 0.0\n    border_brightness = float(np.mean(np.mean(border.reshape(-1,3), axis=1))) if border.size else 0.0\n    return float(center_brightness / (border_brightness + eps))\n\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Row-wise brightness center of mass (0=top, 1=bottom)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or image.size == 0:\n        return 0.0\n    if len(image.shape) == 2:\n        gray = image.astype(float)\n    else:\n        gray = np.mean(image.astype(float), axis=2)\n    h, w = gray.shape[:2]\n    rows = np.arange(h, dtype=float)\n    total_intensity = float(np.sum(gray)) + eps\n    weighted = float(np.sum(rows[:, None] * gray))\n    com = weighted / total_intensity  # between 0 and h-1\n    return float(com / max(1.0, h - 1.0))\n\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Ratio of edge density in bottom half to top half (edges indicate texture/foreground)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or image.size == 0:\n        return 0.0\n    if len(image.shape) == 2:\n        gray = image.astype(float)\n    else:\n        gray = np.mean(image.astype(float), axis=2)\n    h, w = gray.shape[:2]\n    gy, gx = np.gradient(gray)\n    mag = np.sqrt(gx * gx + gy * gy)\n    thr = float(np.mean(mag) + np.std(mag))\n    edge_mask = mag > thr\n    top_mask = np.zeros_like(edge_mask); top_mask[:h//2, :] = True\n    bottom_mask = np.zeros_like(edge_mask); bottom_mask[h//2:, :] = True\n    top_edges = np.count_nonzero(edge_mask & top_mask)\n    bottom_edges = np.count_nonzero(edge_mask & bottom_mask)\n    # return ratio bottom/top\n    return float(bottom_edges / (top_edges + eps))\n\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Fraction of high-chroma green pixels (vegetation patch indicator)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or image.size == 0:\n        return 0.0\n    if len(image.shape) == 2:\n        rgb = np.stack([image, image, image], axis=2).astype(float)\n    else:\n        rgb = image.astype(float)\n    R = rgb[:, :, 0]\n    G = rgb[:, :, 1]\n    B = rgb[:, :, 2]\n    mx = np.maximum(np.maximum(R, G), B)\n    mn = np.minimum(np.minimum(R, G), B)\n    chroma = mx - mn\n    global_range = float(np.max(mx) - np.min(mn) + eps)\n    # green dominant and reasonably chromatic\n    green_mask = (G > R) & (G > B) & (chroma > 0.08 * (global_range + eps))\n    return float(np.count_nonzero(green_mask) / (rgb.shape[0] * rgb.shape[1] + eps))\n\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Standard deviation across rows of (mean blue - mean green) (color stratification)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or image.size == 0:\n        return 0.0\n    if len(image.shape) == 2:\n        rgb = np.stack([image, image, image], axis=2).astype(float)\n    else:\n        rgb = image.astype(float)\n    B_row_mean = np.mean(rgb[:, :, 2], axis=1)\n    G_row_mean = np.mean(rgb[:, :, 1], axis=1)\n    diff = B_row_mean - G_row_mean\n    row_std = float(np.std(diff))\n    overall_intensity = float(np.mean(rgb)) + eps\n    return float(row_std / overall_intensity)\n\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Fraction of warm (red-dominant, saturated) pixels (land/earth indicator)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or image.size == 0:\n        return 0.0\n    if len(image.shape) == 2:\n        rgb = np.stack([image, image, image], axis=2).astype(float)\n    else:\n        rgb = image.astype(float)\n    R = rgb[:, :, 0]\n    G = rgb[:, :, 1]\n    B = rgb[:, :, 2]\n    mx = np.maximum(np.maximum(R, G), B)\n    mn = np.minimum(np.minimum(R, G), B)\n    sat = (mx - mn) / (mx + eps)\n    warm = (R > G) & (R > B) & ((R - np.maximum(G, B)) > 0.05 * (R + eps)) & (sat > 0.25)\n    return float(np.count_nonzero(warm) / (rgb.shape[0] * rgb.shape[1] + eps))\n\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Blue channel skewness proxy: (mean - median) / std (positive = heavy blue tail)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or image.size == 0:\n        return 0.0\n    if len(image.shape) == 2:\n        B = image.astype(float).flatten()\n    else:\n        B = image[:, :, 2].astype(float).flatten()\n    if B.size == 0:\n        return 0.0\n    mean = float(np.mean(B))\n    median = float(np.median(B))\n    std = float(np.std(B)) + eps\n    return float((mean - median) / std)\n\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Center region mean gradient magnitude divided by global mean (center sharpness ratio)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or image.size == 0:\n        return 0.0\n    if len(image.shape) == 2:\n        gray = image.astype(float)\n    else:\n        gray = np.mean(image.astype(float), axis=2)\n    h, w = gray.shape[:2]\n    gy, gx = np.gradient(gray)\n    mag = np.sqrt(gx * gx + gy * gy)\n    sr, sc = h // 4, w // 4\n    er, ec = h - sr, w - sc\n    center_mag = mag[sr:er, sc:ec] if (er > sr and ec > sc) else mag\n    mean_center = float(np.mean(center_mag)) if center_mag.size else 0.0\n    mean_global = float(np.mean(mag)) + eps\n    return float(mean_center / mean_global)\n",
  "def feature(image: np.ndarray) -> float:\n    'Vertical reflection symmetry between top and bottom halves (0..1, higher = more symmetric)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or image.size == 0:\n        return 0.0\n    # grayscale\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    if h < 2:\n        return 0.0\n    half = h // 2\n    top = gray[:half, :]\n    bottom = gray[-half:, :]\n    if top.size == 0 or bottom.size == 0:\n        return 0.0\n    bottom_flip = np.flipud(bottom)\n    t = top.flatten().astype(float)\n    b = bottom_flip.flatten().astype(float)\n    t_mean = np.mean(t)\n    b_mean = np.mean(b)\n    t0 = t - t_mean\n    b0 = b - b_mean\n    num = np.sum(t0 * b0)\n    den = np.sqrt(np.sum(t0 * t0) * np.sum(b0 * b0)) + eps\n    corr = num / den\n    return float(min(1.0, max(0.0, abs(corr))))\n\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Mean gradient magnitude in the center region (texture / smoothness indicator)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or image.size == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    gy, gx = np.gradient(gray)\n    mag = np.sqrt(gx * gx + gy * gy)\n    sr, sc = h // 4, w // 4\n    er, ec = h - sr, w - sc\n    if er <= sr or ec <= sc:\n        region = mag\n    else:\n        region = mag[sr:er, sc:ec]\n    if region.size == 0:\n        return 0.0\n    return float(np.mean(region))\n\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Ratio of mean blue in bottom third to mean blue in top third (water often blue-low)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or image.size == 0:\n        return 0.0\n    if len(image.shape) == 2:\n        rgb = np.stack([image, image, image], axis=2).astype(float)\n    else:\n        rgb = image.astype(float)\n    h = rgb.shape[0]\n    th = max(1, h // 3)\n    top = rgb[:th, :, 2].astype(float)\n    bottom = rgb[-th:, :, 2].astype(float)\n    mean_top = float(np.mean(top)) if top.size else 0.0\n    mean_bottom = float(np.mean(bottom)) if bottom.size else 0.0\n    return float(mean_bottom / (mean_top + eps))\n\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Cosine similarity of mean color to pure blue (1 = very blue, 0 = not)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or image.size == 0:\n        return 0.0\n    if len(image.shape) == 2:\n        mean_vec = np.array([np.mean(image), np.mean(image), np.mean(image)], dtype=float)\n    else:\n        rgb = image.astype(float)\n        mean_vec = np.array([np.mean(rgb[:, :, 0]), np.mean(rgb[:, :, 1]), np.mean(rgb[:, :, 2])], dtype=float)\n    blue = np.array([0.0, 0.0, 1.0], dtype=float)\n    mv_norm = np.linalg.norm(mean_vec) + eps\n    blue_norm = np.linalg.norm(blue) + eps\n    cos = np.dot(mean_vec, blue) / (mv_norm * blue_norm)\n    # clamp to [0,1]\n    return float(min(1.0, max(0.0, cos)))\n\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Low-frequency energy ratio (fraction of image energy captured by coarse block means)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or image.size == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    bs = max(1, min(h, w) // 16)\n    bh = (h // bs) * bs\n    bw = (w // bs) * bs\n    if bh == 0 or bw == 0:\n        total_energy = np.sum((gray - np.mean(gray)) ** 2)\n        return float(min(1.0, total_energy / (total_energy + eps)))\n    cropped = gray[:bh, :bw]\n    # reshape into blocks: (rows_blocks, bs, cols_blocks, bs)\n    rb = bh // bs\n    cb = bw // bs\n    blocks = cropped.reshape(rb, bs, cb, bs)\n    block_means = np.mean(np.mean(blocks, axis=1), axis=2)  # shape (rb, cb)\n    # expand block means to full cropped size\n    low = np.repeat(np.repeat(block_means, bs, axis=0), bs, axis=1)\n    # energy measured as variance around global mean to be scale-invariant\n    global_mean = np.mean(cropped)\n    low_energy = np.sum((low - global_mean) ** 2)\n    total_energy = np.sum((cropped - global_mean) ** 2) + eps\n    return float(low_energy / (total_energy + eps))\n\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Normalized entropy of gradient orientations in the central region (0..1)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or image.size == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    sr, sc = h // 4, w // 4\n    er, ec = h - sr, w - sc\n    region = gray[sr:er, sc:ec] if (er > sr and ec > sc) else gray\n    if region.size == 0:\n        return 0.0\n    gy, gx = np.gradient(region)\n    mag = np.sqrt(gx * gx + gy * gy)\n    if np.sum(mag) < eps:\n        return 0.0\n    ori = np.arctan2(gy, gx).flatten()  # range -pi..pi\n    magw = mag.flatten()\n    bins = 16\n    hist, _ = np.histogram(ori, bins=bins, range=(-np.pi, np.pi), weights=magw)\n    p = hist / (np.sum(hist) + eps)\n    # entropy\n    p_nonzero = p[p > 0]\n    ent = -np.sum(p_nonzero * np.log(p_nonzero + eps))\n    max_ent = np.log(bins)\n    return float(ent / (max_ent + eps))\n\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Fraction of green-dominant pixels in lower half (vegetation indicator)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or image.size == 0:\n        return 0.0\n    if len(image.shape) == 2:\n        rgb = np.stack([image, image, image], axis=2).astype(float)\n    else:\n        rgb = image.astype(float)\n    h = rgb.shape[0]\n    lower = rgb[h // 2 :, :, :]\n    if lower.size == 0:\n        return 0.0\n    R = lower[:, :, 0]\n    G = lower[:, :, 1]\n    B = lower[:, :, 2]\n    green_mask = (G > R) & (G > B) & (G > (np.mean(G) * 0.9 + eps))\n    return float(np.count_nonzero(green_mask) / (green_mask.size + eps))\n\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Longest horizontal run of blue-dominant pixels as fraction of image width'\n    import numpy as np\n    eps = 1e-8\n    if image is None or image.size == 0:\n        return 0.0\n    if len(image.shape) == 2:\n        rgb = np.stack([image, image, image], axis=2).astype(float)\n    else:\n        rgb = image.astype(float)\n    h, w = rgb.shape[:2]\n    R = rgb[:, :, 0]\n    G = rgb[:, :, 1]\n    B = rgb[:, :, 2]\n    # blue-dominant threshold: B noticeably greater than R and G\n    meanB = np.mean(B) if B.size else 0.0\n    blue_mask = (B > R) & (B > G) & (B > (meanB * 0.9 + eps))\n    if blue_mask.size == 0:\n        return 0.0\n    # For each row compute longest run length\n    max_run = 0\n    for row in blue_mask:\n        # find consecutive True lengths\n        if not np.any(row):\n            continue\n        # compute runs via diff trick\n        r = np.concatenate(([0], row.view(np.int8), [0]))\n        diffs = np.diff(r)\n        starts = np.where(diffs == 1)[0]\n        ends = np.where(diffs == -1)[0]\n        if starts.size and ends.size:\n            lengths = ends - starts\n            max_run = max(max_run, int(np.max(lengths)))\n    return float(max_run / (w + eps))\n\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Ratio of blue-channel std to green-channel std (higher = more variable blue)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or image.size == 0:\n        return 0.0\n    if len(image.shape) == 2:\n        B = image.astype(float).flatten()\n        G = image.astype(float).flatten()\n    else:\n        B = image[:, :, 2].astype(float).flatten()\n        G = image[:, :, 1].astype(float).flatten()\n    if B.size == 0 or G.size == 0:\n        return 0.0\n    stdB = float(np.std(B)) + eps\n    stdG = float(np.std(G)) + eps\n    return float(stdB / stdG)\n\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Contrast between center and border brightness ((center-border)/(center+border))'\n    import numpy as np\n    eps = 1e-8\n    if image is None or image.size == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    sr, sc = h // 4, w // 4\n    er, ec = h - sr, w - sc\n    if er <= sr or ec <= sc:\n        center = gray\n    else:\n        center = gray[sr:er, sc:ec]\n    t = max(1, min(h, w) // 8)\n    top = gray[:t, :]\n    bottom = gray[-t:, :]\n    left = gray[:, :t]\n    right = gray[:, -t:]\n    border = np.concatenate([top.flatten(), bottom.flatten(), left.flatten(), right.flatten()]) if gray.size else np.array([0.0])\n    mean_center = float(np.mean(center)) if center.size else 0.0\n    mean_border = float(np.mean(border)) if border.size else 0.0\n    return float((mean_center - mean_border) / (mean_center + mean_border + eps))\n",
  "def feature(image: np.ndarray) -> float:\n    'Normalized top-to-bottom blue bias (positive if bottom is bluer)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or image.size == 0:\n        return 0.0\n    if len(image.shape) == 2:\n        rgb = np.stack([image, image, image], axis=2).astype(float)\n    else:\n        rgb = image.astype(float)\n    h, w = rgb.shape[:2]\n    top = rgb[:h//2, :, 2]\n    bot = rgb[h//2:, :, 2]\n    if top.size == 0 or bot.size == 0:\n        return 0.0\n    mean_top = float(np.mean(top))\n    mean_bot = float(np.mean(bot))\n    mean_all = float(np.mean(rgb[:, :, 2]) + eps)\n    return float((mean_bot - mean_top) / mean_all)\n\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Fraction of pixels that are extreme highlights (>95th percentile luminance)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or image.size == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    flat = gray.flatten()\n    if flat.size == 0:\n        return 0.0\n    thr = float(np.percentile(flat, 95))\n    count = np.count_nonzero(flat > thr + eps)\n    return float(count / (flat.size + eps))\n\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Fraction of strong edges that are vertically oriented (|gx| > |gy|)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or image.size == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    gy, gx = np.gradient(gray)\n    mag = np.sqrt(gx * gx + gy * gy)\n    if mag.size == 0:\n        return 0.0\n    thr = np.percentile(mag, 70) if mag.size else 0.0\n    strong = mag > (thr + eps)\n    if np.count_nonzero(strong) == 0:\n        return 0.0\n    vert_strong = np.count_nonzero((np.abs(gx) > np.abs(gy)) & strong)\n    return float(vert_strong / (np.count_nonzero(strong) + eps))\n\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Mean local 5x5 variance normalized by global variance (low=very smooth)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or image.size == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    if h < 5 or w < 5:\n        return 0.0\n    # integral image for sum and sum of squares\n    S = np.cumsum(np.cumsum(gray, axis=0), axis=1)\n    Sq = np.cumsum(np.cumsum(gray * gray, axis=0), axis=1)\n    # pad with zero at top-left to simplify indexing\n    Spad = np.zeros((h + 1, w + 1), dtype=float)\n    Spad[1:, 1:] = S\n    Sqpad = np.zeros((h + 1, w + 1), dtype=float)\n    Sqpad[1:, 1:] = Sq\n    # compute sums for all 5x5 windows (top-left positions 0..h-5, 0..w-5)\n    i1 = 5\n    j1 = 5\n    sum_map = Spad[i1:, j1:] - Spad[:-i1, j1:] - Spad[i1:, :-j1] + Spad[:-i1, :-j1]\n    sumsq_map = Sqpad[i1:, j1:] - Sqpad[:-i1, j1:] - Sqpad[i1:, :-j1] + Sqpad[:-i1, :-j1]\n    area = 25.0\n    mean_map = sum_map / area\n    mean_sq_map = sumsq_map / area\n    local_var = mean_sq_map - mean_map * mean_map\n    local_var_mean = float(np.mean(local_var))\n    global_var = float(np.var(gray))\n    if global_var <= 0:\n        return 0.0\n    return float(local_var_mean / (global_var + eps))\n\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Fraction of pixels that are blue-dominant (B > R and B > G)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or image.size == 0:\n        return 0.0\n    if len(image.shape) == 2:\n        rgb = np.stack([image, image, image], axis=2).astype(float)\n    else:\n        rgb = image.astype(float)\n    r = rgb[:, :, 0].flatten()\n    g = rgb[:, :, 1].flatten()\n    b = rgb[:, :, 2].flatten()\n    if b.size == 0:\n        return 0.0\n    mask = (b > r) & (b > g)\n    return float(np.count_nonzero(mask) / (b.size + eps))\n\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Image warmth score: normalized (meanR - meanB) / (meanR + meanB)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or image.size == 0:\n        return 0.0\n    if len(image.shape) == 2:\n        rgb = np.stack([image, image, image], axis=2).astype(float)\n    else:\n        rgb = image.astype(float)\n    meanR = float(np.mean(rgb[:, :, 0]))\n    meanB = float(np.mean(rgb[:, :, 2]))\n    denom = (meanR + meanB + eps)\n    return float((meanR - meanB) / denom)\n\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Vertical centroid (0..1) of the top 10% brightest pixels (0=top, 1=bottom)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or image.size == 0:\n        return 0.5\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    h = gray.shape[0]\n    flat = gray.flatten()\n    if flat.size == 0:\n        return 0.5\n    thr = np.percentile(flat, 90)\n    mask = gray > thr + eps\n    if np.count_nonzero(mask) == 0:\n        return 0.5\n    rows = np.arange(h).reshape(-1, 1)\n    row_indices = np.repeat(rows, gray.shape[1], axis=1)\n    centroid = float(np.sum(row_indices[mask]) / (np.count_nonzero(mask) + eps))\n    return float(centroid / max(1, h - 1))\n\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Left-right symmetry score (1 = very symmetric horizontally)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or image.size == 0:\n        return 0.5\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    if w < 2:\n        return 0.5\n    mid = w // 2\n    left = gray[:, :mid]\n    right = gray[:, -mid:] if mid > 0 else gray[:, :mid]\n    # make sizes equal\n    if left.shape[1] != right.shape[1]:\n        if left.shape[1] < right.shape[1]:\n            right = right[:, -left.shape[1]:]\n        else:\n            left = left[:, -right.shape[1]:]\n    if left.size == 0 or right.size == 0:\n        return 0.5\n    right_flipped = np.fliplr(right)\n    diff = np.abs(left - right_flipped)\n    dyn = float(np.max(gray) - np.min(gray) + eps)\n    score = 1.0 - float(np.mean(diff) / dyn)\n    score = max(0.0, min(1.0, score))\n    return float(score)\n\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Mean per-pixel chroma (max-min) normalized by mean intensity (colorfulness)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or image.size == 0:\n        return 0.0\n    if len(image.shape) == 2:\n        rgb = np.stack([image, image, image], axis=2).astype(float)\n    else:\n        rgb = image.astype(float)\n    r = rgb[:, :, 0].flatten()\n    g = rgb[:, :, 1].flatten()\n    b = rgb[:, :, 2].flatten()\n    if r.size == 0:\n        return 0.0\n    mx = np.maximum(np.maximum(r, g), b)\n    mn = np.minimum(np.minimum(r, g), b)\n    chroma = mx - mn\n    mean_chroma = float(np.mean(chroma))\n    mean_intensity = float(np.mean((r + g + b) / 3.0) + eps)\n    return float(mean_chroma / mean_intensity)\n\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Fraction of row-mean energy in the lowest 3 vertical-frequency bands (horizon-like layering)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or image.size == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    h = gray.shape[0]\n    if h < 2:\n        return 0.0\n    row_means = np.mean(gray, axis=1)\n    row_means = row_means - np.mean(row_means)\n    # real FFT length h, take positive frequencies including DC\n    fft = np.fft.rfft(row_means)\n    psd = np.abs(fft) ** 2\n    if psd.size == 0:\n        return 0.0\n    # include DC and first two non-DC bins (if present)\n    k = min(3, psd.size)\n    low_energy = float(np.sum(psd[:k]))\n    total_energy = float(np.sum(psd) + eps)\n    return float(low_energy / total_energy)\n",
  "def feature(image: np.ndarray) -> float:\n    'Fraction of image pixels that are blue-dominant and lie in the top quarter'\n    import numpy as np\n    eps = 1e-8\n    if image is None or image.size == 0:\n        return 0.0\n    if len(image.shape) == 2:\n        rgb = np.stack([image, image, image], axis=2).astype(float)\n    else:\n        rgb = image.astype(float)\n    h = rgb.shape[0]\n    top_h = max(1, h // 4)\n    top = rgb[:top_h, :, :]\n    r = top[:, :, 0]\n    g = top[:, :, 1]\n    b = top[:, :, 2]\n    blue_mask = (b > g * 1.05) & (b > r * 1.05)\n    return float(np.count_nonzero(blue_mask) / (top_h * rgb.shape[1] + eps))\n\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Fraction of pixels with very low gradient magnitude (smooth regions)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or image.size == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    gy, gx = np.gradient(gray)\n    mag = np.sqrt(gx * gx + gy * gy)\n    if mag.size == 0:\n        return 0.0\n    thr = np.percentile(mag, 25)  # low-gradient threshold\n    low_mask = mag <= (thr + eps)\n    return float(np.count_nonzero(low_mask) / (mag.size + eps))\n\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Fraction of pixels that are very bright across all channels (specular / highlights)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or image.size == 0:\n        return 0.0\n    if len(image.shape) == 2:\n        rgb = np.stack([image, image, image], axis=2).astype(float)\n    else:\n        rgb = image.astype(float)\n    r = rgb[:, :, 0].flatten()\n    g = rgb[:, :, 1].flatten()\n    b = rgb[:, :, 2].flatten()\n    mean_all = np.mean((r + g + b) / 3.0)\n    std_all = np.std((r + g + b) / 3.0)\n    thr = mean_all + 1.5 * std_all\n    bright_mask = ((r + g + b) / 3.0) > (thr + eps)\n    return float(np.count_nonzero(bright_mask) / (r.size + eps))\n\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Vertical symmetry score between left and right halves (1.0 = perfectly symmetric)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or image.size == 0:\n        return 0.0\n    arr = image.astype(float) if len(image.shape) == 3 else np.stack([image, image, image], axis=2).astype(float)\n    h, w = arr.shape[:2]\n    half = w // 2\n    left = arr[:, :half, :]\n    right = arr[:, -half:, :]\n    if left.size == 0 or right.size == 0:\n        return 0.0\n    # flip right horizontally to compare to left\n    right_flipped = right[:, ::-1, :]\n    # crop to same shape if odd width\n    minw = min(left.shape[1], right_flipped.shape[1])\n    left_c = left[:, :minw, :].astype(float)\n    right_c = right_flipped[:, :minw, :].astype(float)\n    diff = np.abs(left_c - right_c)\n    denom = (np.max(arr) - np.min(arr) + eps)\n    mean_diff = float(np.mean(diff) / denom)\n    # convert to similarity score in [0,1]\n    score = max(0.0, 1.0 - mean_diff)\n    return float(score)\n\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Average red-minus-blue normalized by image range (positive = warmer colors)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or image.size == 0:\n        return 0.0\n    if len(image.shape) == 2:\n        rgb = np.stack([image, image, image], axis=2).astype(float)\n    else:\n        rgb = image.astype(float)\n    R = rgb[:, :, 0]\n    B = rgb[:, :, 2]\n    diff = np.mean(R - B)\n    img_range = float(np.max(rgb) - np.min(rgb) + eps)\n    return float(diff / img_range)\n\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Normalized row index (0..1) of the row with strongest summed horizontal edge strength'\n    import numpy as np\n    eps = 1e-8\n    if image is None or image.size == 0:\n        return 0.5\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    gy, gx = np.gradient(gray)\n    mag = np.sqrt(gx * gx + gy * gy)\n    # horizontal edge strength component = absolute vertical gradient magnitude\n    horiz_strength = np.abs(gy) * mag\n    if horiz_strength.size == 0:\n        return 0.5\n    row_sums = np.sum(horiz_strength, axis=1)\n    if np.all(row_sums == 0):\n        return 0.5\n    row_idx = int(np.argmax(row_sums))\n    h = gray.shape[0]\n    return float(row_idx / float(max(1, h - 1)))\n\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Ratio of mean blue to mean green inside smooth (low-gradient) regions'\n    import numpy as np\n    eps = 1e-8\n    if image is None or image.size == 0:\n        return 0.0\n    if len(image.shape) == 2:\n        rgb = np.stack([image, image, image], axis=2).astype(float)\n    else:\n        rgb = image.astype(float)\n    h, w = rgb.shape[:2]\n    gray = np.mean(rgb, axis=2)\n    gy, gx = np.gradient(gray)\n    mag = np.sqrt(gx * gx + gy * gy)\n    if mag.size == 0:\n        return 0.0\n    thr = np.median(mag)\n    smooth_mask = mag <= (thr + eps)\n    if np.count_nonzero(smooth_mask) == 0:\n        return 0.0\n    B = rgb[:, :, 2]\n    G = rgb[:, :, 1]\n    meanB = float(np.mean(B[smooth_mask]))\n    meanG = float(np.mean(G[smooth_mask]) + eps)\n    return float(meanB / meanG)\n\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Fraction of pixels with very low chroma (near-gray pixels)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or image.size == 0:\n        return 0.0\n    if len(image.shape) == 2:\n        rgb = np.stack([image, image, image], axis=2).astype(float)\n    else:\n        rgb = image.astype(float)\n    mx = np.max(rgb, axis=2)\n    mn = np.min(rgb, axis=2)\n    chroma = mx - mn\n    thr = np.percentile(chroma, 25)  # treat lower quartile as low chroma\n    low_chroma_mask = chroma <= (thr + eps)\n    return float(np.count_nonzero(low_chroma_mask) / (chroma.size + eps))\n\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Fraction of strong edges that are vertical and located in the upper half of the image'\n    import numpy as np\n    eps = 1e-8\n    if image is None or image.size == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    gy, gx = np.gradient(gray)\n    mag = np.sqrt(gx * gx + gy * gy)\n    if mag.size == 0:\n        return 0.0\n    thr = np.percentile(mag, 75)\n    strong = mag > (thr + eps)\n    if np.count_nonzero(strong) == 0:\n        return 0.0\n    vertical = (np.abs(gx) > 1.5 * np.abs(gy)) & strong\n    upper_half = np.zeros_like(vertical)\n    upper_half[:max(1, h // 2), :] = True\n    count_vertical_upper = np.count_nonzero(vertical & upper_half)\n    total_strong = np.count_nonzero(strong)\n    return float(count_vertical_upper / (total_strong + eps))\n",
  "def feature(image: np.ndarray) -> float:\n    'Fraction of pixels in the top third that are blue-dominant (sky/water indicator)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or image.size == 0:\n        return 0.0\n    if len(image.shape) == 2:\n        rgb = np.stack([image, image, image], axis=2).astype(float)\n    else:\n        rgb = image.astype(float)\n    h, w = rgb.shape[:2]\n    t = max(1, h // 3)\n    top = rgb[:t, :, :]\n    if top.size == 0:\n        return 0.0\n    R = top[:, :, 0]; G = top[:, :, 1]; B = top[:, :, 2]\n    img_range = float(np.max(rgb) - np.min(rgb) + eps)\n    thr = 0.06 * img_range\n    mask = (B - np.maximum(R, G)) > thr\n    return float(np.count_nonzero(mask) / (mask.size + eps))\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Normalized absolute intensity contrast between center region and border'\n    import numpy as np\n    eps = 1e-8\n    if image is None or image.size == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    sr, sc = h // 4, w // 4\n    er, ec = h - sr, w - sc\n    center = gray[sr:er, sc:ec] if (er > sr and ec > sc) else gray\n    t = max(1, min(h, w) // 8)\n    top = gray[:t, :] ; bottom = gray[-t:, :] ; left = gray[:, :t] ; right = gray[:, -t:]\n    border = np.concatenate([top.reshape(-1), bottom.reshape(-1), left.reshape(-1), right.reshape(-1)]) if gray.size else np.array([0.0])\n    if center.size == 0 or border.size == 0:\n        return 0.0\n    center_mean = float(np.mean(center))\n    border_mean = float(np.mean(border))\n    dyn = float(np.max(gray) - np.min(gray) + eps)\n    return float(abs(center_mean - border_mean) / (dyn + eps))\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Colorfulness metric (Hasler-S\u00fcsstrunk) normalized by dynamic range'\n    import numpy as np\n    eps = 1e-8\n    if image is None or image.size == 0:\n        return 0.0\n    if len(image.shape) == 2:\n        rgb = np.stack([image, image, image], axis=2).astype(float)\n    else:\n        rgb = image.astype(float)\n    R = rgb[:, :, 0].flatten()\n    G = rgb[:, :, 1].flatten()\n    B = rgb[:, :, 2].flatten()\n    rg = R - G\n    yb = 0.5 * (R + G) - B\n    std_rg = np.std(rg)\n    std_yb = np.std(yb)\n    mean_rg = np.mean(rg)\n    mean_yb = np.mean(yb)\n    metric = np.sqrt(std_rg * std_rg + std_yb * std_yb) + 0.3 * np.sqrt(mean_rg * mean_rg + mean_yb * mean_yb)\n    img_range = float(np.max(rgb) - np.min(rgb) + eps)\n    return float(metric / (img_range + eps))\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Ratio of center-region gradient energy to total gradient energy (high-frequency center prominence)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or image.size == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    gy, gx = np.gradient(gray)\n    mag = np.sqrt(gx * gx + gy * gy)\n    sr, sc = h // 4, w // 4\n    er, ec = h - sr, w - sc\n    center = mag[sr:er, sc:ec] if (er > sr and ec > sc) else mag\n    total = np.sum(mag) + eps\n    return float(np.sum(center) / total)\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Normalized count of small bright local peaks in the bottom half (specular highlights proxy)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or image.size == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    start = h // 2\n    bottom = gray[start:, :] if start < h else gray\n    if bottom.size == 0:\n        return 0.0\n    meanv = float(np.mean(bottom)); stdv = float(np.std(bottom))\n    thr = meanv + 2.0 * stdv\n    # local maxima wrt 4-neighbors\n    padded = np.pad(bottom, ((1,1),(1,1)), mode='constant', constant_values=np.min(bottom))\n    center = padded[1:-1,1:-1]\n    up = padded[:-2,1:-1]; down = padded[2:,1:-1]; left = padded[1:-1,:-2]; right = padded[1:-1,2:]\n    peaks = (center > up) & (center > down) & (center > left) & (center > right) & (center > thr)\n    count = int(np.count_nonzero(peaks))\n    area = float(bottom.size) + eps\n    return float(count / area)\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Normalized warm vs cool balance: (meanR - meanB) / (meanR + meanB)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or image.size == 0:\n        return 0.0\n    if len(image.shape) == 2:\n        arr = image.astype(float)\n        R = G = B = arr.flatten()\n    else:\n        rgb = image.astype(float)\n        R = rgb[:, :, 0].flatten()\n        G = rgb[:, :, 1].flatten()\n        B = rgb[:, :, 2].flatten()\n    meanR = float(np.mean(R)); meanB = float(np.mean(B))\n    denom = (meanR + meanB + eps)\n    return float((meanR - meanB) / denom)\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Relative vertical-edge energy in the central column region (vertical object/standing shapes)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or image.size == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    gy, gx = np.gradient(gray)\n    total_energy = np.sum(np.abs(gy)) + np.sum(np.abs(gx)) + eps\n    cw = max(1, w // 8)\n    sc = max(0, (w - cw) // 2)\n    ec = sc + cw\n    center_vert_energy = np.sum(np.abs(gy)[:, sc:ec])\n    return float(center_vert_energy / total_energy)\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Mean block-wise chroma variability (patchiness): average std of (max-min) per block'\n    import numpy as np\n    eps = 1e-8\n    if image is None or image.size == 0:\n        return 0.0\n    if len(image.shape) == 2:\n        rgb = np.stack([image, image, image], axis=2).astype(float)\n    else:\n        rgb = image.astype(float)\n    h, w = rgb.shape[:2]\n    bs = max(1, min(h, w) // 16)\n    bh = (h // bs) * bs\n    bw = (w // bs) * bs\n    if bh == 0 or bw == 0:\n        arr = rgb.reshape(-1,3)\n        mx = np.max(arr, axis=1); mn = np.min(arr, axis=1)\n        return float(np.std(mx - mn) / (np.mean(mx - mn) + eps))\n    trimmed = rgb[:bh, :bw, :].reshape(bh//bs, bs, bw//bs, bs, 3).swapaxes(1,2)\n    blocks = trimmed.reshape(-1, bs*bs, 3)\n    chromas = np.max(blocks, axis=1) - np.min(blocks, axis=1)  # per-block chroma (3 values)\n    chroma_std = np.std(chromas, axis=1)  # variability within block across channels\n    result = float(np.mean(chroma_std) / (np.mean(chromas) + eps))\n    return float(result)\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Entropy of green-channel histogram in the bottom half (uniformity of vegetation/water)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or image.size == 0:\n        return 0.0\n    if len(image.shape) == 2:\n        green = image.astype(float)\n    else:\n        green = image.astype(float)[:, :, 1]\n    h, w = green.shape[:2]\n    start = h // 2\n    bottom = green[start:, :] if start < h else green\n    if bottom.size == 0:\n        return 0.0\n    bins = 16\n    hist, _ = np.histogram(bottom.flatten(), bins=bins, range=(np.min(bottom), np.max(bottom)))\n    s = float(np.sum(hist) + eps)\n    p = hist / s\n    entropy = -np.sum(np.where(p > 0, p * np.log2(p + eps), 0.0))\n    max_entropy = np.log2(bins + eps)\n    return float(entropy / (max_entropy + eps))\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Average correlation between adjacent rows in grayscale (horizontal texture/horizon measure)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or image.size == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    if h < 2 or w < 2:\n        return 0.0\n    # compute correlation between row i and i+1 for all rows, robust to constant rows\n    corrs = []\n    for i in range(h - 1):\n        r1 = gray[i, :].astype(float)\n        r2 = gray[i + 1, :].astype(float)\n        m1 = r1.mean(); m2 = r2.mean()\n        s1 = r1.std(); s2 = r2.std()\n        if s1 < eps or s2 < eps:\n            continue\n        num = np.mean((r1 - m1) * (r2 - m2))\n        den = (s1 * s2 + eps)\n        corrs.append(num / den)\n    if len(corrs) == 0:\n        return 0.5\n    mean_corr = float(np.mean(corrs))\n    # map from [-1,1] to [0,1]\n    return float((mean_corr + 1.0) / 2.0)\n",
  "def feature(image: np.ndarray) -> float:\n    'Fraction of top-quarter pixels that are blue-dominant (sky/water top cue)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or image.size == 0:\n        return 0.0\n    if len(image.shape) == 2:\n        rgb = np.stack([image, image, image], axis=2).astype(float)\n    else:\n        rgb = image.astype(float)\n    h, w = rgb.shape[:2]\n    top_h = max(1, h // 4)\n    top = rgb[:top_h, :, :]\n    if top.size == 0:\n        return 0.0\n    R = top[:, :, 0]\n    G = top[:, :, 1]\n    B = top[:, :, 2]\n    intensity = (R + G + B) / 3.0\n    # blue-dominant if blue exceeds others by a margin relative to intensity\n    margin = 0.06 * (np.max(intensity) - np.min(intensity) + eps)\n    mask = (B > G + margin) & (B > R + margin) & (intensity > np.percentile(intensity, 10))\n    return float(np.count_nonzero(mask) / (mask.size + eps))\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Fraction of strong edges in the central horizontal band that are horizontal (|gy|>|gx|)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or image.size == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    sr = h // 3\n    er = h - sr\n    band = gray[sr:er, :] if (er > sr) else gray\n    if band.size == 0:\n        return 0.0\n    gy, gx = np.gradient(band)\n    mag = np.sqrt(gx * gx + gy * gy)\n    thr = np.percentile(mag, 70) if mag.size else 0.0\n    strong = mag > (thr + eps)\n    if np.count_nonzero(strong) == 0:\n        return 0.0\n    horiz = np.count_nonzero((np.abs(gy) > np.abs(gx)) & strong)\n    return float(horiz / (np.count_nonzero(strong) + eps))\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Horizontal smoothness score: high when row-to-row intensity changes are small (horizontal bands)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or image.size == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    h = gray.shape[0]\n    if h < 2 or gray.size == 0:\n        return 0.0\n    row_means = np.mean(gray, axis=1)\n    mad = np.mean(np.abs(np.diff(row_means)))\n    denom = np.mean(np.abs(gray - np.mean(gray))) + eps\n    # higher value when mad is small (i.e., more horizontal smoothness)\n    score = np.exp(-mad / denom)\n    return float(score)\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Warmth proxy: mean red minus average of green/blue normalized by intensity'\n    import numpy as np\n    eps = 1e-8\n    if image is None or image.size == 0:\n        return 0.0\n    if len(image.shape) == 2:\n        rgb = np.stack([image, image, image], axis=2).astype(float)\n    else:\n        rgb = image.astype(float)\n    R = rgb[:, :, 0]\n    G = rgb[:, :, 1]\n    B = rgb[:, :, 2]\n    intensity = (R + G + B) / 3.0 + eps\n    warmth = (R - 0.5 * (G + B)) / intensity\n    if warmth.size == 0:\n        return 0.0\n    return float(np.mean(warmth))\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Texture density: fraction of pixels with gradient magnitude above the 75th percentile'\n    import numpy as np\n    eps = 1e-8\n    if image is None or image.size == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    if gray.size == 0:\n        return 0.0\n    gy, gx = np.gradient(gray)\n    mag = np.sqrt(gx * gx + gy * gy)\n    thr = np.percentile(mag, 75) if mag.size else 0.0\n    mask = mag > (thr + eps)\n    return float(np.count_nonzero(mask) / (mask.size + eps))\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Normalized entropy of center-region intensity histogram (0..1)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or image.size == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    sr, sc = h // 4, w // 4\n    er, ec = h - sr, w - sc\n    region = gray[sr:er, sc:ec] if (er > sr and ec > sc) else gray\n    if region.size == 0:\n        return 0.0\n    flat = region.flatten()\n    bins = 16\n    hist, _ = np.histogram(flat, bins=bins, range=(np.min(flat), np.max(flat)) if flat.size else (0, 1))\n    total = np.sum(hist)\n    if total == 0:\n        return 0.0\n    p = hist.astype(float) / (total + eps)\n    p_nonzero = p[p > 0]\n    ent = -np.sum(p_nonzero * np.log(p_nonzero + eps))\n    # normalize by max entropy = log(bins)\n    norm = ent / (np.log(bins) + eps)\n    return float(norm)\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Standard deviation of per-pixel chroma (max-min) normalized by overall intensity range'\n    import numpy as np\n    eps = 1e-8\n    if image is None or image.size == 0:\n        return 0.0\n    if len(image.shape) == 2:\n        rgb = np.stack([image, image, image], axis=2).astype(float)\n    else:\n        rgb = image.astype(float)\n    mx = np.max(rgb, axis=2)\n    mn = np.min(rgb, axis=2)\n    chroma = mx - mn\n    if chroma.size == 0:\n        return 0.0\n    dyn = float(np.max(mx) - np.min(mx) + eps)\n    return float(np.std(chroma) / dyn)\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Fraction of columns with strong vertical edge energy (indicates tree trunks/vertical structures)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or image.size == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    if gray.size == 0:\n        return 0.0\n    gy, gx = np.gradient(gray)\n    col_energy = np.sum(np.abs(gx), axis=0)  # sum over rows for each column\n    thr = np.percentile(col_energy, 75) if col_energy.size else 0.0\n    cols_strong = np.count_nonzero(col_energy > (thr + eps))\n    return float(cols_strong / (col_energy.size + eps))\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Center-region contrast ratio: (90th-10th percentile) center divided by global (normalized)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or image.size == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    if gray.size == 0:\n        return 0.0\n    h, w = gray.shape[:2]\n    sr, sc = h // 4, w // 4\n    er, ec = h - sr, w - sc\n    center = gray[sr:er, sc:ec] if (er > sr and ec > sc) else gray\n    if center.size == 0:\n        return 0.0\n    c90 = np.percentile(center, 90)\n    c10 = np.percentile(center, 10)\n    g90 = np.percentile(gray, 90)\n    g10 = np.percentile(gray, 10)\n    center_range = c90 - c10\n    global_range = g90 - g10 + eps\n    return float(center_range / global_range)\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Ratio of bottom-half blue-dominant fraction to top-half blue-dominant fraction (water vs sky bias)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or image.size == 0:\n        return 0.0\n    if len(image.shape) == 2:\n        rgb = np.stack([image, image, image], axis=2).astype(float)\n    else:\n        rgb = image.astype(float)\n    h = rgb.shape[0]\n    mid = h // 2\n    top = rgb[:mid, :, :]\n    bottom = rgb[mid:, :, :]\n    def blue_frac(block):\n        if block.size == 0:\n            return 0.0\n        R = block[:, :, 0]\n        G = block[:, :, 1]\n        B = block[:, :, 2]\n        intensity = (R + G + B) / 3.0\n        margin = 0.06 * (np.max(intensity) - np.min(intensity) + eps)\n        mask = (B > G + margin) & (B > R + margin) & (intensity > np.percentile(intensity, 5))\n        return float(np.count_nonzero(mask) / (mask.size + eps))\n    bf_top = blue_frac(top)\n    bf_bot = blue_frac(bottom)\n    return float((bf_bot) / (bf_top + eps))\n",
  "def feature(image: np.ndarray) -> float:\n    'Fraction of bottom-half pixels that are strongly blue-dominant and bright (water indicator)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or image.size == 0:\n        return 0.0\n    h = image.shape[0]\n    bottom = image[h // 2 :, ...]\n    if bottom.size == 0:\n        return 0.0\n    if len(bottom.shape) == 2:\n        rgb = np.stack([bottom, bottom, bottom], axis=2).astype(float)\n    else:\n        rgb = bottom.astype(float)\n    R = rgb[:, :, 0]; G = rgb[:, :, 1]; B = rgb[:, :, 2]\n    intensity = np.mean(rgb, axis=2)\n    bright_thr = np.percentile(intensity, 70)  # moderate brightness threshold\n    blue_dom = (B > G) & (B > R) & (B > 0)\n    bright = intensity >= (bright_thr - eps)\n    mask = blue_dom & bright\n    return float(np.count_nonzero(mask) / (mask.size + eps))\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Vertical reflection symmetry between top and flipped bottom halves (correlation in grayscale)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or image.size == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    h = gray.shape[0]\n    if h < 2:\n        return 0.0\n    half = h // 2\n    top = gray[:half, :]\n    bottom = gray[-half:, :]\n    if top.size == 0 or bottom.size == 0:\n        return 0.0\n    bottom_flipped = bottom[::-1, :]\n    # ensure same shape\n    if top.shape != bottom_flipped.shape:\n        min_r = min(top.shape[0], bottom_flipped.shape[0])\n        min_c = min(top.shape[1], bottom_flipped.shape[1])\n        top = top[:min_r, :min_c]\n        bottom_flipped = bottom_flipped[:min_r, :min_c]\n    a = top.flatten() - np.mean(top)\n    b = bottom_flipped.flatten() - np.mean(bottom_flipped)\n    denom = np.sqrt(np.sum(a * a) * np.sum(b * b)) + eps\n    corr = float(np.sum(a * b) / denom)\n    return float(corr)\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Fraction of pixels in the bottom third with very low gradient magnitude (smooth water surface)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or image.size == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    h = gray.shape[0]\n    start = max(0, h - max(1, h // 3))\n    region = gray[start:, :]\n    if region.size == 0:\n        return 0.0\n    gy, gx = np.gradient(region)\n    mag = np.sqrt(gx * gx + gy * gy)\n    thr = np.percentile(mag, 40)  # low texture threshold\n    mask = mag <= (thr + eps)\n    return float(np.count_nonzero(mask) / (mask.size + eps))\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Fraction of center-region pixels that are green-dominant and have noticeable chroma (vegetation patches)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or image.size == 0:\n        return 0.0\n    if len(image.shape) == 2:\n        rgb = np.stack([image, image, image], axis=2).astype(float)\n    else:\n        rgb = image.astype(float)\n    h, w = rgb.shape[:2]\n    sr, sc = h // 4, w // 4\n    er, ec = h - sr, w - sc\n    region = rgb[sr:er, sc:ec, :] if (er > sr and ec > sc) else rgb\n    if region.size == 0:\n        return 0.0\n    r = region[:, :, 0].flatten()\n    g = region[:, :, 1].flatten()\n    b = region[:, :, 2].flatten()\n    mx = np.maximum(np.maximum(r, g), b)\n    mn = np.minimum(np.minimum(r, g), b)\n    chroma = mx - mn\n    dyn = float(np.max(mx) - np.min(mn) + eps)\n    chroma_thr = 0.08 * dyn\n    green_mask = (g > r) & (g > b) & (chroma >= chroma_thr)\n    return float(np.count_nonzero(green_mask) / (green_mask.size + eps))\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Ratio of blue-channel stddev to green-channel stddev in the central region (color variance balance)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or image.size == 0:\n        return 0.0\n    if len(image.shape) == 2:\n        rgb = np.stack([image, image, image], axis=2).astype(float)\n    else:\n        rgb = image.astype(float)\n    h, w = rgb.shape[:2]\n    sr, sc = h // 4, w // 4\n    er, ec = h - sr, w - sc\n    region = rgb[sr:er, sc:ec, :] if (er > sr and ec > sc) else rgb\n    if region.size == 0:\n        return 0.0\n    B = region[:, :, 2].flatten()\n    G = region[:, :, 1].flatten()\n    stdB = float(np.std(B))\n    stdG = float(np.std(G))\n    return float(stdB / (stdG + eps))\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Maximum row-to-row mean absolute difference (horizontal waterline/horizon edge strength), normalized by mean intensity'\n    import numpy as np\n    eps = 1e-8\n    if image is None or image.size == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    h = gray.shape[0]\n    if h < 2:\n        return 0.0\n    diffs = np.mean(np.abs(gray[1:, :] - gray[:-1, :]), axis=1)\n    if diffs.size == 0:\n        return 0.0\n    max_diff = float(np.max(diffs))\n    mean_int = float(np.mean(gray) + eps)\n    return float(max_diff / mean_int)\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Global color temperature proxy: average (R - B) / (R + B), positive = warmer (land), negative = cooler (water)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or image.size == 0:\n        return 0.0\n    if len(image.shape) == 2:\n        R = G = B = image.astype(float)\n    else:\n        R = image[:, :, 0].astype(float)\n        G = image[:, :, 1].astype(float)\n        B = image[:, :, 2].astype(float)\n    denom = (R + B + eps)\n    temp_map = (R - B) / denom\n    if temp_map.size == 0:\n        return 0.0\n    return float(np.mean(temp_map))\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Average normalized horizontal run length of very bright pixels in bottom half (specular streak length indicator)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or image.size == 0:\n        return 0.0\n    h = image.shape[0]\n    bottom = image[h // 2 :, ...]\n    if bottom.size == 0:\n        return 0.0\n    if len(bottom.shape) == 2:\n        gray = bottom.astype(float)\n    else:\n        gray = np.mean(bottom, axis=2).astype(float)\n    h2, w2 = gray.shape[:2]\n    if h2 == 0 or w2 == 0:\n        return 0.0\n    thr = np.percentile(gray, 95)\n    mask = gray >= (thr - eps)\n    # compute average normalized run length per row\n    run_lengths = []\n    for r in range(mask.shape[0]):\n        row = mask[r, :].astype(np.int8)\n        if np.count_nonzero(row) == 0:\n            continue\n        # find run lengths\n        diff = np.diff(np.concatenate(([0], row, [0])))\n        starts = np.where(diff == 1)[0]\n        ends = np.where(diff == -1)[0]\n        lengths = (ends - starts).astype(float)\n        if lengths.size > 0:\n            run_lengths.append(np.mean(lengths) / (w2 + eps))\n    if len(run_lengths) == 0:\n        return 0.0\n    return float(np.mean(run_lengths))\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Mean blue-excess relative to local intensity: mean(B - 0.5*(R+G)) normalized by mean intensity'\n    import numpy as np\n    eps = 1e-8\n    if image is None or image.size == 0:\n        return 0.0\n    if len(image.shape) == 2:\n        R = G = B = image.astype(float)\n    else:\n        R = image[:, :, 0].astype(float)\n        G = image[:, :, 1].astype(float)\n        B = image[:, :, 2].astype(float)\n    intensity = (R + G + B) / 3.0\n    blue_excess = B - 0.5 * (R + G)\n    mean_int = float(np.mean(intensity) + eps)\n    return float(np.mean(blue_excess) / mean_int)\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Fraction of pixels with strong high-frequency residual after coarse block smoothing (foreground texture fraction)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or image.size == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    # choose block size proportional to image size\n    bs = max(4, min(h, w) // 16)\n    Hc = (h // bs) * bs\n    Wc = (w // bs) * bs\n    if Hc == 0 or Wc == 0:\n        return 0.0\n    cropped = gray[:Hc, :Wc]\n    # compute block means\n    reshaped = cropped.reshape(Hc // bs, bs, Wc // bs, bs)\n    block_means = reshaped.mean(axis=(1, 3))\n    # expand back\n    low = np.repeat(np.repeat(block_means, bs, axis=0), bs, axis=1)\n    high = cropped - low\n    abs_high = np.abs(high)\n    thr = np.percentile(abs_high, 75)\n    mask = abs_high >= (thr - eps)\n    return float(np.count_nonzero(mask) / (mask.size + eps))\n",
  "def feature(image: np.ndarray) -> float:\n    'Fraction of top-region pixels that are blue-dominant (sky indicator)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if len(image.shape) == 2:\n        rgb = np.stack([image, image, image], axis=2).astype(float)\n    else:\n        rgb = image.astype(float)\n    h, w = rgb.shape[:2]\n    top_h = max(1, h // 5)\n    top = rgb[:top_h, :, :]\n    if top.size == 0:\n        return 0.0\n    R = top[:, :, 0]\n    G = top[:, :, 1]\n    B = top[:, :, 2]\n    meanB = np.mean(B) if B.size else 0.0\n    margin = 0.06 * (np.max((R+G+B)/3.0) - np.min((R+G+B)/3.0) + eps)\n    mask = (B > G + margin) & (B > R + margin) & (B > (meanB * 0.75 + eps))\n    return float(np.count_nonzero(mask) / (mask.size + eps))\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Mean approximate saturation in the center region (colorfulness)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if len(image.shape) == 2:\n        rgb = np.stack([image, image, image], axis=2).astype(float)\n    else:\n        rgb = image.astype(float)\n    h, w = rgb.shape[:2]\n    sr, sc = h // 4, w // 4\n    er, ec = h - sr, w - sc\n    region = rgb[sr:er, sc:ec, :] if (er > sr and ec > sc) else rgb\n    if region.size == 0:\n        return 0.0\n    r = region[:, :, 0].astype(float)\n    g = region[:, :, 1].astype(float)\n    b = region[:, :, 2].astype(float)\n    mx = np.maximum(np.maximum(r, g), b)\n    mn = np.minimum(np.minimum(r, g), b)\n    sat = (mx - mn) / (mx + eps)\n    return float(np.mean(sat))\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Entropy of the grayscale intensity distribution (16-bin)'\n    import numpy as np\n    eps = 1e-12\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    arr = gray.flatten()\n    if arr.size == 0:\n        return 0.0\n    lo, hi = np.min(arr), np.max(arr)\n    if hi - lo < eps:\n        return 0.0\n    hist, _ = np.histogram(arr, bins=16, range=(lo, hi))\n    p = hist.astype(float) / (np.sum(hist) + eps)\n    p_nonzero = p[p > 0]\n    ent = -np.sum(p_nonzero * np.log2(p_nonzero + eps))\n    # normalize by max entropy log2(16)=4\n    return float(ent / 4.0)\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Edge density: fraction of pixels with strong gradient magnitude'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    if gray.size == 0:\n        return 0.0\n    gy, gx = np.gradient(gray)\n    mag = np.sqrt(gx * gx + gy * gy)\n    thr = np.percentile(mag, 75) if mag.size else 0.0\n    strong = mag > thr\n    return float(np.count_nonzero(strong) / (strong.size + eps))\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Fraction of image columns with high column-wise variability (vertical structures)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    if w == 0:\n        return 0.0\n    col_std = np.std(gray, axis=0)\n    global_mean = np.mean(col_std) if col_std.size else 0.0\n    global_std = np.std(col_std) if col_std.size else 0.0\n    thr = global_mean + 0.5 * global_std\n    frac = float(np.count_nonzero(col_std > thr) / (w + eps))\n    return frac\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Average color warmth: normalized (R-B)/(R+B) across image'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if len(image.shape) == 2:\n        rgb = np.stack([image, image, image], axis=2).astype(float)\n    else:\n        rgb = image.astype(float)\n    R = rgb[:, :, 0].astype(float)\n    B = rgb[:, :, 2].astype(float)\n    denom = (R + B + eps)\n    warmth = (R - B) / denom\n    return float(np.mean(warmth))\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Normalized brightness contrast between center and border regions'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    sr, sc = h // 4, w // 4\n    er, ec = h - sr, w - sc\n    center = gray[sr:er, sc:ec] if (er > sr and ec > sc) else gray\n    t = max(1, min(h, w) // 8)\n    top = gray[:t, :] if t > 0 else np.array([])\n    bottom = gray[-t:, :] if t > 0 else np.array([])\n    left = gray[:, :t] if t > 0 else np.array([])\n    right = gray[:, -t:] if t > 0 else np.array([])\n    border_parts = []\n    for part in (top, bottom, left, right):\n        if getattr(part, 'size', 0) > 0:\n            border_parts.append(part.flatten())\n    border = np.concatenate(border_parts) if border_parts else np.array([])\n    if center.size == 0 or border.size == 0:\n        return 0.0\n    mc = float(np.mean(center))\n    mb = float(np.mean(border))\n    return float((mc - mb) / (mc + mb + eps))\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Fraction of rows that contain a long blue-dominant stretch (water horizontal bands)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if len(image.shape) == 2:\n        rgb = np.stack([image, image, image], axis=2).astype(float)\n    else:\n        rgb = image.astype(float)\n    h, w = rgb.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    R = rgb[:, :, 0]\n    G = rgb[:, :, 1]\n    B = rgb[:, :, 2]\n    intensity = (R + G + B) / 3.0\n    margin = 0.06 * (np.max(intensity) - np.min(intensity) + eps)\n    blue_mask = (B > G + margin) & (B > R + margin)\n    long_needed = max(1, int(0.3 * w))\n    rows_with_long = 0\n    for row in blue_mask:\n        if not np.any(row):\n            continue\n        r = np.concatenate(([0], row.astype(np.int8), [0]))\n        diffs = np.diff(r)\n        starts = np.where(diffs == 1)[0]\n        ends = np.where(diffs == -1)[0]\n        if starts.size and ends.size:\n            lengths = ends - starts\n            if np.max(lengths) >= long_needed:\n                rows_with_long += 1\n    return float(rows_with_long / (h + eps))\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Difference in green-dominant fraction: lower-half minus upper-half (vegetation on ground)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if len(image.shape) == 2:\n        rgb = np.stack([image, image, image], axis=2).astype(float)\n    else:\n        rgb = image.astype(float)\n    h = rgb.shape[0]\n    mid = max(1, h // 2)\n    upper = rgb[:mid, :, :]\n    lower = rgb[mid:, :, :]\n    def green_frac(block):\n        if block.size == 0:\n            return 0.0\n        R = block[:, :, 0]\n        G = block[:, :, 1]\n        B = block[:, :, 2]\n        mask = (G > R) & (G > B)\n        return float(np.count_nonzero(mask) / (mask.size + eps))\n    gu = green_frac(upper)\n    gl = green_frac(lower)\n    return float(gl - gu)\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Mean patch-level texture (mean local std) normalized by global intensity'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    p = max(4, min(h, w) // 8)\n    ph = (h // p) * p\n    pw = (w // p) * p\n    if ph == 0 or pw == 0:\n        # fallback to whole-image std\n        global_std = np.std(gray)\n        global_mean = np.mean(gray) + eps\n        return float(global_std / global_mean)\n    gray_crop = gray[:ph, :pw]\n    patches = gray_crop.reshape(ph // p, p, pw // p, p).swapaxes(1,2).reshape(-1, p, p)\n    stds = np.array([np.std(patch) for patch in patches]) if patches.size else np.array([0.0])\n    mean_std = float(np.mean(stds))\n    global_mean = float(np.mean(gray) + eps)\n    return float(mean_std / global_mean)\n",
  "def feature(image: np.ndarray) -> float:\n    'Fraction of pixels where blue channel is noticeably dominant (blue-heavy areas)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if len(image.shape) == 2:\n        rgb = np.stack([image, image, image], axis=2).astype(float)\n    else:\n        rgb = image.astype(float)\n    R = rgb[:, :, 0]\n    G = rgb[:, :, 1]\n    B = rgb[:, :, 2]\n    # relative dominance threshold (5% stronger than other channels)\n    mask = (B > 1.05 * G) & (B > 1.05 * R)\n    return float(np.count_nonzero(mask) / (rgb.shape[0] * rgb.shape[1] + eps))\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Fraction of 16x16 blocks whose majority pixels are green-dominant (clustered vegetation)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if len(image.shape) == 2:\n        rgb = np.stack([image, image, image], axis=2).astype(float)\n    else:\n        rgb = image.astype(float)\n    h, w = rgb.shape[:2]\n    bs = 16\n    bh = (h // bs) * bs\n    bw = (w // bs) * bs\n    if bh == 0 or bw == 0:\n        # fallback: whole image check\n        r = rgb[:, :, 0].flatten()\n        g = rgb[:, :, 1].flatten()\n        b = rgb[:, :, 2].flatten()\n        mask = (g > r) & (g > b)\n        return float(np.count_nonzero(mask) / (mask.size + eps))\n    trimmed = rgb[:bh, :bw, :].astype(float)\n    nh = bh // bs; nw = bw // bs\n    blocks = trimmed.reshape(nh, bs, nw, bs, 3)\n    blocks = blocks.swapaxes(1,2)  # shape (nh, nw, bs, bs, 3)\n    # compute fraction of green-dominant pixels per block\n    r = blocks[:, :, :, :, 0]\n    g = blocks[:, :, :, :, 1]\n    b = blocks[:, :, :, :, 2]\n    green_mask = (g > r) & (g > b)\n    frac_green = np.mean(green_mask, axis=(2,3))\n    # count blocks where >40% pixels are green-dominant\n    count = np.count_nonzero(frac_green > 0.4)\n    return float(count / (frac_green.size + eps))\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Normalized variance in the top quarter of the image (smooth sky/water vs textured land)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    h, w = image.shape[:2]\n    top_h = max(1, h // 4)\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    top = gray[:top_h, :]\n    if top.size == 0:\n        return 0.0\n    var_top = float(np.var(top))\n    var_global = float(np.var(gray))\n    if var_global <= 0:\n        return 0.0\n    return float(var_top / (var_global + eps))\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Fraction of very bright specular pixels (potential water reflections/highlights)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if len(image.shape) == 2:\n        rgb = np.stack([image, image, image], axis=2).astype(float)\n    else:\n        rgb = image.astype(float)\n    # use per-image maximum to adapt to different ranges\n    maxv = float(np.max(rgb))\n    if maxv <= 0:\n        return 0.0\n    brightness = np.max(rgb, axis=2)\n    mask = brightness >= (0.98 * maxv)\n    return float(np.count_nonzero(mask) / (rgb.shape[0] * rgb.shape[1] + eps))\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Center-region color temperature proxy: (meanR - meanB) / (meanR + meanB)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if len(image.shape) == 2:\n        rgb = np.stack([image, image, image], axis=2).astype(float)\n    else:\n        rgb = image.astype(float)\n    h, w = rgb.shape[:2]\n    sr, sc = h // 4, w // 4\n    er, ec = h - sr, w - sc\n    if er <= sr or ec <= sc:\n        region = rgb\n    else:\n        region = rgb[sr:er, sc:ec, :]\n    if region.size == 0:\n        return 0.0\n    meanR = float(np.mean(region[:, :, 0]))\n    meanB = float(np.mean(region[:, :, 2]))\n    return float((meanR - meanB) / (meanR + meanB + eps))\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Left-right grayscale correlation (horizontal symmetry of scene)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    h, w = image.shape[:2]\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    mid = w // 2\n    left = gray[:, :mid]\n    right = gray[:, (w - mid):]  # ensure same width as left\n    if left.size == 0 or right.size == 0:\n        return 0.0\n    right_flipped = np.fliplr(right)\n    v1 = left.flatten().astype(float)\n    v2 = right_flipped.flatten().astype(float)\n    # normalize\n    v1m = v1 - np.mean(v1)\n    v2m = v2 - np.mean(v2)\n    s1 = np.std(v1m)\n    s2 = np.std(v2m)\n    if s1 <= 0 or s2 <= 0:\n        return 0.0\n    corr = float(np.dot(v1m, v2m) / (v1m.size * s1 * s2 + eps))\n    # map correlation from [-1,1] to [0,1]\n    return float((corr + 1.0) / 2.0)\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Mean absolute Laplacian (second-derivative) energy normalized by mean intensity (texture measure)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    if h < 3 or w < 3:\n        return 0.0\n    gy, gx = np.gradient(gray)\n    gxx, _ = np.gradient(gx)\n    _, gyy = np.gradient(gy)\n    lap = gxx + gyy\n    mean_abs_lap = float(np.mean(np.abs(lap)))\n    mean_int = float(np.mean(np.abs(gray)) + eps)\n    return float(mean_abs_lap / mean_int)\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Fraction of pixels in the central region with saturation above 0.3 (colorful center presence)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if len(image.shape) == 2:\n        rgb = np.stack([image, image, image], axis=2).astype(float)\n    else:\n        rgb = image.astype(float)\n    h, w = rgb.shape[:2]\n    sr, sc = h // 4, w // 4\n    er, ec = h - sr, w - sc\n    region = rgb[sr:er, sc:ec, :] if (er > sr and ec > sc) else rgb\n    if region.size == 0:\n        return 0.0\n    r = region[:, :, 0]\n    g = region[:, :, 1]\n    b = region[:, :, 2]\n    mx = np.maximum(np.maximum(r, g), b)\n    mn = np.minimum(np.minimum(r, g), b)\n    sat = (mx - mn) / (mx + eps)\n    return float(np.count_nonzero(sat > 0.3) / (sat.size + eps))\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Fraction of strong edges in the central vertical band that are vertical (object edges)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    c1 = w // 3\n    c2 = w - c1\n    band = gray[:, c1:c2]\n    if band.size == 0:\n        return 0.0\n    gy, gx = np.gradient(band)\n    mag = np.sqrt(gx * gx + gy * gy)\n    if mag.size == 0:\n        return 0.0\n    thr = np.percentile(mag, 75) if mag.size else 0.0\n    strong = mag > (thr + eps)\n    if np.count_nonzero(strong) == 0:\n        return 0.0\n    vert_orient = np.where(mag > 0, np.abs(gx) / (mag + eps), 0.0)\n    vert_count = np.count_nonzero((vert_orient > 0.8) & strong)\n    return float(vert_count / (np.count_nonzero(strong) + eps))\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Slope of mean blue intensity per row (normalized) to capture vertical blue gradients (water/sky)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    h, w = image.shape[:2]\n    rows = np.arange(h, dtype=float)\n    if len(image.shape) == 2:\n        blue = image.astype(float)\n    else:\n        blue = image.astype(float)[:, :, 2]\n    mean_per_row = np.mean(blue, axis=1)\n    if h < 2 or np.all(mean_per_row == mean_per_row[0]):\n        return 0.0\n    # linear fit slope\n    A = np.vstack([rows, np.ones_like(rows)]).T\n    try:\n        slope, _ = np.linalg.lstsq(A, mean_per_row, rcond=None)[0]\n    except Exception:\n        return 0.0\n    # normalize slope by intensity range and image height to make scale stable\n    vrange = (np.max(mean_per_row) - np.min(mean_per_row) + eps)\n    norm_slope = slope * (h / (vrange + eps))\n    return float(norm_slope)\n",
  "def feature(image: np.ndarray) -> float:\n    'Fraction of pixels where blue is strongly dominant over red and green'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if len(image.shape) == 2:\n        rgb = np.stack([image, image, image], axis=2).astype(float)\n    else:\n        rgb = image.astype(float)\n    R = rgb[:, :, 0]\n    G = rgb[:, :, 1]\n    B = rgb[:, :, 2]\n    # relative dominance threshold (10% stronger)\n    mask = (B > 1.10 * G) & (B > 1.10 * R)\n    count = np.count_nonzero(mask)\n    total = float(R.size) + eps\n    return float(count / total)\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Ratio of vertical edge energy to total edge energy (vertical vs horizontal emphasis)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    if gray.size == 0:\n        return 0.0\n    gy, gx = np.gradient(gray)\n    v = np.sum(np.abs(gy))\n    h = np.sum(np.abs(gx))\n    return float(v / (v + h + eps))\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Fraction of pixels in the top band that are blue-dominant (sky/water indicator)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if len(image.shape) == 2:\n        rgb = np.stack([image, image, image], axis=2).astype(float)\n    else:\n        rgb = image.astype(float)\n    h, w = rgb.shape[:2]\n    top_h = max(1, h // 6)\n    top = rgb[:top_h, :, :]\n    if top.size == 0:\n        return 0.0\n    R = top[:, :, 0].flatten()\n    G = top[:, :, 1].flatten()\n    B = top[:, :, 2].flatten()\n    mask = (B > R) & (B > G)\n    return float(np.count_nonzero(mask) / (R.size + eps))\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Global fraction of green-dominant pixels (vegetation coverage proxy)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if len(image.shape) == 2:\n        rgb = np.stack([image, image, image], axis=2).astype(float)\n    else:\n        rgb = image.astype(float)\n    R = rgb[:, :, 0].flatten()\n    G = rgb[:, :, 1].flatten()\n    B = rgb[:, :, 2].flatten()\n    mask = (G > R) & (G > B)\n    return float(np.count_nonzero(mask) / (R.size + eps))\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Center-region gradient magnitude stability (inverse of gradient std => smoothness)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    sr, sc = h // 4, w // 4\n    er, ec = h - sr, w - sc\n    region = gray[sr:er, sc:ec] if (er > sr and ec > sc) else gray\n    if region.size == 0:\n        return 0.0\n    gy, gx = np.gradient(region)\n    mag = np.sqrt(gx * gx + gy * gy).flatten()\n    std = float(np.std(mag))\n    # higher value means smoother (lower std)\n    return float(1.0 / (std + eps))\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Ratio of blue-channel standard deviation to green-channel standard deviation'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if len(image.shape) == 2:\n        rgb = np.stack([image, image, image], axis=2).astype(float)\n    else:\n        rgb = image.astype(float)\n    B = rgb[:, :, 2].flatten()\n    G = rgb[:, :, 1].flatten()\n    stdB = float(np.std(B))\n    stdG = float(np.std(G))\n    return float(stdB / (stdG + eps))\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Absolute normalized difference of (blue - green) between top and bottom halves'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if len(image.shape) == 2:\n        rgb = np.stack([image, image, image], axis=2).astype(float)\n    else:\n        rgb = image.astype(float)\n    h = rgb.shape[0]\n    mid = h // 2\n    top = rgb[:mid, :, :]\n    bottom = rgb[mid:, :, :]\n    if top.size == 0 or bottom.size == 0:\n        return 0.0\n    top_diff = float(np.mean(top[:, :, 2] - top[:, :, 1]))\n    bot_diff = float(np.mean(bottom[:, :, 2] - bottom[:, :, 1]))\n    overall = float(np.mean(np.mean(rgb, axis=2)) + eps)\n    return float(abs(top_diff - bot_diff) / overall)\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Mean saturation among blue-dominant pixels (how colorful blue areas are)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if len(image.shape) == 2:\n        rgb = np.stack([image, image, image], axis=2).astype(float)\n    else:\n        rgb = image.astype(float)\n    r = rgb[:, :, 0].flatten()\n    g = rgb[:, :, 1].flatten()\n    b = rgb[:, :, 2].flatten()\n    mask = (b > r) & (b > g)\n    if np.count_nonzero(mask) == 0:\n        return 0.0\n    mx = np.maximum(np.maximum(r, g), b)\n    mn = np.minimum(np.minimum(r, g), b)\n    sat = (mx - mn) / (mx + eps)\n    return float(np.mean(sat[mask]))\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Normalized entropy of edge orientations (1.0 = uniform orientation distribution)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    gy, gx = np.gradient(gray)\n    mag = np.sqrt(gx * gx + gy * gy)\n    if mag.size == 0:\n        return 0.0\n    angles = np.arctan2(gy, gx)  # -pi..pi\n    bins = 16\n    idx = np.floor(((angles + np.pi) / (2 * np.pi)) * bins).astype(int)\n    idx = np.clip(idx, 0, bins - 1)\n    hist = np.zeros(bins, dtype=float)\n    for b in range(bins):\n        hist[b] = np.sum(mag[idx == b])\n    total = np.sum(hist) + eps\n    p = hist / total\n    ent = -np.sum(np.where(p > 0, p * np.log(p + eps), 0.0))\n    # normalize by log(bins) to get 0..1\n    return float(ent / (np.log(bins) + eps))\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Fractional length of the longest consecutive horizontal band of low row-variance (smooth band presence)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    h = gray.shape[0]\n    if h < 1 or gray.size == 0:\n        return 0.0\n    row_std = np.std(gray, axis=1)\n    thr = np.percentile(row_std, 40)  # consider rows smoother than lower-middle\n    mask = row_std <= thr\n    # compute longest run of True in mask\n    max_run = 0\n    run = 0\n    for v in mask:\n        if v:\n            run += 1\n            if run > max_run:\n                max_run = run\n        else:\n            run = 0\n    return float(max_run / (h + eps))\n",
  "def feature(image: np.ndarray) -> float:\n    'Fraction of the top quarter area that is strongly blue (sky/water indicator)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if len(image.shape) == 2:\n        rgb = np.stack([image, image, image], axis=2).astype(float)\n    else:\n        rgb = image.astype(float)\n    h, w = rgb.shape[:2]\n    top_h = max(1, h // 4)\n    top = rgb[:top_h, :, :]\n    if top.size == 0:\n        return 0.0\n    R = top[:, :, 0]; G = top[:, :, 1]; B = top[:, :, 2]\n    global_mean = float(np.mean(rgb)) + eps\n    mask = (B > 1.05 * R) & (B > 1.05 * G) & (B > 0.6 * global_mean)\n    return float(np.count_nonzero(mask) / (mask.size + eps))\n\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Vertical reflection similarity between top half and flipped bottom half (1 = very similar)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    h, w = image.shape[:2]\n    mid = max(1, h // 2)\n    if len(image.shape) == 3:\n        top = image[:mid, :, :].astype(float)\n        bottom = image[-mid:, :, :].astype(float)\n        bottom_flip = np.flipud(bottom)\n        # ensure same shape\n        if top.shape != bottom_flip.shape:\n            # trim to smaller\n            minr = min(top.shape[0], bottom_flip.shape[0])\n            top = top[:minr]; bottom_flip = bottom_flip[:minr]\n        diff = np.mean(np.abs(top - bottom_flip))\n        denom = np.mean(np.abs(np.vstack([top, bottom_flip]))) + eps\n    else:\n        top = image[:mid, :].astype(float)\n        bottom = image[-mid:, :].astype(float)\n        bottom_flip = np.flipud(bottom)\n        if top.shape != bottom_flip.shape:\n            minr = min(top.shape[0], bottom_flip.shape[0])\n            top = top[:minr]; bottom_flip = bottom_flip[:minr]\n        diff = np.mean(np.abs(top - bottom_flip))\n        denom = np.mean(np.abs(np.vstack([top, bottom_flip]))) + eps\n    sim = 1.0 - (diff / denom)\n    # clip to [0,1]\n    return float(max(0.0, min(1.0, sim)))\n\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Fraction of pixels with very low local gradient magnitude (smooth area fraction)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    if gray.size == 0:\n        return 0.0\n    gy, gx = np.gradient(gray)\n    mag = np.sqrt(gx * gx + gy * gy)\n    # threshold at 25th percentile to adapt per-image\n    thr = float(np.percentile(mag, 25)) if mag.size else 0.0\n    low_frac = np.count_nonzero(mag < (thr + eps)) / (mag.size + eps)\n    return float(low_frac)\n\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Fraction of pixels that are bright and low-chroma (specular/glint candidates)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if len(image.shape) == 2:\n        arr = image.astype(float)\n        R = G = B = arr\n    else:\n        rgb = image.astype(float)\n        R = rgb[:, :, 0]; G = rgb[:, :, 1]; B = rgb[:, :, 2]\n    # luminance\n    lum = 0.299 * R + 0.587 * G + 0.114 * B\n    if lum.size == 0:\n        return 0.0\n    thr = float(np.percentile(lum, 99))\n    mx = np.maximum(np.maximum(R, G), B)\n    mn = np.minimum(np.minimum(R, G), B)\n    chroma = mx - mn\n    global_lum_mean = float(np.mean(lum)) + eps\n    spec_mask = (lum >= thr) & (chroma <= 0.12 * global_lum_mean)\n    return float(np.count_nonzero(spec_mask) / (lum.size + eps))\n\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Fraction of image columns that contain a non-trivial fraction of green-dominant pixels'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if len(image.shape) == 2:\n        rgb = np.stack([image, image, image], axis=2).astype(float)\n    else:\n        rgb = image.astype(float)\n    h, w = rgb.shape[:2]\n    if w == 0 or h == 0:\n        return 0.0\n    R = rgb[:, :, 0]; G = rgb[:, :, 1]; B = rgb[:, :, 2]\n    global_mean = float(np.mean(rgb)) + eps\n    col_has_green = 0\n    for c in range(w):\n        colR = R[:, c]; colG = G[:, c]; colB = B[:, c]\n        mask = (colG > colR) & (colG > colB) & (colG > 0.6 * global_mean)\n        if np.count_nonzero(mask) > max(1, 0.05 * h):\n            col_has_green += 1\n    return float(col_has_green / (w + eps))\n\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Maximum horizontal-edge (vertical gradient) energy in the upper region normalized by overall energy'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    h = gray.shape[0]\n    if h < 2 or gray.size == 0:\n        return 0.0\n    gy, gx = np.gradient(gray)\n    row_energy = np.sum(np.abs(gy), axis=1)  # vertical gradient magnitude per row\n    # focus on upper half (likely location of horizon/sky-water boundary)\n    up_end = max(1, h // 2)\n    upper_region = row_energy[:up_end]\n    max_upper = float(np.max(upper_region)) if upper_region.size else 0.0\n    overall_mean = float(np.mean(row_energy)) + eps\n    score = max_upper / overall_mean\n    return float(score)\n\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Mean per-block color variance (8x8 grid) normalized by global color variance'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if len(image.shape) == 2:\n        rgb = np.stack([image, image, image], axis=2).astype(float)\n    else:\n        rgb = image.astype(float)\n    h, w = rgb.shape[:2]\n    bh = max(1, h // 8)\n    bw = max(1, w // 8)\n    variances = []\n    for r in range(0, h, bh):\n        for c in range(0, w, bw):\n            block = rgb[r:r+bh, c:c+bw, :]\n            if block.size == 0:\n                continue\n            # variance across all channels/pixels in block\n            variances.append(float(np.var(block)))\n    if len(variances) == 0:\n        return 0.0\n    mean_block_var = float(np.mean(variances))\n    global_var = float(np.var(rgb)) + eps\n    return float(mean_block_var / global_var)\n\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Vertical slope of blue-minus-green across rows (normalized); positive means more blue toward bottom'\n    import numpy as np\n    import numpy as _np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if len(image.shape) == 2:\n        arr = image.astype(float)\n        B = G = arr\n    else:\n        rgb = image.astype(float)\n        B = rgb[:, :, 2]; G = rgb[:, :, 1]\n    h = B.shape[0]\n    if h < 2 or B.size == 0:\n        return 0.0\n    row_bg = _np.mean(B - G, axis=1)\n    x = _np.arange(row_bg.size).astype(float)\n    x_mean = _np.mean(x)\n    y_mean = _np.mean(row_bg)\n    denom = _np.sum((x - x_mean) ** 2) + eps\n    slope = float(_np.sum((x - x_mean) * (row_bg - y_mean)) / denom)\n    # normalize by std of row_bg so units are comparable\n    slope_norm = slope / (float(_np.std(row_bg)) + eps)\n    return float(slope_norm)\n\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Concentration of edge energy across image columns (1.0 means energy concentrated in few columns)'\n    import numpy as np\n    import math\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    if w == 0 or h == 0:\n        return 0.0\n    gy, gx = np.gradient(gray)\n    col_energy = np.sum(np.abs(gx) + np.abs(gy), axis=0)\n    total = float(np.sum(col_energy)) + eps\n    p = col_energy / total\n    # normalized entropy\n    n = p.size\n    ent = -float(np.sum(np.where(p > 0, p * np.log(p + eps), 0.0)))\n    max_ent = float(np.log(n + eps))\n    norm_ent = ent / (max_ent + eps)\n    concentration = 1.0 - norm_ent\n    # clip\n    return float(max(0.0, min(1.0, concentration)))\n\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Relative luminance contrast between center region and border (0=no contrast)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if len(image.shape) == 2:\n        rgb = np.stack([image, image, image], axis=2).astype(float)\n    else:\n        rgb = image.astype(float)\n    h, w = rgb.shape[:2]\n    sr, sc = h // 4, w // 4\n    er, ec = h - sr, w - sc\n    if er <= sr or ec <= sc:\n        center = rgb\n    else:\n        center = rgb[sr:er, sc:ec, :]\n    # border composed of top/bottom/left/right strips\n    t = max(1, min(h, w) // 8)\n    top = rgb[:t, :, :]; bottom = rgb[-t:, :, :]\n    left = rgb[:, :t, :]; right = rgb[:, -t:, :]\n    border_pixels = np.concatenate([top.reshape(-1,3), bottom.reshape(-1,3), left.reshape(-1,3), right.reshape(-1,3)], axis=0) if rgb.size else np.zeros((1,3))\n    if center.size == 0 or border_pixels.size == 0:\n        return 0.0\n    # luminance\n    def lum(arr):\n        R = arr[..., 0]; G = arr[..., 1]; B = arr[..., 2]\n        return 0.299 * R + 0.587 * G + 0.114 * B\n    mean_center = float(np.mean(lum(center.reshape(-1,3))))\n    mean_border = float(np.mean(lum(border_pixels)))\n    contrast = abs(mean_center - mean_border) / (mean_center + mean_border + eps)\n    return float(contrast)\n",
  "def feature(image: np.ndarray) -> float:\n    'Fraction of pixels in the top third where blue channel dominates (sky/water top-band)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if len(image.shape) == 2:\n        rgb = np.stack([image, image, image], axis=2).astype(float)\n    else:\n        rgb = image.astype(float)\n    h, w = rgb.shape[:2]\n    top_h = max(1, h // 3)\n    top = rgb[:top_h, :, :]\n    if top.size == 0:\n        return 0.0\n    R = top[:, :, 0].flatten()\n    G = top[:, :, 1].flatten()\n    B = top[:, :, 2].flatten()\n    mask = (B > R) & (B > G)\n    return float(np.count_nonzero(mask) / (R.size + eps))\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Standard deviation of block mean intensities across an 8x8 grid (image patchiness)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    h, w = image.shape[:2]\n    gh, gw = 8, 8\n    bh = max(1, h // gh)\n    bw = max(1, w // gw)\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    means = []\n    for r in range(0, h, bh):\n        for c in range(0, w, bw):\n            block = gray[r:r+bh, c:c+bw]\n            if block.size == 0:\n                continue\n            means.append(np.mean(block))\n    if len(means) == 0:\n        return 0.0\n    means = np.array(means, dtype=float)\n    return float(np.std(means) / (np.mean(means) + eps))\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Normalized brightness difference between center region and border (center - border)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    h, w = image.shape[:2]\n    sr, sc = h // 4, w // 4\n    er, ec = h - sr, w - sc\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    center = gray[sr:er, sc:ec] if (er > sr and ec > sc) else gray\n    if center.size == 0:\n        return 0.0\n    # border is everything outside center\n    mask = np.ones_like(gray, dtype=bool)\n    mask[sr:er, sc:ec] = False\n    border = gray[mask]\n    mean_c = float(np.mean(center))\n    mean_b = float(np.mean(border)) if border.size > 0 else mean_c\n    return float((mean_c - mean_b) / (mean_b + eps))\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Left-right reflection correlation in grayscale (horizontal symmetry)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    w = gray.shape[1]\n    half = w // 2\n    left = gray[:, :half]\n    right = gray[:, -half:]\n    right_flipped = right[:, ::-1]\n    if left.size == 0 or right_flipped.size == 0:\n        return 0.0\n    # ensure same shape\n    if left.shape != right_flipped.shape:\n        min_r = min(left.shape[0], right_flipped.shape[0])\n        min_c = min(left.shape[1], right_flipped.shape[1])\n        left = left[:min_r, :min_c]\n        right_flipped = right_flipped[:min_r, :min_c]\n    a = left.flatten() - np.mean(left)\n    b = right_flipped.flatten() - np.mean(right_flipped)\n    denom = np.sqrt(np.sum(a*a) * np.sum(b*b)) + eps\n    corr = float(np.sum(a*b) / denom)\n    return float(corr)\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Proportion of strong edges whose orientation is near-horizontal (horizon-like structure)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    gy, gx = np.gradient(gray)\n    mag = np.sqrt(gx*gx + gy*gy)\n    if mag.size == 0:\n        return 0.0\n    thr = float(np.percentile(mag.flatten(), 70))\n    strong = mag > thr\n    if not np.any(strong):\n        return 0.0\n    # orientation: arctan2(gy, gx), horizontal when angle near 0 or pi\n    angles = np.arctan2(gy[strong], gx[strong])\n    # map to absolute angle from horizontal\n    abs_angle = np.abs(np.mod(angles + np.pi, np.pi) - 0.0)\n    # consider within 22.5 degrees (~pi/8)\n    band = (abs_angle <= (np.pi / 8))\n    return float(np.count_nonzero(band) / (np.count_nonzero(strong) + eps))\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Fraction of 16x16 blocks containing a bright local peak (small bright object proxy)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    h, w = image.shape[:2]\n    bh, bw = 16, 16\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    count_blocks = 0\n    strong_blocks = 0\n    for r in range(0, h, bh):\n        for c in range(0, w, bw):\n            block = gray[r:r+bh, c:c+bw]\n            if block.size == 0:\n                continue\n            count_blocks += 1\n            m = np.mean(block)\n            s = np.std(block)\n            local_max = np.max(block)\n            if local_max > m + 2.0 * (s + 1e-6):\n                strong_blocks += 1\n    if count_blocks == 0:\n        return 0.0\n    return float(strong_blocks / (count_blocks + eps))\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Mean blue chromaticity in the lower half (B / (R+G+B)) as a lower-scene blueness indicator'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if len(image.shape) == 2:\n        rgb = np.stack([image, image, image], axis=2).astype(float)\n    else:\n        rgb = image.astype(float)\n    h = rgb.shape[0]\n    lower = rgb[h//2:, :, :]\n    if lower.size == 0:\n        return 0.0\n    R = lower[:, :, 0].astype(float)\n    G = lower[:, :, 1].astype(float)\n    B = lower[:, :, 2].astype(float)\n    denom = (R + G + B + eps)\n    chroma_b = B / denom\n    return float(np.mean(chroma_b))\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Skewness of the (blue - green) distribution (positive means long blue tail)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if len(image.shape) == 2:\n        rgb = np.stack([image, image, image], axis=2).astype(float)\n    else:\n        rgb = image.astype(float)\n    diff = (rgb[:, :, 2].astype(float) - rgb[:, :, 1].astype(float)).flatten()\n    if diff.size == 0:\n        return 0.0\n    mu = float(np.mean(diff))\n    sigma = float(np.std(diff)) + eps\n    skew = float(np.mean((diff - mu)**3) / (sigma**3 + eps))\n    return float(skew)\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Column-wise variance of mean blue intensity (vertical blue banding measure)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if len(image.shape) == 2:\n        blue = image.astype(float)\n    else:\n        blue = image.astype(float)[:, :, 2]\n    if blue.size == 0:\n        return 0.0\n    col_means = np.mean(blue, axis=0)\n    return float(np.var(col_means) / (np.mean(col_means) + eps))\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Approximate grayscale entropy using 16-bin histogram (global texture/complexity)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    vals = gray.flatten()\n    if vals.size == 0:\n        return 0.0\n    hist, _ = np.histogram(vals, bins=16, range=(np.min(vals), np.max(vals)+1e-6))\n    p = hist.astype(float) / (np.sum(hist) + eps)\n    p = p[p > 0]\n    entropy = -np.sum(p * np.log(p + eps))\n    return float(entropy)\n",
  "def feature(image: np.ndarray) -> float:\n    'Fraction of top-third pixels that are blue-dominant (sky/water indicator)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if len(image.shape) == 2:\n        rgb = np.stack([image, image, image], axis=2).astype(float)\n    else:\n        rgb = image.astype(float)\n    h, w = rgb.shape[:2]\n    th = max(1, h // 3)\n    top = rgb[:th, :, :]\n    if top.size == 0:\n        return 0.0\n    r = top[:, :, 0].flatten()\n    g = top[:, :, 1].flatten()\n    b = top[:, :, 2].flatten()\n    # blue-dominant and reasonably bright relative to local max\n    mx = np.maximum(np.maximum(r, g), b)\n    global_max = mx.max() if mx.size else 0.0\n    thr = 0.6 * (global_max + eps)\n    mask = (b > g) & (b > r) & (mx > thr)\n    return float(np.count_nonzero(mask) / (mx.size + eps))\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Fraction of bottom-third pixels that are green-dominant (vegetation indicator)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if len(image.shape) == 2:\n        rgb = np.stack([image, image, image], axis=2).astype(float)\n    else:\n        rgb = image.astype(float)\n    h, w = rgb.shape[:2]\n    th = max(1, h // 3)\n    bottom = rgb[-th:, :, :]\n    if bottom.size == 0:\n        return 0.0\n    r = bottom[:, :, 0].flatten()\n    g = bottom[:, :, 1].flatten()\n    b = bottom[:, :, 2].flatten()\n    mx = np.maximum(np.maximum(r, g), b)\n    mask = (g > r) & (g > b) & (g > 0.5 * mx)\n    return float(np.count_nonzero(mask) / (mx.size + eps))\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Left-right mirror symmetry score (1.0 = perfectly symmetric)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    arr = image.astype(float) if len(image.shape) < 3 else image.astype(float)\n    h, w = arr.shape[:2]\n    if w < 2:\n        return 0.0\n    mid = w // 2\n    left = arr[:, :mid, ...]\n    right = arr[:, -mid:, ...]\n    if left.size == 0 or right.size == 0:\n        return 0.0\n    # flip right horizontally to compare\n    right_flipped = np.flip(right, axis=1)\n    # match shapes if odd width\n    if left.shape != right_flipped.shape:\n        # crop to smallest\n        min_w = min(left.shape[1], right_flipped.shape[1])\n        left = left[:, :min_w, ...]\n        right_flipped = right_flipped[:, :min_w, ...]\n    diff = np.abs(left.astype(float) - right_flipped.astype(float))\n    # normalize by overall intensity\n    norm = np.mean(np.abs(arr)) + eps\n    score = 1.0 - (np.mean(diff) / norm)\n    return float(max(0.0, min(1.0, score)))\n\n",
  "def feature(image: np.ndarray) -> float:\n    'High-frequency (Laplacian) energy normalized by mean-squared intensity (texture roughness)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    if gray.size == 0:\n        return 0.0\n    # discrete Laplacian via rolled neighbors (wrap-around acceptable as approximation)\n    up = np.roll(gray, -1, axis=0)\n    down = np.roll(gray, 1, axis=0)\n    left = np.roll(gray, -1, axis=1)\n    right = np.roll(gray, 1, axis=1)\n    lap = 4.0 * gray - (up + down + left + right)\n    hf = np.mean(lap * lap)\n    denom = np.mean(gray * gray) + eps\n    return float(hf / denom)\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Color warmth: normalized red-blue bias (positive = warmer)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if len(image.shape) == 2:\n        R = image.astype(float).flatten()\n        G = image.astype(float).flatten()\n        B = image.astype(float).flatten()\n    else:\n        R = image[:, :, 0].astype(float).flatten()\n        G = image[:, :, 1].astype(float).flatten()\n        B = image[:, :, 2].astype(float).flatten()\n    if R.size == 0:\n        return 0.0\n    meanR = np.mean(R)\n    meanB = np.mean(B)\n    score = (meanR - meanB) / (meanR + meanB + eps)\n    return float(score)\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Center-vs-border brightness contrast (center brighter positive)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    sr, sc = max(0, h // 4), max(0, w // 4)\n    er, ec = h - sr, w - sc\n    center = gray[sr:er, sc:ec] if er > sr and ec > sc else gray\n    border_mask = np.ones_like(gray, dtype=bool)\n    border_mask[sr:er, sc:ec] = False\n    border = gray[border_mask]\n    if center.size == 0:\n        return 0.0\n    center_mean = np.mean(center)\n    border_mean = np.mean(border) if border.size > 0 else center_mean\n    contrast = (center_mean - border_mean) / (abs(center_mean) + abs(border_mean) + eps)\n    return float(contrast)\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Fraction of near-white/specular pixels (high max-channel relative to image max)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if len(image.shape) == 2:\n        mx = image.astype(float)\n    else:\n        mx = np.max(image.astype(float), axis=2)\n    if mx.size == 0:\n        return 0.0\n    global_max = mx.max() if mx.size else 0.0\n    thr = 0.95 * (global_max + eps)\n    mask = mx >= thr\n    return float(np.count_nonzero(mask) / (mx.size + eps))\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Vertical color separation (distance between top-third and bottom-third mean colors)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if len(image.shape) == 2:\n        rgb = np.stack([image, image, image], axis=2).astype(float)\n    else:\n        rgb = image.astype(float)\n    h = rgb.shape[0]\n    if h < 3:\n        # fallback to global color variance\n        pix = rgb.reshape(-1, 3)\n        if pix.size == 0:\n            return 0.0\n        mean_color = np.mean(pix, axis=0)\n        return float(np.linalg.norm(mean_color) / (np.linalg.norm(mean_color) + eps))\n    t = max(1, h // 3)\n    top = rgb[:t, :, :].reshape(-1, 3)\n    bottom = rgb[-t:, :, :].reshape(-1, 3)\n    if top.size == 0 or bottom.size == 0:\n        return 0.0\n    mean_top = np.mean(top, axis=0)\n    mean_bottom = np.mean(bottom, axis=0)\n    dist = np.linalg.norm(mean_top - mean_bottom)\n    norm = (np.linalg.norm(mean_top) + np.linalg.norm(mean_bottom) + eps)\n    return float(dist / norm)\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Edge orientation entropy (0 low = uniform orientation, 1 high = diverse orientations)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    if gray.size == 0:\n        return 0.0\n    gy, gx = np.gradient(gray)\n    mag = np.sqrt(gx * gx + gy * gy)\n    # ignore very small gradients\n    mask = mag > (np.percentile(mag, 50) * 0.1 + eps)\n    if np.count_nonzero(mask) == 0:\n        return 0.0\n    ang = np.arctan2(gy[mask], gx[mask])  # range [-pi, pi]\n    # bin orientations into 12 bins\n    bins = 12\n    hist, _ = np.histogram(ang, bins=bins, range=(-np.pi, np.pi))\n    p = hist.astype(float) / (np.sum(hist) + eps)\n    ent = -np.sum(np.where(p > 0, p * np.log(p + eps), 0.0))\n    max_ent = np.log(bins + eps)\n    norm_ent = ent / (max_ent + eps)\n    return float(norm_ent)\n",
  "def feature(image: np.ndarray) -> float:\n    'Fraction of strong edges in the center region that are near-vertical'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    sr, sc = h // 4, w // 4\n    er, ec = h - sr, w - sc\n    region = gray[sr:er, sc:ec] if (er > sr and ec > sc) else gray\n    if region.size == 0:\n        return 0.0\n    gy, gx = np.gradient(region)\n    mag = np.sqrt(gx * gx + gy * gy)\n    if mag.size == 0:\n        return 0.0\n    thr = np.percentile(mag.flatten(), 70)\n    strong = mag > (thr + eps)\n    if not np.any(strong):\n        return 0.0\n    orient_frac = np.where(mag > 0, np.abs(gx) / (mag + eps), 0.0)  # 1.0 -> vertical\n    vertical = np.count_nonzero((orient_frac > 0.8) & strong)\n    return float(vertical / (np.count_nonzero(strong) + eps))\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Mean normalized blue excess: mean(B - (R+G)/2) normalized by overall intensity'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if len(image.shape) == 2:\n        rgb = np.stack([image, image, image], axis=2).astype(float)\n    else:\n        rgb = image.astype(float)\n    R = rgb[:, :, 0].astype(float)\n    G = rgb[:, :, 1].astype(float)\n    B = rgb[:, :, 2].astype(float)\n    blue_excess = B - 0.5 * (R + G)\n    mean_excess = float(np.mean(blue_excess))\n    mean_intensity = float(np.mean((R + G + B) / 3.0) + eps)\n    return float(mean_excess / mean_intensity)\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Fraction of very bright pixels in the bottom half (specular highlights / reflections)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        intensity = np.mean(image, axis=2).astype(float)\n    else:\n        intensity = image.astype(float)\n    h = intensity.shape[0]\n    bottom = intensity[h//2:, :] if h//2 > 0 else intensity\n    if bottom.size == 0:\n        return 0.0\n    maxv = float(np.max(intensity) + eps)\n    thr = maxv * 0.95  # very bright\n    mask = bottom > thr\n    return float(np.count_nonzero(mask) / (mask.size + eps))\n\n",
  "def feature(image: np.ndarray) -> float:\n    'L1 distance between normalized blue histograms of top-quarter and bottom-quarter regions'\n    import numpy as np\n    eps = 1e-8\n    bins = 16\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if len(image.shape) == 2:\n        blue = image.astype(float)\n    else:\n        blue = image[:, :, 2].astype(float)\n    h, w = blue.shape[:2]\n    top_h = max(1, h // 4)\n    top = blue[:top_h, :]\n    bottom = blue[-top_h:, :] if top_h > 0 else blue\n    if top.size == 0 or bottom.size == 0:\n        return 0.0\n    minv, maxv = float(np.min(blue)), float(np.max(blue))\n    if maxv - minv < eps:\n        return 0.0\n    top_hist, _ = np.histogram(top.flatten(), bins=bins, range=(minv, maxv), density=True)\n    bot_hist, _ = np.histogram(bottom.flatten(), bins=bins, range=(minv, maxv), density=True)\n    l1 = np.sum(np.abs(top_hist - bot_hist))\n    # normalize to [0,1] (max possible L1 between two distributions is 2)\n    return float(l1 / 2.0)\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Vertical position (0..1) of centroid of the brightest 5% pixels (0=top,1=bottom)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    if gray.size == 0:\n        return 0.0\n    flat = gray.flatten()\n    thr = np.percentile(flat, 95)\n    mask = gray >= (thr - eps)\n    if not np.any(mask):\n        return 0.0\n    rows = np.nonzero(mask)[0]\n    if rows.size == 0:\n        return 0.0\n    centroid_row = float(np.mean(rows))\n    return float(centroid_row / max(1.0, (h - 1)))\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Fraction of image area that is locally smooth (block variance much lower than global)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    bs = 16\n    h2 = (h // bs) * bs\n    w2 = (w // bs) * bs\n    if h2 == 0 or w2 == 0:\n        # fallback to global variance comparison\n        global_var = float(np.var(gray) + eps)\n        return float(1.0 if global_var < 1e-6 else 0.0)\n    cropped = gray[:h2, :w2]\n    blocks = cropped.reshape(h2//bs, bs, w2//bs, bs)\n    # compute variance per block\n    block_vars = np.var(blocks, axis=(1, 3))\n    global_var = float(np.var(gray) + eps)\n    smooth_blocks = block_vars < (0.2 * global_var)\n    frac = float(np.count_nonzero(smooth_blocks) / (smooth_blocks.size + eps))\n    return float(frac)\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Fraction of pixels in center region that are red-dominant (R > G and R > B by margin)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if len(image.shape) == 2:\n        rgb = np.stack([image, image, image], axis=2).astype(float)\n    else:\n        rgb = image.astype(float)\n    h, w = rgb.shape[:2]\n    sr, sc = h // 4, w // 4\n    er, ec = h - sr, w - sc\n    region = rgb[sr:er, sc:ec, :] if (er > sr and ec > sc) else rgb\n    if region.size == 0:\n        return 0.0\n    R = region[:, :, 0]\n    G = region[:, :, 1]\n    B = region[:, :, 2]\n    intensity = (R + G + B) / 3.0\n    margin = 0.08 * (np.max(intensity) - np.min(intensity) + eps)\n    mask = (R > G + margin) & (R > B + margin)\n    return float(np.count_nonzero(mask) / (mask.size + eps))\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Ratio of low-frequency (block-averaged) variance to original image variance (smooth vs textured)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        img = np.mean(image, axis=2).astype(float)\n    else:\n        img = image.astype(float)\n    h, w = img.shape[:2]\n    bs = 8\n    h2 = (h // bs) * bs\n    w2 = (w // bs) * bs\n    if h2 == 0 or w2 == 0:\n        return 0.0\n    cropped = img[:h2, :w2]\n    blocks = cropped.reshape(h2//bs, bs, w2//bs, bs)\n    block_means = np.mean(blocks, axis=(1, 3)).flatten()\n    var_low = float(np.var(block_means))\n    var_orig = float(np.var(img) + eps)\n    return float(var_low / var_orig)\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Fraction of strong edge pixels in the top quarter that coincide with green-dominant pixels'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if len(image.shape) == 2:\n        rgb = np.stack([image, image, image], axis=2).astype(float)\n    else:\n        rgb = image.astype(float)\n    h, w = rgb.shape[:2]\n    top_h = max(1, h // 4)\n    top = rgb[:top_h, :, :]\n    if top.size == 0:\n        return 0.0\n    gray_top = np.mean(top, axis=2).astype(float)\n    gy, gx = np.gradient(gray_top)\n    mag = np.sqrt(gx * gx + gy * gy)\n    if mag.size == 0:\n        return 0.0\n    thr = np.percentile(mag.flatten(), 70)\n    strong = mag > (thr + eps)\n    if not np.any(strong):\n        return 0.0\n    g = top[:, :, 1]\n    r = top[:, :, 0]\n    b = top[:, :, 2]\n    green_dom = (g > r) & (g > b)\n    coincide = np.count_nonzero(strong & green_dom)\n    return float(coincide / (np.count_nonzero(strong) + eps))\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Vertical symmetry score: 1 - normalized mean absolute difference between left and flipped right halves'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    if w < 2:\n        return 0.0\n    mid = w // 2\n    left = gray[:, :mid]\n    right = gray[:, -mid:] if mid > 0 else gray[:, :mid]\n    if left.size == 0 or right.size == 0:\n        return 0.0\n    # flip right horizontally to compare with left\n    right_flipped = np.fliplr(right)\n    # if shapes mismatch (when odd width), crop to min width\n    min_w = min(left.shape[1], right_flipped.shape[1])\n    left_c = left[:, :min_w]\n    right_c = right_flipped[:, :min_w]\n    diff = np.abs(left_c - right_c)\n    norm = float(np.mean(np.abs(gray)) + eps)\n    score = 1.0 - float(np.mean(diff) / norm)\n    # clamp to [0,1]\n    return float(max(0.0, min(1.0, score)))\n",
  "def feature(image: np.ndarray) -> float:\n    'Fraction of top-quarter pixels that are strongly blue-dominant (sky/water indicator)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    # ensure RGB\n    if len(image.shape) == 2:\n        rgb = np.stack([image, image, image], axis=2).astype(float)\n    else:\n        rgb = image.astype(float)\n    h, w = rgb.shape[:2]\n    th = max(1, h // 4)\n    top = rgb[:th, :, :]\n    if top.size == 0:\n        return 0.0\n    r = top[:, :, 0].flatten()\n    g = top[:, :, 1].flatten()\n    b = top[:, :, 2].flatten()\n    # blue dominant by margin relative to other channels\n    mask = (b > r * 1.15) & (b > g * 1.15) & (b > (r + g + b) / 9.0 + eps)\n    return float(np.count_nonzero(mask) / (r.size + eps))\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Normalized vertical symmetry between left and right halves (0..1)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    # grayscale\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    half = w // 2\n    left = gray[:, :half]\n    right = gray[:, w - half:]\n    if left.size == 0 or right.size == 0:\n        return 0.0\n    right_flipped = np.fliplr(right)\n    # flatten and compute normalized correlation\n    a = left.flatten().astype(float) - np.mean(left)\n    b = right_flipped.flatten().astype(float) - np.mean(right_flipped)\n    na = np.linalg.norm(a) + eps\n    nb = np.linalg.norm(b) + eps\n    corr = float(np.dot(a, b) / (na * nb))\n    # map from [-1,1] to [0,1]\n    return float((corr + 1.0) / 2.0)\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Mean gradient magnitude normalized by mean intensity (texture per overall brightness)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n        mean_int = np.mean(gray) + eps\n    else:\n        gray = image.astype(float)\n        mean_int = np.mean(gray) + eps\n    if gray.size == 0:\n        return 0.0\n    gy, gx = np.gradient(gray)\n    mag = np.sqrt(gx * gx + gy * gy)\n    return float(np.mean(mag) / mean_int)\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Vertical position of strongest horizontal edges (0=top, 1=bottom), useful for horizon/waterline'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.5\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    if h == 0:\n        return 0.5\n    gy, gx = np.gradient(gray)\n    row_energy = np.sum(np.abs(gy), axis=1)\n    total = np.sum(row_energy) + eps\n    if total <= eps:\n        return 0.5\n    indices = np.arange(h).astype(float)\n    weighted = np.sum(indices * row_energy) / total\n    return float(weighted / (max(1.0, h - 1.0)))\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Global fraction of pixels that are strongly blue relative to red and green (water indicator)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if len(image.shape) == 2:\n        rgb = np.stack([image, image, image], axis=2).astype(float)\n    else:\n        rgb = image.astype(float)\n    r = rgb[:, :, 0].flatten()\n    g = rgb[:, :, 1].flatten()\n    b = rgb[:, :, 2].flatten()\n    # require blue to exceed both by a margin and be above local mean\n    mean_all = np.mean((r + g + b) / 3.0) + eps\n    mask = (b > r * 1.2) & (b > g * 1.2) & (b > mean_all * 0.9)\n    return float(np.count_nonzero(mask) / (r.size + eps))\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Relative difference of mean edge strength between center and border (center - border) / (center + border)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    gy, gx = np.gradient(gray)\n    mag = np.sqrt(gx * gx + gy * gy)\n    sr, sc = h // 4, w // 4\n    er, ec = h - sr, w - sc\n    if er <= sr or ec <= sc:\n        center = mag\n    else:\n        center = mag[sr:er, sc:ec]\n    t = max(1, min(h, w) // 8)\n    top = mag[:t, :]\n    bottom = mag[-t:, :]\n    left = mag[:, :t]\n    right = mag[:, -t:]\n    border = np.concatenate([top.flatten(), bottom.flatten(), left.flatten(), right.flatten()]) if mag.size else np.array([0.0])\n    mean_c = float(np.mean(center)) if center.size else 0.0\n    mean_b = float(np.mean(border)) if border.size else 0.0\n    return float((mean_c - mean_b) / (mean_c + mean_b + eps))\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Color uniformity score: 1 = very uniform color, 0 = very varied (based on per-channel std)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if len(image.shape) == 2:\n        rgb = np.stack([image, image, image], axis=2).astype(float)\n    else:\n        rgb = image.astype(float)\n    r = rgb[:, :, 0].flatten()\n    g = rgb[:, :, 1].flatten()\n    b = rgb[:, :, 2].flatten()\n    mean_all = np.mean((r + g + b) / 3.0) + eps\n    std_sum = float(np.std(r) + np.std(g) + np.std(b))\n    # convert to a 0..1 score: higher std_sum -> lower uniformity\n    score = 1.0 - (std_sum / (std_sum + mean_all))\n    return float(max(0.0, min(1.0, score)))\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Fraction of high-frequency pixels (gradient magnitude above mean+0.75*std)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    if gray.size == 0:\n        return 0.0\n    gy, gx = np.gradient(gray)\n    mag = np.sqrt(gx * gx + gy * gy).flatten()\n    m = np.mean(mag)\n    s = np.std(mag)\n    thr = m + 0.75 * s\n    return float(np.count_nonzero(mag > thr) / (mag.size + eps))\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Fraction of bottom-half pixels that are very bright (possible water reflection / glare)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    # compute per-pixel intensity as mean of channels\n    if len(image.shape) == 2:\n        intensity = image.astype(float)\n    else:\n        intensity = np.mean(image.astype(float), axis=2)\n    h, w = intensity.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    bottom = intensity[h // 2 :, :]\n    if bottom.size == 0:\n        return 0.0\n    mean_all = np.mean(intensity) + eps\n    std_all = np.std(intensity)\n    thr = mean_all + 1.0 * std_all\n    return float(np.count_nonzero(bottom > thr) / (bottom.size + eps))\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Image aspect ratio (width / height) as a float (>=0)'\n    import numpy as np\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    h, w = image.shape[:2]\n    if h <= 0:\n        return 0.0\n    return float(float(w) / float(h))\n",
  "def feature(image: np.ndarray) -> float:\n    'Vertical centroid of blue intensity (0=top,1=bottom)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if len(image.shape) == 2:\n        rgb = np.stack([image, image, image], axis=2).astype(float)\n    else:\n        rgb = image.astype(float)\n    h = rgb.shape[0]\n    B = rgb[:, :, 2].astype(float)\n    row_means = np.mean(B, axis=1)\n    weight_sum = float(np.sum(row_means))\n    if weight_sum <= 0:\n        return 0.5\n    rows = np.arange(h).astype(float)\n    centroid = float(np.sum(rows * row_means) / (weight_sum + eps))\n    return float(centroid / max(1.0, h - 1.0))\n\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Vertical symmetry of the blue channel (1.0 = perfectly symmetric)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if len(image.shape) == 2:\n        rgb = np.stack([image, image, image], axis=2).astype(float)\n    else:\n        rgb = image.astype(float)\n    B = rgb[:, :, 2].astype(float)\n    row_means = np.mean(B, axis=1)\n    rev = row_means[::-1]\n    if row_means.size == 0:\n        return 0.0\n    mean_abs = float(np.mean(np.abs(row_means - rev)))\n    denom = float(np.mean(np.abs(row_means) + np.abs(rev)) + eps)\n    sym_score = 1.0 - (mean_abs / denom)\n    return float(max(0.0, min(1.0, sym_score)))\n\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Ratio of fine-scale to coarse-scale average gradient magnitude (texture scale)'\n    import numpy as np\n    import numpy as _np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = _np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    gy1, gx1 = _np.gradient(gray)\n    mag1 = _np.sqrt(gx1 * gx1 + gy1 * gy1)\n    mean1 = float(_np.mean(mag1)) if mag1.size else 0.0\n    s = max(2, min(h, w) // 8)\n    small = gray[::s, ::s]\n    gy2, gx2 = _np.gradient(small)\n    mag2 = _np.sqrt(gx2 * gx2 + gy2 * gy2)\n    mean2 = float(_np.mean(mag2)) if mag2.size else 0.0\n    return float(mean1 / (mean2 + eps))\n\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Average per-block color standard deviation (higher -> more local color variation)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if len(image.shape) == 2:\n        rgb = np.stack([image, image, image], axis=2).astype(float)\n    else:\n        rgb = image.astype(float)\n    h, w = rgb.shape[:2]\n    bs = max(4, min(h, w) // 16)\n    nh = (h // bs) * bs\n    nw = (w // bs) * bs\n    if nh == 0 or nw == 0:\n        return float(np.std(rgb))\n    cropped = rgb[:nh, :nw, :].reshape(nh // bs, bs, nw // bs, bs, 3)\n    # std within each block across pixels and channels\n    block_std = np.std(cropped, axis=(1, 3, 4))\n    return float(np.mean(block_std) if block_std.size else 0.0)\n\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Fraction of strong edges that are near-vertical'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    gy, gx = np.gradient(gray)\n    mag = np.sqrt(gx * gx + gy * gy)\n    if mag.size == 0:\n        return 0.0\n    thr = np.percentile(mag, 75) if mag.size else 0.0\n    strong = mag > (thr + eps)\n    if np.count_nonzero(strong) == 0:\n        return 0.0\n    orient_frac = np.where(mag > 0, np.abs(gx) / (mag + eps), 0.0)  # 1.0 -> vertical\n    vert_strong = np.count_nonzero((orient_frac > 0.8) & strong)\n    return float(vert_strong / (np.count_nonzero(strong) + eps))\n\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Skewness of blue-minus-average-redgreen (positive -> long blue tail)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if len(image.shape) == 2:\n        rgb = np.stack([image, image, image], axis=2).astype(float)\n    else:\n        rgb = image.astype(float)\n    R = rgb[:, :, 0].astype(float).flatten()\n    G = rgb[:, :, 1].astype(float).flatten()\n    B = rgb[:, :, 2].astype(float).flatten()\n    x = B - 0.5 * (R + G)\n    m = float(np.mean(x))\n    s = float(np.std(x) + eps)\n    skew = float(np.mean(((x - m) / s) ** 3))\n    return float(skew)\n\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Center vs border brightness contrast normalized by global intensity'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if len(image.shape) == 2:\n        rgb = np.stack([image, image, image], axis=2).astype(float)\n    else:\n        rgb = image.astype(float)\n    h, w = rgb.shape[:2]\n    sr, sc = h // 4, w // 4\n    er, ec = h - sr, w - sc\n    center = rgb[sr:er, sc:ec, :] if (er > sr and ec > sc) else rgb\n    t = max(1, min(h, w) // 8)\n    top = rgb[:t, :, :]\n    bottom = rgb[-t:, :, :]\n    left = rgb[:, :t, :]\n    right = rgb[:, -t:, :]\n    border = np.concatenate([top.reshape(-1,3), bottom.reshape(-1,3), left.reshape(-1,3), right.reshape(-1,3)], axis=0) if rgb.size else np.zeros((1,3))\n    mean_center = float(np.mean(center)) if center.size else 0.0\n    mean_border = float(np.mean(border)) if border.size else 0.0\n    global_mean = float(np.mean(rgb) + eps)\n    return float((mean_center - mean_border) / global_mean)\n\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Low-frequency variance ratio of blue to green (block-averaged variances)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if len(image.shape) == 2:\n        rgb = np.stack([image, image, image], axis=2).astype(float)\n    else:\n        rgb = image.astype(float)\n    h, w = rgb.shape[:2]\n    bs = max(8, min(h, w) // 12)\n    nh = (h // bs) * bs\n    nw = (w // bs) * bs\n    if nh == 0 or nw == 0:\n        return 0.0\n    cropped = rgb[:nh, :nw, :].reshape(nh // bs, bs, nw // bs, bs, 3)\n    # block means for each channel\n    block_means = np.mean(np.mean(cropped, axis=1), axis=2)  # shape (nh_blocks, nw_blocks, 3)\n    Bm = block_means[:, :, 2].flatten()\n    Gm = block_means[:, :, 1].flatten()\n    varB = float(np.var(Bm))\n    varG = float(np.var(Gm))\n    return float(varB / (varG + eps))\n\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Fraction of strong edge pixels that lie inside blue-dominant pixels'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if len(image.shape) == 2:\n        rgb = np.stack([image, image, image], axis=2).astype(float)\n    else:\n        rgb = image.astype(float)\n    R = rgb[:, :, 0].astype(float)\n    G = rgb[:, :, 1].astype(float)\n    B = rgb[:, :, 2].astype(float)\n    gray = np.mean(rgb, axis=2).astype(float)\n    gy, gx = np.gradient(gray)\n    mag = np.sqrt(gx * gx + gy * gy)\n    if mag.size == 0:\n        return 0.0\n    thr = np.percentile(mag, 75) if mag.size else 0.0\n    strong = mag > (thr + eps)\n    global_mean = float(np.mean(rgb))\n    blue_mask = (B > R) & (B > G) & (B > global_mean * 0.6)\n    num_edge = np.count_nonzero(strong)\n    if num_edge == 0:\n        return 0.0\n    num_bedge = np.count_nonzero(strong & blue_mask)\n    return float(num_bedge / (num_edge + eps))\n\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Fraction of rows that form a continuous horizontal blue band (longest run fraction)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if len(image.shape) == 2:\n        rgb = np.stack([image, image, image], axis=2).astype(float)\n    else:\n        rgb = image.astype(float)\n    h = rgb.shape[0]\n    R = rgb[:, :, 0].astype(float)\n    G = rgb[:, :, 1].astype(float)\n    B = rgb[:, :, 2].astype(float)\n    rowB = np.mean(B, axis=1)\n    rowG = np.mean(G, axis=1)\n    global_mean = float(np.mean(rgb) + eps)\n    mask_rows = rowB > (rowG + 0.05 * global_mean)\n    if mask_rows.size == 0:\n        return 0.0\n    # find longest consecutive True run\n    max_run = 0\n    cur = 0\n    for v in mask_rows:\n        if v:\n            cur += 1\n            if cur > max_run:\n                max_run = cur\n        else:\n            cur = 0\n    return float(max_run / max(1, h))\n",
  "def feature(image: np.ndarray) -> float:\n    'Ratio of average horizontal-edge strength to vertical-edge strength in the image'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    # gradients: gy (d/drow) captures horizontal edges, gx (d/col) captures vertical edges\n    gy, gx = np.gradient(gray)\n    mean_h = float(np.mean(np.abs(gy)))\n    mean_v = float(np.mean(np.abs(gx)))\n    return float(mean_h / (mean_v + eps))\n\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Fraction of coarse blocks that are both low-variance and blue-dominant (smooth blue areas)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if len(image.shape) == 2:\n        rgb = np.stack([image, image, image], axis=2).astype(float)\n    else:\n        rgb = image.astype(float)\n    h, w = rgb.shape[:2]\n    bs = 16\n    # fallback to global if image too small\n    if h < bs or w < bs:\n        R, G, B = rgb[:, :, 0], rgb[:, :, 1], rgb[:, :, 2]\n        var = float(np.var(np.mean(rgb, axis=2)))\n        blue_frac = float(np.count_nonzero((B > R) & (B > G)) / (h * w + eps))\n        return float(1.0 if (var < 50 and blue_frac > 0.1) else 0.0)\n    h2 = (h // bs) * bs\n    w2 = (w // bs) * bs\n    crop = rgb[:h2, :w2, :].astype(float)\n    blocks = crop.reshape(h2//bs, bs, w2//bs, bs, 3)\n    # compute per-block variance of intensity and mean blue>green ratio\n    block_int = np.mean(blocks, axis=(1, 3, 4))\n    block_var = np.var(np.mean(blocks, axis=4), axis=(1, 2))\n    block_B = np.mean(blocks[:, :, :, :, 2], axis=(1, 2))\n    block_G = np.mean(blocks[:, :, :, :, 1], axis=(1, 2))\n    smooth_blue = (block_var < (0.5 * np.mean(block_var) + eps)) & (block_B > block_G)\n    frac = float(np.count_nonzero(smooth_blue) / (smooth_blue.size + eps))\n    return float(frac)\n\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Longest contiguous vertical blue-dominant band length as fraction of image height'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if len(image.shape) == 2:\n        rgb = np.stack([image, image, image], axis=2).astype(float)\n    else:\n        rgb = image.astype(float)\n    h = rgb.shape[0]\n    R = np.mean(rgb[:, :, 0], axis=1)\n    G = np.mean(rgb[:, :, 1], axis=1)\n    B = np.mean(rgb[:, :, 2], axis=1)\n    diff = B - G\n    # threshold: positive and above a modest percentile to avoid noise\n    thr = max(0.0, np.percentile(diff, 60))\n    mask = diff > thr\n    if mask.size == 0 or not np.any(mask):\n        return 0.0\n    # longest run of True in mask\n    max_run = 0\n    cur = 0\n    for v in mask:\n        if v:\n            cur += 1\n            if cur > max_run:\n                max_run = cur\n        else:\n            cur = 0\n    return float(max_run / (h + eps))\n\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Fraction of pixels with strong gradient magnitude (edge density)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    gy, gx = np.gradient(gray)\n    mag = np.sqrt(gy * gy + gx * gx)\n    thr = np.mean(mag) + np.std(mag)\n    strong = np.count_nonzero(mag > thr)\n    total = mag.size\n    return float(strong / (total + eps))\n\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Mean chromatic angle (R-G vs B-G) normalized to [-1,1] using atan2/\u03c0'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if len(image.shape) == 2:\n        rgb = np.stack([image, image, image], axis=2).astype(float)\n    else:\n        rgb = image.astype(float)\n    meanR = float(np.mean(rgb[:, :, 0]))\n    meanG = float(np.mean(rgb[:, :, 1]))\n    meanB = float(np.mean(rgb[:, :, 2]))\n    vx = meanR - meanG\n    vy = meanB - meanG\n    angle = np.arctan2(vy, vx)  # -pi..pi\n    return float(angle / (np.pi + eps))\n\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Fraction of bottom third pixels that are blue-dominant and bright (water indicator)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if len(image.shape) == 2:\n        rgb = np.stack([image, image, image], axis=2).astype(float)\n    else:\n        rgb = image.astype(float)\n    h = rgb.shape[0]\n    start = max(0, (2 * h) // 3)\n    bottom = rgb[start:, :, :].astype(float)\n    if bottom.size == 0:\n        return 0.0\n    R = bottom[:, :, 0]\n    G = bottom[:, :, 1]\n    B = bottom[:, :, 2]\n    intensity = np.mean(bottom, axis=2)\n    bright_thr = np.percentile(intensity.flatten(), 30)\n    mask = (B > R) & (B > G) & (intensity > bright_thr)\n    return float(np.count_nonzero(mask) / (mask.size + eps))\n\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Fraction of center-region blocks that show strong local texture (center object proxy)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        rgb = image.astype(float)\n        gray = np.mean(rgb, axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    # center region\n    sr, sc = h // 4, w // 4\n    er, ec = h - sr, w - sc\n    region = gray[sr:er, sc:ec] if (er > sr and ec > sc) else gray\n    bs = 16\n    rh, rw = region.shape[:2]\n    if rh < bs or rw < bs:\n        # fallback: return normalized mean gradient of region\n        gy, gx = np.gradient(region)\n        return float(np.mean(np.sqrt(gy * gy + gx * gx)))\n    h2 = (rh // bs) * bs\n    w2 = (rw // bs) * bs\n    cropped = region[:h2, :w2]\n    blocks = cropped.reshape(h2//bs, bs, w2//bs, bs)\n    # compute mean gradient magnitude per block\n    block_grad = np.zeros((h2//bs, w2//bs))\n    for i in range(blocks.shape[0]):\n        for j in range(blocks.shape[2]):\n            blk = blocks[i, :, j, :].astype(float)\n            gy, gx = np.gradient(blk)\n            block_grad[i, j] = np.mean(np.sqrt(gy * gy + gx * gx))\n    thr = np.mean(block_grad) + np.std(block_grad)\n    strong = block_grad > thr\n    return float(np.count_nonzero(strong) / (strong.size + eps))\n",
  "def feature(image: np.ndarray) -> float:\n    'Fraction of pixels that are blue-dominant (blue > red and blue > green) with minimum blue intensity'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if len(image.shape) == 2:\n        rgb = np.stack([image, image, image], axis=2).astype(float)\n    else:\n        rgb = image.astype(float)\n    r = rgb[:, :, 0]\n    g = rgb[:, :, 1]\n    b = rgb[:, :, 2]\n    # require blue to be noticeably dominant and not just dark noise\n    dominance_mask = (b > r + 5) & (b > g + 5) & (b > (np.mean(rgb) * 0.8 + eps))\n    return float(np.count_nonzero(dominance_mask) / (dominance_mask.size + eps))\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Ratio of count of blue-dominant pixels to green-dominant pixels (blue_count/green_count)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if len(image.shape) == 2:\n        rgb = np.stack([image, image, image], axis=2).astype(float)\n    else:\n        rgb = image.astype(float)\n    r = rgb[:, :, 0]\n    g = rgb[:, :, 1]\n    b = rgb[:, :, 2]\n    blue_dom = (b > r + 3) & (b > g + 3)\n    green_dom = (g > r + 3) & (g > b + 3)\n    blue_count = np.count_nonzero(blue_dom)\n    green_count = np.count_nonzero(green_dom)\n    return float(blue_count / (green_count + eps))\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Mean gradient magnitude (texture strength) using grayscale; low values often indicate smooth water'\n    import numpy as np\n    import numpy as _np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = _np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    if gray.size == 0:\n        return 0.0\n    gy, gx = _np.gradient(gray)\n    mag = _np.sqrt(gx * gx + gy * gy)\n    return float(_np.mean(mag))\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Vertical reflection correlation between upper region and vertically flipped lower region (reflection indicator)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    h, w = image.shape[:2]\n    quarter = max(1, h // 4)\n    # use top quarter and bottom quarter\n    top = image[:quarter, :quarter * 2] if w >= quarter * 2 else image[:quarter, :]\n    bottom = image[-quarter:, :top.shape[1]]\n    if len(image.shape) == 3:\n        top_gray = np.mean(top, axis=2).astype(float)\n        bottom_gray = np.mean(bottom, axis=2).astype(float)\n    else:\n        top_gray = top.astype(float)\n        bottom_gray = bottom.astype(float)\n    bottom_flipped = bottom_gray[::-1, :]\n    # ensure same shape\n    min_r = min(top_gray.shape[0], bottom_flipped.shape[0])\n    min_c = min(top_gray.shape[1], bottom_flipped.shape[1])\n    if min_r == 0 or min_c == 0:\n        return 0.0\n    a = top_gray[:min_r, :min_c].flatten() - np.mean(top_gray[:min_r, :min_c])\n    b = bottom_flipped[:min_r, :min_c].flatten() - np.mean(bottom_flipped[:min_r, :min_c])\n    denom = np.sqrt(np.sum(a * a) * np.sum(b * b)) + eps\n    corr = float(np.sum(a * b) / denom)\n    return float(corr)\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Strength and extent of the strongest horizontal edge row (horizon-like structure)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    gy, _ = np.gradient(gray)\n    # compute row-wise average absolute vertical gradient\n    row_strength = np.mean(np.abs(gy), axis=1)\n    if row_strength.size == 0:\n        return 0.0\n    max_idx = int(np.argmax(row_strength))\n    max_val = float(row_strength[max_idx])\n    median_val = float(np.median(row_strength) + eps)\n    # measure how wide the strong edge is across columns at that row\n    row_abs = np.abs(gy[max_idx, :])\n    thr = max(1e-3, np.percentile(row_abs, 75))\n    span_frac = float(np.count_nonzero(row_abs >= thr) / (row_abs.size + eps))\n    # combine prominence and span into a single normalized score\n    score = (max_val / (median_val)) * span_frac\n    return float(score)\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Mean blue chroma for blue-dominant pixels: avg(max(0, B - max(R,G))) normalized by mean intensity'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if len(image.shape) == 2:\n        rgb = np.stack([image, image, image], axis=2).astype(float)\n    else:\n        rgb = image.astype(float)\n    r = rgb[:, :, 0].flatten()\n    g = rgb[:, :, 1].flatten()\n    b = rgb[:, :, 2].flatten()\n    mx_other = np.maximum(r, g)\n    blue_adv = np.maximum(0.0, b - mx_other)\n    mask = blue_adv > 0\n    if np.count_nonzero(mask) == 0:\n        return 0.0\n    mean_blue_adv = float(np.mean(blue_adv[mask]))\n    mean_intensity = float(np.mean((r + g + b) / 3.0) + eps)\n    return float(mean_blue_adv / mean_intensity)\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Fraction of small blocks (8x8 or adaptive) with very low variance (fine-scale smoothness)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    bs = 8\n    if h < bs or w < bs:\n        # fallback: use whole image variance\n        return float(1.0 if np.var(gray) < 1e-3 else 0.0)\n    bh = (h // bs) * bs\n    bw = (w // bs) * bs\n    trimmed = gray[:bh, :bw]\n    nh = bh // bs\n    nw = bw // bs\n    blocks = trimmed.reshape(nh, bs, nw, bs).swapaxes(1,2)\n    # compute variance per block\n    block_vars = np.var(blocks, axis=(2,3)).flatten()\n    global_var = np.var(gray) + eps\n    thr = global_var * 0.15\n    low_var_count = np.count_nonzero(block_vars < thr)\n    return float(low_var_count / (block_vars.size + eps))\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Fraction of vertical-edge energy relative to total edge energy (vertical vs total)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    gy, gx = np.gradient(gray)\n    abs_gx = np.abs(gx)\n    abs_gy = np.abs(gy)\n    total = np.sum(abs_gx) + np.sum(abs_gy) + eps\n    return float(np.sum(abs_gx) / total)\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Difference in mean blue between lower-center region and upper-center region (lower - upper)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if len(image.shape) == 2:\n        rgb = np.stack([image, image, image], axis=2).astype(float)\n    else:\n        rgb = image.astype(float)\n    h, w = rgb.shape[:2]\n    ch_w = max(1, w // 3)\n    # define upper-center and lower-center strips\n    upper = rgb[:h//3, w//2 - ch_w//2:w//2 + ch_w//2, :]\n    lower = rgb[-(h//3):, w//2 - ch_w//2:w//2 + ch_w//2, :]\n    if upper.size == 0 or lower.size == 0:\n        # fallback to global difference\n        meanB = float(np.mean(rgb[:, :, 2]))\n        mean_upper = meanB\n        return float(0.0)\n    meanB_upper = float(np.mean(upper[:, :, 2]))\n    meanB_lower = float(np.mean(lower[:, :, 2]))\n    return float((meanB_lower - meanB_upper) / (max(1.0, meanB_upper + eps)))\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Fraction of very bright specular pixels (top 0.5% intensity) that are blue-biased (glints)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        rgb = image.astype(float)\n        intensity = np.mean(rgb, axis=2)\n    else:\n        rgb = np.stack([image, image, image], axis=2).astype(float)\n        intensity = image.astype(float)\n    flat_int = intensity.flatten()\n    if flat_int.size == 0:\n        return 0.0\n    thr = np.percentile(flat_int, 99.5)\n    bright_mask = intensity >= thr\n    if np.count_nonzero(bright_mask) == 0:\n        return 0.0\n    r = rgb[:, :, 0]\n    g = rgb[:, :, 1]\n    b = rgb[:, :, 2]\n    blue_biased = (b > r + 5) & (b > g + 5)\n    selected = bright_mask & blue_biased\n    return float(np.count_nonzero(selected) / (np.count_nonzero(bright_mask) + eps))\n",
  "def feature(image: np.ndarray) -> float:\n    'Fraction of top-region pixels that are blue-dominant (detect sky/water at top)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if len(image.shape) == 2:\n        rgb = np.stack([image, image, image], axis=2).astype(float)\n    else:\n        rgb = image.astype(float)\n    h, w = rgb.shape[:2]\n    top_h = max(1, h // 4)\n    top = rgb[:top_h, :, :]\n    R = top[:, :, 0]\n    G = top[:, :, 1]\n    B = top[:, :, 2]\n    global_mean = float(np.mean(rgb))\n    mask = (B > R) & (B > G) & (B > global_mean * 0.9)\n    total = mask.size + eps\n    return float(np.count_nonzero(mask) / total)\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Fraction of rows dominated by blue (horizontal blue bands like water horizons)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if len(image.shape) == 2:\n        arr = np.stack([image, image, image], axis=2).astype(float)\n    else:\n        arr = image.astype(float)\n    h = arr.shape[0]\n    R = arr[:, :, 0].astype(float)\n    G = arr[:, :, 1].astype(float)\n    B = arr[:, :, 2].astype(float)\n    meanR = np.mean(R, axis=1)\n    meanG = np.mean(G, axis=1)\n    meanB = np.mean(B, axis=1)\n    blue_rows = (meanB > 1.05 * meanR) & (meanB > 1.05 * meanG)\n    return float(np.count_nonzero(blue_rows) / (h + eps))\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Normalized global gradient energy (texture level normalized by mean intensity)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    if gray.size == 0:\n        return 0.0\n    gy, gx = np.gradient(gray)\n    mag = np.sqrt(gx * gx + gy * gy)\n    mean_mag = float(np.mean(mag))\n    mean_int = float(np.mean(gray) + eps)\n    return float(mean_mag / mean_int)\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Absolute intensity contrast between center region and border, normalized'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if len(image.shape) == 2:\n        rgb = np.stack([image, image, image], axis=2).astype(float)\n    else:\n        rgb = image.astype(float)\n    h, w = rgb.shape[:2]\n    sr, sc = h // 4, w // 4\n    er, ec = h - sr, w - sc\n    center = rgb[sr:er, sc:ec, :] if (er > sr and ec > sc) else rgb\n    t = max(1, min(h, w) // 8)\n    top = rgb[:t, :, :]\n    bottom = rgb[-t:, :, :]\n    left = rgb[:, :t, :]\n    right = rgb[:, -t:, :]\n    border = np.concatenate([top.reshape(-1,3), bottom.reshape(-1,3), left.reshape(-1,3), right.reshape(-1,3)], axis=0) if rgb.size else np.zeros((1,3))\n    mean_center = float(np.mean(center)) if center.size else 0.0\n    mean_border = float(np.mean(border)) if border.size else 0.0\n    overall_mean = float(np.mean(rgb) + eps)\n    return float(abs(mean_center - mean_border) / overall_mean)\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Fraction of very bright pixels (specular highlights / glints) using top percentile'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    flat = gray.flatten()\n    if flat.size == 0:\n        return 0.0\n    thr = np.percentile(flat, 99.0)\n    cnt = np.count_nonzero(flat >= thr)\n    return float(cnt / (flat.size + eps))\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Horizontal centroid (0..1) of red-weighted pixels (where red channel is strong)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.5\n    if len(image.shape) == 2:\n        rgb = np.stack([image, image, image], axis=2).astype(float)\n    else:\n        rgb = image.astype(float)\n    h, w = rgb.shape[:2]\n    R = rgb[:, :, 0]\n    G = rgb[:, :, 1]\n    B = rgb[:, :, 2]\n    global_mean = float(np.mean(rgb) + eps)\n    mask = (R > G) & (R > B) & (R > global_mean * 0.6)\n    weights = (R * mask).astype(float)\n    s = float(np.sum(weights))\n    if s <= 0:\n        return 0.5\n    cols = np.arange(w).reshape(1, w)\n    centroid = float(np.sum(weights * cols) / (s + eps))\n    return float(centroid / max(1, w - 1))\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Fraction of local grayscale maxima (4-neighbor) \u2014 indicates many small bright objects'\n    import numpy as np\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    pad = np.pad(gray, ((1,1),(1,1)), mode='constant', constant_values=-1e9)\n    center = pad[1:-1,1:-1]\n    up = pad[:-2,1:-1]\n    down = pad[2:,1:-1]\n    left = pad[1:-1,:-2]\n    right = pad[1:-1,2:]\n    mask = (center > up) & (center > down) & (center > left) & (center > right)\n    return float(np.count_nonzero(mask) / (center.size + 1e-8))\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Fraction of image area composed of low-variance blocks (large uniform regions like water)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    bs = max(4, min(h, w) // 16) if min(h,w) >= 8 else min(h,w)\n    if bs <= 1 or h < bs or w < bs:\n        # fallback: single-image variance check\n        var = float(np.var(gray))\n        thr = np.percentile(gray.flatten(), 50.0) * 0.01 + 1e-6\n        return 1.0 if var < thr else 0.0\n    H0 = (h // bs) * bs\n    W0 = (w // bs) * bs\n    crop = gray[:H0, :W0]\n    if crop.size == 0:\n        return 0.0\n    blocks = crop.reshape(H0//bs, bs, W0//bs, bs)\n    blocks = blocks.swapaxes(1,2).reshape(-1, bs*bs)\n    vars = np.var(blocks, axis=1)\n    thr = np.percentile(vars, 30.0)\n    low_blocks = np.count_nonzero(vars <= thr)\n    area_low = low_blocks * (bs * bs)\n    return float(area_low / (h * w + eps))\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Approximate color temperature: (meanR+meanG)/meanB (higher => warmer tones)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if len(image.shape) == 2:\n        arr = np.stack([image, image, image], axis=2).astype(float)\n    else:\n        arr = image.astype(float)\n    meanR = float(np.mean(arr[:, :, 0]))\n    meanG = float(np.mean(arr[:, :, 1]))\n    meanB = float(np.mean(arr[:, :, 2]) + eps)\n    return float((meanR + meanG) / meanB)\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Vertical reflection score for blue channel: correlation between top and flipped bottom halves (0..1)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if len(image.shape) == 2:\n        blue = image.astype(float)\n    else:\n        blue = image.astype(float)[:, :, 2]\n    h = blue.shape[0]\n    if h < 4:\n        return 0.0\n    half = h // 2\n    top = blue[:half, :]\n    bottom = blue[-half:, :]\n    # make shapes equal\n    min_h = min(top.shape[0], bottom.shape[0])\n    top_c = top[:min_h, :].flatten()\n    bot_c = np.flipud(bottom[-min_h:, :]).flatten()\n    if top_c.size == 0:\n        return 0.0\n    top_c = top_c - np.mean(top_c)\n    bot_c = bot_c - np.mean(bot_c)\n    denom = (np.std(top_c) * np.std(bot_c) + eps)\n    corr = float(np.sum(top_c * bot_c) / (top_c.size * denom))\n    # clamp and map to 0..1\n    corr = max(-1.0, min(1.0, corr))\n    return float((corr + 1.0) / 2.0)\n",
  "def feature(image: np.ndarray) -> float:\n    'Fraction of top-quarter pixels that are strongly blue (sky/water indicator)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if len(image.shape) == 2:\n        # grayscale: no blue channel, return 0\n        return 0.0\n    rgb = image.astype(float)\n    h, w = rgb.shape[:2]\n    top_h = max(1, h // 4)\n    region = rgb[:top_h, :, :]\n    if region.size == 0:\n        return 0.0\n    R = region[:, :, 0]\n    G = region[:, :, 1]\n    B = region[:, :, 2]\n    global_mean = float(np.mean(rgb) + eps)\n    mask = (B > 1.1 * R) & (B > 1.1 * G) & (B > 0.5 * global_mean)\n    return float(np.count_nonzero(mask) / (mask.size + eps))\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Mean gradient magnitude in the center region (texture/edge strength)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    # convert to grayscale\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    sr, sc = h // 4, w // 4\n    er, ec = h - sr, w - sc\n    region = gray[sr:er, sc:ec] if (er > sr and ec > sc) else gray\n    if region.size == 0:\n        return 0.0\n    gy, gx = np.gradient(region)\n    mag = np.sqrt(gx * gx + gy * gy)\n    # normalize by region mean intensity to keep scale stable\n    norm = float(np.mean(region) + eps)\n    return float(np.mean(mag) / (norm + eps))\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Variance of approximate Laplacian across the image (overall texture measure)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    # first derivatives\n    gy, gx = np.gradient(gray)\n    # second derivatives\n    gyy, gyx = np.gradient(gy)\n    gxy, gxx = np.gradient(gx)\n    lap = gxx + gyy\n    # return variance normalized by mean intensity\n    norm = float(np.mean(np.abs(gray)) + eps)\n    return float(np.var(lap) / (norm + eps))\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Mean blue minus mean green across image (global blue vs green bias)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if len(image.shape) == 2:\n        # grayscale: no color contrast\n        return 0.0\n    rgb = image.astype(float)\n    meanB = float(np.mean(rgb[:, :, 2]))\n    meanG = float(np.mean(rgb[:, :, 1]))\n    meanInt = float(np.mean(np.mean(rgb, axis=2)) + eps)\n    return float((meanB - meanG) / (meanInt + eps))\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Horizontal blue-band score near top: long contiguous blue runs (sky/water band)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if len(image.shape) == 2:\n        return 0.0\n    rgb = image.astype(float)\n    h, w = rgb.shape[:2]\n    top_h = max(1, h // 3)\n    region = rgb[:top_h, :, :]\n    if region.size == 0:\n        return 0.0\n    R = region[:, :, 0]\n    G = region[:, :, 1]\n    B = region[:, :, 2]\n    global_mean = float(np.mean(rgb) + eps)\n    mask = (B > 1.05 * R) & (B > 1.05 * G) & (B > 0.45 * global_mean)\n    # for each row compute longest consecutive True run\n    max_run = 0\n    rows_with_any = 0\n    for row in mask:\n        arr = row.astype(int)\n        if arr.sum() > 0:\n            rows_with_any += 1\n            dif = np.diff(np.concatenate([[0], arr, [0]]))\n            starts = np.where(dif == 1)[0]\n            ends = np.where(dif == -1)[0]\n            if starts.size and ends.size:\n                lengths = ends - starts\n                max_run = max(max_run, int(np.max(lengths)))\n    max_run_frac = float(max_run) / float(w + eps)\n    row_frac = float(rows_with_any) / float(top_h + eps)\n    return float(max_run_frac * row_frac)\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Bottom-minus-top green fraction (positive if more green at bottom)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if len(image.shape) == 2:\n        return 0.0\n    rgb = image.astype(float)\n    h, w = rgb.shape[:2]\n    half = max(1, h // 2)\n    top = rgb[:half, :, :]\n    bottom = rgb[-half:, :, :]\n    global_mean = float(np.mean(rgb) + eps)\n    def green_frac(region):\n        if region.size == 0:\n            return 0.0\n        R = region[:, :, 0]\n        G = region[:, :, 1]\n        B = region[:, :, 2]\n        mask = (G > R) & (G > B) & (G > 0.8 * global_mean)\n        return float(np.count_nonzero(mask) / (mask.size + eps))\n    return float(green_frac(bottom) - green_frac(top))\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Normalized color entropy in center region (higher -> more diverse colors)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    # work with RGB buckets (4x4x4 -> 64 bins) for speed\n    if len(image.shape) == 2:\n        rgb = np.stack([image, image, image], axis=2).astype(float)\n    else:\n        rgb = image.astype(float)\n    h, w = rgb.shape[:2]\n    sr, sc = h // 4, w // 4\n    er, ec = h - sr, w - sc\n    region = rgb[sr:er, sc:ec, :] if (er > sr and ec > sc) else rgb\n    if region.size == 0:\n        return 0.0\n    r = region[:, :, 0].astype(int) // 64\n    g = region[:, :, 1].astype(int) // 64\n    b = region[:, :, 2].astype(int) // 64\n    codes = (r * 16 + g * 4 + b).flatten()\n    hist = np.bincount(codes, minlength=64).astype(float)\n    probs = hist / (np.sum(hist) + eps)\n    probs = probs[probs > 0]\n    entropy = -np.sum(probs * np.log(probs + eps))\n    # normalize by max entropy log(64)\n    return float(entropy / (np.log(64.0) + eps))\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Euclidean distance from mean image color to pure green (0..1, lower means greener)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if len(image.shape) == 2:\n        # grayscale: treat mean as gray color\n        m = float(np.mean(image))\n        mean_color = np.array([m, m, m], dtype=float)\n    else:\n        rgb = image.astype(float)\n        mean_color = np.mean(rgb.reshape(-1, 3), axis=0)\n    green = np.array([0.0, 255.0, 0.0], dtype=float)\n    dist = np.linalg.norm(mean_color - green)\n    # normalize by maximum possible distance\n    maxd = np.linalg.norm(np.array([255.0, 255.0, 255.0]))\n    return float(dist / (maxd + eps))\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Relative brightness contrast: center mean brightness minus border mean, normalized'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    sr, sc = h // 4, w // 4\n    er, ec = h - sr, w - sc\n    center = gray[sr:er, sc:ec] if (er > sr and ec > sc) else gray\n    t = max(1, min(h, w) // 8)\n    top = gray[:t, :]\n    bottom = gray[-t:, :]\n    left = gray[:, :t]\n    right = gray[:, -t:]\n    border_parts = [top, bottom, left, right]\n    border = np.concatenate([p.reshape(-1) for p in border_parts]) if gray.size else np.array([0.0])\n    if center.size == 0 or border.size == 0:\n        return 0.0\n    center_mean = float(np.mean(center))\n    border_mean = float(np.mean(border))\n    denom = (abs(center_mean) + abs(border_mean) + eps)\n    return float((center_mean - border_mean) / denom)\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Bright-pixel centeredness: 1.0 if top bright pixels are centered, 0 if far from center'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    flat = gray.flatten()\n    if flat.size == 0:\n        return 0.0\n    thr = np.percentile(flat, 90)\n    coords = np.argwhere(gray >= thr)\n    if coords.size == 0:\n        return 0.0\n    cy, cx = np.mean(coords, axis=0)\n    center_y, center_x = (h - 1) / 2.0, (w - 1) / 2.0\n    dist = np.sqrt((cy - center_y) ** 2 + (cx - center_x) ** 2)\n    max_dist = np.sqrt(center_y ** 2 + center_x ** 2) + eps\n    score = 1.0 - (dist / max_dist)\n    return float(max(0.0, min(1.0, score)))\n",
  "def feature(image: np.ndarray) -> float:\n    'Fractional height of the tallest horizontal blue band (longest contiguous rows with many blue pixels)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if len(image.shape) == 2:\n        rgb = np.stack([image, image, image], axis=2).astype(float)\n    else:\n        rgb = image.astype(float)\n    h, w = rgb.shape[:2]\n    R = rgb[:, :, 0]\n    G = rgb[:, :, 1]\n    B = rgb[:, :, 2]\n    blue_mask = (B > G * 1.05) & (B > R * 1.05)\n    # per-row fraction of blue pixels\n    row_frac = np.sum(blue_mask, axis=1) / (w + eps)\n    thr = 0.3  # require at least 30% of row to be blue to count as band\n    runs = 0\n    max_run = 0\n    for v in row_frac:\n        if v > thr:\n            runs += 1\n        else:\n            if runs > max_run:\n                max_run = runs\n            runs = 0\n    if runs > max_run:\n        max_run = runs\n    return float(max_run / (h + eps))\n\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Vertical centroid of blue-dominant pixels (0.0 top, 1.0 bottom)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.5\n    if len(image.shape) == 2:\n        rgb = np.stack([image, image, image], axis=2).astype(float)\n    else:\n        rgb = image.astype(float)\n    h = rgb.shape[0]\n    R = rgb[:, :, 0].flatten()\n    G = rgb[:, :, 1].flatten()\n    B = rgb[:, :, 2].flatten()\n    mask = (B > G * 1.03) & (B > R * 1.03)\n    if np.count_nonzero(mask) == 0:\n        return 0.5\n    rows = np.repeat(np.arange(h), rgb.shape[1]).flatten()\n    rows_masked = rows[mask]\n    centroid = float(np.mean(rows_masked))\n    return float(centroid / (max(1, h - 1) + eps))\n\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Fraction of strong edges whose gradient direction is near-horizontal (|angle| < 30 degrees)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    gy, gx = np.gradient(gray)\n    mag = np.sqrt(gx * gx + gy * gy)\n    if mag.size == 0:\n        return 0.0\n    thr = np.percentile(mag, 75)\n    strong = mag > (thr + eps)\n    # angle in radians; horizontal gradient means gy near 0 -> angle near 0 or pi\n    angles = np.arctan2(gy, gx)\n    # normalize angles to [-pi/2, pi/2] by taking absolute sine? simpler: take absolute minimal angle to 0 or pi\n    ang = np.abs(np.arctan2(np.sin(angles), np.cos(angles)))  # now in [0, pi]\n    # choose closeness to 0 or pi -> map to min(angle, pi-angle)\n    ang = np.minimum(ang, np.pi - ang)\n    thresh = np.deg2rad(30.0)\n    horiz = ang < thresh\n    num_strong = np.count_nonzero(strong)\n    if num_strong == 0:\n        return 0.0\n    return float(np.count_nonzero(strong & horiz) / (num_strong + eps))\n\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Variance across rows of the per-row blue-minus-green mean (high means vertical color layering)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if len(image.shape) == 2:\n        rgb = np.stack([image, image, image], axis=2).astype(float)\n    else:\n        rgb = image.astype(float)\n    h = rgb.shape[0]\n    B = rgb[:, :, 2].astype(float)\n    G = rgb[:, :, 1].astype(float)\n    row_signal = np.mean(B - G, axis=1)\n    var = float(np.var(row_signal))\n    # normalize by overall mean absolute signal to keep scale stable\n    norm = float(np.mean(np.abs(row_signal)) + eps)\n    return float(var / (norm + eps))\n\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Ratio of mean blue intensity in top third to bottom third of image'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 1.0\n    if len(image.shape) == 2:\n        rgb = np.stack([image, image, image], axis=2).astype(float)\n    else:\n        rgb = image.astype(float)\n    h = rgb.shape[0]\n    t = max(1, h // 3)\n    top = rgb[:t, :, 2].astype(float)\n    bottom = rgb[-t:, :, 2].astype(float)\n    if top.size == 0 or bottom.size == 0:\n        return 1.0\n    mean_top = float(np.mean(top))\n    mean_bottom = float(np.mean(bottom))\n    return float(mean_top / (mean_bottom + eps))\n\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Center-region Laplacian standard deviation (texture roughness in the center)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    sr, sc = h // 4, w // 4\n    er, ec = h - sr, w - sc\n    if er <= sr or ec <= sc:\n        region = gray\n    else:\n        region = gray[sr:er, sc:ec]\n    if region.size == 0:\n        return 0.0\n    gy, gx = np.gradient(region)\n    gyy, gyx = np.gradient(gy)\n    gxy, gxx = np.gradient(gx)\n    lap = gxx + gyy\n    return float(np.std(lap) + eps)\n\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Fraction of rows that contain a nontrivial amount of green-dominant pixels (vegetation vertical coverage)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if len(image.shape) == 2:\n        rgb = np.stack([image, image, image], axis=2).astype(float)\n    else:\n        rgb = image.astype(float)\n    h, w = rgb.shape[:2]\n    R = rgb[:, :, 0]\n    G = rgb[:, :, 1]\n    B = rgb[:, :, 2]\n    green_mask = (G > R) & (G > B)\n    row_frac = np.sum(green_mask, axis=1) / (w + eps)\n    # consider a row green-covered if >5% pixels are green-dominant\n    cover_rows = np.count_nonzero(row_frac > 0.05)\n    return float(cover_rows / (h + eps))\n\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Center-region bright-spot contrast: (mean of top10% - mean of others) normalized by mean'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    sr, sc = h // 4, w // 4\n    er, ec = h - sr, w - sc\n    region = gray[sr:er, sc:ec] if (er > sr and ec > sc) else gray\n    vals = region.flatten()\n    if vals.size == 0:\n        return 0.0\n    k = max(1, int(0.1 * vals.size))\n    sorted_vals = np.sort(vals)\n    top_mean = float(np.mean(sorted_vals[-k:]))\n    rest_mean = float(np.mean(sorted_vals[:-k]) if vals.size - k > 0 else float(np.mean(sorted_vals[-k:])))\n    denom = float(np.mean(vals) + eps)\n    return float((top_mean - rest_mean) / (denom + eps))\n\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Difference in color variance (chroma variance) between center and border regions'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if len(image.shape) == 2:\n        rgb = np.stack([image, image, image], axis=2).astype(float)\n    else:\n        rgb = image.astype(float)\n    h, w = rgb.shape[:2]\n    sr, sc = h // 4, w // 4\n    er, ec = h - sr, w - sc\n    center = rgb[sr:er, sc:ec, :] if (er > sr and ec > sc) else rgb\n    t = max(1, min(h, w) // 10)\n    top = rgb[:t, :, :]\n    bottom = rgb[-t:, :, :]\n    left = rgb[:, :t, :]\n    right = rgb[:, -t:, :]\n    border = np.concatenate([top.reshape(-1,3), bottom.reshape(-1,3), left.reshape(-1,3), right.reshape(-1,3)], axis=0) if rgb.size else np.zeros((1,3))\n    def chroma_var(arr):\n        if arr.size == 0:\n            return 0.0\n        mx = np.max(arr, axis=1)\n        mn = np.min(arr, axis=1)\n        chroma = mx - mn\n        return float(np.var(chroma))\n    cvar = chroma_var(center.reshape(-1,3))\n    bvar = chroma_var(border)\n    return float((cvar - bvar) / (bvar + eps))\n\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Proportion of top-half pixels that are strongly bluish (sky-like) relative to that half'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if len(image.shape) == 2:\n        rgb = np.stack([image, image, image], axis=2).astype(float)\n    else:\n        rgb = image.astype(float)\n    h = rgb.shape[0]\n    mid = max(1, h // 2)\n    top = rgb[:mid, :, :].astype(float)\n    if top.size == 0:\n        return 0.0\n    R = top[:, :, 0]\n    G = top[:, :, 1]\n    B = top[:, :, 2]\n    global_mean = float(np.mean(rgb) + eps)\n    bluish = (B > R * 1.05) & (B > G * 1.05) & (B > global_mean * 0.55)\n    return float(np.count_nonzero(bluish) / (top.shape[0] * top.shape[1] + eps))\n",
  "def feature(image: np.ndarray) -> float:\n    'Fraction of pixels in the lower third that are strongly blue-biased'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if len(image.shape) == 2:\n        rgb = np.stack([image, image, image], axis=2).astype(float)\n    else:\n        rgb = image.astype(float)\n    h, w = rgb.shape[:2]\n    start = (2 * h) // 3\n    region = rgb[start:, :, :] if start < h else rgb\n    if region.size == 0:\n        return 0.0\n    r = region[:, :, 0]\n    g = region[:, :, 1]\n    b = region[:, :, 2]\n    blue_mask = (b > g + 8) & (b > r + 8)  # absolute bias to catch water/sky blue\n    return float(np.count_nonzero(blue_mask) / (region.shape[0] * region.shape[1] + eps))\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Stddev of discrete Laplacian on the green channel in the central region (vegetation texture)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if len(image.shape) == 2:\n        rgb = np.stack([image, image, image], axis=2).astype(float)\n    else:\n        rgb = image.astype(float)\n    h, w = rgb.shape[:2]\n    sr, sc = h // 4, w // 4\n    er, ec = h - sr, w - sc\n    region = rgb[sr:er, sc:ec, :] if (er > sr and ec > sc) else rgb\n    if region.size == 0:\n        return 0.0\n    G = region[:, :, 1].astype(float)\n    up = np.roll(G, -1, axis=0)\n    down = np.roll(G, 1, axis=0)\n    left = np.roll(G, -1, axis=1)\n    right = np.roll(G, 1, axis=1)\n    lap = 4.0 * G - (up + down + left + right)\n    return float(np.std(lap) if lap.size else 0.0)\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Fraction of strong edges that are vertical (vertical-edge dominance)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    gy, gx = np.gradient(gray)\n    mag = np.sqrt(gx * gx + gy * gy)\n    if mag.size == 0:\n        return 0.0\n    thr = np.percentile(mag, 75) if mag.size else 0.0\n    strong_mask = mag > (thr + eps)\n    if np.count_nonzero(strong_mask) == 0:\n        return 0.0\n    orient_frac = np.where(mag > 0, np.abs(gx) / (mag + eps), 0.0)  # 1.0 -> vertical\n    vert_strong = np.count_nonzero((orient_frac > 0.8) & strong_mask)\n    return float(vert_strong / (np.count_nonzero(strong_mask) + eps))\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Normalized contrast between top and bottom regions (top_mean - bottom_mean) / (sum)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        intensity = np.mean(image.astype(float), axis=2)\n    else:\n        intensity = image.astype(float)\n    h = intensity.shape[0]\n    t = max(1, h // 5)\n    top = intensity[:t, :]\n    bottom = intensity[-t:, :]\n    if top.size == 0 or bottom.size == 0:\n        return 0.0\n    top_mean = float(np.mean(top))\n    bottom_mean = float(np.mean(bottom))\n    return float((top_mean - bottom_mean) / (abs(top_mean) + abs(bottom_mean) + eps))\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Normalized skew-like measure of blue minus green: (mean - median) / std'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if len(image.shape) == 2:\n        rgb = np.stack([image, image, image], axis=2).astype(float)\n    else:\n        rgb = image.astype(float)\n    b = rgb[:, :, 2].flatten()\n    g = rgb[:, :, 1].flatten()\n    diff = (b - g)\n    if diff.size == 0:\n        return 0.0\n    m = float(np.mean(diff))\n    med = float(np.median(diff))\n    sd = float(np.std(diff) + eps)\n    return float((m - med) / sd)\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Approximate entropy of per-pixel chroma (max-min) using a small histogram'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if len(image.shape) == 2:\n        rgb = np.stack([image, image, image], axis=2).astype(float)\n    else:\n        rgb = image.astype(float)\n    maxc = np.max(rgb, axis=2).flatten()\n    minc = np.min(rgb, axis=2).flatten()\n    chroma = maxc - minc\n    if chroma.size == 0:\n        return 0.0\n    hist, _ = np.histogram(chroma, bins=16, range=(0.0, float(np.max(chroma) + eps)))\n    p = hist.astype(float) / (np.sum(hist) + eps)\n    entropy = -np.sum(np.where(p > 0, p * np.log(p + eps), 0.0))\n    return float(entropy)\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Longest contiguous run of blue-biased pixels in the middle row normalized by width'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if len(image.shape) == 2:\n        row_rgb = np.stack([image, image, image], axis=2).astype(float)\n    else:\n        row_rgb = image.astype(float)\n    h, w = row_rgb.shape[:2]\n    mid = h // 2\n    row = row_rgb[mid, :, :] if h > 0 else row_rgb.reshape(-1, 3)\n    if row.size == 0:\n        return 0.0\n    r = row[:, 0]\n    g = row[:, 1]\n    b = row[:, 2]\n    blue_mask = (b > g + 6) & (b > r + 6)\n    max_run = 0\n    cur = 0\n    for v in blue_mask:\n        if v:\n            cur += 1\n            if cur > max_run:\n                max_run = cur\n        else:\n            cur = 0\n    return float(max_run / (w + eps))\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Mean saturation of border pixels (approx (max-min)/max) to capture scene colorfulness at edges'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if len(image.shape) == 2:\n        rgb = np.stack([image, image, image], axis=2).astype(float)\n    else:\n        rgb = image.astype(float)\n    h, w = rgb.shape[:2]\n    t = max(1, min(h, w) // 10)\n    top = rgb[:t, :, :].reshape(-1, 3)\n    bottom = rgb[-t:, :, :].reshape(-1, 3)\n    left = rgb[:, :t, :].reshape(-1, 3)\n    right = rgb[:, -t:, :].reshape(-1, 3)\n    border = np.concatenate([top, bottom, left, right], axis=0) if rgb.size else np.zeros((1,3))\n    if border.size == 0:\n        return 0.0\n    mx = np.max(border, axis=1)\n    mn = np.min(border, axis=1)\n    sat = (mx - mn) / (mx + eps)\n    return float(np.mean(sat))\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Fraction of very bright pixels whose edge orientation is predominantly vertical (bright vertical glints)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        rgb = image.astype(float)\n        intensity = np.mean(rgb, axis=2)\n    else:\n        rgb = np.stack([image, image, image], axis=2).astype(float)\n        intensity = image.astype(float)\n    flat = intensity.flatten()\n    if flat.size == 0:\n        return 0.0\n    thr = np.percentile(flat, 99)\n    bright_mask = intensity >= thr\n    if np.count_nonzero(bright_mask) == 0:\n        return 0.0\n    gy, gx = np.gradient(intensity)\n    mag = np.sqrt(gx * gx + gy * gy) + eps\n    vert_orient = (np.abs(gx) / mag) > 0.8\n    selected = bright_mask & vert_orient\n    return float(np.count_nonzero(selected) / (np.count_nonzero(bright_mask) + eps))\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Normalized vertical centroid (0..1) of blue-dominant pixels (where blue is strongest) in the image'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.5\n    if len(image.shape) == 2:\n        rgb = np.stack([image, image, image], axis=2).astype(float)\n    else:\n        rgb = image.astype(float)\n    h, w = rgb.shape[:2]\n    r = rgb[:, :, 0]\n    g = rgb[:, :, 1]\n    b = rgb[:, :, 2]\n    blue_mask = (b > g + 5) & (b > r + 5)\n    count = np.count_nonzero(blue_mask)\n    if count == 0:\n        return 0.5\n    rows = np.arange(h).reshape(h, 1)\n    weighted = np.sum(rows * blue_mask.astype(float))\n    return float((weighted / (count + eps)) / max(1, h - 1))\n",
  "def feature(image: np.ndarray) -> float:\n    'Fraction of blue-like pixels in the bottom third of the image (water pool indicator)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    # ensure RGB\n    if len(image.shape) == 2:\n        rgb = np.stack([image, image, image], axis=2).astype(float)\n    else:\n        rgb = image.astype(float)\n    h, w = rgb.shape[:2]\n    start = (2 * h) // 3\n    region = rgb[start:h, :, :] if h - start > 0 else rgb\n    if region.size == 0:\n        return 0.0\n    R = region[:, :, 0]\n    G = region[:, :, 1]\n    B = region[:, :, 2]\n    intensity = (R + G + B) / 3.0 + eps\n    blue_like = (B > R) & (B > G) & (B > 0.6 * intensity)\n    return float(np.count_nonzero(blue_like) / (blue_like.size + eps))\n\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Normalized vertical centroid of blue intensity (0=top,1=bottom)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.5\n    if len(image.shape) == 2:\n        B = image.astype(float)\n    else:\n        B = image[:, :, 2].astype(float)\n    h = B.shape[0]\n    if B.size == 0:\n        return 0.5\n    rows = np.arange(h).reshape(-1, 1)\n    total = np.sum(B) + eps\n    centroid = float(np.sum(rows * np.sum(B, axis=1).reshape(-1, 1)) / total)  # sum(rows*row_sum)/total\n    # centroid normalized 0..1\n    return float(centroid / float(max(1, h - 1)))\n\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Mean blue difference between bottom third and top third normalized by overall intensity'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if len(image.shape) == 2:\n        rgb = np.stack([image, image, image], axis=2).astype(float)\n    else:\n        rgb = image.astype(float)\n    h = rgb.shape[0]\n    if h < 3:\n        # fall back to simple difference\n        meanB = float(np.mean(rgb[:, :, 2]))\n        meanI = float(np.mean(rgb) + eps)\n        return float((meanB - meanI) / meanI)\n    top = rgb[:h // 3, :, 2].astype(float)\n    bottom = rgb[(2 * h) // 3:, :, 2].astype(float)\n    mean_top = float(np.mean(top)) if top.size else 0.0\n    mean_bottom = float(np.mean(bottom)) if bottom.size else 0.0\n    overall = float(np.mean(rgb) + eps)\n    return float((mean_bottom - mean_top) / overall)\n\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Ratio of gradient energy inside center region to gradient energy in border (center-focus sharpness)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    if gray.size == 0:\n        return 0.0\n    gy, gx = np.gradient(gray)\n    mag = np.sqrt(gx * gx + gy * gy)\n    sr, sc = h // 4, w // 4\n    er, ec = h - sr, w - sc\n    center = mag[sr:er, sc:ec] if (er > sr and ec > sc) else mag\n    # border defined as union of top/bottom/left/right strips of thickness t\n    t = max(1, min(h, w) // 8)\n    top = mag[:t, :] if t < h else np.zeros((0,))\n    bottom = mag[-t:, :] if t < h else np.zeros((0,))\n    left = mag[:, :t] if t < w else np.zeros((0,))\n    right = mag[:, -t:] if t < w else np.zeros((0,))\n    border_vals = np.concatenate([top.flatten(), bottom.flatten(), left.flatten(), right.flatten()]) if mag.size else np.zeros((0,))\n    center_energy = float(np.sum(center))\n    border_energy = float(np.sum(border_vals) + eps)\n    return float(center_energy / border_energy)\n\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Vertical edge dominance (sum |gx| / (sum |gy| + eps))'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 1.0\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    if gray.size == 0:\n        return 1.0\n    gy, gx = np.gradient(gray)\n    sum_vert = float(np.sum(np.abs(gx)))\n    sum_horiz = float(np.sum(np.abs(gy)))\n    return float(sum_vert / (sum_horiz + eps))\n\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Fraction of pixels that are both bright and blue (specular blue highlights)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if len(image.shape) == 2:\n        rgb = np.stack([image, image, image], axis=2).astype(float)\n    else:\n        rgb = image.astype(float)\n    R = rgb[:, :, 0]\n    G = rgb[:, :, 1]\n    B = rgb[:, :, 2]\n    intensity = (R + G + B) / 3.0\n    if intensity.size == 0:\n        return 0.0\n    thr = np.percentile(intensity.flatten(), 95) if intensity.size else np.max(intensity)\n    mask = (B > R) & (B > G) & (intensity > thr)\n    return float(np.count_nonzero(mask) / (mask.size + eps))\n\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Proportion of image columns that contain any colorful pixels (color horizontal spread)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    import numpy as np\n    if len(image.shape) == 2:\n        # grayscale has no colorful pixels\n        return 0.0\n    rgb = image.astype(float)\n    r = rgb[:, :, 0]\n    g = rgb[:, :, 1]\n    b = rgb[:, :, 2]\n    mx = np.maximum(np.maximum(r, g), b)\n    mn = np.minimum(np.minimum(r, g), b)\n    sat = (mx - mn) / (mx + 1e-8)\n    h, w = sat.shape\n    if sat.size == 0:\n        return 0.0\n    col_has = np.any(sat > 0.25, axis=0)\n    return float(np.count_nonzero(col_has) / float(max(1, w)))\n\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Ratio of green variance to blue variance in central region (vegetation texture vs water)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if len(image.shape) == 2:\n        # grayscale: no green/blue distinction\n        return 0.0\n    rgb = image.astype(float)\n    h, w = rgb.shape[:2]\n    sr, sc = h // 4, w // 4\n    er, ec = h - sr, w - sc\n    region = rgb[sr:er, sc:ec, :] if (er > sr and ec > sc) else rgb\n    if region.size == 0:\n        return 0.0\n    G = region[:, :, 1].flatten()\n    B = region[:, :, 2].flatten()\n    varG = float(np.var(G))\n    varB = float(np.var(B) + eps)\n    return float(varG / varB)\n\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Horizontal symmetry score (1.0 = perfectly symmetric left-right), based on grayscale mirror similarity'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.5\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    if gray.size == 0:\n        return 0.5\n    mid = w // 2\n    left = gray[:, :mid]\n    # create right cropped to same width as left (mirror)\n    if w % 2 == 0:\n        right = gray[:, mid:]\n    else:\n        right = gray[:, mid+1:]\n    # flip right horizontally\n    right_flipped = np.fliplr(right)\n    # if widths differ, crop to min\n    minw = min(left.shape[1], right_flipped.shape[1]) if left.size and right_flipped.size else 0\n    if minw == 0:\n        return 0.5\n    left_crop = left[:, :minw]\n    right_crop = right_flipped[:, :minw]\n    diff = np.abs(left_crop - right_crop)\n    mean_diff = float(np.mean(diff))\n    # normalize by image intensity range to get 0..1\n    rng = float(np.max(gray) - np.min(gray) + eps)\n    norm_diff = mean_diff / rng\n    # convert to symmetry score: 1 - normalized difference, clamp 0..1\n    score = 1.0 - np.clip(norm_diff, 0.0, 1.0)\n    return float(score)\n\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Gradient orientation coherence: normalized magnitude of mean gradient unit vector (1=aligned orientations)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    if gray.size == 0:\n        return 0.0\n    gy, gx = np.gradient(gray)\n    mag = np.sqrt(gx * gx + gy * gy)\n    # ignore very small magnitudes\n    mask = mag > (np.percentile(mag.flatten(), 25) * 0.1 + eps)\n    if np.count_nonzero(mask) == 0:\n        return 0.0\n    ux = gx[mask] / (mag[mask] + eps)\n    uy = gy[mask] / (mag[mask] + eps)\n    # mean unit vector length (coherence)\n    mean_ux = float(np.mean(ux))\n    mean_uy = float(np.mean(uy))\n    coherence = np.sqrt(mean_ux * mean_ux + mean_uy * mean_uy)\n    # coherence is between 0 and 1\n    return float(np.clip(coherence, 0.0, 1.0))\n",
  "def feature(image: np.ndarray) -> float:\n    'Fraction of bright smooth highlights (specular-like spots)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    # convert to grayscale intensity\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    if h * w == 0:\n        return 0.0\n    # bright threshold and gradient to select smooth bright spots\n    bright_thr = np.percentile(gray, 95)\n    gy, gx = np.gradient(gray)\n    mag = np.sqrt(gx * gx + gy * gy)\n    # smooth if gradient below lower 30th percentile\n    smooth_thr = np.percentile(mag, 30) if mag.size else 0.0\n    mask = (gray >= bright_thr - eps) & (mag <= smooth_thr + eps)\n    return float(np.count_nonzero(mask) / (h * w + eps))\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Concentration of strong edges aligned with horizontal lines (edge orientation)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    gy, gx = np.gradient(gray)\n    mag = np.sqrt(gx * gx + gy * gy)\n    if mag.size == 0:\n        return 0.0\n    thr = np.percentile(mag, 75)\n    strong = mag > thr + eps\n    # orientation of gradient; horizontal image edges produce vertical gradient (~+/- pi/2)\n    orient = np.arctan2(gy, gx)\n    angle_dist = np.abs(np.abs(orient) - np.pi / 2.0)\n    # consider edges within 20 degrees (~0.35 rad) of vertical gradient => horizontal edges\n    deg_thresh = 20.0 * np.pi / 180.0\n    horiz_edges = strong & (angle_dist <= deg_thresh + eps)\n    total_strong = np.count_nonzero(strong)\n    if total_strong == 0:\n        return 0.0\n    return float(np.count_nonzero(horiz_edges) / (total_strong + eps))\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Relative difference of blue between top and bottom thirds (top - bottom) / sum'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if len(image.shape) == 2:\n        rgb = np.stack([image, image, image], axis=2).astype(float)\n    else:\n        rgb = image.astype(float)\n    h, w = rgb.shape[:2]\n    if h == 0:\n        return 0.0\n    third = max(1, h // 3)\n    top = rgb[0:third, :, 2]\n    bottom = rgb[h - third:h, :, 2]\n    mean_top = float(np.mean(top)) if top.size else 0.0\n    mean_bottom = float(np.mean(bottom)) if bottom.size else 0.0\n    return float((mean_top - mean_bottom) / (mean_top + mean_bottom + eps))\n\n",
  "def feature(image: np.ndarray) -> float:\n    'High-frequency energy ratio in 2D FFT (texture vs smoothness)'\n    import numpy as np\n    eps = 1e-12\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    # compute power spectrum\n    F = np.fft.fftshift(np.fft.fft2(gray))\n    P = np.abs(F) ** 2\n    # radius grid\n    cy, cx = h // 2, w // 2\n    y = np.arange(h) - cy\n    x = np.arange(w) - cx\n    X, Y = np.meshgrid(x, y)\n    R = np.sqrt(X * X + Y * Y)\n    max_r = float(np.max(R)) + eps\n    # high-frequency defined as > 25% of max radius\n    mask_high = R >= (0.25 * max_r)\n    total = float(np.sum(P)) + eps\n    high = float(np.sum(P[mask_high]))\n    return float(high / total)\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Variance across vertical stripe means for the green channel (vertical color variation)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if len(image.shape) == 2:\n        green = image.astype(float)\n    else:\n        green = image[:, :, 1].astype(float)\n    h, w = green.shape[:2]\n    if h * w == 0:\n        return 0.0\n    # split into up to 8 vertical stripes\n    stripes = min(8, max(1, w))\n    widths = [w // stripes] * stripes\n    rem = w - sum(widths)\n    for i in range(rem):\n        widths[i] += 1\n    means = []\n    col = 0\n    for wd in widths:\n        region = green[:, col:col + wd]\n        if region.size:\n            means.append(float(np.mean(region)))\n        col += wd\n    if len(means) == 0:\n        return 0.0\n    var_means = float(np.var(np.array(means)))\n    mean_of_means = float(np.mean(np.array(means)) + eps)\n    return float(var_means / (mean_of_means + eps))\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Number of prominently represented dominant color channels (R/G/B) normalized to [0,1]'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if len(image.shape) == 2:\n        rgb = np.stack([image, image, image], axis=2).astype(float)\n    else:\n        rgb = image.astype(float)\n    h, w = rgb.shape[:2]\n    if h * w == 0:\n        return 0.0\n    R = rgb[:, :, 0].flatten()\n    G = rgb[:, :, 1].flatten()\n    B = rgb[:, :, 2].flatten()\n    # determine which channel is dominant per pixel\n    dom = np.argmax(np.stack([R, G, B], axis=1), axis=1)\n    counts = np.bincount(dom, minlength=3).astype(float)\n    proportions = counts / (R.size + eps)\n    # count channels that exceed 5% area\n    prominent = np.count_nonzero(proportions > 0.05)\n    return float(prominent / 3.0)\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Fraction of low-saturation pixels (desaturated areas like water/sky)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if len(image.shape) == 2:\n        rgb = np.stack([image, image, image], axis=2).astype(float)\n    else:\n        rgb = image.astype(float)\n    r = rgb[:, :, 0].astype(float)\n    g = rgb[:, :, 1].astype(float)\n    b = rgb[:, :, 2].astype(float)\n    mx = np.maximum(np.maximum(r, g), b)\n    mn = np.minimum(np.minimum(r, g), b)\n    sat = (mx - mn) / (mx + eps)\n    low_sat_mask = sat < 0.12\n    return float(np.count_nonzero(low_sat_mask) / (sat.size + eps))\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Relative green prominence in the bottom-center region compared to overall intensity'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if len(image.shape) == 2:\n        rgb = np.stack([image, image, image], axis=2).astype(float)\n    else:\n        rgb = image.astype(float)\n    h, w = rgb.shape[:2]\n    if h * w == 0:\n        return 0.0\n    bh = max(1, h // 3)\n    bw = max(1, w // 3)\n    sr = h - bh\n    sc = (w - bw) // 2\n    region = rgb[sr:h, sc:sc + bw, :]\n    mean_green_region = float(np.mean(region[:, :, 1])) if region.size else 0.0\n    mean_intensity_overall = float(np.mean(np.mean(rgb, axis=2)) + eps)\n    return float((mean_green_region / (mean_intensity_overall + eps)))\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Centering score of high-contrast pixels (1.0 = concentrated at image center)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    if h * w == 0:\n        return 0.0\n    gy, gx = np.gradient(gray)\n    mag = np.sqrt(gx * gx + gy * gy)\n    thr = np.percentile(mag, 80) if mag.size else 0.0\n    mask = mag > thr + eps\n    if np.count_nonzero(mask) == 0:\n        return 0.0\n    ys, xs = np.nonzero(mask)\n    weights = mag[ys, xs].astype(float)\n    sum_w = np.sum(weights) + eps\n    cy = np.sum(ys * weights) / sum_w\n    cx = np.sum(xs * weights) / sum_w\n    # distance normalized by half-diagonal (so centered -> 0 dist -> score 1)\n    center_y, center_x = (h - 1) / 2.0, (w - 1) / 2.0\n    dist = np.sqrt((cy - center_y) ** 2 + (cx - center_x) ** 2)\n    half_diag = 0.5 * np.sqrt(h * h + w * w) + eps\n    score = 1.0 - (dist / half_diag)\n    return float(max(0.0, min(1.0, score)))\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Fraction of border pixels that are blue-dominant (captures water/sky framing)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if len(image.shape) == 2:\n        rgb = np.stack([image, image, image], axis=2).astype(float)\n    else:\n        rgb = image.astype(float)\n    h, w = rgb.shape[:2]\n    if h * w == 0:\n        return 0.0\n    bw = max(1, int(min(h, w) * 0.05))\n    top = rgb[0:bw, :, :]\n    bottom = rgb[h - bw:h, :, :]\n    left = rgb[:, 0:bw, :]\n    right = rgb[:, w - bw:w, :]\n    # combine border regions (may overlap at corners but that's fine)\n    border = np.concatenate([top.reshape(-1, 3), bottom.reshape(-1, 3),\n                             left.reshape(-1, 3), right.reshape(-1, 3)], axis=0)\n    if border.size == 0:\n        return 0.0\n    R = border[:, 0].astype(float)\n    G = border[:, 1].astype(float)\n    B = border[:, 2].astype(float)\n    mask = (B > 1.1 * R) & (B > 1.1 * G)\n    return float(np.count_nonzero(mask) / (mask.size + eps))\n",
  "def feature(image: np.ndarray) -> float:\n    'Normalized difference between mean blue in top third and bottom third (sky vs water)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    # ensure RGB\n    if len(image.shape) == 2:\n        rgb = np.stack([image, image, image], axis=2).astype(float)\n    else:\n        rgb = image.astype(float)\n    h, w = rgb.shape[:2]\n    t = max(1, h // 3)\n    top_b = np.mean(rgb[:t, :, 2]) if t > 0 else 0.0\n    bottom_b = np.mean(rgb[-t:, :, 2]) if t > 0 else 0.0\n    denom = (abs(top_b) + abs(bottom_b) + eps)\n    return float((top_b - bottom_b) / denom)\n\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Fraction of horizontal edge energy relative to total edge energy'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    if gray.size == 0:\n        return 0.0\n    gy, gx = np.gradient(gray)\n    horiz = np.sum(np.abs(gx))\n    vert = np.sum(np.abs(gy))\n    return float(horiz / (horiz + vert + eps))\n\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Compactness of green-dominant pixels in the center region (higher = more compact)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if len(image.shape) == 2:\n        rgb = np.stack([image, image, image], axis=2).astype(float)\n    else:\n        rgb = image.astype(float)\n    h, w = rgb.shape[:2]\n    sr, sc = h // 4, w // 4\n    er, ec = h - sr, w - sc\n    region = rgb[sr:er, sc:ec, :] if (er > sr and ec > sc) else rgb\n    if region.size == 0:\n        return 0.0\n    r = region[:, :, 0].astype(float)\n    g = region[:, :, 1].astype(float)\n    b = region[:, :, 2].astype(float)\n    mask = (g > r) & (g > b)\n    ys, xs = np.nonzero(mask)\n    if ys.size == 0:\n        return 0.0\n    cy = np.mean(ys)\n    cx = np.mean(xs)\n    dists = np.sqrt((ys - cy) ** 2 + (xs - cx) ** 2)\n    mean_dist = np.mean(dists)\n    # normalize by diagonal of region\n    diag = np.sqrt(region.shape[0] ** 2 + region.shape[1] ** 2) / 2.0 + eps\n    compactness = 1.0 - np.minimum(1.0, mean_dist / diag)\n    return float(compactness)\n\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Ratio of global variance to mean non-overlapping block variance (smoothness indicator)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    # use grayscale for variance computation\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    if gray.size == 0:\n        return 0.0\n    overall_var = float(np.var(gray) + eps)\n    # choose block size relative to image\n    b = max(4, min(h, w) // 16)\n    bh = (h // b) * b\n    bw = (w // b) * b\n    if bh == 0 or bw == 0:\n        mean_block_var = overall_var\n    else:\n        blocks = gray[:bh, :bw].reshape(bh // b, b, bw // b, b)\n        # move block dims to first axis and compute variance per block\n        blocks = blocks.transpose(0, 2, 1, 3).reshape(-1, b * b)\n        if blocks.size == 0:\n            mean_block_var = overall_var\n        else:\n            mean_block_var = float(np.mean(np.var(blocks, axis=1)) + eps)\n    return float(overall_var / (mean_block_var + eps))\n\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Fraction of very bright low-saturation pixels (specular highlight indicator, e.g., water reflections)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if len(image.shape) == 2:\n        rgb = np.stack([image, image, image], axis=2).astype(float)\n    else:\n        rgb = image.astype(float)\n    h, w = rgb.shape[:2]\n    mx = np.max(rgb, axis=2)\n    mn = np.min(rgb, axis=2)\n    sat = (mx - mn) / (mx + eps)\n    # brightness threshold: top 5% of pixel brightness\n    thresh = np.percentile(mx.flatten(), 95) if mx.size else 255.0\n    bright = mx >= thresh\n    low_sat = sat < 0.15\n    mask = bright & low_sat\n    return float(np.count_nonzero(mask) / (h * w + eps))\n\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Normalized difference between center mean intensity and border mean intensity'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        rgb = image.astype(float)\n        intensity = np.mean(rgb, axis=2)\n    else:\n        intensity = image.astype(float)\n    h, w = intensity.shape[:2]\n    sr, sc = h // 4, w // 4\n    er, ec = h - sr, w - sc\n    center = intensity[sr:er, sc:ec] if (er > sr and ec > sc) else intensity\n    # border as union of thin strips\n    t = max(1, min(h, w) // 12)\n    top = intensity[:t, :]\n    bottom = intensity[-t:, :]\n    left = intensity[:, :t]\n    right = intensity[:, -t:]\n    border = np.concatenate([top.reshape(-1), bottom.reshape(-1), left.reshape(-1), right.reshape(-1)])\n    if center.size == 0 or border.size == 0:\n        return 0.0\n    mc = float(np.mean(center))\n    mb = float(np.mean(border))\n    denom = (abs(mc) + abs(mb) + eps)\n    return float((mc - mb) / denom)\n\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Skewness-like measure of per-pixel chroma distribution (positive = long tail to high chroma)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if len(image.shape) == 2:\n        rgb = np.stack([image, image, image], axis=2).astype(float)\n    else:\n        rgb = image.astype(float)\n    mx = np.max(rgb, axis=2).flatten()\n    mn = np.min(rgb, axis=2).flatten()\n    chroma = mx - mn\n    if chroma.size == 0:\n        return 0.0\n    mu = np.mean(chroma)\n    sigma = np.std(chroma) + eps\n    skew = np.mean(((chroma - mu) ** 3)) / (sigma ** 3 + eps)\n    return float(skew)\n\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Aspect ratio of bounding box of colored (high-chroma) pixels relative to image aspect ( >1 = wider than image)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 1.0\n    if len(image.shape) == 2:\n        rgb = np.stack([image, image, image], axis=2).astype(float)\n    else:\n        rgb = image.astype(float)\n    h, w = rgb.shape[:2]\n    mx = np.max(rgb, axis=2)\n    mn = np.min(rgb, axis=2)\n    chroma = mx - mn\n    thr = np.percentile(chroma.flatten(), 70) if chroma.size else 0.0\n    mask = chroma > thr\n    ys, xs = np.nonzero(mask)\n    if ys.size == 0:\n        return 1.0\n    miny, maxy = int(np.min(ys)), int(np.max(ys))\n    minx, maxx = int(np.min(xs)), int(np.max(xs))\n    bbox_h = max(1, maxy - miny + 1)\n    bbox_w = max(1, maxx - minx + 1)\n    bbox_aspect = (bbox_w + eps) / (bbox_h + eps)\n    image_aspect = (w + eps) / (h + eps)\n    return float(bbox_aspect / (image_aspect + eps))\n\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Concentration (mean resultant length) of gradient orientations (1 = all same, 0 = uniform)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    if gray.size == 0:\n        return 0.0\n    gy, gx = np.gradient(gray)\n    angles = np.arctan2(gy, gx)\n    cos_mean = np.mean(np.cos(angles))\n    sin_mean = np.mean(np.sin(angles))\n    R = np.sqrt(cos_mean ** 2 + sin_mean ** 2)\n    return float(R)\n\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Dominance of the most common blue-minus-green bin (histogram peak fraction)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if len(image.shape) == 2:\n        rgb = np.stack([image, image, image], axis=2).astype(float)\n    else:\n        rgb = image.astype(float)\n    B = rgb[:, :, 2].flatten()\n    G = rgb[:, :, 1].flatten()\n    diff = B - G\n    if diff.size == 0:\n        return 0.0\n    bins = 21\n    hist, _ = np.histogram(diff, bins=bins, range=(np.min(diff), np.max(diff)))\n    total = float(np.sum(hist) + eps)\n    peak = float(np.max(hist))\n    return float(peak / (total + eps))\n",
  "def feature(image: np.ndarray) -> float:\n    'Mean blue excess in the bottom third of the image normalized by mean intensity'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if len(image.shape) == 2:\n        rgb = np.stack([image, image, image], axis=2).astype(float)\n    else:\n        rgb = image.astype(float)\n    h, w = rgb.shape[:2]\n    bh = max(1, h // 3)\n    bottom = rgb[h - bh:, :, :]\n    R = bottom[:, :, 0]; G = bottom[:, :, 1]; B = bottom[:, :, 2]\n    blue_excess = B - 0.5 * (R + G)\n    pos = blue_excess > 0\n    if np.count_nonzero(pos) == 0:\n        return 0.0\n    mean_intensity = float(np.mean((R + G + B) / 3.0) + eps)\n    return float(np.mean(blue_excess[pos]) / (mean_intensity + eps))\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Fraction of strong edges in the central band that are horizontal (horizon/waterline cue)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    if gray.size == 0:\n        return 0.0\n    gy, gx = np.gradient(gray)\n    mag = np.sqrt(gx * gx + gy * gy)\n    thr = np.percentile(mag, 75) + eps\n    strong = mag > thr\n    horizontal = (np.abs(gy) > 1.5 * np.abs(gx)) & strong\n    sr = h // 4\n    er = h - sr\n    central = horizontal[sr:er, :]\n    total_strong = np.count_nonzero(strong)\n    if total_strong == 0:\n        return 0.0\n    return float(np.count_nonzero(central) / (total_strong + eps))\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Horizontal (top-bottom) symmetry score of the blue channel (reflection indicator)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if len(image.shape) == 2:\n        B = image.astype(float)\n    else:\n        B = image[:, :, 2].astype(float)\n    h = B.shape[0]\n    if h < 2:\n        return 0.0\n    top = B[:h // 2, :]\n    bottom = B[h - (h // 2):, :]\n    bottom_flipped = np.flipud(bottom)\n    minr = min(top.shape[0], bottom_flipped.shape[0])\n    if minr == 0:\n        return 0.0\n    a = top[:minr, :].flatten().astype(float)\n    b = bottom_flipped[:minr, :].flatten().astype(float)\n    a_mean = a.mean() if a.size else 0.0\n    b_mean = b.mean() if b.size else 0.0\n    a0 = a - a_mean\n    b0 = b - b_mean\n    denom = (np.linalg.norm(a0) * np.linalg.norm(b0) + eps)\n    corr = float(np.dot(a0, b0) / denom)\n    # map correlation from [-1,1] to [0,1]\n    return float((corr + 1.0) / 2.0)\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Ratio of horizontal to vertical edge energy in the lower half (water usually horizontal)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    if h == 0:\n        return 0.0\n    gy, gx = np.gradient(gray)\n    lower = slice(h // 2, h)\n    gx_l = gx[lower, :]\n    gy_l = gy[lower, :]\n    horiz_energy = float(np.sum(gy_l * gy_l))\n    vert_energy = float(np.sum(gx_l * gx_l))\n    return float(horiz_energy / (vert_energy + eps))\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Normalized row position of the blue-weighted centroid (1.0 bottom, 0.0 top)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.5\n    if len(image.shape) == 2:\n        rgb = np.stack([image, image, image], axis=2).astype(float)\n    else:\n        rgb = image.astype(float)\n    h, w = rgb.shape[:2]\n    R = rgb[:, :, 0]; G = rgb[:, :, 1]; B = rgb[:, :, 2]\n    weight = B - np.maximum(R, G)\n    weight = np.clip(weight, a_min=0.0, a_max=None)\n    total = np.sum(weight)\n    if total <= 0:\n        return 0.5\n    rows = np.arange(h).reshape(h, 1).astype(float)\n    centroid = float(np.sum(rows * np.sum(weight, axis=1, keepdims=True)) / (total + eps))\n    return float(centroid / float(max(1, h - 1)))\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Ratio of low-frequency (block-averaged) variance to full-image variance (smoothness indicator)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    if gray.size == 0:\n        return 0.0\n    overall_var = float(np.var(gray) + eps)\n    # block size chosen relative to image size\n    b = max(4, min(h, w) // 16)\n    bh = (h // b) * b\n    bw = (w // b) * b\n    if bh == 0 or bw == 0:\n        return 0.0\n    blocks = gray[:bh, :bw].reshape(bh // b, b, bw // b, b)\n    # average each block to get coarse image\n    blocks_mean = blocks.mean(axis=(1, 3))\n    coarse_var = float(np.var(blocks_mean) + eps)\n    return float(coarse_var / overall_var)\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Normalized luminance difference between center region and image border (center - border)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if len(image.shape) == 2:\n        rgb = np.stack([image, image, image], axis=2).astype(float)\n    else:\n        rgb = image.astype(float)\n    h, w = rgb.shape[:2]\n    lum = np.mean(rgb, axis=2)\n    sr, sc = h // 4, w // 4\n    er, ec = h - sr, w - sc\n    if er > sr and ec > sc:\n        center = lum[sr:er, sc:ec]\n    else:\n        center = lum\n    t = max(1, min(h, w) // 12)\n    top = lum[:t, :].reshape(-1)\n    bottom = lum[-t:, :].reshape(-1)\n    left = lum[:, :t].reshape(-1)\n    right = lum[:, -t:].reshape(-1)\n    border = np.concatenate([top, bottom, left, right]) if lum.size else np.array([0.0])\n    if center.size == 0 or border.size == 0:\n        return 0.0\n    center_mean = float(np.mean(center))\n    border_mean = float(np.mean(border))\n    global_mean = float(np.mean(lum) + eps)\n    return float((center_mean - border_mean) / (global_mean + eps))\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Fraction of pixels that are bright but low-chroma (specular highlight candidates)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if len(image.shape) == 2:\n        mx = image.astype(float)\n        mn = image.astype(float)\n        chroma = mx - mn\n        brightness = mx\n    else:\n        rgb = image.astype(float)\n        mx = np.max(rgb, axis=2)\n        mn = np.min(rgb, axis=2)\n        chroma = mx - mn\n        brightness = mx\n    if brightness.size == 0:\n        return 0.0\n    bright_thr = np.percentile(brightness, 90)\n    dyn = float(np.max(brightness) - np.min(brightness) + eps)\n    chroma_thr = 0.08 * dyn\n    spec = (brightness >= bright_thr) & (chroma <= chroma_thr)\n    return float(np.count_nonzero(spec) / (spec.size + eps))\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Center-region green-to-blue texture ratio (std of green / std of blue)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if len(image.shape) == 2:\n        rgb = np.stack([image, image, image], axis=2).astype(float)\n    else:\n        rgb = image.astype(float)\n    h, w = rgb.shape[:2]\n    sr, sc = h // 4, w // 4\n    er, ec = h - sr, w - sc\n    region = rgb[sr:er, sc:ec, :] if (er > sr and ec > sc) else rgb\n    if region.size == 0:\n        return 0.0\n    gstd = float(np.std(region[:, :, 1]) + eps)\n    bstd = float(np.std(region[:, :, 2]) + eps)\n    return float(gstd / bstd)\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Fraction of columns with a blue streak (columns containing a notable fraction of blue-dominant pixels)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if len(image.shape) == 2:\n        rgb = np.stack([image, image, image], axis=2).astype(float)\n    else:\n        rgb = image.astype(float)\n    h, w = rgb.shape[:2]\n    R = rgb[:, :, 0]; G = rgb[:, :, 1]; B = rgb[:, :, 2]\n    global_mean = float(np.mean(rgb) + eps)\n    blue_dom = (B > R) & (B > G) & (B > 0.5 * global_mean)\n    # for each column compute fraction of rows that are blue-dominant\n    col_frac = np.sum(blue_dom, axis=0).astype(float) / float(max(1, h))\n    cols_with_streak = np.count_nonzero(col_frac > 0.10)\n    return float(cols_with_streak / float(max(1, w)))\n",
  "def feature(image: np.ndarray) -> float:\n    'Fraction of top-quarter pixels that are blue-dominant (blue > red and blue > green by dynamic threshold)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if len(image.shape) == 2:\n        # no color channels -> no blue dominance\n        return 0.0\n    rgb = image.astype(float)\n    h, w = rgb.shape[:2]\n    top_end = max(1, h // 4)\n    top = rgb[:top_end, :, :]\n    if top.size == 0:\n        return 0.0\n    mx = np.max(top)\n    mn = np.min(top)\n    dyn = float(mx - mn) + eps\n    thr = 0.08 * dyn\n    r = top[:, :, 0]; g = top[:, :, 1]; b = top[:, :, 2]\n    mask = (b > r + thr) & (b > g + thr)\n    return float(np.count_nonzero(mask) / (mask.size + eps))\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Fraction of total vertical-gradient energy concentrated in a narrow horizontal band (horizon prominence)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    if h < 1 or w < 1 or gray.size == 0:\n        return 0.0\n    gy, gx = np.gradient(gray)\n    row_energy = np.sum(np.abs(gy), axis=1)\n    total = float(np.sum(row_energy)) + eps\n    peak_row = int(np.argmax(row_energy))\n    band = max(1, h // 10)\n    start = max(0, peak_row - band // 2)\n    end = min(h, start + band)\n    band_energy = float(np.sum(row_energy[start:end]))\n    return float(band_energy / total)\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Ratio of Laplacian variance in center region to border regions (texture concentration)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    if h < 3 or w < 3:\n        return 0.0\n    # approximate Laplacian: second derivatives\n    gy, gx = np.gradient(gray)\n    gxx = np.gradient(gx, axis=1)\n    gyy = np.gradient(gy, axis=0)\n    lap = gxx + gyy\n    sr, sc = h // 4, w // 4\n    er, ec = h - sr, w - sc\n    center = lap[sr:er, sc:ec] if (er > sr and ec > sc) else lap\n    # border = outer bands of width t\n    t = max(1, min(h, w) // 8)\n    top = lap[:t, :] if t < h else np.empty((0,))\n    bottom = lap[-t:, :] if t < h else np.empty((0,))\n    left = lap[:, :t] if t < w else np.empty((0,))\n    right = lap[:, -t:] if t < w else np.empty((0,))\n    if center.size == 0:\n        return 0.0\n    border_concat = np.concatenate([top.reshape(-1), bottom.reshape(-1), left.reshape(-1), right.reshape(-1)]) if any(arr.size for arr in [top,bottom,left,right]) else np.array([])\n    center_var = float(np.var(center))\n    border_var = float(np.var(border_concat)) if border_concat.size else 0.0\n    return float(center_var / (border_var + eps))\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Normalized difference of mean (blue - green) between top half and bottom half'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if len(image.shape) == 2:\n        # grayscale -> no blue/green difference\n        return 0.0\n    rgb = image.astype(float)\n    h = rgb.shape[0]\n    mid = h // 2\n    top = rgb[:mid, :, :]\n    bottom = rgb[mid:, :, :]\n    if top.size == 0 or bottom.size == 0:\n        return 0.0\n    top_diff = float(np.mean(top[:, :, 2] - top[:, :, 1]))\n    bottom_diff = float(np.mean(bottom[:, :, 2] - bottom[:, :, 1]))\n    denom = (abs(top_diff) + abs(bottom_diff) + eps)\n    return float((top_diff - bottom_diff) / denom)\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Fraction of columns where more than half of pixels are dark (vertical-dark-column proportion)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        brightness = np.mean(image.astype(float), axis=2)\n    else:\n        brightness = image.astype(float)\n    h, w = brightness.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    thr = float(np.percentile(brightness, 25))\n    col_dark_fraction = np.mean(brightness < thr, axis=0)  # per-column fraction\n    cols_with_vertical_dark = np.count_nonzero(col_dark_fraction > 0.5)\n    return float(cols_with_vertical_dark / (w + eps))\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Mean hue angle (0..1) in center region using an RGB-to-hue arctan approximation'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if len(image.shape) == 2:\n        rgb = np.stack([image, image, image], axis=2).astype(float)\n    else:\n        rgb = image.astype(float)\n    h, w = rgb.shape[:2]\n    sr, sc = h // 4, w // 4\n    er, ec = h - sr, w - sc\n    region = rgb[sr:er, sc:ec, :] if (er > sr and ec > sc) else rgb\n    if region.size == 0:\n        return 0.0\n    r = region[:, :, 0].astype(float)\n    g = region[:, :, 1].astype(float)\n    b = region[:, :, 2].astype(float)\n    # approximate hue formula stable for grayscale as well\n    num = np.sqrt(3.0) * (g - b)\n    den = 2.0 * r - g - b + eps\n    hue = np.arctan2(num, den)  # -pi..pi\n    hue_norm = (hue + np.pi) / (2.0 * np.pi)  # 0..1\n    return float(np.mean(hue_norm))\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Brightness-weighted vertical centroid (mean row index of brightness) normalized to [0,1]'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        bright = np.mean(image.astype(float), axis=2)\n    else:\n        bright = image.astype(float)\n    h, w = bright.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    rows = np.arange(h).reshape(h, 1)\n    total_brightness = float(np.sum(bright)) + eps\n    weighted = float(np.sum(rows * bright)) / (w + eps)\n    # weighted sums used rows repeated per column; divide by total brightness\n    centroid_row = weighted / total_brightness\n    return float(centroid_row / (h - 1 + eps))\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Proportion of populated coarse RGB color bins (color diversity proxy, 4x4x4 quantization)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if len(image.shape) == 2:\n        rgb = np.stack([image, image, image], axis=2).astype(int)\n    else:\n        rgb = image.astype(int)\n    h, w = rgb.shape[:2]\n    if h * w == 0:\n        return 0.0\n    levels = 4\n    # quantize 0..255 into levels bins safely\n    maxv = max(1, np.max(rgb))\n    scale = 256.0 / levels\n    rbin = np.floor(rgb[:, :, 0] / scale).astype(int)\n    gbin = np.floor(rgb[:, :, 1] / scale).astype(int)\n    bbin = np.floor(rgb[:, :, 2] / scale).astype(int)\n    rbin = np.clip(rbin, 0, levels - 1)\n    gbin = np.clip(gbin, 0, levels - 1)\n    bbin = np.clip(bbin, 0, levels - 1)\n    idx = (rbin * levels + gbin) * levels + bbin\n    flat = idx.flatten()\n    counts = np.bincount(flat, minlength=levels**3)\n    populated = np.count_nonzero(counts > (0.01 * flat.size))  # bins with >1% pixels\n    return float(populated / (levels**3))\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Mean ratio of vertical to horizontal gradient magnitude (texture orientation bias)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    if gray.size == 0:\n        return 0.0\n    gy, gx = np.gradient(gray)\n    mean_abs_gy = float(np.mean(np.abs(gy)))\n    mean_abs_gx = float(np.mean(np.abs(gx))) + eps\n    return float(mean_abs_gy / mean_abs_gx)\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Normalized difference of mean brightness between center and border (center - border) / global_mean'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        bright = np.mean(image.astype(float), axis=2)\n    else:\n        bright = image.astype(float)\n    h, w = bright.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    sr, sc = h // 4, w // 4\n    er, ec = h - sr, w - sc\n    center = bright[sr:er, sc:ec] if (er > sr and ec > sc) else bright\n    t = max(1, min(h, w) // 8)\n    top = bright[:t, :]\n    bottom = bright[-t:, :]\n    left = bright[:, :t]\n    right = bright[:, -t:]\n    border = np.concatenate([top.reshape(-1), bottom.reshape(-1), left.reshape(-1), right.reshape(-1)]) if any(arr.size for arr in [top,bottom,left,right]) else np.array([])\n    center_mean = float(np.mean(center)) if center.size else 0.0\n    border_mean = float(np.mean(border)) if border.size else 0.0\n    global_mean = float(np.mean(bright)) + eps\n    return float((center_mean - border_mean) / global_mean)\n",
  "def feature(image: np.ndarray) -> float:\n    'Normalized column-wise intensity variation (std of column means / overall mean)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    img = image.astype(float)\n    # convert to grayscale if needed\n    if len(img.shape) == 3:\n        gray = np.mean(img, axis=2)\n    else:\n        gray = img\n    h, w = gray.shape[:2]\n    # column means\n    col_means = np.mean(gray, axis=0)\n    overall = float(np.mean(gray) + eps)\n    result = np.std(col_means) / overall\n    return float(result)\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Normalized vertical centroid of green-dominant pixels (1.0 bottom, 0.0 top)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.5\n    img = image.astype(float)\n    if len(img.shape) == 2:\n        rgb = np.stack([img, img, img], axis=2)\n    else:\n        rgb = img\n    h = rgb.shape[0]\n    R = rgb[:, :, 0]; G = rgb[:, :, 1]; B = rgb[:, :, 2]\n    # weight green when it's clearly dominant\n    margin = 0.05 * (np.max(G) - np.min(G) + eps)\n    mask = (G > R + margin) & (G > B + margin)\n    weight = np.where(mask, G - np.minimum(R, B), 0.0)\n    total = float(np.sum(weight))\n    if total <= 0:\n        return 0.5\n    rows = np.arange(h).reshape(h, 1)\n    row_weights = np.sum(weight, axis=1)\n    centroid = float(np.sum(rows.flatten() * row_weights) / (total + eps))\n    return float(centroid / float(max(1, h - 1)))\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Fraction of pixels strongly red-dominant (red > others by margin)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    img = image.astype(float)\n    if len(img.shape) == 2:\n        rgb = np.stack([img, img, img], axis=2)\n    else:\n        rgb = img\n    R = rgb[:, :, 0]; G = rgb[:, :, 1]; B = rgb[:, :, 2]\n    intensity = (R + G + B) / 3.0\n    margin = 0.06 * (np.max(intensity) - np.min(intensity) + eps)\n    mask = (R > G + margin) & (R > B + margin) & (intensity > np.percentile(intensity, 5))\n    frac = float(np.count_nonzero(mask)) / (mask.size + eps)\n    return float(frac)\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Skewness of luminance distribution (third standardized moment)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    img = image.astype(float)\n    if len(img.shape) == 3:\n        lum = np.mean(img, axis=2).flatten()\n    else:\n        lum = img.flatten()\n    if lum.size == 0:\n        return 0.0\n    mu = float(np.mean(lum))\n    sigma = float(np.std(lum) + eps)\n    m3 = float(np.mean((lum - mu) ** 3))\n    skew = m3 / (sigma ** 3 + eps)\n    return float(skew)\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Ratio of center-edge gradient energy (center mean mag / border mean mag)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    img = image.astype(float)\n    if len(img.shape) == 3:\n        gray = np.mean(img, axis=2)\n    else:\n        gray = img\n    h, w = gray.shape[:2]\n    gy, gx = np.gradient(gray)\n    mag = np.sqrt(gx * gx + gy * gy)\n    # define center\n    sr, sc = h // 4, w // 4\n    er, ec = h - sr, w - sc\n    center = mag[sr:er, sc:ec] if (er > sr and ec > sc) else mag\n    # border as ring of width t\n    t = max(1, min(h, w) // 8)\n    top = mag[:t, :]\n    bottom = mag[-t:, :]\n    left = mag[:, :t]\n    right = mag[:, -t:]\n    border_stack = np.concatenate([top.flatten(), bottom.flatten(), left.flatten(), right.flatten()]) if mag.size else np.array([0.0])\n    mean_center = float(np.mean(center) if center.size else 0.0)\n    mean_border = float(np.mean(border_stack) if border_stack.size else 0.0)\n    result = mean_center / (mean_border + eps)\n    return float(result)\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Vertical symmetry score: 1 - normalized mean abs difference between left and mirrored right'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    img = image.astype(float)\n    if len(img.shape) == 3:\n        comp = np.mean(img, axis=2)\n    else:\n        comp = img\n    h, w = comp.shape[:2]\n    mid = w // 2\n    left = comp[:, :mid]\n    if w % 2 == 0:\n        right = comp[:, mid:]\n    else:\n        right = comp[:, mid+1:]\n    # ensure same width by cropping larger side\n    minw = min(left.shape[1], right.shape[1]) if left.size and right.size else 0\n    if minw == 0:\n        return 0.0\n    left_crop = left[:, :minw]\n    right_crop = right[:, :minw][:, ::-1]  # mirror right\n    diff = np.mean(np.abs(left_crop - right_crop))\n    norm = float(np.mean(comp) + eps)\n    symmetry = 1.0 - (diff / norm)\n    return float(max(-1.0, min(1.0, symmetry)))\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Approximate fraction of image occupied by medium-to-large green patches (block pooling)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    img = image.astype(float)\n    if len(img.shape) == 2:\n        rgb = np.stack([img, img, img], axis=2)\n    else:\n        rgb = img\n    h, w = rgb.shape[:2]\n    # block size scaled to image\n    bs = max(8, min(h, w) // 20)\n    bh = (h + bs - 1) // bs\n    bw = (w + bs - 1) // bs\n    count_blocks = 0\n    green_blocks = 0\n    for i in range(bh):\n        r0 = i * bs\n        r1 = min(h, (i + 1) * bs)\n        for j in range(bw):\n            c0 = j * bs\n            c1 = min(w, (j + 1) * bs)\n            block = rgb[r0:r1, c0:c1, :]\n            if block.size == 0:\n                continue\n            R = block[:, :, 0]; G = block[:, :, 1]; B = block[:, :, 2]\n            intensity = (R + G + B) / 3.0\n            margin = 0.06 * (np.max(intensity) - np.min(intensity) + eps)\n            mask = (G > R + margin) & (G > B + margin) & (intensity > np.percentile(intensity, 5))\n            frac = float(np.count_nonzero(mask)) / (mask.size + eps)\n            count_blocks += 1\n            if frac > 0.25:\n                green_blocks += 1\n    if count_blocks == 0:\n        return 0.0\n    return float(green_blocks / float(count_blocks))\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Top 20% blue intensity contrast: (mean_top_blue - mean_rest_blue) / overall_mean'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    img = image.astype(float)\n    if len(img.shape) == 2:\n        rgb = np.stack([img, img, img], axis=2)\n    else:\n        rgb = img\n    h = rgb.shape[0]\n    t = max(1, int(np.ceil(0.2 * h)))\n    top = rgb[:t, :, :]\n    rest = rgb[t:, :, :] if t < h else np.zeros((1,1,3))\n    mean_top_blue = float(np.mean(top[:, :, 2])) if top.size else 0.0\n    mean_rest_blue = float(np.mean(rest[:, :, 2])) if rest.size else 0.0\n    overall = float(np.mean(rgb) + eps)\n    return float((mean_top_blue - mean_rest_blue) / overall)\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Ratio of chroma (mx-mn) in bottom third to top third (bottom vegetation/water bias)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    img = image.astype(float)\n    if len(img.shape) == 2:\n        rgb = np.stack([img, img, img], axis=2)\n    else:\n        rgb = img\n    h = rgb.shape[0]\n    t = max(1, h // 3)\n    top = rgb[:t, :, :].reshape(-1, 3)\n    bottom = rgb[-t:, :, :].reshape(-1, 3)\n    def mean_chroma(arr):\n        if arr.size == 0:\n            return 0.0\n        mx = np.max(arr, axis=1)\n        mn = np.min(arr, axis=1)\n        return float(np.mean(mx - mn))\n    mc_top = mean_chroma(top)\n    mc_bot = mean_chroma(bottom)\n    return float(mc_bot / (mc_top + eps))\n",
  "def feature(image: np.ndarray) -> float:\n    'Fraction of pixels where blue strongly dominates both red and green'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if len(image.shape) == 2:\n        rgb = np.stack([image, image, image], axis=2).astype(float)\n    else:\n        rgb = image.astype(float)\n    R = rgb[:, :, 0]\n    G = rgb[:, :, 1]\n    B = rgb[:, :, 2]\n    # require B larger than both R and G by an adaptive margin\n    mean_int = float(np.mean((R + G + B) / 3.0) + eps)\n    margin = max(5.0, mean_int * 0.05)\n    mask = (B > R + margin) & (B > G + margin)\n    total = float(R.size) + eps\n    return float(np.count_nonzero(mask) / total)\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Normalized vertical position of the brightest pixel (0=top, 1=bottom)'\n    import numpy as np\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    flat_idx = int(np.argmax(gray))\n    row = flat_idx // w\n    denom = float(max(1, h - 1))\n    return float(row / denom)\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Fraction of image area that is locally smooth (low gradient magnitude)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    gy, gx = np.gradient(gray)\n    mag = np.sqrt(gx * gx + gy * gy)\n    thr = float(np.mean(mag) * 0.6 + np.std(mag) * 0.1)\n    mask = mag < thr\n    total = float(mag.size) + eps\n    return float(np.count_nonzero(mask) / total)\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Ratio of mean blue to mean green in the bottom quarter of the image'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 2:\n        rgb = np.stack([image, image, image], axis=2).astype(float)\n    else:\n        rgb = image.astype(float)\n    start = max(0, (3 * h) // 4)\n    bottom = rgb[start:h, :, :]\n    if bottom.size == 0:\n        return 0.0\n    meanB = float(np.mean(bottom[:, :, 2]))\n    meanG = float(np.mean(bottom[:, :, 1]))\n    return float(meanB / (meanG + eps))\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Aspect ratio of bounding box of the largest colorful blob (height/width)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if len(image.shape) == 2:\n        return 0.0\n    rgb = image.astype(float)\n    r = rgb[:, :, 0]\n    g = rgb[:, :, 1]\n    b = rgb[:, :, 2]\n    mx = np.maximum(np.maximum(r, g), b)\n    mn = np.minimum(np.minimum(r, g), b)\n    sat = (mx - mn) / (mx + eps)\n    if sat.size == 0:\n        return 0.0\n    # threshold for colorful pixels: above mean + 0.5*std\n    thr = float(np.mean(sat) + 0.5 * np.std(sat))\n    mask = sat > thr\n    if not np.any(mask):\n        return 0.0\n    ys, xs = np.where(mask)\n    miny, maxy = int(ys.min()), int(ys.max())\n    minx, maxx = int(xs.min()), int(xs.max())\n    bbox_h = float(maxy - miny + 1)\n    bbox_w = float(maxx - minx + 1)\n    if bbox_w <= 0:\n        return 0.0\n    return float(bbox_h / (bbox_w + eps))\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Skewness of the green channel intensity distribution'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if len(image.shape) == 2:\n        g = image.astype(float).flatten()\n    else:\n        g = image[:, :, 1].astype(float).flatten()\n    if g.size == 0:\n        return 0.0\n    mu = float(np.mean(g))\n    sigma = float(np.std(g))\n    if sigma < eps:\n        return 0.0\n    m3 = float(np.mean((g - mu) ** 3))\n    skew = m3 / (sigma ** 3 + eps)\n    return float(skew)\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Fraction of top region classified as sky by being bright and low-saturation'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    top_h = max(1, h // 4)\n    if len(image.shape) == 2:\n        rgb_top = np.stack([image[:top_h, :], image[:top_h, :], image[:top_h, :]], axis=2).astype(float)\n    else:\n        rgb_top = image[:top_h, :, :].astype(float)\n    r = rgb_top[:, :, 0]\n    g = rgb_top[:, :, 1]\n    b = rgb_top[:, :, 2]\n    brightness = (r + g + b) / 3.0\n    mx = np.maximum(np.maximum(r, g), b)\n    mn = np.minimum(np.minimum(r, g), b)\n    sat = (mx - mn) / (mx + eps)\n    # adaptive thresholds\n    bright_thr = float(np.percentile(brightness, 60))\n    sat_thr = 0.25\n    sky_mask = (brightness > bright_thr) & (sat < sat_thr)\n    total = float(brightness.size) + eps\n    return float(np.count_nonzero(sky_mask) / total)\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Mean normalized (R - B) indicating scene warmth (positive = warmer)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if len(image.shape) == 2:\n        rgb = np.stack([image, image, image], axis=2).astype(float)\n    else:\n        rgb = image.astype(float)\n    R = rgb[:, :, 0]\n    B = rgb[:, :, 2]\n    meanR = float(np.mean(R))\n    meanB = float(np.mean(B))\n    mean_int = float(np.mean((rgb[:, :, 0] + rgb[:, :, 1] + rgb[:, :, 2]) / 3.0) + eps)\n    return float((meanR - meanB) / mean_int)\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Vertical extent of rows with strong edge energy (fraction of image height)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    if h == 0:\n        return 0.0\n    gy, gx = np.gradient(gray)\n    row_energy = np.sum(np.abs(gx) + np.abs(gy), axis=1)\n    thr = float(np.mean(row_energy) + 0.5 * np.std(row_energy))\n    active_rows = np.count_nonzero(row_energy > thr)\n    return float(active_rows / (float(h) + eps))\n",
  "def feature(image: np.ndarray) -> float:\n    'Fraction of pixels in the top quarter that are blue-dominant (sky/water at top)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    # get rgb\n    if len(image.shape) == 2:\n        rgb = np.stack([image, image, image], axis=2).astype(float)\n    else:\n        rgb = image.astype(float)\n    h, w = rgb.shape[:2]\n    top_h = max(1, h // 4)\n    top = rgb[:top_h, :, :]\n    if top.size == 0:\n        return 0.0\n    R = top[:, :, 0]; G = top[:, :, 1]; B = top[:, :, 2]\n    global_mean = float(np.mean(rgb) + eps)\n    blue_mask = (B > R) & (B > G) & (B > 0.5 * global_mean)\n    return float(np.count_nonzero(blue_mask) / (blue_mask.size + eps))\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Ratio of horizontal to vertical edge energy in grayscale (horiz/vert)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    # grayscale\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    # compute gradients\n    try:\n        gy, gx = np.gradient(gray)\n    except Exception:\n        return 0.0\n    horiz_energy = float(np.sum(np.abs(gy)))\n    vert_energy = float(np.sum(np.abs(gx)))\n    return float(horiz_energy / (vert_energy + eps))\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Vertical mirror similarity between upper and lower halves (higher => more reflection-like)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    # grayscale for similarity\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    mid = h // 2\n    if mid < 1:\n        return 0.0\n    upper = gray[:mid, :]\n    lower = gray[h - mid:, :]\n    # flip lower vertically to compare as reflection\n    lower_flip = np.flipud(lower)\n    # align sizes\n    min_h = min(upper.shape[0], lower_flip.shape[0])\n    upper = upper[:min_h, :]\n    lower_flip = lower_flip[:min_h, :]\n    diff = np.abs(upper - lower_flip)\n    # normalized similarity: 1 - (mean diff / (global std + eps))\n    denom = np.std(gray) + eps\n    sim = 1.0 - (float(np.mean(diff)) / denom)\n    # clamp\n    return float(max(0.0, sim))\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Fraction of pixels with low gradient magnitude (smooth areas like water)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    try:\n        gy, gx = np.gradient(gray)\n    except Exception:\n        return 0.0\n    mag = np.sqrt(gy * gy + gx * gx)\n    # threshold relative to median\n    thr = np.median(mag) * 0.5 + eps\n    low_frac = float(np.count_nonzero(mag <= thr) / (mag.size + eps))\n    return float(low_frac)\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Fraction of warm-colored pixels (R dominant and relatively strong), indicative of plumage/land'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if len(image.shape) == 2:\n        rgb = np.stack([image, image, image], axis=2).astype(float)\n    else:\n        rgb = image.astype(float)\n    R = rgb[:, :, 0]; G = rgb[:, :, 1]; B = rgb[:, :, 2]\n    global_mean = float(np.mean(rgb) + eps)\n    warm_mask = (R > G) & (R > B) & (R > 0.9 * global_mean)\n    return float(np.count_nonzero(warm_mask) / (warm_mask.size + eps))\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Count of columns where dominant color flips between blue and green from top to bottom (shoreline indicator)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if len(image.shape) == 2:\n        rgb = np.stack([image, image, image], axis=2).astype(float)\n    else:\n        rgb = image.astype(float)\n    h, w = rgb.shape[:2]\n    if h < 4:\n        return 0.0\n    half = h // 2\n    top = rgb[:half, :, :]\n    bottom = rgb[half:, :, :]\n    # compute per-column dominant channel (1=green, 2=blue, 0=other)\n    def col_dom(block):\n        R = block[:, :, 0]; G = block[:, :, 1]; B = block[:, :, 2]\n        meanR = np.mean(R, axis=0)\n        meanG = np.mean(G, axis=0)\n        meanB = np.mean(B, axis=0)\n        dom = np.zeros(meanR.shape, dtype=int)\n        dom[(meanG > meanR) & (meanG > meanB)] = 1\n        dom[(meanB > meanR) & (meanB > meanG)] = 2\n        return dom\n    top_dom = col_dom(top)\n    bottom_dom = col_dom(bottom)\n    flips = np.count_nonzero(top_dom != bottom_dom)\n    return float(flips / float(max(1, w)))\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Fraction of central-region pixels notably darker than border mean (dark subject on brighter background)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        rgb = image.astype(float)\n        gray = np.mean(rgb, axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    sr, sc = h // 4, w // 4\n    er, ec = h - sr, w - sc\n    center = gray[sr:er, sc:ec] if (er > sr and ec > sc) else gray\n    t = max(1, min(h, w) // 8)\n    top = gray[:t, :]\n    bottom = gray[-t:, :]\n    left = gray[:, :t]\n    right = gray[:, -t:]\n    border = np.concatenate([top.reshape(-1), bottom.reshape(-1), left.reshape(-1), right.reshape(-1)]) if gray.size else np.array([0.0])\n    if center.size == 0 or border.size == 0:\n        return 0.0\n    border_mean = float(np.mean(border))\n    thr = 0.85 * border_mean\n    dark_mask = center < thr\n    return float(np.count_nonzero(dark_mask) / (dark_mask.size + eps))\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Inverse of column-wise variance of (B - G) means (low variance => large uniform blue band)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if len(image.shape) == 2:\n        rgb = np.stack([image, image, image], axis=2).astype(float)\n    else:\n        rgb = image.astype(float)\n    h, w = rgb.shape[:2]\n    # per-column mean difference B-G\n    B = rgb[:, :, 2]; G = rgb[:, :, 1]\n    col_diff = np.mean(B - G, axis=0)\n    var = float(np.var(col_diff))\n    return float(1.0 / (var + eps))\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Mean saturation among pixels that are not blue-dominant (captures colorful non-water objects)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if len(image.shape) == 2:\n        rgb = np.stack([image, image, image], axis=2).astype(float)\n    else:\n        rgb = image.astype(float)\n    r = rgb[:, :, 0].flatten()\n    g = rgb[:, :, 1].flatten()\n    b = rgb[:, :, 2].flatten()\n    mask_nonblue = ~((b > r) & (b > g))\n    if np.count_nonzero(mask_nonblue) == 0:\n        return 0.0\n    mx = np.maximum(np.maximum(r, g), b)\n    mn = np.minimum(np.minimum(r, g), b)\n    sat = (mx - mn) / (mx + eps)\n    return float(np.mean(sat[mask_nonblue]))\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Concentration of horizontal edges near the strongest horizontal-edge row (horizon-like concentration)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    try:\n        gy, gx = np.gradient(gray)\n    except Exception:\n        return 0.0\n    row_energy = np.sum(np.abs(gy), axis=1)  # energy per row from horizontal edges\n    total = float(np.sum(row_energy) + eps)\n    if total <= eps:\n        return 0.0\n    peak_row = int(np.argmax(row_energy))\n    radius = max(1, h // 10)\n    r0 = max(0, peak_row - radius)\n    r1 = min(h, peak_row + radius + 1)\n    concentrated = float(np.sum(row_energy[r0:r1]) / total)\n    return float(concentrated)\n",
  "def feature(image: np.ndarray) -> float:\n    'Maximum average blue strength in a horizontal band normalized by overall blue mean'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if len(image.shape) == 2:\n        b = image.astype(float)\n    else:\n        b = image[:, :, 2].astype(float)\n    h = b.shape[0]\n    wsize = max(1, h // 6)\n    # sliding window mean along rows using cumulative sum\n    row_mean = np.mean(b, axis=1)\n    c = np.concatenate(([0.0], np.cumsum(row_mean)))\n    if c.size <= wsize:\n        max_band = float(np.mean(row_mean))\n    else:\n        sums = c[wsize:] - c[:-wsize]\n        max_band = float(np.max(sums) / float(wsize))\n    overall_mean = float(np.mean(b) + eps)\n    return float(max_band / overall_mean)\n\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Fraction of center-region green pixels that belong to horizontal runs (neighbor on same row)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if len(image.shape) == 2:\n        rgb = np.stack([image, image, image], axis=2).astype(float)\n    else:\n        rgb = image.astype(float)\n    h, w = rgb.shape[:2]\n    sr, sc = h // 4, w // 4\n    er, ec = h - sr, w - sc\n    region = rgb[sr:er, sc:ec, :] if (er > sr and ec > sc) else rgb\n    if region.size == 0:\n        return 0.0\n    r = region[:, :, 0]\n    g = region[:, :, 1]\n    b = region[:, :, 2]\n    mx = np.maximum(np.maximum(r, g), b)\n    mn = np.minimum(np.minimum(r, g), b)\n    chroma = mx - mn\n    dyn = float(np.max(mx) - np.min(mn) + eps)\n    green_mask = (g > r) & (g > b) & (chroma >= 0.06 * dyn)\n    total_green = int(np.count_nonzero(green_mask))\n    if total_green == 0:\n        return 0.0\n    # horizontal run membership: pixel has a green neighbor left or right\n    gm = green_mask.astype(np.uint8)\n    left = np.pad(gm, ((0, 0), (1, 0)), mode='constant')[:, :-1]\n    right = np.pad(gm, ((0, 0), (0, 1)), mode='constant')[:, 1:]\n    run_pixels = (green_mask & ((left == 1) | (right == 1)))\n    return float(np.count_nonzero(run_pixels) / (total_green + eps))\n\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Ratio of mean horizontal gradient magnitude to mean vertical gradient magnitude (vertical-structure bias)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    if gray.size == 0:\n        return 0.0\n    gy, gx = np.gradient(gray)\n    mean_gx = float(np.mean(np.abs(gx)))\n    mean_gy = float(np.mean(np.abs(gy)))\n    return float(mean_gx / (mean_gy + eps))\n\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Fraction of pixels that are very bright low-chroma highlights (specular highlight proxy)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if len(image.shape) == 2:\n        rgb = np.stack([image, image, image], axis=2).astype(float)\n    else:\n        rgb = image.astype(float)\n    r = rgb[:, :, 0]\n    g = rgb[:, :, 1]\n    b = rgb[:, :, 2]\n    lum = (r + g + b) / 3.0\n    mx = np.max(lum)\n    mn = np.min(lum)\n    dyn = mx - mn + eps\n    thr = mn + 0.85 * dyn\n    chroma = np.maximum(np.maximum(r, g), b) - np.minimum(np.minimum(r, g), b)\n    # highlights: very bright and relatively desaturated (low chroma)\n    mask = (lum >= thr) & (chroma <= 0.12 * dyn)\n    return float(np.count_nonzero(mask) / (mask.size + eps))\n\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Mean blue-to-green ratio in the bottom third of the image'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if len(image.shape) == 2:\n        b = image.astype(float)\n        g = image.astype(float)\n    else:\n        b = image[:, :, 2].astype(float)\n        g = image[:, :, 1].astype(float)\n    h = b.shape[0]\n    start = (2 * h) // 3\n    bottom_b = b[start:, :] if start < h else b\n    bottom_g = g[start:, :] if start < h else g\n    if bottom_b.size == 0:\n        return 0.0\n    meanB = float(np.mean(bottom_b))\n    meanG = float(np.mean(bottom_g))\n    return float(meanB / (meanG + eps))\n\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Fraction of upper-third pixels that are blue-dominant and brighter than image median (sky estimate)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if len(image.shape) == 2:\n        rgb = np.stack([image, image, image], axis=2).astype(float)\n    else:\n        rgb = image.astype(float)\n    h = rgb.shape[0]\n    top = rgb[:max(1, h // 3), :, :]\n    if top.size == 0:\n        return 0.0\n    r = top[:, :, 0]\n    g = top[:, :, 1]\n    b = top[:, :, 2]\n    lum_all = np.mean(rgb, axis=2)\n    med = float(np.median(lum_all))\n    blue_dominant = (b > g) & (b > r) & (np.mean(top, axis=2) > med)\n    return float(np.count_nonzero(blue_dominant) / (blue_dominant.size + eps))\n\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Mean local 3x3 grayscale standard deviation (texture coarseness; water tends to be low)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    if gray.size == 0:\n        return 0.0\n    pad = np.pad(gray, ((1, 1), (1, 1)), mode='reflect')\n    # sum of values in 3x3 and sum of squares in 3x3\n    s = (pad[:-2, :-2] + pad[:-2, 1:-1] + pad[:-2, 2:] +\n         pad[1:-1, :-2] + pad[1:-1, 1:-1] + pad[1:-1, 2:] +\n         pad[2:, :-2] + pad[2:, 1:-1] + pad[2:, 2:])\n    sq = (pad[:-2, :-2]**2 + pad[:-2, 1:-1]**2 + pad[:-2, 2:]**2 +\n          pad[1:-1, :-2]**2 + pad[1:-1, 1:-1]**2 + pad[1:-1, 2:]**2 +\n          pad[2:, :-2]**2 + pad[2:, 1:-1]**2 + pad[2:, 2:]**2)\n    mean3 = s / 9.0\n    mean_sq3 = sq / 9.0\n    var3 = np.maximum(0.0, mean_sq3 - mean3**2)\n    std3 = np.sqrt(var3)\n    return float(np.mean(std3))\n\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Variance of a discrete Laplacian in the center region (proxy for sharp object detail)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    if gray.size == 0:\n        return 0.0\n    pad = np.pad(gray, ((1, 1), (1, 1)), mode='reflect')\n    center = pad[1:-1, 1:-1]\n    up = pad[:-2, 1:-1]\n    down = pad[2:, 1:-1]\n    left = pad[1:-1, :-2]\n    right = pad[1:-1, 2:]\n    lap = (up + down + left + right) - 4.0 * center\n    sr, sc = h // 4, w // 4\n    er, ec = h - sr, w - sc\n    region_lap = lap[sr:er, sc:ec] if (er > sr and ec > sc) else lap\n    if region_lap.size == 0:\n        return 0.0\n    return float(np.var(region_lap))\n\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Hue-like angle of the mean center color mapped to [0,1] (approximate dominant center hue)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if len(image.shape) == 2:\n        rgb = np.stack([image, image, image], axis=2).astype(float)\n    else:\n        rgb = image.astype(float)\n    h, w = rgb.shape[:2]\n    sr, sc = h // 4, w // 4\n    er, ec = h - sr, w - sc\n    center = rgb[sr:er, sc:ec, :] if (er > sr and ec > sc) else rgb\n    if center.size == 0:\n        return 0.0\n    r = float(np.mean(center[:, :, 0]))\n    g = float(np.mean(center[:, :, 1]))\n    b = float(np.mean(center[:, :, 2]))\n    # approximate hue: atan2( sqrt(3)*(g-b), 2*r - g - b )\n    num = np.sqrt(3.0) * (g - b)\n    den = (2.0 * r - g - b) + eps\n    angle = np.arctan2(num, den)  # range [-pi, pi]\n    normalized = (angle + np.pi) / (2.0 * np.pi)\n    return float(normalized)\n\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Fraction of center-region pixels brighter than global mean + 0.5*std (foreground prominence)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        lum = np.mean(image.astype(float), axis=2)\n    else:\n        lum = image.astype(float)\n    if lum.size == 0:\n        return 0.0\n    global_mean = float(np.mean(lum))\n    global_std = float(np.std(lum))\n    thr = global_mean + 0.5 * global_std\n    h, w = lum.shape[:2]\n    sr, sc = h // 4, w // 4\n    er, ec = h - sr, w - sc\n    center = lum[sr:er, sc:ec] if (er > sr and ec > sc) else lum\n    if center.size == 0:\n        return 0.0\n    mask = center > thr\n    return float(np.count_nonzero(mask) / (mask.size + eps))\n",
  "def feature(image: np.ndarray) -> float:\n    'Global fraction of strongly blue pixels (water-color heuristic)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if len(image.shape) == 2:\n        return 0.0\n    rgb = image.astype(float)\n    r = rgb[:, :, 0]\n    g = rgb[:, :, 1]\n    b = rgb[:, :, 2]\n    # require blue to noticeably exceed other channels\n    mask = (b > r * 1.08) & (b > g * 1.08)\n    total = float(mask.size) if mask.size else eps\n    return float(np.count_nonzero(mask) / total)\n\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Fraction of image rows where blue-dominant pixels form a horizontal band (>30% of row)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if len(image.shape) == 2:\n        return 0.0\n    rgb = image.astype(float)\n    r = rgb[:, :, 0]; g = rgb[:, :, 1]; b = rgb[:, :, 2]\n    h, w = b.shape\n    if h == 0:\n        return 0.0\n    row_frac = np.sum((b > r * 1.05) & (b > g * 1.05), axis=1) / float(max(1, w))\n    rows_with_band = np.count_nonzero(row_frac > 0.30)\n    return float(rows_with_band / float(max(1, h)))\n\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Fraction of image area that is very smooth (low gradient magnitude)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    img = image.astype(float)\n    if len(img.shape) == 3:\n        gray = np.mean(img, axis=2)\n    else:\n        gray = img\n    if gray.size == 0:\n        return 0.0\n    gy, gx = np.gradient(gray)\n    mag = np.sqrt(gx * gx + gy * gy)\n    thr = np.percentile(mag.flatten(), 20)  # bottom 20% considered smooth\n    return float(np.count_nonzero(mag < thr) / float(mag.size + eps))\n\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Fraction of pixels that are extreme bright highlights (99th percentile)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    img = image.astype(float)\n    if len(img.shape) == 3:\n        inten = np.mean(img, axis=2)\n    else:\n        inten = img\n    if inten.size == 0:\n        return 0.0\n    thr = np.percentile(inten.flatten(), 99)\n    return float(np.count_nonzero(inten >= thr) / float(inten.size + eps))\n\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Normalized contrast between center region and border (center_mean - border_mean) / global_mean'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    img = image.astype(float)\n    if len(img.shape) == 3:\n        gray = np.mean(img, axis=2)\n    else:\n        gray = img\n    h, w = gray.shape[:2]\n    sr, sc = h // 4, w // 4\n    er, ec = h - sr, w - sc\n    center = gray[sr:er, sc:ec] if (er > sr and ec > sc) else gray\n    t = max(1, min(h, w) // 8)\n    top = gray[:t, :].flatten()\n    bottom = gray[-t:, :].flatten()\n    left = gray[:, :t].flatten()\n    right = gray[:, -t:].flatten()\n    border = np.concatenate([top, bottom, left, right]) if gray.size else np.array([0.0])\n    mean_center = float(np.mean(center) if center.size else 0.0)\n    mean_border = float(np.mean(border) if border.size else 0.0)\n    mean_global = float(np.mean(gray) if gray.size else eps)\n    return float((mean_center - mean_border) / (abs(mean_global) + eps))\n\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Vertical symmetry score (1.0 = symmetric, 0.0 = very asymmetric)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    arr = image.astype(float)\n    h, w = arr.shape[:2]\n    if w < 2 or h == 0:\n        return 0.0\n    # create grayscale representation for symmetry check\n    if len(arr.shape) == 3:\n        gray = np.mean(arr, axis=2)\n    else:\n        gray = arr\n    # split left and right\n    mid = w // 2\n    if w % 2 == 0:\n        left = gray[:, :mid]\n        right = gray[:, mid:]\n    else:\n        left = gray[:, :mid]\n        right = gray[:, mid+1:]\n    # resize to same width if necessary\n    minw = min(left.shape[1], right.shape[1])\n    if minw == 0:\n        return 0.0\n    leftc = left[:, :minw]\n    rightc = right[:, :minw][:, ::-1]  # flip right for symmetry\n    diff = np.abs(leftc - rightc)\n    mean_diff = float(np.mean(diff))\n    mean_int = float(np.mean(gray) + eps)\n    score = 1.0 - (mean_diff / (mean_int + eps))\n    if score < 0.0:\n        score = 0.0\n    if score > 1.0:\n        score = 1.0\n    return float(score)\n\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Vertical position (normalized 0..1) of green-dominant pixel centroid (0=top,1=bottom)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.5\n    if len(image.shape) == 2:\n        return 0.5\n    rgb = image.astype(float)\n    r = rgb[:, :, 0]; g = rgb[:, :, 1]; b = rgb[:, :, 2]\n    mask = (g > r) & (g > b)\n    h = r.shape[0]\n    if np.count_nonzero(mask) == 0:\n        return 0.5\n    rows = np.arange(h).reshape(h, 1)\n    weighted_sum = float(np.sum(rows * mask))\n    denom = float(np.count_nonzero(mask))\n    centroid = weighted_sum / (denom + eps)\n    return float(centroid / max(1, h - 1))\n\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Fraction of edge energy aligned vertically (weighted by gradient magnitude)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    arr = image.astype(float)\n    if len(arr.shape) == 3:\n        gray = np.mean(arr, axis=2)\n    else:\n        gray = arr\n    if gray.size == 0:\n        return 0.0\n    gy, gx = np.gradient(gray)\n    mag = np.sqrt(gx * gx + gy * gy)\n    angles = np.arctan2(gy, gx)  # angle of gradient\n    # vertical edges => gradient points horizontally => angle near 0 or pi\n    # use sine of angle to detect closeness to 0/pi (sin ~ 0)\n    thresh = np.sin(np.pi / 8.0)\n    vertical_mask = np.abs(np.sin(angles)) < thresh\n    weighted_vert = float(np.sum(mag * vertical_mask))\n    total_energy = float(np.sum(mag) + eps)\n    return float(weighted_vert / total_energy)\n\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Mean per-pixel color-channel std divided by global intensity std (color texture ratio)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    arr = image.astype(float)\n    if len(arr.shape) == 2:\n        return 0.0\n    # per-pixel color variability\n    pixel_std = np.std(arr, axis=2)\n    mean_pixel_std = float(np.mean(pixel_std)) if pixel_std.size else 0.0\n    global_std = float(np.std(arr)) if arr.size else eps\n    return float(mean_pixel_std / (global_std + eps))\n\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Ratio of vertical gradient magnitude in blue channel to green channel (smoothness of blue)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if len(image.shape) == 2:\n        return 0.0\n    rgb = image.astype(float)\n    b = rgb[:, :, 2]\n    g = rgb[:, :, 1]\n    # vertical gradients (along rows)\n    db = np.abs(np.gradient(b, axis=0))\n    dg = np.abs(np.gradient(g, axis=0))\n    mean_db = float(np.mean(db)) if db.size else 0.0\n    mean_dg = float(np.mean(dg)) if dg.size else 0.0\n    return float(mean_db / (mean_dg + eps))\n",
  "def feature(image: np.ndarray) -> float:\n    'Mean normalized gradient magnitude of luminance (texture strength)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    img = image.astype(float)\n    if len(img.shape) == 3:\n        gray = np.mean(img, axis=2)\n    else:\n        gray = img\n    gy, gx = np.gradient(gray)\n    mag = np.sqrt(gx * gx + gy * gy)\n    return float(np.mean(mag) / (np.max(mag) + eps))\n\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Ratio of vertical-to-horizontal edge energy in luminance (horizon vs vertical textures)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    img = image.astype(float)\n    if len(img.shape) == 3:\n        gray = np.mean(img, axis=2)\n    else:\n        gray = img\n    gy, gx = np.gradient(gray)\n    vert = np.mean(np.abs(gy))\n    hori = np.mean(np.abs(gx))\n    return float((vert + eps) / (hori + eps))\n\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Top-bottom color similarity (high similarity suggests water reflections)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    img = image.astype(float)\n    h, w = img.shape[:2]\n    # make sure rgb\n    if len(img.shape) == 2:\n        rgb = np.stack([img, img, img], axis=2)\n    else:\n        rgb = img\n    top = rgb[:h//2, :, :].astype(float)\n    bottom = rgb[h - (h//2):, :, :].astype(float)\n    if top.size == 0 or bottom.size == 0:\n        return 0.0\n    # align sizes if odd\n    if top.shape[0] != bottom.shape[0]:\n        bottom = bottom[-top.shape[0]:, :, :]\n    bottom_flipped = bottom[::-1, :, :]\n    diff = np.mean(np.abs(top - bottom_flipped))\n    # invert so that more similarity -> higher feature\n    max_val = np.mean((np.max(rgb, axis=(0,1)) + np.min(rgb, axis=(0,1))) / 2.0) + eps\n    sim = 1.0 / (1.0 + diff / (max_val + eps))\n    return float(sim)\n\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Fraction of blue-dominant pixels that are locally smooth (low gradient) - smooth blue patch proxy'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    img = image.astype(float)\n    if len(img.shape) == 2:\n        rgb = np.stack([img, img, img], axis=2)\n    else:\n        rgb = img\n    R = rgb[:, :, 0]\n    G = rgb[:, :, 1]\n    B = rgb[:, :, 2]\n    blue_mask = (B > R) & (B > G)\n    gray = np.mean(rgb, axis=2)\n    gy, gx = np.gradient(gray)\n    mag = np.sqrt(gx * gx + gy * gy)\n    # threshold at low-gradient = below median * 0.8\n    thresh = np.median(mag) * 0.8 + eps\n    smooth_blue = blue_mask & (mag < thresh)\n    return float(np.count_nonzero(smooth_blue) / (rgb.shape[0] * rgb.shape[1] + eps))\n\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Estimated horizon vertical position (row index normalized 0..1 where strong horizontal edge occurs)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    img = image.astype(float)\n    if len(img.shape) == 3:\n        gray = np.mean(img, axis=2)\n    else:\n        gray = img\n    gy, gx = np.gradient(gray)\n    # horizontal edges correspond to large vertical gradient (gy)\n    row_energy = np.mean(np.abs(gy), axis=1)\n    if row_energy.size == 0:\n        return 0.0\n    idx = int(np.argmax(row_energy))\n    return float(idx / (gray.shape[0] - 1 + eps))\n\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Fraction of top-region pixels that are bright and blue-dominant (sky/water surface indicator)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    img = image.astype(float)\n    h, w = img.shape[:2]\n    top_h = max(1, h // 5)\n    if len(img.shape) == 2:\n        rgb = np.stack([img, img, img], axis=2)\n    else:\n        rgb = img\n    top = rgb[:top_h, :, :]\n    R = top[:, :, 0]\n    G = top[:, :, 1]\n    B = top[:, :, 2]\n    intensity = np.mean(top, axis=2)\n    bright_blue = (B > R) & (B > G) & (intensity > (np.mean(rgb) * 0.8 + eps))\n    return float(np.count_nonzero(bright_blue) / (top_h * w + eps))\n\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Dispersion between quadrant mean colors (sum of squared distances normalized)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    img = image.astype(float)\n    h, w = img.shape[:2]\n    if len(img.shape) == 2:\n        rgb = np.stack([img, img, img], axis=2)\n    else:\n        rgb = img\n    hm, wm = h//2, w//2\n    quads = [\n        rgb[:hm, :wm, :].reshape(-1,3),\n        rgb[:hm, wm:, :].reshape(-1,3),\n        rgb[hm:, :wm, :].reshape(-1,3),\n        rgb[hm:, wm:, :].reshape(-1,3)\n    ]\n    means = []\n    for q in quads:\n        if q.size == 0:\n            means.append(np.array([0.0,0.0,0.0]))\n        else:\n            means.append(np.mean(q, axis=0))\n    means = np.array(means)\n    center = np.mean(means, axis=0)\n    d2 = np.sum((means - center)**2, axis=1)\n    score = np.mean(d2)\n    mean_intensity = np.mean(np.mean(rgb, axis=2)) + eps\n    return float(score / mean_intensity)\n\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Difference in mean saturation between center region and border (color contrast)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    img = image.astype(float)\n    h, w = img.shape[:2]\n    if len(img.shape) == 2:\n        rgb = np.stack([img, img, img], axis=2)\n    else:\n        rgb = img\n    sr, sc = h//4, w//4\n    er, ec = h - sr, w - sc\n    center = rgb[sr:er, sc:ec, :] if (er>sr and ec>sc) else rgb\n    t = max(1, min(h,w)//8)\n    top = rgb[:t,:,:]\n    bottom = rgb[-t:,:,:]\n    left = rgb[:, :t, :]\n    right = rgb[:, -t:, :]\n    border = np.concatenate([top.reshape(-1,3), bottom.reshape(-1,3), left.reshape(-1,3), right.reshape(-1,3)], axis=0) if rgb.size else np.zeros((1,3))\n    def sat_arr(arr):\n        if arr.size == 0:\n            return np.array([0.0])\n        mx = np.max(arr, axis=1)\n        mn = np.min(arr, axis=1)\n        return (mx - mn) / (mx + eps)\n    sat_center = np.mean(sat_arr(center.reshape(-1,3)))\n    sat_border = np.mean(sat_arr(border))\n    return float(sat_center - sat_border)\n\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Vertical bias between green and blue pixel centroids (positive if blue centroid lower than green)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    img = image.astype(float)\n    h, w = img.shape[:2]\n    ys = np.arange(h).reshape(h,1)\n    if len(img.shape) == 2:\n        rgb = np.stack([img, img, img], axis=2)\n    else:\n        rgb = img\n    R = rgb[:, :, 0]\n    G = rgb[:, :, 1]\n    B = rgb[:, :, 2]\n    green_mask = (G > R) & (G > B)\n    blue_mask = (B > R) & (B > G)\n    if np.count_nonzero(green_mask) == 0 or np.count_nonzero(blue_mask) == 0:\n        return 0.0\n    green_y = float(np.sum(ys * green_mask) / (np.count_nonzero(green_mask) + eps))\n    blue_y = float(np.sum(ys * blue_mask) / (np.count_nonzero(blue_mask) + eps))\n    # positive if blue centroid is lower (greater y) than green centroid\n    return float((blue_y - green_y) / (h + eps))\n\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Proportion of high-gradient pixels (rough texture fraction)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    img = image.astype(float)\n    if len(img.shape) == 3:\n        gray = np.mean(img, axis=2)\n    else:\n        gray = img\n    gy, gx = np.gradient(gray)\n    mag = np.sqrt(gx*gx + gy*gy).flatten()\n    if mag.size == 0:\n        return 0.0\n    thresh = np.percentile(mag, 75)  # top quartile considered high-gradient\n    return float(np.count_nonzero(mag > thresh) / (mag.size + eps))\n",
  "def feature(image: np.ndarray) -> float:\n    'Proportion of top-third pixels that are strongly blue (sky/water at top)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    arr = image.astype(float)\n    h, w = arr.shape[:2]\n    top = max(1, h // 3)\n    if arr.ndim == 2:\n        # grayscale can't be blue -> return 0\n        return 0.0\n    B = arr[:top, :, 2]\n    G = arr[:top, :, 1]\n    R = arr[:top, :, 0]\n    # strong blue where blue exceeds both other channels by margin relative to local intensity\n    intensity = (R + G + B) / 3.0 + eps\n    blue_mask = (B > G + 10) & (B > R + 10) | (B > 1.05 * intensity)\n    denom = float(B.size) + eps\n    return float(np.count_nonzero(blue_mask) / denom)\n\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Ratio of mean horizontal-gradient magnitude to vertical-gradient magnitude'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if image.ndim == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    gy, gx = np.gradient(gray)\n    abs_gx = np.abs(gx)\n    abs_gy = np.abs(gy)\n    mean_horiz = float(np.mean(abs_gy))\n    mean_vert = float(np.mean(abs_gx))\n    return float(mean_horiz / (mean_vert + eps))\n\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Fraction of strong edges that are horizontally oriented (horizon/wave indicator)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if image.ndim == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    gy, gx = np.gradient(gray)\n    mag = np.sqrt(gx * gx + gy * gy)\n    # threshold for \"strong\" edges: above median\n    if mag.size == 0:\n        return 0.0\n    thresh = float(np.median(mag))\n    strong = mag > thresh\n    if np.count_nonzero(strong) == 0:\n        return 0.0\n    # horizontal edges: absolute vertical gradient dominates\n    horiz = (np.abs(gy) > np.abs(gx)) & strong\n    return float(np.count_nonzero(horiz) / (np.count_nonzero(strong) + eps))\n\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Vertical center-of-mass offset of (blue - green) signal (positive means blue concentrated lower)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    arr = image.astype(float)\n    h, w = arr.shape[:2]\n    rows = np.arange(h).reshape(h, 1)\n    if arr.ndim == 2:\n        # grayscale: no blue-green signal\n        return 0.0\n    B = arr[:, :, 2]\n    G = arr[:, :, 1]\n    diff = B - G\n    weight = np.abs(diff)\n    total_weight = float(np.sum(weight) + eps)\n    com = float(np.sum(rows * weight) / total_weight)  # in [0, h)\n    # normalize to center offset in [-0.5, 0.5]\n    offset = (com - (h - 1) / 2.0) / float(max(1, h))\n    return float(offset)\n\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Entropy of chroma (max-min) histogram (color complexity measure)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    img = image.astype(float)\n    if img.ndim == 2:\n        r = g = b = img\n    else:\n        r = img[:, :, 0]\n        g = img[:, :, 1]\n        b = img[:, :, 2]\n    mx = np.maximum(np.maximum(r, g), b).flatten()\n    mn = np.minimum(np.minimum(r, g), b).flatten()\n    chroma = (mx - mn)\n    if chroma.size == 0:\n        return 0.0\n    bins = 16\n    hist, _ = np.histogram(chroma, bins=bins, range=(float(np.min(chroma)), float(np.max(chroma) + eps)))\n    prob = hist.astype(float) / (np.sum(hist) + eps)\n    # entropy\n    ent = -np.sum(np.where(prob > 0, prob * np.log(prob + eps), 0.0))\n    return float(ent)\n\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Fraction of central-region pixels that are near-maximum intensity (specular highlights)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    arr = image.astype(float)\n    h, w = arr.shape[:2]\n    sr, sc = h // 4, w // 4\n    er, ec = h - sr, w - sc\n    region = arr[sr:er, sc:ec] if (er > sr and ec > sc) else arr\n    if region.size == 0:\n        return 0.0\n    if region.ndim == 3:\n        intensity = np.mean(region, axis=2)\n    else:\n        intensity = region\n    global_max = float(np.max(intensity))\n    if global_max <= 0:\n        return 0.0\n    mask = intensity >= (0.95 * global_max)\n    return float(np.count_nonzero(mask) / (mask.size + eps))\n\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Green-patch concentration score: green fraction weighted by concentration in vertical span'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    arr = image.astype(float)\n    h = arr.shape[0]\n    if arr.ndim == 2:\n        return 0.0\n    R = arr[:, :, 0].flatten()\n    G = arr[:, :, 1].flatten()\n    B = arr[:, :, 2].flatten()\n    mask = (G > R) & (G > B) & (G > np.mean(arr))\n    total = float(mask.size)\n    if total <= 0:\n        return 0.0\n    coords = np.arange(arr.shape[0]).reshape(arr.shape[0], 1)\n    mask2d = mask.reshape(arr.shape[0], arr.shape[1])\n    if np.count_nonzero(mask2d) == 0:\n        return 0.0\n    rows_present = np.where(np.any(mask2d, axis=1))[0]\n    vspan = float((rows_present.max() - rows_present.min()) + eps) / float(max(1, h))\n    green_fraction = float(np.count_nonzero(mask2d) / total)\n    # higher when many green pixels and they are concentrated (small vertical span)\n    score = green_fraction * (1.0 - vspan)\n    return float(score)\n\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Normalized intensity contrast between center region and border (center - border) / (sum)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    arr = image.astype(float)\n    h, w = arr.shape[:2]\n    sr, sc = h // 4, w // 4\n    er, ec = h - sr, w - sc\n    if arr.ndim == 3:\n        gray = np.mean(arr, axis=2)\n    else:\n        gray = arr\n    if er <= sr or ec <= sc:\n        center = gray\n        border = np.array([])\n    else:\n        center = gray[sr:er, sc:ec]\n        mask = np.ones_like(gray, dtype=bool)\n        mask[sr:er, sc:ec] = False\n        border = gray[mask]\n    mean_center = float(np.mean(center)) if center.size else 0.0\n    mean_border = float(np.mean(border)) if border.size else 0.0\n    return float((mean_center - mean_border) / (abs(mean_center) + abs(mean_border) + eps))\n\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Grayscale bimodality proxy: distance between two largest histogram peaks weighted by their mass'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if image.ndim == 3:\n        gray = np.mean(image.astype(float), axis=2).flatten()\n    else:\n        gray = image.astype(float).flatten()\n    if gray.size == 0:\n        return 0.0\n    bins = 32\n    hist, edges = np.histogram(gray, bins=bins, range=(float(np.min(gray)), float(np.max(gray) + eps)))\n    if hist.sum() == 0:\n        return 0.0\n    # find top two peaks\n    idx_sorted = np.argsort(hist)[::-1]\n    top1 = idx_sorted[0]\n    top2 = idx_sorted[1] if idx_sorted.size > 1 else top1\n    center_vals = 0.5 * (edges[:-1] + edges[1:])\n    dist = abs(center_vals[top1] - center_vals[top2])\n    mass = float(hist[top1] + hist[top2]) / (np.sum(hist) + eps)\n    score = dist * mass\n    return float(score)\n\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Image aspect ratio (width / height) to capture framing/composition'\n    import numpy as np\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 1.0\n    h, w = image.shape[:2]\n    if h <= 0:\n        return 1.0\n    return float(w / float(h))\n",
  "def feature(image: np.ndarray) -> float:\n    'Normalized vertical (left-right) symmetry score: 1.0 = perfectly symmetric)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    if w < 2:\n        return 1.0\n    # compare overlapping halves\n    left = gray[:, :w//2]\n    right = np.fliplr(gray)[:, :w//2]\n    diff = np.abs(left - right)\n    mean_diff = float(np.mean(diff)) if diff.size else 0.0\n    mean_int = float(np.mean(np.abs(gray))) + eps\n    score = 1.0 - (mean_diff / (mean_int + eps))\n    # clamp\n    return float(max(0.0, min(1.0, score)))\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Signed vertical gradient bias (mean(gy)/mean(|gy|)), positive -> upward intensity change preference)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    gy, gx = np.gradient(gray)\n    mag_abs = np.abs(gy)\n    denom = float(np.mean(mag_abs)) + eps\n    bias = float(np.mean(gy)) / denom\n    # clamp to [-1,1]\n    bias = max(-1.0, min(1.0, bias))\n    return float(bias)\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Fraction of pixels that are highly blue and near the global maximum intensity (bright blue regions)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    img = image.astype(float)\n    maxv = float(np.max(img)) if img.size else 1.0\n    if maxv <= 0:\n        maxv = 1.0\n    if len(img.shape) == 2:\n        rgb = np.stack([img, img, img], axis=2)\n    else:\n        rgb = img\n    r = rgb[:, :, 0]; g = rgb[:, :, 1]; b = rgb[:, :, 2]\n    thr = 0.75 * maxv\n    mask = (b > thr) & (b > r) & (b > g)\n    total = float(r.size) + eps\n    return float(np.count_nonzero(mask) / total)\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Aspect ratio (width/height) of bounding box of brightest region (uses 90th percentile threshold)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    flat = gray.flatten()\n    if flat.size == 0:\n        return 0.0\n    thr = float(np.percentile(flat, 90))\n    mask = gray > thr\n    if not np.any(mask):\n        return 0.0\n    rows = np.any(mask, axis=1)\n    cols = np.any(mask, axis=0)\n    r_indices = np.where(rows)[0]\n    c_indices = np.where(cols)[0]\n    if r_indices.size == 0 or c_indices.size == 0:\n        return 0.0\n    rmin, rmax = int(r_indices[0]), int(r_indices[-1])\n    cmin, cmax = int(c_indices[0]), int(c_indices[-1])\n    width = float(cmax - cmin + 1)\n    height = float(rmax - rmin + 1) + eps\n    ratio = width / height\n    return float(ratio)\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Fraction of center-region pixels that are warm (red-dominant, e.g., brown/yellow hues)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    img = image.astype(float)\n    if len(img.shape) == 2:\n        rgb = np.stack([img, img, img], axis=2)\n    else:\n        rgb = img\n    h, w = rgb.shape[:2]\n    sr, sc = h//4, w//4\n    er, ec = h - sr, w - sc\n    region = rgb[sr:er, sc:ec, :] if (er > sr and ec > sc) else rgb\n    if region.size == 0:\n        return 0.0\n    r = region[:, :, 0]\n    g = region[:, :, 1]\n    b = region[:, :, 2]\n    maxv = float(np.max(region)) if region.size else 1.0\n    thr_rel = 0.12 * (maxv + eps)\n    warm = (r > g) & (r > b) & ((r - np.maximum(g, b)) > thr_rel)\n    return float(np.count_nonzero(warm) / (r.size + eps))\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Image colorfulness metric (Hasler & S\u00fcsstrunk) normalized by image max intensity)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    img = image.astype(float)\n    if len(img.shape) == 2:\n        R = img.flatten()\n        G = img.flatten()\n        B = img.flatten()\n    else:\n        R = img[:, :, 0].flatten()\n        G = img[:, :, 1].flatten()\n        B = img[:, :, 2].flatten()\n    if R.size == 0:\n        return 0.0\n    rg = R - G\n    yb = 0.5 * (R + G) - B\n    std_rg = float(np.std(rg))\n    std_yb = float(np.std(yb))\n    mean_rg = float(np.mean(rg))\n    mean_yb = float(np.mean(yb))\n    color = np.sqrt(std_rg**2 + std_yb**2) + 0.3 * np.sqrt(mean_rg**2 + mean_yb**2)\n    maxv = float(np.max(np.abs(np.concatenate([R, G, B])))) + eps\n    return float(color / maxv)\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Fraction of image rows that contain a significant number of strong edges (vertical span of edges)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    gy, gx = np.gradient(gray)\n    mag = np.sqrt(gx*gx + gy*gy)\n    thr = float(np.percentile(mag.flatten(), 75)) if mag.size else 0.0\n    per_row_counts = np.count_nonzero(mag > (thr + eps), axis=1)\n    # a row is active if it contains at least a small fraction of strong edge pixels\n    row_thr = max(1, w // 50)\n    active_rows = np.count_nonzero(per_row_counts >= row_thr)\n    return float(active_rows / (h + eps))\n",
  "def feature(image: np.ndarray) -> float:\n    'Edge density in the central region measured from gradient magnitude (higher -> more texture)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    # get grayscale\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    sr, sc = h // 4, w // 4\n    er, ec = h - sr, w - sc\n    region = gray[sr:er, sc:ec] if (er > sr and ec > sc) else gray\n    if region.size == 0:\n        return 0.0\n    gy, gx = np.gradient(region)\n    mag = np.sqrt(gx * gx + gy * gy)\n    # adaptive threshold: median + 0.5*std\n    thr = float(np.median(mag) + 0.5 * np.std(mag))\n    edge_frac = float(np.count_nonzero(mag > thr) / (mag.size + eps))\n    return float(edge_frac)\n\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Correlation between top and vertically flipped bottom blue channels (reflection indicator)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    # Ensure RGB\n    if len(image.shape) == 2:\n        rgb = np.stack([image, image, image], axis=2).astype(float)\n    else:\n        rgb = image.astype(float)\n    h = rgb.shape[0]\n    t = max(1, h // 3)\n    top = rgb[:t, :, 2].astype(float).reshape(-1)\n    bottom = rgb[-t:, :, 2].astype(float)\n    # flip bottom vertically to compare possible reflection\n    bottom_flipped = np.flipud(bottom).reshape(-1)\n    if top.size == 0 or bottom_flipped.size == 0:\n        return 0.0\n    # ensure same length (they are by construction) and compute Pearson correlation\n    top_mean = top.mean()\n    bot_mean = bottom_flipped.mean()\n    top_dev = top - top_mean\n    bot_dev = bottom_flipped - bot_mean\n    denom = np.sqrt(np.sum(top_dev * top_dev) * np.sum(bot_dev * bot_dev)) + eps\n    corr = float(np.sum(top_dev * bot_dev) / denom)\n    # clamp to [-1,1]\n    corr = max(-1.0, min(1.0, corr))\n    # shift to [0,1]\n    return float((corr + 1.0) / 2.0)\n\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Vertical vs horizontal gradient anisotropy (mean |dy| / mean |dx|)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 1.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    if gray.size == 0:\n        return 1.0\n    gy, gx = np.gradient(gray)\n    mean_vert = float(np.mean(np.abs(gy)))\n    mean_horz = float(np.mean(np.abs(gx)))\n    return float(mean_vert / (mean_horz + eps))\n\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Fraction difference: center green-dominant fraction minus blue-dominant fraction'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if len(image.shape) == 2:\n        rgb = np.stack([image, image, image], axis=2).astype(float)\n    else:\n        rgb = image.astype(float)\n    h, w = rgb.shape[:2]\n    sr, sc = h // 4, w // 4\n    er, ec = h - sr, w - sc\n    region = rgb[sr:er, sc:ec, :] if (er > sr and ec > sc) else rgb\n    if region.size == 0:\n        return 0.0\n    r = region[:, :, 0].reshape(-1)\n    g = region[:, :, 1].reshape(-1)\n    b = region[:, :, 2].reshape(-1)\n    green_frac = float(np.count_nonzero((g > r) & (g > b)) / (r.size + eps))\n    blue_frac = float(np.count_nonzero((b > r) & (b > g)) / (r.size + eps))\n    return float(green_frac - blue_frac)\n\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Standard deviation of approximate saturation in the center region (variation of colorfulness)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if len(image.shape) == 2:\n        rgb = np.stack([image, image, image], axis=2).astype(float)\n    else:\n        rgb = image.astype(float)\n    h, w = rgb.shape[:2]\n    sr, sc = h // 4, w // 4\n    er, ec = h - sr, w - sc\n    region = rgb[sr:er, sc:ec, :] if (er > sr and ec > sc) else rgb\n    if region.size == 0:\n        return 0.0\n    r = region[:, :, 0].astype(float)\n    g = region[:, :, 1].astype(float)\n    b = region[:, :, 2].astype(float)\n    mx = np.maximum(np.maximum(r, g), b)\n    mn = np.minimum(np.minimum(r, g), b)\n    sat = (mx - mn) / (mx + eps)\n    return float(np.std(sat))\n\n\n",
  "def feature(image: np.ndarray) -> float:\n    'High-frequency energy approximated by mean squared gradient (normalized by mean luminance)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    if gray.size == 0:\n        return 0.0\n    gy, gx = np.gradient(gray)\n    energy = np.mean(gx * gx + gy * gy)\n    mean_lum = float(np.mean(gray) + eps)\n    return float(energy / mean_lum)\n\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Maximum row-to-row jump in mean blue (horizon sharpness) normalized by mean blue'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    # ensure RGB\n    if len(image.shape) == 2:\n        b = image.astype(float)\n    else:\n        b = image[:, :, 2].astype(float)\n    h = b.shape[0]\n    if h <= 1 or b.size == 0:\n        return 0.0\n    row_mean = np.mean(b, axis=1)\n    diffs = np.abs(np.diff(row_mean))\n    if diffs.size == 0:\n        return 0.0\n    max_jump = float(np.max(diffs))\n    denom = (np.mean(row_mean) + eps)\n    return float(max_jump / denom)\n\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Vertical compactness of luminous content: normalized span of rows from 10% to 90% cumulative luminance'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 1.0\n    if len(image.shape) == 3:\n        lum = np.mean(image.astype(float), axis=2)\n    else:\n        lum = image.astype(float)\n    h, w = lum.shape[:2]\n    if lum.size == 0:\n        return 1.0\n    row_sum = np.sum(np.maximum(lum, 0.0), axis=1)\n    total = np.sum(row_sum) + eps\n    cum = np.cumsum(row_sum) / total\n    # find first index where cum >= 0.1 and last index where cum <= 0.9\n    low_idx = int(np.searchsorted(cum, 0.1))\n    high_idx = int(np.searchsorted(cum, 0.9))\n    # ensure at least one row\n    span = max(1, high_idx - low_idx)\n    # normalized span (smaller -> more compact)\n    norm_span = float(span / max(1, h - 1))\n    return float(norm_span)\n\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Euclidean color distance between center mean color and border mean color (normalized)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if len(image.shape) == 2:\n        rgb = np.stack([image, image, image], axis=2).astype(float)\n    else:\n        rgb = image.astype(float)\n    h, w = rgb.shape[:2]\n    sr, sc = h // 4, w // 4\n    er, ec = h - sr, w - sc\n    center = rgb[sr:er, sc:ec, :] if (er > sr and ec > sc) else rgb\n    t = max(1, min(h, w) // 8)\n    top = rgb[:t, :, :]\n    bottom = rgb[-t:, :, :]\n    left = rgb[:, :t, :]\n    right = rgb[:, -t:, :]\n    # compute means safely\n    def mean_color(arr):\n        arr = arr.reshape(-1, 3) if arr.size else np.zeros((0, 3))\n        return np.mean(arr, axis=0) if arr.size else np.array([0.0, 0.0, 0.0])\n    cmean = mean_color(center)\n    border_stack = np.concatenate([top.reshape(-1,3), bottom.reshape(-1,3), left.reshape(-1,3), right.reshape(-1,3)]) if rgb.size else np.zeros((0,3))\n    bmean = mean_color(border_stack)\n    diff = cmean - bmean\n    dist = float(np.sqrt(np.sum(diff * diff)))\n    # normalize by average intensity\n    norm = (np.mean((cmean + bmean) / 2.0) + eps)\n    return float(dist / norm)\n\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Fraction of strong edges that are more horizontal than vertical (edge directionality)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.5\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    if gray.size == 0:\n        return 0.5\n    gy, gx = np.gradient(gray)\n    mag = np.sqrt(gx * gx + gy * gy)\n    # strong edges mask: > median\n    thr = float(np.median(mag))\n    mask = mag > thr\n    total = np.count_nonzero(mask)\n    if total == 0:\n        return 0.5\n    horiz_count = np.count_nonzero(mask & (np.abs(gx) >= np.abs(gy)))\n    frac_horiz = float(horiz_count / total)\n    return float(frac_horiz)\n",
  "def feature(image: np.ndarray) -> float:\n    'Fraction of top-third pixels that are strongly blue-dominant (sky/blue area indicator)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if len(image.shape) == 2:\n        rgb = np.stack([image, image, image], axis=2).astype(float)\n    else:\n        rgb = image.astype(float)\n    h, w = rgb.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    top = rgb[:max(1, h // 3), :, :].reshape(-1, 3)\n    if top.size == 0:\n        return 0.0\n    R = top[:, 0] + eps\n    G = top[:, 1] + eps\n    B = top[:, 2] + eps\n    denom = R + G + B + eps\n    blue_chroma = B / denom\n    # require blue to be a clear majority of the pixel color\n    blue_mask = blue_chroma > 0.45\n    return float(np.count_nonzero(blue_mask) / (blue_mask.size + eps))\n\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Normalized grayscale entropy (0..1) measuring amount of texture/variety'\n    import numpy as np\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    vals = gray.flatten()\n    if vals.size == 0:\n        return 0.0\n    mn, mx = float(np.min(vals)), float(np.max(vals))\n    if mx <= mn:\n        return 0.0\n    bins = 32\n    hist, _ = np.histogram(vals, bins=bins, range=(mn, mx))\n    total = float(np.sum(hist)) + 1e-12\n    p = hist / total\n    p_nonzero = p[p > 0]\n    entropy = -np.sum(p_nonzero * np.log2(p_nonzero))\n    # normalize by maximum entropy log2(bins)\n    return float(entropy / (np.log2(bins) + 1e-12))\n\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Density of strong green-channel edges inside the image center (vegetation edge indicator)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if len(image.shape) == 2:\n        green = image.astype(float)\n    else:\n        green = image[:, :, 1].astype(float)\n    h, w = green.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    sr, sc = h // 4, w // 4\n    er, ec = h - sr, w - sc\n    region = green[sr:er, sc:ec] if (er > sr and ec > sc) else green\n    if region.size == 0:\n        return 0.0\n    gy, gx = np.gradient(region)\n    mag = np.sqrt(gx * gx + gy * gy)\n    thr = np.percentile(mag, 70)\n    strong = mag > (thr + eps)\n    return float(np.count_nonzero(strong) / (strong.size + eps))\n\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Fraction of strong edges that are near-vertical (vertical structural dominance)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    if gray.size == 0:\n        return 0.0\n    gy, gx = np.gradient(gray)\n    mag = np.sqrt(gx * gx + gy * gy)\n    if np.count_nonzero(mag) == 0:\n        return 0.0\n    thr = np.percentile(mag, 75)\n    strong = mag > (thr + eps)\n    orient = np.arctan2(gy, gx)  # -pi..pi\n    # distance to 0 or pi (vertical edges produce gradient near 0 or pi)\n    angle_dist = np.minimum(np.abs(orient), np.abs(np.pi - np.abs(orient)))\n    deg_thresh = 20.0 * np.pi / 180.0\n    vert_edges = strong & (angle_dist <= deg_thresh + eps)\n    total_strong = np.count_nonzero(strong)\n    return float(np.count_nonzero(vert_edges) / (total_strong + eps))\n\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Colorfulness metric (Hasler\u2013S\u00fcsstrunk) normalized by mean intensity'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if len(image.shape) == 2:\n        rgb = np.stack([image, image, image], axis=2).astype(float)\n    else:\n        rgb = image.astype(float)\n    r = rgb[:, :, 0].flatten()\n    g = rgb[:, :, 1].flatten()\n    b = rgb[:, :, 2].flatten()\n    if r.size == 0:\n        return 0.0\n    rg = r - g\n    yb = 0.5 * (r + g) - b\n    std_rg = float(np.std(rg))\n    std_yb = float(np.std(yb))\n    mean_rg = float(np.mean(rg))\n    mean_yb = float(np.mean(yb))\n    colorfulness = np.sqrt(std_rg * std_rg + std_yb * std_yb) + 0.3 * np.sqrt(mean_rg * mean_rg + mean_yb * mean_yb)\n    mean_int = float(np.mean((r + g + b) / 3.0) + eps)\n    return float(colorfulness / mean_int)\n\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Normalized brightness contrast between center region and border (center - border) / overall'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    sr, sc = h // 4, w // 4\n    er, ec = h - sr, w - sc\n    center = gray[sr:er, sc:ec] if (er > sr and ec > sc) else gray\n    t = max(1, min(h, w) // 8)\n    top = gray[:t, :] if t > 0 else np.array([])\n    bottom = gray[-t:, :] if t > 0 else np.array([])\n    left = gray[:, :t] if t > 0 else np.array([])\n    right = gray[:, -t:] if t > 0 else np.array([])\n    border_pieces = []\n    if top.size: border_pieces.append(top.flatten())\n    if bottom.size: border_pieces.append(bottom.flatten())\n    if left.size: border_pieces.append(left.flatten())\n    if right.size: border_pieces.append(right.flatten())\n    if len(border_pieces) == 0 or center.size == 0:\n        return 0.0\n    border = np.concatenate(border_pieces)\n    mean_center = float(np.mean(center))\n    mean_border = float(np.mean(border))\n    overall = float(np.mean(gray) + eps)\n    return float((mean_center - mean_border) / overall)\n\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Fraction of pixels that are bright white specular highlights (all channels saturated & neutral)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if len(image.shape) == 2:\n        rgb = np.stack([image, image, image], axis=2).astype(float)\n    else:\n        rgb = image.astype(float)\n    h, w = rgb.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    R = rgb[:, :, 0]\n    G = rgb[:, :, 1]\n    B = rgb[:, :, 2]\n    global_max = float(np.max(rgb) + eps)\n    thr = 0.95 * global_max\n    all_high = (R > thr) & (G > thr) & (B > thr)\n    # ensure near-neutral (min/max ratio close to 1)\n    pixel_min = np.minimum(np.minimum(R, G), B)\n    pixel_max = np.maximum(np.maximum(R, G), B) + eps\n    neutral = (pixel_min / pixel_max) > 0.9\n    mask = all_high & neutral\n    return float(np.count_nonzero(mask) / (h * w + eps))\n\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Mean absolute vertical gradient of blue channel normalized by mean intensity'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if len(image.shape) == 2:\n        blue = image.astype(float)\n    else:\n        blue = image[:, :, 2].astype(float)\n    if blue.size == 0:\n        return 0.0\n    gy, gx = np.gradient(blue)\n    mean_vert_grad = float(np.mean(np.abs(gy)))\n    mean_intensity = float(np.mean(blue) + eps)\n    return float(mean_vert_grad / (mean_intensity + eps))\n\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Center-region hue consistency (resultant vector magnitude of hue angles, 0-1)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if len(image.shape) == 2:\n        rgb = np.stack([image, image, image], axis=2).astype(float)\n    else:\n        rgb = image.astype(float)\n    h, w = rgb.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    sr, sc = h // 4, w // 4\n    er, ec = h - sr, w - sc\n    region = rgb[sr:er, sc:ec, :] if (er > sr and ec > sc) else rgb\n    if region.size == 0:\n        return 0.0\n    r = region[:, :, 0].flatten().astype(float)\n    g = region[:, :, 1].flatten().astype(float)\n    b = region[:, :, 2].flatten().astype(float)\n    # compute hue via stable arctan2 formulation\n    x = np.sqrt(3.0) * (g - b)\n    y = 2.0 * r - g - b\n    angles = np.arctan2(x, y)  # circular hue angle\n    cos_sum = float(np.sum(np.cos(angles)))\n    sin_sum = float(np.sum(np.sin(angles)))\n    n = float(angles.size) + eps\n    R = np.sqrt(cos_sum * cos_sum + sin_sum * sin_sum) / n\n    return float(np.clip(R, 0.0, 1.0))\n\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Left-right symmetry score (1 - normalized mean absolute difference between halves)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    if w < 2 or h == 0:\n        return 0.0\n    mid = w // 2\n    left = gray[:, :mid]\n    right = gray[:, w - mid:]\n    if left.size == 0 or right.size == 0:\n        return 0.0\n    right_flipped = right[:, ::-1]\n    # if widths differ (odd width), crop to min\n    min_w = min(left.shape[1], right_flipped.shape[1])\n    left_c = left[:, :min_w]\n    right_c = right_flipped[:, :min_w]\n    diff = np.abs(left_c - right_c)\n    mean_diff = float(np.mean(diff))\n    mean_int = float(np.mean(gray) + eps)\n    norm = mean_diff / (mean_int + eps)\n    score = 1.0 - np.clip(norm, 0.0, 1.0)\n    return float(score)\n",
  "def feature(image: np.ndarray) -> float:\n    'Fraction of image rows where mean blue is substantially greater than red and green (blue horizontal bands)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    img = image.astype(float)\n    h, w = img.shape[:2]\n    if img.ndim == 2:\n        R = G = B = img\n    else:\n        R, G, B = img[:, :, 0], img[:, :, 1], img[:, :, 2]\n    # per-row means\n    meanR = np.mean(R, axis=1)\n    meanG = np.mean(G, axis=1)\n    meanB = np.mean(B, axis=1)\n    # blue-dominant row criterion (tolerance)\n    thr = 5.0\n    blue_rows = (meanB > meanR + thr) & (meanB > meanG + thr)\n    return float(np.count_nonzero(blue_rows) / (h + eps))\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Mean gradient magnitude in the central region normalized by mean intensity'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    img = image.astype(float)\n    h, w = img.shape[:2]\n    if img.ndim == 3:\n        gray = np.mean(img, axis=2)\n    else:\n        gray = img\n    sr, sc = h // 4, w // 4\n    er, ec = h - sr, w - sc\n    region = gray[sr:er, sc:ec] if (er > sr and ec > sc) else gray\n    if region.size == 0:\n        return 0.0\n    gy, gx = np.gradient(region)\n    mag = np.sqrt(gx * gx + gy * gy)\n    mean_mag = float(np.mean(np.abs(mag)))\n    mean_int = float(np.mean(region) + eps)\n    return float(mean_mag / mean_int)\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Left-right color symmetry score (1 - normalized mean absolute difference between halves)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    img = image.astype(float)\n    h, w = img.shape[:2]\n    mid = w // 2\n    if img.ndim == 2:\n        left = img[:, :mid]\n        right = img[:, -mid:]\n        right_flipped = np.fliplr(right)\n        diff = np.abs(left[:, :right_flipped.shape[1]] - right_flipped)\n    else:\n        left = img[:, :mid, :]\n        right = img[:, -mid:, :]\n        right_flipped = np.fliplr(right)\n        minw = min(left.shape[1], right_flipped.shape[1])\n        left_c = left[:, :minw, :].astype(float)\n        right_c = right_flipped[:, :minw, :].astype(float)\n        diff = np.abs(left_c - right_c)\n    if diff.size == 0:\n        return 0.0\n    mean_diff = float(np.mean(diff))\n    mean_intensity = float(np.mean(img) + eps)\n    score = 1.0 - (mean_diff / mean_intensity)\n    return float(score)\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Normalized vertical centroid of brightness (0=top, 1=bottom)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    img = image.astype(float)\n    h, w = img.shape[:2]\n    if img.ndim == 3:\n        intensity = np.mean(img, axis=2)\n    else:\n        intensity = img\n    flat = intensity.flatten()\n    if flat.size == 0 or np.sum(flat) == 0:\n        return float(0.5)  # neutral center if no intensity\n    rows = np.arange(h)\n    row_weights = np.sum(intensity, axis=1)\n    weighted_sum = float(np.sum(rows * row_weights))\n    norm = float(np.sum(row_weights) + eps)\n    centroid = weighted_sum / norm\n    return float(centroid / max(1, h - 1))\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Fill ratio of bounding box of bright pixels (threshold mean+std): bright_count / bbox_area'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    img = image.astype(float)\n    if img.ndim == 3:\n        intensity = np.mean(img, axis=2)\n    else:\n        intensity = img\n    mean_i = float(np.mean(intensity))\n    std_i = float(np.std(intensity))\n    thr = mean_i + std_i\n    mask = intensity > thr\n    coords = np.argwhere(mask)\n    if coords.size == 0:\n        return 0.0\n    rmin, cmin = coords.min(axis=0)\n    rmax, cmax = coords.max(axis=0)\n    bbox_area = float((rmax - rmin + 1) * (cmax - cmin + 1) + eps)\n    bright_count = float(coords.shape[0])\n    return float(bright_count / bbox_area)\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Fraction of center-region pixels whose color is similar to the center pixel color (color coherence)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    img = image.astype(float)\n    h, w = img.shape[:2]\n    sr, sc = h // 4, w // 4\n    er, ec = h - sr, w - sc\n    if img.ndim == 2:\n        region = img[sr:er, sc:ec]\n        center_col = img[h // 2, w // 2]\n        dif = np.abs(region - center_col)\n        d = dif.flatten()\n        thr = 15.0\n        similar = d <= thr\n        return float(np.count_nonzero(similar) / (d.size + eps))\n    else:\n        region = img[sr:er, sc:ec, :].astype(float) if (er > sr and ec > sc) else img.astype(float)\n        center = img[h // 2, w // 2, :].astype(float)\n        if region.size == 0:\n            return 0.0\n        diff = region - center.reshape((1, 1, 3))\n        dist = np.sqrt(np.sum(diff * diff, axis=2)).flatten()\n        # threshold relative to mean intensity\n        mean_int = float(np.mean(np.mean(region, axis=2)) + eps)\n        thr = max(10.0, 0.25 * mean_int)\n        return float(np.count_nonzero(dist <= thr) / (dist.size + eps))\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Ratio of mean blue in lower third to mean blue in upper third (vertical blue concentration)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    img = image.astype(float)\n    h = img.shape[0]\n    t = max(1, h // 3)\n    if img.ndim == 2:\n        lower = img[-t:, :]\n        upper = img[:t, :]\n        meanB_lower = float(np.mean(lower))\n        meanB_upper = float(np.mean(upper))\n    else:\n        meanB_lower = float(np.mean(img[-t:, :, 2]))\n        meanB_upper = float(np.mean(img[:t, :, 2]))\n    return float(meanB_lower / (meanB_upper + eps))\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Fraction of very dark pixels that are green-biased (dark-vegetation indicator)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    img = image.astype(float)\n    if img.ndim == 2:\n        intensity = img\n        # in grayscale treat as non-green\n        dark_mask = intensity <= np.percentile(intensity.flatten(), 5)\n        if np.count_nonzero(dark_mask) == 0:\n            return 0.0\n        return 0.0\n    else:\n        intensity = np.mean(img, axis=2)\n        flat = intensity.flatten()\n        if flat.size == 0:\n            return 0.0\n        thr = np.percentile(flat, 5)\n        dark_mask = intensity <= thr\n        if np.count_nonzero(dark_mask) == 0:\n            return 0.0\n        R = img[:, :, 0]\n        G = img[:, :, 1]\n        B = img[:, :, 2]\n        green_dark = (G > R) & (G > B) & dark_mask\n        return float(np.count_nonzero(green_dark) / (np.count_nonzero(dark_mask) + eps))\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Ratio of mean absolute Laplacian to mean gradient magnitude in the image (high-frequency emphasis)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    img = image.astype(float)\n    if img.ndim == 3:\n        gray = np.mean(img, axis=2)\n    else:\n        gray = img\n    gy, gx = np.gradient(gray)\n    mag = np.sqrt(gx * gx + gy * gy)\n    # second derivatives\n    gxx, _ = np.gradient(gx)\n    _, gyy = np.gradient(gy)\n    lap = gxx + gyy\n    mean_abs_lap = float(np.mean(np.abs(lap)))\n    mean_abs_grad = float(np.mean(np.abs(mag)) + eps)\n    return float(mean_abs_lap / mean_abs_grad)\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Ratio of horizontal to vertical edge energy in the central region (orientation bias)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    img = image.astype(float)\n    h, w = img.shape[:2]\n    if img.ndim == 3:\n        gray = np.mean(img, axis=2)\n    else:\n        gray = img\n    sr, sc = h // 4, w // 4\n    er, ec = h - sr, w - sc\n    region = gray[sr:er, sc:ec] if (er > sr and ec > sc) else gray\n    if region.size == 0:\n        return 0.0\n    gy, gx = np.gradient(region)\n    horiz_energy = float(np.mean(np.abs(gx)))\n    vert_energy = float(np.mean(np.abs(gy)))\n    return float(horiz_energy / (vert_energy + eps))\n",
  "def feature(image: np.ndarray) -> float:\n    'Fraction of pixels that are bright blue-dominant (simple sky/water indicator)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    img = image.astype(float)\n    if len(img.shape) == 2:\n        rgb = np.stack([img, img, img], axis=2)\n    else:\n        rgb = img\n    r = rgb[:, :, 0]\n    g = rgb[:, :, 1]\n    b = rgb[:, :, 2]\n    meanB = np.mean(b)\n    mask = (b > r * 1.05) & (b > g * 1.05) & (b > meanB)\n    return float(np.count_nonzero(mask) / (r.size + eps))\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Normalized centroid distance of high-saturation regions from image center (0=centered)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    img = image.astype(float)\n    if len(img.shape) == 2:\n        rgb = np.stack([img, img, img], axis=2)\n    else:\n        rgb = img\n    h, w = rgb.shape[:2]\n    r = rgb[:, :, 0]\n    g = rgb[:, :, 1]\n    b = rgb[:, :, 2]\n    mx = np.maximum(np.maximum(r, g), b)\n    mn = np.minimum(np.minimum(r, g), b)\n    sat = (mx - mn) / (mx + eps)\n    thr = np.percentile(sat.flatten(), 80) if sat.size else 1.0\n    mask = sat >= thr\n    if np.count_nonzero(mask) == 0:\n        return 0.0\n    rows, cols = np.nonzero(mask)\n    cy, cx = rows.mean(), cols.mean()\n    center_y, center_x = (h - 1) / 2.0, (w - 1) / 2.0\n    dist = np.sqrt((cy - center_y) ** 2 + (cx - center_x) ** 2)\n    diag = np.sqrt(h * h + w * w) + eps\n    norm = float(dist / diag)\n    return float(min(1.0, max(0.0, norm)))\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Edge density: fraction of pixels with gradient magnitude above mean+std'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    gy, gx = np.gradient(gray)\n    mag = np.sqrt(gx * gx + gy * gy)\n    thr = float(np.mean(mag) + np.std(mag))\n    return float(np.count_nonzero(mag > thr) / (mag.size + eps))\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Left-right mirror symmetry score in grayscale (1.0 = perfect symmetry)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    flipped = np.fliplr(gray)\n    # crop to common width if odd width still same shape\n    diff = np.abs(gray - flipped)\n    mean_diff = float(np.mean(diff))\n    denom = float(np.mean(np.abs(gray - np.mean(gray)))) + eps\n    score = 1.0 - (mean_diff / (denom + eps))\n    score = max(0.0, min(1.0, score))\n    return float(score)\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Relative top-quarter vs bottom-quarter mean luminance (top / bottom)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    img = image.astype(float)\n    if len(img.shape) == 2:\n        rgb = np.stack([img, img, img], axis=2)\n    else:\n        rgb = img\n    h, w = rgb.shape[:2]\n    t = max(1, h // 4)\n    top = rgb[:t, :, :]\n    bottom = rgb[-t:, :, :]\n    def lum(arr):\n        R = arr[..., 0]; G = arr[..., 1]; B = arr[..., 2]\n        return 0.299 * R + 0.587 * G + 0.114 * B\n    mean_top = float(np.mean(lum(top))) if top.size else 0.0\n    mean_bottom = float(np.mean(lum(bottom))) if bottom.size else 0.0\n    return float(mean_top / (mean_bottom + eps))\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Laplacian variance (approx.) as a sharpness / texture measure'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    gx, gy = np.gradient(gray)\n    gxx, _ = np.gradient(gx)\n    _, gyy = np.gradient(gy)\n    lap = gxx + gyy\n    var = float(np.var(lap))\n    # scale down by mean intensity to keep roughly comparable across images\n    mean_int = float(np.mean(np.abs(gray))) + eps\n    return float(var / mean_int)\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Longest consecutive horizontal band of rows with >30% blue pixels (fraction of image height)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if len(image.shape) == 2:\n        return 0.0\n    rgb = image.astype(float)\n    r = rgb[:, :, 0]; g = rgb[:, :, 1]; b = rgb[:, :, 2]\n    h, w = b.shape\n    row_frac = np.sum((b > r * 1.05) & (b > g * 1.05), axis=1) / float(max(1, w))\n    band_bool = row_frac > 0.30\n    # compute longest run of True in band_bool\n    longest = 0\n    cur = 0\n    for v in band_bool:\n        if v:\n            cur += 1\n            if cur > longest:\n                longest = cur\n        else:\n            cur = 0\n    return float(longest / float(max(1, h)))\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Fraction of specular highlights (very bright, low-chroma pixels) indicating reflections'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    img = image.astype(float)\n    if len(img.shape) == 2:\n        rgb = np.stack([img, img, img], axis=2)\n    else:\n        rgb = img\n    R = rgb[:, :, 0]; G = rgb[:, :, 1]; B = rgb[:, :, 2]\n    mx = np.maximum(np.maximum(R, G), B)\n    mn = np.minimum(np.minimum(R, G), B)\n    chroma = mx - mn\n    lum = 0.299 * R + 0.587 * G + 0.114 * B\n    thr_lum = np.percentile(lum.flatten(), 95) if lum.size else np.max(lum)\n    max_chroma = float(np.max(chroma)) + eps\n    mask = (lum >= thr_lum) & (chroma <= 0.1 * max_chroma)\n    return float(np.count_nonzero(mask) / (R.size + eps))\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Mean per-pixel normalized blue excess: (B - (R+G)/2) / (R+G+B) averaged over image'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    img = image.astype(float)\n    if len(img.shape) == 2:\n        rgb = np.stack([img, img, img], axis=2)\n    else:\n        rgb = img\n    r = rgb[:, :, 0]; g = rgb[:, :, 1]; b = rgb[:, :, 2]\n    denom = r + g + b + eps\n    blue_excess = (b - 0.5 * (r + g)) / denom\n    # average positive excess only to focus on blue dominance\n    pos = blue_excess > 0\n    if np.count_nonzero(pos) == 0:\n        return 0.0\n    return float(np.mean(blue_excess[pos]))\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Difference between top-half and bottom-half green-dominant pixel fractions (top - bottom)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    img = image.astype(float)\n    if len(img.shape) == 2:\n        rgb = np.stack([img, img, img], axis=2)\n    else:\n        rgb = img\n    h = rgb.shape[0]\n    mid = h // 2\n    top = rgb[:mid, :, :]\n    bottom = rgb[mid:, :, :]\n    def green_frac(arr):\n        if arr.size == 0:\n            return 0.0\n        R = arr[:, :, 0]; G = arr[:, :, 1]; B = arr[:, :, 2]\n        mask = (G > R) & (G > B)\n        return float(np.count_nonzero(mask) / (R.size + eps))\n    return float(green_frac(top) - green_frac(bottom))\n",
  "def feature(image: np.ndarray) -> float:\n    'Ratio of mean blue in the bottom half to the top half (water often occupies lower region)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    img = image.astype(float)\n    h, w = img.shape[:2]\n    mid = h // 2\n    if img.ndim == 2:\n        top = img[:mid, :]\n        bottom = img[mid:, :]\n        mean_top = float(np.mean(top)) if top.size else 0.0\n        mean_bottom = float(np.mean(bottom)) if bottom.size else 0.0\n    else:\n        mean_top = float(np.mean(img[:mid, :, 2])) if img[:mid, :, :].size else 0.0\n        mean_bottom = float(np.mean(img[mid:, :, 2])) if img[mid:, :, :].size else 0.0\n    return float(mean_bottom / (mean_top + eps))\n\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Normalized vertical centroid (0..1) of blue-dominant pixels (where blue areas concentrate)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.5\n    img = image.astype(float)\n    h = img.shape[0]\n    if img.ndim == 2:\n        rgb = np.stack([img, img, img], axis=2)\n    else:\n        rgb = img\n    R, G, B = rgb[:, :, 0], rgb[:, :, 1], rgb[:, :, 2]\n    mask = (B > 1.05 * G) & (B > 1.05 * R)\n    if not np.any(mask):\n        return 0.5\n    rows = np.where(mask)[0]\n    centroid_row = float(np.mean(rows))\n    return float(centroid_row / float(max(1, h - 1)))\n\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Compactness-weighted bounding-box area fraction of blue-dominant pixels (large contiguous blue regions)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    img = image.astype(float)\n    h, w = img.shape[:2]\n    if img.ndim == 2:\n        rgb = np.stack([img, img, img], axis=2)\n    else:\n        rgb = img\n    R, G, B = rgb[:, :, 0], rgb[:, :, 1], rgb[:, :, 2]\n    mask = (B > 1.10 * G) & (B > 1.10 * R)\n    total = float(h * w) + eps\n    count = float(np.count_nonzero(mask))\n    if count == 0.0:\n        return 0.0\n    ys, xs = np.where(mask)\n    miny, maxy = int(np.min(ys)), int(np.max(ys))\n    minx, maxx = int(np.min(xs)), int(np.max(xs))\n    bbox_area = float((maxy - miny + 1) * (maxx - minx + 1))\n    bbox_frac = bbox_area / total\n    mask_frac = count / total\n    # prefer concentrated large blue regions -> multiply density by bbox coverage\n    return float(mask_frac * bbox_frac)\n\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Normalized mean gradient magnitude divided by mean brightness (texture energy indicator)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if image.ndim == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    gy, gx = np.gradient(gray)\n    mag = np.sqrt(gx * gx + gy * gy)\n    mean_mag = float(np.mean(mag)) if mag.size else 0.0\n    mean_brightness = float(np.mean(gray)) + eps\n    return float(mean_mag / mean_brightness)\n\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Ratio of horizontal-edge strength to vertical-edge strength (horiz/vert) to detect horizon-like patterns'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 1.0\n    if image.ndim == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    gy, gx = np.gradient(gray)\n    sum_horiz = float(np.sum(np.abs(gy)))\n    sum_vert = float(np.sum(np.abs(gx)))\n    if sum_vert + eps == 0:\n        return float(sum_horiz)\n    return float(sum_horiz / (sum_vert + eps))\n\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Fraction of lower-third pixels that are green-dominant and chromatic (vegetation at bottom)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    img = image.astype(float)\n    h, w = img.shape[:2]\n    start = (2 * h) // 3\n    region = img[start:, :, :] if img.ndim == 3 else img[start:, :]\n    if region.size == 0:\n        return 0.0\n    if region.ndim == 2:\n        r = region.flatten()\n        g = region.flatten()\n        b = region.flatten()\n    else:\n        r = region[:, :, 0].flatten()\n        g = region[:, :, 1].flatten()\n        b = region[:, :, 2].flatten()\n    mx = np.maximum(np.maximum(r, g), b)\n    mn = np.minimum(np.minimum(r, g), b)\n    chroma = mx - mn\n    dyn = float(np.max(mx) - np.min(mn) + eps)\n    thr = 0.06 * dyn\n    green_mask = (g > r) & (g > b) & (chroma >= thr)\n    return float(np.count_nonzero(green_mask) / (green_mask.size + eps))\n\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Fraction of center-region pixels that are red-dominant (warm/brown tones suggesting land)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    img = image.astype(float)\n    h, w = img.shape[:2]\n    sr, sc = h // 4, w // 4\n    er, ec = h - sr, w - sc\n    region = img[sr:er, sc:ec, :] if (img.ndim == 3 and er > sr and ec > sc) else (img[sr:er, sc:ec] if (img.ndim == 2 and er > sr and ec > sc) else img)\n    if region.size == 0:\n        return 0.0\n    if region.ndim == 2:\n        r = region.flatten()\n        g = region.flatten()\n        b = region.flatten()\n    else:\n        r = region[:, :, 0].flatten()\n        g = region[:, :, 1].flatten()\n        b = region[:, :, 2].flatten()\n    red_mask = (r > g) & (r > b)\n    return float(np.count_nonzero(red_mask) / (red_mask.size + eps))\n\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Variance of mean brightness across four quadrants (large-scale color/brightness heterogeneity)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    img = image.astype(float)\n    h, w = img.shape[:2]\n    hm, wm = h // 2, w // 2\n    def mean_quad(r0, r1, c0, c1):\n        sub = img[r0:r1, c0:c1]\n        if sub.size == 0:\n            return 0.0\n        if sub.ndim == 3:\n            return float(np.mean(np.mean(sub, axis=2)))\n        return float(np.mean(sub))\n    m1 = mean_quad(0, hm, 0, wm)\n    m2 = mean_quad(0, hm, wm, w)\n    m3 = mean_quad(hm, h, 0, wm)\n    m4 = mean_quad(hm, h, wm, w)\n    vals = np.array([m1, m2, m3, m4], dtype=float)\n    return float(np.var(vals))\n\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Relative brightness difference between bottom quarter and top quarter normalized by overall brightness'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    img = image.astype(float)\n    h = img.shape[0]\n    q = max(1, h // 4)\n    top = img[:q, :]\n    bottom = img[-q:, :]\n    if top.size == 0 or bottom.size == 0:\n        return 0.0\n    if img.ndim == 3:\n        mean_top = float(np.mean(np.mean(top, axis=2)))\n        mean_bottom = float(np.mean(np.mean(bottom, axis=2)))\n        mean_all = float(np.mean(np.mean(img, axis=2))) + eps\n    else:\n        mean_top = float(np.mean(top))\n        mean_bottom = float(np.mean(bottom))\n        mean_all = float(np.mean(img)) + eps\n    return float((mean_bottom - mean_top) / mean_all)\n\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Skew-like saturation metric: (mean - median) / (std + eps) of per-pixel saturation'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    img = image.astype(float)\n    if img.ndim == 2:\n        rgb = np.stack([img, img, img], axis=2)\n    else:\n        rgb = img\n    mx = np.max(rgb, axis=2)\n    mn = np.min(rgb, axis=2)\n    sat = (mx - mn) / (mx + eps)\n    if sat.size == 0:\n        return 0.0\n    mean_sat = float(np.mean(sat))\n    med_sat = float(np.median(sat))\n    std_sat = float(np.std(sat))\n    return float((mean_sat - med_sat) / (std_sat + eps))\n",
  "def feature(image: np.ndarray) -> float:\n    'Fraction of top-quartile rows that are blue-dominant (sky/water indicator)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if len(image.shape) == 2:\n        rgb = np.stack([image, image, image], axis=2).astype(float)\n    else:\n        rgb = image.astype(float)\n    h = rgb.shape[0]\n    t = max(1, h // 4)\n    top = rgb[:t, :, :]\n    if top.size == 0:\n        return 0.0\n    r = top[:, :, 0]\n    g = top[:, :, 1]\n    b = top[:, :, 2]\n    # blue-dominant and reasonably bright relative to local top brightness\n    bright_thresh = np.percentile((r + g + b) / 3.0, 50) if top.size else 0.0\n    mask = (b > g) & (b > r) & (b > bright_thresh * 0.8)\n    return float(np.count_nonzero(mask) / (mask.size + eps))\n\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Proportion of green-dominant pixels in the central region (vegetation mass proxy)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if len(image.shape) == 2:\n        rgb = np.stack([image, image, image], axis=2).astype(float)\n    else:\n        rgb = image.astype(float)\n    h, w = rgb.shape[:2]\n    sr, sc = h // 4, w // 4\n    er, ec = h - sr, w - sc\n    region = rgb[sr:er, sc:ec, :] if (er > sr and ec > sc) else rgb\n    if region.size == 0:\n        return 0.0\n    r = region[:, :, 0].flatten()\n    g = region[:, :, 1].flatten()\n    b = region[:, :, 2].flatten()\n    green_mask = (g > r) & (g > b)\n    return float(np.count_nonzero(green_mask) / (green_mask.size + eps))\n\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Mean absolute horizontal gradient (vertical changes) normalized by intensity'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    if gray.size == 0:\n        return 0.0\n    grad = np.gradient(gray)\n    # grad[0] = d/drow (vertical changes) -> corresponds to horizontal edges\n    vert_change = np.abs(grad[0])\n    return float(np.mean(vert_change) / (np.mean(gray) + eps))\n\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Mean absolute difference between blue channel and vertically flipped blue (reflection symmetry)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if len(image.shape) == 2:\n        b = image.astype(float)\n    else:\n        b = image[:, :, 2].astype(float)\n    if b.size == 0:\n        return 0.0\n    flipped = np.flipud(b)\n    # pad or crop to common shape (should be same)\n    if flipped.shape != b.shape:\n        minr = min(flipped.shape[0], b.shape[0])\n        minc = min(flipped.shape[1], b.shape[1])\n        b_crop = b[:minr, :minc]\n        f_crop = flipped[:minr, :minc]\n    else:\n        b_crop = b\n        f_crop = flipped\n    diff = np.abs(b_crop - f_crop)\n    norm = (np.mean(b_crop) + eps)\n    return float(np.mean(diff) / norm)\n\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Skewness of approximate saturation in the central region (color distribution asymmetry)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if len(image.shape) == 2:\n        rgb = np.stack([image, image, image], axis=2).astype(float)\n    else:\n        rgb = image.astype(float)\n    h, w = rgb.shape[:2]\n    sr, sc = h // 4, w // 4\n    er, ec = h - sr, w - sc\n    region = rgb[sr:er, sc:ec, :] if (er > sr and ec > sc) else rgb\n    if region.size == 0:\n        return 0.0\n    r = region[:, :, 0].astype(float).flatten()\n    g = region[:, :, 1].astype(float).flatten()\n    b = region[:, :, 2].astype(float).flatten()\n    mx = np.maximum(np.maximum(r, g), b)\n    mn = np.minimum(np.minimum(r, g), b)\n    sat = (mx - mn) / (mx + eps)\n    if sat.size == 0:\n        return 0.0\n    mu = np.mean(sat)\n    sigma = np.std(sat)\n    skew = np.mean((sat - mu) ** 3) / (sigma ** 3 + eps)\n    return float(skew)\n\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Relative low-frequency (large-block) energy: variance of block-means normalized by global variance'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if len(image.shape) == 2:\n        img = np.stack([image, image, image], axis=2).astype(float)\n    else:\n        img = image.astype(float)\n    h, w = img.shape[:2]\n    bh = max(1, h // 8)\n    bw = max(1, w // 8)\n    nh = h // bh\n    nw = w // bw\n    if nh == 0 or nw == 0:\n        return 0.0\n    hh = nh * bh\n    ww = nw * bw\n    cropped = img[:hh, :ww, :]\n    # reshape to (nh, bh, nw, bw, 3) and average over block dims\n    try:\n        blocks = cropped.reshape(nh, bh, nw, bw, 3)\n        block_means = blocks.mean(axis=(1, 3))  # shape (nh, nw, 3)\n    except Exception:\n        # fallback: use simple coarse downsample by striding\n        block_means = cropped.reshape(nh, bh, nw, bw, 3).mean(axis=(1,3))\n    flat_block = block_means.reshape(-1, 3)\n    low_freq_var = np.var(flat_block)\n    global_var = np.var(cropped)\n    return float(low_freq_var / (global_var + eps))\n\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Ratio of mean blue to mean green among the brightest quarter of pixels (bright-color bias)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if len(image.shape) == 2:\n        rgb = np.stack([image, image, image], axis=2).astype(float)\n    else:\n        rgb = image.astype(float)\n    intensity = np.mean(rgb, axis=2)\n    if intensity.size == 0:\n        return 0.0\n    thresh = np.percentile(intensity.flatten(), 75)\n    mask = intensity >= thresh\n    if np.count_nonzero(mask) == 0:\n        return 0.0\n    meanB = float(np.mean(rgb[:, :, 2][mask]))\n    meanG = float(np.mean(rgb[:, :, 1][mask]))\n    return float(meanB / (meanG + eps))\n\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Normalized Euclidean distance between center and border mean colors (foreground vs background contrast)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if len(image.shape) == 2:\n        rgb = np.stack([image, image, image], axis=2).astype(float)\n    else:\n        rgb = image.astype(float)\n    h, w = rgb.shape[:2]\n    sr, sc = h // 4, w // 4\n    er, ec = h - sr, w - sc\n    center = rgb[sr:er, sc:ec, :] if (er > sr and ec > sc) else rgb\n    t = max(1, min(h, w) // 8)\n    top = rgb[:t, :, :]\n    bottom = rgb[-t:, :, :]\n    left = rgb[:, :t, :]\n    right = rgb[:, -t:, :]\n    border_parts = []\n    for part in (top, bottom, left, right):\n        if part.size:\n            border_parts.append(part.reshape(-1, 3))\n    if center.size == 0 or len(border_parts) == 0:\n        return 0.0\n    border = np.concatenate(border_parts, axis=0)\n    cm = np.mean(center.reshape(-1, 3), axis=0)\n    bm = np.mean(border, axis=0)\n    dist = np.linalg.norm(cm - bm)\n    norm = (np.mean(rgb) + eps)\n    return float(dist / norm)\n\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Fraction of pixels above the 95th intensity percentile (specular/highlight fraction)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if len(image.shape) == 2:\n        gray = image.astype(float)\n    else:\n        gray = np.mean(image, axis=2).astype(float)\n    vals = gray.flatten()\n    if vals.size == 0:\n        return 0.0\n    p95 = np.percentile(vals, 95)\n    mask = vals >= p95\n    return float(np.count_nonzero(mask) / (vals.size + eps))\n\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Pearson correlation between row index and mean blue per row (vertical blue trend)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if len(image.shape) == 2:\n        b = image.astype(float)\n    else:\n        b = image[:, :, 2].astype(float)\n    h = b.shape[0]\n    if h == 0:\n        return 0.0\n    row_mean = np.mean(b, axis=1)\n    rows = np.arange(row_mean.shape[0]).astype(float)\n    rm_mean = np.mean(row_mean)\n    rows_mean = np.mean(rows)\n    cov = np.mean((rows - rows_mean) * (row_mean - rm_mean))\n    stds = (np.std(rows) * np.std(row_mean) + eps)\n    corr = cov / stds\n    return float(corr)\n",
  "def feature(image: np.ndarray) -> float:\n    'Ratio of horizontal-edge strength to vertical-edge strength in the central region'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    arr = image.astype(float)\n    h, w = arr.shape[:2]\n    # convert to gray\n    if arr.ndim == 3:\n        gray = np.mean(arr, axis=2)\n    else:\n        gray = arr\n    # central region\n    sr, sc = h // 4, w // 4\n    er, ec = h - sr, w - sc\n    region = gray[sr:er, sc:ec] if (er > sr and ec > sc) else gray\n    if region.size == 0:\n        return 0.0\n    gy, gx = np.gradient(region)\n    # vertical gradient (gy) corresponds to horizontal edges\n    horiz_strength = np.mean(np.abs(gy))\n    vert_strength = np.mean(np.abs(gx))\n    return float(horiz_strength / (vert_strength + eps))\n\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Difference between fraction of blue-dominant pixels in bottom half and top half'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    img = image.astype(float)\n    h, w = img.shape[:2]\n    if img.ndim == 2:\n        rgb = np.stack([img, img, img], axis=2)\n    else:\n        rgb = img\n    half = max(1, h // 2)\n    top = rgb[:half, :, :]\n    bottom = rgb[half:, :, :]\n    def blue_frac(block):\n        if block.size == 0:\n            return 0.0\n        r = block[:, :, 0].flatten()\n        g = block[:, :, 1].flatten()\n        b = block[:, :, 2].flatten()\n        mx = np.maximum(np.maximum(r, g), b) + eps\n        mask = (b > r) & (b > g) & (mx > 0.05 * (mx.max() + eps))\n        return float(np.count_nonzero(mask) / (mask.size + eps))\n    return float(blue_frac(bottom) - blue_frac(top))\n\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Normalized center-to-border mean intensity ratio (center_mean / border_mean)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    arr = image.astype(float)\n    h, w = arr.shape[:2]\n    if arr.ndim == 3:\n        gray = np.mean(arr, axis=2)\n    else:\n        gray = arr\n    sr, sc = h // 4, w // 4\n    er, ec = h - sr, w - sc\n    center = gray[sr:er, sc:ec] if (er > sr and ec > sc) else gray\n    t = max(1, min(h, w) // 8)\n    top = gray[:t, :]\n    bottom = gray[-t:, :]\n    left = gray[:, :t]\n    right = gray[:, -t:]\n    border_pixels = np.concatenate([top.ravel(), bottom.ravel(), left.ravel(), right.ravel()]) if gray.size else np.array([0.0])\n    if center.size == 0 or border_pixels.size == 0:\n        return 0.0\n    center_mean = float(np.mean(center))\n    border_mean = float(np.mean(border_pixels) + eps)\n    return float(center_mean / border_mean)\n\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Normalized offset of the strongest horizontal-edge row (horizon-like) from image center'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    arr = image.astype(float)\n    h, w = arr.shape[:2]\n    if arr.ndim == 3:\n        gray = np.mean(arr, axis=2)\n    else:\n        gray = arr\n    gy, gx = np.gradient(gray)\n    # horizontal-edge energy per row = sum of absolute vertical gradient across columns\n    row_energy = np.sum(np.abs(gy), axis=1)\n    if row_energy.size == 0:\n        return 0.0\n    row_idx = int(np.argmax(row_energy))\n    # normalized from -0.5..0.5 (positive means horizon below center)\n    offset = (row_idx - (h / 2.0)) / float(h + eps)\n    return float(offset)\n\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Fraction of low-texture, blue-dominant blocks (uniform blue area fraction)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    arr = image.astype(float)\n    h, w = arr.shape[:2]\n    if arr.ndim == 2:\n        rgb = np.stack([arr, arr, arr], axis=2)\n    else:\n        rgb = arr\n    block = 16\n    bh = max(1, min(h, w) // block)\n    bh_pixels = max(1, h // bh)\n    bw_pixels = max(1, w // bh)\n    # iterate blocks roughly of size ~16 but robust for small images\n    counts = 0\n    total = 0\n    for r in range(0, h, bh_pixels):\n        for c in range(0, w, bw_pixels):\n            blk = rgb[r:min(r+bh_pixels, h), c:min(c+bw_pixels, w), :]\n            total += 1\n            if blk.size == 0:\n                continue\n            rch = float(np.mean(blk[:, :, 0]))\n            gch = float(np.mean(blk[:, :, 1]))\n            bch = float(np.mean(blk[:, :, 2]))\n            stdblk = float(np.mean(np.std(blk.reshape(-1, 3), axis=0)))\n            if (bch > rch) and (bch > gch) and (stdblk < 12.0):  # thresholds tuned for uint8 images\n                counts += 1\n    return float(counts / (total + eps))\n\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Length of longest horizontal run of blue-dominant bright pixels in the top third normalized by width'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    img = image.astype(float)\n    h, w = img.shape[:2]\n    top_h = max(1, h // 3)\n    if img.ndim == 2:\n        rgb = np.stack([img, img, img], axis=2)\n    else:\n        rgb = img\n    top = rgb[:top_h, :, :]\n    if top.size == 0:\n        return 0.0\n    r = top[:, :, 0]\n    g = top[:, :, 1]\n    b = top[:, :, 2]\n    mx = np.maximum(np.maximum(r, g), b) + eps\n    mask = (b > r) & (b > g) & (mx > 0.1 * (mx.max() + eps))\n    max_run = 0\n    for row in mask:\n        # find longest contiguous True in row\n        if not row.any():\n            continue\n        # compute run lengths efficiently\n        dif = np.diff(np.concatenate([[0], row.astype(int), [0]]))\n        starts = np.where(dif == 1)[0]\n        ends = np.where(dif == -1)[0]\n        runs = ends - starts\n        if runs.size:\n            max_run = max(max_run, runs.max())\n    return float(max_run / (w + eps))\n\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Normalized high-frequency energy in the green channel (mean gradient magnitude / mean intensity)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    arr = image.astype(float)\n    h, w = arr.shape[:2]\n    if arr.ndim == 2:\n        green = arr\n    else:\n        green = arr[:, :, 1]\n    if green.size == 0:\n        return 0.0\n    gy, gx = np.gradient(green)\n    grad_mag = np.sqrt(gy * gy + gx * gx)\n    mean_grad = float(np.mean(grad_mag))\n    mean_int = float(np.mean(green) + eps)\n    return float(mean_grad / mean_int)\n\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Fraction of edge orientations within \u00b122.5\u00b0 of horizontal (indicates prevalence of horizontal structures)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    arr = image.astype(float)\n    if arr.ndim == 3:\n        gray = np.mean(arr, axis=2)\n    else:\n        gray = arr\n    gy, gx = np.gradient(gray)\n    if gx.size == 0:\n        return 0.0\n    # orientation angle = arctan2(gy, gx); horizontal edges have angle near 0 or pi -> gy ~ 0\n    angles = np.arctan2(gy, gx)  # range [-pi, pi]\n    # map angles to absolute deviation from horizontal: treat both 0 and pi same\n    # compute minimal angle to 0 or pi\n    ang0 = np.abs(angles)\n    angpi = np.abs(np.abs(angles) - np.pi)\n    dev = np.minimum(ang0, angpi)\n    threshold = np.deg2rad(22.5)\n    mask = (dev <= threshold) & (np.sqrt(gx * gx + gy * gy) > 1e-3)\n    return float(np.count_nonzero(mask) / (angles.size + eps))\n\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Scene warmth index: normalized (meanR - meanB) / (meanR + meanB) indicating warm vs cool coloring'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    arr = image.astype(float)\n    if arr.ndim == 2:\n        r = g = b = arr\n    else:\n        r = arr[:, :, 0]\n        b = arr[:, :, 2]\n    mean_r = float(np.mean(r)) if r.size else 0.0\n    mean_b = float(np.mean(b)) if b.size else 0.0\n    return float((mean_r - mean_b) / (mean_r + mean_b + eps))\n",
  "def feature(image: np.ndarray) -> float:\n    'Fraction of pixels that are strongly sky/sea-blue (blue > red and green and relatively bright)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    img = image.astype(float)\n    if len(img.shape) == 2:\n        return 0.0\n    r = img[:, :, 0]\n    g = img[:, :, 1]\n    b = img[:, :, 2]\n    brightness = (r + g + b) / 3.0\n    mean_brightness = float(np.mean(brightness)) if brightness.size else 0.0\n    blue_mask = (b > 1.1 * g) & (b > 1.1 * r) & (brightness > mean_brightness)\n    total = float(b.size) + eps\n    return float(np.count_nonzero(blue_mask) / total)\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Normalized vertical position (0..1) of the brightest blue pixel (row index normalized)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.5\n    img = image.astype(float)\n    h, w = img.shape[:2]\n    if len(img.shape) == 2:\n        b = img\n    else:\n        b = img[:, :, 2]\n    if b.size == 0:\n        return 0.5\n    idx = int(np.argmax(b))\n    row = idx // max(1, w)\n    if h <= 1:\n        return 0.5\n    return float(row / float(h - 1 + eps))\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Ratio of horizontal gradient energy to vertical gradient energy (gx vs gy)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 1.0\n    img = image.astype(float)\n    if len(img.shape) == 3:\n        gray = np.mean(img, axis=2)\n    else:\n        gray = img\n    if gray.size == 0:\n        return 1.0\n    gy, gx = np.gradient(gray)\n    e_x = float(np.sum(np.abs(gx)))\n    e_y = float(np.sum(np.abs(gy)))\n    return float((e_x + eps) / (e_y + eps))\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Average local patch standard deviation (non-overlapping blocks) normalized by mean intensity'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    img = image.astype(float)\n    h, w = img.shape[:2]\n    if len(img.shape) == 3:\n        gray = np.mean(img, axis=2)\n    else:\n        gray = img\n    if gray.size == 0:\n        return 0.0\n    # choose patch size proportional to image size, but at least 1\n    ps = max(1, min(h, w) // 16)\n    nh = h // ps\n    nw = w // ps\n    if nh == 0 or nw == 0:\n        # fallback to whole-image std\n        local_mean_std = float(np.std(gray))\n    else:\n        cropped = gray[:nh * ps, :nw * ps]\n        blocks = cropped.reshape(nh, ps, nw, ps)\n        # compute std for each block\n        local_stds = np.std(blocks, axis=(1, 3))\n        local_mean_std = float(np.mean(local_stds))\n    mean_intensity = float(np.mean(gray) + eps)\n    return float(local_mean_std / mean_intensity)\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Row index of maximal mean gradient (possible horizon line), normalized to [0,1]'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.5\n    img = image.astype(float)\n    h, w = img.shape[:2]\n    if len(img.shape) == 3:\n        gray = np.mean(img, axis=2)\n    else:\n        gray = img\n    if gray.size == 0 or h < 1:\n        return 0.5\n    gy, gx = np.gradient(gray)\n    mag = np.sqrt(gx * gx + gy * gy)\n    row_strength = np.mean(mag, axis=1)\n    idx = int(np.argmax(row_strength))\n    if h <= 1:\n        return 0.5\n    return float(idx / float(h - 1 + eps))\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Normalized difference between mean blue in top half and bottom half ((top-bottom)/(top+bottom))'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    img = image.astype(float)\n    h = img.shape[0]\n    if len(img.shape) == 2:\n        b = img\n    else:\n        b = img[:, :, 2]\n    if b.size == 0:\n        return 0.0\n    mid = h // 2\n    top = b[:mid, :] if mid > 0 else b\n    bottom = b[mid:, :] if mid < h else b\n    mean_top = float(np.mean(top)) if top.size else 0.0\n    mean_bot = float(np.mean(bottom)) if bottom.size else 0.0\n    return float((mean_top - mean_bot) / (mean_top + mean_bot + eps))\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Left-right mirror symmetry score (1.0 = perfectly symmetric), normalized'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.5\n    img = image.astype(float)\n    h, w = img.shape[:2]\n    if w < 2:\n        return 0.5\n    if len(img.shape) == 3:\n        left = img[:, :w // 2, :]\n        right = img[:, - (w // 2):, :]\n        # ensure same width\n        m = min(left.shape[1], right.shape[1])\n        left = left[:, :m, :]\n        right = right[:, :m, :]\n        right_flipped = right[:, ::-1, :]\n        diff = np.abs(left - right_flipped)\n        mean_diff = float(np.mean(diff)) if diff.size else 0.0\n        gray = np.mean(img, axis=2)\n    else:\n        left = img[:, :w // 2]\n        right = img[:, - (w // 2):]\n        m = min(left.shape[1], right.shape[1])\n        left = left[:, :m]\n        right = right[:, :m]\n        right_flipped = right[:, ::-1]\n        diff = np.abs(left - right_flipped)\n        mean_diff = float(np.mean(diff)) if diff.size else 0.0\n        gray = img\n    mean_intensity = float(np.mean(np.abs(gray)) + eps)\n    norm = mean_diff / (mean_intensity + eps)\n    sym = 1.0 - max(0.0, min(1.0, norm))\n    return float(sym)\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Mean brightness of the top 5% brightest pixels divided by mean brightness (high = strong specular highlights)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    img = image.astype(float)\n    if len(img.shape) == 3:\n        gray = np.mean(img, axis=2).flatten()\n    else:\n        gray = img.flatten()\n    if gray.size == 0:\n        return 0.0\n    thr = float(np.percentile(gray, 95))\n    top = gray[gray >= thr]\n    mean_top = float(np.mean(top)) if top.size else float(thr)\n    mean_all = float(np.mean(gray) + eps)\n    return float(mean_top / mean_all)\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Fraction of distinct quantized colors (color diversity) using 8-level quantization per channel'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    img = image.astype(np.int32)\n    h, w = img.shape[:2]\n    total = int(h * w)\n    if total == 0:\n        return 0.0\n    if len(img.shape) == 2:\n        q = (img // 16).astype(np.int32).flatten()  # 16 levels for grayscale\n        uniq = np.unique(q)\n        return float(uniq.size / (total + eps))\n    r = (img[:, :, 0] // 32).astype(np.int32)\n    g = (img[:, :, 1] // 32).astype(np.int32)\n    b = (img[:, :, 2] // 32).astype(np.int32)\n    codes = (r << 6) | (g << 3) | b  # unique code per quantized color\n    uniq = np.unique(codes)\n    return float(uniq.size / (total + eps))\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Fraction of strong green edges located in the upper-central region (green-vegetation edge concentration)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    img = image.astype(float)\n    h, w = img.shape[:2]\n    if len(img.shape) == 3:\n        r = img[:, :, 0]\n        g = img[:, :, 1]\n        b = img[:, :, 2]\n    else:\n        # grayscale: treat channel as all equal\n        r = g = b = img\n    gy, gx = np.gradient(g)\n    mag = np.sqrt(gx * gx + gy * gy)\n    if mag.size == 0:\n        return 0.0\n    thr = float(np.percentile(mag, 75))\n    strong = mag > (thr + eps)\n    # green-dominant edge pixels\n    green_dom = (g > r) & (g > b)\n    # upper-central region mask\n    upper = np.zeros_like(strong, dtype=bool)\n    upper[:max(1, h // 2), :] = True\n    c1 = max(0, w // 4)\n    c2 = min(w, 3 * w // 4)\n    center_mask = np.zeros_like(strong, dtype=bool)\n    if c2 > c1:\n        center_mask[:, c1:c2] = True\n    region = strong & green_dom & upper & center_mask\n    total_strong = float(np.count_nonzero(strong)) + eps\n    return float(np.count_nonzero(region) / total_strong)\n",
  "def feature(image: np.ndarray) -> float:\n    'Normalized row index of the peak mean blue intensity (where blue mass is vertically concentrated)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    img = image.astype(float)\n    if len(img.shape) == 2:\n        blue = img\n    else:\n        blue = img[:, :, 2]\n    h = blue.shape[0]\n    if h == 0:\n        return 0.0\n    row_means = np.mean(blue, axis=1)\n    idx = int(np.argmax(row_means)) if row_means.size else 0\n    return float(idx / max(1, h - 1 + eps))\n\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Fraction of bright specular-like pixels in the lower half (water glint indicator)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    img = image.astype(float)\n    h, w = img.shape[:2]\n    if len(img.shape) == 2:\n        rgb = np.stack([img, img, img], axis=2)\n    else:\n        rgb = img\n    lower = rgb[h//2:, :, :]\n    if lower.size == 0:\n        return 0.0\n    brightness = np.mean(lower, axis=2)\n    thr = np.percentile(brightness.flatten(), 90)\n    # specular often bright and not highly saturated (white-ish) or bright blue (water)\n    mx = np.max(lower, axis=2)\n    mn = np.min(lower, axis=2)\n    chroma = mx - mn\n    mask = (brightness >= thr) & (chroma < (np.mean(chroma) + eps) * 1.5)\n    return float(np.count_nonzero(mask) / float(max(1, brightness.size)))\n\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Top-bottom reflection symmetry score (higher when top and flipped bottom are similar)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    img = image.astype(float)\n    if len(img.shape) == 3:\n        gray = np.mean(img, axis=2)\n    else:\n        gray = img\n    h = gray.shape[0]\n    if h < 2:\n        return 0.0\n    mid = h // 2\n    top = gray[:mid, :]\n    bottom = gray[-mid:, :]\n    if top.size == 0 or bottom.size == 0:\n        return 0.0\n    bottom_flipped = bottom[::-1, :]\n    # make shapes match (in case odd height)\n    m = min(top.shape[0], bottom_flipped.shape[0])\n    top = top[:m, :]\n    bottom_flipped = bottom_flipped[:m, :]\n    diff = np.abs(top - bottom_flipped)\n    mean_diff = float(np.mean(diff))\n    mean_int = float(np.mean(np.abs(gray))) + eps\n    # score in [0, ~1], higher = more symmetric\n    score = max(0.0, 1.0 - (mean_diff / mean_int))\n    return float(score)\n\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Ratio of mean horizontal to vertical gradient magnitude in grayscale (horizontal vs vertical texture)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    img = image.astype(float)\n    if len(img.shape) == 3:\n        gray = np.mean(img, axis=2)\n    else:\n        gray = img\n    if gray.size == 0:\n        return 0.0\n    gy, gx = np.gradient(gray)\n    hor = np.mean(np.abs(gx))\n    ver = np.mean(np.abs(gy))\n    return float(hor / (ver + eps))\n\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Normalized distance of blue-channel center-of-mass from image center (blue mass offset)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    img = image.astype(float)\n    h, w = img.shape[:2]\n    if len(img.shape) == 2:\n        blue = img\n    else:\n        blue = img[:, :, 2]\n    if blue.size == 0:\n        return 0.0\n    total = np.sum(blue) + eps\n    ys = np.arange(h).reshape(h, 1)\n    xs = np.arange(w).reshape(1, w)\n    cx = float(np.sum(xs * blue) / total)\n    cy = float(np.sum(ys * blue) / total)\n    dx = (cx - (w - 1) / 2.0) / (w + eps)\n    dy = (cy - (h - 1) / 2.0) / (h + eps)\n    dist = np.sqrt(dx * dx + dy * dy)\n    return float(dist)\n\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Normalized histogram entropy of the green channel (higher for diverse vegetation textures)'\n    import numpy as np\n    eps = 1e-8\n    bins = 16\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    img = image.astype(float)\n    if len(img.shape) == 2:\n        g = img.flatten()\n    else:\n        g = img[:, :, 1].flatten()\n    if g.size == 0:\n        return 0.0\n    # scale to 0..1 based on min/max for stability\n    gmin, gmax = float(np.min(g)), float(np.max(g))\n    if gmax - gmin < eps:\n        return 0.0\n    gnorm = (g - gmin) / (gmax - gmin + eps)\n    hist, _ = np.histogram(gnorm, bins=bins, range=(0.0, 1.0))\n    p = hist.astype(float) / (np.sum(hist) + eps)\n    p_nonzero = p[p > 0]\n    entropy = -np.sum(p_nonzero * np.log(p_nonzero + eps))\n    # normalize by log(bins)\n    entropy_norm = entropy / (np.log(bins) + eps)\n    return float(entropy_norm)\n\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Fraction of pixels with brown-like RGB ratios (land/ground indicator)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    img = image.astype(float)\n    if len(img.shape) == 2:\n        rgb = np.stack([img, img, img], axis=2)\n    else:\n        rgb = img\n    r = rgb[:, :, 0]\n    g = rgb[:, :, 1]\n    b = rgb[:, :, 2]\n    s = r + g + b + eps\n    r_rel = r / s\n    g_rel = g / s\n    b_rel = b / s\n    # brown tends to have relatively high red, moderate green, low blue\n    mask = (r_rel > 0.34) & (g_rel > 0.22) & (b_rel < 0.28)\n    return float(np.count_nonzero(mask) / float(max(1, r.size)))\n\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Horizon candidate strength: row with strong vertical blue gradient and fraction of columns supporting it'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    img = image.astype(float)\n    if len(img.shape) == 2:\n        blue = img\n    else:\n        blue = img[:, :, 2]\n    h, w = blue.shape[:2]\n    if blue.size == 0:\n        return 0.0\n    gy = np.abs(np.gradient(blue, axis=0))\n    row_strength = np.mean(gy, axis=1)\n    idx = int(np.argmax(row_strength)) if row_strength.size else 0\n    row_vals = gy[idx, :] if gy.shape[0] > idx else gy.mean(axis=0)\n    thr = np.mean(row_vals) + 0.5 * np.std(row_vals)\n    frac_cols = float(np.count_nonzero(row_vals > thr)) / float(max(1, w))\n    norm_strength = row_strength[idx] / (np.mean(row_strength) + eps)\n    return float(frac_cols * norm_strength)\n\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Euclidean distance between mean RGB of center region and border region normalized by mean intensity'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    img = image.astype(float)\n    h, w = img.shape[:2]\n    if len(img.shape) == 2:\n        rgb = np.stack([img, img, img], axis=2)\n    else:\n        rgb = img\n    sr, sc = h // 4, w // 4\n    er, ec = h - sr, w - sc\n    center = rgb[sr:er, sc:ec, :] if (er > sr and ec > sc) else rgb\n    t = max(1, min(h, w) // 8)\n    top = rgb[:t, :, :]\n    bottom = rgb[-t:, :, :]\n    left = rgb[:, :t, :]\n    right = rgb[:, -t:, :]\n    border = np.concatenate([top.reshape(-1, 3), bottom.reshape(-1, 3),\n                             left.reshape(-1, 3), right.reshape(-1, 3)], axis=0) if rgb.size else np.zeros((1,3))\n    if center.size == 0 or border.size == 0:\n        return 0.0\n    mean_center = np.mean(center.reshape(-1, 3), axis=0)\n    mean_border = np.mean(border.reshape(-1, 3), axis=0)\n    diff = mean_center - mean_border\n    dist = np.sqrt(np.sum(diff * diff))\n    mean_intensity = np.mean((mean_center + mean_border) / 2.0) + eps\n    return float(dist / mean_intensity)\n\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Variance of mean luminance across four quadrants normalized by overall mean luminance'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    img = image.astype(float)\n    h, w = img.shape[:2]\n    if len(img.shape) == 2:\n        rgb = np.stack([img, img, img], axis=2)\n    else:\n        rgb = img\n    mid_h = h // 2\n    mid_w = w // 2\n    quads = [\n        rgb[:mid_h, :mid_w, :],\n        rgb[:mid_h, mid_w:, :],\n        rgb[mid_h:, :mid_w, :],\n        rgb[mid_h:, mid_w:, :]\n    ]\n    lumas = []\n    for q in quads:\n        if q.size == 0:\n            lumas.append(0.0)\n        else:\n            # luminance approximation\n            r = q[:, :, 0]\n            g = q[:, :, 1]\n            b = q[:, :, 2]\n            lumas.append(float(np.mean(0.2989 * r + 0.5870 * g + 0.1140 * b)))\n    lumas = np.array(lumas)\n    var = float(np.var(lumas))\n    mean_l = float(np.mean(lumas)) + eps\n    return float(var / mean_l)\n",
  "def feature(image: np.ndarray) -> float:\n    'Prominence of a strong horizontal edge (horizon-like) normalized to [0,1]'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    img = image.astype(float)\n    h, w = img.shape[:2]\n    if len(img.shape) == 3:\n        gray = np.mean(img, axis=2)\n    else:\n        gray = img\n    if h < 2 or w < 2:\n        return 0.0\n    gy, gx = np.gradient(gray)\n    row_strength = np.mean(np.abs(gy), axis=1)  # strength per row\n    max_row = float(np.max(row_strength))\n    mean_row = float(np.mean(row_strength) + eps)\n    ratio = max_row / mean_row\n    # map ratio to (0,1) smoothly\n    score = ratio / (1.0 + ratio)\n    return float(score)\n\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Fraction of the image that is very smooth (low gradient magnitude)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    img = image.astype(float)\n    if len(img.shape) == 3:\n        gray = np.mean(img, axis=2)\n    else:\n        gray = img\n    if gray.size == 0:\n        return 0.0\n    gy, gx = np.gradient(gray)\n    grad = np.sqrt(gx * gx + gy * gy)\n    # low gradient threshold set to lower quartile\n    thresh = float(np.percentile(grad.flatten(), 25)) if grad.size else 0.0\n    smooth_frac = float(np.count_nonzero(grad < thresh) / (grad.size + eps))\n    return float(smooth_frac)\n\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Normalized color temperature: positive = redder/warmer, negative = bluer/cooler'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if len(image.shape) == 2:\n        R = G = B = image.astype(float)\n    else:\n        rgb = image.astype(float)\n        R = rgb[:, :, 0]\n        G = rgb[:, :, 1]\n        B = rgb[:, :, 2]\n    meanR = float(np.mean(R))\n    meanB = float(np.mean(B))\n    mean_int = float(np.mean((R + G + B) / 3.0) + eps)\n    temp = (meanR - meanB) / mean_int\n    # clamp a bit to keep stable range\n    return float(max(-1.0, min(1.0, temp)))\n\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Top-bottom reflection similarity (possible water reflection) normalized [0,1]'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    img = image.astype(float)\n    h, w = img.shape[:2]\n    if len(img.shape) == 3:\n        gray = np.mean(img, axis=2)\n    else:\n        gray = img\n    if h < 2:\n        return 0.0\n    th = h // 2\n    top = gray[:th, :]\n    bot = gray[-th:, :]\n    # ensure same height\n    m = min(top.shape[0], bot.shape[0])\n    if m == 0:\n        return 0.0\n    top = top[:m, :]\n    bot = bot[-m:, :]\n    bot_flipped = bot[::-1, :]\n    mean_diff = float(np.mean(np.abs(top - bot_flipped)))\n    mean_int = float(np.mean(np.abs(gray)) + eps)\n    sim = 1.0 - min(1.0, mean_diff / (mean_int + eps))\n    return float(sim)\n\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Fraction of pixels in the upper third that are blue-dominant and chromatic'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if len(image.shape) == 2:\n        rgb = np.stack([image, image, image], axis=2).astype(float)\n    else:\n        rgb = image.astype(float)\n    h = rgb.shape[0]\n    th = max(1, h // 3)\n    region = rgb[:th, :, :].reshape(-1, 3)\n    if region.size == 0:\n        return 0.0\n    r = region[:, 0]\n    g = region[:, 1]\n    b = region[:, 2]\n    mx = np.maximum(np.maximum(r, g), b)\n    mn = np.minimum(np.minimum(r, g), b)\n    chroma = mx - mn\n    # blue-dominant and reasonably chromatic\n    mask = (b > r) & (b > g) & (chroma > 0.05 * (np.max(mx) - np.min(mn) + eps))\n    return float(np.count_nonzero(mask) / (region.shape[0] + eps))\n\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Absolute normalized intensity contrast between center region and border'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    img = image.astype(float)\n    h, w = img.shape[:2]\n    if len(img.shape) == 3:\n        gray = np.mean(img, axis=2)\n    else:\n        gray = img\n    sr, sc = h // 4, w // 4\n    er, ec = h - sr, w - sc\n    center = gray[sr:er, sc:ec] if (er > sr and ec > sc) else gray\n    # border as concatenation of strips\n    t = max(1, min(h, w) // 8)\n    top = gray[:t, :]\n    bottom = gray[-t:, :]\n    left = gray[:, :t]\n    right = gray[:, -t:]\n    border = np.concatenate([top.reshape(-1), bottom.reshape(-1), left.reshape(-1), right.reshape(-1)]) if gray.size else np.array([0.0])\n    mean_center = float(np.mean(center) if center.size else 0.0)\n    mean_border = float(np.mean(border) if border.size else 0.0)\n    mean_global = float(np.mean(gray) + eps)\n    contrast = float(np.abs(mean_center - mean_border) / (mean_global + eps))\n    return float(contrast)\n\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Fraction of strong edges that are horizontally oriented (indicates horizontal structures)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    img = image.astype(float)\n    if len(img.shape) == 3:\n        gray = np.mean(img, axis=2)\n    else:\n        gray = img\n    if gray.size == 0:\n        return 0.0\n    gy, gx = np.gradient(gray)\n    grad = np.sqrt(gx * gx + gy * gy)\n    if grad.size == 0:\n        return 0.0\n    # strong edges defined relative to upper percentile\n    thr = float(np.percentile(grad.flatten(), 75))\n    strong = grad > thr\n    if np.count_nonzero(strong) == 0:\n        return 0.0\n    # horizontal edges correspond to vertical gradients dominating (|gy| > |gx|)\n    horiz = (np.abs(gy) > np.abs(gx)) & strong\n    frac = float(np.count_nonzero(horiz) / (np.count_nonzero(strong) + eps))\n    return float(frac)\n\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Longest contiguous vertical run of rows dominated by blue pixels, normalized by height'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if len(image.shape) == 2:\n        rgb = np.stack([image, image, image], axis=2).astype(float)\n    else:\n        rgb = image.astype(float)\n    h, w = rgb.shape[:2]\n    r = rgb[:, :, 0]\n    g = rgb[:, :, 1]\n    b = rgb[:, :, 2]\n    mx = np.maximum(np.maximum(r, g), b)\n    mn = np.minimum(np.minimum(r, g), b)\n    chroma = mx - mn\n    # per-row proportion of blue-dominant & chromatic pixels\n    row_mask = ((b > r) & (b > g) & (chroma > 0.02 * (np.max(mx) - np.min(mn) + eps))).astype(np.float32)\n    row_props = np.mean(row_mask, axis=1) if row_mask.size else np.zeros((h,))\n    # find longest run where row_props > 0.5\n    thresh = 0.5\n    longest = 0\n    cur = 0\n    for v in row_props:\n        if v > thresh:\n            cur += 1\n            if cur > longest:\n                longest = cur\n        else:\n            cur = 0\n    return float(longest / (h + eps))\n\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Fraction of local intensity maxima (3x3) as a proxy for small-object density'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    img = image.astype(float)\n    if len(img.shape) == 3:\n        gray = np.mean(img, axis=2)\n    else:\n        gray = img\n    h, w = gray.shape[:2]\n    if h < 3 or w < 3:\n        return 0.0\n    center = gray[1:-1, 1:-1]\n    # neighbors\n    n1 = gray[:-2, :-2]; n2 = gray[:-2, 1:-1]; n3 = gray[:-2, 2:]\n    n4 = gray[1:-1, :-2]; n5 = gray[1:-1, 2:]\n    n6 = gray[2:, :-2]; n7 = gray[2:, 1:-1]; n8 = gray[2:, 2:]\n    local_max = (center > n1) & (center > n2) & (center > n3) & (center > n4) & (center > n5) & (center > n6) & (center > n7) & (center > n8)\n    cnt = float(np.count_nonzero(local_max))\n    area = float(center.size)\n    return float(cnt / (area + eps))\n",
  "def feature(image: np.ndarray) -> float:\n    'Ratio of vertical to horizontal edge strength (captures vertical structures vs horizontal)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    # grayscale\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    if gray.size == 0:\n        return 0.0\n    gy, gx = np.gradient(gray)\n    vert = np.sum(np.abs(gx))\n    horiz = np.sum(np.abs(gy))\n    return float(vert / (horiz + eps))\n\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Fraction of center pixels that are strongly red-dominant (warm/ornithological colors)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if len(image.shape) == 2:\n        rgb = np.stack([image, image, image], axis=2).astype(float)\n    else:\n        rgb = image.astype(float)\n    h, w = rgb.shape[:2]\n    sr, sc = h // 4, w // 4\n    er, ec = h - sr, w - sc\n    region = rgb[sr:er, sc:ec, :] if (er > sr and ec > sc) else rgb\n    if region.size == 0:\n        return 0.0\n    r = region[:, :, 0]; g = region[:, :, 1]; b = region[:, :, 2]\n    mean_int = np.mean((r + g + b) / 3.0) + eps\n    strong_red = (r > g) & (r > b) & ((r - np.maximum(g, b)) > 0.15 * mean_int)\n    return float(np.count_nonzero(strong_red) / (strong_red.size + eps))\n\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Similarity between top-third and bottom-third mean colors (high for reflective water)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if len(image.shape) == 2:\n        rgb = np.stack([image, image, image], axis=2).astype(float)\n    else:\n        rgb = image.astype(float)\n    h = rgb.shape[0]\n    t = max(1, h // 3)\n    top = rgb[:t, :, :].reshape(-1, 3)\n    bottom = rgb[-t:, :, :].reshape(-1, 3)\n    if top.size == 0 or bottom.size == 0:\n        return 0.0\n    mt = np.mean(top, axis=0)\n    mb = np.mean(bottom, axis=0)\n    dist = np.linalg.norm(mt - mb)\n    denom = (np.mean(rgb) + eps)\n    # map distance to similarity in (0,1]\n    sim = 1.0 / (1.0 + (dist / denom))\n    return float(sim)\n\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Mean blue in bottom quarter divided by mean blue in top quarter (water at bottom indicator)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if len(image.shape) == 2:\n        b = image.astype(float)\n        rgb = np.stack([b, b, b], axis=2)\n    else:\n        rgb = image.astype(float)\n    h = rgb.shape[0]\n    q = max(1, h // 4)\n    top = rgb[:q, :, :]\n    bottom = rgb[-q:, :, :]\n    if top.size == 0 or bottom.size == 0:\n        return 0.0\n    meanB_top = float(np.mean(top[:, :, 2]))\n    meanB_bottom = float(np.mean(bottom[:, :, 2]))\n    return float(meanB_bottom / (meanB_top + eps))\n\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Normalized color entropy using 4x4x4 quantization (higher -> more color variety)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if len(image.shape) == 2:\n        img = np.stack([image, image, image], axis=2).astype(float)\n    else:\n        img = image.astype(float)\n    h, w = img.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    flat = img.reshape(-1, 3)\n    maxv = float(np.max(flat)) + eps\n    bins = 4\n    # quantize channels to 0..bins-1\n    q = np.floor((flat / maxv) * (bins - 1)).astype(int)\n    q = np.clip(q, 0, bins - 1)\n    idx = q[:, 0] * (bins * bins) + q[:, 1] * bins + q[:, 2]\n    counts = np.bincount(idx, minlength=bins**3).astype(float)\n    probs = counts / (np.sum(counts) + eps)\n    nz = probs > 0\n    entropy = -np.sum(probs[nz] * np.log(probs[nz] + eps))\n    # normalize by log(num_bins)\n    norm = np.log(float(bins**3))\n    return float(entropy / (norm + eps))\n\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Color contrast between center mean and border mean (euclidean / mean intensity)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if len(image.shape) == 2:\n        rgb = np.stack([image, image, image], axis=2).astype(float)\n    else:\n        rgb = image.astype(float)\n    h, w = rgb.shape[:2]\n    sr, sc = h // 4, w // 4\n    er, ec = h - sr, w - sc\n    center = rgb[sr:er, sc:ec, :].reshape(-1, 3) if (er > sr and ec > sc) else rgb.reshape(-1, 3)\n    t = max(1, min(h, w) // 8)\n    top = rgb[:t, :, :].reshape(-1, 3)\n    bottom = rgb[-t:, :, :].reshape(-1, 3)\n    left = rgb[:, :t, :].reshape(-1, 3)\n    right = rgb[:, -t:, :].reshape(-1, 3)\n    border = np.concatenate([top, bottom, left, right], axis=0) if rgb.size else np.zeros((1,3))\n    if center.size == 0 or border.size == 0:\n        return 0.0\n    mc = np.mean(center, axis=0)\n    mb = np.mean(border, axis=0)\n    dist = np.linalg.norm(mc - mb)\n    denom = (np.mean(rgb) + eps)\n    return float(dist / denom)\n\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Fraction of columns containing a long vertical blue-dominant run (vertical water/river streaks)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if len(image.shape) == 2:\n        rgb = np.stack([image, image, image], axis=2).astype(float)\n    else:\n        rgb = image.astype(float)\n    h, w = rgb.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    R = rgb[:, :, 0]; G = rgb[:, :, 1]; B = rgb[:, :, 2]\n    intensity = (R + G + B) / 3.0\n    margin = 0.06 * (np.max(intensity) - np.min(intensity) + eps)\n    blue_mask = (B > G + margin) & (B > R + margin)\n    long_needed = max(1, int(0.3 * h))\n    cols_with_long = 0\n    for c in range(w):\n        col = blue_mask[:, c]\n        if not np.any(col):\n            continue\n        r = np.concatenate(([0], col.astype(np.int8), [0]))\n        diffs = np.diff(r)\n        starts = np.where(diffs == 1)[0]\n        ends = np.where(diffs == -1)[0]\n        if starts.size and ends.size:\n            lengths = ends - starts\n            if np.max(lengths) >= long_needed:\n                cols_with_long += 1\n    return float(cols_with_long / (w + eps))\n\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Fraction of center pixels whose intensity differs strongly from border mean (foreground separation)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if len(image.shape) == 2:\n        gray = image.astype(float)\n        rgb = np.stack([gray, gray, gray], axis=2)\n    else:\n        rgb = image.astype(float)\n        gray = np.mean(rgb, axis=2)\n    h, w = gray.shape[:2]\n    sr, sc = h // 4, w // 4\n    er, ec = h - sr, w - sc\n    center = gray[sr:er, sc:ec] if (er > sr and ec > sc) else gray\n    t = max(1, min(h, w) // 8)\n    border_pixels = []\n    if t > 0:\n        border_pixels.append(gray[:t, :].ravel())\n        border_pixels.append(gray[-t:, :].ravel())\n        border_pixels.append(gray[:, :t].ravel())\n        border_pixels.append(gray[:, -t:].ravel())\n    if len(border_pixels) == 0:\n        return 0.0\n    border = np.concatenate(border_pixels)\n    if center.size == 0 or border.size == 0:\n        return 0.0\n    border_mean = float(np.mean(border))\n    rng = float(np.max(gray) - np.min(gray) + eps)\n    thr = 0.25 * rng\n    diff_mask = np.abs(center - border_mean) > thr\n    return float(np.count_nonzero(diff_mask) / (diff_mask.size + eps))\n\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Global smoothness score: higher when image is smoother (low mean gradient)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    if gray.size == 0:\n        return 0.0\n    gy, gx = np.gradient(gray)\n    mean_abs_grad = float(np.mean(np.abs(gx) + np.abs(gy)))\n    norm = float(np.max(gray) - np.min(gray) + eps)\n    # higher value for smoother images\n    smoothness = 1.0 / (1.0 + (mean_abs_grad / (norm + eps)))\n    return float(smoothness)\n\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Fraction of small central circular region that is green-dominant (vegetation/foliage core)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if len(image.shape) == 2:\n        rgb = np.stack([image, image, image], axis=2).astype(float)\n    else:\n        rgb = image.astype(float)\n    h, w = rgb.shape[:2]\n    cy, cx = h // 2, w // 2\n    r = max(1, min(h, w) // 6)\n    ys = np.arange(h) - cy\n    xs = np.arange(w) - cx\n    yy, xx = np.meshgrid(ys, xs, indexing='ij')\n    mask = (yy * yy + xx * xx) <= (r * r)\n    if not np.any(mask):\n        return 0.0\n    rch = rgb[:, :, 0]; gch = rgb[:, :, 1]; bch = rgb[:, :, 2]\n    mean_int = np.mean((rch + gch + bch) / 3.0) + eps\n    green_dom = (gch > rch) & (gch > bch) & ((gch - np.maximum(rch, bch)) > 0.12 * mean_int)\n    masked = green_dom[mask]\n    return float(np.count_nonzero(masked) / (masked.size + eps))\n",
  "def feature(image: np.ndarray) -> float:\n    'Fraction of pixels that are strongly blue-dominant (water color prevalence)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    # ensure RGB\n    if len(image.shape) == 2:\n        rgb = np.stack([image, image, image], axis=2).astype(float)\n    else:\n        rgb = image.astype(float)\n    r = rgb[:, :, 0].astype(float)\n    g = rgb[:, :, 1].astype(float)\n    b = rgb[:, :, 2].astype(float)\n    sum_rgb = r + g + b + eps\n    blue_frac = b / sum_rgb\n    mask = (blue_frac > 0.45) & (b > g) & (b > r)\n    return float(np.count_nonzero(mask) / float(r.size + eps))\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Fraction of top-band pixels that are sky-like (bright blue region at top)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    h, w = image.shape[:2]\n    top_h = max(1, h // 5)\n    if len(image.shape) == 2:\n        rgb = np.stack([image, image, image], axis=2).astype(float)\n    else:\n        rgb = image.astype(float)\n    top = rgb[:top_h, :, :].astype(float)\n    r = top[:, :, 0]\n    g = top[:, :, 1]\n    b = top[:, :, 2]\n    intensity = (r + g + b) / 3.0\n    blue_frac = b / (r + g + b + eps)\n    bright = intensity > (np.mean(intensity) + 0.0)\n    sky_like = (blue_frac > 0.45) & (b > g) & bright\n    return float(np.count_nonzero(sky_like) / float(top_h * w + eps))\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Mean gradient magnitude normalized by mean intensity (texture/smoothness indicator)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    if gray.size == 0:\n        return 0.0\n    gy, gx = np.gradient(gray)\n    mag = np.sqrt(gx * gx + gy * gy)\n    mean_mag = float(np.mean(mag))\n    mean_int = float(np.mean(gray))\n    return float(mean_mag / (mean_int + eps))\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Fraction of small patches with very low variance (smooth-region coverage)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    h, w = image.shape[:2]\n    ph = max(1, h // 8)\n    pw = max(1, w // 8)\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    patches = []\n    for r in range(0, h, ph):\n        for c in range(0, w, pw):\n            block = gray[r:min(r+ph, h), c:min(c+pw, w)]\n            if block.size:\n                patches.append(np.var(block))\n    if len(patches) == 0:\n        return 0.0\n    patches = np.array(patches)\n    med = np.median(patches)\n    low_count = np.count_nonzero(patches < (med * 0.5 + eps))\n    return float(low_count / float(patches.size + eps))\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Ratio of mean blue in lower half to mean blue in upper half (bottom-water bias)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    h = image.shape[0]\n    mid = h // 2\n    if len(image.shape) == 2:\n        rgb = np.stack([image, image, image], axis=2).astype(float)\n    else:\n        rgb = image.astype(float)\n    top = rgb[:mid, :, 2].astype(float)\n    bottom = rgb[mid:, :, 2].astype(float)\n    if top.size == 0 or bottom.size == 0:\n        return 0.0\n    mean_top = float(np.mean(top))\n    mean_bottom = float(np.mean(bottom))\n    return float(mean_bottom / (mean_top + eps))\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Fraction of lower-half pixels that are green-dominant (vegetation on ground)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    h, w = image.shape[:2]\n    half = h // 2\n    if len(image.shape) == 2:\n        rgb = np.stack([image, image, image], axis=2).astype(float)\n    else:\n        rgb = image.astype(float)\n    lower = rgb[half:, :, :].astype(float)\n    r = lower[:, :, 0]\n    g = lower[:, :, 1]\n    b = lower[:, :, 2]\n    sumv = r + g + b + eps\n    green_frac = g / sumv\n    mask = (g > r) & (g > b) & (green_frac > 0.35)\n    return float(np.count_nonzero(mask) / float(lower.shape[0] * lower.shape[1] + eps))\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Proportion of dark pixels in the central region (central silhouette/dark mass)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    h, w = image.shape[:2]\n    sr, sc = h // 4, w // 4\n    er, ec = h - sr, w - sc\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    center = gray[sr:er, sc:ec] if (er > sr and ec > sc) else gray\n    if center.size == 0:\n        return 0.0\n    mean_c = float(np.mean(center))\n    std_all = float(np.std(gray)) + eps\n    thr = mean_c - 0.5 * std_all\n    dark_mask = center < thr\n    return float(np.count_nonzero(dark_mask) / float(center.size + eps))\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Vertical symmetry score (1.0 = perfectly symmetric left-right)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    if w <= 1:\n        return 0.0\n    mid = w // 2\n    left = gray[:, :mid]\n    if w % 2 == 0:\n        right = gray[:, mid:]\n    else:\n        right = gray[:, mid+1:]\n    # make same shape by cropping larger side\n    minw = min(left.shape[1], right.shape[1])\n    left_c = left[:, :minw]\n    right_c = right[:, :minw][:, ::-1]  # mirror right\n    if left_c.size == 0:\n        return 0.0\n    mean_int = float(np.mean(gray)) + eps\n    diff = np.abs(left_c - right_c)\n    score = 1.0 - (np.mean(diff) / mean_int)\n    return float(max(0.0, min(1.0, score)))\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Fraction of strong edges that are near-vertical (|angle - 90deg| < 30deg)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    gy, gx = np.gradient(gray)\n    mag = np.sqrt(gx * gx + gy * gy)\n    if mag.size == 0:\n        return 0.0\n    thr = np.percentile(mag, 75)\n    strong = mag > (thr + eps)\n    angles = np.abs(np.arctan2(gy, gx))  # angle in [-pi/2, pi/2] absolute\n    # vertical corresponds to angle near pi/2 -> compare distance to pi/2\n    ang_dist = np.abs((np.pi/2.0) - angles)\n    thresh = np.deg2rad(30.0)\n    vert = ang_dist < thresh\n    num_strong = np.count_nonzero(strong)\n    if num_strong == 0:\n        return 0.0\n    return float(np.count_nonzero(strong & vert) / (num_strong + eps))\n",
  "def feature(image: np.ndarray) -> float:\n    'Fraction of top-quarter pixels that are blue-dominant (sky/water indicator)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if len(image.shape) == 2:\n        rgb = np.stack([image, image, image], axis=2).astype(float)\n    else:\n        rgb = image.astype(float)\n    h, w = rgb.shape[:2]\n    top_h = max(1, h // 4)\n    top_region = rgb[:top_h, :, :]\n    r = top_region[:, :, 0].flatten()\n    g = top_region[:, :, 1].flatten()\n    b = top_region[:, :, 2].flatten()\n    mx = np.maximum(np.maximum(r, g), b) + eps\n    mn = np.minimum(np.minimum(r, g), b)\n    chroma = mx - mn\n    blue_mask = (b == mx) & (chroma / mx > 0.07)\n    return float(np.count_nonzero(blue_mask) / (r.size + eps))\n\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Ratio of green-channel texture to blue-channel texture in the center region'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if len(image.shape) == 2:\n        rgb = np.stack([image, image, image], axis=2).astype(float)\n    else:\n        rgb = image.astype(float)\n    h, w = rgb.shape[:2]\n    sr, sc = h // 4, w // 4\n    er, ec = h - sr, w - sc\n    region = rgb[sr:er, sc:ec, :] if (er > sr and ec > sc) else rgb\n    if region.size == 0:\n        return 0.0\n    g = region[:, :, 1]\n    b = region[:, :, 2]\n    std_g = float(np.std(g))\n    std_b = float(np.std(b))\n    return float(std_g / (std_b + eps))\n\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Perceptual colorfulness measure (Hasler-S\u00fcsstrunk style), normalized by intensity'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if len(image.shape) == 2:\n        rgb = np.stack([image, image, image], axis=2).astype(float)\n    else:\n        rgb = image.astype(float)\n    r = rgb[:, :, 0].flatten()\n    g = rgb[:, :, 1].flatten()\n    b = rgb[:, :, 2].flatten()\n    rg = r - g\n    yb = 0.5 * (r + g) - b\n    std_rg = np.std(rg)\n    std_yb = np.std(yb)\n    mean_rg = np.mean(np.abs(rg))\n    mean_yb = np.mean(np.abs(yb))\n    raw = np.sqrt(std_rg ** 2 + std_yb ** 2) + 0.3 * np.sqrt(mean_rg ** 2 + mean_yb ** 2)\n    mean_int = np.mean((r + g + b) / 3.0) + eps\n    return float(raw / mean_int)\n\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Fraction of strong horizontal edges concentrated in a mid-upper horizontal band (horizon cue)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    gy, gx = np.gradient(gray)\n    mag = np.sqrt(gx * gx + gy * gy)\n    if mag.size == 0:\n        return 0.0\n    thr = np.percentile(mag, 75)\n    strong = mag > (thr + eps)\n    orient = np.abs(np.arctan2(gy, gx))\n    # horizontal edges -> gradient near +/- pi/2 (orient near pi/2)\n    angle_dist = np.abs(orient - (np.pi / 2.0))\n    horiz = strong & (angle_dist <= (20.0 * np.pi / 180.0) + eps)\n    # mid-upper band (between 20%-55% of height)\n    r0 = int(max(0, h * 0.20)); r1 = int(min(h, h * 0.55))\n    band_mask = np.zeros_like(gray, dtype=bool)\n    band_mask[r0:r1, :] = True\n    focused = horiz & band_mask\n    total_strong = np.count_nonzero(strong) + eps\n    return float(np.count_nonzero(focused) / total_strong)\n\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Normalized difference of mean (blue - green) between bottom and top halves'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if len(image.shape) == 2:\n        rgb = np.stack([image, image, image], axis=2).astype(float)\n    else:\n        rgb = image.astype(float)\n    h = rgb.shape[0]\n    top = rgb[:h // 2, :, :]\n    bottom = rgb[h // 2:, :, :]\n    if top.size == 0 or bottom.size == 0:\n        return 0.0\n    mean_top = float(np.mean(bottom[:, :, 2] - bottom[:, :, 1])) - float(np.mean(top[:, :, 2] - top[:, :, 1]))\n    norm = float(np.mean((rgb[:, :, 0] + rgb[:, :, 1] + rgb[:, :, 2]) / 3.0) + eps)\n    return float(mean_top / norm)\n\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Fraction of pixels with very low chroma (near-gray regions), indicating uniform water/sky'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if len(image.shape) == 2:\n        rgb = np.stack([image, image, image], axis=2).astype(float)\n    else:\n        rgb = image.astype(float)\n    r = rgb[:, :, 0].flatten()\n    g = rgb[:, :, 1].flatten()\n    b = rgb[:, :, 2].flatten()\n    mx = np.maximum(np.maximum(r, g), b) + eps\n    mn = np.minimum(np.minimum(r, g), b)\n    chroma = (mx - mn) / mx\n    low_chroma = chroma < 0.05\n    return float(np.count_nonzero(low_chroma) / (r.size + eps))\n\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Vertical luminance symmetry score between top and flipped bottom (reflection-like cue)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.5\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    half = h // 2\n    top = gray[:half, :]\n    bottom = gray[-half:, :] if half > 0 else np.array([])\n    if top.size == 0 or bottom.size == 0:\n        return 0.5\n    # flip bottom vertically to compare\n    bottom_flipped = np.flipud(bottom)\n    # crop to same shape if needed\n    min_rows = min(top.shape[0], bottom_flipped.shape[0])\n    top_c = top[:min_rows, :].flatten()\n    bot_c = bottom_flipped[:min_rows, :].flatten()\n    if top_c.size == 0:\n        return 0.5\n    top_mean = np.mean(top_c)\n    bot_mean = np.mean(bot_c)\n    top_std = np.std(top_c)\n    bot_std = np.std(bot_c)\n    cov = np.mean((top_c - top_mean) * (bot_c - bot_mean))\n    denom = (top_std * bot_std) + eps\n    corr = cov / denom\n    # map from [-1,1] to [0,1]\n    return float((corr + 1.0) / 2.0)\n\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Concentration of blue-dominant pixels in the lower-center patch (water-reflection cue)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if len(image.shape) == 2:\n        rgb = np.stack([image, image, image], axis=2).astype(float)\n    else:\n        rgb = image.astype(float)\n    h, w = rgb.shape[:2]\n    r0 = int(h * 2 / 3)\n    r1 = h\n    c0 = max(0, w // 3)\n    c1 = min(w, 2 * w // 3)\n    patch = rgb[r0:r1, c0:c1, :] if (r1 > r0 and c1 > c0) else rgb\n    if patch.size == 0:\n        return 0.0\n    r = patch[:, :, 0].flatten()\n    g = patch[:, :, 1].flatten()\n    b = patch[:, :, 2].flatten()\n    mx = np.maximum(np.maximum(r, g), b) + eps\n    mn = np.minimum(np.minimum(r, g), b)\n    chroma = mx - mn\n    blue_mask = (b == mx) & (chroma / mx > 0.07)\n    return float(np.count_nonzero(blue_mask) / (r.size + eps))\n\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Ratio of average edge magnitude outside blue regions to inside blue regions (smooth-blue cue)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 1.0\n    if len(image.shape) == 3:\n        img = image.astype(float)\n        gray = np.mean(img, axis=2)\n    else:\n        img = np.stack([image, image, image], axis=2).astype(float)\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    r = img[:, :, 0].flatten()\n    g = img[:, :, 1].flatten()\n    b = img[:, :, 2].flatten()\n    mx = np.maximum(np.maximum(r, g), b) + eps\n    mn = np.minimum(np.minimum(r, g), b)\n    chroma = mx - mn\n    blue_mask_flat = ((b == mx) & (chroma / mx > 0.07))\n    gy, gx = np.gradient(gray)\n    mag = np.sqrt(gx * gx + gy * gy).flatten()\n    if mag.size == 0:\n        return 1.0\n    avg_blue = float(np.mean(mag[blue_mask_flat]) if np.count_nonzero(blue_mask_flat) > 0 else 0.0)\n    avg_nonblue = float(np.mean(mag[~blue_mask_flat]) if np.count_nonzero(~blue_mask_flat) > 0 else 0.0)\n    return float((avg_nonblue + eps) / (avg_blue + eps))\n\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Normalized difference of gradient variance: center minus border (foreground focus cue)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    gy, gx = np.gradient(gray)\n    mag = np.sqrt(gx * gx + gy * gy)\n    sr, sc = h // 4, w // 4\n    er, ec = h - sr, w - sc\n    center = mag[sr:er, sc:ec] if (er > sr and ec > sc) else mag\n    # border = top + bottom + left + right strips\n    t = max(1, min(h, w) // 8)\n    top = mag[:t, :] if t < h else np.array([])\n    bottom = mag[-t:, :] if t < h else np.array([])\n    left = mag[:, :t] if t < w else np.array([])\n    right = mag[:, -t:] if t < w else np.array([])\n    border_parts = []\n    if top.size: border_parts.append(top.flatten())\n    if bottom.size: border_parts.append(bottom.flatten())\n    if left.size: border_parts.append(left.flatten())\n    if right.size: border_parts.append(right.flatten())\n    border = np.concatenate(border_parts) if border_parts else np.array([0.0])\n    var_center = float(np.var(center)) if center.size else 0.0\n    var_border = float(np.var(border)) if border.size else 0.0\n    denom = (var_center + var_border + eps)\n    return float((var_center - var_border) / denom)\n",
  "def feature(image: np.ndarray) -> float:\n    'Fraction of top-quarter pixels that are blue-dominant (sky/water indicator)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    img = image.astype(float)\n    h, w = img.shape[:2]\n    if len(img.shape) == 2:\n        r = g = b = img\n    else:\n        r = img[:, :, 0]\n        g = img[:, :, 1]\n        b = img[:, :, 2]\n    top = slice(0, max(1, h // 4))\n    global_mean = float(np.mean(img) + eps)\n    mask = (b[top, :] > r[top, :]) & (b[top, :] > g[top, :]) & (b[top, :] > 0.6 * global_mean)\n    total = float(mask.size) + eps\n    return float(np.count_nonzero(mask) / total)\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Ratio of horizontal to vertical edge energy (>>1 = more horizontal structure)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 1.0\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    gy, gx = np.gradient(gray)\n    horiz = float(np.sum(np.abs(gy)))\n    vert = float(np.sum(np.abs(gx)))\n    return float(horiz / (vert + eps))\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Mean blue in lower half divided by mean blue in upper half (water lower bias)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 1.0\n    img = image.astype(float)\n    h = img.shape[0]\n    if len(img.shape) == 2:\n        b = img\n    else:\n        b = img[:, :, 2]\n    upper = b[:h // 2, :]\n    lower = b[h // 2:, :]\n    if upper.size == 0 or lower.size == 0:\n        return 1.0\n    mean_upper = float(np.mean(upper))\n    mean_lower = float(np.mean(lower))\n    return float(mean_lower / (mean_upper + eps))\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Standard deviation of pixel chroma normalized by mean intensity (color variability)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if len(image.shape) == 2:\n        r = g = b = image.astype(float)\n    else:\n        img = image.astype(float)\n        r = img[:, :, 0]\n        g = img[:, :, 1]\n        b = img[:, :, 2]\n    mx = np.maximum(np.maximum(r, g), b)\n    mn = np.minimum(np.minimum(r, g), b)\n    chroma = (mx - mn).flatten()\n    std_chroma = float(np.std(chroma)) if chroma.size else 0.0\n    mean_intensity = float(np.mean((r + g + b) / 3.0) + eps)\n    return float(std_chroma / mean_intensity)\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Normalized vertical position (0..1) of largest blue row jump (horizon location)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.5\n    img = image.astype(float)\n    h = img.shape[0]\n    if len(img.shape) == 2:\n        b = img\n    else:\n        b = img[:, :, 2]\n    row_mean = np.mean(b, axis=1) if b.size else np.zeros((h,))\n    if row_mean.size <= 1:\n        return 0.5\n    diffs = np.abs(np.diff(row_mean))\n    idx = int(np.argmax(diffs)) if diffs.size else 0\n    pos = (idx + 0.5) / max(1, h - 1)\n    return float(np.clip(pos, 0.0, 1.0))\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Fraction of brownish pixels (R-dominant with moderate green) \u2014 branch/earth indicator'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    img = image.astype(float)\n    if len(img.shape) == 2:\n        r = g = b = img\n    else:\n        r = img[:, :, 0]\n        g = img[:, :, 1]\n        b = img[:, :, 2]\n    mx = np.maximum(np.maximum(r, g), b)\n    mn = np.minimum(np.minimum(r, g), b)\n    dyn = float(np.max(mx) - np.min(mn) + eps)\n    chroma = mx - mn\n    brown_mask = (r > g) & (r > b) & (g / (r + eps) > 0.25) & (g / (r + eps) < 0.95) & (chroma > 0.05 * dyn)\n    total = float(brown_mask.size) + eps\n    return float(np.count_nonzero(brown_mask) / total)\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Normalized horizontal spread (std) of high-chroma pixels across image width (small = concentrated object)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 1.0\n    img = image.astype(float)\n    h, w = img.shape[:2]\n    if len(img.shape) == 2:\n        r = g = b = img\n    else:\n        r = img[:, :, 0]\n        g = img[:, :, 1]\n        b = img[:, :, 2]\n    mx = np.maximum(np.maximum(r, g), b)\n    mn = np.minimum(np.minimum(r, g), b)\n    chroma = (mx - mn).flatten()\n    if chroma.size == 0:\n        return 1.0\n    thr = np.percentile(chroma, 70)\n    mask = (mx - mn).reshape(h, w) > thr\n    ys, xs = np.nonzero(mask)\n    if xs.size == 0:\n        return 1.0\n    std_x = float(np.std(xs))\n    return float(std_x / (w + eps))\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Mean gradient magnitude normalized by mean intensity (texture / smoothness)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    gy, gx = np.gradient(gray)\n    mag = np.sqrt(gx * gx + gy * gy)\n    mean_mag = float(np.mean(mag)) if mag.size else 0.0\n    mean_intensity = float(np.mean(gray) + eps)\n    return float(mean_mag / mean_intensity)\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Ratio of mean center-region brightness to mean outer-region brightness (center contrast)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 1.0\n    img = image.astype(float)\n    h, w = img.shape[:2]\n    if len(img.shape) == 3:\n        gray = np.mean(img, axis=2)\n    else:\n        gray = img\n    sr, sc = h // 4, w // 4\n    er, ec = h - sr, w - sc\n    if er <= sr or ec <= sc:\n        center = gray\n        outer = np.array([], dtype=float)\n    else:\n        center = gray[sr:er, sc:ec]\n        mask = np.ones_like(gray, dtype=bool)\n        mask[sr:er, sc:ec] = False\n        outer = gray[mask]\n    mean_center = float(np.mean(center) + eps)\n    mean_outer = float(np.mean(outer) + eps) if outer.size else mean_center + eps\n    return float(mean_center / mean_outer)\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Average short-lag row autocorrelation (1..-1) indicating banded/repetitive horizontal patterns'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    h = gray.shape[0]\n    if h <= 2:\n        return 0.0\n    max_lag = min(3, h - 1)\n    corrs = []\n    for lag in range(1, max_lag + 1):\n        valid = h - lag\n        if valid <= 0:\n            continue\n        num = 0.0\n        den = 0.0\n        count = 0\n        for i in range(valid):\n            a = gray[i].astype(float)\n            b = gray[i + lag].astype(float)\n            a = a - np.mean(a)\n            b = b - np.mean(b)\n            na = np.sum(a * a)\n            nb = np.sum(b * b)\n            denom = np.sqrt(na * nb) + eps\n            if denom > 0:\n                num += float(np.sum(a * b) / denom)\n                count += 1\n        if count > 0:\n            corrs.append(num / float(count))\n    if len(corrs) == 0:\n        return 0.0\n    return float(np.mean(corrs))\n",
  "def feature(image: np.ndarray) -> float:\n    'Fraction of pixels that are strong edges (edge density)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    gy, gx = np.gradient(gray)\n    mag = np.sqrt(gx * gx + gy * gy)\n    if mag.size == 0:\n        return 0.0\n    thr = float(np.mean(mag) + np.std(mag))\n    strong = np.count_nonzero(mag > thr)\n    return float(strong / (mag.size + eps))\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Variance of the Laplacian response (focus / texture measure)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    # second derivatives\n    gy, gx = np.gradient(gray)\n    gxx, gxy = np.gradient(gx)\n    gyx, gyy = np.gradient(gy)\n    lap = gxx + gyy\n    if lap.size == 0:\n        return 0.0\n    # normalize by average intensity to be scale-stable\n    mean_int = float(np.mean(np.abs(gray)) + eps)\n    return float(np.var(lap) / mean_int)\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Fraction of top-half pixels that are strongly blue (blue dominance up top)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if len(image.shape) == 2:\n        rgb = np.stack([image, image, image], axis=2).astype(float)\n    else:\n        rgb = image.astype(float)\n    h, w = rgb.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    top = rgb[:max(1, h // 2), :, :]\n    if top.size == 0:\n        return 0.0\n    R = top[:, :, 0]; G = top[:, :, 1]; B = top[:, :, 2]\n    thr = float(np.mean(B) + np.std(B))\n    mask = (B > thr) & (B > G) & (B > R)\n    return float(np.count_nonzero(mask) / (mask.size + eps))\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Green-channel patchiness in center region (std/mean of green)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if len(image.shape) == 2:\n        rgb = np.stack([image, image, image], axis=2).astype(float)\n    else:\n        rgb = image.astype(float)\n    h, w = rgb.shape[:2]\n    sr, sc = h // 4, w // 4\n    er, ec = h - sr, w - sc\n    center = rgb[sr:er, sc:ec, :] if (er > sr and ec > sc) else rgb\n    if center.size == 0:\n        return 0.0\n    G = center[:, :, 1].astype(float)\n    meanG = float(np.mean(G) + eps)\n    stdG = float(np.std(G))\n    return float(stdG / meanG)\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Row position (normalized) of maximum horizontal-edge energy (horizon candidate)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    if h < 2 or w < 1:\n        return 0.0\n    gy, gx = np.gradient(gray)\n    horiz = np.abs(gy)  # vertical derivative -> horizontal edges\n    row_strength = np.mean(horiz, axis=1)\n    idx = int(np.argmax(row_strength)) if row_strength.size else 0\n    return float(idx / (max(1, h - 1) + eps))\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Fraction of center-region pixels that are noticeably darker than image mean'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    img = image.astype(float)\n    if len(img.shape) == 2:\n        lum = img\n    else:\n        R = img[:, :, 0]; G = img[:, :, 1]; B = img[:, :, 2]\n        lum = 0.299 * R + 0.587 * G + 0.114 * B\n    h, w = lum.shape[:2]\n    sr, sc = h // 4, w // 4\n    er, ec = h - sr, w - sc\n    center = lum[sr:er, sc:ec] if (er > sr and ec > sc) else lum\n    if center.size == 0 or lum.size == 0:\n        return 0.0\n    mean_l = float(np.mean(lum))\n    std_l = float(np.std(lum))\n    thr = mean_l - 0.5 * std_l\n    thr = float(max(thr, np.min(lum)))  # avoid too low thresholds\n    dark_count = np.count_nonzero(center < thr)\n    return float(dark_count / (center.size + eps))\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Proportion of pixels that are near-white low-chroma highlights (specular-like)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if len(image.shape) == 2:\n        rgb = np.stack([image, image, image], axis=2).astype(float)\n    else:\n        rgb = image.astype(float)\n    R = rgb[:, :, 0].astype(float)\n    G = rgb[:, :, 1].astype(float)\n    B = rgb[:, :, 2].astype(float)\n    mx = np.maximum(np.maximum(R, G), B)\n    mn = np.minimum(np.minimum(R, G), B)\n    lum = 0.299 * R + 0.587 * G + 0.114 * B\n    if lum.size == 0:\n        return 0.0\n    memean = float(np.mean(lum))\n    mestd = float(np.std(lum))\n    bright_thr = memean + 0.75 * mestd\n    chroma = mx - mn\n    chroma_thr = float(np.mean(chroma) * 0.3 + eps)\n    mask = (lum > bright_thr) & (chroma < chroma_thr)\n    return float(np.count_nonzero(mask) / (mask.size + eps))\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Normalized warm-cool center bias: (R-B)/(R+B) in the center region'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if len(image.shape) == 2:\n        rgb = np.stack([image, image, image], axis=2).astype(float)\n    else:\n        rgb = image.astype(float)\n    h, w = rgb.shape[:2]\n    sr, sc = h // 4, w // 4\n    er, ec = h - sr, w - sc\n    center = rgb[sr:er, sc:ec, :] if (er > sr and ec > sc) else rgb\n    if center.size == 0:\n        return 0.0\n    meanR = float(np.mean(center[:, :, 0]))\n    meanB = float(np.mean(center[:, :, 2]))\n    return float((meanR - meanB) / (meanR + meanB + eps))\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Relative aspect ratio of bright-region bounding box vs image aspect (1 = same)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    img = image.astype(float)\n    if len(img.shape) == 3:\n        R = img[:, :, 0]; G = img[:, :, 1]; B = img[:, :, 2]\n        lum = 0.299 * R + 0.587 * G + 0.114 * B\n    else:\n        lum = img\n    h, w = lum.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    thr = float(np.mean(lum) + np.std(lum))\n    mask = lum > thr\n    if not np.any(mask):\n        return 0.0\n    rows = np.any(mask, axis=1)\n    cols = np.any(mask, axis=0)\n    r_idxs = np.where(rows)[0]\n    c_idxs = np.where(cols)[0]\n    if r_idxs.size == 0 or c_idxs.size == 0:\n        return 0.0\n    rowmin, rowmax = int(r_idxs[0]), int(r_idxs[-1])\n    colmin, colmax = int(c_idxs[0]), int(c_idxs[-1])\n    bbox_h = float(rowmax - rowmin + 1)\n    bbox_w = float(colmax - colmin + 1)\n    img_ar = float(w / (h + eps))\n    bbox_ar = float(bbox_w / (bbox_h + eps))\n    return float((bbox_ar / (img_ar + eps)))\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Ratio of vertical-to-horizontal gradient energy (vertical/horizontal)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    gy, gx = np.gradient(gray)\n    v_energy = float(np.sum(np.abs(gy)))\n    h_energy = float(np.sum(np.abs(gx)))\n    return float(v_energy / (h_energy + eps))\n",
  "def feature(image: np.ndarray) -> float:\n    'Fraction of top-region pixels that are blue-dominant and bright (sky/water proxy)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    img = image.astype(float)\n    h, w = img.shape[:2]\n    th = max(1, h // 4)\n    top = img[:th, :, :] if img.ndim == 3 else img[:th, :]\n    if top.size == 0:\n        return 0.0\n    if top.ndim == 2:\n        # grayscale: no blue dominance\n        return 0.0\n    # brightness threshold -> consider pixels brighter than regional mean\n    mean_brightness = np.mean(np.mean(top, axis=2))\n    r = top[:, :, 0].flatten()\n    g = top[:, :, 1].flatten()\n    b = top[:, :, 2].flatten()\n    bright = (r + g + b) / 3.0 > mean_brightness\n    blue_dom = (b > r) & (b > g)\n    mask = bright & blue_dom\n    return float(np.count_nonzero(mask) / (mask.size + eps))\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Mean gradient magnitude in the bottom region normalized by overall mean intensity (ground/water texture)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if image.ndim == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    bh = max(1, h // 3)\n    bottom = gray[-bh:, :]\n    if bottom.size == 0:\n        return 0.0\n    gy, gx = np.gradient(bottom)\n    mag = np.sqrt(gy * gy + gx * gx)\n    mean_mag = float(np.mean(mag))\n    mean_int = float(np.mean(gray) + eps)\n    return float(mean_mag / mean_int)\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Width-to-height aspect ratio of the bright-object bounding box (object spread proxy)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    img = image.astype(float)\n    h, w = img.shape[:2]\n    if img.ndim == 3:\n        intensity = np.mean(img, axis=2)\n    else:\n        intensity = img\n    m = intensity.size\n    if m == 0:\n        return 0.0\n    thr = np.mean(intensity) + 0.5 * np.std(intensity)\n    mask = intensity > thr\n    if not np.any(mask):\n        # fallback: use a looser threshold\n        thr2 = np.mean(intensity)\n        mask = intensity > thr2\n        if not np.any(mask):\n            return 0.0\n    rows = np.any(mask, axis=1)\n    cols = np.any(mask, axis=0)\n    r_idx = np.where(rows)[0]\n    c_idx = np.where(cols)[0]\n    if r_idx.size == 0 or c_idx.size == 0:\n        return 0.0\n    height = r_idx[-1] - r_idx[0] + 1\n    width = c_idx[-1] - c_idx[0] + 1\n    return float(width / (height + eps))\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Ratio of mean green in lower half to mean green in upper half (vegetation below vs above)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    img = image.astype(float)\n    h = img.shape[0]\n    mid = h // 2\n    if img.ndim == 2:\n        # grayscale: approximate using same channel\n        top = img[:mid, :].astype(float)\n        bottom = img[mid:, :].astype(float)\n        mean_bot = float(np.mean(bottom)) if bottom.size else 0.0\n        mean_top = float(np.mean(top)) if top.size else 0.0\n        return float(mean_bot / (mean_top + eps))\n    else:\n        g = img[:, :, 1]\n        top = g[:mid, :]\n        bottom = g[mid:, :]\n        mean_bot = float(np.mean(bottom)) if bottom.size else 0.0\n        mean_top = float(np.mean(top)) if top.size else 0.0\n        return float(mean_bot / (mean_top + eps))\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Mean saturation across image using (max-min)/(max + eps) per pixel'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    img = image.astype(float)\n    if img.ndim == 2:\n        return 0.0\n    mx = np.max(img, axis=2)\n    mn = np.min(img, axis=2)\n    sat = (mx - mn) / (mx + eps)\n    return float(np.mean(sat))\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Normalized center minus border brightness (center bias in luminance)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    img = image.astype(float)\n    h, w = img.shape[:2]\n    sr, sc = h // 4, w // 4\n    er, ec = h - sr, w - sc\n    if img.ndim == 3:\n        lum = np.mean(img, axis=2)\n    else:\n        lum = img\n    center = lum[sr:er, sc:ec] if (er > sr and ec > sc) else lum\n    t = max(1, min(h, w) // 8)\n    border = np.concatenate([lum[:t, :].ravel(), lum[-t:, :].ravel(), lum[:, :t].ravel(), lum[:, -t:].ravel()]) if lum.size else np.array([0.0])\n    if center.size == 0 or border.size == 0:\n        return 0.0\n    mean_center = float(np.mean(center))\n    mean_border = float(np.mean(border))\n    overall = float(np.mean(lum) + eps)\n    return float((mean_center - mean_border) / overall)\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Vertical blue-channel gradient (top minus bottom mean blue) normalized by overall blue mean'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    img = image.astype(float)\n    if img.ndim == 2:\n        # grayscale: no blue channel\n        return 0.0\n    h = img.shape[0]\n    q = max(1, h // 4)\n    top = img[:q, :, 2]\n    bottom = img[-q:, :, 2]\n    if top.size == 0 or bottom.size == 0:\n        return 0.0\n    mean_top = float(np.mean(top))\n    mean_bottom = float(np.mean(bottom))\n    mean_all = float(np.mean(img[:, :, 2]) + eps)\n    return float((mean_top - mean_bottom) / mean_all)\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Entropy of gradient orientation histogram (0..log) as a measure of structural complexity'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if image.ndim == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    gy, gx = np.gradient(gray)\n    orient = np.arctan2(gy, gx)  # range [-pi, pi]\n    # map to [0, pi) because orientation +/- are equivalent for edges\n    orient = np.abs(orient)\n    bins = 12\n    hist, _ = np.histogram(orient.flatten(), bins=bins, range=(0.0, np.pi))\n    total = np.sum(hist)\n    if total == 0:\n        return 0.0\n    p = hist / (total + eps)\n    p_nonzero = p[p > 0]\n    entropy = -np.sum(p_nonzero * np.log(p_nonzero + eps))\n    return float(entropy)\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Fraction of strong edges concentrated in the top third of the image (skyline/upper-edge bias)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if image.ndim == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    h = gray.shape[0]\n    gy, gx = np.gradient(gray)\n    mag = np.sqrt(gy * gy + gx * gx)\n    if mag.size == 0:\n        return 0.0\n    thr = np.percentile(mag, 90)\n    strong = mag > thr\n    total_strong = np.count_nonzero(strong)\n    if total_strong == 0:\n        return 0.0\n    top_h = max(1, h // 3)\n    strong_top = np.count_nonzero(strong[:top_h, :])\n    return float(strong_top / (total_strong + eps))\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Mean absolute second-derivative energy in center region (curvature/detail proxy)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if image.ndim == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    sr, sc = h // 4, w // 4\n    er, ec = h - sr, w - sc\n    region = gray[sr:er, sc:ec] if (er > sr and ec > sc) else gray\n    if region.size == 0:\n        return 0.0\n    gy, gx = np.gradient(region)\n    gyy, _ = np.gradient(gy)\n    _, gxx = np.gradient(gx)\n    second_energy = np.mean(np.abs(gyy) + np.abs(gxx))\n    # normalize by first-order mean gradient to stabilize scale\n    first_energy = np.mean(np.sqrt(gy * gy + gx * gx)) + eps\n    return float(second_energy / first_energy)\n",
  "def feature(image: np.ndarray) -> float:\n    'Vertical reflection similarity between top half and vertically flipped bottom half (water reflection proxy)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    half = h // 2\n    top = gray[:half, :]\n    bottom = gray[-half:, :]\n    if top.size == 0 or bottom.size == 0:\n        return 0.0\n    # crop to same shape if needed\n    if top.shape != bottom.shape:\n        minr = min(top.shape[0], bottom.shape[0])\n        top = top[:minr, :]\n        bottom = bottom[-minr:, :]\n    bottom_flipped = np.flipud(bottom)\n    a = top.flatten().astype(float)\n    b = bottom_flipped.flatten().astype(float)\n    a_mean = np.mean(a)\n    b_mean = np.mean(b)\n    num = np.sum((a - a_mean) * (b - b_mean))\n    den = np.sqrt(np.sum((a - a_mean) ** 2) * np.sum((b - b_mean) ** 2)) + eps\n    corr = num / den\n    return float((corr + 1.0) / 2.0)\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Horizon edge strength measured as strongest row-wise change in column-averaged intensity'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    # profile across rows\n    row_profile = np.mean(gray, axis=1)\n    if row_profile.size < 2:\n        return 0.0\n    grad = np.gradient(row_profile)\n    abs_grad = np.abs(grad)\n    max_grad = float(np.max(abs_grad))\n    mean_grad = float(np.mean(abs_grad)) + eps\n    return float(max_grad / mean_grad)\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Top-quarter blue-sky score: fraction of top quarter pixels that are bright and blue-dominant'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if len(image.shape) == 2:\n        rgb = np.stack([image, image, image], axis=2).astype(float)\n    else:\n        rgb = image.astype(float)\n    h, w = rgb.shape[:2]\n    th = max(1, h // 4)\n    region = rgb[:th, :, :]\n    if region.size == 0:\n        return 0.0\n    R = region[:, :, 0]\n    G = region[:, :, 1]\n    B = region[:, :, 2]\n    intensity = (R + G + B) / 3.0\n    mean_int = np.mean(intensity)\n    mask = (B > 1.05 * R) & (B > 1.05 * G) & (B > mean_int)\n    return float(np.count_nonzero(mask) / (region.shape[0] * region.shape[1] + eps))\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Bottom-half blue-smooth fraction: fraction of blue-dominant pixels in bottom half that are low-texture (water-like)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if len(image.shape) == 2:\n        rgb = np.stack([image, image, image], axis=2).astype(float)\n        gray = image.astype(float)\n    else:\n        rgb = image.astype(float)\n        gray = np.mean(rgb, axis=2).astype(float)\n    h, w = gray.shape[:2]\n    bh = h // 2\n    bottom_gray = gray[-bh:, :] if bh > 0 else gray\n    bottom_rgb = rgb[-bh:, :, :] if bh > 0 else rgb\n    if bottom_gray.size == 0:\n        return 0.0\n    R = bottom_rgb[:, :, 0]\n    G = bottom_rgb[:, :, 1]\n    B = bottom_rgb[:, :, 2]\n    blue_mask = (B > 1.05 * R) & (B > 1.05 * G)\n    gy, gx = np.gradient(bottom_gray)\n    mag = np.sqrt(gx * gx + gy * gy)\n    thr = np.median(mag)  # low-texture if below median\n    low_texture_blue = blue_mask & (mag < (thr + eps))\n    # fraction relative to bottom area\n    return float(np.count_nonzero(low_texture_blue) / (bottom_gray.size + eps))\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Green block fraction: fraction of 8x8 blocks with mean green strongly dominant (vegetation blocks)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if len(image.shape) == 2:\n        rgb = np.stack([image, image, image], axis=2).astype(float)\n    else:\n        rgb = image.astype(float)\n    h, w = rgb.shape[:2]\n    bh, bw = 8, 8\n    # ensure at least one block\n    rows = max(1, h // bh)\n    cols = max(1, w // bw)\n    # compute block means by reshaping where possible\n    # pad if necessary by cropping only\n    h2 = rows * bh\n    w2 = cols * bw\n    block_area = rgb[:h2, :w2, :].reshape(rows, bh, cols, bw, 3)\n    block_means = np.mean(block_area, axis=(1, 3))\n    Rm = block_means[:, :, 0]\n    Gm = block_means[:, :, 1]\n    Bm = block_means[:, :, 2]\n    green_blocks = (Gm > 1.05 * Rm) & (Gm > 1.05 * Bm)\n    return float(np.count_nonzero(green_blocks) / (green_blocks.size + eps))\n\n",
  "def feature(image: np.ndarray) -> float:\n    'High-frequency energy ratio using a simple Laplacian filter (small-detail vs overall energy)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    if gray.size == 0:\n        return 0.0\n    # discrete Laplacian: 4*center - neighbors\n    center = gray\n    up = np.roll(gray, -1, axis=0)\n    down = np.roll(gray, 1, axis=0)\n    left = np.roll(gray, -1, axis=1)\n    right = np.roll(gray, 1, axis=1)\n    lap = (4.0 * center) - (up + down + left + right)\n    hf_energy = np.mean(np.abs(lap))\n    total_energy = np.mean(np.abs(gray)) + eps\n    return float(hf_energy / total_energy)\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Horizontal-edge bias: ratio of horizontal-edge energy to vertical-edge energy (horizon vs vertical texture)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    if gray.size == 0:\n        return 0.0\n    gy, gx = np.gradient(gray)\n    mean_abs_gy = float(np.mean(np.abs(gy))) + eps  # gradient across rows (sensitive to horizontal edges)\n    mean_abs_gx = float(np.mean(np.abs(gx))) + eps  # gradient across cols (sensitive to vertical edges)\n    return float(mean_abs_gy / mean_abs_gx)\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Color temperature index: (mean red - mean green) relative to mean blue (warmer vs cooler scenes)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if len(image.shape) == 2:\n        rgb = np.stack([image, image, image], axis=2).astype(float)\n    else:\n        rgb = image.astype(float)\n    R = float(np.mean(rgb[:, :, 0]))\n    G = float(np.mean(rgb[:, :, 1]))\n    B = float(np.mean(rgb[:, :, 2])) + eps\n    return float((R - G) / B)\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Center intensity contrast: normalized absolute difference between center region mean and border mean'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    sr, sc = h // 4, w // 4\n    er, ec = h - sr, w - sc\n    if er <= sr or ec <= sc:\n        center = gray\n    else:\n        center = gray[sr:er, sc:ec]\n    # border as ring: top,bottom,left,right strips of width min(h,w)//8\n    t = max(1, min(h, w) // 8)\n    top = gray[:t, :]\n    bottom = gray[-t:, :]\n    left = gray[:, :t]\n    right = gray[:, -t:]\n    border_concat = np.concatenate([top.flatten(), bottom.flatten(), left.flatten(), right.flatten()]) if gray.size else np.array([0.0])\n    if center.size == 0 or border_concat.size == 0:\n        return 0.0\n    center_mean = float(np.mean(center))\n    border_mean = float(np.mean(border_concat))\n    denom = (abs(center_mean) + abs(border_mean) + eps)\n    return float(abs(center_mean - border_mean) / denom)\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Foreground-size proxy: fraction of pixels whose intensity deviates from the image median by >0.75*std'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    if gray.size == 0:\n        return 0.0\n    med = float(np.median(gray))\n    std = float(np.std(gray)) + eps\n    mask = np.abs(gray - med) > (0.75 * std)\n    return float(np.count_nonzero(mask) / (gray.size + eps))\n",
  "def feature(image: np.ndarray) -> float:\n    'Fraction of strong-blue pixels in the top region (sky indicator)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if image.ndim == 2:\n        rgb = np.stack([image, image, image], axis=2).astype(float)\n    else:\n        rgb = image.astype(float)\n    h, w = rgb.shape[:2]\n    t = max(1, h // 5)\n    top = rgb[:t, :, :]\n    if top.size == 0:\n        return 0.0\n    r = top[:, :, 0]\n    g = top[:, :, 1]\n    b = top[:, :, 2]\n    thr = np.percentile(b, 60)\n    mask = (b > r) & (b > g) & (b > thr)\n    return float(mask.sum() / (top.shape[0] * top.shape[1] + eps))\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Relative green-channel texture in center (std-green / mean-green)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    img = image.astype(float)\n    h, w = img.shape[:2]\n    sr, sc = h // 4, w // 4\n    er, ec = h - sr, w - sc\n    if img.ndim == 3:\n        region = img[sr:er, sc:ec, 1] if (er > sr and ec > sc) else img[:, :, 1]\n    else:\n        region = img[sr:er, sc:ec] if (er > sr and ec > sc) else img\n    if region.size == 0:\n        return 0.0\n    stdg = float(np.std(region))\n    meang = float(np.mean(region)) + eps\n    return float(stdg / meang)\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Ratio of horizontal-edge dominance to vertical-edge dominance (gradient orientation)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 1.0\n    if image.ndim == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    if gray.size == 0:\n        return 1.0\n    gy, gx = np.gradient(gray)\n    mag = np.sqrt(gx * gx + gy * gy) + eps\n    # focus on stronger edges to avoid noise\n    thresh = np.percentile(mag, 70)\n    mask = mag >= thresh\n    if not np.any(mask):\n        mask = mag > (np.mean(mag) + eps)\n    gx_m = gx[mask]\n    gy_m = gy[mask]\n    mag_m = mag[mask]\n    cosv = np.abs(gx_m / mag_m)\n    sinv = np.abs(gy_m / mag_m)\n    cos_thresh = np.cos(np.deg2rad(20.0))\n    sin_thresh = np.cos(np.deg2rad(20.0))  # same threshold for vertical via sine\n    horiz_count = np.count_nonzero(cosv > cos_thresh)\n    vert_count = np.count_nonzero(sinv > cos_thresh)\n    return float((horiz_count + eps) / (vert_count + eps))\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Standard deviation of quadrant mean chroma (scene heterogeneity)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if image.ndim == 2:\n        rgb = np.stack([image, image, image], axis=2).astype(float)\n    else:\n        rgb = image.astype(float)\n    h, w = rgb.shape[:2]\n    if h < 2 or w < 2:\n        return 0.0\n    mid_h, mid_w = h // 2, w // 2\n    quads = [\n        rgb[0:mid_h, 0:mid_w, :],\n        rgb[0:mid_h, mid_w:w, :],\n        rgb[mid_h:h, 0:mid_w, :],\n        rgb[mid_h:h, mid_w:w, :]\n    ]\n    means = []\n    for q in quads:\n        if q.size == 0:\n            means.append(0.0)\n            continue\n        r = q[:, :, 0].flatten()\n        g = q[:, :, 1].flatten()\n        b = q[:, :, 2].flatten()\n        mx = np.maximum(np.maximum(r, g), b)\n        mn = np.minimum(np.minimum(r, g), b)\n        chroma = mx - mn\n        means.append(float(np.mean(chroma)))\n    means = np.array(means)\n    overall_mean = float(np.mean(means)) + eps\n    return float(np.std(means) / overall_mean)\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Normalized entropy of center-region intensity histogram (texture complexity)'\n    import numpy as np\n    eps = 1e-8\n    bins = 16\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if image.ndim == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    sr, sc = h // 4, w // 4\n    er, ec = h - sr, w - sc\n    region = gray[sr:er, sc:ec] if (er > sr and ec > sc) else gray\n    if region.size == 0:\n        return 0.0\n    hist, _ = np.histogram(region.flatten(), bins=bins, range=(np.min(region), np.max(region)))\n    p = hist.astype(float)\n    s = p.sum()\n    if s == 0:\n        return 0.0\n    p /= s\n    ent = -np.sum(np.where(p > 0, p * np.log(p + eps), 0.0))\n    max_ent = np.log(bins)\n    return float(ent / (max_ent + eps))\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Mean intensity top-quarter divided by bottom-quarter (vertical brightness bias)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 1.0\n    img = image.astype(float)\n    h = img.shape[0]\n    q = max(1, h // 4)\n    if img.ndim == 3:\n        intensity = np.mean(img, axis=2)\n    else:\n        intensity = img\n    top = intensity[:q, :]\n    bottom = intensity[-q:, :]\n    if top.size == 0 or bottom.size == 0:\n        return 1.0\n    mean_top = float(np.mean(top))\n    mean_bottom = float(np.mean(bottom)) + eps\n    return float(mean_top / mean_bottom)\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Horizon smoothness score: low central row contrast implies a smooth horizontal band (0..1)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if image.ndim == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    h = gray.shape[0]\n    if h < 3:\n        return 0.0\n    row_means = np.mean(gray, axis=1)\n    diffs = np.abs(np.diff(row_means))\n    if diffs.size == 0:\n        return 0.0\n    start = h // 4\n    end = max(start + 1, 3 * h // 4)\n    central = diffs[start:end] if end > start else diffs\n    min_diff = float(np.min(central))\n    mean_diff = float(np.mean(diffs)) + eps\n    score = 1.0 - (min_diff / mean_diff)\n    # clamp to [0,1]\n    score = max(0.0, min(1.0, score))\n    return float(score)\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Mean blue-to-green ratio measured on strong edge pixels (edge color cue)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 1.0\n    img = image.astype(float)\n    if img.ndim == 3:\n        gray = np.mean(img, axis=2)\n    else:\n        gray = img\n    gy, gx = np.gradient(gray)\n    mag = np.sqrt(gx * gx + gy * gy)\n    thr = np.percentile(mag, 75)\n    edge_mask = mag >= thr\n    if img.ndim == 2:\n        b = img\n        g = img\n    else:\n        b = img[:, :, 2]\n        g = img[:, :, 1]\n    if not np.any(edge_mask):\n        # fallback to whole-image ratio\n        meanB = float(np.mean(b)) + eps\n        meanG = float(np.mean(g)) + eps\n        return float(meanB / meanG)\n    meanB = float(np.mean(b[edge_mask])) + eps\n    meanG = float(np.mean(g[edge_mask])) + eps\n    return float(meanB / meanG)\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Perimeter-to-area proxy for bright objects using simple inner-pixel count (edge/area)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    img = image.astype(float)\n    if img.ndim == 3:\n        intensity = np.mean(img, axis=2)\n    else:\n        intensity = img\n    thr = np.mean(intensity) + np.std(intensity)\n    mask = intensity > thr\n    area = int(np.count_nonzero(mask))\n    if area == 0:\n        return 0.0\n    h, w = mask.shape\n    if h < 3 or w < 3:\n        # small images: approximate perimeter as 1\n        return float(1.0)\n    inner = mask[1:-1, 1:-1] & mask[1:-1, 0:-2] & mask[1:-1, 2:] & mask[0:-2, 1:-1] & mask[2:, 1:-1]\n    inner_count = int(np.count_nonzero(inner))\n    perimeter_est = area - inner_count\n    return float(perimeter_est / (area + eps))\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Skewness of approximate per-pixel saturation distribution (color skew)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if image.ndim == 2:\n        r = g = b = image.astype(float).flatten()\n    else:\n        arr = image.astype(float)\n        r = arr[:, :, 0].flatten()\n        g = arr[:, :, 1].flatten()\n        b = arr[:, :, 2].flatten()\n    mx = np.maximum(np.maximum(r, g), b)\n    mn = np.minimum(np.minimum(r, g), b)\n    sat = (mx - mn) / (mx + eps)\n    if sat.size == 0:\n        return 0.0\n    mean = float(np.mean(sat))\n    std = float(np.std(sat)) + eps\n    skew = float(np.mean(((sat - mean) ** 3))) / (std ** 3 + eps)\n    return float(skew)\n",
  "def feature(image: np.ndarray) -> float:\n    'Fraction of pixels that are strongly blue (global water indicator)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if image.ndim == 2:\n        rgb = np.stack([image, image, image], axis=2).astype(float)\n    else:\n        rgb = image.astype(float)\n    R = rgb[:, :, 0]\n    G = rgb[:, :, 1]\n    B = rgb[:, :, 2]\n    # blue dominant relative to red/green and also reasonably bright\n    blue_mask = (B > 1.05 * (R + G) / 2.0) & (B > (R + G + B) / 6.0 + eps)\n    return float(np.count_nonzero(blue_mask) / (rgb.shape[0] * rgb.shape[1] + eps))\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Difference in blue-proportion between lower and upper halves (positive => more blue below)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if image.ndim == 2:\n        rgb = np.stack([image, image, image], axis=2).astype(float)\n    else:\n        rgb = image.astype(float)\n    h = rgb.shape[0]\n    mid = h // 2\n    def blue_frac(region):\n        R = region[:, :, 0]; G = region[:, :, 1]; B = region[:, :, 2]\n        mask = (B > 1.05 * (R + G) / 2.0)\n        return float(np.count_nonzero(mask) / (region.shape[0] * region.shape[1] + eps))\n    top = rgb[:mid, :, :] if mid > 0 else rgb\n    bottom = rgb[mid:, :, :] if mid < h else rgb\n    return float(blue_frac(bottom) - blue_frac(top))\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Mean longest horizontal run-length of blue mask per row normalized by width (horiz continuity)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if image.ndim == 2:\n        rgb = np.stack([image, image, image], axis=2).astype(float)\n    else:\n        rgb = image.astype(float)\n    h, w = rgb.shape[:2]\n    R = rgb[:, :, 0]; G = rgb[:, :, 1]; B = rgb[:, :, 2]\n    mask = (B > 1.02 * (R + G) / 2.0)\n    # compute longest run per row\n    runs = []\n    for row in mask:\n        if w == 0:\n            runs.append(0)\n            continue\n        # find transitions\n        row_int = row.astype(np.int8)\n        if row_int.sum() == 0:\n            runs.append(0)\n            continue\n        dif = np.diff(np.concatenate(([0], row_int, [0])))\n        starts = np.where(dif == 1)[0]\n        ends = np.where(dif == -1)[0]\n        if starts.size == 0:\n            runs.append(0)\n        else:\n            runs.append(int(np.max(ends - starts)))\n    return float((np.mean(runs) / (w + eps)))\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Normalized std of row-wise mean blue in lower quarter (consistency of water area)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if image.ndim == 2:\n        rgb = np.stack([image, image, image], axis=2).astype(float)\n    else:\n        rgb = image.astype(float)\n    h = rgb.shape[0]\n    start = (3 * h) // 4\n    region = rgb[start:, :, :] if start < h else rgb\n    if region.size == 0:\n        return 0.0\n    B = region[:, :, 2]\n    row_means = np.mean(B, axis=1)\n    # normalize by mean to be scale-invariant\n    return float(np.std(row_means) / (np.mean(row_means) + eps))\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Variance of the image Laplacian (texture/fineness proxy)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if image.ndim == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    gy, gx = np.gradient(gray)\n    gyy, _ = np.gradient(gy)\n    _, gxx = np.gradient(gx)\n    lap = gyy + gxx\n    return float(np.var(lap) / (np.mean(np.abs(gray)) + eps))\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Mean warm-color bias (R - G) normalized by intensity (landbird color cue)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if image.ndim == 2:\n        return 0.0\n    rgb = image.astype(float)\n    R = rgb[:, :, 0]\n    G = rgb[:, :, 1]\n    intensity = np.mean(np.maximum(np.mean(rgb, axis=2), eps))\n    bias = np.mean(R - G)\n    return float(bias / (intensity + eps))\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Fraction of non-overlapping blocks that are smooth (low variance) - global smooth area proportion'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if image.ndim == 3:\n        lum = np.mean(image.astype(float), axis=2)\n    else:\n        lum = image.astype(float)\n    h, w = lum.shape[:2]\n    # choose block size proportional to image but not too small\n    blk = max(8, min(h, w) // 16)\n    if blk <= 0:\n        return 0.0\n    nh = h // blk\n    nw = w // blk\n    if nh == 0 or nw == 0:\n        # fallback global variance\n        return float(np.var(lum) < 1.0)\n    cropped = lum[:nh * blk, :nw * blk]\n    blocks = cropped.reshape(nh, blk, nw, blk).swapaxes(1, 2).reshape(nh * nw, blk * blk)\n    vars_blocks = np.var(blocks, axis=1)\n    thr = np.median(vars_blocks) * 0.5\n    smooth_frac = float(np.count_nonzero(vars_blocks < thr) / (vars_blocks.size + eps))\n    return float(smooth_frac)\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Mean horizontal-edge dominance fraction (horizontal edges vs total strong edges)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if image.ndim == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    gy, gx = np.gradient(gray)\n    mag = np.sqrt(gx * gx + gy * gy)\n    if mag.size == 0:\n        return 0.0\n    thr = np.percentile(mag.flatten(), 70)\n    strong = mag > (thr + eps)\n    if np.count_nonzero(strong) == 0:\n        return 0.0\n    horiz = (np.abs(gy) > np.abs(gx)) & strong\n    return float(np.count_nonzero(horiz) / (np.count_nonzero(strong) + eps))\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Top-quarter blue proportion (sky / distant water indicator)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if image.ndim == 2:\n        rgb = np.stack([image, image, image], axis=2).astype(float)\n    else:\n        rgb = image.astype(float)\n    h = rgb.shape[0]\n    top = rgb[:max(1, h // 4), :, :]\n    R = top[:, :, 0]; G = top[:, :, 1]; B = top[:, :, 2]\n    mask = (B > 1.05 * (R + G) / 2.0)\n    return float(np.count_nonzero(mask) / (top.shape[0] * top.shape[1] + eps))\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Difference between center-region saturation and image-wide saturation (salient color contrast)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if image.ndim == 2:\n        return 0.0\n    rgb = image.astype(float)\n    h, w = rgb.shape[:2]\n    sr, sc = h // 4, w // 4\n    er, ec = h - sr, w - sc\n    center = rgb[sr:er, sc:ec, :] if (er > sr and ec > sc) else rgb\n    mx_all = np.max(rgb, axis=2)\n    mn_all = np.min(rgb, axis=2)\n    sat_all = np.where(mx_all > 0, (mx_all - mn_all) / (mx_all + eps), 0.0)\n    mx_c = np.max(center, axis=2)\n    mn_c = np.min(center, axis=2)\n    sat_c = np.where(mx_c > 0, (mx_c - mn_c) / (mx_c + eps), 0.0)\n    return float(np.mean(sat_c) - np.mean(sat_all))\n",
  "def feature(image: np.ndarray) -> float:\n    'Fraction of very bright pixels that are blue-dominant (specular blue highlight proxy)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    # ensure RGB\n    if image.ndim == 2:\n        rgb = np.stack([image, image, image], axis=2).astype(float)\n    else:\n        rgb = image.astype(float)\n    h, w = rgb.shape[:2]\n    gray = np.mean(rgb, axis=2)\n    if gray.size == 0:\n        return 0.0\n    bright_thr = float(np.percentile(gray, 99))  # top 1% considered very bright\n    bright_mask = gray >= bright_thr\n    if np.count_nonzero(bright_mask) == 0:\n        return 0.0\n    R, G, B = rgb[:, :, 0], rgb[:, :, 1], rgb[:, :, 2]\n    blue_specular = bright_mask & (B > 1.05 * R) & (B > 1.05 * G)\n    return float(np.count_nonzero(blue_specular) / (bright_mask.size + eps))\n\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Elongation ratio of the brightest connected region approximated via covariance eigenvalues'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if image.ndim == 2:\n        gray = image.astype(float)\n    else:\n        gray = np.mean(image.astype(float), axis=2)\n    if gray.size == 0:\n        return 0.0\n    thr = float(np.percentile(gray, 95))  # use top 5% as object proxy\n    ys, xs = np.nonzero(gray >= thr)\n    if ys.size < 5:\n        return 0.0\n    # coordinates centered\n    yc = ys - np.mean(ys)\n    xc = xs - np.mean(xs)\n    coords = np.vstack([yc, xc])\n    cov = np.cov(coords)\n    # handle degenerate covariance\n    if np.any(np.isnan(cov)) or cov.shape != (2, 2):\n        return 0.0\n    evals = np.linalg.eigvalsh(cov)\n    # ensure positive\n    evals = np.maximum(evals, eps)\n    ratio = float(evals[1] / (evals[0] + eps))\n    return float(ratio)\n\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Horizontal edge prominence in upper third (proxy for horizon/waterline)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if image.ndim == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    if h == 0:\n        return 0.0\n    gy, gx = np.gradient(gray)\n    abs_gy = np.abs(gy)\n    upper_end = max(1, h // 3)\n    upper_region = abs_gy[:upper_end, :]\n    global_mean = float(np.mean(abs_gy) + eps)\n    upper_mean = float(np.mean(upper_region)) if upper_region.size else 0.0\n    return float(upper_mean / global_mean)\n\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Warmth index in bottom quarter: (mean R - mean G) / (mean B + eps)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if image.ndim == 2:\n        rgb = np.stack([image, image, image], axis=2).astype(float)\n    else:\n        rgb = image.astype(float)\n    h, w = rgb.shape[:2]\n    start = (3 * h) // 4\n    bottom = rgb[start:h, :, :] if start < h else rgb\n    if bottom.size == 0:\n        return 0.0\n    meanR = float(np.mean(bottom[:, :, 0]))\n    meanG = float(np.mean(bottom[:, :, 1]))\n    meanB = float(np.mean(bottom[:, :, 2]))\n    return float((meanR - meanG) / (meanB + eps))\n\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Mean of 8x8 block local standard deviations (texture roughness) normalized by global std'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if image.ndim == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    bh, bw = 8, 8\n    if h < bh or w < bw:\n        return float(np.std(gray) / (np.mean(np.abs(gray)) + eps))\n    nh = (h // bh) * bh\n    nw = (w // bw) * bw\n    cropped = gray[:nh, :nw]\n    # reshape into blocks\n    blocks = cropped.reshape(nh // bh, bh, nw // bw, bw)\n    # move block dims together: (n_blocks_h, n_blocks_w, bh, bw)\n    blocks = blocks.transpose(0, 2, 1, 3).reshape(-1, bh * bw)\n    block_stds = np.std(blocks, axis=1)\n    mean_block_std = float(np.mean(block_stds)) if block_stds.size else 0.0\n    global_std = float(np.std(gray) + eps)\n    return float(mean_block_std / global_std)\n\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Entropy of gradient orientations (8-bin) normalized to [0,1]'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if image.ndim == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    if gray.size == 0:\n        return 0.0\n    gy, gx = np.gradient(gray)\n    ang = np.arctan2(gy, gx)  # range [-pi, pi]\n    # bin into 8 bins\n    bins = 8\n    hist, _ = np.histogram(ang.flatten(), bins=bins, range=(-np.pi, np.pi))\n    total = float(np.sum(hist) + eps)\n    p = hist.astype(float) / total\n    # entropy\n    p_nonzero = p[p > 0]\n    ent = -np.sum(p_nonzero * np.log(p_nonzero + eps))\n    # normalize by max entropy log(bins)\n    max_ent = np.log(bins)\n    return float(ent / (max_ent + eps))\n\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Low-frequency chroma dominance: (smoothed chroma - highpass chroma) / (sum + eps)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if image.ndim == 2:\n        rgb = np.stack([image, image, image], axis=2).astype(float)\n    else:\n        rgb = image.astype(float)\n    # simple 3x3 box filter via shifted sums\n    pad = ((1, 1), (1, 1), (0, 0))\n    rgb_p = np.pad(rgb, pad_width=pad, mode='reflect')\n    sm = (\n        rgb_p[:-2, :-2] + rgb_p[:-2, 1:-1] + rgb_p[:-2, 2:] +\n        rgb_p[1:-1, :-2] + rgb_p[1:-1, 1:-1] + rgb_p[1:-1, 2:] +\n        rgb_p[2:, :-2] + rgb_p[2:, 1:-1] + rgb_p[2:, 2:]\n    ) / 9.0\n    high = rgb - sm\n    mx_s = np.max(sm, axis=2)\n    mn_s = np.min(sm, axis=2)\n    chroma_low = mx_s - mn_s\n    mx_h = np.max(np.abs(high), axis=2)\n    mn_h = np.min(np.abs(high), axis=2)\n    chroma_high = mx_h - mn_h\n    mean_low = float(np.mean(chroma_low))\n    mean_high = float(np.mean(chroma_high))\n    return float((mean_low - mean_high) / (mean_low + mean_high + eps))\n\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Upper-minus-lower blue difference normalized by overall intensity (blue top vs bottom)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if image.ndim == 2:\n        rgb = np.stack([image, image, image], axis=2).astype(float)\n    else:\n        rgb = image.astype(float)\n    h = rgb.shape[0]\n    top = rgb[:h // 2, :, :]\n    bottom = rgb[h // 2:, :, :]\n    if top.size == 0 or bottom.size == 0:\n        return 0.0\n    meanB_top = float(np.mean(top[:, :, 2]))\n    meanB_bottom = float(np.mean(bottom[:, :, 2]))\n    mean_int = float(np.mean(np.mean(rgb, axis=2)) + eps)\n    return float((meanB_top - meanB_bottom) / mean_int)\n\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Top percentile brightness contrast: mean(top1%) / (median + eps)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if image.ndim == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    flat = gray.flatten()\n    if flat.size == 0:\n        return 0.0\n    thr = float(np.percentile(flat, 99))\n    top_pixels = flat[flat >= thr]\n    if top_pixels.size == 0:\n        return 0.0\n    median = float(np.median(flat) + eps)\n    return float(np.mean(top_pixels) / median)\n\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Fraction of strong edges where green-channel gradient dominates (vegetation-edge signal)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if image.ndim == 2:\n        rgb = np.stack([image, image, image], axis=2).astype(float)\n    else:\n        rgb = image.astype(float)\n    # gradients per channel\n    gy_r, gx_r = np.gradient(rgb[:, :, 0])\n    gy_g, gx_g = np.gradient(rgb[:, :, 1])\n    gy_b, gx_b = np.gradient(rgb[:, :, 2])\n    mag_r = np.sqrt(gx_r * gx_r + gy_r * gy_r)\n    mag_g = np.sqrt(gx_g * gx_g + gy_g * gy_g)\n    mag_b = np.sqrt(gx_b * gx_b + gy_b * gy_b)\n    combined = mag_r + mag_g + mag_b\n    if combined.size == 0:\n        return 0.0\n    thr = float(np.percentile(combined, 90))  # strong edges\n    edge_mask = combined >= thr\n    if np.count_nonzero(edge_mask) == 0:\n        return 0.0\n    green_dom = (mag_g > mag_r) & (mag_g > mag_b) & edge_mask\n    return float(np.count_nonzero(green_dom) / (np.count_nonzero(edge_mask) + eps))\n",
  "def feature(image: np.ndarray) -> float:\n    'Fraction of red-warm pixels in the center region (land/feather warm tones indicator)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if len(image.shape) == 2:\n        rgb = np.stack([image, image, image], axis=2).astype(float)\n    else:\n        rgb = image.astype(float)\n    h, w = rgb.shape[:2]\n    sr, sc = h // 4, w // 4\n    er, ec = h - sr, w - sc\n    region = rgb[sr:er, sc:ec, :] if (er > sr and ec > sc) else rgb\n    if region.size == 0:\n        return 0.0\n    R = region[:, :, 0]\n    G = region[:, :, 1]\n    B = region[:, :, 2]\n    global_mean = float(np.mean(rgb)) + eps\n    mask = (R > 1.05 * G) & (R > 1.05 * B) & (R > 0.45 * global_mean)\n    return float(np.count_nonzero(mask) / (mask.size + eps))\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Normalized entropy of image luminance (complexity / texture proxy)'\n    import numpy as np\n    eps = 1e-12\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    flat = gray.flatten()\n    if flat.size == 0:\n        return 0.0\n    bins = 32\n    hist, _ = np.histogram(flat, bins=bins, range=(flat.min(), flat.max() if flat.max() > flat.min() else flat.min()+1.0))\n    total = float(hist.sum()) + eps\n    p = hist / total\n    entropy = -np.sum(np.where(p > 0, p * np.log(p + eps), 0.0))\n    # normalize to [0,1] by dividing by log(bins)\n    return float(entropy / (np.log(bins) + eps))\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Vertical edge density: fraction of pixels with strong vertical gradient'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    if gray.size == 0:\n        return 0.0\n    gy, gx = np.gradient(gray)\n    vert = np.abs(gy)\n    thr = float(np.percentile(vert.flatten(), 75))\n    count = np.count_nonzero(vert > thr)\n    return float(count / (vert.size + eps))\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Horizontal skyline score: fraction of rows with strong horizontal edge activity'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    gy, gx = np.gradient(gray)\n    row_activity = np.mean(np.abs(gx), axis=1)  # per-row horizontal change\n    thr = np.percentile(row_activity, 90) if row_activity.size > 0 else np.max(row_activity)\n    rows_high = np.count_nonzero(row_activity > thr)\n    return float(rows_high / (h + eps))\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Low-frequency energy ratio using 3x3 uniform blur (smoothness vs detail)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        # convert to luminance for energy computation\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    if gray.size == 0:\n        return 0.0\n    p = np.pad(gray, ((1, 1), (1, 1)), mode='reflect')\n    # sum of 3x3 neighborhood via slicing\n    s = (p[:-2, :-2] + p[:-2, 1:-1] + p[:-2, 2:] +\n         p[1:-1, :-2] + p[1:-1, 1:-1] + p[1:-1, 2:] +\n         p[2:, :-2] + p[2:, 1:-1] + p[2:, 2:])\n    low = s / 9.0\n    low_energy = np.sum(low * low)\n    total_energy = np.sum(gray * gray) + eps\n    return float(low_energy / total_energy)\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Relative blue-green top vs bottom difference (sky/water vertical bias)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if len(image.shape) == 2:\n        rgb = np.stack([image, image, image], axis=2).astype(float)\n    else:\n        rgb = image.astype(float)\n    h = rgb.shape[0]\n    if h == 0:\n        return 0.0\n    top_h = max(1, h // 4)\n    top = rgb[:top_h, :, :]\n    bottom = rgb[-top_h:, :, :]\n    B_top = np.mean(top[:, :, 2]) if top.size else 0.0\n    G_top = np.mean(top[:, :, 1]) if top.size else 0.0\n    B_bot = np.mean(bottom[:, :, 2]) if bottom.size else 0.0\n    G_bot = np.mean(bottom[:, :, 1]) if bottom.size else 0.0\n    top_val = B_top - G_top\n    bot_val = B_bot - G_bot\n    denom = (abs(top_val) + abs(bot_val) + eps)\n    return float((top_val - bot_val) / denom)\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Fraction of smooth blocks (low local std) using non-overlapping blocks'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    if h < 8 or w < 8 or gray.size == 0:\n        return 0.0\n    # block size roughly 1/8 of smaller dimension but at least 8\n    bs = max(8, min(h, w) // 8)\n    nh = h // bs\n    nw = w // bs\n    if nh == 0 or nw == 0:\n        return 0.0\n    trimmed = gray[:nh*bs, :nw*bs]\n    blocks = trimmed.reshape(nh, bs, nw, bs).swapaxes(1,2).reshape(nh*nw, bs*bs)\n    global_std = np.std(gray) + eps\n    block_std = np.std(blocks, axis=1)\n    smooth_count = np.count_nonzero(block_std < (0.35 * global_std))\n    return float(smooth_count / (blocks.shape[0] + eps))\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Skewness of luminance distribution (asymmetry of brightness)'\n    import numpy as np\n    eps = 1e-12\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        lum = np.mean(image, axis=2).astype(float).flatten()\n    else:\n        lum = image.astype(float).flatten()\n    if lum.size == 0:\n        return 0.0\n    m = np.mean(lum)\n    s = np.std(lum) + eps\n    skew = np.mean(((lum - m) ** 3)) / (s ** 3 + eps)\n    return float(skew)\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Mean saturation among the brightest 10% pixels (vivid bright colors indicator)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if len(image.shape) == 2:\n        rgb = np.stack([image, image, image], axis=2).astype(float)\n    else:\n        rgb = image.astype(float)\n    R = rgb[:, :, 0]\n    G = rgb[:, :, 1]\n    B = rgb[:, :, 2]\n    mx = np.maximum(np.maximum(R, G), B)\n    mn = np.minimum(np.minimum(R, G), B)\n    intensity = np.mean(rgb, axis=2)\n    flat_int = intensity.flatten()\n    if flat_int.size == 0:\n        return 0.0\n    thr = np.percentile(flat_int, 90)\n    mask = intensity >= thr\n    if np.count_nonzero(mask) == 0:\n        return 0.0\n    sat = (mx - mn) / (mx + eps)\n    return float(np.mean(sat[mask]))\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Vertical mirror symmetry score between top and flipped bottom (1 = symmetric)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        arr = np.mean(image, axis=2).astype(float)\n    else:\n        arr = image.astype(float)\n    h = arr.shape[0]\n    if h < 2 or arr.size == 0:\n        return 0.0\n    half = h // 2\n    top = arr[:half, :]\n    bottom = arr[-half:, :]\n    if top.shape != bottom.shape:\n        # ensure same shape by cropping the larger\n        minr = min(top.shape[0], bottom.shape[0])\n        top = top[:minr, :]\n        bottom = bottom[-minr:, :]\n    bottom_flipped = np.flipud(bottom)\n    diff = np.abs(top - bottom_flipped)\n    denom = np.mean(np.abs(top)) + np.mean(np.abs(bottom_flipped)) + eps\n    norm_diff = np.mean(diff) / denom\n    score = 1.0 - np.clip(norm_diff, 0.0, 1.0)\n    return float(score)\n",
  "def feature(image: np.ndarray) -> float:\n    'Fraction of image pixels that are blue-dominant and locally smooth (water-like smooth blue areas)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    img = image.astype(float)\n    if img.ndim == 2:\n        rgb = np.stack([img, img, img], axis=2)\n    else:\n        rgb = img\n    h, w = rgb.shape[:2]\n    gray = np.mean(rgb, axis=2)\n    gy, gx = np.gradient(gray)\n    mag = np.sqrt(gx * gx + gy * gy)\n    if mag.size == 0:\n        return 0.0\n    low_thr = float(np.percentile(mag.flatten(), 30))\n    blue_dom = (rgb[:, :, 2] > rgb[:, :, 0]) & (rgb[:, :, 2] > rgb[:, :, 1])\n    smooth = mag <= low_thr\n    mask = blue_dom & smooth\n    return float(np.count_nonzero(mask) / (h * w + eps))\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Fraction of top 20% rows that are bright and blue-dominant (sky indicator)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    img = image.astype(float)\n    if img.ndim == 2:\n        return 0.0\n    rgb = img\n    h, w = rgb.shape[:2]\n    top_h = max(1, h // 5)\n    top = rgb[:top_h, :, :]\n    if top.size == 0:\n        return 0.0\n    intensity = np.mean(top, axis=2)\n    thr = float(np.mean(intensity))\n    blue_dom = (top[:, :, 2] > top[:, :, 0]) & (top[:, :, 2] > top[:, :, 1])\n    bright = intensity >= thr\n    mask = blue_dom & bright\n    return float(np.count_nonzero(mask) / (top_h * w + eps))\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Colorfulness metric (Hasler-S\u00fcsstrunk style) normalized by mean intensity'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    img = image.astype(float)\n    if img.ndim == 2:\n        rgb = np.stack([img, img, img], axis=2)\n    else:\n        rgb = img\n    R = rgb[:, :, 0].flatten()\n    G = rgb[:, :, 1].flatten()\n    B = rgb[:, :, 2].flatten()\n    if R.size == 0:\n        return 0.0\n    rg = R - G\n    yb = 0.5 * (R + G) - B\n    std_rg = float(np.std(rg))\n    std_yb = float(np.std(yb))\n    mean_rg = float(np.mean(rg))\n    mean_yb = float(np.mean(yb))\n    colorfulness = np.sqrt(std_rg * std_rg + std_yb * std_yb) + 0.3 * np.sqrt(mean_rg * mean_rg + mean_yb * mean_yb)\n    mean_intensity = float(np.mean((R + G + B) / 3.0) + eps)\n    return float(colorfulness / mean_intensity)\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Edge density: fraction of pixels with gradient magnitude above the 75th percentile'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    img = image.astype(float)\n    if img.ndim == 3:\n        gray = np.mean(img, axis=2)\n    else:\n        gray = img\n    if gray.size == 0:\n        return 0.0\n    gy, gx = np.gradient(gray)\n    mag = np.sqrt(gx * gx + gy * gy)\n    thr = float(np.percentile(mag.flatten(), 75))\n    strong = mag > thr\n    return float(np.count_nonzero(strong) / (gray.size + eps))\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Proportion of strong edges that are predominantly horizontal (edge orientation bias)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.5\n    img = image.astype(float)\n    if img.ndim == 3:\n        gray = np.mean(img, axis=2)\n    else:\n        gray = img\n    if gray.size == 0:\n        return 0.5\n    gy, gx = np.gradient(gray)\n    mag = np.sqrt(gx * gx + gy * gy)\n    thr = float(np.percentile(mag.flatten(), 70))\n    strong_mask = mag > thr\n    if np.count_nonzero(strong_mask) == 0:\n        return 0.5\n    horiz_pref = np.abs(gy) > np.abs(gx)\n    count_horiz = np.count_nonzero(strong_mask & horiz_pref)\n    return float(count_horiz / (np.count_nonzero(strong_mask) + eps))\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Normalized intensity contrast between center region and border (range approx -1..1)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    img = image.astype(float)\n    if img.ndim == 3:\n        gray = np.mean(img, axis=2)\n    else:\n        gray = img\n    h, w = gray.shape[:2]\n    sr, sc = h // 4, w // 4\n    er, ec = h - sr, w - sc\n    if er > sr and ec > sc:\n        center = gray[sr:er, sc:ec]\n        # border as everything outside center\n        mask = np.ones_like(gray, dtype=bool)\n        mask[sr:er, sc:ec] = False\n        border_vals = gray[mask]\n    else:\n        center = gray\n        border_vals = gray\n    if center.size == 0 or border_vals.size == 0:\n        return 0.0\n    mean_c = float(np.mean(center))\n    mean_b = float(np.mean(border_vals))\n    return float((mean_c - mean_b) / (mean_c + mean_b + eps))\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Fraction of image area that is very smooth (low gradient magnitude) - global smoothness fraction'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 1.0\n    img = image.astype(float)\n    if img.ndim == 3:\n        gray = np.mean(img, axis=2)\n    else:\n        gray = img\n    if gray.size == 0:\n        return 1.0\n    gy, gx = np.gradient(gray)\n    mag = np.sqrt(gx * gx + gy * gy)\n    thr = float(np.percentile(mag.flatten(), 25))\n    smooth_mask = mag <= thr\n    return float(np.count_nonzero(smooth_mask) / (gray.size + eps))\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Green compactness: ratio of green-pixel count to bounding-box area of green pixels (higher = more compact blobs)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    img = image.astype(float)\n    if img.ndim == 2:\n        return 0.0\n    rgb = img\n    R = rgb[:, :, 0]\n    G = rgb[:, :, 1]\n    B = rgb[:, :, 2]\n    intensity = np.mean(rgb, axis=2)\n    green_mask = (G > R) & (G > B) & (G > intensity * 0.9)\n    coords = np.nonzero(green_mask)\n    count = coords[0].size\n    if count == 0:\n        return 0.0\n    minr, maxr = int(coords[0].min()), int(coords[0].max())\n    minc, maxc = int(coords[1].min()), int(coords[1].max())\n    bbox_area = (maxr - minr + 1) * (maxc - minc + 1)\n    if bbox_area <= 0:\n        return 0.0\n    compactness = count / float(bbox_area + eps)\n    return float(compactness)\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Longest consecutive horizontal run in lower half where rows have substantial blue fraction (horizon/shoreline score)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    img = image.astype(float)\n    if img.ndim == 2:\n        rgb = np.stack([img, img, img], axis=2)\n    else:\n        rgb = img\n    h, w = rgb.shape[:2]\n    start = h // 2\n    if start >= h:\n        return 0.0\n    lower = rgb[start:, :, :]\n    rows = lower.shape[0]\n    if rows == 0:\n        return 0.0\n    blue_row_frac = np.mean((lower[:, :, 2] > lower[:, :, 0]) & (lower[:, :, 2] > lower[:, :, 1]), axis=1)\n    mask = blue_row_frac >= 0.25\n    # longest consecutive True run\n    max_run = 0\n    cur = 0\n    for val in mask:\n        if val:\n            cur += 1\n            if cur > max_run:\n                max_run = cur\n        else:\n            cur = 0\n    return float(max_run / (h + eps))\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Normalized intensity histogram entropy (0..1) using 16 bins'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    img = image.astype(float)\n    if img.ndim == 3:\n        gray = np.mean(img, axis=2)\n    else:\n        gray = img\n    flat = gray.flatten()\n    if flat.size == 0:\n        return 0.0\n    bins = 16\n    hist, _ = np.histogram(flat, bins=bins, range=(flat.min(), flat.max()), density=False)\n    total = float(hist.sum()) + eps\n    p = hist.astype(float) / total\n    p_nonzero = p[p > 0]\n    entropy = -float(np.sum(p_nonzero * np.log(p_nonzero + eps)))\n    # normalize by log(bins) to keep in 0..1\n    norm = float(entropy / (np.log(bins) + eps))\n    return float(norm)\n",
  "def feature(image: np.ndarray) -> float:\n    'Proportion of strongly blue pixels relative to image size (water indicator)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if image.ndim == 2:\n        rgb = np.stack([image, image, image], axis=2).astype(float)\n    else:\n        rgb = image.astype(float)\n    R = rgb[:, :, 0]\n    G = rgb[:, :, 1]\n    B = rgb[:, :, 2]\n    mean_int = np.mean((R + G + B) / 3.0) + eps\n    # blue-dominant and reasonably brighter than average\n    mask = (B > 1.15 * G) & (B > 1.15 * R) & (B > 0.9 * mean_int)\n    return float(np.count_nonzero(mask) / (R.size + eps))\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Normalized vertical centroid of blue-dominant pixels (0=top,1=bottom)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.5\n    if image.ndim == 2:\n        rgb = np.stack([image, image, image], axis=2).astype(float)\n    else:\n        rgb = image.astype(float)\n    h, w = rgb.shape[:2]\n    R = rgb[:, :, 0]; G = rgb[:, :, 1]; B = rgb[:, :, 2]\n    mask = (B > G) & (B > R)\n    if not np.any(mask):\n        return 0.5\n    rows = np.nonzero(mask)[0]\n    centroid = float(np.mean(rows))\n    return float(centroid / max(1, h - 1))\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Fraction of strong edges that are on green-dominant pixels (vegetation edge density)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if image.ndim == 3:\n        green = image[:, :, 1].astype(float)\n        R = image[:, :, 0].astype(float)\n        B = image[:, :, 2].astype(float)\n    else:\n        green = image.astype(float)\n        R = green; B = green\n    gy, gx = np.gradient(green)\n    mag = np.sqrt(gx * gx + gy * gy)\n    if mag.size == 0:\n        return 0.0\n    thr = np.percentile(mag.flatten(), 75)\n    strong_edge = mag > thr\n    green_dom = (green > R) & (green > B)\n    mask = strong_edge & green_dom\n    return float(np.count_nonzero(mask) / (green.size + eps))\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Lower-half smoothness measured as inverse of gradient std (higher = smoother)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if image.ndim == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    h = gray.shape[0]\n    mid = h // 2\n    lower = gray[mid:, :] if mid < h else gray\n    if lower.size == 0:\n        return 0.0\n    gy, gx = np.gradient(lower)\n    mag = np.sqrt(gx * gx + gy * gy)\n    std = float(np.std(mag))\n    return float(1.0 / (std + eps))\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Normalized absolute difference between mean blue in top and bottom bands'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if image.ndim == 2:\n        rgb = np.stack([image, image, image], axis=2).astype(float)\n    else:\n        rgb = image.astype(float)\n    h = rgb.shape[0]\n    band = max(1, h // 6)\n    top_mean = float(np.mean(rgb[:band, :, 2])) if band > 0 else 0.0\n    bot_mean = float(np.mean(rgb[-band:, :, 2])) if band > 0 else 0.0\n    overall = float(np.mean(rgb)) + eps\n    return float(abs(bot_mean - top_mean) / overall)\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Fraction of near-white pixels in the center region (specular/highlight fraction)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if image.ndim == 2:\n        rgb = np.stack([image, image, image], axis=2).astype(float)\n    else:\n        rgb = image.astype(float)\n    h, w = rgb.shape[:2]\n    sr, sc = h // 4, w // 4\n    er, ec = h - sr, w - sc\n    center = rgb[sr:er, sc:ec, :] if (er > sr and ec > sc) else rgb\n    if center.size == 0:\n        return 0.0\n    R = center[:, :, 0]; G = center[:, :, 1]; B = center[:, :, 2]\n    mx = np.max(center)\n    if mx <= 0:\n        return 0.0\n    thr = mx * 0.9\n    mask = (R >= thr) & (G >= thr) & (B >= thr)\n    return float(np.count_nonzero(mask) / (R.size + eps))\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Colorfulness score (Hasler-S\u00fcsstrunk style) across the whole image'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if image.ndim == 2:\n        R = G = B = image.astype(float)\n    else:\n        R = image[:, :, 0].astype(float)\n        G = image[:, :, 1].astype(float)\n        B = image[:, :, 2].astype(float)\n    rg = R - G\n    yb = 0.5 * (R + G) - B\n    std_rg = float(np.std(rg))\n    std_yb = float(np.std(yb))\n    mean_rg = float(np.mean(rg))\n    mean_yb = float(np.mean(yb))\n    colorfulness = np.sqrt(std_rg * std_rg + std_yb * std_yb) + 0.3 * np.sqrt(mean_rg * mean_rg + mean_yb * mean_yb)\n    return float(colorfulness)\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Area fraction of bounding box of blue-dominant region (largest blue blob bounding box)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if image.ndim == 2:\n        rgb = np.stack([image, image, image], axis=2).astype(float)\n    else:\n        rgb = image.astype(float)\n    h, w = rgb.shape[:2]\n    R = rgb[:, :, 0]; G = rgb[:, :, 1]; B = rgb[:, :, 2]\n    meanB = float(np.mean(B)) + eps\n    mask = (B > G) & (B > R) & (B > 0.8 * meanB)\n    if not np.any(mask):\n        return 0.0\n    rows, cols = np.where(mask)\n    minr, maxr = int(rows.min()), int(rows.max())\n    minc, maxc = int(cols.min()), int(cols.max())\n    bbox_area = float((maxr - minr + 1) * (maxc - minc + 1))\n    return float(bbox_area / (h * w + eps))\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Center vs surrounding ring intensity contrast (positive if center brighter)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if image.ndim == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    cr = max(1, min(h, w) // 6)\n    sr, sc = h // 2 - cr, w // 2 - cr\n    er, ec = h // 2 + cr, w // 2 + cr\n    sr = max(0, sr); sc = max(0, sc); er = min(h, er); ec = min(w, ec)\n    center = gray[sr:er, sc:ec]\n    if center.size == 0:\n        return 0.0\n    # surrounding ring: whole image minus center\n    total_mean = float(np.mean(gray))\n    center_mean = float(np.mean(center))\n    ring_mean = float((np.sum(gray) - np.sum(center)) / (gray.size - center.size + eps))\n    return float((center_mean - ring_mean) / (abs(ring_mean) + eps))\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Approximate dominant color hue angle using mean chroma differences (range -1..1)'\n    import numpy as np\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if image.ndim == 2:\n        R = G = B = image.astype(float)\n    else:\n        R = image[:, :, 0].astype(float)\n        G = image[:, :, 1].astype(float)\n        B = image[:, :, 2].astype(float)\n    meanR = float(np.mean(R))\n    meanG = float(np.mean(G))\n    meanB = float(np.mean(B))\n    x = meanR - meanG\n    y = meanB - meanG\n    ang = float(np.arctan2(y, x))  # -pi..pi\n    return float(ang / np.pi)\n",
  "def feature(image: np.ndarray) -> float:\n    'Fraction of strong edges (gradient magnitude) in the image'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    # convert to grayscale\n    img = image.astype(float)\n    if img.ndim == 3:\n        gray = np.mean(img, axis=2)\n    else:\n        gray = img\n    h, w = gray.shape[:2]\n    if h < 2 or w < 2:\n        return 0.0\n    gy, gx = np.gradient(gray)\n    mag = np.sqrt(gx * gx + gy * gy)\n    thr = np.percentile(mag.flatten(), 75) if mag.size else 0.0\n    mask = mag >= thr\n    return float(np.count_nonzero(mask) / (mag.size + eps))\n\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Normalized top vs bottom mean intensity difference (top-bottom bias)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    img = image.astype(float)\n    h = img.shape[0]\n    band = max(1, h // 4)\n    # intensity\n    if img.ndim == 3:\n        inten = np.mean(img, axis=2)\n    else:\n        inten = img\n    top_mean = float(np.mean(inten[:band, :])) if inten.size else 0.0\n    bot_mean = float(np.mean(inten[-band:, :])) if inten.size else 0.0\n    denom = (abs(top_mean) + abs(bot_mean) + eps)\n    return float((top_mean - bot_mean) / denom)\n\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Fraction of globally blue-dominant pixels (water color indicator)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if len(image.shape) == 2:\n        rgb = np.stack([image, image, image], axis=2).astype(float)\n    else:\n        rgb = image.astype(float)\n    r = rgb[:, :, 0].flatten()\n    g = rgb[:, :, 1].flatten()\n    b = rgb[:, :, 2].flatten()\n    mx = np.maximum(np.maximum(r, g), b) + eps\n    mask = (b > r) & (b > g) & (b > 0.45 * mx)\n    return float(np.count_nonzero(mask) / (mx.size + eps))\n\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Circular hue concentration (resultant length of hue weighted by chroma)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    img = image.astype(float)\n    if img.ndim == 2:\n        r = g = b = img\n    else:\n        r, g, b = img[:, :, 0], img[:, :, 1], img[:, :, 2]\n    mx = np.maximum(np.maximum(r, g), b)\n    mn = np.minimum(np.minimum(r, g), b)\n    chroma = (mx - mn).flatten()\n    # hue using atan2 formulation (returns -pi..pi)\n    num = np.sqrt(3.0) * (g - b)\n    den = (2.0 * r - g - b)\n    hue = np.arctan2(num.flatten(), den.flatten())\n    weights = chroma\n    total_w = float(np.sum(weights) + eps)\n    if total_w <= eps:\n        return 0.0\n    c = float(np.sum(np.cos(hue) * weights) / total_w)\n    s = float(np.sum(np.sin(hue) * weights) / total_w)\n    resultant = np.sqrt(c * c + s * s)\n    # clamp to [0,1]\n    return float(max(0.0, min(1.0, resultant)))\n\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Color distance between top-10% and bottom-10% regions (RGB euclidean)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    img = image.astype(float)\n    h = img.shape[0]\n    band = max(1, h // 10)\n    if img.ndim == 2:\n        top = bottom = img\n        top_mean = np.array([np.mean(top[:band, :])]*3)\n        bot_mean = np.array([np.mean(top[-band:, :])]*3)\n    else:\n        top_mean = np.array([np.mean(img[:band, :, c]) for c in range(img.shape[2])])\n        bot_mean = np.array([np.mean(img[-band:, :, c]) for c in range(img.shape[2])])\n    dist = np.linalg.norm(top_mean - bot_mean)\n    norm = (np.linalg.norm((top_mean + bot_mean) / 2.0) + eps)\n    return float(dist / norm)\n\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Fraction of high-contrast pixels relative to image median (foreground estimate)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    img = image.astype(float)\n    if img.ndim == 3:\n        gray = np.mean(img, axis=2)\n    else:\n        gray = img\n    flat = gray.flatten()\n    if flat.size == 0:\n        return 0.0\n    med = np.median(flat)\n    sd = float(np.std(flat) + eps)\n    mask = np.abs(flat - med) > (0.7 * sd)\n    return float(np.count_nonzero(mask) / (flat.size + eps))\n\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Left-right mean color similarity score (1 = identical, 0 = very different)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    img = image.astype(float)\n    h, w = img.shape[:2]\n    mid = w // 2\n    if img.ndim == 2:\n        left = img[:, :mid]\n        right = img[:, mid:]\n        left_mean = np.array([np.mean(left)]) if left.size else np.array([0.0])\n        right_mean = np.array([np.mean(right)]) if right.size else np.array([0.0])\n    else:\n        left_mean = np.array([np.mean(img[:, :mid, c]) for c in range(3)]) if mid > 0 else np.array([0.0, 0.0, 0.0])\n        right_mean = np.array([np.mean(img[:, mid:, c]) for c in range(3)]) if w - mid > 0 else np.array([0.0, 0.0, 0.0])\n    d = float(np.linalg.norm(left_mean - right_mean))\n    baseline = float(np.linalg.norm((left_mean + right_mean) / 2.0) + eps)\n    score = 1.0 - (d / (baseline + eps))\n    return float(max(0.0, min(1.0, score)))\n\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Normalized mean absolute Laplacian (full-image curvature / texture)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if image.ndim == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    if gray.size == 0:\n        return 0.0\n    gy, gx = np.gradient(gray)\n    gyy, _ = np.gradient(gy)\n    _, gxx = np.gradient(gx)\n    lap = gyy + gxx\n    mean_abs_lap = float(np.mean(np.abs(lap)))\n    mean_abs_grad = float(np.mean(np.sqrt(gx * gx + gy * gy)) + eps)\n    return float(mean_abs_lap / (mean_abs_grad + eps))\n\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Fraction of bright specular blue highlights (bright + blue-dominant)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if len(image.shape) == 2:\n        rgb = np.stack([image, image, image], axis=2).astype(float)\n    else:\n        rgb = image.astype(float)\n    r = rgb[:, :, 0].flatten()\n    g = rgb[:, :, 1].flatten()\n    b = rgb[:, :, 2].flatten()\n    inten = (r + g + b) / 3.0\n    mean_i = float(np.mean(inten))\n    std_i = float(np.std(inten) + eps)\n    bright_mask = inten > (mean_i + 1.0 * std_i)\n    blue_dominant = (b > r) & (b > g)\n    mask = bright_mask & blue_dominant\n    return float(np.count_nonzero(mask) / (inten.size + eps))\n\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Skewness of green channel distribution (third standardized moment)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    img = image.astype(float)\n    if img.ndim == 2:\n        g = img.flatten()\n    else:\n        g = img[:, :, 1].flatten()\n    if g.size == 0:\n        return 0.0\n    mean_g = float(np.mean(g))\n    std_g = float(np.std(g) + eps)\n    skew = float(np.mean((g - mean_g) ** 3) / (std_g ** 3 + eps))\n    # keep values in a reasonable numeric range\n    if np.isnan(skew) or np.isinf(skew):\n        return 0.0\n    return float(max(-10.0, min(10.0, skew)))\n",
  "def feature(image: np.ndarray) -> float:\n    'Skewness of the blue channel histogram (blue-heavy tails)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if image.ndim == 2:\n        blue = image.astype(float).flatten()\n    else:\n        blue = image[:, :, 2].astype(float).flatten()\n    if blue.size == 0:\n        return 0.0\n    m = float(np.mean(blue))\n    s = float(np.std(blue)) + eps\n    skew = float(np.mean(((blue - m) / s) ** 3))\n    return float(skew)\n\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Ratio of mean luminance in bottom third to mean luminance in top third'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    h, w = image.shape[:2]\n    t = max(1, h // 3)\n    b = max(1, h - 2 * t)\n    if image.ndim == 2:\n        Y = image.astype(float)\n    else:\n        rgb = image.astype(float)\n        Y = 0.299 * rgb[:, :, 0] + 0.587 * rgb[:, :, 1] + 0.114 * rgb[:, :, 2]\n    top = Y[:t, :]\n    bottom = Y[-t:, :]\n    if top.size == 0 or bottom.size == 0:\n        return 0.0\n    mean_top = float(np.mean(top))\n    mean_bottom = float(np.mean(bottom))\n    return float(mean_bottom / (mean_top + eps))\n\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Proportion of horizontal edge energy concentrated in the central horizontal band'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if image.ndim == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    gy, gx = np.gradient(gray)\n    horiz_mag = np.abs(gy)\n    if horiz_mag.size == 0:\n        return 0.0\n    thr = np.percentile(horiz_mag, 75)\n    strong = horiz_mag > (thr + eps)\n    sr = h // 3\n    er = max(sr + 1, 2 * h // 3)\n    band = np.zeros_like(strong)\n    band[sr:er, :] = True\n    num_strong = np.count_nonzero(strong)\n    if num_strong == 0:\n        return 0.0\n    return float(np.count_nonzero(strong & band) / (num_strong + eps))\n\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Normalized Euclidean distance between mean center color and mean border color'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if image.ndim == 2:\n        rgb = np.stack([image, image, image], axis=2).astype(float)\n    else:\n        rgb = image.astype(float)\n    h, w = rgb.shape[:2]\n    br = max(1, min(h, w) // 10)\n    sr, sc = h // 4, w // 4\n    er, ec = h - sr, w - sc\n    center = rgb[sr:er, sc:ec, :] if (er > sr and ec > sc) else rgb\n    # border: pixels within br of any edge\n    mask = np.zeros((h, w), dtype=bool)\n    mask[:br, :] = True\n    mask[-br:, :] = True\n    mask[:, :br] = True\n    mask[:, -br:] = True\n    border = rgb[mask]\n    if center.size == 0 or border.size == 0:\n        return 0.0\n    mean_center = np.mean(center.reshape(-1, 3), axis=0)\n    mean_border = np.mean(border.reshape(-1, 3), axis=0)\n    dist = np.linalg.norm(mean_center - mean_border)\n    norm = (np.mean((mean_center + mean_border) / 2.0) + eps)\n    return float(dist / norm)\n\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Fraction of pixels that are very bright and blue-dominant (possible specular blue highlights)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if image.ndim == 2:\n        rgb = np.stack([image, image, image], axis=2).astype(float)\n    else:\n        rgb = image.astype(float)\n    r = rgb[:, :, 0]\n    g = rgb[:, :, 1]\n    b = rgb[:, :, 2]\n    intensity = (r + g + b) / 3.0\n    p95 = float(np.percentile(intensity, 95))\n    bright = intensity >= (p95 - eps)\n    blue_dom = (b > 1.05 * r) & (b > 1.05 * g)\n    mask = bright & blue_dom\n    return float(np.count_nonzero(mask) / (mask.size + eps))\n\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Coarse texture: std of an 8x8 block-averaged image normalized by image std'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if image.ndim == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    desired_blocks = 8\n    bh = max(1, h // desired_blocks)\n    bw = max(1, w // desired_blocks)\n    nh = max(1, h // bh)\n    nw = max(1, w // bw)\n    h_eff = nh * bh\n    w_eff = nw * bw\n    crop = gray[:h_eff, :w_eff]\n    try:\n        down = crop.reshape(nh, bh, nw, bw).mean(axis=(1, 3))\n    except Exception:\n        down = np.mean(crop)\n        down = np.array([[down]])\n    coarse_std = float(np.std(down))\n    overall_std = float(np.std(gray)) + eps\n    return float(coarse_std / overall_std)\n\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Ratio of mean red to mean blue in the top half (warmth in sky region)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    h = image.shape[0]\n    top_h = max(1, h // 2)\n    if image.ndim == 2:\n        top = image[:top_h, :].astype(float)\n        meanR = float(np.mean(top))\n        meanB = meanR\n    else:\n        top = image[:top_h, :, :].astype(float)\n        meanR = float(np.mean(top[:, :, 0]))\n        meanB = float(np.mean(top[:, :, 2]))\n    return float(meanR / (meanB + eps))\n\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Normalized difference between median brightness of top 10% rows and bottom 10% rows'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    h = image.shape[0]\n    band = max(1, h // 10)\n    if image.ndim == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    top_med = float(np.median(gray[:band, :])) if band <= gray.shape[0] else float(np.median(gray))\n    bot_med = float(np.median(gray[-band:, :])) if band <= gray.shape[0] else float(np.median(gray))\n    global_mean = float(np.mean(gray)) + eps\n    return float((top_med - bot_med) / global_mean)\n\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Vertical symmetry score: 1 - normalized mean absolute difference between left and mirrored right halves'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    h, w = image.shape[:2]\n    if image.ndim == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    half = w // 2\n    if half == 0:\n        return 0.0\n    left = gray[:, :half]\n    right = gray[:, -half:]\n    right_flipped = np.fliplr(right)\n    if left.shape != right_flipped.shape:\n        # crop to minimum common shape\n        min_h = min(left.shape[0], right_flipped.shape[0])\n        min_w = min(left.shape[1], right_flipped.shape[1])\n        left = left[:min_h, :min_w]\n        right_flipped = right_flipped[:min_h, :min_w]\n    mean_abs_diff = float(np.mean(np.abs(left - right_flipped)))\n    mean_int = float(np.mean(gray)) + eps\n    score = 1.0 - (mean_abs_diff / mean_int)\n    return float(score)\n",
  "def feature(image: np.ndarray) -> float:\n    'Fraction of blue-dominant pixels in the top third of the image'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    img = image.astype(float)\n    h, w = img.shape[:2]\n    top = max(1, h // 3)\n    if img.ndim == 2:\n        # grayscale -> no blue dominance\n        return 0.0\n    R = img[:top, :, 0]\n    G = img[:top, :, 1]\n    B = img[:top, :, 2]\n    # blue-dominant threshold: blue greater than other channels by a margin\n    thr = 5.0  # absolute margin in image value units; robust across scales\n    mask = (B > G + thr) & (B > R + thr)\n    return float(np.count_nonzero(mask) / float(mask.size + eps))\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Normalized vertical centroid of blue-dominant pixels (0=top,1=bottom)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    img = image.astype(float)\n    h, w = img.shape[:2]\n    if img.ndim == 2:\n        return 0.0\n    R = img[:, :, 0].ravel()\n    G = img[:, :, 1].ravel()\n    B = img[:, :, 2].ravel()\n    blue_mask = (B > G) & (B > R)\n    if np.count_nonzero(blue_mask) == 0:\n        return 0.0\n    # compute row indices for each pixel\n    rows = np.repeat(np.arange(h), w)\n    rows_blue = rows[blue_mask]\n    centroid_row = float(np.mean(rows_blue))\n    return float(centroid_row / (h - 1.0 + eps))\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Ratio of horizontal to vertical edge energy in grayscale (horizontal/vertical)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    img = image.astype(float)\n    if img.ndim == 3:\n        gray = np.mean(img, axis=2)\n    else:\n        gray = img\n    gy, gx = np.gradient(gray)\n    # energy as mean absolute gradient\n    horiz_energy = float(np.mean(np.abs(gx)))\n    vert_energy = float(np.mean(np.abs(gy)))\n    return float(horiz_energy / (vert_energy + eps))\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Left-right symmetry score of the image (1 = symmetric, 0 = very asymmetric)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    img = image.astype(float)\n    h, w = img.shape[:2]\n    if img.ndim == 3:\n        gray = np.mean(img, axis=2)\n    else:\n        gray = img\n    half = w // 2\n    left = gray[:, :half]\n    # take corresponding right part (same width)\n    right = gray[:, w - half:]\n    if left.size == 0 or right.size == 0:\n        return 0.0\n    right_flipped = np.fliplr(right)\n    mean_abs_diff = float(np.mean(np.abs(left - right_flipped)))\n    mean_intensity = float(np.mean(gray) + eps)\n    score = 1.0 - (mean_abs_diff / (mean_intensity + eps))\n    # clamp to [0,1]\n    score = max(0.0, min(1.0, score))\n    return float(score)\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Fraction of red-dominant pixels in the central region (centered R > G and R > B)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    img = image.astype(float)\n    h, w = img.shape[:2]\n    sr, sc = h // 4, w // 4\n    er, ec = h - sr, w - sc\n    if img.ndim == 2:\n        rgb = np.stack([img, img, img], axis=2)\n    else:\n        rgb = img\n    center = rgb[sr:er, sc:ec, :] if (er > sr and ec > sc) else rgb\n    if center.size == 0:\n        return 0.0\n    R = center[:, :, 0]\n    G = center[:, :, 1]\n    B = center[:, :, 2]\n    mask = (R > G) & (R > B)\n    return float(np.count_nonzero(mask) / (mask.size + eps))\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Normalized row position of the row with maximum mean green (0=top,1=bottom)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    img = image.astype(float)\n    h, w = img.shape[:2]\n    if img.ndim == 2:\n        # grayscale -> no green information\n        return 0.0\n    G = img[:, :, 1]\n    row_means = np.mean(G, axis=1)\n    if row_means.size == 0:\n        return 0.0\n    idx = int(np.argmax(row_means))\n    return float(idx / (h - 1.0 + eps))\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Spread (normalized mean distance) of the top 5% brightest pixels around their centroid'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    img = image.astype(float)\n    h, w = img.shape[:2]\n    if img.ndim == 3:\n        bright = np.mean(img, axis=2)\n    else:\n        bright = img\n    flat = bright.ravel()\n    if flat.size == 0:\n        return 0.0\n    p = 95\n    thr = float(np.percentile(flat, p))\n    mask = bright >= thr\n    count = np.count_nonzero(mask)\n    if count < 3:\n        return 0.0\n    ys, xs = np.nonzero(mask)\n    vals = bright[mask]\n    # weighted centroid\n    total = float(np.sum(vals) + eps)\n    cx = float(np.sum(xs * vals) / total)\n    cy = float(np.sum(ys * vals) / total)\n    dists = np.sqrt((xs - cx) ** 2 + (ys - cy) ** 2)\n    mean_dist = float(np.mean(dists))\n    diag = np.sqrt(h * h + w * w) + eps\n    return float(mean_dist / diag)\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Entropy of gradient orientations (how diverse edge directions are)'\n    import numpy as np\n    eps = 1e-10\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    img = image.astype(float)\n    if img.ndim == 3:\n        gray = np.mean(img, axis=2)\n    else:\n        gray = img\n    gy, gx = np.gradient(gray)\n    mag = np.sqrt(gx * gx + gy * gy)\n    # ignore near-zero magnitude to focus on meaningful edges\n    mag_flat = mag.ravel()\n    thresh = np.percentile(mag_flat, 50)  # median magnitude\n    mask = mag >= thresh\n    if np.count_nonzero(mask) == 0:\n        return 0.0\n    ori = np.arctan2(gy[mask], gx[mask])  # range -pi..pi\n    bins = 8\n    hist, _ = np.histogram(ori, bins=bins, range=(-np.pi, np.pi))\n    p = hist.astype(float) / (np.sum(hist) + eps)\n    entropy = -np.sum(np.where(p > 0, p * np.log2(p), 0.0))\n    return float(entropy)\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Fraction of low-saturation pixels (chroma small relative to max) across the image'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    img = image.astype(float)\n    if img.ndim == 2:\n        # grayscale is fully unsaturated\n        return 1.0\n    mx = np.max(img, axis=2)\n    mn = np.min(img, axis=2)\n    sat = np.where(mx > 0, (mx - mn) / (mx + eps), 0.0)\n    thr = 0.15  # threshold for \"low saturation\"\n    low_mask = sat < thr\n    return float(np.count_nonzero(low_mask) / float(sat.size + eps))\n",
  "def feature(image: np.ndarray) -> float:\n    'Fraction of high-gradient (edge) pixels using gradient magnitude percentile'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if image.ndim == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    gy, gx = np.gradient(gray)\n    mag = np.sqrt(gx * gx + gy * gy)\n    flat = mag.flatten()\n    if flat.size == 0:\n        return 0.0\n    thr = np.percentile(flat, 90)\n    high = mag >= thr\n    return float(np.count_nonzero(high) / (flat.size + eps))\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Difference between top-quarter and bottom-quarter blue-dominant pixel fractions'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if len(image.shape) == 2:\n        rgb = np.stack([image, image, image], axis=2).astype(float)\n    else:\n        rgb = image.astype(float)\n    h = rgb.shape[0]\n    t = max(1, h // 4)\n    top = rgb[:t, :, :]\n    bottom = rgb[-t:, :, :]\n    def blue_frac(arr):\n        if arr.size == 0:\n            return 0.0\n        r = arr[:, :, 0].reshape(-1)\n        g = arr[:, :, 1].reshape(-1)\n        b = arr[:, :, 2].reshape(-1)\n        return float(np.count_nonzero((b > r) & (b > g)) / (r.size + eps))\n    return float(blue_frac(top) - blue_frac(bottom))\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Max vertical contiguous run of green-dominant pixels in any column (normalized)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if image.ndim == 2:\n        rgb = np.stack([image, image, image], axis=2).astype(float)\n    else:\n        rgb = image.astype(float)\n    h, w = rgb.shape[:2]\n    R = rgb[:, :, 0]\n    G = rgb[:, :, 1]\n    B = rgb[:, :, 2]\n    green = (G > R) & (G > B)\n    if green.size == 0:\n        return 0.0\n    max_run = 0\n    # compute longest contiguous True run per column\n    for c in range(w):\n        col = green[:, c]\n        if not np.any(col):\n            continue\n        # find run lengths by differences\n        d = np.diff(np.concatenate(([0], col.view(np.int8), [0])))\n        starts = np.where(d == 1)[0]\n        ends = np.where(d == -1)[0]\n        if starts.size and ends.size:\n            runs = ends - starts\n            max_run = max(max_run, int(np.max(runs)))\n    return float(max_run / (h + eps))\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Skewness of (B-G) chroma distribution in lower half (third moment normalized)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if image.ndim == 2:\n        rgb = np.stack([image, image, image], axis=2).astype(float)\n    else:\n        rgb = image.astype(float)\n    h = rgb.shape[0]\n    lower = rgb[h//2:, :, :]\n    if lower.size == 0:\n        return 0.0\n    B = lower[:, :, 2].astype(float).reshape(-1)\n    G = lower[:, :, 1].astype(float).reshape(-1)\n    x = (B - G)\n    m = np.mean(x)\n    s = np.std(x) + eps\n    skew = np.mean(((x - m) / s) ** 3)\n    return float(skew)\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Entropy of center-region intensity histogram (higher = more texture/complexity)'\n    import numpy as np\n    eps = 1e-10\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if image.ndim == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    sr, sc = h // 4, w // 4\n    er, ec = h - sr, w - sc\n    region = gray[sr:er, sc:ec] if (er > sr and ec > sc) else gray\n    flat = region.flatten()\n    if flat.size == 0:\n        return 0.0\n    # use 32 bins\n    hist, _ = np.histogram(flat, bins=32, range=(flat.min(), flat.max() if flat.max() > flat.min() else flat.min()+1))\n    p = hist.astype(float) / (np.sum(hist) + eps)\n    ent = -np.sum(np.where(p > 0, p * np.log(p + eps), 0.0))\n    # normalize by log(bins)\n    return float(ent / (np.log(32) + eps))\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Fraction of very bright pixels that are low-saturation (specular/white highlights fraction)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if image.ndim == 2:\n        rgb = np.stack([image, image, image], axis=2).astype(float)\n    else:\n        rgb = image.astype(float)\n    R = rgb[:, :, 0]\n    G = rgb[:, :, 1]\n    B = rgb[:, :, 2]\n    intensity = np.mean(rgb, axis=2)\n    flat = intensity.flatten()\n    if flat.size == 0:\n        return 0.0\n    thr = np.percentile(flat, 99)\n    bright = intensity >= thr\n    if np.count_nonzero(bright) == 0:\n        return 0.0\n    mx = np.maximum(np.maximum(R, G), B)\n    mn = np.minimum(np.minimum(R, G), B)\n    sat = (mx - mn) / (mx + eps)\n    low_sat_and_bright = bright & (sat < 0.12)\n    return float(np.count_nonzero(low_sat_and_bright) / (np.count_nonzero(bright) + eps))\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Relative horizontal vs vertical gradient energy in the center (positive => horizontal dominates)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if image.ndim == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    sr, sc = h // 4, w // 4\n    er, ec = h - sr, w - sc\n    region = gray[sr:er, sc:ec] if (er > sr and ec > sc) else gray\n    if region.size == 0:\n        return 0.0\n    gy, gx = np.gradient(region)\n    eh = np.mean(np.abs(gx))\n    ev = np.mean(np.abs(gy))\n    return float((eh - ev) / (eh + ev + eps))\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Fraction of edge pixels that are isolated (3x3 neighborhood sum == 1) indicating fine speckle texture'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if image.ndim == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    gy, gx = np.gradient(gray)\n    mag = np.sqrt(gx * gx + gy * gy)\n    flat = mag.flatten()\n    if flat.size == 0:\n        return 0.0\n    thr = np.percentile(flat, 90)\n    edges = (mag >= thr).astype(np.int8)\n    # pad and compute 3x3 sums via shifted additions\n    p = np.pad(edges, ((1,1),(1,1)), mode='constant', constant_values=0)\n    s = np.zeros_like(edges, dtype=np.int16)\n    for dy in (-1, 0, 1):\n        for dx in (-1, 0, 1):\n            s += p[1+dy:1+dy+edges.shape[0], 1+dx:1+dx+edges.shape[1]]\n    isolated = (edges == 1) & (s == 1)\n    total_edges = np.count_nonzero(edges)\n    if total_edges == 0:\n        return 0.0\n    return float(np.count_nonzero(isolated) / (total_edges + eps))\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Max horizontal contiguous run length of blue-dominant pixels in middle rows (normalized)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if image.ndim == 2:\n        rgb = np.stack([image, image, image], axis=2).astype(float)\n    else:\n        rgb = image.astype(float)\n    h, w = rgb.shape[:2]\n    rs = h // 4\n    re = h - rs\n    mid = rgb[rs:re, :, :]\n    if mid.size == 0:\n        return 0.0\n    r = mid[:, :, 0]\n    g = mid[:, :, 1]\n    b = mid[:, :, 2]\n    blue = (b > r) & (b > g)\n    max_run = 0\n    for ridx in range(blue.shape[0]):\n        row = blue[ridx, :]\n        if not np.any(row):\n            continue\n        d = np.diff(np.concatenate(([0], row.view(np.int8), [0])))\n        starts = np.where(d == 1)[0]\n        ends = np.where(d == -1)[0]\n        if starts.size and ends.size:\n            runs = ends - starts\n            max_run = max(max_run, int(np.max(runs)))\n    return float(max_run / (w + eps))\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Aspect ratio (width/height) of bright-region bounding box in the central half (0.5 default)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.5\n    if image.ndim == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    sr, sc = h//4, w//4\n    er, ec = h - sr, w - sc\n    region = gray[sr:er, sc:ec] if (er > sr and ec > sc) else gray\n    if region.size == 0:\n        return 0.5\n    thr = np.mean(region) + np.std(region)\n    mask = region >= thr\n    if np.count_nonzero(mask) == 0:\n        return 0.5\n    rows = np.where(np.any(mask, axis=1))[0]\n    cols = np.where(np.any(mask, axis=0))[0]\n    if rows.size == 0 or cols.size == 0:\n        return 0.5\n    height = rows[-1] - rows[0] + 1\n    width = cols[-1] - cols[0] + 1\n    if height <= 0:\n        return 0.5\n    return float((width + eps) / (height + eps))\n",
  "def feature(image: np.ndarray) -> float:\n    'Fraction of blue-dominant pixels weighted by their darkness (captures water vs bright sky)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    img = image.astype(float)\n    if img.ndim == 2:\n        rgb = np.stack([img, img, img], axis=2)\n    else:\n        rgb = img\n    R = rgb[:, :, 0]\n    G = rgb[:, :, 1]\n    B = rgb[:, :, 2]\n    # blue-dominant relative threshold (scale-invariant)\n    blue_mask = (B > 1.1 * R + eps) & (B > 1.1 * G + eps)\n    total = float(rgb.shape[0] * rgb.shape[1]) + eps\n    frac_blue = float(np.count_nonzero(blue_mask)) / total\n    if np.count_nonzero(blue_mask) == 0:\n        return 0.0\n    mean_int_blue = float(np.mean((R[blue_mask] + G[blue_mask] + B[blue_mask]) / 3.0) + eps)\n    mean_int_all = float(np.mean((R + G + B) / 3.0) + eps)\n    # darker blue regions (water) get higher weight: darkness = 1 - relative intensity\n    darkness = max(0.0, 1.0 - (mean_int_blue / (mean_int_all + eps)))\n    result = frac_blue * darkness\n    return float(result)\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Vertical symmetry score based on normalized correlation of left and flipped-right'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if image.ndim == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    left = gray[:, :w//2].astype(float)\n    right = np.fliplr(gray[:, (w+1)//2:]).astype(float) if w//2 > 0 else np.zeros_like(left)\n    # Resize to same shape if needed (simple cropping/padding)\n    min_rows = min(left.shape[0], right.shape[0])\n    min_cols = min(left.shape[1], right.shape[1])\n    if min_rows == 0 or min_cols == 0:\n        return 0.0\n    leftc = left[:min_rows, :min_cols].ravel()\n    rightc = right[:min_rows, :min_cols].ravel()\n    leftc = leftc - np.mean(leftc)\n    rightc = rightc - np.mean(rightc)\n    denom = (np.linalg.norm(leftc) * np.linalg.norm(rightc) + eps)\n    corr = np.dot(leftc, rightc) / denom\n    # return absolute correlation in [0,1]\n    return float(abs(corr))\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Fraction of center pixels with high Laplacian magnitude (center texture spike ratio)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if image.ndim == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    if gray.size == 0:\n        return 0.0\n    pad = np.pad(gray, ((1, 1), (1, 1)), mode='reflect')\n    c = pad[1:-1, 1:-1]\n    up = pad[:-2, 1:-1]\n    down = pad[2:, 1:-1]\n    left = pad[1:-1, :-2]\n    right = pad[1:-1, 2:]\n    lap = (up + down + left + right) - 4.0 * c\n    abs_lap = np.abs(lap)\n    # threshold set to 75th percentile of full-image laplacian\n    thr = float(np.percentile(abs_lap, 75.0)) + eps\n    sr, sc = h // 4, w // 4\n    er, ec = h - sr, w - sc\n    center = abs_lap[sr:er, sc:ec] if (er > sr and ec > sc) else abs_lap\n    if center.size == 0:\n        return 0.0\n    high_count = float(np.count_nonzero(center > thr))\n    result = high_count / float(center.size + eps)\n    return float(result)\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Relative brightness of the top decile pixels (bright-spot contrast)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if image.ndim == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    flat = gray.ravel()\n    if flat.size == 0:\n        return 0.0\n    p90 = float(np.percentile(flat, 90))\n    top_pixels = flat[flat >= p90]\n    if top_pixels.size == 0:\n        return 0.0\n    mean_top = float(np.mean(top_pixels))\n    mean_all = float(np.mean(flat) + eps)\n    result = (mean_top - mean_all) / (mean_all + eps)\n    return float(result)\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Circular hue dispersion using an arctan2 approximation (low = uniform hue, high = varied hues)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    img = image.astype(float)\n    if img.ndim == 2:\n        # grayscale: no hue variation\n        return 0.0\n    R = img[:, :, 0]\n    G = img[:, :, 1]\n    B = img[:, :, 2]\n    # approximate hue formula (Robust RGB->hue approximate)\n    x = (2.0 * R - G - B)\n    y = np.sqrt(3.0) * (G - B)\n    ang = np.arctan2(y, x)  # range [-pi, pi]\n    cos_m = np.mean(np.cos(ang))\n    sin_m = np.mean(np.sin(ang))\n    Rval = np.sqrt(cos_m * cos_m + sin_m * sin_m)\n    # circular dispersion (0 = all same hue, 1 = maximally spread)\n    disp = 1.0 - Rval\n    return float(disp)\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Normalized entropy of gradient orientations (how diverse edge directions are)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if image.ndim == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    if gray.size == 0:\n        return 0.0\n    gy, gx = np.gradient(gray)\n    ang = np.arctan2(gy, gx)  # [-pi, pi]\n    ang_flat = ang.ravel()\n    bins = 16\n    hist, _ = np.histogram(ang_flat, bins=bins, range=(-np.pi, np.pi))\n    probs = hist.astype(float) / (np.sum(hist) + eps)\n    probs_nonzero = probs[probs > 0]\n    if probs_nonzero.size == 0:\n        return 0.0\n    entropy = -np.sum(probs_nonzero * np.log(probs_nonzero + eps))\n    # normalize by log(bins) to get [0,1]\n    norm_entropy = entropy / (np.log(bins) + eps)\n    return float(norm_entropy)\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Ratio of center-region mean gradient magnitude to global mean gradient magnitude'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if image.ndim == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    if gray.size == 0:\n        return 0.0\n    gy, gx = np.gradient(gray)\n    mag = np.sqrt(gy * gy + gx * gx)\n    global_mean = float(np.mean(mag) + eps)\n    sr, sc = h // 4, w // 4\n    er, ec = h - sr, w - sc\n    center = mag[sr:er, sc:ec] if (er > sr and ec > sc) else mag\n    if center.size == 0:\n        return 0.0\n    center_mean = float(np.mean(center))\n    return float(center_mean / (global_mean + eps))\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Concentration of horizontal-edge energy near the mid-height band (horizon-like signature)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    img = image.astype(float)\n    if img.ndim == 3:\n        gray = np.mean(img, axis=2)\n    else:\n        gray = img\n    h = gray.shape[0]\n    if h == 0 or gray.size == 0:\n        return 0.0\n    gy, gx = np.gradient(gray)\n    horiz_per_row = np.sum(np.abs(gx), axis=1)\n    total_horiz = float(np.sum(horiz_per_row) + eps)\n    band_half = max(1, int(round(h * 0.05)))  # 5% above/below center\n    center_row = h // 2\n    r0 = max(0, center_row - band_half)\n    r1 = min(h, center_row + band_half + 1)\n    band_sum = float(np.sum(horiz_per_row[r0:r1]))\n    result = band_sum / total_horiz\n    return float(result)\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Fraction of green-dominant pixels that coincide with edges (green edges concentration)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    img = image.astype(float)\n    if img.ndim == 2:\n        return 0.0\n    R = img[:, :, 0]\n    G = img[:, :, 1]\n    B = img[:, :, 2]\n    intensity = np.mean(img, axis=2)\n    green_mask = (G > R) & (G > B) & (G > intensity * 0.9)\n    if np.count_nonzero(green_mask) == 0:\n        return 0.0\n    gy, gx = np.gradient(intensity)\n    mag = np.sqrt(gy * gy + gx * gx)\n    thr = float(np.median(mag))\n    edge_mask = mag > (thr + eps)\n    intersect = np.count_nonzero(green_mask & edge_mask)\n    result = float(intersect) / float(np.count_nonzero(green_mask) + eps)\n    return float(result)\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Global color warmth estimate: (mean red minus mean blue) normalized by overall intensity'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    img = image.astype(float)\n    if img.ndim == 2:\n        # grayscale has no warmth\n        return 0.0\n    R = np.mean(img[:, :, 0])\n    B = np.mean(img[:, :, 2])\n    mean_int = np.mean(img) + eps\n    warmth = (R - B) / mean_int\n    return float(warmth)\n",
  "def feature(image: np.ndarray) -> float:\n    'Fraction of blue-dominant pixels in the top quarter region (sky/water indicator)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    img = image.astype(float)\n    if img.ndim == 2:\n        rgb = np.stack([img, img, img], axis=2)\n    else:\n        rgb = img\n    h, w = rgb.shape[:2]\n    th = max(1, h // 4)\n    region = rgb[:th, :, :]\n    if region.size == 0:\n        return 0.0\n    R = region[:, :, 0]\n    G = region[:, :, 1]\n    B = region[:, :, 2]\n    intensity = (R + G + B) / 3.0\n    thr = np.percentile(intensity.flatten(), 40) if intensity.size else 0.0\n    mask = (B > G) & (B > R) & (intensity > thr)\n    return float(np.count_nonzero(mask) / float(max(1, mask.size)))\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Shannon entropy of grayscale intensities in the central region (texture measure)'\n    import numpy as np\n    eps = 1e-10\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    arr = image.astype(float)\n    if arr.ndim == 3:\n        gray = np.mean(arr, axis=2)\n    else:\n        gray = arr\n    h, w = gray.shape[:2]\n    sr, sc = h // 4, w // 4\n    er, ec = h - sr, w - sc\n    region = gray[sr:er, sc:ec] if (er > sr and ec > sc) else gray\n    if region.size == 0:\n        return 0.0\n    vals = region.flatten()\n    bins = 32\n    hist, _ = np.histogram(vals, bins=bins, range=(vals.min(), vals.max()), density=True)\n    hist = hist + eps\n    ent = -float(np.sum(hist * np.log(hist)))\n    return float(ent)\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Normalized vertical centroid (0..1) of blue-dominant pixels (where they lie vertically)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.5\n    img = image.astype(float)\n    if img.ndim == 2:\n        rgb = np.stack([img, img, img], axis=2)\n    else:\n        rgb = img\n    h = rgb.shape[0]\n    R = rgb[:, :, 0]\n    G = rgb[:, :, 1]\n    B = rgb[:, :, 2]\n    mask = (B > G) & (B > R)\n    if not np.any(mask):\n        return 0.5\n    rows = np.arange(h)[:, None]\n    mean_row = float(np.sum(rows * mask) / (np.count_nonzero(mask) + eps))\n    return float(mean_row / float(max(1, h - 1)))\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Fraction of low-saturation pixels in the center region (water often desaturated)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    img = image.astype(float)\n    if img.ndim == 2:\n        rgb = np.stack([img, img, img], axis=2)\n    else:\n        rgb = img\n    h, w = rgb.shape[:2]\n    sr, sc = h // 4, w // 4\n    er, ec = h - sr, w - sc\n    region = rgb[sr:er, sc:ec, :] if (er > sr and ec > sc) else rgb\n    if region.size == 0:\n        return 0.0\n    r = region[:, :, 0].flatten()\n    g = region[:, :, 1].flatten()\n    b = region[:, :, 2].flatten()\n    mx = np.maximum(np.maximum(r, g), b)\n    mn = np.minimum(np.minimum(r, g), b)\n    sat = (mx - mn) / (mx + eps)\n    mask = sat < 0.15\n    return float(np.count_nonzero(mask) / float(max(1, sat.size)))\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Fraction of strong edges that are near-horizontal (|angle| < 30deg)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    arr = image.astype(float)\n    if arr.ndim == 3:\n        gray = np.mean(arr, axis=2)\n    else:\n        gray = arr\n    gy, gx = np.gradient(gray)\n    mag = np.sqrt(gx * gx + gy * gy)\n    if mag.size == 0:\n        return 0.0\n    thr = np.percentile(mag, 75)\n    strong = mag > (thr + eps)\n    angles = np.abs(np.arctan2(gy, gx))\n    thresh = np.deg2rad(30.0)\n    horiz = angles < thresh\n    num_strong = np.count_nonzero(strong)\n    if num_strong == 0:\n        return 0.0\n    return float(np.count_nonzero(strong & horiz) / (num_strong + eps))\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Relative difference of vertical blue/band gradients: (B_top-B_bottom)-(G_top-G_bottom) normalized'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    img = image.astype(float)\n    if img.ndim == 2:\n        rgb = np.stack([img, img, img], axis=2)\n    else:\n        rgb = img\n    h = rgb.shape[0]\n    mid = max(1, h // 2)\n    top = rgb[:mid, :, :]\n    bot = rgb[mid:, :, :]\n    if top.size == 0 or bot.size == 0:\n        return 0.0\n    Bt = float(np.mean(top[:, :, 2]))\n    Bb = float(np.mean(bot[:, :, 2]))\n    Gt = float(np.mean(top[:, :, 1]))\n    Gb = float(np.mean(bot[:, :, 1]))\n    numer = (Bt - Bb) - (Gt - Gb)\n    denom = float(np.mean((rgb[:, :, 0] + rgb[:, :, 1] + rgb[:, :, 2]) / 3.0) + eps)\n    return float(numer / denom)\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Maximum horizontal contiguous run ratio of bright blue pixels in any row (wide water regions)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    img = image.astype(float)\n    if img.ndim == 2:\n        rgb = np.stack([img, img, img], axis=2)\n    else:\n        rgb = img\n    h, w = rgb.shape[:2]\n    R = rgb[:, :, 0]\n    G = rgb[:, :, 1]\n    B = rgb[:, :, 2]\n    intensity = (R + G + B) / 3.0\n    thr = np.percentile(intensity.flatten(), 50) if intensity.size else 0.0\n    mask = (B > G) & (B > R) & (intensity > thr)\n    max_run = 0\n    for r in range(h):\n        row = mask[r, :].astype(np.int8)\n        if not np.any(row):\n            continue\n        d = np.diff(np.concatenate(([0], row, [0])))\n        starts = np.where(d == 1)[0]\n        ends = np.where(d == -1)[0]\n        if starts.size and ends.size:\n            runs = ends - starts\n            max_run = max(max_run, int(np.max(runs)))\n    return float(max_run / float(max(1, w)))\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Ratio of mean brightness of center region to mean brightness of image border'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 1.0\n    arr = image.astype(float)\n    if arr.ndim == 3:\n        gray = np.mean(arr, axis=2)\n    else:\n        gray = arr\n    h, w = gray.shape[:2]\n    sr, sc = h // 4, w // 4\n    er, ec = h - sr, w - sc\n    center = gray[sr:er, sc:ec] if (er > sr and ec > sc) else gray\n    t = max(1, min(h, w) // 8)\n    top = gray[:t, :]\n    bottom = gray[-t:, :]\n    left = gray[:, :t]\n    right = gray[:, -t:]\n    border_vals = np.concatenate([top.flatten(), bottom.flatten(), left.flatten(), right.flatten()]) if gray.size else np.array([0.0])\n    mean_center = float(np.mean(center) if center.size else 0.0)\n    mean_border = float(np.mean(border_vals) if border_vals.size else 0.0)\n    return float((mean_center + eps) / (mean_border + eps))\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Simple color-temperature estimate: normalized (R-B)/(R+B) mean (positive = warm, negative = cool)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    img = image.astype(float)\n    if img.ndim == 2:\n        r = g = b = img\n    else:\n        r = img[:, :, 0]\n        g = img[:, :, 1]\n        b = img[:, :, 2]\n    numer = np.mean(r - b)\n    denom = np.mean(r + b) + eps\n    return float(numer / denom)\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Vertical symmetry score of blue channel across midline (1.0 = very symmetric)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    img = image.astype(float)\n    if img.ndim == 2:\n        blue = img\n    else:\n        blue = img[:, :, 2]\n    h = blue.shape[0]\n    mid = h // 2\n    top = blue[:mid, :]\n    bot = blue[mid:mid + top.shape[0], :]\n    if top.size == 0 or bot.size == 0:\n        return 0.0\n    bot_flipped = np.flipud(bot)\n    # crop to same shape if needed\n    min_r = min(top.shape[0], bot_flipped.shape[0])\n    top_crop = top[:min_r, :]\n    bot_crop = bot_flipped[:min_r, :]\n    denom = float(np.mean(np.abs(top_crop)) + np.mean(np.abs(bot_crop)) + eps)\n    diff = float(np.mean(np.abs(top_crop - bot_crop)))\n    score = 1.0 - (diff / denom)\n    # clamp 0..1\n    score = max(0.0, min(1.0, score))\n    return float(score)\n",
  "def feature(image: np.ndarray) -> float:\n    'Fraction of lower-half pixels that are green-dominant (vegetation indicator)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    img = image.astype(float)\n    h = img.shape[0]\n    mid = h // 2\n    if img.ndim == 2:\n        r = g = b = img\n    else:\n        r = img[:, :, 0]\n        g = img[:, :, 1]\n        b = img[:, :, 2]\n    lower_r = r[mid:, :]\n    lower_g = g[mid:, :]\n    lower_b = b[mid:, :]\n    if lower_g.size == 0:\n        return 0.0\n    mask = (lower_g > lower_r) & (lower_g > lower_b) & (lower_g > (np.mean(lower_g) + eps))\n    return float(np.count_nonzero(mask) / (lower_g.size + eps))\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Mean local patch standard deviation (texture coarseness)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if image.ndim == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    # choose patch size relative to image\n    p = max(4, min(h, w) // 16)\n    if p <= 0:\n        return 0.0\n    nh = (h // p)\n    nw = (w // p)\n    if nh == 0 or nw == 0:\n        # fallback to whole-image std\n        return float(np.std(gray))\n    h_crop = nh * p\n    w_crop = nw * p\n    g = gray[:h_crop, :w_crop]\n    # reshape to blocks (nh, p, nw, p)\n    try:\n        blocks = g.reshape(nh, p, nw, p)\n        # move axes to (nh, nw, p, p)\n        blocks = blocks.transpose(0, 2, 1, 3)\n        # compute std per block\n        stds = np.std(blocks, axis=(2, 3))\n        return float(np.mean(stds))\n    except Exception:\n        return float(np.std(gray))\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Edge density: fraction of pixels with strong gradient magnitude'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if image.ndim == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    if gray.size == 0:\n        return 0.0\n    gy, gx = np.gradient(gray)\n    mag = np.sqrt(gx * gx + gy * gy)\n    thresh = np.mean(mag) + np.std(mag)\n    mask = mag > (thresh + eps)\n    return float(np.count_nonzero(mask) / (gray.size + eps))\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Fraction of strong edges that are predominantly horizontal'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if image.ndim == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    if gray.size == 0:\n        return 0.0\n    gy, gx = np.gradient(gray)\n    mag = np.sqrt(gx * gx + gy * gy)\n    strong = mag > (np.mean(mag) + 0.5 * np.std(mag) + eps)\n    if np.count_nonzero(strong) == 0:\n        return 0.0\n    horiz_mask = (np.abs(gx) > 1.2 * np.abs(gy)) & strong\n    return float(np.count_nonzero(horiz_mask) / (np.count_nonzero(strong) + eps))\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Fraction of near-white pixels (specular highlights / bright reflections)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    img = image.astype(float)\n    if img.ndim == 2:\n        # grayscale: treat as all channels equal\n        r = g = b = img\n    else:\n        r = img[:, :, 0]\n        g = img[:, :, 1]\n        b = img[:, :, 2]\n    mx = max(1.0, np.max(img))\n    thr = 0.9 * mx\n    mask = (r >= thr) & (g >= thr) & (b >= thr)\n    return float(np.count_nonzero(mask) / (r.size + eps))\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Ratio of mean green to mean blue in the lower third of the image'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    img = image.astype(float)\n    h = img.shape[0]\n    start = (2 * h) // 3\n    if img.ndim == 2:\n        r = g = b = img\n    else:\n        r = img[:, :, 0]\n        g = img[:, :, 1]\n        b = img[:, :, 2]\n    lower_r = r[start:, :]\n    lower_g = g[start:, :]\n    lower_b = b[start:, :]\n    if lower_g.size == 0:\n        return 0.0\n    mean_g = float(np.mean(lower_g))\n    mean_b = float(np.mean(lower_b))\n    return float(mean_g / (mean_b + eps))\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Fraction of top-quarter pixels that are blue-dominant and relatively bright (sky indicator)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    img = image.astype(float)\n    h = img.shape[0]\n    top_h = max(1, h // 4)\n    region = img[:top_h, :, :] if img.ndim == 3 else img[:top_h, :]\n    if region.size == 0:\n        return 0.0\n    if region.ndim == 2:\n        r = g = b = region\n    else:\n        r = region[:, :, 0]\n        g = region[:, :, 1]\n        b = region[:, :, 2]\n    meanB = np.mean(b)\n    mask = (b > r * 1.05) & (b > g * 1.05) & (b > meanB)\n    return float(np.count_nonzero(mask) / (r.size + eps))\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Normalized grayscale entropy (0..1) using 16 bins'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if image.ndim == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    flat = gray.flatten()\n    if flat.size == 0:\n        return 0.0\n    bins = 16\n    hist, _ = np.histogram(flat, bins=bins, density=False)\n    p = hist.astype(float) / (np.sum(hist) + eps)\n    # avoid log(0)\n    p_nonzero = p[p > 0]\n    entropy = -np.sum(p_nonzero * np.log(p_nonzero + eps))\n    # normalize by log(bins)\n    norm = entropy / (np.log(bins) + eps)\n    return float(norm)\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Saturation of the most frequent coarse color bucket (dominant-color saturation)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    img = image.astype(float)\n    if img.ndim == 2:\n        rgb = np.stack([img, img, img], axis=2)\n    else:\n        rgb = img\n    h, w = rgb.shape[:2]\n    total = h * w\n    if total == 0:\n        return 0.0\n    # quantize each channel into 4 levels\n    mx = max(1.0, np.max(rgb))\n    levels = 4\n    q = np.floor((rgb / mx) * (levels - 1 + eps)).astype(int)\n    q = np.clip(q, 0, levels - 1)\n    idx = q[:, :, 0] * (levels * levels) + q[:, :, 1] * levels + q[:, :, 2]\n    idx_flat = idx.flatten()\n    # find most frequent bucket\n    vals, counts = np.unique(idx_flat, return_counts=True)\n    if counts.size == 0:\n        return 0.0\n    dominant = vals[np.argmax(counts)]\n    mask = (idx == dominant)\n    if np.count_nonzero(mask) == 0:\n        return 0.0\n    sel = rgb[mask]\n    r = sel[:, 0]\n    g = sel[:, 1]\n    b = sel[:, 2]\n    mxs = np.maximum(np.maximum(r, g), b)\n    mns = np.minimum(np.minimum(r, g), b)\n    sat = (mxs - mns) / (mxs + eps)\n    return float(np.mean(sat))\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Low-frequency energy ratio using block-wise mean approximation (1.0 = all low-frequency)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if image.ndim == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    # choose block size relative to image\n    b = max(4, min(h, w) // 16)\n    if b <= 0:\n        return 0.0\n    nh = h // b\n    nw = w // b\n    if nh == 0 or nw == 0:\n        # fallback: single block (all low-frequency)\n        return 1.0\n    h_crop = nh * b\n    w_crop = nw * b\n    g = gray[:h_crop, :w_crop]\n    try:\n        blocks = g.reshape(nh, b, nw, b).transpose(0, 2, 1, 3)\n        block_mean = blocks.mean(axis=(2, 3))\n        # expand block_mean back to pixel grid\n        approx = np.repeat(np.repeat(block_mean, b, axis=0), b, axis=1)\n        high_energy = np.mean(np.abs(g - approx))\n        low_energy = np.mean(np.abs(approx))\n        ratio = low_energy / (low_energy + high_energy + eps)\n        return float(ratio)\n    except Exception:\n        return 0.0\n",
  "def feature(image: np.ndarray) -> float:\n    'Ratio of mean gradient magnitude in the lower half to the whole image (lower_half_smoothness_ratio)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    # get grayscale\n    if image.ndim == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    gy, gx = np.gradient(gray)\n    mag = np.sqrt(gx * gx + gy * gy)\n    whole_mean = float(np.mean(mag) + eps)\n    lower = mag[h//2:, :] if h//2 < h else mag\n    lower_mean = float(np.mean(lower) + eps)\n    return float(lower_mean / whole_mean)\n\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Normalized difference of mean (B-G) between top third and bottom third'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    img = image.astype(float)\n    h = img.shape[0]\n    top_h = max(1, h // 3)\n    bot_h = max(1, h // 3)\n    if img.ndim == 2:\n        # grayscale -> no color difference\n        return 0.0\n    top = img[:top_h, :, :]\n    bottom = img[h - bot_h:, :, :]\n    if top.size == 0 or bottom.size == 0:\n        return 0.0\n    mean_top = float(np.mean(top[:, :, 2] - top[:, :, 1]))\n    mean_bottom = float(np.mean(bottom[:, :, 2] - bottom[:, :, 1]))\n    denom = (abs(mean_top) + abs(mean_bottom) + eps)\n    return float((mean_top - mean_bottom) / denom)\n\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Fraction of small blocks that are low-variance in color (uniform area fraction)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    img = image.astype(float)\n    h, w = img.shape[:2]\n    # ensure RGB for color variance\n    if img.ndim == 2:\n        rgb = np.stack([img, img, img], axis=2)\n    else:\n        rgb = img\n    # choose block size adaptive but not too small\n    bh = max(8, h // 16)\n    bw = max(8, w // 16)\n    nh = max(1, h // bh)\n    nw = max(1, w // bw)\n    count_uniform = 0\n    total = 0\n    # threshold as small fraction of dynamic range\n    global_std = float(np.std(rgb) + eps)\n    thr = max(5.0, global_std * 0.3)\n    for i in range(nh):\n        r0 = i * bh\n        r1 = h if i == nh - 1 else (i + 1) * bh\n        for j in range(nw):\n            c0 = j * bw\n            c1 = w if j == nw - 1 else (j + 1) * bw\n            block = rgb[r0:r1, c0:c1, :]\n            if block.size == 0:\n                continue\n            # color std across channels and pixels\n            blk_std = float(np.std(block))\n            total += 1\n            if blk_std <= thr:\n                count_uniform += 1\n    if total == 0:\n        return 0.0\n    return float(count_uniform / (total + eps))\n\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Center-region brownness score (R > G with low saturation and moderate intensity)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    img = image.astype(float)\n    h, w = img.shape[:2]\n    sr, sc = h // 4, w // 4\n    er, ec = h - sr, w - sc\n    if img.ndim == 2:\n        rgb = np.stack([img, img, img], axis=2)\n    else:\n        rgb = img\n    region = rgb[sr:er, sc:ec, :] if (er > sr and ec > sc) else rgb\n    if region.size == 0:\n        return 0.0\n    r = region[:, :, 0]\n    g = region[:, :, 1]\n    b = region[:, :, 2]\n    mx = np.maximum(np.maximum(r, g), b)\n    mn = np.minimum(np.minimum(r, g), b)\n    sat = (mx - mn) / (mx + eps)\n    intensity = np.mean(region, axis=2)\n    # brown criteria: R somewhat greater than G, low-to-moderate saturation, and not too dark\n    mask = (r > g + 5.0) & (sat < 0.45) & (intensity > np.percentile(intensity.flatten(), 20))\n    if np.count_nonzero(mask) == 0:\n        return 0.0\n    # score proportional to (R-G) normalized by intensity\n    score = np.mean(((r - g)[mask] / (intensity[mask] + eps)))\n    return float(score)\n\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Horizon edge prominence: strongest horizontal edge row energy relative to median row energy'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if image.ndim == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    gy, gx = np.gradient(gray)\n    row_energy = np.sum(np.sqrt(gy * gy + gx * gx), axis=1)  # energy per row\n    max_row = float(np.max(row_energy))\n    med = float(np.median(row_energy) + eps)\n    return float((max_row - med) / (med + eps))\n\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Red-minus-blue balance among the top 1% brightest pixels (highlights color cast)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    img = image.astype(float)\n    if img.ndim == 2:\n        rgb = np.stack([img, img, img], axis=2)\n    else:\n        rgb = img\n    bright = np.mean(rgb, axis=2).flatten()\n    if bright.size == 0:\n        return 0.0\n    thr = np.percentile(bright, 99)\n    mask = bright >= thr\n    if np.count_nonzero(mask) == 0:\n        return 0.0\n    flat = rgb.reshape(-1, 3)\n    sel = flat[mask, :]\n    meanR = float(np.mean(sel[:, 0]) + eps)\n    meanB = float(np.mean(sel[:, 2]) + eps)\n    return float((meanR - meanB) / (meanR + meanB + eps))\n\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Variance of per-patch grayscale contrast (std of 8x8 patch stds) as a texture diversity measure'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if image.ndim == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    ph, pw = 8, 8\n    nh = max(1, h // ph)\n    nw = max(1, w // pw)\n    stds = []\n    for i in range(nh):\n        r0 = i * ph\n        r1 = h if i == nh - 1 else (i + 1) * ph\n        for j in range(nw):\n            c0 = j * pw\n            c1 = w if j == nw - 1 else (j + 1) * pw\n            patch = gray[r0:r1, c0:c1]\n            if patch.size == 0:\n                continue\n            stds.append(float(np.std(patch)))\n    if len(stds) == 0:\n        return 0.0\n    return float(np.var(stds) / (np.mean(stds) + eps))\n\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Fraction of image columns where mean blue exceeds other channels by a margin (horizontal blue coverage)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    img = image.astype(float)\n    h, w = img.shape[:2]\n    if img.ndim == 2:\n        return 0.0\n    R = np.mean(img[:, :, 0], axis=0)\n    G = np.mean(img[:, :, 1], axis=0)\n    B = np.mean(img[:, :, 2], axis=0)\n    # margin adaptive to global std\n    margin = max(8.0, np.std(img) * 0.2)\n    mask = (B > R + margin) & (B > G + margin)\n    return float(np.count_nonzero(mask) / float(max(1, w)))\n\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Center vs border gradient-energy ratio (center compactness proxy)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if image.ndim == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    if h < 3 or w < 3:\n        return 0.0\n    # define center box and a surrounding border band (10% of dims or at least 2 px)\n    br = max(2, h // 10)\n    bc = max(2, w // 10)\n    sr, sc = br, bc\n    er, ec = h - br, w - bc\n    center = gray[sr:er, sc:ec] if (er > sr and ec > sc) else gray\n    # border is the full image minus center\n    gy, gx = np.gradient(gray)\n    energy = np.sqrt(gy * gy + gx * gx)\n    center_energy = np.sum(energy[sr:er, sc:ec]) if (er > sr and ec > sc) else np.sum(energy)\n    border_energy = np.sum(energy) - center_energy\n    return float(center_energy / (border_energy + eps))\n",
  "def feature(image: np.ndarray) -> float:\n    'Ratio of horizontal to vertical gradient energy in the center region (texture anisotropy)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    # convert to grayscale\n    if image.ndim == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    sr, sc = h // 4, w // 4\n    er, ec = h - sr, w - sc\n    region = gray[sr:er, sc:ec] if (er > sr and ec > sc) else gray\n    if region.size == 0:\n        return 0.0\n    gy, gx = np.gradient(region)\n    horiz_energy = np.mean(np.abs(gx))\n    vert_energy = np.mean(np.abs(gy))\n    return float((horiz_energy + eps) / (vert_energy + eps))\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Horizontal band score: variance of row means normalized by overall intensity variance'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    # use luminance proxy\n    if image.ndim == 3:\n        lum = np.mean(image.astype(float), axis=2)\n    else:\n        lum = image.astype(float)\n    row_means = np.mean(lum, axis=1)\n    var_row_means = np.var(row_means)\n    var_global = np.var(lum) + eps\n    return float(var_row_means / var_global)\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Difference between bottom-half mean blue and top-half mean blue normalized by intensity'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if image.ndim == 2:\n        # grayscale: no blue information\n        return 0.0\n    arr = image.astype(float)\n    h = arr.shape[0]\n    mid = h // 2\n    topB = np.mean(arr[:max(1, mid), :, 2]) if arr.size else 0.0\n    botB = np.mean(arr[mid:, :, 2]) if arr.size else 0.0\n    mean_intensity = np.mean(np.mean(arr, axis=2)) + eps\n    return float((botB - topB) / mean_intensity)\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Mean block-wise variance in the central region (coarse texture measure)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if image.ndim == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    sr, sc = h // 4, w // 4\n    er, ec = h - sr, w - sc\n    region = gray[sr:er, sc:ec] if (er > sr and ec > sc) else gray\n    if region.size == 0:\n        return 0.0\n    # block size scaled to image size\n    b = max(4, min(region.shape[:2]) // 20)\n    bh, bw = b, b\n    variances = []\n    for i in range(0, region.shape[0], bh):\n        for j in range(0, region.shape[1], bw):\n            patch = region[i:i+bh, j:j+bw]\n            if patch.size:\n                variances.append(np.var(patch))\n    if len(variances) == 0:\n        return 0.0\n    return float(np.mean(variances) / (np.var(region) + eps))\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Fraction of very bright specular-like pixels (high intensity highlights)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    img = image.astype(float)\n    if img.ndim == 3:\n        inten = np.mean(img, axis=2)\n    else:\n        inten = img\n    # threshold by 99.5th percentile and absolute high value\n    p99 = np.percentile(inten, 99.5)\n    thr = max(p99, np.max(inten) - 1.0, np.mean(inten) + 2.0 * np.std(inten))\n    mask = inten >= thr\n    return float(np.count_nonzero(mask) / float(inten.size + eps))\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Center dark patch contrast: how dark the darkest patch is relative to global mean'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if image.ndim == 3:\n        lum = np.mean(image.astype(float), axis=2)\n    else:\n        lum = image.astype(float)\n    h, w = lum.shape[:2]\n    # examine a grid of patches across image to find darkest patch (bird candidate)\n    grid_r = min(6, max(2, h // 50 + 2))\n    grid_c = min(6, max(2, w // 50 + 2))\n    pr = max(1, h // grid_r)\n    pc = max(1, w // grid_c)\n    patch_means = []\n    for i in range(0, h, pr):\n        for j in range(0, w, pc):\n            patch = lum[i:i+pr, j:j+pc]\n            if patch.size:\n                patch_means.append(np.mean(patch))\n    if len(patch_means) == 0:\n        return 0.0\n    min_patch = float(np.min(patch_means))\n    global_mean = float(np.mean(lum)) + eps\n    # larger positive value means darker patch relative to background\n    return float((global_mean - min_patch) / global_mean)\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Standard deviation of blue chromaticity (B / (R+G+B)) across the image'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if image.ndim == 2:\n        return 0.0\n    arr = image.astype(float)\n    R = arr[:, :, 0].flatten()\n    G = arr[:, :, 1].flatten()\n    B = arr[:, :, 2].flatten()\n    total = R + G + B + eps\n    chroma_b = B / total\n    return float(np.std(chroma_b))\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Ratio of mean green in lower half to upper half (vegetation concentration)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if image.ndim == 2:\n        # grayscale has no green channel\n        return 0.0\n    arr = image.astype(float)\n    h = arr.shape[0]\n    mid = h // 2\n    topG = np.mean(arr[:max(1, mid), :, 1]) if arr.size else 0.0\n    botG = np.mean(arr[mid:, :, 1]) if arr.size else 0.0\n    return float((botG + eps) / (topG + eps))\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Edge orientation bias: mean normalized difference between horizontal and vertical edge strengths'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if image.ndim == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    gy, gx = np.gradient(gray)\n    mag = np.sqrt(gx * gx + gy * gy) + eps\n    horiz_frac = np.abs(gx) / mag\n    vert_frac = np.abs(gy) / mag\n    # positive values indicate horizontal-gradient dominance, negative indicate vertical\n    bias = np.mean(horiz_frac - vert_frac)\n    return float(bias)\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Color temperature proxy: normalized mean (R - B) relative to overall intensity (warm vs cool)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if image.ndim == 2:\n        # grayscale: R-B is zero\n        return 0.0\n    arr = image.astype(float)\n    R = arr[:, :, 0]\n    B = arr[:, :, 2]\n    mean_diff = np.mean(R - B)\n    mean_int = np.mean(np.mean(arr, axis=2)) + eps\n    return float(mean_diff / mean_int)\n",
  "def feature(image: np.ndarray) -> float:\n    'Fraction of pixels in the lower half that are blue-dominant (water-bottom signal)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    img = image.astype(float)\n    if img.ndim == 2:\n        rgb = np.stack([img, img, img], axis=2)\n    else:\n        rgb = img\n    h, w = rgb.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    lower = rgb[h // 2:, :, :].reshape(-1, 3)\n    if lower.size == 0:\n        return 0.0\n    R = lower[:, 0]\n    G = lower[:, 1]\n    B = lower[:, 2]\n    mask = (B > 1.15 * R) & (B > 1.15 * G)\n    return float(np.count_nonzero(mask) / (mask.size + eps))\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Fraction of strong edges that are horizontally oriented (abs(gx) > 1.5*abs(gy))'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    img = image.astype(float)\n    if img.ndim == 3:\n        gray = np.mean(img, axis=2)\n    else:\n        gray = img\n    if gray.size == 0:\n        return 0.0\n    gy, gx = np.gradient(gray)\n    mag = np.sqrt(gx * gx + gy * gy)\n    thr = float(np.percentile(mag.flatten(), 70)) if mag.size else 0.0\n    strong = mag > (thr + eps)\n    horiz = (np.abs(gx) > 1.5 * (np.abs(gy) + eps)) & strong\n    total_strong = float(np.count_nonzero(strong)) + eps\n    return float(np.count_nonzero(horiz) / total_strong)\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Uniformity of blue channel across horizontal bands (1/(std+eps) larger => more uniform)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    img = image.astype(float)\n    if img.ndim == 2:\n        bchan = img\n    else:\n        bchan = img[:, :, 2]\n    h, w = bchan.shape[:2]\n    if h == 0:\n        return 0.0\n    bands = 8\n    band_h = max(1, h // bands)\n    means = []\n    for i in range(0, h, band_h):\n        band = bchan[i:min(i + band_h, h), :]\n        if band.size:\n            means.append(np.mean(band))\n    if len(means) == 0:\n        return 0.0\n    means = np.array(means)\n    std = float(np.std(means))\n    return float(1.0 / (std + eps))\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Fraction of red-dominant pixels in the upper half (bird/flower/field cues)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    img = image.astype(float)\n    if img.ndim == 2:\n        rgb = np.stack([img, img, img], axis=2)\n    else:\n        rgb = img\n    h, w = rgb.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    upper = rgb[:max(1, h // 2), :, :].reshape(-1, 3)\n    if upper.size == 0:\n        return 0.0\n    R = upper[:, 0]\n    G = upper[:, 1]\n    B = upper[:, 2]\n    mask = (R > 1.2 * G) & (R > 1.2 * B)\n    return float(np.count_nonzero(mask) / (mask.size + eps))\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Normalized contrast between center mean intensity and border mean intensity'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    img = image.astype(float)\n    if img.ndim == 3:\n        gray = np.mean(img, axis=2)\n    else:\n        gray = img\n    h, w = gray.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    sr, sc = h // 4, w // 4\n    er, ec = h - sr, w - sc\n    center = gray[sr:er, sc:ec] if (er > sr and ec > sc) else gray\n    t = max(1, min(h, w) // 10)\n    top = gray[:t, :]\n    bottom = gray[-t:, :]\n    left = gray[:, :t]\n    right = gray[:, -t:]\n    border = np.concatenate([top.reshape(-1), bottom.reshape(-1), left.reshape(-1), right.reshape(-1)]) if gray.size else np.array([])\n    if center.size == 0 or border.size == 0:\n        return 0.0\n    center_mean = float(np.mean(center))\n    border_mean = float(np.mean(border))\n    return float((center_mean - border_mean) / (abs(border_mean) + eps))\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Average row-wise autocorrelation at lag 4 (horizontal periodicity indicator)'\n    import numpy as np\n    eps = 1e-8\n    lag = 4\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    img = image.astype(float)\n    if img.ndim == 3:\n        gray = np.mean(img, axis=2)\n    else:\n        gray = img\n    h, w = gray.shape[:2]\n    if h == 0 or w <= lag:\n        return 0.0\n    acs = []\n    for r in range(h):\n        row = gray[r, :]\n        a = row[:-lag]\n        b = row[lag:]\n        if a.size == 0 or b.size == 0:\n            continue\n        num = float(np.sum((a - a.mean()) * (b - b.mean())))\n        den = (np.sqrt(np.sum((a - a.mean())**2)) * np.sqrt(np.sum((b - b.mean())**2)) + eps)\n        acs.append(num / den)\n    if len(acs) == 0:\n        return 0.0\n    return float(np.mean(acs))\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Fraction of dark pixels in the center region (possible silhouetted subjects)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    img = image.astype(float)\n    if img.ndim == 3:\n        gray = np.mean(img, axis=2)\n    else:\n        gray = img\n    if gray.size == 0:\n        return 0.0\n    thr = float(np.percentile(gray.flatten(), 25))\n    h, w = gray.shape[:2]\n    sr, sc = h // 4, w // 4\n    er, ec = h - sr, w - sc\n    center = gray[sr:er, sc:ec] if (er > sr and ec > sc) else gray\n    if center.size == 0:\n        return 0.0\n    mask = center < thr\n    return float(np.count_nonzero(mask) / (mask.size + eps))\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Difference of mean(B-G) between upper and lower halves normalized by overall intensity'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    img = image.astype(float)\n    if img.ndim == 2:\n        rgb = np.stack([img, img, img], axis=2)\n    else:\n        rgb = img\n    h, w = rgb.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    upper = rgb[:h//2, :, :].reshape(-1, 3)\n    lower = rgb[h//2:, :, :].reshape(-1, 3)\n    if upper.size == 0 or lower.size == 0:\n        return 0.0\n    bu = upper[:, 2]; gu = upper[:, 1]\n    bl = lower[:, 2]; gl = lower[:, 1]\n    diff = float(np.mean(bu - gu) - np.mean(bl - gl))\n    mean_int = float(np.mean(rgb.reshape(-1,3).mean(axis=1)) + eps)\n    return float(diff / mean_int)\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Saturation-weighted center brightness (higher when colorful+bright subjects are central)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    img = image.astype(float)\n    if img.ndim == 2:\n        rgb = np.stack([img, img, img], axis=2)\n    else:\n        rgb = img\n    h, w = rgb.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    sr, sc = h // 4, w // 4\n    er, ec = h - sr, w - sc\n    region = rgb[sr:er, sc:ec, :] if (er > sr and ec > sc) else rgb\n    if region.size == 0:\n        return 0.0\n    r = region[:, :, 0].reshape(-1)\n    g = region[:, :, 1].reshape(-1)\n    b = region[:, :, 2].reshape(-1)\n    mx = np.maximum(np.maximum(r, g), b)\n    mn = np.minimum(np.minimum(r, g), b)\n    sat = (mx - mn) / (mx + eps)\n    bright = (r + g + b) / 3.0\n    return float(np.mean(sat * bright) / (np.mean(bright) + eps))\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Absolute deviation of image aspect ratio from square (|w/h - 1|)'\n    import numpy as np\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0:\n        return 0.0\n    return float(abs(float(w) / float(h) - 1.0))\n",
  "def feature(image: np.ndarray) -> float:\n    'Normalized difference of mean blue between top and bottom halves (positive if top is bluer)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    img = image.astype(float)\n    if img.ndim == 2:\n        img = np.stack([img, img, img], axis=2)\n    h, w = img.shape[:2]\n    mid = h // 2\n    top = img[:mid, :, 2] if mid > 0 else img[:, :, 2]\n    bottom = img[mid:, :, 2] if mid > 0 else img[:, :, 2]\n    mean_top = float(np.mean(top)) if top.size else 0.0\n    mean_bottom = float(np.mean(bottom)) if bottom.size else 0.0\n    global_mean = float(np.mean(img) + eps)\n    return float((mean_top - mean_bottom) / global_mean)\n\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Inverse of gradient std in the bottom third (higher means smoother bottom -> likely water)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    img = image.astype(float)\n    if img.ndim == 3:\n        gray = np.mean(img, axis=2)\n    else:\n        gray = img\n    h, w = gray.shape[:2]\n    start = (2 * h) // 3\n    region = gray[start:h, :] if start < h else gray\n    if region.size == 0:\n        return 0.0\n    gy, gx = np.gradient(region)\n    mag = np.sqrt(gx * gx + gy * gy)\n    std_mag = float(np.std(mag))\n    # smoother bottom -> larger feature; scale with inverse\n    return float(1.0 / (std_mag + eps))\n\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Ratio of mean chroma (max-min) in the center region to the border ring (colorful subject vs background)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    img = image.astype(float)\n    if img.ndim == 2:\n        rgb = np.stack([img, img, img], axis=2)\n    else:\n        rgb = img\n    h, w = rgb.shape[:2]\n    sr, sc = h // 4, w // 4\n    er, ec = h - sr, w - sc\n    center = rgb[sr:er, sc:ec, :] if (er > sr and ec > sc) else rgb\n    # border ring: outer 10% band (top, bottom, left, right) excluding center\n    band = max(1, int(min(h, w) * 0.1))\n    top_band = rgb[:band, :, :]\n    bottom_band = rgb[h-band:, :, :]\n    left_band = rgb[:, :band, :]\n    right_band = rgb[:, w-band:, :]\n    border = np.concatenate([top_band.reshape(-1,3),\n                             bottom_band.reshape(-1,3),\n                             left_band.reshape(-1,3),\n                             right_band.reshape(-1,3)], axis=0)\n    if center.size == 0 or border.size == 0:\n        return 0.0\n    c_r, c_g, c_b = center[:,:,0].flatten(), center[:,:,1].flatten(), center[:,:,2].flatten()\n    b_r, b_g, b_b = border[:,0], border[:,1], border[:,2]\n    c_mx = np.maximum(np.maximum(c_r, c_g), c_b)\n    c_mn = np.minimum(np.minimum(c_r, c_g), c_b)\n    b_mx = np.maximum(np.maximum(b_r, b_g), b_b)\n    b_mn = np.minimum(np.minimum(b_r, b_g), b_b)\n    mean_center_chroma = float(np.mean(c_mx - c_mn) + eps)\n    mean_border_chroma = float(np.mean(b_mx - b_mn) + eps)\n    return float(mean_center_chroma / mean_border_chroma)\n\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Global warmth estimate: mean(R+G) divided by mean(B) (higher => warmer colors)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    img = image.astype(float)\n    if img.ndim == 2:\n        r = g = b = img.flatten()\n    else:\n        r = img[:, :, 0].flatten()\n        g = img[:, :, 1].flatten()\n        b = img[:, :, 2].flatten()\n    mean_rg = float(np.mean(r + g) + eps)\n    mean_b = float(np.mean(b) + eps)\n    return float(mean_rg / mean_b)\n\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Absolute normalized contrast between center mean intensity and border mean intensity'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    img = image.astype(float)\n    if img.ndim == 3:\n        gray = np.mean(img, axis=2)\n    else:\n        gray = img\n    h, w = gray.shape[:2]\n    sr, sc = h // 4, w // 4\n    er, ec = h - sr, w - sc\n    center = gray[sr:er, sc:ec] if (er > sr and ec > sc) else gray\n    # border as outer frame (10% width)\n    band = max(1, int(min(h, w) * 0.1))\n    top = gray[:band, :] if band < h else gray\n    bottom = gray[h-band:, :] if band < h else gray\n    left = gray[:, :band] if band < w else gray\n    right = gray[:, w-band:] if band < w else gray\n    border_concat = np.concatenate([top.flatten(), bottom.flatten(), left.flatten(), right.flatten()]) if gray.size else np.array([])\n    if center.size == 0 or border_concat.size == 0:\n        return 0.0\n    m_center = float(np.mean(center))\n    m_border = float(np.mean(border_concat))\n    global_mean = float(np.mean(gray) + eps)\n    return float(abs(m_center - m_border) / global_mean)\n\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Fractional height of the longest contiguous bright horizontal band (relative to image height)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    img = image.astype(float)\n    if img.ndim == 3:\n        lum = np.mean(img, axis=2)\n    else:\n        lum = img\n    h, w = lum.shape[:2]\n    if h == 0:\n        return 0.0\n    row_means = np.mean(lum, axis=1)\n    thr = np.percentile(row_means, 85)\n    mask = row_means >= thr\n    # find longest run of True in mask\n    if not np.any(mask):\n        return 0.0\n    # compute lengths\n    diff = np.diff(np.concatenate([[0], mask.astype(int), [0]]))\n    starts = np.where(diff == 1)[0]\n    ends = np.where(diff == -1)[0]\n    if starts.size == 0:\n        return 0.0\n    lengths = ends - starts\n    max_len = int(np.max(lengths))\n    return float(max_len / (h + eps))\n\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Left-right mirror symmetry concentration (1.0 -> perfect symmetry)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    img = image.astype(float)\n    if img.ndim == 2:\n        img = np.stack([img, img, img], axis=2)\n    h, w = img.shape[:2]\n    mid = w // 2\n    left = img[:, :mid, :]\n    if mid == 0:\n        return 0.0\n    # make right the same width as left (drop center column if odd)\n    right = img[:, w-mid:, :]\n    # mirror right horizontally\n    right_mirror = right[:, ::-1, :]\n    # ensure same shape\n    if left.shape != right_mirror.shape:\n        min_w = min(left.shape[1], right_mirror.shape[1])\n        left = left[:, :min_w, :]\n        right_mirror = right_mirror[:, :min_w, :]\n    diff = np.abs(left - right_mirror)\n    mean_diff = float(np.mean(diff))\n    mean_intensity = float(np.mean(img) + eps)\n    score = 1.0 - (mean_diff / mean_intensity)\n    # clamp to [0,1]\n    return float(max(0.0, min(1.0, score)))\n\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Fraction of bottom half pixels that are blue-dominant and low-saturation (water patch indicator)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    img = image.astype(float)\n    if img.ndim == 2:\n        rgb = np.stack([img, img, img], axis=2)\n    else:\n        rgb = img\n    h, w = rgb.shape[:2]\n    bottom = rgb[h//2:, :, :] if h//2 < h else rgb\n    if bottom.size == 0:\n        return 0.0\n    r = bottom[:, :, 0].flatten()\n    g = bottom[:, :, 1].flatten()\n    b = bottom[:, :, 2].flatten()\n    mx = np.maximum(np.maximum(r, g), b)\n    mn = np.minimum(np.minimum(r, g), b)\n    sat = (mx - mn) / (mx + eps)\n    blue_dom = (b > r) & (b > g)\n    low_sat = sat < 0.18\n    mask = blue_dom & low_sat\n    return float(np.count_nonzero(mask) / float(max(1, r.size)))\n\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Center-to-global high-frequency energy ratio (mean gradient mag in center / global)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    img = image.astype(float)\n    if img.ndim == 3:\n        gray = np.mean(img, axis=2)\n    else:\n        gray = img\n    h, w = gray.shape[:2]\n    sr, sc = h // 4, w // 4\n    er, ec = h - sr, w - sc\n    center = gray[sr:er, sc:ec] if (er > sr and ec > sc) else gray\n    gy_all, gx_all = np.gradient(gray)\n    mag_all = np.sqrt(gx_all * gx_all + gy_all * gy_all)\n    gy_c, gx_c = np.gradient(center)\n    mag_c = np.sqrt(gx_c * gx_c + gy_c * gy_c) if center.size else np.array([0.0])\n    mean_all = float(np.mean(mag_all) + eps)\n    mean_c = float(np.mean(mag_c) + eps)\n    return float(mean_c / mean_all)\n\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Concentration of chromaticity angles (higher -> consistent dominant hue across image)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    img = image.astype(float)\n    if img.ndim == 2:\n        r = g = b = img.flatten()\n    else:\n        r = img[:, :, 0].flatten()\n        g = img[:, :, 1].flatten()\n        b = img[:, :, 2].flatten()\n    total = (r + g + b) + eps\n    rn = r / total\n    gn = g / total\n    # center chromaticity at (1/3,1/3)\n    xr = rn - (1.0/3.0)\n    yg = gn - (1.0/3.0)\n    angles = np.arctan2(yg, xr)\n    cos_mean = float(np.mean(np.cos(angles)))\n    sin_mean = float(np.mean(np.sin(angles)))\n    concentration = float(np.sqrt(cos_mean * cos_mean + sin_mean * sin_mean))\n    # concentration in [0,1]\n    return float(max(0.0, min(1.0, concentration)))\n",
  "def feature(image: np.ndarray) -> float:\n    'Fraction of pixels in the bottom half that are green-dominant (vegetation indicator)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    img = image.astype(float)\n    if img.ndim == 2:\n        rgb = np.stack([img, img, img], axis=2)\n    else:\n        rgb = img\n    h, w = rgb.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    lower = rgb[h//2:h, :, :]\n    if lower.size == 0:\n        return 0.0\n    r = lower[:, :, 0].flatten()\n    g = lower[:, :, 1].flatten()\n    b = lower[:, :, 2].flatten()\n    mx = np.maximum(np.maximum(r, g), b) + eps\n    green_dom = (g == mx) & ((g - np.maximum(r, b)) > (0.05 * mx))\n    return float(np.count_nonzero(green_dom) / (r.size + eps))\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Mean normalized red-minus-blue (warmth) across image'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    img = image.astype(float)\n    if img.ndim == 2:\n        r = g = b = img\n    else:\n        r = img[:, :, 0]\n        g = img[:, :, 1]\n        b = img[:, :, 2]\n    meanR = float(np.mean(r))\n    meanB = float(np.mean(b))\n    meanLum = float(np.mean((r + g + b) / 3.0)) + eps\n    return float((meanR - meanB) / meanLum)\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Fraction of strong edges oriented near-horizontal (horizontal structural dominance)'\n    import numpy as np\n    eps = 1e-8\n    import numpy as np\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if image.ndim == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    if gray.size == 0:\n        return 0.0\n    gy, gx = np.gradient(gray)\n    mag = np.sqrt(gx * gx + gy * gy)\n    if np.count_nonzero(mag) == 0:\n        return 0.0\n    thr = np.percentile(mag, 75)\n    strong = mag > (thr + eps)\n    orient = np.arctan2(gy, gx)  # -pi..pi\n    # horizontal edges produce gradient near +/-pi/2 (i.e., orient ~ +/-1.5708)\n    angle_dist = np.minimum(np.abs(orient - (np.pi/2)), np.abs(orient + (np.pi/2)))\n    deg_thresh = 20.0 * np.pi / 180.0\n    horiz_edges = strong & (angle_dist <= deg_thresh + eps)\n    total_strong = np.count_nonzero(strong)\n    return float(np.count_nonzero(horiz_edges) / (total_strong + eps))\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Inverse of vertical luminance variability (1 / std of row means) indicating vertical smoothness'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if image.ndim == 3:\n        lum = np.mean(image.astype(float), axis=2)\n    else:\n        lum = image.astype(float)\n    if lum.size == 0:\n        return 0.0\n    row_mean = np.mean(lum, axis=1)\n    s = float(np.std(row_mean))\n    return float(1.0 / (s + eps))\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Fraction of very bright, low-saturation pixels (specular highlights / white reflections)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    img = image.astype(float)\n    if img.ndim == 2:\n        rgb = np.stack([img, img, img], axis=2)\n    else:\n        rgb = img\n    r = rgb[:, :, 0].flatten()\n    g = rgb[:, :, 1].flatten()\n    b = rgb[:, :, 2].flatten()\n    mx_val = np.max(rgb) if rgb.size else 0.0\n    if mx_val <= 0:\n        mx_val = 1.0\n    bright_thr = 0.9 * mx_val\n    mx = np.maximum(np.maximum(r, g), b) + eps\n    mn = np.minimum(np.minimum(r, g), b)\n    sat = (mx - mn) / (mx + eps)\n    bright_mask = (mx >= bright_thr)\n    white_spec = bright_mask & (sat < 0.12)\n    return float(np.count_nonzero(white_spec) / (r.size + eps))\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Fraction of pixels with very low local gradient magnitude (large smooth regions proxy)'\n    import numpy as np\n    eps = 1e-8\n    import numpy as np\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if image.ndim == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    if gray.size == 0:\n        return 0.0\n    gy, gx = np.gradient(gray)\n    mag = np.sqrt(gx * gx + gy * gy).flatten()\n    if mag.size == 0:\n        return 0.0\n    thr = np.percentile(mag, 25)\n    low_frac = np.count_nonzero(mag <= thr) / (mag.size + eps)\n    return float(low_frac)\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Relative difference of mean green between lower and upper halves (lower green bias)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    img = image.astype(float)\n    if img.ndim == 2:\n        g = img\n        h = g.shape[0]\n        upper = g[:h//2, :]\n        lower = g[h//2:, :]\n        mean_upper = float(np.mean(upper)) if upper.size else 0.0\n        mean_lower = float(np.mean(lower)) if lower.size else 0.0\n    else:\n        h = img.shape[0]\n        upper = img[:h//2, :, 1]\n        lower = img[h//2:, :, 1]\n        mean_upper = float(np.mean(upper)) if upper.size else 0.0\n        mean_lower = float(np.mean(lower)) if lower.size else 0.0\n    return float((mean_lower - mean_upper) / (abs(mean_upper) + eps))\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Entropy of strong-gradient orientation histogram (normalized, low for uniform orientation)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if image.ndim == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    if gray.size == 0:\n        return 0.0\n    gy, gx = np.gradient(gray)\n    mag = np.sqrt(gx * gx + gy * gy)\n    med = np.median(mag) + eps\n    strong_mask = mag >= med\n    if np.count_nonzero(strong_mask) == 0:\n        return 0.0\n    orient = np.arctan2(gy, gx)[strong_mask]  # subset\n    bins = 18\n    hist, _ = np.histogram(orient, bins=bins, range=(-np.pi, np.pi))\n    probs = hist.astype(float) / (np.sum(hist) + eps)\n    probs_nonzero = probs[probs > 0]\n    ent = -np.sum(probs_nonzero * np.log(probs_nonzero + eps))\n    norm = np.log(bins) + eps\n    return float(ent / norm)\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Contrast between center region brightness and border ring brightness (center subject salience)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    img = image.astype(float)\n    h, w = img.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if img.ndim == 3:\n        lum = np.mean(img, axis=2)\n    else:\n        lum = img\n    sr, sc = h // 4, w // 4\n    er, ec = h - sr, w - sc\n    if er > sr and ec > sc:\n        center = lum[sr:er, sc:ec]\n    else:\n        center = lum\n    # border ring = whole minus center\n    whole = lum\n    border_sum = np.sum(whole) - np.sum(center)\n    border_count = whole.size - center.size\n    mean_center = float(np.mean(center)) if center.size else 0.0\n    mean_border = float(border_sum / (border_count + eps))\n    return float((mean_center - mean_border) / (abs(mean_center) + abs(mean_border) + eps))\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Difference between top-third and bottom-third blue-dominant fractions (sky vs water bias)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    img = image.astype(float)\n    if img.ndim == 2:\n        rgb = np.stack([img, img, img], axis=2)\n    else:\n        rgb = img\n    h = rgb.shape[0]\n    t = max(1, h // 3)\n    top = rgb[:t, :, :]\n    bottom = rgb[-t:, :, :]\n    def blue_frac(region):\n        if region.size == 0:\n            return 0.0\n        r = region[:, :, 0].flatten()\n        g = region[:, :, 1].flatten()\n        b = region[:, :, 2].flatten()\n        mx = np.maximum(np.maximum(r, g), b) + eps\n        mn = np.minimum(np.minimum(r, g), b)\n        chroma = mx - mn\n        mask = (b == mx) & (chroma / mx > 0.07)\n        return float(np.count_nonzero(mask) / (r.size + eps))\n    return float(blue_frac(top) - blue_frac(bottom))\n",
  "def feature(image: np.ndarray) -> float:\n    'Fraction of blue-dominant pixels in the bottom half of the image'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    arr = image.astype(float)\n    h, w = arr.shape[:2]\n    # ensure RGB\n    if arr.ndim == 2:\n        rgb = np.stack([arr, arr, arr], axis=2)\n    else:\n        rgb = arr\n    bottom = rgb[h//2:, :, :]\n    if bottom.size == 0:\n        return 0.0\n    R = bottom[:, :, 0]\n    G = bottom[:, :, 1]\n    B = bottom[:, :, 2]\n    blue_dom = (B > R) & (B > G)\n    return float(np.count_nonzero(blue_dom) / (blue_dom.size + eps))\n\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Mean per-pixel chroma (max-min) normalized by mean intensity'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    arr = image.astype(float)\n    if arr.ndim == 2:\n        return 0.0\n    R = arr[:, :, 0]\n    G = arr[:, :, 1]\n    B = arr[:, :, 2]\n    mx = np.maximum(np.maximum(R, G), B)\n    mn = np.minimum(np.minimum(R, G), B)\n    chroma = mx - mn\n    mean_chroma = float(np.mean(chroma)) if chroma.size else 0.0\n    mean_intensity = float(np.mean((R + G + B) / 3.0) + eps)\n    return float(mean_chroma / mean_intensity)\n\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Concentration of the brightest pixels: 1 - normalized bounding-box area of 90th-percentile pixels'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    # grayscale for brightness\n    if image.ndim == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    thr = np.percentile(gray, 90)\n    mask = gray >= thr\n    if np.count_nonzero(mask) == 0:\n        return 0.0\n    rows, cols = np.where(mask)\n    rmin, rmax = int(np.min(rows)), int(np.max(rows))\n    cmin, cmax = int(np.min(cols)), int(np.max(cols))\n    bbox_area = max(1, (rmax - rmin + 1)) * max(1, (cmax - cmin + 1))\n    norm_area = bbox_area / (h * w + eps)\n    # also weight by fraction of bright pixels (so tiny specks are reduced)\n    bright_frac = np.count_nonzero(mask) / (mask.size + eps)\n    result = (1.0 - norm_area) * bright_frac\n    return float(result)\n\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Top-bottom reflection similarity: how similar top half is to vertically flipped bottom half'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if image.ndim == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    if h < 2:\n        return 0.0\n    top = gray[:h//2, :]\n    bottom = gray[h - (h//2):, :]\n    # make sizes equal\n    if top.shape != bottom.shape:\n        minr = min(top.shape[0], bottom.shape[0])\n        top = top[:minr, :]\n        bottom = bottom[-minr:, :]\n    # flip bottom vertically\n    bottom_flip = np.flipud(bottom)\n    diff = np.mean(np.abs(top - bottom_flip))\n    mean_int = np.mean(gray) + eps\n    sim = 1.0 - (diff / (mean_int + eps))\n    # clip to [0,1]\n    sim = max(0.0, min(1.0, sim))\n    return float(sim)\n\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Prominence of a horizontal horizon: strength of strongest horizontal edge weighted by proximity to image center'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if image.ndim == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    gy, gx = np.gradient(gray)\n    # gy measures change along rows -> highlights horizontal edges\n    row_strengths = np.mean(np.abs(gy), axis=1) if h > 0 else np.zeros((h,))\n    if row_strengths.size == 0:\n        return 0.0\n    row_idx = int(np.argmax(row_strengths))\n    max_strength = float(row_strengths[row_idx])\n    mean_strength = float(np.mean(row_strengths) + eps)\n    norm_strength = max_strength / (mean_strength + eps)\n    # proximity to vertical center (1 at center, 0 at edges)\n    center_row = (h - 1) / 2.0\n    closeness = 1.0 - (abs(row_idx - center_row) / (center_row + eps))\n    closeness = max(0.0, min(1.0, closeness))\n    result = norm_strength * closeness\n    return float(result)\n\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Average longest vertical contiguous run fraction of strong vertical edges per column'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if image.ndim == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    gy, gx = np.gradient(gray)\n    strong_mag = np.abs(gx)\n    thr = np.percentile(strong_mag, 75)\n    avg_run_fracs = []\n    for c in range(w):\n        col = strong_mag[:, c] > (thr + eps)\n        if not np.any(col):\n            avg_run_fracs.append(0.0)\n            continue\n        d = np.diff(np.concatenate(([0], col.view(np.int8), [0])))\n        starts = np.where(d == 1)[0]\n        ends = np.where(d == -1)[0]\n        if starts.size and ends.size:\n            runs = ends - starts\n            max_run = int(np.max(runs))\n        else:\n            max_run = 0\n        avg_run_fracs.append(max_run / (h + eps))\n    return float(np.mean(avg_run_fracs))\n\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Difference in blue-vs-green balance between lower and upper halves (lower - upper)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    arr = image.astype(float)\n    if arr.ndim == 2:\n        rgb = np.stack([arr, arr, arr], axis=2)\n    else:\n        rgb = arr\n    h, w = rgb.shape[:2]\n    upper = rgb[:h//2, :, :]\n    lower = rgb[h - (h//2):, :, :]\n    def balance(region):\n        if region.size == 0:\n            return 0.0\n        R = region[:, :, 0]\n        G = region[:, :, 1]\n        B = region[:, :, 2]\n        return float(np.mean((B - G) / (R + G + B + eps)))\n    return float(balance(lower) - balance(upper))\n\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Density of local intensity maxima per pixel (count of pixels greater than all 8 neighbors)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if image.ndim == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    pad = np.pad(gray, 1, mode='constant', constant_values=-np.inf)\n    center = pad[1:-1, 1:-1]\n    n0 = pad[0:-2, 1:-1]  # up\n    n1 = pad[2:, 1:-1]    # down\n    n2 = pad[1:-1, 0:-2]  # left\n    n3 = pad[1:-1, 2:]    # right\n    n4 = pad[0:-2, 0:-2]  # up-left\n    n5 = pad[0:-2, 2:]    # up-right\n    n6 = pad[2:, 0:-2]    # down-left\n    n7 = pad[2:, 2:]      # down-right\n    mask = (center > n0) & (center > n1) & (center > n2) & (center > n3) & (center > n4) & (center > n5) & (center > n6) & (center > n7)\n    count = np.count_nonzero(mask)\n    return float(count / (h * w + eps))\n\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Mean chroma of pixels above median chroma divided by mean intensity (vivid color fraction)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    arr = image.astype(float)\n    if arr.ndim == 2:\n        return 0.0\n    R = arr[:, :, 0]\n    G = arr[:, :, 1]\n    B = arr[:, :, 2]\n    mx = np.maximum(np.maximum(R, G), B)\n    mn = np.minimum(np.minimum(R, G), B)\n    chroma = mx - mn\n    if chroma.size == 0:\n        return 0.0\n    med = np.median(chroma)\n    mask = chroma > med\n    if np.count_nonzero(mask) == 0:\n        return 0.0\n    mean_chroma = float(np.mean(chroma[mask]))\n    mean_intensity = float(np.mean((R + G + B) / 3.0) + eps)\n    return float((mean_chroma / (mean_intensity + eps)) * (np.count_nonzero(mask) / (chroma.size + eps)))\n\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Circular variance of strong edge orientations (0=aligned, 1=uniformly distributed)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if image.ndim == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    gy, gx = np.gradient(gray)\n    mag = np.sqrt(gx * gx + gy * gy)\n    if mag.size == 0:\n        return 0.0\n    thr = np.median(mag)\n    strong = mag > (thr + eps)\n    if np.count_nonzero(strong) == 0:\n        return 0.0\n    ang = np.arctan2(gy[strong], gx[strong])\n    # use doubled angles to make orientation pi-periodic (edges have no direction)\n    ang2 = 2.0 * ang\n    c = np.cos(ang2)\n    s = np.sin(ang2)\n    mean_c = float(np.mean(c))\n    mean_s = float(np.mean(s))\n    R = np.sqrt(mean_c * mean_c + mean_s * mean_s)\n    circ_var = 1.0 - R\n    circ_var = max(0.0, min(1.0, circ_var))\n    return float(circ_var)\n",
  "def feature(image: np.ndarray) -> float:\n    'Fraction of pixels that are green-dominant (G > R and G > B and fairly green)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    img = image.astype(float)\n    if img.ndim == 2:\n        rgb = np.stack([img, img, img], axis=2)\n    else:\n        rgb = img\n    R = rgb[:, :, 0]\n    G = rgb[:, :, 1]\n    B = rgb[:, :, 2]\n    s = R + G + B + eps\n    green_score = G / s\n    mask = (G > R) & (G > B) & (green_score > 0.33)\n    return float(np.count_nonzero(mask) / float(R.size + eps))\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Relative concentration of blue-dominant pixels in the bottom third of the image'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    img = image.astype(float)\n    if img.ndim == 2:\n        rgb = np.stack([img, img, img], axis=2)\n    else:\n        rgb = img\n    h = rgb.shape[0]\n    split = max(1, h * 2 // 3)  # bottom third starts here\n    bottom = rgb[split:, :, :] if split < h else rgb\n    r = bottom[:, :, 0]\n    g = bottom[:, :, 1]\n    b = bottom[:, :, 2]\n    s = r + g + b + eps\n    blue_frac_bottom = (b / s) > 0.45\n    return float(np.count_nonzero(blue_frac_bottom) / float(r.size + eps))\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Left-right vertical symmetry score (1.0 = perfectly symmetric, 0 = very asymmetric)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.5\n    img = image.astype(float)\n    gray = np.mean(img, axis=2) if img.ndim == 3 else img\n    h, w = gray.shape[:2]\n    if w < 2:\n        return 1.0\n    mid = w // 2\n    left = gray[:, :mid]\n    right = gray[:, -mid:]\n    # flip right horizontally to compare\n    right_flipped = np.fliplr(right)\n    # crop to same width if odd\n    if left.shape[1] != right_flipped.shape[1]:\n        minw = min(left.shape[1], right_flipped.shape[1])\n        left = left[:, :minw]\n        right_flipped = right_flipped[:, :minw]\n    diff = np.mean(np.abs(left - right_flipped))\n    norm = np.mean(np.abs(gray)) + eps\n    score = 1.0 - (diff / (norm + eps))\n    # clamp\n    return float(max(0.0, min(1.0, score)))\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Normalized center vs border brightness contrast (center minus border) / (sum)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    img = image.astype(float)\n    gray = np.mean(img, axis=2) if img.ndim == 3 else img\n    h, w = gray.shape[:2]\n    if h < 3 or w < 3:\n        return float(np.mean(gray))\n    sr, sc = h // 4, w // 4\n    er, ec = h - sr, w - sc\n    center = gray[sr:er, sc:ec] if (er > sr and ec > sc) else gray\n    # border ring: whole image minus center\n    total_mean = np.mean(gray)\n    center_mean = np.mean(center) if center.size else total_mean\n    border_mean = (np.sum(gray) - np.sum(center)) / float(max(1, gray.size - center.size))\n    result = (center_mean - border_mean) / (abs(center_mean) + abs(border_mean) + eps)\n    return float(result)\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Inter-quadrant mean RGB variance (how different quadrants are in color)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    img = image.astype(float)\n    if img.ndim == 2:\n        rgb = np.stack([img, img, img], axis=2)\n    else:\n        rgb = img\n    h, w = rgb.shape[:2]\n    hr, wr = max(1, h // 2), max(1, w // 2)\n    q1 = rgb[:hr, :wr, :].reshape(-1, 3)\n    q2 = rgb[:hr, wr:, :].reshape(-1, 3)\n    q3 = rgb[hr:, :wr, :].reshape(-1, 3)\n    q4 = rgb[hr:, wr:, :].reshape(-1, 3)\n    quads = [q for q in (q1, q2, q3, q4) if q.size > 0]\n    means = np.array([np.mean(q, axis=0) for q in quads])\n    # variance across quadrant means\n    var = np.mean(np.var(means, axis=0))\n    norm = np.mean(np.mean(rgb, axis=(0,1))) + eps\n    return float(var / (norm + eps))\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Strength of a blue horizontal band near the top third (sky indicator)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    img = image.astype(float)\n    if img.ndim == 2:\n        rgb = np.stack([img, img, img], axis=2)\n    else:\n        rgb = img\n    h = rgb.shape[0]\n    top_end = max(1, h // 3)\n    top = rgb[:top_end, :, :]\n    r = top[:, :, 0]\n    g = top[:, :, 1]\n    b = top[:, :, 2]\n    s = r + g + b + eps\n    blue_frac = b / s\n    mask = (blue_frac > 0.45) & (b > g) & (b > r)\n    # additionally weight by vertical extent: fraction of rows in top_end that have >1% blue pixels\n    row_has_blue = np.mean(mask, axis=1) > 0.01\n    vertical_coverage = np.count_nonzero(row_has_blue) / float(top_end + eps)\n    pixel_frac = np.count_nonzero(mask) / float(r.size + eps)\n    return float(pixel_frac * 0.7 + vertical_coverage * 0.3)\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Fraction of pixels with strong local 3x3 contrast relative to local mean'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    img = image.astype(float)\n    gray = np.mean(img, axis=2) if img.ndim == 3 else img\n    h, w = gray.shape[:2]\n    if h < 3 or w < 3:\n        return 0.0\n    # compute 3x3 local mean for inner pixels using shifted sums\n    s = (gray[:-2, :-2] + gray[:-2, 1:-1] + gray[:-2, 2:] +\n         gray[1:-1, :-2] + gray[1:-1, 1:-1] + gray[1:-1, 2:] +\n         gray[2:, :-2] + gray[2:, 1:-1] + gray[2:, 2:]) / 9.0\n    center = gray[1:-1, 1:-1]\n    diff = np.abs(center - s)\n    if diff.size == 0:\n        return 0.0\n    thr = np.percentile(diff, 75)\n    strong = diff > (thr + eps)\n    return float(np.count_nonzero(strong) / float(diff.size + eps))\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Mean color warmth: average normalized (R - B) where positive means warmer'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    img = image.astype(float)\n    if img.ndim == 2:\n        r = g = b = img\n    else:\n        r = img[:, :, 0]\n        g = img[:, :, 1]\n        b = img[:, :, 2]\n    s = r + g + b + eps\n    warmth = (r - b) / s\n    return float(np.mean(warmth))\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Entropy of dominant-channel map (R/G/B) approximating hue diversity'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    img = image.astype(float)\n    if img.ndim == 2:\n        rgb = np.stack([img, img, img], axis=2)\n    else:\n        rgb = img\n    r = rgb[:, :, 0].ravel()\n    g = rgb[:, :, 1].ravel()\n    b = rgb[:, :, 2].ravel()\n    # dominant channel index: 0,1,2\n    dom = np.argmax(np.stack([r, g, b], axis=1), axis=1)\n    counts = np.bincount(dom, minlength=3).astype(float)\n    probs = counts / (np.sum(counts) + eps)\n    # Shannon entropy normalized by log(3)\n    probs_nonzero = probs[probs > 0]\n    entropy = -np.sum(probs_nonzero * np.log(probs_nonzero + eps))\n    norm_entropy = entropy / (np.log(3) + eps)\n    return float(norm_entropy)\n",
  "def feature(image: np.ndarray) -> float:\n    'Fraction of pixels in the top third that are blue-dominant'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    img = image.astype(float)\n    if img.ndim == 2:\n        rgb = np.stack([img, img, img], axis=2)\n    else:\n        rgb = img\n    h = rgb.shape[0]\n    t = max(1, h // 3)\n    top = rgb[:t, :, :]\n    if top.size == 0:\n        return 0.0\n    R = top[:, :, 0]\n    G = top[:, :, 1]\n    B = top[:, :, 2]\n    meanB = np.mean(B) if B.size else 0.0\n    mask = (B > R) & (B > G) & (B > (0.9 * meanB + eps))\n    return float(np.count_nonzero(mask) / (mask.size + eps))\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Global fraction of green, saturated patches (vegetation proxy)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    img = image.astype(float)\n    if img.ndim == 2:\n        rgb = np.stack([img, img, img], axis=2)\n    else:\n        rgb = img\n    r = rgb[:, :, 0]\n    g = rgb[:, :, 1]\n    b = rgb[:, :, 2]\n    mx = np.maximum(np.maximum(r, g), b)\n    mn = np.minimum(np.minimum(r, g), b)\n    sat = (mx - mn) / (mx + eps)\n    green_mask = (g > r) & (g > b) & (sat > 0.15)\n    return float(np.count_nonzero(green_mask) / (green_mask.size + eps))\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Fraction of image height occupied by strong-edge rows (object vertical coverage)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if image.ndim == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    if gray.size == 0:\n        return 0.0\n    gy, gx = np.gradient(gray)\n    mag = np.sqrt(gx * gx + gy * gy)\n    # threshold at 75th percentile of magnitudes\n    thresh = np.percentile(mag.flatten(), 75) if mag.size else 0.0\n    rows = np.any(mag > thresh, axis=1)\n    h = gray.shape[0]\n    return float(np.count_nonzero(rows) / (h + eps))\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Fraction of pixels that are both bright and blue-dominant (possible water highlights)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    img = image.astype(float)\n    if img.ndim == 2:\n        rgb = np.stack([img, img, img], axis=2)\n    else:\n        rgb = img\n    r = rgb[:, :, 0]\n    g = rgb[:, :, 1]\n    b = rgb[:, :, 2]\n    bright = (r + g + b) / 3.0\n    mean_brightness = np.mean(bright) if bright.size else 0.0\n    std_brightness = np.std(bright) if bright.size else 0.0\n    bright_thresh = mean_brightness + 0.5 * std_brightness\n    mask = (b > 1.1 * r) & (b > 1.1 * g) & (bright > bright_thresh)\n    return float(np.count_nonzero(mask) / (mask.size + eps))\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Warmth index: normalized (mean red - mean green) divided by mean blue'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    img = image.astype(float)\n    if img.ndim == 2:\n        r = g = b = img\n    else:\n        r = img[:, :, 0]\n        g = img[:, :, 1]\n        b = img[:, :, 2]\n    meanR = np.mean(r) if r.size else 0.0\n    meanG = np.mean(g) if g.size else 0.0\n    meanB = np.mean(b) if b.size else 0.0\n    return float((meanR - meanG) / (meanB + eps))\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Mean local contrast via first-neighbor absolute differences (texture proxy)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    img = image.astype(float)\n    if img.ndim == 3:\n        gray = np.mean(img, axis=2)\n    else:\n        gray = img\n    h, w = gray.shape[:2]\n    if h < 2 or w < 2:\n        return float(0.0)\n    right = gray[:, 1:]\n    down = gray[1:, :]\n    orig_r = gray[:, :-1]\n    orig_d = gray[:-1, :]\n    diffs = np.abs(orig_r - right[:, :w-1]) if right.size and orig_r.size else np.array([0.0])\n    diffs2 = np.abs(orig_d - down[:h-1, :]) if down.size and orig_d.size else np.array([0.0])\n    all_d = np.concatenate([diffs.flatten(), diffs2.flatten()]) if (diffs.size + diffs2.size) > 0 else np.array([0.0])\n    return float(np.mean(all_d) if all_d.size else 0.0)\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Normalized color difference between top 25% and bottom 25% (euclidean / mean intensity)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    img = image.astype(float)\n    if img.ndim == 2:\n        rgb = np.stack([img, img, img], axis=2)\n    else:\n        rgb = img\n    h = rgb.shape[0]\n    q = max(1, h // 4)\n    top = rgb[:q, :, :].reshape(-1, 3)\n    bottom = rgb[-q:, :, :].reshape(-1, 3)\n    if top.size == 0 or bottom.size == 0:\n        return 0.0\n    mean_top = np.mean(top, axis=0)\n    mean_bot = np.mean(bottom, axis=0)\n    diff = np.linalg.norm(mean_top - mean_bot)\n    mean_int = (np.mean(mean_top) + np.mean(mean_bot)) / 2.0 + eps\n    return float(diff / mean_int)\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Left-right symmetry score: 1 - normalized mean absolute difference between halves (1 symmetrical)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    img = image.astype(float)\n    if img.ndim == 2:\n        left = img[:, :img.shape[1]//2]\n        right = img[:, img.shape[1] - img.shape[1]//2:]\n        # reflect right to align\n        right = np.fliplr(right)\n        # match shapes\n        min_w = min(left.shape[1], right.shape[1]) if left.size and right.size else 0\n        if min_w == 0:\n            return 0.0\n        left_c = left[:, :min_w].reshape(-1)\n        right_c = right[:, :min_w].reshape(-1)\n        denom = np.mean((left_c + right_c) / 2.0) + eps\n        diff = np.mean(np.abs(left_c - right_c))\n        score = 1.0 - (diff / denom)\n        return float(np.clip(score, 0.0, 1.0))\n    else:\n        h, w = img.shape[:2]\n        mid = w // 2\n        left = img[:, :mid, :].astype(float)\n        right = img[:, w - mid:, :].astype(float)\n        right = np.fliplr(right)\n        if left.size == 0 or right.size == 0:\n            return 0.0\n        min_w = min(left.shape[1], right.shape[1])\n        left_c = left[:, :min_w, :].reshape(-1, 3)\n        right_c = right[:, :min_w, :].reshape(-1, 3)\n        left_mean = np.mean(left_c, axis=1)\n        right_mean = np.mean(right_c, axis=1)\n        denom = np.mean((left_mean + right_mean) / 2.0) + eps\n        diff = np.mean(np.abs(left_mean - right_mean))\n        score = 1.0 - (diff / denom)\n        return float(np.clip(score, 0.0, 1.0))\n",
  "def feature(image: np.ndarray) -> float:\n    'Relative height of a contiguous blue-dominant band starting from the top (sky band height ratio)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    img = image.astype(float)\n    h, w = img.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if img.ndim == 2:\n        rgb = np.stack([img, img, img], axis=2)\n    else:\n        rgb = img\n    R = rgb[:, :, 0]\n    G = rgb[:, :, 1]\n    B = rgb[:, :, 2]\n    # per-row blue fraction\n    mean_int = np.mean((R + G + B) / 3.0) + eps\n    blue_pix = (B > R + 8) & (B > G + 8) & (B > 0.6 * mean_int)\n    row_frac = np.sum(blue_pix, axis=1) / (w + eps)\n    # consider a row \"sky\" if more than 30% pixels are blue-dominant\n    sky_rows = row_frac > 0.3\n    # find contiguous true rows from the top\n    top_count = 0\n    for val in sky_rows:\n        if val:\n            top_count += 1\n        else:\n            break\n    return float(top_count / (h + eps))\n\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Global color temperature proxy: normalized (mean_red - mean_blue)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    img = image.astype(float)\n    if img.ndim == 2:\n        r = g = b = img\n    else:\n        r = img[:, :, 0]\n        g = img[:, :, 1]\n        b = img[:, :, 2]\n    mean_r = float(np.mean(r))\n    mean_b = float(np.mean(b))\n    mean_int = float(np.mean((r + g + b) / 3.0) + eps)\n    return float((mean_r - mean_b) / mean_int)\n\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Colorfulness index (Hasler-S\u00fcsstrunk) measuring vividness'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    img = image.astype(float)\n    if img.ndim == 2:\n        R = G = B = img\n    else:\n        R = img[:, :, 0]\n        G = img[:, :, 1]\n        B = img[:, :, 2]\n    rg = R - G\n    yb = 0.5 * (R + G) - B\n    std_rg = float(np.std(rg))\n    std_yb = float(np.std(yb))\n    mean_rg = float(np.mean(rg))\n    mean_yb = float(np.mean(yb))\n    colorfulness = np.sqrt(std_rg**2 + std_yb**2) + 0.3 * np.sqrt(mean_rg**2 + mean_yb**2)\n    # normalize by overall intensity\n    mean_int = float(np.mean((R + G + B) / 3.0) + eps)\n    return float(colorfulness / mean_int)\n\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Left-right luminance asymmetry: normalized absolute difference between halves'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    img = image.astype(float)\n    h, w = img.shape[:2]\n    if w == 0:\n        return 0.0\n    if img.ndim == 3:\n        gray = np.mean(img, axis=2)\n    else:\n        gray = img\n    mid = w // 2\n    left = gray[:, :mid] if mid > 0 else gray\n    right = gray[:, mid:] if mid < w else gray\n    mean_left = float(np.mean(left) if left.size else 0.0)\n    mean_right = float(np.mean(right) if right.size else 0.0)\n    mean_all = float(np.mean(gray) + eps)\n    return float(abs(mean_left - mean_right) / mean_all)\n\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Fraction of strong vertical edges (vertical-edge pixels proportion)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if image.ndim == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    if gray.size == 0:\n        return 0.0\n    gy, gx = np.gradient(gray)\n    abs_gx = np.abs(gx)\n    abs_gy = np.abs(gy)\n    mag = np.sqrt(abs_gx**2 + abs_gy**2)\n    mean_mag = np.mean(mag)\n    std_mag = np.std(mag)\n    thr = mean_mag + 0.5 * std_mag\n    strong_vert = (abs_gx > abs_gy) & (abs_gx > thr)\n    return float(np.count_nonzero(strong_vert) / (mag.size + eps))\n\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Center-versus-outer texture ratio using mean gradient magnitude'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 1.0\n    img = image.astype(float)\n    h, w = img.shape[:2]\n    if img.ndim == 3:\n        gray = np.mean(img, axis=2)\n    else:\n        gray = img\n    sr, sc = h // 4, w // 4\n    er, ec = h - sr, w - sc\n    gy, gx = np.gradient(gray)\n    mag = np.sqrt(gy * gy + gx * gx)\n    if er <= sr or ec <= sc:\n        center_mag = mag\n        outer_mask = np.zeros_like(mag, dtype=bool)\n    else:\n        center_mag = mag[sr:er, sc:ec]\n        outer_mask = np.ones_like(mag, dtype=bool)\n        outer_mask[sr:er, sc:ec] = False\n    mean_center = float(np.mean(center_mag) + eps)\n    outer_vals = mag[outer_mask] if outer_mask.any() else np.array([])\n    mean_outer = float(np.mean(outer_vals) + eps) if outer_vals.size else mean_center + eps\n    return float(mean_center / mean_outer)\n\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Fraction of small isolated bright specular pixels (bright pixels with few bright neighbors)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    img = image.astype(float)\n    if img.ndim == 3:\n        gray = np.mean(img, axis=2)\n    else:\n        gray = img\n    if gray.size == 0:\n        return 0.0\n    mean_g = np.mean(gray)\n    std_g = np.std(gray)\n    thr = mean_g + max(8.0, 0.5 * std_g)\n    bright = gray > thr\n    # compute neighbor count via shifted sums\n    pad = np.pad(bright.astype(np.int32), ((1, 1), (1, 1)), mode='constant', constant_values=0)\n    neigh = np.zeros_like(bright, dtype=np.int32)\n    shifts = [(-1, -1), (-1, 0), (-1, 1), (0, -1), (0, 1), (1, -1), (1, 0), (1, 1)]\n    for dy, dx in shifts:\n        neigh += pad[1 + dy : 1 + dy + bright.shape[0], 1 + dx : 1 + dx + bright.shape[1]]\n    isolated = bright & (neigh <= 2)\n    return float(np.count_nonzero(isolated) / (bright.size + eps))\n\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Mean hue-like opponent angle (arctan2 of color-opponent means) normalized to [-1,1]'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    img = image.astype(float)\n    if img.ndim == 2:\n        R = G = B = img\n    else:\n        R = img[:, :, 0]\n        G = img[:, :, 1]\n        B = img[:, :, 2]\n    # opponent channels: a = R - G, b = (R + G)/2 - B\n    a = np.mean(R - G)\n    b = np.mean(0.5 * (R + G) - B)\n    angle = np.arctan2(b, a)  # -pi..pi\n    return float(angle / np.pi)\n\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Normalized upper-vs-lower intensity balance: (upper - lower) / total'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    img = image.astype(float)\n    h = img.shape[0] if img.ndim >= 2 else 0\n    if h == 0:\n        return 0.0\n    if img.ndim == 3:\n        gray = np.mean(img, axis=2)\n    else:\n        gray = img\n    mid = h // 2\n    upper = gray[:mid, :] if mid > 0 else np.array([])\n    lower = gray[mid:, :] if mid < h else np.array([])\n    sum_upper = float(np.sum(upper)) if upper.size else 0.0\n    sum_lower = float(np.sum(lower)) if lower.size else 0.0\n    total = sum_upper + sum_lower + eps\n    return float((sum_upper - sum_lower) / total)\n\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Difference in blue-dominant saturation between top third and bottom third (normalized)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    img = image.astype(float)\n    h, w = img.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if img.ndim == 2:\n        rgb = np.stack([img, img, img], axis=2)\n    else:\n        rgb = img\n    sr_top, er_top = 0, max(1, h // 3)\n    sr_bot, er_bot = max(0, 2 * h // 3), h\n    top = rgb[sr_top:er_top, :, :]\n    bot = rgb[sr_bot:er_bot, :, :]\n    def mean_blue_sat(region):\n        if region.size == 0:\n            return 0.0\n        r = region[:, :, 0].flatten()\n        g = region[:, :, 1].flatten()\n        b = region[:, :, 2].flatten()\n        mx = np.maximum(np.maximum(r, g), b)\n        mn = np.minimum(np.minimum(r, g), b)\n        sat = (mx - mn) / (mx + eps)\n        blue_mask = (b > r + 5) & (b > g + 5)\n        if np.count_nonzero(blue_mask) == 0:\n            return 0.0\n        return float(np.mean(sat[blue_mask]))\n    top_sat = mean_blue_sat(top)\n    bot_sat = mean_blue_sat(bot)\n    denom = (top_sat + bot_sat) / 2.0 + eps\n    return float((top_sat - bot_sat) / denom)\n",
  "def feature(image: np.ndarray) -> float:\n    'Relative blue intensity concentration in the top third compared to the rest of the image'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    img = image.astype(float)\n    h, w = img.shape[:2]\n    top_h = max(1, h // 3)\n    if img.ndim == 2:\n        blue = img\n    else:\n        blue = img[:, :, 2]\n    top_mean = float(np.mean(blue[:top_h, :])) if top_h > 0 else 0.0\n    rest = blue[top_h:, :]\n    rest_mean = float(np.mean(rest)) if rest.size > 0 else float(np.mean(blue))\n    result = top_mean / (rest_mean + eps)\n    return float(result)\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Mirror symmetry score between left and right halves (1 = identical, 0 = very different)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    if w < 2 or h == 0:\n        return 0.0\n    half = w // 2\n    left = gray[:, :half]\n    right = gray[:, -half:] if half > 0 else gray[:, :half]\n    right_flipped = np.fliplr(right)\n    if left.size == 0 or right_flipped.size == 0:\n        return 0.0\n    diff = np.mean(np.abs(left - right_flipped))\n    mean_int = np.mean(np.abs(gray)) + eps\n    score = 1.0 - (diff / mean_int)\n    # clamp to [0,1]\n    result = float(max(0.0, min(1.0, score)))\n    return float(result)\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Aspect ratio (width/height) of the bounding box of bright pixels in the center region'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    img = image.astype(float)\n    if img.ndim == 3:\n        R = img[:, :, 0]; G = img[:, :, 1]; B = img[:, :, 2]\n        lum = 0.299 * R + 0.587 * G + 0.114 * B\n    else:\n        lum = img\n    h, w = lum.shape[:2]\n    sr, sc = h // 4, w // 4\n    er, ec = h - sr, w - sc\n    region = lum[sr:er, sc:ec] if (er > sr and ec > sc) else lum\n    if region.size == 0:\n        return 0.0\n    mean_r = float(np.mean(region))\n    std_r = float(np.std(region))\n    thr = mean_r + 0.5 * std_r\n    mask = region > thr\n    if np.count_nonzero(mask) == 0:\n        return 0.0\n    rows, cols = np.where(mask)\n    height = rows.max() - rows.min() + 1\n    width = cols.max() - cols.min() + 1\n    result = float(width / (height + eps))\n    return float(result)\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Ratio of vertical-edge energy to horizontal-edge energy (>1 means more vertical edges)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    if gray.size == 0:\n        return 0.0\n    gy, gx = np.gradient(gray)\n    vert_energy = np.mean(np.abs(gx))\n    horiz_energy = np.mean(np.abs(gy))\n    result = vert_energy / (horiz_energy + eps)\n    return float(result)\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Mean local standard deviation across non-overlapping patches (texture roughness)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    # choose patch size relative to image\n    p = max(4, min(16, max(1, min(h, w) // 8)))\n    h0 = (h // p) * p\n    w0 = (w // p) * p\n    if h0 == 0 or w0 == 0:\n        # fallback to global std\n        result = float(np.std(gray))\n        return float(result)\n    sub = gray[:h0, :w0]\n    try:\n        blocks = sub.reshape(h0 // p, p, w0 // p, p).transpose(0,2,1,3)\n        block_std = np.std(blocks, axis=(2,3))\n        result = float(np.mean(block_std))\n    except Exception:\n        result = float(np.std(sub))\n    return float(result)\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Normalized red-blue balance in the center region (positive = red-dominant)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    img = image.astype(float)\n    h, w = img.shape[:2]\n    sr, sc = h // 4, w // 4\n    er, ec = h - sr, w - sc\n    if img.ndim == 2:\n        rgb = np.stack([img, img, img], axis=2)\n    else:\n        rgb = img\n    region = rgb[sr:er, sc:ec, :] if (er > sr and ec > sc) else rgb\n    if region.size == 0:\n        return 0.0\n    meanR = float(np.mean(region[:, :, 0]))\n    meanB = float(np.mean(region[:, :, 2]))\n    result = (meanR - meanB) / (meanR + meanB + eps)\n    return float(result)\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Relative vertical position (0..1) of the row with strongest horizontal edge activity'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    if h == 0:\n        return 0.0\n    gy, gx = np.gradient(gray)\n    row_energy = np.mean(np.abs(gy), axis=1)\n    if row_energy.size == 0:\n        return 0.0\n    r = int(np.argmax(row_energy))\n    result = float(r / max(1, h - 1))\n    return float(result)\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Fraction of columns that contain at least one bright peak (bright-column density)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        R = image[:, :, 0].astype(float); G = image[:, :, 1].astype(float); B = image[:, :, 2].astype(float)\n        lum = 0.299 * R + 0.587 * G + 0.114 * B\n    else:\n        lum = image.astype(float)\n    h, w = lum.shape[:2]\n    if w == 0:\n        return 0.0\n    thr = np.mean(lum) + 0.75 * np.std(lum)\n    col_max = np.max(lum, axis=0)\n    count = int(np.count_nonzero(col_max > thr))\n    result = float(count / (w + eps))\n    return float(result)\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Distance of center-region mean color to pure green normalized by mean intensity (vegetation proximity)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    img = image.astype(float)\n    h, w = img.shape[:2]\n    sr, sc = h // 4, w // 4\n    er, ec = h - sr, w - sc\n    if img.ndim == 2:\n        rgb = np.stack([img, img, img], axis=2)\n    else:\n        rgb = img\n    region = rgb[sr:er, sc:ec, :] if (er > sr and ec > sc) else rgb\n    if region.size == 0:\n        return 0.0\n    mean_col = np.mean(region.reshape(-1, 3), axis=0)\n    target = np.array([0.0, 255.0, 0.0])\n    dist = np.sqrt(np.sum((mean_col - target) ** 2))\n    mean_int = np.mean(mean_col) + eps\n    result = float(dist / mean_int)\n    return float(result)\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Ratio of low-frequency energy to total energy computed via 2x2 block averaging'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    if h < 2 or w < 2:\n        # trivial small image: low-frequency equals total\n        tenergy = np.mean(gray ** 2) + eps\n        return float(1.0)\n    # crop to even dimensions\n    h0 = h - (h % 2)\n    w0 = w - (w % 2)\n    sub = gray[:h0, :w0]\n    # 2x2 averaging\n    a = sub[0::2, 0::2]\n    b = sub[0::2, 1::2]\n    c = sub[1::2, 0::2]\n    d = sub[1::2, 1::2]\n    low = (a + b + c + d) / 4.0\n    low_energy = np.mean(low ** 2)\n    total_energy = np.mean(sub ** 2) + eps\n    result = float(low_energy / total_energy)\n    return float(result)\n",
  "def feature(image: np.ndarray) -> float:\n    'Fraction of image rows that are blue-dominant (useful for water detection)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    arr = image.astype(float)\n    if arr.ndim == 2:\n        r = g = b = arr\n    else:\n        r = arr[:, :, 0]\n        g = arr[:, :, 1]\n        b = arr[:, :, 2]\n    # compute per-row means\n    r_row = np.mean(r, axis=1)\n    g_row = np.mean(g, axis=1)\n    b_row = np.mean(b, axis=1)\n    blue_dominant = (b_row > r_row) & (b_row > g_row + 0.5)  # require some margin\n    return float(np.count_nonzero(blue_dominant) / (r_row.size + eps))\n\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Ratio of horizontal to vertical gradient energy (horizontal bias >1)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 1.0\n    arr = image.astype(float)\n    if arr.ndim == 3:\n        gray = np.mean(arr, axis=2)\n    else:\n        gray = arr\n    gy, gx = np.gradient(gray)\n    hx = np.sum(np.abs(gx))\n    hy = np.sum(np.abs(gy))\n    return float((hx + eps) / (hy + eps))\n\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Normalized difference between bottom-blue and top-blue mean (positive => more blue at bottom)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    arr = image.astype(float)\n    h = arr.shape[0]\n    top_h = max(1, h // 4)\n    bot_h = top_h\n    if arr.ndim == 2:\n        b_top = np.mean(arr[:top_h, :])\n        b_bot = np.mean(arr[-bot_h:, :])\n        overall = np.mean(arr)\n    else:\n        b_top = np.mean(arr[:top_h, :, 2])\n        b_bot = np.mean(arr[-bot_h:, :, 2])\n        overall = np.mean(np.mean(arr, axis=2))\n    return float((b_bot - b_top) / (abs(overall) + eps))\n\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Horizontal reflection correlation between upper half and flipped lower half (reflection score)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    arr = image.astype(float)\n    if arr.ndim == 3:\n        gray = np.mean(arr, axis=2)\n    else:\n        gray = arr\n    h = gray.shape[0]\n    mid = h // 2\n    if mid < 1:\n        return 0.0\n    top = gray[:mid, :]\n    bottom = gray[-mid:, :]\n    bottom_flipped = np.flipud(bottom)\n    x = top.flatten()\n    y = bottom_flipped.flatten()\n    if x.size == 0:\n        return 0.0\n    xm = x - np.mean(x)\n    ym = y - np.mean(y)\n    den = (np.sqrt(np.mean(xm * xm)) * np.sqrt(np.mean(ym * ym)) + eps)\n    corr = np.mean(xm * ym) / den\n    return float(corr)\n\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Density of strict local maxima in a 3x3 neighborhood in intensity (salient point density)'\n    import numpy as np\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    arr = image.astype(float)\n    if arr.ndim == 3:\n        gray = np.mean(arr, axis=2)\n    else:\n        gray = arr\n    # pad with very small values so edges are handled\n    pad = np.pad(gray, 1, mode='constant', constant_values=-1e9)\n    center = pad[1:-1, 1:-1]\n    neighs = [\n        pad[0:-2, 0:-2], pad[0:-2, 1:-1], pad[0:-2, 2:],\n        pad[1:-1, 0:-2],                 pad[1:-1, 2:],\n        pad[2:  , 0:-2], pad[2:  , 1:-1], pad[2:  , 2:],\n    ]\n    is_max = np.ones_like(center, dtype=bool)\n    for n in neighs:\n        is_max &= (center > n)\n    total = center.size\n    if total == 0:\n        return 0.0\n    return float(np.count_nonzero(is_max) / total)\n\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Fraction of top quarter that is sky-like blue (bright and blue-dominant)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    arr = image.astype(float)\n    h = arr.shape[0]\n    top_h = max(1, h // 4)\n    if arr.ndim == 2:\n        region = arr[:top_h, :]\n        b = region\n        r = g = region\n    else:\n        region = arr[:top_h, :, :]\n        r = region[:, :, 0]\n        g = region[:, :, 1]\n        b = region[:, :, 2]\n    inten = (r + g + b) / 3.0\n    mean_i = np.mean(inten) if inten.size else 0.0\n    sky_mask = (b > r) & (b > g) & (inten > (mean_i * 0.6 + eps))\n    return float(np.count_nonzero(sky_mask) / (inten.size + eps))\n\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Ratio of mean red to mean blue in the central region (color temperature center)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 1.0\n    arr = image.astype(float)\n    h, w = arr.shape[:2]\n    sr, sc = h // 4, w // 4\n    er, ec = h - sr, w - sc\n    if arr.ndim == 2:\n        center = arr[sr:er, sc:ec] if (er > sr and ec > sc) else arr\n        r = g = b = center\n    else:\n        center = arr[sr:er, sc:ec, :] if (er > sr and ec > sc) else arr\n        r = center[:, :, 0]\n        b = center[:, :, 2]\n    mean_r = np.mean(r) if r.size else 0.0\n    mean_b = np.mean(b) if b.size else 0.0\n    return float((mean_r + eps) / (mean_b + eps))\n\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Mean absolute cosine of edge orientation (1->horizontal edges dominate, 0->vertical)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.5\n    arr = image.astype(float)\n    if arr.ndim == 3:\n        gray = np.mean(arr, axis=2)\n    else:\n        gray = arr\n    gy, gx = np.gradient(gray)\n    mag = np.sqrt(gx * gx + gy * gy) + eps\n    cos_theta = gx / mag\n    return float(np.mean(np.abs(cos_theta)))\n\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Average per-channel Pearson correlation between left and right halves (symmetry)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    arr = image.astype(float)\n    h, w = arr.shape[:2]\n    half = w // 2\n    if half < 1:\n        return 0.0\n    if arr.ndim == 2:\n        left = arr[:, :half]\n        right = arr[:, w - half:]\n        channels = [ (left, right) ]\n    else:\n        left = arr[:, :half, :]\n        right = arr[:, w - half:, :]\n        channels = [ (left[:, :, c], right[:, :, c]) for c in range(arr.shape[2]) ]\n    corrs = []\n    for L, R in channels:\n        x = L.flatten()\n        y = R.flatten()\n        if x.size == 0:\n            corrs.append(0.0)\n            continue\n        xm = x - np.mean(x)\n        ym = y - np.mean(y)\n        denom = (np.sqrt(np.mean(xm * xm)) * np.sqrt(np.mean(ym * ym)) + eps)\n        corrs.append(np.mean(xm * ym) / denom)\n    return float(np.mean(corrs))\n\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Large-scale block color variance: variance of block means normalized by overall mean (uniform scenes -> low)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    arr = image.astype(float)\n    h, w = arr.shape[:2]\n    rows = min(4, h)\n    cols = min(4, w)\n    bh = max(1, h // rows)\n    bw = max(1, w // cols)\n    block_means = []\n    if arr.ndim == 2:\n        for i in range(0, h, bh):\n            for j in range(0, w, bw):\n                blk = arr[i:i+bh, j:j+bw]\n                if blk.size:\n                    block_means.append(np.mean(blk))\n    else:\n        inten = np.mean(arr, axis=2)\n        for i in range(0, h, bh):\n            for j in range(0, w, bw):\n                blk = inten[i:i+bh, j:j+bw]\n                if blk.size:\n                    block_means.append(np.mean(blk))\n    if len(block_means) == 0:\n        return 0.0\n    bm = np.array(block_means)\n    overall = np.mean(bm)\n    return float(np.var(bm) / (abs(overall) + eps))\n",
  "def feature(image: np.ndarray) -> float:\n    'Ratio of horizontal to vertical edge energy ( >1 => more horizontal structure)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if image.ndim == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    if gray.size == 0:\n        return 0.0\n    gy, gx = np.gradient(gray)\n    horiz = float(np.sum(np.abs(gy)))\n    vert = float(np.sum(np.abs(gx)))\n    return float((horiz + eps) / (vert + eps))\n\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Variance of the Laplacian in the central region (sharpness/texture proxy)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if image.ndim == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    sr, sc = h // 4, w // 4\n    er, ec = h - sr, w - sc\n    region = gray[sr:er, sc:ec] if (er > sr and ec > sc) else gray\n    if region.size == 0:\n        return 0.0\n    gy, gx = np.gradient(region)\n    gyy, _ = np.gradient(gy)\n    _, gxx = np.gradient(gx)\n    lap = gxx + gyy\n    return float(np.var(lap) + eps)\n\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Center brightness divided by border brightness ( >1 => center brighter than border)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    img = image.astype(float)\n    h, w = img.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if img.ndim == 3:\n        gray = np.mean(img, axis=2)\n    else:\n        gray = img\n    sr, sc = h // 4, w // 4\n    er, ec = h - sr, w - sc\n    center = gray[sr:er, sc:ec] if (er > sr and ec > sc) else gray\n    # border = outside that center\n    mask = np.ones_like(gray, dtype=bool)\n    if center.size > 0:\n        mask[sr:er, sc:ec] = False\n    border = gray[mask]\n    if border.size == 0:\n        return float(np.mean(center) + eps)\n    return float((np.mean(center) + eps) / (np.mean(border) + eps))\n\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Mean blue divided by blue std in the top quarter (high when top is uniformly blue)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    img = image.astype(float)\n    h, w = img.shape[:2]\n    top_h = max(1, h // 4)\n    if img.ndim == 2:\n        B = img[:top_h, :].astype(float)\n        global_mean = float(np.mean(img) + eps)\n    else:\n        B = img[:top_h, :, 2].astype(float)\n        global_mean = float(np.mean(img) + eps)\n    if B.size == 0:\n        return 0.0\n    meanB = float(np.mean(B))\n    stdB = float(np.std(B))\n    # Higher when mean blue large but variation small; normalize by global mean\n    return float((meanB / (stdB + eps)) / (global_mean + eps))\n\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Fraction of pixels in lower quarter that are green-dominant and chromatic (vegetation patches)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    img = image.astype(float)\n    h = img.shape[0]\n    start = (3 * h) // 4\n    if img.ndim == 2:\n        r = g = b = img[start:, :].astype(float)\n    else:\n        r = img[start:, :, 0].astype(float)\n        g = img[start:, :, 1].astype(float)\n        b = img[start:, :, 2].astype(float)\n    if g.size == 0:\n        return 0.0\n    mx = np.maximum(np.maximum(r, g), b)\n    mn = np.minimum(np.minimum(r, g), b)\n    chroma = mx - mn\n    mean_chroma = float(np.mean(chroma) + eps)\n    mask = (g > r + 5.0) & (g > b + 5.0) & (chroma > (0.08 * (mx + eps)))\n    return float(np.count_nonzero(mask) / (g.size + eps))\n\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Fraction of near-white bright pixels (specular highlights / sun glints) in image'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    img = image.astype(float)\n    if img.ndim == 2:\n        r = g = b = img\n    else:\n        r = img[:, :, 0]\n        g = img[:, :, 1]\n        b = img[:, :, 2]\n    bright = (r + g + b) / 3.0\n    mx = np.maximum(np.maximum(r, g), b) + eps\n    mn = np.minimum(np.minimum(r, g), b)\n    chroma = mx - mn\n    mean_b = float(np.mean(bright))\n    std_b = float(np.std(bright) + eps)\n    # highlight: much brighter than average and low chroma (close to white)\n    mask = (bright > (mean_b + 1.5 * std_b)) & (chroma / mx < 0.12)\n    return float(np.count_nonzero(mask) / (bright.size + eps))\n\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Colorfulness index (Hasler-S\u00fcsstrunk style) normalized to 0..1'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    img = image.astype(float)\n    if img.ndim == 2:\n        R = G = B = img\n    else:\n        R = img[:, :, 0]\n        G = img[:, :, 1]\n        B = img[:, :, 2]\n    rg = R - G\n    yb = 0.5 * (R + G) - B\n    std_rg = float(np.std(rg))\n    std_yb = float(np.std(yb))\n    mean_rg = float(np.mean(np.abs(rg)))\n    mean_yb = float(np.mean(np.abs(yb)))\n    colorfulness = np.sqrt(std_rg * std_rg + std_yb * std_yb) + 0.3 * (mean_rg + mean_yb)\n    # normalize by typical 8-bit scale\n    norm = 255.0 + eps\n    return float(colorfulness / norm)\n\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Entropy of coarse 4x4x4 RGB quantization (color diversity, 0..1)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    img = image.astype(int)\n    h, w = img.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if img.ndim == 2:\n        R = G = B = img\n    else:\n        R = img[:, :, 0]\n        G = img[:, :, 1]\n        B = img[:, :, 2]\n    # quantize each channel into 4 levels (0..3)\n    qr = (R // 64).clip(0, 3).ravel()\n    qg = (G // 64).clip(0, 3).ravel()\n    qb = (B // 64).clip(0, 3).ravel()\n    bins = (qr * 16 + qg * 4 + qb).astype(int)\n    hist = np.bincount(bins, minlength=64).astype(float)\n    total = hist.sum() + eps\n    probs = hist / total\n    probs_nonzero = probs[probs > 0]\n    ent = -np.sum(probs_nonzero * np.log(probs_nonzero + eps))\n    norm = np.log(64.0) + eps\n    return float(ent / norm)\n\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Normalized vertical position of the brightest pixel (0=top, 1=bottom)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if image.ndim == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    h = gray.shape[0]\n    if gray.size == 0 or h == 0:\n        return 0.0\n    idx = np.argmax(gray)\n    row = int(idx // gray.shape[1])\n    return float(row / (h - 1 + eps))\n\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Fraction of pixels within a small distance of the dominant coarse color (uniform-area measure)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    img = image.astype(float)\n    h, w = img.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if img.ndim == 2:\n        R = G = B = img\n    else:\n        R = img[:, :, 0]\n        G = img[:, :, 1]\n        B = img[:, :, 2]\n    # coarse quantization to find dominant bin\n    qr = (R // 64).clip(0, 3).ravel().astype(int)\n    qg = (G // 64).clip(0, 3).ravel().astype(int)\n    qb = (B // 64).clip(0, 3).ravel().astype(int)\n    bins = qr * 16 + qg * 4 + qb\n    if bins.size == 0:\n        return 0.0\n    domin = int(np.bincount(bins).argmax())\n    dr = (domin // 16)\n    dg = (domin % 16) // 4\n    db = (domin % 4)\n    # representative color center for that bin\n    center_color = np.array([dr * 64 + 32, dg * 64 + 32, db * 64 + 32], dtype=float)\n    colors = np.stack([R.ravel(), G.ravel(), B.ravel()], axis=1)\n    dists = np.linalg.norm(colors - center_color[None, :], axis=1)\n    thresh = 30.0  # pixels within ~30 intensity are considered same region\n    return float(np.count_nonzero(dists <= thresh) / (dists.size + eps))\n",
  "def feature(image: np.ndarray) -> float:\n    'Fraction of pixels in the top quarter that are blue-dominant (B>G and B>R and above local mean)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    img = image.astype(float)\n    if img.ndim == 2:\n        rgb = np.stack([img, img, img], axis=2)\n    else:\n        rgb = img\n    h, w = rgb.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    top = rgb[0:max(1, h // 4), :, :]\n    if top.size == 0:\n        return 0.0\n    R = top[:, :, 0]\n    G = top[:, :, 1]\n    B = top[:, :, 2]\n    thr = np.mean(B)\n    mask = (B > G) & (B > R) & (B >= thr)\n    return float(np.count_nonzero(mask) / (mask.size + eps))\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Difference between bottom-quarter and top-quarter blue-dominant pixel fractions (bottom - top)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    img = image.astype(float)\n    if img.ndim == 2:\n        rgb = np.stack([img, img, img], axis=2)\n    else:\n        rgb = img\n    h, w = rgb.shape[:2]\n    if h < 2:\n        return 0.0\n    q = max(1, h // 4)\n    top = rgb[0:q, :, :]\n    bottom = rgb[h - q:h, :, :]\n    def frac_blue(region):\n        if region.size == 0:\n            return 0.0\n        R = region[:, :, 0]; G = region[:, :, 1]; B = region[:, :, 2]\n        thr = np.mean(B)\n        mask = (B > G) & (B > R) & (B >= thr)\n        return float(np.count_nonzero(mask) / (mask.size + eps))\n    return float(frac_blue(bottom) - frac_blue(top))\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Vertical reflection symmetry score between top and flipped bottom halves (higher = more symmetric)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    img = image.astype(float)\n    if img.ndim == 3:\n        gray = np.mean(img, axis=2)\n    else:\n        gray = img\n    h, w = gray.shape[:2]\n    if h < 2 or w == 0:\n        return 0.0\n    mid = h // 2\n    top = gray[0:mid, :] \n    bottom = gray[h - mid:h, :]\n    if top.size == 0 or bottom.size == 0:\n        return 0.0\n    bottom_flip = np.flipud(bottom)\n    # align sizes if odd\n    min_rows = min(top.shape[0], bottom_flip.shape[0])\n    top_crop = top[:min_rows, :]\n    bot_crop = bottom_flip[:min_rows, :]\n    diff = np.mean(np.abs(top_crop - bot_crop))\n    mean_int = np.mean(gray) + eps\n    norm_diff = diff / mean_int\n    score = 1.0 / (1.0 + norm_diff)\n    return float(score)\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Variance of the image Laplacian (sharpness/detail) normalized by mean intensity'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    img = image.astype(float)\n    if img.ndim == 3:\n        gray = np.mean(img, axis=2)\n    else:\n        gray = img\n    if gray.size == 0:\n        return 0.0\n    gy, gx = np.gradient(gray)\n    gyy, _ = np.gradient(gy)\n    _, gxx = np.gradient(gx)\n    lap = gxx + gyy\n    var_lap = np.var(lap)\n    mean_int = np.mean(np.abs(gray)) + eps\n    return float(var_lap / (mean_int + eps))\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Color-temperature proxy: normalized mean red minus mean blue (positive = warmer)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    img = image.astype(float)\n    if img.ndim == 2:\n        rgb = np.stack([img, img, img], axis=2)\n    else:\n        rgb = img\n    if rgb.size == 0:\n        return 0.0\n    meanR = float(np.mean(rgb[:, :, 0]))\n    meanB = float(np.mean(rgb[:, :, 2]))\n    meanInt = float(np.mean((rgb[:, :, 0] + rgb[:, :, 1] + rgb[:, :, 2]) / 3.0) + eps)\n    return float((meanR - meanB) / (meanInt + eps))\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Normalized entropy of the grayscale intensity histogram (0..1)'\n    import numpy as np\n    eps = 1e-8\n    bins = 16\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    img = image.astype(float)\n    if img.ndim == 3:\n        gray = np.mean(img, axis=2)\n    else:\n        gray = img\n    flat = gray.flatten()\n    if flat.size == 0:\n        return 0.0\n    hist, _ = np.histogram(flat, bins=bins, density=False)\n    p = hist.astype(float) / (np.sum(hist) + eps)\n    ent = -np.sum(np.where(p > 0, p * np.log(p + eps), 0.0))\n    # normalize by log(bins)\n    norm = ent / (np.log(bins) + eps)\n    return float(norm)\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Fraction of pixels that are both high-blue (>=90th percentile) and blue-dominant'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    img = image.astype(float)\n    if img.ndim == 2:\n        rgb = np.stack([img, img, img], axis=2)\n    else:\n        rgb = img\n    B = rgb[:, :, 2]\n    R = rgb[:, :, 0]\n    G = rgb[:, :, 1]\n    if B.size == 0:\n        return 0.0\n    thr = float(np.percentile(B.flatten(), 90))\n    mask = (B >= thr) & (B > R) & (B > G)\n    return float(np.count_nonzero(mask) / (mask.size + eps))\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Proportion of edges whose orientation is near-horizontal (|angle|<15\u00b0), using gradients'\n    import numpy as np\n    eps = 1e-8\n    ang_tol = np.deg2rad(15.0)\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    img = image.astype(float)\n    if img.ndim == 3:\n        gray = np.mean(img, axis=2)\n    else:\n        gray = img\n    if gray.size == 0:\n        return 0.0\n    gy, gx = np.gradient(gray)\n    mag = np.sqrt(gx * gx + gy * gy)\n    strong = mag > (np.percentile(mag.flatten(), 50) * 0.25)  # consider at least some edge strength\n    if np.count_nonzero(strong) == 0:\n        return 0.0\n    angle = np.arctan2(gy, gx)  # -pi..pi\n    # horizontal if angle near 0 or pi (sin(angle) near 0)\n    horiz_mask = np.abs(np.sin(angle)) <= np.sin(ang_tol)\n    mask = strong & horiz_mask\n    return float(np.count_nonzero(mask) / (np.count_nonzero(strong) + eps))\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Bounding-box occupancy * aspect ratio of high-chroma region (captures subject size and shape)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    img = image.astype(float)\n    if img.ndim == 2:\n        rgb = np.stack([img, img, img], axis=2)\n    else:\n        rgb = img\n    h, w = rgb.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    mx = np.max(rgb, axis=2)\n    mn = np.min(rgb, axis=2)\n    chroma = mx - mn\n    thr = float(np.percentile(chroma.flatten(), 70))\n    mask = chroma >= thr\n    if not np.any(mask):\n        return 0.0\n    ys, xs = np.where(mask)\n    miny, maxy = np.min(ys), np.max(ys)\n    minx, maxx = np.min(xs), np.max(xs)\n    bbox_h = maxy - miny + 1\n    bbox_w = maxx - minx + 1\n    bbox_area = bbox_h * bbox_w\n    img_area = h * w\n    area_ratio = float(bbox_area) / (img_area + eps)\n    aspect = float(bbox_h) / (bbox_w + eps)\n    # combine so that both size and shape matter, scale to reasonable range\n    return float(area_ratio * aspect)\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Bottom-center green minus blue contrast (vegetation vs water) normalized by local intensity'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    img = image.astype(float)\n    if img.ndim == 2:\n        rgb = np.stack([img, img, img], axis=2)\n    else:\n        rgb = img\n    h, w = rgb.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    r0 = (2 * h) // 3\n    c0 = w // 4\n    region = rgb[r0:h, c0: max(c0 + 1, 3 * w // 4), :]\n    if region.size == 0:\n        return 0.0\n    meanG = float(np.mean(region[:, :, 1]))\n    meanB = float(np.mean(region[:, :, 2]))\n    meanInt = float(np.mean((region[:, :, 0] + region[:, :, 1] + region[:, :, 2]) / 3.0) + eps)\n    return float((meanG - meanB) / (meanInt + eps))\n",
  "def feature(image: np.ndarray) -> float:\n    'Normalized difference of mean blue between top and bottom halves (sky indicator)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    img = image.astype(float)\n    if img.ndim == 2:\n        rgb = np.stack([img, img, img], axis=2)\n    else:\n        rgb = img\n    h, w = rgb.shape[:2]\n    mid = h // 2\n    top = rgb[:mid, :, :] if mid > 0 else np.zeros((0, w, 3))\n    bottom = rgb[mid:, :, :] if h - mid > 0 else np.zeros((0, w, 3))\n    meanB_top = float(np.mean(top[:, :, 2])) if top.size else 0.0\n    meanB_bottom = float(np.mean(bottom[:, :, 2])) if bottom.size else 0.0\n    return float((meanB_top - meanB_bottom) / (meanB_top + meanB_bottom + eps))\n\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Fraction of vertical-edge energy located in the bottom half (ground texture bias)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    arr = image.astype(float)\n    if arr.ndim == 3:\n        gray = np.mean(arr, axis=2)\n    else:\n        gray = arr\n    h = gray.shape[0]\n    if h == 0 or gray.size == 0:\n        return 0.0\n    gy, gx = np.gradient(gray)\n    vert_energy = np.abs(gx)\n    mid = h // 2\n    top_sum = float(np.sum(vert_energy[:mid, :]))\n    bottom_sum = float(np.sum(vert_energy[mid:, :]))\n    return float(bottom_sum / (top_sum + bottom_sum + eps))\n\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Row index of peak mean green normalized by image height (vegetation vertical placement)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.5\n    img = image.astype(float)\n    if img.ndim == 2:\n        green = img\n    else:\n        green = img[:, :, 1]\n    h = green.shape[0]\n    if h == 0 or green.size == 0:\n        return 0.5\n    row_means = np.mean(green, axis=1)\n    peak_row = int(np.argmax(row_means))\n    denom = max(1, h - 1)\n    return float(peak_row / float(denom))\n\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Ratio of mean absolute horizontal gradient to mean absolute vertical gradient (texture orientation)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 1.0\n    arr = image.astype(float)\n    if arr.ndim == 3:\n        gray = np.mean(arr, axis=2)\n    else:\n        gray = arr\n    if gray.size == 0:\n        return 1.0\n    gy, gx = np.gradient(gray)\n    mean_horiz = float(np.mean(np.abs(gx)))\n    mean_vert = float(np.mean(np.abs(gy)))\n    return float(mean_horiz / (mean_vert + eps))\n\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Fraction of non-overlapping patches with high local variance (texture density)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    img = image.astype(float)\n    if img.ndim == 3:\n        gray = np.mean(img, axis=2)\n    else:\n        gray = img\n    h, w = gray.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    # choose patch size proportional to image\n    ph = max(8, h // 8)\n    pw = max(8, w // 8)\n    vars_list = []\n    for r in range(0, h, ph):\n        for c in range(0, w, pw):\n            patch = gray[r:min(r + ph, h), c:min(c + pw, w)]\n            if patch.size:\n                vars_list.append(float(np.var(patch)))\n    if len(vars_list) == 0:\n        return 0.0\n    patch_vars = np.array(vars_list)\n    global_var = float(np.var(gray))\n    threshold = max(global_var * 0.6, eps)\n    high_count = int(np.count_nonzero(patch_vars > threshold))\n    return float(high_count / max(1, patch_vars.size))\n\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Area ratio of the bounding box of bright pixels (extent of bright subject)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    img = image.astype(float)\n    if img.ndim == 3:\n        gray = np.mean(img, axis=2)\n    else:\n        gray = img\n    h, w = gray.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    mean = float(np.mean(gray))\n    std = float(np.std(gray))\n    thresh = mean + std\n    mask = gray > thresh\n    if not np.any(mask):\n        return 0.0\n    rows = np.any(mask, axis=1)\n    cols = np.any(mask, axis=0)\n    rmin = int(np.argmax(rows))\n    rmax = int(len(rows) - 1 - np.argmax(rows[::-1]))\n    cmin = int(np.argmax(cols))\n    cmax = int(len(cols) - 1 - np.argmax(cols[::-1]))\n    bbox_area = float((rmax - rmin + 1) * (cmax - cmin + 1))\n    total_area = float(h * w) + eps\n    return float(bbox_area / total_area)\n\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Simple color temperature score: (meanR - meanB) / (meanR + meanB) (warm vs cool)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    img = image.astype(float)\n    if img.ndim == 2:\n        rgb = np.stack([img, img, img], axis=2)\n    else:\n        rgb = img\n    meanR = float(np.mean(rgb[:, :, 0]))\n    meanB = float(np.mean(rgb[:, :, 2]))\n    return float((meanR - meanB) / (meanR + meanB + eps))\n\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Relative edge energy in the central vertical strip compared to the whole image'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    arr = image.astype(float)\n    if arr.ndim == 3:\n        gray = np.mean(arr, axis=2)\n    else:\n        gray = arr\n    h, w = gray.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    gy, gx = np.gradient(gray)\n    mag = np.sqrt(gx * gx + gy * gy)\n    strip_w = max(1, w // 6)\n    mid = w // 2\n    c0 = max(0, mid - strip_w // 2)\n    c1 = min(w, c0 + strip_w)\n    strip_mag = mag[:, c0:c1]\n    mean_strip = float(np.mean(strip_mag)) if strip_mag.size else 0.0\n    mean_all = float(np.mean(mag)) + eps\n    return float(mean_strip / mean_all)\n\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Vertical symmetry score (1 = perfectly symmetric, 0 = very asymmetric)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.5\n    arr = image.astype(float)\n    if arr.ndim == 3:\n        gray = np.mean(arr, axis=2)\n    else:\n        gray = arr\n    h, w = gray.shape[:2]\n    if h == 0 or w == 0:\n        return 0.5\n    mid = w // 2\n    left = gray[:, :mid]\n    right = gray[:, w - mid:] if mid > 0 else np.zeros_like(left)\n    # make same width\n    minw = min(left.shape[1], right.shape[1]) if left.size and right.size else 0\n    if minw == 0:\n        return 0.5\n    left_c = left[:, :minw]\n    right_c = right[:, -minw:]\n    right_flipped = np.fliplr(right_c)\n    diff = np.abs(left_c - right_flipped)\n    norm = float(np.mean(np.abs(gray)) + eps)\n    score = 1.0 - float(np.mean(diff) / norm)\n    # clamp to [0,1]\n    return float(max(0.0, min(1.0, score)))\n\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Proportion of pixels in the largest quantized RGB bin (dominant color fraction)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    img = image.astype(np.int32)\n    h, w = img.shape[:2]\n    total = int(max(1, h * w))\n    if img.ndim == 2:\n        r = (img // 32).astype(np.int32).flatten()\n        g = r\n        b = r\n    else:\n        r = (img[:, :, 0] // 32).astype(np.int32).flatten()\n        g = (img[:, :, 1] // 32).astype(np.int32).flatten()\n        b = (img[:, :, 2] // 32).astype(np.int32).flatten()\n    codes = (r << 6) | (g << 3) | b\n    # bins 0..511\n    counts = np.bincount(codes, minlength=512)\n    max_count = int(np.max(counts)) if counts.size else 0\n    return float(max_count / float(total + eps))\n",
  "def feature(image: np.ndarray) -> float:\n    'Fraction of strong horizontal edges (horizontal-edge pixels proportion)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    # convert to grayscale float\n    if image.ndim == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    if gray.size == 0:\n        return 0.0\n    gy, gx = np.gradient(gray)\n    abs_gx = np.abs(gx)\n    abs_gy = np.abs(gy)\n    mag = np.sqrt(abs_gx**2 + abs_gy**2)\n    mean_mag = np.mean(mag) if mag.size else 0.0\n    std_mag = np.std(mag) if mag.size else 0.0\n    thr = mean_mag + 0.5 * std_mag\n    strong_horiz = (abs_gy > abs_gx) & (abs_gy > thr)\n    return float(np.count_nonzero(strong_horiz) / (mag.size + eps))\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Correlation of column-wise mean blue between top and bottom quarters (reflection proxy)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    img = image.astype(float)\n    if img.ndim == 2:\n        # replicate grayscale to pseudo-RGB so blue exists\n        img = np.stack([img, img, img], axis=2)\n    h, w = img.shape[:2]\n    if h < 4 or w == 0:\n        return 0.0\n    top = img[:h//4, :, 2]  # blue channel\n    bottom = img[3*h//4:, :, 2]\n    if top.size == 0 or bottom.size == 0:\n        return 0.0\n    top_col = np.mean(top, axis=0)\n    bottom_col = np.mean(bottom, axis=0)\n    # compute correlation safely\n    top_mean = np.mean(top_col)\n    bottom_mean = np.mean(bottom_col)\n    top_centered = top_col - top_mean\n    bottom_centered = bottom_col - bottom_mean\n    denom = (np.sqrt(np.sum(top_centered**2)) * np.sqrt(np.sum(bottom_centered**2))) + eps\n    corr = np.sum(top_centered * bottom_centered) / denom\n    # clamp to [-1,1]\n    corr = max(-1.0, min(1.0, corr))\n    return float(corr)\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Fraction of pixels dominated by green (vegetation proxy)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    img = image.astype(float)\n    if img.ndim == 2:\n        # grayscale has no green dominance\n        return 0.0\n    r = img[:, :, 0]\n    g = img[:, :, 1]\n    b = img[:, :, 2]\n    brightness = (r + g + b) / 3.0\n    mean_b = float(np.mean(brightness)) if brightness.size else 0.0\n    mask = (g > 1.05 * r) & (g > 1.05 * b) & (brightness > mean_b * 0.6)\n    total = float(g.size) + eps\n    return float(np.count_nonzero(mask) / total)\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Variance of Laplacian (global focus/texture measure)'\n    import numpy as np\n    eps = 1e-12\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if image.ndim == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    if gray.size == 0:\n        return 0.0\n    gy, gx = np.gradient(gray)\n    gyy, _ = np.gradient(gy)\n    _, gxx = np.gradient(gx)\n    lap = gxx + gyy\n    var_lap = np.var(lap)\n    return float(var_lap + eps)\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Center-region red minus blue normalized by center brightness (warmth in center)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    img = image.astype(float)\n    h, w = img.shape[:2]\n    sr, sc = h // 4, w // 4\n    er, ec = h - sr, w - sc\n    if img.ndim == 2:\n        center = img[sr:er, sc:ec] if (er > sr and ec > sc) else img\n        # grayscale: no red-blue difference\n        return 0.0\n    center = img[sr:er, sc:ec, :] if (er > sr and ec > sc) else img\n    if center.size == 0:\n        return 0.0\n    r = center[:, :, 0]\n    b = center[:, :, 2]\n    bright = np.mean(np.mean(center, axis=2)) + eps\n    return float((np.mean(r) - np.mean(b)) / bright)\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Fraction of sky/sea-blue pixels in the upper third of the image'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    img = image.astype(float)\n    h = img.shape[0]\n    if h == 0:\n        return 0.0\n    upper = img[:max(1, h // 3), ...]\n    if upper.size == 0:\n        return 0.0\n    if upper.ndim == 3:\n        r = upper[:, :, 0]\n        g = upper[:, :, 1]\n        b = upper[:, :, 2]\n        brightness = (r + g + b) / 3.0\n        mean_bright = float(np.mean(brightness)) if brightness.size else 0.0\n        mask = (b > 1.15 * g) & (b > 1.15 * r) & (brightness > mean_bright * 0.9)\n        total = float(b.size) + eps\n        return float(np.count_nonzero(mask) / total)\n    else:\n        return 0.0\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Relative darkness of center vs outer region (outer_mean - center_mean) / overall_mean'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if image.ndim == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    sr, sc = h // 4, w // 4\n    er, ec = h - sr, w - sc\n    if er <= sr or ec <= sc:\n        center = gray\n        outer = np.array([])\n    else:\n        center = gray[sr:er, sc:ec]\n        outer_mask = np.ones_like(gray, dtype=bool)\n        outer_mask[sr:er, sc:ec] = False\n        outer = gray[outer_mask]\n    center_mean = float(np.mean(center)) if center.size else 0.0\n    outer_mean = float(np.mean(outer)) if outer.size else center_mean\n    overall = float(np.mean(gray)) + eps\n    return float((outer_mean - center_mean) / overall)\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Normalized brightness difference between top third and bottom third'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    img = image.astype(float)\n    h = img.shape[0]\n    if h < 3:\n        # fallback to global brightness variance\n        if img.ndim == 3:\n            return float(np.std(np.mean(img, axis=2)))\n        else:\n            return float(np.std(img))\n    top = img[:h//3, ...]\n    bottom = img[2*h//3:, ...]\n    if top.size == 0 or bottom.size == 0:\n        return 0.0\n    if img.ndim == 3:\n        top_b = np.mean(top, axis=2)\n        bot_b = np.mean(bottom, axis=2)\n    else:\n        top_b = top\n        bot_b = bottom\n    top_mean = float(np.mean(top_b))\n    bot_mean = float(np.mean(bot_b))\n    overall = float(np.mean(np.mean(img, axis=2) if img.ndim == 3 else img)) + eps\n    return float(abs(top_mean - bot_mean) / overall)\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Euclidean color distance between central region mean and outer-region mean normalized by overall brightness'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    img = image.astype(float)\n    h, w = img.shape[:2]\n    if img.ndim == 2:\n        rgb = np.stack([img, img, img], axis=2)\n    else:\n        rgb = img\n    sr, sc = h // 4, w // 4\n    er, ec = h - sr, w - sc\n    if er <= sr or ec <= sc:\n        center = rgb\n        outer = np.zeros((0, 3))\n    else:\n        center = rgb[sr:er, sc:ec, :]\n        outer_mask = np.ones((h, w), dtype=bool)\n        outer_mask[sr:er, sc:ec] = False\n        outer = rgb[outer_mask, :]\n    if center.size == 0:\n        return 0.0\n    center_mean = np.mean(center.reshape(-1, 3), axis=0)\n    outer_mean = np.mean(outer.reshape(-1, 3), axis=0) if outer.size else center_mean\n    dist = np.linalg.norm(center_mean - outer_mean)\n    overall_brightness = float(np.mean(np.mean(rgb, axis=2))) + eps\n    return float(dist / overall_brightness)\n",
  "def feature(image: np.ndarray) -> float:\n    'Fraction of pixels in the lower half that are blue-dominant (blue > red/green by margin)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if image.ndim == 2:\n        return 0.0\n    rgb = image.astype(float)\n    h, w = rgb.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    R = rgb[:, :, 0]\n    G = rgb[:, :, 1]\n    B = rgb[:, :, 2]\n    scale = max(np.max(rgb) - np.min(rgb), eps)\n    thr = 0.10 * scale\n    lower = slice(h // 2, h)\n    blue_dom = (B > R + thr) & (B > G + thr)\n    lower_count = np.count_nonzero(blue_dom[lower, :])\n    lower_area = float(max(1, (h - h // 2) * w))\n    return float(lower_count / lower_area)\n\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Ratio of blue-dominant fraction in lower half to that in upper half (water often lower)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if image.ndim == 2:\n        return 0.0\n    rgb = image.astype(float)\n    h, w = rgb.shape[:2]\n    if h < 2 or w == 0:\n        return 0.0\n    R = rgb[:, :, 0]\n    G = rgb[:, :, 1]\n    B = rgb[:, :, 2]\n    scale = max(np.max(rgb) - np.min(rgb), eps)\n    thr = 0.10 * scale\n    blue_dom = (B > R + thr) & (B > G + thr)\n    upper_count = np.count_nonzero(blue_dom[:h // 2, :])\n    lower_count = np.count_nonzero(blue_dom[h // 2:, :])\n    upper_area = float(max(1, (h // 2) * w))\n    lower_area = float(max(1, (h - h // 2) * w))\n    frac_upper = upper_count / upper_area\n    frac_lower = lower_count / lower_area\n    return float(frac_lower / (frac_upper + eps))\n\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Normalized center vs border brightness contrast (center mean minus border mean)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    img = image.astype(float)\n    if img.ndim == 3:\n        gray = np.mean(img, axis=2)\n    else:\n        gray = img\n    h, w = gray.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    sr, sc = h // 4, w // 4\n    er, ec = h - sr, w - sc\n    if er <= sr or ec <= sc:\n        center = gray\n        border = gray\n    else:\n        center = gray[sr:er, sc:ec]\n        mask = np.ones_like(gray, dtype=bool)\n        mask[sr:er, sc:ec] = False\n        border = gray[mask]\n        if border.size == 0:\n            border = gray\n    mean_center = float(np.mean(center)) if center.size else 0.0\n    mean_border = float(np.mean(border)) if border.size else 0.0\n    overall = float(np.mean(gray)) + eps\n    return float((mean_center - mean_border) / overall)\n\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Variance of the image Laplacian (higher for detailed/sharp scenes)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if image.ndim == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    if gray.size == 0:\n        return 0.0\n    gy, gx = np.gradient(gray)\n    gyy, _ = np.gradient(gy)\n    _, gxx = np.gradient(gx)\n    lap = gxx + gyy\n    return float(np.var(lap) / (np.mean(np.abs(lap)) + eps))\n\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Normalized histogram entropy of grayscale intensities (scene complexity)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if image.ndim == 3:\n        gray = np.mean(image.astype(float), axis=2).flatten()\n    else:\n        gray = image.astype(float).flatten()\n    if gray.size == 0:\n        return 0.0\n    bins = 16\n    hist, _ = np.histogram(gray, bins=bins, range=(np.min(gray), np.max(gray) + eps))\n    probs = hist.astype(float) / float(max(1, np.sum(hist)))\n    probs = probs + eps\n    entropy = -float(np.sum(probs * np.log(probs)))\n    max_entropy = np.log(bins)\n    return float(entropy / (max_entropy + eps))\n\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Mean normalized (blue - green) chroma: positive = bluish, negative = greenish'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if image.ndim == 2:\n        return 0.0\n    rgb = image.astype(float)\n    B = rgb[:, :, 2]\n    G = rgb[:, :, 1]\n    denom = (B + G) + eps\n    val = (B - G) / denom\n    if val.size == 0:\n        return 0.0\n    return float(np.mean(val))\n\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Vertical position (0..1) of the centroid of the top 5% brightest pixels (1=bottom)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.5\n    if image.ndim == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    flat = gray.flatten()\n    if flat.size == 0:\n        return 0.5\n    pct = 95\n    thr = np.percentile(flat, pct)\n    mask = gray >= thr\n    if np.count_nonzero(mask) == 0:\n        return 0.5\n    ys, xs = np.nonzero(mask)\n    mean_y = float(np.mean(ys))\n    return float(mean_y / max(1, h - 1))\n\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Fraction of strong gradient pixels that lie inside the central vertical band (vertical object cue)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if image.ndim == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    if gray.size == 0:\n        return 0.0\n    gy, gx = np.gradient(gray)\n    mag = np.sqrt(gx * gx + gy * gy)\n    thr = np.percentile(mag, 75) + eps\n    strong = mag > thr\n    sc, ec = w // 4, w - w // 4\n    band = strong[:, sc:ec] if (ec > sc) else strong\n    total_strong = float(np.count_nonzero(strong))\n    if total_strong == 0.0:\n        return 0.0\n    return float(np.count_nonzero(band) / (total_strong + eps))\n\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Aspect ratio (width/height) of the bounding box of high-saturation pixels in center'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    img = image.astype(float)\n    if img.ndim == 2:\n        return 0.0\n    h, w = img.shape[:2]\n    sr, sc = h // 4, w // 4\n    er, ec = h - sr, w - sc\n    region = img[sr:er, sc:ec, :] if (er > sr and ec > sc) else img\n    if region.size == 0:\n        return 0.0\n    r = region[:, :, 0].flatten()\n    g = region[:, :, 1].flatten()\n    b = region[:, :, 2].flatten()\n    mx = np.maximum(np.maximum(r, g), b)\n    mn = np.minimum(np.minimum(r, g), b)\n    sat = (mx - mn) / (mx + eps)\n    mask2d = sat.reshape(region.shape[0], region.shape[1]) > 0.25\n    if np.count_nonzero(mask2d) == 0:\n        return 0.0\n    ys, xs = np.nonzero(mask2d)\n    miny, maxy = int(np.min(ys)), int(np.max(ys))\n    minx, maxx = int(np.min(xs)), int(np.max(xs))\n    bw = maxx - minx + 1\n    bh = maxy - miny + 1\n    if bh <= 0:\n        return 0.0\n    return float((bw / float(bh)))\n\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Fraction of central-region pixels with very low local 3x3 standard deviation (smoothness)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if image.ndim == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    if gray.size == 0 or h < 3 or w < 3:\n        return 0.0\n    pad = np.pad(gray, 1, mode='reflect')\n    # sum of 3x3 neighborhoods via shifted slices\n    s = (pad[0:-2, 0:-2] + pad[0:-2, 1:-1] + pad[0:-2, 2:] +\n         pad[1:-1, 0:-2] + pad[1:-1, 1:-1] + pad[1:-1, 2:] +\n         pad[2:, 0:-2] + pad[2:, 1:-1] + pad[2:, 2:])\n    sq = (pad[0:-2, 0:-2]**2 + pad[0:-2, 1:-1]**2 + pad[0:-2, 2:]**2 +\n          pad[1:-1, 0:-2]**2 + pad[1:-1, 1:-1]**2 + pad[1:-1, 2:]**2 +\n          pad[2:, 0:-2]**2 + pad[2:, 1:-1]**2 + pad[2:, 2:]**2)\n    mean9 = s / 9.0\n    mean_sq9 = sq / 9.0\n    var9 = mean_sq9 - mean9 * mean9\n    std9 = np.sqrt(np.maximum(var9, 0.0))\n    # central region\n    sr, sc = h // 4, w // 4\n    er, ec = h - sr, w - sc\n    if er <= sr or ec <= sc:\n        region_std = std9\n    else:\n        region_std = std9[sr:er, sc:ec]\n    if region_std.size == 0:\n        return 0.0\n    scale = max(np.max(gray) - np.min(gray), eps)\n    thr = 0.03 * scale\n    smooth_frac = float(np.count_nonzero(region_std < thr)) / float(region_std.size)\n    return float(smooth_frac)\n",
  "def feature(image: np.ndarray) -> float:\n    'Normalized green minus blue mean in the central region (positive -> greener center)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    img = image.astype(float)\n    if img.ndim == 2:\n        rgb = np.stack([img, img, img], axis=2)\n    else:\n        rgb = img\n    h, w = rgb.shape[:2]\n    sr, sc = h // 4, w // 4\n    er, ec = h - sr, w - sc\n    region = rgb[sr:er, sc:ec, :] if (er > sr and ec > sc) else rgb\n    if region.size == 0:\n        return 0.0\n    meanG = float(np.mean(region[:, :, 1]))\n    meanB = float(np.mean(region[:, :, 2]))\n    return float((meanG - meanB) / (meanG + meanB + eps))\n\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Fraction of warm (reddish) pixels in the lower half'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    img = image.astype(float)\n    if img.ndim == 2:\n        rgb = np.stack([img, img, img], axis=2)\n    else:\n        rgb = img\n    h = rgb.shape[0]\n    region = rgb[h//2:, :, :].reshape(-1, 3)\n    if region.size == 0:\n        return 0.0\n    r, g, b = region[:, 0], region[:, 1], region[:, 2]\n    mx = np.maximum(np.maximum(r, g), b)\n    mn = np.minimum(np.minimum(r, g), b)\n    chroma = mx - mn\n    dyn = np.max(mx) - np.min(mn) + eps\n    mask = (r > 1.05 * g) & (r > 1.05 * b) & (chroma > 0.05 * dyn)\n    return float(np.count_nonzero(mask) / (region.shape[0] + eps))\n\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Edge density in a central vertical strip (fraction of strong gradient pixels)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    arr = image.astype(float)\n    if arr.ndim == 3:\n        gray = np.mean(arr, axis=2)\n    else:\n        gray = arr\n    h, w = gray.shape[:2]\n    sw = max(1, int(w * 0.20))\n    c0 = max(0, (w - sw) // 2)\n    c1 = min(w, c0 + sw)\n    strip = gray[:, c0:c1]\n    if strip.size == 0:\n        return 0.0\n    gy, gx = np.gradient(strip)\n    mag = np.sqrt(gx * gx + gy * gy)\n    thr = np.mean(mag) + np.std(mag)\n    strong = np.count_nonzero(mag > thr)\n    total = float(mag.size) + eps\n    return float(strong / total)\n\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Circular variance of approximate hue (0=all same hue, 1=uniformly varied)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 1.0\n    img = image.astype(float)\n    if img.ndim == 2:\n        rgb = np.stack([img, img, img], axis=2)\n    else:\n        rgb = img\n    r = rgb[:, :, 0].flatten()\n    g = rgb[:, :, 1].flatten()\n    b = rgb[:, :, 2].flatten()\n    mx = np.maximum(np.maximum(r, g), b)\n    mn = np.minimum(np.minimum(r, g), b)\n    chroma = mx - mn\n    mask = chroma > (np.max(mx) - np.min(mn)) * 1e-3\n    if not np.any(mask):\n        return 0.0\n    r_, g_, b_ = r[mask], g[mask], b[mask]\n    # approximate hue angle from RGB (robust algebraic form)\n    angles = np.arctan2(np.sqrt(3.0) * (g_ - b_), 2.0 * r_ - g_ - b_)\n    cosm = np.mean(np.cos(angles))\n    sinm = np.mean(np.sin(angles))\n    R = np.sqrt(cosm * cosm + sinm * sinm)\n    circ_var = 1.0 - R\n    return float(circ_var)\n\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Standard deviation of blue channel in the top third normalized by mean blue (lower -> smooth sky/water)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    img = image.astype(float)\n    if img.ndim == 2:\n        rgb = np.stack([img, img, img], axis=2)\n    else:\n        rgb = img\n    h = rgb.shape[0]\n    th = max(1, h // 3)\n    top = rgb[:th, :, 2]\n    if top.size == 0:\n        return 0.0\n    std_top = float(np.std(top))\n    mean_top = float(np.mean(top)) + eps\n    return float(std_top / mean_top)\n\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Normalized left-right symmetry error in intensity (0=perfect symmetry)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    arr = image.astype(float)\n    if arr.ndim == 3:\n        gray = np.mean(arr, axis=2)\n    else:\n        gray = arr\n    h, w = gray.shape[:2]\n    mid = w // 2\n    left = gray[:, :mid]\n    right = gray[:, w - mid:]\n    if left.size == 0 or right.size == 0:\n        return 0.0\n    # ensure same shape\n    if left.shape[1] != right.shape[1]:\n        # pad smaller\n        minw = min(left.shape[1], right.shape[1])\n        left = left[:, :minw]\n        right = right[:, :minw]\n    right_flipped = np.fliplr(right)\n    diff = np.abs(left - right_flipped)\n    mean_intensity = np.mean(gray) + eps\n    return float(np.mean(diff) / mean_intensity)\n\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Average run-length of bright regions per row (normalized by width) as a proxy for blob size'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    img = image.astype(float)\n    if img.ndim == 3:\n        bright = np.mean(img, axis=2)\n    else:\n        bright = img\n    h, w = bright.shape[:2]\n    meanv = np.mean(bright)\n    stdv = np.std(bright)\n    thr = meanv + stdv\n    mask = bright > thr\n    total_bright = float(np.count_nonzero(mask))\n    if total_bright == 0:\n        return 0.0\n    segments = 0\n    for i in range(h):\n        row = mask[i, :].astype(int)\n        if row.sum() == 0:\n            continue\n        dif = np.diff(row)\n        seg = int(np.sum(dif == 1) + (1 if row[0] == 1 else 0))\n        segments += seg\n    if segments == 0:\n        return 0.0\n    avg_run = (total_bright / (segments + eps))\n    return float(avg_run / max(1.0, float(w)))\n\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Variance of block-averaged RGB colors (low -> large uniform regions like water)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    img = image.astype(float)\n    if img.ndim == 2:\n        rgb = np.stack([img, img, img], axis=2)\n    else:\n        rgb = img\n    h, w = rgb.shape[:2]\n    bh = min(8, h)\n    bw = min(8, w)\n    if bh == 0 or bw == 0:\n        return 0.0\n    # compute block means\n    block_means = []\n    for i in range(bh):\n        r0 = int(i * h / bh)\n        r1 = int((i + 1) * h / bh) if i < bh - 1 else h\n        for j in range(bw):\n            c0 = int(j * w / bw)\n            c1 = int((j + 1) * w / bw) if j < bw - 1 else w\n            block = rgb[r0:r1, c0:c1, :]\n            if block.size == 0:\n                continue\n            block_means.append(np.mean(block.reshape(-1, 3), axis=0))\n    if len(block_means) == 0:\n        return 0.0\n    block_means = np.array(block_means)\n    var_across = np.mean(np.var(block_means, axis=0))\n    # normalize by overall channel variance\n    overall_var = np.mean(np.var(rgb.reshape(-1, 3), axis=0)) + eps\n    return float(var_across / (overall_var + eps))\n\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Ratio of mean gradient magnitude in green channel to grayscale (green texture prominence)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    img = image.astype(float)\n    if img.ndim == 2:\n        rgb = np.stack([img, img, img], axis=2)\n    else:\n        rgb = img\n    G = rgb[:, :, 1]\n    gray = np.mean(rgb, axis=2)\n    gy_g, gx_g = np.gradient(G)\n    gy, gx = np.gradient(gray)\n    mag_g = np.sqrt(gx_g * gx_g + gy_g * gy_g)\n    mag = np.sqrt(gx * gx + gy * gy)\n    mean_g = float(np.mean(mag_g))\n    mean_all = float(np.mean(mag)) + eps\n    return float(mean_g / (mean_all + eps))\n\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Fraction of strong horizontal edges occurring on blue-dominant pixels (higher -> horizontal edges aligned with water/sky)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.5\n    img = image.astype(float)\n    if img.ndim == 2:\n        rgb = np.stack([img, img, img], axis=2)\n    else:\n        rgb = img\n    h, w = rgb.shape[:2]\n    r = rgb[:, :, 0]\n    g = rgb[:, :, 1]\n    b = rgb[:, :, 2]\n    gray = np.mean(rgb, axis=2)\n    gy, gx = np.gradient(gray)\n    mag = np.sqrt(gx * gx + gy * gy) + eps\n    cos_theta = gx / mag\n    horizness = np.abs(cos_theta)\n    blue_mask = (b > g) & (b > r)\n    if np.count_nonzero(blue_mask) == 0:\n        return float(np.mean(horizness))\n    return float(np.mean(horizness[blue_mask]))\n",
  "def feature(image: np.ndarray) -> float:\n    'Fraction of pixels in the bottom third where blue channel dominates (water indicator)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    img = image.astype(float)\n    if img.ndim == 2:\n        rgb = np.stack([img, img, img], axis=2)\n    else:\n        rgb = img\n    h, w = rgb.shape[:2]\n    bottom_h = max(1, h // 3)\n    bottom = rgb[-bottom_h:, :, :]\n    if bottom.size == 0:\n        return 0.0\n    R = bottom[:, :, 0].flatten()\n    G = bottom[:, :, 1].flatten()\n    B = bottom[:, :, 2].flatten()\n    mask = (B > R) & (B > G)\n    return float(np.count_nonzero(mask) / (R.size + eps))\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Normalized row index of maximum horizontal edge strength (horizon proxy)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if image.ndim == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    if h <= 1:\n        return 0.0\n    gy, gx = np.gradient(gray)\n    # horizontal edges correspond to strong vertical gradient (gy)\n    row_strength = np.mean(np.abs(gy), axis=1)  # length h\n    idx = int(np.argmax(row_strength))\n    return float(idx / max(1, (h - 1) + eps))\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Vertical center-of-mass of green channel (0 top -> 1 bottom)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    img = image.astype(float)\n    if img.ndim == 2:\n        rgb = np.stack([img, img, img], axis=2)\n    else:\n        rgb = img\n    h, w = rgb.shape[:2]\n    g = rgb[:, :, 1]\n    row_sums = np.sum(g, axis=1)  # sum per row\n    total = np.sum(row_sums) + eps\n    rows = np.arange(h, dtype=float)\n    com = float(np.sum(rows * row_sums) / total)  # in pixel coordinates\n    if h <= 1:\n        return 0.0\n    return float(com / (h - 1))\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Ratio of horizontal gradient energy in bottom third to top third (texture asymmetry)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if image.ndim == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    third = max(1, h // 3)\n    top = gray[:third, :]\n    bottom = gray[-third:, :]\n    if top.size == 0 or bottom.size == 0:\n        return 0.0\n    gy_top, gx_top = np.gradient(top)\n    gy_bot, gx_bot = np.gradient(bottom)\n    horiz_top = np.mean(np.abs(gx_top)) + eps\n    horiz_bot = np.mean(np.abs(gx_bot)) + eps\n    return float(horiz_bot / horiz_top)\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Mean image colorfulness (Hasler & Suesstrunk metric)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    img = image.astype(float)\n    if img.ndim == 2:\n        rgb = np.stack([img, img, img], axis=2)\n    else:\n        rgb = img\n    R = rgb[:, :, 0].flatten()\n    G = rgb[:, :, 1].flatten()\n    B = rgb[:, :, 2].flatten()\n    rg = R - G\n    yb = 0.5 * (R + G) - B\n    std_rg = float(np.std(rg))\n    std_yb = float(np.std(yb))\n    mean_rg = float(np.mean(rg))\n    mean_yb = float(np.mean(yb))\n    colorfulness = np.sqrt(std_rg ** 2 + std_yb ** 2) + 0.3 * np.sqrt(mean_rg ** 2 + mean_yb ** 2)\n    return float(colorfulness)\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Fraction of strong edge pixels in central region (edge density proxy)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if image.ndim == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    sr, sc = h // 4, w // 4\n    er, ec = h - sr, w - sc\n    region = gray[sr:er, sc:ec] if (er > sr and ec > sc) else gray\n    if region.size == 0:\n        return 0.0\n    gy, gx = np.gradient(region)\n    mag = np.sqrt(gx * gx + gy * gy)\n    thr = np.mean(mag) + np.std(mag)\n    strong = mag > thr\n    return float(np.count_nonzero(strong) / float(max(1, mag.size)))\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Top-bottom vertical reflection similarity (correlation between top and vertically flipped bottom)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if image.ndim == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    half = h // 2\n    top = gray[:half, :]\n    bottom = gray[-half:, :]\n    if top.size == 0 or bottom.size == 0:\n        return 0.0\n    # crop to same shape if needed\n    if top.shape != bottom.shape:\n        minr = min(top.shape[0], bottom.shape[0])\n        top = top[-minr:, :]\n        bottom = bottom[:minr, :]\n    bottom_flipped = np.flipud(bottom)\n    a = top.flatten().astype(float)\n    b = bottom_flipped.flatten().astype(float)\n    a_mean = np.mean(a)\n    b_mean = np.mean(b)\n    num = np.sum((a - a_mean) * (b - b_mean))\n    den = np.sqrt(np.sum((a - a_mean) ** 2) * np.sum((b - b_mean) ** 2)) + eps\n    corr = num / den\n    return float((corr + 1.0) / 2.0)\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Normalized difference of mean blue between top third and bottom third'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    img = image.astype(float)\n    if img.ndim == 2:\n        rgb = np.stack([img, img, img], axis=2)\n    else:\n        rgb = img\n    h, w = rgb.shape[:2]\n    third = max(1, h // 3)\n    top = rgb[:third, :, 2].flatten()\n    bottom = rgb[-third:, :, 2].flatten()\n    if top.size == 0 or bottom.size == 0:\n        return 0.0\n    mean_top = float(np.mean(top))\n    mean_bottom = float(np.mean(bottom))\n    return float((mean_top - mean_bottom) / (mean_top + mean_bottom + eps))\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Fraction of green-dominant pixels across the image (vegetation prevalence)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    img = image.astype(float)\n    if img.ndim == 2:\n        rgb = np.stack([img, img, img], axis=2)\n    else:\n        rgb = img\n    r = rgb[:, :, 0].flatten()\n    g = rgb[:, :, 1].flatten()\n    b = rgb[:, :, 2].flatten()\n    mask = (g > r) & (g > b)\n    return float(np.count_nonzero(mask) / float(max(1, r.size + eps)))\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Orientation coherence of gradients in the central region (0..1, 1 = strongly aligned)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if image.ndim == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    sr, sc = h // 4, w // 4\n    er, ec = h - sr, w - sc\n    region = gray[sr:er, sc:ec] if (er > sr and ec > sc) else gray\n    if region.size == 0:\n        return 0.0\n    gy, gx = np.gradient(region)\n    ang = np.arctan2(gy, gx)\n    cosm = np.mean(np.cos(ang))\n    sinm = np.mean(np.sin(ang))\n    coherence = np.sqrt(cosm * cosm + sinm * sinm)\n    return float(coherence)\n",
  "def feature(image: np.ndarray) -> float:\n    'Ratio of blue-dominant pixel fraction in lower half vs upper half (water lower bias)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    img = image.astype(float)\n    if img.ndim == 2:\n        rgb = np.stack([img, img, img], axis=2)\n    else:\n        rgb = img\n    h, w = rgb.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    R = rgb[:, :, 0]; G = rgb[:, :, 1]; B = rgb[:, :, 2]\n    bright = (R + G + B) / 3.0\n    # blue-dominant and reasonably bright to avoid dark noise\n    thr = np.percentile(bright, 40)\n    blue_mask = (B > R) & (B > G) & (bright > thr * 0.7)\n    upper = blue_mask[:h//2, :]\n    lower = blue_mask[h//2:, :]\n    frac_upper = float(np.count_nonzero(upper)) / (upper.size + eps)\n    frac_lower = float(np.count_nonzero(lower)) / (lower.size + eps)\n    return float(frac_lower / (frac_upper + eps))\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Colorfulness score (Hasler-Susstrunk metric) normalized by brightness'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    img = image.astype(float)\n    if img.ndim == 2:\n        R = G = B = img\n    else:\n        R, G, B = img[:, :, 0], img[:, :, 1], img[:, :, 2]\n    rg = R - G\n    yb = 0.5 * (R + G) - B\n    std_rg = float(np.std(rg))\n    std_yb = float(np.std(yb))\n    mean_rg = float(np.mean(rg))\n    mean_yb = float(np.mean(yb))\n    colorfulness = np.sqrt(std_rg * std_rg + std_yb * std_yb) + 0.3 * np.sqrt(mean_rg * mean_rg + mean_yb * mean_yb)\n    brightness = float(np.mean((R + G + B) / 3.0)) + eps\n    return float(colorfulness / brightness)\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Fraction of strong edges that are predominantly horizontal (global)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    if gray.size == 0:\n        return 0.0\n    gy, gx = np.gradient(gray)\n    mag = np.sqrt(gx * gx + gy * gy)\n    thr = np.percentile(mag, 70) if mag.size else 0.0\n    strong = mag > (thr + eps)\n    if np.count_nonzero(strong) == 0:\n        return 0.0\n    # horizontal where vertical gradient dominates (captures horizontal edges)\n    horiz = (np.abs(gy) > 1.5 * np.abs(gx)) & strong\n    return float(np.count_nonzero(horiz) / (np.count_nonzero(strong) + eps))\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Normalized vertical symmetry score (1 = perfectly symmetric left-right)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if image.ndim == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    mid = w // 2\n    left = gray[:, :mid]\n    # align flipped right to left (handle odd widths)\n    right = gray[:, w - mid:w][:, ::-1]\n    if left.size == 0 or right.size == 0:\n        return 0.0\n    diff = np.abs(left - right)\n    mean_diff = float(np.mean(diff))\n    mean_brightness = float(np.mean(gray)) + eps\n    score = 1.0 - (mean_diff / mean_brightness)\n    # clamp to [0,1]\n    score = max(0.0, min(1.0, score))\n    return float(score)\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Fraction of green-dominant pixels in the lower-middle band (vegetation proxy)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    img = image.astype(float)\n    if img.ndim == 2:\n        rgb = np.stack([img, img, img], axis=2)\n    else:\n        rgb = img\n    h, w = rgb.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    r = rgb[:, :, 0]; g = rgb[:, :, 1]; b = rgb[:, :, 2]\n    sr, er = h // 2, min(h, (3 * h) // 4)\n    sc, ec = w // 4, min(w, (3 * w) // 4)\n    band = rgb[sr:er, sc:ec, :]\n    if band.size == 0:\n        return 0.0\n    r_b, g_b, b_b = band[:, :, 0], band[:, :, 1], band[:, :, 2]\n    bright_thr = np.percentile((r_b + g_b + b_b) / 3.0, 40)\n    mask = (g_b > r_b) & (g_b > b_b) & ((g_b + r_b + b_b) / 3.0 > bright_thr * 0.6)\n    return float(np.count_nonzero(mask) / (mask.size + eps))\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Fraction of center region pixels brighter than local threshold (center object area estimate)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    sr, sc = h // 4, w // 4\n    er, ec = h - sr, w - sc\n    center = gray[sr:er, sc:ec] if (er > sr and ec > sc) else gray\n    if center.size == 0:\n        return 0.0\n    center_mean = np.mean(center)\n    center_std = np.std(center)\n    thr = center_mean + 0.5 * center_std\n    mask = center > thr\n    return float(np.count_nonzero(mask) / (mask.size + eps))\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Normalized entropy of gradient magnitude histogram (texture complexity)'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if image.ndim == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    if gray.size == 0:\n        return 0.0\n    gy, gx = np.gradient(gray)\n    mag = np.sqrt(gx * gx + gy * gy).reshape(-1)\n    if mag.size == 0:\n        return 0.0\n    bins = 16\n    hist, _ = np.histogram(mag, bins=bins, range=(0.0, np.max(mag) + eps))\n    p = hist.astype(float) / (np.sum(hist) + eps)\n    ent = -np.sum(p * np.log(p + eps))\n    # normalize by log(bins) to be in [0,1]\n    ent_norm = ent / (np.log(bins) + eps)\n    return float(ent_norm)\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Average longest contiguous dark run per row normalized by image width'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    if image.ndim == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    mean = float(np.mean(gray))\n    std = float(np.std(gray))\n    thr = mean - 0.25 * std\n    mask = gray < thr\n    # for each row compute longest consecutive True run\n    max_runs = []\n    for row in mask:\n        if row.size == 0:\n            max_runs.append(0)\n            continue\n        # compute run lengths by diff trick\n        # pad with False at ends\n        r = np.concatenate(([0], row.astype(int), [0]))\n        diff = np.diff(r)\n        starts = np.where(diff == 1)[0]\n        ends = np.where(diff == -1)[0]\n        if starts.size and ends.size:\n            lengths = ends - starts\n            max_runs.append(int(np.max(lengths)))\n        else:\n            max_runs.append(0)\n    avg_max = float(np.mean(max_runs)) if max_runs else 0.0\n    return float(avg_max / (w + eps))\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Mean hue angle in central region (radians, -pi..pi) using robust atan2 formula'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    img = image.astype(float)\n    if img.ndim == 2:\n        # grayscale has no meaningful hue\n        return 0.0\n    h, w = img.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    sr, sc = h // 4, w // 4\n    er, ec = h - sr, w - sc\n    region = img[sr:er, sc:ec, :] if (er > sr and ec > sc) else img\n    if region.size == 0:\n        return 0.0\n    R = region[:, :, 0].reshape(-1)\n    G = region[:, :, 1].reshape(-1)\n    B = region[:, :, 2].reshape(-1)\n    # hue approximation using atan2( sqrt(3)*(G-B), 2R - G - B )\n    num = np.sqrt(3.0) * (G - B)\n    den = (2.0 * R - G - B)\n    hues = np.arctan2(num, den)\n    if hues.size == 0:\n        return 0.0\n    # circular mean\n    s = float(np.mean(np.sin(hues)))\n    c = float(np.mean(np.cos(hues)))\n    mean_angle = float(np.arctan2(s, c))\n    return float(mean_angle)\n\n",
  "def feature(image: np.ndarray) -> float:\n    'Bottom-third mean blue minus mean green normalized by overall brightness'\n    import numpy as np\n    eps = 1e-8\n    if image is None or getattr(image, 'size', 0) == 0:\n        return 0.0\n    img = image.astype(float)\n    if img.ndim == 2:\n        rgb = np.stack([img, img, img], axis=2)\n    else:\n        rgb = img\n    h, w = rgb.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    start = max(0, (2 * h) // 3)\n    bottom = rgb[start:, :, :]\n    if bottom.size == 0:\n        return 0.0\n    meanB = float(np.mean(bottom[:, :, 2]))\n    meanG = float(np.mean(bottom[:, :, 1]))\n    mean_brightness = float(np.mean((rgb[:, :, 0] + rgb[:, :, 1] + rgb[:, :, 2]) / 3.0)) + eps\n    return float((meanB - meanG) / mean_brightness)\n"
]