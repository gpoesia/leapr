{"used_features": ["def feature(board: chess.Board) -> list[float]:\n    'material balance: white material minus black material'\n    material = 0.0\n    for sq, piece in board.piece_map().items():\n        if piece is None:\n            continue\n        if piece.piece_type == chess.PAWN:\n            val = 1.0\n        elif piece.piece_type == chess.KNIGHT:\n            val = 3.0\n        elif piece.piece_type == chess.BISHOP:\n            val = 3.0\n        elif piece.piece_type == chess.ROOK:\n            val = 5.0\n        elif piece.piece_type == chess.QUEEN:\n            val = 9.0\n        else:  # KING or unknown\n            val = 0.0\n        material += val if piece.color == chess.WHITE else -val\n    return [float(material)]", "def feature(board: chess.Board) -> list[float]:\n    \"White minus Black material balance in pawns values\"\n    value_map = {chess.PAWN: 1, chess.KNIGHT: 3, chess.BISHOP: 3, chess.ROOK: 5, chess.QUEEN: 9, chess.KING: 0}\n    total = 0.0\n    for sq, piece in board.piece_map().items():\n        val = value_map.get(piece.piece_type, 0)\n        if piece.color == chess.WHITE:\n            total += val\n        else:\n            total -= val\n    return [float(total)]", "def feature(board: chess.Board) -> list[float]:\n    \"Material balance: white minus black\"\n    try:\n        score = 0.0\n        piece_values = {chess.PAWN: 1, chess.KNIGHT: 3, chess.BISHOP: 3, chess.ROOK: 5, chess.QUEEN: 9, chess.KING: 0}\n        for square, piece in board.piece_map().items():\n            val = piece_values.get(piece.piece_type, 0)\n            if piece.color == chess.WHITE:\n                score += val\n            else:\n                score -= val\n        return float(score)\n    except Exception:\n        return 0.0", "def feature(board: chess.Board) -> list[float]:\n    'Mobility of side to move: number of legal moves'\n    try:\n        moves = list(board.legal_moves)\n        return float(len(moves))\n    except Exception:\n        return 0.0", "def feature(board: chess.Board) -> list[float]:\n    \"Mobility by color: difference in number of legal moves originating from White vs Black pieces\"\n    white_moves = 0\n    black_moves = 0\n    for move in board.legal_moves:\n        piece = board.piece_at(move.from_square)\n        if piece is None:\n            continue\n        if piece.color == chess.WHITE:\n            white_moves += 1\n        else:\n            black_moves += 1\n    return [float(white_moves - black_moves)]", "def feature(board: chess.Board) -> list[float]:\n    'material balance: white minus black total material'\n    white = 0.0\n    black = 0.0\n    pieces = board.piece_map()\n    for sq, piece in pieces.items():\n        val = 0.0\n        if piece.piece_type == chess.PAWN:\n            val = 1.0\n        elif piece.piece_type in (chess.KNIGHT, chess.BISHOP):\n            val = 3.0\n        elif piece.piece_type == chess.ROOK:\n            val = 5.0\n        elif piece.piece_type == chess.QUEEN:\n            val = 9.0\n        else:\n            val = 0.0\n        if piece.color == chess.WHITE:\n            white += val\n        else:\n            black += val\n    return [float(white - black)]", "def feature(board: chess.Board) -> list[float]:\n    \"mobility by color: difference in number of legal moves White vs Black if to move\"\n    def mobility_for(color):\n        b = board.copy()\n        b.turn = color\n        return len(list(b.legal_moves))\n    w = mobility_for(chess.WHITE)\n    b = mobility_for(chess.BLACK)\n    return [float(w - b)]", "def feature(board: chess.Board) -> list[float]:\n    \"Pawn balance: number of white pawns minus number of black pawns\"\n    import chess\n    white_pawns = len(board.pieces(chess.PAWN, chess.WHITE))\n    black_pawns = len(board.pieces(chess.PAWN, chess.BLACK))\n    return float(white_pawns - black_pawns)", "def feature(board: chess.Board) -> list[float]:\n    \"Material balance: white material minus black material\"\n    white = 0.0\n    black = 0.0\n    for sq, piece in board.piece_map().items():\n        if piece.piece_type == chess.PAWN:\n            val = 1.0\n        elif piece.piece_type in (chess.KNIGHT, chess.BISHOP):\n            val = 3.0\n        elif piece.piece_type == chess.ROOK:\n            val = 5.0\n        elif piece.piece_type == chess.QUEEN:\n            val = 9.0\n        else:\n            val = 0.0\n        if piece.color == chess.WHITE:\n            white += val\n        else:\n            black += val\n    return [float(white - black)]", "def feature(board: chess.Board) -> list[float]:\n    \"mobility score: number of legal moves for side to move\"\n    import chess\n    return float(len(list(board.legal_moves)))", "def feature(board: chess.Board) -> list[float]:\n    \"mobility by color difference (White vs Black moves)\"\n    white_mob = 0\n    black_mob = 0\n    b1 = board.copy()\n    b1.turn = chess.WHITE\n    white_mob = len(list(b1.legal_moves))\n    b2 = board.copy()\n    b2.turn = chess.BLACK\n    black_mob = len(list(b2.legal_moves))\n    diff = white_mob - black_mob\n    return [float(diff)]", "def feature(board: chess.Board) -> list[float]:\n    'heavy piece count difference: rooks and queens'\n    white_heavy = 0\n    black_heavy = 0\n    for sq, piece in board.piece_map().items():\n        if piece.piece_type in (chess.ROOK, chess.QUEEN):\n            if piece.color == chess.WHITE:\n                white_heavy += 1\n            else:\n                black_heavy += 1\n    val = white_heavy - black_heavy\n    return [float(val)]", "def feature(board: chess.Board) -> list[float]:\n    \"Passed pawn difference: White passed pawns minus Black passed pawns\"\n    def is_white_passed(b: chess.Board, sq: int) -> bool:\n        f = chess.square_file(sq)\n        r = chess.square_rank(sq)\n        for ff in range(max(0, f-1), min(7, f+1) + 1):\n            for rr in range(r+1, 8):\n                s = chess.square(ff, rr)\n                pc = b.piece_at(s)\n                if pc is not None and pc.piece_type == chess.PAWN and pc.color == chess.BLACK:\n                    return False\n        return True\n\n    def is_black_passed(b: chess.Board, sq: int) -> bool:\n        f = chess.square_file(sq)\n        r = chess.square_rank(sq)\n        for ff in range(max(0, f-1), min(7, f+1) + 1):\n            for rr in range(0, r):\n                s = chess.square(ff, rr)\n                pc = b.piece_at(s)\n                if pc is not None and pc.piece_type == chess.PAWN and pc.color == chess.WHITE:\n                    return False\n        return True\n\n    white_passed = 0\n    black_passed = 0\n    for sq, p in board.piece_map().items():\n        if p.piece_type != chess.PAWN:\n            continue\n        if p.color == chess.WHITE:\n            if is_white_passed(board, sq):\n                white_passed += 1\n        else:\n            if is_black_passed(board, sq):\n                black_passed += 1\n    return float(white_passed - black_passed)", "def feature(board: chess.Board) -> list[float]:\n    \"king safety: number of attackers on side to move's king\"\n    if board.king(board.turn) is None:\n        return float(0)\n    king_sq = board.king(board.turn)\n    opp = not board.turn\n    attackers = board.attackers(opp, king_sq)\n    return float(len(attackers))", "def feature(board: chess.Board) -> list[float]:\n    'Material balance: white minus black material using standard piece values'\n    values = {\n        chess.PAWN: 1.0,\n        chess.KNIGHT: 3.0,\n        chess.BISHOP: 3.0,\n        chess.ROOK: 5.0,\n        chess.QUEEN: 9.0,\n        chess.KING: 0.0\n    }\n    white_material = 0.0\n    black_material = 0.0\n    for square, piece in board.piece_map().items():\n        val = values.get(piece.piece_type, 0.0)\n        if piece.color == chess.WHITE:\n            white_material += val\n        else:\n            black_material += val\n    return white_material - black_material", "def feature(board: chess.Board) -> list[float]:\n    'Piece centrality difference: weighted sum by proximity to center'\n    center_sqs = [chess.D4, chess.E4, chess.D5, chess.E5]\n    piece_values = {\n        chess.PAWN: 1.0,\n        chess.KNIGHT: 3.0,\n        chess.BISHOP: 3.0,\n        chess.ROOK: 5.0,\n        chess.QUEEN: 9.0,\n        chess.KING: 0.0\n    }\n    white_score = 0.0\n    black_score = 0.0\n    for sq, p in board.piece_map().items():\n        if p.piece_type not in piece_values:\n            continue\n        val = piece_values[p.piece_type]\n        dist = min(chess.square_distance(sq, c) for c in center_sqs)\n        centrality = 1.0 + max(0.0, 4.0 - dist)\n        contrib = val * centrality\n        if p.color == chess.WHITE:\n            white_score += contrib\n        else:\n            black_score += contrib\n    return float(white_score - black_score)", "def feature(board: chess.Board) -> list[float]:\n    \"Piece centrality difference: weighted sum by proximity to center\"\n    center_sqs = [chess.D4, chess.E4, chess.D5, chess.E5]\n    def center_dist(sq: chess.Square) -> int:\n        f = chess.square_file(sq)\n        r = chess.square_rank(sq)\n        dmin = 10\n        for c in center_sqs:\n            cf = chess.square_file(c)\n            cr = chess.square_rank(c)\n            d = max(abs(f - cf), abs(r - cr))\n            if d < dmin:\n                dmin = d\n        return dmin\n    white_score = 0.0\n    black_score = 0.0\n    for sq, p in board.piece_map().items():\n        dist = center_dist(sq)\n        weight = 1.0 / (dist + 1.0)\n        val = 0\n        if p.piece_type == chess.PAWN:\n            val = 1\n        elif p.piece_type == chess.KNIGHT:\n            val = 3\n        elif p.piece_type == chess.BISHOP:\n            val = 3\n        elif p.piece_type == chess.ROOK:\n            val = 5\n        elif p.piece_type == chess.QUEEN:\n            val = 9\n        else:\n            val = 0\n        score = weight * val\n        if p.color == chess.WHITE:\n            white_score += score\n        else:\n            black_score += score\n    return [float(white_score - black_score)]", "def feature(board: chess.Board) -> list[float]:\n    \"piece centrality difference: weighted sum by proximity to center\"\n    centers = [chess.D4, chess.E4, chess.D5, chess.E5]\n    def dist_to_center(sq: int) -> int:\n        return min(chess.square_distance(sq, c) for c in centers)\n    white_sum = 0.0\n    black_sum = 0.0\n    for sq, p in board.piece_map().items():\n        d = dist_to_center(sq)\n        w = 1.0 / (1.0 + d)\n        if p.color == chess.WHITE:\n            white_sum += w\n        else:\n            black_sum += w\n    return float(white_sum - black_sum)", "def feature(board: chess.Board) -> list[float]:\n    'Ratio of non-pawn moves to total legal moves for side to move'\n    moves = list(board.legal_moves)\n    total = len(moves)\n    non_pawn = 0\n    for mv in moves:\n        piece = board.piece_at(mv.from_square)\n        if piece is not None and piece.piece_type != chess.PAWN:\n            non_pawn += 1\n    ratio = non_pawn / max(1, total)\n    return [float(ratio)]", "def feature(board: chess.Board) -> list[float]:\n    'Material balance: white material minus black material'\n    values = {chess.PAWN: 1.0, chess.KNIGHT: 3.0, chess.BISHOP: 3.0, chess.ROOK: 5.0, chess.QUEEN: 9.0, chess.KING: 0.0}\n    white = 0.0\n    black = 0.0\n    for square, piece in board.piece_map().items():\n        val = values.get(piece.piece_type, 0.0)\n        if piece.color == chess.WHITE:\n            white += val\n        else:\n            black += val\n    return float(white - black)", "def feature(board: chess.Board) -> list[float]:\n    'minor-piece mobility difference: knights and bishops'\n    import chess\n    def moves_by_types(color, types):\n        b = board.copy()\n        b.turn = color\n        count = 0\n        for mv in b.legal_moves:\n            p = b.piece_at(mv.from_square)\n            if p and p.color == color and p.piece_type in types:\n                count += 1\n        return count\n\n    white_kb = moves_by_types(chess.WHITE, {chess.KNIGHT, chess.BISHOP})\n    black_kb = moves_by_types(chess.BLACK, {chess.KNIGHT, chess.BISHOP})\n    return [float(white_kb - black_kb)]", "def feature(board: chess.Board) -> list[float]:\n    \"central_piece_balance: white pieces on central squares minus black pieces on central squares\"\n    central = [chess.D4, chess.E4, chess.D5, chess.E5]\n    white_center = 0\n    black_center = 0\n    for sq, piece in board.piece_map().items():\n        if piece is None:\n            continue\n        if sq in central:\n            if piece.color == chess.WHITE:\n                white_center += 1\n            else:\n                black_center += 1\n    return float(white_center - black_center)", "def feature(board: chess.Board) -> list[float]:\n    \"Major piece mobility difference: rooks and queens moves White minus Black\"\n    white_major = 0\n    black_major = 0\n    for m in board.legal_moves:\n        p = board.piece_at(m.from_square)\n        if p is None:\n            continue\n        if p.piece_type in (chess.ROOK, chess.QUEEN):\n            if p.color == chess.WHITE:\n                white_major += 1\n            else:\n                black_major += 1\n    return float(white_major - black_major)", "def feature(board: chess.Board) -> list[float]:\n    'Major piece mobility difference: rooks and queens moves White minus Black'\n    def major_mobility(color: chess.Color) -> int:\n        b = board.copy()\n        b.turn = color\n        count = 0\n        for m in b.legal_moves:\n            p = b.piece_at(m.from_square)\n            if p is not None and p.color == color and p.piece_type in (chess.ROOK, chess.QUEEN):\n                count += 1\n        return count\n    white = major_mobility(chess.WHITE)\n    black = major_mobility(chess.BLACK)\n    return float(white - black)", "def feature(board: chess.Board) -> list[float]:\n    \"pawn balance: number of white pawns minus number of black pawns\"\n    white_pawns = 0\n    black_pawns = 0\n    for piece in board.piece_map().values():\n        if piece.piece_type == chess.PAWN:\n            if piece.color == chess.WHITE:\n                white_pawns += 1\n            else:\n                black_pawns += 1\n    return [float(white_pawns - black_pawns)]", "def feature(board: chess.Board) -> list[float]:\n    'material balance: white minus black'\n    values = {\n        chess.PAWN: 1,\n        chess.KNIGHT: 3,\n        chess.BISHOP: 3,\n        chess.ROOK: 5,\n        chess.QUEEN: 9,\n        chess.KING: 0\n    }\n    total = 0\n    for sq, piece in board.piece_map().items():\n        sign = 1 if piece.color == chess.WHITE else -1\n        total += sign * values.get(piece.piece_type, 0)\n    return float(total)", "def feature(board: chess.Board) -> list[float]:\n    \"Material balance: white material minus black material\"\n    import chess\n    values = {\n        chess.PAWN: 1,\n        chess.KNIGHT: 3,\n        chess.BISHOP: 3,\n        chess.ROOK: 5,\n        chess.QUEEN: 9\n    }\n    white = 0\n    black = 0\n    for sq, piece in board.piece_map().items():\n        if piece.piece_type in values:\n            val = values[piece.piece_type]\n            if piece.color == chess.WHITE:\n                white += val\n            else:\n                black += val\n    return float(white - black)", "def feature(board: chess.Board) -> list[float]:\n    \"Material balance: white material minus black material, normalized by total material\"\n    white = 0.0\n    black = 0.0\n    values = {chess.PAWN: 1.0, chess.KNIGHT: 3.0, chess.BISHOP: 3.0, chess.ROOK: 5.0, chess.QUEEN: 9.0, chess.KING: 0.0}\n    for sq, piece in board.piece_map().items():\n        val = values.get(piece.piece_type, 0.0)\n        if piece.color == chess.WHITE:\n            white += val\n        else:\n            black += val\n    denom = max(1.0, white + black)\n    return float((white - black) / denom)", "def feature(board: chess.Board) -> list[float]:\n    \"Centrality difference: weighted sum by proximity to center\"\n    import chess\n    center_sqs = [(3, 3), (4, 3), (3, 4), (4, 4)]\n    white_sum = 0.0\n    black_sum = 0.0\n\n    VALUES = {chess.PAWN: 1, chess.KNIGHT: 3, chess.BISHOP: 3, chess.ROOK: 5, chess.QUEEN: 9, chess.KING: 0}\n\n    for sq, piece in board.piece_map().items():\n        f = chess.square_file(sq)\n        r = chess.square_rank(sq)\n        # distance to nearest center square using Chebyshev distance\n        dist = None\n        for cf, cr in center_sqs:\n            d = max(abs(f - cf), abs(r - cr))\n            if dist is None or d < dist:\n                dist = d\n        if dist is None:\n            dist = 0\n        centrality = 1.0 / (1.0 + dist)\n        val = VALUES.get(piece.piece_type, 0)\n        contrib = val * centrality\n        if piece.color == chess.WHITE:\n            white_sum += contrib\n        else:\n            black_sum += contrib\n\n    return [float(white_sum - black_sum)]", "def feature(board: chess.Board) -> list[float]:\n    \"Material balance: white minus black total material\"\n    value_map = {\n        chess.PAWN: 1.0,\n        chess.KNIGHT: 3.0,\n        chess.BISHOP: 3.0,\n        chess.ROOK: 5.0,\n        chess.QUEEN: 9.0,\n        chess.KING: 0.0\n    }\n    white = 0.0\n    black = 0.0\n    for sq, p in board.piece_map().items():\n        val = value_map.get(p.piece_type, 0.0)\n        if p.color == chess.WHITE:\n            white += val\n        else:\n            black += val\n    return float(white - black)", "def feature(board: chess.Board) -> list[float]:\n    \"minor piece mobility difference: knights and bishops\"\n    try:\n        def mobility_for_color_mins(bd: chess.Board, color: bool) -> int:\n            bb = bd.copy()\n            bb.turn = color\n            cnt = 0\n            for mv in bb.legal_moves:\n                p = bb.piece_at(mv.from_square)\n                if p is not None and p.color == color and p.piece_type in (chess.KNIGHT, chess.BISHOP):\n                    cnt += 1\n            return cnt\n        w_min = mobility_for_color_mins(board, chess.WHITE)\n        b_min = mobility_for_color_mins(board, chess.BLACK)\n        return [float(w_min - b_min)]\n    except Exception:\n        return [0.0]", "def feature(board: chess.Board) -> list[float]:\n    'mobility of side to move: number of legal moves'\n    moves = list(board.legal_moves)\n    return [float(len(moves))]", "def feature(board: chess.Board) -> list[float]:\n    'king_centrality_diff: White king centrality minus Black king centrality'\n    center_sqs = [chess.D4, chess.E4, chess.D5, chess.E5]\n    def dist_to_center(ksq):\n        if ksq is None:\n            return 0.0\n        return min(chess.square_distance(ksq, c) for c in center_sqs)\n    wksq = board.king(chess.WHITE)\n    bksq = board.king(chess.BLACK)\n    w_cent = 1.0 / (1.0 + dist_to_center(wksq)) if wksq is not None else 0.0\n    b_cent = 1.0 / (1.0 + dist_to_center(bksq)) if bksq is not None else 0.0\n    return float(w_cent - b_cent)", "def feature(board: chess.Board) -> list[float]:\n    \"major piece mobility by color: rooks and queens\"\n    def count_major_moves_for_color(b, color):\n        b2 = b.copy()\n        b2.turn = color\n        cnt = 0\n        for mv in b2.legal_moves:\n            pc = b2.piece_at(mv.from_square)\n            if pc and pc.color == color and pc.piece_type in (chess.ROOK, chess.QUEEN):\n                cnt += 1\n        return cnt\n    white_major = count_major_moves_for_color(board, chess.WHITE)\n    black_major = count_major_moves_for_color(board, chess.BLACK)\n    return [float(white_major - black_major)]", "def feature(board: chess.Board) -> list[float]:\n    \"Mobility: difference in number of legal moves with White to move vs Black to move\"\n    try:\n        wb = board.copy()\n        wb.turn = chess.WHITE\n        mw = len(list(wb.legal_moves))\n        bb = board.copy()\n        bb.turn = chess.BLACK\n        mb = len(list(bb.legal_moves))\n        return [float(mw - mb)]\n    except Exception:\n        return [0.0]", "def feature(board: chess.Board) -> list[float]:\n    \"Material balance: white material minus black material\"\n    value = 0.0\n    piece_values = {\n        chess.PAWN: 1,\n        chess.KNIGHT: 3,\n        chess.BISHOP: 3,\n        chess.ROOK: 5,\n        chess.QUEEN: 9,\n        chess.KING: 0\n    }\n    for sq, piece in board.piece_map().items():\n        val = piece_values.get(piece.piece_type, 0)\n        if piece.color == chess.WHITE:\n            value += val\n        else:\n            value -= val\n    return float(value)", "def feature(board: chess.Board) -> list[float]:\n    'King safety pressure: difference in enemy pressure on squares around kings'\n    import chess\n    def neighbor_squares(sq):\n        f = chess.square_file(sq)\n        r = chess.square_rank(sq)\n        neigh = []\n        for df in (-1, 0, 1):\n            for dr in (-1, 0, 1):\n                if df == 0 and dr == 0:\n                    continue\n                nf, nr = f + df, r + dr\n                if 0 <= nf < 8 and 0 <= nr < 8:\n                    neigh.append(chess.square(nf, nr))\n        return neigh\n\n    white_king = board.king(chess.WHITE)\n    black_king = board.king(chess.BLACK)\n    white_pressure = 0\n    black_pressure = 0\n    if white_king is not None:\n        for nsq in neighbor_squares(white_king):\n            if board.is_attacked_by(chess.BLACK, nsq):\n                white_pressure += 1\n    if black_king is not None:\n        for nsq in neighbor_squares(black_king):\n            if board.is_attacked_by(chess.WHITE, nsq):\n                black_pressure += 1\n    return float(white_pressure - black_pressure)", "def feature(board: chess.Board) -> list[float]:\n    'Piece centrality difference: weighted sum by proximity to center'\n    center_sqs = [chess.D4, chess.E4, chess.D5, chess.E5]\n    white_score = 0.0\n    black_score = 0.0\n    for sq, piece in board.piece_map().items():\n        file = chess.square_file(sq)\n        rank = chess.square_rank(sq)\n        dist = min(chess.square_distance(sq, c) for c in center_sqs)\n        proximity = 1.0 / (1.0 + dist)\n        value = 0.0\n        if piece.piece_type == chess.PAWN:\n            value = 1.0\n        elif piece.piece_type == chess.KNIGHT:\n            value = 3.0\n        elif piece.piece_type == chess.BISHOP:\n            value = 3.0\n        elif piece.piece_type == chess.ROOK:\n            value = 5.0\n        elif piece.piece_type == chess.QUEEN:\n            value = 9.0\n        else:\n            value = 0.0\n        if piece.color == chess.WHITE:\n            white_score += value * proximity\n        else:\n            black_score += value * proximity\n    return float(white_score - black_score)", "def feature(board: chess.Board) -> list[float]:\n    \"Mobility: number of legal moves for side to move\"\n    return float(len(list(board.legal_moves)))", "def feature(board: chess.Board) -> list[float]:\n    \"Piece centrality difference: weighted sum by proximity to center\"\n    center_squares = [chess.D4, chess.E4, chess.D5, chess.E5]\n    def distance_to_center(sq: int) -> int:\n        return min(chess.square_distance(sq, c) for c in center_squares)\n\n    def piece_value(p: chess.Piece) -> float:\n        values = {chess.PAWN:1.0, chess.KNIGHT:3.0, chess.BISHOP:3.0, chess.ROOK:5.0, chess.QUEEN:9.0, chess.KING:0.0}\n        return values.get(p.piece_type, 0.0)\n\n    white_sum = 0.0\n    black_sum = 0.0\n    for sq, p in board.piece_map().items():\n        dist = distance_to_center(sq)\n        weight = 1.0 / (dist + 1.0)\n        val = piece_value(p) * weight\n        if p.color == chess.WHITE:\n            white_sum += val\n        else:\n            black_sum += val\n\n    return [float(white_sum - black_sum)]", "def feature(board: chess.Board) -> list[float]:\n    \"White pawns minus Black pawns\"\n    try:\n        white_pawns = 0\n        black_pawns = 0\n        for sq, piece in board.piece_map().items():\n            if piece.piece_type == chess.PAWN:\n                if piece.color == chess.WHITE:\n                    white_pawns += 1\n                else:\n                    black_pawns += 1\n        return [float(white_pawns - black_pawns)]\n    except Exception:\n        return [0.0]", "def feature(board: chess.Board) -> list[float]:\n    'passed pawns balance: white passed minus black passed'\n    import chess\n    white_pawns = [sq for sq, p in board.piece_map().items() if p.color == chess.WHITE and p.piece_type == chess.PAWN]\n    black_pawns = [sq for sq, p in board.piece_map().items() if p.color == chess.BLACK and p.piece_type == chess.PAWN]\n    white_passed = 0\n    for w in white_pawns:\n        fw = chess.square_file(w)\n        rw = chess.square_rank(w)\n        blocked = False\n        for b in black_pawns:\n            fb = chess.square_file(b)\n            rb = chess.square_rank(b)\n            if abs(fw - fb) <= 1 and rb > rw:\n                blocked = True\n                break\n        if not blocked:\n            white_passed += 1\n    black_passed = 0\n    for b in black_pawns:\n        fb = chess.square_file(b)\n        rb = chess.square_rank(b)\n        blocked = False\n        for w in white_pawns:\n            fw = chess.square_file(w)\n            rw = chess.square_rank(w)\n            if abs(fw - fb) <= 1 and rw < rb:\n                blocked = True\n                break\n        if not blocked:\n            black_passed += 1\n    return float(white_passed - black_passed)", "def feature(board: chess.Board) -> list[float]:\n    \"Pawn balance: White pawns minus Black pawns\"\n    white_pawns = len(board.pieces(chess.PAWN, chess.WHITE))\n    black_pawns = len(board.pieces(chess.PAWN, chess.BLACK))\n    return float(white_pawns - black_pawns)"], "all_features": ["def feature(board: chess.Board) -> list[float]:\n    'material balance: white material minus black material'\n    material = 0.0\n    for sq, piece in board.piece_map().items():\n        if piece is None:\n            continue\n        if piece.piece_type == chess.PAWN:\n            val = 1.0\n        elif piece.piece_type == chess.KNIGHT:\n            val = 3.0\n        elif piece.piece_type == chess.BISHOP:\n            val = 3.0\n        elif piece.piece_type == chess.ROOK:\n            val = 5.0\n        elif piece.piece_type == chess.QUEEN:\n            val = 9.0\n        else:  # KING or unknown\n            val = 0.0\n        material += val if piece.color == chess.WHITE else -val\n    return [float(material)]", "def feature(board: chess.Board) -> list[float]:\n    'king safety score for side to move: negative of attacked neighbor squares around king'\n    turn_color = chess.WHITE if board.turn else chess.BLACK\n    opp_color = chess.BLACK if board.turn else chess.WHITE\n    king_sq = board.king(turn_color)\n    attacked_neighbors = 0\n    if king_sq is not None:\n        file = chess.square_file(king_sq)\n        rank = chess.square_rank(king_sq)\n        for df in (-1, 0, 1):\n            for dr in (-1, 0, 1):\n                if df == 0 and dr == 0:\n                    continue\n                f = file + df\n                r = rank + dr\n                if 0 <= f < 8 and 0 <= r < 8:\n                    sq = chess.square(f, r)\n                    attackers = board.attackers(opp_color, sq)\n                    attacked_neighbors += len(attackers)\n    return [float(-attacked_neighbors)]", "def feature(board: chess.Board) -> list[float]:\n    'mobility: number of legal moves for the side to move'\n    moves = list(board.legal_moves)\n    return [float(len(moves))]", "def feature(board: chess.Board) -> list[float]:\n    'center control net: white center attacks minus black center attacks'\n    d4 = chess.parse_square('d4')\n    e4 = chess.parse_square('e4')\n    d5 = chess.parse_square('d5')\n    e5 = chess.parse_square('e5')\n    center_sqs = [d4, e4, d5, e5]\n    white_center = sum(len(board.attackers(chess.WHITE, sq)) for sq in center_sqs)\n    black_center = sum(len(board.attackers(chess.BLACK, sq)) for sq in center_sqs)\n    return [float(white_center - black_center)]", "def feature(board: chess.Board) -> list[float]:\n    'net passed pawns: white passed pawns minus black passed pawns'\n    def count_passed(board, color):\n        counts = [0] * 8\n        for sq, piece in board.piece_map().items():\n            if piece is None:\n                continue\n            if piece.color == color and piece.piece_type == chess.PAWN:\n                f = chess.square_file(sq)\n                counts[f] += 1\n        passed = 0\n        for f in range(8):\n            if counts[f] > 0:\n                left = counts[f - 1] if f > 0 else 0\n                right = counts[f + 1] if f < 7 else 0\n                if left == 0 and right == 0:\n                    passed += counts[f]\n        return passed\n    white_passed = count_passed(board, chess.WHITE)\n    black_passed = count_passed(board, chess.BLACK)\n    return [float(white_passed - black_passed)]", "def feature(board: chess.Board) -> list[float]:\n    'rooks on open files: total rooks on files with no pieces'\n    rooks_open = 0\n    for sq, piece in board.piece_map().items():\n        if piece is None:\n            continue\n        if piece.piece_type == chess.ROOK:\n            f = chess.square_file(sq)\n            open_file = True\n            for r in range(8):\n                s = chess.square(f, r)\n                if board.piece_at(s) is not None:\n                    open_file = False\n                    break\n            if open_file:\n                rooks_open += 1\n    return [float(rooks_open)]", "def feature(board: chess.Board) -> list[float]:\n    'king distance: Manhattan distance between kings'\n    wk = board.king(chess.WHITE)\n    bk = board.king(chess.BLACK)\n    dist = 0\n    if wk is not None and bk is not None:\n        dist = chess.square_distance(wk, bk)\n    return [float(dist)]", "def feature(board: chess.Board) -> list[float]:\n    'captures available to move: number of legal moves that capture'\n    caps = 0\n    for move in board.legal_moves:\n        if board.is_capture(move):\n            caps += 1\n    return [float(caps)]", "def feature(board: chess.Board) -> list[float]:\n    'pawn count difference: white pawns minus black pawns'\n    white_pawns = 0\n    black_pawns = 0\n    for sq, piece in board.piece_map().items():\n        if piece is None:\n            continue\n        if piece.piece_type == chess.PAWN:\n            if piece.color == chess.WHITE:\n                white_pawns += 1\n            else:\n                black_pawns += 1\n    return [float(white_pawns - black_pawns)]", "def feature(board: chess.Board) -> list[float]:\n    'doubled+isolated pawn imbalance: white minus black'\n    def count_doubled_isolated(board, color):\n        counts = [0] * 8\n        for sq, piece in board.piece_map().items():\n            if piece is None:\n                continue\n            if piece.color == color and piece.piece_type == chess.PAWN:\n                f = chess.square_file(sq)\n                counts[f] += 1\n        doubled = sum(max(0, c - 1) for c in counts)\n        isolated = 0\n        for f in range(8):\n            if counts[f] > 0:\n                left = counts[f - 1] if f > 0 else 0\n                right = counts[f + 1] if f < 7 else 0\n                if left == 0 and right == 0:\n                    isolated += counts[f]\n        return doubled + isolated\n    w = count_doubled_isolated(board, chess.WHITE)\n    b = count_doubled_isolated(board, chess.BLACK)\n    return [float(w - b)]", "def feature(board: chess.Board) -> list[float]:\n    \"White minus Black material balance in pawns values\"\n    value_map = {chess.PAWN: 1, chess.KNIGHT: 3, chess.BISHOP: 3, chess.ROOK: 5, chess.QUEEN: 9, chess.KING: 0}\n    total = 0.0\n    for sq, piece in board.piece_map().items():\n        val = value_map.get(piece.piece_type, 0)\n        if piece.color == chess.WHITE:\n            total += val\n        else:\n            total -= val\n    return [float(total)]", "def feature(board: chess.Board) -> list[float]:\n    \"Difference in pawn count white minus black\"\n    white_pawns = 0\n    black_pawns = 0\n    for piece in board.piece_map().values():\n        if piece.piece_type == chess.PAWN:\n            if piece.color == chess.WHITE:\n                white_pawns += 1\n            else:\n                black_pawns += 1\n    return [float(white_pawns - black_pawns)]", "def feature(board: chess.Board) -> list[float]:\n    \"Difference in number of passed pawns (white minus black)\"\n    white_passed = 0\n    black_passed = 0\n    white_pawns = []\n    black_pawns = []\n    for sq, p in board.piece_map().items():\n        if p.piece_type == chess.PAWN:\n            if p.color == chess.WHITE:\n                white_pawns.append(sq)\n            else:\n                black_pawns.append(sq)\n    # helper to get file/rank\n    def file_of(sq): return chess.square_file(sq)\n    def rank_of(sq): return chess.square_rank(sq)\n    # Determine passed white pawns\n    for w in white_pawns:\n        wf = file_of(w)\n        wr = rank_of(w)\n        blocked = False\n        for bs, bp in board.piece_map().items():\n            if bp.piece_type == chess.PAWN and bp.color == chess.BLACK:\n                bf = file_of(bs)\n                br = rank_of(bs)\n                if abs(bf - wf) <= 1 and br > wr:\n                    blocked = True\n                    break\n        if not blocked:\n            white_passed += 1\n    # Determine passed black pawns\n    for b in black_pawns:\n        bf = file_of(b)\n        br = rank_of(b)\n        blocked = False\n        for ws, wp in board.piece_map().items():\n            if wp.piece_type == chess.PAWN and wp.color == chess.WHITE:\n                wf = file_of(ws)\n                wr = rank_of(ws)\n                if abs(wf - bf) <= 1 and wr < br:\n                    blocked = True\n                    break\n        if not blocked:\n            black_passed += 1\n    return [float(white_passed - black_passed)]", "def feature(board: chess.Board) -> list[float]:\n    \"White developed pieces minus Black developed pieces\"\n    white_developed = 0\n    black_developed = 0\n    for sq, p in board.piece_map().items():\n        if p.piece_type != chess.PAWN:\n            r = chess.square_rank(sq)\n            if p.color == chess.WHITE:\n                if r > 0:\n                    white_developed += 1\n            else:\n                if r < 7:\n                    black_developed += 1\n    return [float(white_developed - black_developed)]", "def feature(board: chess.Board) -> list[float]:\n    \"Center control: white pieces on d4/e4/d5/e5 minus Black\"\n    centers = [chess.parse_square(s) for s in ['d4', 'e4', 'd5', 'e5']]\n    white_center = 0\n    black_center = 0\n    for sq in centers:\n        p = board.piece_at(sq)\n        if p is not None:\n            if p.color == chess.WHITE:\n                white_center += 1\n            else:\n                black_center += 1\n    return [float(white_center - black_center)]", "def feature(board: chess.Board) -> list[float]:\n    \"White king safety minus Black king safety (1 if in check, else 0)\"\n    def king_square(color):\n        sq = None\n        try:\n            sq = board.king(color)\n        except Exception:\n            pass\n        if sq is None:\n            for s, p in board.piece_map().items():\n                if p.color == color and p.piece_type == chess.KING:\n                    sq = s\n                    break\n        return sq\n    wk = king_square(chess.WHITE)\n    bk = king_square(chess.BLACK)\n    white_in_check = board.is_attacked_by(chess.BLACK, wk) if wk is not None else False\n    black_in_check = board.is_attacked_by(chess.WHITE, bk) if bk is not None else False\n    return [float(white_in_check) - float(black_in_check)]", "def feature(board: chess.Board) -> list[float]:\n    \"Difference in queen counts white minus black\"\n    white_queens = 0\n    black_queens = 0\n    for p in board.piece_map().values():\n        if p.piece_type == chess.QUEEN:\n            if p.color == chess.WHITE:\n                white_queens += 1\n            else:\n                black_queens += 1\n    return [float(white_queens - black_queens)]", "def feature(board: chess.Board) -> list[float]:\n    \"Difference in number of doubled pawns white minus black\"\n    white_file_counts = [0] * 8\n    black_file_counts = [0] * 8\n    for sq, p in board.piece_map().items():\n        if p.piece_type == chess.PAWN:\n            f = chess.square_file(sq)\n            if p.color == chess.WHITE:\n                white_file_counts[f] += 1\n            else:\n                black_file_counts[f] += 1\n    white_doubled = sum(n - 1 for n in white_file_counts if n > 1)\n    black_doubled = sum(n - 1 for n in black_file_counts if n > 1)\n    return [float(white_doubled - black_doubled)]", "def feature(board: chess.Board) -> list[float]:\n    \"Material balance divided by (1 + number of legal moves) to reflect mobility\"\n    material_diff = 0.0\n    value_map = {chess.PAWN: 1, chess.KNIGHT: 3, chess.BISHOP: 3, chess.ROOK: 5, chess.QUEEN: 9, chess.KING: 0}\n    for sq, p in board.piece_map().items():\n        val = value_map.get(p.piece_type, 0)\n        if p.color == chess.WHITE:\n            material_diff += val\n        else:\n            material_diff -= val\n    mobility = sum(1 for _ in board.legal_moves)\n    return [float(material_diff) / float(1.0 + mobility)]", "def feature(board: chess.Board) -> list[float]:\n    \"Material balance: white minus black\"\n    try:\n        score = 0.0\n        piece_values = {chess.PAWN: 1, chess.KNIGHT: 3, chess.BISHOP: 3, chess.ROOK: 5, chess.QUEEN: 9, chess.KING: 0}\n        for square, piece in board.piece_map().items():\n            val = piece_values.get(piece.piece_type, 0)\n            if piece.color == chess.WHITE:\n                score += val\n            else:\n                score -= val\n        return float(score)\n    except Exception:\n        return 0.0", "def feature(board: chess.Board) -> list[float]:\n    \"King safety near king: number of opponent attacks on neighboring squares\"\n    try:\n        color_to_move = board.turn\n        opponent = not color_to_move\n        king_sq = board.king(color_to_move)\n        if king_sq is None:\n            return 0.0\n        file = chess.square_file(king_sq)\n        rank = chess.square_rank(king_sq)\n        count = 0\n        for df in (-1, 0, 1):\n            for dr in (-1, 0, 1):\n                if df == 0 and dr == 0:\n                    continue\n                f = file + df\n                r = rank + dr\n                if 0 <= f < 8 and 0 <= r < 8:\n                    sq = chess.square(f, r)\n                    if board.is_attacked_by(opponent, sq):\n                        count += 1\n        return float(count)\n    except Exception:\n        return 0.0", "def feature(board: chess.Board) -> list[float]:\n    \"Current side mobility: number of legal moves for side to move\"\n    try:\n        moves = list(board.legal_moves)\n        return float(len(moves))\n    except Exception:\n        return 0.0", "def feature(board: chess.Board) -> list[float]:\n    \"Approximate passed pawns balance: white passed pawns minus black passed pawns\"\n    try:\n        white_passed = 0\n        black_passed = 0\n        white_pawns = [sq for sq, p in board.piece_map().items() if p.color == chess.WHITE and p.piece_type == chess.PAWN]\n        black_pawns = [sq for sq, p in board.piece_map().items() if p.color == chess.BLACK and p.piece_type == chess.PAWN]\n        for sq in white_pawns:\n            f = chess.square_file(sq)\n            r = chess.square_rank(sq)\n            is_passed = True\n            for bf in (f - 1, f, f + 1):\n                if 0 <= bf < 8:\n                    for bq, bp in board.piece_map().items():\n                        if bp.color == chess.BLACK and bp.piece_type == chess.PAWN and chess.square_file(bq) == bf and chess.square_rank(bq) > r:\n                            is_passed = False\n                            break\n                if not is_passed:\n                    break\n            if is_passed:\n                white_passed += 1\n        for sq in black_pawns:\n            f = chess.square_file(sq)\n            r = chess.square_rank(sq)\n            is_passed = True\n            for bf in (f - 1, f, f + 1):\n                if 0 <= bf < 8:\n                    for wq, wp in board.piece_map().items():\n                        if wp.color == chess.WHITE and wp.piece_type == chess.PAWN and chess.square_file(wq) == bf and chess.square_rank(wq) < r:\n                            is_passed = False\n                            break\n                if not is_passed:\n                    break\n            if is_passed:\n                black_passed += 1\n        return float(white_passed - black_passed)\n    except Exception:\n        return 0.0", "def feature(board: chess.Board) -> list[float]:\n    \"Doubled and isolated pawns imbalance: (white isolated+doubled) - (black isolated+doubled)\"\n    try:\n        def pawn_counts(color):\n            squares = [sq for sq, p in board.piece_map().items() if p.color == color and p.piece_type == chess.PAWN]\n            files = {f: 0 for f in range(8)}\n            for sq in squares:\n                files[chess.square_file(sq)] += 1\n            doubled = sum(max(0, c - 1) for c in files.values())\n            # isolated pawns\n            isolated = 0\n            for sq in squares:\n                f = chess.square_file(sq)\n                has_neighbor = False\n                for nf in (f - 1, f + 1):\n                    if 0 <= nf < 8:\n                        for s2 in squares:\n                            if chess.square_file(s2) == nf:\n                                has_neighbor = True\n                                break\n                    if has_neighbor:\n                        break\n                if not has_neighbor:\n                    isolated += 1\n            return doubled, isolated\n        white_double, white_isolated = pawn_counts(chess.WHITE)\n        black_double, black_isolated = pawn_counts(chess.BLACK)\n        return float((white_double + white_isolated) - (black_double + black_isolated))\n    except Exception:\n        return 0.0", "def feature(board: chess.Board) -> list[float]:\n    \"Center control score: difference in pieces on central squares\"\n    try:\n        central_squares = [chess.D4, chess.E4, chess.D5, chess.E5]\n        score = 0.0\n        for sq in central_squares:\n            p = board.piece_at(sq)\n            if p is not None:\n                score += 1.0 if p.color == chess.WHITE else -1.0\n        return float(score)\n    except Exception:\n        return 0.0", "def feature(board: chess.Board) -> list[float]:\n    \"Rooks on open files: count rooks on files with no pawns\"\n    try:\n        # determine open files\n        open_file = [True] * 8\n        for f in range(8):\n            for r in range(8):\n                sq = chess.square(f, r)\n                p = board.piece_at(sq)\n                if p is not None and p.piece_type == chess.PAWN:\n                    open_file[f] = False\n                    break\n        # count rooks on open files\n        rooks_on_open = 0\n        for sq, p in board.piece_map().items():\n            if p.piece_type == chess.ROOK and open_file[chess.square_file(sq)]:\n                rooks_on_open += 1\n        return float(rooks_on_open)\n    except Exception:\n        return 0.0", "def feature(board: chess.Board) -> list[float]:\n    \"Major piece imbalance: (White rooks+queens) minus (Black rooks+queens)\"\n    try:\n        score = 0.0\n        for sq, p in board.piece_map().items():\n            if p.color == chess.WHITE and p.piece_type in (chess.ROOK, chess.QUEEN):\n                score += 1.0\n            elif p.color == chess.BLACK and p.piece_type in (chess.ROOK, chess.QUEEN):\n                score -= 1.0\n        return float(score)\n    except Exception:\n        return 0.0", "def feature(board: chess.Board) -> list[float]:\n    \"Queen proximity to enemy king: difference of distances (black queen to white king) - (white queen to black king)\"\n    try:\n        white_king = board.king(chess.WHITE)\n        black_king = board.king(chess.BLACK)\n        if white_king is None or black_king is None:\n            return 0.0\n        min_white_q = 1000\n        min_black_q = 1000\n        for sq, p in board.piece_map().items():\n            if p.piece_type == chess.QUEEN:\n                if p.color == chess.WHITE:\n                    d = chess.square_distance(sq, black_king)\n                    if d < min_white_q:\n                        min_white_q = d\n                else:\n                    d = chess.square_distance(sq, white_king)\n                    if d < min_black_q:\n                        min_black_q = d\n        dist_white_to_black = min_white_q if min_white_q != 1000 else 1000\n        dist_black_to_white = min_black_q if min_black_q != 1000 else 1000\n        return float(dist_black_to_white - dist_white_to_black)\n    except Exception:\n        return 0.0", "def feature(board: chess.Board) -> list[float]:\n    \"Pawn activity on current side: number of pawn moves available (pseudo-legal) for pawns\"\n    try:\n        moves = []\n        if hasattr(board, 'pseudo_legal_moves'):\n            moves = list(board.pseudo_legal_moves)\n        else:\n            moves = list(board.legal_moves)\n        count = 0\n        for m in moves:\n            p = board.piece_at(m.from_square)\n            if p is not None and p.piece_type == chess.PAWN:\n                count += 1\n        return float(count)\n    except Exception:\n        return 0.0", "def feature(board: chess.Board) -> list[float]:\n    'Material balance: white minus black material using standard values'\n    values = {chess.PAWN: 1, chess.KNIGHT: 3, chess.BISHOP: 3, chess.ROOK: 5, chess.QUEEN: 9, chess.KING: 0}\n    total = 0.0\n    try:\n        for sq, piece in board.piece_map().items():\n            if piece is None:\n                continue\n            val = values.get(piece.piece_type, 0)\n            if piece.color == chess.WHITE:\n                total += val\n            else:\n                total -= val\n    except Exception:\n        total = 0.0\n    return float(total)", "def feature(board: chess.Board) -> list[float]:\n    'Center control difference on d4,d5,e4,e5: white minus black'\n    center_sqs = [chess.parse_square(s) for s in ['d4','d5','e4','e5']]\n    white = sum(1 for sq in center_sqs if board.is_attacked_by(chess.WHITE, sq))\n    black = sum(1 for sq in center_sqs if board.is_attacked_by(chess.BLACK, sq))\n    return float(white - black)", "def feature(board: chess.Board) -> list[float]:\n    'Mobility of side to move: number of legal moves'\n    try:\n        moves = list(board.legal_moves)\n        return float(len(moves))\n    except Exception:\n        return 0.0", "def feature(board: chess.Board) -> list[float]:\n    'Doubled pawns difference: white minus black'\n    white_files = [0] * 8\n    black_files = [0] * 8\n    try:\n        for sq, piece in board.piece_map().items():\n            if piece.piece_type == chess.PAWN:\n                f = chess.square_file(sq)\n                if piece.color == chess.WHITE:\n                    white_files[f] += 1\n                else:\n                    black_files[f] += 1\n        white_doubled = sum(1 for c in white_files if c >= 2)\n        black_doubled = sum(1 for c in black_files if c >= 2)\n        return float(white_doubled - black_doubled)\n    except Exception:\n        return 0.0", "def feature(board: chess.Board) -> list[float]:\n    'Approximate passed pawns difference: white minus black'\n    def is_passed(sq, color):\n        f = chess.square_file(sq)\n        r = chess.square_rank(sq)\n        if color == chess.WHITE:\n            for ff in range(max(0, f-1), min(7, f+1) + 1):\n                for rr in range(r+1, 8):\n                    sq2 = chess.square(ff, rr)\n                    p = board.piece_at(sq2)\n                    if p is not None and p.color == chess.BLACK and p.piece_type == chess.PAWN:\n                        return False\n            return True\n        else:\n            for ff in range(max(0, f-1), min(7, f+1) + 1):\n                for rr in range(r-1, -1, -1):\n                    sq2 = chess.square(ff, rr)\n                    p = board.piece_at(sq2)\n                    if p is not None and p.color == chess.WHITE and p.piece_type == chess.PAWN:\n                        return False\n            return True\n    white_passed = 0\n    black_passed = 0\n    try:\n        for sq, piece in board.piece_map().items():\n            if piece.piece_type == chess.PAWN:\n                if piece.color == chess.WHITE and is_passed(sq, chess.WHITE):\n                    white_passed += 1\n                elif piece.color == chess.BLACK and is_passed(sq, chess.BLACK):\n                    black_passed += 1\n    except Exception:\n        pass\n    return float(white_passed - black_passed)", "def feature(board: chess.Board) -> list[float]:\n    'Chebyshev distance between white king and black king'\n    wk = None\n    bk = None\n    try:\n        for sq, piece in board.piece_map().items():\n            if piece.piece_type == chess.KING:\n                if piece.color == chess.WHITE:\n                    wk = sq\n                else:\n                    bk = sq\n        if wk is None or bk is None:\n            return 0.0\n        fw = chess.square_file(wk)\n        rw = chess.square_rank(wk)\n        fb = chess.square_file(bk)\n        rb = chess.square_rank(bk)\n        dist = max(abs(fw - fb), abs(rw - rb))\n        return float(dist)\n    except Exception:\n        return 0.0", "def feature(board: chess.Board) -> list[float]:\n    'Check status of current side to move'\n    try:\n        return float(1.0 if board.is_check() else 0.0)\n    except Exception:\n        return 0.0", "def feature(board: chess.Board) -> list[float]:\n    'Major piece imbalance: rooks and queens difference white minus black'\n    values = {chess.ROOK: 5, chess.QUEEN: 9}\n    total = 0.0\n    try:\n        for sq, piece in board.piece_map().items():\n            if piece.piece_type in (chess.ROOK, chess.QUEEN):\n                val = values.get(piece.piece_type, 0)\n                if piece.color == chess.WHITE:\n                    total += val\n                else:\n                    total -= val\n    except Exception:\n        pass\n    return float(total)", "def feature(board: chess.Board) -> list[float]:\n    'King safety: negative penalty proportional to enemy attacks on white king'\n    wk = None\n    try:\n        for sq, piece in board.piece_map().items():\n            if piece.color == chess.WHITE and piece.piece_type == chess.KING:\n                wk = sq\n                break\n        if wk is None:\n            return 0.0\n        attackers = board.attackers(chess.BLACK, wk)\n        return float(-len(attackers))\n    except Exception:\n        return 0.0", "def feature(board: chess.Board) -> list[float]:\n    'Open-file rooks advantage: white open-rooks minus black open-rooks'\n    try:\n        # determine open files (no pawns of either color)\n        open_by_file = [True] * 8\n        for sq, piece in board.piece_map().items():\n            if piece.piece_type == chess.PAWN:\n                f = chess.square_file(sq)\n                open_by_file[f] = False\n        white_open = 0\n        black_open = 0\n        for sq, piece in board.piece_map().items():\n            if piece.piece_type == chess.ROOK:\n                f = chess.square_file(sq)\n                if open_by_file[f]:\n                    if piece.color == chess.WHITE:\n                        white_open += 1\n                    else:\n                        black_open += 1\n        return float(white_open - black_open)\n    except Exception:\n        return 0.0", "def feature(board: chess.Board) -> list[float]:\n    \"material balance: white minus black\"\n    VALUES = {chess.PAWN: 1.0, chess.KNIGHT: 3.0, chess.BISHOP: 3.0, chess.ROOK: 5.0, chess.QUEEN: 9.0, chess.KING: 0.0}\n    white = 0.0\n    black = 0.0\n    for sq, piece in board.piece_map().items():\n        if piece.color == chess.WHITE:\n            white += VALUES.get(piece.piece_type, 0.0)\n        else:\n            black += VALUES.get(piece.piece_type, 0.0)\n    return [float(white - black)]", "def feature(board: chess.Board) -> list[float]:\n    \"Mobility: number of legal moves for side to move\"\n    val = float(len(list(board.legal_moves)))\n    return [val]", "def feature(board: chess.Board) -> list[float]:\n    \"King safety: attackers value on side to move's king\"\n    turn = board.turn\n    opp = not turn\n    king_sq = board.king(turn)\n    if king_sq is None:\n        return [0.0]\n    attackers = board.attackers(opp, king_sq)\n    VALUES = {chess.PAWN: 1.0, chess.KNIGHT: 3.0, chess.BISHOP: 3.0, chess.ROOK: 5.0, chess.QUEEN: 9.0, chess.KING: 0.0}\n    s = 0.0\n    for s_sq in attackers:\n        p = board.piece_at(s_sq)\n        if p is not None and p.color == opp:\n            s += VALUES.get(p.piece_type, 0.0)\n    return [float(s)]", "def feature(board: chess.Board) -> list[float]:\n    \"Center control difference: white minus black control on center squares\"\n    centers = [chess.D4, chess.E4, chess.D5, chess.E5]\n    white_control = 0\n    black_control = 0\n    for sq in centers:\n        white_control += len(board.attackers(chess.WHITE, sq))\n        black_control += len(board.attackers(chess.BLACK, sq))\n    return [float(white_control - black_control)]", "def feature(board: chess.Board) -> list[float]:\n    \"Passed pawns: white passed pawns minus black passed pawns\"\n    def is_passed(board: chess.Board, sq: int, color: chess.Color) -> bool:\n        file = chess.square_file(sq)\n        rank = chess.square_rank(sq)\n        opp = chess.BLACK if color == chess.WHITE else chess.WHITE\n        files = [f for f in (file-1, file, file+1) if 0 <= f <= 7]\n        if color == chess.WHITE:\n            ahead = range(rank+1, 8)\n        else:\n            ahead = range(rank-1, -1, -1)\n        for f in files:\n            for r in ahead:\n                s2 = chess.square(f, r)\n                p = board.piece_at(s2)\n                if p is not None and p.color == opp and p.piece_type == chess.PAWN:\n                    return False\n        return True\n\n    white_passed = 0\n    black_passed = 0\n    for sq, p in board.piece_map().items():\n        if p.piece_type != chess.PAWN:\n            continue\n        if p.color == chess.WHITE:\n            if is_passed(board, sq, chess.WHITE):\n                white_passed += 1\n        else:\n            if is_passed(board, sq, chess.BLACK):\n                black_passed += 1\n    return [float(white_passed - black_passed)]", "def feature(board: chess.Board) -> list[float]:\n    \"Development score: developed knights and bishops (not on starting squares)\"\n    white_dev = 0\n    black_dev = 0\n    for sq, p in board.piece_map().items():\n        if p.color == chess.WHITE and p.piece_type in (chess.KNIGHT, chess.BISHOP):\n            if p.piece_type == chess.KNIGHT:\n                if sq not in (chess.B1, chess.G1):\n                    white_dev += 1\n            else:\n                if sq not in (chess.C1, chess.F1):\n                    white_dev += 1\n        elif p.color == chess.BLACK and p.piece_type in (chess.KNIGHT, chess.BISHOP):\n            if p.piece_type == chess.KNIGHT:\n                if sq not in (chess.B8, chess.G8):\n                    black_dev += 1\n            else:\n                if sq not in (chess.C8, chess.F8):\n                    black_dev += 1\n    return [float(white_dev - black_dev)]", "def feature(board: chess.Board) -> list[float]:\n    \"Queen safety of side to move: attackers value on side-to-move's queen\"\n    turn = board.turn\n    opp = not turn\n    qsq = None\n    for sq, p in board.piece_map().items():\n        if p.color == turn and p.piece_type == chess.QUEEN:\n            qsq = sq\n            break\n    if qsq is None:\n        return [0.0]\n    attackers = board.attackers(opp, qsq)\n    VALUES = {chess.PAWN: 1.0, chess.KNIGHT: 3.0, chess.BISHOP: 3.0, chess.ROOK: 5.0, chess.QUEEN: 9.0, chess.KING: 0.0}\n    s = 0.0\n    for s_sq in attackers:\n        p = board.piece_at(s_sq)\n        if p is not None and p.color == opp:\n            s += VALUES.get(p.piece_type, 0.0)\n    return [float(s)]", "def feature(board: chess.Board) -> list[float]:\n    \"King distance: Manhattan distance between the two kings\"\n    wking = board.king(chess.WHITE)\n    bking = board.king(chess.BLACK)\n    if wking is None or bking is None:\n        return [0.0]\n    wf = chess.square_file(wking)\n    wr = chess.square_rank(wking)\n    bf = chess.square_file(bking)\n    br = chess.square_rank(bking)\n    dist = abs(wf - bf) + abs(wr - br)\n    return [float(dist)]", "def feature(board: chess.Board) -> list[float]:\n    \"Mobility by color: difference in number of legal moves originating from White vs Black pieces\"\n    white_moves = 0\n    black_moves = 0\n    for move in board.legal_moves:\n        piece = board.piece_at(move.from_square)\n        if piece is None:\n            continue\n        if piece.color == chess.WHITE:\n            white_moves += 1\n        else:\n            black_moves += 1\n    return [float(white_moves - black_moves)]", "def feature(board: chess.Board) -> list[float]:\n    \"Major piece imbalance: white rooks/queens minus black rooks/queens\"\n    white_majors = 0\n    black_majors = 0\n    for sq, p in board.piece_map().items():\n        if p.piece_type in (chess.ROOK, chess.QUEEN):\n            if p.color == chess.WHITE:\n                white_majors += 1\n            else:\n                black_majors += 1\n    return [float(white_majors - black_majors)]", "def feature(board: chess.Board) -> list[float]:\n    'material balance: white minus black total material'\n    white = 0.0\n    black = 0.0\n    pieces = board.piece_map()\n    for sq, piece in pieces.items():\n        val = 0.0\n        if piece.piece_type == chess.PAWN:\n            val = 1.0\n        elif piece.piece_type in (chess.KNIGHT, chess.BISHOP):\n            val = 3.0\n        elif piece.piece_type == chess.ROOK:\n            val = 5.0\n        elif piece.piece_type == chess.QUEEN:\n            val = 9.0\n        else:\n            val = 0.0\n        if piece.color == chess.WHITE:\n            white += val\n        else:\n            black += val\n    return [float(white - black)]", "def feature(board: chess.Board) -> list[float]:\n    'pawn material balance: white minus black pawns'\n    white_pawns = 0\n    black_pawns = 0\n    for sq, piece in board.piece_map().items():\n        if piece.piece_type == chess.PAWN:\n            if piece.color == chess.WHITE:\n                white_pawns += 1\n            else:\n                black_pawns += 1\n    return [float(white_pawns - black_pawns)]", "def feature(board: chess.Board) -> list[float]:\n    'king safety delta: attackers on white king minus attackers on black king'\n    wk = board.king(chess.WHITE)\n    bk = board.king(chess.BLACK)\n    a_wk = len(board.attackers(chess.BLACK, wk)) if wk is not None else 0\n    a_bk = len(board.attackers(chess.WHITE, bk)) if bk is not None else 0\n    return [float(a_wk - a_bk)]", "def feature(board: chess.Board) -> list[float]:\n    'developed minor pieces balance: white minus black developed minors'\n    white_dev = 0\n    black_dev = 0\n    for sq, piece in board.piece_map().items():\n        if piece.color == chess.WHITE and piece.piece_type in (chess.KNIGHT, chess.BISHOP):\n            if piece.piece_type == chess.KNIGHT:\n                if sq not in (chess.B1, chess.G1):\n                    white_dev += 1\n            else:  # bishop\n                if sq not in (chess.C1, chess.F1):\n                    white_dev += 1\n        if piece.color == chess.BLACK and piece.piece_type in (chess.KNIGHT, chess.BISHOP):\n            if piece.piece_type == chess.KNIGHT:\n                if sq not in (chess.B8, chess.G8):\n                    black_dev += 1\n            else:  # bishop\n                if sq not in (chess.C8, chess.F8):\n                    black_dev += 1\n    return [float(white_dev - black_dev)]", "def feature(board: chess.Board) -> list[float]:\n    'queen count balance: white minus black queens'\n    white_q = 0\n    black_q = 0\n    for piece in board.piece_map().values():\n        if piece.piece_type == chess.QUEEN:\n            if piece.color == chess.WHITE:\n                white_q += 1\n            else:\n                black_q += 1\n    return [float(white_q - black_q)]", "def feature(board: chess.Board) -> list[float]:\n    'passed pawns balance: white minus black passed pawns'\n    def is_passed(color: chess.Color, square: int) -> bool:\n        file = chess.square_file(square)\n        rank = chess.square_rank(square)\n        if color == chess.WHITE:\n            for r in range(rank + 1, 8):\n                s = chess.square(file, r)\n                p = board.piece_at(s)\n                if p is not None and p.piece_type == chess.PAWN and p.color == chess.BLACK:\n                    return False\n            return True\n        else:\n            for r in range(0, rank):\n                s = chess.square(file, r)\n                p = board.piece_at(s)\n                if p is not None and p.piece_type == chess.PAWN and p.color == chess.WHITE:\n                    return False\n            return True\n    white_passed = 0\n    black_passed = 0\n    for sq, piece in board.piece_map().items():\n        if piece.piece_type == chess.PAWN:\n            if piece.color == chess.WHITE:\n                if is_passed(chess.WHITE, sq):\n                    white_passed += 1\n            else:\n                if is_passed(chess.BLACK, sq):\n                    black_passed += 1\n    return [float(white_passed - black_passed)]", "def feature(board: chess.Board) -> list[float]:\n    'total pieces (excluding kings) balance: white minus black'\n    white_total = 0\n    black_total = 0\n    for piece in board.piece_map().values():\n        if piece.piece_type != chess.KING:\n            if piece.color == chess.WHITE:\n                white_total += 1\n            else:\n                black_total += 1\n    return [float(white_total - black_total)]", "def feature(board: chess.Board) -> list[float]:\n    'center control diff: white central influence minus black central influence'\n    center_sqs = [chess.D4, chess.E4, chess.D5, chess.E5]\n    white_influence = 0\n    black_influence = 0\n    for s in center_sqs:\n        p = board.piece_at(s)\n        if p is not None:\n            if p.color == chess.WHITE:\n                white_influence += 1\n            else:\n                black_influence += 1\n        if board.is_attacked_by(chess.WHITE, s):\n            white_influence += 1\n        if board.is_attacked_by(chess.BLACK, s):\n            black_influence += 1\n    return [float(white_influence - black_influence)]", "def feature(board: chess.Board) -> list[float]:\n    'king distance between kings'\n    wk = board.king(chess.WHITE)\n    bk = board.king(chess.BLACK)\n    if wk is None or bk is None:\n        return [0.0]\n    dist = chess.square_distance(wk, bk)\n    return [float(dist)]", "def feature(board: chess.Board) -> list[float]:\n    'isolated pawns balance: white minus black isolated pawns'\n    white_pawns_by_file = [0] * 8\n    black_pawns_by_file = [0] * 8\n    for sq, piece in board.piece_map().items():\n        if piece.piece_type == chess.PAWN:\n            f = chess.square_file(sq)\n            if piece.color == chess.WHITE:\n                white_pawns_by_file[f] += 1\n            else:\n                black_pawns_by_file[f] += 1\n    def count_isolated(pawn_counts):\n        isolated = 0\n        for f in range(8):\n            left = pawn_counts[f - 1] if f - 1 >= 0 else 0\n            right = pawn_counts[f + 1] if f + 1 < 8 else 0\n            if pawn_counts[f] > 0 and left == 0 and right == 0:\n                isolated += pawn_counts[f]\n        return isolated\n    white_isolated = count_isolated(white_pawns_by_file)\n    black_isolated = count_isolated(black_pawns_by_file)\n    return [float(white_isolated - black_isolated)]", "def feature(board: chess.Board) -> list[float]:\n    \"material_balance: white material minus black material\"\n    piece_values = {\n        chess.PAWN: 1.0,\n        chess.KNIGHT: 3.0,\n        chess.BISHOP: 3.0,\n        chess.ROOK: 5.0,\n        chess.QUEEN: 9.0,\n        chess.KING: 0.0\n    }\n    total = 0.0\n    for sq, piece in board.piece_map().items():\n        val = piece_values.get(piece.piece_type, 0.0)\n        total += val if piece.color == chess.WHITE else -val\n    return [float(total)]", "def feature(board: chess.Board) -> list[float]:\n    \"material_major_balance: white major pieces minus black major pieces (queens and rooks)\"\n    val = 0.0\n    for sq, piece in board.piece_map().items():\n        if piece.piece_type in (chess.ROOK, chess.QUEEN):\n            mv = 5.0 if piece.piece_type == chess.ROOK else 9.0\n            val += mv if piece.color == chess.WHITE else -mv\n    return [float(val)]", "def feature(board: chess.Board) -> list[float]:\n    \"doubled pawns difference between White and Black\"\n    counts_white = [0] * 8\n    counts_black = [0] * 8\n    for sq, piece in board.piece_map().items():\n        if piece.piece_type == chess.PAWN:\n            f = chess.square_file(sq)\n            if piece.color == chess.WHITE:\n                counts_white[f] += 1\n            else:\n                counts_black[f] += 1\n    doubled_white = sum(max(0, c - 1) for c in counts_white)\n    doubled_black = sum(max(0, c - 1) for c in counts_black)\n    return [float(doubled_white - doubled_black)]", "def feature(board: chess.Board) -> list[float]:\n    \"isolated pawns difference: white minus black\"\n    white_counts = [0] * 8\n    black_counts = [0] * 8\n    white_pawns = []\n    black_pawns = []\n    for sq, piece in board.piece_map().items():\n        if piece.piece_type == chess.PAWN:\n            f = chess.square_file(sq)\n            if piece.color == chess.WHITE:\n                white_pawns.append((sq, f))\n                white_counts[f] += 1\n            else:\n                black_pawns.append((sq, f))\n                black_counts[f] += 1\n    white_isolated = 0\n    for _, f in white_pawns:\n        left = white_counts[f - 1] if f > 0 else 0\n        right = white_counts[f + 1] if f < 7 else 0\n        if left == 0 and right == 0:\n            white_isolated += 1\n    black_isolated = 0\n    for _, f in black_pawns:\n        left = black_counts[f - 1] if f > 0 else 0\n        right = black_counts[f + 1] if f < 7 else 0\n        if left == 0 and right == 0:\n            black_isolated += 1\n    return [float(white_isolated - black_isolated)]", "def feature(board: chess.Board) -> list[float]:\n    \"center occupancy difference: white vs black on center squares\"\n    center_squares = [chess.D4, chess.E4, chess.D5, chess.E5]\n    white_count = 0\n    black_count = 0\n    for sq in center_squares:\n        p = board.piece_at(sq)\n        if p is not None:\n            if p.color == chess.WHITE:\n                white_count += 1\n            else:\n                black_count += 1\n    return [float(white_count - black_count)]", "def feature(board: chess.Board) -> list[float]:\n    \"mobility: number of legal moves for side to move\"\n    return [float(len(list(board.legal_moves)))]", "def feature(board: chess.Board) -> list[float]:\n    \"mobility by color: difference in number of legal moves White vs Black if to move\"\n    def mobility_for(color):\n        b = board.copy()\n        b.turn = color\n        return len(list(b.legal_moves))\n    w = mobility_for(chess.WHITE)\n    b = mobility_for(chess.BLACK)\n    return [float(w - b)]", "def feature(board: chess.Board) -> list[float]:\n    \"king safety: negative of number of attackers on current player's king\"\n    turn = board.turn\n    king_sq = board.king(turn)\n    if king_sq is None:\n        attackers = 0\n    else:\n        opp = chess.BLACK if turn == chess.WHITE else chess.WHITE\n        attackers = len(board.attackers(opp, king_sq))\n    return [float(-attackers)]", "def feature(board: chess.Board) -> list[float]:\n    \"passed pawns difference: white minus black\"\n    white_pawns = []\n    black_pawns = []\n    for sq, piece in board.piece_map().items():\n        if piece.piece_type == chess.PAWN:\n            f = chess.square_file(sq)\n            r = chess.square_rank(sq)\n            if piece.color == chess.WHITE:\n                white_pawns.append((sq, f, r))\n            else:\n                black_pawns.append((sq, f, r))\n    passed_white = 0\n    for _, f, r in white_pawns:\n        blocked = False\n        for _, bf, br in black_pawns:\n            if abs(bf - f) <= 1 and br > r:\n                blocked = True\n                break\n        if not blocked:\n            passed_white += 1\n    passed_black = 0\n    for _, f, r in black_pawns:\n        blocked = False\n        for _, wf, wr in white_pawns:\n            if abs(wf - f) <= 1 and wr < r:\n                blocked = True\n                break\n        if not blocked:\n            passed_black += 1\n    return [float(passed_white - passed_black)]", "def feature(board: chess.Board) -> list[float]:\n    \"minor piece imbalance: white minor pieces minus black minor pieces\"\n    white_minors = 0\n    black_minors = 0\n    for sq, piece in board.piece_map().items():\n        if piece.piece_type in (chess.KNIGHT, chess.BISHOP):\n            if piece.color == chess.WHITE:\n                white_minors += 1\n            else:\n                black_minors += 1\n    return [float(white_minors - black_minors)]", "def feature(board: chess.Board) -> list[float]:\n    \"Material balance: total white material minus black material using standard piece values\"\n    import chess\n    values = {chess.PAWN: 1, chess.KNIGHT: 3, chess.BISHOP: 3, chess.ROOK: 5, chess.QUEEN: 9}\n    white_val = 0.0\n    black_val = 0.0\n    for sq, piece in board.piece_map().items():\n        val = float(values.get(piece.piece_type, 0))\n        if piece.color == chess.WHITE:\n            white_val += val\n        else:\n            black_val += val\n    return white_val - black_val", "def feature(board: chess.Board) -> list[float]:\n    \"Pawn balance: number of white pawns minus number of black pawns\"\n    import chess\n    white_pawns = len(board.pieces(chess.PAWN, chess.WHITE))\n    black_pawns = len(board.pieces(chess.PAWN, chess.BLACK))\n    return float(white_pawns - black_pawns)", "def feature(board: chess.Board) -> list[float]:\n    \"Passed pawn score: white passed pawns minus black passed pawns (simple heuristic)\"\n    import chess\n    passed_white = 0\n    passed_black = 0\n    white_pawns = [sq for sq, p in board.piece_map().items() if p.color == chess.WHITE and p.piece_type == chess.PAWN]\n    black_pawns = [sq for sq, p in board.piece_map().items() if p.color == chess.BLACK and p.piece_type == chess.PAWN]\n    # Helper to check if a white pawn at sq is passed\n    def is_white_passed(sq):\n        f = chess.square_file(sq)\n        r = chess.square_rank(sq)\n        for sq2, p2 in board.piece_map().items():\n            if p2.color == chess.BLACK and p2.piece_type == chess.PAWN:\n                f2 = chess.square_file(sq2)\n                r2 = chess.square_rank(sq2)\n                if abs(f2 - f) <= 1 and r2 > r:\n                    return False\n        return True\n    def is_black_passed(sq):\n        f = chess.square_file(sq)\n        r = chess.square_rank(sq)\n        for sq2, p2 in board.piece_map().items():\n            if p2.color == chess.WHITE and p2.piece_type == chess.PAWN:\n                f2 = chess.square_file(sq2)\n                r2 = chess.square_rank(sq2)\n                if abs(f2 - f) <= 1 and r2 < r:\n                    return False\n        return True\n    for sq in white_pawns:\n        if is_white_passed(sq):\n            passed_white += 1\n    for sq in black_pawns:\n        if is_black_passed(sq):\n            passed_black += 1\n    return float(passed_white - passed_black)", "def feature(board: chess.Board) -> list[float]:\n    \"King safety: number of attackers to the side to move's king\"\n    import chess\n    turn = board.turn\n    opp = chess.BLACK if turn == chess.WHITE else chess.WHITE\n    ksq = board.king(turn)\n    if ksq is None:\n        return 0.0\n    attackers = board.attackers(opp, ksq)\n    return float(len(attackers))", "def feature(board: chess.Board) -> list[float]:\n    \"Mobility imbalance: difference in legal moves for White vs Black (computed on copies)\"\n    import chess\n    b_white = board.copy()\n    b_white.turn = chess.WHITE\n    m_white = len(list(b_white.legal_moves))\n    b_black = board.copy()\n    b_black.turn = chess.BLACK\n    m_black = len(list(b_black.legal_moves))\n    return float(m_white - m_black)", "def feature(board: chess.Board) -> list[float]:\n    \"Doubled pawns penalty difference: white doubled pawns minus black doubled pawns\"\n    import chess\n    def count_doubled(color):\n        doubled = 0\n        for file in range(8):\n            count = 0\n            for rank in range(8):\n                sq = chess.square(file, rank)\n                p = board.piece_at(sq)\n                if p is not None and p.color == color and p.piece_type == chess.PAWN:\n                    count += 1\n            if count > 1:\n                doubled += (count - 1)\n        return doubled\n    white_doubled = count_doubled(chess.WHITE)\n    black_doubled = count_doubled(chess.BLACK)\n    return float(white_doubled - black_doubled)", "def feature(board: chess.Board) -> list[float]:\n    \"Bishop pair presence: white bishop pair minus black bishop pair (1 if pair exists, else 0)\"\n    import chess\n    def has_pair(color):\n        bis = [sq for sq, p in board.piece_map().items() if p.color == color and p.piece_type == chess.BISHOP]\n        return len(bis) >= 2\n    white_pair = 1 if has_pair(chess.WHITE) else 0\n    black_pair = 1 if has_pair(chess.BLACK) else 0\n    return float(white_pair - black_pair)", "def feature(board: chess.Board) -> list[float]:\n    \"Development score: developed minor pieces (knights/bishops) for White minus Black\"\n    import chess\n    def developed(color):\n        developed_count = 0\n        white_start_knights = {chess.B1, chess.G1}\n        white_start_bishops = {chess.C1, chess.F1}\n        black_start_knights = {chess.B8, chess.G8}\n        black_start_bishops = {chess.C8, chess.F8}\n        for sq, p in board.piece_map().items():\n            if p.color != color:\n                continue\n            if p.piece_type in (chess.KNIGHT, chess.BISHOP):\n                if color == chess.WHITE:\n                    if p.piece_type == chess.KNIGHT:\n                        if sq not in white_start_knights:\n                            developed_count += 1\n                    else:\n                        if sq not in white_start_bishops:\n                            developed_count += 1\n                else:\n                    if p.piece_type == chess.KNIGHT:\n                        if sq not in black_start_knights:\n                            developed_count += 1\n                    else:\n                        if sq not in black_start_bishops:\n                            developed_count += 1\n        return developed_count\n    white_dev = developed(chess.WHITE)\n    black_dev = developed(chess.BLACK)\n    return float(white_dev - black_dev)", "def feature(board: chess.Board) -> list[float]:\n    \"King distance: Manhattan distance between the two kings\"\n    import chess\n    wk = board.king(chess.WHITE)\n    bk = board.king(chess.BLACK)\n    if wk is None or bk is None:\n        return 0.0\n    dist = abs(chess.square_file(wk) - chess.square_file(bk)) + abs(chess.square_rank(wk) - chess.square_rank(bk))\n    return float(dist)", "def feature(board: chess.Board) -> list[float]:\n    \"Heavy piece imbalance: white rooks/queens minus black rooks/queens\"\n    import chess\n    white_heavy = 0\n    black_heavy = 0\n    for sq, p in board.piece_map().items():\n        if p.piece_type in (chess.ROOK, chess.QUEEN):\n            if p.color == chess.WHITE:\n                white_heavy += 1\n            else:\n                black_heavy += 1\n    return float(white_heavy - black_heavy)", "def feature(board: chess.Board) -> list[float]:\n    \"Material balance: white material minus black material\"\n    white = 0.0\n    black = 0.0\n    for sq, piece in board.piece_map().items():\n        if piece.piece_type == chess.PAWN:\n            val = 1.0\n        elif piece.piece_type in (chess.KNIGHT, chess.BISHOP):\n            val = 3.0\n        elif piece.piece_type == chess.ROOK:\n            val = 5.0\n        elif piece.piece_type == chess.QUEEN:\n            val = 9.0\n        else:\n            val = 0.0\n        if piece.color == chess.WHITE:\n            white += val\n        else:\n            black += val\n    return [float(white - black)]", "def feature(board: chess.Board) -> list[float]:\n    \"Center control: white pieces in center minus black pieces in center\"\n    center_squares = {chess.D4, chess.E4, chess.D5, chess.E5}\n    white_center = 0\n    black_center = 0\n    for sq, piece in board.piece_map().items():\n        if sq in center_squares:\n            if piece.color == chess.WHITE:\n                white_center += 1\n            else:\n                black_center += 1\n    return [float(white_center - black_center)]", "def feature(board: chess.Board) -> list[float]:\n    \"Open-file rook presence balance: white rooks on open files minus black rooks on open files\"\n    white_rooks_on_open = 0\n    black_rooks_on_open = 0\n    for file in range(8):\n        has_pawn_on_file = False\n        white_rooks_on_file = 0\n        black_rooks_on_file = 0\n        for rank in range(8):\n            sq = chess.square(file, rank)\n            p = board.piece_at(sq)\n            if p is not None and p.piece_type == chess.PAWN:\n                has_pawn_on_file = True\n            if p is not None and p.piece_type == chess.ROOK:\n                if p.color == chess.WHITE:\n                    white_rooks_on_file += 1\n                else:\n                    black_rooks_on_file += 1\n        if not has_pawn_on_file:\n            white_rooks_on_open += white_rooks_on_file\n            black_rooks_on_open += black_rooks_on_file\n    return [float(white_rooks_on_open - black_rooks_on_open)]", "def feature(board: chess.Board) -> list[float]:\n    \"Passed pawns difference: white passed pawns minus black passed pawns\"\n    def is_passed(board: chess.Board, sq: int, color: int) -> bool:\n        f = chess.square_file(sq)\n        r = chess.square_rank(sq)\n        if color == chess.WHITE:\n            for df in (-1, 0, 1):\n                f2 = f + df\n                if 0 <= f2 <= 7:\n                    for r2 in range(r + 1, 8):\n                        sq2 = chess.square(f2, r2)\n                        pc = board.piece_at(sq2)\n                        if pc is not None and pc.piece_type == chess.PAWN and pc.color == chess.BLACK:\n                            return False\n            return True\n        else:\n            for df in (-1, 0, 1):\n                f2 = f + df\n                if 0 <= f2 <= 7:\n                    for r2 in range(0, r):\n                        sq2 = chess.square(f2, r2)\n                        pc = board.piece_at(sq2)\n                        if pc is not None and pc.piece_type == chess.PAWN and pc.color == chess.WHITE:\n                            return False\n            return True\n    white_passed = 0\n    black_passed = 0\n    for sq, piece in board.piece_map().items():\n        if piece.piece_type == chess.PAWN:\n            if piece.color == chess.WHITE:\n                if is_passed(board, sq, chess.WHITE):\n                    white_passed += 1\n            else:\n                if is_passed(board, sq, chess.BLACK):\n                    black_passed += 1\n    return [float(white_passed - black_passed)]", "def feature(board: chess.Board) -> list[float]:\n    \"Piece activity difference: number of pieces with at least one legal move (per side)\"\n    def has_move_from(board: chess.Board, sq: int) -> bool:\n        for m in board.legal_moves:\n            if m.from_square == sq:\n                return True\n        return False\n    white_active = 0\n    black_active = 0\n    for sq, piece in board.piece_map().items():\n        if has_move_from(board, sq):\n            if piece.color == chess.WHITE:\n                white_active += 1\n            else:\n                black_active += 1\n    return [float(white_active - black_active)]", "def feature(board: chess.Board) -> list[float]:\n    \"Current king safety flag: 1.0 if in check else 0.0\"\n    return [float(board.is_check())]", "def feature(board: chess.Board) -> list[float]:\n    \"Weighted attackers on own king: sum of attacker piece values from opponent on own king square\"\n    king_sq = board.king(board.turn)\n    if king_sq is None:\n        return [float(0.0)]\n    attackers = board.attackers(not board.turn, king_sq)\n    weight = 0.0\n    for a in attackers:\n        p = board.piece_at(a)\n        if p is None:\n            continue\n        if p.piece_type == chess.PAWN:\n            w = 1.0\n        elif p.piece_type in (chess.KNIGHT, chess.BISHOP):\n            w = 3.0\n        elif p.piece_type == chess.ROOK:\n            w = 5.0\n        elif p.piece_type == chess.QUEEN:\n            w = 9.0\n        else:\n            w = 0.0\n        weight += w\n    return [float(weight)]", "def feature(board: chess.Board) -> list[float]:\n    \"Isolated pawns difference: white isolated pawns minus black isolated pawns\"\n    def is_isolated(board: chess.Board, sq: int, color: int) -> bool:\n        f = chess.square_file(sq)\n        r = chess.square_rank(sq)\n        for df in (-1, 1):\n            f2 = f + df\n            if 0 <= f2 <= 7:\n                for rr in range(8):\n                    sq2 = chess.square(f2, rr)\n                    p = board.piece_at(sq2)\n                    if p is not None and p.color == color and p.piece_type == chess.PAWN:\n                        return False\n        return True\n    white_isolated = 0\n    black_isolated = 0\n    for sq, piece in board.piece_map().items():\n        if piece.piece_type != chess.PAWN:\n            continue\n        if piece.color == chess.WHITE:\n            if is_isolated(board, sq, chess.WHITE):\n                white_isolated += 1\n        else:\n            if is_isolated(board, sq, chess.BLACK):\n                black_isolated += 1\n    return [float(white_isolated - black_isolated)]", "def feature(board: chess.Board) -> list[float]:\n    \"Queen defenders balance: total number of own defenders of queens difference (white minus black)\"\n    white_defenders = 0\n    black_defenders = 0\n    for sq, piece in board.piece_map().items():\n        if piece.piece_type == chess.QUEEN:\n            if piece.color == chess.WHITE:\n                white_defenders += len(board.attackers(chess.WHITE, sq))\n            else:\n                black_defenders += len(board.attackers(chess.BLACK, sq))\n    return [float(white_defenders - black_defenders)]", "def feature(board: chess.Board) -> list[float]:\n    \"Blocked pawns difference: white blocked pawns minus black blocked pawns\"\n    white_blocked = 0\n    black_blocked = 0\n    for sq, piece in board.piece_map().items():\n        if piece.piece_type != chess.PAWN:\n            continue\n        f = chess.square_file(sq)\n        r = chess.square_rank(sq)\n        if piece.color == chess.WHITE:\n            if r + 1 < 8 and board.piece_at(chess.square(f, r + 1)) is not None:\n                white_blocked += 1\n        else:\n            if r - 1 >= 0 and board.piece_at(chess.square(f, r - 1)) is not None:\n                black_blocked += 1\n    return [float(white_blocked - black_blocked)]", "def feature(board: chess.Board) -> list[float]:\n    \"material balance in points (White minus Black)\"\n    import chess\n    VAL = {chess.PAWN: 1, chess.KNIGHT: 3, chess.BISHOP: 3, chess.ROOK: 5, chess.QUEEN: 9, chess.KING: 0}\n    white = 0.0\n    black = 0.0\n    for sq, p in board.piece_map().items():\n        val = VAL.get(p.piece_type, 0)\n        if p.color == chess.WHITE:\n            white += val\n        else:\n            black += val\n    return white - black", "def feature(board: chess.Board) -> list[float]:\n    \"pawn balance: white pawns minus black pawns\"\n    import chess\n    white = 0\n    black = 0\n    for sq, p in board.piece_map().items():\n        if p.piece_type == chess.PAWN:\n            if p.color == chess.WHITE:\n                white += 1\n            else:\n                black += 1\n    return float(white - black)", "def feature(board: chess.Board) -> list[float]:\n    \"mobility score: number of legal moves for side to move\"\n    import chess\n    return float(len(list(board.legal_moves)))", "def feature(board: chess.Board) -> list[float]:\n    \"rooks on open files: rooks on files with no pawns of either color\"\n    import chess\n    files_with_pawns = set()\n    for sq, p in board.piece_map().items():\n        if p.piece_type == chess.PAWN:\n            files_with_pawns.add(chess.square_file(sq))\n    rooks_on_open = 0\n    for sq, p in board.piece_map().items():\n        if p.piece_type == chess.ROOK and chess.square_file(sq) not in files_with_pawns:\n            rooks_on_open += 1\n    return float(rooks_on_open)", "def feature(board: chess.Board) -> list[float]:\n    \"king safety score: sum of nearby enemy attacks to each king's surrounding squares\"\n    import chess\n    score = 0\n    for color in (chess.WHITE, chess.BLACK):\n        king_sq = None\n        for sq, p in board.piece_map().items():\n            if p.color == color and p.piece_type == chess.KING:\n                king_sq = sq\n                break\n        if king_sq is None:\n            continue\n        f = chess.square_file(king_sq)\n        r = chess.square_rank(king_sq)\n        opp = chess.BLACK if color == chess.WHITE else chess.WHITE\n        for df in (-1, 0, 1):\n            for dr in (-1, 0, 1):\n                if df == 0 and dr == 0:\n                    continue\n                nf = f + df\n                nr = r + dr\n                if 0 <= nf < 8 and 0 <= nr < 8:\n                    nb = chess.square(nf, nr)\n                    if board.is_attacked_by(opp, nb):\n                        score += 1\n    return float(score)", "def feature(board: chess.Board) -> list[float]:\n    \"center control: number of pieces on central squares (d4,e4,d5,e5) with color weighting\"\n    import chess\n    center_sqs = [chess.D4, chess.E4, chess.D5, chess.E5]\n    white = 0\n    black = 0\n    for sq in center_sqs:\n        p = board.piece_at(sq)\n        if p is None:\n            continue\n        if p.color == chess.WHITE:\n            white += 1\n        else:\n            black += 1\n    return float(white - black)", "def feature(board: chess.Board) -> list[float]:\n    \"passed pawn balance: number of passed white pawns minus passed black pawns\"\n    import chess\n\n    def is_passed_white(p_sq):\n        f = chess.square_file(p_sq)\n        r = chess.square_rank(p_sq)\n        for sq, piece in board.piece_map().items():\n            if piece.color == chess.BLACK and piece.piece_type == chess.PAWN:\n                f2 = chess.square_file(sq)\n                r2 = chess.square_rank(sq)\n                if abs(f2 - f) <= 1 and r2 > r:\n                    return False\n        return True\n\n    def is_passed_black(p_sq):\n        f = chess.square_file(p_sq)\n        r = chess.square_rank(p_sq)\n        for sq, piece in board.piece_map().items():\n            if piece.color == chess.WHITE and piece.piece_type == chess.PAWN:\n                f2 = chess.square_file(sq)\n                r2 = chess.square_rank(sq)\n                if abs(f2 - f) <= 1 and r2 < r:\n                    return False\n        return True\n\n    white_passed = 0\n    black_passed = 0\n    for sq, p in board.piece_map().items():\n        if p.piece_type == chess.PAWN:\n            if p.color == chess.WHITE:\n                if is_passed_white(sq):\n                    white_passed += 1\n            else:\n                if is_passed_black(sq):\n                    black_passed += 1\n    return float(white_passed - black_passed)", "def feature(board: chess.Board) -> list[float]:\n    \"doubled pawns balance: white doubled pawns minus black doubled pawns\"\n    import chess\n    white_doubled = 0\n    black_doubled = 0\n    for file in range(8):\n        white_on_file = 0\n        black_on_file = 0\n        for sq, p in board.piece_map().items():\n            if p.piece_type == chess.PAWN:\n                if chess.square_file(sq) == file:\n                    if p.color == chess.WHITE:\n                        white_on_file += 1\n                    else:\n                        black_on_file += 1\n        if white_on_file > 1:\n            white_doubled += white_on_file - 1\n        if black_on_file > 1:\n            black_doubled += black_on_file - 1\n    return float(white_doubled - black_doubled)", "def feature(board: chess.Board) -> list[float]:\n    \"minor piece imbalance: knights+bishops white minus black\"\n    import chess\n    white_minors = 0\n    black_minors = 0\n    for square, p in board.piece_map().items():\n        if p.piece_type in (chess.KNIGHT, chess.BISHOP):\n            if p.color == chess.WHITE:\n                white_minors += 1\n            else:\n                black_minors += 1\n    return float(white_minors - black_minors)", "def feature(board: chess.Board) -> list[float]:\n    \"isolated pawns balance: white isolated pawns minus black isolated pawns\"\n    import chess\n\n    def is_isolated(square, color):\n        f = chess.square_file(square)\n        # collect pawns of same color on adjacent files\n        for df in (-1, 1):\n            af = f + df\n            if 0 <= af < 8:\n                for sq, p in board.piece_map().items():\n                    if p.color == color and p.piece_type == chess.PAWN and chess.square_file(sq) == af:\n                        return False\n        return True\n\n    white_iso = 0\n    black_iso = 0\n    for sq, p in board.piece_map().items():\n        if p.piece_type == chess.PAWN:\n            if p.color == chess.WHITE:\n                if is_isolated(sq, chess.WHITE):\n                    white_iso += 1\n            else:\n                if is_isolated(sq, chess.BLACK):\n                    black_iso += 1\n    return float(white_iso - black_iso)", "def feature(board: chess.Board) -> list[float]:\n    \"material balance: white material minus black material\"\n    values = {chess.PAWN: 1, chess.KNIGHT: 3, chess.BISHOP: 3, chess.ROOK: 5, chess.QUEEN: 9, chess.KING: 0}\n    material = 0.0\n    for piece in board.piece_map().values():\n        v = values.get(piece.piece_type, 0)\n        material += v if piece.color == chess.WHITE else -v\n    return [float(material)]", "def feature(board: chess.Board) -> list[float]:\n    \"mobility: number of legal moves for side to move\"\n    return [float(len(list(board.legal_moves)))]", "def feature(board: chess.Board) -> list[float]:\n    \"mobility by color difference (White vs Black moves)\"\n    white_mob = 0\n    black_mob = 0\n    b1 = board.copy()\n    b1.turn = chess.WHITE\n    white_mob = len(list(b1.legal_moves))\n    b2 = board.copy()\n    b2.turn = chess.BLACK\n    black_mob = len(list(b2.legal_moves))\n    diff = white_mob - black_mob\n    return [float(diff)]", "def feature(board: chess.Board) -> list[float]:\n    \"is the side to move in check?\"\n    return [1.0 if board.is_check() else 0.0]", "def feature(board: chess.Board) -> list[float]:\n    \"penalty for doubled pawns (negative value)\"\n    white_counts = [0] * 8\n    black_counts = [0] * 8\n    for sq, piece in board.piece_map().items():\n        if piece.piece_type == chess.PAWN:\n            f = chess.square_file(sq)\n            if piece.color == chess.WHITE:\n                white_counts[f] += 1\n            else:\n                black_counts[f] += 1\n    def doubled(counts):\n        return sum(max(0, c - 1) for c in counts)\n    doubled = doubled(white_counts) + doubled(black_counts)\n    return [float(-doubled)]", "def feature(board: chess.Board) -> list[float]:\n    \"number of queens on central squares (D4, E4, D5, E5)\"\n    central = {chess.D4, chess.E4, chess.D5, chess.E5}\n    count = 0\n    for sq, piece in board.piece_map().items():\n        if piece.piece_type == chess.QUEEN and sq in central:\n            count += 1\n    return [float(count)]", "def feature(board: chess.Board) -> list[float]:\n    \"king distance between WHITE and BLACK kings (lower is more dangerous)\"\n    wk = board.king(chess.WHITE)\n    bk = board.king(chess.BLACK)\n    if wk is None or bk is None:\n        dist = 0\n    else:\n        dist = chess.square_distance(wk, bk)\n    return [float(dist)]", "def feature(board: chess.Board) -> list[float]:\n    \"difference in isolated pawns between White and Black\"\n    white_counts = [0] * 8\n    black_counts = [0] * 8\n    for sq, piece in board.piece_map().items():\n        if piece.piece_type == chess.PAWN:\n            f = chess.square_file(sq)\n            if piece.color == chess.WHITE:\n                white_counts[f] += 1\n            else:\n                black_counts[f] += 1\n    def isolated(counts):\n        isolated = 0\n        for f in range(8):\n            left = counts[f - 1] if f > 0 else 0\n            right = counts[f + 1] if f < 7 else 0\n            if left > 0 or right > 0:\n                continue\n            isolated += counts[f]\n        return isolated\n    white_iso = isolated(white_counts)\n    black_iso = isolated(black_counts)\n    return [float(white_iso - black_iso)]", "def feature(board: chess.Board) -> list[float]:\n    \"center control balance on central squares\"\n    central = [chess.D4, chess.E4, chess.D5, chess.E5]\n    score = 0\n    for sq in central:\n        if board.is_attacked_by(chess.WHITE, sq):\n            score += 1\n        if board.is_attacked_by(chess.BLACK, sq):\n            score -= 1\n    return [float(score)]", "def feature(board: chess.Board) -> list[float]:\n    \"active rooks: number of rooks that have at least one legal move for side to move\"\n    moves = list(board.legal_moves)\n    from_sqs = set(m.from_square for m in moves)\n    active = 0\n    for sq in from_sqs:\n        p = board.piece_at(sq)\n        if p is not None and p.piece_type == chess.ROOK and p.color == board.turn:\n            active += 1\n    return [float(active)]", "def feature(board: chess.Board) -> list[float]:\n    'material balance: white material minus black material'\n    value = 0.0\n    piece_values = {\n        chess.PAWN: 1,\n        chess.KNIGHT: 3,\n        chess.BISHOP: 3,\n        chess.ROOK: 5,\n        chess.QUEEN: 9,\n        chess.KING: 0\n    }\n    for sq, piece in board.piece_map().items():\n        v = piece_values.get(piece.piece_type, 0)\n        value += v if piece.color == chess.WHITE else -v\n    return [float(value)]", "def feature(board: chess.Board) -> list[float]:\n    'is the side to move currently in check'\n    val = 1.0 if board.is_check() else 0.0\n    return [val]", "def feature(board: chess.Board) -> list[float]:\n    'mobility: number of legal moves for side to move'\n    val = len(list(board.legal_moves))\n    return [float(val)]", "def feature(board: chess.Board) -> list[float]:\n    'mobility by color: per-piece mobility difference between colors'\n    white_piece_mobility = 0\n    black_piece_mobility = 0\n    white_turn = chess.WHITE\n    black_turn = chess.BLACK\n\n    # Count mobility per piece by simulating moves from each piece square\n    for sq, piece in board.piece_map().items():\n        if piece.color == white_turn:\n            wb = board.copy()\n            wb.turn = white_turn\n            white_moves = [m for m in wb.legal_moves if m.from_square == sq]\n            white_piece_mobility += len(white_moves)\n        elif piece.color == black_turn:\n            bb = board.copy()\n            bb.turn = black_turn\n            black_moves = [m for m in bb.legal_moves if m.from_square == sq]\n            black_piece_mobility += len(black_moves)\n\n    val = white_piece_mobility - black_piece_mobility\n    return [float(val)]", "def feature(board: chess.Board) -> list[float]:\n    'difference in control of the center squares (d4,e4,d5,e5)'\n    center_sqs = [chess.D4, chess.E4, chess.D5, chess.E5]\n    white_control = 0\n    black_control = 0\n    for sq in center_sqs:\n        white_control += len(board.attackers(chess.WHITE, sq))\n        black_control += len(board.attackers(chess.BLACK, sq))\n    val = white_control - black_control\n    return [float(val)]", "def feature(board: chess.Board) -> list[float]:\n    'enemy king attacked by side to move right now'\n    opp = chess.BLACK if board.turn == chess.WHITE else chess.WHITE\n    enemy_king_square = None\n    for sq, piece in board.piece_map().items():\n        if piece.color == opp and piece.piece_type == chess.KING:\n            enemy_king_square = sq\n            break\n    attacked = False\n    if enemy_king_square is not None:\n        attacked = board.is_attacked_by(board.turn, enemy_king_square)\n    return [1.0 if attacked else 0.0]", "def feature(board: chess.Board) -> list[float]:\n    'king safety: number of defenders of the to-move king'\n    own_king_square = None\n    for sq, piece in board.piece_map().items():\n        if piece.piece_type == chess.KING and piece.color == board.turn:\n            own_king_square = sq\n            break\n    defenders = 0\n    if own_king_square is not None:\n        defenders = len(board.attackers(board.turn, own_king_square))\n    val = -float(defenders)\n    return [val]", "def feature(board: chess.Board) -> list[float]:\n    'doubled pawns difference: white minus black'\n    white_counts = [0] * 8\n    black_counts = [0] * 8\n    for sq, piece in board.piece_map().items():\n        if piece.piece_type == chess.PAWN:\n            file = chess.square_file(sq)\n            if piece.color == chess.WHITE:\n                white_counts[file] += 1\n            else:\n                black_counts[file] += 1\n    white_doubled = sum(max(0, c - 1) for c in white_counts)\n    black_doubled = sum(max(0, c - 1) for c in black_counts)\n    val = white_doubled - black_doubled\n    return [float(val)]", "def feature(board: chess.Board) -> list[float]:\n    'center file pawn presence: white minus black pawns on d or e files'\n    central_files = [3, 4]  # d and e\n    white_center_pawns = 0\n    black_center_pawns = 0\n    for sq, piece in board.piece_map().items():\n        if piece.piece_type == chess.PAWN:\n            f = chess.square_file(sq)\n            if f in central_files:\n                if piece.color == chess.WHITE:\n                    white_center_pawns += 1\n                else:\n                    black_center_pawns += 1\n    val = white_center_pawns - black_center_pawns\n    return [float(val)]", "def feature(board: chess.Board) -> list[float]:\n    'heavy piece count difference: rooks and queens'\n    white_heavy = 0\n    black_heavy = 0\n    for sq, piece in board.piece_map().items():\n        if piece.piece_type in (chess.ROOK, chess.QUEEN):\n            if piece.color == chess.WHITE:\n                white_heavy += 1\n            else:\n                black_heavy += 1\n    val = white_heavy - black_heavy\n    return [float(val)]", "def feature(board: chess.Board) -> list[float]:\n    \"Material balance: White material minus Black material\"\n    white = 0.0\n    black = 0.0\n    for sq, piece in board.piece_map().items():\n        if piece is None:\n            continue\n        if piece.color == chess.WHITE:\n            if piece.piece_type == chess.PAWN:\n                white += 1.0\n            elif piece.piece_type == chess.KNIGHT or piece.piece_type == chess.BISHOP:\n                white += 3.0\n            elif piece.piece_type == chess.ROOK:\n                white += 5.0\n            elif piece.piece_type == chess.QUEEN:\n                white += 9.0\n        else:\n            if piece.piece_type == chess.PAWN:\n                black += 1.0\n            elif piece.piece_type == chess.KNIGHT or piece.piece_type == chess.BISHOP:\n                black += 3.0\n            elif piece.piece_type == chess.ROOK:\n                black += 5.0\n            elif piece.piece_type == chess.QUEEN:\n                black += 9.0\n    return white - black", "def feature(board: chess.Board) -> list[float]:\n    \"Mobility of side to move: number of legal moves\"\n    return float(len(list(board.legal_moves)))", "def feature(board: chess.Board) -> list[float]:\n    \"Mobility by color difference: White moves vs Black moves when each could move\"\n    wb = board.copy()\n    wb.turn = chess.WHITE\n    m_white = len(list(wb.legal_moves))\n    bb = board.copy()\n    bb.turn = chess.BLACK\n    m_black = len(list(bb.legal_moves))\n    return float(m_white - m_black)", "def feature(board: chess.Board) -> list[float]:\n    \"King safety: number of opposing attackers on the side to move's king\"\n    own_color = board.turn\n    opp_color = chess.BLACK if own_color == chess.WHITE else chess.WHITE\n    king_sq = board.king(own_color)\n    if king_sq is None:\n        return 0.0\n    attackers = board.attackers(opp_color, king_sq)\n    return float(len(attackers))", "def feature(board: chess.Board) -> list[float]:\n    \"Doubled pawns penalty: total number of doubled pawns for both sides\"\n    white_counts = [0]*8\n    black_counts = [0]*8\n    for sq, p in board.piece_map().items():\n        if p.piece_type == chess.PAWN:\n            file = chess.square_file(sq)\n            if p.color == chess.WHITE:\n                white_counts[file] += 1\n            else:\n                black_counts[file] += 1\n    white_doubled = sum(1 for c in white_counts if c > 1)\n    black_doubled = sum(1 for c in black_counts if c > 1)\n    return float(white_doubled + black_doubled)", "def feature(board: chess.Board) -> list[float]:\n    \"Development: number of minor pieces (knights/bishops) not on starting squares\"\n    white_dev = 0\n    black_dev = 0\n    for sq, p in board.piece_map().items():\n        if p.piece_type in (chess.KNIGHT, chess.BISHOP):\n            if p.color == chess.WHITE:\n                if p.piece_type == chess.KNIGHT and sq not in (chess.B1, chess.G1):\n                    white_dev += 1\n                elif p.piece_type == chess.BISHOP and sq not in (chess.C1, chess.F1):\n                    white_dev += 1\n            else:\n                if p.piece_type == chess.KNIGHT and sq not in (chess.B8, chess.G8):\n                    black_dev += 1\n                elif p.piece_type == chess.BISHOP and sq not in (chess.C8, chess.F8):\n                    black_dev += 1\n    return float(white_dev - black_dev)", "def feature(board: chess.Board) -> list[float]:\n    \"Queen center distance: average distance of queens to the center squares\"\n    center_sqs = [chess.D4, chess.E4, chess.D5, chess.E5]\n    total_dist = 0\n    count = 0\n    for sq, p in board.piece_map().items():\n        if p.piece_type == chess.QUEEN:\n            d = min(chess.square_distance(sq, c) for c in center_sqs)\n            total_dist += d\n            count += 1\n    if count == 0:\n        return 0.0\n    return float(total_dist / count)", "def feature(board: chess.Board) -> list[float]:\n    \"Heavy piece difference: (rooks + queens) white minus black\"\n    white_heavy = 0\n    black_heavy = 0\n    for sq, p in board.piece_map().items():\n        if p.piece_type in (chess.ROOK, chess.QUEEN):\n            if p.color == chess.WHITE:\n                white_heavy += 1\n            else:\n                black_heavy += 1\n    return float(white_heavy - black_heavy)", "def feature(board: chess.Board) -> list[float]:\n    \"Passed pawn difference: White passed pawns minus Black passed pawns\"\n    def is_white_passed(b: chess.Board, sq: int) -> bool:\n        f = chess.square_file(sq)\n        r = chess.square_rank(sq)\n        for ff in range(max(0, f-1), min(7, f+1) + 1):\n            for rr in range(r+1, 8):\n                s = chess.square(ff, rr)\n                pc = b.piece_at(s)\n                if pc is not None and pc.piece_type == chess.PAWN and pc.color == chess.BLACK:\n                    return False\n        return True\n\n    def is_black_passed(b: chess.Board, sq: int) -> bool:\n        f = chess.square_file(sq)\n        r = chess.square_rank(sq)\n        for ff in range(max(0, f-1), min(7, f+1) + 1):\n            for rr in range(0, r):\n                s = chess.square(ff, rr)\n                pc = b.piece_at(s)\n                if pc is not None and pc.piece_type == chess.PAWN and pc.color == chess.WHITE:\n                    return False\n        return True\n\n    white_passed = 0\n    black_passed = 0\n    for sq, p in board.piece_map().items():\n        if p.piece_type != chess.PAWN:\n            continue\n        if p.color == chess.WHITE:\n            if is_white_passed(board, sq):\n                white_passed += 1\n        else:\n            if is_black_passed(board, sq):\n                black_passed += 1\n    return float(white_passed - black_passed)", "def feature(board: chess.Board) -> list[float]:\n    \"Central occupation difference: white pieces on center vs black\"\n    center_sqs = [chess.D4, chess.E4, chess.D5, chess.E5]\n    white_center = 0\n    black_center = 0\n    for sq in center_sqs:\n        p = board.piece_at(sq)\n        if p is None:\n            continue\n        if p.color == chess.WHITE:\n            white_center += 1\n        else:\n            black_center += 1\n    return float(white_center - black_center)", "def feature(board: chess.Board) -> list[float]:\n    \"material value balance between white and black\"\n    values = {chess.PAWN: 1, chess.KNIGHT: 3, chess.BISHOP: 3, chess.ROOK: 5, chess.QUEEN: 9, chess.KING: 0}\n    total = 0.0\n    for sq, p in board.piece_map().items():\n        v = values.get(p.piece_type, 0)\n        total += v if p.color == chess.WHITE else -v\n    return float(total)", "def feature(board: chess.Board) -> list[float]:\n    \"pawn balance: white pawns minus black pawns\"\n    white_pawns = 0\n    black_pawns = 0\n    for p in board.piece_map().values():\n        if p.piece_type == chess.PAWN:\n            if p.color == chess.WHITE:\n                white_pawns += 1\n            else:\n                black_pawns += 1\n    return float(white_pawns - black_pawns)", "def feature(board: chess.Board) -> list[float]:\n    \"king safety: number of attackers on side to move's king\"\n    if board.king(board.turn) is None:\n        return float(0)\n    king_sq = board.king(board.turn)\n    opp = not board.turn\n    attackers = board.attackers(opp, king_sq)\n    return float(len(attackers))", "def feature(board: chess.Board) -> list[float]:\n    \"mobility: number of legal moves for side to move\"\n    moves = list(board.legal_moves)\n    return float(len(moves))", "def feature(board: chess.Board) -> list[float]:\n    \"central control difference: white control of central squares minus black control\"\n    centers = [chess.D4, chess.E4, chess.D5, chess.E5]\n    white_control = sum(1 for s in centers if board.is_attacked_by(chess.WHITE, s))\n    black_control = sum(1 for s in centers if board.is_attacked_by(chess.BLACK, s))\n    return float(white_control - black_control)", "def feature(board: chess.Board) -> list[float]:\n    \"development difference: developed minor/major pieces (non-pawns) white minus black\"\n    WHITE = chess.WHITE\n    BLACK = chess.BLACK\n    def starting_squares(color, piece_type):\n        if color == WHITE:\n            if piece_type == chess.KNIGHT:\n                return {chess.B1, chess.G1}\n            if piece_type == chess.BISHOP:\n                return {chess.C1, chess.F1}\n            if piece_type == chess.ROOK:\n                return {chess.A1, chess.H1}\n            if piece_type == chess.QUEEN:\n                return {chess.D1}\n        else:\n            if piece_type == chess.KNIGHT:\n                return {chess.B8, chess.G8}\n            if piece_type == chess.BISHOP:\n                return {chess.C8, chess.F8}\n            if piece_type == chess.ROOK:\n                return {chess.A8, chess.H8}\n            if piece_type == chess.QUEEN:\n                return {chess.D8}\n        return set()\n    dev_white = 0\n    dev_black = 0\n    for sq, p in board.piece_map().items():\n        if p.piece_type in (chess.KNIGHT, chess.BISHOP, chess.ROOK, chess.QUEEN):\n            if p.color == WHITE:\n                if sq not in starting_squares(WHITE, p.piece_type):\n                    dev_white += 1\n            else:\n                if sq not in starting_squares(BLACK, p.piece_type):\n                    dev_black += 1\n    return float(dev_white - dev_black)", "def feature(board: chess.Board) -> list[float]:\n    \"attack pressure: net value of pieces attacked by the opponent\"\n    WHITE = chess.WHITE\n    BLACK = chess.BLACK\n    def piece_value(p):\n        if p.piece_type == chess.PAWN: return 1\n        if p.piece_type == chess.KNIGHT: return 3\n        if p.piece_type == chess.BISHOP: return 3\n        if p.piece_type == chess.ROOK: return 5\n        if p.piece_type == chess.QUEEN: return 9\n        return 0\n    white_under_attack = 0\n    black_under_attack = 0\n    for sq, p in board.piece_map().items():\n        if p.color == WHITE:\n            if board.is_attacked_by(BLACK, sq):\n                white_under_attack += piece_value(p)\n        else:\n            if board.is_attacked_by(WHITE, sq):\n                black_under_attack += piece_value(p)\n    return float(white_under_attack - black_under_attack)", "def feature(board: chess.Board) -> list[float]:\n    \"approximate passed pawns difference: white passed pawns minus black passed pawns\"\n    white_passed = 0\n    black_passed = 0\n    # Collect pawn locations for fast lookups\n    white_pawns = []\n    black_pawns = []\n    for sq, p in board.piece_map().items():\n        if p.piece_type == chess.PAWN:\n            if p.color == chess.WHITE:\n                white_pawns.append(sq)\n            else:\n                black_pawns.append(sq)\n    def is_black_pawn_blocking(file, rank):  # black pawn on adjacent file ahead\n        for sq, p in board.piece_map().items():\n            if p.color == chess.BLACK and p.piece_type == chess.PAWN:\n                f = chess.square_file(sq)\n                r = chess.square_rank(sq)\n                if abs(f - file) <= 1 and r > rank:\n                    return True\n        return False\n    def is_white_pawn_blocking(file, rank):\n        for sq, p in board.piece_map().items():\n            if p.color == chess.WHITE and p.piece_type == chess.PAWN:\n                f = chess.square_file(sq)\n                r = chess.square_rank(sq)\n                if abs(f - file) <= 1 and r < rank:\n                    return True\n        return False\n    for sq in white_pawns:\n        f = chess.square_file(sq)\n        r = chess.square_rank(sq)\n        if not is_black_pawn_blocking(f, r):\n            white_passed += 1\n    for sq in black_pawns:\n        f = chess.square_file(sq)\n        r = chess.square_rank(sq)\n        if not is_white_pawn_blocking(f, r):\n            black_passed += 1\n    return float(white_passed - black_passed)", "def feature(board: chess.Board) -> list[float]:\n    \"is current side to move in check\"\n    return float(1.0 if board.is_check() else 0.0)", "def feature(board: chess.Board) -> list[float]:\n    \"number of legal capture moves available to side to move\"\n    captures = 0\n    for m in board.legal_moves:\n        if board.is_capture(m):\n            captures += 1\n    return float(captures)", "def feature(board: chess.Board) -> list[float]:\n    \"queen presence: 1 if a queen is on the board, else 0\"\n    has_white_queen = any(p.piece_type == chess.QUEEN and p.color == chess.WHITE for p in board.piece_map().values())\n    has_black_queen = any(p.piece_type == chess.QUEEN and p.color == chess.BLACK for p in board.piece_map().values())\n    return float((1 if has_white_queen else 0) + (1 if has_black_queen else 0))", "def feature(board: chess.Board) -> list[float]:\n    'Material balance: white minus black material using standard piece values'\n    values = {\n        chess.PAWN: 1.0,\n        chess.KNIGHT: 3.0,\n        chess.BISHOP: 3.0,\n        chess.ROOK: 5.0,\n        chess.QUEEN: 9.0,\n        chess.KING: 0.0\n    }\n    white_material = 0.0\n    black_material = 0.0\n    for square, piece in board.piece_map().items():\n        val = values.get(piece.piece_type, 0.0)\n        if piece.color == chess.WHITE:\n            white_material += val\n        else:\n            black_material += val\n    return white_material - black_material", "def feature(board: chess.Board) -> list[float]:\n    'Mobility: number of legal moves for side to move'\n    try:\n        return float(len(list(board.legal_moves)))\n    except Exception:\n        return 0.0", "def feature(board: chess.Board) -> list[float]:\n    'Pawn structure: white penalties minus black penalties for doubled and isolated pawns'\n    white_per_file = [0] * 8\n    black_per_file = [0] * 8\n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.PAWN:\n            f = chess.square_file(square)\n            if piece.color == chess.WHITE:\n                white_per_file[f] += 1\n            else:\n                black_per_file[f] += 1\n    white_doubled = sum(max(0, c - 1) for c in white_per_file)\n    black_doubled = sum(max(0, c - 1) for c in black_per_file)\n\n    white_isolated = 0\n    black_isolated = 0\n    for f in range(8):\n        if white_per_file[f] > 0:\n            left = white_per_file[f - 1] if f > 0 else 0\n            right = white_per_file[f + 1] if f < 7 else 0\n            if left == 0 and right == 0:\n                white_isolated += white_per_file[f]\n        if black_per_file[f] > 0:\n            left = black_per_file[f - 1] if f > 0 else 0\n            right = black_per_file[f + 1] if f < 7 else 0\n            if left == 0 and right == 0:\n                black_isolated += black_per_file[f]\n    white_penalty = white_doubled + white_isolated\n    black_penalty = black_doubled + black_isolated\n    return float(white_penalty - black_penalty)", "def feature(board: chess.Board) -> list[float]:\n    'Capture moves available for side to move'\n    captures = 0\n    for m in board.legal_moves:\n        try:\n            if board.is_capture(m):\n                captures += 1\n        except Exception:\n            # If move representation is odd, skip safely\n            continue\n    return float(captures)", "def feature(board: chess.Board) -> list[float]:\n    'Queen count difference: white queens minus black queens'\n    wq = 0\n    bq = 0\n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.QUEEN:\n            if piece.color == chess.WHITE:\n                wq += 1\n            else:\n                bq += 1\n    return float(wq - bq)", "def feature(board: chess.Board) -> list[float]:\n    'Central control: white control minus black control over central squares'\n    central = [chess.D4, chess.E4, chess.D5, chess.E5]\n    white_control = sum(1 for sq in central if board.is_attacked_by(chess.WHITE, sq))\n    black_control = sum(1 for sq in central if board.is_attacked_by(chess.BLACK, sq))\n    return float(white_control - black_control)", "def feature(board: chess.Board) -> list[float]:\n    'Open files difference: white open files minus black open files'\n    white_on_file = [0] * 8\n    black_on_file = [0] * 8\n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.PAWN:\n            f = chess.square_file(square)\n            if piece.color == chess.WHITE:\n                white_on_file[f] += 1\n            else:\n                black_on_file[f] += 1\n    white_open = sum(1 for f in range(8) if white_on_file[f] == 0)\n    black_open = sum(1 for f in range(8) if black_on_file[f] == 0)\n    return float(white_open - black_open)", "def feature(board: chess.Board) -> list[float]:\n    'Distance of the active king to the center squares (min distance)'\n    king_square = board.king(board.turn)\n    if king_square is None:\n        return 0.0\n    central = [chess.D4, chess.E4, chess.D5, chess.E5]\n    distances = [chess.square_distance(king_square, c) for c in central]\n    return float(min(distances))", "def feature(board: chess.Board) -> list[float]:\n    'Non-pawn piece count difference: white minus black'\n    white_non_pawn = 0\n    black_non_pawn = 0\n    for square, piece in board.piece_map().items():\n        if piece.piece_type != chess.PAWN:\n            if piece.color == chess.WHITE:\n                white_non_pawn += 1\n            else:\n                black_non_pawn += 1\n    return float(white_non_pawn - black_non_pawn)", "def feature(board: chess.Board) -> list[float]:\n    'King safety score for the side to move: 1/(1+attackers to own king)'\n    own_color = board.turn\n    king_square = None\n    for sq, p in board.piece_map().items():\n        if p.piece_type == chess.KING and p.color == own_color:\n            king_square = sq\n            break\n    if king_square is None:\n        return 0.0\n    opp_color = not own_color\n    attackers = board.attackers(opp_color, king_square)\n    return 1.0 / (1.0 + len(attackers))", "def feature(board: chess.Board) -> list[float]:\n    'Center control difference: White vs Black on central squares'\n    center_sqs = [chess.D4, chess.E4, chess.D5, chess.E5]\n    white_control = sum(1 for sq in center_sqs if board.is_attacked_by(chess.WHITE, sq))\n    black_control = sum(1 for sq in center_sqs if board.is_attacked_by(chess.BLACK, sq))\n    return float(white_control - black_control)", "def feature(board: chess.Board) -> list[float]:\n    'Isolated pawn difference: white isolated pawns minus black isolated pawns'\n    white_files = set()\n    black_files = set()\n    white_pawns = []\n    black_pawns = []\n    for sq, p in board.piece_map().items():\n        if p.piece_type == chess.PAWN:\n            if p.color == chess.WHITE:\n                white_pawns.append(sq)\n                white_files.add(chess.square_file(sq))\n            else:\n                black_pawns.append(sq)\n                black_files.add(chess.square_file(sq))\n    white_isolated = 0\n    for sq in white_pawns:\n        f = chess.square_file(sq)\n        if (f - 1 in white_files) or (f + 1 in white_files):\n            continue\n        white_isolated += 1\n    black_isolated = 0\n    for sq in black_pawns:\n        f = chess.square_file(sq)\n        if (f - 1 in black_files) or (f + 1 in black_files):\n            continue\n        black_isolated += 1\n    return float(white_isolated - black_isolated)", "def feature(board: chess.Board) -> list[float]:\n    'Piece centrality difference: weighted sum by proximity to center'\n    center_sqs = [chess.D4, chess.E4, chess.D5, chess.E5]\n    piece_values = {\n        chess.PAWN: 1.0,\n        chess.KNIGHT: 3.0,\n        chess.BISHOP: 3.0,\n        chess.ROOK: 5.0,\n        chess.QUEEN: 9.0,\n        chess.KING: 0.0\n    }\n    white_score = 0.0\n    black_score = 0.0\n    for sq, p in board.piece_map().items():\n        if p.piece_type not in piece_values:\n            continue\n        val = piece_values[p.piece_type]\n        dist = min(chess.square_distance(sq, c) for c in center_sqs)\n        centrality = 1.0 + max(0.0, 4.0 - dist)\n        contrib = val * centrality\n        if p.color == chess.WHITE:\n            white_score += contrib\n        else:\n            black_score += contrib\n    return float(white_score - black_score)", "def feature(board: chess.Board) -> list[float]:\n    'Distance between kings: manhattan distance on board'\n    white_king = None\n    black_king = None\n    for sq, p in board.piece_map().items():\n        if p.piece_type == chess.KING:\n            if p.color == chess.WHITE:\n                white_king = sq\n            else:\n                black_king = sq\n    if white_king is None or black_king is None:\n        return 0.0\n    return float(chess.square_distance(white_king, black_king))", "def feature(board: chess.Board) -> list[float]:\n    'Castling rights remaining in the game: total count across sides'\n    rights = 0\n    if board.has_kingside_castling_rights(chess.WHITE): rights += 1\n    if board.has_queenside_castling_rights(chess.WHITE): rights += 1\n    if board.has_kingside_castling_rights(chess.BLACK): rights += 1\n    if board.has_queenside_castling_rights(chess.BLACK): rights += 1\n    return float(rights)", "def feature(board: chess.Board) -> list[float]:\n    'Mobility difference by color: White moves minus Black moves'\n    def mobility_count(bd: chess.Board, color: chess.Color) -> int:\n        tmp = bd.copy()\n        tmp.turn = color\n        return sum(1 for _ in tmp.legal_moves)\n    white_moves = mobility_count(board, chess.WHITE)\n    black_moves = mobility_count(board, chess.BLACK)\n    return float(white_moves - black_moves)", "def feature(board: chess.Board) -> list[float]:\n    'Material density difference: centrality-weighted material value'\n    center_sqs = [chess.D4, chess.E4, chess.D5, chess.E5]\n    value_map = {\n        chess.PAWN: 1.0,\n        chess.KNIGHT: 3.0,\n        chess.BISHOP: 3.0,\n        chess.ROOK: 5.0,\n        chess.QUEEN: 9.0,\n        chess.KING: 0.0\n    }\n    white_density = 0.0\n    black_density = 0.0\n    for sq, p in board.piece_map().items():\n        if p.piece_type not in value_map:\n            continue\n        val = value_map[p.piece_type]\n        dist = min(chess.square_distance(sq, c) for c in center_sqs)\n        centrality = 1.0 + max(0.0, 4.0 - dist)\n        contrib = val * centrality\n        if p.color == chess.WHITE:\n            white_density += contrib\n        else:\n            black_density += contrib\n    return float(white_density - black_density)", "def feature(board: chess.Board) -> list[float]:\n    'Pawns on central files: difference White vs Black on d/e files'\n    white_count = 0\n    black_count = 0\n    for sq, p in board.piece_map().items():\n        if p.piece_type != chess.PAWN:\n            continue\n        f = chess.square_file(sq)\n        if f in (3, 4):  # d or e file\n            if p.color == chess.WHITE:\n                white_count += 1\n            else:\n                black_count += 1\n    return float(white_count - black_count)", "def feature(board: chess.Board) -> list[float]:\n    'Threatened own pieces: ratio of own pieces attacked by opponent'\n    opp_color = not board.turn\n    total_pieces = 0\n    threatened_pieces = 0\n    for sq, p in board.piece_map().items():\n        if p is None:\n            continue\n        total_pieces += 1\n        if p.color == board.turn:\n            attackers = board.attackers(opp_color, sq)\n            if len(attackers) > 0:\n                threatened_pieces += 1\n    if total_pieces == 0:\n        return 0.0\n    return float(threatened_pieces) / float(total_pieces)", "def feature(board: chess.Board) -> list[float]:\n    \"Material balance: white material minus black material\"\n    white = 0\n    black = 0\n    values = {chess.PAWN: 1, chess.KNIGHT: 3, chess.BISHOP: 3, chess.ROOK: 5, chess.QUEEN: 9, chess.KING: 0}\n    for piece in board.piece_map().values():\n        val = values.get(piece.piece_type, 0)\n        if piece.color == chess.WHITE:\n            white += val\n        else:\n            black += val\n    return [float(white - black)]", "def feature(board: chess.Board) -> list[float]:\n    \"Mobility by color: difference in number of legal moves White vs Black\"\n    def moves_for_color(color: chess.Color) -> int:\n        b = board.copy()\n        b.turn = color\n        return sum(1 for _ in b.legal_moves)\n    white_moves = moves_for_color(chess.WHITE)\n    black_moves = moves_for_color(chess.BLACK)\n    return [float(white_moves - black_moves)]", "def feature(board: chess.Board) -> list[float]:\n    \"Piece centrality difference: weighted sum by proximity to center\"\n    center_sqs = [chess.D4, chess.E4, chess.D5, chess.E5]\n    def center_dist(sq: chess.Square) -> int:\n        f = chess.square_file(sq)\n        r = chess.square_rank(sq)\n        dmin = 10\n        for c in center_sqs:\n            cf = chess.square_file(c)\n            cr = chess.square_rank(c)\n            d = max(abs(f - cf), abs(r - cr))\n            if d < dmin:\n                dmin = d\n        return dmin\n    white_score = 0.0\n    black_score = 0.0\n    for sq, p in board.piece_map().items():\n        dist = center_dist(sq)\n        weight = 1.0 / (dist + 1.0)\n        val = 0\n        if p.piece_type == chess.PAWN:\n            val = 1\n        elif p.piece_type == chess.KNIGHT:\n            val = 3\n        elif p.piece_type == chess.BISHOP:\n            val = 3\n        elif p.piece_type == chess.ROOK:\n            val = 5\n        elif p.piece_type == chess.QUEEN:\n            val = 9\n        else:\n            val = 0\n        score = weight * val\n        if p.color == chess.WHITE:\n            white_score += score\n        else:\n            black_score += score\n    return [float(white_score - black_score)]", "def feature(board: chess.Board) -> list[float]:\n    \"King safety penalty: number of enemy attackers on own king (negative impact)\"\n    ksq = board.king(board.turn)\n    if ksq is None:\n        return [0.0]\n    enemy = chess.BLACK if board.turn == chess.WHITE else chess.WHITE\n    attackers = board.attackers(enemy, ksq)\n    penalty = -len(attackers)\n    return [float(penalty)]", "def feature(board: chess.Board) -> list[float]:\n    \"Passed pawn difference: White passed pawns minus Black passed pawns\"\n    def is_passed_white(square: chess.Square) -> bool:\n        f = chess.square_file(square)\n        r = chess.square_rank(square)\n        for ff in [f-1, f, f+1]:\n            if ff < 0 or ff > 7:\n                continue\n            for rr in range(r+1, 8):\n                p = board.piece_at(chess.square(ff, rr))\n                if p is not None and p.piece_type == chess.PAWN and p.color == chess.BLACK:\n                    return False\n        return True\n    def is_passed_black(square: chess.Square) -> bool:\n        f = chess.square_file(square)\n        r = chess.square_rank(square)\n        for ff in [f-1, f, f+1]:\n            if ff < 0 or ff > 7:\n                continue\n            for rr in range(0, r):\n                p = board.piece_at(chess.square(ff, rr))\n                if p is not None and p.piece_type == chess.PAWN and p.color == chess.WHITE:\n                    return False\n        return True\n    passed_white = 0\n    passed_black = 0\n    for sq, p in board.piece_map().items():\n        if p.piece_type == chess.PAWN:\n            if p.color == chess.WHITE:\n                if is_passed_white(sq):\n                    passed_white += 1\n            else:\n                if is_passed_black(sq):\n                    passed_black += 1\n    return [float(passed_white - passed_black)]", "def feature(board: chess.Board) -> list[float]:\n    \"Heavy piece difference: rooks + queens white minus black\"\n    white_heavy = 0\n    black_heavy = 0\n    for p in board.piece_map().values():\n        if p.piece_type in (chess.QUEEN, chess.ROOK):\n            if p.color == chess.WHITE:\n                white_heavy += 1\n            else:\n                black_heavy += 1\n    return [float(white_heavy - black_heavy)]", "def feature(board: chess.Board) -> list[float]:\n    \"Isolated pawn difference: white isolated pawns minus black isolated pawns\"\n    def is_isolated(pawn_sq: chess.Square, color: chess.Color) -> bool:\n        f = chess.square_file(pawn_sq)\n        # check if there is any pawn of same color on adjacent files\n        for adj in [f-1, f+1]:\n            if 0 <= adj <= 7:\n                for rr in range(8):\n                    s = chess.square(adj, rr)\n                    q = board.piece_at(s)\n                    if q is not None and q.color == color and q.piece_type == chess.PAWN:\n                        return False\n        return True\n    white_iso = 0\n    black_iso = 0\n    for sq, p in board.piece_map().items():\n        if p.piece_type == chess.PAWN:\n            if p.color == chess.WHITE:\n                if is_isolated(sq, chess.WHITE):\n                    white_iso += 1\n            else:\n                if is_isolated(sq, chess.BLACK):\n                    black_iso += 1\n    return [float(white_iso - black_iso)]", "def feature(board: chess.Board) -> list[float]:\n    \"Queen center proximity: sum of 1/(dist+1) for queens White minus Black\"\n    def dist_to_center(sq: chess.Square) -> int:\n        f = chess.square_file(sq)\n        r = chess.square_rank(sq)\n        centers = [(3,3), (4,3), (3,4), (4,4)]\n        return min(max(abs(f-cf), abs(r-cr)) for (cf, cr) in centers)\n    white_q = 0.0\n    black_q = 0.0\n    for sq, p in board.piece_map().items():\n        if p.piece_type == chess.QUEEN:\n            d = dist_to_center(sq)\n            weight = 1.0 / (d + 1.0)\n            if p.color == chess.WHITE:\n                white_q += weight\n            else:\n                black_q += weight\n    return [float(white_q - black_q)]", "def feature(board: chess.Board) -> list[float]:\n    \"King distance to center difference: White king distance minus Black king distance\"\n    def dist_to_center_square(sq: chess.Square) -> int:\n        f = chess.square_file(sq)\n        r = chess.square_rank(sq)\n        centers = [(3,3), (4,3), (3,4), (4,4)]\n        return min(max(abs(f-cf), abs(r-cr)) for (cf, cr) in centers)\n    w_ks = board.king(chess.WHITE)\n    b_ks = board.king(chess.BLACK)\n    if w_ks is None or b_ks is None:\n        return [0.0]\n    dw = dist_to_center_square(w_ks)\n    db = dist_to_center_square(b_ks)\n    return [float(dw - db)]", "def feature(board: chess.Board) -> list[float]:\n    \"Pawn advancement difference: White average pawn rank minus Black average pawn rank\"\n    white_ranks = []\n    black_ranks = []\n    for sq, p in board.piece_map().items():\n        if p.piece_type == chess.PAWN:\n            if p.color == chess.WHITE:\n                white_ranks.append(chess.square_rank(sq))\n            else:\n                black_ranks.append(chess.square_rank(sq))\n    white_avg = float(sum(white_ranks)) / len(white_ranks) if white_ranks else 0.0\n    black_avg = float(sum(black_ranks)) / len(black_ranks) if black_ranks else 0.0\n    return [float(white_avg - black_avg)]", "def feature(board: chess.Board) -> list[float]:\n    \"material balance: white material minus black material\"\n    piece_values = {chess.PAWN: 1, chess.KNIGHT: 3, chess.BISHOP: 3, chess.ROOK: 5, chess.QUEEN: 9, chess.KING: 0}\n    white_sum = 0.0\n    black_sum = 0.0\n    for sq, p in board.piece_map().items():\n        val = piece_values.get(p.piece_type, 0)\n        if p.color == chess.WHITE:\n            white_sum += val\n        else:\n            black_sum += val\n    return float(white_sum - black_sum)", "def feature(board: chess.Board) -> list[float]:\n    \"mobility: number of legal moves for side to move\"\n    return float(len(list(board.legal_moves)))", "def feature(board: chess.Board) -> list[float]:\n    \"mobility by color: white vs black moves difference\"\n    def moves_for_color(b: chess.Board, color: chess.Color) -> int:\n        b2 = b.copy()\n        b2.turn = color\n        return len(list(b2.legal_moves))\n    white_moves = moves_for_color(board, chess.WHITE)\n    black_moves = moves_for_color(board, chess.BLACK)\n    return float(white_moves - black_moves)", "def feature(board: chess.Board) -> list[float]:\n    \"heavy piece count difference: rooks and queens\"\n    white_heavy = 0\n    black_heavy = 0\n    for sq, p in board.piece_map().items():\n        if p.piece_type in (chess.ROOK, chess.QUEEN):\n            if p.color == chess.WHITE:\n                white_heavy += 1\n            else:\n                black_heavy += 1\n    return float(white_heavy - black_heavy)", "def feature(board: chess.Board) -> list[float]:\n    \"passed pawn difference: White passed pawns minus Black passed pawns\"\n    def is_white_passed(sq) -> bool:\n        if not board.piece_at(sq) or board.piece_at(sq).piece_type != chess.PAWN or board.piece_at(sq).color != chess.WHITE:\n            return False\n        file = chess.square_file(sq)\n        rank = chess.square_rank(sq)\n        for f in range(max(0, file - 1), min(7, file + 1) + 1):\n            for r in range(rank + 1, 8):\n                p = board.piece_at(chess.square(f, r))\n                if p and p.piece_type == chess.PAWN and p.color == chess.BLACK:\n                    return False\n        return True\n    def is_black_passed(sq) -> bool:\n        p = board.piece_at(sq)\n        if not p or p.piece_type != chess.PAWN or p.color != chess.BLACK:\n            return False\n        file = chess.square_file(sq)\n        rank = chess.square_rank(sq)\n        for f in range(max(0, file - 1), min(7, file + 1) + 1):\n            for r in range(0, rank):\n                pp = board.piece_at(chess.square(f, r))\n                if pp and pp.piece_type == chess.PAWN and pp.color == chess.WHITE:\n                    return False\n        return True\n    white_passed = 0\n    black_passed = 0\n    for sq, p in board.piece_map().items():\n        if p.piece_type == chess.PAWN:\n            if p.color == chess.WHITE:\n                if is_white_passed(sq):\n                    white_passed += 1\n            else:\n                if is_black_passed(sq):\n                    black_passed += 1\n    return float(white_passed - black_passed)", "def feature(board: chess.Board) -> list[float]:\n    \"piece centrality difference: weighted sum by proximity to center\"\n    centers = [chess.D4, chess.E4, chess.D5, chess.E5]\n    def dist_to_center(sq: int) -> int:\n        return min(chess.square_distance(sq, c) for c in centers)\n    white_sum = 0.0\n    black_sum = 0.0\n    for sq, p in board.piece_map().items():\n        d = dist_to_center(sq)\n        w = 1.0 / (1.0 + d)\n        if p.color == chess.WHITE:\n            white_sum += w\n        else:\n            black_sum += w\n    return float(white_sum - black_sum)", "def feature(board: chess.Board) -> list[float]:\n    \"piece development difference: developed white pieces minus black\"\n    developed_white = 0\n    developed_black = 0\n    initial_white = {\n        chess.KING: {chess.E1},\n        chess.QUEEN: {chess.D1},\n        chess.ROOK: {chess.A1, chess.H1},\n        chess.KNIGHT: {chess.B1, chess.G1},\n        chess.BISHOP: {chess.C1, chess.F1},\n    }\n    initial_black = {\n        chess.KING: {chess.E8},\n        chess.QUEEN: {chess.D8},\n        chess.ROOK: {chess.A8, chess.H8},\n        chess.KNIGHT: {chess.B8, chess.G8},\n        chess.BISHOP: {chess.C8, chess.F8},\n    }\n    for sq, p in board.piece_map().items():\n        if p.piece_type == chess.PAWN:\n            continue\n        if p.color == chess.WHITE:\n            if sq not in initial_white.get(p.piece_type, set()):\n                developed_white += 1\n        else:\n            if sq not in initial_black.get(p.piece_type, set()):\n                developed_black += 1\n    return float(developed_white - developed_black)", "def feature(board: chess.Board) -> list[float]:\n    \"doubled pawns difference: white doubled pawns minus black doubled pawns\"\n    white_counts = [0] * 8\n    black_counts = [0] * 8\n    for sq, p in board.piece_map().items():\n        if p.piece_type != chess.PAWN:\n            continue\n        file = chess.square_file(sq)\n        if p.color == chess.WHITE:\n            white_counts[file] += 1\n        else:\n            black_counts[file] += 1\n    white_doubled = sum(max(0, c - 1) for c in white_counts)\n    black_doubled = sum(max(0, c - 1) for c in black_counts)\n    return float(white_doubled - black_doubled)", "def feature(board: chess.Board) -> list[float]:\n    \"king safety: number of attackers to own king\"\n    own_color = board.turn\n    king_sq = board.king(own_color)\n    if king_sq is None:\n        return float(0.0)\n    opponent_color = chess.BLACK if own_color == chess.WHITE else chess.WHITE\n    attackers = board.attackers(opponent_color, king_sq)\n    return float(len(attackers))", "def feature(board: chess.Board) -> list[float]:\n    \"pawn islands difference: white pawn islands minus black pawn islands\"\n    white_files = set()\n    black_files = set()\n    for sq, p in board.piece_map().items():\n        if p.piece_type != chess.PAWN:\n            continue\n        f = chess.square_file(sq)\n        if p.color == chess.WHITE:\n            white_files.add(f)\n        else:\n            black_files.add(f)\n    white_islands = len(white_files)\n    black_islands = len(black_files)\n    return float(white_islands - black_islands)", "def feature(board: chess.Board) -> list[float]:\n    'Material balance: white minus black using standard piece values'\n    values = {\n        chess.PAWN: 1,\n        chess.KNIGHT: 3,\n        chess.BISHOP: 3,\n        chess.ROOK: 5,\n        chess.QUEEN: 9,\n        chess.KING: 0\n    }\n    total = 0.0\n    for square, piece in board.piece_map().items():\n        val = values.get(piece.piece_type, 0)\n        if piece.color == chess.WHITE:\n            total += val\n        else:\n            total -= val\n    return [float(total)]", "def feature(board: chess.Board) -> list[float]:\n    'Pawn balance: number of white pawns minus black pawns'\n    white_pawns = 0\n    black_pawns = 0\n    for piece in board.piece_map().values():\n        if piece.piece_type == chess.PAWN:\n            if piece.color == chess.WHITE:\n                white_pawns += 1\n            else:\n                black_pawns += 1\n    return [float(white_pawns - black_pawns)]", "def feature(board: chess.Board) -> list[float]:\n    'Number of attackers on side to move king'\n    king_sq = board.king(board.turn)\n    if king_sq is None:\n        attackers = 0\n    else:\n        enemy_color = chess.BLACK if board.turn == chess.WHITE else chess.WHITE\n        attackers = len(board.attackers(enemy_color, king_sq))\n    return [float(attackers)]", "def feature(board: chess.Board) -> list[float]:\n    'Ratio of non-pawn moves to total legal moves for side to move'\n    moves = list(board.legal_moves)\n    total = len(moves)\n    non_pawn = 0\n    for mv in moves:\n        piece = board.piece_at(mv.from_square)\n        if piece is not None and piece.piece_type != chess.PAWN:\n            non_pawn += 1\n    ratio = non_pawn / max(1, total)\n    return [float(ratio)]", "def feature(board: chess.Board) -> list[float]:\n    'Center control: net control over center squares by side to move'\n    center_sqs = [chess.D4, chess.E4, chess.D5, chess.E5]\n    control = 0\n    for sq in center_sqs:\n        if board.is_attacked_by(board.turn, sq):\n            control += 1\n        enemy_color = chess.BLACK if board.turn == chess.WHITE else chess.WHITE\n        if board.is_attacked_by(enemy_color, sq):\n            control -= 1\n    return [float(control)]", "def feature(board: chess.Board) -> list[float]:\n    'Rooks on open files: number of rooks on files with no pawns of either color'\n    def is_file_open(file_index: int) -> bool:\n        for rank in range(8):\n            sq = chess.square(file_index, rank)\n            p = board.piece_at(sq)\n            if p is not None and p.piece_type == chess.PAWN:\n                return False\n        return True\n\n    open_rooks = 0\n    for sq, piece in board.piece_map().items():\n        if piece.piece_type == chess.ROOK:\n            file = chess.square_file(sq)\n            if is_file_open(file):\n                open_rooks += 1\n    return [float(open_rooks)]", "def feature(board: chess.Board) -> list[float]:\n    'Doubled pawns difference white minus black'\n    counts_white = [0] * 8\n    counts_black = [0] * 8\n    for sq, piece in board.piece_map().items():\n        if piece.piece_type == chess.PAWN:\n            f = chess.square_file(sq)\n            if piece.color == chess.WHITE:\n                counts_white[f] += 1\n            else:\n                counts_black[f] += 1\n    white_doubled = sum(max(0, c - 1) for c in counts_white)\n    black_doubled = sum(max(0, c - 1) for c in counts_black)\n    return [float(white_doubled - black_doubled)]", "def feature(board: chess.Board) -> list[float]:\n    'Heavy piece imbalance: (white queens + rooks) minus (black queens + rooks)'\n    white_heavy = 0\n    black_heavy = 0\n    for piece in board.piece_map().values():\n        if piece.piece_type in (chess.QUEEN, chess.ROOK):\n            if piece.color == chess.WHITE:\n                white_heavy += 1\n            else:\n                black_heavy += 1\n    return [float(white_heavy - black_heavy)]", "def feature(board: chess.Board) -> list[float]:\n    'Average distance from own king to each enemy piece'\n    own_king_sq = board.king(board.turn)\n    if own_king_sq is None:\n        return [0.0]\n    enemy_color = chess.BLACK if board.turn == chess.WHITE else chess.WHITE\n    total_dist = 0\n    count = 0\n    for sq, piece in board.piece_map().items():\n        if piece.color == enemy_color:\n            total_dist += chess.square_distance(own_king_sq, sq)\n            count += 1\n    avg = total_dist / count if count > 0 else 0.0\n    return [float(avg)]", "def feature(board: chess.Board) -> list[float]:\n    'Development score difference: white vs black non-pawn piece rank average'\n    white_sum = 0\n    white_count = 0\n    black_sum = 0\n    black_count = 0\n    for sq, piece in board.piece_map().items():\n        if piece.piece_type != chess.PAWN:\n            rank = chess.square_rank(sq)\n            if piece.color == chess.WHITE:\n                white_sum += rank\n                white_count += 1\n            else:\n                black_sum += rank\n                black_count += 1\n    white_avg = white_sum / white_count if white_count > 0 else 0.0\n    black_avg = black_sum / black_count if black_count > 0 else 0.0\n    return [float(white_avg - black_avg)]", "def feature(board: chess.Board) -> list[float]:\n    'Material balance: white material minus black material'\n    values = {chess.PAWN: 1.0, chess.KNIGHT: 3.0, chess.BISHOP: 3.0, chess.ROOK: 5.0, chess.QUEEN: 9.0, chess.KING: 0.0}\n    white = 0.0\n    black = 0.0\n    for square, piece in board.piece_map().items():\n        val = values.get(piece.piece_type, 0.0)\n        if piece.color == chess.WHITE:\n            white += val\n        else:\n            black += val\n    return float(white - black)", "def feature(board: chess.Board) -> list[float]:\n    'Mobility: number of legal moves for side to move'\n    try:\n        return float(sum(1 for _ in board.legal_moves))\n    except Exception:\n        return 0.0", "def feature(board: chess.Board) -> list[float]:\n    'Mobility by color difference: white vs black pseudo-moves in current position'\n    def count_moves_for_turn(bd: chess.Board, color: chess.Color) -> int:\n        bd2 = bd.copy()\n        bd2.turn = color\n        return sum(1 for _ in bd2.legal_moves)\n    white_moves = count_moves_for_turn(board, chess.WHITE)\n    black_moves = count_moves_for_turn(board, chess.BLACK)\n    return float(white_moves - black_moves)", "def feature(board: chess.Board) -> list[float]:\n    'Passed pawn difference: white passed pawns minus black passed pawns'\n    white_passed = 0\n    black_passed = 0\n    white_pawns = []\n    black_pawns = []\n    for sq, p in board.piece_map().items():\n        if p.piece_type == chess.PAWN:\n            if p.color == chess.WHITE:\n                white_pawns.append(sq)\n            else:\n                black_pawns.append(sq)\n    def is_white_passed(sq: int) -> bool:\n        file = chess.square_file(sq)\n        rank = chess.square_rank(sq)\n        # check for any black pawn on same or adjacent files in front of white pawn\n        for f in (file-1, file, file+1):\n            if 0 <= f < 8:\n                for r in range(rank+1, 8):\n                    s = chess.square(f, r)\n                    p = board.piece_at(s)\n                    if p and p.color == chess.BLACK and p.piece_type == chess.PAWN:\n                        return False\n        return True\n    def is_black_passed(sq: int) -> bool:\n        file = chess.square_file(sq)\n        rank = chess.square_rank(sq)\n        # check for any white pawn on same or adjacent files in front of black pawn\n        for f in (file-1, file, file+1):\n            if 0 <= f < 8:\n                for r in range(0, rank):\n                    s = chess.square(f, r)\n                    p = board.piece_at(s)\n                    if p and p.color == chess.WHITE and p.piece_type == chess.PAWN:\n                        return False\n        return True\n    for sq in white_pawns:\n        if is_white_passed(sq):\n            white_passed += 1\n    for sq in black_pawns:\n        if is_black_passed(sq):\n            black_passed += 1\n    return float(white_passed - black_passed)", "def feature(board: chess.Board) -> list[float]:\n    'Piece centrality difference: weighted sum by proximity to center'\n    def center_weight(sq: int) -> float:\n        f = chess.square_file(sq)\n        r = chess.square_rank(sq)\n        centers = [(3,3), (4,3), (3,4), (4,4)]\n        dist = min(abs(f - cf) + abs(r - rf) for cf, rf in centers)\n        w = max(0.0, 4 - dist)\n        return float(w)\n    white_sum = 0.0\n    black_sum = 0.0\n    for sq, p in board.piece_map().items():\n        w = center_weight(sq)\n        if p.color == chess.WHITE:\n            white_sum += w\n        else:\n            black_sum += w\n    return float(white_sum - black_sum)", "def feature(board: chess.Board) -> list[float]:\n    'Heavy piece count difference: rooks and queens'\n    white_heavy = 0\n    black_heavy = 0\n    for sq, p in board.piece_map().items():\n        if p.piece_type in (chess.ROOK, chess.QUEEN):\n            if p.color == chess.WHITE:\n                white_heavy += 1\n            else:\n                black_heavy += 1\n    return float(white_heavy - black_heavy)", "def feature(board: chess.Board) -> list[float]:\n    'Doubled pawns difference: white vs black'\n    white_counts = {}\n    black_counts = {}\n    for sq, p in board.piece_map().items():\n        if p.piece_type == chess.PAWN:\n            f = chess.square_file(sq)\n            if p.color == chess.WHITE:\n                white_counts[f] = white_counts.get(f, 0) + 1\n            else:\n                black_counts[f] = black_counts.get(f, 0) + 1\n    white_doubled = sum(1 for c in white_counts.values() if c > 1)\n    black_doubled = sum(1 for c in black_counts.values() if c > 1)\n    return float(white_doubled - black_doubled)", "def feature(board: chess.Board) -> list[float]:\n    'Queen piece count difference: white queens minus black queens'\n    white_queens = 0\n    black_queens = 0\n    for _, p in board.piece_map().items():\n        if p.piece_type == chess.QUEEN:\n            if p.color == chess.WHITE:\n                white_queens += 1\n            else:\n                black_queens += 1\n    return float(white_queens - black_queens)", "def feature(board: chess.Board) -> list[float]:\n    'Minor piece count difference: bishops and knights'\n    white_minors = 0\n    black_minors = 0\n    for _, p in board.piece_map().items():\n        if p.piece_type in (chess.KNIGHT, chess.BISHOP):\n            if p.color == chess.WHITE:\n                white_minors += 1\n            else:\n                black_minors += 1\n    return float(white_minors - black_minors)", "def feature(board: chess.Board) -> list[float]:\n    'King safety near squares: difference in enemy attackers near kings'\n    w_ksq = board.king(chess.WHITE)\n    b_ksq = board.king(chess.BLACK)\n    def neighbors(sq: int):\n        f = chess.square_file(sq)\n        r = chess.square_rank(sq)\n        neigh = []\n        for df in (-1,0,1):\n            for dr in (-1,0,1):\n                if df == 0 and dr == 0:\n                    continue\n                nf = f + df\n                nr = r + dr\n                if 0 <= nf < 8 and 0 <= nr < 8:\n                    neigh.append(chess.square(nf, nr))\n        return neigh\n    white_attackers_near = 0\n    black_attackers_near = 0\n    if w_ksq is not None:\n        for s in neighbors(w_ksq):\n            if board.is_attacked_by(chess.BLACK, s):\n                white_attackers_near += 1\n    if b_ksq is not None:\n        for s in neighbors(b_ksq):\n            if board.is_attacked_by(chess.WHITE, s):\n                black_attackers_near += 1\n    return float(white_attackers_near - black_attackers_near)", "def feature(board: chess.Board) -> list[float]:\n    'material balance: white material minus black material'\n    import chess\n    values = {chess.PAWN: 1, chess.KNIGHT: 3, chess.BISHOP: 3, chess.ROOK: 5, chess.QUEEN: 9, chess.KING: 0}\n    val = 0.0\n    for sq, piece in board.piece_map().items():\n        piece_value = values.get(piece.piece_type, 0)\n        if piece.color == chess.WHITE:\n            val += piece_value\n        else:\n            val -= piece_value\n    return [float(val)]", "def feature(board: chess.Board) -> list[float]:\n    'mobility difference: white moves minus black moves'\n    import chess\n    try:\n        b1 = board.copy()\n        b1.turn = chess.WHITE\n        white_moves = sum(1 for _ in b1.legal_moves)\n        b2 = board.copy()\n        b2.turn = chess.BLACK\n        black_moves = sum(1 for _ in b2.legal_moves)\n        return [float(white_moves - black_moves)]\n    except Exception:\n        return [0.0]", "def feature(board: chess.Board) -> list[float]:\n    'passed pawn balance: white passed pawns minus black passed pawns'\n    import chess\n    def is_white_passed(sq):\n        f = chess.square_file(sq)\n        r = chess.square_rank(sq)\n        for pf in (f - 1, f, f + 1):\n            if 0 <= pf < 8:\n                for rr in range(r + 1, 8):\n                    s = chess.square(pf, rr)\n                    p = board.piece_at(s)\n                    if p and p.color == chess.BLACK and p.piece_type == chess.PAWN:\n                        return False\n        return True\n\n    def is_black_passed(sq):\n        f = chess.square_file(sq)\n        r = chess.square_rank(sq)\n        for pf in (f - 1, f, f + 1):\n            if 0 <= pf < 8:\n                for rr in range(0, r):\n                    s = chess.square(pf, rr)\n                    p = board.piece_at(s)\n                    if p and p.color == chess.WHITE and p.piece_type == chess.PAWN:\n                        return False\n        return True\n\n    white_passed = 0\n    black_passed = 0\n    for sq, piece in board.piece_map().items():\n        if piece.piece_type == chess.PAWN:\n            if piece.color == chess.WHITE and is_white_passed(sq):\n                white_passed += 1\n            if piece.color == chess.BLACK and is_black_passed(sq):\n                black_passed += 1\n    return [float(white_passed - black_passed)]", "def feature(board: chess.Board) -> list[float]:\n    'center-weighted material difference: proximity to center'\n    import chess\n    values = {chess.PAWN: 1, chess.KNIGHT: 3, chess.BISHOP: 3, chess.ROOK: 5, chess.QUEEN: 9, chess.KING: 0}\n    centers = [chess.parse_square(s) for s in ['d4', 'e4', 'd5', 'e5']]\n    white_sum = 0.0\n    black_sum = 0.0\n    for sq, piece in board.piece_map().items():\n        v = values.get(piece.piece_type, 0)\n        dist = min(chess.square_distance(sq, c) for c in centers)\n        weight = 1.0 / ((dist + 1) * (dist + 1))\n        if piece.color == chess.WHITE:\n            white_sum += v * weight\n        else:\n            black_sum += v * weight\n    return [float(white_sum - black_sum)]", "def feature(board: chess.Board) -> list[float]:\n    'heavy piece count difference: rooks and queens'\n    import chess\n    white_heavy = 0\n    black_heavy = 0\n    for sq, piece in board.piece_map().items():\n        if piece.piece_type in (chess.ROOK, chess.QUEEN):\n            if piece.color == chess.WHITE:\n                white_heavy += 1\n            else:\n                black_heavy += 1\n    return [float(white_heavy - black_heavy)]", "def feature(board: chess.Board) -> list[float]:\n    'rooks on open files: difference white minus black'\n    import chess\n    def is_file_open(f):\n        for r in range(8):\n            s = chess.square(f, r)\n            p = board.piece_at(s)\n            if p and p.piece_type == chess.PAWN:\n                return False\n        return True\n\n    white_open = 0\n    black_open = 0\n    for sq, piece in board.piece_map().items():\n        if piece.piece_type == chess.ROOK:\n            f = chess.square_file(sq)\n            if is_file_open(f):\n                if piece.color == chess.WHITE:\n                    white_open += 1\n                else:\n                    black_open += 1\n    return [float(white_open - black_open)]", "def feature(board: chess.Board) -> list[float]:\n    'minor-piece mobility difference: knights and bishops'\n    import chess\n    def moves_by_types(color, types):\n        b = board.copy()\n        b.turn = color\n        count = 0\n        for mv in b.legal_moves:\n            p = b.piece_at(mv.from_square)\n            if p and p.color == color and p.piece_type in types:\n                count += 1\n        return count\n\n    white_kb = moves_by_types(chess.WHITE, {chess.KNIGHT, chess.BISHOP})\n    black_kb = moves_by_types(chess.BLACK, {chess.KNIGHT, chess.BISHOP})\n    return [float(white_kb - black_kb)]", "def feature(board: chess.Board) -> list[float]:\n    'king safety: difference in attackers on king squares'\n    import chess\n    w_king = board.king(chess.WHITE)\n    b_king = board.king(chess.BLACK)\n    if w_king is None or b_king is None:\n        return [0.0]\n    attackers_on_white = len(board.attackers(chess.BLACK, w_king))\n    attackers_on_black = len(board.attackers(chess.WHITE, b_king))\n    return [float(attackers_on_white - attackers_on_black)]", "def feature(board: chess.Board) -> list[float]:\n    'isolated pawns difference: white minus black'\n    import chess\n    white_files = set()\n    black_files = set()\n    for sq, piece in board.piece_map().items():\n        if piece.piece_type == chess.PAWN:\n            if piece.color == chess.WHITE:\n                white_files.add(chess.square_file(sq))\n            else:\n                black_files.add(chess.square_file(sq))\n    def is_isolated(file, files_set):\n        return not ((file - 1 in files_set) or (file + 1 in files_set))\n    white_iso = 0\n    black_iso = 0\n    for sq, piece in board.piece_map().items():\n        if piece.piece_type == chess.PAWN:\n            f = chess.square_file(sq)\n            if piece.color == chess.WHITE and is_isolated(f, white_files):\n                white_iso += 1\n            if piece.color == chess.BLACK and is_isolated(f, black_files):\n                black_iso += 1\n    return [float(white_iso - black_iso)]", "def feature(board: chess.Board) -> list[float]:\n    'bishop pair presence difference: white vs black'\n    import chess\n    white_bishops = 0\n    black_bishops = 0\n    for sq, piece in board.piece_map().items():\n        if piece.piece_type == chess.BISHOP:\n            if piece.color == chess.WHITE:\n                white_bishops += 1\n            else:\n                black_bishops += 1\n    white_has_pair = 1 if white_bishops >= 2 else 0\n    black_has_pair = 1 if black_bishops >= 2 else 0\n    return [float(white_has_pair - black_has_pair)]", "def feature(board: chess.Board) -> list[float]:\n    \"material_balance: white material minus black material using standard piece values\"\n    values = {chess.PAWN: 1, chess.KNIGHT: 3, chess.BISHOP: 3, chess.ROOK: 5, chess.QUEEN: 9}\n    total = 0.0\n    for sq, piece in board.piece_map().items():\n        if piece is None or piece.piece_type == chess.KING:\n            continue\n        val = values.get(piece.piece_type, 0)\n        if piece.color == chess.WHITE:\n            total += val\n        else:\n            total -= val\n    return total", "def feature(board: chess.Board) -> list[float]:\n    \"pawn_balance: white pawns minus black pawns\"\n    white_pawns = 0\n    black_pawns = 0\n    for sq, piece in board.piece_map().items():\n        if piece is None or piece.piece_type != chess.PAWN:\n            continue\n        if piece.color == chess.WHITE:\n            white_pawns += 1\n        else:\n            black_pawns += 1\n    return float(white_pawns - black_pawns)", "def feature(board: chess.Board) -> list[float]:\n    \"central_piece_balance: white pieces on central squares minus black pieces on central squares\"\n    central = [chess.D4, chess.E4, chess.D5, chess.E5]\n    white_center = 0\n    black_center = 0\n    for sq, piece in board.piece_map().items():\n        if piece is None:\n            continue\n        if sq in central:\n            if piece.color == chess.WHITE:\n                white_center += 1\n            else:\n                black_center += 1\n    return float(white_center - black_center)", "def feature(board: chess.Board) -> list[float]:\n    \"opponent_attackers_on_own_king: number of enemy attackers on side to move's king square\"\n    king_sq = None\n    for sq, piece in board.piece_map().items():\n        if piece and piece.piece_type == chess.KING and piece.color == board.turn:\n            king_sq = sq\n            break\n    if king_sq is None:\n        return 0.0\n    attackers = board.attackers(not board.turn, king_sq)\n    return float(len(attackers))", "def feature(board: chess.Board) -> list[float]:\n    \"mobility_score: number of legal moves for side to move\"\n    return float(sum(1 for _ in board.legal_moves))", "def feature(board: chess.Board) -> list[float]:\n    \"non_pawn_move_ratio: ratio of non-pawn moves to total legal moves for side to move\"\n    total = 0\n    non_pawn = 0\n    for mv in board.legal_moves:\n        total += 1\n        p = board.piece_at(mv.from_square)\n        if p is not None and p.piece_type != chess.PAWN:\n            non_pawn += 1\n    if total == 0:\n        return 0.0\n    return float(non_pawn) / float(total)", "def feature(board: chess.Board) -> list[float]:\n    \"capture_move_ratio: ratio of capturing moves to total legal moves for side to move\"\n    total = 0\n    captures = 0\n    for mv in board.legal_moves:\n        total += 1\n        if board.is_capture(mv):\n            captures += 1\n    if total == 0:\n        return 0.0\n    return float(captures) / float(total)", "def feature(board: chess.Board) -> list[float]:\n    \"minor_piece_balance: white minor pieces minus black minor pieces (N and B)\"\n    white_minors = 0\n    black_minors = 0\n    for sq, piece in board.piece_map().items():\n        if piece is None:\n            continue\n        if piece.piece_type in (chess.KNIGHT, chess.BISHOP):\n            if piece.color == chess.WHITE:\n                white_minors += 1\n            else:\n                black_minors += 1\n    return float(white_minors - black_minors)", "def feature(board: chess.Board) -> list[float]:\n    \"queen_presence_balance: white queens minus black queens\"\n    white_queens = 0\n    black_queens = 0\n    for sq, piece in board.piece_map().items():\n        if piece is None or piece.piece_type != chess.QUEEN:\n            continue\n        if piece.color == chess.WHITE:\n            white_queens += 1\n        else:\n            black_queens += 1\n    return float(white_queens - black_queens)", "def feature(board: chess.Board) -> list[float]:\n    \"average_distance_of_pieces_to_center: average of min distances from pieces to any central square\"\n    center_sqs = [chess.D4, chess.E4, chess.D5, chess.E5]\n    total_dist = 0.0\n    count = 0\n    for sq, piece in board.piece_map().items():\n        if piece is None:\n            continue\n        min_dist = min(chess.square_distance(sq, c) for c in center_sqs)\n        total_dist += float(min_dist)\n        count += 1\n    if count == 0:\n        return 0.0\n    return total_dist / float(count)", "def feature(board: chess.Board) -> list[float]:\n    \"Material balance: white minus black (sum of piece values)\"\n    piece_values = {\n        chess.PAWN: 1,\n        chess.KNIGHT: 3,\n        chess.BISHOP: 3,\n        chess.ROOK: 5,\n        chess.QUEEN: 9\n    }\n    white = 0\n    black = 0\n    for sq, piece in board.piece_map().items():\n        val = piece_values.get(piece.piece_type)\n        if val is None:\n            continue\n        if piece.color == chess.WHITE:\n            white += val\n        else:\n            black += val\n    return float(white - black)", "def feature(board: chess.Board) -> list[float]:\n    \"Heavy piece material balance: white rooks and queens minus black\"\n    heavy_values = {\n        chess.ROOK: 5,\n        chess.QUEEN: 9\n    }\n    white_heavy = 0\n    black_heavy = 0\n    for piece in board.piece_map().values():\n        if piece.piece_type in heavy_values:\n            val = heavy_values[piece.piece_type]\n            if piece.color == chess.WHITE:\n                white_heavy += val\n            else:\n                black_heavy += val\n    return float(white_heavy - black_heavy)", "def feature(board: chess.Board) -> list[float]:\n    \"Passed pawn difference: White passed pawns minus Black passed pawns\"\n    def is_white_passed(pawn_sq):\n        f = chess.square_file(pawn_sq)\n        r = chess.square_rank(pawn_sq)\n        # White pawns move up (towards higher ranks)\n        for ff in range(max(0, f - 1), min(7, f + 1) + 1):\n            for rr in range(r + 1, 8):\n                sq = chess.square(ff, rr)\n                p = board.piece_at(sq)\n                if p is not None and p.piece_type == chess.PAWN and p.color == chess.BLACK:\n                    return False\n        return True\n\n    def is_black_passed(pawn_sq):\n        f = chess.square_file(pawn_sq)\n        r = chess.square_rank(pawn_sq)\n        # Black pawns move down (towards lower ranks)\n        for ff in range(max(0, f - 1), min(7, f + 1) + 1):\n            for rr in range(r - 1, -1, -1):\n                sq = chess.square(ff, rr)\n                p = board.piece_at(sq)\n                if p is not None and p.piece_type == chess.PAWN and p.color == chess.WHITE:\n                    return False\n        return True\n\n    white_passed = 0\n    black_passed = 0\n    for sq, piece in board.piece_map().items():\n        if piece.piece_type == chess.PAWN:\n            if piece.color == chess.WHITE:\n                if is_white_passed(sq):\n                    white_passed += 1\n            else:\n                if is_black_passed(sq):\n                    black_passed += 1\n    return float(white_passed - black_passed)", "def feature(board: chess.Board) -> list[float]:\n    \"Center proximity: weighted sum of piece values by proximity to center (positive white)\"\n    piece_values = {\n        chess.PAWN: 1,\n        chess.KNIGHT: 3,\n        chess.BISHOP: 3,\n        chess.ROOK: 5,\n        chess.QUEEN: 9\n    }\n    center_sum = 0.0\n    for sq, piece in board.piece_map().items():\n        val = piece_values.get(piece.piece_type)\n        if val is None:\n            continue\n        file = chess.square_file(sq)\n        rank = chess.square_rank(sq)\n        dx = abs(file - 3.5)\n        dy = abs(rank - 3.5)\n        dist2 = dx * dx + dy * dy  # squared distance to center\n        weight = 1.0 / (dist2 + 1.0)\n        contrib = val * weight\n        if piece.color == chess.WHITE:\n            center_sum += contrib\n        else:\n            center_sum -= contrib\n    return float(center_sum)", "def feature(board: chess.Board) -> list[float]:\n    \"Mobility of side to move: total number of legal moves\"\n    return float(len(list(board.legal_moves)))", "def feature(board: chess.Board) -> list[float]:\n    \"Mobility by color: difference in number of legal moves originating from White vs Black pieces\"\n    white_moves = 0\n    black_moves = 0\n    for m in board.legal_moves:\n        p = board.piece_at(m.from_square)\n        if p is None:\n            continue\n        if p.color == chess.WHITE:\n            white_moves += 1\n        else:\n            black_moves += 1\n    return float(white_moves - black_moves)", "def feature(board: chess.Board) -> list[float]:\n    \"King safety pressure: attackers on White king minus attackers on Black king\"\n    white_king_sq = board.king(chess.WHITE)\n    black_king_sq = board.king(chess.BLACK)\n    white_attackers = 0\n    black_attackers = 0\n    if white_king_sq is not None:\n        white_attackers = len(board.attackers(chess.BLACK, white_king_sq))\n    if black_king_sq is not None:\n        black_attackers = len(board.attackers(chess.WHITE, black_king_sq))\n    return float(white_attackers - black_attackers)", "def feature(board: chess.Board) -> list[float]:\n    \"Pawn doubled-pawn penalties difference: White minus Black\"\n    white_pawns_per_file = [0] * 8\n    black_pawns_per_file = [0] * 8\n    for sq, piece in board.piece_map().items():\n        if piece.piece_type != chess.PAWN:\n            continue\n        f = chess.square_file(sq)\n        if piece.color == chess.WHITE:\n            white_pawns_per_file[f] += 1\n        else:\n            black_pawns_per_file[f] += 1\n    white_doubles = sum(max(0, cnt - 1) for cnt in white_pawns_per_file)\n    black_doubles = sum(max(0, cnt - 1) for cnt in black_pawns_per_file)\n    return float(white_doubles - black_doubles)", "def feature(board: chess.Board) -> list[float]:\n    \"Minor piece mobility difference: knights and bishops moves White minus Black\"\n    white_minor = 0\n    black_minor = 0\n    for m in board.legal_moves:\n        p = board.piece_at(m.from_square)\n        if p is None:\n            continue\n        if p.piece_type in (chess.KNIGHT, chess.BISHOP):\n            if p.color == chess.WHITE:\n                white_minor += 1\n            else:\n                black_minor += 1\n    return float(white_minor - black_minor)", "def feature(board: chess.Board) -> list[float]:\n    \"Major piece mobility difference: rooks and queens moves White minus Black\"\n    white_major = 0\n    black_major = 0\n    for m in board.legal_moves:\n        p = board.piece_at(m.from_square)\n        if p is None:\n            continue\n        if p.piece_type in (chess.ROOK, chess.QUEEN):\n            if p.color == chess.WHITE:\n                white_major += 1\n            else:\n                black_major += 1\n    return float(white_major - black_major)", "def feature(board: chess.Board) -> list[float]:\n    'material balance: white material minus black material'\n    values = {chess.PAWN: 1, chess.KNIGHT: 3, chess.BISHOP: 3, chess.ROOK: 5, chess.QUEEN: 9, chess.KING: 0}\n    white = 0\n    black = 0\n    for sq, piece in board.piece_map().items():\n        if piece is None:\n            continue\n        val = values.get(piece.piece_type, 0)\n        if piece.color == chess.WHITE:\n            white += val\n        else:\n            black += val\n    return float(white - black)", "def feature(board: chess.Board) -> list[float]:\n    'mobility: number of legal moves for side to move'\n    moves = list(board.legal_moves)\n    return float(len(moves))", "def feature(board: chess.Board) -> list[float]:\n    'mobility by color: white moves minus black moves'\n    def count_for_color(color: chess.Color) -> int:\n        b = board.copy()\n        b.turn = color\n        return len(list(b.legal_moves))\n    white_moves = count_for_color(chess.WHITE)\n    black_moves = count_for_color(chess.BLACK)\n    return float(white_moves - black_moves)", "def feature(board: chess.Board) -> list[float]:\n    'piece centrality difference: weighted sum by proximity to center'\n    centers = [chess.D4, chess.E4, chess.D5, chess.E5]\n    white = 0.0\n    black = 0.0\n    for sq, piece in board.piece_map().items():\n        if piece is None:\n            continue\n        d = min(chess.square_distance(sq, c) for c in centers)\n        val = 1.0 / (1.0 + d)\n        if piece.color == chess.WHITE:\n            white += val\n        else:\n            black += val\n    return float(white - black)", "def feature(board: chess.Board) -> list[float]:\n    'passed pawn difference: white passed pawns minus black passed pawns'\n    def count_passed(color: chess.Color) -> int:\n        opp = chess.BLACK if color == chess.WHITE else chess.WHITE\n        count = 0\n        pawns = [(sq, p) for sq, p in board.piece_map().items() if p is not None and p.color == color and p.piece_type == chess.PAWN]\n        for sq, p in pawns:\n            file = chess.square_file(sq)\n            rank = chess.square_rank(sq)\n            passed = True\n            for sq2, p2 in board.piece_map().items():\n                if p2.color == opp and p2.piece_type == chess.PAWN:\n                    f2 = chess.square_file(sq2)\n                    r2 = chess.square_rank(sq2)\n                    if abs(f2 - file) <= 1 and r2 > rank:\n                        passed = False\n                        break\n            if passed:\n                count += 1\n        return count\n    white_passed = count_passed(chess.WHITE)\n    black_passed = count_passed(chess.BLACK)\n    return float(white_passed - black_passed)", "def feature(board: chess.Board) -> list[float]:\n    'Major piece mobility difference: rooks and queens moves White minus Black'\n    def major_mobility(color: chess.Color) -> int:\n        b = board.copy()\n        b.turn = color\n        count = 0\n        for m in b.legal_moves:\n            p = b.piece_at(m.from_square)\n            if p is not None and p.color == color and p.piece_type in (chess.ROOK, chess.QUEEN):\n                count += 1\n        return count\n    white = major_mobility(chess.WHITE)\n    black = major_mobility(chess.BLACK)\n    return float(white - black)", "def feature(board: chess.Board) -> list[float]:\n    'Minor piece mobility difference: knights and bishops moves White minus Black'\n    def minor_mobility(color: chess.Color) -> int:\n        b = board.copy()\n        b.turn = color\n        count = 0\n        for m in b.legal_moves:\n            p = b.piece_at(m.from_square)\n            if p is not None and p.color == color and p.piece_type in (chess.KNIGHT, chess.BISHOP):\n                count += 1\n        return count\n    white = minor_mobility(chess.WHITE)\n    black = minor_mobility(chess.BLACK)\n    return float(white - black)", "def feature(board: chess.Board) -> list[float]:\n    'Is the side to move currently in check? (1.0 yes, 0.0 no)'\n    return float(1.0 if board.is_check() else 0.0)", "def feature(board: chess.Board) -> list[float]:\n    'King distance to center difference: white king center distance minus black king center distance'\n    centers = [chess.D4, chess.E4, chess.D5, chess.E5]\n    white_king = None\n    black_king = None\n    for sq, piece in board.piece_map().items():\n        if piece is not None and piece.piece_type == chess.KING:\n            if piece.color == chess.WHITE:\n                white_king = sq\n            else:\n                black_king = sq\n    if white_king is None or black_king is None:\n        return float(0.0)\n    white_dist = min(chess.square_distance(white_king, c) for c in centers)\n    black_dist = min(chess.square_distance(black_king, c) for c in centers)\n    return float(white_dist - black_dist)", "def feature(board: chess.Board) -> list[float]:\n    'Doubled pawn difference: white doubled pawns minus black doubled pawns'\n    def count_doubled(color: chess.Color) -> int:\n        counts = [0] * 8\n        for sq, p in board.piece_map().items():\n            if p is not None and p.color == color and p.piece_type == chess.PAWN:\n                f = chess.square_file(sq)\n                counts[f] += 1\n        return sum(max(0, c - 1) for c in counts)\n    white = count_doubled(chess.WHITE)\n    black = count_doubled(chess.BLACK)\n    return float(white - black)", "def feature(board: chess.Board) -> list[float]:\n    \"material balance: white minus black (sum piece values)\"\n    piece_values = {chess.PAWN: 1.0, chess.KNIGHT: 3.0, chess.BISHOP: 3.0, chess.ROOK: 5.0, chess.QUEEN: 9.0}\n    total = 0.0\n    for square, piece in board.piece_map().items():\n        val = piece_values.get(piece.piece_type, 0.0)\n        if piece.color == chess.WHITE:\n            total += val\n        else:\n            total -= val\n    return [total]", "def feature(board: chess.Board) -> list[float]:\n    \"pawn balance: number of white pawns minus number of black pawns\"\n    white_pawns = 0\n    black_pawns = 0\n    for piece in board.piece_map().values():\n        if piece.piece_type == chess.PAWN:\n            if piece.color == chess.WHITE:\n                white_pawns += 1\n            else:\n                black_pawns += 1\n    return [float(white_pawns - black_pawns)]", "def feature(board: chess.Board) -> list[float]:\n    \"king safety: number of attackers on the side to move's king\"\n    own_color = chess.WHITE if board.turn else chess.BLACK\n    opp_color = chess.BLACK if board.turn else chess.WHITE\n    own_king_sq = board.king(own_color)\n    if own_king_sq is None:\n        return [0.0]\n    attackers = board.attackers(opp_color, own_king_sq)\n    return [float(len(attackers))]", "def feature(board: chess.Board) -> list[float]:\n    \"center control: how many central squares are attacked by the side to move\"\n    center_sqs = [chess.D4, chess.E4, chess.D5, chess.E5]\n    own_color = chess.WHITE if board.turn else chess.BLACK\n    count = 0\n    for sq in center_sqs:\n        if board.is_attacked_by(own_color, sq):\n            count += 1\n    return [float(count)]", "def feature(board: chess.Board) -> list[float]:\n    \"passed pawn balance: rough measure of passed pawns for side to move minus opponent's\"\n    def is_passed(board: chess.Board, square: int, color: int) -> bool:\n        file = chess.square_file(square)\n        rank = chess.square_rank(square)\n        if color == chess.WHITE:\n            for f in range(max(0, file - 1), min(7, file + 1) + 1):\n                for r in range(rank + 1, 8):\n                    sq = chess.square(f, r)\n                    p = board.piece_at(sq)\n                    if p and p.piece_type == chess.PAWN and p.color == chess.BLACK:\n                        return False\n            return True\n        else:\n            for f in range(max(0, file - 1), min(7, file + 1) + 1):\n                for r in range(0, rank):\n                    sq = chess.square(f, r)\n                    p = board.piece_at(sq)\n                    if p and p.piece_type == chess.PAWN and p.color == chess.WHITE:\n                        return False\n            return True\n\n    white_passed = 0\n    black_passed = 0\n    for sq, piece in board.piece_map().items():\n        if piece.piece_type == chess.PAWN:\n            if piece.color == chess.WHITE:\n                if is_passed(board, sq, chess.WHITE):\n                    white_passed += 1\n            else:\n                if is_passed(board, sq, chess.BLACK):\n                    black_passed += 1\n    return [float(white_passed - black_passed)]", "def feature(board: chess.Board) -> list[float]:\n    \"opponent king pressure: number of attackers on the opponent's king\"\n    opp_color = chess.BLACK if board.turn else chess.WHITE\n    opp_king_sq = board.king(opp_color)\n    if opp_king_sq is None:\n        return [0.0]\n    attackers = board.attackers(board.turn, opp_king_sq)\n    return [float(len(attackers))]", "def feature(board: chess.Board) -> list[float]:\n    \"open files with rooks: number of rooks on open files (no pawns on that file)\"\n    # Determine open files (no pawns on the file)\n    pawns_on_file = [False] * 8\n    for sq, piece in board.piece_map().items():\n        if piece.piece_type == chess.PAWN:\n            f = chess.square_file(sq)\n            pawns_on_file[f] = True\n    open_files = [f for f in range(8) if not pawns_on_file[f]]\n    # Count rooks of side to move on open files\n    own_color = chess.WHITE if board.turn else chess.BLACK\n    rooks_on_open = 0\n    for sq, piece in board.piece_map().items():\n        if piece.piece_type == chess.ROOK and piece.color == own_color:\n            if chess.square_file(sq) in open_files:\n                rooks_on_open += 1\n    return [float(rooks_on_open)]", "def feature(board: chess.Board) -> list[float]:\n    \"promotion front line: white pawns on rank 6 and black pawns on rank 1\"\n    white_on_rank6 = 0\n    black_on_rank1 = 0\n    for sq, piece in board.piece_map().items():\n        if piece.piece_type == chess.PAWN:\n            r = chess.square_rank(sq)\n            if piece.color == chess.WHITE and r == 6:\n                white_on_rank6 += 1\n            if piece.color == chess.BLACK and r == 1:\n                black_on_rank1 += 1\n    return [float(white_on_rank6 + black_on_rank1)]", "def feature(board: chess.Board) -> list[float]:\n    \"queen proximity to own king: average distance from own queens to own king\"\n    own_color = chess.WHITE if board.turn else chess.BLACK\n    own_king_sq = board.king(own_color)\n    if own_king_sq is None:\n        return [0.0]\n    total_dist = 0.0\n    count = 0\n    for sq, piece in board.piece_map().items():\n        if piece.color == own_color and piece.piece_type == chess.QUEEN:\n            dist = float(chess.square_distance(sq, own_king_sq))\n            total_dist += dist\n            count += 1\n    if count == 0:\n        return [0.0]\n    return [total_dist / count]", "def feature(board: chess.Board) -> list[float]:\n    \"weighted pawn balance: pawns weighted by advancement towards promotion\"\n    white_weight = 0.0\n    black_weight = 0.0\n    for sq, piece in board.piece_map().items():\n        if piece.piece_type == chess.PAWN:\n            rank = chess.square_rank(sq)\n            if piece.color == chess.WHITE:\n                white_weight += 1.0 + (0.15 * rank)  # advanced pawns get more weight\n            else:\n                black_weight += 1.0 + (0.15 * (7 - rank))\n    return [float(white_weight - black_weight)]", "def feature(board: chess.Board) -> list[float]:\n    'material balance: white minus black'\n    values = {\n        chess.PAWN: 1,\n        chess.KNIGHT: 3,\n        chess.BISHOP: 3,\n        chess.ROOK: 5,\n        chess.QUEEN: 9,\n        chess.KING: 0\n    }\n    total = 0\n    for sq, piece in board.piece_map().items():\n        sign = 1 if piece.color == chess.WHITE else -1\n        total += sign * values.get(piece.piece_type, 0)\n    return float(total)", "def feature(board: chess.Board) -> list[float]:\n    'mobility of side to move: number of legal moves'\n    return float(sum(1 for _ in board.legal_moves))", "def feature(board: chess.Board) -> list[float]:\n    'mobility by color: white minus black legal moves'\n    def count_moves_color(b, color):\n        bb = b.copy()\n        bb.turn = color\n        return sum(1 for _ in bb.legal_moves)\n    white_moves = count_moves_color(board, chess.WHITE)\n    black_moves = count_moves_color(board, chess.BLACK)\n    return float(white_moves - black_moves)", "def feature(board: chess.Board) -> list[float]:\n    'king safety: negative count of enemy attacks around own king'\n    own = board.turn\n    enemy = not own\n    ksq = board.king(own)\n    if ksq is None:\n        return float(0.0)\n    f = chess.square_file(ksq)\n    r = chess.square_rank(ksq)\n    count = 0\n    for df in (-1, 0, 1):\n        for dr in (-1, 0, 1):\n            if df == 0 and dr == 0:\n                continue\n            nf = f + df\n            nr = r + dr\n            if 0 <= nf < 8 and 0 <= nr < 8:\n                sq = chess.square(nf, nr)\n                if board.is_attacked_by(enemy, sq):\n                    count += 1\n    return float(-count)", "def feature(board: chess.Board) -> list[float]:\n    'center proximity centrality: weighted sum of piece values by distance to center'\n    values = {\n        chess.PAWN: 1,\n        chess.KNIGHT: 3,\n        chess.BISHOP: 3,\n        chess.ROOK: 5,\n        chess.QUEEN: 9,\n        chess.KING: 0\n    }\n    total = 0.0\n    for sq, piece in board.piece_map().items():\n        f = chess.square_file(sq)\n        r = chess.square_rank(sq)\n        dx = f - 3.5\n        dy = r - 3.5\n        dist = (dx * dx + dy * dy) ** 0.5\n        w = 1.0 / (1.0 + dist)\n        sign = 1 if piece.color == chess.WHITE else -1\n        total += sign * values.get(piece.piece_type, 0) * w\n    return float(total)", "def feature(board: chess.Board) -> list[float]:\n    'passed pawn difference: white passed pawns minus black passed pawns'\n    def is_passed_white(b, sq):\n        p = b.piece_at(sq)\n        if p is None or p.piece_type != chess.PAWN or p.color != chess.WHITE:\n            return False\n        f = chess.square_file(sq)\n        r = chess.square_rank(sq)\n        for ff in (f - 1, f, f + 1):\n            if 0 <= ff < 8:\n                for rr in range(r + 1, 8):\n                    sq2 = chess.square(ff, rr)\n                    p2 = b.piece_at(sq2)\n                    if p2 is not None and p2.piece_type == chess.PAWN and p2.color == chess.BLACK:\n                        return False\n        return True\n\n    def is_passed_black(b, sq):\n        p = b.piece_at(sq)\n        if p is None or p.piece_type != chess.PAWN or p.color != chess.BLACK:\n            return False\n        f = chess.square_file(sq)\n        r = chess.square_rank(sq)\n        for ff in (f - 1, f, f + 1):\n            if 0 <= ff < 8:\n                for rr in range(0, r):\n                    sq2 = chess.square(ff, rr)\n                    p2 = b.piece_at(sq2)\n                    if p2 is not None and p2.piece_type == chess.PAWN and p2.color == chess.WHITE:\n                        return False\n        return True\n\n    passed_w = 0\n    passed_b = 0\n    for sq, piece in board.piece_map().items():\n        if piece.piece_type == chess.PAWN:\n            if piece.color == chess.WHITE and is_passed_white(board, sq):\n                passed_w += 1\n            if piece.color == chess.BLACK and is_passed_black(board, sq):\n                passed_b += 1\n    return float(passed_w - passed_b)", "def feature(board: chess.Board) -> list[float]:\n    'heavy piece count difference: rooks and queens'\n    white_heavy = 0\n    black_heavy = 0\n    for piece in board.piece_map().values():\n        if piece.piece_type in (chess.ROOK, chess.QUEEN):\n            if piece.color == chess.WHITE:\n                white_heavy += 1\n            else:\n                black_heavy += 1\n    return float(white_heavy - black_heavy)", "def feature(board: chess.Board) -> list[float]:\n    'doubled pawns difference: white minus black'\n    white_counts = [0] * 8\n    black_counts = [0] * 8\n    for sq, piece in board.piece_map().items():\n        if piece.piece_type == chess.PAWN:\n            f = chess.square_file(sq)\n            if piece.color == chess.WHITE:\n                white_counts[f] += 1\n            else:\n                black_counts[f] += 1\n    white_doubled = sum(1 for c in white_counts if c >= 2)\n    black_doubled = sum(1 for c in black_counts if c >= 2)\n    return float(white_doubled - black_doubled)", "def feature(board: chess.Board) -> list[float]:\n    'king distance between kings: negative distance favors closer kings'\n    wk = board.king(chess.WHITE)\n    bk = board.king(chess.BLACK)\n    if wk is None or bk is None:\n        return float(0.0)\n    dist = chess.square_distance(wk, bk)\n    return float(-dist)", "def feature(board: chess.Board) -> list[float]:\n    'development difference: developed minor/major pieces'\n    white_dev = 0\n    black_dev = 0\n    for sq, piece in board.piece_map().items():\n        if piece.piece_type == chess.PAWN:\n            continue\n        rank = chess.square_rank(sq)\n        if piece.color == chess.WHITE:\n            if rank != 0:\n                white_dev += 1\n        else:\n            if rank != 7:\n                black_dev += 1\n    return float(white_dev - black_dev)", "def feature(board: chess.Board) -> list[float]:\n    'check status: 1.0 if in check, else 0.0'\n    return float(1.0 if board.is_check() else 0.0)", "def feature(board: chess.Board) -> list[float]:\n    \"Material balance: white material minus black material\"\n    import chess\n    values = {\n        chess.PAWN: 1,\n        chess.KNIGHT: 3,\n        chess.BISHOP: 3,\n        chess.ROOK: 5,\n        chess.QUEEN: 9\n    }\n    white = 0\n    black = 0\n    for sq, piece in board.piece_map().items():\n        if piece.piece_type in values:\n            val = values[piece.piece_type]\n            if piece.color == chess.WHITE:\n                white += val\n            else:\n                black += val\n    return float(white - black)", "def feature(board: chess.Board) -> list[float]:\n    \"Mobility of side to move: number of legal moves\"\n    import chess\n    mobility = sum(1 for _ in board.legal_moves)\n    return float(mobility)", "def feature(board: chess.Board) -> list[float]:\n    \"Mobility by color difference: White vs Black moves if to move\"\n    import chess\n    b1 = board.copy()\n    b1.turn = chess.WHITE\n    mobility_white = sum(1 for _ in b1.legal_moves)\n\n    b2 = board.copy()\n    b2.turn = chess.BLACK\n    mobility_black = sum(1 for _ in b2.legal_moves)\n\n    return float(mobility_white - mobility_black)", "def feature(board: chess.Board) -> list[float]:\n    \"Heavy piece count difference: rooks and queens\"\n    import chess\n    white_heavy = 0\n    black_heavy = 0\n    for sq, piece in board.piece_map().items():\n        if piece.piece_type in (chess.ROOK, chess.QUEEN):\n            if piece.color == chess.WHITE:\n                white_heavy += 1\n            else:\n                black_heavy += 1\n    return float(white_heavy - black_heavy)", "def feature(board: chess.Board) -> list[float]:\n    \"Passed pawn difference: White minus Black\"\n    import chess\n    white_passed = 0\n    black_passed = 0\n\n    # Helpers to check passed status\n    def is_white_passed(pawn_sq):\n        pf = chess.square_file(pawn_sq)\n        pr = chess.square_rank(pawn_sq)\n        for sq, p in board.piece_map().items():\n            if p.color == chess.BLACK and p.piece_type == chess.PAWN:\n                bf = chess.square_file(sq)\n                br = chess.square_rank(sq)\n                if abs(bf - pf) <= 1 and br > pr:\n                    return False\n        return True\n\n    def is_black_passed(pawn_sq):\n        bf = chess.square_file(pawn_sq)\n        br = chess.square_rank(pawn_sq)\n        for sq, p in board.piece_map().items():\n            if p.color == chess.WHITE and p.piece_type == chess.PAWN:\n                wtf = chess.square_file(sq)\n                wtr = chess.square_rank(sq)\n                if abs(wtf - bf) <= 1 and wtr < br:\n                    return False\n        return True\n\n    for sq, piece in board.piece_map().items():\n        if piece.piece_type == chess.PAWN:\n            if piece.color == chess.WHITE:\n                if is_white_passed(sq):\n                    white_passed += 1\n            else:\n                if is_black_passed(sq):\n                    black_passed += 1\n\n    return float(white_passed - black_passed)", "def feature(board: chess.Board) -> list[float]:\n    \"Piece centrality difference: weighted sum by proximity to center\"\n    import chess\n    import math\n    center_x = 3.5\n    center_y = 3.5\n    white_sum = 0.0\n    black_sum = 0.0\n\n    for sq, piece in board.piece_map().items():\n        if piece.piece_type == chess.KING:\n            continue\n        f = chess.square_file(sq)\n        r = chess.square_rank(sq)\n        dist = math.hypot(f - center_x, r - center_y)\n        weight = 1.0 / (1.0 + dist)\n        if piece.color == chess.WHITE:\n            white_sum += weight\n        else:\n            black_sum += weight\n\n    return float(white_sum - black_sum)", "def feature(board: chess.Board) -> list[float]:\n    \"Current player check status: 1 if in check, else 0\"\n    import chess\n    return float(1.0 if board.is_check() else 0.0)", "def feature(board: chess.Board) -> list[float]:\n    \"King distance to center difference: White king distance minus Black king distance\"\n    import chess\n    def king_dist(ksq):\n        if ksq is None:\n            return 0.0\n        f = chess.square_file(ksq)\n        r = chess.square_rank(ksq)\n        return ( (f - 3.5)**2 + (r - 3.5)**2 )**0.5\n\n    wk = bk = None\n    for sq, piece in board.piece_map().items():\n        if piece.piece_type == chess.KING:\n            if piece.color == chess.WHITE:\n                wk = sq\n            else:\n                bk = sq\n\n    dw = king_dist(wk)\n    db = king_dist(bk)\n    return float(dw - db)", "def feature(board: chess.Board) -> list[float]:\n    \"Capture moves ratio: captures divided by total legal moves\"\n    import chess\n    total = sum(1 for _ in board.legal_moves)\n    captures = 0\n    for mv in board.legal_moves:\n        if board.is_capture(mv):\n            captures += 1\n    ratio = captures / total if total > 0 else 0.0\n    return float(ratio)", "def feature(board: chess.Board) -> list[float]:\n    \"Doubled pawns difference: White doubled pawns minus Black doubled pawns\"\n    import chess\n    def count_doubled(color):\n        file_counts = [0]*8\n        for sq, p in board.piece_map().items():\n            if p.color == color and p.piece_type == chess.PAWN:\n                file_counts[chess.square_file(sq)] += 1\n        doubled = sum(max(0, c-1) for c in file_counts)\n        return int(doubled)\n\n    white_doubled = count_doubled(chess.WHITE)\n    black_doubled = count_doubled(chess.BLACK)\n    return float(white_doubled - black_doubled)", "def feature(board: chess.Board) -> list[float]:\n    \"Material balance: white material minus black material, normalized by total material\"\n    white = 0.0\n    black = 0.0\n    values = {chess.PAWN: 1.0, chess.KNIGHT: 3.0, chess.BISHOP: 3.0, chess.ROOK: 5.0, chess.QUEEN: 9.0, chess.KING: 0.0}\n    for sq, piece in board.piece_map().items():\n        val = values.get(piece.piece_type, 0.0)\n        if piece.color == chess.WHITE:\n            white += val\n        else:\n            black += val\n    denom = max(1.0, white + black)\n    return float((white - black) / denom)", "def feature(board: chess.Board) -> list[float]:\n    \"Mobility: number of legal moves for side to move\"\n    if board.is_game_over():\n        return 0.0\n    moves = sum(1 for _ in board.legal_moves)\n    return float(moves)", "def feature(board: chess.Board) -> list[float]:\n    \"Mobility by color: White moves minus Black moves\"\n    b_w = board.copy()\n    b_w.turn = chess.WHITE\n    moves_w = sum(1 for _ in b_w.legal_moves)\n\n    b_b = board.copy()\n    b_b.turn = chess.BLACK\n    moves_b = sum(1 for _ in b_b.legal_moves)\n\n    return float(moves_w - moves_b)", "def feature(board: chess.Board) -> list[float]:\n    \"Mobility by color difference: White moves minus Black moves, normalized by total mobility\"\n    b_w = board.copy()\n    b_w.turn = chess.WHITE\n    moves_w = sum(1 for _ in b_w.legal_moves)\n\n    b_b = board.copy()\n    b_b.turn = chess.BLACK\n    moves_b = sum(1 for _ in b_b.legal_moves)\n\n    total = max(1.0, moves_w + moves_b)\n    return float((moves_w - moves_b) / total)", "def feature(board: chess.Board) -> list[float]:\n    \"Heavy piece balance: difference in rooks and queens between White and Black\"\n    white_heavy = 0\n    black_heavy = 0\n    for sq, piece in board.piece_map().items():\n        if piece.piece_type in (chess.ROOK, chess.QUEEN):\n            if piece.color == chess.WHITE:\n                white_heavy += 1\n            else:\n                black_heavy += 1\n    return float(white_heavy - black_heavy)", "def feature(board: chess.Board) -> list[float]:\n    \"Passed pawns difference: White passed pawns minus Black passed pawns\"\n    def count_passed(color: bool) -> int:\n        pawns = [sq for sq, p in board.piece_map().items() if p.piece_type == chess.PAWN and p.color == color]\n        passed = 0\n        opp = chess.BLACK if color else chess.WHITE  # not color; placeholder\n        return 0  # placeholder to satisfy syntax\n    # Implement a robust passed pawn check\n    white_passed = 0\n    black_passed = 0\n    for sq, piece in board.piece_map().items():\n        if piece.piece_type != chess.PAWN:\n            continue\n        file = chess.square_file(sq)\n        rank = chess.square_rank(sq)\n        if piece.color == chess.WHITE:\n            blocked = False\n            for f in (file - 1, file, file + 1):\n                if 0 <= f <= 7:\n                    for r in range(rank + 1, 8):\n                        s = chess.square(f, r)\n                        p = board.piece_at(s)\n                        if p is not None and p.color == chess.BLACK and p.piece_type == chess.PAWN:\n                            blocked = True\n                            break\n                    if blocked:\n                        break\n            if not blocked:\n                white_passed += 1\n        else:\n            blocked = False\n            for f in (file - 1, file, file + 1):\n                if 0 <= f <= 7:\n                    for r in range(0, rank):\n                        s = chess.square(f, r)\n                        p = board.piece_at(s)\n                        if p is not None and p.color == chess.WHITE and p.piece_type == chess.PAWN:\n                            blocked = True\n                            break\n                    if blocked:\n                        break\n            if not blocked:\n                black_passed += 1\n    return float(white_passed - black_passed)", "def feature(board: chess.Board) -> list[float]:\n    \"King safety: negative value for more attackers on the king\"\n    king_sq = board.king(board.turn)\n    if king_sq is None:\n        return 0.0\n    enemy = not board.turn\n    attackers = len(board.attackers(enemy, king_sq))\n    score = -float(attackers)\n    if board.is_check():\n        score -= 2.0\n    return float(score)", "def feature(board: chess.Board) -> list[float]:\n    \"Central control diff: attackers on central squares by White minus Black\"\n    center_squares = [chess.D4, chess.E4, chess.D5, chess.E5]\n    diff = 0\n    for sq in center_squares:\n        diff += len(board.attackers(chess.WHITE, sq)) - len(board.attackers(chess.BLACK, sq))\n    return float(diff)", "def feature(board: chess.Board) -> list[float]:\n    \"Isolated pawns difference: White isolated pawns minus Black isolated pawns\"\n    def count_isolated(color: bool) -> int:\n        isolated = 0\n        for sq, p in board.piece_map().items():\n            if p.piece_type != chess.PAWN or p.color != color:\n                continue\n            file = chess.square_file(sq)\n            rank = chess.square_rank(sq)\n            has_neighbor = False\n            for nf in (file - 1, file + 1):\n                if 0 <= nf <= 7:\n                    for r in range(8):\n                        s = chess.square(nf, r)\n                        q = board.piece_at(s)\n                        if q is not None and q.color == color and q.piece_type == chess.PAWN:\n                            has_neighbor = True\n                            break\n                    if has_neighbor:\n                        break\n            if not has_neighbor:\n                isolated += 1\n        return isolated\n    iso_w = count_isolated(chess.WHITE)\n    iso_b = count_isolated(chess.BLACK)\n    return float(iso_w - iso_b)", "def feature(board: chess.Board) -> list[float]:\n    \"Mobility of side to move: number of legal moves\"\n    import chess\n    try:\n        moves = list(board.legal_moves)\n        val = len(moves) / 20.0\n    except Exception:\n        val = 0.0\n    return [float(val)]", "def feature(board: chess.Board) -> list[float]:\n    \"Material balance: white minus black in standard values\"\n    import chess\n    VALUE = {chess.PAWN: 1, chess.KNIGHT: 3, chess.BISHOP: 3, chess.ROOK: 5, chess.QUEEN: 9, chess.KING: 0}\n    white = 0\n    black = 0\n    for square, piece in board.piece_map().items():\n        v = VALUE.get(piece.piece_type, 0)\n        if piece.color == chess.WHITE:\n            white += v\n        else:\n            black += v\n    diff = white - black\n    return [float(diff)]", "def feature(board: chess.Board) -> list[float]:\n    \"Passed pawn difference: white passed pawns minus black passed pawns\"\n    import chess\n\n    def is_passed(square: int, color) -> bool:\n        file = chess.square_file(square)\n        rank = chess.square_rank(square)\n        if color == chess.WHITE:\n            for r in range(rank + 1, 8):\n                for f in (file - 1, file, file + 1):\n                    if 0 <= f < 8:\n                        sq = chess.square(f, r)\n                        p = board.piece_at(sq)\n                        if p and p.piece_type == chess.PAWN and p.color == chess.BLACK:\n                            return False\n            return True\n        else:\n            for r in range(rank - 1, -1, -1):\n                for f in (file - 1, file, file + 1):\n                    if 0 <= f < 8:\n                        sq = chess.square(f, r)\n                        p = board.piece_at(sq)\n                        if p and p.piece_type == chess.PAWN and p.color == chess.WHITE:\n                            return False\n            return True\n\n    passed_white = 0\n    passed_black = 0\n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.PAWN:\n            if piece.color == chess.WHITE and is_passed(square, chess.WHITE):\n                passed_white += 1\n            if piece.color == chess.BLACK and is_passed(square, chess.BLACK):\n                passed_black += 1\n    diff = passed_white - passed_black\n    return [float(diff)]", "def feature(board: chess.Board) -> list[float]:\n    \"Centrality difference: weighted sum by proximity to center\"\n    import chess\n    center_sqs = [(3, 3), (4, 3), (3, 4), (4, 4)]\n    white_sum = 0.0\n    black_sum = 0.0\n\n    VALUES = {chess.PAWN: 1, chess.KNIGHT: 3, chess.BISHOP: 3, chess.ROOK: 5, chess.QUEEN: 9, chess.KING: 0}\n\n    for sq, piece in board.piece_map().items():\n        f = chess.square_file(sq)\n        r = chess.square_rank(sq)\n        # distance to nearest center square using Chebyshev distance\n        dist = None\n        for cf, cr in center_sqs:\n            d = max(abs(f - cf), abs(r - cr))\n            if dist is None or d < dist:\n                dist = d\n        if dist is None:\n            dist = 0\n        centrality = 1.0 / (1.0 + dist)\n        val = VALUES.get(piece.piece_type, 0)\n        contrib = val * centrality\n        if piece.color == chess.WHITE:\n            white_sum += contrib\n        else:\n            black_sum += contrib\n\n    return [float(white_sum - black_sum)]", "def feature(board: chess.Board) -> list[float]:\n    \"Doubled pawn difference: number of doubled pawns_white minus doubled pawns_black\"\n    import chess\n    white_files = {}\n    black_files = {}\n    for sq, piece in board.piece_map().items():\n        if piece.piece_type == chess.PAWN:\n            f = chess.square_file(sq)\n            if piece.color == chess.WHITE:\n                white_files[f] = white_files.get(f, 0) + 1\n            else:\n                black_files[f] = black_files.get(f, 0) + 1\n\n    doubled_white = sum(n - 1 for n in white_files.values() if n > 1)\n    doubled_black = sum(n - 1 for n in black_files.values() if n > 1)\n    return [float(doubled_white - doubled_black)]", "def feature(board: chess.Board) -> list[float]:\n    \"Is side to move in check: 1.0 if in check else 0.0\"\n    import chess\n    val = 1.0 if board.is_check() else 0.0\n    return [float(val)]", "def feature(board: chess.Board) -> list[float]:\n    \"King distance to center difference: White king distance minus Black king distance\"\n    import chess\n\n    def dist_to_center(sq: int) -> float:\n        if sq is None:\n            return 0.0\n        f = chess.square_file(sq)\n        r = chess.square_rank(sq)\n        centers = [(3, 3), (4, 3), (3, 4), (4, 4)]\n        d = None\n        for cf, cr in centers:\n            di = max(abs(f - cf), abs(r - cr))\n            if d is None or di < d:\n                d = di\n        return float(d if d is not None else 0)\n\n    wk = board.king(chess.WHITE)\n    bk = board.king(chess.BLACK)\n    if wk is None or bk is None:\n        diff = 0.0\n    else:\n        diff = dist_to_center(wk) - dist_to_center(bk)\n    return [float(diff)]", "def feature(board: chess.Board) -> list[float]:\n    \"Heavy piece count difference: rooks and queens (White minus Black)\"\n    import chess\n    white_heavy = 0\n    black_heavy = 0\n    for sq, piece in board.piece_map().items():\n        if piece.color == chess.WHITE and piece.piece_type in (chess.ROOK, chess.QUEEN):\n            white_heavy += 1\n        elif piece.color == chess.BLACK and piece.piece_type in (chess.ROOK, chess.QUEEN):\n            black_heavy += 1\n    return [float(white_heavy - black_heavy)]", "def feature(board: chess.Board) -> list[float]:\n    \"Center square attackers difference: White attackers minus Black attackers on center squares\"\n    import chess\n    center_sqs = [chess.D4, chess.E4, chess.D5, chess.E5]\n    diff = 0\n    for sq in center_sqs:\n        diff += len(board.attackers(chess.WHITE, sq)) - len(board.attackers(chess.BLACK, sq))\n    return [float(diff)]", "def feature(board: chess.Board) -> list[float]:\n    \"Isolated pawn difference: white isolated pawns minus black isolated pawns\"\n    import chess\n    white_isolated = 0\n    black_isolated = 0\n\n    def has_pawn(color, file, rank=None):\n        for r in range(8):\n            if board.piece_at(chess.square(file, r)) and board.piece_at(chess.square(file, r)).piece_type == chess.PAWN and board.piece_at(chess.square(file, r)).color == color:\n                return True\n        return False\n\n    for sq, piece in board.piece_map().items():\n        if piece.piece_type != chess.PAWN:\n            continue\n        f = chess.square_file(sq)\n        color = piece.color\n        adjacent = []\n        if f - 1 >= 0:\n            adjacent.append(f - 1)\n        if f + 1 <= 7:\n            adjacent.append(f + 1)\n        isolated = True\n        for af in adjacent:\n            if any(pp.piece_type == chess.PAWN and pp.color != color for pp in board.piece_map().values()):\n                # check if there exists an opponent pawn on adjacent file (any rank)\n                for r in range(8):\n                    p = board.piece_at(chess.square(af, r))\n                    if p and p.piece_type == chess.PAWN and p.color != color:\n                        isolated = False\n                        break\n                if not isolated:\n                    break\n        if color == chess.WHITE:\n            if isolated:\n                white_isolated += 1\n        else:\n            if isolated:\n                black_isolated += 1\n    return [float(white_isolated - black_isolated)]", "def feature(board: chess.Board) -> list[float]:\n    \"Material balance: white minus black total material\"\n    value_map = {\n        chess.PAWN: 1.0,\n        chess.KNIGHT: 3.0,\n        chess.BISHOP: 3.0,\n        chess.ROOK: 5.0,\n        chess.QUEEN: 9.0,\n        chess.KING: 0.0\n    }\n    white = 0.0\n    black = 0.0\n    for sq, p in board.piece_map().items():\n        val = value_map.get(p.piece_type, 0.0)\n        if p.color == chess.WHITE:\n            white += val\n        else:\n            black += val\n    return float(white - black)", "def feature(board: chess.Board) -> list[float]:\n    \"Mobility of side to move: number of legal moves\"\n    try:\n        count = sum(1 for _ in board.legal_moves)\n    except Exception:\n        count = 0\n    return float(count)", "def feature(board: chess.Board) -> list[float]:\n    \"Mobility by color: difference in number of legal moves White vs Black pieces\"\n    try:\n        wb = board.copy()\n        wb.turn = chess.WHITE\n        moves_white = sum(1 for _ in wb.legal_moves)\n        bb = board.copy()\n        bb.turn = chess.BLACK\n        moves_black = sum(1 for _ in bb.legal_moves)\n        return float(moves_white - moves_black)\n    except Exception:\n        return 0.0", "def feature(board: chess.Board) -> list[float]:\n    \"Heavy piece count difference: rooks and queens (White - Black)\"\n    white_heavy = 0\n    black_heavy = 0\n    for p in board.piece_map().values():\n        if p.piece_type in (chess.ROOK, chess.QUEEN):\n            if p.color == chess.WHITE:\n                white_heavy += 1\n            else:\n                black_heavy += 1\n    return float(white_heavy - black_heavy)", "def feature(board: chess.Board) -> list[float]:\n    \"Passed pawn difference: white passed pawns minus black passed pawns\"\n    def is_white_passed(square, b):\n        file = chess.square_file(square)\n        rank = chess.square_rank(square)\n        for f in range(max(0, file - 1), min(7, file + 1) + 1):\n            for r in range(rank + 1, 8):\n                sq = chess.square(f, r)\n                pc = b.piece_at(sq)\n                if pc is not None and pc.piece_type == chess.PAWN and pc.color == chess.BLACK:\n                    return False\n        return True\n\n    def is_black_passed(square, b):\n        file = chess.square_file(square)\n        rank = chess.square_rank(square)\n        for f in range(max(0, file - 1), min(7, file + 1) + 1):\n            for r in range(0, rank):\n                sq = chess.square(f, r)\n                pc = b.piece_at(sq)\n                if pc is not None and pc.piece_type == chess.PAWN and pc.color == chess.WHITE:\n                    return False\n        return True\n\n    white_passed = 0\n    black_passed = 0\n    for sq, p in board.piece_map().items():\n        if p.color == chess.WHITE and p.piece_type == chess.PAWN:\n            if is_white_passed(sq, board):\n                white_passed += 1\n        elif p.color == chess.BLACK and p.piece_type == chess.PAWN:\n            if is_black_passed(sq, board):\n                black_passed += 1\n    return float(white_passed - black_passed)", "def feature(board: chess.Board) -> list[float]:\n    \"King safety differential: white king safety vs black king safety\"\n    white_king = board.king(chess.WHITE)\n    black_king = board.king(chess.BLACK)\n    white_attackers = 0\n    black_attackers = 0\n    if white_king is not None:\n        white_attackers = len(board.attackers(chess.BLACK, white_king))\n    if black_king is not None:\n        black_attackers = len(board.attackers(chess.WHITE, black_king))\n    return float(white_attackers - black_attackers)", "def feature(board: chess.Board) -> list[float]:\n    \"Center proximity difference: white pieces proximity to center minus black pieces proximity\"\n    center_squares = [chess.D4, chess.E4, chess.D5, chess.E5]\n    white_sum = 0.0\n    black_sum = 0.0\n    for sq, p in board.piece_map().items():\n        dist = min(chess.square_distance(sq, c) for c in center_squares)\n        centrality = 1.0 / (1.0 + dist)\n        if p.color == chess.WHITE:\n            white_sum += centrality\n        else:\n            black_sum += centrality\n    return float(white_sum - black_sum)", "def feature(board: chess.Board) -> list[float]:\n    \"Material balance: white minus black material, normalized by total material\"\n    value_map = {\n        chess.PAWN: 1.0,\n        chess.KNIGHT: 3.0,\n        chess.BISHOP: 3.0,\n        chess.ROOK: 5.0,\n        chess.QUEEN: 9.0,\n        chess.KING: 0.0\n    }\n    white = 0.0\n    black = 0.0\n    for p in board.piece_map().values():\n        val = value_map.get(p.piece_type, 0.0)\n        if p.color == chess.WHITE:\n            white += val\n        else:\n            black += val\n    total = white + black\n    if total == 0.0:\n        return 0.0\n    return float((white - black) / total)", "def feature(board: chess.Board) -> list[float]:\n    \"Doubled pawn difference: white doubled pawns minus black doubled pawns\"\n    white_counts = [0] * 8\n    black_counts = [0] * 8\n    for sq, p in board.piece_map().items():\n        if p.piece_type == chess.PAWN:\n            file = chess.square_file(sq)\n            if p.color == chess.WHITE:\n                white_counts[file] += 1\n            else:\n                black_counts[file] += 1\n    white_doubled = sum(max(0, c - 1) for c in white_counts)\n    black_doubled = sum(max(0, c - 1) for c in black_counts)\n    return float(white_doubled - black_doubled)", "def feature(board: chess.Board) -> list[float]:\n    \"Advanced pawn pressure difference: white advanced pawns minus black advanced pawns\"\n    white_adv = 0\n    black_adv = 0\n    for sq, p in board.piece_map().items():\n        if p.piece_type != chess.PAWN:\n            continue\n        file = chess.square_file(sq)\n        rank = chess.square_rank(sq)\n        if p.color == chess.WHITE:\n            if rank >= 5:  # ranks 6,7,8 from white's perspective (0-based: 5,6,7)\n                white_adv += 1\n        else:\n            if rank <= 2:  # ranks 1,2,3 from white's perspective (0-based: 0,1,2)\n                black_adv += 1\n    return float(white_adv - black_adv)", "def feature(board: chess.Board) -> list[float]:\n    \"material balance: White minus Black material difference\"\n    try:\n        values = {chess.PAWN: 1, chess.KNIGHT: 3, chess.BISHOP: 3, chess.ROOK: 5, chess.QUEEN: 9, chess.KING: 0}\n        white = 0\n        black = 0\n        for square, piece in board.piece_map().items():\n            val = values.get(piece.piece_type, 0)\n            if piece.color == chess.WHITE:\n                white += val\n            else:\n                black += val\n        return [float(white - black)]\n    except Exception:\n        return [0.0]", "def feature(board: chess.Board) -> list[float]:\n    \"king safety difference: attackers on white king minus attackers on black king\"\n    try:\n        w_king = board.king(chess.WHITE)\n        b_king = board.king(chess.BLACK)\n        attackers_white = len(board.attackers(chess.BLACK, w_king)) if w_king is not None else 0\n        attackers_black = len(board.attackers(chess.WHITE, b_king)) if b_king is not None else 0\n        return [float(attackers_white - attackers_black)]\n    except Exception:\n        return [0.0]", "def feature(board: chess.Board) -> list[float]:\n    \"mobility by color: White moves minus Black moves\"\n    try:\n        def mobility_for_color(bd: chess.Board, color: bool) -> int:\n            bb = bd.copy()\n            bb.turn = color\n            cnt = 0\n            for _ in bb.legal_moves:\n                cnt += 1\n            return cnt\n        w_moves = mobility_for_color(board, chess.WHITE)\n        b_moves = mobility_for_color(board, chess.BLACK)\n        return [float(w_moves - b_moves)]\n    except Exception:\n        return [0.0]", "def feature(board: chess.Board) -> list[float]:\n    \"piece centrality difference: weighted sum by proximity to center\"\n    try:\n        center_sqs = [chess.D4, chess.E4, chess.D5, chess.E5]\n        def centrality(bd: chess.Board, color: bool) -> float:\n            total = 0.0\n            for sq, piece in bd.piece_map().items():\n                if piece.color != color:\n                    continue\n                dist = min(chess.square_distance(sq, c) for c in center_sqs)\n                total += 1.0 / (dist + 1.0)\n            return total\n        white_cent = centrality(board, chess.WHITE)\n        black_cent = centrality(board, chess.BLACK)\n        return [float(white_cent - black_cent)]\n    except Exception:\n        return [0.0]", "def feature(board: chess.Board) -> list[float]:\n    \"heavy piece count difference: rooks and queens\"\n    try:\n        white_heavy = 0\n        black_heavy = 0\n        for piece in board.piece_map().values():\n            if piece.piece_type in (chess.ROOK, chess.QUEEN):\n                if piece.color == chess.WHITE:\n                    white_heavy += 1\n                else:\n                    black_heavy += 1\n        return [float(white_heavy - black_heavy)]\n    except Exception:\n        return [0.0]", "def feature(board: chess.Board) -> list[float]:\n    \"passed pawn difference: White passed pawns minus Black passed pawns\"\n    try:\n        def is_white_passed(sq: int) -> bool:\n            f = chess.square_file(sq)\n            r = chess.square_rank(sq)\n            # check for any black pawn on files f-1..f+1 with rank > r\n            for pf in (f - 1, f, f + 1):\n                if 0 <= pf <= 7:\n                    for rr in range(r + 1, 8):\n                        s = chess.square(pf, rr)\n                        p = board.piece_at(s)\n                        if p is not None and p.piece_type == chess.PAWN and p.color == chess.BLACK:\n                            return False\n            return True\n\n        def is_black_passed(sq: int) -> bool:\n            f = chess.square_file(sq)\n            r = chess.square_rank(sq)\n            for pf in (f - 1, f, f + 1):\n                if 0 <= pf <= 7:\n                    for rr in range(0, r):\n                        s = chess.square(pf, rr)\n                        p = board.piece_at(s)\n                        if p is not None and p.piece_type == chess.PAWN and p.color == chess.WHITE:\n                            return False\n            return True\n\n        white_passed = 0\n        black_passed = 0\n        for sq, piece in board.piece_map().items():\n            if piece.piece_type == chess.PAWN:\n                if piece.color == chess.WHITE and is_white_passed(sq):\n                    white_passed += 1\n                if piece.color == chess.BLACK and is_black_passed(sq):\n                    black_passed += 1\n        return [float(white_passed - black_passed)]\n    except Exception:\n        return [0.0]", "def feature(board: chess.Board) -> list[float]:\n    \"minor piece mobility difference: knights and bishops\"\n    try:\n        def mobility_for_color_mins(bd: chess.Board, color: bool) -> int:\n            bb = bd.copy()\n            bb.turn = color\n            cnt = 0\n            for mv in bb.legal_moves:\n                p = bb.piece_at(mv.from_square)\n                if p is not None and p.color == color and p.piece_type in (chess.KNIGHT, chess.BISHOP):\n                    cnt += 1\n            return cnt\n        w_min = mobility_for_color_mins(board, chess.WHITE)\n        b_min = mobility_for_color_mins(board, chess.BLACK)\n        return [float(w_min - b_min)]\n    except Exception:\n        return [0.0]", "def feature(board: chess.Board) -> list[float]:\n    \"major piece mobility difference: rooks and queens\"\n    try:\n        def mobility_for_color_maj(bd: chess.Board, color: bool) -> int:\n            bb = bd.copy()\n            bb.turn = color\n            cnt = 0\n            for mv in bb.legal_moves:\n                p = bb.piece_at(mv.from_square)\n                if p is not None and p.color == color and p.piece_type in (chess.ROOK, chess.QUEEN):\n                    cnt += 1\n            return cnt\n        w_maj = mobility_for_color_maj(board, chess.WHITE)\n        b_maj = mobility_for_color_maj(board, chess.BLACK)\n        return [float(w_maj - b_maj)]\n    except Exception:\n        return [0.0]", "def feature(board: chess.Board) -> list[float]:\n    \"doubled pawn difference: White doubled pawns minus Black doubled pawns\"\n    try:\n        def doubled_pawns(color: bool) -> int:\n            count = 0\n            for f in range(8):\n                cp = 0\n                for r in range(8):\n                    sq = chess.square(f, r)\n                    p = board.piece_at(sq)\n                    if p is not None and p.color == color and p.piece_type == chess.PAWN:\n                        cp += 1\n                if cp > 1:\n                    count += 1\n            return count\n        white_doubled = doubled_pawns(chess.WHITE)\n        black_doubled = doubled_pawns(chess.BLACK)\n        return [float(white_doubled - black_doubled)]\n    except Exception:\n        return [0.0]", "def feature(board: chess.Board) -> list[float]:\n    \"potential checks difference: White checks in one move minus Black checks in one move\"\n    try:\n        def potential_checks_for_color(bd: chess.Board, color: bool) -> int:\n            bb = bd.copy()\n            bb.turn = color\n            cnt = 0\n            for mv in bb.legal_moves:\n                bb2 = bb.copy()\n                bb2.push(mv)\n                if bb2.is_check():\n                    cnt += 1\n            return cnt\n        white_checks = potential_checks_for_color(board, chess.WHITE)\n        black_checks = potential_checks_for_color(board, chess.BLACK)\n        return [float(white_checks - black_checks)]\n    except Exception:\n        return [0.0]", "def feature(board: chess.Board) -> list[float]:\n    'material balance: white material minus black material'\n    white = 0\n    black = 0\n    for square, piece in board.piece_map().items():\n        # approximate piece values\n        if piece.piece_type == chess.PAWN:\n            val = 1\n        elif piece.piece_type in (chess.KNIGHT, chess.BISHOP):\n            val = 3\n        elif piece.piece_type == chess.ROOK:\n            val = 5\n        elif piece.piece_type == chess.QUEEN:\n            val = 9\n        else:\n            val = 0\n        if piece.color == chess.WHITE:\n            white += val\n        else:\n            black += val\n    return [float(white - black)]", "def feature(board: chess.Board) -> list[float]:\n    'mobility of side to move: number of legal moves'\n    moves = list(board.legal_moves)\n    return [float(len(moves))]", "def feature(board: chess.Board) -> list[float]:\n    'Mobility by color: difference in number of legal moves White vs Black (legal moves)'\n    def count_legal_for_color(bd: chess.Board, color: chess.Color) -> int:\n        b = bd.copy()\n        b.turn = color\n        return len(list(b.legal_moves))\n    white_legal = count_legal_for_color(board, chess.WHITE)\n    black_legal = count_legal_for_color(board, chess.BLACK)\n    return [float(white_legal - black_legal)]", "def feature(board: chess.Board) -> list[float]:\n    'Mobility by color: difference in number of pseudo-legal moves White vs Black'\n    def count_pseudo_for_color(bd: chess.Board, color: chess.Color) -> int:\n        b = bd.copy()\n        b.turn = color\n        return len(list(b.pseudo_legal_moves))\n    white_pseudo = count_pseudo_for_color(board, chess.WHITE)\n    black_pseudo = count_pseudo_for_color(board, chess.BLACK)\n    return [float(white_pseudo - black_pseudo)]", "def feature(board: chess.Board) -> list[float]:\n    'Passed pawn difference: White passed pawns minus Black passed pawns'\n    def is_white_passed_square(bd: chess.Board, sq: chess.Square) -> bool:\n        piece = bd.piece_at(sq)\n        if not piece or piece.piece_type != chess.PAWN or piece.color != chess.WHITE:\n            return False\n        f = chess.square_file(sq)\n        r = chess.square_rank(sq)\n        for df in (-1, 0, 1):\n            f2 = f + df\n            if 0 <= f2 < 8:\n                for r2 in range(r + 1, 8):\n                    s = chess.square(f2, r2)\n                    p = bd.piece_at(s)\n                    if p and p.piece_type == chess.PAWN and p.color == chess.BLACK:\n                        return False\n        return True\n\n    def is_black_passed_square(bd: chess.Board, sq: chess.Square) -> bool:\n        piece = bd.piece_at(sq)\n        if not piece or piece.piece_type != chess.PAWN or piece.color != chess.BLACK:\n            return False\n        f = chess.square_file(sq)\n        r = chess.square_rank(sq)\n        for df in (-1, 0, 1):\n            f2 = f + df\n            if 0 <= f2 < 8:\n                for r2 in range(0, r):\n                    s = chess.square(f2, r2)\n                    p = bd.piece_at(s)\n                    if p and p.piece_type == chess.PAWN and p.color == chess.WHITE:\n                        return False\n        return True\n\n    white_passed = 0\n    black_passed = 0\n    for sq, pc in board.piece_map().items():\n        if pc.piece_type == chess.PAWN:\n            if pc.color == chess.WHITE and is_white_passed_square(board, sq):\n                white_passed += 1\n            elif pc.color == chess.BLACK and is_black_passed_square(board, sq):\n                black_passed += 1\n    return [float(white_passed - black_passed)]", "def feature(board: chess.Board) -> list[float]:\n    'Piece centrality difference: weighted sum by proximity to center (white minus black)'\n    center_sqs = [chess.D4, chess.E4, chess.D5, chess.E5]\n\n    def piece_value(p: chess.Piece) -> int:\n        if p.piece_type == chess.PAWN:\n            return 1\n        if p.piece_type in (chess.KNIGHT, chess.BISHOP):\n            return 3\n        if p.piece_type == chess.ROOK:\n            return 5\n        if p.piece_type == chess.QUEEN:\n            return 9\n        return 0\n\n    white_sum = 0.0\n    black_sum = 0.0\n    for sq, pc in board.piece_map().items():\n        dist = min(chess.square_distance(sq, c) for c in center_sqs)\n        weight = 1.0 / (1.0 + dist)\n        val = piece_value(pc)\n        if pc.color == chess.WHITE:\n            white_sum += val * weight\n        else:\n            black_sum += val * weight\n    return [float(white_sum - black_sum)]", "def feature(board: chess.Board) -> list[float]:\n    'Heavy piece difference: rooks and queens disparity (White minus Black)'\n    white_heavy = 0\n    black_heavy = 0\n    for sq, pc in board.piece_map().items():\n        if pc.piece_type in (chess.ROOK, chess.QUEEN):\n            if pc.color == chess.WHITE:\n                white_heavy += 1\n            else:\n                black_heavy += 1\n    return [float(white_heavy - black_heavy)]", "def feature(board: chess.Board) -> list[float]:\n    'King safety: difference in number of attackers on white king vs black king'\n    wk = board.king(chess.WHITE)\n    bk = board.king(chess.BLACK)\n    wk_attackers = len(board.attackers(chess.BLACK, wk)) if wk is not None else 0\n    bk_attackers = len(board.attackers(chess.WHITE, bk)) if bk is not None else 0\n    return [float(wk_attackers - bk_attackers)]", "def feature(board: chess.Board) -> list[float]:\n    'Non-king piece count difference: total pieces except kings (White minus Black)'\n    white_count = 0\n    black_count = 0\n    for sq, pc in board.piece_map().items():\n        if pc.piece_type != chess.KING:\n            if pc.color == chess.WHITE:\n                white_count += 1\n            else:\n                black_count += 1\n    return [float(white_count - black_count)]", "def feature(board: chess.Board) -> list[float]:\n    'Center control difference: number of center squares attacked by White minus attacked by Black'\n    center_sqs = [chess.D4, chess.E4, chess.D5, chess.E5]\n    white_control = sum(1 for s in center_sqs if board.is_attacked_by(chess.WHITE, s))\n    black_control = sum(1 for s in center_sqs if board.is_attacked_by(chess.BLACK, s))\n    return [float(white_control - black_control)]", "def feature(board: chess.Board) -> list[float]:\n    'heavy_piece_diff: White rooks+queens minus Black rooks+queens'\n    white_rooks = len(board.pieces(chess.ROOK, chess.WHITE))\n    white_queens = len(board.pieces(chess.QUEEN, chess.WHITE))\n    black_rooks = len(board.pieces(chess.ROOK, chess.BLACK))\n    black_queens = len(board.pieces(chess.QUEEN, chess.BLACK))\n    return float((white_rooks + white_queens) - (black_rooks + black_queens))", "def feature(board: chess.Board) -> list[float]:\n    'centrality_heavies_diff: weighted centrality difference for rooks and queens'\n    center_sqs = [chess.D4, chess.E4, chess.D5, chess.E5]\n    def min_center_dist(sq):\n        return min(chess.square_distance(sq, c) for c in center_sqs)\n    white_sum = 0.0\n    for sq in board.pieces(chess.ROOK, chess.WHITE) | board.pieces(chess.QUEEN, chess.WHITE):\n        white_sum += 1.0 / (1.0 + min_center_dist(sq))\n    black_sum = 0.0\n    for sq in board.pieces(chess.ROOK, chess.BLACK) | board.pieces(chess.QUEEN, chess.BLACK):\n        black_sum += 1.0 / (1.0 + min_center_dist(sq))\n    return float(white_sum - black_sum)", "def feature(board: chess.Board) -> list[float]:\n    'king_centrality_diff: White king centrality minus Black king centrality'\n    center_sqs = [chess.D4, chess.E4, chess.D5, chess.E5]\n    def dist_to_center(ksq):\n        if ksq is None:\n            return 0.0\n        return min(chess.square_distance(ksq, c) for c in center_sqs)\n    wksq = board.king(chess.WHITE)\n    bksq = board.king(chess.BLACK)\n    w_cent = 1.0 / (1.0 + dist_to_center(wksq)) if wksq is not None else 0.0\n    b_cent = 1.0 / (1.0 + dist_to_center(bksq)) if bksq is not None else 0.0\n    return float(w_cent - b_cent)", "def feature(board: chess.Board) -> list[float]:\n    'mobility_color_diff: difference in legal moves for White vs Black pieces'\n    orig_turn = board.turn\n    try:\n        def moves_for_color(color):\n            board.turn = color\n            cnt = sum(1 for _ in board.legal_moves)\n            board.turn = orig_turn\n            return cnt\n        white_moves = moves_for_color(chess.WHITE)\n        black_moves = moves_for_color(chess.BLACK)\n    finally:\n        board.turn = orig_turn\n    return float(white_moves - black_moves)", "def feature(board: chess.Board) -> list[float]:\n    'side_to_move_in_check: 1.0 if side to move is in check, else 0.0'\n    return float(board.is_check())", "def feature(board: chess.Board) -> list[float]:\n    'passed_pawn_metric: combined passed pawn count and distance to promotion'\n    def is_white_passed(sq):\n        if sq is None:\n            return False\n        if board.piece_at(sq) is None or board.piece_at(sq).piece_type != chess.PAWN or board.piece_at(sq).color != chess.WHITE:\n            return False\n        f = chess.square_file(sq)\n        r = chess.square_rank(sq)\n        for nf in range(max(0, f - 1), min(7, f + 1) + 1):\n            for nr in range(r + 1, 8):\n                s = chess.square(nf, nr)\n                p = board.piece_at(s)\n                if p is not None and p.piece_type == chess.PAWN and p.color == chess.BLACK:\n                    return False\n        return True\n    def is_black_passed(sq):\n        if sq is None:\n            return False\n        if board.piece_at(sq) is None or board.piece_at(sq).piece_type != chess.PAWN or board.piece_at(sq).color != chess.BLACK:\n            return False\n        f = chess.square_file(sq)\n        r = chess.square_rank(sq)\n        for nf in range(max(0, f - 1), min(7, f + 1) + 1):\n            for nr in range(0, r):\n                s = chess.square(nf, nr)\n                p = board.piece_at(s)\n                if p is not None and p.piece_type == chess.PAWN and p.color == chess.WHITE:\n                    return False\n        return True\n    white_passed = []\n    black_passed = []\n    for sq, p in board.piece_map().items():\n        if p.piece_type == chess.PAWN:\n            if p.color == chess.WHITE and is_white_passed(sq):\n                white_passed.append(sq)\n            if p.color == chess.BLACK and is_black_passed(sq):\n                black_passed.append(sq)\n    def avg_promo_distance(passed_sqs, color_white):\n        if not passed_sqs:\n            return 0.0\n        dist_sum = 0\n        for s in passed_sqs:\n            r = chess.square_rank(s)\n            dist = (7 - r) if color_white else r\n            dist_sum += dist\n        return dist_sum / float(len(passed_sqs))\n    white_avg = avg_promo_distance(white_passed, True)\n    black_avg = avg_promo_distance(black_passed, False)\n    passed_diff = len(white_passed) - len(black_passed)\n    return float(passed_diff + 0.5 * (white_avg - black_avg))", "def feature(board: chess.Board) -> list[float]:\n    'queen_center_control_diff: center squares controlled by White queens minus Black queens'\n    center_sqs = [chess.D4, chess.E4, chess.D5, chess.E5]\n    white_q_control = 0\n    for sq in board.pieces(chess.QUEEN, chess.WHITE):\n        for c in center_sqs:\n            if board.is_attacked_by(chess.WHITE, c):\n                white_q_control += 1\n    black_q_control = 0\n    for sq in board.pieces(chess.QUEEN, chess.BLACK):\n        for c in center_sqs:\n            if board.is_attacked_by(chess.BLACK, c):\n                black_q_control += 1\n    return float(white_q_control - black_q_control)", "def feature(board: chess.Board) -> list[float]:\n    'king_distance_between_kings: distance between White and Black kings'\n    wksq = board.king(chess.WHITE)\n    bksq = board.king(chess.BLACK)\n    if wksq is None or bksq is None:\n        return float(0.0)\n    return float(chess.square_distance(wksq, bksq))", "def feature(board: chess.Board) -> list[float]:\n    'en_passant_available: 1.0 if en passant target square exists, else 0.0'\n    ep = getattr(board, 'ep_square', None)\n    return float(ep is not None)", "def feature(board: chess.Board) -> list[float]:\n    'king_attackers_diff: attackers to white king minus attackers to black king'\n    wksq = board.king(chess.WHITE)\n    bksq = board.king(chess.BLACK)\n    attackers_to_white = len(board.attackers(chess.BLACK, wksq)) if wksq is not None else 0\n    attackers_to_black = len(board.attackers(chess.WHITE, bksq)) if bksq is not None else 0\n    return float(attackers_to_white - attackers_to_black)", "def feature(board: chess.Board) -> list[float]:\n    \"material balance: white material minus black material\"\n    values = {chess.PAWN: 1, chess.KNIGHT: 3, chess.BISHOP: 3, chess.ROOK: 5, chess.QUEEN: 9, chess.KING: 0}\n    white = 0\n    black = 0\n    for sq, p in board.piece_map().items():\n        val = values.get(p.piece_type, 0)\n        if p.color == chess.WHITE:\n            white += val\n        else:\n            black += val\n    return [float(white - black)]", "def feature(board: chess.Board) -> list[float]:\n    \"mobility: number of legal moves for side to move\"\n    moves = 0\n    for _ in board.legal_moves:\n        moves += 1\n    return [float(moves)]", "def feature(board: chess.Board) -> list[float]:\n    \"passed pawn difference: white passed pawns minus black passed pawns\"\n    def is_white_passed(b, sq):\n        p = b.piece_at(sq)\n        if p is None or p.piece_type != chess.PAWN or p.color != chess.WHITE:\n            return False\n        f = chess.square_file(sq)\n        r = chess.square_rank(sq)\n        for file in (f - 1, f, f + 1):\n            if 0 <= file <= 7:\n                for rr in range(r + 1, 8):\n                    s = chess.square(file, rr)\n                    q = b.piece_at(s)\n                    if q is not None and q.piece_type == chess.PAWN and q.color == chess.BLACK:\n                        return False\n        return True\n    def is_black_passed(b, sq):\n        p = b.piece_at(sq)\n        if p is None or p.piece_type != chess.PAWN or p.color != chess.BLACK:\n            return False\n        f = chess.square_file(sq)\n        r = chess.square_rank(sq)\n        for file in (f - 1, f, f + 1):\n            if 0 <= file <= 7:\n                for rr in range(0, r):\n                    s = chess.square(file, rr)\n                    q = b.piece_at(s)\n                    if q is not None and q.piece_type == chess.PAWN and q.color == chess.WHITE:\n                        return False\n        return True\n    white_passed = 0\n    black_passed = 0\n    for sq, p in board.piece_map().items():\n        if p.piece_type == chess.PAWN:\n            if p.color == chess.WHITE and is_white_passed(board, sq):\n                white_passed += 1\n            elif p.color == chess.BLACK and is_black_passed(board, sq):\n                black_passed += 1\n    return [float(white_passed - black_passed)]", "def feature(board: chess.Board) -> list[float]:\n    \"piece centrality difference: weighted sum by proximity to center\"\n    center_sqs = [chess.parse_square('d4'), chess.parse_square('e4'), chess.parse_square('d5'), chess.parse_square('e5')]\n    def center_dist(sq):\n        return min(chess.square_distance(sq, c) for c in center_sqs)\n    white_sum = 0.0\n    black_sum = 0.0\n    for sq, p in board.piece_map().items():\n        dist = center_dist(sq)\n        weight = 1.0 / (1.0 + dist)\n        if p.color == chess.WHITE:\n            white_sum += weight\n        else:\n            black_sum += weight\n    return [float(white_sum - black_sum)]", "def feature(board: chess.Board) -> list[float]:\n    \"major piece mobility by color: rooks and queens\"\n    def count_major_moves_for_color(b, color):\n        b2 = b.copy()\n        b2.turn = color\n        cnt = 0\n        for mv in b2.legal_moves:\n            pc = b2.piece_at(mv.from_square)\n            if pc and pc.color == color and pc.piece_type in (chess.ROOK, chess.QUEEN):\n                cnt += 1\n        return cnt\n    white_major = count_major_moves_for_color(board, chess.WHITE)\n    black_major = count_major_moves_for_color(board, chess.BLACK)\n    return [float(white_major - black_major)]", "def feature(board: chess.Board) -> list[float]:\n    \"minor piece mobility by color: knights and bishops\"\n    def count_minor_moves_for_color(b, color):\n        b2 = b.copy()\n        b2.turn = color\n        cnt = 0\n        for mv in b2.legal_moves:\n            pc = b2.piece_at(mv.from_square)\n            if pc and pc.color == color and pc.piece_type in (chess.KNIGHT, chess.BISHOP):\n                cnt += 1\n        return cnt\n    white_minor = count_minor_moves_for_color(board, chess.WHITE)\n    black_minor = count_minor_moves_for_color(board, chess.BLACK)\n    return [float(white_minor - black_minor)]", "def feature(board: chess.Board) -> list[float]:\n    \"heavy piece count difference: rooks and queens\"\n    white_heavy = 0\n    black_heavy = 0\n    for sq, p in board.piece_map().items():\n        if p.piece_type in (chess.ROOK, chess.QUEEN):\n            if p.color == chess.WHITE:\n                white_heavy += 1\n            else:\n                black_heavy += 1\n    return [float(white_heavy - black_heavy)]", "def feature(board: chess.Board) -> list[float]:\n    \"king safety proxy: number of attackers on the king of side to move\"\n    king_sq = board.king(board.turn)\n    if king_sq is None:\n        return [0.0]\n    attackers = board.attackers(not board.turn, king_sq)\n    return [float(len(attackers))]", "def feature(board: chess.Board) -> list[float]:\n    \"center control difference: how many center squares are attacked by white minus attacked by black\"\n    center_sqs = [chess.parse_square('d4'), chess.parse_square('e4'), chess.parse_square('d5'), chess.parse_square('e5')]\n    white_control = 0\n    black_control = 0\n    for sq in center_sqs:\n        if board.is_attacked_by(chess.WHITE, sq):\n            white_control += 1\n        if board.is_attacked_by(chess.BLACK, sq):\n            black_control += 1\n    return [float(white_control - black_control)]", "def feature(board: chess.Board) -> list[float]:\n    \"doubled pawn pawn structure difference: white doubled minus black doubled\"\n    white_by_file = [0] * 8\n    black_by_file = [0] * 8\n    for sq, p in board.piece_map().items():\n        if p.piece_type == chess.PAWN:\n            f = chess.square_file(sq)\n            if p.color == chess.WHITE:\n                white_by_file[f] += 1\n            else:\n                black_by_file[f] += 1\n    white_doubled = sum(n - 1 for n in white_by_file if n > 1)\n    black_doubled = sum(n - 1 for n in black_by_file if n > 1)\n    return [float(white_doubled - black_doubled)]", "def feature(board: chess.Board) -> list[float]:\n    \"Material balance: white material minus black material\"\n    try:\n        values = {chess.PAWN: 1, chess.KNIGHT: 3, chess.BISHOP: 3, chess.ROOK: 5, chess.QUEEN: 9}\n        white = 0.0\n        black = 0.0\n        for sq, piece in board.piece_map().items():\n            v = values.get(piece.piece_type, 0)\n            if piece.color == chess.WHITE:\n                white += v\n            else:\n                black += v\n        return [white - black]\n    except Exception:\n        return [0.0]", "def feature(board: chess.Board) -> list[float]:\n    \"Mobility: difference in number of legal moves with White to move vs Black to move\"\n    try:\n        wb = board.copy()\n        wb.turn = chess.WHITE\n        mw = len(list(wb.legal_moves))\n        bb = board.copy()\n        bb.turn = chess.BLACK\n        mb = len(list(bb.legal_moves))\n        return [float(mw - mb)]\n    except Exception:\n        return [0.0]", "def feature(board: chess.Board) -> list[float]:\n    \"Mobility by color: difference in number of legal moves originating from White vs Black pieces\"\n    try:\n        def moves_by_color(b: chess.Board, color: chess.Color) -> int:\n            b2 = b.copy()\n            b2.turn = color\n            return len(list(b2.legal_moves))\n        white_moves = moves_by_color(board, chess.WHITE)\n        black_moves = moves_by_color(board, chess.BLACK)\n        return [float(white_moves - black_moves)]\n    except Exception:\n        return [0.0]", "def feature(board: chess.Board) -> list[float]:\n    \"Piece centrality difference: weighted sum by proximity to center\"\n    try:\n        center_sqs = [chess.E4, chess.D4, chess.E5, chess.D5]\n        def piece_value(pt: int) -> int:\n            if pt == chess.PAWN:\n                return 1\n            if pt in (chess.KNIGHT, chess.BISHOP):\n                return 3\n            if pt in (chess.ROOK,):\n                return 5\n            if pt == chess.QUEEN:\n                return 9\n            return 0\n        white_sum = 0.0\n        black_sum = 0.0\n        for sq, piece in board.piece_map().items():\n            if piece.piece_type == chess.KING:\n                continue\n            dist = min(chess.square_distance(sq, c) for c in center_sqs)\n            centrality = 1.0 / (1.0 + dist)\n            v = piece_value(piece.piece_type) * centrality\n            if piece.color == chess.WHITE:\n                white_sum += v\n            else:\n                black_sum += v\n        return [float(white_sum - black_sum)]\n    except Exception:\n        return [0.0]", "def feature(board: chess.Board) -> list[float]:\n    \"Passed pawn difference: White passed pawns minus Black passed pawns\"\n    try:\n        def is_passed_white(bp: chess.Board, sq: int) -> bool:\n            f = chess.square_file(sq)\n            r = chess.square_rank(sq)\n            for file_off in (-1, 0, 1):\n                f2 = f + file_off\n                if f2 < 0 or f2 > 7:\n                    continue\n                for rank in range(r + 1, 8):\n                    s = chess.square(f2, rank)\n                    p = bp.piece_at(s)\n                    if p and p.piece_type == chess.PAWN and p.color == chess.BLACK:\n                        return False\n            return True\n\n        def is_passed_black(bp: chess.Board, sq: int) -> bool:\n            f = chess.square_file(sq)\n            r = chess.square_rank(sq)\n            for file_off in (-1, 0, 1):\n                f2 = f + file_off\n                if f2 < 0 or f2 > 7:\n                    continue\n                for rank in range(0, r):\n                    s = chess.square(f2, rank)\n                    p = bp.piece_at(s)\n                    if p and p.piece_type == chess.PAWN and p.color == chess.WHITE:\n                        return False\n            return True\n\n        white_passed = 0\n        black_passed = 0\n        for sq, piece in board.piece_map().items():\n            if piece.piece_type == chess.PAWN:\n                if piece.color == chess.WHITE and is_passed_white(board, sq):\n                    white_passed += 1\n                elif piece.color == chess.BLACK and is_passed_black(board, sq):\n                    black_passed += 1\n        return [float(white_passed - black_passed)]\n    except Exception:\n        return [0.0]", "def feature(board: chess.Board) -> list[float]:\n    \"Heavy piece difference: rooks and queens (White minus Black)\"\n    try:\n        white_heavy = 0\n        black_heavy = 0\n        for sq, piece in board.piece_map().items():\n            if piece.piece_type in (chess.ROOK, chess.QUEEN):\n                if piece.color == chess.WHITE:\n                    white_heavy += 1\n                else:\n                    black_heavy += 1\n        return [float(white_heavy - black_heavy)]\n    except Exception:\n        return [0.0]", "def feature(board: chess.Board) -> list[float]:\n    \"King centrality difference: White king centrality minus Black king centrality\"\n    try:\n        center_sqs = [chess.E4, chess.D4, chess.E5, chess.D5]\n        def king_centrality(color: chess.Color) -> float:\n            for sq, piece in board.piece_map().items():\n                if piece.piece_type == chess.KING and piece.color == color:\n                    dist = min(chess.square_distance(sq, c) for c in center_sqs)\n                    return 1.0 / (1.0 + dist)\n            return 0.0\n        white_cent = king_centrality(chess.WHITE)\n        black_cent = king_centrality(chess.BLACK)\n        return [float(white_cent - black_cent)]\n    except Exception:\n        return [0.0]", "def feature(board: chess.Board) -> list[float]:\n    \"Pawn structure: difference in doubled pawns between White and Black\"\n    try:\n        def doubled_pawns(color: chess.Color) -> int:\n            counts = [0]*8\n            for sq, piece in board.piece_map().items():\n                if piece.color == color and piece.piece_type == chess.PAWN:\n                    f = chess.square_file(sq)\n                    counts[f] += 1\n            doubles = sum(max(0, c-1) for c in counts)\n            return doubles\n        white_doubles = doubled_pawns(chess.WHITE)\n        black_doubles = doubled_pawns(chess.BLACK)\n        return [float(white_doubles - black_doubles)]\n    except Exception:\n        return [0.0]", "def feature(board: chess.Board) -> list[float]:\n    \"Minor piece balance: bishops plus knights difference (White minus Black)\"\n    try:\n        white_minor = 0\n        black_minor = 0\n        for sq, piece in board.piece_map().items():\n            if piece.piece_type in (chess.KNIGHT, chess.BISHOP):\n                if piece.color == chess.WHITE:\n                    white_minor += 1\n                else:\n                    black_minor += 1\n        return [float(white_minor - black_minor)]\n    except Exception:\n        return [0.0]", "def feature(board: chess.Board) -> list[float]:\n    \"Heavy-piece density difference: ratio of rooks+queens to total pieces per color (White - Black)\"\n    try:\n        def heavy_density(color: chess.Color) -> float:\n            total = 0\n            heavy = 0\n            for sq, piece in board.piece_map().items():\n                if piece.color == color:\n                    total += 1\n                    if piece.piece_type in (chess.ROOK, chess.QUEEN):\n                        heavy += 1\n            if total == 0:\n                return 0.0\n            return heavy / total\n        white_density = heavy_density(chess.WHITE)\n        black_density = heavy_density(chess.BLACK)\n        return [float(white_density - black_density)]\n    except Exception:\n        return [0.0]", "def feature(board: chess.Board) -> list[float]:\n    \"Material balance: white material minus black material\"\n    value = 0.0\n    piece_values = {\n        chess.PAWN: 1,\n        chess.KNIGHT: 3,\n        chess.BISHOP: 3,\n        chess.ROOK: 5,\n        chess.QUEEN: 9,\n        chess.KING: 0\n    }\n    for sq, piece in board.piece_map().items():\n        val = piece_values.get(piece.piece_type, 0)\n        if piece.color == chess.WHITE:\n            value += val\n        else:\n            value -= val\n    return float(value)", "def feature(board: chess.Board) -> list[float]:\n    \"Major piece difference: white rooks and queens minus black\"\n    value = 0.0\n    for sq, piece in board.piece_map().items():\n        if piece.piece_type in (chess.ROOK, chess.QUEEN):\n            val = 5 if piece.piece_type == chess.ROOK else 9\n            if piece.color == chess.WHITE:\n                value += val\n            else:\n                value -= val\n    return float(value)", "def feature(board: chess.Board) -> list[float]:\n    \"Minor piece difference: white knights and bishops minus black\"\n    value = 0.0\n    for sq, piece in board.piece_map().items():\n        if piece.piece_type in (chess.KNIGHT, chess.BISHOP):\n            val = 3\n            if piece.color == chess.WHITE:\n                value += val\n            else:\n                value -= val\n    return float(value)", "def feature(board: chess.Board) -> list[float]:\n    \"Passed pawn difference: white passed pawns minus black passed pawns\"\n    def is_passed_white(b, square, color):\n        f = chess.square_file(square)\n        r = chess.square_rank(square)\n        for df in (-1, 0, 1):\n            ff = f + df\n            if ff < 0 or ff > 7:\n                continue\n            for rr in range(r + 1, 8):\n                sq2 = chess.square(ff, rr)\n                p = b.piece_at(sq2)\n                if p is not None and p.color == chess.BLACK and p.piece_type == chess.PAWN:\n                    return False\n        return True\n\n    def is_passed_black(b, square):\n        f = chess.square_file(square)\n        r = chess.square_rank(square)\n        for df in (-1, 0, 1):\n            ff = f + df\n            if ff < 0 or ff > 7:\n                continue\n            for rr in range(0, r):\n                sq2 = chess.square(ff, rr)\n                p = b.piece_at(sq2)\n                if p is not None and p.color == chess.WHITE and p.piece_type == chess.PAWN:\n                    return False\n        return True\n\n    white_passed = 0\n    black_passed = 0\n    for sq, piece in board.piece_map().items():\n        if piece.piece_type != chess.PAWN:\n            continue\n        if piece.color == chess.WHITE:\n            if is_passed_white(board, sq, piece.color):\n                white_passed += 1\n        else:\n            if is_passed_black(board, sq):\n                black_passed += 1\n    return float(white_passed - black_passed)", "def feature(board: chess.Board) -> list[float]:\n    \"Doubled pawn difference: white doubled pawns minus black doubled pawns\"\n    white_pawn_counts = [0] * 8\n    black_pawn_counts = [0] * 8\n    for sq, piece in board.piece_map().items():\n        if piece.piece_type != chess.PAWN:\n            continue\n        f = chess.square_file(sq)\n        if piece.color == chess.WHITE:\n            white_pawn_counts[f] += 1\n        else:\n            black_pawn_counts[f] += 1\n    white_doubled = sum(max(0, cnt - 1) for cnt in white_pawn_counts)\n    black_doubled = sum(max(0, cnt - 1) for cnt in black_pawn_counts)\n    return float(white_doubled - black_doubled)", "def feature(board: chess.Board) -> list[float]:\n    \"Rook on open files difference: white rooks on open files minus black rooks on open files\"\n    pawn_on_file = [False] * 8\n    rooks_on_open = {chess.WHITE: 0, chess.BLACK: 0}\n    for sq, piece in board.piece_map().items():\n        if piece.piece_type == chess.PAWN:\n            pawn_on_file[chess.square_file(sq)] = True\n    open_files = [f for f in range(8) if not pawn_on_file[f]]\n    for sq, piece in board.piece_map().items():\n        if piece.piece_type == chess.ROOK and chess.square_file(sq) in open_files:\n            if piece.color == chess.WHITE:\n                rooks_on_open[chess.WHITE] += 1\n            else:\n                rooks_on_open[chess.BLACK] += 1\n    return float(rooks_on_open[chess.WHITE] - rooks_on_open[chess.BLACK])", "def feature(board: chess.Board) -> list[float]:\n    \"Piece centrality difference: weighted sum by proximity to center (d4,e4,d5,e5)\"\n    central = [chess.D4, chess.E4, chess.D5, chess.E5]\n    piece_values = {\n        chess.PAWN: 1,\n        chess.KNIGHT: 3,\n        chess.BISHOP: 3,\n        chess.ROOK: 5,\n        chess.QUEEN: 9,\n        chess.KING: 0\n    }\n    white_sum = 0\n    black_sum = 0\n    for sq in central:\n        p = board.piece_at(sq)\n        if p is None:\n            continue\n        val = piece_values.get(p.piece_type, 0)\n        if p.color == chess.WHITE:\n            white_sum += val\n        else:\n            black_sum += val\n    return float(white_sum - black_sum)", "def feature(board: chess.Board) -> list[float]:\n    \"Center piece count difference: number of pieces on central squares white minus black\"\n    central = [chess.D4, chess.E4, chess.D5, chess.E5]\n    white_count = 0\n    black_count = 0\n    for sq in central:\n        p = board.piece_at(sq)\n        if p is None:\n            continue\n        if p.color == chess.WHITE:\n            white_count += 1\n        else:\n            black_count += 1\n    return float(white_count - black_count)", "def feature(board: chess.Board) -> list[float]:\n    \"King safety difference: attackers on white king minus attackers on black king\"\n    wk = board.king(chess.WHITE)\n    bk = board.king(chess.BLACK)\n    attackers_on_wk = len(board.attackers(chess.BLACK, wk)) if wk is not None else 0\n    attackers_on_bk = len(board.attackers(chess.WHITE, bk)) if bk is not None else 0\n    return float(attackers_on_wk - attackers_on_bk)", "def feature(board: chess.Board) -> list[float]:\n    \"Mobility difference: number of legal moves for White minus number of legal moves for Black\"\n    white_moves = 0\n    black_moves = 0\n    # mobility for White\n    b_white = board.copy()\n    b_white.turn = True\n    for _ in b_white.legal_moves:\n        white_moves += 1\n    # mobility for Black\n    b_black = board.copy()\n    b_black.turn = False\n    for _ in b_black.legal_moves:\n        black_moves += 1\n    return float(white_moves - black_moves)", "def feature(board: chess.Board) -> list[float]:\n    'Material balance: white minus black using standard piece values'\n    import chess\n    VALUE = {\n        chess.PAWN: 1.0,\n        chess.KNIGHT: 3.0,\n        chess.BISHOP: 3.0,\n        chess.ROOK: 5.0,\n        chess.QUEEN: 9.0,\n        chess.KING: 0.0\n    }\n    val = 0.0\n    for sq, piece in board.piece_map().items():\n        v = VALUE.get(piece.piece_type, 0.0)\n        val += v if piece.color == chess.WHITE else -v\n    return float(val)", "def feature(board: chess.Board) -> list[float]:\n    'Major piece mobility difference: White vs Black (rooks and queens)'\n    import chess\n    b_white = board.copy()\n    b_white.turn = chess.WHITE\n    maj_white = 0\n    for mv in b_white.legal_moves:\n        p = b_white.piece_at(mv.from_square)\n        if p and p.piece_type in (chess.ROOK, chess.QUEEN):\n            maj_white += 1\n\n    b_black = board.copy()\n    b_black.turn = chess.BLACK\n    maj_black = 0\n    for mv in b_black.legal_moves:\n        p = b_black.piece_at(mv.from_square)\n        if p and p.piece_type in (chess.ROOK, chess.QUEEN):\n            maj_black += 1\n\n    return float(maj_white - maj_black)", "def feature(board: chess.Board) -> list[float]:\n    'Passed pawn difference: White passed pawns minus Black passed pawns'\n    import chess\n    white_pawns = [sq for sq, p in board.piece_map().items() if p.color == chess.WHITE and p.piece_type == chess.PAWN]\n    black_pawns = [sq for sq, p in board.piece_map().items() if p.color == chess.BLACK and p.piece_type == chess.PAWN]\n\n    def is_passed(sq, color):\n        f = chess.square_file(sq)\n        r = chess.square_rank(sq)\n        if color == chess.WHITE:\n            for rr in range(r + 1, 8):\n                for ff in (f - 1, f, f + 1):\n                    if 0 <= ff < 8:\n                        s = chess.square(ff, rr)\n                        p = board.piece_at(s)\n                        if p and p.color == chess.BLACK and p.piece_type == chess.PAWN:\n                            return False\n            return True\n        else:\n            for rr in range(r - 1, -1, -1):\n                for ff in (f - 1, f, f + 1):\n                    if 0 <= ff < 8:\n                        s = chess.square(ff, rr)\n                        p = board.piece_at(s)\n                        if p and p.color == chess.WHITE and p.piece_type == chess.PAWN:\n                            return False\n            return True\n\n    white_passed = sum(1 for sq in white_pawns if is_passed(sq, chess.WHITE))\n    black_passed = sum(1 for sq in black_pawns if is_passed(sq, chess.BLACK))\n\n    return float(white_passed - black_passed)", "def feature(board: chess.Board) -> list[float]:\n    'Minor piece balance: white vs black knights and bishops'\n    import chess\n    white_minors = 0\n    black_minors = 0\n    for sq, p in board.piece_map().items():\n        if p.piece_type in (chess.KNIGHT, chess.BISHOP):\n            if p.color == chess.WHITE:\n                white_minors += 1\n            else:\n                black_minors += 1\n    return float(white_minors - black_minors)", "def feature(board: chess.Board) -> list[float]:\n    'King safety pressure: difference in enemy pressure on squares around kings'\n    import chess\n    def neighbor_squares(sq):\n        f = chess.square_file(sq)\n        r = chess.square_rank(sq)\n        neigh = []\n        for df in (-1, 0, 1):\n            for dr in (-1, 0, 1):\n                if df == 0 and dr == 0:\n                    continue\n                nf, nr = f + df, r + dr\n                if 0 <= nf < 8 and 0 <= nr < 8:\n                    neigh.append(chess.square(nf, nr))\n        return neigh\n\n    white_king = board.king(chess.WHITE)\n    black_king = board.king(chess.BLACK)\n    white_pressure = 0\n    black_pressure = 0\n    if white_king is not None:\n        for nsq in neighbor_squares(white_king):\n            if board.is_attacked_by(chess.BLACK, nsq):\n                white_pressure += 1\n    if black_king is not None:\n        for nsq in neighbor_squares(black_king):\n            if board.is_attacked_by(chess.WHITE, nsq):\n                black_pressure += 1\n    return float(white_pressure - black_pressure)", "def feature(board: chess.Board) -> list[float]:\n    'Doubled pawns difference: White doubled pawns minus Black doubled pawns'\n    import chess\n    def count_doubled(color):\n        doubled = 0\n        for file in range(8):\n            count = 0\n            for rank in range(8):\n                sq = chess.square(file, rank)\n                p = board.piece_at(sq)\n                if p and p.color == color and p.piece_type == chess.PAWN:\n                    count += 1\n            if count > 1:\n                doubled += (count - 1)\n        return doubled\n    white_doubled = count_doubled(chess.WHITE)\n    black_doubled = count_doubled(chess.BLACK)\n    return float(white_doubled - black_doubled)", "def feature(board: chess.Board) -> list[float]:\n    'Center control: number of center squares attacked by white minus attacked by black'\n    import chess\n    center_sqs = [chess.D4, chess.E4, chess.D5, chess.E5]\n    white_controls = sum(1 for s in center_sqs if board.is_attacked_by(chess.WHITE, s))\n    black_controls = sum(1 for s in center_sqs if board.is_attacked_by(chess.BLACK, s))\n    return float(white_controls - black_controls)", "def feature(board: chess.Board) -> list[float]:\n    'Material balance: simple material count White minus Black'\n    white = 0.0\n    black = 0.0\n    values = {\n        chess.PAWN: 1.0,\n        chess.KNIGHT: 3.0,\n        chess.BISHOP: 3.0,\n        chess.ROOK: 5.0,\n        chess.QUEEN: 9.0,\n        chess.KING: 0.0\n    }\n    for sq, piece in board.piece_map().items():\n        val = values.get(piece.piece_type, 0.0)\n        if piece.color == chess.WHITE:\n            white += val\n        else:\n            black += val\n    return float(white - black)", "def feature(board: chess.Board) -> list[float]:\n    'Mobility: number of legal moves for side to move'\n    return float(sum(1 for _ in board.legal_moves))", "def feature(board: chess.Board) -> list[float]:\n    'Mobility by color: difference in legal moves White vs Black (ignoring side to move)'\n    def count_for_color(bd: chess.Board, color: int) -> int:\n        bb = bd.copy()\n        bb.turn = color\n        return sum(1 for _ in bb.legal_moves)\n    white_moves = count_for_color(board, chess.WHITE)\n    black_moves = count_for_color(board, chess.BLACK)\n    return float(white_moves - black_moves)", "def feature(board: chess.Board) -> list[float]:\n    'Passed pawn difference: White passed pawns minus Black passed pawns'\n    def is_passed_pawn(bd: chess.Board, sq: int, color: int) -> bool:\n        file = chess.square_file(sq)\n        rank = chess.square_rank(sq)\n        enemy = chess.BLACK if color == chess.WHITE else chess.WHITE\n        files = [file - 1, file, file + 1]\n        for f in files:\n            if f < 0 or f > 7:\n                continue\n            if color == chess.WHITE:\n                for r in range(rank + 1, 8):\n                    s = chess.square(f, r)\n                    p = bd.piece_at(s)\n                    if p and p.piece_type == chess.PAWN and p.color == enemy:\n                        return False\n            else:\n                for r in range(rank - 1, -1, -1):\n                    s = chess.square(f, r)\n                    p = bd.piece_at(s)\n                    if p and p.piece_type == chess.PAWN and p.color == enemy:\n                        return False\n        return True\n\n    white_passed = 0\n    black_passed = 0\n    for sq in board.pieces(chess.PAWN, chess.WHITE):\n        if is_passed_pawn(board, sq, chess.WHITE):\n            white_passed += 1\n    for sq in board.pieces(chess.PAWN, chess.BLACK):\n        if is_passed_pawn(board, sq, chess.BLACK):\n            black_passed += 1\n    return float(white_passed - black_passed)", "def feature(board: chess.Board) -> list[float]:\n    'King safety pressure: difference in enemy pressure on squares around kings'\n    def neighbor_squares(king_sq: int):\n        fx = chess.square_file(king_sq)\n        ry = chess.square_rank(king_sq)\n        neigh = []\n        for df in (-1, 0, 1):\n            for dr in (-1, 0, 1):\n                if df == 0 and dr == 0:\n                    continue\n                f = fx + df\n                r = ry + dr\n                if 0 <= f <= 7 and 0 <= r <= 7:\n                    neigh.append(chess.square(f, r))\n        return neigh\n\n    w_king = board.king(chess.WHITE)\n    b_king = board.king(chess.BLACK)\n    white_pressure = 0\n    black_pressure = 0\n    if w_king is not None:\n        for s in neighbor_squares(w_king):\n            if board.is_attacked_by(chess.BLACK, s):\n                white_pressure += 1\n    if b_king is not None:\n        for s in neighbor_squares(b_king):\n            if board.is_attacked_by(chess.WHITE, s):\n                black_pressure += 1\n    return float(white_pressure - black_pressure)", "def feature(board: chess.Board) -> list[float]:\n    'Piece centrality difference: weighted sum by proximity to center'\n    center_sqs = [chess.D4, chess.E4, chess.D5, chess.E5]\n    white_score = 0.0\n    black_score = 0.0\n    for sq, piece in board.piece_map().items():\n        file = chess.square_file(sq)\n        rank = chess.square_rank(sq)\n        dist = min(chess.square_distance(sq, c) for c in center_sqs)\n        proximity = 1.0 / (1.0 + dist)\n        value = 0.0\n        if piece.piece_type == chess.PAWN:\n            value = 1.0\n        elif piece.piece_type == chess.KNIGHT:\n            value = 3.0\n        elif piece.piece_type == chess.BISHOP:\n            value = 3.0\n        elif piece.piece_type == chess.ROOK:\n            value = 5.0\n        elif piece.piece_type == chess.QUEEN:\n            value = 9.0\n        else:\n            value = 0.0\n        if piece.color == chess.WHITE:\n            white_score += value * proximity\n        else:\n            black_score += value * proximity\n    return float(white_score - black_score)", "def feature(board: chess.Board) -> list[float]:\n    'Major piece mobility difference: rooks and queens moves White minus Black'\n    def count_major_moves(bd: chess.Board, color: int) -> int:\n        bb = bd.copy()\n        bb.turn = color\n        count = 0\n        for mv in bb.legal_moves:\n            p = bb.piece_at(mv.from_square)\n            if p and p.color == color and p.piece_type in (chess.ROOK, chess.QUEEN):\n                count += 1\n        return count\n\n    white_major = count_major_moves(board, chess.WHITE)\n    black_major = count_major_moves(board, chess.BLACK)\n    return float(white_major - black_major)", "def feature(board: chess.Board) -> list[float]:\n    'Central control pressure difference: White vs Black on center squares'\n    center_sqs = [chess.D4, chess.E4, chess.D5, chess.E5]\n    white_control = sum(1 for sq in center_sqs if board.is_attacked_by(chess.WHITE, sq))\n    black_control = sum(1 for sq in center_sqs if board.is_attacked_by(chess.BLACK, sq))\n    return float(white_control - black_control)", "def feature(board: chess.Board) -> list[float]:\n    'Minor piece mobility difference: knights and bishops moves White minus Black'\n    def count_minor_moves(bd: chess.Board, color: int) -> int:\n        bd2 = bd.copy()\n        bd2.turn = color\n        c = 0\n        for mv in bd2.legal_moves:\n            p = bd2.piece_at(mv.from_square)\n            if p and p.color == color and p.piece_type in (chess.KNIGHT, chess.BISHOP):\n                c += 1\n        return c\n\n    white_minor = count_minor_moves(board, chess.WHITE)\n    black_minor = count_minor_moves(board, chess.BLACK)\n    return float(white_minor - black_minor)", "def feature(board: chess.Board) -> list[float]:\n    'Open-file rooks difference: number of rooks on open files White minus Black'\n    def is_open_file(bd: chess.Board, f: int) -> bool:\n        for r in range(8):\n            sq = chess.square(f, r)\n            p = bd.piece_at(sq)\n            if p and p.piece_type == chess.PAWN:\n                return False\n        return True\n\n    white_rooks_on_open = 0\n    black_rooks_on_open = 0\n    for sq in board.pieces(chess.ROOK, chess.WHITE):\n        if is_open_file(board, chess.square_file(sq)):\n            white_rooks_on_open += 1\n    for sq in board.pieces(chess.ROOK, chess.BLACK):\n        if is_open_file(board, chess.square_file(sq)):\n            black_rooks_on_open += 1\n    return float(white_rooks_on_open - black_rooks_on_open)", "def feature(board: chess.Board) -> list[float]:\n    'Queen safety difference: sum of attackers on White vs Black queens'\n    white_safety = 0\n    black_safety = 0\n    for sq in board.pieces(chess.QUEEN, chess.WHITE):\n        white_safety += len(board.attackers(chess.BLACK, sq))\n    for sq in board.pieces(chess.QUEEN, chess.BLACK):\n        black_safety += len(board.attackers(chess.WHITE, sq))\n    return float(white_safety - black_safety)", "def feature(board: chess.Board) -> list[float]:\n    'Minor mobility difference specifically for knights and bishops (alternative metric)'\n    def count_minor_moves_alt(bd: chess.Board, color: int) -> int:\n        b = bd.copy()\n        b.turn = color\n        c = 0\n        for mv in b.legal_moves:\n            p = b.piece_at(mv.from_square)\n            if p and p.color == color and p.piece_type in (chess.KNIGHT, chess.BISHOP):\n                c += 1\n        return c\n    white_minor = count_minor_moves_alt(board, chess.WHITE)\n    black_minor = count_minor_moves_alt(board, chess.BLACK)\n    return float(white_minor - black_minor)", "def feature(board: chess.Board) -> list[float]:\n    'Advanced pawn presence: White advanced pawns minus Black advanced pawns'\n    white_adv = 0\n    black_adv = 0\n    for sq in board.pieces(chess.PAWN, chess.WHITE):\n        rank = chess.square_rank(sq)\n        if rank >= 5:  # sixth rank or higher\n            white_adv += 1\n    for sq in board.pieces(chess.PAWN, chess.BLACK):\n        rank = chess.square_rank(sq)\n        if rank <= 2:  # third rank or lower\n            black_adv += 1\n    return float(white_adv - black_adv)", "def feature(board: chess.Board) -> list[float]:\n    \"Material balance: white material minus black material\"\n    values = {\n        chess.PAWN: 1.0,\n        chess.KNIGHT: 3.0,\n        chess.BISHOP: 3.0,\n        chess.ROOK: 5.0,\n        chess.QUEEN: 9.0,\n        chess.KING: 0.0,\n    }\n    white = 0.0\n    black = 0.0\n    for square, piece in board.piece_map().items():\n        v = values.get(piece.piece_type, 0.0)\n        if piece.color == chess.WHITE:\n            white += v\n        else:\n            black += v\n    return white - black", "def feature(board: chess.Board) -> list[float]:\n    \"Mobility: number of legal moves for side to move\"\n    return float(len(list(board.legal_moves)))", "def feature(board: chess.Board) -> list[float]:\n    \"Mobility difference by color if to move (White vs Black)\"\n    wb = board.copy()\n    wb.turn = chess.WHITE\n    bb = board.copy()\n    bb.turn = chess.BLACK\n    w_moves = len(list(wb.legal_moves))\n    b_moves = len(list(bb.legal_moves))\n    return float(w_moves - b_moves)", "def feature(board: chess.Board) -> list[float]:\n    \"Piece centrality difference: white minus black, weighted by proximity to center\"\n    center_squares = [chess.D4, chess.D5, chess.E4, chess.E5]\n    white_score = 0.0\n    black_score = 0.0\n    for square, piece in board.piece_map().items():\n        dist = min(chess.square_distance(square, c) for c in center_squares)\n        weight = 1.0 / (dist + 1.0)\n        if piece.color == chess.WHITE:\n            white_score += weight\n        else:\n            black_score += weight\n    return white_score - black_score", "def feature(board: chess.Board) -> list[float]:\n    \"Passed pawn difference: White passed pawns minus Black passed pawns\"\n    def is_passed(b, sq, color):\n        file = chess.square_file(sq)\n        rank = chess.square_rank(sq)\n        if color == chess.WHITE:\n            for r in range(rank + 1, 8):\n                for f in (file - 1, file, file + 1):\n                    if 0 <= f <= 7:\n                        sq2 = chess.square(f, r)\n                        p = b.piece_at(sq2)\n                        if p is not None and p.piece_type == chess.PAWN and p.color == chess.BLACK:\n                            return False\n            return True\n        else:\n            for r in range(rank - 1, -1, -1):\n                for f in (file - 1, file, file + 1):\n                    if 0 <= f <= 7:\n                        sq2 = chess.square(f, r)\n                        p = b.piece_at(sq2)\n                        if p is not None and p.piece_type == chess.PAWN and p.color == chess.WHITE:\n                            return False\n            return True\n\n    white_passed = 0\n    black_passed = 0\n    for sq, piece in board.piece_map().items():\n        if piece.piece_type == chess.PAWN:\n            if piece.color == chess.WHITE and is_passed(board, sq, chess.WHITE):\n                white_passed += 1\n            elif piece.color == chess.BLACK and is_passed(board, sq, chess.BLACK):\n                black_passed += 1\n    return float(white_passed - black_passed)", "def feature(board: chess.Board) -> list[float]:\n    \"Heavy piece difference: rooks and queens (White minus Black)\"\n    white_heavy = 0\n    black_heavy = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == chess.WHITE and piece.piece_type in (chess.ROOK, chess.QUEEN):\n            white_heavy += 1\n        elif piece.color == chess.BLACK and piece.piece_type in (chess.ROOK, chess.QUEEN):\n            black_heavy += 1\n    return float(white_heavy - black_heavy)", "def feature(board: chess.Board) -> list[float]:\n    \"Center attack pressure difference: White attacks on center minus Black attacks on center\"\n    center_squares = [chess.D4, chess.D5, chess.E4, chess.E5]\n    turn = board.turn\n    attackers_to_center = {\n        chess.WHITE: 0,\n        chess.BLACK: 0,\n    }\n    for s in center_squares:\n        if board.is_attacked_by(chess.WHITE, s):\n            attackers_to_center[chess.WHITE] += 1\n        if board.is_attacked_by(chess.BLACK, s):\n            attackers_to_center[chess.BLACK] += 1\n    return float(attackers_to_center[chess.WHITE] - attackers_to_center[chess.BLACK])", "def feature(board: chess.Board) -> list[float]:\n    \"King distance feature: reciprocal of distance between kings\"\n    wk = board.king(chess.WHITE)\n    bk = board.king(chess.BLACK)\n    if wk is None or bk is None:\n        return 0.0\n    dist = chess.square_distance(wk, bk)\n    return float(1.0 / (dist + 1.0))", "def feature(board: chess.Board) -> list[float]:\n    \"Doubled pawns difference: White doubled pawns minus Black doubled pawns\"\n    def doubled_for_color(b, color):\n        counts = [0] * 8\n        for sq, piece in b.piece_map().items():\n            if piece.color == color and piece.piece_type == chess.PAWN:\n                counts[chess.square_file(sq)] += 1\n        doubled = sum((c - 1) for c in counts if c > 1)\n        return doubled\n\n    white_doubled = doubled_for_color(board, chess.WHITE)\n    black_doubled = doubled_for_color(board, chess.BLACK)\n    return float(white_doubled - black_doubled)", "def feature(board: chess.Board) -> list[float]:\n    \"Attack pressure difference: White pressure on own pieces minus Black pressure on own pieces\"\n    white_pressure = 0\n    black_pressure = 0\n    for sq, piece in board.piece_map().items():\n        enemy = chess.BLACK if piece.color == chess.WHITE else chess.WHITE\n        attackers = board.attackers(enemy, sq)\n        count = len(attackers)\n        if piece.color == chess.WHITE:\n            white_pressure += count\n        else:\n            black_pressure += count\n    return float(white_pressure - black_pressure)", "def feature(board: chess.Board) -> list[float]:\n    \"Material balance: white material minus black material\"\n    piece_values = {\n        chess.PAWN: 1.0,\n        chess.KNIGHT: 3.0,\n        chess.BISHOP: 3.0,\n        chess.ROOK: 5.0,\n        chess.QUEEN: 9.0,\n        chess.KING: 0.0\n    }\n    white = 0.0\n    black = 0.0\n    for sq, p in board.piece_map().items():\n        val = piece_values.get(p.piece_type, 0.0)\n        if p.color == chess.WHITE:\n            white += val\n        else:\n            black += val\n    return [float(white - black)]", "def feature(board: chess.Board) -> list[float]:\n    \"Mobility: number of legal moves for side to move\"\n    moves = 0\n    for _ in board.legal_moves:\n        moves += 1\n    return [float(moves)]", "def feature(board: chess.Board) -> list[float]:\n    \"Major/minor piece mobility difference by color\"\n    def mobility_by_type(board: chess.Board, color: chess.Color, types: tuple[int, ...]) -> int:\n        cnt = 0\n        for m in board.legal_moves:\n            p = board.piece_at(m.from_square)\n            if p is not None and p.color == color and p.piece_type in types:\n                cnt += 1\n        return cnt\n\n    white_major = mobility_by_type(board, chess.WHITE, (chess.ROOK, chess.QUEEN))\n    black_major = mobility_by_type(board, chess.BLACK, (chess.ROOK, chess.QUEEN))\n    white_minor = mobility_by_type(board, chess.WHITE, (chess.KNIGHT, chess.BISHOP))\n    black_minor = mobility_by_type(board, chess.BLACK, (chess.KNIGHT, chess.BISHOP))\n\n    value = (white_major - black_major) - (white_minor - black_minor)\n    return [float(value)]", "def feature(board: chess.Board) -> list[float]:\n    \"White passed pawns minus Black passed pawns\"\n    if board.piece_map() == {}:\n        return [0.0]\n\n    def center_squares():\n        return [chess.D4, chess.E4, chess.D5, chess.E5]\n\n    center = center_squares()\n\n    def file_of(sq): return chess.square_file(sq)\n    def rank_of(sq): return chess.square_rank(sq)\n\n    white_pawns = [sq for sq, p in board.piece_map().items() if p.color == chess.WHITE and p.piece_type == chess.PAWN]\n    black_pawns = [sq for sq, p in board.piece_map().items() if p.color == chess.BLACK and p.piece_type == chess.PAWN]\n\n    def is_passed(board: chess.Board, color: chess.Color, sq: int) -> bool:\n        f = file_of(sq)\n        r = rank_of(sq)\n        if color == chess.WHITE:\n            for nf in (f - 1, f, f + 1):\n                if 0 <= nf <= 7:\n                    for nr in range(r + 1, 8):\n                        s = chess.square(nf, nr)\n                        p = board.piece_at(s)\n                        if p is not None and p.color == chess.BLACK and p.piece_type == chess.PAWN:\n                            return False\n            return True\n        else:\n            for nf in (f - 1, f, f + 1):\n                if 0 <= nf <= 7:\n                    for nr in range(r - 1, -1, -1):\n                        s = chess.square(nf, nr)\n                        p = board.piece_at(s)\n                        if p is not None and p.color == chess.WHITE and p.piece_type == chess.PAWN:\n                            return False\n            return True\n\n    passed_white = 0\n    for sq in white_pawns:\n        if is_passed(board, chess.WHITE, sq):\n            passed_white += 1\n\n    passed_black = 0\n    for sq in black_pawns:\n        if is_passed(board, chess.BLACK, sq):\n            passed_black += 1\n\n    return [float(passed_white - passed_black)]", "def feature(board: chess.Board) -> list[float]:\n    \"Piece centrality difference: weighted sum by proximity to center\"\n    center_squares = [chess.D4, chess.E4, chess.D5, chess.E5]\n    def distance_to_center(sq: int) -> int:\n        return min(chess.square_distance(sq, c) for c in center_squares)\n\n    def piece_value(p: chess.Piece) -> float:\n        values = {chess.PAWN:1.0, chess.KNIGHT:3.0, chess.BISHOP:3.0, chess.ROOK:5.0, chess.QUEEN:9.0, chess.KING:0.0}\n        return values.get(p.piece_type, 0.0)\n\n    white_sum = 0.0\n    black_sum = 0.0\n    for sq, p in board.piece_map().items():\n        dist = distance_to_center(sq)\n        weight = 1.0 / (dist + 1.0)\n        val = piece_value(p) * weight\n        if p.color == chess.WHITE:\n            white_sum += val\n        else:\n            black_sum += val\n\n    return [float(white_sum - black_sum)]", "def feature(board: chess.Board) -> list[float]:\n    \"Pawn structure: penalty for doubled and isolated pawns, difference White vs Black\"\n    def penalty_for_color(color: chess.Color) -> float:\n        counts_by_file = [0]*8\n        pawns = []\n        for sq, p in board.piece_map().items():\n            if p.color == color and p.piece_type == chess.PAWN:\n                f = chess.square_file(sq)\n                counts_by_file[f] += 1\n                pawns.append(sq)\n        doubles = sum(max(0, c-1) for c in counts_by_file)\n        isolates = 0\n        for sq in pawns:\n            f = chess.square_file(sq)\n            if (f-1 >= 0 and counts_by_file[f-1] > 0) or (f+1 <= 7 and counts_by_file[f+1] > 0):\n                continue\n            isolates += 1\n        return float(doubles + isolates)\n\n    white_penalty = penalty_for_color(chess.WHITE)\n    black_penalty = penalty_for_color(chess.BLACK)\n    return [float(white_penalty - black_penalty)]", "def feature(board: chess.Board) -> list[float]:\n    \"Heavy piece count difference: rooks and queens\"\n    def heavy_count(color: chess.Color) -> int:\n        cnt = 0\n        for sq, p in board.piece_map().items():\n            if p.color == color and p.piece_type in (chess.ROOK, chess.QUEEN):\n                cnt += 1\n        return cnt\n\n    white_heavy = heavy_count(chess.WHITE)\n    black_heavy = heavy_count(chess.BLACK)\n    return [float(white_heavy - black_heavy)]", "def feature(board: chess.Board) -> list[float]:\n    \"King safety pressure: enemy pressure on squares around kings\"\n    def around_squares(king_sq: int) -> list[int]:\n        f = chess.square_file(king_sq)\n        r = chess.square_rank(king_sq)\n        squares = []\n        for df in (-1, 0, 1):\n            for dr in (-1, 0, 1):\n                if df == 0 and dr == 0:\n                    continue\n                nf, nr = f + df, r + dr\n                if 0 <= nf <= 7 and 0 <= nr <= 7:\n                    squares.append(chess.square(nf, nr))\n        return squares\n\n    wk = board.king(chess.WHITE)\n    bk = board.king(chess.BLACK)\n    white_pressure = 0\n    black_pressure = 0\n    if wk is not None:\n        for s in around_squares(wk):\n            if board.is_attacked_by(chess.BLACK, s):\n                white_pressure += 1\n    if bk is not None:\n        for s in around_squares(bk):\n            if board.is_attacked_by(chess.WHITE, s):\n                black_pressure += 1\n    return [float(white_pressure - black_pressure)]", "def feature(board: chess.Board) -> list[float]:\n    \"Center control: difference in attack on center squares by White vs Black\"\n    center_squares = [chess.D4, chess.E4, chess.D5, chess.E5]\n    white_control = 0\n    black_control = 0\n    for sq in center_squares:\n        if board.is_attacked_by(chess.WHITE, sq):\n            white_control += 1\n        if board.is_attacked_by(chess.BLACK, sq):\n            black_control += 1\n    return [float(white_control - black_control)]", "def feature(board: chess.Board) -> list[float]:\n    \"King distance to center difference: White vs Black\"\n    center_squares = [chess.D4, chess.E4, chess.D5, chess.E5]\n    def dist_to_center(color: chess.Color) -> float:\n        k = board.king(color)\n        if k is None:\n            return 100.0\n        d = min(chess.square_distance(k, c) for c in center_squares)\n        return float(d)\n    white_dist = dist_to_center(chess.WHITE)\n    black_dist = dist_to_center(chess.BLACK)\n    return [float(white_dist - black_dist)]", "def feature(board: chess.Board) -> list[float]:\n    \"Material balance: white material minus black material using standard piece values\"\n    try:\n        value_map = {\n            chess.PAWN: 1.0,\n            chess.KNIGHT: 3.0,\n            chess.BISHOP: 3.0,\n            chess.ROOK: 5.0,\n            chess.QUEEN: 9.0,\n            chess.KING: 0.0\n        }\n        material = 0.0\n        for sq, piece in board.piece_map().items():\n            val = value_map.get(piece.piece_type, 0.0)\n            if piece.color == chess.WHITE:\n                material += val\n            else:\n                material -= val\n        return [float(material)]\n    except Exception:\n        return [0.0]", "def feature(board: chess.Board) -> list[float]:\n    \"White pawns minus Black pawns\"\n    try:\n        white_pawns = 0\n        black_pawns = 0\n        for sq, piece in board.piece_map().items():\n            if piece.piece_type == chess.PAWN:\n                if piece.color == chess.WHITE:\n                    white_pawns += 1\n                else:\n                    black_pawns += 1\n        return [float(white_pawns - black_pawns)]\n    except Exception:\n        return [0.0]", "def feature(board: chess.Board) -> list[float]:\n    \"Passed pawns balance: white passed pawns minus black passed pawns\"\n    try:\n        def is_white_passed(pawn_sq):\n            pf = chess.square_file(pawn_sq)\n            pr = chess.square_rank(pawn_sq)\n            for sq, pc in board.piece_map().items():\n                if pc.color == chess.BLACK and pc.piece_type == chess.PAWN:\n                    bf = chess.square_file(sq)\n                    br = chess.square_rank(sq)\n                    if br > pr and abs(bf - pf) <= 1:\n                        return False\n            return True\n\n        def is_black_passed(pawn_sq):\n            pb = chess.square_file(pawn_sq)\n            prb = chess.square_rank(pawn_sq)\n            for sq, pc in board.piece_map().items():\n                if pc.color == chess.WHITE and pc.piece_type == chess.PAWN:\n                    wf = chess.square_file(sq)\n                    wr = chess.square_rank(sq)\n                    if wr < prb and abs(wf - pb) <= 1:\n                        return False\n            return True\n\n        white_passed = 0\n        black_passed = 0\n        for sq, pc in board.piece_map().items():\n            if pc.piece_type == chess.PAWN:\n                if pc.color == chess.WHITE and is_white_passed(sq):\n                    white_passed += 1\n                elif pc.color == chess.BLACK and is_black_passed(sq):\n                    black_passed += 1\n        return [float(white_passed - black_passed)]\n    except Exception:\n        return [0.0]", "def feature(board: chess.Board) -> list[float]:\n    \"Central area occupation: number of pieces on central squares (d4, e4, d5, e5)\"\n    try:\n        central_sqs = {chess.D4, chess.E4, chess.D5, chess.E5}\n        count = 0\n        for sq, piece in board.piece_map().items():\n            if sq in central_sqs:\n                count += 1\n        return [float(count)]\n    except Exception:\n        return [0.0]", "def feature(board: chess.Board) -> list[float]:\n    \"Manhattan king distance between white and black kings\"\n    try:\n        wk = bk = None\n        for sq, pc in board.piece_map().items():\n            if pc.piece_type == chess.KING:\n                if pc.color == chess.WHITE:\n                    wk = sq\n                else:\n                    bk = sq\n        if wk is None or bk is None:\n            return [0.0]\n        dist = chess.square_distance(wk, bk)\n        return [float(dist)]\n    except Exception:\n        return [0.0]", "def feature(board: chess.Board) -> list[float]:\n    \"Current side mobility: number of legal moves available to the side to move\"\n    try:\n        moves = list(board.legal_moves)\n        return [float(len(moves))]\n    except Exception:\n        return [0.0]", "def feature(board: chess.Board) -> list[float]:\n    \"Is the side to move in check?\"\n    try:\n        return [float(board.is_check())]\n    except Exception:\n        return [0.0]", "def feature(board: chess.Board) -> list[float]:\n    \"Is the position stalemate?\"\n    try:\n        return [float(board.is_stalemate())]\n    except Exception:\n        return [0.0]", "def feature(board: chess.Board) -> list[float]:\n    \"Piece density: number of pieces divided by 64\"\n    try:\n        total_pieces = len(board.piece_map())\n        density = total_pieces / 64.0\n        return [float(density)]\n    except Exception:\n        return [0.0]", "def feature(board: chess.Board) -> list[float]:\n    \"Advanced pawn imbalance: white advanced pawns minus black advanced pawns\"\n    try:\n        white_adv = 0\n        black_adv = 0\n        for sq, pc in board.piece_map().items():\n            if pc.piece_type == chess.PAWN:\n                r = chess.square_rank(sq)\n                if pc.color == chess.WHITE and r >= 4:\n                    white_adv += 1\n                elif pc.color == chess.BLACK and r <= 3:\n                    black_adv += 1\n        return [float(white_adv - black_adv)]\n    except Exception:\n        return [0.0]", "def feature(board: chess.Board) -> list[float]:\n    'material value difference white minus black'\n    import chess\n    values = {\n        chess.PAWN: 1,\n        chess.KNIGHT: 3,\n        chess.BISHOP: 3,\n        chess.ROOK: 5,\n        chess.QUEEN: 9,\n        chess.KING: 0\n    }\n    diff = 0.0\n    for sq, piece in board.piece_map().items():\n        val = values.get(piece.piece_type, 0)\n        if piece.color == chess.WHITE:\n            diff += val\n        else:\n            diff -= val\n    return float(diff)", "def feature(board: chess.Board) -> list[float]:\n    'passed pawns balance: white passed minus black passed'\n    import chess\n    white_pawns = [sq for sq, p in board.piece_map().items() if p.color == chess.WHITE and p.piece_type == chess.PAWN]\n    black_pawns = [sq for sq, p in board.piece_map().items() if p.color == chess.BLACK and p.piece_type == chess.PAWN]\n    white_passed = 0\n    for w in white_pawns:\n        fw = chess.square_file(w)\n        rw = chess.square_rank(w)\n        blocked = False\n        for b in black_pawns:\n            fb = chess.square_file(b)\n            rb = chess.square_rank(b)\n            if abs(fw - fb) <= 1 and rb > rw:\n                blocked = True\n                break\n        if not blocked:\n            white_passed += 1\n    black_passed = 0\n    for b in black_pawns:\n        fb = chess.square_file(b)\n        rb = chess.square_rank(b)\n        blocked = False\n        for w in white_pawns:\n            fw = chess.square_file(w)\n            rw = chess.square_rank(w)\n            if abs(fw - fb) <= 1 and rw < rb:\n                blocked = True\n                break\n        if not blocked:\n            black_passed += 1\n    return float(white_passed - black_passed)", "def feature(board: chess.Board) -> list[float]:\n    'whether the side to move is in check (1.0 if in check, else 0.0)'\n    import chess\n    return float(board.is_check())", "def feature(board: chess.Board) -> list[float]:\n    'mobility: number of legal moves for side to move'\n    import chess\n    return float(len(list(board.legal_moves)))", "def feature(board: chess.Board) -> list[float]:\n    'open file rooks balance: white rooks on open files minus black rooks on open files'\n    import chess\n    pawn_files = set()\n    for sq, p in board.piece_map().items():\n        if p.piece_type == chess.PAWN:\n            pawn_files.add(chess.square_file(sq))\n    white_open = 0\n    black_open = 0\n    for sq, p in board.piece_map().items():\n        if p.piece_type == chess.ROOK:\n            if chess.square_file(sq) not in pawn_files:\n                if p.color == chess.WHITE:\n                    white_open += 1\n                else:\n                    black_open += 1\n    return float(white_open - black_open)", "def feature(board: chess.Board) -> list[float]:\n    'central piece presence: white minus black on central squares d4/e4/d5/e5'\n    import chess\n    central = [chess.D4, chess.E4, chess.D5, chess.E5]\n    score = 0\n    for sq in central:\n        p = board.piece_at(sq)\n        if p:\n            score += 1 if p.color == chess.WHITE else -1\n    return float(score)", "def feature(board: chess.Board) -> list[float]:\n    'rooks on 7th rank difference: white rooks on rank 6 minus black rooks on rank 1'\n    import chess\n    white_rooks = 0\n    black_rooks = 0\n    for sq, p in board.piece_map().items():\n        if p.piece_type == chess.ROOK:\n            r = chess.square_rank(sq)\n            if p.color == chess.WHITE and r == 6:\n                white_rooks += 1\n            if p.color == chess.BLACK and r == 1:\n                black_rooks += 1\n    return float(white_rooks - black_rooks)", "def feature(board: chess.Board) -> list[float]:\n    'piece count balance: white pieces minus black pieces'\n    import chess\n    white_count = 0\n    black_count = 0\n    for p in board.piece_map().values():\n        if p.color == chess.WHITE:\n            white_count += 1\n        else:\n            black_count += 1\n    return float(white_count - black_count)", "def feature(board: chess.Board) -> list[float]:\n    'attack pressure balance: squares attacked by white minus squares attacked by black'\n    import chess\n    white_attack = sum(1 for sq in range(64) if board.is_attacked_by(chess.WHITE, sq))\n    black_attack = sum(1 for sq in range(64) if board.is_attacked_by(chess.BLACK, sq))\n    return float(white_attack - black_attack)", "def feature(board: chess.Board) -> list[float]:\n    'pawn advancement balance: white pawns advancement minus black pawns advancement'\n    import chess\n    white_pawns = [sq for sq, p in board.piece_map().items() if p.color == chess.WHITE and p.piece_type == chess.PAWN]\n    black_pawns = [sq for sq, p in board.piece_map().items() if p.color == chess.BLACK and p.piece_type == chess.PAWN]\n    white_adv = sum(chess.square_rank(sq) for sq in white_pawns)\n    black_adv = sum(chess.square_rank(sq) for sq in black_pawns)\n    return float(white_adv - black_adv)", "def feature(board: chess.Board) -> list[float]:\n    \"Material balance: White material minus Black material\"\n    white_material = 0.0\n    black_material = 0.0\n    val = {chess.PAWN: 1, chess.KNIGHT: 3, chess.BISHOP: 3, chess.ROOK: 5, chess.QUEEN: 9, chess.KING: 0}\n    for sq, piece in board.piece_map().items():\n        v = val.get(piece.piece_type, 0)\n        if piece.color == chess.WHITE:\n            white_material += v\n        else:\n            black_material += v\n    return float(white_material - black_material)", "def feature(board: chess.Board) -> list[float]:\n    \"Pawn balance: White pawns minus Black pawns\"\n    white_pawns = len(board.pieces(chess.PAWN, chess.WHITE))\n    black_pawns = len(board.pieces(chess.PAWN, chess.BLACK))\n    return float(white_pawns - black_pawns)", "def feature(board: chess.Board) -> list[float]:\n    \"Passed pawns difference: White passed pawns minus Black passed pawns\"\n    def count_passed(color: chess.Color) -> int:\n        opponent = chess.BLACK if color == chess.WHITE else chess.WHITE\n        passed = 0\n        for sq in board.pieces(chess.PAWN, color):\n            f = chess.square_file(sq)\n            r = chess.square_rank(sq)\n            if color == chess.WHITE:\n                ahead_ranks = range(r + 1, 8)\n                is_passed = True\n                for nf in (f - 1, f, f + 1):\n                    if 0 <= nf <= 7:\n                        for rr in ahead_ranks:\n                            sq2 = chess.square(nf, rr)\n                            p = board.piece_at(sq2)\n                            if p is not None and p.color == opponent and p.piece_type == chess.PAWN:\n                                is_passed = False\n                                break\n                        if not is_passed:\n                            break\n                if is_passed:\n                    passed += 1\n            else:\n                behind_ranks = range(r - 1, -1, -1)\n                is_passed = True\n                for nf in (f - 1, f, f + 1):\n                    if 0 <= nf <= 7:\n                        for rr in behind_ranks:\n                            sq2 = chess.square(nf, rr)\n                            p = board.piece_at(sq2)\n                            if p is not None and p.color == opponent and p.piece_type == chess.PAWN:\n                                is_passed = False\n                                break\n                        if not is_passed:\n                            break\n                if is_passed:\n                    passed += 1\n        return passed\n    white_passed = count_passed(chess.WHITE)\n    black_passed = count_passed(chess.BLACK)\n    return float(white_passed - black_passed)", "def feature(board: chess.Board) -> list[float]:\n    \"King safety imbalance: white king exposure minus black king exposure\"\n    wksq = board.king(chess.WHITE)\n    bksq = board.king(chess.BLACK)\n    w_exposed = len(board.attackers(chess.BLACK, wksq)) if wksq is not None else 0\n    b_exposed = len(board.attackers(chess.WHITE, bksq)) if bksq is not None else 0\n    return float(w_exposed - b_exposed)", "def feature(board: chess.Board) -> list[float]:\n    \"Center control difference: white controls center minus black controls\"\n    centers = [chess.D4, chess.E4, chess.D5, chess.E5]\n    white_control = sum(1 for sq in centers if board.is_attacked_by(chess.WHITE, sq))\n    black_control = sum(1 for sq in centers if board.is_attacked_by(chess.BLACK, sq))\n    return float(white_control - black_control)", "def feature(board: chess.Board) -> list[float]:\n    \"Open file rook balance: difference of rooks on open files\"\n    def file_has_pawn(color: chess.Color, f: int) -> bool:\n        for r in range(8):\n            sq = chess.square(f, r)\n            p = board.piece_at(sq)\n            if p is not None and p.color == color and p.piece_type == chess.PAWN:\n                return True\n        return False\n    white_rooks_open = 0\n    black_rooks_open = 0\n    for f in range(8):\n        if not file_has_pawn(chess.WHITE, f) and not file_has_pawn(chess.BLACK, f):\n            # open file\n            for r in range(8):\n                sq = chess.square(f, r)\n                p = board.piece_at(sq)\n                if p is not None:\n                    if p.piece_type == chess.ROOK and p.color == chess.WHITE:\n                        white_rooks_open += 1\n                    if p.piece_type == chess.ROOK and p.color == chess.BLACK:\n                        black_rooks_open += 1\n    return float(white_rooks_open - black_rooks_open)", "def feature(board: chess.Board) -> list[float]:\n    \"Major/minor piece imbalance: weighted difference between majors and minors\"\n    white_minor = len(board.pieces(chess.KNIGHT, chess.WHITE)) + len(board.pieces(chess.BISHOP, chess.WHITE))\n    black_minor = len(board.pieces(chess.KNIGHT, chess.BLACK)) + len(board.pieces(chess.BISHOP, chess.BLACK))\n    white_major = len(board.pieces(chess.ROOK, chess.WHITE)) + len(board.pieces(chess.QUEEN, chess.WHITE))\n    black_major = len(board.pieces(chess.ROOK, chess.BLACK)) + len(board.pieces(chess.QUEEN, chess.BLACK))\n    value = (white_major - black_major) * 5.0 + (white_minor - black_minor) * 2.0\n    return float(value)", "def feature(board: chess.Board) -> list[float]:\n    \"Centralization score for major pieces: white minus black\"\n    def major_centralization(color: chess.Color) -> float:\n        total = 0.0\n        for sq in board.pieces(chess.ROOK, color):\n            total += -abs(chess.square_file(sq) - 3.5)\n        for sq in board.pieces(chess.QUEEN, color):\n            total += -abs(chess.square_file(sq) - 3.5)\n        return total\n    white_c = major_centralization(chess.WHITE)\n    black_c = major_centralization(chess.BLACK)\n    return float(white_c - black_c)", "def feature(board: chess.Board) -> list[float]:\n    \"Pawn immobility difference: blocked white pawns minus blocked black pawns\"\n    blocked_white = 0\n    blocked_black = 0\n    for sq in board.pieces(chess.PAWN, chess.WHITE):\n        r = chess.square_rank(sq)\n        if r == 7:\n            continue\n        f = chess.square_file(sq)\n        front = chess.square(f, r + 1)\n        if board.piece_at(front) is not None:\n            blocked_white += 1\n    for sq in board.pieces(chess.PAWN, chess.BLACK):\n        r = chess.square_rank(sq)\n        if r == 0:\n            continue\n        f = chess.square_file(sq)\n        front = chess.square(f, r - 1)\n        if board.piece_at(front) is not None:\n            blocked_black += 1\n    return float(blocked_white - blocked_black)"]}