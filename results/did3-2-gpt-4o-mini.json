{"used_features": ["def feature(board: chess.Board) -> float:\n    \"Measures the material balance by counting the difference in total value of pieces\"\n    piece_values = {\n        chess.PAWN: 100,\n        chess.KNIGHT: 320,\n        chess.BISHOP: 330,\n        chess.ROOK: 500,\n        chess.QUEEN: 900,\n        chess.KING: 0,  # King value is not essential for material count\n    }\n    material_balance = 0.0\n    for piece in board.piece_map().values():\n        value = piece_values[piece.piece_type]\n        if piece.color == chess.WHITE:\n            material_balance += value\n        else:\n            material_balance -= value\n    return material_balance", "def feature(board: chess.Board) -> float:\n    'Counts the number of pieces for each player and gives a ratio of pieces on the board.'\n    white_pieces = sum(1 for p in board.piece_map().values() if p.color == chess.WHITE)\n    black_pieces = sum(1 for p in board.piece_map().values() if p.color == chess.BLACK)\n    return white_pieces / (black_pieces + 1e-6)  # Avoid division by zero", "def feature(board: chess.Board) -> float:\n    'Calculates the number of pieces that are currently defended by their own pieces.'\n    defenders = 0\n    for square, piece in board.piece_map().items():\n        attackers = board.attackers(piece.color, square)\n        if attackers:\n            defenders += 1\n    return defenders", "def feature(board: chess.Board) -> float:\n    \"Measures the material balance by counting the difference in total value of pieces\"\n    piece_values = {\n        chess.PAWN: 100,\n        chess.KNIGHT: 320,\n        chess.BISHOP: 330,\n        chess.ROOK: 500,\n        chess.QUEEN: 900,\n        chess.KING: 0,  # King value is not essential for material count\n    }\n    material_balance = 0.0\n    for piece in board.piece_map().values():\n        value = piece_values[piece.piece_type]\n        if piece.color == chess.WHITE:\n            material_balance += value\n        else:\n            material_balance -= value\n    return material_balance", "def feature(board: chess.Board) -> float:\n    'Counts the number of pieces for each player and gives a ratio of pieces on the board.'\n    white_pieces = sum(1 for p in board.piece_map().values() if p.color == chess.WHITE)\n    black_pieces = sum(1 for p in board.piece_map().values() if p.color == chess.BLACK)\n    return white_pieces / (black_pieces + 1e-6)  # Avoid division by zero", "def feature(board: chess.Board) -> float:\n    \"Counts the number of possible legal moves for both players.\"\n    white_legal_moves = len(list(board.legal_moves)) if board.turn == chess.WHITE else 0\n    black_legal_moves = len(list(board.legal_moves)) if board.turn == chess.BLACK else 0\n    return float(white_legal_moves - black_legal_moves)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of possible legal moves for both players.\"\n    white_legal_moves = len(list(board.legal_moves)) if board.turn == chess.WHITE else 0\n    black_legal_moves = len(list(board.legal_moves)) if board.turn == chess.BLACK else 0\n    return float(white_legal_moves - black_legal_moves)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of available squares for all pieces on the board.\"\n    available_squares = sum(1 for square in board.piece_map() if board.piece_at(square) is not None and len(list(board.legal_moves)) > 0)\n    return float(available_squares)", "def feature(board: chess.Board) -> float:\n    'Counts the number of pieces for each player and gives a ratio of pieces on the board.'\n    white_pieces = sum(1 for p in board.piece_map().values() if p.color == chess.WHITE)\n    black_pieces = sum(1 for p in board.piece_map().values() if p.color == chess.BLACK)\n    return white_pieces / (black_pieces + 1e-6)  # Avoid division by zero", "def feature(board: chess.Board) -> float:\n    \"Counts the number of advanced pawns (pawns on ranks 4 or 5 for White and 4 or 3 for Black)\"\n    advanced_pawns = 0\n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.PAWN:\n            if (piece.color == chess.WHITE and chess.square_rank(square) >= 4) or \\\n               (piece.color == chess.BLACK and chess.square_rank(square) <= 4):\n                advanced_pawns += 1\n    return float(advanced_pawns)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of open files for rooks for both players.\"\n    open_files = 0\n    for file in range(8):\n        if all(board.piece_at(chess.square(file, rank)) is None for rank in range(8)):\n            open_files += 1\n    return float(open_files)", "def feature(board: chess.Board) -> float:\n    \"Calculate the total piece value for the current player.\"\n    value = 0\n    for piece in board.piece_map().values():\n        if piece.color == board.turn:\n            value += piece.piece_type\n    return float(value)", "def feature(board: chess.Board) -> float:\n    \"Scores the king safety based on the number of pieces defending the king\"\n    king_square = None\n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.KING and piece.color == board.turn:\n            king_square = square\n            break\n    if king_square is None:\n        return 0.0\n    defending_pieces = sum(1 for piece in board.piece_map().values()\n                           if piece.color == board.turn and board.is_attacked_by(not board.turn, king_square))\n    return float(defending_pieces)", "def feature(board: chess.Board) -> float:\n    'Measures the number of squares controlled by pieces of the current player.'\n    controlled_squares = set()\n    for square, piece in board.piece_map().items():\n        if piece.color == board.turn:\n            controlled_squares.update(board.attacks(square))\n    return len(controlled_squares)", "def feature(board: chess.Board) -> float:\n    \"Measures the material balance by counting the difference in total value of pieces\"\n    piece_values = {\n        chess.PAWN: 100,\n        chess.KNIGHT: 320,\n        chess.BISHOP: 330,\n        chess.ROOK: 500,\n        chess.QUEEN: 900,\n        chess.KING: 0,  # King value is not essential for material count\n    }\n    material_balance = 0.0\n    for piece in board.piece_map().values():\n        value = piece_values[piece.piece_type]\n        if piece.color == chess.WHITE:\n            material_balance += value\n        else:\n            material_balance -= value\n    return material_balance", "def feature(board: chess.Board) -> float:\n    \"Counts the number of possible legal moves for both players.\"\n    white_legal_moves = len(list(board.legal_moves)) if board.turn == chess.WHITE else 0\n    black_legal_moves = len(list(board.legal_moves)) if board.turn == chess.BLACK else 0\n    return float(white_legal_moves - black_legal_moves)", "def feature(board: chess.Board) -> float:\n    \"Measures the material balance by counting the difference in total value of pieces\"\n    piece_values = {\n        chess.PAWN: 100,\n        chess.KNIGHT: 320,\n        chess.BISHOP: 330,\n        chess.ROOK: 500,\n        chess.QUEEN: 900,\n        chess.KING: 0,  # King value is not essential for material count\n    }\n    material_balance = 0.0\n    for piece in board.piece_map().values():\n        value = piece_values[piece.piece_type]\n        if piece.color == chess.WHITE:\n            material_balance += value\n        else:\n            material_balance -= value\n    return material_balance", "def feature(board: chess.Board) -> float:\n    'Measures the number of squares controlled by each side.'\n    white_control = sum(1 for square in chess.SQUARES if board.is_attacked_by(chess.WHITE, square))\n    black_control = sum(1 for square in chess.SQUARES if board.is_attacked_by(chess.BLACK, square))\n    return float(white_control - black_control)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of advanced pawns (pawns on ranks 4 or 5 for White and 4 or 3 for Black)\"\n    advanced_pawns = 0\n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.PAWN:\n            if (piece.color == chess.WHITE and chess.square_rank(square) >= 4) or \\\n               (piece.color == chess.BLACK and chess.square_rank(square) <= 4):\n                advanced_pawns += 1\n    return float(advanced_pawns)", "def feature(board: chess.Board) -> float:\n    \"Measures the material balance by counting the difference in total value of pieces\"\n    piece_values = {\n        chess.PAWN: 100,\n        chess.KNIGHT: 320,\n        chess.BISHOP: 330,\n        chess.ROOK: 500,\n        chess.QUEEN: 900,\n        chess.KING: 0,  # King value is not essential for material count\n    }\n    material_balance = 0.0\n    for piece in board.piece_map().values():\n        value = piece_values[piece.piece_type]\n        if piece.color == chess.WHITE:\n            material_balance += value\n        else:\n            material_balance -= value\n    return material_balance", "def feature(board: chess.Board) -> float:\n    \"Measures the material balance by counting the difference in total value of pieces\"\n    piece_values = {\n        chess.PAWN: 100,\n        chess.KNIGHT: 320,\n        chess.BISHOP: 330,\n        chess.ROOK: 500,\n        chess.QUEEN: 900,\n        chess.KING: 0,  # King value is not essential for material count\n    }\n    material_balance = 0.0\n    for piece in board.piece_map().values():\n        value = piece_values[piece.piece_type]\n        if piece.color == chess.WHITE:\n            material_balance += value\n        else:\n            material_balance -= value\n    return material_balance", "def feature(board: chess.Board) -> float:\n    \"Measures the material balance by counting the difference in total value of pieces\"\n    piece_values = {\n        chess.PAWN: 100,\n        chess.KNIGHT: 320,\n        chess.BISHOP: 330,\n        chess.ROOK: 500,\n        chess.QUEEN: 900,\n        chess.KING: 0,  # King value is not essential for material count\n    }\n    material_balance = 0.0\n    for piece in board.piece_map().values():\n        value = piece_values[piece.piece_type]\n        if piece.color == chess.WHITE:\n            material_balance += value\n        else:\n            material_balance -= value\n    return material_balance", "def feature(board: chess.Board) -> float:\n    \"Measures the distance of all pieces to their opponent's back rank.\"\n    total_distance = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == chess.WHITE:\n            total_distance += chess.square_rank(square)  # Distance to rank 0\n        else:\n            total_distance += 7 - chess.square_rank(square)  # Distance to rank 7\n    return float(total_distance)", "def feature(board: chess.Board) -> float:\n    \"Checks the material imbalance based on piece types.\"\n    material_values = {chess.PAWN: 100, chess.KNIGHT: 300, chess.BISHOP: 300, chess.ROOK: 500, chess.QUEEN: 900}\n    material_balance = 0\n    for piece in board.piece_map().values():\n        color_factor = 1 if piece.color == chess.WHITE else -1\n        material_balance += color_factor * material_values.get(piece.piece_type, 0)\n    return float(material_balance)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pawns on the board and gives a ratio of White to Black pawns.\"\n    white_pawns = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE and piece.piece_type == chess.PAWN)\n    black_pawns = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK and piece.piece_type == chess.PAWN)\n    return float(white_pawns) / (black_pawns + 1)  # Avoid division by zero", "def feature(board: chess.Board) -> float:\n    'Measures the number of squares controlled by each side.'\n    white_control = sum(1 for square in chess.SQUARES if board.is_attacked_by(chess.WHITE, square))\n    black_control = sum(1 for square in chess.SQUARES if board.is_attacked_by(chess.BLACK, square))\n    return float(white_control - black_control)", "def feature(board: chess.Board) -> float:\n    \"Measures the potential mobility advantage by counting the legal moves available to each player.\"\n    white_legal_moves = len(list(board.legal_moves)) if board.turn else 0\n    black_legal_moves = len(list(board.legal_moves)) if not board.turn else 0\n    return float(white_legal_moves - black_legal_moves)", "def feature(board: chess.Board) -> float:\n    \"Measures the material balance by counting the difference in total value of pieces\"\n    piece_values = {\n        chess.PAWN: 100,\n        chess.KNIGHT: 320,\n        chess.BISHOP: 330,\n        chess.ROOK: 500,\n        chess.QUEEN: 900,\n        chess.KING: 0,  # King value is not essential for material count\n    }\n    material_balance = 0.0\n    for piece in board.piece_map().values():\n        value = piece_values[piece.piece_type]\n        if piece.color == chess.WHITE:\n            material_balance += value\n        else:\n            material_balance -= value\n    return material_balance", "def feature(board: chess.Board) -> float:\n    'Measures the number of squares controlled by each side.'\n    white_control = sum(1 for square in chess.SQUARES if board.is_attacked_by(chess.WHITE, square))\n    black_control = sum(1 for square in chess.SQUARES if board.is_attacked_by(chess.BLACK, square))\n    return float(white_control - black_control)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of possible legal moves for both players.\"\n    white_legal_moves = len(list(board.legal_moves)) if board.turn == chess.WHITE else 0\n    black_legal_moves = len(list(board.legal_moves)) if board.turn == chess.BLACK else 0\n    return float(white_legal_moves - black_legal_moves)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of possible legal moves for both players.\"\n    white_legal_moves = len(list(board.legal_moves)) if board.turn == chess.WHITE else 0\n    black_legal_moves = len(list(board.legal_moves)) if board.turn == chess.BLACK else 0\n    return float(white_legal_moves - black_legal_moves)", "def feature(board: chess.Board) -> float:\n    'Measures the number of squares controlled by each side.'\n    white_control = sum(1 for square in chess.SQUARES if board.is_attacked_by(chess.WHITE, square))\n    black_control = sum(1 for square in chess.SQUARES if board.is_attacked_by(chess.BLACK, square))\n    return float(white_control - black_control)", "def feature(board: chess.Board) -> float:\n    \"Measures the distance of all pieces to their opponent's back rank.\"\n    total_distance = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == chess.WHITE:\n            total_distance += chess.square_rank(square)  # Distance to rank 0\n        else:\n            total_distance += 7 - chess.square_rank(square)  # Distance to rank 7\n    return float(total_distance)", "def feature(board: chess.Board) -> float:\n    'Measures the number of squares controlled by each side.'\n    white_control = sum(1 for square in chess.SQUARES if board.is_attacked_by(chess.WHITE, square))\n    black_control = sum(1 for square in chess.SQUARES if board.is_attacked_by(chess.BLACK, square))\n    return float(white_control - black_control)", "def feature(board: chess.Board) -> float:\n    'Measures the number of squares controlled by each side.'\n    white_control = sum(1 for square in chess.SQUARES if board.is_attacked_by(chess.WHITE, square))\n    black_control = sum(1 for square in chess.SQUARES if board.is_attacked_by(chess.BLACK, square))\n    return float(white_control - black_control)", "def feature(board: chess.Board) -> float:\n    'Calculates the sum of piece values for the most valuable piece of each side.'\n    piece_values = {chess.PAWN: 100, chess.KNIGHT: 300, chess.BISHOP: 300, chess.ROOK: 500, chess.QUEEN: 900, chess.KING: 0}\n    white_max_value = max((piece_values[piece.piece_type] for piece in board.piece_map().values() if piece.color == chess.WHITE), default=0)\n    black_max_value = max((piece_values[piece.piece_type] for piece in board.piece_map().values() if piece.color == chess.BLACK), default=0)\n    return float(white_max_value - black_max_value)", "def feature(board: chess.Board) -> float:\n    \"Measures the material balance by counting the difference in total value of pieces\"\n    piece_values = {\n        chess.PAWN: 100,\n        chess.KNIGHT: 320,\n        chess.BISHOP: 330,\n        chess.ROOK: 500,\n        chess.QUEEN: 900,\n        chess.KING: 0,  # King value is not essential for material count\n    }\n    material_balance = 0.0\n    for piece in board.piece_map().values():\n        value = piece_values[piece.piece_type]\n        if piece.color == chess.WHITE:\n            material_balance += value\n        else:\n            material_balance -= value\n    return material_balance", "def feature(board: chess.Board) -> float:\n    \"Calculates the ratio of major pieces (rooks and queens) to total pieces.\"\n    major_piece_count = sum(1 for piece in board.piece_map().values() if piece.piece_type in {chess.ROOK, chess.QUEEN})\n    total_piece_count = len(board.piece_map())\n    ratio = major_piece_count / total_piece_count if total_piece_count > 0 else 0\n    return float(ratio)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of supported pieces on the board.\"\n    supported_count = 0\n    for square, piece in board.piece_map().items():\n        if any(board.is_attacked_by(piece.color, support_sq) for support_sq in board.attackers(not piece.color, square)):\n            supported_count += 1\n    return float(supported_count)", "def feature(board: chess.Board) -> float:\n    \"Measures the distance of all pieces to their opponent's back rank.\"\n    total_distance = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == chess.WHITE:\n            total_distance += chess.square_rank(square)  # Distance to rank 0\n        else:\n            total_distance += 7 - chess.square_rank(square)  # Distance to rank 7\n    return float(total_distance)", "def feature(board: chess.Board) -> float:\n    \"Evaluates material balance adjusted for piece activity on the board.\"\n    piece_values = {chess.PAWN: 100, chess.KNIGHT: 300, chess.BISHOP: 300, chess.ROOK: 500, chess.QUEEN: 900, chess.KING: 0}\n    activity_factor = sum(1 for piece in board.piece_map().values() if piece.color == board.turn)\n    material_balance = sum(piece_values[piece.piece_type] * (1 if piece.color == chess.WHITE else -1) for piece in board.piece_map().values())\n    return float(material_balance + activity_factor)", "def feature(board: chess.Board) -> float:\n    \"Calculates the total value of pieces on the board for the active color.\"\n    piece_values = {chess.PAWN: 100, chess.KNIGHT: 320, chess.BISHOP: 330, chess.ROOK: 500, chess.QUEEN: 900, chess.KING: 0}\n    total_value = sum(piece_values[piece.piece_type] for piece in board.piece_map().values() if piece.color == board.turn)\n    return float(total_value)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces within the opponent's territory for each side.\"\n    white_pieces_in_enemy_territory = sum(1 for square, piece in board.piece_map().items() \n                                           if piece.color == chess.WHITE and chess.square_rank(square) > 4)\n    black_pieces_in_enemy_territory = sum(1 for square, piece in board.piece_map().items() \n                                           if piece.color == chess.BLACK and chess.square_rank(square) < 4)\n    return float(white_pieces_in_enemy_territory - black_pieces_in_enemy_territory)", "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in number of rooks for both players.\"\n    white_rooks = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE and piece.piece_type == chess.ROOK)\n    black_rooks = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK and piece.piece_type == chess.ROOK)\n    return float(white_rooks - black_rooks)", "def feature(board: chess.Board) -> float:\n    \"Gives the difference in the number of pieces on squares with more than one attack (strong squares).\"\n    strong_squares_count = 0\n    for square in chess.SQUARES:\n        if len(board.attackers(chess.WHITE, square)) > 1:\n            strong_squares_count += 1\n        if len(board.attackers(chess.BLACK, square)) > 1:\n            strong_squares_count -= 1\n    return float(strong_squares_count)", "def feature(board: chess.Board) -> float:\n    \"Computes the mobility score based on the number of squares each piece can move to.\"\n    mobility_score = 0\n    for square in board.piece_map():\n        piece = board.piece_at(square)\n        if piece is not None:\n            mobility_score += len(list(board.legal_moves))\n    return float(mobility_score)", "def feature(board: chess.Board) -> float:\n    \"Returns the number of pieces that are pinned by the opponent's pieces.\"\n    pinned_count = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == (chess.WHITE if board.turn else chess.BLACK):\n            for attacker in board.attackers(chess.BLACK if piece.color == chess.WHITE else chess.WHITE, square):\n                if board.piece_at(attacker) and board.is_attacked_by(piece.color, attacker):\n                    pinned_count += 1\n                    break\n    return float(pinned_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the ratio of actively developed pieces to total pieces.\"\n    developed_pieces = sum(1 for square, piece in board.piece_map().items() if chess.square_rank(square) > 4 and piece.color == (chess.WHITE if board.turn else chess.BLACK))\n    total_pieces = len(board.piece_map())\n    return developed_pieces / total_pieces if total_pieces > 0 else 0.0", "def feature(board: chess.Board) -> float:\n    \"Measures the material balance by counting the difference in total value of pieces\"\n    piece_values = {\n        chess.PAWN: 100,\n        chess.KNIGHT: 320,\n        chess.BISHOP: 330,\n        chess.ROOK: 500,\n        chess.QUEEN: 900,\n        chess.KING: 0,  # King value is not essential for material count\n    }\n    material_balance = 0.0\n    for piece in board.piece_map().values():\n        value = piece_values[piece.piece_type]\n        if piece.color == chess.WHITE:\n            material_balance += value\n        else:\n            material_balance -= value\n    return material_balance", "def feature(board: chess.Board) -> float:\n    \"Measures the number of pieces that can deliver check on the next move.\"\n    check_chances = sum(1 for move in board.legal_moves if board.gives_check(move))\n    return float(check_chances)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces on the 7th rank for each player.\"\n    rank_count = {chess.WHITE: 0, chess.BLACK: 0}\n    for square, piece in board.piece_map().items():\n        if chess.square_rank(square) == 6:  # 7th rank for white\n            rank_count[chess.WHITE] += 1\n        elif chess.square_rank(square) == 1:  # 7th rank for black\n            rank_count[chess.BLACK] += 1\n    return float(rank_count[chess.WHITE] - rank_count[chess.BLACK])", "def feature(board: chess.Board) -> float:\n    \"Measures the material balance by counting the difference in total value of pieces\"\n    piece_values = {\n        chess.PAWN: 100,\n        chess.KNIGHT: 320,\n        chess.BISHOP: 330,\n        chess.ROOK: 500,\n        chess.QUEEN: 900,\n        chess.KING: 0,  # King value is not essential for material count\n    }\n    material_balance = 0.0\n    for piece in board.piece_map().values():\n        value = piece_values[piece.piece_type]\n        if piece.color == chess.WHITE:\n            material_balance += value\n        else:\n            material_balance -= value\n    return material_balance", "def feature(board: chess.Board) -> float:\n    \"Measures the total potential value of pieces that can move in the next turn.\"\n    potential_value = 0\n    for move in board.legal_moves:\n        piece = board.piece_at(move.from_square)\n        if piece:\n            potential_value += piece.piece_type\n    return float(potential_value)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of pieces controlled (attacked) by each player.\"\n    white_control = sum(1 for square in board.piece_map() for attacker in board.attackers(chess.WHITE, square))\n    black_control = sum(1 for square in board.piece_map() for attacker in board.attackers(chess.BLACK, square))\n    return float(white_control - black_control)", "def feature(board: chess.Board) -> float:\n    \"Measures the value of pieces protected by pawns for both sides.\"\n    value_map = {\n        chess.PAWN: 1, chess.KNIGHT: 3, chess.BISHOP: 3,\n        chess.ROOK: 5, chess.QUEEN: 9, chess.KING: 0\n    }\n\n    white_protected_value = 0\n    black_protected_value = 0\n\n    for square, piece in board.piece_map().items():\n        if piece.color == chess.WHITE:\n            attackers = board.attackers(chess.BLACK, square)\n            if all(board.piece_at(attacker) is None or board.piece_at(attacker).color == chess.WHITE for attacker in attackers):\n                white_protected_value += value_map.get(piece.piece_type, 0)\n        else:\n            attackers = board.attackers(chess.WHITE, square)\n            if all(board.piece_at(attacker) is None or board.piece_at(attacker).color == chess.BLACK for attacker in attackers):\n                black_protected_value += value_map.get(piece.piece_type, 0)\n\n    return white_protected_value - black_protected_value", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces that are controlling the center squares.\"\n    center_squares = [chess.D4, chess.D5, chess.E4, chess.E5]\n    control_count = 0\n    for square in center_squares:\n        attackers = board.attackers(chess.WHITE, square)\n        if board.turn:\n            control_count += len(attackers)\n        else:\n            control_count += len(board.attackers(chess.BLACK, square))\n    return float(control_count)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces on the 7th rank for each player.\"\n    rank_count = {chess.WHITE: 0, chess.BLACK: 0}\n    for square, piece in board.piece_map().items():\n        if chess.square_rank(square) == 6:  # 7th rank for white\n            rank_count[chess.WHITE] += 1\n        elif chess.square_rank(square) == 1:  # 7th rank for black\n            rank_count[chess.BLACK] += 1\n    return float(rank_count[chess.WHITE] - rank_count[chess.BLACK])", "def feature(board: chess.Board) -> float:\n    \"Calculates the piece activity, defined as the number of moves each piece can make.\"\n    activity_score = 0\n    for piece in board.piece_map().values():\n        activity_score += len(list(board.legal_moves)) if piece.color == board.turn else -len(list(board.legal_moves))\n    return float(activity_score)", "def feature(board: chess.Board) -> float:\n    \"Calculates the distance of the kings to the nearest enemy piece.\"\n    white_king_sq = next((sq for sq in board.piece_map() if board.piece_map()[sq].piece_type == chess.KING and board.piece_map()[sq].color == chess.WHITE), None)\n    black_king_sq = next((sq for sq in board.piece_map() if board.piece_map()[sq].piece_type == chess.KING and board.piece_map()[sq].color == chess.BLACK), None)\n    white_dist = min(chess.square_distance(white_king_sq, sq) for sq in board.piece_map() if board.piece_map()[sq].color == chess.BLACK) if white_king_sq else float('inf')\n    black_dist = min(chess.square_distance(black_king_sq, sq) for sq in board.piece_map() if board.piece_map()[sq].color == chess.WHITE) if black_king_sq else float('inf')\n    return float(white_dist - black_dist)", "def feature(board: chess.Board) -> float:\n    'Measures the number of squares controlled by each side.'\n    white_control = sum(1 for square in chess.SQUARES if board.is_attacked_by(chess.WHITE, square))\n    black_control = sum(1 for square in chess.SQUARES if board.is_attacked_by(chess.BLACK, square))\n    return float(white_control - black_control)", "def feature(board: chess.Board) -> float:\n    \"Measures the mobility of all pieces on the board by counting their legal moves.\"\n    total_moves = sum(len(list(board.legal_moves)) for piece in board.piece_map().values())\n    return float(total_moves)", "def feature(board: chess.Board) -> float:\n    \"Measures the value of pieces protected by pawns for both sides.\"\n    value_map = {\n        chess.PAWN: 1, chess.KNIGHT: 3, chess.BISHOP: 3,\n        chess.ROOK: 5, chess.QUEEN: 9, chess.KING: 0\n    }\n\n    white_protected_value = 0\n    black_protected_value = 0\n\n    for square, piece in board.piece_map().items():\n        if piece.color == chess.WHITE:\n            attackers = board.attackers(chess.BLACK, square)\n            if all(board.piece_at(attacker) is None or board.piece_at(attacker).color == chess.WHITE for attacker in attackers):\n                white_protected_value += value_map.get(piece.piece_type, 0)\n        else:\n            attackers = board.attackers(chess.WHITE, square)\n            if all(board.piece_at(attacker) is None or board.piece_at(attacker).color == chess.BLACK for attacker in attackers):\n                black_protected_value += value_map.get(piece.piece_type, 0)\n\n    return white_protected_value - black_protected_value", "def feature(board: chess.Board) -> float:\n    'Calculates the centralization of pieces for both players'\n    center_squares = [chess.E4, chess.E5, chess.D4, chess.D5]\n    white_center = sum(1 for square in center_squares if board.piece_at(square) and board.piece_at(square).color == chess.WHITE)\n    black_center = sum(1 for square in center_squares if board.piece_at(square) and board.piece_at(square).color == chess.BLACK)\n    return float(white_center - black_center)", "def feature(board: chess.Board) -> float:\n    \"Calculates the ratio of actively developed pieces to total pieces.\"\n    developed_pieces = sum(1 for square, piece in board.piece_map().items() if chess.square_rank(square) > 4 and piece.color == (chess.WHITE if board.turn else chess.BLACK))\n    total_pieces = len(board.piece_map())\n    return developed_pieces / total_pieces if total_pieces > 0 else 0.0", "def feature(board: chess.Board) -> float:\n    \"Returns the number of pieces that are pinned by the opponent's pieces.\"\n    pinned_count = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == (chess.WHITE if board.turn else chess.BLACK):\n            for attacker in board.attackers(chess.BLACK if piece.color == chess.WHITE else chess.WHITE, square):\n                if board.piece_at(attacker) and board.is_attacked_by(piece.color, attacker):\n                    pinned_count += 1\n                    break\n    return float(pinned_count)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pawns that are advanced (on ranks 4-7).\"\n    advanced_pawns = {chess.WHITE: 0, chess.BLACK: 0}\n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.PAWN:\n            if chess.square_rank(square) >= 4:\n                advanced_pawns[piece.color] += 1\n    return float(advanced_pawns[chess.WHITE] - advanced_pawns[chess.BLACK])", "def feature(board: chess.Board) -> float:\n    \"Counts the number of available squares for all pieces on the board.\"\n    available_squares = sum(1 for square in board.piece_map() if board.piece_at(square) is not None and len(list(board.legal_moves)) > 0)\n    return float(available_squares)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of pieces that are pinned.\"\n    pinned_count = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == board.turn:\n            for opponent_square in board.attackers(not piece.color, square):\n                if board.is_attacked_by(piece.color, opponent_square):\n                    pinned_count += 1\n                    break\n    return float(pinned_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the king safety based on the number of adjacent squares controlled by the opponent.\"\n    white_king_square = next((square for square, piece in board.piece_map().items() \n                               if piece.color == chess.WHITE and piece.piece_type == chess.KING), None)\n    black_king_square = next((square for square, piece in board.piece_map().items() \n                               if piece.color == chess.BLACK and piece.piece_type == chess.KING), None)\n    white_king_attackers = sum(1 for square in chess.SQUARES if board.is_attacked_by(chess.BLACK, square) and \n                                chess.square_distance(square, white_king_square) <= 1)\n    black_king_attackers = sum(1 for square in chess.SQUARES if board.is_attacked_by(chess.WHITE, square) and \n                                chess.square_distance(square, black_king_square) <= 1)\n    return float(black_king_attackers - white_king_attackers)", "def feature(board: chess.Board) -> float:\n    \"Calculates the imbalance in material based on piece types.\"\n    piece_values = {\n        chess.PAWN: 100,\n        chess.KNIGHT: 320,\n        chess.BISHOP: 330,\n        chess.ROOK: 500,\n        chess.QUEEN: 900,\n        chess.KING: float('inf'),  # King shouldn't be counted\n    }\n    material_balance = 0\n    for piece in board.piece_map().values():\n        material_balance += piece_values[piece.piece_type] if piece.color == chess.WHITE else -piece_values[piece.piece_type]\n    return float(material_balance)", "def feature(board: chess.Board) -> float:\n    \"Evaluates material balance adjusted for piece activity on the board.\"\n    piece_values = {chess.PAWN: 100, chess.KNIGHT: 300, chess.BISHOP: 300, chess.ROOK: 500, chess.QUEEN: 900, chess.KING: 0}\n    activity_factor = sum(1 for piece in board.piece_map().values() if piece.color == board.turn)\n    material_balance = sum(piece_values[piece.piece_type] * (1 if piece.color == chess.WHITE else -1) for piece in board.piece_map().values())\n    return float(material_balance + activity_factor)", "def feature(board: chess.Board) -> float:\n    \"Calculates the king safety based on the number of adjacent squares controlled by the opponent.\"\n    white_king_square = next((square for square, piece in board.piece_map().items() \n                               if piece.color == chess.WHITE and piece.piece_type == chess.KING), None)\n    black_king_square = next((square for square, piece in board.piece_map().items() \n                               if piece.color == chess.BLACK and piece.piece_type == chess.KING), None)\n    white_king_attackers = sum(1 for square in chess.SQUARES if board.is_attacked_by(chess.BLACK, square) and \n                                chess.square_distance(square, white_king_square) <= 1)\n    black_king_attackers = sum(1 for square in chess.SQUARES if board.is_attacked_by(chess.WHITE, square) and \n                                chess.square_distance(square, black_king_square) <= 1)\n    return float(black_king_attackers - white_king_attackers)", "def feature(board: chess.Board) -> float:\n    \"Measures the material balance by counting the difference in total value of pieces\"\n    piece_values = {\n        chess.PAWN: 100,\n        chess.KNIGHT: 320,\n        chess.BISHOP: 330,\n        chess.ROOK: 500,\n        chess.QUEEN: 900,\n        chess.KING: 0,  # King value is not essential for material count\n    }\n    material_balance = 0.0\n    for piece in board.piece_map().values():\n        value = piece_values[piece.piece_type]\n        if piece.color == chess.WHITE:\n            material_balance += value\n        else:\n            material_balance -= value\n    return material_balance", "def feature(board: chess.Board) -> float:\n    \"Calculates the distance of the kings to the nearest enemy piece.\"\n    white_king_sq = next((sq for sq in board.piece_map() if board.piece_map()[sq].piece_type == chess.KING and board.piece_map()[sq].color == chess.WHITE), None)\n    black_king_sq = next((sq for sq in board.piece_map() if board.piece_map()[sq].piece_type == chess.KING and board.piece_map()[sq].color == chess.BLACK), None)\n    white_dist = min(chess.square_distance(white_king_sq, sq) for sq in board.piece_map() if board.piece_map()[sq].color == chess.BLACK) if white_king_sq else float('inf')\n    black_dist = min(chess.square_distance(black_king_sq, sq) for sq in board.piece_map() if board.piece_map()[sq].color == chess.WHITE) if black_king_sq else float('inf')\n    return float(white_dist - black_dist)", "def feature(board: chess.Board) -> float:\n    \"Calculates the imbalance in material based on piece types.\"\n    piece_values = {\n        chess.PAWN: 100,\n        chess.KNIGHT: 320,\n        chess.BISHOP: 330,\n        chess.ROOK: 500,\n        chess.QUEEN: 900,\n        chess.KING: float('inf'),  # King shouldn't be counted\n    }\n    material_balance = 0\n    for piece in board.piece_map().values():\n        material_balance += piece_values[piece.piece_type] if piece.color == chess.WHITE else -piece_values[piece.piece_type]\n    return float(material_balance)", "def feature(board: chess.Board) -> float:\n    \"Measures the average distance of all pieces from their back rank to assess development.\"\n    distance_sum = sum(chess.square_rank(square) for square in board.piece_map())\n    piece_count = len(board.piece_map())\n    return float(distance_sum) / (piece_count + 1) if piece_count > 0 else 0.0", "def feature(board: chess.Board) -> float:\n    \"Calculates the average distance of pieces from the opponent's back rank.\"\n    color = board.turn\n    total_distance = 0\n    count = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == color:\n            distance = 7 - chess.square_rank(square) if color == chess.WHITE else chess.square_rank(square)\n            total_distance += distance\n            count += 1\n    return total_distance / count if count > 0 else 0.0", "def feature(board: chess.Board) -> float:\n    'Measures the number of squares controlled by pieces of the current player.'\n    controlled_squares = set()\n    for square, piece in board.piece_map().items():\n        if piece.color == board.turn:\n            controlled_squares.update(board.attacks(square))\n    return len(controlled_squares)", "def feature(board: chess.Board) -> float:\n    \"Calculates the distance of all pieces from their starting positions.\"\n    total_distance = sum(chess.square_distance(square, piece.piece_type + 8 * piece.color) \n                         for square, piece in board.piece_map().items())\n    return float(total_distance)", "def feature(board: chess.Board) -> float:\n    \"Measures the distance of each side's king from the center of the board (central control).\"\n    center_squares = [chess.D4, chess.D5, chess.E4, chess.E5]\n    white_king_square = next((square for square in board.piece_map() if board.piece_map()[square].piece_type == chess.KING and board.piece_map()[square].color == chess.WHITE), None)\n    black_king_square = next((square for square in board.piece_map() if board.piece_map()[square].piece_type == chess.KING and board.piece_map()[square].color == chess.BLACK), None)\n    white_king_distance = min(chess.square_distance(white_king_square, sq) for sq in center_squares) if white_king_square else 0\n    black_king_distance = min(chess.square_distance(black_king_square, sq) for sq in center_squares) if black_king_square else 0\n    return float(black_king_distance - white_king_distance)", "def feature(board: chess.Board) -> float:\n    \"Calculates the ratio of minor pieces to total pieces for each player.\"\n    white_minor = len([p for p in board.piece_map().values() if p.color == chess.WHITE and p.piece_type in (chess.KNIGHT, chess.BISHOP)])\n    black_minor = len([p for p in board.piece_map().values() if p.color == chess.BLACK and p.piece_type in (chess.KNIGHT, chess.BISHOP)])\n    total_white = len([p for p in board.piece_map().values() if p.color == chess.WHITE])\n    total_black = len([p for p in board.piece_map().values() if p.color == chess.BLACK])\n    return float((white_minor / max(1, total_white)) - (black_minor / max(1, total_black)))", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces within the opponent's territory for each side.\"\n    white_pieces_in_enemy_territory = sum(1 for square, piece in board.piece_map().items() \n                                           if piece.color == chess.WHITE and chess.square_rank(square) > 4)\n    black_pieces_in_enemy_territory = sum(1 for square, piece in board.piece_map().items() \n                                           if piece.color == chess.BLACK and chess.square_rank(square) < 4)\n    return float(white_pieces_in_enemy_territory - black_pieces_in_enemy_territory)", "def feature(board: chess.Board) -> float:\n    \"Measures the average distance of pawns from the opponent's back rank.\"\n    distance_sum = 0\n    pawn_count = 0\n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.PAWN:\n            distance_sum += chess.square_rank(square) if piece.color == chess.WHITE else 7 - chess.square_rank(square)\n            pawn_count += 1\n    average_distance = distance_sum / pawn_count if pawn_count > 0 else 0\n    return float(average_distance)", "def feature(board: chess.Board) -> float:\n    \"Computes the ratio of rooks on open files for both players.\"\n    open_file_count_white = sum(1 for file in range(8) if not any(board.piece_at(chess.square(file, rank)) is not None for rank in range(8)))\n    open_file_count_black = sum(1 for file in range(8) if not any(board.piece_at(chess.square(file, rank)) is not None for rank in range(0, 4)))\n    total_rooks_white = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE and piece.piece_type == chess.ROOK)\n    total_rooks_black = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK and piece.piece_type == chess.ROOK)\n    \n    result = (open_file_count_white / (total_rooks_white + 1)) - (open_file_count_black / (total_rooks_black + 1))\n    return result", "def feature(board: chess.Board) -> float:\n    \"Evaluates the control of the center squares by counting pieces on d4, d5, e4, and e5.\"\n    center_squares = [chess.parse_square('d4'), chess.parse_square('d5'), \n                      chess.parse_square('e4'), chess.parse_square('e5')]\n    control_score = sum(1 for square in center_squares if board.piece_at(square) and board.piece_at(square).color == (chess.WHITE if board.turn else chess.BLACK))\n    return float(control_score)", "def feature(board: chess.Board) -> float:\n    \"Measures the average distance of all pieces from their back rank to assess development.\"\n    distance_sum = sum(chess.square_rank(square) for square in board.piece_map())\n    piece_count = len(board.piece_map())\n    return float(distance_sum) / (piece_count + 1) if piece_count > 0 else 0.0", "def feature(board: chess.Board) -> float:\n    \"Calculates the average distance of pieces from the center of the board.\"\n    center_squares = [chess.E4, chess.D4, chess.E5, chess.D5]\n    total_distance = 0\n    piece_count = len(board.piece_map())\n    \n    for piece_square in board.piece_map():\n        total_distance += min(chess.square_distance(piece_square, center) for center in center_squares)\n    \n    return total_distance / piece_count if piece_count > 0 else 0.0", "def feature(board: chess.Board) -> float:\n    \"Measures the distance from the king to the nearest enemy piece.\"\n    white_king_square = next(square for square, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color == chess.WHITE)\n    black_king_square = next(square for square, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color == chess.BLACK)\n    nearest_enemy_distance_white = min((chess.square_distance(white_king_square, enemy_square) for enemy_square in board.attackers(chess.BLACK, black_king_square)), default=8)\n    nearest_enemy_distance_black = min((chess.square_distance(black_king_square, enemy_square) for enemy_square in board.attackers(chess.WHITE, white_king_square)), default=8)\n    return float(nearest_enemy_distance_white - nearest_enemy_distance_black)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of possible legal moves for both players.\"\n    white_legal_moves = len(list(board.legal_moves)) if board.turn == chess.WHITE else 0\n    black_legal_moves = len(list(board.legal_moves)) if board.turn == chess.BLACK else 0\n    return float(white_legal_moves - black_legal_moves)", "def feature(board: chess.Board) -> float:\n    'Counts the number of threats made by each player towards the opponent\u2019s pieces.'\n    threats = 0\n    for square, piece in board.piece_map().items():\n        if piece.color != board.turn:\n            threats += len(board.attackers(board.turn, square))\n    return float(threats)", "def feature(board: chess.Board) -> float:\n    \"Calculates the distance of all pieces from the center of the board.\"\n    center_squares = [chess.E4, chess.E5, chess.D4, chess.D5]\n    distance_sum = 0\n    for square in board.piece_map():\n        piece = board.piece_at(square)\n        if piece:\n            distance_sum += min(chess.square_distance(square, cs) for cs in center_squares)\n    return float(1 / (distance_sum + 1))", "def feature(board: chess.Board) -> float:\n    'Counts the number of pieces for each player and gives a ratio of pieces on the board.'\n    white_pieces = sum(1 for p in board.piece_map().values() if p.color == chess.WHITE)\n    black_pieces = sum(1 for p in board.piece_map().values() if p.color == chess.BLACK)\n    return white_pieces / (black_pieces + 1e-6)  # Avoid division by zero", "def feature(board: chess.Board) -> float:\n    \"Calculates the material imbalance considering only qualitative piece development.\"\n    development_score = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == chess.WHITE:\n            development_score += 0.1 * (piece.piece_type + 1)  # Slightly favor developed pieces\n        else:\n            development_score -= 0.1 * (piece.piece_type + 1)\n\n    return development_score", "def feature(board: chess.Board) -> float:\n    \"Calculates the ratio of minor pieces to total pieces for each player.\"\n    white_minor = len([p for p in board.piece_map().values() if p.color == chess.WHITE and p.piece_type in (chess.KNIGHT, chess.BISHOP)])\n    black_minor = len([p for p in board.piece_map().values() if p.color == chess.BLACK and p.piece_type in (chess.KNIGHT, chess.BISHOP)])\n    total_white = len([p for p in board.piece_map().values() if p.color == chess.WHITE])\n    total_black = len([p for p in board.piece_map().values() if p.color == chess.BLACK])\n    return float((white_minor / max(1, total_white)) - (black_minor / max(1, total_black)))", "def feature(board: chess.Board) -> float:\n    \"Counts the number of supported pieces on the board.\"\n    supported_count = 0\n    for square, piece in board.piece_map().items():\n        if any(board.is_attacked_by(piece.color, support_sq) for support_sq in board.attackers(not piece.color, square)):\n            supported_count += 1\n    return float(supported_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the cumulative piece value of unprotected pieces for the current player.\"\n    piece_values = {chess.PAWN: 100, chess.KNIGHT: 320, chess.BISHOP: 330, chess.ROOK: 500, chess.QUEEN: 900}\n    unprotected_value = 0.0\n    for square, piece in board.piece_map().items():\n        if piece.color == board.turn and not any(board.is_attacked_by(not board.turn, sq) for sq in board.attackers(not board.turn, square)):\n            unprotected_value += piece_values.get(piece.piece_type, 0)\n    return unprotected_value", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pawns on the 6th and 7th ranks for each player.\"\n    white_pawns = sum(1 for sq in board.piece_map() if board.piece_at(sq).piece_type == chess.PAWN and chess.square_rank(sq) >= 6 and board.piece_at(sq).color == chess.WHITE)\n    black_pawns = sum(1 for sq in board.piece_map() if board.piece_at(sq).piece_type == chess.PAWN and chess.square_rank(sq) <= 1 and board.piece_at(sq).color == chess.BLACK)\n    return float(white_pawns - black_pawns)", "def feature(board: chess.Board) -> float:\n    \"Computes the mobility score based on the number of squares each piece can move to.\"\n    mobility_score = 0\n    for square in board.piece_map():\n        piece = board.piece_at(square)\n        if piece is not None:\n            mobility_score += len(list(board.legal_moves))\n    return float(mobility_score)", "def feature(board: chess.Board) -> float:\n    \"Measures the distance of the kings from their respective back ranks\"\n    white_king_square = next((square for square, piece in board.piece_map().items() if piece.color == chess.WHITE and piece.piece_type == chess.KING), None)\n    black_king_square = next((square for square, piece in board.piece_map().items() if piece.color == chess.BLACK and piece.piece_type == chess.KING), None)\n    distance_white = chess.square_rank(white_king_square) if white_king_square is not None else 8\n    distance_black = chess.square_rank(black_king_square) if black_king_square is not None else 8\n    return float(distance_black - distance_white)", "def feature(board: chess.Board) -> float:\n    \"Calculates the imbalance in material based on piece types.\"\n    piece_values = {\n        chess.PAWN: 100,\n        chess.KNIGHT: 320,\n        chess.BISHOP: 330,\n        chess.ROOK: 500,\n        chess.QUEEN: 900,\n        chess.KING: float('inf'),  # King shouldn't be counted\n    }\n    material_balance = 0\n    for piece in board.piece_map().values():\n        material_balance += piece_values[piece.piece_type] if piece.color == chess.WHITE else -piece_values[piece.piece_type]\n    return float(material_balance)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of hanging pieces on the board, which are undefended.\"\n    hanging_pieces = sum(1 for square, piece in board.piece_map().items() if piece.color == (chess.WHITE if board.turn else chess.BLACK) and not board.is_attacked_by(not piece.color, square))\n    return float(hanging_pieces)", "def feature(board: chess.Board) -> float:\n    \"Calculates the cumulative piece value of unprotected pieces for the current player.\"\n    piece_values = {chess.PAWN: 100, chess.KNIGHT: 320, chess.BISHOP: 330, chess.ROOK: 500, chess.QUEEN: 900}\n    unprotected_value = 0.0\n    for square, piece in board.piece_map().items():\n        if piece.color == board.turn and not any(board.is_attacked_by(not board.turn, sq) for sq in board.attackers(not board.turn, square)):\n            unprotected_value += piece_values.get(piece.piece_type, 0)\n    return unprotected_value", "def feature(board: chess.Board) -> float:\n    \"Evaluates the distribution of pawns across the ranks.\"\n    pawns = [square for square, piece in board.piece_map().items() if piece.piece_type == chess.PAWN]\n    ranks = [chess.square_rank(square) for square in pawns]\n    rank_distribution = sum(1 for rank in range(8) if rank in ranks)\n    return float(rank_distribution)", "def feature(board: chess.Board) -> float:\n    'Calculates the average distance of pieces from their home squares.'\n    home_squares = {\n        chess.WHITE: [chess.A2, chess.B2, chess.C2, chess.D2, chess.E2, chess.F2, chess.G2, chess.H2],\n        chess.BLACK: [chess.A7, chess.B7, chess.C7, chess.D7, chess.E7, chess.F7, chess.G7, chess.H7]\n    }\n    total_distance = 0\n    piece_count = 0\n    \n    for piece in board.piece_map().values():\n        square = next(sq for sq in chess.SQUARES if board.piece_at(sq) == piece)\n        home_square = home_squares[piece.color][piece.piece_type - 1]\n        total_distance += chess.square_distance(square, home_square)\n        piece_count += 1\n        \n    return total_distance / piece_count if piece_count > 0 else 0.0", "def feature(board: chess.Board) -> float:\n    \"Measures the average distance of pieces from the opponent's king.\"\n    opponent_king_square = board.king(chess.WHITE if board.turn else chess.BLACK)\n    total_distance = sum(chess.square_distance(square, opponent_king_square) \n                         for square, piece in board.piece_map().items() \n                         if piece.color == (chess.WHITE if board.turn else chess.BLACK))\n    num_pieces = len([piece for piece in board.piece_map().values() \n                      if piece.color == (chess.WHITE if board.turn else chess.BLACK)])\n    return total_distance / num_pieces if num_pieces > 0 else 0.0", "def feature(board: chess.Board) -> float:\n    \"Returns the number of pieces that are pinned by the opponent's pieces.\"\n    pinned_count = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == (chess.WHITE if board.turn else chess.BLACK):\n            for attacker in board.attackers(chess.BLACK if piece.color == chess.WHITE else chess.WHITE, square):\n                if board.piece_at(attacker) and board.is_attacked_by(piece.color, attacker):\n                    pinned_count += 1\n                    break\n    return float(pinned_count)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of protected pieces for each player.\"\n    white_protected = sum(1 for square, piece in board.piece_map().items() if piece.color == chess.WHITE and any(board.is_attacked_by(chess.BLACK, square_2) for square_2 in board.attackers(chess.WHITE, square)) == False)\n    black_protected = sum(1 for square, piece in board.piece_map().items() if piece.color == chess.BLACK and any(board.is_attacked_by(chess.WHITE, square_2) for square_2 in board.attackers(chess.BLACK, square)) == False)\n    return float(white_protected - black_protected)", "def feature(board: chess.Board) -> float:\n    \"Calculate the material imbalance between bishops and knights for current player.\"\n    bishops = sum(1 for piece in board.piece_map().values() if piece.color == board.turn and piece.piece_type == chess.BISHOP)\n    knights = sum(1 for piece in board.piece_map().values() if piece.color == board.turn and piece.piece_type == chess.KNIGHT)\n    return float(bishops - knights)", "def feature(board: chess.Board) -> float:\n    'Calculates the centralization of pieces for both players'\n    center_squares = [chess.E4, chess.E5, chess.D4, chess.D5]\n    white_center = sum(1 for square in center_squares if board.piece_at(square) and board.piece_at(square).color == chess.WHITE)\n    black_center = sum(1 for square in center_squares if board.piece_at(square) and board.piece_at(square).color == chess.BLACK)\n    return float(white_center - black_center)", "def feature(board: chess.Board) -> float:\n    \"Calculates the king safety based on the number of adjacent squares controlled by the opponent.\"\n    white_king_square = next((square for square, piece in board.piece_map().items() \n                               if piece.color == chess.WHITE and piece.piece_type == chess.KING), None)\n    black_king_square = next((square for square, piece in board.piece_map().items() \n                               if piece.color == chess.BLACK and piece.piece_type == chess.KING), None)\n    white_king_attackers = sum(1 for square in chess.SQUARES if board.is_attacked_by(chess.BLACK, square) and \n                                chess.square_distance(square, white_king_square) <= 1)\n    black_king_attackers = sum(1 for square in chess.SQUARES if board.is_attacked_by(chess.WHITE, square) and \n                                chess.square_distance(square, black_king_square) <= 1)\n    return float(black_king_attackers - white_king_attackers)", "def feature(board: chess.Board) -> float:\n    \"Measures the mobility of all pieces on the board by counting their legal moves.\"\n    total_moves = sum(len(list(board.legal_moves)) for piece in board.piece_map().values())\n    return float(total_moves)", "def feature(board: chess.Board) -> float:\n    'Calculates the average distance of pieces from their respective king positions.'\n    white_king_square = next(square for square, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color == chess.WHITE)\n    black_king_square = next(square for square, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color == chess.BLACK)\n    total_distance = 0\n    piece_count = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == chess.WHITE:\n            total_distance += chess.square_distance(square, white_king_square)\n        elif piece.color == chess.BLACK:\n            total_distance += chess.square_distance(square, black_king_square)\n        piece_count += 1\n    return float(total_distance / max(piece_count, 1))", "def feature(board: chess.Board) -> float:\n    \"Evaluates the proportion of pieces developed versus total pieces, emphasizing development.\"\n    total_pieces = sum(1 for piece in board.piece_map().values())\n    developed_pieces = sum(1 for square in range(0, 64) if board.piece_at(square) is not None and chess.square_rank(square) >= 1)  # pawns in row 2 or 7, others in row 1 or 8\n    return float(developed_pieces / total_pieces) if total_pieces > 0 else 0.0", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces that are attacking enemy squares.\"\n    attacking_pieces = sum(1 for square in board.piece_map() if board.is_attacked_by(not board.piece_at(square).color, square))\n    return float(attacking_pieces)", "def feature(board: chess.Board) -> float:\n    \"Calculates the average distance of pieces from the center of the board for the current player.\"\n    total_distance = 0\n    piece_count = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == board.turn:\n            total_distance += (chess.square_file(square) + chess.square_rank(square))\n            piece_count += 1\n    return total_distance / piece_count if piece_count > 0 else 0.0", "def feature(board: chess.Board) -> float:\n    \"Measures the material balance by counting the difference in total value of pieces\"\n    piece_values = {\n        chess.PAWN: 100,\n        chess.KNIGHT: 320,\n        chess.BISHOP: 330,\n        chess.ROOK: 500,\n        chess.QUEEN: 900,\n        chess.KING: 0,  # King value is not essential for material count\n    }\n    material_balance = 0.0\n    for piece in board.piece_map().values():\n        value = piece_values[piece.piece_type]\n        if piece.color == chess.WHITE:\n            material_balance += value\n        else:\n            material_balance -= value\n    return material_balance", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pawns on the board and gives a ratio of White to Black pawns.\"\n    white_pawns = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE and piece.piece_type == chess.PAWN)\n    black_pawns = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK and piece.piece_type == chess.PAWN)\n    return float(white_pawns) / (black_pawns + 1)  # Avoid division by zero", "def feature(board: chess.Board) -> float:\n    \"Evaluates the number of squares defended by each player.\"\n    white_defended_squares = sum(1 for square in chess.SQUARES if board.is_attacked_by(chess.WHITE, square) and board.piece_at(square) is None)\n    black_defended_squares = sum(1 for square in chess.SQUARES if board.is_attacked_by(chess.BLACK, square) and board.piece_at(square) is None)\n    return float(white_defended_squares - black_defended_squares)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of pieces that are pinned by the opponent's pieces.\"\n    pinned_pieces = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == (chess.WHITE if board.turn else chess.BLACK):\n            if any(board.is_attacked_by(not piece.color, pin_square) for pin_square in board.attackers(not piece.color, square)):\n                pinned_pieces += 1\n    return float(pinned_pieces)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces attacking the opponent's back rank.\"\n    attacking_white = sum(1 for square in chess.SQUARES if board.is_attacked_by(chess.WHITE, square) and chess.square_rank(square) == 0)\n    attacking_black = sum(1 for square in chess.SQUARES if board.is_attacked_by(chess.BLACK, square) and chess.square_rank(square) == 7)\n    return float(attacking_white - attacking_black)", "def feature(board: chess.Board) -> float:\n    \"Calculates the king safety based on the number of adjacent squares controlled by the opponent.\"\n    white_king_square = next((square for square, piece in board.piece_map().items() \n                               if piece.color == chess.WHITE and piece.piece_type == chess.KING), None)\n    black_king_square = next((square for square, piece in board.piece_map().items() \n                               if piece.color == chess.BLACK and piece.piece_type == chess.KING), None)\n    white_king_attackers = sum(1 for square in chess.SQUARES if board.is_attacked_by(chess.BLACK, square) and \n                                chess.square_distance(square, white_king_square) <= 1)\n    black_king_attackers = sum(1 for square in chess.SQUARES if board.is_attacked_by(chess.WHITE, square) and \n                                chess.square_distance(square, black_king_square) <= 1)\n    return float(black_king_attackers - white_king_attackers)", "def feature(board: chess.Board) -> float:\n    \"Calculates the total value of the opponent's pieces that are attacked.\"\n    attacked_value = 0.0\n    for square, piece in board.piece_map().items():\n        if piece.color != board.turn and board.is_attacked_by(board.turn, square):\n            attacked_value += piece.piece_type\n    return attacked_value", "def feature(board: chess.Board) -> float:\n    \"Measures the difference in control over open files by counting rooks on those files.\"\n    open_files = sum(1 for file in range(8) if not any(board.piece_at(chess.square(file, rank)) \n                                                          for rank in range(8)))\n    white_rooks_on_open_files = sum(1 for square, piece in board.piece_map().items() \n                                     if piece.color == chess.WHITE and piece.piece_type == chess.ROOK and chess.square_file(square) in range(open_files))\n    black_rooks_on_open_files = sum(1 for square, piece in board.piece_map().items() \n                                     if piece.color == chess.BLACK and piece.piece_type == chess.ROOK and chess.square_file(square) in range(open_files))\n    return float(white_rooks_on_open_files - black_rooks_on_open_files)", "def feature(board: chess.Board) -> float:\n    'Calculates the number of pieces that are currently defended by their own pieces.'\n    defenders = 0\n    for square, piece in board.piece_map().items():\n        attackers = board.attackers(piece.color, square)\n        if attackers:\n            defenders += 1\n    return defenders", "def feature(board: chess.Board) -> float:\n    \"Calculates the piece activity, defined as the number of moves each piece can make.\"\n    activity_score = 0\n    for piece in board.piece_map().values():\n        activity_score += len(list(board.legal_moves)) if piece.color == board.turn else -len(list(board.legal_moves))\n    return float(activity_score)", "def feature(board: chess.Board) -> float:\n    'Calculates the centralization of pieces for both players'\n    center_squares = [chess.E4, chess.E5, chess.D4, chess.D5]\n    white_center = sum(1 for square in center_squares if board.piece_at(square) and board.piece_at(square).color == chess.WHITE)\n    black_center = sum(1 for square in center_squares if board.piece_at(square) and board.piece_at(square).color == chess.BLACK)\n    return float(white_center - black_center)", "def feature(board: chess.Board) -> float:\n    'Measures the value of pieces that are pinned.'\n    pinned_pieces_value = sum(piece.piece_type for square, piece in board.piece_map().items() if any(board.is_attacked_by(color, square) for color in (chess.WHITE, chess.BLACK)))\n    return float(pinned_pieces_value)", "def feature(board: chess.Board) -> float:\n    \"Calculates the average distance of all pieces from the opponent's king.\"\n    opponent_king_square = next(square for square, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color != board.turn)\n    total_distance = sum(chess.square_distance(square, opponent_king_square) for square in board.piece_map() if board.piece_map()[square].color == board.turn)\n    piece_count = len([square for square in board.piece_map() if board.piece_map()[square].color == board.turn])\n    return total_distance / piece_count if piece_count > 0 else 0.0", "def feature(board: chess.Board) -> float:\n    \"Measures the potential mobility advantage by counting the legal moves available to each player.\"\n    white_legal_moves = len(list(board.legal_moves)) if board.turn else 0\n    black_legal_moves = len(list(board.legal_moves)) if not board.turn else 0\n    return float(white_legal_moves - black_legal_moves)", "def feature(board: chess.Board) -> float:\n    \"Calculates the average distance of pieces from the center of the board.\"\n    center_squares = [chess.E4, chess.D4, chess.E5, chess.D5]\n    total_distance = 0\n    piece_count = len(board.piece_map())\n    \n    for piece_square in board.piece_map():\n        total_distance += min(chess.square_distance(piece_square, center) for center in center_squares)\n    \n    return total_distance / piece_count if piece_count > 0 else 0.0", "def feature(board: chess.Board) -> float:\n    \"Measures the difference in the number of pieces that can be captured in the next move.\"\n    white_captures = sum(1 for move in board.legal_moves if board.piece_at(move.to_square) and board.piece_at(move.to_square).color == chess.BLACK)\n    black_captures = sum(1 for move in board.legal_moves if board.piece_at(move.to_square) and board.piece_at(move.to_square).color == chess.WHITE)\n    result = white_captures - black_captures\n    return float(result)", "def feature(board: chess.Board) -> float:\n    \"Measures the difference in the number of pieces that can be captured in the next move.\"\n    white_captures = sum(1 for move in board.legal_moves if board.piece_at(move.to_square) and board.piece_at(move.to_square).color == chess.BLACK)\n    black_captures = sum(1 for move in board.legal_moves if board.piece_at(move.to_square) and board.piece_at(move.to_square).color == chess.WHITE)\n    result = white_captures - black_captures\n    return float(result)", "def feature(board: chess.Board) -> float:\n    \"Measures the distance of the king(s) to their respective back rank.\"\n    def king_distance(color):\n        for square in board.piece_map():\n            piece = board.piece_at(square)\n            if piece and piece.piece_type == chess.KING and piece.color == color:\n                return 7 - chess.square_rank(square) if color == chess.WHITE else chess.square_rank(square)\n        return 0\n    \n    white_distance = king_distance(chess.WHITE)\n    black_distance = king_distance(chess.BLACK)\n    return float(white_distance - black_distance)", "def feature(board: chess.Board) -> float:\n    \"Measures the difference in the number of pieces that can be captured in the next move.\"\n    white_captures = sum(1 for move in board.legal_moves if board.piece_at(move.to_square) and board.piece_at(move.to_square).color == chess.BLACK)\n    black_captures = sum(1 for move in board.legal_moves if board.piece_at(move.to_square) and board.piece_at(move.to_square).color == chess.WHITE)\n    result = white_captures - black_captures\n    return float(result)", "def feature(board: chess.Board) -> float:\n    \"Counts pieces in the opponent's half of the board and returns the difference.\"\n    opponent_half_count = sum(1 for square, piece in board.piece_map().items() if \n                               piece.color == (chess.BLACK if board.turn == chess.WHITE else chess.WHITE) and chess.square_rank(square) >= 4)\n    return float(opponent_half_count)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of major pieces (rooks and queens) present for each side.\"\n    major_piece_value = {chess.ROOK: 1, chess.QUEEN: 1}\n    white_major_pieces = sum(major_piece_value.get(board.piece_at(square).piece_type, 0) for square in board.piece_map() if board.piece_at(square).color == chess.WHITE)\n    black_major_pieces = sum(major_piece_value.get(board.piece_at(square).piece_type, 0) for square in board.piece_map() if board.piece_at(square).color == chess.BLACK)\n    return float(white_major_pieces - black_major_pieces)", "def feature(board: chess.Board) -> float:\n    \"Calculates the mobility advantage of the player to move.\"\n    if board.turn:\n        white_moves = len(list(board.legal_moves))\n        black_board = board.copy()\n        black_board.turn = chess.BLACK\n        black_moves = len(list(black_board.legal_moves))\n    else:\n        black_moves = len(list(board.legal_moves))\n        white_board = board.copy()\n        white_board.turn = chess.WHITE\n        white_moves = len(list(white_board.legal_moves))\n    return float(white_moves - black_moves)", "def feature(board: chess.Board) -> float:\n    \"Calculates the total distance of all pieces from the opponent's back rank.\"\n    total_distance = sum(8 - chess.square_rank(square) for square in board.piece_map() if board.piece_map()[square].color == chess.WHITE)\n    return float(total_distance)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of advanced pawns for both colors and returns the difference.\"\n    white_advanced_pawns = sum(1 for square, piece in board.piece_map().items() if piece.color == chess.WHITE and chess.square_rank(square) >= 4)\n    black_advanced_pawns = sum(1 for square, piece in board.piece_map().items() if piece.color == chess.BLACK and chess.square_rank(square) <= 3)\n    return float(white_advanced_pawns - black_advanced_pawns)", "def feature(board: chess.Board) -> float:\n    \"Measures the mobility of the kings by counting available escape squares.\"\n    king_square = chess.square_name(board.king(board.turn))\n    escape_squares = board.attacks(chess.parse_square(king_square))\n    return float(len(escape_squares))", "def feature(board: chess.Board) -> float:\n    \"Calculates the total value of pinned pieces.\"\n    total_pinned_value = 0\n    for square in board.piece_map():\n        piece = board.piece_at(square)\n        if piece and board.is_attacked_by(not piece.color, square):\n            # For simplicity, we assume that a pinned piece has no legal moves\n            if not any(board.piece_at(move.to_square) for move in board.legal_moves if move.from_square == square):\n                total_pinned_value += 100 * piece.piece_type\n    return total_pinned_value", "def feature(board: chess.Board) -> float:\n    \"Calculates the ratio of knight pieces to total pieces on the board.\"\n    total_pieces = sum(1 for piece in board.piece_map().values())\n    knight_count = sum(1 for piece in board.piece_map().values() if piece.piece_type == chess.KNIGHT)\n    return float(knight_count / total_pieces) if total_pieces > 0 else 0.0", "def feature(board: chess.Board) -> float:\n    \"Calculates the ratio of pawns to total pieces for both players.\"\n    white_pawn_count = sum(1 for piece in board.piece_map().values() \n                           if piece.color == chess.WHITE and piece.piece_type == chess.PAWN)\n    black_pawn_count = sum(1 for piece in board.piece_map().values() \n                           if piece.color == chess.BLACK and piece.piece_type == chess.PAWN)\n    total_white_pieces = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE)\n    total_black_pieces = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK)\n    white_ratio = white_pawn_count / total_white_pieces if total_white_pieces > 0 else 0.0\n    black_ratio = black_pawn_count / total_black_pieces if total_black_pieces > 0 else 0.0\n    return float(white_ratio - black_ratio)", "def feature(board: chess.Board) -> float:\n    \"Checks the material imbalance based on piece types.\"\n    material_values = {chess.PAWN: 100, chess.KNIGHT: 300, chess.BISHOP: 300, chess.ROOK: 500, chess.QUEEN: 900}\n    material_balance = 0\n    for piece in board.piece_map().values():\n        color_factor = 1 if piece.color == chess.WHITE else -1\n        material_balance += color_factor * material_values.get(piece.piece_type, 0)\n    return float(material_balance)", "def feature(board: chess.Board) -> float:\n    \"Measures the average distance of pawns from the opponent's back rank.\"\n    distance_sum = 0\n    pawn_count = 0\n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.PAWN:\n            distance_sum += chess.square_rank(square) if piece.color == chess.WHITE else 7 - chess.square_rank(square)\n            pawn_count += 1\n    average_distance = distance_sum / pawn_count if pawn_count > 0 else 0\n    return float(average_distance)", "def feature(board: chess.Board) -> float:\n    \"Gives the difference in the number of pieces on squares with more than one attack (strong squares).\"\n    strong_squares_count = 0\n    for square in chess.SQUARES:\n        if len(board.attackers(chess.WHITE, square)) > 1:\n            strong_squares_count += 1\n        if len(board.attackers(chess.BLACK, square)) > 1:\n            strong_squares_count -= 1\n    return float(strong_squares_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the total value of pieces that are currently attacking enemy pieces.\"\n    attack_value = 0.0\n    for square, piece in board.piece_map().items():\n        for attacker in board.attackers(piece.color, square):\n            attack_value += piece.piece_type * (1 if piece.color == chess.WHITE else -1)\n    return attack_value", "def feature(board: chess.Board) -> float:\n    'Calculates the average distance of pieces from their home squares.'\n    home_squares = {\n        chess.WHITE: [chess.A2, chess.B2, chess.C2, chess.D2, chess.E2, chess.F2, chess.G2, chess.H2],\n        chess.BLACK: [chess.A7, chess.B7, chess.C7, chess.D7, chess.E7, chess.F7, chess.G7, chess.H7]\n    }\n    total_distance = 0\n    piece_count = 0\n    \n    for piece in board.piece_map().values():\n        square = next(sq for sq in chess.SQUARES if board.piece_at(sq) == piece)\n        home_square = home_squares[piece.color][piece.piece_type - 1]\n        total_distance += chess.square_distance(square, home_square)\n        piece_count += 1\n        \n    return total_distance / piece_count if piece_count > 0 else 0.0", "def feature(board: chess.Board) -> float:\n    \"Measures the total distance of all pieces from the center of the board.\"\n    total_distance = 0\n    for square, piece in board.piece_map().items():\n        # calculate the Manhattan distance to the center (e4/e5)\n        center_distance = chess.square_distance(square, chess.parse_square('e4')) + chess.square_distance(square, chess.parse_square('e5'))\n        total_distance += center_distance\n    return float(total_distance)", "def feature(board: chess.Board) -> float:\n    \"Calculates the distance of the closest king to the opposing player's pieces.\"\n    king_square = next((square for square in board.piece_map() if board.piece_at(square).piece_type == chess.KING), None)\n    if not king_square:\n        return 0.0\n    other_pieces = [square for square in board.piece_map() if board.piece_at(square).color != board.piece_at(king_square).color]\n    closest_distance = min(chess.square_distance(king_square, sq) for sq in other_pieces)\n    return float(closest_distance)", "def feature(board: chess.Board) -> float:\n    \"Checks for potential promotions by counting the pawns able to advance to the seventh rank.\"\n    potential_promotions = sum(1 for square in board.piece_map() if board.piece_at(square).piece_type == chess.PAWN and (square // 8 == 6 if board.piece_at(square).color == chess.WHITE else square // 8 == 1))\n    return float(potential_promotions)", "def feature(board: chess.Board) -> float:\n    \"Measures the distribution of pieces by calculating the average rank and file occupied.\"\n    total_rank = total_file = piece_count = 0\n    for square, piece in board.piece_map().items():\n        total_rank += chess.square_rank(square)\n        total_file += chess.square_file(square)\n        piece_count += 1\n    return float((total_rank + total_file) / piece_count) if piece_count > 0 else 0.0", "def feature(board: chess.Board) -> float:\n    \"Calculates the imbalance in material based on piece types.\"\n    piece_values = {\n        chess.PAWN: 100,\n        chess.KNIGHT: 320,\n        chess.BISHOP: 330,\n        chess.ROOK: 500,\n        chess.QUEEN: 900,\n        chess.KING: float('inf'),  # King shouldn't be counted\n    }\n    material_balance = 0\n    for piece in board.piece_map().values():\n        material_balance += piece_values[piece.piece_type] if piece.color == chess.WHITE else -piece_values[piece.piece_type]\n    return float(material_balance)", "def feature(board: chess.Board) -> float:\n    \"Calculates the average distance of pieces from the center of the board.\"\n    center_squares = [chess.E4, chess.D4, chess.E5, chess.D5]\n    total_distance = 0\n    piece_count = len(board.piece_map())\n    \n    for piece_square in board.piece_map():\n        total_distance += min(chess.square_distance(piece_square, center) for center in center_squares)\n    \n    return total_distance / piece_count if piece_count > 0 else 0.0", "def feature(board: chess.Board) -> float:\n    \"Calculates the material imbalance considering only qualitative piece development.\"\n    development_score = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == chess.WHITE:\n            development_score += 0.1 * (piece.piece_type + 1)  # Slightly favor developed pieces\n        else:\n            development_score -= 0.1 * (piece.piece_type + 1)\n\n    return development_score", "def feature(board: chess.Board) -> float:\n    \"Measures the distance of the kings from their respective back ranks\"\n    white_king_square = next((square for square, piece in board.piece_map().items() if piece.color == chess.WHITE and piece.piece_type == chess.KING), None)\n    black_king_square = next((square for square, piece in board.piece_map().items() if piece.color == chess.BLACK and piece.piece_type == chess.KING), None)\n    distance_white = chess.square_rank(white_king_square) if white_king_square is not None else 8\n    distance_black = chess.square_rank(black_king_square) if black_king_square is not None else 8\n    return float(distance_black - distance_white)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces attacking opponent's back rank squares.\"\n    attacking_back_rank = 0\n    back_rank_squares = [chess.A8, chess.B8, chess.C8, chess.D8, chess.E8, chess.F8, chess.G8, chess.H8]\n    for square in back_rank_squares:\n        attacking_back_rank += len(board.attackers(chess.BLACK, square))\n    return float(attacking_back_rank)", "def feature(board: chess.Board) -> float:\n    'Measures the distance of the king to the center of the board for both players.'\n    white_king_square = board.king(chess.WHITE)\n    black_king_square = board.king(chess.BLACK)\n    distance_to_center = (2 - chess.square_file(white_king_square)) + (2 - chess.square_rank(white_king_square))\n    distance_to_center += (2 - chess.square_file(black_king_square)) + (2 - chess.square_rank(black_king_square))\n    return float(distance_to_center)", "def feature(board: chess.Board) -> float:\n    \"Measures the distance of all pieces to their opponent's back rank.\"\n    total_distance = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == chess.WHITE:\n            total_distance += chess.square_rank(square)  # Distance to rank 0\n        else:\n            total_distance += 7 - chess.square_rank(square)  # Distance to rank 7\n    return float(total_distance)", "def feature(board: chess.Board) -> float:\n    \"Measures the distance of all pieces to their opponent's back rank.\"\n    total_distance = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == chess.WHITE:\n            total_distance += chess.square_rank(square)  # Distance to rank 0\n        else:\n            total_distance += 7 - chess.square_rank(square)  # Distance to rank 7\n    return float(total_distance)", "def feature(board: chess.Board) -> float:\n    \"Assesses pawn majorities by counting the number of pawns on each side of the center.\"\n    white_majority = sum(1 for square in board.piece_map() if board.piece_at(square).piece_type == chess.PAWN and chess.square_file(square) >= 4 and board.piece_at(square).color == chess.WHITE)\n    black_majority = sum(1 for square in board.piece_map() if board.piece_at(square).piece_type == chess.PAWN and chess.square_file(square) <= 3 and board.piece_at(square).color == chess.BLACK)\n    return float(white_majority - black_majority)", "def feature(board: chess.Board) -> float:\n    'Calculates the total number of squares a player is attacking but where there are no pieces.'\n    attacking_empty_squares = set()\n    for square, piece in board.piece_map().items():\n        if piece.color == board.turn:\n            for attacked_square in board.attacks(square):\n                if not board.piece_at(attacked_square):\n                    attacking_empty_squares.add(attacked_square)\n    return float(len(attacking_empty_squares))", "def feature(board: chess.Board) -> float:\n    \"Measures the number of squares available to the current player that are not attacked.\"\n    legal_moves = len(list(board.legal_moves))\n    unsafe_squares = sum(1 for square in chess.SQUARES if board.is_attacked_by(board.turn, square))\n    return float(legal_moves - unsafe_squares)", "def feature(board: chess.Board) -> float:\n    \"Measures the distance of all pieces to their opponent's back rank.\"\n    total_distance = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == chess.WHITE:\n            total_distance += chess.square_rank(square)  # Distance to rank 0\n        else:\n            total_distance += 7 - chess.square_rank(square)  # Distance to rank 7\n    return float(total_distance)", "def feature(board: chess.Board) -> float:\n    \"Measures the centralization of the king's position.\"\n    white_king_square = next(square for square, piece in board.piece_map().items() if piece.color == chess.WHITE and piece.piece_type == chess.KING)\n    black_king_square = next(square for square, piece in board.piece_map().items() if piece.color == chess.BLACK and piece.piece_type == chess.KING)\n    central_distance = chess.square_distance(white_king_square, chess.parse_square('e4')) + chess.square_distance(black_king_square, chess.parse_square('e4'))\n    return float(central_distance)", "def feature(board: chess.Board) -> float:\n    \"Estimates the potential for promotion by counting passed pawns.\"\n    white_passed = sum(1 for square in chess.SQUARES if board.piece_at(square) and board.piece_at(square).color == chess.WHITE and board.piece_at(square).piece_type == chess.PAWN and not any(board.is_attacked_by(chess.BLACK, square + 8 * i) for i in range(1, 2)))\n    black_passed = sum(1 for square in chess.SQUARES if board.piece_at(square) and board.piece_at(square).color == chess.BLACK and board.piece_at(square).piece_type == chess.PAWN and not any(board.is_attacked_by(chess.WHITE, square - 8 * i) for i in range(1, 2)))\n\n    return float(white_passed - black_passed)", "def feature(board: chess.Board) -> float:\n    \"Calculates the ratio of minor pieces to major pieces for both players.\"\n    minor_count = {chess.WHITE: 0, chess.BLACK: 0}\n    major_count = {chess.WHITE: 0, chess.BLACK: 0}\n    for piece in board.piece_map().values():\n        if piece.piece_type in [chess.KNIGHT, chess.BISHOP]:\n            minor_count[piece.color] += 1\n        elif piece.piece_type in [chess.ROOK, chess.QUEEN]:\n            major_count[piece.color] += 1\n    ratio_white = minor_count[chess.WHITE] / (major_count[chess.WHITE] + 1)  # Avoid division by zero\n    ratio_black = minor_count[chess.BLACK] / (major_count[chess.BLACK] + 1)\n    return float(ratio_white - ratio_black)", "def feature(board: chess.Board) -> float:\n    \"Measures the distribution of pieces by calculating the average rank and file occupied.\"\n    total_rank = total_file = piece_count = 0\n    for square, piece in board.piece_map().items():\n        total_rank += chess.square_rank(square)\n        total_file += chess.square_file(square)\n        piece_count += 1\n    return float((total_rank + total_file) / piece_count) if piece_count > 0 else 0.0", "def feature(board: chess.Board) -> float:\n    \"Calculates the piece activity, defined as the number of moves each piece can make.\"\n    activity_score = 0\n    for piece in board.piece_map().values():\n        activity_score += len(list(board.legal_moves)) if piece.color == board.turn else -len(list(board.legal_moves))\n    return float(activity_score)", "def feature(board: chess.Board) -> float:\n    \"Checks if there are any pieces that can capture an opponent's major piece (rook or queen).\"\n    major_piece_threat_count = 0\n    major_pieces = {chess.ROOK, chess.QUEEN}\n    for square, piece in board.piece_map().items():\n        if piece.color == board.turn and piece.piece_type in major_pieces:\n            for move in board.legal_moves:\n                if move.from_square == square and board.piece_at(move.to_square) and \\\n                   board.piece_at(move.to_square).color != piece.color and \\\n                   board.piece_at(move.to_square).piece_type in major_pieces:\n                    major_piece_threat_count += 1\n    return float(major_piece_threat_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the average distance of the player's pieces from the opponent's king.\"\n    opponent_king_square = next(square for square, piece in board.piece_map().items() if piece.color != board.turn and piece.piece_type == chess.KING)\n    distances = []\n    for square, piece in board.piece_map().items():\n        if piece.color == board.turn:\n            distances.append(chess.square_distance(square, opponent_king_square))\n    return float(sum(distances) / len(distances)) if distances else 0.0", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces for each player and gives the material ratio.\"\n    piece_values = {chess.PAWN: 100, chess.KNIGHT: 320, chess.BISHOP: 330, chess.ROOK: 500,\n                    chess.QUEEN: 900, chess.KING: 20000}\n    white_material = sum(piece_values[piece.piece_type] for piece in board.piece_map().values() if piece.color == chess.WHITE)\n    black_material = sum(piece_values[piece.piece_type] for piece in board.piece_map().values() if piece.color == chess.BLACK)\n    return float(white_material / max(1, black_material))", "def feature(board: chess.Board) -> float:\n    \"Measures the number of pieces that are pinned (unable to move without exposing the king) on each side.\"\n    def count_pinned_pieces(color):\n        pinned_count = 0\n        for square, piece in board.piece_map().items():\n            if piece.color == color:\n                for opponent_square in board.attackers(not color, square):\n                    if board.piece_at(opponent_square) and board.piece_at(opponent_square).piece_type == chess.QUEEN:\n                        pinned_count += 1\n                        break\n        return pinned_count\n\n    white_pinned = count_pinned_pieces(chess.WHITE)\n    black_pinned = count_pinned_pieces(chess.BLACK)\n    result = white_pinned - black_pinned\n    return float(result)", "def feature(board: chess.Board) -> float:\n    'Calculates the total number of squares a player is attacking but where there are no pieces.'\n    attacking_empty_squares = set()\n    for square, piece in board.piece_map().items():\n        if piece.color == board.turn:\n            for attacked_square in board.attacks(square):\n                if not board.piece_at(attacked_square):\n                    attacking_empty_squares.add(attacked_square)\n    return float(len(attacking_empty_squares))", "def feature(board: chess.Board) -> float:\n    \"Measures the total number of checks available by the current player.\"\n    check_count = sum(1 for move in board.legal_moves if board.gives_check(move))\n    return float(check_count)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of squares controlled by the current player's pieces.\"\n    controlled_squares = set()\n    for sq, piece in board.piece_map().items():\n        if piece.color == board.turn:\n            if piece.piece_type == chess.PAWN:\n                controlled_squares.add(sq + 8 if piece.color == chess.WHITE else sq - 8)\n                controlled_squares.add(sq + 7 if piece.color == chess.WHITE and chess.square_file(sq) < 7 else sq - 9)\n                controlled_squares.add(sq + 9 if piece.color == chess.WHITE and chess.square_file(sq) > 0 else sq - 7)\n            # Add logic for other pieces...\n    return float(len(controlled_squares))", "def feature(board: chess.Board) -> float:\n    \"Measures the distance of all pieces from the center of the board.\"\n    center_squares = [chess.D4, chess.D5, chess.E4, chess.E5]\n    distance_sum = sum(chess.square_distance(sq, center_sq) for sq in board.piece_map() for center_sq in center_squares)\n    return float(distance_sum)", "def feature(board: chess.Board) -> float:\n    \"Measures the total piece value of each side in relation to the center control.\"\n    piece_values = {chess.PAWN: 100, chess.KNIGHT: 320, chess.BISHOP: 330, chess.ROOK: 500, chess.QUEEN: 900, chess.KING: 20000}\n    center_control_value = 0\n    center_squares = [chess.D4, chess.E4, chess.D5, chess.E5]\n\n    for square in center_squares:\n        piece = board.piece_at(square)\n        if piece:\n            value = piece_values[piece.piece_type] if piece.color == chess.WHITE else -piece_values[piece.piece_type]\n            center_control_value += value\n\n    return float(center_control_value)", "def feature(board: chess.Board) -> float:\n    \"Calculates the total number of safe squares for the current player.\"\n    safe_square_count = sum(1 for square in chess.SQUARES \n                             if board.is_attacked_by(not board.turn, square) == False and \n                             board.piece_at(square) is None)\n    return float(safe_square_count)", "def feature(board: chess.Board) -> float:\n    \"Measures the material balance by counting the difference in total value of pieces\"\n    piece_values = {\n        chess.PAWN: 100,\n        chess.KNIGHT: 320,\n        chess.BISHOP: 330,\n        chess.ROOK: 500,\n        chess.QUEEN: 900,\n        chess.KING: 0,  # King value is not essential for material count\n    }\n    material_balance = 0.0\n    for piece in board.piece_map().values():\n        value = piece_values[piece.piece_type]\n        if piece.color == chess.WHITE:\n            material_balance += value\n        else:\n            material_balance -= value\n    return material_balance", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of pieces that are currently pinned by the opponent's pieces.\"\n    pinned_pieces = 0\n    for square in board.piece_map():\n        piece = board.piece_map()[square]\n        if piece.color == board.turn:\n            for attacker in board.attackers(not piece.color, square):\n                # Check if the attacker can attack the piece without being blocked\n                if board.piece_at(attacker) and board.piece_at(attacker).piece_type != chess.KING:\n                    pinned_pieces += 1\n                    break\n    return float(pinned_pieces)", "def feature(board: chess.Board) -> float:\n    \"Calculates the average distance of all pieces from the opponent's king.\"\n    opponent_king_square = next(square for square in board.piece_map() \n                                 if board.piece_at(square).piece_type == chess.KING and \n                                 board.piece_at(square).color != board.turn)\n    total_distance = sum(chess.square_distance(square, opponent_king_square) \n                         for square in board.piece_map() \n                         if board.piece_at(square).color == board.turn)\n    piece_count = len(list(board.piece_map().keys()))\n    return total_distance / piece_count if piece_count > 0 else 0.0", "def feature(board: chess.Board) -> float:\n    \"Calculates the sum of the distances of all pieces from the opponent's back rank.\"\n    total_distance = 0\n    opponent_color = chess.WHITE if board.turn else chess.BLACK\n    for square, piece in board.piece_map().items():\n        if piece.color == opponent_color:\n            total_distance += chess.square_distance(square, chess.square_file(0) if opponent_color == chess.WHITE else chess.square_file(7))\n    return float(total_distance)", "def feature(board: chess.Board) -> float:\n    \"Measures the control of center squares (d4, d5, e4, e5) by counting controlled squares.\"\n    center_squares = [chess.parse_square('d4'), chess.parse_square('d5'), chess.parse_square('e4'), chess.parse_square('e5')]\n    control = sum(1 for square in center_squares if board.is_attacked_by(chess.WHITE, square)) - sum(1 for square in center_squares if board.is_attacked_by(chess.BLACK, square))\n    return float(control)", "def feature(board: chess.Board) -> float:\n    \"Calculates the ratio of active pieces (those that can move) to total pieces for the current player.\"\n    active_pieces = sum(1 for move in board.legal_moves)\n    total_pieces = len(board.piece_map())\n    return active_pieces / total_pieces if total_pieces > 0 else 0.0", "def feature(board: chess.Board) -> float:\n    \"Measures the distribution of the opponent's pieces (fewer pieces on own side often indicates weakness).\"\n    opponent_pieces = sum(1 for piece in board.piece_map().values() if piece.color != board.turn)\n    own_pieces_on_front = sum(1 for square, piece in board.piece_map().items() if piece.color == board.turn and (chess.square_rank(square) > 4))\n    return float(opponent_pieces - own_pieces_on_front)", "def feature(board: chess.Board) -> float:\n    \"Checks if a player has potential checkmating patterns by counting pieces near the opponent's king.\"\n    king_square = board.king(chess.BLACK) if board.turn else board.king(chess.WHITE)\n    if king_square is None:\n        return 0.0\n    vulnerable_squares = sum(1 for sq in chess.SQUARES if board.is_attacked_by(board.turn, sq) and chess.square_distance(sq, king_square) <= 2)\n    return float(vulnerable_squares)", "def feature(board: chess.Board) -> float:\n    \"Calculates the mobility advantage of the player to move.\"\n    if board.turn:\n        white_moves = len(list(board.legal_moves))\n        black_board = board.copy()\n        black_board.turn = chess.BLACK\n        black_moves = len(list(black_board.legal_moves))\n    else:\n        black_moves = len(list(board.legal_moves))\n        white_board = board.copy()\n        white_board.turn = chess.WHITE\n        white_moves = len(list(white_board.legal_moves))\n    return float(white_moves - black_moves)", "def feature(board: chess.Board) -> float:\n    \"Scores based on the number of squares controlled by the pieces.\"\n    control_squares = len(set(move.to_square for move in board.legal_moves))\n    return float(control_squares)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of double attacked pieces (attacked by two opponent pieces).\"\n    double_attacked_count = sum(1 for square in board.piece_map() if (piece := board.piece_at(square)) and piece.color == board.turn and \n                                 len(board.attackers(not board.turn, square)) > 1)\n    return float(double_attacked_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the mobility advantage of the player to move.\"\n    if board.turn:\n        white_moves = len(list(board.legal_moves))\n        black_board = board.copy()\n        black_board.turn = chess.BLACK\n        black_moves = len(list(black_board.legal_moves))\n    else:\n        black_moves = len(list(board.legal_moves))\n        white_board = board.copy()\n        white_board.turn = chess.WHITE\n        white_moves = len(list(white_board.legal_moves))\n    return float(white_moves - black_moves)", "def feature(board: chess.Board) -> float:\n    \"Calculates the imbalance in material based on piece types.\"\n    piece_values = {\n        chess.PAWN: 100,\n        chess.KNIGHT: 320,\n        chess.BISHOP: 330,\n        chess.ROOK: 500,\n        chess.QUEEN: 900,\n        chess.KING: float('inf'),  # King shouldn't be counted\n    }\n    material_balance = 0\n    for piece in board.piece_map().values():\n        material_balance += piece_values[piece.piece_type] if piece.color == chess.WHITE else -piece_values[piece.piece_type]\n    return float(material_balance)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces that are in the opponent's territory for both players.\"\n    white_in_enemy_territory = sum(1 for square, piece in board.piece_map().items() if piece.color == chess.WHITE and chess.square_rank(square) > 4)\n    black_in_enemy_territory = sum(1 for square, piece in board.piece_map().items() if piece.color == chess.BLACK and chess.square_rank(square) < 3)\n    return float(white_in_enemy_territory - black_in_enemy_territory)", "def feature(board: chess.Board) -> float:\n    \"Measures the total number of pawns on the board.\"\n    pawns_count = sum(1 for piece in board.piece_map().values() if piece.piece_type == chess.PAWN)\n    return float(pawns_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the cumulative piece value of unprotected pieces for the current player.\"\n    piece_values = {chess.PAWN: 100, chess.KNIGHT: 320, chess.BISHOP: 330, chess.ROOK: 500, chess.QUEEN: 900}\n    unprotected_value = 0.0\n    for square, piece in board.piece_map().items():\n        if piece.color == board.turn and not any(board.is_attacked_by(not board.turn, sq) for sq in board.attackers(not board.turn, square)):\n            unprotected_value += piece_values.get(piece.piece_type, 0)\n    return unprotected_value", "def feature(board: chess.Board) -> float:\n    'Measures the value of pieces that are attacked but not defended.'\n    attacked_unprotected_value = 0\n    for square in board.piece_map():\n        piece = board.piece_at(square)\n        if piece and piece.color == board.turn and board.is_attacked_by(not board.turn, square):\n            attacked_unprotected_value += {\n                chess.PAWN: 100, chess.KNIGHT: 300, chess.BISHOP: 300,\n                chess.ROOK: 500, chess.QUEEN: 900, chess.KING: 0\n            }[piece.piece_type]\n    return float(attacked_unprotected_value)", "def feature(board: chess.Board) -> float:\n    'Counts the number of pawns that are double pawns (on the same file).'\n    pawn_files = {}\n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.PAWN:\n            file = chess.square_file(square)\n            pawn_files[file] = pawn_files.get(file, 0) + 1\n    double_pawn_count = sum(1 for count in pawn_files.values() if count > 1)\n    return float(double_pawn_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of attack opportunities for each player's pieces.\"\n    white_attacks = sum(len(board.attackers(chess.WHITE, square)) for square in board.piece_map() if board.piece_map()[square].color == chess.WHITE)\n    black_attacks = sum(len(board.attackers(chess.BLACK, square)) for square in board.piece_map() if board.piece_map()[square].color == chess.BLACK)\n    return float(white_attacks - black_attacks)", "def feature(board: chess.Board) -> float:\n    \"Measures the average distance of pieces from the opponent's king.\"\n    opponent_king_square = board.king(chess.WHITE if board.turn else chess.BLACK)\n    total_distance = sum(chess.square_distance(square, opponent_king_square) \n                         for square, piece in board.piece_map().items() \n                         if piece.color == (chess.WHITE if board.turn else chess.BLACK))\n    num_pieces = len([piece for piece in board.piece_map().values() \n                      if piece.color == (chess.WHITE if board.turn else chess.BLACK)])\n    return total_distance / num_pieces if num_pieces > 0 else 0.0", "def feature(board: chess.Board) -> float:\n    \"Measures the total number of pawns on the board.\"\n    pawns_count = sum(1 for piece in board.piece_map().values() if piece.piece_type == chess.PAWN)\n    return float(pawns_count)", "def feature(board: chess.Board) -> float:\n    'Counts the number of pieces for each player and gives a ratio of pieces on the board.'\n    white_pieces = sum(1 for p in board.piece_map().values() if p.color == chess.WHITE)\n    black_pieces = sum(1 for p in board.piece_map().values() if p.color == chess.BLACK)\n    return white_pieces / (black_pieces + 1e-6)  # Avoid division by zero", "def feature(board: chess.Board) -> float:\n    \"Measures the spatial distribution of pieces by calculating the variance of their positions.\"\n    color = chess.WHITE if board.turn else chess.BLACK\n    positions = [chess.square_file(square) + chess.square_rank(square) * 10 for square, piece in board.piece_map().items() if piece.color == color]\n    \n    if not positions:\n        return 0.0\n    \n    mean_position = sum(positions) / len(positions)\n    variance = sum((x - mean_position) ** 2 for x in positions) / len(positions)\n    return float(variance)", "def feature(board: chess.Board) -> float:\n    \"Measures the total mobility of each player by summing the number of legal moves for both sides.\"\n    white_moves = sum(1 for _ in board.legal_moves if board.turn)\n    board.turn = not board.turn\n    black_moves = sum(1 for _ in board.legal_moves if not board.turn)\n    return float(white_moves + black_moves)", "def feature(board: chess.Board) -> float:\n    'Counts the number of pieces for each player and gives a ratio of pieces on the board.'\n    white_pieces = sum(1 for p in board.piece_map().values() if p.color == chess.WHITE)\n    black_pieces = sum(1 for p in board.piece_map().values() if p.color == chess.BLACK)\n    return white_pieces / (black_pieces + 1e-6)  # Avoid division by zero", "def feature(board: chess.Board) -> float:\n    \"Calculates the sum of the distances of all pieces from their respective pawns.\"\n    total_distance = 0\n    for square, piece in board.piece_map().items():\n        if piece.piece_type != chess.PAWN:\n            pawn_squares = [s for s in board.piece_map() if board.piece_at(s).piece_type == chess.PAWN and board.piece_at(s).color == piece.color]\n            if pawn_squares:\n                closest_distance = min(chess.square_distance(square, ps) for ps in pawn_squares)\n                total_distance += closest_distance\n    return total_distance", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of squares that are currently attacked but not defended.\"\n    attacked_not_defended = 0\n    for square in chess.SQUARES:\n        if board.is_attacked_by(chess.WHITE, square) and not board.is_attacked_by(chess.BLACK, square):\n            attacked_not_defended += 1\n        elif board.is_attacked_by(chess.BLACK, square) and not board.is_attacked_by(chess.WHITE, square):\n            attacked_not_defended += 1\n    return float(attacked_not_defended)", "def feature(board: chess.Board) -> float:\n    \"Calculates how many pieces are in the back rank for both players\"\n    back_rank_count = 0\n    for rank in [0, 7]:  # 0 for White's back rank, 7 for Black's back rank\n        for file in range(8):\n            square = chess.square(file, rank)\n            if board.piece_at(square) is not None:\n                back_rank_count += 1\n    return float(back_rank_count)", "def feature(board: chess.Board) -> float:\n    \"Scores based on the number of squares controlled by the pieces.\"\n    control_squares = len(set(move.to_square for move in board.legal_moves))\n    return float(control_squares)", "def feature(board: chess.Board) -> float:\n    \"Measures the material value of pieces that are attacking opponent's pieces with no defenders.\"\n    attacking_value = 0\n    for square in board.piece_map():\n        piece = board.piece_map()[square]\n        if piece.color == board.turn:\n            for target in board.legal_moves:\n                if target.from_square == square:\n                    target_piece = board.piece_at(target.to_square)\n                    if target_piece and not any(board.is_attacked_by(not piece.color, target.to_square) for attacker in board.attackers(not piece.color, target.to_square)):\n                        attacking_value += target_piece.piece_type\n    return float(attacking_value)", "def feature(board: chess.Board) -> float:\n    \"Measures the distribution of pieces by calculating the average rank and file occupied.\"\n    total_rank = total_file = piece_count = 0\n    for square, piece in board.piece_map().items():\n        total_rank += chess.square_rank(square)\n        total_file += chess.square_file(square)\n        piece_count += 1\n    return float((total_rank + total_file) / piece_count) if piece_count > 0 else 0.0", "def feature(board: chess.Board) -> float:\n    \"Evaluates the number of isolated pawns for both players.\"\n    white_isolated = sum(1 for square in board.piece_map() if board.piece_at(square).color == chess.WHITE and\n                         board.piece_at(square).piece_type == chess.PAWN and\n                         not any(board.piece_at(chess.parse_square(chess.square_name(square + offset))) for offset in [-1, 1] if 0 <= chess.square_file(square + offset) < 8))\n    black_isolated = sum(1 for square in board.piece_map() if board.piece_at(square).color == chess.BLACK and\n                         board.piece_at(square).piece_type == chess.PAWN and\n                         not any(board.piece_at(chess.parse_square(chess.square_name(square + offset))) for offset in [-1, 1] if 0 <= chess.square_file(square + offset) < 8))\n    return float(white_isolated - black_isolated)", "def feature(board: chess.Board) -> float:\n    \"Calculates the distance from each pawn to the opponent's back rank.\"\n    distance_sum = 0\n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.PAWN:\n            target_rank = 0 if piece.color == chess.WHITE else 7\n            distance_sum += chess.square_rank(square) - target_rank\n    return float(distance_sum)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pinned pieces for both players.\"\n    pinned_white = sum(1 for square, piece in board.piece_map().items() if piece.color == chess.WHITE and is_pinned(board, square))\n    pinned_black = sum(1 for square, piece in board.piece_map().items() if piece.color == chess.BLACK and is_pinned(board, square))\n    return float(pinned_white - pinned_black)\n\ndef is_pinned(board: chess.Board, square: int) -> bool:\n    \"Determines if a piece is pinned against the king.\"\n    piece = board.piece_at(square)\n    if piece is None or piece.piece_type == chess.KING:\n        return False\n    \n    king_square = next((sq for sq, p in board.piece_map().items() if p.piece_type == chess.KING and p.color == piece.color), None)\n    return board.is_attacked_by(not piece.color, square) and not board.is_attacked_by(piece.color, king_square)", "def feature(board: chess.Board) -> float:\n    \"Measures the dynamic potential by counting the number of pieces that can make immediate threats.\"\n    threats = sum(1 for move in board.legal_moves if board.is_attacked_by(not board.turn, move.to_square))\n    return float(threats)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of pieces directly controlling the central squares.\"\n    central_squares = [chess.D4, chess.D5, chess.E4, chess.E5]\n    control_count = sum(1 for square in central_squares if any(board.is_attacked_by(piece.color, square) for piece in board.piece_map().values()))\n    return float(control_count)", "def feature(board: chess.Board) -> float:\n    \"Measures the material balance by counting the difference in total value of pieces\"\n    piece_values = {\n        chess.PAWN: 100,\n        chess.KNIGHT: 320,\n        chess.BISHOP: 330,\n        chess.ROOK: 500,\n        chess.QUEEN: 900,\n        chess.KING: 0,  # King value is not essential for material count\n    }\n    material_balance = 0.0\n    for piece in board.piece_map().values():\n        value = piece_values[piece.piece_type]\n        if piece.color == chess.WHITE:\n            material_balance += value\n        else:\n            material_balance -= value\n    return material_balance", "def feature(board: chess.Board) -> float:\n    \"Counts the number of advanced pawns (pawns on ranks 5 or 6 for White and 3 or 4 for Black).\"\n    advanced_pawns = sum(1 for square, piece in board.piece_map().items() if piece.piece_type == chess.PAWN and \n                         ((piece.color == chess.WHITE and chess.square_rank(square) in [5, 6]) or \n                          (piece.color == chess.BLACK and chess.square_rank(square) in [3, 4])))\n    return float(advanced_pawns)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces controlled by the player that are in enemy territory.\"\n    controlled_in_enemy_territory = 0\n    for sq, piece in board.piece_map().items():\n        if piece.color == board.turn and chess.square_rank(sq) > 4:  # Past the 4th rank for White\n            controlled_in_enemy_territory += 1\n    return float(controlled_in_enemy_territory)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of advanced pawns (pawns on ranks 4 or 5 for White and 4 or 3 for Black)\"\n    advanced_pawns = 0\n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.PAWN:\n            if (piece.color == chess.WHITE and chess.square_rank(square) >= 4) or \\\n               (piece.color == chess.BLACK and chess.square_rank(square) <= 4):\n                advanced_pawns += 1\n    return float(advanced_pawns)", "def feature(board: chess.Board) -> float:\n    \"Calculates the average rank of all pieces for both players.\"\n    total_rank = 0\n    piece_count = 0\n    for square, piece in board.piece_map().items():\n        total_rank += chess.square_rank(square)\n        piece_count += 1\n    return float(total_rank / piece_count) if piece_count > 0 else 0.0", "def feature(board: chess.Board) -> float:\n    \"Measures the total number of checks available by the current player.\"\n    check_count = sum(1 for move in board.legal_moves if board.gives_check(move))\n    return float(check_count)", "def feature(board: chess.Board) -> float:\n    \"Measures the total number of attacks on kings and their proximity to attackers.\"\n    white_attackers = sum(1 for sq in board.attackers(chess.WHITE, next((sq for sq in board.piece_map() if board.piece_map()[sq].piece_type == chess.KING and board.piece_map()[sq].color == chess.WHITE), None)) if board.is_attacked_by(chess.BLACK, sq))\n    black_attackers = sum(1 for sq in board.attackers(chess.BLACK, next((sq for sq in board.piece_map() if board.piece_map()[sq].piece_type == chess.KING and board.piece_map()[sq].color == chess.BLACK), None)) if board.is_attacked_by(chess.WHITE, sq))\n    return float(white_attackers - black_attackers)", "def feature(board: chess.Board) -> float:\n    \"Measures the total number of checks available by the current player.\"\n    check_count = sum(1 for move in board.legal_moves if board.gives_check(move))\n    return float(check_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the average distance of pieces from the center of the board.\"\n    center_squares = [chess.E4, chess.D4, chess.E5, chess.D5]\n    total_distance = 0\n    piece_count = len(board.piece_map())\n    \n    for piece_square in board.piece_map():\n        total_distance += min(chess.square_distance(piece_square, center) for center in center_squares)\n    \n    return total_distance / piece_count if piece_count > 0 else 0.0", "def feature(board: chess.Board) -> float:\n    \"Counts the number of knights on the board and checks if they are centralized (e.g., on squares D4, D5, E4, E5).\"\n    knight_positions = [chess.D4, chess.D5, chess.E4, chess.E5]\n    knight_count = sum(1 for square in board.piece_map() if (board.piece_at(square).piece_type == chess.KNIGHT and \n                                                              square in knight_positions))\n    return float(knight_count)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces on the 7th rank for each player and returns the difference.\"\n    white_7th_rank = sum(1 for square in chess.SQUARES if board.piece_at(square) and \n                         board.piece_at(square).color == chess.WHITE and chess.square_rank(square) == 6)\n    black_7th_rank = sum(1 for square in chess.SQUARES if board.piece_at(square) and \n                         board.piece_at(square).color == chess.BLACK and chess.square_rank(square) == 6)\n    return float(white_7th_rank - black_7th_rank)", "def feature(board: chess.Board) -> float:\n    \"Measures the material value of pieces that are attacking opponent's pieces with no defenders.\"\n    attacking_value = 0\n    for square in board.piece_map():\n        piece = board.piece_map()[square]\n        if piece.color == board.turn:\n            for target in board.legal_moves:\n                if target.from_square == square:\n                    target_piece = board.piece_at(target.to_square)\n                    if target_piece and not any(board.is_attacked_by(not piece.color, target.to_square) for attacker in board.attackers(not piece.color, target.to_square)):\n                        attacking_value += target_piece.piece_type\n    return float(attacking_value)", "def feature(board: chess.Board) -> float:\n    \"Measures the material value of pieces that are attacking opponent's pieces with no defenders.\"\n    attacking_value = 0\n    for square in board.piece_map():\n        piece = board.piece_map()[square]\n        if piece.color == board.turn:\n            for target in board.legal_moves:\n                if target.from_square == square:\n                    target_piece = board.piece_at(target.to_square)\n                    if target_piece and not any(board.is_attacked_by(not piece.color, target.to_square) for attacker in board.attackers(not piece.color, target.to_square)):\n                        attacking_value += target_piece.piece_type\n    return float(attacking_value)", "def feature(board: chess.Board) -> float:\n    \"Calculates the average distance of all pieces from the center of the board (d4, e4, d5, e5).\"\n    center_squares = [chess.parse_square('d4'), chess.parse_square('e4'), chess.parse_square('d5'), chess.parse_square('e5')]\n    total_distance = sum(chess.square_distance(square, center) for square in board.piece_map() for center in center_squares)\n    piece_count = len(board.piece_map())\n    return float(total_distance / piece_count) if piece_count > 0 else 0.0", "def feature(board: chess.Board) -> float:\n    \"Measures the total number of checks available by the current player.\"\n    check_count = sum(1 for move in board.legal_moves if board.gives_check(move))\n    return float(check_count)", "def feature(board: chess.Board) -> float:\n    \"Measures the total number of checks available by the current player.\"\n    check_count = sum(1 for move in board.legal_moves if board.gives_check(move))\n    return float(check_count)", "def feature(board: chess.Board) -> float:\n    \"Computes the ratio of rooks on open files for both players.\"\n    open_file_count_white = sum(1 for file in range(8) if not any(board.piece_at(chess.square(file, rank)) is not None for rank in range(8)))\n    open_file_count_black = sum(1 for file in range(8) if not any(board.piece_at(chess.square(file, rank)) is not None for rank in range(0, 4)))\n    total_rooks_white = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE and piece.piece_type == chess.ROOK)\n    total_rooks_black = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK and piece.piece_type == chess.ROOK)\n    \n    result = (open_file_count_white / (total_rooks_white + 1)) - (open_file_count_black / (total_rooks_black + 1))\n    return result", "def feature(board: chess.Board) -> float:\n    \"Measures the total distance of all pieces from their respective home ranks.\"\n    white_distance = sum(chess.square_rank(sq) for sq, piece in board.piece_map().items() if piece.color == chess.WHITE)\n    black_distance = sum(7 - chess.square_rank(sq) for sq, piece in board.piece_map().items() if piece.color == chess.BLACK)\n    return float(white_distance - black_distance)", "def feature(board: chess.Board) -> float:\n    \"Calculates the average distance of all pieces from their opponent's back rank to assess offensive potential.\"\n    white_avg_distance = sum(chess.square_rank(sq) for sq in board.piece_map() if board.piece_at(sq).color == chess.WHITE) / len([1 for sq in board.piece_map() if board.piece_at(sq).color == chess.WHITE])\n    black_avg_distance = sum(7 - chess.square_rank(sq) for sq in board.piece_map() if board.piece_at(sq).color == chess.BLACK) / len([1 for sq in board.piece_map() if board.piece_at(sq).color == chess.BLACK])\n    result = white_avg_distance - black_avg_distance\n    return float(result)", "def feature(board: chess.Board) -> float:\n    \"Calculates the average rank of all pawns for each player.\"\n    white_pawn_ranks = [chess.square_rank(sq) for sq, piece in board.piece_map().items() if piece.piece_type == chess.PAWN and piece.color == chess.WHITE]\n    black_pawn_ranks = [chess.square_rank(sq) for sq, piece in board.piece_map().items() if piece.piece_type == chess.PAWN and piece.color == chess.BLACK]\n    \n    avg_white_rank = sum(white_pawn_ranks) / len(white_pawn_ranks) if white_pawn_ranks else 0\n    avg_black_rank = sum(black_pawn_ranks) / len(black_pawn_ranks) if black_pawn_ranks else 0\n    \n    return float(avg_white_rank - avg_black_rank)", "def feature(board: chess.Board) -> float:\n    \"Measures the total number of checks available by the current player.\"\n    check_count = sum(1 for move in board.legal_moves if board.gives_check(move))\n    return float(check_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the mobility of the player whose turn it is, based on the number of legal moves.\"\n    mobility = len(list(board.legal_moves))\n    return float(mobility)", "def feature(board: chess.Board) -> float:\n    \"Evaluates the distribution of pawns on the board, with a focus on pawn structure.\"\n    pawn_structure_score = 0\n    for file in range(8):\n        file_pawns_count = sum(1 for rank in range(8) if board.piece_at(chess.square(file, rank)) and board.piece_at(chess.square(file, rank)).piece_type == chess.PAWN)\n        if file_pawns_count > 0:\n            pawn_structure_score += 1 / (file_pawns_count + 1)  # Less pawns in a file gives a higher score, promoting better structure.\n    return float(pawn_structure_score)", "def feature(board: chess.Board) -> float:\n    \"Calculates the ratio of pieces to pawns for each player.\"\n    total_pieces_white = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE)\n    total_pawns_white = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE and piece.piece_type == chess.PAWN)\n    total_pieces_black = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK)\n    total_pawns_black = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK and piece.piece_type == chess.PAWN)\n\n    ratio_white = total_pieces_white / (total_pawns_white + 1e-5)\n    ratio_black = total_pieces_black / (total_pawns_black + 1e-5)\n    \n    return float(ratio_white - ratio_black)", "def feature(board: chess.Board) -> float:\n    \"Calculates the mobility of the player whose turn it is, based on the number of legal moves.\"\n    mobility = len(list(board.legal_moves))\n    return float(mobility)", "def feature(board: chess.Board) -> float:\n    \"Measures the distance of the pieces to the opponent's back rank.\"\n    distance_sum = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == chess.WHITE:\n            distance_sum += (7 - chess.square_rank(square))  # Closer to rank 0\n        else:\n            distance_sum -= (chess.square_rank(square))  # Closer to rank 7\n    return float(distance_sum)", "def feature(board: chess.Board) -> float:\n    \"Calculates the mobility advantage of the player to move.\"\n    if board.turn:\n        white_moves = len(list(board.legal_moves))\n        black_board = board.copy()\n        black_board.turn = chess.BLACK\n        black_moves = len(list(black_board.legal_moves))\n    else:\n        black_moves = len(list(board.legal_moves))\n        white_board = board.copy()\n        white_board.turn = chess.WHITE\n        white_moves = len(list(white_board.legal_moves))\n    return float(white_moves - black_moves)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of double pawns for the current player.\"\n    double_pawns = 0\n    pawns = [square for square, piece in board.piece_map().items() if piece.color == board.turn and piece.piece_type == chess.PAWN]\n    files = {}\n    for pawn in pawns:\n        file = chess.square_file(pawn)\n        if file in files:\n            files[file] += 1\n        else:\n            files[file] = 1\n    for count in files.values():\n        if count > 1:\n            double_pawns += count - 1\n    return float(double_pawns)", "def feature(board: chess.Board) -> float:\n    \"Measures the overall safety of the kings by counting the squares they control.\"\n    white_king_safety = len(board.attackers(chess.BLACK, chess.parse_square('e1')))  # King on e1 for White\n    black_king_safety = len(board.attackers(chess.WHITE, chess.parse_square('e8')))  # King on e8 for Black\n    return float(white_king_safety - black_king_safety)", "def feature(board: chess.Board) -> float:\n    \"Calculates the sum of piece values for the player to move.\"\n    piece_values = {chess.PAWN: 100, chess.KNIGHT: 320, chess.BISHOP: 330, chess.ROOK: 500, chess.QUEEN: 900, chess.KING: 20000}\n    total_value = sum(piece_values[piece.piece_type] for piece in board.piece_map().values() if piece.color == board.turn)\n    return float(total_value)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of squares that pawn pieces can advance to.\"\n    advanceable_squares = 0\n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.PAWN:\n            if piece.color == chess.WHITE:\n                advance_squares = [square + 8, square + 16] if chess.square_rank(square) == 1 else [square + 8]\n            else:\n                advance_squares = [square - 8, square - 16] if chess.square_rank(square) == 6 else [square - 8]\n            advanceable_squares += sum(1 for sq in advance_squares if 0 <= sq < 64 and board.piece_at(sq) is None)\n    return float(advanceable_squares)", "def feature(board: chess.Board) -> float:\n    \"Assesses pawn majorities by counting the number of pawns on each side of the center.\"\n    white_majority = sum(1 for square in board.piece_map() if board.piece_at(square).piece_type == chess.PAWN and chess.square_file(square) >= 4 and board.piece_at(square).color == chess.WHITE)\n    black_majority = sum(1 for square in board.piece_map() if board.piece_at(square).piece_type == chess.PAWN and chess.square_file(square) <= 3 and board.piece_at(square).color == chess.BLACK)\n    return float(white_majority - black_majority)", "def feature(board: chess.Board) -> float:\n    \"Measures the total distance of pieces from their optimal squares based on piece type.\"\n    optimal_positions = {\n        chess.PAWN: [chess.A7, chess.B7, chess.C7, chess.D7, chess.E7, chess.F7, chess.G7, chess.H7],\n        chess.ROOK: [chess.A8, chess.H8],\n        chess.KNIGHT: [chess.B8, chess.G8],\n        chess.BISHOP: [chess.C8, chess.F8],\n        chess.QUEEN: [chess.D8],\n        chess.KING: [chess.E8]\n    }\n    total_distance = 0\n    for sq, piece in board.piece_map().items():\n        optimal = optimal_positions.get(piece.piece_type, [])\n        distances = [chess.square_distance(sq, opt) for opt in optimal]\n        total_distance += min(distances, default=0)\n    return float(total_distance)", "def feature(board: chess.Board) -> float:\n    \"Calculates the sum of the distances of all pieces from the opponent's back rank.\"\n    total_distance = 0\n    opponent_color = chess.WHITE if board.turn else chess.BLACK\n    for square, piece in board.piece_map().items():\n        if piece.color == opponent_color:\n            total_distance += chess.square_distance(square, chess.square_file(0) if opponent_color == chess.WHITE else chess.square_file(7))\n    return float(total_distance)", "def feature(board: chess.Board) -> float:\n    \"Calculates the distance of the kings from the center of the board.\"\n    white_king_square = next((square for square, piece in board.piece_map().items() if piece.color == chess.WHITE and piece.piece_type == chess.KING), None)\n    black_king_square = next((square for square, piece in board.piece_map().items() if piece.color == chess.BLACK and piece.piece_type == chess.KING), None)\n    if white_king_square is None or black_king_square is None:\n        return 0.0\n    white_distance = chess.square_distance(white_king_square, chess.E4) + chess.square_distance(white_king_square, chess.E5)\n    black_distance = chess.square_distance(black_king_square, chess.E4) + chess.square_distance(black_king_square, chess.E5)\n    return float(white_distance + black_distance)", "def feature(board: chess.Board) -> float:\n    \"Measures king safety by counting the number of squares the king can escape to.\"\n    king_square = next((square for square in board.piece_map() if board.piece_at(square).piece_type == chess.KING and board.piece_at(square).color == board.turn), None)\n    if king_square is None:\n        return 0.0\n    escape_squares = sum(1 for move in board.legal_moves if move.from_square == king_square)\n    return float(escape_squares)", "def feature(board: chess.Board) -> float:\n    \"Calculates the ratio of pieces in the opponent's half of the board.\"\n    white_pieces_in_enemy_half = sum(1 for sq, piece in board.piece_map().items() if piece.color == chess.WHITE and chess.square_rank(sq) >= 4)\n    black_pieces_in_enemy_half = sum(1 for sq, piece in board.piece_map().items() if piece.color == chess.BLACK and chess.square_rank(sq) <= 3)\n    total_pieces = len(board.piece_map())\n    if total_pieces == 0:\n        return 0.0\n    result = (white_pieces_in_enemy_half - black_pieces_in_enemy_half) / total_pieces\n    return result", "def feature(board: chess.Board) -> float:\n    \"Counts the number of squares each side has available to their king, contributing to king safety.\"\n    white_king_square = next((s for s, p in board.piece_map().items() if p.color == chess.WHITE and p.piece_type == chess.KING), None)\n    black_king_square = next((s for s, p in board.piece_map().items() if p.color == chess.BLACK and p.piece_type == chess.KING), None)\n    \n    def count_king_squares(king_square):\n        if king_square is None:\n            return 0\n        return sum(1 for move in chess.SQUARES if board.is_legal(chess.Move(king_square, move)))\n\n    return float(count_king_squares(white_king_square) - count_king_squares(black_king_square))", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of isolated pawns for the current player.\"\n    isolated_count = 0\n    for square in board.piece_map().keys():\n        piece = board.piece_at(square)\n        if piece is not None and piece.color == board.turn and piece.piece_type == chess.PAWN:\n            file = chess.square_file(square)\n            if (board.piece_at(chess.square(file - 1, chess.square_rank(square))) is None and\n                    board.piece_at(chess.square(file + 1, chess.square_rank(square))) is None):\n                isolated_count += 1\n    return float(isolated_count)", "def feature(board: chess.Board) -> float:\n    \"Measures the distribution of pieces by calculating the average rank and file occupied.\"\n    total_rank = total_file = piece_count = 0\n    for square, piece in board.piece_map().items():\n        total_rank += chess.square_rank(square)\n        total_file += chess.square_file(square)\n        piece_count += 1\n    return float((total_rank + total_file) / piece_count) if piece_count > 0 else 0.0", "def feature(board: chess.Board) -> float:\n    \"Calculates the king safety by counting the number of squares around the king that are attacked.\"\n    king_square = next((sq for sq, p in board.piece_map().items() if p.piece_type == chess.KING and p.color == board.turn), None)\n    if king_square is None:\n        return 0.0  # If no king is found, return neutral safety\n    attacked_squares_around_king = sum(1 for offset in [-1, 0, 1] for offset2 in [-1, 0, 1] if (offset != 0 or offset2 != 0) and \n                                          0 <= chess.square_rank(king_square) + offset < 8 and \n                                          0 <= chess.square_file(king_square) + offset2 < 8 and \n                                          board.is_attacked_by(not board.turn, chess.square(king_square // 8 + offset, king_square % 8 + offset2)))\n    return float(attacked_squares_around_king)", "def feature(board: chess.Board) -> float:\n    \"Calculates the distance in ranks between the kings to assess king safety.\"\n    white_king = board.king(chess.WHITE)\n    black_king = board.king(chess.BLACK)\n    if white_king is not None and black_king is not None:\n        distance = chess.square_rank(white_king) - chess.square_rank(black_king)\n        return float(abs(distance))\n    return 0.0", "def feature(board: chess.Board) -> float:\n    \"Calculates the ratio of major pieces (rooks and queens) to minor pieces (knights and bishops) on the board.\"\n    major_count = sum(1 for piece in board.piece_map().values() if piece.piece_type in {chess.ROOK, chess.QUEEN})\n    minor_count = sum(1 for piece in board.piece_map().values() if piece.piece_type in {chess.KNIGHT, chess.BISHOP})\n    return float(major_count) / (minor_count + 1)  # Adding 1 to avoid division by zero", "def feature(board: chess.Board) -> float:\n    'Counts the number of pawns that are double pawns (on the same file).'\n    pawn_files = {}\n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.PAWN:\n            file = chess.square_file(square)\n            pawn_files[file] = pawn_files.get(file, 0) + 1\n    double_pawn_count = sum(1 for count in pawn_files.values() if count > 1)\n    return float(double_pawn_count)", "def feature(board: chess.Board) -> float:\n    'Calculates the number of pieces that are currently defended by their own pieces.'\n    defenders = 0\n    for square, piece in board.piece_map().items():\n        attackers = board.attackers(piece.color, square)\n        if attackers:\n            defenders += 1\n    return defenders", "def feature(board: chess.Board) -> float:\n    \"Measures the sum of distances of all pieces of the current player to the opponent's king.\"\n    opponent_king_square = next((sq for sq, piece in board.piece_map().items() \n                                   if piece.color != board.turn and piece.piece_type == chess.KING), None)\n    total_distance = sum(chess.square_distance(square, opponent_king_square) for square in board.piece_map()\n                         if board.piece_map()[square].color == board.turn)\n    return float(total_distance)", "def feature(board: chess.Board) -> float:\n    'Measures the distance of the king to the center of the board for both players.'\n    white_king_square = board.king(chess.WHITE)\n    black_king_square = board.king(chess.BLACK)\n    distance_to_center = (2 - chess.square_file(white_king_square)) + (2 - chess.square_rank(white_king_square))\n    distance_to_center += (2 - chess.square_file(black_king_square)) + (2 - chess.square_rank(black_king_square))\n    return float(distance_to_center)", "def feature(board: chess.Board) -> float:\n    'Calculates the average distance of pieces from their respective king positions.'\n    white_king_square = next(square for square, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color == chess.WHITE)\n    black_king_square = next(square for square, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color == chess.BLACK)\n    total_distance = 0\n    piece_count = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == chess.WHITE:\n            total_distance += chess.square_distance(square, white_king_square)\n        elif piece.color == chess.BLACK:\n            total_distance += chess.square_distance(square, black_king_square)\n        piece_count += 1\n    return float(total_distance / max(piece_count, 1))", "def feature(board: chess.Board) -> float:\n    \"Measures the total number of knight jumps possible for both players.\"\n    knight_moves = {chess.KNIGHT: 0}\n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.KNIGHT:\n            knight_moves[chess.KNIGHT] += len(list(board.legal_moves))\n    return float(knight_moves[chess.KNIGHT])", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of attack opportunities for each player's pieces.\"\n    white_attacks = sum(len(board.attackers(chess.WHITE, square)) for square in board.piece_map() if board.piece_map()[square].color == chess.WHITE)\n    black_attacks = sum(len(board.attackers(chess.BLACK, square)) for square in board.piece_map() if board.piece_map()[square].color == chess.BLACK)\n    return float(white_attacks - black_attacks)", "def feature(board: chess.Board) -> float:\n    \"Calculates the average distance of all pieces from their starting positions.\"\n    total_distance = 0\n    piece_count = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == board.turn:\n            piece_count += 1\n            start_square = chess.parse_square('a1') if piece.piece_type == chess.PAWN else chess.parse_square('e1' if piece.color == chess.WHITE else 'e8')\n            total_distance += chess.square_distance(square, start_square)\n    return total_distance / piece_count if piece_count > 0 else 0.0", "def feature(board: chess.Board) -> float:\n    \"Measures the distance of kings to the center of the board for both players.\"\n    white_king_square = chess.square_name(board.king(chess.WHITE))\n    black_king_square = chess.square_name(board.king(chess.BLACK))\n    white_king_distance = (chess.square_file(board.king(chess.WHITE)) - 3)**2 + (chess.square_rank(board.king(chess.WHITE)) - 3)**2\n    black_king_distance = (chess.square_file(board.king(chess.BLACK)) - 3)**2 + (chess.square_rank(board.king(chess.BLACK)) - 3)**2\n    return float(black_king_distance - white_king_distance)", "def feature(board: chess.Board) -> float:\n    \"Calculates the average distance of all pieces from their opponent's back rank to assess offensive potential.\"\n    white_avg_distance = sum(chess.square_rank(sq) for sq in board.piece_map() if board.piece_at(sq).color == chess.WHITE) / len([1 for sq in board.piece_map() if board.piece_at(sq).color == chess.WHITE])\n    black_avg_distance = sum(7 - chess.square_rank(sq) for sq in board.piece_map() if board.piece_at(sq).color == chess.BLACK) / len([1 for sq in board.piece_map() if board.piece_at(sq).color == chess.BLACK])\n    result = white_avg_distance - black_avg_distance\n    return float(result)", "def feature(board: chess.Board) -> float:\n    \"Measures the distance of the king from the center of the board, penalizing distant king positions.\"\n    king_square = next(square for square in board.piece_map() if board.piece_at(square).piece_type == chess.KING and board.piece_at(square).color == board.turn)\n    center_squares = [chess.square_name(square) for square in [chess.D4, chess.D5, chess.E4, chess.E5]]\n    return float(chess.square_distance(king_square, chess.D4) + chess.square_distance(king_square, chess.D5) + \n                 chess.square_distance(king_square, chess.E4) + chess.square_distance(king_square, chess.E5))", "def feature(board: chess.Board) -> float:\n    \"Calculates the total number of squares each player's pieces control.\"\n    white_control = sum(len(board.attacks(square)) for square in board.piece_map() if board.piece_at(square).color == chess.WHITE)\n    black_control = sum(len(board.attacks(square)) for square in board.piece_map() if board.piece_at(square).color == chess.BLACK)\n    return float(white_control - black_control)", "def feature(board: chess.Board) -> float:\n    'Measures the distance of the king to the center of the board for both players.'\n    white_king_square = board.king(chess.WHITE)\n    black_king_square = board.king(chess.BLACK)\n    distance_to_center = (2 - chess.square_file(white_king_square)) + (2 - chess.square_rank(white_king_square))\n    distance_to_center += (2 - chess.square_file(black_king_square)) + (2 - chess.square_rank(black_king_square))\n    return float(distance_to_center)", "def feature(board: chess.Board) -> float:\n    'Measures the value of pieces that are pinned.'\n    pinned_pieces_value = sum(piece.piece_type for square, piece in board.piece_map().items() if any(board.is_attacked_by(color, square) for color in (chess.WHITE, chess.BLACK)))\n    return float(pinned_pieces_value)", "def feature(board: chess.Board) -> float:\n    \"Evaluates the king distance from the center of the board (central squares).\"\n    central_squares = [chess.E4, chess.E5, chess.D4, chess.D5]\n    white_king = board.king(chess.WHITE)\n    black_king = board.king(chess.BLACK)\n    white_distance = min(chess.square_distance(white_king, sq) for sq in central_squares)\n    black_distance = min(chess.square_distance(black_king, sq) for sq in central_squares)\n    return float(black_distance - white_distance)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of advanced pawns (pawns on ranks 4 or 5 for White and 4 or 3 for Black)\"\n    advanced_pawns = 0\n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.PAWN:\n            if (piece.color == chess.WHITE and chess.square_rank(square) >= 4) or \\\n               (piece.color == chess.BLACK and chess.square_rank(square) <= 4):\n                advanced_pawns += 1\n    return float(advanced_pawns)", "def feature(board: chess.Board) -> float:\n    \"Measures the average distance of pawns from the opponent's back rank.\"\n    distance_sum = 0\n    pawn_count = 0\n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.PAWN:\n            distance_sum += chess.square_rank(square) if piece.color == chess.WHITE else 7 - chess.square_rank(square)\n            pawn_count += 1\n    average_distance = distance_sum / pawn_count if pawn_count > 0 else 0\n    return float(average_distance)", "def feature(board: chess.Board) -> float:\n    'Evaluates the number of rooks on open files for both players, which can indicate control of the board.'\n    open_file_count = 0\n    for file in range(8):\n        if all(board.piece_at(chess.square(file, rank)) is None or board.piece_at(chess.square(file, rank)).piece_type == chess.ROOK for rank in range(8)):\n            open_file_count += 1\n    return float(open_file_count)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of squares controlled by the player's pieces that are adjacent to the opponent's king.\"\n    opponent_king = board.king(not board.turn)\n    controlled_squares = set()\n    if opponent_king is None:\n        return 0.0\n    for square in chess.SQUARES:\n        piece = board.piece_at(square)\n        if piece and piece.color == board.turn:\n            controlled_squares.update(board.attacks(square))\n    adjacent_squares = [s for s in chess.SQUARES if chess.square_distance(s, opponent_king) == 1]\n    return float(len(set(adjacent_squares) & controlled_squares))", "def feature(board: chess.Board) -> float:\n    \"Measures the number of pieces that are in positions to control the center squares.\"\n    center_control = 0\n    center_squares = [chess.E4, chess.E5, chess.D4, chess.D5]\n    for square in center_squares:\n        attackers_white = board.attackers(chess.WHITE, square)\n        attackers_black = board.attackers(chess.BLACK, square)\n        center_control += len(attackers_white) - len(attackers_black)\n    return float(center_control)", "def feature(board: chess.Board) -> float:\n    \"Calculates the total piece square advantage for the current player\"\n    piece_values = {chess.PAWN: 100, chess.KNIGHT: 300, chess.BISHOP: 300, chess.ROOK: 500, chess.QUEEN: 900, chess.KING: 2000}\n    advantage = 0\n    for square, piece in board.piece_map().items():\n        value = piece_values.get(piece.piece_type, 0)\n        if piece.color == board.turn:\n            advantage += value * (8 - chess.square_rank(square))  # pieces in higher ranks are more valuable\n        else:\n            advantage -= value * (8 - chess.square_rank(square))\n    return float(advantage)", "def feature(board: chess.Board) -> float:\n    'Measures the total number of pieces attacking key squares (central squares).'\n    center_squares = [chess.D4, chess.D5, chess.E4, chess.E5]\n    attackers = sum(len(board.attackers(color, sq)) for color in [chess.WHITE, chess.BLACK] for sq in center_squares)\n    return float(attackers)", "def feature(board: chess.Board) -> float:\n    'Calculates the number of pieces that are currently defended by their own pieces.'\n    defenders = 0\n    for square, piece in board.piece_map().items():\n        attackers = board.attackers(piece.color, square)\n        if attackers:\n            defenders += 1\n    return defenders", "def feature(board: chess.Board) -> float:\n    \"Measures the material balance by counting the difference in total value of pieces\"\n    piece_values = {\n        chess.PAWN: 100,\n        chess.KNIGHT: 320,\n        chess.BISHOP: 330,\n        chess.ROOK: 500,\n        chess.QUEEN: 900,\n        chess.KING: 0,  # King value is not essential for material count\n    }\n    material_balance = 0.0\n    for piece in board.piece_map().values():\n        value = piece_values[piece.piece_type]\n        if piece.color == chess.WHITE:\n            material_balance += value\n        else:\n            material_balance -= value\n    return material_balance", "def feature(board: chess.Board) -> float:\n    \"Measures the number of pieces with no legal moves (stuck pieces) for the current player.\"\n    stuck_pieces = 0\n    for square in chess.SQUARES:\n        piece = board.piece_at(square)\n        if piece and piece.color == board.turn:\n            # Create a temporary board state to check moves without modifying the original board\n            temp_board = board.copy()\n            temp_board.remove_piece_at(square)\n            moves = len(list(temp_board.legal_moves))\n            if moves == 0:\n                stuck_pieces += 1\n    return float(stuck_pieces)", "def feature(board: chess.Board) -> float:\n    \"Measures the total number of free pawns for both players.\"\n    free_pawn_count = 0\n\n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.PAWN:\n            if not board.is_attacked_by(chess.WHITE if piece.color == chess.BLACK else chess.BLACK, square):\n                free_pawn_count += 1\n                \n    return float(free_pawn_count)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of pieces attacked by each player.\"\n    white_attacked = sum(1 for square in board.piece_map() if board.is_attacked_by(chess.WHITE, square))\n    black_attacked = sum(1 for square in board.piece_map() if board.is_attacked_by(chess.BLACK, square))\n    return float(white_attacked - black_attacked)", "def feature(board: chess.Board) -> float:\n    'Calculates the average distance of pieces from their respective king positions.'\n    white_king_square = next(square for square, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color == chess.WHITE)\n    black_king_square = next(square for square, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color == chess.BLACK)\n    total_distance = 0\n    piece_count = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == chess.WHITE:\n            total_distance += chess.square_distance(square, white_king_square)\n        elif piece.color == chess.BLACK:\n            total_distance += chess.square_distance(square, black_king_square)\n        piece_count += 1\n    return float(total_distance / max(piece_count, 1))", "def feature(board: chess.Board) -> float:\n    'Measures the distance of the kings from the corners of the board'\n    white_king_square = next(square for square, piece in board.piece_map().items() if piece.color == chess.WHITE and piece.piece_type == chess.KING)\n    black_king_square = next(square for square, piece in board.piece_map().items() if piece.color == chess.BLACK and piece.piece_type == chess.KING)\n    white_distance = min(chess.square_distance(white_king_square, corner) for corner in [chess.A1, chess.A8, chess.H1, chess.H8])\n    black_distance = min(chess.square_distance(black_king_square, corner) for corner in [chess.A1, chess.A8, chess.H1, chess.H8])\n    return float(white_distance - black_distance)", "def feature(board: chess.Board) -> float:\n    \"Measures the distance of kings to the center of the board for both players.\"\n    white_king_square = chess.square_name(board.king(chess.WHITE))\n    black_king_square = chess.square_name(board.king(chess.BLACK))\n    white_king_distance = (chess.square_file(board.king(chess.WHITE)) - 3)**2 + (chess.square_rank(board.king(chess.WHITE)) - 3)**2\n    black_king_distance = (chess.square_file(board.king(chess.BLACK)) - 3)**2 + (chess.square_rank(board.king(chess.BLACK)) - 3)**2\n    return float(black_king_distance - white_king_distance)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces that are attacking enemy squares.\"\n    attacking_pieces = sum(1 for square in board.piece_map() if board.is_attacked_by(not board.piece_at(square).color, square))\n    return float(attacking_pieces)", "def feature(board: chess.Board) -> float:\n    'Counts the number of pieces for each player and gives a ratio of pieces on the board.'\n    white_pieces = sum(1 for p in board.piece_map().values() if p.color == chess.WHITE)\n    black_pieces = sum(1 for p in board.piece_map().values() if p.color == chess.BLACK)\n    return white_pieces / (black_pieces + 1e-6)  # Avoid division by zero", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of passed pawns for each color.\"\n    white_passed_pawns = sum(1 for square, piece in board.piece_map().items() \n                              if piece.color == chess.WHITE and piece.piece_type == chess.PAWN and \n                              all(board.piece_at(chess.square_file(square) + i) is None for i in range(1, 8)))\n    black_passed_pawns = sum(1 for square, piece in board.piece_map().items() \n                              if piece.color == chess.BLACK and piece.piece_type == chess.PAWN and \n                              all(board.piece_at(chess.square_file(square) - i) is None for i in range(1, 8)))\n    return float(white_passed_pawns - black_passed_pawns)", "def feature(board: chess.Board) -> float:\n    \"Measures the distance of all pieces to their opponent's back rank.\"\n    total_distance = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == chess.WHITE:\n            total_distance += chess.square_rank(square)  # Distance to rank 0\n        else:\n            total_distance += 7 - chess.square_rank(square)  # Distance to rank 7\n    return float(total_distance)", "def feature(board: chess.Board) -> float:\n    \"Measures the pawn majority on one side of the board\"\n    white_pawns = sum(1 for square, piece in board.piece_map().items() if piece.color == chess.WHITE and piece.piece_type == chess.PAWN)\n    black_pawns = sum(1 for square, piece in board.piece_map().items() if piece.color == chess.BLACK and piece.piece_type == chess.PAWN)\n    return float(white_pawns - black_pawns)", "def feature(board: chess.Board) -> float:\n    \"Measures the material balance by counting the difference in total value of pieces\"\n    piece_values = {\n        chess.PAWN: 100,\n        chess.KNIGHT: 320,\n        chess.BISHOP: 330,\n        chess.ROOK: 500,\n        chess.QUEEN: 900,\n        chess.KING: 0,  # King value is not essential for material count\n    }\n    material_balance = 0.0\n    for piece in board.piece_map().values():\n        value = piece_values[piece.piece_type]\n        if piece.color == chess.WHITE:\n            material_balance += value\n        else:\n            material_balance -= value\n    return material_balance", "def feature(board: chess.Board) -> float:\n    \"Measures the maximum rank of pawns for White and Black.\"\n    max_rank_white = max((chess.square_rank(square) for square in board.piece_map() \n                          if board.piece_map()[square].color == chess.WHITE and \n                          board.piece_map()[square].piece_type == chess.PAWN), default=-1)\n    \n    max_rank_black = max((chess.square_rank(square) for square in board.piece_map() \n                          if board.piece_map()[square].color == chess.BLACK and \n                          board.piece_map()[square].piece_type == chess.PAWN), default=-1)\n    \n    return float(max_rank_white - max_rank_black)", "def feature(board: chess.Board) -> float:\n    \"Calculates the material strength of the pieces on the board.\"\n    material_values = {\n        chess.PAWN: 100,\n        chess.KNIGHT: 320,\n        chess.BISHOP: 330,\n        chess.ROOK: 500,\n        chess.QUEEN: 900,\n        chess.KING: 0\n    }\n    material_value = sum(material_values[piece.piece_type] for piece in board.piece_map().values())\n    return float(material_value) * (1 if board.turn == chess.WHITE else -1)", "def feature(board: chess.Board) -> float:\n    \"Measures the spatial distribution of pieces by calculating the variance of their positions.\"\n    color = chess.WHITE if board.turn else chess.BLACK\n    positions = [chess.square_file(square) + chess.square_rank(square) * 10 for square, piece in board.piece_map().items() if piece.color == color]\n    \n    if not positions:\n        return 0.0\n    \n    mean_position = sum(positions) / len(positions)\n    variance = sum((x - mean_position) ** 2 for x in positions) / len(positions)\n    return float(variance)", "def feature(board: chess.Board) -> float:\n    \"Measures the average distance of pawns from the opponent's back rank.\"\n    distance_sum = 0\n    pawn_count = 0\n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.PAWN:\n            distance_sum += chess.square_rank(square) if piece.color == chess.WHITE else 7 - chess.square_rank(square)\n            pawn_count += 1\n    average_distance = distance_sum / pawn_count if pawn_count > 0 else 0\n    return float(average_distance)", "def feature(board: chess.Board) -> float:\n    \"Calculates the distance of all pieces from their respective back ranks.\"\n    distance_sum = 0\n    for sq, piece in board.piece_map().items():\n        if piece.color == chess.WHITE:\n            distance_sum += 7 - chess.square_rank(sq)\n        else:\n            distance_sum += chess.square_rank(sq)\n    return float(distance_sum)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of open files for rooks for both players.\"\n    open_files = 0\n    for file in range(8):\n        if all(board.piece_at(chess.square(file, rank)) is None for rank in range(8)):\n            open_files += 1\n    return float(open_files)", "def feature(board: chess.Board) -> float:\n    \"Calculates the sum of the ranks occupied by each player's pawns, reflecting their advancement.\"\n    white_pawn_ranks = sum(chess.square_rank(square) for square in board.piece_map() if board.piece_at(square).piece_type == chess.PAWN and board.piece_at(square).color == chess.WHITE)\n    black_pawn_ranks = sum(chess.square_rank(square) for square in board.piece_map() if board.piece_at(square).piece_type == chess.PAWN and board.piece_at(square).color == chess.BLACK)\n    return float(white_pawn_ranks - black_pawn_ranks)", "def feature(board: chess.Board) -> float:\n    \"Calculates the ratio of knights to other pieces on the board for each player.\"\n    white_knights = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE and piece.piece_type == chess.KNIGHT)\n    black_knights = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK and piece.piece_type == chess.KNIGHT)\n    total_pieces_white = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE)\n    total_pieces_black = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK)\n    white_knight_ratio = white_knights / total_pieces_white if total_pieces_white > 0 else 0\n    black_knight_ratio = black_knights / total_pieces_black if total_pieces_black > 0 else 0\n    return float(white_knight_ratio - black_knight_ratio)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of squares that are currently attacked but not defended.\"\n    attacked_not_defended = 0\n    for square in chess.SQUARES:\n        if board.is_attacked_by(chess.WHITE, square) and not board.is_attacked_by(chess.BLACK, square):\n            attacked_not_defended += 1\n        elif board.is_attacked_by(chess.BLACK, square) and not board.is_attacked_by(chess.WHITE, square):\n            attacked_not_defended += 1\n    return float(attacked_not_defended)", "def feature(board: chess.Board) -> float:\n    \"Measures the potential mobility advantage by counting the legal moves available to each player.\"\n    white_legal_moves = len(list(board.legal_moves)) if board.turn else 0\n    black_legal_moves = len(list(board.legal_moves)) if not board.turn else 0\n    return float(white_legal_moves - black_legal_moves)", "def feature(board: chess.Board) -> float:\n    \"Measures the material balance by counting the difference in total value of pieces\"\n    piece_values = {\n        chess.PAWN: 100,\n        chess.KNIGHT: 320,\n        chess.BISHOP: 330,\n        chess.ROOK: 500,\n        chess.QUEEN: 900,\n        chess.KING: 0,  # King value is not essential for material count\n    }\n    material_balance = 0.0\n    for piece in board.piece_map().values():\n        value = piece_values[piece.piece_type]\n        if piece.color == chess.WHITE:\n            material_balance += value\n        else:\n            material_balance -= value\n    return material_balance", "def feature(board: chess.Board) -> float:\n    \"Counts the number of double attacks present on the board.\"\n    double_attacks = 0\n    for square, piece in board.piece_map().items():\n        for target in board.legal_moves:\n            if (target.to_square in board.attackers(not piece.color, target.from_square)):\n                double_attacks += 1\n    return float(double_attacks)", "def feature(board: chess.Board) -> float:\n    'Calculates the king safety score based on the number of attacks on the king.'\n    king_square = board.king(chess.WHITE) if board.turn == chess.WHITE else board.king(chess.BLACK)\n    return float(len(board.attackers(not board.turn, king_square)))", "def feature(board: chess.Board) -> float:\n    \"Calculates the average distance of all pieces from the center of the board (d4, e4, d5, e5).\"\n    center_squares = [chess.parse_square('d4'), chess.parse_square('e4'), chess.parse_square('d5'), chess.parse_square('e5')]\n    total_distance = sum(chess.square_distance(square, center) for square in board.piece_map() for center in center_squares)\n    piece_count = len(board.piece_map())\n    return float(total_distance / piece_count) if piece_count > 0 else 0.0", "def feature(board: chess.Board) -> float:\n    \"Counts the number of double attacks present on the board.\"\n    double_attacks = 0\n    for square, piece in board.piece_map().items():\n        for target in board.legal_moves:\n            if (target.to_square in board.attackers(not piece.color, target.from_square)):\n                double_attacks += 1\n    return float(double_attacks)", "def feature(board: chess.Board) -> float:\n    \"Measures the mobility of the pieces by counting legal moves available for each player.\"\n    white_moves = len(list(board.legal_moves))\n    board.turn = not board.turn  # Switch to the opponent's turn to count their moves\n    black_moves = len(list(board.legal_moves))\n    board.turn = not board.turn  # Switch back to original turn\n    result = white_moves - black_moves\n    return float(result)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of pieces that are pinned by the opponent's pieces.\"\n    pinned_pieces = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == (chess.WHITE if board.turn else chess.BLACK):\n            if any(board.is_attacked_by(not piece.color, pin_square) for pin_square in board.attackers(not piece.color, square)):\n                pinned_pieces += 1\n    return float(pinned_pieces)", "def feature(board: chess.Board) -> float:\n    'Measures the number of squares controlled by each side.'\n    white_control = sum(1 for square in chess.SQUARES if board.is_attacked_by(chess.WHITE, square))\n    black_control = sum(1 for square in chess.SQUARES if board.is_attacked_by(chess.BLACK, square))\n    return float(white_control - black_control)", "def feature(board: chess.Board) -> float:\n    \"Calculates the distance of the kings to the nearest enemy piece.\"\n    white_king_sq = next((sq for sq in board.piece_map() if board.piece_map()[sq].piece_type == chess.KING and board.piece_map()[sq].color == chess.WHITE), None)\n    black_king_sq = next((sq for sq in board.piece_map() if board.piece_map()[sq].piece_type == chess.KING and board.piece_map()[sq].color == chess.BLACK), None)\n    white_dist = min(chess.square_distance(white_king_sq, sq) for sq in board.piece_map() if board.piece_map()[sq].color == chess.BLACK) if white_king_sq else float('inf')\n    black_dist = min(chess.square_distance(black_king_sq, sq) for sq in board.piece_map() if board.piece_map()[sq].color == chess.WHITE) if black_king_sq else float('inf')\n    return float(white_dist - black_dist)", "def feature(board: chess.Board) -> float:\n    \"Calculates the average distance of all pieces from their opponent's pawns.\"\n    total_distance = 0\n    pieces_count = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == board.turn:\n            for pawn_sq in [sq for sq in board.piece_map() if board.piece_map()[sq].piece_type == chess.PAWN and board.piece_map()[sq].color != board.turn]:\n                total_distance += chess.square_distance(square, pawn_sq)\n                pieces_count += 1\n    return float(total_distance / pieces_count) if pieces_count > 0 else 0.0", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of attack opportunities for each player's pieces.\"\n    white_attacks = sum(len(board.attackers(chess.WHITE, square)) for square in board.piece_map() if board.piece_map()[square].color == chess.WHITE)\n    black_attacks = sum(len(board.attackers(chess.BLACK, square)) for square in board.piece_map() if board.piece_map()[square].color == chess.BLACK)\n    return float(white_attacks - black_attacks)", "def feature(board: chess.Board) -> float:\n    \"Measures the distance from all bishops to the opponent's pieces as an indicator of their activity.\"\n    opponent_pieces_squares = [sq for sq, piece in board.piece_map().items() if piece.color != board.turn]\n    bishops_squares = [sq for sq, piece in board.piece_map().items() if piece.piece_type == chess.BISHOP and piece.color == board.turn]\n    \n    total_distance = 0\n    for bishop in bishops_squares:\n        for opponent_piece in opponent_pieces_squares:\n            total_distance += chess.square_distance(bishop, opponent_piece)\n    \n    return float(total_distance)", "def feature(board: chess.Board) -> float:\n    \"Measures the distance of all pieces to their opponent's back rank.\"\n    total_distance = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == chess.WHITE:\n            total_distance += chess.square_rank(square)  # Distance to rank 0\n        else:\n            total_distance += 7 - chess.square_rank(square)  # Distance to rank 7\n    return float(total_distance)", "def feature(board: chess.Board) -> float:\n    \"Calculates the king safety by counting the number of squares around the king that are attacked.\"\n    king_square = next((sq for sq, p in board.piece_map().items() if p.piece_type == chess.KING and p.color == board.turn), None)\n    if king_square is None:\n        return 0.0  # If no king is found, return neutral safety\n    attacked_squares_around_king = sum(1 for offset in [-1, 0, 1] for offset2 in [-1, 0, 1] if (offset != 0 or offset2 != 0) and \n                                          0 <= chess.square_rank(king_square) + offset < 8 and \n                                          0 <= chess.square_file(king_square) + offset2 < 8 and \n                                          board.is_attacked_by(not board.turn, chess.square(king_square // 8 + offset, king_square % 8 + offset2)))\n    return float(attacked_squares_around_king)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces each player has that are attacking the opponent's pieces.\"\n    attacking_piece_count = sum(1 for square in board.piece_map() if board.piece_at(square).color == board.turn \n                                 and board.piece_at(square).piece_type != chess.KING \n                                 and len(board.attackers(chess.WHITE if board.turn else chess.BLACK, square)) > 0)\n    return float(attacking_piece_count)", "def feature(board: chess.Board) -> float:\n    \"Counts how many pieces are defending the King of the current player.\"\n    king_square = next(sq for sq, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color == board.turn)\n    defending_pieces = sum(1 for sq in board.piece_map() if board.is_attacked_by(not board.turn, sq) and board.attackers(board.turn, king_square))\n    return float(defending_pieces)", "def feature(board: chess.Board) -> float:\n    \"Count the number of pieces that have squares they control which cannot be attacked.\"\n    controlled_safe_squares = 0\n    for square, piece in board.piece_map().items():\n        controlled_squares = set(board.attackers(piece.color, square))\n        safe_controlled_squares = sum(1 for sq in controlled_squares if not board.is_attacked_by(not piece.color, sq))\n        controlled_safe_squares += safe_controlled_squares\n    return float(controlled_safe_squares)", "def feature(board: chess.Board) -> float:\n    \"Measures the presence of passed pawns for both sides.\"\n    passed_pawns = 0\n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.PAWN:\n            if piece.color == chess.WHITE and all(board.piece_at(sq) is None for sq in range(square + 8, 64, 8)):\n                passed_pawns += 1\n            if piece.color == chess.BLACK and all(board.piece_at(sq) is None for sq in range(square - 8, -1, -8)):\n                passed_pawns += 1\n    return float(passed_pawns)", "def feature(board: chess.Board) -> float:\n    \"Measures the total value of pieces in the opponent's half of the board.\"\n    opponent_half_value = sum(board.piece_map()[square].piece_type for square in board.piece_map() if (board.turn and chess.square_rank(square) < 4) or (not board.turn and chess.square_rank(square) > 3))\n    return float(opponent_half_value)", "def feature(board: chess.Board) -> float:\n    \"Count the number of key squares controlled by the pawns.\"\n    pawn_controlled_squares = {chess.E4, chess.E5, chess.D4, chess.D5}\n    control_count = sum(1 for pawn in [piece for piece in board.piece_map().values() if piece.piece_type == chess.PAWN] for sq in pawn_controlled_squares if board.is_attacked_by(pawn.color, sq))\n    return float(control_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates a pawn structure score based on doubled, isolated, and passed pawns\"\n    score = 0\n    for sq in range(64):\n        piece = board.piece_at(sq)\n        if piece is not None and piece.piece_type == chess.PAWN:\n            file = chess.square_file(sq)\n            rank = chess.square_rank(sq)\n            if (file > 0 and board.piece_at(sq - 1) is not None and board.piece_at(sq - 1).piece_type == chess.PAWN) or \\\n               (file < 7 and board.piece_at(sq + 1) is not None and board.piece_at(sq + 1).piece_type == chess.PAWN):\n                score -= 0.5  # penalty for doubled pawns\n            if (file > 0 and board.piece_at(sq - 1) is None) and (file < 7 and board.piece_at(sq + 1) is None):\n                score += 0.5  # bonus for isolated pawns\n            if (piece.color == chess.WHITE and rank == 6) or (piece.color == chess.BLACK and rank == 1):\n                score += 1.0  # bonus for advanced pawns\n    return float(score)", "def feature(board: chess.Board) -> float:\n    \"Measures the average distance of all pieces from the center of the board.\"\n    total_distance = 0\n    piece_count = 0\n    for square, piece in board.piece_map().items():\n        distance = chess.square_distance(square, chess.parse_square('e4'))  # Center of the board\n        total_distance += distance\n        piece_count += 1\n    return total_distance / piece_count if piece_count > 0 else 0.0", "def feature(board: chess.Board) -> float:\n    \"Counts the number of potential checks available for both players.\"\n    white_checks = sum(1 for move in board.legal_moves if board.is_check() or board.gives_check(move))\n    black_checks = sum(1 for move in board.legal_moves if not board.is_check() or board.gives_check(move))\n    return float(white_checks + black_checks)", "def feature(board: chess.Board) -> float:\n    'Counts the total number of potential captures available for both sides.'\n    total_captures = sum(1 for move in board.legal_moves if move.to_square in board.piece_map())\n    return float(total_captures)", "def feature(board: chess.Board) -> float:\n    \"Evaluates the king's safety based on the number of squares it can move to.\"\n    king_square = [square for square, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color == board.turn]\n    if not king_square:\n        return 0.0\n    king_square = king_square[0]\n    safe_squares = sum(1 for move in board.legal_moves if chess.square_distance(move.from_square, king_square) == 1 and not board.is_attacked_by(not board.turn, move.to_square))\n    return float(safe_squares)", "def feature(board: chess.Board) -> float:\n    \"Measures the total number of pawns that are connected.\"\n    connected_pawns = 0\n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.PAWN:\n            file = chess.square_file(square)\n            rank = chess.square_rank(square)\n            if (board.piece_at(chess.square(file - 1, rank)) and board.piece_at(chess.square(file - 1, rank)).piece_type == chess.PAWN and\n                board.piece_at(chess.square(file - 1, rank)).color == piece.color) or \\\n               (board.piece_at(chess.square(file + 1, rank)) and board.piece_at(chess.square(file + 1, rank)).piece_type == chess.PAWN and\n                board.piece_at(chess.square(file + 1, rank)).color == piece.color):\n                connected_pawns += 1\n    return float(connected_pawns)", "def feature(board: chess.Board) -> float:\n    \"Calculates the ratio of pieces in the opponent's half of the board.\"\n    white_pieces_in_enemy_half = sum(1 for sq, piece in board.piece_map().items() if piece.color == chess.WHITE and chess.square_rank(sq) >= 4)\n    black_pieces_in_enemy_half = sum(1 for sq, piece in board.piece_map().items() if piece.color == chess.BLACK and chess.square_rank(sq) <= 3)\n    total_pieces = len(board.piece_map())\n    if total_pieces == 0:\n        return 0.0\n    result = (white_pieces_in_enemy_half - black_pieces_in_enemy_half) / total_pieces\n    return result", "def feature(board: chess.Board) -> float:\n    'Measures the distance of the king to the center of the board for both players.'\n    white_king_square = board.king(chess.WHITE)\n    black_king_square = board.king(chess.BLACK)\n    distance_to_center = (2 - chess.square_file(white_king_square)) + (2 - chess.square_rank(white_king_square))\n    distance_to_center += (2 - chess.square_file(black_king_square)) + (2 - chess.square_rank(black_king_square))\n    return float(distance_to_center)", "def feature(board: chess.Board) -> float:\n    \"Calculates the average distance of all pieces from their opponent's back rank to assess offensive potential.\"\n    white_avg_distance = sum(chess.square_rank(sq) for sq in board.piece_map() if board.piece_at(sq).color == chess.WHITE) / len([1 for sq in board.piece_map() if board.piece_at(sq).color == chess.WHITE])\n    black_avg_distance = sum(7 - chess.square_rank(sq) for sq in board.piece_map() if board.piece_at(sq).color == chess.BLACK) / len([1 for sq in board.piece_map() if board.piece_at(sq).color == chess.BLACK])\n    result = white_avg_distance - black_avg_distance\n    return float(result)", "def feature(board: chess.Board) -> float:\n    \"Calculates the ratio of developed pieces for each player.\"\n    developed_white = sum(1 for square, piece in board.piece_map().items() if piece.color == chess.WHITE and (piece.piece_type in [chess.KNIGHT, chess.BISHOP, chess.ROOK]) and chess.square_rank(square) >= 1)\n    developed_black = sum(1 for square, piece in board.piece_map().items() if piece.color == chess.BLACK and (piece.piece_type in [chess.KNIGHT, chess.BISHOP, chess.ROOK]) and chess.square_rank(square) <= 6)\n    return float(developed_white / (developed_black + 1))  # Add 1 to avoid division by zero", "def feature(board: chess.Board) -> float:\n    \"Counts the number of connected pawns for each player and returns the difference\"\n    def connected_pawns(color):\n        connected = 0\n        for file in range(8):\n            for rank in range(8):\n                square = chess.square(file, rank)\n                if board.piece_at(square) and board.piece_at(square).color == color:\n                    if color == chess.WHITE:\n                        if rank > 0 and board.piece_at(chess.square(file, rank - 1)) and board.piece_at(chess.square(file, rank - 1)).color == color:\n                            connected += 1\n                    else:\n                        if rank < 7 and board.piece_at(chess.square(file, rank + 1)) and board.piece_at(chess.square(file, rank + 1)).color == color:\n                            connected += 1\n        return connected\n\n    return float(connected_pawns(chess.WHITE) - connected_pawns(chess.BLACK))", "def feature(board: chess.Board) -> float:\n    \"Measures the dynamic potential by counting the number of pieces that can make immediate threats.\"\n    threats = sum(1 for move in board.legal_moves if board.is_attacked_by(not board.turn, move.to_square))\n    return float(threats)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of doubled pawns for both players.\"\n    def count_doubled_pawns(color):\n        pawn_files = [0] * 8\n        for square in board.piece_map():\n            piece = board.piece_at(square)\n            if piece and piece.piece_type == chess.PAWN and piece.color == color:\n                pawn_files[chess.square_file(square)] += 1\n        return sum(1 for count in pawn_files if count > 1)\n    \n    white_doubled = count_doubled_pawns(chess.WHITE)\n    black_doubled = count_doubled_pawns(chess.BLACK)\n    return float(white_doubled - black_doubled)", "def feature(board: chess.Board) -> float:\n    \"Evaluates the maximum distance of any piece from its base rank.\"\n    max_white_distance = max(chess.square_rank(square) for square, piece in board.piece_map().items() if piece.color == chess.WHITE) - 0\n    max_black_distance = max(7 - chess.square_rank(square) for square, piece in board.piece_map().items() if piece.color == chess.BLACK)\n    result = float(max_white_distance - max_black_distance)\n    return result", "def feature(board: chess.Board) -> float:\n    \"Evaluates king safety by counting the number of pieces protecting the king.\"\n    king_square = next((sq for sq, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color == board.turn), None)\n    if king_square is not None:\n        protecting_pieces = len(board.attackers(board.turn, king_square))\n        return float(protecting_pieces)\n    return 0.0", "def feature(board: chess.Board) -> float:\n    \"Calculates the average distance of all pieces from their starting positions.\"\n    total_distance = 0\n    piece_count = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == board.turn:\n            piece_count += 1\n            start_square = chess.parse_square('a1') if piece.piece_type == chess.PAWN else chess.parse_square('e1' if piece.color == chess.WHITE else 'e8')\n            total_distance += chess.square_distance(square, start_square)\n    return total_distance / piece_count if piece_count > 0 else 0.0", "def feature(board: chess.Board) -> float:\n    \"Calculates the cumulative piece value of unprotected pieces for the current player.\"\n    piece_values = {chess.PAWN: 100, chess.KNIGHT: 320, chess.BISHOP: 330, chess.ROOK: 500, chess.QUEEN: 900}\n    unprotected_value = 0.0\n    for square, piece in board.piece_map().items():\n        if piece.color == board.turn and not any(board.is_attacked_by(not board.turn, sq) for sq in board.attackers(not board.turn, square)):\n            unprotected_value += piece_values.get(piece.piece_type, 0)\n    return unprotected_value", "def feature(board: chess.Board) -> float:\n    \"Measures the number of squares available to the current player that are not attacked.\"\n    legal_moves = len(list(board.legal_moves))\n    unsafe_squares = sum(1 for square in chess.SQUARES if board.is_attacked_by(board.turn, square))\n    return float(legal_moves - unsafe_squares)", "def feature(board: chess.Board) -> float:\n    \"Calculates the value difference based on material, considering advanced pawns (pawns on 4th and 5th ranks for White, 3rd and 4th for Black).\"\n    material_value = 0\n    for square, piece in board.piece_map().items():\n        value = piece.piece_type\n        if piece.color == chess.WHITE:\n            if chess.square_rank(square) >= 4:\n                value += 1  # Add point for advanced pawns (White)\n            material_value += value\n        else:\n            if chess.square_rank(square) <= 4:\n                value += 1  # Add point for advanced pawns (Black)\n            material_value -= value\n    return float(material_value)", "def feature(board: chess.Board) -> float:\n    \"Calculates the sum of the distances of all pieces from their respective pawns.\"\n    total_distance = 0\n    for square, piece in board.piece_map().items():\n        if piece.piece_type != chess.PAWN:\n            pawn_squares = [s for s in board.piece_map() if board.piece_at(s).piece_type == chess.PAWN and board.piece_at(s).color == piece.color]\n            if pawn_squares:\n                closest_distance = min(chess.square_distance(square, ps) for ps in pawn_squares)\n                total_distance += closest_distance\n    return total_distance", "def feature(board: chess.Board) -> float:\n    \"Measures the number of piece types on the board for each player.\"\n    white_types = set(piece.piece_type for piece in board.piece_map().values() if piece.color == chess.WHITE)\n    black_types = set(piece.piece_type for piece in board.piece_map().values() if piece.color == chess.BLACK)\n    return float(len(white_types) - len(black_types))", "def feature(board: chess.Board) -> float:\n    \"Measures the maximum distance from the king to any piece for the current player.\"\n    king_square = next(sq for sq in board.piece_map() if board.piece_at(sq).piece_type == chess.KING and board.piece_at(sq).color == board.turn)\n    max_distance = max(chess.square_distance(king_square, sq) for sq in board.piece_map() if board.piece_at(sq).color == board.turn)\n    return float(max_distance)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of pieces attacked by each player.\"\n    white_attacked = sum(1 for square in board.piece_map() if board.is_attacked_by(chess.WHITE, square))\n    black_attacked = sum(1 for square in board.piece_map() if board.is_attacked_by(chess.BLACK, square))\n    return float(white_attacked - black_attacked)", "def feature(board: chess.Board) -> float:\n    \"Counts how many squares are attacked by each side and computes their ratio.\"\n    white_attacks = sum(board.is_attacked_by(chess.WHITE, square) for square in chess.SQUARES)\n    black_attacks = sum(board.is_attacked_by(chess.BLACK, square) for square in chess.SQUARES)\n    \n    if black_attacks == 0:\n        return float('inf')\n    return white_attacks / black_attacks", "def feature(board: chess.Board) -> float:\n    \"Measures the mobility of the queens by counting their legal moves.\"\n    queen_moves = sum(1 for move in board.legal_moves if board.piece_at(move.from_square).piece_type == chess.QUEEN)\n    return float(queen_moves)", "def feature(board: chess.Board) -> float:\n    \"Measures the material balance by counting the difference in total value of pieces\"\n    piece_values = {\n        chess.PAWN: 100,\n        chess.KNIGHT: 320,\n        chess.BISHOP: 330,\n        chess.ROOK: 500,\n        chess.QUEEN: 900,\n        chess.KING: 0,  # King value is not essential for material count\n    }\n    material_balance = 0.0\n    for piece in board.piece_map().values():\n        value = piece_values[piece.piece_type]\n        if piece.color == chess.WHITE:\n            material_balance += value\n        else:\n            material_balance -= value\n    return material_balance", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of squares from which a king can safely escape.\"\n    white_king_sq = next((sq for sq in board.piece_map() if board.piece_map()[sq].piece_type == chess.KING and board.piece_map()[sq].color == chess.WHITE), None)\n    black_king_sq = next((sq for sq in board.piece_map() if board.piece_map()[sq].piece_type == chess.KING and board.piece_map()[sq].color == chess.BLACK), None)\n    white_moves = sum(1 for sq in chess.SQUARES if board.is_legal(chess.Move(white_king_sq, sq)) and not board.is_attacked_by(chess.BLACK, sq))\n    black_moves = sum(1 for sq in chess.SQUARES if board.is_legal(chess.Move(black_king_sq, sq)) and not board.is_attacked_by(chess.WHITE, sq))\n    return float(white_moves - black_moves)", "def feature(board: chess.Board) -> float:\n    \"Measures the material balance by counting the difference in total value of pieces\"\n    piece_values = {\n        chess.PAWN: 100,\n        chess.KNIGHT: 320,\n        chess.BISHOP: 330,\n        chess.ROOK: 500,\n        chess.QUEEN: 900,\n        chess.KING: 0,  # King value is not essential for material count\n    }\n    material_balance = 0.0\n    for piece in board.piece_map().values():\n        value = piece_values[piece.piece_type]\n        if piece.color == chess.WHITE:\n            material_balance += value\n        else:\n            material_balance -= value\n    return material_balance", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of undeveloped pieces for each player.\"\n    undeveloped_white = sum(1 for square, piece in board.piece_map().items() if piece.color == chess.WHITE and piece.piece_type in [chess.KNIGHT, chess.BISHOP] and chess.square_rank(square) < 2)\n    undeveloped_black = sum(1 for square, piece in board.piece_map().items() if piece.color == chess.BLACK and piece.piece_type in [chess.KNIGHT, chess.BISHOP] and chess.square_rank(square) > 5)\n    return float(undeveloped_white - undeveloped_black)", "def feature(board: chess.Board) -> float:\n    \"Measures the total value of pieces in the opponent's half of the board.\"\n    opponent_half_value = sum(board.piece_map()[square].piece_type for square in board.piece_map() if (board.turn and chess.square_rank(square) < 4) or (not board.turn and chess.square_rank(square) > 3))\n    return float(opponent_half_value)", "def feature(board: chess.Board) -> float:\n    'Measures the number of squares controlled by pieces of the current player.'\n    controlled_squares = set()\n    for square, piece in board.piece_map().items():\n        if piece.color == board.turn:\n            controlled_squares.update(board.attacks(square))\n    return len(controlled_squares)", "def feature(board: chess.Board) -> float:\n    \"Measures the influence of bishops on the board by counting the number of controlled squares for each.\"\n    white_bishop_influence = sum(len(board.attacks(square)) for square in board.piece_map() if board.piece_at(square).color == chess.WHITE and board.piece_at(square).piece_type == chess.BISHOP)\n    black_bishop_influence = sum(len(board.attacks(square)) for square in board.piece_map() if board.piece_at(square).color == chess.BLACK and board.piece_at(square).piece_type == chess.BISHOP)\n    return float(white_bishop_influence - black_bishop_influence)", "def feature(board: chess.Board) -> float:\n    \"Measures the material value of pieces that are attacking opponent's pieces with no defenders.\"\n    attacking_value = 0\n    for square in board.piece_map():\n        piece = board.piece_map()[square]\n        if piece.color == board.turn:\n            for target in board.legal_moves:\n                if target.from_square == square:\n                    target_piece = board.piece_at(target.to_square)\n                    if target_piece and not any(board.is_attacked_by(not piece.color, target.to_square) for attacker in board.attackers(not piece.color, target.to_square)):\n                        attacking_value += target_piece.piece_type\n    return float(attacking_value)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of check and checkmate threats posed to the opponent's king.\"\n    threats = 0\n    if board.is_check():\n        threats += 1\n    for move in board.legal_moves:\n        board.push(move)\n        if board.is_checkmate():\n            threats += 1\n        board.pop()\n    return float(threats)", "def feature(board: chess.Board) -> float:\n    \"Calculates the average distance of all pieces from their respective kings.\"\n    total_distance = 0\n    pieces_count = 0\n    kings_positions = [square for square, piece in board.piece_map().items() if piece.piece_type == chess.KING]\n    for square, piece in board.piece_map().items():\n        if piece.piece_type != chess.KING:\n            total_distance += chess.square_distance(square, kings_positions[piece.color])\n            pieces_count += 1\n    return float(total_distance / (pieces_count + 1))  # Avoid division by zero", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces in the center squares (e4, e5, d4, d5)\"\n    center_squares = [chess.parse_square('e4'), chess.parse_square('e5'),\n                      chess.parse_square('d4'), chess.parse_square('d5')]\n    center_piece_count = sum(1 for square in center_squares if board.piece_at(square) is not None)\n    return float(center_piece_count)", "def feature(board: chess.Board) -> float:\n    \"Tracks the balance of the material considering pieces defended by others\"\n    material_balance = 0\n    piece_values = {\n        chess.PAWN: 100,\n        chess.KNIGHT: 320,\n        chess.BISHOP: 330,\n        chess.ROOK: 500,\n        chess.QUEEN: 900,\n        chess.KING: 20000\n    }\n    for square, piece in board.piece_map().items():\n        if piece.color == board.turn:\n            material_balance += piece_values[piece.piece_type]\n            if any(board.is_attacked_by(not board.turn, square) for square in board.attackers(board.turn, square)):\n                material_balance -= piece_values[piece.piece_type] / 2\n        else:\n            material_balance -= piece_values[piece.piece_type]\n    return float(material_balance)", "def feature(board: chess.Board) -> float:\n    \"Calculates the sum of the ranks of all pieces for each color to assess piece placement.\"\n    white_ranks = sum(chess.square_rank(square) for square in board.piece_map() if board.piece_at(square).color == chess.WHITE)\n    black_ranks = sum(chess.square_rank(square) for square in board.piece_map() if board.piece_at(square).color == chess.BLACK)\n    return float(white_ranks - black_ranks)", "def feature(board: chess.Board) -> float:\n    \"Calculates the average distance of pieces from the center of the board for the current player.\"\n    total_distance = 0\n    piece_count = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == board.turn:\n            total_distance += (chess.square_file(square) + chess.square_rank(square))\n            piece_count += 1\n    return total_distance / piece_count if piece_count > 0 else 0.0", "def feature(board: chess.Board) -> float:\n    \"Calculates the value of pieces that are currently on the 1st and 8th ranks.\"\n    value_map = {chess.PAWN: 100, chess.KNIGHT: 320, chess.BISHOP: 330, chess.ROOK: 500, chess.QUEEN: 900, chess.KING: 20000}\n    value = 0.0\n    for square, piece in board.piece_map().items():\n        if chess.square_rank(square) in (0, 7):  # 1st or 8th rank\n            value += value_map[piece.piece_type] * (1 if piece.color == chess.WHITE else -1)\n    return value", "def feature(board: chess.Board) -> float:\n    \"Measures the number of squares available to the current player that are not attacked.\"\n    legal_moves = len(list(board.legal_moves))\n    unsafe_squares = sum(1 for square in chess.SQUARES if board.is_attacked_by(board.turn, square))\n    return float(legal_moves - unsafe_squares)", "def feature(board: chess.Board) -> float:\n    \"Calculates the mobility advantage based on legal moves.\"\n    white_moves = sum(1 for move in board.legal_moves if move.from_square)\n    black_moves = sum(1 for move in board.legal_moves if move.from_square and board.piece_at(move.from_square).color == chess.BLACK)\n    mobility_advantage = white_moves - black_moves\n    return float(mobility_advantage)", "def feature(board: chess.Board) -> float:\n    \"Measures the imbalance of pawns compared to other pieces for both players.\"\n    white_pawn_count = len([p for p in board.piece_map().values() if p.color == chess.WHITE and p.piece_type == chess.PAWN])\n    black_pawn_count = len([p for p in board.piece_map().values() if p.color == chess.BLACK and p.piece_type == chess.PAWN])\n    white_non_pawn_count = len([p for p in board.piece_map().values() if p.color == chess.WHITE and p.piece_type != chess.PAWN])\n    black_non_pawn_count = len([p for p in board.piece_map().values() if p.color == chess.BLACK and p.piece_type != chess.PAWN])\n    if (white_non_pawn_count + black_non_pawn_count) == 0:\n        return 0.0\n    result = (white_pawn_count - black_pawn_count) / (white_non_pawn_count + black_non_pawn_count)\n    return result", "def feature(board: chess.Board) -> float:\n    \"Calculates the average distance of pieces from the opponent's back rank\"\n    total_distance = 0\n    piece_count = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == (chess.WHITE if board.turn else chess.BLACK):\n            piece_count += 1\n            total_distance += (7 - chess.square_rank(square) if piece.color == chess.WHITE else chess.square_rank(square))\n    return float(total_distance / piece_count) if piece_count > 0 else 0.0", "def feature(board: chess.Board) -> float:\n    \"Measures the distance of the opposing king from the center of the board.\"\n    opposing_king_square = board.king(not board.turn)\n    distance_to_center = chess.square_distance(opposing_king_square, chess.parse_square('e4')) + chess.square_distance(opposing_king_square, chess.parse_square('d4'))\n    return float(8 - distance_to_center)  # Closer to center = higher value", "def feature(board: chess.Board) -> float:\n    \"Calculates the ratio of pieces in the opponent's half of the board.\"\n    white_pieces_in_enemy_half = sum(1 for sq, piece in board.piece_map().items() if piece.color == chess.WHITE and chess.square_rank(sq) >= 4)\n    black_pieces_in_enemy_half = sum(1 for sq, piece in board.piece_map().items() if piece.color == chess.BLACK and chess.square_rank(sq) <= 3)\n    total_pieces = len(board.piece_map())\n    if total_pieces == 0:\n        return 0.0\n    result = (white_pieces_in_enemy_half - black_pieces_in_enemy_half) / total_pieces\n    return result", "def feature(board: chess.Board) -> float:\n    \"Evaluates the number of safe squares for the king of the current player.\"\n    king_square = board.king(board.turn)\n    safe_squares = sum(1 for move in board.legal_moves if chess.square_distance(king_square, move.to_square) == 1 and not board.is_attacked_by(not board.turn, move.to_square))\n    return float(safe_squares)", "def feature(board: chess.Board) -> float:\n    'Counts the number of pieces for each player and gives a ratio of pieces on the board.'\n    white_pieces = sum(1 for p in board.piece_map().values() if p.color == chess.WHITE)\n    black_pieces = sum(1 for p in board.piece_map().values() if p.color == chess.BLACK)\n    return white_pieces / (black_pieces + 1e-6)  # Avoid division by zero", "def feature(board: chess.Board) -> float:\n    \"Calculates the king safety based on the number of adjacent squares controlled by the opponent.\"\n    white_king_square = next((square for square, piece in board.piece_map().items() \n                               if piece.color == chess.WHITE and piece.piece_type == chess.KING), None)\n    black_king_square = next((square for square, piece in board.piece_map().items() \n                               if piece.color == chess.BLACK and piece.piece_type == chess.KING), None)\n    white_king_attackers = sum(1 for square in chess.SQUARES if board.is_attacked_by(chess.BLACK, square) and \n                                chess.square_distance(square, white_king_square) <= 1)\n    black_king_attackers = sum(1 for square in chess.SQUARES if board.is_attacked_by(chess.WHITE, square) and \n                                chess.square_distance(square, black_king_square) <= 1)\n    return float(black_king_attackers - white_king_attackers)", "def feature(board: chess.Board) -> float:\n    \"Calculates the average rank of all pawns for each player.\"\n    white_pawn_ranks = [chess.square_rank(sq) for sq, piece in board.piece_map().items() if piece.piece_type == chess.PAWN and piece.color == chess.WHITE]\n    black_pawn_ranks = [chess.square_rank(sq) for sq, piece in board.piece_map().items() if piece.piece_type == chess.PAWN and piece.color == chess.BLACK]\n    \n    avg_white_rank = sum(white_pawn_ranks) / len(white_pawn_ranks) if white_pawn_ranks else 0\n    avg_black_rank = sum(black_pawn_ranks) / len(black_pawn_ranks) if black_pawn_ranks else 0\n    \n    return float(avg_white_rank - avg_black_rank)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of possible legal moves for both players.\"\n    white_legal_moves = len(list(board.legal_moves)) if board.turn == chess.WHITE else 0\n    black_legal_moves = len(list(board.legal_moves)) if board.turn == chess.BLACK else 0\n    return float(white_legal_moves - black_legal_moves)", "def feature(board: chess.Board) -> float:\n    \"Measures the distance of pieces from the center (optimal positioning).\"\n    center_squares = [chess.square(3, 3), chess.square(3, 4), chess.square(4, 3), chess.square(4, 4)]\n    central_control_score = 0.0\n    for square, piece in board.piece_map().items():\n        distance = min(chess.square_distance(square, center_square) for center_square in center_squares)\n        central_control_score += (1 / (1 + distance)) if piece.color == board.turn else -(1 / (1 + distance))\n    return central_control_score", "def feature(board: chess.Board) -> float:\n    \"Calculates the distance of the nearest enemy's pawn to each king.\"\n    white_king_square = board.king(chess.WHITE)\n    black_king_square = board.king(chess.BLACK)\n    white_distance = min((chess.square_distance(white_king_square, pawn) for pawn in board.piece_map() if board.piece_at(pawn).color == chess.BLACK and board.piece_at(pawn).piece_type == chess.PAWN), default=8)\n    black_distance = min((chess.square_distance(black_king_square, pawn) for pawn in board.piece_map() if board.piece_at(pawn).color == chess.WHITE and board.piece_at(pawn).piece_type == chess.PAWN), default=8)\n    return float(white_distance - black_distance)", "def feature(board: chess.Board) -> float:\n    \"Evaluates the control of the center squares (d4, d5, e4, e5).\"\n    center_squares = [chess.parse_square('d4'), chess.parse_square('d5'), chess.parse_square('e4'), chess.parse_square('e5')]\n    control_score = sum(1 if board.piece_at(sq) and board.piece_at(sq).color == chess.WHITE else -1 for sq in center_squares)\n    return float(control_score)", "def feature(board: chess.Board) -> float:\n    \"Measures the distance of the king(s) to their respective back rank.\"\n    def king_distance(color):\n        for square in board.piece_map():\n            piece = board.piece_at(square)\n            if piece and piece.piece_type == chess.KING and piece.color == color:\n                return 7 - chess.square_rank(square) if color == chess.WHITE else chess.square_rank(square)\n        return 0\n    \n    white_distance = king_distance(chess.WHITE)\n    black_distance = king_distance(chess.BLACK)\n    return float(white_distance - black_distance)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces for each player and gives the material ratio.\"\n    piece_values = {chess.PAWN: 100, chess.KNIGHT: 320, chess.BISHOP: 330, chess.ROOK: 500,\n                    chess.QUEEN: 900, chess.KING: 20000}\n    white_material = sum(piece_values[piece.piece_type] for piece in board.piece_map().values() if piece.color == chess.WHITE)\n    black_material = sum(piece_values[piece.piece_type] for piece in board.piece_map().values() if piece.color == chess.BLACK)\n    return float(white_material / max(1, black_material))", "def feature(board: chess.Board) -> float:\n    \"Calculates the average distance of pieces from the center of the board for the current player.\"\n    total_distance = 0\n    piece_count = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == board.turn:\n            total_distance += (chess.square_file(square) + chess.square_rank(square))\n            piece_count += 1\n    return total_distance / piece_count if piece_count > 0 else 0.0", "def feature(board: chess.Board) -> float:\n    \"Calculates the ratio of actively developed pieces to total pieces.\"\n    developed_pieces = sum(1 for square, piece in board.piece_map().items() if chess.square_rank(square) > 4 and piece.color == (chess.WHITE if board.turn else chess.BLACK))\n    total_pieces = len(board.piece_map())\n    return developed_pieces / total_pieces if total_pieces > 0 else 0.0", "def feature(board: chess.Board) -> float:\n    \"Counts the number of check and checkmate threats posed to the opponent's king.\"\n    threats = 0\n    if board.is_check():\n        threats += 1\n    for move in board.legal_moves:\n        board.push(move)\n        if board.is_checkmate():\n            threats += 1\n        board.pop()\n    return float(threats)", "def feature(board: chess.Board) -> float:\n    \"Calculates the ratio of pieces in the opponent's half of the board.\"\n    white_pieces_in_enemy_half = sum(1 for sq, piece in board.piece_map().items() if piece.color == chess.WHITE and chess.square_rank(sq) >= 4)\n    black_pieces_in_enemy_half = sum(1 for sq, piece in board.piece_map().items() if piece.color == chess.BLACK and chess.square_rank(sq) <= 3)\n    total_pieces = len(board.piece_map())\n    if total_pieces == 0:\n        return 0.0\n    result = (white_pieces_in_enemy_half - black_pieces_in_enemy_half) / total_pieces\n    return result", "def feature(board: chess.Board) -> float:\n    \"Measures the distance from the opposing king for all pieces of the player to move.\"\n    total_distance = 0\n    opposing_king_square = None\n    for square in board.piece_map():\n        if board.piece_at(square).piece_type == chess.KING and board.piece_at(square).color != board.turn:\n            opposing_king_square = square\n            break\n    if opposing_king_square is None:\n        return 0.0\n    for square in board.piece_map():\n        if board.piece_at(square).color == board.turn:\n            total_distance += chess.square_distance(square, opposing_king_square)\n    return float(total_distance)", "def feature(board: chess.Board) -> float:\n    \"Evaluates the distribution of pawns across the ranks.\"\n    pawns = [square for square, piece in board.piece_map().items() if piece.piece_type == chess.PAWN]\n    ranks = [chess.square_rank(square) for square in pawns]\n    rank_distribution = sum(1 for rank in range(8) if rank in ranks)\n    return float(rank_distribution)", "def feature(board: chess.Board) -> float:\n    \"Calculates the average distance of pieces from the center of the board for the current player.\"\n    total_distance = 0\n    piece_count = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == board.turn:\n            total_distance += (chess.square_file(square) + chess.square_rank(square))\n            piece_count += 1\n    return total_distance / piece_count if piece_count > 0 else 0.0", "def feature(board: chess.Board) -> float:\n    \"Calculates the imbalance in material based on piece types.\"\n    piece_values = {\n        chess.PAWN: 100,\n        chess.KNIGHT: 320,\n        chess.BISHOP: 330,\n        chess.ROOK: 500,\n        chess.QUEEN: 900,\n        chess.KING: float('inf'),  # King shouldn't be counted\n    }\n    material_balance = 0\n    for piece in board.piece_map().values():\n        material_balance += piece_values[piece.piece_type] if piece.color == chess.WHITE else -piece_values[piece.piece_type]\n    return float(material_balance)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of weak pawns on the board (pawns that are isolated or doubled).\"\n    weak_pawn_count = 0\n    for square in range(64):\n        pawn = board.piece_at(square)\n        if pawn and pawn.piece_type == chess.PAWN:\n            file = chess.square_file(square)\n            rank = chess.square_rank(square)\n            if (board.piece_at(chess.parse_square(chess.square_name(square - 8))) is None and \n                board.piece_at(chess.parse_square(chess.square_name(square + 8))) is None):\n                weak_pawn_count += 1\n            elif (board.piece_at(chess.parse_square(chess.square_name(square - 1))) is not None and \n                  board.piece_at(chess.parse_square(chess.square_name(square + 1))) is not None):\n                weak_pawn_count += 1\n    return float(weak_pawn_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the ratio of major pieces (rooks and queens) to minor pieces (knights and bishops) on the board.\"\n    major_count = sum(1 for piece in board.piece_map().values() if piece.piece_type in {chess.ROOK, chess.QUEEN})\n    minor_count = sum(1 for piece in board.piece_map().values() if piece.piece_type in {chess.KNIGHT, chess.BISHOP})\n    return float(major_count) / (minor_count + 1)  # Adding 1 to avoid division by zero", "def feature(board: chess.Board) -> float:\n    \"Measures how many squares are controlled by the current player's pieces.\"\n    controlled_squares = set()\n    for square, piece in board.piece_map().items():\n        if piece.color == board.turn:\n            controlled_squares.add(square)\n            if piece.piece_type == chess.PAWN:\n                controlled_squares.add(square + 7)  # Diagonal left\n                controlled_squares.add(square + 9)  # Diagonal right\n            elif piece.piece_type == chess.ROOK or piece.piece_type == chess.QUEEN:\n                for i in range(1, 8):\n                    controlled_squares.add(square + i)  # Horizontal right\n                    controlled_squares.add(square - i)  # Horizontal left\n            elif piece.piece_type == chess.BISHOP or piece.piece_type == chess.QUEEN:\n                for i in range(1, 8):\n                    controlled_squares.add(square + 8 * i + i)  # Diagonal up right\n                    controlled_squares.add(square + 8 * i - i)  # Diagonal up left\n    return float(len(controlled_squares))", "def feature(board: chess.Board) -> float:\n    \"Measures the total mobility of pieces for both sides.\"\n    white_mobility = sum(len(list(board.legal_moves)) for square, piece in board.piece_map().items() if piece.color == chess.WHITE)\n    black_mobility = sum(len(list(board.legal_moves)) for square, piece in board.piece_map().items() if piece.color == chess.BLACK)\n    return float(white_mobility - black_mobility)", "def feature(board: chess.Board) -> float:\n    \"Calculates the average rank of each player's pawns.\"\n    pawn_squares = [square for square, piece in board.piece_map().items() if piece.piece_type == chess.PAWN]\n    if not pawn_squares:\n        return 0.0\n    avg_rank = sum(chess.square_rank(square) for square in pawn_squares) / len(pawn_squares)\n    return avg_rank", "def feature(board: chess.Board) -> float:\n    \"Measures the total number of squares that are defended by pawns for both sides.\"\n    def defended_squares_count(color):\n        defended_squares = set()\n        for square in board.piece_map():\n            piece = board.piece_at(square)\n            if piece.color == color and piece.piece_type == chess.PAWN:\n                defended_squares.add(square + 1)  # Right\n                defended_squares.add(square - 1)  # Left\n        return len(defended_squares)\n\n    return float(defended_squares_count(chess.WHITE) - defended_squares_count(chess.BLACK))", "def feature(board: chess.Board) -> float:\n    \"Checks how many pieces are undeveloped (not moved from their starting positions).\"\n    undeveloped_count = 0\n    starting_positions = {\n        chess.WHITE: [chess.A1, chess.B1, chess.C1, chess.D1, chess.E1, chess.F1, chess.G1, chess.H1, chess.A2, chess.B2, chess.C2, chess.D2, chess.E2, chess.F2, chess.G2, chess.H2],\n        chess.BLACK: [chess.A8, chess.B8, chess.C8, chess.D8, chess.E8, chess.F8, chess.G8, chess.H8, chess.A7, chess.B7, chess.C7, chess.D7, chess.E7, chess.F7, chess.G7, chess.H7],\n    }\n    for sq in starting_positions[board.turn]:\n        if board.piece_at(sq) is not None:\n            undeveloped_count += 1\n    return float(undeveloped_count)", "def feature(board: chess.Board) -> float:\n    \"Measures the distance of kings to the center of the board for both players.\"\n    white_king_square = chess.square_name(board.king(chess.WHITE))\n    black_king_square = chess.square_name(board.king(chess.BLACK))\n    white_king_distance = (chess.square_file(board.king(chess.WHITE)) - 3)**2 + (chess.square_rank(board.king(chess.WHITE)) - 3)**2\n    black_king_distance = (chess.square_file(board.king(chess.BLACK)) - 3)**2 + (chess.square_rank(board.king(chess.BLACK)) - 3)**2\n    return float(black_king_distance - white_king_distance)", "def feature(board: chess.Board) -> float:\n    \"Computes the ratio of total pawns to total pieces on the board.\"\n    total_pawns = sum(1 for piece in board.piece_map().values() if piece.piece_type == chess.PAWN)\n    total_pieces = len(board.piece_map())\n    return float(total_pawns / (total_pieces + 1e-9))", "def feature(board: chess.Board) -> float:\n    \"Measures the distance of the closest piece to the opponent's king.\"\n    opponent_king = chess.KING if board.turn == chess.WHITE else chess.KING\n    opponent_king_square = next((sq for sq, p in board.piece_map().items() if p.piece_type == opponent_king and p.color != board.turn), None)\n    if opponent_king_square is None:\n        return float('inf')  # If no king is found, return a large distance\n    min_distance = min(chess.square_distance(sq, opponent_king_square) for sq, p in board.piece_map().items() if p.color == board.turn)\n    return float(min_distance)", "def feature(board: chess.Board) -> float:\n    \"Calculates the distance of the nearest enemy's pawn to each king.\"\n    white_king_square = board.king(chess.WHITE)\n    black_king_square = board.king(chess.BLACK)\n    white_distance = min((chess.square_distance(white_king_square, pawn) for pawn in board.piece_map() if board.piece_at(pawn).color == chess.BLACK and board.piece_at(pawn).piece_type == chess.PAWN), default=8)\n    black_distance = min((chess.square_distance(black_king_square, pawn) for pawn in board.piece_map() if board.piece_at(pawn).color == chess.WHITE and board.piece_at(pawn).piece_type == chess.PAWN), default=8)\n    return float(white_distance - black_distance)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces in the center squares (e4, e5, d4, d5)\"\n    center_squares = [chess.parse_square('e4'), chess.parse_square('e5'),\n                      chess.parse_square('d4'), chess.parse_square('d5')]\n    center_piece_count = sum(1 for square in center_squares if board.piece_at(square) is not None)\n    return float(center_piece_count)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of potential forks for the current player.\"\n    forks = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == board.turn and (piece.piece_type == chess.KNIGHT or piece.piece_type == chess.QUEEN):\n            target_squares = {move.to_square for move in board.legal_moves if move.from_square == square}\n            for target in target_squares:\n                attackers = sum(1 for attacking_square in board.attackers(not board.turn, target))\n                if attackers >= 2:\n                    forks += 1\n    return float(forks)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces in the opponent's half of the board.\"\n    opponent_color = chess.BLACK if board.turn else chess.WHITE\n    return float(sum(1 for sq in board.piece_map() if board.piece_at(sq).color == opponent_color and chess.square_rank(sq) >= 4))", "def feature(board: chess.Board) -> float:\n    \"Measures the distance of pieces from the center (optimal positioning).\"\n    center_squares = [chess.square(3, 3), chess.square(3, 4), chess.square(4, 3), chess.square(4, 4)]\n    central_control_score = 0.0\n    for square, piece in board.piece_map().items():\n        distance = min(chess.square_distance(square, center_square) for center_square in center_squares)\n        central_control_score += (1 / (1 + distance)) if piece.color == board.turn else -(1 / (1 + distance))\n    return central_control_score", "def feature(board: chess.Board) -> float:\n    \"Measures the total value of pieces on the board, weighted by position (closer to the opponent's back rank).\"\n    value = 0.0\n    for square, piece in board.piece_map().items():\n        piece_value = {chess.PAWN: 100, chess.KNIGHT: 320, chess.BISHOP: 330, chess.ROOK: 500, chess.QUEEN: 900, chess.KING: 0}\n        position_weight = 1 + (7 - chess.square_rank(square)) / 10  # Add additional weight for pieces close to the opponent\n        value += piece_value[piece.piece_type] * position_weight if piece.color == chess.WHITE else -piece_value[piece.piece_type] * position_weight\n    return value", "def feature(board: chess.Board) -> float:\n    'Measures the number of squares controlled by pieces of the current player.'\n    controlled_squares = set()\n    for square, piece in board.piece_map().items():\n        if piece.color == board.turn:\n            controlled_squares.update(board.attacks(square))\n    return len(controlled_squares)", "def feature(board: chess.Board) -> float:\n    \"Counts the difference in the number of isolated pawns for both sides.\"\n    def is_isolated_pawn(square, color):\n        if color == chess.WHITE:\n            return (board.piece_at(square) and board.piece_at(square).piece_type == chess.PAWN and\n                    (not board.piece_at(square - 1) and not board.piece_at(square + 1)))\n        else:\n            return (board.piece_at(square) and board.piece_at(square).piece_type == chess.PAWN and\n                    (not board.piece_at(square - 1) and not board.piece_at(square + 1)))\n\n    white_isolated = sum(1 for sq in range(8) if is_isolated_pawn(chess.square(sq, 1), chess.WHITE))\n    black_isolated = sum(1 for sq in range(8) if is_isolated_pawn(chess.square(sq, 6), chess.BLACK))\n    return float(white_isolated - black_isolated)", "def feature(board: chess.Board) -> float:\n    \"Calculates the total number of pawn structures (connected pawns and isolated pawns) for both players.\"\n    pawn_structure_score = 0\n    for square in range(64):\n        piece = board.piece_at(square)\n        if piece and piece.piece_type == chess.PAWN:\n            file = chess.square_file(square)\n            rank = chess.square_rank(square)\n            if (board.piece_at(chess.square(file, rank + 1)) if rank < 7 else None) or \\\n               (board.piece_at(chess.square(file, rank - 1)) if rank > 0 else None):\n                pawn_structure_score += 1  # Connected pawn\n            else:\n                pawn_structure_score -= 1  # Isolated pawn\n    return float(pawn_structure_score)", "def feature(board: chess.Board) -> float:\n    'Measures the distribution of pieces across the board by calculating the variance of their ranks'\n    piece_ranks = [chess.square_rank(square) for square in board.piece_map()]\n    if not piece_ranks:\n        return 0.0\n    mean_rank = sum(piece_ranks) / len(piece_ranks)\n    variance = sum((rank - mean_rank) ** 2 for rank in piece_ranks) / len(piece_ranks)\n    return variance", "def feature(board: chess.Board) -> float:\n    \"Evaluates the proportion of pieces developed versus total pieces, emphasizing development.\"\n    total_pieces = sum(1 for piece in board.piece_map().values())\n    developed_pieces = sum(1 for square in range(0, 64) if board.piece_at(square) is not None and chess.square_rank(square) >= 1)  # pawns in row 2 or 7, others in row 1 or 8\n    return float(developed_pieces / total_pieces) if total_pieces > 0 else 0.0", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of scattered pieces by summing distances between pieces of the same color.\"\n    positions = [sq for sq, piece in board.piece_map().items() if piece.color == board.turn]\n    if len(positions) < 2:\n        return 0.0\n    total_distance = sum(chess.square_distance(pos1, pos2) for i, pos1 in enumerate(positions) for pos2 in positions[i + 1:])\n    return float(total_distance)", "def feature(board: chess.Board) -> float:\n    \"Calculates the connectedness of pawns (number of pawn clusters).\"\n    pawns = [square for square, piece in board.piece_map().items() if piece.piece_type == chess.PAWN]\n    clusters = 0\n    visited = set()\n    \n    for square in pawns:\n        if square not in visited:\n            clusters += 1\n            stack = [square]\n            while stack:\n                current = stack.pop()\n                visited.add(current)\n                neighbors = [chess.square_file(current), chess.square_rank(current)-1, chess.square_rank(current)+1]\n                for file in neighbors:\n                    if chess.square_file(file) != chess.square_file(current):\n                        next_sq = chess.square(file, chess.square_rank(current))\n                        if next_sq in pawns and next_sq not in visited:\n                            stack.append(next_sq)\n    return float(clusters)", "def feature(board: chess.Board) -> float:\n    'Counts the number of pieces for each player and gives a ratio of pieces on the board.'\n    white_pieces = sum(1 for p in board.piece_map().values() if p.color == chess.WHITE)\n    black_pieces = sum(1 for p in board.piece_map().values() if p.color == chess.BLACK)\n    return white_pieces / (black_pieces + 1e-6)  # Avoid division by zero", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces within the opponent's territory for each side.\"\n    white_pieces_in_enemy_territory = sum(1 for square, piece in board.piece_map().items() \n                                           if piece.color == chess.WHITE and chess.square_rank(square) > 4)\n    black_pieces_in_enemy_territory = sum(1 for square, piece in board.piece_map().items() \n                                           if piece.color == chess.BLACK and chess.square_rank(square) < 4)\n    return float(white_pieces_in_enemy_territory - black_pieces_in_enemy_territory)", "def feature(board: chess.Board) -> float:\n    \"Calculates the imbalance in material based on piece types.\"\n    piece_values = {\n        chess.PAWN: 100,\n        chess.KNIGHT: 320,\n        chess.BISHOP: 330,\n        chess.ROOK: 500,\n        chess.QUEEN: 900,\n        chess.KING: float('inf'),  # King shouldn't be counted\n    }\n    material_balance = 0\n    for piece in board.piece_map().values():\n        material_balance += piece_values[piece.piece_type] if piece.color == chess.WHITE else -piece_values[piece.piece_type]\n    return float(material_balance)", "def feature(board: chess.Board) -> float:\n    'Calculates the average distance of pieces from their home squares.'\n    home_squares = {\n        chess.WHITE: [chess.A2, chess.B2, chess.C2, chess.D2, chess.E2, chess.F2, chess.G2, chess.H2],\n        chess.BLACK: [chess.A7, chess.B7, chess.C7, chess.D7, chess.E7, chess.F7, chess.G7, chess.H7]\n    }\n    total_distance = 0\n    piece_count = 0\n    \n    for piece in board.piece_map().values():\n        square = next(sq for sq in chess.SQUARES if board.piece_at(sq) == piece)\n        home_square = home_squares[piece.color][piece.piece_type - 1]\n        total_distance += chess.square_distance(square, home_square)\n        piece_count += 1\n        \n    return total_distance / piece_count if piece_count > 0 else 0.0", "def feature(board: chess.Board) -> float:\n    'Measures the distance of the king to the center of the board for both players.'\n    white_king_square = board.king(chess.WHITE)\n    black_king_square = board.king(chess.BLACK)\n    distance_to_center = (2 - chess.square_file(white_king_square)) + (2 - chess.square_rank(white_king_square))\n    distance_to_center += (2 - chess.square_file(black_king_square)) + (2 - chess.square_rank(black_king_square))\n    return float(distance_to_center)", "def feature(board: chess.Board) -> float:\n    \"Measures the king safety by counting the number of squares around the kings that are attacked.\"\n    white_king_square = next(square for square, piece in board.piece_map().items() if piece.color == chess.WHITE and piece.piece_type == chess.KING)\n    black_king_square = next(square for square, piece in board.piece_map().items() if piece.color == chess.BLACK and piece.piece_type == chess.KING)\n    white_king_safety = sum(board.is_attacked_by(chess.BLACK, square) for square in board.attacks(white_king_square))\n    black_king_safety = sum(board.is_attacked_by(chess.WHITE, square) for square in board.attacks(black_king_square))\n    return float(black_king_safety - white_king_safety)", "def feature(board: chess.Board) -> float:\n    \"Evaluates the distance of all pieces from the center of the board, favoring central control.\"\n    center_squares = [chess.E4, chess.E5, chess.D4, chess.D5]\n    distance_score = sum(1 / (chess.square_distance(square, center) + 1) for square in board.piece_map() for center in center_squares)\n    return float(distance_score)", "def feature(board: chess.Board) -> float:\n    \"Measures the material balance by counting the difference in total value of pieces\"\n    piece_values = {\n        chess.PAWN: 100,\n        chess.KNIGHT: 320,\n        chess.BISHOP: 330,\n        chess.ROOK: 500,\n        chess.QUEEN: 900,\n        chess.KING: 0,  # King value is not essential for material count\n    }\n    material_balance = 0.0\n    for piece in board.piece_map().values():\n        value = piece_values[piece.piece_type]\n        if piece.color == chess.WHITE:\n            material_balance += value\n        else:\n            material_balance -= value\n    return material_balance", "def feature(board: chess.Board) -> float:\n    \"Measures the total distance of all pieces from their respective home ranks.\"\n    white_distance = sum(chess.square_rank(sq) for sq, piece in board.piece_map().items() if piece.color == chess.WHITE)\n    black_distance = sum(7 - chess.square_rank(sq) for sq, piece in board.piece_map().items() if piece.color == chess.BLACK)\n    return float(white_distance - black_distance)", "def feature(board: chess.Board) -> float:\n    \"Measures the material balance by counting the difference in total value of pieces\"\n    piece_values = {\n        chess.PAWN: 100,\n        chess.KNIGHT: 320,\n        chess.BISHOP: 330,\n        chess.ROOK: 500,\n        chess.QUEEN: 900,\n        chess.KING: 0,  # King value is not essential for material count\n    }\n    material_balance = 0.0\n    for piece in board.piece_map().values():\n        value = piece_values[piece.piece_type]\n        if piece.color == chess.WHITE:\n            material_balance += value\n        else:\n            material_balance -= value\n    return material_balance", "def feature(board: chess.Board) -> float:\n    \"Measures the material balance by counting the difference in total value of pieces\"\n    piece_values = {\n        chess.PAWN: 100,\n        chess.KNIGHT: 320,\n        chess.BISHOP: 330,\n        chess.ROOK: 500,\n        chess.QUEEN: 900,\n        chess.KING: 0,  # King value is not essential for material count\n    }\n    material_balance = 0.0\n    for piece in board.piece_map().values():\n        value = piece_values[piece.piece_type]\n        if piece.color == chess.WHITE:\n            material_balance += value\n        else:\n            material_balance -= value\n    return material_balance", "def feature(board: chess.Board) -> float:\n    \"Measures the king's distance from the center as a factor of safety.\"\n    king_square = next(square for square in board.piece_map() if board.piece_at(square).piece_type == chess.KING)\n    distance_to_center = chess.square_distance(king_square, chess.parse_square('e4')) + chess.square_distance(king_square, chess.parse_square('e5'))\n    return float(8 - distance_to_center)  # The closer to the center, the safer", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of pieces in the opponent's back rank\"\n    rank = 0 if board.turn == chess.WHITE else 7\n    opponent_color = chess.BLACK if board.turn == chess.WHITE else chess.WHITE\n    pieces_in_back_rank = sum(1 for sq in range(8) if board.piece_at(chess.square(sq, rank)) and board.piece_at(chess.square(sq, rank)).color == opponent_color)\n    return float(pieces_in_back_rank)", "def feature(board: chess.Board) -> float:\n    \"Measures the distance of pieces from the opponent's back rank.\"\n    opponent_back_rank = 7 if board.turn == chess.WHITE else 0\n    distance_sum = sum(chess.square_distance(square, opponent_back_rank * 8) for square, piece in board.piece_map().items() \n                       if piece.color == board.turn)\n    return float(distance_sum)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of pieces attacking the opponent's king\"\n    opponent_king_square = None\n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.KING and piece.color != board.turn:\n            opponent_king_square = square\n            break\n    if opponent_king_square is None:\n        return 0.0\n    attacking_pieces = sum(1 for move in board.legal_moves if move.to_square == opponent_king_square)\n    return float(attacking_pieces)", "def feature(board: chess.Board) -> float:\n    \"Calculates the distance of the nearest enemy's pawn to each king.\"\n    white_king_square = board.king(chess.WHITE)\n    black_king_square = board.king(chess.BLACK)\n    white_distance = min((chess.square_distance(white_king_square, pawn) for pawn in board.piece_map() if board.piece_at(pawn).color == chess.BLACK and board.piece_at(pawn).piece_type == chess.PAWN), default=8)\n    black_distance = min((chess.square_distance(black_king_square, pawn) for pawn in board.piece_map() if board.piece_at(pawn).color == chess.WHITE and board.piece_at(pawn).piece_type == chess.PAWN), default=8)\n    return float(white_distance - black_distance)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of advanced pawns (pawns on ranks 4 or 5 for White and 4 or 3 for Black)\"\n    advanced_pawns = 0\n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.PAWN:\n            if (piece.color == chess.WHITE and chess.square_rank(square) >= 4) or \\\n               (piece.color == chess.BLACK and chess.square_rank(square) <= 4):\n                advanced_pawns += 1\n    return float(advanced_pawns)", "def feature(board: chess.Board) -> float:\n    \"Calculates the average distance of pieces from the center of the board.\"\n    center_squares = [chess.E4, chess.D4, chess.E5, chess.D5]\n    total_distance = 0\n    piece_count = len(board.piece_map())\n    \n    for piece_square in board.piece_map():\n        total_distance += min(chess.square_distance(piece_square, center) for center in center_squares)\n    \n    return total_distance / piece_count if piece_count > 0 else 0.0", "def feature(board: chess.Board) -> float:\n    \"Calculates the total distance of all pieces to their optimal square positions.\"\n    optimal_positions = {\n        chess.PAWN: [chess.A7, chess.B7, chess.C7, chess.D7, chess.E7, chess.F7, chess.G7, chess.H7],\n        chess.ROOK: [chess.A8, chess.H8],\n        chess.KNIGHT: [chess.B8, chess.G8],\n        chess.BISHOP: [chess.C8, chess.F8],\n        chess.QUEEN: [chess.D8],\n        chess.KING: [chess.E8]\n    }\n    total_distance = 0\n    piece_count = 0\n    for sq, piece in board.piece_map().items():\n        optimal_squares = optimal_positions.get(piece.piece_type, [])\n        for opt_sq in optimal_squares:\n            total_distance += chess.square_distance(sq, opt_sq)\n            piece_count += 1\n    return float(total_distance / piece_count) if piece_count > 0 else 0.0", "def feature(board: chess.Board) -> float:\n    'Measures the distance of the king to the center of the board for both players.'\n    white_king_square = board.king(chess.WHITE)\n    black_king_square = board.king(chess.BLACK)\n    distance_to_center = (2 - chess.square_file(white_king_square)) + (2 - chess.square_rank(white_king_square))\n    distance_to_center += (2 - chess.square_file(black_king_square)) + (2 - chess.square_rank(black_king_square))\n    return float(distance_to_center)", "def feature(board: chess.Board) -> float:\n    \"Measures the distance of major pieces (Rooks, Queens) from the starting rank.\"\n    major_pieces = [chess.ROOK, chess.QUEEN]\n    total_distance = sum(chess.square_rank(square) for square, piece in board.piece_map().items() if piece.piece_type in major_pieces)\n    return float(total_distance)", "def feature(board: chess.Board) -> float:\n    \"Calculates the total distance of all pieces to their opposing king.\"\n    white_king_square = next(square for square, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color == chess.WHITE)\n    black_king_square = next(square for square, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color == chess.BLACK)\n    total_distance = sum(chess.square_distance(square, black_king_square) for square, piece in board.piece_map().items() if piece.color == chess.WHITE)\n    total_distance += sum(chess.square_distance(square, white_king_square) for square, piece in board.piece_map().items() if piece.color == chess.BLACK)\n    return float(total_distance)", "def feature(board: chess.Board) -> float:\n    \"Measures the total mobility of each player by summing the number of legal moves for both sides.\"\n    white_moves = sum(1 for _ in board.legal_moves if board.turn)\n    board.turn = not board.turn\n    black_moves = sum(1 for _ in board.legal_moves if not board.turn)\n    return float(white_moves + black_moves)", "def feature(board: chess.Board) -> float:\n    \"Calculates the sum of the distances of all pieces from the opponent's back rank.\"\n    total_distance = 0\n    opponent_color = chess.WHITE if board.turn else chess.BLACK\n    for square, piece in board.piece_map().items():\n        if piece.color == opponent_color:\n            total_distance += chess.square_distance(square, chess.square_file(0) if opponent_color == chess.WHITE else chess.square_file(7))\n    return float(total_distance)", "def feature(board: chess.Board) -> float:\n    \"Measures the king safety by counting the number of pawns around the king.\"\n    king_square = next(sq for sq, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color == board.turn)\n    safe_pawns = sum(1 for sq in board.piece_map() if board.piece_at(sq) and board.piece_at(sq).piece_type == chess.PAWN and \n                     abs(chess.square_file(sq) - chess.square_file(king_square)) <= 1 and \n                     abs(chess.square_rank(sq) - chess.square_rank(king_square)) <= 1)\n    return float(safe_pawns)", "def feature(board: chess.Board) -> float:\n    'Counts the number of threats made by each player towards the opponent\u2019s pieces.'\n    threats = 0\n    for square, piece in board.piece_map().items():\n        if piece.color != board.turn:\n            threats += len(board.attackers(board.turn, square))\n    return float(threats)", "def feature(board: chess.Board) -> float:\n    \"Measures the material balance by counting the difference in total value of pieces\"\n    piece_values = {\n        chess.PAWN: 100,\n        chess.KNIGHT: 320,\n        chess.BISHOP: 330,\n        chess.ROOK: 500,\n        chess.QUEEN: 900,\n        chess.KING: 0,  # King value is not essential for material count\n    }\n    material_balance = 0.0\n    for piece in board.piece_map().values():\n        value = piece_values[piece.piece_type]\n        if piece.color == chess.WHITE:\n            material_balance += value\n        else:\n            material_balance -= value\n    return material_balance", "def feature(board: chess.Board) -> float:\n    \"Measures the distance of the king from its starting position (to evaluate king safety).\"\n    king_square = board.king(chess.WHITE) if board.turn else board.king(chess.BLACK)\n    if king_square is None:\n        return 0.0\n    distance_from_start = chess.square_distance(king_square, chess.E1 if board.turn else chess.E8)\n    return float(8 - distance_from_start)  # Closer to start is safer; further away is more dangerous.", "def feature(board: chess.Board) -> float:\n    \"Counts the number of squares in the opponent's half that are controlled by the current player's pieces.\"\n    controlled_squares = set()\n    for square in board.piece_map():\n        piece = board.piece_map()[square]\n        if piece.color == board.turn:\n            for move in board.legal_moves:\n                if move.from_square == square:\n                    controlled_squares.add(move.to_square)\n    opponent_half = {i for i in range(0, 32)} if board.turn == chess.WHITE else {i for i in range(32, 64)}\n    controlled_in_half = controlled_squares.intersection(opponent_half)\n    return float(len(controlled_in_half))", "def feature(board: chess.Board) -> float:\n    \"Calculates how many pieces are in the back rank for both players\"\n    back_rank_count = 0\n    for rank in [0, 7]:  # 0 for White's back rank, 7 for Black's back rank\n        for file in range(8):\n            square = chess.square(file, rank)\n            if board.piece_at(square) is not None:\n                back_rank_count += 1\n    return float(back_rank_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of squares controlled by each player's pawns.\"\n    def controlled_squares(color):\n        return sum(1 for square in board.piece_map() if board.piece_at(square) and board.piece_at(square).color == color and \n                   (chess.square_file(square) > 0 and board.is_attacked_by(not color, square - 1)) or \n                   (chess.square_file(square) < 7 and board.is_attacked_by(not color, square + 1)))\n    return float(controlled_squares(chess.WHITE) - controlled_squares(chess.BLACK))", "def feature(board: chess.Board) -> float:\n    \"Estimates the mobility factor based on the total number of legal moves available for both sides.\"\n    white_moves = sum(1 for move in board.legal_moves if move.from_square & chess.WHITE)\n    black_moves = sum(1 for move in board.legal_moves if move.from_square & chess.BLACK)\n    return float(white_moves - black_moves)", "def feature(board: chess.Board) -> float:\n    \"Counts the bishops each player has on opposite colored squares as a strength indicator\"\n    white_bishops = sum(1 for sq in board.pieces(chess.BISHOP, chess.WHITE) if (chess.square_file(sq) + chess.square_rank(sq)) % 2 == 0)\n    black_bishops = sum(1 for sq in board.pieces(chess.BISHOP, chess.BLACK) if (chess.square_file(sq) + chess.square_rank(sq)) % 2 == 0)\n    return float(white_bishops - black_bishops)", "def feature(board: chess.Board) -> float:\n    'Counts the number of isolated pawns for both players.'\n    isolated_white = sum(1 for square in board.piece_map() if board.piece_at(square).color == chess.WHITE and board.piece_at(square).piece_type == chess.PAWN and not (board.is_attacked_by(chess.BLACK, chess.square_file(square) - 1) or board.is_attacked_by(chess.BLACK, chess.square_file(square) + 1)))\n    isolated_black = sum(1 for square in board.piece_map() if board.piece_at(square).color == chess.BLACK and board.piece_at(square).piece_type == chess.PAWN and not (board.is_attacked_by(chess.WHITE, chess.square_file(square) - 1) or board.is_attacked_by(chess.WHITE, chess.square_file(square) + 1)))\n    result = float(isolated_white - isolated_black)\n    return result", "def feature(board: chess.Board) -> float:\n    'Measures the number of squares controlled by pieces of the current player.'\n    controlled_squares = set()\n    for square, piece in board.piece_map().items():\n        if piece.color == board.turn:\n            controlled_squares.update(board.attacks(square))\n    return len(controlled_squares)", "def feature(board: chess.Board) -> float:\n    \"Calculates the distance of the closest king to the opposing player's pieces.\"\n    king_square = next((square for square in board.piece_map() if board.piece_at(square).piece_type == chess.KING), None)\n    if not king_square:\n        return 0.0\n    other_pieces = [square for square in board.piece_map() if board.piece_at(square).color != board.piece_at(king_square).color]\n    closest_distance = min(chess.square_distance(king_square, sq) for sq in other_pieces)\n    return float(closest_distance)", "def feature(board: chess.Board) -> float:\n    \"Measures the spatial distribution of pieces by calculating the variance of their positions.\"\n    color = chess.WHITE if board.turn else chess.BLACK\n    positions = [chess.square_file(square) + chess.square_rank(square) * 10 for square, piece in board.piece_map().items() if piece.color == color]\n    \n    if not positions:\n        return 0.0\n    \n    mean_position = sum(positions) / len(positions)\n    variance = sum((x - mean_position) ** 2 for x in positions) / len(positions)\n    return float(variance)", "def feature(board: chess.Board) -> float:\n    \"Calculates the imbalance in material based on piece types.\"\n    piece_values = {\n        chess.PAWN: 100,\n        chess.KNIGHT: 320,\n        chess.BISHOP: 330,\n        chess.ROOK: 500,\n        chess.QUEEN: 900,\n        chess.KING: float('inf'),  # King shouldn't be counted\n    }\n    material_balance = 0\n    for piece in board.piece_map().values():\n        material_balance += piece_values[piece.piece_type] if piece.color == chess.WHITE else -piece_values[piece.piece_type]\n    return float(material_balance)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces in the center squares (e4, e5, d4, d5)\"\n    center_squares = [chess.parse_square('e4'), chess.parse_square('e5'),\n                      chess.parse_square('d4'), chess.parse_square('d5')]\n    center_piece_count = sum(1 for square in center_squares if board.piece_at(square) is not None)\n    return float(center_piece_count)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of advanced pawns (pawns on ranks 4 or 5 for White and 4 or 3 for Black)\"\n    advanced_pawns = 0\n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.PAWN:\n            if (piece.color == chess.WHITE and chess.square_rank(square) >= 4) or \\\n               (piece.color == chess.BLACK and chess.square_rank(square) <= 4):\n                advanced_pawns += 1\n    return float(advanced_pawns)", "def feature(board: chess.Board) -> float:\n    \"Evaluates the structure of pawns by counting isolated pawns for each player.\"\n    white_isolated = sum(1 for file in range(8) if board.piece_at(chess.square(chess.square_file(chess.A2), 1)) and \n                         (file == 0 or not board.piece_at(chess.square(file - 1, 1))) and \n                         (file == 7 or not board.piece_at(chess.square(file + 1, 1))))\n    black_isolated = sum(1 for file in range(8) if board.piece_at(chess.square(chess.square_file(chess.A7), 6)) and \n                         (file == 0 or not board.piece_at(chess.square(file - 1, 6))) and \n                         (file == 7 or not board.piece_at(chess.square(file + 1, 6))))\n    return float(white_isolated - black_isolated)", "def feature(board: chess.Board) -> float:\n    \"Measures the overall piece activity by calculating the distance of pieces from their starting positions.\"\n    activity = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == chess.WHITE:\n            activity += chess.square_distance(square, piece.piece_type)\n        else:\n            activity -= chess.square_distance(square, piece.piece_type)\n    return float(activity)", "def feature(board: chess.Board) -> float:\n    \"Measures the distance of the center squares from the pieces of each player.\"\n    center_squares = [chess.E4, chess.E5, chess.D4, chess.D5]\n    white_distance = sum(min(chess.square_distance(square, center) for center in center_squares) for square, piece in board.piece_map().items() if piece.color == chess.WHITE)\n    black_distance = sum(min(chess.square_distance(square, center) for center in center_squares) for square, piece in board.piece_map().items() if piece.color == chess.BLACK)\n    return float(white_distance - black_distance)", "def feature(board: chess.Board) -> float:\n    \"Measures the distribution of pieces by calculating the average rank and file occupied.\"\n    total_rank = total_file = piece_count = 0\n    for square, piece in board.piece_map().items():\n        total_rank += chess.square_rank(square)\n        total_file += chess.square_file(square)\n        piece_count += 1\n    return float((total_rank + total_file) / piece_count) if piece_count > 0 else 0.0", "def feature(board: chess.Board) -> float:\n    \"Measures the number of pieces attacked by each player.\"\n    white_attacked = sum(1 for square in board.piece_map() if board.is_attacked_by(chess.WHITE, square))\n    black_attacked = sum(1 for square in board.piece_map() if board.is_attacked_by(chess.BLACK, square))\n    return float(white_attacked - black_attacked)", "def feature(board: chess.Board) -> float:\n    \"Evaluates the presence of major pieces (rooks and queens) on the seventh rank.\"\n    major_pieces_seventh_rank = sum(1 for square, piece in board.piece_map().items() if (piece.piece_type in {chess.ROOK, chess.QUEEN}) and chess.square_rank(square) == 6)\n    return float(major_pieces_seventh_rank)", "def feature(board: chess.Board) -> float:\n    \"Calculates the sum of the distances of all pieces from their respective pawns.\"\n    total_distance = 0\n    for square, piece in board.piece_map().items():\n        if piece.piece_type != chess.PAWN:\n            pawn_squares = [s for s in board.piece_map() if board.piece_at(s).piece_type == chess.PAWN and board.piece_at(s).color == piece.color]\n            if pawn_squares:\n                closest_distance = min(chess.square_distance(square, ps) for ps in pawn_squares)\n                total_distance += closest_distance\n    return total_distance", "def feature(board: chess.Board) -> float:\n    \"Measures the distance of the closest piece to the opponent's pawns.\"\n    closest_white_pawn = min((chess.square_distance(sq, chess.parse_square('a2')) for sq in board.piece_map() if board.piece_map()[sq].color == chess.WHITE and board.piece_map()[sq].piece_type != chess.KING), default=8)\n    closest_black_pawn = min((chess.square_distance(sq, chess.parse_square('a7')) for sq in board.piece_map() if board.piece_map()[sq].color == chess.BLACK and board.piece_map()[sq].piece_type != chess.KING), default=8)\n    return float(closest_white_pawn - closest_black_pawn)", "def feature(board: chess.Board) -> float:\n    \"Measures the value of pieces protected by pawns for both sides.\"\n    value_map = {\n        chess.PAWN: 1, chess.KNIGHT: 3, chess.BISHOP: 3,\n        chess.ROOK: 5, chess.QUEEN: 9, chess.KING: 0\n    }\n\n    white_protected_value = 0\n    black_protected_value = 0\n\n    for square, piece in board.piece_map().items():\n        if piece.color == chess.WHITE:\n            attackers = board.attackers(chess.BLACK, square)\n            if all(board.piece_at(attacker) is None or board.piece_at(attacker).color == chess.WHITE for attacker in attackers):\n                white_protected_value += value_map.get(piece.piece_type, 0)\n        else:\n            attackers = board.attackers(chess.WHITE, square)\n            if all(board.piece_at(attacker) is None or board.piece_at(attacker).color == chess.BLACK for attacker in attackers):\n                black_protected_value += value_map.get(piece.piece_type, 0)\n\n    return white_protected_value - black_protected_value", "def feature(board: chess.Board) -> float:\n    \"Measures the proportion of pieces on the board that are developed (not on the back rank).\"\n    developed_pieces = 0\n    total_pieces = len(board.piece_map())\n    for square, piece in board.piece_map().items():\n        if piece.color == (chess.WHITE if board.turn else chess.BLACK) and chess.square_rank(square) > 0:\n            developed_pieces += 1\n    return float(developed_pieces / total_pieces) if total_pieces > 0 else 0.0", "def feature(board: chess.Board) -> float:\n    \"Calculates the activity of rooks as a ratio to their total count.\"\n    white_rooks = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE and piece.piece_type == chess.ROOK)\n    black_rooks = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK and piece.piece_type == chess.ROOK)\n    active_white_rooks = sum(1 for square in board.piece_map() if board.piece_at(square).color == chess.WHITE and chess.square_file(square) in (0, 7))\n    active_black_rooks = sum(1 for square in board.piece_map() if board.piece_at(square).color == chess.BLACK and chess.square_file(square) in (0, 7))\n    return float(active_white_rooks / (white_rooks + 1e-5) - active_black_rooks / (black_rooks + 1e-5))", "def feature(board: chess.Board) -> float:\n    'Measures the distance of the king to the center of the board for both players.'\n    white_king_square = board.king(chess.WHITE)\n    black_king_square = board.king(chess.BLACK)\n    distance_to_center = (2 - chess.square_file(white_king_square)) + (2 - chess.square_rank(white_king_square))\n    distance_to_center += (2 - chess.square_file(black_king_square)) + (2 - chess.square_rank(black_king_square))\n    return float(distance_to_center)", "def feature(board: chess.Board) -> float:\n    \"Measures the material balance by counting the difference in total value of pieces\"\n    piece_values = {\n        chess.PAWN: 100,\n        chess.KNIGHT: 320,\n        chess.BISHOP: 330,\n        chess.ROOK: 500,\n        chess.QUEEN: 900,\n        chess.KING: 0,  # King value is not essential for material count\n    }\n    material_balance = 0.0\n    for piece in board.piece_map().values():\n        value = piece_values[piece.piece_type]\n        if piece.color == chess.WHITE:\n            material_balance += value\n        else:\n            material_balance -= value\n    return material_balance", "def feature(board: chess.Board) -> float:\n    \"Measures the development of pieces based on their proximity to the center.\"\n    centralization_score = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == board.turn:\n            centralization_score += 8 - (chess.square_file(square) + chess.square_rank(square))\n    return float(centralization_score)", "def feature(board: chess.Board) -> float:\n    \"Counts doubled pawns for both players and returns the difference.\"\n    white_doubled_pawns = sum(1 for file in range(8) if board.piece_map().get(chess.parse_square(f'{chess.FILE_NAMES[file]}2')) and \n                               board.piece_map().get(chess.parse_square(f'{chess.FILE_NAMES[file]}3')))\n    black_doubled_pawns = sum(1 for file in range(8) if board.piece_map().get(chess.parse_square(f'{chess.FILE_NAMES[file]}7')) and \n                               board.piece_map().get(chess.parse_square(f'{chess.FILE_NAMES[file]}6')))\n    return float(white_doubled_pawns - black_doubled_pawns)", "def feature(board: chess.Board) -> float:\n    \"Measures the control of center squares (d4, d5, e4, e5) by counting controlled squares.\"\n    center_squares = [chess.parse_square('d4'), chess.parse_square('d5'), chess.parse_square('e4'), chess.parse_square('e5')]\n    control = sum(1 for square in center_squares if board.is_attacked_by(chess.WHITE, square)) - sum(1 for square in center_squares if board.is_attacked_by(chess.BLACK, square))\n    return float(control)", "def feature(board: chess.Board) -> float:\n    \"Measures the distance from the king to the nearest enemy piece.\"\n    white_king_square = next(square for square, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color == chess.WHITE)\n    black_king_square = next(square for square, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color == chess.BLACK)\n    nearest_enemy_distance_white = min((chess.square_distance(white_king_square, enemy_square) for enemy_square in board.attackers(chess.BLACK, black_king_square)), default=8)\n    nearest_enemy_distance_black = min((chess.square_distance(black_king_square, enemy_square) for enemy_square in board.attackers(chess.WHITE, white_king_square)), default=8)\n    return float(nearest_enemy_distance_white - nearest_enemy_distance_black)", "def feature(board: chess.Board) -> float:\n    \"Measures the difference in piece activity, based on distance from the center.\"\n    activity_score = 0\n    center_squares = [chess.E4, chess.E5, chess.D4, chess.D5]\n    \n    for square, piece in board.piece_map().items():\n        distance_from_center = chess.square_distance(square, chess.E4)  # E4 is the center square\n        if piece.color == chess.WHITE:\n            activity_score += 1 / (1 + distance_from_center)  # Closer pieces have higher activity score\n        else:\n            activity_score -= 1 / (1 + distance_from_center)  # Closer pieces have lower activity score for black\n            \n    return float(activity_score)", "def feature(board: chess.Board) -> float:\n    'Calculates the average distance of pieces from their home squares.'\n    home_squares = {\n        chess.WHITE: [chess.A2, chess.B2, chess.C2, chess.D2, chess.E2, chess.F2, chess.G2, chess.H2],\n        chess.BLACK: [chess.A7, chess.B7, chess.C7, chess.D7, chess.E7, chess.F7, chess.G7, chess.H7]\n    }\n    total_distance = 0\n    piece_count = 0\n    \n    for piece in board.piece_map().values():\n        square = next(sq for sq in chess.SQUARES if board.piece_at(sq) == piece)\n        home_square = home_squares[piece.color][piece.piece_type - 1]\n        total_distance += chess.square_distance(square, home_square)\n        piece_count += 1\n        \n    return total_distance / piece_count if piece_count > 0 else 0.0", "def feature(board: chess.Board) -> float:\n    \"Calculates the total distance of pieces to their respective back ranks\"\n    total_distance = 0\n    for sq in board.piece_map():\n        piece = board.piece_at(sq)\n        if piece.color == chess.WHITE:\n            total_distance += chess.square_distance(sq, chess.A8)\n        else:\n            total_distance += chess.square_distance(sq, chess.A1)\n    return float(total_distance)", "def feature(board: chess.Board) -> float:\n    \"Calculates the distance from each pawn to the opponent's back rank.\"\n    distance_sum = 0\n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.PAWN:\n            target_rank = 0 if piece.color == chess.WHITE else 7\n            distance_sum += chess.square_rank(square) - target_rank\n    return float(distance_sum)", "def feature(board: chess.Board) -> float:\n    \"Evaluates the distance of kings from the center of the board as a safety measure.\"\n    white_king_square = next(square for square, piece in board.piece_map().items() if piece.color == chess.WHITE and piece.piece_type == chess.KING)\n    black_king_square = next(square for square, piece in board.piece_map().items() if piece.color == chess.BLACK and piece.piece_type == chess.KING)\n    white_king_distance = chess.square_distance(white_king_square, chess.E4) + chess.square_distance(white_king_square, chess.D4)\n    black_king_distance = chess.square_distance(black_king_square, chess.E4) + chess.square_distance(black_king_square, chess.D4)\n    return float(white_king_distance - black_king_distance)", "def feature(board: chess.Board) -> float:\n    \"Evaluates the number of backward pawns for both players.\"\n    backward_pawns_white = sum(1 for sq in chess.SQUARES if board.piece_at(sq) and \n                                  board.piece_at(sq).color == chess.WHITE and\n                                  board.piece_at(sq).piece_type == chess.PAWN and\n                                  (sq in [chess.A7, chess.B7, chess.C7, chess.D7, chess.E7, chess.F7, chess.G7, chess.H7] and \n                                   board.piece_at(sq + 8) is None))\n    backward_pawns_black = sum(1 for sq in chess.SQUARES if board.piece_at(sq) and \n                                  board.piece_at(sq).color == chess.BLACK and\n                                  board.piece_at(sq).piece_type == chess.PAWN and\n                                  (sq in [chess.A2, chess.B2, chess.C2, chess.D2, chess.E2, chess.F2, chess.G2, chess.H2] and \n                                   board.piece_at(sq - 8) is None))\n    return float(backward_pawns_white - backward_pawns_black)", "def feature(board: chess.Board) -> float:\n    \"Calculates the total value of pieces that are currently pinned.\"\n    pinned_value = 0\n    for square, piece in board.piece_map().items():\n        if board.is_attacked_by(not piece.color, square):\n            pinned_value += {chess.PAWN: 100, chess.KNIGHT: 320, chess.BISHOP: 330, chess.ROOK: 500, chess.QUEEN: 900, chess.KING: 20000}.get(piece.piece_type, 0)\n    \n    return float(pinned_value)", "def feature(board: chess.Board) -> float:\n    \"Measures the distance of each side's king from the center of the board (central control).\"\n    center_squares = [chess.D4, chess.D5, chess.E4, chess.E5]\n    white_king_square = next((square for square in board.piece_map() if board.piece_map()[square].piece_type == chess.KING and board.piece_map()[square].color == chess.WHITE), None)\n    black_king_square = next((square for square in board.piece_map() if board.piece_map()[square].piece_type == chess.KING and board.piece_map()[square].color == chess.BLACK), None)\n    white_king_distance = min(chess.square_distance(white_king_square, sq) for sq in center_squares) if white_king_square else 0\n    black_king_distance = min(chess.square_distance(black_king_square, sq) for sq in center_squares) if black_king_square else 0\n    return float(black_king_distance - white_king_distance)", "def feature(board: chess.Board) -> float:\n    \"Measures the distance of kings to the center of the board for both players.\"\n    white_king_square = chess.square_name(board.king(chess.WHITE))\n    black_king_square = chess.square_name(board.king(chess.BLACK))\n    white_king_distance = (chess.square_file(board.king(chess.WHITE)) - 3)**2 + (chess.square_rank(board.king(chess.WHITE)) - 3)**2\n    black_king_distance = (chess.square_file(board.king(chess.BLACK)) - 3)**2 + (chess.square_rank(board.king(chess.BLACK)) - 3)**2\n    return float(black_king_distance - white_king_distance)", "def feature(board: chess.Board) -> float:\n    \"Calculates how many pieces are in the back rank for both players\"\n    back_rank_count = 0\n    for rank in [0, 7]:  # 0 for White's back rank, 7 for Black's back rank\n        for file in range(8):\n            square = chess.square(file, rank)\n            if board.piece_at(square) is not None:\n                back_rank_count += 1\n    return float(back_rank_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the total distance of all pieces to their optimal square positions.\"\n    optimal_positions = {\n        chess.PAWN: [chess.A7, chess.B7, chess.C7, chess.D7, chess.E7, chess.F7, chess.G7, chess.H7],\n        chess.ROOK: [chess.A8, chess.H8],\n        chess.KNIGHT: [chess.B8, chess.G8],\n        chess.BISHOP: [chess.C8, chess.F8],\n        chess.QUEEN: [chess.D8],\n        chess.KING: [chess.E8]\n    }\n    total_distance = 0\n    piece_count = 0\n    for sq, piece in board.piece_map().items():\n        optimal_squares = optimal_positions.get(piece.piece_type, [])\n        for opt_sq in optimal_squares:\n            total_distance += chess.square_distance(sq, opt_sq)\n            piece_count += 1\n    return float(total_distance / piece_count) if piece_count > 0 else 0.0", "def feature(board: chess.Board) -> float:\n    \"Calculates the average distance of pieces from the opponent's back rank.\"\n    color = board.turn\n    total_distance = 0\n    count = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == color:\n            distance = 7 - chess.square_rank(square) if color == chess.WHITE else chess.square_rank(square)\n            total_distance += distance\n            count += 1\n    return total_distance / count if count > 0 else 0.0", "def feature(board: chess.Board) -> float:\n    \"Measures the difference in material of pieces above a certain rank.\"\n    piece_values = {chess.PAWN: 100, chess.KNIGHT: 320, chess.BISHOP: 330,\n                    chess.ROOK: 500, chess.QUEEN: 900, chess.KING: 20000}\n    critical_rank = 4\n    white_material = sum(piece_values[board.piece_at(square).piece_type] \n                         for square in board.piece_map() \n                         if board.piece_at(square).color == chess.WHITE and \n                         chess.square_rank(square) >= critical_rank)\n    black_material = sum(piece_values[board.piece_at(square).piece_type] \n                         for square in board.piece_map() \n                         if board.piece_at(square).color == chess.BLACK and \n                         chess.square_rank(square) < critical_rank)\n    return float(white_material - black_material)", "def feature(board: chess.Board) -> float:\n    \"Calculates the distance of all major pieces to the opponent's king.\"\n    total_distance = 0\n    opponent_king_square = next(square for square in board.piece_map() if board.piece_at(square).piece_type == chess.KING and board.piece_at(square).color != board.turn)\n    for square in board.piece_map():\n        piece = board.piece_at(square)\n        if piece.color == board.turn and piece.piece_type in {chess.QUEEN, chess.ROOK, chess.BISHOP}:\n            total_distance += chess.square_distance(square, opponent_king_square)\n    return float(total_distance)", "def feature(board: chess.Board) -> float:\n    \"Measures the material balance by counting the difference in total value of pieces\"\n    piece_values = {\n        chess.PAWN: 100,\n        chess.KNIGHT: 320,\n        chess.BISHOP: 330,\n        chess.ROOK: 500,\n        chess.QUEEN: 900,\n        chess.KING: 0,  # King value is not essential for material count\n    }\n    material_balance = 0.0\n    for piece in board.piece_map().values():\n        value = piece_values[piece.piece_type]\n        if piece.color == chess.WHITE:\n            material_balance += value\n        else:\n            material_balance -= value\n    return material_balance", "def feature(board: chess.Board) -> float:\n    \"Measures the material imbalance due to isolated pawns.\"\n    isolated_pawns_white = sum(1 for square in board.pieces(chess.PAWN, chess.WHITE) if \n                                (chess.square_file(square) > 0 and board.piece_at(square - 1) is None) and \n                                (chess.square_file(square) < 7 and board.piece_at(square + 1) is None))\n    isolated_pawns_black = sum(1 for square in board.pieces(chess.PAWN, chess.BLACK) if \n                                (chess.square_file(square) > 0 and board.piece_at(square - 1) is None) and \n                                (chess.square_file(square) < 7 and board.piece_at(square + 1) is None))\n    result = float(isolated_pawns_white - isolated_pawns_black)\n    return result", "def feature(board: chess.Board) -> float:\n    \"Measures the distance of the queens from the center of the board (e4 and d4)\"\n    total_distance = sum(chess.square_distance(square, chess.parse_square('e4')) + \n                         chess.square_distance(square, chess.parse_square('d4'))\n                         for square, piece in board.piece_map().items()\n                         if piece.piece_type == chess.QUEEN)\n    return float(total_distance)", "def feature(board: chess.Board) -> float:\n    \"Evaluates material balance adjusted for piece activity on the board.\"\n    piece_values = {chess.PAWN: 100, chess.KNIGHT: 300, chess.BISHOP: 300, chess.ROOK: 500, chess.QUEEN: 900, chess.KING: 0}\n    activity_factor = sum(1 for piece in board.piece_map().values() if piece.color == board.turn)\n    material_balance = sum(piece_values[piece.piece_type] * (1 if piece.color == chess.WHITE else -1) for piece in board.piece_map().values())\n    return float(material_balance + activity_factor)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of squares with less than 2 defenders from the player's perspective.\"\n    weak_squares_count = 0\n    for square in chess.SQUARES:\n        if board.piece_at(square) is None:\n            attackers = board.attackers(not board.turn, square)\n            if len(attackers) < 2:\n                weak_squares_count += 1\n    return float(weak_squares_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the value difference based on material, considering advanced pawns (pawns on 4th and 5th ranks for White, 3rd and 4th for Black).\"\n    material_value = 0\n    for square, piece in board.piece_map().items():\n        value = piece.piece_type\n        if piece.color == chess.WHITE:\n            if chess.square_rank(square) >= 4:\n                value += 1  # Add point for advanced pawns (White)\n            material_value += value\n        else:\n            if chess.square_rank(square) <= 4:\n                value += 1  # Add point for advanced pawns (Black)\n            material_value -= value\n    return float(material_value)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of pieces behind the pawns for the current player.\"\n    color = chess.WHITE if board.turn else chess.BLACK\n    back_rank = 0 if color == chess.WHITE else 7\n    pieces_behind_pawns = sum(1 for sq, piece in board.piece_map().items() if piece.color == color and chess.square_rank(sq) > back_rank and piece.piece_type != chess.PAWN)\n    return float(pieces_behind_pawns)", "def feature(board: chess.Board) -> float:\n    \"Gives the difference in the number of pieces on squares with more than one attack (strong squares).\"\n    strong_squares_count = 0\n    for square in chess.SQUARES:\n        if len(board.attackers(chess.WHITE, square)) > 1:\n            strong_squares_count += 1\n        if len(board.attackers(chess.BLACK, square)) > 1:\n            strong_squares_count -= 1\n    return float(strong_squares_count)", "def feature(board: chess.Board) -> float:\n    \"Measures the value of pieces protected by pawns for both sides.\"\n    value_map = {\n        chess.PAWN: 1, chess.KNIGHT: 3, chess.BISHOP: 3,\n        chess.ROOK: 5, chess.QUEEN: 9, chess.KING: 0\n    }\n\n    white_protected_value = 0\n    black_protected_value = 0\n\n    for square, piece in board.piece_map().items():\n        if piece.color == chess.WHITE:\n            attackers = board.attackers(chess.BLACK, square)\n            if all(board.piece_at(attacker) is None or board.piece_at(attacker).color == chess.WHITE for attacker in attackers):\n                white_protected_value += value_map.get(piece.piece_type, 0)\n        else:\n            attackers = board.attackers(chess.WHITE, square)\n            if all(board.piece_at(attacker) is None or board.piece_at(attacker).color == chess.BLACK for attacker in attackers):\n                black_protected_value += value_map.get(piece.piece_type, 0)\n\n    return white_protected_value - black_protected_value", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pawns that have advanced to the 4th and 5th ranks for White, and 4th and 3rd ranks for Black.\"\n    white_advanced_pawns = sum(1 for square in board.piece_map() if board.piece_at(square).piece_type == chess.PAWN and square >= chess.A4)\n    black_advanced_pawns = sum(1 for square in board.piece_map() if board.piece_at(square).piece_type == chess.PAWN and square <= chess.H3)\n    return float(white_advanced_pawns - black_advanced_pawns)", "def feature(board: chess.Board) -> float:\n    \"Calculate the total piece value for the current player.\"\n    value = 0\n    for piece in board.piece_map().values():\n        if piece.color == board.turn:\n            value += piece.piece_type\n    return float(value)", "def feature(board: chess.Board) -> float:\n    \"Measures the imbalance of pawns compared to other pieces for both players.\"\n    white_pawn_count = len([p for p in board.piece_map().values() if p.color == chess.WHITE and p.piece_type == chess.PAWN])\n    black_pawn_count = len([p for p in board.piece_map().values() if p.color == chess.BLACK and p.piece_type == chess.PAWN])\n    white_non_pawn_count = len([p for p in board.piece_map().values() if p.color == chess.WHITE and p.piece_type != chess.PAWN])\n    black_non_pawn_count = len([p for p in board.piece_map().values() if p.color == chess.BLACK and p.piece_type != chess.PAWN])\n    if (white_non_pawn_count + black_non_pawn_count) == 0:\n        return 0.0\n    result = (white_pawn_count - black_pawn_count) / (white_non_pawn_count + black_non_pawn_count)\n    return result", "def feature(board: chess.Board) -> float:\n    \"Calculates how many pieces are pinned by each side to their king.\"\n    def count_pinned(color):\n        pinned_count = 0\n        for square, piece in board.piece_map().items():\n            if piece.color == color:\n                for attacker in board.attackers(not color, square):\n                    if board.is_attacked_by(color, attacker):\n                        pinned_count += 1\n        return pinned_count\n\n    white_pinned = count_pinned(chess.WHITE)\n    black_pinned = count_pinned(chess.BLACK)\n    result = float(white_pinned - black_pinned)\n    return result", "def feature(board: chess.Board) -> float:\n    \"Calculates the ratio of minor pieces to major pieces for both players.\"\n    minor_count = {chess.WHITE: 0, chess.BLACK: 0}\n    major_count = {chess.WHITE: 0, chess.BLACK: 0}\n    for piece in board.piece_map().values():\n        if piece.piece_type in [chess.KNIGHT, chess.BISHOP]:\n            minor_count[piece.color] += 1\n        elif piece.piece_type in [chess.ROOK, chess.QUEEN]:\n            major_count[piece.color] += 1\n    ratio_white = minor_count[chess.WHITE] / (major_count[chess.WHITE] + 1)  # Avoid division by zero\n    ratio_black = minor_count[chess.BLACK] / (major_count[chess.BLACK] + 1)\n    return float(ratio_white - ratio_black)", "def feature(board: chess.Board) -> float:\n    \"Calculates the distance from each pawn to the opponent's back rank.\"\n    distance_sum = 0\n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.PAWN:\n            target_rank = 0 if piece.color == chess.WHITE else 7\n            distance_sum += chess.square_rank(square) - target_rank\n    return float(distance_sum)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of protected pieces for each player.\"\n    white_protected = sum(1 for square, piece in board.piece_map().items() if piece.color == chess.WHITE and any(board.is_attacked_by(chess.BLACK, square_2) for square_2 in board.attackers(chess.WHITE, square)) == False)\n    black_protected = sum(1 for square, piece in board.piece_map().items() if piece.color == chess.BLACK and any(board.is_attacked_by(chess.WHITE, square_2) for square_2 in board.attackers(chess.BLACK, square)) == False)\n    return float(white_protected - black_protected)", "def feature(board: chess.Board) -> float:\n    'Measures the distance of the king to the center of the board for both players.'\n    white_king_square = board.king(chess.WHITE)\n    black_king_square = board.king(chess.BLACK)\n    distance_to_center = (2 - chess.square_file(white_king_square)) + (2 - chess.square_rank(white_king_square))\n    distance_to_center += (2 - chess.square_file(black_king_square)) + (2 - chess.square_rank(black_king_square))\n    return float(distance_to_center)", "def feature(board: chess.Board) -> float:\n    \"Evaluates the average rank of each side's pawns to gauge advancement.\"\n    white_pawn_ranks = [chess.square_rank(square) for square in board.piece_map() if board.piece_at(square).piece_type == chess.PAWN and board.piece_at(square).color == chess.WHITE]\n    black_pawn_ranks = [7 - chess.square_rank(square) for square in board.piece_map() if board.piece_at(square).piece_type == chess.PAWN and board.piece_at(square).color == chess.BLACK]\n    average_white_rank = sum(white_pawn_ranks) / max(len(white_pawn_ranks), 1)\n    average_black_rank = sum(black_pawn_ranks) / max(len(black_pawn_ranks), 1)\n    return float(average_white_rank - average_black_rank)", "def feature(board: chess.Board) -> float:\n    \"Evaluates the activity of knights based on the number of moves they can make.\"\n    knight_moves = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == board.turn and piece.piece_type == chess.KNIGHT:\n            knight_moves += len(list(board.legal_moves))  # Count legal moves for each knight\n    return float(knight_moves)", "def feature(board: chess.Board) -> float:\n    'Counts the number of pieces that are pinned against the king'\n    def is_pinned(piece_square):\n        for attacker_square in board.attackers(board.color_at(piece_square), piece_square):\n            if board.is_attacked_by(board.color_at(piece_square), chess.KING):\n                return True\n        return False\n    \n    pinned_count = sum(1 for square in board.piece_map() if is_pinned(square))\n    return float(pinned_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the imbalance in material based on piece types.\"\n    piece_values = {\n        chess.PAWN: 100,\n        chess.KNIGHT: 320,\n        chess.BISHOP: 330,\n        chess.ROOK: 500,\n        chess.QUEEN: 900,\n        chess.KING: float('inf'),  # King shouldn't be counted\n    }\n    material_balance = 0\n    for piece in board.piece_map().values():\n        material_balance += piece_values[piece.piece_type] if piece.color == chess.WHITE else -piece_values[piece.piece_type]\n    return float(material_balance)", "def feature(board: chess.Board) -> float:\n    \"Computes the ratio of rooks on open files for both players.\"\n    open_file_count_white = sum(1 for file in range(8) if not any(board.piece_at(chess.square(file, rank)) is not None for rank in range(8)))\n    open_file_count_black = sum(1 for file in range(8) if not any(board.piece_at(chess.square(file, rank)) is not None for rank in range(0, 4)))\n    total_rooks_white = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE and piece.piece_type == chess.ROOK)\n    total_rooks_black = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK and piece.piece_type == chess.ROOK)\n    \n    result = (open_file_count_white / (total_rooks_white + 1)) - (open_file_count_black / (total_rooks_black + 1))\n    return result", "def feature(board: chess.Board) -> float:\n    \"Calculates the ratio of minor pieces (Knights and Bishops) to rooks on the board.\"\n    minor_pieces = 0\n    rooks = 0\n    for piece in board.piece_map().values():\n        if piece.piece_type in [chess.KNIGHT, chess.BISHOP]:\n            minor_pieces += 1\n        elif piece.piece_type == chess.ROOK:\n            rooks += 1\n    return float(minor_pieces / (rooks + 1))  # Avoid division by zero", "def feature(board: chess.Board) -> float:\n    \"Measures the mobility of all pieces on the board by counting their legal moves.\"\n    total_moves = sum(len(list(board.legal_moves)) for piece in board.piece_map().values())\n    return float(total_moves)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of check and checkmate threats posed to the opponent's king.\"\n    threats = 0\n    if board.is_check():\n        threats += 1\n    for move in board.legal_moves:\n        board.push(move)\n        if board.is_checkmate():\n            threats += 1\n        board.pop()\n    return float(threats)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of squares controlled by the player's pieces that are adjacent to the opponent's king.\"\n    opponent_king = board.king(not board.turn)\n    controlled_squares = set()\n    if opponent_king is None:\n        return 0.0\n    for square in chess.SQUARES:\n        piece = board.piece_at(square)\n        if piece and piece.color == board.turn:\n            controlled_squares.update(board.attacks(square))\n    adjacent_squares = [s for s in chess.SQUARES if chess.square_distance(s, opponent_king) == 1]\n    return float(len(set(adjacent_squares) & controlled_squares))", "def feature(board: chess.Board) -> float:\n    \"Calculates the total value of pieces that are currently unprotected.\"\n    unprotected_value = 0\n    for square, piece in board.piece_map().items():\n        if not board.attackers(piece.color, square):\n            unprotected_value += {\n                chess.PAWN: 100,\n                chess.KNIGHT: 320,\n                chess.BISHOP: 330,\n                chess.ROOK: 500,\n                chess.QUEEN: 900,\n                chess.KING: 20000\n            }[piece.piece_type]\n    return float(unprotected_value)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of squares in the opponent's half that are controlled by the current player's pieces.\"\n    controlled_squares = set()\n    for square in board.piece_map():\n        piece = board.piece_map()[square]\n        if piece.color == board.turn:\n            for move in board.legal_moves:\n                if move.from_square == square:\n                    controlled_squares.add(move.to_square)\n    opponent_half = {i for i in range(0, 32)} if board.turn == chess.WHITE else {i for i in range(32, 64)}\n    controlled_in_half = controlled_squares.intersection(opponent_half)\n    return float(len(controlled_in_half))", "def feature(board: chess.Board) -> float:\n    \"Evaluates the number of safe squares for the king of the current player.\"\n    king_square = board.king(board.turn)\n    safe_squares = sum(1 for move in board.legal_moves if chess.square_distance(king_square, move.to_square) == 1 and not board.is_attacked_by(not board.turn, move.to_square))\n    return float(safe_squares)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of protected pawns for both players.\"\n    protected_pawns = 0\n    for square in chess.SQUARES:\n        piece = board.piece_at(square)\n        if piece and piece.piece_type == chess.PAWN:\n            attackers = board.attackers(piece.color, square)\n            if attackers:\n                num_protectors = len(board.attackers(not piece.color, square))\n                if num_protectors > 0:\n                    protected_pawns += 1\n    return float(protected_pawns)", "def feature(board: chess.Board) -> float:\n    'Measures the total number of pieces attacking key squares (central squares).'\n    center_squares = [chess.D4, chess.D5, chess.E4, chess.E5]\n    attackers = sum(len(board.attackers(color, sq)) for color in [chess.WHITE, chess.BLACK] for sq in center_squares)\n    return float(attackers)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of double attacks possible (pieces attacking two different targets).\"\n    double_attacks = 0\n    for piece_square in board.piece_map():\n        piece = board.piece_at(piece_square)\n        if piece:\n            attackers = board.attackers(piece.color, piece_square)\n            for target_square in attackers:\n                if board.is_attacked_by(piece.color, target_square):\n                    double_attacks += 1\n    return float(double_attacks)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of pawn majority on one side of the board.\"\n    white_pawn_count = sum(1 for square in board.piece_map() \n                            if board.piece_map()[square].piece_type == chess.PAWN and \n                            chess.square_file(square) < 4)\n    black_pawn_count = sum(1 for square in board.piece_map() \n                            if board.piece_map()[square].piece_type == chess.PAWN and \n                            chess.square_file(square) > 3)\n    return float(white_pawn_count - black_pawn_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of squares left unchecked by own pieces.\"\n    unchecked_squares = 0\n    for rank in range(8):\n        for file in range(8):\n            square = chess.square(file, rank)\n            if board.piece_at(square) is None and not board.is_attacked_by(board.turn, square):\n                unchecked_squares += 1\n    return float(unchecked_squares)", "def feature(board: chess.Board) -> float:\n    'Counts the number of pieces that are pinned against their own king.'\n    pinned_pieces = 0\n    for square in board.piece_map():\n        piece = board.piece_at(square)\n        if piece.color == board.turn:\n            if board.is_attacked_by(not piece.color, square) and board.is_attacked_by(piece.color, piece.color and board.king(piece.color)):\n                pinned_pieces += 1\n    return float(pinned_pieces)", "def feature(board: chess.Board) -> float:\n    \"Measures the king's safety by counting the number of squares it can move to that are not attacked.\"\n    current_king_square = board.king(board.turn)\n    safe_squares = sum(1 for sq in board.attacks(current_king_square) if not board.is_attacked_by(not board.turn, sq))\n    return float(safe_squares)", "def feature(board: chess.Board) -> float:\n    \"Calculates the positional advantage based on the number of pieces on the back rank.\"\n    white_back_rank = sum(1 for square in range(8) if board.piece_at(chess.parse_square(f'a{1}')) and board.piece_at(chess.parse_square(f'a{1}')).color == chess.WHITE)\n    black_back_rank = sum(1 for square in range(8) if board.piece_at(chess.parse_square(f'a{8}')) and board.piece_at(chess.parse_square(f'a{8}')).color == chess.BLACK)\n    return float(white_back_rank - black_back_rank)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of pieces attacked by each player.\"\n    white_attacked = sum(1 for square in board.piece_map() if board.is_attacked_by(chess.WHITE, square))\n    black_attacked = sum(1 for square in board.piece_map() if board.is_attacked_by(chess.BLACK, square))\n    return float(white_attacked - black_attacked)", "def feature(board: chess.Board) -> float:\n    \"Counts the potential threats to the opponent's pieces.\"\n    threats = sum(1 for square in board.piece_map() if board.is_attacked_by(chess.WHITE, square))\n    return float(threats)", "def feature(board: chess.Board) -> float:\n    \"Calculates the ratio of light-square vs dark-square control by each player.\"\n    white_light_control = len([sq for sq in chess.SQUARES if board.is_attacked_by(chess.WHITE, sq) and (sq % 2 == 0)])\n    white_dark_control = len([sq for sq in chess.SQUARES if board.is_attacked_by(chess.WHITE, sq) and (sq % 2 != 0)])\n    black_light_control = len([sq for sq in chess.SQUARES if board.is_attacked_by(chess.BLACK, sq) and (sq % 2 == 0)])\n    black_dark_control = len([sq for sq in chess.SQUARES if board.is_attacked_by(chess.BLACK, sq) and (sq % 2 != 0)])\n    return float(white_light_control + black_dark_control)", "def feature(board: chess.Board) -> float:\n    \"Calculates the activity of rooks as a ratio to their total count.\"\n    white_rooks = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE and piece.piece_type == chess.ROOK)\n    black_rooks = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK and piece.piece_type == chess.ROOK)\n    active_white_rooks = sum(1 for square in board.piece_map() if board.piece_at(square).color == chess.WHITE and chess.square_file(square) in (0, 7))\n    active_black_rooks = sum(1 for square in board.piece_map() if board.piece_at(square).color == chess.BLACK and chess.square_file(square) in (0, 7))\n    return float(active_white_rooks / (white_rooks + 1e-5) - active_black_rooks / (black_rooks + 1e-5))"], "all_features": ["def feature(board: chess.Board) -> float:\n    \"Measures the material balance by counting the difference in total value of pieces\"\n    piece_values = {\n        chess.PAWN: 100,\n        chess.KNIGHT: 320,\n        chess.BISHOP: 330,\n        chess.ROOK: 500,\n        chess.QUEEN: 900,\n        chess.KING: 0,  # King value is not essential for material count\n    }\n    material_balance = 0.0\n    for piece in board.piece_map().values():\n        value = piece_values[piece.piece_type]\n        if piece.color == chess.WHITE:\n            material_balance += value\n        else:\n            material_balance -= value\n    return material_balance", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of pieces attacking the opponent's king\"\n    opponent_king_square = None\n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.KING and piece.color != board.turn:\n            opponent_king_square = square\n            break\n    if opponent_king_square is None:\n        return 0.0\n    attacking_pieces = sum(1 for move in board.legal_moves if move.to_square == opponent_king_square)\n    return float(attacking_pieces)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of advanced pawns (pawns on ranks 4 or 5 for White and 4 or 3 for Black)\"\n    advanced_pawns = 0\n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.PAWN:\n            if (piece.color == chess.WHITE and chess.square_rank(square) >= 4) or \\\n               (piece.color == chess.BLACK and chess.square_rank(square) <= 4):\n                advanced_pawns += 1\n    return float(advanced_pawns)", "def feature(board: chess.Board) -> float:\n    \"Measures the tempo based on the current fullmove number for strategic insights\"\n    fullmove_number = board.fullmove_number\n    return float(fullmove_number)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces in the center squares (e4, e5, d4, d5)\"\n    center_squares = [chess.parse_square('e4'), chess.parse_square('e5'),\n                      chess.parse_square('d4'), chess.parse_square('d5')]\n    center_piece_count = sum(1 for square in center_squares if board.piece_at(square) is not None)\n    return float(center_piece_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates how many pieces are in the back rank for both players\"\n    back_rank_count = 0\n    for rank in [0, 7]:  # 0 for White's back rank, 7 for Black's back rank\n        for file in range(8):\n            square = chess.square(file, rank)\n            if board.piece_at(square) is not None:\n                back_rank_count += 1\n    return float(back_rank_count)", "def feature(board: chess.Board) -> float:\n    \"Scores the king safety based on the number of pieces defending the king\"\n    king_square = None\n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.KING and piece.color == board.turn:\n            king_square = square\n            break\n    if king_square is None:\n        return 0.0\n    defending_pieces = sum(1 for piece in board.piece_map().values()\n                           if piece.color == board.turn and board.is_attacked_by(not board.turn, king_square))\n    return float(defending_pieces)", "def feature(board: chess.Board) -> float:\n    \"Measures the pawn majority on one side of the board\"\n    white_pawns = sum(1 for square, piece in board.piece_map().items() if piece.color == chess.WHITE and piece.piece_type == chess.PAWN)\n    black_pawns = sum(1 for square, piece in board.piece_map().items() if piece.color == chess.BLACK and piece.piece_type == chess.PAWN)\n    return float(white_pawns - black_pawns)", "def feature(board: chess.Board) -> float:\n    'Measures the total material value of active pieces on the board for both players.'\n    value_map = {chess.PAWN: 100, chess.KNIGHT: 320, chess.BISHOP: 330, chess.ROOK: 500, chess.QUEEN: 900, chess.KING: 0}\n    total_value = 0.0\n    for piece in board.piece_map().values():\n        total_value += value_map[piece.piece_type] if piece.color == chess.WHITE else -value_map[piece.piece_type]\n    return total_value", "def feature(board: chess.Board) -> float:\n    'Counts the number of pieces for each player and gives a ratio of pieces on the board.'\n    white_pieces = sum(1 for p in board.piece_map().values() if p.color == chess.WHITE)\n    black_pieces = sum(1 for p in board.piece_map().values() if p.color == chess.BLACK)\n    return white_pieces / (black_pieces + 1e-6)  # Avoid division by zero", "def feature(board: chess.Board) -> float:\n    'Calculates the number of pieces that are currently defended by their own pieces.'\n    defenders = 0\n    for square, piece in board.piece_map().items():\n        attackers = board.attackers(piece.color, square)\n        if attackers:\n            defenders += 1\n    return defenders", "def feature(board: chess.Board) -> float:\n    'Measures the number of squares controlled by pieces of the current player.'\n    controlled_squares = set()\n    for square, piece in board.piece_map().items():\n        if piece.color == board.turn:\n            controlled_squares.update(board.attacks(square))\n    return len(controlled_squares)", "def feature(board: chess.Board) -> float:\n    'Calculates the king safety score based on the number of attacks on the king.'\n    king_square = board.king(chess.WHITE) if board.turn == chess.WHITE else board.king(chess.BLACK)\n    return float(len(board.attackers(not board.turn, king_square)))", "def feature(board: chess.Board) -> float:\n    'Counts the number of checks the opponent can deliver next move.'\n    check_moves = sum(1 for move in board.legal_moves if board.is_check())\n    return float(check_moves)", "def feature(board: chess.Board) -> float:\n    'Measures the distance of the king to the center of the board for both players.'\n    white_king_square = board.king(chess.WHITE)\n    black_king_square = board.king(chess.BLACK)\n    distance_to_center = (2 - chess.square_file(white_king_square)) + (2 - chess.square_rank(white_king_square))\n    distance_to_center += (2 - chess.square_file(black_king_square)) + (2 - chess.square_rank(black_king_square))\n    return float(distance_to_center)", "def feature(board: chess.Board) -> float:\n    'Calculates the total number of squares a player is attacking but where there are no pieces.'\n    attacking_empty_squares = set()\n    for square, piece in board.piece_map().items():\n        if piece.color == board.turn:\n            for attacked_square in board.attacks(square):\n                if not board.piece_at(attacked_square):\n                    attacking_empty_squares.add(attacked_square)\n    return float(len(attacking_empty_squares))", "def feature(board: chess.Board) -> float:\n    'Counts the number of threats made by each player towards the opponent\u2019s pieces.'\n    threats = 0\n    for square, piece in board.piece_map().items():\n        if piece.color != board.turn:\n            threats += len(board.attackers(board.turn, square))\n    return float(threats)", "def feature(board: chess.Board) -> float:\n    \"Calculate the total piece value for the current player.\"\n    value = 0\n    for piece in board.piece_map().values():\n        if piece.color == board.turn:\n            value += piece.piece_type\n    return float(value)", "def feature(board: chess.Board) -> float:\n    \"Calculate the difference in total piece value between both players.\"\n    white_value = sum(piece.piece_type for piece in board.piece_map().values() if piece.color == chess.WHITE)\n    black_value = sum(piece.piece_type for piece in board.piece_map().values() if piece.color == chess.BLACK)\n    return float(white_value - black_value)", "def feature(board: chess.Board) -> float:\n    \"Count the number of pieces on the board for the current player.\"\n    count = sum(1 for piece in board.piece_map().values() if piece.color == board.turn)\n    return float(count)", "def feature(board: chess.Board) -> float:\n    \"Count the number of pawns for the current player.\"\n    count = sum(1 for piece in board.piece_map().values() if piece.color == board.turn and piece.piece_type == chess.PAWN)\n    return float(count)", "def feature(board: chess.Board) -> float:\n    \"Check if the player's king is in check.\"\n    return float(1.0 if board.is_check() else 0.0)", "def feature(board: chess.Board) -> float:\n    \"Check if the player's king is in checkmate.\"\n    return float(1.0 if board.is_checkmate() else 0.0)", "def feature(board: chess.Board) -> float:\n    \"Count the number of pieces attacking the current player's king.\"\n    king_square = next(square for square, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color == board.turn)\n    attackers = board.attackers(not board.turn, king_square)\n    return float(len(attackers))", "def feature(board: chess.Board) -> float:\n    \"Calculate the material imbalance between bishops and knights for current player.\"\n    bishops = sum(1 for piece in board.piece_map().values() if piece.color == board.turn and piece.piece_type == chess.BISHOP)\n    knights = sum(1 for piece in board.piece_map().values() if piece.color == board.turn and piece.piece_type == chess.KNIGHT)\n    return float(bishops - knights)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of pieces on the board filtered by piece type value.\"\n    piece_values = {chess.PAWN: 100, chess.KNIGHT: 320, chess.BISHOP: 330, chess.ROOK: 500, chess.QUEEN: 900, chess.KING: 20000}\n    white_value = sum(piece_values[piece.piece_type] for piece in board.piece_map().values() if piece.color == chess.WHITE)\n    black_value = sum(piece_values[piece.piece_type] for piece in board.piece_map().values() if piece.color == chess.BLACK)\n    return float(white_value - black_value)", "def feature(board: chess.Board) -> float:\n    \"Calculates the central pawns advantage by counting pawns on central squares.\"\n    central_squares = [chess.D4, chess.E4, chess.D5, chess.E5]\n    white_central_pawns = sum(1 for square in central_squares if board.piece_at(square) == chess.PAWN and board.piece_at(square).color == chess.WHITE)\n    black_central_pawns = sum(1 for square in central_squares if board.piece_at(square) == chess.PAWN and board.piece_at(square).color == chess.BLACK)\n    return float(white_central_pawns - black_central_pawns)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of major pieces (rooks and queens) present for each side.\"\n    major_piece_value = {chess.ROOK: 1, chess.QUEEN: 1}\n    white_major_pieces = sum(major_piece_value.get(board.piece_at(square).piece_type, 0) for square in board.piece_map() if board.piece_at(square).color == chess.WHITE)\n    black_major_pieces = sum(major_piece_value.get(board.piece_at(square).piece_type, 0) for square in board.piece_map() if board.piece_at(square).color == chess.BLACK)\n    return float(white_major_pieces - black_major_pieces)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of possible legal moves for both players.\"\n    white_legal_moves = len(list(board.legal_moves)) if board.turn == chess.WHITE else 0\n    black_legal_moves = len(list(board.legal_moves)) if board.turn == chess.BLACK else 0\n    return float(white_legal_moves - black_legal_moves)", "def feature(board: chess.Board) -> float:\n    \"Computes the mobility score based on the number of squares each piece can move to.\"\n    mobility_score = 0\n    for square in board.piece_map():\n        piece = board.piece_at(square)\n        if piece is not None:\n            mobility_score += len(list(board.legal_moves))\n    return float(mobility_score)", "def feature(board: chess.Board) -> float:\n    \"Measures the presence and location of the kings related to pawn structure.\"\n    white_king_square = next(square for square in board.piece_map() if board.piece_at(square).piece_type == chess.KING and board.piece_at(square).color == chess.WHITE)\n    black_king_square = next(square for square in board.piece_map() if board.piece_at(square).piece_type == chess.KING and board.piece_at(square).color == chess.BLACK)\n    return float(chess.square_distance(white_king_square, black_king_square))", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of doubled pawns for both players.\"\n    def count_doubled_pawns(color):\n        pawn_files = [0] * 8\n        for square in board.piece_map():\n            piece = board.piece_at(square)\n            if piece and piece.piece_type == chess.PAWN and piece.color == color:\n                pawn_files[chess.square_file(square)] += 1\n        return sum(1 for count in pawn_files if count > 1)\n    \n    white_doubled = count_doubled_pawns(chess.WHITE)\n    black_doubled = count_doubled_pawns(chess.BLACK)\n    return float(white_doubled - black_doubled)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of available squares for all pieces on the board.\"\n    available_squares = sum(1 for square in board.piece_map() if board.piece_at(square) is not None and len(list(board.legal_moves)) > 0)\n    return float(available_squares)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of pieces attacked by each player.\"\n    white_attacked = sum(1 for square in board.piece_map() if board.is_attacked_by(chess.WHITE, square))\n    black_attacked = sum(1 for square in board.piece_map() if board.is_attacked_by(chess.BLACK, square))\n    return float(white_attacked - black_attacked)", "def feature(board: chess.Board) -> float:\n    \"Calculates king safety by counting the number of attackers around each king.\"\n    def attackers_around_king(color):\n        king_square = next(square for square in board.piece_map() if board.piece_at(square).piece_type == chess.KING and board.piece_at(square).color == color)\n        return len(board.attackers(not color, king_square))\n    \n    white_attackers = attackers_around_king(chess.WHITE)\n    black_attackers = attackers_around_king(chess.BLACK)\n    return float(black_attackers - white_attackers)", "def feature(board: chess.Board) -> float:\n    \"Measures the total piece-square value based on piece type and position\"\n    piece_values = {\n        chess.PAWN: 100,\n        chess.KNIGHT: 320,\n        chess.BISHOP: 330,\n        chess.ROOK: 500,\n        chess.QUEEN: 900,\n        chess.KING: 20000\n    }\n    total_value = 0.0\n    for square, piece in board.piece_map().items():\n        total_value += piece_values[piece.piece_type] * (1 if piece.color == chess.WHITE else -1)\n    return total_value", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pawns for each player and computes their difference\"\n    white_pawns = len([p for p in board.piece_map().values() if p.piece_type == chess.PAWN and p.color == chess.WHITE])\n    black_pawns = len([p for p in board.piece_map().values() if p.piece_type == chess.PAWN and p.color == chess.BLACK])\n    return float(white_pawns - black_pawns)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of pieces in the opponent's back rank\"\n    rank = 0 if board.turn == chess.WHITE else 7\n    opponent_color = chess.BLACK if board.turn == chess.WHITE else chess.WHITE\n    pieces_in_back_rank = sum(1 for sq in range(8) if board.piece_at(chess.square(sq, rank)) and board.piece_at(chess.square(sq, rank)).color == opponent_color)\n    return float(pieces_in_back_rank)", "def feature(board: chess.Board) -> float:\n    \"Measures the mobility of pieces by counting the total number of legal moves\"\n    total_moves = sum(1 for move in board.legal_moves)\n    return float(total_moves)", "def feature(board: chess.Board) -> float:\n    \"Measures the distance of the king from the center of the board\"\n    king_square = next((sq for sq, p in board.piece_map().items() if p.piece_type == chess.KING and p.color == board.turn), None)\n    if king_square is None:\n        return 0.0\n    center_squares = [chess.parse_square(sq) for sq in ['d4', 'd5', 'e4', 'e5']]\n    distance_to_center = min(chess.square_distance(king_square, sq) for sq in center_squares)\n    return float(8 - distance_to_center)", "def feature(board: chess.Board) -> float:\n    \"Checks if any player's king is in check and assigns a value for being in check\"\n    if board.is_check():\n        return 1.0 if board.turn else -1.0\n    return 0.0", "def feature(board: chess.Board) -> float:\n    \"Measures how close the game is to stalemate by evaluating the halfmove clock\"\n    return float(board.halfmove_clock)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces that are attacking enemy squares.\"\n    attacking_pieces = sum(1 for square in board.piece_map() if board.is_attacked_by(not board.piece_at(square).color, square))\n    return float(attacking_pieces)", "def feature(board: chess.Board) -> float:\n    \"Measures the king safety by counting the number of pawns protecting the king.\"\n    king_square = next(square for square, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color == (chess.WHITE if board.turn else chess.BLACK))\n    protecting_pawns = sum(1 for sq in board.piece_map() if board.piece_at(sq).piece_type == chess.PAWN and board.is_attacked_by(board.piece_at(sq).color, king_square))\n    return float(protecting_pawns)", "def feature(board: chess.Board) -> float:\n    \"Calculates the mobility by counting the number of legal moves for each side.\"\n    legal_moves = len(list(board.legal_moves))\n    return float(legal_moves)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces that can be attacked in the next move.\"\n    attackable_pieces = sum(1 for square in board.piece_map() if board.attackers(not board.piece_at(square).color, square))\n    return float(attackable_pieces)", "def feature(board: chess.Board) -> float:\n    \"Evaluates the distribution of pawns across the ranks.\"\n    pawns = [square for square, piece in board.piece_map().items() if piece.piece_type == chess.PAWN]\n    ranks = [chess.square_rank(square) for square in pawns]\n    rank_distribution = sum(1 for rank in range(8) if rank in ranks)\n    return float(rank_distribution)", "def feature(board: chess.Board) -> float:\n    \"Measures the total distance of all pieces from the enemy king.\"\n    enemy_king_square = next(square for square, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color == (chess.BLACK if board.turn else chess.WHITE))\n    total_distance = sum(chess.square_distance(square, enemy_king_square) for square in board.piece_map())\n    return float(total_distance)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces that are pinned by an enemy piece.\"\n    pinned_pieces = sum(1 for square in board.piece_map() if board.is_attacked_by(not board.piece_at(square).color, square) and board.is_check())\n    return float(pinned_pieces)", "def feature(board: chess.Board) -> float:\n    \"Calculates the ratio of actively developed pieces to total pieces.\"\n    developed_pieces = sum(1 for square, piece in board.piece_map().items() if chess.square_rank(square) > 4 and piece.color == (chess.WHITE if board.turn else chess.BLACK))\n    total_pieces = len(board.piece_map())\n    return developed_pieces / total_pieces if total_pieces > 0 else 0.0", "def feature(board: chess.Board) -> float:\n    \"Measures the number of squares around the enemy king that are controlled.\"\n    enemy_king_square = next(square for square, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color == (chess.BLACK if board.turn else chess.WHITE))\n    controlled_squares = sum(1 for square in chess.SQUARES if board.is_attacked_by(not board.piece_at(enemy_king_square).color, square))\n    return float(controlled_squares)", "def feature(board: chess.Board) -> float:\n    \"Calculates the mobility of pieces by counting the total number of legal moves available.\"\n    return float(len(list(board.legal_moves)))", "def feature(board: chess.Board) -> float:\n    \"Measures the total value of all pieces on the board according to standard chess piece values.\"\n    piece_values = {chess.PAWN: 100, chess.KNIGHT: 320, chess.BISHOP: 330, chess.ROOK: 500, chess.QUEEN: 900, chess.KING: 20000}\n    total_value = 0.0\n    for piece in board.piece_map().values():\n        total_value += piece_values[piece.piece_type] if piece.color == chess.WHITE else -piece_values[piece.piece_type]\n    return total_value", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces on the board for each side and returns the difference.\"\n    white_pieces = len([p for p in board.piece_map().values() if p.color == chess.WHITE])\n    black_pieces = len([p for p in board.piece_map().values() if p.color == chess.BLACK])\n    return float(white_pieces - black_pieces)", "def feature(board: chess.Board) -> float:\n    \"Evaluates the king safety by counting the number of attacking pieces around the opposing king.\"\n    king_square = board.king(chess.WHITE) if board.turn else board.king(chess.BLACK)\n    attacking_pieces = len(board.attackers(chess.BLACK if board.turn else chess.WHITE, king_square))\n    return float(attacking_pieces)", "def feature(board: chess.Board) -> float:\n    \"Measures the control of center squares (d4, d5, e4, e5) by counting controlled squares.\"\n    center_squares = [chess.parse_square('d4'), chess.parse_square('d5'), chess.parse_square('e4'), chess.parse_square('e5')]\n    control = sum(1 for square in center_squares if board.is_attacked_by(chess.WHITE, square)) - sum(1 for square in center_squares if board.is_attacked_by(chess.BLACK, square))\n    return float(control)", "def feature(board: chess.Board) -> float:\n    \"Checks for potential promotions by counting the pawns able to advance to the seventh rank.\"\n    potential_promotions = sum(1 for square in board.piece_map() if board.piece_at(square).piece_type == chess.PAWN and (square // 8 == 6 if board.piece_at(square).color == chess.WHITE else square // 8 == 1))\n    return float(potential_promotions)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of doubled pawns for both sides to assess pawn weaknesses.\"\n    doubled_pawns = 0\n    for file in range(8):\n        white_pawns = len([sq for sq in range(chess.A2, chess.H2 + 1) if board.piece_at(sq) is not None and board.piece_at(sq).piece_type == chess.PAWN and chess.square_file(sq) == file])\n        black_pawns = len([sq for sq in range(chess.A7, chess.H7 + 1) if board.piece_at(sq) is not None and board.piece_at(sq).piece_type == chess.PAWN and chess.square_file(sq) == file])\n        doubled_pawns += max(0, white_pawns - 1) + max(0, black_pawns - 1)\n    return float(doubled_pawns)", "def feature(board: chess.Board) -> float:\n    \"Computes the difference between the number of pieces attacking the opponent\u2019s pieces.\"\n    attacking_count = sum(len(board.attackers(piece.color, square)) for square, piece in board.piece_map().items())\n    return float(attacking_count)", "def feature(board: chess.Board) -> float:\n    \"Measures the control of central squares by counting the pieces on d4, d5, e4, e5.\"\n    central_squares = [chess.parse_square(square) for square in ['d4', 'd5', 'e4', 'e5']]\n    control = sum(1 for sq in central_squares if board.piece_at(sq) is not None)\n    return float(control)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pawns for each player and returns the difference.\"\n    white_pawns = len([p for p in board.piece_map().values() if p.piece_type == chess.PAWN and p.color == chess.WHITE])\n    black_pawns = len([p for p in board.piece_map().values() if p.piece_type == chess.PAWN and p.color == chess.BLACK])\n    return float(white_pawns - black_pawns)", "def feature(board: chess.Board) -> float:\n    \"Measures the longest distance between the two kings on the board.\"\n    white_king_square = next((sq for sq, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color == chess.WHITE), None)\n    black_king_square = next((sq for sq, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color == chess.BLACK), None)\n    if white_king_square is not None and black_king_square is not None:\n        distance = chess.square_distance(white_king_square, black_king_square)\n        return float(distance)\n    return 0.0", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces supported by other pieces, contributing to a sense of security.\"\n    supported_pieces_count = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == board.turn:\n            for attacker in board.attackers(board.turn, square):\n                if board.piece_at(attacker) and board.piece_at(attacker).color == board.turn:\n                    supported_pieces_count += 1\n    return float(supported_pieces_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of open files for rooks for both players.\"\n    open_files = 0\n    for file in range(8):\n        if all(board.piece_at(chess.square(file, rank)) is None for rank in range(8)):\n            open_files += 1\n    return float(open_files)", "def feature(board: chess.Board) -> float:\n    \"Measures the attack potential by counting the number of pieces attacking opponent's pieces.\"\n    attacking_pieces = 0\n    for square in board.piece_map():\n        piece = board.piece_at(square)\n        if piece is not None and piece.color != board.turn:\n            attacking_pieces += len(board.attackers(board.turn, square))\n    return float(attacking_pieces)", "def feature(board: chess.Board) -> float:\n    \"Evaluates king safety by counting the number of pieces protecting the king.\"\n    king_square = next((sq for sq, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color == board.turn), None)\n    if king_square is not None:\n        protecting_pieces = len(board.attackers(board.turn, king_square))\n        return float(protecting_pieces)\n    return 0.0", "def feature(board: chess.Board) -> float:\n    \"Measures the total number of pawns on the board.\"\n    pawns_count = sum(1 for piece in board.piece_map().values() if piece.piece_type == chess.PAWN)\n    return float(pawns_count)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of squares controlled by each player.\"\n    controlled_squares_white = sum(1 for move in board.legal_moves if move.from_square not in board.attackers(chess.BLACK, move.to_square))\n    controlled_squares_black = sum(1 for move in board.legal_moves if move.from_square not in board.attackers(chess.WHITE, move.to_square))\n    return float(controlled_squares_white - controlled_squares_black)", "def feature(board: chess.Board) -> float:\n    \"Calculates the distance of the closest king to the opposing player's pieces.\"\n    king_square = next((square for square in board.piece_map() if board.piece_at(square).piece_type == chess.KING), None)\n    if not king_square:\n        return 0.0\n    other_pieces = [square for square in board.piece_map() if board.piece_at(square).color != board.piece_at(king_square).color]\n    closest_distance = min(chess.square_distance(king_square, sq) for sq in other_pieces)\n    return float(closest_distance)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of pieces under attack by opposing pieces.\"\n    attacked_count = sum(1 for square in board.piece_map() if board.is_attacked_by(not board.piece_at(square).color, square))\n    return float(attacked_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of available moves for the current player.\"\n    available_moves_count = len(list(board.legal_moves))\n    return float(available_moves_count)", "def feature(board: chess.Board) -> float:\n    \"Checks if the position is in a check position and scores accordingly.\"\n    return float(1.0 if board.is_check() else 0.0)", "def feature(board: chess.Board) -> float:\n    \"Measures the distance of the furthest enemy piece from the king.\"\n    king_square = next((square for square in board.piece_map() if board.piece_at(square).piece_type == chess.KING), None)\n    if not king_square:\n        return 0.0\n    enemy_pieces = [square for square in board.piece_map() if board.piece_at(square).color != board.piece_at(king_square).color]\n    if not enemy_pieces:\n        return 0.0\n    furthest_distance = max(chess.square_distance(king_square, sq) for sq in enemy_pieces)\n    return float(furthest_distance)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of supported pieces on the board.\"\n    supported_count = 0\n    for square, piece in board.piece_map().items():\n        if any(board.is_attacked_by(piece.color, support_sq) for support_sq in board.attackers(not piece.color, square)):\n            supported_count += 1\n    return float(supported_count)", "def feature(board: chess.Board) -> float:\n    \"Checks the material imbalance based on piece types.\"\n    material_values = {chess.PAWN: 100, chess.KNIGHT: 300, chess.BISHOP: 300, chess.ROOK: 500, chess.QUEEN: 900}\n    material_balance = 0\n    for piece in board.piece_map().values():\n        color_factor = 1 if piece.color == chess.WHITE else -1\n        material_balance += color_factor * material_values.get(piece.piece_type, 0)\n    return float(material_balance)", "def feature(board: chess.Board) -> float:\n    \"Calculates the sum of material values for each player on the board.\"\n    value_map = {\n        chess.PAWN: 100,\n        chess.KNIGHT: 320,\n        chess.BISHOP: 330,\n        chess.ROOK: 500,\n        chess.QUEEN: 900,\n        chess.KING: 0  # King has no value in terms of material\n    }\n    white_value = sum(value_map[piece.piece_type] for piece in board.piece_map().values() if piece.color == chess.WHITE)\n    black_value = sum(value_map[piece.piece_type] for piece in board.piece_map().values() if piece.color == chess.BLACK)\n    return float(white_value - black_value)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pawns on the board for both players.\"\n    white_pawns = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE and piece.piece_type == chess.PAWN)\n    black_pawns = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK and piece.piece_type == chess.PAWN)\n    return float(white_pawns - black_pawns)", "def feature(board: chess.Board) -> float:\n    \"Measures the distance of the kings from each other on the board.\"\n    white_king = next(square for square, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color == chess.WHITE)\n    black_king = next(square for square, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color == chess.BLACK)\n    distance = chess.square_distance(white_king, black_king)\n    return float(distance)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of attack opportunities for each player's pieces.\"\n    white_attacks = sum(len(board.attackers(chess.WHITE, square)) for square in board.piece_map() if board.piece_map()[square].color == chess.WHITE)\n    black_attacks = sum(len(board.attackers(chess.BLACK, square)) for square in board.piece_map() if board.piece_map()[square].color == chess.BLACK)\n    return float(white_attacks - black_attacks)", "def feature(board: chess.Board) -> float:\n    \"Determines the number of legal moves available for each player.\"\n    white_moves = len(list(board.legal_moves)) if board.turn else 0\n    black_moves = len(list(board.legal_moves)) if not board.turn else 0\n    return float(white_moves - black_moves)", "def feature(board: chess.Board) -> float:\n    \"Counts the total number of pieces on the board for both players.\"\n    white_piece_count = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE)\n    black_piece_count = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK)\n    return float(white_piece_count - black_piece_count)", "def feature(board: chess.Board) -> float:\n    \"Measures how many pieces are pinned for each player.\"\n    def count_pinned_pieces(color):\n        count = 0\n        for square in board.piece_map():\n            piece = board.piece_map()[square]\n            if piece.color == color:\n                for target in board.legal_moves:\n                    if target.from_square == square and (board.is_check() or not board.is_checkmate()):\n                        count += 1\n        return count\n\n    white_pinned = count_pinned_pieces(chess.WHITE)\n    black_pinned = count_pinned_pieces(chess.BLACK)\n    return float(white_pinned - black_pinned)", "def feature(board: chess.Board) -> float:\n    'Measures the difference in material value between both players'\n    material_values = {\n        chess.PAWN: 100,\n        chess.KNIGHT: 320,\n        chess.BISHOP: 330,\n        chess.ROOK: 500,\n        chess.QUEEN: 900,\n        chess.KING: 20000\n    }\n    white_value = sum(material_values[piece.piece_type] for piece in board.piece_map().values() if piece.color == chess.WHITE)\n    black_value = sum(material_values[piece.piece_type] for piece in board.piece_map().values() if piece.color == chess.BLACK)\n    return float(white_value - black_value)", "def feature(board: chess.Board) -> float:\n    'Counts the number of pieces on the board for each player and returns the ratio of pieces'\n    white_count = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE)\n    black_count = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK)\n    return float(white_count / (black_count + 1e-6))", "def feature(board: chess.Board) -> float:\n    'Calculates the centralization of pieces for both players'\n    center_squares = [chess.E4, chess.E5, chess.D4, chess.D5]\n    white_center = sum(1 for square in center_squares if board.piece_at(square) and board.piece_at(square).color == chess.WHITE)\n    black_center = sum(1 for square in center_squares if board.piece_at(square) and board.piece_at(square).color == chess.BLACK)\n    return float(white_center - black_center)", "def feature(board: chess.Board) -> float:\n    'Measures the number of pieces attacked by each player'\n    white_attack_count = sum(1 for square in board.piece_map() if board.is_attacked_by(chess.WHITE, square))\n    black_attack_count = sum(1 for square in board.piece_map() if board.is_attacked_by(chess.BLACK, square))\n    return float(white_attack_count - black_attack_count)", "def feature(board: chess.Board) -> float:\n    'Counts the number of pawns for each player and returns the difference in count'\n    white_pawns = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE and piece.piece_type == chess.PAWN)\n    black_pawns = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK and piece.piece_type == chess.PAWN)\n    return float(white_pawns - black_pawns)", "def feature(board: chess.Board) -> float:\n    'Assesses king safety by counting the number of pieces protecting the king'\n    white_king_square = next(square for square, piece in board.piece_map().items() if piece.color == chess.WHITE and piece.piece_type == chess.KING)\n    black_king_square = next(square for square, piece in board.piece_map().items() if piece.color == chess.BLACK and piece.piece_type == chess.KING)\n    white_protection = len(board.attackers(chess.WHITE, white_king_square))\n    black_protection = len(board.attackers(chess.BLACK, black_king_square))\n    return float(white_protection - black_protection)", "def feature(board: chess.Board) -> float:\n    'Measures the distance of the kings from the corners of the board'\n    white_king_square = next(square for square, piece in board.piece_map().items() if piece.color == chess.WHITE and piece.piece_type == chess.KING)\n    black_king_square = next(square for square, piece in board.piece_map().items() if piece.color == chess.BLACK and piece.piece_type == chess.KING)\n    white_distance = min(chess.square_distance(white_king_square, corner) for corner in [chess.A1, chess.A8, chess.H1, chess.H8])\n    black_distance = min(chess.square_distance(black_king_square, corner) for corner in [chess.A1, chess.A8, chess.H1, chess.H8])\n    return float(white_distance - black_distance)", "def feature(board: chess.Board) -> float:\n    'Counts the number of pieces in endgame positions for either player'\n    endgame_threshold = 12  # typical number of pieces for the transition point\n    total_pieces = len(board.piece_map())\n    return float(total_pieces - endgame_threshold)  # positive if more pieces than in a typical endgame", "def feature(board: chess.Board) -> float:\n    \"Calculates the total piece value for each player.\"\n    value_map = {\n        chess.PAWN: 100,\n        chess.KNIGHT: 320,\n        chess.BISHOP: 330,\n        chess.ROOK: 500,\n        chess.QUEEN: 900,\n        chess.KING: 20000\n    }\n    white_value = sum(value_map[piece.piece_type] for piece in board.piece_map().values() if piece.color == chess.WHITE)\n    black_value = sum(value_map[piece.piece_type] for piece in board.piece_map().values() if piece.color == chess.BLACK)\n    return float(white_value - black_value)", "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in mobility by subtracting the number of legal moves.\"\n    white_moves = len(list(board.legal_moves)) if board.turn == chess.WHITE else 0\n    black_moves = len(list(board.legal_moves)) if board.turn == chess.BLACK else 0\n    return float(white_moves - black_moves)", "def feature(board: chess.Board) -> float:\n    \"Calculates the ratio of minor pieces to major pieces for both players.\"\n    minor_count = {chess.WHITE: 0, chess.BLACK: 0}\n    major_count = {chess.WHITE: 0, chess.BLACK: 0}\n    for piece in board.piece_map().values():\n        if piece.piece_type in [chess.KNIGHT, chess.BISHOP]:\n            minor_count[piece.color] += 1\n        elif piece.piece_type in [chess.ROOK, chess.QUEEN]:\n            major_count[piece.color] += 1\n    ratio_white = minor_count[chess.WHITE] / (major_count[chess.WHITE] + 1)  # Avoid division by zero\n    ratio_black = minor_count[chess.BLACK] / (major_count[chess.BLACK] + 1)\n    return float(ratio_white - ratio_black)", "def feature(board: chess.Board) -> float:\n    \"Measures the difference in the number of pieces on open files.\"\n    open_files = [file for file in range(8) if all(board.piece_at(chess.square(file, rank)) is None for rank in range(8))]\n    white_open_count = sum(1 for file in open_files for rank in range(8) if board.piece_at(chess.square(file, rank)) and board.piece_at(chess.square(file, rank)).color == chess.WHITE)\n    black_open_count = sum(1 for file in open_files for rank in range(8) if board.piece_at(chess.square(file, rank)) and board.piece_at(chess.square(file, rank)).color == chess.BLACK)\n    return float(white_open_count - black_open_count)", "def feature(board: chess.Board) -> float:\n    \"Measures the king's safety by counting the number of squares around it that are attacked.\"\n    king_square = board.king(board.turn)\n    attacked_squares = sum(1 for square in chess.SQUARES if board.is_attacked_by(not board.turn, square) and chess.square_distance(king_square, square) <= 1)\n    return float(attacked_squares)", "def feature(board: chess.Board) -> float:\n    \"Measures the mobility by calculating the average number of legal moves per piece.\"\n    total_moves = sum(len(list(board.legal_moves)) for square, piece in board.piece_map().items())\n    num_pieces = len(board.piece_map())\n    return total_moves / num_pieces if num_pieces > 0 else 0.0", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces that are controlling the center squares.\"\n    center_squares = [chess.D4, chess.D5, chess.E4, chess.E5]\n    control_count = 0\n    for square in center_squares:\n        attackers = board.attackers(chess.WHITE, square)\n        if board.turn:\n            control_count += len(attackers)\n        else:\n            control_count += len(board.attackers(chess.BLACK, square))\n    return float(control_count)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces on the 7th rank for each player.\"\n    rank_count = {chess.WHITE: 0, chess.BLACK: 0}\n    for square, piece in board.piece_map().items():\n        if chess.square_rank(square) == 6:  # 7th rank for white\n            rank_count[chess.WHITE] += 1\n        elif chess.square_rank(square) == 1:  # 7th rank for black\n            rank_count[chess.BLACK] += 1\n    return float(rank_count[chess.WHITE] - rank_count[chess.BLACK])", "def feature(board: chess.Board) -> float:\n    \"Measures the distance of all pieces to their opponent's back rank.\"\n    total_distance = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == chess.WHITE:\n            total_distance += chess.square_rank(square)  # Distance to rank 0\n        else:\n            total_distance += 7 - chess.square_rank(square)  # Distance to rank 7\n    return float(total_distance)", "def feature(board: chess.Board) -> float:\n    \"Evaluates the number of pawns advanced past the midpoint of the board.\"\n    advanced_pawns = 0\n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.PAWN:\n            if (piece.color == chess.WHITE and chess.square_rank(square) > 3) or (piece.color == chess.BLACK and chess.square_rank(square) < 4):\n                advanced_pawns += 1\n    return float(advanced_pawns)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of pieces that are pinned.\"\n    pinned_count = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == board.turn:\n            for opponent_square in board.attackers(not piece.color, square):\n                if board.is_attacked_by(piece.color, opponent_square):\n                    pinned_count += 1\n                    break\n    return float(pinned_count)", "def feature(board: chess.Board) -> float:\n    \"Measures the difference in total piece value between the players.\"\n    piece_values = {chess.PAWN: 100, chess.KNIGHT: 320, chess.BISHOP: 330,\n                    chess.ROOK: 500, chess.QUEEN: 900, chess.KING: 0}\n    white_value = sum(piece_values[piece.piece_type] for piece in board.piece_map().values() if piece.color == chess.WHITE)\n    black_value = sum(piece_values[piece.piece_type] for piece in board.piece_map().values() if piece.color == chess.BLACK)\n    return float(white_value - black_value)", "def feature(board: chess.Board) -> float:\n    \"Calculates a score based on the number of open files available to rooks.\"\n    open_file_count = 0\n    for file in range(8):\n        if not any(board.piece_at(chess.square(file, rank)) for rank in range(8)):\n            open_file_count += 1\n    return float(open_file_count)", "def feature(board: chess.Board) -> float:\n    \"Measures the total mobility of each player by summing the number of legal moves for both sides.\"\n    white_moves = sum(1 for _ in board.legal_moves if board.turn)\n    board.turn = not board.turn\n    black_moves = sum(1 for _ in board.legal_moves if not board.turn)\n    return float(white_moves + black_moves)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of pieces controlled (attacked) by each player.\"\n    white_control = sum(1 for square in board.piece_map() for attacker in board.attackers(chess.WHITE, square))\n    black_control = sum(1 for square in board.piece_map() for attacker in board.attackers(chess.BLACK, square))\n    return float(white_control - black_control)", "def feature(board: chess.Board) -> float:\n    \"Measures the distance of kings to the center of the board for both players.\"\n    white_king_square = chess.square_name(board.king(chess.WHITE))\n    black_king_square = chess.square_name(board.king(chess.BLACK))\n    white_king_distance = (chess.square_file(board.king(chess.WHITE)) - 3)**2 + (chess.square_rank(board.king(chess.WHITE)) - 3)**2\n    black_king_distance = (chess.square_file(board.king(chess.BLACK)) - 3)**2 + (chess.square_rank(board.king(chess.BLACK)) - 3)**2\n    return float(black_king_distance - white_king_distance)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces in the opponent's territory (for Black: ranks 7 and 8; for White: ranks 2 and 1).\"\n    opponent_color = chess.BLACK if board.turn else chess.WHITE\n    count = sum(1 for square in range(64) if board.piece_at(square) and board.piece_at(square).color == opponent_color and (chess.square_rank(square) in (0, 1)))\n    return float(count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the piece activity, defined as the number of moves each piece can make.\"\n    activity_score = 0\n    for piece in board.piece_map().values():\n        activity_score += len(list(board.legal_moves)) if piece.color == board.turn else -len(list(board.legal_moves))\n    return float(activity_score)", "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in the number of protected pawns (pawns defended by other pieces).\"\n    white_protected_pawns = sum(1 for square in board.piece_map() if board.piece_at(square).piece_type == chess.PAWN and \n                                 len(board.attackers(chess.BLACK, square)) == 0)\n    black_protected_pawns = sum(1 for square in board.piece_map() if board.piece_at(square).piece_type == chess.PAWN and \n                                 len(board.attackers(chess.WHITE, square)) == 0)\n    return float(white_protected_pawns - black_protected_pawns)", "def feature(board: chess.Board) -> float:\n    \"Assesses whether either king is in an exposed position, defined as having no defending pieces adjacent.\"\n    def is_king_exposed(king_color):\n        king_square = board.king(king_color)\n        adjacent_squares = [king_square + 1, king_square - 1, king_square + 8, king_square - 8,\n                            king_square + 7, king_square + 9, king_square - 7, king_square - 9]\n        return all(board.piece_at(sq) is None or board.piece_at(sq).color != king_color for sq in adjacent_squares if 0 <= sq < 64)\n    \n    white_exposed = 1.0 if is_king_exposed(chess.WHITE) else 0.0\n    black_exposed = 1.0 if is_king_exposed(chess.BLACK) else 0.0\n    return float(white_exposed - black_exposed)", "def feature(board: chess.Board) -> float:\n    \"Measures the total count of pieces each side has on the board.\"\n    white_count = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE)\n    black_count = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK)\n    return float(white_count - black_count)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces currently attacking the opponent's king.\"\n    white_attacks = sum(board.is_attacked_by(chess.WHITE, square) for square in board.piece_map() if board.piece_map()[square].color == chess.BLACK and board.piece_map()[square].piece_type == chess.KING)\n    black_attacks = sum(board.is_attacked_by(chess.BLACK, square) for square in board.piece_map() if board.piece_map()[square].color == chess.WHITE and board.piece_map()[square].piece_type == chess.KING)\n    return float(white_attacks - black_attacks)", "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in the number of pawns for each color on the board.\"\n    white_pawns = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE and piece.piece_type == chess.PAWN)\n    black_pawns = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK and piece.piece_type == chess.PAWN)\n    return float(white_pawns - black_pawns)", "def feature(board: chess.Board) -> float:\n    \"Measures the potential mobility advantage by counting the legal moves available to each player.\"\n    white_legal_moves = len(list(board.legal_moves)) if board.turn else 0\n    black_legal_moves = len(list(board.legal_moves)) if not board.turn else 0\n    return float(white_legal_moves - black_legal_moves)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of pieces that are currently pinned by the opponent's pieces.\"\n    pinned_pieces = 0\n    for square in board.piece_map():\n        piece = board.piece_map()[square]\n        if piece.color == board.turn:\n            for attacker in board.attackers(not piece.color, square):\n                # Check if the attacker can attack the piece without being blocked\n                if board.piece_at(attacker) and board.piece_at(attacker).piece_type != chess.KING:\n                    pinned_pieces += 1\n                    break\n    return float(pinned_pieces)", "def feature(board: chess.Board) -> float:\n    \"Measures the weighted material score based on common piece values.\"\n    piece_values = {\n        chess.PAWN: 100,\n        chess.KNIGHT: 320,\n        chess.BISHOP: 330,\n        chess.ROOK: 500,\n        chess.QUEEN: 900,\n        chess.KING: 0  # King's value is not counted in material\n    }\n    material_score = 0\n    for piece in board.piece_map().values():\n        material_score += piece_values[piece.piece_type] * (1 if piece.color == chess.WHITE else -1)\n    return float(material_score)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of vulnerable pieces (i.e., pieces that are attacked by opponent's pieces).\"\n    vulnerable_count = sum(1 for square in board.piece_map() if board.is_attacked_by(not board.piece_map()[square].color, square))\n    return float(vulnerable_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the king safety score based on the number of pieces around the king.\"\n    king_square = next((square for square, piece in board.piece_map().items() if piece.piece_type == chess.KING), None)\n    if king_square is None:\n        return 0.0\n    surrounding_pieces = sum(1 for square in chess.SQUARES if board.piece_at(square) and abs(chess.square_file(square) - chess.square_file(king_square)) <= 1 and abs(chess.square_rank(square) - chess.square_rank(king_square)) <= 1)\n    return float(surrounding_pieces)", "def feature(board: chess.Board) -> float:\n    \"Measures the distance of each side's king from the center of the board (central control).\"\n    center_squares = [chess.D4, chess.D5, chess.E4, chess.E5]\n    white_king_square = next((square for square in board.piece_map() if board.piece_map()[square].piece_type == chess.KING and board.piece_map()[square].color == chess.WHITE), None)\n    black_king_square = next((square for square in board.piece_map() if board.piece_map()[square].piece_type == chess.KING and board.piece_map()[square].color == chess.BLACK), None)\n    white_king_distance = min(chess.square_distance(white_king_square, sq) for sq in center_squares) if white_king_square else 0\n    black_king_distance = min(chess.square_distance(black_king_square, sq) for sq in center_squares) if black_king_square else 0\n    return float(black_king_distance - white_king_distance)", "def feature(board: chess.Board) -> float:\n    'Measures the number of squares controlled by each side.'\n    white_control = sum(1 for square in chess.SQUARES if board.is_attacked_by(chess.WHITE, square))\n    black_control = sum(1 for square in chess.SQUARES if board.is_attacked_by(chess.BLACK, square))\n    return float(white_control - black_control)", "def feature(board: chess.Board) -> float:\n    'Calculates the distance of the king to the center of the board.'\n    king_square = next((sq for sq, piece in board.piece_map().items() if piece.piece_type == chess.KING), None)\n    if king_square is not None:\n        center_squares = [chess.E4, chess.E5, chess.D4, chess.D5]\n        return float(min(chess.square_distance(king_square, sq) for sq in center_squares))\n    return 0.0", "def feature(board: chess.Board) -> float:\n    'Counts the number of pieces that are attacked and can capture.'\n    attacking_pieces = sum(1 for square in board.piece_map() if board.is_attacked_by(board.piece_map()[square].color, square))\n    return float(attacking_pieces)", "def feature(board: chess.Board) -> float:\n    'Measures the material presence of pawns on the board.'\n    white_pawns = sum(1 for piece in board.piece_map().values() if piece.piece_type == chess.PAWN and piece.color == chess.WHITE)\n    black_pawns = sum(1 for piece in board.piece_map().values() if piece.piece_type == chess.PAWN and piece.color == chess.BLACK)\n    return float(white_pawns - black_pawns)", "def feature(board: chess.Board) -> float:\n    'Calculates the average distance of pieces from their home squares.'\n    home_squares = {\n        chess.WHITE: [chess.A2, chess.B2, chess.C2, chess.D2, chess.E2, chess.F2, chess.G2, chess.H2],\n        chess.BLACK: [chess.A7, chess.B7, chess.C7, chess.D7, chess.E7, chess.F7, chess.G7, chess.H7]\n    }\n    total_distance = 0\n    piece_count = 0\n    \n    for piece in board.piece_map().values():\n        square = next(sq for sq in chess.SQUARES if board.piece_at(sq) == piece)\n        home_square = home_squares[piece.color][piece.piece_type - 1]\n        total_distance += chess.square_distance(square, home_square)\n        piece_count += 1\n        \n    return total_distance / piece_count if piece_count > 0 else 0.0", "def feature(board: chess.Board) -> float:\n    'Measures the value of pieces that are pinned.'\n    pinned_pieces_value = sum(piece.piece_type for square, piece in board.piece_map().items() if any(board.is_attacked_by(color, square) for color in (chess.WHITE, chess.BLACK)))\n    return float(pinned_pieces_value)", "def feature(board: chess.Board) -> float:\n    'Calculates the number of pieces on the back rank, which can indicate safety or vulnerability.'\n    back_rank_count = sum(1 for square in (chess.A8, chess.B8, chess.C8, chess.D8, chess.E8, chess.F8, chess.G8, chess.H8) if board.piece_at(square) is not None)\n    return float(back_rank_count)", "def feature(board: chess.Board) -> float:\n    'Measures the parity of the material; whether the number of pieces is even or odd.'\n    piece_count = len(board.piece_map())\n    return float(piece_count % 2)", "def feature(board: chess.Board) -> float:\n    'Counts the total number of potential captures available for both sides.'\n    total_captures = sum(1 for move in board.legal_moves if move.to_square in board.piece_map())\n    return float(total_captures)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of pieces in each player's back rank.\"\n    back_rank_white = sum(1 for square in range(56, 64) if board.piece_at(square) and board.piece_at(square).color == chess.WHITE)\n    back_rank_black = sum(1 for square in range(0, 8) if board.piece_at(square) and board.piece_at(square).color == chess.BLACK)\n    return float(back_rank_white - back_rank_black)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of pawns remaining for each player.\"\n    pawns_white = len([p for p in board.piece_map().values() if p.piece_type == chess.PAWN and p.color == chess.WHITE])\n    pawns_black = len([p for p in board.piece_map().values() if p.piece_type == chess.PAWN and p.color == chess.BLACK])\n    return float(pawns_white - pawns_black)", "def feature(board: chess.Board) -> float:\n    \"Calculates the mobility of pieces by counting legal moves for each player.\"\n    mobility_white = len(list(board.legal_moves)) if board.turn else 0\n    mobility_black = len(list(board.legal_moves)) if not board.turn else 0\n    return float(mobility_white - mobility_black)", "def feature(board: chess.Board) -> float:\n    \"Measures the distance from the king to the nearest enemy piece.\"\n    white_king_square = next(square for square, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color == chess.WHITE)\n    black_king_square = next(square for square, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color == chess.BLACK)\n    nearest_enemy_distance_white = min((chess.square_distance(white_king_square, enemy_square) for enemy_square in board.attackers(chess.BLACK, black_king_square)), default=8)\n    nearest_enemy_distance_black = min((chess.square_distance(black_king_square, enemy_square) for enemy_square in board.attackers(chess.WHITE, white_king_square)), default=8)\n    return float(nearest_enemy_distance_white - nearest_enemy_distance_black)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of doubled pawns for each player.\"\n    doubled_pawns_white = sum(1 for file in range(8) if len([square for square in range(chess.A2 + file, chess.H2 + file + 1, 8) if board.piece_at(square) and board.piece_at(square).color == chess.WHITE]) > 1)\n    doubled_pawns_black = sum(1 for file in range(8) if len([square for square in range(chess.A7 + file, chess.H7 + file + 1, 8) if board.piece_at(square) and board.piece_at(square).color == chess.BLACK]) > 1)\n    return float(doubled_pawns_black - doubled_pawns_white)", "def feature(board: chess.Board) -> float:\n    \"Calculates the total piece value advantage based on a standard material value.\"\n    piece_values = {chess.PAWN: 100, chess.KNIGHT: 320, chess.BISHOP: 330, chess.ROOK: 500, chess.QUEEN: 900}\n    material_white = sum(piece_values.get(piece.piece_type, 0) for piece in board.piece_map().values() if piece.color == chess.WHITE)\n    material_black = sum(piece_values.get(piece.piece_type, 0) for piece in board.piece_map().values() if piece.color == chess.BLACK)\n    return float(material_white - material_black)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of targets (pieces) each king is attacking.\"\n    white_king_square = next(square for square, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color == chess.WHITE)\n    black_king_square = next(square for square, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color == chess.BLACK)\n    attacks_white = len(board.attackers(chess.BLACK, white_king_square))\n    attacks_black = len(board.attackers(chess.WHITE, black_king_square))\n    return float(attacks_white - attacks_black)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of pieces threatening the opponent's king.\"\n    enemy_king_square = next(square for square, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color == (chess.WHITE if board.turn else chess.BLACK))\n    threatening_pieces = sum(1 for square in board.piece_map() if board.is_attacked_by(board.turn, enemy_king_square))\n    return float(threatening_pieces)", "def feature(board: chess.Board) -> float:\n    \"Measures the isolated pawn count for both players.\"\n    isolated_pawn_count = 0\n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.PAWN:\n            file = chess.square_file(square)\n            if not (board.piece_at(chess.parse_square(chess.square_name(square)[0] + str(r))) for r in range(8) if r != chess.square_rank(square)):\n                isolated_pawn_count += 1 if piece.color == chess.WHITE else -1\n    return float(isolated_pawn_count)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pawns on the board to evaluate pawn structure.\"\n    white_pawns = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE and piece.piece_type == chess.PAWN)\n    black_pawns = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK and piece.piece_type == chess.PAWN)\n    return float(white_pawns - black_pawns)", "def feature(board: chess.Board) -> float:\n    \"Evaluates piece mobility by counting the number of legal moves.\"\n    mobility = len(list(board.legal_moves))\n    return float(mobility)", "def feature(board: chess.Board) -> float:\n    \"Measures the centralization of the king's position.\"\n    white_king_square = next(square for square, piece in board.piece_map().items() if piece.color == chess.WHITE and piece.piece_type == chess.KING)\n    black_king_square = next(square for square, piece in board.piece_map().items() if piece.color == chess.BLACK and piece.piece_type == chess.KING)\n    central_distance = chess.square_distance(white_king_square, chess.parse_square('e4')) + chess.square_distance(black_king_square, chess.parse_square('e4'))\n    return float(central_distance)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces that are defended by other pieces.\"\n    defended_count = sum(1 for square, piece in board.piece_map().items() if any(board.is_attacked_by(piece.color, square) for square in board.attackers(piece.color, square)))\n    return float(defended_count)", "def feature(board: chess.Board) -> float:\n    \"Checks if either player is in check, helping to understand tactical threats.\"\n    return float(1.0 if board.is_check() else 0.0)", "def feature(board: chess.Board) -> float:\n    \"Calculates the total piece value disparity between both players.\"\n    piece_values = {chess.PAWN: 100, chess.KNIGHT: 320, chess.BISHOP: 330, chess.ROOK: 500, chess.QUEEN: 900, chess.KING: 0}\n    white_value = sum(piece_values[piece.piece_type] for piece in board.piece_map().values() if piece.color == chess.WHITE)\n    black_value = sum(piece_values[piece.piece_type] for piece in board.piece_map().values() if piece.color == chess.BLACK)\n    return float(white_value - black_value)", "def feature(board: chess.Board) -> float:\n    \"Calculates the material imbalance score based on piece types.\"\n    imbalance_score = 0\n    for piece in board.piece_map().values():\n        value = 0\n        if piece.color == chess.WHITE:\n            value = piece.piece_type\n        else:\n            value = -piece.piece_type\n        imbalance_score += value\n    return float(imbalance_score)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of protected pieces for each player.\"\n    white_protected = sum(1 for square, piece in board.piece_map().items() if piece.color == chess.WHITE and any(board.is_attacked_by(chess.BLACK, square_2) for square_2 in board.attackers(chess.WHITE, square)) == False)\n    black_protected = sum(1 for square, piece in board.piece_map().items() if piece.color == chess.BLACK and any(board.is_attacked_by(chess.WHITE, square_2) for square_2 in board.attackers(chess.BLACK, square)) == False)\n    return float(white_protected - black_protected)", "def feature(board: chess.Board) -> float:\n    \"Evaluates central control by counting pieces in the central squares.\"\n    central_squares = [chess.D4, chess.D5, chess.E4, chess.E5]\n    control = sum(1 for sq in central_squares if board.piece_at(sq) is not None)\n    return float(control)", "def feature(board: chess.Board) -> float:\n    \"Measures the total number of pieces on the board.\"\n    piece_count = len(board.piece_map())\n    return float(piece_count)", "def feature(board: chess.Board) -> float:\n    \"Checks for potential back rank weaknesses by counting pieces on the back rank.\"\n    back_rank_white = sum(1 for sq in range(chess.A1, chess.H1 + 1) if board.piece_at(sq) is not None and board.piece_at(sq).color == chess.WHITE)\n    back_rank_black = sum(1 for sq in range(chess.A8, chess.H8 + 1) if board.piece_at(sq) is not None and board.piece_at(sq).color == chess.BLACK)\n    return float(back_rank_white - back_rank_black)", "def feature(board: chess.Board) -> float:\n    \"Measures the distance of the kings from the center of the board.\"\n    white_king_sq = next(sq for sq in board.piece_map() if board.piece_map()[sq].piece_type == chess.KING and board.piece_map()[sq].color == chess.WHITE)\n    black_king_sq = next(sq for sq in board.piece_map() if board.piece_map()[sq].piece_type == chess.KING and board.piece_map()[sq].color == chess.BLACK)\n    distance = (chess.square_distance(white_king_sq, chess.E4) + chess.square_distance(black_king_sq, chess.E4)) / 2\n    return float(distance)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of pieces attacking the opponent's king.\"\n    opponent_king_sq = next(sq for sq in board.piece_map() if board.piece_map()[sq].piece_type == chess.KING and board.piece_map()[sq].color != board.turn)\n    attackers_count = len(board.attackers(board.turn, opponent_king_sq))\n    return float(attackers_count)", "def feature(board: chess.Board) -> float:\n    \"Measures the difference in pawn structure by counting doubled pawns.\"\n    white_doubled = sum(1 for file in range(8) if len([1 for rank in range(8) if board.piece_at(chess.square(file, rank)) == chess.PAWN and board.piece_at(chess.square(file, rank)).color == chess.WHITE]) > 1)\n    black_doubled = sum(1 for file in range(8) if len([1 for rank in range(8) if board.piece_at(chess.square(file, rank)) == chess.PAWN and board.piece_at(chess.square(file, rank)).color == chess.BLACK]) > 1)\n    return float(white_doubled - black_doubled)", "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in total piece values between players.\"\n    piece_values = {chess.PAWN: 100, chess.KNIGHT: 320, chess.BISHOP: 330, chess.ROOK: 500, chess.QUEEN: 900, chess.KING: 0}\n    white_value = sum(piece_values[piece.piece_type] for piece in board.piece_map().values() if piece.color == chess.WHITE)\n    black_value = sum(piece_values[piece.piece_type] for piece in board.piece_map().values() if piece.color == chess.BLACK)\n    return float(white_value - black_value)", "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in the number of pawns for both players.\"\n    white_pawns = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE and piece.piece_type == chess.PAWN)\n    black_pawns = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK and piece.piece_type == chess.PAWN)\n    return float(white_pawns - black_pawns)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces on the board and returns their total count.\"\n    total_pieces = len(board.piece_map())\n    return float(total_pieces)", "def feature(board: chess.Board) -> float:\n    \"Measures the material difference based on the piece values.\"\n    piece_values = {\n        chess.PAWN: 100,\n        chess.KNIGHT: 300,\n        chess.BISHOP: 300,\n        chess.ROOK: 500,\n        chess.QUEEN: 900,\n        chess.KING: 0\n    }\n    material_white = sum(piece_values[piece.piece_type] for piece in board.piece_map().values() if piece.color == chess.WHITE)\n    material_black = sum(piece_values[piece.piece_type] for piece in board.piece_map().values() if piece.color == chess.BLACK)\n    return float(material_white - material_black)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of attacks on the opponent's king.\"\n    opponent_king_square = next(square for square, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color == chess.BLACK)\n    attacks_on_king = sum(1 for move in board.legal_moves if move.to_square == opponent_king_square)\n    return float(attacks_on_king)", "def feature(board: chess.Board) -> float:\n    \"Checks if either king is in check and returns a score based on that.\"\n    white_in_check = board.is_check() if board.turn else False\n    black_in_check = board.is_check() if not board.turn else False\n    if white_in_check and black_in_check:\n        return 1.0\n    elif white_in_check:\n        return -1.0\n    elif black_in_check:\n        return 0.0\n    return 0.0", "def feature(board: chess.Board) -> float:\n    \"Counts the potential threats to the opponent's pieces.\"\n    threats = sum(1 for square in board.piece_map() if board.is_attacked_by(chess.WHITE, square))\n    return float(threats)", "def feature(board: chess.Board) -> float:\n    \"Measures mobility by counting the number of legal moves available.\"\n    mobility = sum(1 for _ in board.legal_moves)\n    return float(mobility)", "def feature(board: chess.Board) -> float:\n    \"Evaluates the control of the center squares (d4, d5, e4, e5).\"\n    center_squares = [chess.parse_square('d4'), chess.parse_square('d5'), chess.parse_square('e4'), chess.parse_square('e5')]\n    control_score = sum(1 if board.piece_at(sq) and board.piece_at(sq).color == chess.WHITE else -1 for sq in center_squares)\n    return float(control_score)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of pieces for both players in the endgame phase.\"\n    white_pieces = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE)\n    black_pieces = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK)\n    return float(white_pieces - black_pieces)", "def feature(board: chess.Board) -> float:\n    \"Calculates the distance of the kings from each other.\"\n    white_king_square = next(sq for sq, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color == chess.WHITE)\n    black_king_square = next(sq for sq, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color == chess.BLACK)\n    distance = chess.square_distance(white_king_square, black_king_square)\n    return float(distance)", "def feature(board: chess.Board) -> float:\n    \"Counts the total number of pawns on the board.\"\n    pawn_count = sum(1 for piece in board.piece_map().values() if piece.piece_type == chess.PAWN)\n    return float(pawn_count)", "def feature(board: chess.Board) -> float:\n    \"Scores based on the number of squares controlled by the pieces.\"\n    control_squares = len(set(move.to_square for move in board.legal_moves))\n    return float(control_squares)", "def feature(board: chess.Board) -> float:\n    \"Measures the presence of passed pawns for both sides.\"\n    passed_pawns = 0\n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.PAWN:\n            if piece.color == chess.WHITE and all(board.piece_at(sq) is None for sq in range(square + 8, 64, 8)):\n                passed_pawns += 1\n            if piece.color == chess.BLACK and all(board.piece_at(sq) is None for sq in range(square - 8, -1, -8)):\n                passed_pawns += 1\n    return float(passed_pawns)", "def feature(board: chess.Board) -> float:\n    \"Evaluates the position based on king safety; checks if kings are attacked.\"\n    white_king_square = next(sq for sq, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color == chess.WHITE)\n    black_king_square = next(sq for sq, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color == chess.BLACK)\n    white_king_attacked = board.is_attacked_by(chess.BLACK, white_king_square)\n    black_king_attacked = board.is_attacked_by(chess.WHITE, black_king_square)\n    return float(white_king_attacked) - float(black_king_attacked)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces that are pinned.\"\n    pinned_count = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == board.turn:\n            for move in board.legal_moves:\n                if move.from_square == square and board.is_check():\n                    pinned_count += 1\n                    break\n    return float(pinned_count)", "def feature(board: chess.Board) -> float:\n    \"Measures the central control by counting the pieces in central squares.\"\n    central_squares = [chess.D4, chess.E4, chess.D5, chess.E5]\n    central_control = sum(1 for square in central_squares if board.piece_at(square) is not None)\n    return float(central_control)", "def feature(board: chess.Board) -> float:\n    \"Calculates the mobility of pieces by counting available moves.\"\n    mobility_score = sum(len([move for move in board.legal_moves if move.from_square == piece_square])\n                         for piece_square, piece in board.piece_map().items())\n    return float(mobility_score)", "def feature(board: chess.Board) -> float:\n    \"Returns a score based on the position of pawns relative to their promotion squares.\"\n    pawn_positions = sum(1 for square, piece in board.piece_map().items() if piece.piece_type == chess.PAWN and \n                         ((piece.color == chess.WHITE and chess.square_rank(square) >= 6) or\n                          (piece.color == chess.BLACK and chess.square_rank(square) <= 1)))\n    return float(pawn_positions)", "def feature(board: chess.Board) -> float:\n    \"Measures the dynamic potential by counting the number of pieces that can make immediate threats.\"\n    threats = sum(1 for move in board.legal_moves if board.is_attacked_by(not board.turn, move.to_square))\n    return float(threats)", "def feature(board: chess.Board) -> float:\n    \"Calculates the total number of pieces controlled by each player and their proximity.\"\n    player_control = sum(1 for piece in board.piece_map().values() if piece.color == board.turn)\n    opponent_control = sum(1 for piece in board.piece_map().values() if piece.color != board.turn)\n    return float(player_control - opponent_control)", "def feature(board: chess.Board) -> float:\n    \"Measures the central control by counting how many pieces are on the central squares (d4, d5, e4, e5).\"\n    central_squares = [chess.D4, chess.D5, chess.E4, chess.E5]\n    control_count = sum(1 for square in central_squares if board.piece_at(square) is not None)\n    return float(control_count)", "def feature(board: chess.Board) -> float:\n    \"Computes the material value of pawns that are passed (no opposing pawns on adjacent files).\"\n    passed_pawns = sum(1 for square in range(8) if (\n        board.piece_at(chess.parse_square(f'{chr(square + 97)}2')) == chess.PAWN and\n        board.piece_at(chess.parse_square(f'{chr(square + 97)}3')) is None and\n        board.piece_at(chess.parse_square(f'{chr(square + 97)}4')) is None\n    ))\n    return float(passed_pawns)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of attacking pairs (two pieces of the same color that can attack the same square).\"\n    attack_pairs = sum(1 for square in board.piece_map() if board.is_attacked_by(board.piece_map()[square].color, square))\n    return float(attack_pairs)", "def feature(board: chess.Board) -> float:\n    \"Evaluates the king safety based on the number of pieces defending the king.\"\n    king_square = None\n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.KING and piece.color == board.turn:\n            king_square = square\n            break\n    defending_pieces = sum(1 for piece in board.piece_map().values() if piece.color == board.turn and square in board.attackers(piece.color, king_square))\n    return float(defending_pieces)", "def feature(board: chess.Board) -> float:\n    \"Measures the pawn structure by counting isolated pawns.\"\n    isolated_pawns = sum(1 for square in chess.SQUARES if (\n        board.piece_at(square) == chess.PAWN and\n        (not board.piece_at(square - 1) if chess.square_file(square) > 0 else True) and\n        (not board.piece_at(square + 1) if chess.square_file(square) < 7 else True)\n    ))\n    return float(isolated_pawns)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pawns on the board and gives a ratio of White to Black pawns.\"\n    white_pawns = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE and piece.piece_type == chess.PAWN)\n    black_pawns = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK and piece.piece_type == chess.PAWN)\n    return float(white_pawns) / (black_pawns + 1)  # Avoid division by zero", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of king safety threats for both players.\"\n    white_king_square = chess.square(board.king(chess.WHITE), 0)\n    black_king_square = chess.square(board.king(chess.BLACK), 0)\n    white_threats = len(board.attackers(chess.BLACK, white_king_square))\n    black_threats = len(board.attackers(chess.WHITE, black_king_square))\n    return float(white_threats - black_threats)", "def feature(board: chess.Board) -> float:\n    \"Evaluates the number of pieces on the back rank for each player.\"\n    white_back_rank = [square for square in range(56, 64) if board.piece_at(square) and board.piece_at(square).color == chess.WHITE]\n    black_back_rank = [square for square in range(0, 8) if board.piece_at(square) and board.piece_at(square).color == chess.BLACK]\n    return float(len(white_back_rank) - len(black_back_rank))", "def feature(board: chess.Board) -> float:\n    \"Measures the mobility of pieces by counting the number of legal moves for each player.\"\n    white_moves = len(list(board.legal_moves)) if board.turn == chess.WHITE else 0\n    black_moves = len(list(board.legal_moves)) if board.turn == chess.BLACK else 0\n    return float(white_moves - black_moves)", "def feature(board: chess.Board) -> float:\n    \"Counts doubled pawns for both players and returns the difference.\"\n    white_doubled_pawns = sum(1 for file in range(8) if board.piece_map().get(chess.parse_square(f'{chess.FILE_NAMES[file]}2')) and \n                               board.piece_map().get(chess.parse_square(f'{chess.FILE_NAMES[file]}3')))\n    black_doubled_pawns = sum(1 for file in range(8) if board.piece_map().get(chess.parse_square(f'{chess.FILE_NAMES[file]}7')) and \n                               board.piece_map().get(chess.parse_square(f'{chess.FILE_NAMES[file]}6')))\n    return float(white_doubled_pawns - black_doubled_pawns)", "def feature(board: chess.Board) -> float:\n    \"Calculates the distance of kings from the center of the board for both players.\"\n    white_king_square = board.king(chess.WHITE)\n    black_king_square = board.king(chess.BLACK)\n    white_distance = chess.square_distance(white_king_square, chess.parse_square('e4'))\n    black_distance = chess.square_distance(black_king_square, chess.parse_square('e4'))\n    return float(black_distance - white_distance)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of piece types on the board for each player.\"\n    white_types = set(piece.piece_type for piece in board.piece_map().values() if piece.color == chess.WHITE)\n    black_types = set(piece.piece_type for piece in board.piece_map().values() if piece.color == chess.BLACK)\n    return float(len(white_types) - len(black_types))", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of isolated pawns for each player and returns the difference.\"\n    def is_isolated_pawn(square):\n        file = chess.square_file(square)\n        return (file == 0 or board.piece_at(chess.parse_square(chess.FILE_NAMES[file-1] + str(chess.square_rank(square)+1))) is None) and \\\n               (file == 7 or board.piece_at(chess.parse_square(chess.FILE_NAMES[file+1] + str(chess.square_rank(square)+1))) is None)\n    \n    white_isolated_pawns = sum(1 for square in chess.SQUARES if board.piece_at(square) and \n                                board.piece_at(square).color == chess.WHITE and \n                                board.piece_at(square).piece_type == chess.PAWN and is_isolated_pawn(square))\n    black_isolated_pawns = sum(1 for square in chess.SQUARES if board.piece_at(square) and \n                                board.piece_at(square).color == chess.BLACK and \n                                board.piece_at(square).piece_type == chess.PAWN and is_isolated_pawn(square))\n    return float(white_isolated_pawns - black_isolated_pawns)", "def feature(board: chess.Board) -> float:\n    \"Calculates the total number of pieces on the board.\"\n    return float(len(board.piece_map()))", "def feature(board: chess.Board) -> float:\n    \"Measures the distance of the king to the center of the board.\"\n    king_square = next((square for square, piece in board.piece_map().items() if piece.piece_type == chess.KING), None)\n    if king_square is not None:\n        return float(chess.square_distance(king_square, chess.parse_square('e4')))\n    return 0.0", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pawns that can promote in the next move.\"\n    return float(sum(1 for square, piece in board.piece_map().items() if piece.piece_type == chess.PAWN and\n                     (piece.color == chess.WHITE and chess.square_rank(square) == 6 or\n                      piece.color == chess.BLACK and chess.square_rank(square) == 1)))", "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in number of rooks for both players.\"\n    white_rooks = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE and piece.piece_type == chess.ROOK)\n    black_rooks = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK and piece.piece_type == chess.ROOK)\n    return float(white_rooks - black_rooks)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of squares attacked by all pieces for the current player.\"\n    color = chess.WHITE if board.turn else chess.BLACK\n    return float(len([square for square in board.piece_map() if board.is_attacked_by(color, square)]))", "def feature(board: chess.Board) -> float:\n    \"Returns the number of pieces that are pinned by the opponent's pieces.\"\n    pinned_count = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == (chess.WHITE if board.turn else chess.BLACK):\n            for attacker in board.attackers(chess.BLACK if piece.color == chess.WHITE else chess.WHITE, square):\n                if board.piece_at(attacker) and board.is_attacked_by(piece.color, attacker):\n                    pinned_count += 1\n                    break\n    return float(pinned_count)", "def feature(board: chess.Board) -> float:\n    \"Measures the control of central squares (d4, e4, d5, e5).\"\n    central_squares = [chess.parse_square('d4'), chess.parse_square('e4'), chess.parse_square('d5'), chess.parse_square('e5')]\n    control_count = sum(1 for square in central_squares if board.is_attacked_by(chess.WHITE if board.turn else chess.BLACK, square))\n    return float(control_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the halfmove clock adjusted for current player's pieces.\"\n    return float(board.halfmove_clock + (sum(1 for piece in board.piece_map().values() if piece.color == (chess.WHITE if board.turn else chess.BLACK))))", "def feature(board: chess.Board) -> float:\n    \"Measures how many pieces have no legal moves.\"\n    immobile_count = sum(1 for square in board.piece_map() if not list(board.legal_moves) and \n                         board.piece_at(square).color == (chess.WHITE if board.turn else chess.BLACK))\n    return float(immobile_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in mobility between both players' pieces.\"\n    white_mobility = len(list(board.legal_moves)) if board.turn else 0\n    black_mobility = len(list(board.legal_moves)) if not board.turn else 0\n    return float(white_mobility - black_mobility)", "def feature(board: chess.Board) -> float:\n    \"Measures the total number of pawns on the board.\"\n    pawn_count = sum(1 for piece in board.piece_map().values() if piece.piece_type == chess.PAWN)\n    return float(pawn_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in material value between both players.\"\n    piece_values = {chess.PAWN: 100, chess.KNIGHT: 300, chess.BISHOP: 300,\n                    chess.ROOK: 500, chess.QUEEN: 900, chess.KING: 0}\n    white_value = sum(piece_values[piece.piece_type] for piece in board.piece_map().values() if piece.color == chess.WHITE)\n    black_value = sum(piece_values[piece.piece_type] for piece in board.piece_map().values() if piece.color == chess.BLACK)\n    return float(white_value - black_value)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces under attack by the opponent.\"\n    threatened_pieces = sum(1 for square, piece in board.piece_map().items() if board.is_attacked_by(not piece.color, square))\n    return float(threatened_pieces)", "def feature(board: chess.Board) -> float:\n    \"Evaluates the number of connected pawns for each player.\"\n    def count_connected_pawns(color):\n        connected_pawns = 0\n        for rank in range(8):\n            files = [file for file in range(8) if board.piece_at(chess.square(file, rank)) and \n                     board.piece_at(chess.square(file, rank)).color == color and \n                     board.piece_at(chess.square(file, rank)).piece_type == chess.PAWN]\n            connected_pawns += len(files) - (len(files) - 1)  # -1 for non-connected files\n        return connected_pawns\n    \n    return float(count_connected_pawns(chess.WHITE) - count_connected_pawns(chess.BLACK))", "def feature(board: chess.Board) -> float:\n    \"Calculates the distance of all pieces from their starting positions.\"\n    total_distance = sum(chess.square_distance(square, piece.piece_type + 8 * piece.color) \n                         for square, piece in board.piece_map().items())\n    return float(total_distance)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces that are pinned.\"\n    pinned_piece_count = sum(1 for square, piece in board.piece_map().items() \n                              if board.is_attacked_by(not piece.color, square) \n                              and any(board.attackers(piece.color, square)))\n    return float(pinned_piece_count)", "def feature(board: chess.Board) -> float:\n    \"Measures the distribution of pieces across ranks for the current player.\"\n    distribution = [0] * 8\n    for square, piece in board.piece_map().items():\n        if piece.color == board.turn:\n            distribution[chess.square_rank(square)] += 1\n    return float(max(distribution) - min(distribution))", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of squares controlled by each player.\"\n    controlled_squares = [0, 0]  # [White, Black]\n    for move in board.legal_moves:\n        controlled_squares[0 if move.from_square == chess.WHITE else 1] += 1\n    return float(controlled_squares[0] - controlled_squares[1])", "def feature(board: chess.Board) -> float:\n    \"Measures the average distance of pieces from the opponent's king.\"\n    opponent_king_square = board.king(chess.WHITE if board.turn else chess.BLACK)\n    total_distance = sum(chess.square_distance(square, opponent_king_square) \n                         for square, piece in board.piece_map().items() \n                         if piece.color == (chess.WHITE if board.turn else chess.BLACK))\n    num_pieces = len([piece for piece in board.piece_map().values() \n                      if piece.color == (chess.WHITE if board.turn else chess.BLACK)])\n    return total_distance / num_pieces if num_pieces > 0 else 0.0", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pawns present for each side and computes their difference.\"\n    white_pawns = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE and piece.piece_type == chess.PAWN)\n    black_pawns = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK and piece.piece_type == chess.PAWN)\n    return float(white_pawns - black_pawns)", "def feature(board: chess.Board) -> float:\n    \"Calculates the ratio of minor pieces (knights and bishops) to major pieces (rooks and queens) for both sides.\"\n    white_minor = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE and piece.piece_type in {chess.KNIGHT, chess.BISHOP})\n    white_major = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE and piece.piece_type in {chess.ROOK, chess.QUEEN})\n    black_minor = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK and piece.piece_type in {chess.KNIGHT, chess.BISHOP})\n    black_major = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK and piece.piece_type in {chess.ROOK, chess.QUEEN})\n    \n    return (white_minor / (white_major + 1)) - (black_minor / (black_major + 1))  # Avoid division by zero", "def feature(board: chess.Board) -> float:\n    \"Evaluates the control of the center squares by counting pieces on d4, d5, e4, and e5.\"\n    center_squares = [chess.parse_square('d4'), chess.parse_square('d5'), \n                      chess.parse_square('e4'), chess.parse_square('e5')]\n    control_score = sum(1 for square in center_squares if board.piece_at(square) and board.piece_at(square).color == (chess.WHITE if board.turn else chess.BLACK))\n    return float(control_score)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of pieces attacking the opponent's king.\"\n    opponent_king_square = board.king(chess.WHITE if board.turn else chess.BLACK)\n    attackers_count = len(board.attackers(chess.WHITE if board.turn else chess.BLACK, opponent_king_square))\n    return float(attackers_count)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces currently pinned by the opponent.\"\n    pinned_count = sum(1 for square, piece in board.piece_map().items() \n                       if piece.color == (chess.WHITE if board.turn else chess.BLACK) \n                       and board.is_attacked_by(chess.WHITE if board.turn else chess.BLACK, square))\n    return float(pinned_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the safety of kings based on their attacking pieces.\"\n    white_king_square = board.king(chess.WHITE)\n    black_king_square = board.king(chess.BLACK)\n    white_king_safety = len(board.attackers(chess.BLACK, white_king_square))\n    black_king_safety = len(board.attackers(chess.WHITE, black_king_square))\n    return float(black_king_safety - white_king_safety)", "def feature(board: chess.Board) -> float:\n    \"Measures the difference in control over open files by counting rooks on those files.\"\n    open_files = sum(1 for file in range(8) if not any(board.piece_at(chess.square(file, rank)) \n                                                          for rank in range(8)))\n    white_rooks_on_open_files = sum(1 for square, piece in board.piece_map().items() \n                                     if piece.color == chess.WHITE and piece.piece_type == chess.ROOK and chess.square_file(square) in range(open_files))\n    black_rooks_on_open_files = sum(1 for square, piece in board.piece_map().items() \n                                     if piece.color == chess.BLACK and piece.piece_type == chess.ROOK and chess.square_file(square) in range(open_files))\n    return float(white_rooks_on_open_files - black_rooks_on_open_files)", "def feature(board: chess.Board) -> float:\n    \"Calculates the total number of pieces on the board.\"\n    total_pieces = sum(1 for piece in board.piece_map().values())\n    return float(total_pieces)", "def feature(board: chess.Board) -> float:\n    \"Measures the difference in material value of pieces, giving more weight to higher-value pieces.\"\n    value_map = {chess.PAWN: 100, chess.KNIGHT: 320, chess.BISHOP: 330, chess.ROOK: 500, chess.QUEEN: 900, chess.KING: 0}\n    white_value = sum(value_map[piece.piece_type] for piece in board.piece_map().values() if piece.color == chess.WHITE)\n    black_value = sum(value_map[piece.piece_type] for piece in board.piece_map().values() if piece.color == chess.BLACK)\n    return float(white_value - black_value)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces in attack position on the opponent's king.\"\n    king_square = next(square for square, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color == (chess.WHITE if board.turn else chess.BLACK))\n    attackers = len(board.attackers(chess.WHITE if board.turn else chess.BLACK, king_square))\n    return float(attackers)", "def feature(board: chess.Board) -> float:\n    \"Evaluates the center control by counting pieces on central squares.\"\n    center_squares = [chess.D4, chess.D5, chess.E4, chess.E5]\n    center_control = sum(1 for square in center_squares if board.piece_at(square) and board.piece_at(square).color == (chess.WHITE if board.turn else chess.BLACK))\n    return float(center_control)", "def feature(board: chess.Board) -> float:\n    \"Checks the distance of kings from the center of the board, closer is better.\"\n    white_king_square = next(square for square, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color == chess.WHITE)\n    black_king_square = next(square for square, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color == chess.BLACK)\n    white_distance = chess.square_distance(white_king_square, chess.E4)\n    black_distance = chess.square_distance(black_king_square, chess.E4)\n    return float(black_distance - white_distance)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of hanging pieces on the board, which are undefended.\"\n    hanging_pieces = sum(1 for square, piece in board.piece_map().items() if piece.color == (chess.WHITE if board.turn else chess.BLACK) and not board.is_attacked_by(not piece.color, square))\n    return float(hanging_pieces)", "def feature(board: chess.Board) -> float:\n    \"Counts the threats a player has against the opposing king.\"\n    opponent_king_square = next(square for square, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color == (chess.BLACK if board.turn else chess.WHITE))\n    threats = sum(1 for move in board.legal_moves if move.to_square == opponent_king_square)\n    return float(threats)", "def feature(board: chess.Board) -> float:\n    \"Measures the mobility of the player to move by counting the potential legal moves.\"\n    mobility = len(list(board.legal_moves))\n    return float(mobility)", "def feature(board: chess.Board) -> float:\n    \"Measures the difference in the number of occupied squares of both players.\"\n    white_occupied = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE)\n    black_occupied = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK)\n    return float(white_occupied - black_occupied)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of attacks launched by the current player's pieces.\"\n    color = board.turn\n    return float(len(list(board.legal_moves)))", "def feature(board: chess.Board) -> float:\n    \"Calculates the average piece distance to the opponent's king for the current player.\"\n    king_square = next((sq for sq, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color == (chess.WHITE if board.turn else chess.BLACK)), None)\n    if king_square is None:\n        return 0.0\n    \n    total_distance = 0\n    piece_count = 0\n    for sq, piece in board.piece_map().items():\n        if piece.color == (chess.WHITE if board.turn else chess.BLACK):\n            total_distance += chess.square_distance(sq, king_square)\n            piece_count += 1\n            \n    return float(total_distance / piece_count) if piece_count > 0 else 0.0", "def feature(board: chess.Board) -> float:\n    \"Measures the number of pieces pinned by the opponent.\"\n    pinned_pieces = sum(1 for sq, piece in board.piece_map().items() if (piece.color != board.turn and board.is_attacked_by(not board.turn, sq)))\n    return float(pinned_pieces)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of squares attacked by the current player's pawns.\"\n    color = board.turn\n    pawn_attacks = 0\n    for sq, piece in board.piece_map().items():\n        if piece.color == color and piece.piece_type == chess.PAWN:\n            file = chess.square_file(sq)\n            if color == chess.WHITE:\n                pawn_attacks += board.is_attacked_by(chess.BLACK, chess.parse_square(chess.square_name(sq + 1))) + board.is_attacked_by(chess.BLACK, chess.parse_square(chess.square_name(sq - 1)))\n            else:\n                pawn_attacks += board.is_attacked_by(chess.WHITE, chess.parse_square(chess.square_name(sq + 1))) + board.is_attacked_by(chess.WHITE, chess.parse_square(chess.square_name(sq - 1)))\n    return float(pawn_attacks)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of squares controlled by the current player's pieces.\"\n    controlled_squares = set()\n    for sq, piece in board.piece_map().items():\n        if piece.color == board.turn:\n            if piece.piece_type == chess.PAWN:\n                controlled_squares.add(sq + 8 if piece.color == chess.WHITE else sq - 8)\n                controlled_squares.add(sq + 7 if piece.color == chess.WHITE and chess.square_file(sq) < 7 else sq - 9)\n                controlled_squares.add(sq + 9 if piece.color == chess.WHITE and chess.square_file(sq) > 0 else sq - 7)\n            # Add logic for other pieces...\n    return float(len(controlled_squares))", "def feature(board: chess.Board) -> float:\n    \"Calculates the material advantage in terms of piece types left on the board.\"\n    material_score = sum(1 if piece.color == chess.WHITE else -1 for piece in board.piece_map().values())\n    return float(material_score)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of squares where the opponent's king can move to.\"\n    king_square = next((sq for sq, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color != (chess.WHITE if board.turn else chess.BLACK)), None)\n    if king_square is None:\n        return 0.0\n    \n    return float(len([sq for sq in board.attackers(not board.turn, king_square) if board.is_attacked_by(board.turn, sq)]))", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces in the center of the board (d4, d5, e4, e5 for both colors).\"\n    center_squares = [chess.D4, chess.D5, chess.E4, chess.E5]\n    center_piece_count = sum(1 for sq in center_squares if board.piece_at(sq) is not None)\n    return float(center_piece_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the material advantage by evaluating the total value of pieces for both sides.\"\n    piece_value = {chess.PAWN: 100, chess.KNIGHT: 300, chess.BISHOP: 300, chess.ROOK: 500, chess.QUEEN: 900, chess.KING: 0}\n    white_value = sum(piece_value[board.piece_at(square).piece_type] for square in board.piece_map() if board.piece_at(square).color == chess.WHITE)\n    black_value = sum(piece_value[board.piece_at(square).piece_type] for square in board.piece_map() if board.piece_at(square).color == chess.BLACK)\n    result = float(white_value - black_value)\n    return result", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces that are pinned by opponent pieces.\"\n    pinned_pieces = 0\n    for square in board.piece_map():\n        piece = board.piece_at(square)\n        if piece:\n            attackers = board.attackers(chess.WHITE if piece.color == chess.BLACK else chess.BLACK, square)\n            if attackers:\n                for attack_square in attackers:\n                    if board.is_attacked_by(piece.color, attack_square) and board.piece_at(attack_square):\n                        pinned_pieces += 1\n                        break\n    return float(pinned_pieces)", "def feature(board: chess.Board) -> float:\n    \"Measures the mobility of pieces by counting pieces that can make legal moves.\"\n    mobile_pieces = sum(1 for piece in board.piece_map().values() if board.legal_moves.count() > 0)\n    return float(mobile_pieces)", "def feature(board: chess.Board) -> float:\n    \"Calculates the average square distance for pieces to the opponent's king.\"\n    opponent_king_square = next(square for square, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color == (chess.WHITE if board.turn else chess.BLACK))\n    distances = [chess.square_distance(square, opponent_king_square) for square in board.piece_map() if board.piece_at(square).color == (chess.WHITE if board.turn else chess.BLACK)]\n    result = sum(distances) / len(distances) if distances else 0.0\n    return float(result)", "def feature(board: chess.Board) -> float:\n    \"Measures the degree of control over the center (squares e4, d4, e5, d5).\"\n    central_squares = [chess.parse_square('e4'), chess.parse_square('d4'), chess.parse_square('e5'), chess.parse_square('d5')]\n    control_count = sum(1 for square in central_squares if board.is_attacked_by(board.turn, square))\n    return float(control_count)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of double-attacked pieces (attacked by two or more opposing pieces).\"\n    double_attacked_count = 0\n    for square in board.piece_map():\n        piece = board.piece_at(square)\n        if piece:\n            attackers = board.attackers(chess.WHITE if piece.color == chess.BLACK else chess.BLACK, square)\n            if len(attackers) >= 2:\n                double_attacked_count += 1\n    return float(double_attacked_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in the number of pawns on each side.\"\n    white_pawns = len([1 for square in board.piece_map() if board.piece_at(square).piece_type == chess.PAWN and board.piece_at(square).color == chess.WHITE])\n    black_pawns = len([1 for square in board.piece_map() if board.piece_at(square).piece_type == chess.PAWN and board.piece_at(square).color == chess.BLACK])\n    result = float(white_pawns - black_pawns)\n    return result", "def feature(board: chess.Board) -> float:\n    \"Measures the number of squares that are attacked by the player's pieces.\"\n    attacking_squares = set()\n    for square in board.piece_map():\n        piece = board.piece_at(square)\n        if piece and piece.color == (chess.WHITE if board.turn else chess.BLACK):\n            for move in board.legal_moves:\n                if square == move.from_square:\n                    attacking_squares.add(move.to_square)\n    return float(len(attacking_squares))", "def feature(board: chess.Board) -> float:\n    \"Calculates the total number of pieces under attack by the opponent.\"\n    under_attack_count = sum(1 for square in board.piece_map() if board.is_attacked_by(chess.WHITE if board.turn else chess.BLACK, square))\n    return float(under_attack_count)", "def feature(board: chess.Board) -> float:\n    \"Measures whether the player's pieces are coordinated by calculating the number of defending pairs.\"\n    defending_pairs = 0\n    for square in board.piece_map():\n        piece = board.piece_at(square)\n        if piece and piece.color == (chess.WHITE if board.turn else chess.BLACK):\n            attackers = board.attackers(chess.WHITE if piece.color == chess.BLACK else chess.BLACK, square)\n            if any(board.is_attacked_by(piece.color, attack_square) for attack_square in attackers):\n                defending_pairs += 1\n    return float(defending_pairs)", "def feature(board: chess.Board) -> float:\n    \"Measures the total number of squares attacked by all pieces.\"\n    total_attacks = sum(len(board.attackers(piece.color, square)) for square, piece in board.piece_map().items())\n    return float(total_attacks)", "def feature(board: chess.Board) -> float:\n    \"Calculates the total number of pawns on the board.\"\n    total_pawns = sum(1 for piece in board.piece_map().values() if piece.piece_type == chess.PAWN)\n    return float(total_pawns)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of squares controlled by the current player's pieces.\"\n    controlled_squares = set()\n    for square, piece in board.piece_map().items():\n        if piece.color == board.turn:\n            controlled_squares.update(board.attacks(square))\n    return float(len(controlled_squares))", "def feature(board: chess.Board) -> float:\n    \"Measures the distance of the kings from each other.\"\n    white_king = next(square for square, piece in board.piece_map().items() if piece.color == chess.WHITE and piece.piece_type == chess.KING)\n    black_king = next(square for square, piece in board.piece_map().items() if piece.color == chess.BLACK and piece.piece_type == chess.KING)\n    distance = chess.square_distance(white_king, black_king)\n    return float(distance)", "def feature(board: chess.Board) -> float:\n    \"Calculates the total number of pieces that are pinned.\"\n    pinned_count = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == board.turn and board.is_attacked_by(not piece.color, square):\n            attackers = board.attackers(not piece.color, square)\n            if any(board.piece_at(attack_square) and board.piece_at(attack_square).piece_type == chess.QUEEN for attack_square in attackers):\n                pinned_count += 1\n    return float(pinned_count)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of pieces that can deliver check on the next move.\"\n    check_chances = sum(1 for move in board.legal_moves if board.gives_check(move))\n    return float(check_chances)", "def feature(board: chess.Board) -> float:\n    \"Calculates the ratio of major pieces (rooks and queens) to total pieces.\"\n    major_piece_count = sum(1 for piece in board.piece_map().values() if piece.piece_type in {chess.ROOK, chess.QUEEN})\n    total_piece_count = len(board.piece_map())\n    ratio = major_piece_count / total_piece_count if total_piece_count > 0 else 0\n    return float(ratio)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces currently involved in a discovered attack.\"\n    discovered_attack_count = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == board.turn:\n            for target_square in board.attackers(not piece.color, square):\n                if board.piece_at(target_square) is not None:\n                    discovered_attack_count += 1\n                    break\n    return float(discovered_attack_count)", "def feature(board: chess.Board) -> float:\n    \"Measures the average distance of pawns from the opponent's back rank.\"\n    distance_sum = 0\n    pawn_count = 0\n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.PAWN:\n            distance_sum += chess.square_rank(square) if piece.color == chess.WHITE else 7 - chess.square_rank(square)\n            pawn_count += 1\n    average_distance = distance_sum / pawn_count if pawn_count > 0 else 0\n    return float(average_distance)", "def feature(board: chess.Board) -> float:\n    \"Counts how many pieces are currently being attacked.\"\n    attacked_count = sum(1 for square in board.piece_map() if board.is_attacked_by(not board.turn, square))\n    return float(attacked_count)", "def feature(board: chess.Board) -> float:\n    'Measures the total number of pieces attacking key squares (central squares).'\n    center_squares = [chess.D4, chess.D5, chess.E4, chess.E5]\n    attackers = sum(len(board.attackers(color, sq)) for color in [chess.WHITE, chess.BLACK] for sq in center_squares)\n    return float(attackers)", "def feature(board: chess.Board) -> float:\n    'Counts the number of units that can move to a central square in one turn.'\n    central_squares = [chess.D4, chess.D5, chess.E4, chess.E5]\n    movable_units = sum(1 for move in board.legal_moves if move.to_square in central_squares)\n    return float(movable_units)", "def feature(board: chess.Board) -> float:\n    'Calculates the difference in the number of pawns on the board for both sides.'\n    white_pawns = len([p for p in board.piece_map().values() if p.color == chess.WHITE and p.piece_type == chess.PAWN])\n    black_pawns = len([p for p in board.piece_map().values() if p.color == chess.BLACK and p.piece_type == chess.PAWN])\n    return float(white_pawns - black_pawns)", "def feature(board: chess.Board) -> float:\n    'Calculates the sum of piece values for the most valuable piece of each side.'\n    piece_values = {chess.PAWN: 100, chess.KNIGHT: 300, chess.BISHOP: 300, chess.ROOK: 500, chess.QUEEN: 900, chess.KING: 0}\n    white_max_value = max((piece_values[piece.piece_type] for piece in board.piece_map().values() if piece.color == chess.WHITE), default=0)\n    black_max_value = max((piece_values[piece.piece_type] for piece in board.piece_map().values() if piece.color == chess.BLACK), default=0)\n    return float(white_max_value - black_max_value)", "def feature(board: chess.Board) -> float:\n    'Counts the number of pawns that are double pawns (on the same file).'\n    pawn_files = {}\n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.PAWN:\n            file = chess.square_file(square)\n            pawn_files[file] = pawn_files.get(file, 0) + 1\n    double_pawn_count = sum(1 for count in pawn_files.values() if count > 1)\n    return float(double_pawn_count)", "def feature(board: chess.Board) -> float:\n    'Calculates the total number of pieces pinned by opposing pieces.'\n    pinned_count = 0\n    for square in board.piece_map():\n        piece = board.piece_at(square)\n        if piece.color == chess.WHITE:\n            if board.is_attacked_by(chess.BLACK, square):\n                pinned_count += 1\n        else:\n            if board.is_attacked_by(chess.WHITE, square):\n                pinned_count += 1\n    return float(pinned_count)", "def feature(board: chess.Board) -> float:\n    'Calculates a score based on the ratio of minor to major pieces for each side.'\n    white_minor = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE and piece.piece_type in [chess.KNIGHT, chess.BISHOP])\n    black_minor = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK and piece.piece_type in [chess.KNIGHT, chess.BISHOP])\n    white_major = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE and piece.piece_type in [chess.ROOK, chess.QUEEN])\n    black_major = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK and piece.piece_type in [chess.ROOK, chess.QUEEN])\n    return float((white_minor / (white_major + 1e-10)) - (black_minor / (black_major + 1e-10)))", "def feature(board: chess.Board) -> float:\n    'Estimates the safety of kings by counting the surrounding pieces within one square.'\n    white_king_square = next((sq for sq, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color == chess.WHITE), None)\n    black_king_square = next((sq for sq, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color == chess.BLACK), None)\n    \n    def count_neighbors(king_square):\n        if king_square is None:\n            return 0\n        return sum(1 for sq in chess.SQUARES if board.piece_at(sq) is not None and chess.square_distance(king_square, sq) == 1)\n\n    return float(count_neighbors(white_king_square) - count_neighbors(black_king_square))", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of passed pawns for each color.\"\n    white_passed_pawns = sum(1 for square, piece in board.piece_map().items() \n                              if piece.color == chess.WHITE and piece.piece_type == chess.PAWN and \n                              all(board.piece_at(chess.square_file(square) + i) is None for i in range(1, 8)))\n    black_passed_pawns = sum(1 for square, piece in board.piece_map().items() \n                              if piece.color == chess.BLACK and piece.piece_type == chess.PAWN and \n                              all(board.piece_at(chess.square_file(square) - i) is None for i in range(1, 8)))\n    return float(white_passed_pawns - black_passed_pawns)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of squares controlled by each color.\"\n    controlled_white = sum(1 for square in chess.SQUARES if board.is_attacked_by(chess.WHITE, square))\n    controlled_black = sum(1 for square in chess.SQUARES if board.is_attacked_by(chess.BLACK, square))\n    return float(controlled_white - controlled_black)", "def feature(board: chess.Board) -> float:\n    \"Measures the rook activity by counting the number of open files for rooks.\"\n    open_files = sum(1 for file in range(8) if all(board.piece_at(chess.square(file, rank)) is None for rank in range(8)))\n    return float(open_files)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces within the opponent's territory for each side.\"\n    white_pieces_in_enemy_territory = sum(1 for square, piece in board.piece_map().items() \n                                           if piece.color == chess.WHITE and chess.square_rank(square) > 4)\n    black_pieces_in_enemy_territory = sum(1 for square, piece in board.piece_map().items() \n                                           if piece.color == chess.BLACK and chess.square_rank(square) < 4)\n    return float(white_pieces_in_enemy_territory - black_pieces_in_enemy_territory)", "def feature(board: chess.Board) -> float:\n    \"Calculates the king safety based on the number of adjacent squares controlled by the opponent.\"\n    white_king_square = next((square for square, piece in board.piece_map().items() \n                               if piece.color == chess.WHITE and piece.piece_type == chess.KING), None)\n    black_king_square = next((square for square, piece in board.piece_map().items() \n                               if piece.color == chess.BLACK and piece.piece_type == chess.KING), None)\n    white_king_attackers = sum(1 for square in chess.SQUARES if board.is_attacked_by(chess.BLACK, square) and \n                                chess.square_distance(square, white_king_square) <= 1)\n    black_king_attackers = sum(1 for square in chess.SQUARES if board.is_attacked_by(chess.WHITE, square) and \n                                chess.square_distance(square, black_king_square) <= 1)\n    return float(black_king_attackers - white_king_attackers)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of minor pieces (knights and bishops) still on the board.\"\n    white_minors = sum(1 for piece in board.piece_map().values() \n                       if piece.color == chess.WHITE and piece.piece_type in [chess.KNIGHT, chess.BISHOP])\n    black_minors = sum(1 for piece in board.piece_map().values() \n                       if piece.color == chess.BLACK and piece.piece_type in [chess.KNIGHT, chess.BISHOP])\n    return float(white_minors - black_minors)", "def feature(board: chess.Board) -> float:\n    \"Evaluates the number of doubled pawns for each player.\"\n    white_doubled_pawns = sum(1 for file in range(8) \n                               if sum(1 for square in chess.SQUARES if board.piece_at(square) is not None and \n                                      board.piece_at(square).color == chess.WHITE and \n                                      chess.square_file(square) == file) > 1)\n    black_doubled_pawns = sum(1 for file in range(8) \n                               if sum(1 for square in chess.SQUARES if board.piece_at(square) is not None and \n                                      board.piece_at(square).color == chess.BLACK and \n                                      chess.square_file(square) == file) > 1)\n    return float(white_doubled_pawns - black_doubled_pawns)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces attacking the opponent's king.\"\n    white_king_square = next((square for square in chess.SQUARES \n                               if board.piece_at(square) is not None and \n                               board.piece_at(square).color == chess.WHITE and \n                               board.piece_at(square).piece_type == chess.KING), None)\n    black_king_square = next((square for square in chess.SQUARES \n                               if board.piece_at(square) is not None and \n                               board.piece_at(square).color == chess.BLACK and \n                               board.piece_at(square).piece_type == chess.KING), None)\n    white_attackers = sum(1 for square in chess.SQUARES if board.is_attacked_by(chess.WHITE, square) and \n                           square == black_king_square)\n    black_attackers = sum(1 for square in chess.SQUARES if board.is_attacked_by(chess.BLACK, square) and \n                           square == white_king_square)\n    return float(white_attackers - black_attackers)", "def feature(board: chess.Board) -> float:\n    \"Counts the total number of pieces on the board and returns the value.\"\n    return float(len(board.piece_map()))", "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in the number of pawns for both players.\"\n    white_pawns = sum(1 for piece in board.piece_map().values() if piece.piece_type == chess.PAWN and piece.color == chess.WHITE)\n    black_pawns = sum(1 for piece in board.piece_map().values() if piece.piece_type == chess.PAWN and piece.color == chess.BLACK)\n    return float(white_pawns - black_pawns)", "def feature(board: chess.Board) -> float:\n    \"Measures the distance of the kings from each other; smaller distance is better.\"\n    white_king = next(square for square, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color == chess.WHITE)\n    black_king = next(square for square, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color == chess.BLACK)\n    distance = chess.square_distance(white_king, black_king)\n    return float(1 / (distance + 1))  # Add 1 to avoid division by zero", "def feature(board: chess.Board) -> float:\n    \"Counts the number of controlled squares by the active player's pieces.\"\n    color = board.turn\n    controlled_squares = set()\n    for square in board.piece_map():\n        piece = board.piece_at(square)\n        if piece and piece.color == color:\n            for move in board.legal_moves:\n                if move.from_square == square:\n                    controlled_squares.add(move.to_square)\n    return float(len(controlled_squares))", "def feature(board: chess.Board) -> float:\n    \"Calculates the total mobility of both players as the sum of legal moves.\"\n    return float(len(list(board.legal_moves)))", "def feature(board: chess.Board) -> float:\n    \"Measures if either player has a piece that is currently attacking the opponent's king.\"\n    white_attacking_king = board.is_attacked_by(chess.WHITE, chess.parse_square('e8'))  # assuming black king at e8\n    black_attacking_king = board.is_attacked_by(chess.BLACK, chess.parse_square('e1'))  # assuming white king at e1\n    return float(int(white_attacking_king) + int(black_attacking_king))", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of pieces that are in danger of being captured.\"\n    danger_count = sum(1 for square in board.piece_map() if board.is_attacked_by(not board.turn, square))\n    return float(danger_count)", "def feature(board: chess.Board) -> float:\n    \"Measures the difference in piece values for pieces on the board.\"\n    piece_values = {\n        chess.PAWN: 100,\n        chess.KNIGHT: 320,\n        chess.BISHOP: 330,\n        chess.ROOK: 500,\n        chess.QUEEN: 900,\n        chess.KING: 0  # King is invaluable for this purpose\n    }\n    value_white = sum(piece_values[piece.piece_type] for piece in board.piece_map().values() if piece.color == chess.WHITE)\n    value_black = sum(piece_values[piece.piece_type] for piece in board.piece_map().values() if piece.color == chess.BLACK)\n    return float(value_white - value_black)", "def feature(board: chess.Board) -> float:\n    \"Evaluates if any player has doubled pawns.\"\n    doubled_pawns = 0\n    for file in range(8):\n        white_count = sum(1 for square in range(8) if board.piece_at(chess.square(file, square)) == chess.PAWN)\n        black_count = sum(1 for square in range(8) if board.piece_at(chess.square(file, square)) == chess.PAWN)\n        if white_count > 1:\n            doubled_pawns += 1\n        if black_count > 1:\n            doubled_pawns += 1\n    return float(doubled_pawns)", "def feature(board: chess.Board) -> float:\n    \"Calculates the sum of the distances of all pieces from their respective pawns.\"\n    total_distance = 0\n    for square, piece in board.piece_map().items():\n        if piece.piece_type != chess.PAWN:\n            pawn_squares = [s for s in board.piece_map() if board.piece_at(s).piece_type == chess.PAWN and board.piece_at(s).color == piece.color]\n            if pawn_squares:\n                closest_distance = min(chess.square_distance(square, ps) for ps in pawn_squares)\n                total_distance += closest_distance\n    return total_distance", "def feature(board: chess.Board) -> float:\n    \"Measures the number of doubled pawns for both players.\"\n    white_doubled = sum(1 for file in range(8) if sum(1 for rank in range(8) if board.piece_at(chess.square(file, rank)) == chess.PAWN and rank < 8) > 1)\n    black_doubled = sum(1 for file in range(8) if sum(1 for rank in range(8) if board.piece_at(chess.square(file, rank)) == chess.PAWN and rank > 1) > 1)\n    return float(white_doubled - black_doubled)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of major pieces (rooks and queens) on the board.\"\n    major_pieces_count = sum(1 for piece in board.piece_map().values() if piece.piece_type in (chess.ROOK, chess.QUEEN))\n    return float(major_pieces_count)", "def feature(board: chess.Board) -> float:\n    \"Measures the safety of the king by counting the number of attackers on its square.\"\n    king_square = board.king(chess.WHITE if board.turn else chess.BLACK)\n    attackers_count = len(board.attackers(board.turn, king_square))\n    return float(attackers_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the average rank of all pawns for each player.\"\n    white_pawn_ranks = [chess.square_rank(sq) for sq, piece in board.piece_map().items() if piece.piece_type == chess.PAWN and piece.color == chess.WHITE]\n    black_pawn_ranks = [chess.square_rank(sq) for sq, piece in board.piece_map().items() if piece.piece_type == chess.PAWN and piece.color == chess.BLACK]\n    \n    avg_white_rank = sum(white_pawn_ranks) / len(white_pawn_ranks) if white_pawn_ranks else 0\n    avg_black_rank = sum(black_pawn_ranks) / len(black_pawn_ranks) if black_pawn_ranks else 0\n    \n    return float(avg_white_rank - avg_black_rank)", "def feature(board: chess.Board) -> float:\n    \"Calculates the average distance of pieces from the center of the board.\"\n    center_squares = [chess.E4, chess.D4, chess.E5, chess.D5]\n    total_distance = 0\n    piece_count = len(board.piece_map())\n    \n    for piece_square in board.piece_map():\n        total_distance += min(chess.square_distance(piece_square, center) for center in center_squares)\n    \n    return total_distance / piece_count if piece_count > 0 else 0.0", "def feature(board: chess.Board) -> float:\n    \"Measures the difference in mobility for both players based on legal moves.\"\n    white_mobility = len(list(board.legal_moves)) if board.turn else 0\n    black_mobility = len(list(board.legal_moves)) if not board.turn else 0\n    return float(white_mobility - black_mobility)", "def feature(board: chess.Board) -> float:\n    \"Evaluates the number of pieces that attack the opponent's king.\"\n    king_square = None\n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.KING and piece.color == chess.BLACK:\n            king_square = square\n            break\n    if king_square is None:\n        return 0.0\n    attackers = board.attackers(chess.WHITE, king_square)\n    return float(len(attackers))", "def feature(board: chess.Board) -> float:\n    \"Measures the mobility of all pieces on the board by counting their legal moves.\"\n    total_moves = sum(len(list(board.legal_moves)) for piece in board.piece_map().values())\n    return float(total_moves)", "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in the number of pieces on the board.\"\n    white_count = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE)\n    black_count = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK)\n    return float(white_count - black_count)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of pawns remaining on the board for both colors.\"\n    white_pawns = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE and piece.piece_type == chess.PAWN)\n    black_pawns = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK and piece.piece_type == chess.PAWN)\n    return float(white_pawns - black_pawns)", "def feature(board: chess.Board) -> float:\n    \"Evaluates the concentration of pieces by measuring the average distance between pieces of the same color.\"\n    pieces = [square for square, piece in board.piece_map().items() if piece.color == board.turn]\n    if len(pieces) < 2:\n        return 0.0\n    total_distance = sum(chess.square_distance(pieces[i], pieces[j]) for i in range(len(pieces)) for j in range(i + 1, len(pieces)))\n    num_pairs = len(pieces) * (len(pieces) - 1) / 2\n    return total_distance / num_pairs if num_pairs > 0 else 0.0", "def feature(board: chess.Board) -> float:\n    \"Checks if the current player is in check and returns a penalty value if so.\"\n    return float(-100) if board.is_check() else 0.0", "def feature(board: chess.Board) -> float:\n    \"Calculates the total value of pieces on the board for the active color.\"\n    piece_values = {chess.PAWN: 100, chess.KNIGHT: 320, chess.BISHOP: 330, chess.ROOK: 500, chess.QUEEN: 900, chess.KING: 0}\n    total_value = sum(piece_values[piece.piece_type] for piece in board.piece_map().values() if piece.color == board.turn)\n    return float(total_value)", "def feature(board: chess.Board) -> float:\n    \"Measures the positional advantage by counting the number of pieces on advanced ranks for the active color.\"\n    advanced_ranks = [1, 2, 3, 4, 5, 6, 7] if board.turn == chess.WHITE else [0, 1, 2, 3, 4, 5]\n    advanced_pieces = sum(1 for square, piece in board.piece_map().items() if piece.color == board.turn and chess.square_rank(square) in advanced_ranks)\n    return float(advanced_pieces)", "def feature(board: chess.Board) -> float:\n    \"Evaluates the king safety by counting the number of opponent's pieces attacking the king's escape squares.\"\n    king_square = next(square for square, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color == board.turn)\n    escape_squares = [chess.square_name(king_square + offset) for offset in [-1, 1, -8, 8] if 0 <= king_square + offset < 64]\n    threats = sum(board.is_attacked_by(not board.turn, chess.parse_square(square)) for square in escape_squares)\n    return float(threats)", "def feature(board: chess.Board) -> float:\n    \"Counts how many squares are attacked by each side and computes their ratio.\"\n    white_attacks = sum(board.is_attacked_by(chess.WHITE, square) for square in chess.SQUARES)\n    black_attacks = sum(board.is_attacked_by(chess.BLACK, square) for square in chess.SQUARES)\n    \n    if black_attacks == 0:\n        return float('inf')\n    return white_attacks / black_attacks", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of potential checkmating threats each side has.\"\n    white_threats = sum(1 for move in board.legal_moves if board.is_check() and board.turn == chess.WHITE)\n    black_threats = sum(1 for move in board.legal_moves if board.is_check() and board.turn == chess.BLACK)\n    \n    return white_threats - black_threats", "def feature(board: chess.Board) -> float:\n    \"Measures the value of pieces protected by pawns for both sides.\"\n    value_map = {\n        chess.PAWN: 1, chess.KNIGHT: 3, chess.BISHOP: 3,\n        chess.ROOK: 5, chess.QUEEN: 9, chess.KING: 0\n    }\n\n    white_protected_value = 0\n    black_protected_value = 0\n\n    for square, piece in board.piece_map().items():\n        if piece.color == chess.WHITE:\n            attackers = board.attackers(chess.BLACK, square)\n            if all(board.piece_at(attacker) is None or board.piece_at(attacker).color == chess.WHITE for attacker in attackers):\n                white_protected_value += value_map.get(piece.piece_type, 0)\n        else:\n            attackers = board.attackers(chess.WHITE, square)\n            if all(board.piece_at(attacker) is None or board.piece_at(attacker).color == chess.BLACK for attacker in attackers):\n                black_protected_value += value_map.get(piece.piece_type, 0)\n\n    return white_protected_value - black_protected_value", "def feature(board: chess.Board) -> float:\n    \"Calculates the material imbalance considering only qualitative piece development.\"\n    development_score = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == chess.WHITE:\n            development_score += 0.1 * (piece.piece_type + 1)  # Slightly favor developed pieces\n        else:\n            development_score -= 0.1 * (piece.piece_type + 1)\n\n    return development_score", "def feature(board: chess.Board) -> float:\n    \"Measures control over central squares (d4, d5, e4, e5) by each side.\"\n    central_squares = [chess.D4, chess.D5, chess.E4, chess.E5]\n    control_score = 0\n\n    for square in central_squares:\n        if board.is_attacked_by(chess.WHITE, square):\n            control_score += 1\n        if board.is_attacked_by(chess.BLACK, square):\n            control_score -= 1\n\n    return control_score", "def feature(board: chess.Board) -> float:\n    \"Calculates the total number of double attacks present on the board.\"\n    double_attack_count = 0\n\n    for square in chess.SQUARES:\n        if board.piece_at(square):\n            attackers = board.attackers(board.piece_at(square).color, square)\n            if len(attackers) > 1:\n                double_attack_count += 1\n\n    return float(double_attack_count)", "def feature(board: chess.Board) -> float:\n    \"Assesses the advancement of pawns on the board.\"\n    white_passed = sum(1 for square in chess.SQUARES if board.piece_at(square) and board.piece_at(square).color == chess.WHITE)\n    black_passed = sum(1 for square in chess.SQUARES if board.piece_at(square) and board.piece_at(square).color == chess.BLACK)\n\n    return float(white_passed - black_passed)", "def feature(board: chess.Board) -> float:\n    \"Estimates the potential for promotion by counting passed pawns.\"\n    white_passed = sum(1 for square in chess.SQUARES if board.piece_at(square) and board.piece_at(square).color == chess.WHITE and board.piece_at(square).piece_type == chess.PAWN and not any(board.is_attacked_by(chess.BLACK, square + 8 * i) for i in range(1, 2)))\n    black_passed = sum(1 for square in chess.SQUARES if board.piece_at(square) and board.piece_at(square).color == chess.BLACK and board.piece_at(square).piece_type == chess.PAWN and not any(board.is_attacked_by(chess.WHITE, square - 8 * i) for i in range(1, 2)))\n\n    return float(white_passed - black_passed)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pawns advanced for both sides, where advanced pawns are on rank 4 or 5 for White and 4 or 3 for Black.\"\n    white_advanced_pawns = sum(1 for sq in board.piece_map() if board.piece_at(sq).color == chess.WHITE and chess.square_rank(sq) >= 4 and board.piece_at(sq).piece_type == chess.PAWN)\n    black_advanced_pawns = sum(1 for sq in board.piece_map() if board.piece_at(sq).color == chess.BLACK and chess.square_rank(sq) <= 4 and board.piece_at(sq).piece_type == chess.PAWN)\n    return float(white_advanced_pawns - black_advanced_pawns)", "def feature(board: chess.Board) -> float:\n    \"Measures the total number of pieces on the board for both sides.\"\n    total_pieces = len(board.piece_map())\n    return float(total_pieces)", "def feature(board: chess.Board) -> float:\n    \"Calculates the proximity of the kings to the center of the board, rewarding central positioning.\"\n    white_king = next(sq for sq in board.piece_map() if board.piece_at(sq).color == chess.WHITE and board.piece_at(sq).piece_type == chess.KING)\n    black_king = next(sq for sq in board.piece_map() if board.piece_at(sq).color == chess.BLACK and board.piece_at(sq).piece_type == chess.KING)\n    center_distance = (chess.square_distance(white_king, chess.E4) + chess.square_distance(black_king, chess.E5))\n    return float(16 - center_distance)  # Closer is better", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of attackable squares for each side, giving an idea of control over the board.\"\n    white_attackable = sum(len(board.attackers(chess.WHITE, sq)) for sq in board.piece_map() if board.piece_at(sq).color == chess.WHITE)\n    black_attackable = sum(len(board.attackers(chess.BLACK, sq)) for sq in board.piece_map() if board.piece_at(sq).color == chess.BLACK)\n    return float(white_attackable - black_attackable)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of pieces under attack for each player, which can indicate vulnerabilities.\"\n    white_under_attack = sum(1 for sq in board.piece_map() if board.piece_at(sq).color == chess.WHITE and board.is_attacked_by(chess.BLACK, sq))\n    black_under_attack = sum(1 for sq in board.piece_map() if board.piece_at(sq).color == chess.BLACK and board.is_attacked_by(chess.WHITE, sq))\n    return float(black_under_attack - white_under_attack)", "def feature(board: chess.Board) -> float:\n    \"Evaluates the position based on the number of pieces pinned against the king.\"\n    white_pinned = sum(1 for sq in board.piece_map() if board.piece_at(sq).color == chess.WHITE and board.is_attacked_by(chess.BLACK, sq) and board.piece_at(sq).piece_type != chess.KING)\n    black_pinned = sum(1 for sq in board.piece_map() if board.piece_at(sq).color == chess.BLACK and board.is_attacked_by(chess.WHITE, sq) and board.piece_at(sq).piece_type != chess.KING)\n    return float(white_pinned - black_pinned)", "def feature(board: chess.Board) -> float:\n    \"Counts the pieces that are in an open file (relevant for rooks and queens).\"\n    open_file_count = 0\n    for file in range(8):\n        if all(board.piece_at(chess.square(file, rank)) is None for rank in range(8)):\n            open_file_count += 1\n    return float(open_file_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in material value considering only minor pieces (knights and bishops).\"\n    piece_values = {chess.KNIGHT: 320, chess.BISHOP: 330}\n    white_minor_value = sum(piece_values.get(board.piece_at(sq).piece_type, 0) for sq in board.piece_map() if board.piece_at(sq).color == chess.WHITE)\n    black_minor_value = sum(piece_values.get(board.piece_at(sq).piece_type, 0) for sq in board.piece_map() if board.piece_at(sq).color == chess.BLACK)\n    return float(white_minor_value - black_minor_value)", "def feature(board: chess.Board) -> float:\n    \"Gives the difference in the number of pieces on squares with more than one attack (strong squares).\"\n    strong_squares_count = 0\n    for square in chess.SQUARES:\n        if len(board.attackers(chess.WHITE, square)) > 1:\n            strong_squares_count += 1\n        if len(board.attackers(chess.BLACK, square)) > 1:\n            strong_squares_count -= 1\n    return float(strong_squares_count)", "def feature(board: chess.Board) -> float:\n    \"Measures the total number of pieces for each player and returns the ratio.\"\n    white_pieces = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE)\n    black_pieces = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK)\n    return white_pieces / (black_pieces + 1e-9)  # Add small epsilon to avoid division by zero", "def feature(board: chess.Board) -> float:\n    \"Counts advanced pawns (pawns on ranks 4 or 5 for White and 4 or 3 for Black).\"\n    advanced_pawns = 0\n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.PAWN:\n            rank = chess.square_rank(square)\n            if (piece.color == chess.WHITE and rank >= 3) or (piece.color == chess.BLACK and rank <= 4):\n                advanced_pawns += 1\n    return float(advanced_pawns)", "def feature(board: chess.Board) -> float:\n    \"Calculates the total number of threatened pieces on the board.\"\n    threatened_pieces = 0\n    for square, piece in board.piece_map().items():\n        if board.is_attacked_by(not piece.color, square):\n            threatened_pieces += 1\n    return float(threatened_pieces)", "def feature(board: chess.Board) -> float:\n    \"Returns the difference in central pawn structure (control of central squares).\"\n    central_squares = [chess.E4, chess.E5, chess.D4, chess.D5]\n    white_central_pawns = sum(1 for sq in central_squares if board.piece_at(sq) == chess.PAWN and board.piece_at(sq).color == chess.WHITE)\n    black_central_pawns = sum(1 for sq in central_squares if board.piece_at(sq) == chess.PAWN and board.piece_at(sq).color == chess.BLACK)\n    return float(white_central_pawns - black_central_pawns)", "def feature(board: chess.Board) -> float:\n    \"Measures how many pieces are attacking the enemy king.\"\n    enemy_king_square = board.king(not board.turn)\n    attackers_count = len(board.attackers(board.turn, enemy_king_square))\n    return float(attackers_count)", "def feature(board: chess.Board) -> float:\n    \"Computes the ratio of total pawns to total pieces on the board.\"\n    total_pawns = sum(1 for piece in board.piece_map().values() if piece.piece_type == chess.PAWN)\n    total_pieces = len(board.piece_map())\n    return float(total_pawns / (total_pieces + 1e-9))", "def feature(board: chess.Board) -> float:\n    \"Measures the activity of rooks based on their distance from the 7th rank.\"\n    active_rooks = 0\n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.ROOK:\n            rank = chess.square_rank(square)\n            if (piece.color == chess.WHITE and rank == 6) or (piece.color == chess.BLACK and rank == 1):\n                active_rooks += 1\n    return float(active_rooks)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of pieces in the last rank for both players.\"\n    white_last_rank = sum(1 for sq in range(56, 64) if board.piece_at(sq) and board.piece_at(sq).color == chess.WHITE)\n    black_last_rank = sum(1 for sq in range(0, 8) if board.piece_at(sq) and board.piece_at(sq).color == chess.BLACK)\n    return float(white_last_rank - black_last_rank)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pawns in the promotion ranks for both players.\"\n    white_promotions = sum(1 for sq in range(48, 56) if board.piece_at(sq) and board.piece_at(sq).piece_type == chess.PAWN)\n    black_promotions = sum(1 for sq in range(8, 16) if board.piece_at(sq) and board.piece_at(sq).piece_type == chess.PAWN)\n    return float(white_promotions - black_promotions)", "def feature(board: chess.Board) -> float:\n    \"Calculates the distance of the kings to the nearest enemy piece.\"\n    white_king_sq = next((sq for sq in board.piece_map() if board.piece_map()[sq].piece_type == chess.KING and board.piece_map()[sq].color == chess.WHITE), None)\n    black_king_sq = next((sq for sq in board.piece_map() if board.piece_map()[sq].piece_type == chess.KING and board.piece_map()[sq].color == chess.BLACK), None)\n    white_dist = min(chess.square_distance(white_king_sq, sq) for sq in board.piece_map() if board.piece_map()[sq].color == chess.BLACK) if white_king_sq else float('inf')\n    black_dist = min(chess.square_distance(black_king_sq, sq) for sq in board.piece_map() if board.piece_map()[sq].color == chess.WHITE) if black_king_sq else float('inf')\n    return float(white_dist - black_dist)", "def feature(board: chess.Board) -> float:\n    \"Calculates the material value of the pieces remaining on the board.\"\n    piece_values = {chess.PAWN: 100, chess.KNIGHT: 300, chess.BISHOP: 300, chess.ROOK: 500, chess.QUEEN: 900, chess.KING: 0}\n    material_balance = sum(piece_values[board.piece_map()[sq].piece_type] * (1 if board.piece_map()[sq].color == chess.WHITE else -1) for sq in board.piece_map())\n    return float(material_balance)", "def feature(board: chess.Board) -> float:\n    \"Measures the total number of attacks on kings and their proximity to attackers.\"\n    white_attackers = sum(1 for sq in board.attackers(chess.WHITE, next((sq for sq in board.piece_map() if board.piece_map()[sq].piece_type == chess.KING and board.piece_map()[sq].color == chess.WHITE), None)) if board.is_attacked_by(chess.BLACK, sq))\n    black_attackers = sum(1 for sq in board.attackers(chess.BLACK, next((sq for sq in board.piece_map() if board.piece_map()[sq].piece_type == chess.KING and board.piece_map()[sq].color == chess.BLACK), None)) if board.is_attacked_by(chess.WHITE, sq))\n    return float(white_attackers - black_attackers)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of squares from which a king can safely escape.\"\n    white_king_sq = next((sq for sq in board.piece_map() if board.piece_map()[sq].piece_type == chess.KING and board.piece_map()[sq].color == chess.WHITE), None)\n    black_king_sq = next((sq for sq in board.piece_map() if board.piece_map()[sq].piece_type == chess.KING and board.piece_map()[sq].color == chess.BLACK), None)\n    white_moves = sum(1 for sq in chess.SQUARES if board.is_legal(chess.Move(white_king_sq, sq)) and not board.is_attacked_by(chess.BLACK, sq))\n    black_moves = sum(1 for sq in chess.SQUARES if board.is_legal(chess.Move(black_king_sq, sq)) and not board.is_attacked_by(chess.WHITE, sq))\n    return float(white_moves - black_moves)", "def feature(board: chess.Board) -> float:\n    \"Evaluates material balance adjusted for piece activity on the board.\"\n    piece_values = {chess.PAWN: 100, chess.KNIGHT: 300, chess.BISHOP: 300, chess.ROOK: 500, chess.QUEEN: 900, chess.KING: 0}\n    activity_factor = sum(1 for piece in board.piece_map().values() if piece.color == board.turn)\n    material_balance = sum(piece_values[piece.piece_type] * (1 if piece.color == chess.WHITE else -1) for piece in board.piece_map().values())\n    return float(material_balance + activity_factor)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pawns on the 4th and 5th ranks for White, and 4th and 3rd ranks for Black.\"\n    white_advanced_pawns = sum(1 for sq in board.piece_map() if board.piece_at(sq).piece_type == chess.PAWN and board.piece_at(sq).color == chess.WHITE and chess.square_rank(sq) >= 4)\n    black_advanced_pawns = sum(1 for sq in board.piece_map() if board.piece_at(sq).piece_type == chess.PAWN and board.piece_at(sq).color == chess.BLACK and chess.square_rank(sq) <= 4)\n    return float(white_advanced_pawns - black_advanced_pawns)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces for each player and returns the difference.\"\n    white_piece_count = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE)\n    black_piece_count = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK)\n    return float(white_piece_count - black_piece_count)", "def feature(board: chess.Board) -> float:\n    \"Measures the distance of the closest enemy piece to the opponent's king.\"\n    if board.turn == chess.WHITE:\n        king_square = board.king(chess.WHITE)\n        enemy_pieces = [sq for sq, piece in board.piece_map().items() if piece.color == chess.BLACK]\n    else:\n        king_square = board.king(chess.BLACK)\n        enemy_pieces = [sq for sq, piece in board.piece_map().items() if piece.color == chess.WHITE]\n    if not enemy_pieces:\n        return float('inf')\n    distances = [chess.square_distance(king_square, sq) for sq in enemy_pieces]\n    return float(min(distances))", "def feature(board: chess.Board) -> float:\n    \"Calculates the ratio of major pieces (rook, queen, king) to total pieces on the board.\"\n    major_piece_types = {chess.ROOK, chess.QUEEN, chess.KING}\n    total_pieces = len(board.piece_map())\n    major_piece_count = sum(1 for piece in board.piece_map().values() if piece.piece_type in major_piece_types)\n    return float(major_piece_count / total_pieces) if total_pieces > 0 else 0.0", "def feature(board: chess.Board) -> float:\n    \"Counts the number of squares controlled by pieces of the player to move.\"\n    controlled_squares = set()\n    for move in board.legal_moves:\n        controlled_squares.add(move.to_square)\n    return float(len(controlled_squares))", "def feature(board: chess.Board) -> float:\n    \"Checks and gives a score based on whether the current player is in check, checkmate, or stalemate.\"\n    if board.is_checkmate():\n        return -1000.0\n    elif board.is_stalemate():\n        return 0.0\n    elif board.is_check():\n        return -100.0\n    return 100.0", "def feature(board: chess.Board) -> float:\n    \"Evaluates the position based on the number of targets (attacked pieces) for both players.\"\n    white_attack_count = sum(1 for sq in board.piece_map() if board.is_attacked_by(chess.WHITE, sq) and board.piece_at(sq).color == chess.BLACK)\n    black_attack_count = sum(1 for sq in board.piece_map() if board.is_attacked_by(chess.BLACK, sq) and board.piece_at(sq).color == chess.WHITE)\n    return float(white_attack_count - black_attack_count)", "def feature(board: chess.Board) -> float:\n    \"Computes a feature based on the halfmove clock, penalizing positions nearing the 50-move rule.\"\n    return float(1.0 / (1 + board.halfmove_clock))", "def feature(board: chess.Board) -> float:\n    \"Measures the number of doubled pawns for each player.\"\n    white_doubled_pawns = sum(1 for file in range(8) if len([sq for sq in range(8) if board.piece_at(chess.square(file, sq)) and board.piece_at(chess.square(file, sq)).color == chess.WHITE]) > 1)\n    black_doubled_pawns = sum(1 for file in range(8) if len([sq for sq in range(8) if board.piece_at(chess.square(file, sq)) and board.piece_at(chess.square(file, sq)).color == chess.BLACK]) > 1)\n    return float(white_doubled_pawns - black_doubled_pawns)", "def feature(board: chess.Board) -> float:\n    \"Assesses the position based on the material difference in terms of piece values.\"\n    piece_values = {\n        chess.PAWN: 100,\n        chess.KNIGHT: 320,\n        chess.BISHOP: 330,\n        chess.ROOK: 500,\n        chess.QUEEN: 900,\n        chess.KING: 20000\n    }\n    material_balance = sum(piece_values[piece.piece_type] * (1 if piece.color == chess.WHITE else -1) for piece in board.piece_map().values())\n    return float(material_balance)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of pawns on the 7th and 8th ranks (promotion potential).\"\n    pawn_count = sum(1 for square, piece in board.piece_map().items() if piece.piece_type == chess.PAWN and chess.square_rank(square) >= 6)\n    return float(pawn_count)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces protected by other pieces.\"\n    protected_count = sum(1 for square, piece in board.piece_map().items() if any(board.is_attacked_by(piece.color, square) for square in board.attackers(not piece.color, square)))\n    return float(protected_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the average distance of all pieces from their home squares.\"\n    distance_sum = 0\n    piece_count = 0\n    home_squares = {\n        chess.WHITE: [chess.A7, chess.B7, chess.C7, chess.D7, chess.E7, chess.F7, chess.G7, chess.H7],\n        chess.BLACK: [chess.A2, chess.B2, chess.C2, chess.D2, chess.E2, chess.F2, chess.G2, chess.H2],\n    }\n    for square, piece in board.piece_map().items():\n        piece_count += 1\n        distance_sum += chess.square_distance(square, home_squares[piece.color][piece.piece_type - 1]) if piece.color == chess.WHITE else chess.square_distance(square, home_squares[piece.color][piece.piece_type - 1])\n    return distance_sum / piece_count if piece_count > 0 else 0.0", "def feature(board: chess.Board) -> float:\n    \"Measures the number of squares controlled by pawns.\"\n    controlled_squares = set()\n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.PAWN:\n            rank, file = chess.square_rank(square), chess.square_file(square)\n            if piece.color == chess.WHITE:\n                controlled_squares.update([chess.square(rank + 1, file - 1), chess.square(rank + 1, file + 1)])\n            else:\n                controlled_squares.update([chess.square(rank - 1, file - 1), chess.square(rank - 1, file + 1)])\n    return float(len(controlled_squares))", "def feature(board: chess.Board) -> float:\n    \"Counts the number of double-attacked pieces (pieces attacked by two or more pieces).\"\n    double_attacked_count = sum(1 for square, piece in board.piece_map().items() if len(board.attackers(not piece.color, square)) > 1)\n    return float(double_attacked_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the mobility of pieces based on the number of legal moves.\"\n    mobility_score = sum(len(list(board.legal_moves)) for piece in board.piece_map().values())\n    return float(mobility_score)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of isolated pawns (pawns with no pawns of the same color on adjacent files).\"\n    isolated_pawn_count = 0\n    for file in range(8):\n        if board.piece_at(chess.square(6, file)) == chess.PAWN and (file == 0 or board.piece_at(chess.square(6, file - 1)) != chess.PAWN) and (file == 7 or board.piece_at(chess.square(6, file + 1)) != chess.PAWN):\n            isolated_pawn_count += 1\n        if board.piece_at(chess.square(1, file)) == chess.PAWN and (file == 0 or board.piece_at(chess.square(1, file - 1)) != chess.PAWN) and (file == 7 or board.piece_at(chess.square(1, file + 1)) != chess.PAWN):\n            isolated_pawn_count += 1\n    return float(isolated_pawn_count)", "def feature(board: chess.Board) -> float:\n    \"Measures the king safety based on the number of squares around the king that are controlled by the opponent.\"\n    king_square = board.king(chess.WHITE) if board.turn else board.king(chess.BLACK)\n    unsafe_squares = sum(1 for square in chess.SQUARES if board.is_attacked_by(not board.turn, square))\n    return float(unsafe_squares)", "def feature(board: chess.Board) -> float:\n    \"Measures the mobility of the pieces by counting legal moves available for each player.\"\n    white_moves = len(list(board.legal_moves))\n    board.turn = not board.turn  # Switch to the opponent's turn to count their moves\n    black_moves = len(list(board.legal_moves))\n    board.turn = not board.turn  # Switch back to original turn\n    result = white_moves - black_moves\n    return float(result)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of advanced pawns for each side (pawns on ranks 4 or 5 for White, 4 or 3 for Black).\"\n    white_advanced_pawns = sum(1 for square in board.piece_map() \n                                if board.piece_at(square).piece_type == chess.PAWN and \n                                board.piece_at(square).color == chess.WHITE and \n                                chess.square_rank(square) >= 4)\n    black_advanced_pawns = sum(1 for square in board.piece_map() \n                                if board.piece_at(square).piece_type == chess.PAWN and \n                                board.piece_at(square).color == chess.BLACK and \n                                chess.square_rank(square) <= 3)\n    result = white_advanced_pawns - black_advanced_pawns\n    return float(result)", "def feature(board: chess.Board) -> float:\n    \"Counts the total number of pieces for both players and calculates the difference.\"\n    white_piece_count = len([p for p in board.piece_map().values() if p.color == chess.WHITE])\n    black_piece_count = len([p for p in board.piece_map().values() if p.color == chess.BLACK])\n    result = white_piece_count - black_piece_count\n    return float(result)", "def feature(board: chess.Board) -> float:\n    \"Measures the control of the center by counting pieces on central squares (d4, d5, e4, e5).\"\n    central_squares = [chess.parse_square('d4'), chess.parse_square('d5'), \n                       chess.parse_square('e4'), chess.parse_square('e5')]\n    control_count = sum(1 for square in central_squares if board.is_attacked_by(chess.WHITE, square)) - \\\n                   sum(1 for square in central_squares if board.is_attacked_by(chess.BLACK, square))\n    return float(control_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in king safety by counting the number of pieces defending each king.\"\n    white_king_square = next(square for square, piece in board.piece_map().items() \n                              if piece.color == chess.WHITE and piece.piece_type == chess.KING)\n    black_king_square = next(square for square, piece in board.piece_map().items() \n                              if piece.color == chess.BLACK and piece.piece_type == chess.KING)\n    \n    white_defenders = len(board.attackers(chess.WHITE, white_king_square))\n    black_defenders = len(board.attackers(chess.BLACK, black_king_square))\n    result = white_defenders - black_defenders\n    return float(result)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of pieces that are pinned (unable to move without exposing the king) on each side.\"\n    def count_pinned_pieces(color):\n        pinned_count = 0\n        for square, piece in board.piece_map().items():\n            if piece.color == color:\n                for opponent_square in board.attackers(not color, square):\n                    if board.piece_at(opponent_square) and board.piece_at(opponent_square).piece_type == chess.QUEEN:\n                        pinned_count += 1\n                        break\n        return pinned_count\n\n    white_pinned = count_pinned_pieces(chess.WHITE)\n    black_pinned = count_pinned_pieces(chess.BLACK)\n    result = white_pinned - black_pinned\n    return float(result)", "def feature(board: chess.Board) -> float:\n    \"Calculates the disparity in the piece values of material that is currently on the board.\"\n    piece_value = {chess.PAWN: 100, chess.KNIGHT: 320, chess.BISHOP: 330, \n                   chess.ROOK: 500, chess.QUEEN: 900, chess.KING: 0}\n    \n    white_material = sum(piece_value[piece.piece_type] for piece in board.piece_map().values() if piece.color == chess.WHITE)\n    black_material = sum(piece_value[piece.piece_type] for piece in board.piece_map().values() if piece.color == chess.BLACK)\n    \n    return float(white_material - black_material)", "def feature(board: chess.Board) -> float:\n    \"Measures the king's distance from the center for both white and black kings.\"\n    white_king_square = next(square for square, piece in board.piece_map().items() \n                              if piece.color == chess.WHITE and piece.piece_type == chess.KING)\n    black_king_square = next(square for square, piece in board.piece_map().items() \n                              if piece.color == chess.BLACK and piece.piece_type == chess.KING)\n    \n    white_distance = abs(chess.square_file(white_king_square) - 3.5) + abs(chess.square_rank(white_king_square) - 3.5)\n    black_distance = abs(chess.square_file(black_king_square) - 3.5) + abs(chess.square_rank(black_king_square) - 3.5)\n    \n    result = white_distance - black_distance\n    return float(result)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of hanging pieces (pieces that can be captured without retaliation) for each side.\"\n    hanging_count = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == chess.WHITE:\n            if not board.is_attacked_by(chess.BLACK, square):\n                hanging_count += 1\n        else:\n            if not board.is_attacked_by(chess.WHITE, square):\n                hanging_count -= 1\n    return float(hanging_count)", "def feature(board: chess.Board) -> float:\n    \"Measures the total number of pawns on the board for both players.\"\n    pawn_count = sum(1 for piece in board.piece_map().values() if piece.piece_type == chess.PAWN)\n    return float(pawn_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the distance between the two kings on the board.\"\n    white_king_square = board.king(chess.WHITE)\n    black_king_square = board.king(chess.BLACK)\n    distance = chess.square_distance(white_king_square, black_king_square)\n    return float(distance)", "def feature(board: chess.Board) -> float:\n    \"Measures the control of the center squares by counting pieces on d4, d5, e4, and e5.\"\n    center_squares = [chess.D4, chess.D5, chess.E4, chess.E5]\n    control_count = sum(1 for square in center_squares if board.piece_at(square) is not None)\n    return float(control_count)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of defenders a piece has by counting pieces defending it.\"\n    total_defenders = 0\n    for square, piece in board.piece_map().items():\n        total_defenders += len(board.attackers(piece.color, square))\n    return float(total_defenders)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of legal moves available for each player.\"\n    move_count = len(list(board.legal_moves))\n    return float(move_count)", "def feature(board: chess.Board) -> float:\n    \"Counts the total number of pieces that are pinned.\"\n    pinned_count = sum(1 for square, piece in board.piece_map().items() if board.is_attacked_by(not piece.color, square) and board.is_check())\n    return float(pinned_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the imbalance of minor pieces on the board (knights and bishops).\"\n    minor_white = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE and piece.piece_type in [chess.KNIGHT, chess.BISHOP])\n    minor_black = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK and piece.piece_type in [chess.KNIGHT, chess.BISHOP])\n    imbalance = minor_white - minor_black\n    return float(imbalance)", "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in control of the center squares (d4, e4, d5, e5).\"\n    center_squares = [chess.parse_square('d4'), chess.parse_square('e4'), chess.parse_square('d5'), chess.parse_square('e5')]\n    white_control = sum(board.is_attacked_by(chess.WHITE, square) for square in center_squares)\n    black_control = sum(board.is_attacked_by(chess.BLACK, square) for square in center_squares)\n    result = float(white_control - black_control)\n    return result", "def feature(board: chess.Board) -> float:\n    \"Measures the number of pieces on the 7th rank for each player.\"\n    white_seventh_rank = sum(1 for square in range(chess.A7, chess.H7 + 1) if board.piece_at(square) and board.piece_at(square).color == chess.WHITE)\n    black_seventh_rank = sum(1 for square in range(chess.A2, chess.H2 + 1) if board.piece_at(square) and board.piece_at(square).color == chess.BLACK)\n    result = float(white_seventh_rank - black_seventh_rank)\n    return result", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of minor pieces (knights and bishops) for each player.\"\n    white_minor = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE and piece.piece_type in (chess.KNIGHT, chess.BISHOP))\n    black_minor = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK and piece.piece_type in (chess.KNIGHT, chess.BISHOP))\n    result = float(white_minor - black_minor)\n    return result", "def feature(board: chess.Board) -> float:\n    \"Computes the ratio of rooks on open files for both players.\"\n    open_file_count_white = sum(1 for file in range(8) if not any(board.piece_at(chess.square(file, rank)) is not None for rank in range(8)))\n    open_file_count_black = sum(1 for file in range(8) if not any(board.piece_at(chess.square(file, rank)) is not None for rank in range(0, 4)))\n    total_rooks_white = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE and piece.piece_type == chess.ROOK)\n    total_rooks_black = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK and piece.piece_type == chess.ROOK)\n    \n    result = (open_file_count_white / (total_rooks_white + 1)) - (open_file_count_black / (total_rooks_black + 1))\n    return result", "def feature(board: chess.Board) -> float:\n    \"Determines the mobility of each side by counting legal moves available.\"\n    white_moves = len(list(board.legal_moves)) if board.turn else 0\n    black_moves = len(list(board.legal_moves)) if not board.turn else 0\n    result = float(white_moves - black_moves)\n    return result", "def feature(board: chess.Board) -> float:\n    \"Measures the number of pieces that are attacked by enemy pieces.\"\n    white_attacked = sum(1 for square in board.piece_map() if board.is_attacked_by(chess.BLACK, square))\n    black_attacked = sum(1 for square in board.piece_map() if board.is_attacked_by(chess.WHITE, square))\n    result = float(white_attacked - black_attacked)\n    return result", "def feature(board: chess.Board) -> float:\n    \"Measures the number of pawns on the board for each player.\"\n    white_pawns = sum(1 for piece in board.piece_map().values() if piece.piece_type == chess.PAWN and piece.color == chess.WHITE)\n    black_pawns = sum(1 for piece in board.piece_map().values() if piece.piece_type == chess.PAWN and piece.color == chess.BLACK)\n    return float(white_pawns - black_pawns)", "def feature(board: chess.Board) -> float:\n    \"Calculates the total piece value on the board for each player.\"\n    piece_values = {chess.PAWN: 100, chess.KNIGHT: 320, chess.BISHOP: 330, chess.ROOK: 500, chess.QUEEN: 900, chess.KING: 20000}\n    white_value = sum(piece_values[piece.piece_type] for piece in board.piece_map().values() if piece.color == chess.WHITE)\n    black_value = sum(piece_values[piece.piece_type] for piece in board.piece_map().values() if piece.color == chess.BLACK)\n    return float(white_value - black_value)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces that are controlled by the opponent.\"\n    opponent_color = chess.WHITE if board.turn == chess.BLACK else chess.BLACK\n    control_count = sum(1 for square in board.piece_map() if board.is_attacked_by(opponent_color, square))\n    return float(control_count)", "def feature(board: chess.Board) -> float:\n    \"Measures the mobility of current player's pieces.\"\n    legal_moves_count = len(list(board.legal_moves))\n    return float(legal_moves_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the sum of distances of all pieces from their opponent's back rank.\"\n    total_distance = 0\n    for square, piece in board.piece_map().items():\n        rank_difference = chess.square_rank(square) if piece.color == chess.WHITE else 7 - chess.square_rank(square)\n        total_distance += rank_difference\n    return float(total_distance)", "def feature(board: chess.Board) -> float:\n    \"Checks if the current player is in check and penalizes the position accordingly.\"\n    return float(-1 if board.is_check() else 0)", "def feature(board: chess.Board) -> float:\n    \"Calculates the total number of pieces remaining on the board.\"\n    total_pieces = len(board.piece_map())\n    return float(total_pieces)", "def feature(board: chess.Board) -> float:\n    \"Counts how many ranks are occupied by pawns for each player.\"\n    white_pawn_ranks = {chess.square_rank(square) for square in board.piece_map() if \n                         board.piece_map()[square].piece_type == chess.PAWN and \n                         board.piece_map()[square].color == chess.WHITE}\n    black_pawn_ranks = {chess.square_rank(square) for square in board.piece_map() if \n                         board.piece_map()[square].piece_type == chess.PAWN and \n                         board.piece_map()[square].color == chess.BLACK}\n    return float(len(white_pawn_ranks) - len(black_pawn_ranks))", "def feature(board: chess.Board) -> float:\n    \"Checks the number of pieces on the back rank for both players.\"\n    white_back_rank_count = sum(1 for square in board.piece_map() if chess.square_rank(square) == 0 and \n                                 board.piece_map()[square].color == chess.WHITE)\n    black_back_rank_count = sum(1 for square in board.piece_map() if chess.square_rank(square) == 7 and \n                                 board.piece_map()[square].color == chess.BLACK)\n    return float(white_back_rank_count - black_back_rank_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of major pieces (rooks and queens) on the board for each player.\"\n    white_major_pieces = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE and piece.piece_type in {chess.ROOK, chess.QUEEN})\n    black_major_pieces = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK and piece.piece_type in {chess.ROOK, chess.QUEEN})\n    return float(white_major_pieces - black_major_pieces)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of pawn promotions possible for both players.\"\n    white_pawns = sum(1 for sq, piece in board.piece_map().items() if piece.piece_type == chess.PAWN and piece.color == chess.WHITE and chess.square_rank(sq) == 6)\n    black_pawns = sum(1 for sq, piece in board.piece_map().items() if piece.piece_type == chess.PAWN and piece.color == chess.BLACK and chess.square_rank(sq) == 1)\n    return float(white_pawns + black_pawns)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of pieces that can directly attack the opponent's king.\"\n    attackers_white = sum(1 for sq in board.attackers(chess.WHITE, board.king(chess.BLACK) if board.king(chess.BLACK) else chess.square(0, 0)))\n    attackers_black = sum(1 for sq in board.attackers(chess.BLACK, board.king(chess.WHITE) if board.king(chess.WHITE) else chess.square(0, 0)))\n    return float(attackers_white + attackers_black)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of isolated pawns for both players.\"\n    isolated_pawns = 0\n    for sq, piece in board.piece_map().items():\n        if piece.piece_type == chess.PAWN:\n            file = chess.square_file(sq)\n            if (file > 0 and board.piece_at(chess.square(sq // 8, file - 1)) is None) and (file < 7 and board.piece_at(chess.square(sq // 8, file + 1)) is None):\n                isolated_pawns += 1\n    return float(isolated_pawns)", "def feature(board: chess.Board) -> float:\n    \"Calculates the distance of all pieces from their respective back ranks.\"\n    distance_sum = 0\n    for sq, piece in board.piece_map().items():\n        if piece.color == chess.WHITE:\n            distance_sum += 7 - chess.square_rank(sq)\n        else:\n            distance_sum += chess.square_rank(sq)\n    return float(distance_sum)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of pieces on the same file as the enemy king.\"\n    king_square = board.king(chess.BLACK) if board.turn else board.king(chess.WHITE)\n    if king_square is None:\n        return 0.0\n    file = chess.square_file(king_square)\n    return float(sum(1 for sq, piece in board.piece_map().items() if chess.square_file(sq) == file))", "def feature(board: chess.Board) -> float:\n    \"Calculates the ratio of knight pieces to total pieces on the board.\"\n    total_pieces = sum(1 for piece in board.piece_map().values())\n    knight_count = sum(1 for piece in board.piece_map().values() if piece.piece_type == chess.KNIGHT)\n    return float(knight_count / total_pieces) if total_pieces > 0 else 0.0", "def feature(board: chess.Board) -> float:\n    \"Checks if a player has potential checkmating patterns by counting pieces near the opponent's king.\"\n    king_square = board.king(chess.BLACK) if board.turn else board.king(chess.WHITE)\n    if king_square is None:\n        return 0.0\n    vulnerable_squares = sum(1 for sq in chess.SQUARES if board.is_attacked_by(board.turn, sq) and chess.square_distance(sq, king_square) <= 2)\n    return float(vulnerable_squares)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces that have safe escape squares.\"\n    safe_pieces = sum(1 for sq, piece in board.piece_map().items() if piece.color == board.turn and any(board.piece_at(move.to_square) is None for move in board.legal_moves))\n    return float(safe_pieces)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of backward pawns for both players.\"\n    backward_pawns = 0\n    for sq, piece in board.piece_map().items():\n        if piece.piece_type == chess.PAWN and (\n            (piece.color == chess.WHITE and (board.piece_at(chess.square(sq // 8 + 1, chess.square_file(sq))) is None) and any(board.piece_at(chess.square(sq // 8, f)) is not None for f in range(max(0, chess.square_file(sq) - 1), min(7, chess.square_file(sq) + 2))))\n            or (piece.color == chess.BLACK and (board.piece_at(chess.square(sq // 8 - 1, chess.square_file(sq))) is None) and any(board.piece_at(chess.square(sq // 8, f)) is not None for f in range(max(0, chess.square_file(sq) - 1), min(7, chess.square_file(sq) + 2))))):\n                backward_pawns += 1\n    return float(backward_pawns)", "def feature(board: chess.Board) -> float:\n    \"Analyzes the number of squares controlled by each player using their pieces.\"\n    controlled_squares_white = len(set(move.to_square for move in board.legal_moves if move.from_square in board.piece_map() and board.piece_map()[move.from_square].color == chess.WHITE))\n    controlled_squares_black = len(set(move.to_square for move in board.legal_moves if move.from_square in board.piece_map() and board.piece_map()[move.from_square].color == chess.BLACK))\n    return float(controlled_squares_white - controlled_squares_black)", "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in the number of pawns for each player.\"\n    white_pawns = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE and piece.piece_type == chess.PAWN)\n    black_pawns = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK and piece.piece_type == chess.PAWN)\n    return float(white_pawns - black_pawns)", "def feature(board: chess.Board) -> float:\n    \"Measures the total number of squares attacked by each side.\"\n    white_attacks = sum(1 for square in chess.SQUARES if board.is_attacked_by(chess.WHITE, square))\n    black_attacks = sum(1 for square in chess.SQUARES if board.is_attacked_by(chess.BLACK, square))\n    return float(white_attacks - black_attacks)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces controlling the center squares (d4, d5, e4, e5).\"\n    center_squares = [chess.D4, chess.D5, chess.E4, chess.E5]\n    control_count = sum(1 for square in center_squares if board.is_attacked_by(chess.WHITE, square)) - sum(1 for square in center_squares if board.is_attacked_by(chess.BLACK, square))\n    return float(control_count)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces with mobility (not blocked by other pieces).\"\n    mobility_count = sum(1 for piece in board.piece_map().values() if board.legal_moves.count() > 0)\n    return float(mobility_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the total distance of all pieces from the opponent's back rank.\"\n    total_distance = sum(8 - chess.square_rank(square) for square in board.piece_map() if board.piece_map()[square].color == chess.WHITE)\n    return float(total_distance)", "def feature(board: chess.Board) -> float:\n    \"Evaluates the number of pieces that can give check in the next turn.\"\n    check_possible = sum(1 for move in board.legal_moves if board.gives_check(move))\n    return float(check_possible)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of major pieces (rooks and queens) for each player.\"\n    white_major = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE and piece.piece_type in [chess.ROOK, chess.QUEEN])\n    black_major = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK and piece.piece_type in [chess.ROOK, chess.QUEEN])\n    return float(white_major - black_major)", "def feature(board: chess.Board) -> float:\n    \"Calculates the difference between the number of pieces captured by each player, indicating material imbalance.\"\n    white_captured = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK)\n    black_captured = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE)\n    return float(white_captured - black_captured)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of pieces currently in jeopardy, which can indicate potential future threats.\"\n    jeopardy_count = sum(1 for square, piece in board.piece_map().items() if board.is_attacked_by(not piece.color, square))\n    return float(jeopardy_count)", "def feature(board: chess.Board) -> float:\n    \"Measures the mobility of the player to move by counting the number of legal moves available.\"\n    return float(len(list(board.legal_moves)))", "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in material value between the two players.\"\n    material_values = {chess.PAWN: 100, chess.KNIGHT: 320, chess.BISHOP: 330, chess.ROOK: 500, chess.QUEEN: 900, chess.KING: 20000}\n    white_value = sum(material_values[piece.piece_type] for piece in board.piece_map().values() if piece.color == chess.WHITE)\n    black_value = sum(material_values[piece.piece_type] for piece in board.piece_map().values() if piece.color == chess.BLACK)\n    return float(white_value - black_value)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of squares controlling the center (d4, d5, e4, e5) for both players.\"\n    center_squares = [chess.parse_square('d4'), chess.parse_square('d5'), chess.parse_square('e4'), chess.parse_square('e5')]\n    white_control = sum(1 for square in center_squares if board.is_attacked_by(chess.WHITE, square))\n    black_control = sum(1 for square in center_squares if board.is_attacked_by(chess.BLACK, square))\n    return float(white_control - black_control)", "def feature(board: chess.Board) -> float:\n    \"Evaluates potential mobility by counting pieces that have more than one legal move.\"\n    mobile_piece_count = sum(1 for piece in board.piece_map().values() if len(list(board.legal_moves)) > 1)\n    return float(mobile_piece_count)", "def feature(board: chess.Board) -> float:\n    \"Measures the distance of the king from the center, as middle-control is often crucial.\"\n    king_square = next((square for square, piece in board.piece_map().items() if piece.piece_type == chess.KING), None)\n    if king_square is None:\n        return 0.0\n    center_distance = chess.square_distance(king_square, chess.parse_square('e4')) + chess.square_distance(king_square, chess.parse_square('d4'))\n    return float(center_distance)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of pawns on the 4th and 5th ranks as an indicator of pawn structure.\"\n    pawn_count = sum(1 for square, piece in board.piece_map().items() if piece.piece_type == chess.PAWN and chess.square_rank(square) >= 3)\n    return float(pawn_count)", "def feature(board: chess.Board) -> float:\n    \"Evaluates the proportion of pieces developed versus total pieces, emphasizing development.\"\n    total_pieces = sum(1 for piece in board.piece_map().values())\n    developed_pieces = sum(1 for square in range(0, 64) if board.piece_at(square) is not None and chess.square_rank(square) >= 1)  # pawns in row 2 or 7, others in row 1 or 8\n    return float(developed_pieces / total_pieces) if total_pieces > 0 else 0.0", "def feature(board: chess.Board) -> float:\n    \"Measures the number of pieces that are threatened but not defended, indicating potential tactics.\"\n    threats_count = sum(1 for square, piece in board.piece_map().items() if board.is_attacked_by(not piece.color, square) and len(board.attackers(piece.color, square)) == 0)\n    return float(threats_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the average distance of pieces from the opponent's back rank.\"\n    color = board.turn\n    total_distance = 0\n    count = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == color:\n            distance = 7 - chess.square_rank(square) if color == chess.WHITE else chess.square_rank(square)\n            total_distance += distance\n            count += 1\n    return total_distance / count if count > 0 else 0.0", "def feature(board: chess.Board) -> float:\n    \"Measures the number of pieces on the board that can execute a check on the opponent's king.\"\n    color = board.turn\n    check_possible = sum(1 for move in board.legal_moves if board.is_check())\n    return float(check_possible)", "def feature(board: chess.Board) -> float:\n    \"Counts the difference in the number of pawn structures between the two sides.\"\n    white_pawn_structure = sum(1 for square in board.piece_map() if board.piece_at(square).color == chess.WHITE and board.piece_at(square).piece_type == chess.PAWN)\n    black_pawn_structure = sum(1 for square in board.piece_map() if board.piece_at(square).color == chess.BLACK and board.piece_at(square).piece_type == chess.PAWN)\n    return float(white_pawn_structure - black_pawn_structure)", "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in control over the center squares.\"\n    center_squares = [chess.D4, chess.D5, chess.E4, chess.E5]\n    control = 0\n    for square in center_squares:\n        if board.is_attacked_by(chess.WHITE, square):\n            control += 1\n        if board.is_attacked_by(chess.BLACK, square):\n            control -= 1\n    return float(control)", "def feature(board: chess.Board) -> float:\n    \"Measures the total potential value of pieces that can move in the next turn.\"\n    potential_value = 0\n    for move in board.legal_moves:\n        piece = board.piece_at(move.from_square)\n        if piece:\n            potential_value += piece.piece_type\n    return float(potential_value)", "def feature(board: chess.Board) -> float:\n    \"Calculates the total number of pins affecting pieces for both sides.\"\n    pinned_count = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == board.turn:\n            attackers = board.attackers(not piece.color, square)\n            if attackers:\n                for attacker in attackers:\n                    if board.is_attacked_by(piece.color, attacker):\n                        pinned_count += 1\n    return float(pinned_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the imbalance in material based on piece types.\"\n    piece_values = {\n        chess.PAWN: 100,\n        chess.KNIGHT: 320,\n        chess.BISHOP: 330,\n        chess.ROOK: 500,\n        chess.QUEEN: 900,\n        chess.KING: float('inf'),  # King shouldn't be counted\n    }\n    material_balance = 0\n    for piece in board.piece_map().values():\n        material_balance += piece_values[piece.piece_type] if piece.color == chess.WHITE else -piece_values[piece.piece_type]\n    return float(material_balance)", "def feature(board: chess.Board) -> float:\n    \"Counts total doubled pawns for both players.\"\n    doubled_pawns = 0\n    pawn_counts = [0] * 8  # 8 files for pawns\n    for square in board.piece_map():\n        piece = board.piece_at(square)\n        if piece.piece_type == chess.PAWN:\n            pawn_counts[chess.square_file(square)] += 1\n    for count in pawn_counts:\n        if count > 1:\n            doubled_pawns += (count - 1)  # Only count excess\n    return float(doubled_pawns)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of pieces attacking the opponent's King.\"\n    king_square = next((sq for sq in board.piece_map() if board.piece_at(sq).piece_type == chess.KING and board.piece_at(sq).color != board.turn), None)\n    if king_square is None:\n        return 0.0\n    attackers_count = len(board.attackers(board.turn, king_square))\n    return float(attackers_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in the number of pawns for both players.\"\n    white_pawns = sum(1 for sq in board.piece_map() if board.piece_at(sq).piece_type == chess.PAWN and board.piece_at(sq).color == chess.WHITE)\n    black_pawns = sum(1 for sq in board.piece_map() if board.piece_at(sq).piece_type == chess.PAWN and board.piece_at(sq).color == chess.BLACK)\n    return float(white_pawns - black_pawns)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces in 'development' (pieces on ranks 2-3 for White, 6-7 for Black).\"\n    development_count = sum(1 for sq in board.piece_map() if (\n        (board.piece_at(sq).color == chess.WHITE and chess.square_rank(sq) < 3) or\n        (board.piece_at(sq).color == chess.BLACK and chess.square_rank(sq) > 4)\n    ))\n    return float(development_count)", "def feature(board: chess.Board) -> float:\n    \"Computes the ratio of advanced pawns (pawns on ranks 4-5 for White, 5-6 for Black).\"\n    advanced_white = sum(1 for sq in board.piece_map() if board.piece_at(sq).piece_type == chess.PAWN and board.piece_at(sq).color == chess.WHITE and chess.square_rank(sq) >= 4)\n    advanced_black = sum(1 for sq in board.piece_map() if board.piece_at(sq).piece_type == chess.PAWN and board.piece_at(sq).color == chess.BLACK and chess.square_rank(sq) <= 3)\n    return float(advanced_white / (advanced_black + 1))  # Avoid division by zero", "def feature(board: chess.Board) -> float:\n    \"Measures how many squares each side has control over.\"\n    control_squares_white = {move.to_square for move in board.legal_moves if board.turn == chess.WHITE}\n    control_squares_black = {move.to_square for move in board.legal_moves if board.turn == chess.BLACK}\n    return float(len(control_squares_white) - len(control_squares_black))", "def feature(board: chess.Board) -> float:\n    \"Calculates the total number of pieces each player has and returns the difference.\"\n    white_count = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE)\n    black_count = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK)\n    return float(white_count - black_count)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces that are pinned.\"\n    pinned_count = 0\n    for square in board.piece_map():\n        piece = board.piece_at(square)\n        if piece.color == board.turn:\n            if any(board.is_attacked_by(piece.color, sq) for sq in board.attackers(not piece.color, square)):\n                pinned_count += 1\n    return float(pinned_count)", "def feature(board: chess.Board) -> float:\n    \"Measures the material value difference between both players.\"\n    piece_values = {chess.PAWN: 100, chess.KNIGHT: 320, chess.BISHOP: 330, chess.ROOK: 500, chess.QUEEN: 900}\n    material_white = sum(piece_values.get(board.piece_at(sq).piece_type, 0) for sq in board.piece_map() if board.piece_at(sq).color == chess.WHITE)\n    material_black = sum(piece_values.get(board.piece_at(sq).piece_type, 0) for sq in board.piece_map() if board.piece_at(sq).color == chess.BLACK)\n    return float(material_white - material_black)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of squares that are available for movement for the current player's pieces.\"\n    legal_moves_count = len(list(board.legal_moves))\n    return float(legal_moves_count)", "def feature(board: chess.Board) -> float:\n    \"Checks if the King of the current player is in a position to escape check.\"\n    king_square = next((sq for sq in board.piece_map() if board.piece_at(sq).piece_type == chess.KING and board.piece_at(sq).color == board.turn), None)\n    escape_moves = sum(1 for move in board.legal_moves if move.to_square in board.attackers(board.turn, king_square))\n    return float(escape_moves)", "def feature(board: chess.Board) -> float:\n    \"Measures the distance of each king to the center of the board.\"\n    white_king_square = board.king(chess.WHITE)\n    black_king_square = board.king(chess.BLACK)\n    center_x = (chess.square_file(white_king_square) + chess.square_file(black_king_square)) / 2\n    center_y = (chess.square_rank(white_king_square) + chess.square_rank(black_king_square)) / 2\n    distance_from_center = (chess.square_distance(white_king_square, chess.parse_square('e4')) +\n                            chess.square_distance(black_king_square, chess.parse_square('e4'))) / 2\n    return float(distance_from_center)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces attacking the opponent's king.\"\n    opponent_king_square = board.king(not board.turn)\n    attackers_count = len(board.attackers(board.turn, opponent_king_square))\n    return float(attackers_count)", "def feature(board: chess.Board) -> float:\n    \"Measures the average value of pieces on the board for the current player.\"\n    piece_values = {chess.PAWN: 100, chess.KNIGHT: 320, chess.BISHOP: 330, \n                    chess.ROOK: 500, chess.QUEEN: 900, chess.KING: 20000}\n    total_value = sum(piece_values[piece.piece_type] for piece in board.piece_map().values() \n                      if piece.color == board.turn)\n    average_value = total_value / (len(board.piece_map()) // 2) if board.piece_map() else 0\n    return float(average_value)", "def feature(board: chess.Board) -> float:\n    \"Calculates the mobility score based on the difference in legal moves between players.\"\n    white_moves = len(list(board.legal_moves)) if board.turn else 0\n    black_moves = len(list(board.legal_moves)) if not board.turn else 0\n    mobility_score = white_moves - black_moves\n    return float(mobility_score)", "def feature(board: chess.Board) -> float:\n    \"Measures the symmetry of the board's piece arrangement.\"\n    piece_map = board.piece_map()\n    symmetrical_count = 0\n    for square in piece_map.keys():\n        opposite_square = chess.square(7 - chess.square_file(square), 7 - chess.square_rank(square))\n        if (opposite_square in piece_map and piece_map[square].piece_type == piece_map[opposite_square].piece_type and \n            piece_map[square].color != piece_map[opposite_square].color):\n            symmetrical_count += 1\n    return float(symmetrical_count)", "def feature(board: chess.Board) -> float:\n    \"Scores the controlled squares by each side, where controlled means attacked.\"\n    white_controlled = len([sq for sq in chess.SQUARES if board.is_attacked_by(chess.WHITE, sq)])\n    black_controlled = len([sq for sq in chess.SQUARES if board.is_attacked_by(chess.BLACK, sq)])\n    control_score = white_controlled - black_controlled\n    return float(control_score)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of double attacks available for each color.\"\n    double_attacks = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == board.turn:\n            for target in board.legal_moves:\n                if target.to_square == square and \\\n                len(board.attackers(not board.turn, target.from_square)) > 1:\n                    double_attacks += 1\n    return float(double_attacks)", "def feature(board: chess.Board) -> float:\n    \"Measures the material imbalance score for pieces captured by each side.\"\n    material_balance = sum(1 for piece in board.piece_map().values() \n                          if piece.color == chess.WHITE) - \\\n                      sum(1 for piece in board.piece_map().values() \n                          if piece.color == chess.BLACK)\n    return float(material_balance)", "def feature(board: chess.Board) -> float:\n    \"Measures the difference in mobility between both players.\"\n    white_moves = len(list(board.legal_moves)) if board.turn else 0\n    black_moves = len(list(board.legal_moves)) if not board.turn else 0\n    return float(white_moves - black_moves)", "def feature(board: chess.Board) -> float:\n    \"Counts the total piece value difference between the players.\"\n    piece_values = {chess.PAWN: 100, chess.KNIGHT: 300, chess.BISHOP: 300, \n                    chess.ROOK: 500, chess.QUEEN: 900, chess.KING: 0}\n    total_value_white = sum(piece_values[piece.piece_type] for piece in board.piece_map().values() if piece.color == chess.WHITE)\n    total_value_black = sum(piece_values[piece.piece_type] for piece in board.piece_map().values() if piece.color == chess.BLACK)\n    return float(total_value_white - total_value_black)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of attackers on each king.\"\n    white_king_square = next(square for square, piece in board.piece_map().items() if piece.color == chess.WHITE and piece.piece_type == chess.KING)\n    black_king_square = next(square for square, piece in board.piece_map().items() if piece.color == chess.BLACK and piece.piece_type == chess.KING)\n    white_attackers = len(board.attackers(chess.BLACK, white_king_square))\n    black_attackers = len(board.attackers(chess.WHITE, black_king_square))\n    return float(black_attackers - white_attackers)", "def feature(board: chess.Board) -> float:\n    \"Measures the distance between the kings in the current position.\"\n    white_king_square = next(square for square, piece in board.piece_map().items() if piece.color == chess.WHITE and piece.piece_type == chess.KING)\n    black_king_square = next(square for square, piece in board.piece_map().items() if piece.color == chess.BLACK and piece.piece_type == chess.KING)\n    return float(chess.square_distance(white_king_square, black_king_square))", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pawns for each player.\"\n    white_pawns = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE and piece.piece_type == chess.PAWN)\n    black_pawns = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK and piece.piece_type == chess.PAWN)\n    return float(white_pawns - black_pawns)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of pieces attacking each player's king.\"\n    white_king_square = next(square for square, piece in board.piece_map().items() if piece.color == chess.WHITE and piece.piece_type == chess.KING)\n    black_king_square = next(square for square, piece in board.piece_map().items() if piece.color == chess.BLACK and piece.piece_type == chess.KING)\n    attacking_pieces_white = len(board.attackers(chess.BLACK, white_king_square))\n    attacking_pieces_black = len(board.attackers(chess.WHITE, black_king_square))\n    return float(attacking_pieces_white - attacking_pieces_black)", "def feature(board: chess.Board) -> float:\n    \"Measures how many pieces are pinned (not able to move without exposing the king) on the board.\"\n    pinned_count = sum(1 for square, piece in board.piece_map().items() if piece.color == board.turn and board.is_attacked_by(not board.turn, square))\n    return float(pinned_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of back rank pieces (pieces on the first rank) for each player.\"\n    white_back_rank = sum(1 for square, piece in board.piece_map().items() if piece.color == chess.WHITE and chess.square_rank(square) == 0)\n    black_back_rank = sum(1 for square, piece in board.piece_map().items() if piece.color == chess.BLACK and chess.square_rank(square) == 7)\n    return float(white_back_rank - black_back_rank)", "def feature(board: chess.Board) -> float:\n    \"Measures the total number of pawns on the board for both players.\"\n    pawns_count = sum(1 for piece in board.piece_map().values() if piece.piece_type == chess.PAWN)\n    return float(pawns_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the material imbalance by subtracting the sum of black pieces' values from the sum of white pieces' values.\"\n    material_value = {\n        chess.PAWN: 100, chess.KNIGHT: 320, chess.BISHOP: 330, \n        chess.ROOK: 500, chess.QUEEN: 900, chess.KING: 0\n    }\n    white_material = sum(material_value[piece.piece_type] for piece in board.piece_map().values() if piece.color == chess.WHITE)\n    black_material = sum(material_value[piece.piece_type] for piece in board.piece_map().values() if piece.color == chess.BLACK)\n    return float(white_material - black_material)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of squares attacked by each player's pieces.\"\n    white_attacks = sum(board.is_attacked_by(chess.WHITE, sq) for sq in chess.SQUARES)\n    black_attacks = sum(board.is_attacked_by(chess.BLACK, sq) for sq in chess.SQUARES)\n    return float(white_attacks - black_attacks)", "def feature(board: chess.Board) -> float:\n    \"Evaluates king safety based on the number of direct attackers to the king.\"\n    king_square = board.king(chess.WHITE) if board.turn else board.king(chess.BLACK)\n    return float(len(board.attackers(chess.WHITE, king_square)) if board.turn else len(board.attackers(chess.BLACK, king_square)))", "def feature(board: chess.Board) -> float:\n    \"Measures the number of advanced pawns on each side.\"\n    advanced_white_pawns = sum(1 for sq in range(8) if board.piece_at(chess.A7 + sq) == chess.PAWN)\n    advanced_black_pawns = sum(1 for sq in range(8) if board.piece_at(chess.A2 + sq) == chess.PAWN)\n    return float(advanced_white_pawns - advanced_black_pawns)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces that are pinned to the king.\"\n    pinned_pieces_count = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == (chess.WHITE if board.turn else chess.BLACK):\n            if board.is_attacked_by(chess.BLACK if piece.color == chess.WHITE else chess.WHITE, square):\n                pinned_pieces_count += 1\n    return float(pinned_pieces_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the mobility of the player to move by counting their legal moves.\"\n    legal_moves_count = len(list(board.legal_moves))\n    return float(legal_moves_count)", "def feature(board: chess.Board) -> float:\n    \"Measures the presence of any major pieces (ROOK, QUEEN) still active on the board.\"\n    major_pieces = [chess.ROOK, chess.QUEEN]\n    active_major_pieces = sum(1 for piece in board.piece_map().values() if piece.piece_type in major_pieces)\n    return float(active_major_pieces)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces that are currently unprotected (not defended by any friendly pieces).\"\n    unprotected_count = sum(1 for square, piece in board.piece_map().items() if piece.color == (chess.WHITE if board.turn else chess.BLACK) and not board.attackers(piece.color, square))\n    return float(unprotected_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in number of squares controlled by each player.\"\n    white_control = sum(board.is_attacked_by(chess.WHITE, sq) for sq in chess.SQUARES)\n    black_control = sum(board.is_attacked_by(chess.BLACK, sq) for sq in chess.SQUARES)\n    return float(white_control - black_control)", "def feature(board: chess.Board) -> float:\n    \"Measures the ratio of active pieces (pieces that can move) to total pieces on the board.\"\n    total_pieces = sum(1 for piece in board.piece_map().values() if piece.color == board.turn)\n    active_pieces = sum(1 for move in board.legal_moves)\n    return active_pieces / total_pieces if total_pieces > 0 else 0.0", "def feature(board: chess.Board) -> float:\n    \"Calculates the value of the least valued piece still on the board for the current player.\"\n    piece_values = {chess.PAWN: 100, chess.KNIGHT: 320, chess.BISHOP: 330, chess.ROOK: 500, chess.QUEEN: 900}\n    least_value = float('inf')\n    for piece in board.piece_map().values():\n        if piece.color == board.turn and piece.piece_type in piece_values:\n            least_value = min(least_value, piece_values[piece.piece_type])\n    return least_value if least_value < float('inf') else 0.0", "def feature(board: chess.Board) -> float:\n    \"Evaluates the king distance from the center of the board (central squares).\"\n    central_squares = [chess.E4, chess.E5, chess.D4, chess.D5]\n    white_king = board.king(chess.WHITE)\n    black_king = board.king(chess.BLACK)\n    white_distance = min(chess.square_distance(white_king, sq) for sq in central_squares)\n    black_distance = min(chess.square_distance(black_king, sq) for sq in central_squares)\n    return float(black_distance - white_distance)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces pinned against the king.\"\n    pinned_count = sum(1 for square in board.piece_map() if (board.piece_map()[square].color == board.turn and board.is_attacked_by(not board.turn, square)))\n    return float(pinned_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the cumulative piece value of unprotected pieces for the current player.\"\n    piece_values = {chess.PAWN: 100, chess.KNIGHT: 320, chess.BISHOP: 330, chess.ROOK: 500, chess.QUEEN: 900}\n    unprotected_value = 0.0\n    for square, piece in board.piece_map().items():\n        if piece.color == board.turn and not any(board.is_attacked_by(not board.turn, sq) for sq in board.attackers(not board.turn, square)):\n            unprotected_value += piece_values.get(piece.piece_type, 0)\n    return unprotected_value", "def feature(board: chess.Board) -> float:\n    \"Measures the distribution of pawns across ranks for the current player.\"\n    pawn_count_per_rank = [0] * 8\n    for square, piece in board.piece_map().items():\n        if piece.color == board.turn and piece.piece_type == chess.PAWN:\n            pawn_count_per_rank[chess.square_rank(square)] += 1\n    return float(sum(count * (rank + 1) for rank, count in enumerate(pawn_count_per_rank)))", "def feature(board: chess.Board) -> float:\n    \"Calculates the average distance of pieces from the center of the board for the current player.\"\n    total_distance = 0\n    piece_count = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == board.turn:\n            total_distance += (chess.square_file(square) + chess.square_rank(square))\n            piece_count += 1\n    return total_distance / piece_count if piece_count > 0 else 0.0", "def feature(board: chess.Board) -> float:\n    \"Calculates the ratio of pieces on the board to the number of legal moves.\"\n    piece_count = len(board.piece_map())\n    legal_moves_count = len(list(board.legal_moves))\n    return piece_count / (legal_moves_count + 1)  # Avoid division by zero", "def feature(board: chess.Board) -> float:\n    \"Measures the distance of the closest opponent's piece to the king.\"\n    king_square = board.king(board.turn)\n    opponent_pieces = [sq for sq, piece in board.piece_map().items() if piece.color != board.turn]\n    if not opponent_pieces:\n        return float('inf')\n    return min(chess.square_distance(king_square, sq) for sq in opponent_pieces)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces pinned to their own king.\"\n    pinned_piece_count = 0\n    for sq, piece in board.piece_map().items():\n        if piece.color == board.turn and piece.piece_type != chess.KING:\n            for opponent_sq in board.attackers(not board.turn, sq):\n                if board.piece_at(opponent_sq).piece_type == chess.QUEEN or \\\n                   board.piece_at(opponent_sq).piece_type == chess.ROOK:\n                    pinned_piece_count += 1\n                    break\n    return float(pinned_piece_count)", "def feature(board: chess.Board) -> float:\n    \"Evaluates the central control by counting pieces in the central squares.\"\n    central_squares = [chess.E4, chess.E5, chess.D4, chess.D5]\n    control_count = sum(1 for sq in central_squares if board.piece_at(sq) and board.piece_at(sq).color == board.turn)\n    return float(control_count)", "def feature(board: chess.Board) -> float:\n    \"Measures the coordination of major pieces (rooks and queens) within three ranks of each other.\"\n    pieces = [sq for sq in board.piece_map() if board.piece_map()[sq].piece_type in (chess.ROOK, chess.QUEEN)]\n    ranks = [chess.square_rank(sq) for sq in pieces]\n    return float(len(set(ranks)))", "def feature(board: chess.Board) -> float:\n    \"Counts the number of squares that are currently attacked by the current player's pieces.\"\n    attack_count = 0\n    for sq, piece in board.piece_map().items():\n        if piece.color == board.turn:\n            attack_count += len(board.attackers(not board.turn, sq))\n    return float(attack_count)", "def feature(board: chess.Board) -> float:\n    \"Measures the vulnerability of the current player's back rank by checking for attacks.\"\n    back_rank = 7 if board.turn == chess.WHITE else 0\n    vulnerable = 0\n    for file in range(8):\n        square = chess.square(file, back_rank)\n        if board.is_attacked_by(not board.turn, square):\n            vulnerable += 1\n    return float(vulnerable)", "def feature(board: chess.Board) -> float:\n    \"Calculates the material strength of the pieces on the board.\"\n    material_values = {\n        chess.PAWN: 100,\n        chess.KNIGHT: 320,\n        chess.BISHOP: 330,\n        chess.ROOK: 500,\n        chess.QUEEN: 900,\n        chess.KING: 0\n    }\n    material_value = sum(material_values[piece.piece_type] for piece in board.piece_map().values())\n    return float(material_value) * (1 if board.turn == chess.WHITE else -1)", "def feature(board: chess.Board) -> float:\n    \"Assesses the safety of the current player's king by counting attacks on surrounding squares.\"\n    king_square = board.king(board.turn)\n    unsafe_squares = sum(1 for sq in chess.SQUARES if board.is_attacked_by(not board.turn, sq))\n    return float(unsafe_squares)", "def feature(board: chess.Board) -> float:\n    \"Measures the difference in the number of major pieces (rooks and queens) for both players.\"\n    white_major = sum(1 for piece in board.piece_map().values() \n                      if piece.color == chess.WHITE and piece.piece_type in [chess.ROOK, chess.QUEEN])\n    black_major = sum(1 for piece in board.piece_map().values() \n                      if piece.color == chess.BLACK and piece.piece_type in [chess.ROOK, chess.QUEEN])\n    return float(white_major - black_major)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of enemy pieces threatened by pieces of the current player.\"\n    attackers = sum(1 for square in board.piece_map() \n                    if board.is_attacked_by(board.turn, square))\n    return float(attackers)", "def feature(board: chess.Board) -> float:\n    \"Calculates the total number of pieces on the board for the side to move.\"\n    piece_count = sum(1 for piece in board.piece_map().values() \n                      if piece.color == board.turn)\n    return float(piece_count)", "def feature(board: chess.Board) -> float:\n    \"Measures the sum of distances of all pieces of the current player to the opponent's king.\"\n    opponent_king_square = next((sq for sq, piece in board.piece_map().items() \n                                   if piece.color != board.turn and piece.piece_type == chess.KING), None)\n    total_distance = sum(chess.square_distance(square, opponent_king_square) for square in board.piece_map()\n                         if board.piece_map()[square].color == board.turn)\n    return float(total_distance)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces of the opponent that are placed on the back rank.\"\n    opponent_back_rank = [chess.A8, chess.B8, chess.C8, chess.D8, chess.E8, chess.F8, chess.G8, chess.H8] \\\n                         if board.turn == chess.WHITE else \\\n                         [chess.A1, chess.B1, chess.C1, chess.D1, chess.E1, chess.F1, chess.G1, chess.H1]\n    back_rank_count = sum(1 for square in opponent_back_rank \n                          if board.piece_at(square) is not None)\n    return float(back_rank_count)", "def feature(board: chess.Board) -> float:\n    \"Measures the difference in mobility scores based on the number of legal moves for both sides.\"\n    white_legal_moves = len(list(board.legal_moves))\n    board.turn = not board.turn\n    black_legal_moves = len(list(board.legal_moves))\n    board.turn = not board.turn\n    return float(white_legal_moves - black_legal_moves)", "def feature(board: chess.Board) -> float:\n    \"Calculates the total number of safe squares for the current player.\"\n    safe_square_count = sum(1 for square in chess.SQUARES \n                             if board.is_attacked_by(not board.turn, square) == False and \n                             board.piece_at(square) is None)\n    return float(safe_square_count)", "def feature(board: chess.Board) -> float:\n    \"Measures the total number of pieces in the center squares (d4, d5, e4, e5).\"\n    center_squares = [chess.D4, chess.D5, chess.E4, chess.E5]\n    center_piece_count = sum(1 for square in center_squares \n                              if board.piece_at(square) is not None)\n    return float(center_piece_count)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces that are pinned against the king.\"\n    pinned_pieces = sum(1 for square in board.piece_map() \n                        if board.is_attacked_by(not board.turn, square) and \n                        (board.piece_at(square).piece_type == chess.ROOK or \n                         board.piece_at(square).piece_type == chess.QUEEN) and \n                        (square in board.attackers(not board.turn, square)))\n    return float(pinned_pieces)", "def feature(board: chess.Board) -> float:\n    \"Measures the current player's control of open files with rooks.\"\n    open_files = sum(1 for file in range(8) \n                     if all(board.piece_at(chess.square(file, rank)) is None for rank in range(8)))\n    return float(open_files)", "def feature(board: chess.Board) -> float:\n    \"Calculates the material imbalance favoring the side to move.\"\n    material_value = 0\n    for square, piece in board.piece_map().items():\n        value = 0\n        if piece.piece_type == chess.PAWN:\n            value = 100\n        elif piece.piece_type == chess.KNIGHT:\n            value = 320\n        elif piece.piece_type == chess.BISHOP:\n            value = 330\n        elif piece.piece_type == chess.ROOK:\n            value = 500\n        elif piece.piece_type == chess.QUEEN:\n            value = 900\n        elif piece.piece_type == chess.KING:\n            value = 20000\n        material_value += value if piece.color == board.turn else -value\n    return float(material_value)", "def feature(board: chess.Board) -> float:\n    \"Measures the king's safety based on squares it can escape to.\"\n    king_square = next((square for square, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color == board.turn), None)\n    escape_squares = 0\n    if king_square is not None:\n        for move in board.legal_moves:\n            if move.from_square == king_square:\n                escape_squares += 1\n    return float(escape_squares)", "def feature(board: chess.Board) -> float:\n    \"Evaluates the control of central squares by counting occupied central squares.\"\n    central_squares = [chess.E4, chess.E5, chess.D4, chess.D5]\n    control_count = sum(1 for square in central_squares if board.piece_at(square) is not None)\n    return float(control_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the distance of the closest enemy piece to the player's king.\"\n    king_square = next((square for square, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color == board.turn), None)\n    if king_square is None:\n        return float('inf')\n    distances = []\n    for square, piece in board.piece_map().items():\n        if piece.color != board.turn:\n            distances.append(chess.square_distance(king_square, square))\n    return float(min(distances)) if distances else float('inf')", "def feature(board: chess.Board) -> float:\n    \"Measures the rook connection by counting pairs of rooks on the same file or rank.\"\n    rooks = [square for square, piece in board.piece_map().items() if piece.piece_type == chess.ROOK]\n    rook_connections = sum(1 for i in range(len(rooks)) for j in range(i + 1, len(rooks)) \n                             if chess.square_file(rooks[i]) == chess.square_file(rooks[j]) or \n                             chess.square_rank(rooks[i]) == chess.square_rank(rooks[j]))\n    return float(rook_connections)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces with threatening positions.\"\n    threats = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == board.turn:\n            for target in board.attackers(not board.turn, square):\n                if board.piece_at(target) is not None:\n                    threats += 1\n    return float(threats)", "def feature(board: chess.Board) -> float:\n    \"Calculates the mobility difference based on the number of legal moves between players.\"\n    white_moves = len(list(board.legal_moves)) if board.turn == chess.WHITE else 0\n    black_moves = len(list(board.legal_moves)) if board.turn == chess.BLACK else 0\n    return float(white_moves - black_moves)", "def feature(board: chess.Board) -> float:\n    \"Measures the pawn structure by counting doubled pawns.\"\n    doubled_pawns = 0\n    files = {}\n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.PAWN:\n            file = chess.square_file(square)\n            if file not in files:\n                files[file] = 0\n            files[file] += 1\n    doubled_pawns = sum(1 for count in files.values() if count > 1)\n    return float(doubled_pawns)", "def feature(board: chess.Board) -> float:\n    \"Measures the amount of material on the board, counting total piece values.\"\n    piece_values = {chess.PAWN: 100, chess.KNIGHT: 300, chess.BISHOP: 300, chess.ROOK: 500, chess.QUEEN: 900, chess.KING: 0}\n    total_value = sum(piece_values[piece.piece_type] for piece in board.piece_map().values())\n    return total_value", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces that are pinned by opponent pieces.\"\n    pinned_count = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == board.turn:\n            for attacker in board.attackers(not board.turn, square):\n                if board.piece_at(attacker).piece_type in {chess.ROOK, chess.QUEEN}:\n                    pinned_count += 1\n                    break\n    return float(pinned_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of doubled pawns for the current player.\"\n    pawns = [s for s in board.piece_map() if board.piece_map()[s].piece_type == chess.PAWN and board.piece_map()[s].color == board.turn]\n    files = [chess.square_file(sq) for sq in pawns]\n    doubled_count = sum(files.count(f) > 1 for f in set(files))\n    return float(doubled_count)", "def feature(board: chess.Board) -> float:\n    \"Determines the number of outposts for the current player.\"\n    outpost_count = 0\n    for square in range(64):\n        piece = board.piece_at(square)\n        if piece and piece.color == board.turn and (piece.piece_type == chess.KNIGHT or piece.piece_type == chess.BISHOP):\n            if (piece.color == chess.WHITE and chess.square_rank(square) == 6) or (piece.color == chess.BLACK and chess.square_rank(square) == 1):\n                if not board.is_attacked_by(not board.turn, square):\n                    outpost_count += 1\n    return float(outpost_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the king safety based on the number of pawns in front of each player's king.\"\n    king_square = chess.square_rank(board.king(chess.WHITE) if board.turn == chess.WHITE else board.king(chess.BLACK))\n    pawn_count = 0\n    for file in range(8):\n        square = chess.square(file, king_square)\n        if board.piece_at(square) and board.piece_at(square).piece_type == chess.PAWN and board.piece_at(square).color == board.turn:\n            pawn_count += 1\n    return float(pawn_count)", "def feature(board: chess.Board) -> float:\n    \"Measures potential threats by counting the number of opposing pieces that can attack the current player\u2019s king.\"\n    king_square = board.king(chess.WHITE if board.turn else chess.BLACK)\n    threaten_count = len(board.attackers(not board.turn, king_square))\n    return float(threaten_count)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of open files for rooks of the current player.\"\n    open_files = set()\n    for file in range(8):\n        is_open = not any(board.piece_at(chess.square(file, rank)) for rank in range(8))\n        if is_open:\n            open_files.add(file)\n    return float(len(open_files))", "def feature(board: chess.Board) -> float:\n    \"Calculates the central control by counting pieces in the central squares.\"\n    central_squares = [chess.E4, chess.E5, chess.D4, chess.D5]\n    control_count = sum(1 for sq in central_squares if board.piece_at(sq) and board.piece_at(sq).color == board.turn)\n    return float(control_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of weak squares controlled by the opposing player.\"\n    weak_squares_count = 0\n    for square in range(64):\n        if board.is_attacked_by(not board.turn, square):\n            weak_squares_count += 1\n    return float(weak_squares_count)", "def feature(board: chess.Board) -> float:\n    \"Counts the total number of pieces that are currently unprotected.\"\n    unprotected_count = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == board.turn and not any(board.is_attacked_by(not board.turn, sq) for sq in board.attackers(not board.turn, square)):\n            unprotected_count += 1\n    return float(unprotected_count)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pawns that are on their opponent's side of the board.\"\n    white_pawns = sum(1 for square, piece in board.piece_map().items() \n                      if piece.color == chess.WHITE and piece.piece_type == chess.PAWN and chess.square_rank(square) > 4)\n    black_pawns = sum(1 for square, piece in board.piece_map().items() \n                      if piece.color == chess.BLACK and piece.piece_type == chess.PAWN and chess.square_rank(square) < 4)\n    return float(white_pawns + black_pawns)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of pieces that are pinned by the opponent's pieces.\"\n    pinned_pieces = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == (chess.WHITE if board.turn else chess.BLACK):\n            if any(board.is_attacked_by(not piece.color, pin_square) for pin_square in board.attackers(not piece.color, square)):\n                pinned_pieces += 1\n    return float(pinned_pieces)", "def feature(board: chess.Board) -> float:\n    \"Measures the balance of central control by counting pieces on central squares.\"\n    central_squares = [chess.E4, chess.E5, chess.D4, chess.D5]\n    control_count = sum(1 for square in central_squares if board.piece_at(square) is not None)\n    return float(control_count)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of double attacks present on the board.\"\n    double_attacks = 0\n    for square, piece in board.piece_map().items():\n        for target in board.legal_moves:\n            if (target.to_square in board.attackers(not piece.color, target.from_square)):\n                double_attacks += 1\n    return float(double_attacks)", "def feature(board: chess.Board) -> float:\n    \"Measures the difference in material value between the two players' remaining pieces.\"\n    material_values = {chess.PAWN: 100, chess.KNIGHT: 320, chess.BISHOP: 330, \n                       chess.ROOK: 500, chess.QUEEN: 900, chess.KING: 20000}\n    white_material = sum(material_values[piece.piece_type] for piece in board.piece_map().values() if piece.color == chess.WHITE)\n    black_material = sum(material_values[piece.piece_type] for piece in board.piece_map().values() if piece.color == chess.BLACK)\n    return float(white_material - black_material)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces controlled by each player.\"\n    white_piece_count = len([p for p in board.piece_map().values() if p.color == chess.WHITE])\n    black_piece_count = len([p for p in board.piece_map().values() if p.color == chess.BLACK])\n    return float(white_piece_count - black_piece_count)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of pieces that are in the back rank for each player.\"\n    back_rank_white = all(board.piece_at(chess.parse_square(f'{file}1')) is not None for file in 'abcdefgh')\n    back_rank_black = all(board.piece_at(chess.parse_square(f'{file}8')) is not None for file in 'abcdefgh')\n    return float(back_rank_white) - float(back_rank_black)", "def feature(board: chess.Board) -> float:\n    \"Calculates the total piece value of advanced pawns (pawns on ranks 5 and above).\"\n    advanced_pawn_value = sum(1.0 for square in board.piece_map() if board.piece_at(square).piece_type == chess.PAWN and chess.square_rank(square) >= 4)\n    return advanced_pawn_value", "def feature(board: chess.Board) -> float:\n    \"Evaluates the number of safe squares for the king of the current player.\"\n    king_square = board.king(board.turn)\n    safe_squares = sum(1 for move in board.legal_moves if chess.square_distance(king_square, move.to_square) == 1 and not board.is_attacked_by(not board.turn, move.to_square))\n    return float(safe_squares)", "def feature(board: chess.Board) -> float:\n    \"Calculates material advantage based on piece types and their positions (central control).\"\n    central_control_value = sum(1.0 for square in board.piece_map() if chess.square_file(square) in [3, 4] and chess.square_rank(square) in [3, 4])\n    return central_control_value", "def feature(board: chess.Board) -> float:\n    \"Measures the total value of pieces in the opponent's half of the board.\"\n    opponent_half_value = sum(board.piece_map()[square].piece_type for square in board.piece_map() if (board.turn and chess.square_rank(square) < 4) or (not board.turn and chess.square_rank(square) > 3))\n    return float(opponent_half_value)", "def feature(board: chess.Board) -> float:\n    \"Measures the difference in mobility between both players by counting legal moves.\"\n    white_moves = sum(1 for move in board.legal_moves if board.turn)\n    black_moves = sum(1 for move in board.legal_moves if not board.turn)\n    return float(white_moves - black_moves)", "def feature(board: chess.Board) -> float:\n    \"Calculates the positional advantage based on piece coordination (attacks set).\"\n    attack_positions = set()\n    for square, piece in board.piece_map().items():\n        if piece.color == board.turn:\n            attack_positions.update(board.attackers(piece.color, square))\n    return float(len(attack_positions))", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces each side has attacking the opponent's king.\"\n    white_attacks = len(board.attackers(chess.WHITE, board.king(chess.BLACK))) \n    black_attacks = len(board.attackers(chess.BLACK, board.king(chess.WHITE)))\n    return float(white_attacks - black_attacks)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces directly attacking the opponent's king.\"\n    attackers = sum(1 for square in board.piece_map() if board.is_attacked_by(not board.turn, square) and board.piece_at(square).color == board.turn)\n    return float(attackers)", "def feature(board: chess.Board) -> float:\n    \"Calculates material value based on pieces currently on the board.\"\n    piece_values = {\n        chess.PAWN: 100,\n        chess.KNIGHT: 320,\n        chess.BISHOP: 330,\n        chess.ROOK: 500,\n        chess.QUEEN: 900,\n        chess.KING: 20000\n    }\n    material_value = sum(piece_values[piece.piece_type] for piece in board.piece_map().values())\n    return float(material_value)", "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in pawn structure between both players.\"\n    white_pawns = len([square for square in board.piece_map() if board.piece_at(square).piece_type == chess.PAWN and board.piece_at(square).color == chess.WHITE])\n    black_pawns = len([square for square in board.piece_map() if board.piece_at(square).piece_type == chess.PAWN and board.piece_at(square).color == chess.BLACK])\n    return float(white_pawns - black_pawns)", "def feature(board: chess.Board) -> float:\n    \"Evaluates the position's mobility by comparing potential moves of both players.\"\n    white_moves = len(list(board.legal_moves)) if board.turn else 0\n    black_moves = len(list(board.legal_moves)) if not board.turn else 0\n    return float(white_moves - black_moves)", "def feature(board: chess.Board) -> float:\n    \"Measures how many pieces are on the back rank and potentially in danger.\"\n    back_rank_count = sum(1 for square in board.piece_map() if (board.piece_at(square).color == chess.WHITE and chess.square_rank(square) == 0) or \n                                                             (board.piece_at(square).color == chess.BLACK and chess.square_rank(square) == 7))\n    return float(back_rank_count)", "def feature(board: chess.Board) -> float:\n    \"Measures the king safety by counting the number of pieces surrounding the king.\"\n    king_square = next((sq for sq in board.piece_map() if board.piece_at(sq).piece_type == chess.KING), None)\n    if king_square is None:\n        return 0.0\n    surrounding_pieces = sum(1 for square in chess.SQUARES if chess.square_distance(king_square, square) == 1 and board.piece_at(square) is not None)\n    return float(surrounding_pieces)", "def feature(board: chess.Board) -> float:\n    \"Counts the total number of hanging pieces for both players.\"\n    hanging_pieces = 0\n    for square, piece in board.piece_map().items():\n        if board.is_attacked_by(not piece.color, square):\n            hanging_pieces += 1\n    return float(hanging_pieces)", "def feature(board: chess.Board) -> float:\n    \"Measures the piece mobility by counting legal moves for both players.\"\n    white_moves = len(list(board.legal_moves)) if board.turn else 0\n    black_moves = len(list(board.legal_moves)) if not board.turn else 0\n    return float(white_moves - black_moves)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces on the back rank for both players.\"\n    back_rank_pieces = {chess.WHITE: 0, chess.BLACK: 0}\n    for file in range(8):\n        if board.piece_at(chess.square(file, 0)):  # White back rank\n            back_rank_pieces[chess.WHITE] += 1\n        if board.piece_at(chess.square(file, 7)):  # Black back rank\n            back_rank_pieces[chess.BLACK] += 1\n    return float(back_rank_pieces[chess.WHITE] - back_rank_pieces[chess.BLACK])", "def feature(board: chess.Board) -> float:\n    \"Checks if the position is likely to lead to a forced checkmate.\"\n    if board.is_checkmate():\n        return 1.0\n    return 0.0", "def feature(board: chess.Board) -> float:\n    \"Calculates the average distance of king from the center of the board for both players.\"\n    center_squares = [(3, 3), (3, 4), (4, 3), (4, 4)]\n    def distance_to_center(king_square):\n        return min(chess.square_distance(king_square, chess.square(file, rank))\n                   for file, rank in center_squares)\n    \n    white_king_distance = distance_to_center(board.king(chess.WHITE))\n    black_king_distance = distance_to_center(board.king(chess.BLACK))\n    \n    return float(black_king_distance - white_king_distance)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pawns that are advanced (on ranks 4-7).\"\n    advanced_pawns = {chess.WHITE: 0, chess.BLACK: 0}\n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.PAWN:\n            if chess.square_rank(square) >= 4:\n                advanced_pawns[piece.color] += 1\n    return float(advanced_pawns[chess.WHITE] - advanced_pawns[chess.BLACK])", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces that are directly attacking the opponent's king.\"\n    attacking_opponent_king = 0\n    opponent_king_square = board.king(not board.turn)\n    for square, piece in board.piece_map().items():\n        if piece.color == board.turn and square in board.attackers(not board.turn, opponent_king_square):\n            attacking_opponent_king += 1\n    return float(attacking_opponent_king)", "def feature(board: chess.Board) -> float:\n    \"Measures the difference in the number of pieces on the board for each player.\"\n    white_piece_count = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE)\n    black_piece_count = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK)\n    return float(white_piece_count - black_piece_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the total value of all pieces on the board for each player.\"\n    piece_value = {chess.PAWN: 100, chess.KNIGHT: 300, chess.BISHOP: 300, \n                   chess.ROOK: 500, chess.QUEEN: 900, chess.KING: 0}\n    total_value = 0\n    for piece in board.piece_map().values():\n        total_value += piece_value[piece.piece_type] if piece.color == chess.WHITE else -piece_value[piece.piece_type]\n    return float(total_value)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of pieces attacked by the opponent.\"\n    opponent_color = chess.BLACK if board.turn else chess.WHITE\n    attacked_count = sum(1 for square in board.piece_map() \n                         if board.is_attacked_by(opponent_color, square))\n    return float(attacked_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the ratio of pawns to total pieces for both players.\"\n    white_pawn_count = sum(1 for piece in board.piece_map().values() \n                           if piece.color == chess.WHITE and piece.piece_type == chess.PAWN)\n    black_pawn_count = sum(1 for piece in board.piece_map().values() \n                           if piece.color == chess.BLACK and piece.piece_type == chess.PAWN)\n    total_white_pieces = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE)\n    total_black_pieces = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK)\n    white_ratio = white_pawn_count / total_white_pieces if total_white_pieces > 0 else 0.0\n    black_ratio = black_pawn_count / total_black_pieces if total_black_pieces > 0 else 0.0\n    return float(white_ratio - black_ratio)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces pinned by the opponent's pieces.\"\n    pinned_count = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == chess.WHITE:\n            if board.is_attacked_by(chess.BLACK, square):\n                pinned_count += 1\n    return float(pinned_count)", "def feature(board: chess.Board) -> float:\n    \"Measures the distance of all pieces to the opponent's king.\"\n    opponent_king_square = next((square for square, piece in board.piece_map().items() \n                                  if piece.piece_type == chess.KING and piece.color != board.turn), None)\n    if opponent_king_square is None:\n        return 0.0\n    total_distance = sum(chess.square_distance(square, opponent_king_square) \n                         for square, piece in board.piece_map().items() if piece.color == board.turn)\n    return float(total_distance)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of legal moves available to the current player.\"\n    legal_moves_count = len(list(board.legal_moves))\n    return float(legal_moves_count)", "def feature(board: chess.Board) -> float:\n    \"Checks if either player is in check.\"\n    return float(board.is_check())", "def feature(board: chess.Board) -> float:\n    \"Counts the number of hanging pieces for both players.\"\n    hanging_pieces = sum(1 for sq, piece in board.piece_map().items() if board.is_attacked_by(not piece.color, sq) and piece.color == board.turn)\n    return float(hanging_pieces)", "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in material value of pieces on the board.\"\n    piece_values = {chess.PAWN: 100, chess.KNIGHT: 300, chess.BISHOP: 300, chess.ROOK: 500, chess.QUEEN: 900}\n    white_value = sum(piece_values.get(piece.piece_type, 0) for piece in board.piece_map().values() if piece.color == chess.WHITE)\n    black_value = sum(piece_values.get(piece.piece_type, 0) for piece in board.piece_map().values() if piece.color == chess.BLACK)\n    return float(white_value - black_value)", "def feature(board: chess.Board) -> float:\n    \"Measures the distance of all pieces from the center of the board.\"\n    center_squares = [chess.D4, chess.D5, chess.E4, chess.E5]\n    distance_sum = sum(chess.square_distance(sq, center_sq) for sq in board.piece_map() for center_sq in center_squares)\n    return float(distance_sum)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces on the back rank for both players.\"\n    back_rank_count = sum(1 for sq, piece in board.piece_map().items() if (piece.color == chess.WHITE and chess.square_rank(sq) == 0) or \n                                                                               (piece.color == chess.BLACK and chess.square_rank(sq) == 7))\n    return float(back_rank_count)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of pawn structures on the board.\"\n    pawn_structure = sum(1 for sq in board.piece_map() if board.piece_at(sq).piece_type == chess.PAWN)\n    return float(pawn_structure)", "def feature(board: chess.Board) -> float:\n    \"Analyses the number of possible forks (pieces that can attack two or more enemy pieces at once).\"\n    forks_count = sum(1 for move in board.legal_moves if board.piece_at(move.to_square) and \n                      len(board.attackers(not board.turn, move.to_square)) > 1)\n    return float(forks_count)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of centers controlled by each player based on pawn positions.\"\n    controlled_centers = sum(1 for sq in [chess.D4, chess.D5, chess.E4, chess.E5] if board.piece_at(sq) and \n                                                       board.piece_at(sq).color == board.turn)\n    return float(controlled_centers)", "def feature(board: chess.Board) -> float:\n    \"Measures how many pieces are under direct attack.\"\n    under_attack = sum(1 for sq, piece in board.piece_map().items() if board.is_attacked_by(not piece.color, sq))\n    return float(under_attack)", "def feature(board: chess.Board) -> float:\n    \"Measures the attacking potential by counting the number of pieces attacking the opponent's king.\"\n    king_square = board.king(chess.BLACK) if board.turn else board.king(chess.WHITE)\n    attackers_count = sum(1 for square in board.attackers(chess.WHITE if board.turn else chess.BLACK, king_square))\n    return float(attackers_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in material value between the two sides based on piece types.\"\n    material_value = {chess.PAWN: 100, chess.KNIGHT: 320, chess.BISHOP: 330,\n                      chess.ROOK: 500, chess.QUEEN: 900, chess.KING: 0}\n    total_value_white = sum(material_value[piece.piece_type] for piece in board.piece_map().values() if piece.color == chess.WHITE)\n    total_value_black = sum(material_value[piece.piece_type] for piece in board.piece_map().values() if piece.color == chess.BLACK)\n    return float(total_value_white - total_value_black)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of available moves for the side to move, normalized by the total number of pieces.\"\n    legal_moves = len(list(board.legal_moves))\n    total_pieces = len(board.piece_map())\n    return float(legal_moves / (total_pieces + 1))  # Add 1 to avoid division by zero", "def feature(board: chess.Board) -> float:\n    \"Measures the maximum distance of any piece from the opponent's back rank.\"\n    back_rank = 0 if board.turn else 7\n    max_distance = max(chess.square_distance(square, chess.parse_square('a' + str(back_rank + 1))) \n                       for square, piece in board.piece_map().items() if piece.color == (chess.WHITE if board.turn else chess.BLACK))\n    return float(max_distance)", "def feature(board: chess.Board) -> float:\n    \"Calculates the central control by counting pieces in the central squares.\"\n    central_squares = [chess.D4, chess.D5, chess.E4, chess.E5]\n    control_count = sum(1 for square in central_squares if board.piece_at(square) is not None)\n    return float(control_count)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces that are pinned against their own king.\"\n    pinned_count = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == (chess.WHITE if board.turn else chess.BLACK) and \\\n           board.is_attacked_by(chess.BLACK if board.turn else chess.WHITE, square):\n            pinned_count += 1\n    return float(pinned_count)", "def feature(board: chess.Board) -> float:\n    \"Measures the presence of major pieces (queens and rooks) on the board.\"\n    major_piece_count = sum(1 for piece in board.piece_map().values() if piece.piece_type in (chess.QUEEN, chess.ROOK))\n    return float(major_piece_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the total number of pawns on the board.\"\n    pawn_count = sum(1 for piece in board.piece_map().values() if piece.piece_type == chess.PAWN)\n    return float(pawn_count)", "def feature(board: chess.Board) -> float:\n    \"Computes the difference in mobility between both players based on available legal moves.\"\n    white_moves = len(list(board.legal_moves) if board.turn else [])\n    black_moves = len(list(board.legal_moves) if not board.turn else [])\n    return float(white_moves - black_moves)", "def feature(board: chess.Board) -> float:\n    \"Evaluates the central control by counting pieces on central squares (d4, d5, e4, e5).\"\n    central_squares = [chess.parse_square(sq) for sq in ['d4', 'd5', 'e4', 'e5']]\n    control_count = sum(1 for sq in central_squares if board.piece_at(sq) is not None)\n    return float(control_count)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of pieces that are pinned (unable to move without exposing the king).\"\n    pinned_count = sum(1 for square, piece in board.piece_map().items() if board.is_attacked_by(not piece.color, square) and (piece.piece_type != chess.KING))\n    return float(pinned_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the distance of the kings from the center of the board.\"\n    white_king_square = next((square for square in board.piece_map() if board.piece_map()[square].piece_type == chess.KING and board.piece_map()[square].color == chess.WHITE), None)\n    black_king_square = next((square for square in board.piece_map() if board.piece_map()[square].piece_type == chess.KING and board.piece_map()[square].color == chess.BLACK), None)\n    \n    if white_king_square is None or black_king_square is None:\n        return 0.0\n    \n    white_distance = chess.square_distance(white_king_square, chess.parse_square('e4'))\n    black_distance = chess.square_distance(black_king_square, chess.parse_square('e5'))\n    \n    return float(black_distance - white_distance)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of weak pawns on the board (pawns that are isolated or doubled).\"\n    weak_pawn_count = 0\n    for square in range(64):\n        pawn = board.piece_at(square)\n        if pawn and pawn.piece_type == chess.PAWN:\n            file = chess.square_file(square)\n            rank = chess.square_rank(square)\n            if (board.piece_at(chess.parse_square(chess.square_name(square - 8))) is None and \n                board.piece_at(chess.parse_square(chess.square_name(square + 8))) is None):\n                weak_pawn_count += 1\n            elif (board.piece_at(chess.parse_square(chess.square_name(square - 1))) is not None and \n                  board.piece_at(chess.parse_square(chess.square_name(square + 1))) is not None):\n                weak_pawn_count += 1\n    return float(weak_pawn_count)", "def feature(board: chess.Board) -> float:\n    \"Assesses the number of safe squares for each player's king to move to.\"\n    white_king_square = next((square for square in board.piece_map() if board.piece_map()[square].piece_type == chess.KING and board.piece_map()[square].color == chess.WHITE), None)\n    black_king_square = next((square for square in board.piece_map() if board.piece_map()[square].piece_type == chess.KING and board.piece_map()[square].color == chess.BLACK), None)\n    \n    if white_king_square is None or black_king_square is None:\n        return 0.0\n    \n    safe_moves_white = sum(1 for move in board.legal_moves if move.to_square == white_king_square and not board.is_attacked_by(chess.BLACK, move.to_square))\n    safe_moves_black = sum(1 for move in board.legal_moves if move.to_square == black_king_square and not board.is_attacked_by(chess.WHITE, move.to_square))\n    \n    return float(safe_moves_black - safe_moves_white)", "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in control of the center squares.\"\n    center_squares = [chess.D4, chess.D5, chess.E4, chess.E5]\n    white_control = sum(board.is_attacked_by(chess.WHITE, sq) for sq in center_squares)\n    black_control = sum(board.is_attacked_by(chess.BLACK, sq) for sq in center_squares)\n    return float(white_control - black_control)", "def feature(board: chess.Board) -> float:\n    \"Measures the total number of pawns on the board.\"\n    total_pawns = sum(1 for piece in board.piece_map().values() if piece.piece_type == chess.PAWN)\n    return float(total_pawns)", "def feature(board: chess.Board) -> float:\n    \"Computes the material balance of knights and bishops.\"\n    piece_values = {chess.KNIGHT: 320, chess.BISHOP: 330}\n    white_material = sum(piece_values.get(piece.piece_type, 0) for piece in board.piece_map().values() if piece.color == chess.WHITE)\n    black_material = sum(piece_values.get(piece.piece_type, 0) for piece in board.piece_map().values() if piece.color == chess.BLACK)\n    return float(white_material - black_material)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces that are pinned (cannot move without exposing a king).\"\n    pinned_count = sum(1 for square, piece in board.piece_map().items() if board.is_attacked_by(board.turn, square) and not board.is_attacked_by(not board.turn, square))\n    return float(pinned_count)", "def feature(board: chess.Board) -> float:\n    \"Measures the distance of the kings from the center of the board.\"\n    white_king = next(square for square, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color == chess.WHITE)\n    black_king = next(square for square, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color == chess.BLACK)\n    distance = chess.square_distance(white_king, chess.E4) + chess.square_distance(black_king, chess.E4)\n    return float(40 - distance)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of pieces attacking the opponent's king.\"\n    opponent_king_square = next(square for square, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color != board.turn)\n    attacking_count = sum(1 for move in board.legal_moves if move.to_square == opponent_king_square)\n    return float(attacking_count)", "def feature(board: chess.Board) -> float:\n    \"Measures the mobility of the player by counting available moves.\"\n    available_moves = len(list(board.legal_moves))\n    return float(available_moves)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of rook interactions (potentially controlling open files).\"\n    white_rooks = [square for square, piece in board.piece_map().items() if piece.piece_type == chess.ROOK and piece.color == chess.WHITE]\n    black_rooks = [square for square, piece in board.piece_map().items() if piece.piece_type == chess.ROOK and piece.color == chess.BLACK]\n    return float(len(white_rooks) - len(black_rooks))", "def feature(board: chess.Board) -> float:\n    \"Measures the distribution of the opponent's pieces (fewer pieces on own side often indicates weakness).\"\n    opponent_pieces = sum(1 for piece in board.piece_map().values() if piece.color != board.turn)\n    own_pieces_on_front = sum(1 for square, piece in board.piece_map().items() if piece.color == board.turn and (chess.square_rank(square) > 4))\n    return float(opponent_pieces - own_pieces_on_front)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of pawns on the board for each side\"\n    white_pawns = sum(1 for piece in board.piece_map().values() if piece.piece_type == chess.PAWN and piece.color == chess.WHITE)\n    black_pawns = sum(1 for piece in board.piece_map().values() if piece.piece_type == chess.PAWN and piece.color == chess.BLACK)\n    return float(white_pawns - black_pawns)", "def feature(board: chess.Board) -> float:\n    \"Calculates the total piece square advantage for the current player\"\n    piece_values = {chess.PAWN: 100, chess.KNIGHT: 300, chess.BISHOP: 300, chess.ROOK: 500, chess.QUEEN: 900, chess.KING: 2000}\n    advantage = 0\n    for square, piece in board.piece_map().items():\n        value = piece_values.get(piece.piece_type, 0)\n        if piece.color == board.turn:\n            advantage += value * (8 - chess.square_rank(square))  # pieces in higher ranks are more valuable\n        else:\n            advantage -= value * (8 - chess.square_rank(square))\n    return float(advantage)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces on the board for each side\"\n    white_count = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE)\n    black_count = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK)\n    return float(white_count - black_count)", "def feature(board: chess.Board) -> float:\n    \"Evaluates the positional safety of the kings\"\n    white_king_square = next((square for square, piece in board.piece_map().items() if piece.color == chess.WHITE and piece.piece_type == chess.KING), None)\n    black_king_square = next((square for square, piece in board.piece_map().items() if piece.color == chess.BLACK and piece.piece_type == chess.KING), None)\n    white_threats = len(board.attackers(chess.BLACK, white_king_square)) if white_king_square is not None else 0\n    black_threats = len(board.attackers(chess.WHITE, black_king_square)) if black_king_square is not None else 0\n    return float(black_threats - white_threats)", "def feature(board: chess.Board) -> float:\n    \"Measures the distance of the kings from their respective back ranks\"\n    white_king_square = next((square for square, piece in board.piece_map().items() if piece.color == chess.WHITE and piece.piece_type == chess.KING), None)\n    black_king_square = next((square for square, piece in board.piece_map().items() if piece.color == chess.BLACK and piece.piece_type == chess.KING), None)\n    distance_white = chess.square_rank(white_king_square) if white_king_square is not None else 8\n    distance_black = chess.square_rank(black_king_square) if black_king_square is not None else 8\n    return float(distance_black - distance_white)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of open files for both players\"\n    open_files_white = sum(1 for file in range(8) if all(board.piece_at(chess.square(file, rank)) is None for rank in range(8)))\n    open_files_black = sum(1 for file in range(8) if all(board.piece_at(chess.square(file, rank)) is None for rank in range(8)))\n    return float(open_files_white - open_files_black)", "def feature(board: chess.Board) -> float:\n    \"Checks for the mobility of pieces while counting unoccupied squares around pieces\"\n    mobility_score = 0\n    for square, piece in board.piece_map().items():\n        possible_moves = len(list(board.legal_moves))\n        mobility_score += possible_moves\n    return float(mobility_score)", "def feature(board: chess.Board) -> float:\n    \"Measures the activity of rooks on open ranks and files\"\n    active_rooks = sum(1 for square, piece in board.piece_map().items() if piece.piece_type == chess.ROOK and (chess.square_rank(square) in (0, 7) or chess.square_file(square) in (0, 7)))\n    return float(active_rooks)", "def feature(board: chess.Board) -> float:\n    'Measures the total value of pieces for both sides combined.'\n    total_value = 0\n    piece_values = {\n        chess.PAWN: 100,\n        chess.KNIGHT: 320,\n        chess.BISHOP: 330,\n        chess.ROOK: 500,\n        chess.QUEEN: 900,\n        chess.KING: 0\n    }\n    for piece in board.piece_map().values():\n        total_value += piece_values.get(piece.piece_type, 0)\n    return float(total_value)", "def feature(board: chess.Board) -> float:\n    'Counts the number of pieces for each player and computes the ratio of White to Black pieces.'\n    white_count = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE)\n    black_count = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK)\n    return float(white_count / (black_count if black_count > 0 else 1))", "def feature(board: chess.Board) -> float:\n    'Measures the total number of squares attacked by both players.'\n    attack_count = 0\n    for square in chess.SQUARES:\n        if board.is_attacked_by(chess.WHITE, square):\n            attack_count += 1\n        if board.is_attacked_by(chess.BLACK, square):\n            attack_count += 1\n    return float(attack_count)", "def feature(board: chess.Board) -> float:\n    'Counts the number of pawns on the board for both players.'\n    white_pawns = len([p for p in board.piece_map().values() if p.piece_type == chess.PAWN and p.color == chess.WHITE])\n    black_pawns = len([p for p in board.piece_map().values() if p.piece_type == chess.PAWN and p.color == chess.BLACK])\n    return float(white_pawns - black_pawns)", "def feature(board: chess.Board) -> float:\n    'Calculates the difference in the number of pieces close to the opponent\u2019s king.'\n    white_near_king = sum(1 for square in board.piece_map() if board.piece_map()[square].color == chess.WHITE and chess.square_distance(square, chess.parse_square('e8')) <= 2)\n    black_near_king = sum(1 for square in board.piece_map() if board.piece_map()[square].color == chess.BLACK and chess.square_distance(square, chess.parse_square('e1')) <= 2)\n    return float(white_near_king - black_near_king)", "def feature(board: chess.Board) -> float:\n    'Measures the king safety based on the number of pawns surrounding the kings.'\n    white_king_square = [square for square, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color == chess.WHITE]\n    black_king_square = [square for square, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color == chess.BLACK]\n    white_pawn_protection = sum(1 for p_square, piece in board.piece_map().items() if piece.piece_type == chess.PAWN and piece.color == chess.WHITE and chess.square_distance(p_square, white_king_square[0]) == 1)\n    black_pawn_protection = sum(1 for p_square, piece in board.piece_map().items() if piece.piece_type == chess.PAWN and piece.color == chess.BLACK and chess.square_distance(p_square, black_king_square[0]) == 1)\n    return float(white_pawn_protection - black_pawn_protection)", "def feature(board: chess.Board) -> float:\n    'Counts the number of hanging pieces (pieces that can be captured without retaliation).'\n    hanging_pieces = sum(1 for square in board.piece_map() if board.piece_map()[square].color == board.turn and not board.attackers(not board.turn, square))\n    return float(hanging_pieces)", "def feature(board: chess.Board) -> float:\n    'Calculates the average distance of pieces from their respective king positions.'\n    white_king_square = next(square for square, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color == chess.WHITE)\n    black_king_square = next(square for square, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color == chess.BLACK)\n    total_distance = 0\n    piece_count = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == chess.WHITE:\n            total_distance += chess.square_distance(square, white_king_square)\n        elif piece.color == chess.BLACK:\n            total_distance += chess.square_distance(square, black_king_square)\n        piece_count += 1\n    return float(total_distance / max(piece_count, 1))", "def feature(board: chess.Board) -> float:\n    'Calculates the difference in mobility, defined as the number of legal moves for each player.'\n    white_moves = len(list(board.legal_moves)) if board.turn else 0\n    black_moves = len(list(board.legal_moves)) if not board.turn else 0\n    return float(white_moves - black_moves)", "def feature(board: chess.Board) -> float:\n    \"Measures the total influence of each player's pieces based on the number of squares they attack.\"\n    white_attacked_squares = sum(board.is_attacked_by(chess.WHITE, sq) for sq in chess.SQUARES)\n    black_attacked_squares = sum(board.is_attacked_by(chess.BLACK, sq) for sq in chess.SQUARES)\n    result = float(white_attacked_squares - black_attacked_squares)\n    return result", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces for each player and measures the total value difference.\"\n    piece_values = {chess.PAWN: 100, chess.KNIGHT: 320, chess.BISHOP: 330, \n                    chess.ROOK: 500, chess.QUEEN: 900, chess.KING: 0}\n    white_value = sum(piece_values[piece.piece_type] for piece in board.piece_map().values() if piece.color == chess.WHITE)\n    black_value = sum(piece_values[piece.piece_type] for piece in board.piece_map().values() if piece.color == chess.BLACK)\n    result = float(white_value - black_value)\n    return result", "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in the total number of pawns between players.\"\n    white_pawns = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE and piece.piece_type == chess.PAWN)\n    black_pawns = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK and piece.piece_type == chess.PAWN)\n    result = float(white_pawns - black_pawns)\n    return result", "def feature(board: chess.Board) -> float:\n    \"Measures the positioning value of knights based on their centrality in the board.\"\n    knight_positions = [sq for sq, piece in board.piece_map().items() if piece.piece_type == chess.KNIGHT]\n    centrality_score = sum(1 for sq in knight_positions if chess.square_file(sq) in [2, 3, 4, 5] and chess.square_rank(sq) in [2, 3, 4, 5])\n    result = float(centrality_score)\n    return result", "def feature(board: chess.Board) -> float:\n    \"Measures the distance of the kings from the center of the board.\"\n    white_king = next((square for square, piece in board.piece_map().items() if piece.color == chess.WHITE and piece.piece_type == chess.KING), None)\n    black_king = next((square for square, piece in board.piece_map().items() if piece.color == chess.BLACK and piece.piece_type == chess.KING), None)\n    center = chess.square_name(chess.E4)\n    distance_score = (chess.square_distance(white_king, chess.E4) + chess.square_distance(black_king, chess.E4)) / 2\n    result = float(distance_score)\n    return result", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of pieces on the board and discerns from the expected number based on material count.\"\n    total_pieces = len(board.piece_map())\n    expected_pieces = (16 if board.turn == chess.WHITE else 16) - (sum(1 for piece in board.piece_map().values() if piece.color != board.turn))\n    result = float(total_pieces - expected_pieces)\n    return result", "def feature(board: chess.Board) -> float:\n    \"Calculates the activity of pieces by counting the number of legal moves available for each side.\"\n    white_moves = len(list(board.legal_moves)) if board.turn == chess.WHITE else 0\n    black_moves = len(list(board.legal_moves)) if board.turn == chess.BLACK else 0\n    result = float(white_moves - black_moves)\n    return result", "def feature(board: chess.Board) -> float:\n    \"Measures the mobility of the pieces by counting the total number of legal moves available.\"\n    return float(len(list(board.legal_moves)))", "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in the number of pawns for each side.\"\n    white_pawns = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE and piece.piece_type == chess.PAWN)\n    black_pawns = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK and piece.piece_type == chess.PAWN)\n    return float(white_pawns - black_pawns)", "def feature(board: chess.Board) -> float:\n    \"Evaluates the number of squares defended by each player.\"\n    white_defended_squares = sum(1 for square in chess.SQUARES if board.is_attacked_by(chess.WHITE, square) and board.piece_at(square) is None)\n    black_defended_squares = sum(1 for square in chess.SQUARES if board.is_attacked_by(chess.BLACK, square) and board.piece_at(square) is None)\n    return float(white_defended_squares - black_defended_squares)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of major pieces (queen and rooks) for each side.\"\n    white_major_pieces = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE and piece.piece_type in [chess.QUEEN, chess.ROOK])\n    black_major_pieces = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK and piece.piece_type in [chess.QUEEN, chess.ROOK])\n    return float(white_major_pieces - black_major_pieces)", "def feature(board: chess.Board) -> float:\n    \"Measures the king safety by counting the number of squares surrounding the kings that are attacked.\"\n    white_king_square = [sq for sq, piece in board.piece_map().items() if piece.color == chess.WHITE and piece.piece_type == chess.KING][0]\n    black_king_square = [sq for sq, piece in board.piece_map().items() if piece.color == chess.BLACK and piece.piece_type == chess.KING][0]\n    \n    white_attacked_squares = sum(1 for sq in chess.SQUARES if board.is_attacked_by(chess.BLACK, sq) and chess.square_distance(sq, white_king_square) <= 1)\n    black_attacked_squares = sum(1 for sq in chess.SQUARES if board.is_attacked_by(chess.WHITE, sq) and chess.square_distance(sq, black_king_square) <= 1)\n    \n    return float(white_attacked_squares - black_attacked_squares)", "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in the number of pieces on the board.\"\n    white_pieces = len([piece for piece in board.piece_map().values() if piece.color == chess.WHITE])\n    black_pieces = len([piece for piece in board.piece_map().values() if piece.color == chess.BLACK])\n    return float(white_pieces - black_pieces)", "def feature(board: chess.Board) -> float:\n    \"Measures the material value difference based on a custom piece value system.\"\n    piece_values = {chess.PAWN: 100, chess.KNIGHT: 300, chess.BISHOP: 300, chess.ROOK: 500, chess.QUEEN: 900, chess.KING: 0}\n    material_value = sum(piece_values[piece.piece_type] * (-1 if piece.color == chess.BLACK else 1)\n                         for piece in board.piece_map().values())\n    return float(material_value)", "def feature(board: chess.Board) -> float:\n    \"Computes the potential threats by evaluating the number of pieces attacking the opponent's king.\"\n    opponent_king_square = [sq for sq, piece in board.piece_map().items() if piece.color != board.turn and piece.piece_type == chess.KING][0]\n    attacking_pieces_count = sum(1 for sq in chess.SQUARES if board.is_attacked_by(board.turn, sq) and \n                                  (board.piece_at(sq) is not None and board.piece_at(sq).color == board.turn))\n    return float(attacking_pieces_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of pawns for each player and returns their ratio.\"\n    white_pawns = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE and piece.piece_type == chess.PAWN)\n    black_pawns = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK and piece.piece_type == chess.PAWN)\n    if black_pawns == 0:\n        return float(white_pawns)\n    return white_pawns / black_pawns", "def feature(board: chess.Board) -> float:\n    \"Measures how many squares each player's pieces control.\"\n    white_control = sum(1 for square in chess.SQUARES if board.is_attacked_by(chess.WHITE, square))\n    black_control = sum(1 for square in chess.SQUARES if board.is_attacked_by(chess.BLACK, square))\n    return white_control - black_control", "def feature(board: chess.Board) -> float:\n    \"Returns a value based on the material imbalance considering only knights.\"\n    white_knights = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE and piece.piece_type == chess.KNIGHT)\n    black_knights = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK and piece.piece_type == chess.KNIGHT)\n    return float(white_knights - black_knights)", "def feature(board: chess.Board) -> float:\n    \"Calculates the distance from kings to each other to evaluate potential threats.\"\n    white_king = board.king(chess.WHITE)\n    black_king = board.king(chess.BLACK)\n    if white_king is not None and black_king is not None:\n        return float(chess.square_distance(white_king, black_king))\n    return float('inf')", "def feature(board: chess.Board) -> float:\n    \"Calculates the total value of pieces on the board.\"\n    piece_values = {\n        chess.PAWN: 100,\n        chess.KNIGHT: 320,\n        chess.BISHOP: 330,\n        chess.ROOK: 500,\n        chess.QUEEN: 900,\n        chess.KING: 20000,\n    }\n    total_value = sum(piece_values[piece.piece_type] for piece in board.piece_map().values())\n    return total_value", "def feature(board: chess.Board) -> float:\n    \"Measures the number of open files for rooks for both players.\"\n    open_files = {i: [0, 0] for i in range(8)}  # [white, black] for each file\n    for square in chess.SQUARES:\n        piece = board.piece_at(square)\n        if piece and piece.piece_type == chess.ROOK:\n            file = chess.square_file(square)\n            if piece.color == chess.WHITE:\n                open_files[file][0] += 1\n            else:\n                open_files[file][1] += 1\n    return sum(1 for file in open_files.values() if file[0] == 0) * 1.0 + sum(1 for file in open_files.values() if file[1] == 0) * -1.0", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces left on the board and returns it.\"\n    return float(len(board.piece_map()))", "def feature(board: chess.Board) -> float:\n    \"Calculates the distance of all pieces from the nearest enemy piece.\"\n    total_distance = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == board.turn:\n            closest_distance = float('inf')\n            for enemy_square, enemy_piece in board.piece_map().items():\n                if enemy_piece.color != piece.color:\n                    distance = chess.square_distance(square, enemy_square)\n                    closest_distance = min(closest_distance, distance)\n            total_distance += closest_distance if closest_distance != float('inf') else 0\n    return total_distance", "def feature(board: chess.Board) -> float:\n    \"Calculates the ratio of bishops to pawns for each player.\"\n    white_bishops = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE and piece.piece_type == chess.BISHOP)\n    black_bishops = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK and piece.piece_type == chess.BISHOP)\n    white_pawns = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE and piece.piece_type == chess.PAWN)\n    black_pawns = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK and piece.piece_type == chess.PAWN)\n    \n    white_ratio = white_bishops / white_pawns if white_pawns > 0 else 0\n    black_ratio = black_bishops / black_pawns if black_pawns > 0 else 0\n    return white_ratio - black_ratio", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pawns on the board, giving a sense of material structure.\"\n    pawn_count = sum(1 for piece in board.piece_map().values() if piece.piece_type == chess.PAWN)\n    return float(pawn_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of pieces attacked by each player's pieces.\"\n    white_attacked = sum(1 for square in board.piece_map() if board.is_attacked_by(chess.WHITE, square))\n    black_attacked = sum(1 for square in board.piece_map() if board.is_attacked_by(chess.BLACK, square))\n    return float(white_attacked - black_attacked)", "def feature(board: chess.Board) -> float:\n    \"Measures the king's safety based on the number of attacking pieces near it.\"\n    white_king_square = next(square for square, piece in board.piece_map().items() if piece.color == chess.WHITE and piece.piece_type == chess.KING)\n    black_king_square = next(square for square, piece in board.piece_map().items() if piece.color == chess.BLACK and piece.piece_type == chess.KING)\n    white_safety = len(board.attackers(chess.BLACK, white_king_square))\n    black_safety = len(board.attackers(chess.WHITE, black_king_square))\n    return float(black_safety - white_safety)", "def feature(board: chess.Board) -> float:\n    \"Calculates the ratio of major pieces (rooks and queens) to minor pieces (knights and bishops) on the board.\"\n    major_count = sum(1 for piece in board.piece_map().values() if piece.piece_type in {chess.ROOK, chess.QUEEN})\n    minor_count = sum(1 for piece in board.piece_map().values() if piece.piece_type in {chess.KNIGHT, chess.BISHOP})\n    return float(major_count) / (minor_count + 1)  # Adding 1 to avoid division by zero", "def feature(board: chess.Board) -> float:\n    \"Measures the mobility of the pieces by counting total legal moves available.\"\n    total_legal_moves = sum(1 for move in board.legal_moves)\n    return float(total_legal_moves)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of advanced pawns for both colors and returns the difference.\"\n    white_advanced_pawns = sum(1 for square, piece in board.piece_map().items() if piece.color == chess.WHITE and chess.square_rank(square) >= 4)\n    black_advanced_pawns = sum(1 for square, piece in board.piece_map().items() if piece.color == chess.BLACK and chess.square_rank(square) <= 3)\n    return float(white_advanced_pawns - black_advanced_pawns)", "def feature(board: chess.Board) -> float:\n    \"Measures the average distance of all pieces from their back rank to assess development.\"\n    distance_sum = sum(chess.square_rank(square) for square in board.piece_map())\n    piece_count = len(board.piece_map())\n    return float(distance_sum) / (piece_count + 1) if piece_count > 0 else 0.0", "def feature(board: chess.Board) -> float:\n    \"Measures the total number of discovered checks and their intensity.\"\n    discovered_checks = 0\n    for move in board.legal_moves:\n        board.push(move)\n        if board.is_check():\n            discovered_checks += 1\n        board.pop()\n    return float(discovered_checks)", "def feature(board: chess.Board) -> float:\n    \"Measures the activity of rooks based on how many open files they control.\"\n    open_files = 0\n    for file in range(8):\n        if all(board.piece_at(chess.square(file, rank)) is None for rank in range(8)):\n            open_files += 1\n    return float(open_files)", "def feature(board: chess.Board) -> float:\n    \"Calculates the sum of the distances of all pieces from the opponent's back rank.\"\n    total_distance = 0\n    opponent_color = chess.WHITE if board.turn else chess.BLACK\n    for square, piece in board.piece_map().items():\n        if piece.color == opponent_color:\n            total_distance += chess.square_distance(square, chess.square_file(0) if opponent_color == chess.WHITE else chess.square_file(7))\n    return float(total_distance)", "def feature(board: chess.Board) -> float:\n    \"Measures material imbalance based on piece types present.\"\n    piece_values = {chess.PAWN: 100, chess.KNIGHT: 320, chess.BISHOP: 330, chess.ROOK: 500, chess.QUEEN: 900}\n    imbalance = 0\n    for piece in board.piece_map().values():\n        imbalance += piece_values.get(piece.piece_type, 0) * (1 if piece.color == chess.WHITE else -1)\n    return float(imbalance)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces in the center of the board (squares d4, d5, e4, e5).\"\n    center_squares = [chess.parse_square('d4'), chess.parse_square('d5'), chess.parse_square('e4'), chess.parse_square('e5')]\n    center_piece_count = sum(1 for square in center_squares if board.piece_at(square) is not None)\n    return float(center_piece_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the pawn structure by counting doubled pawns for each side.\"\n    doubled_pawns = {chess.WHITE: 0, chess.BLACK: 0}\n    for file in range(8):\n        if sum(1 for rank in range(8) if board.piece_at(chess.square(file, rank)) == chess.PAWN) > 1:\n            if board.is_attacked_by(chess.WHITE, chess.square(file, 0)):\n                doubled_pawns[chess.WHITE] += 1\n            if board.is_attacked_by(chess.BLACK, chess.square(file, 7)):\n                doubled_pawns[chess.BLACK] += 1\n    return float(doubled_pawns[chess.WHITE] - doubled_pawns[chess.BLACK])", "def feature(board: chess.Board) -> float:\n    \"Measures the total number of knight jumps possible for both players.\"\n    knight_moves = {chess.KNIGHT: 0}\n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.KNIGHT:\n            knight_moves[chess.KNIGHT] += len(list(board.legal_moves))\n    return float(knight_moves[chess.KNIGHT])", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces that are pinned (unable to move without exposing the king).\"\n    pinned_count = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == board.turn and any(board.is_attacked_by(not piece.color, attacker) for attacker in board.attackers(not piece.color, square)):\n            pinned_count += 1\n    return float(pinned_count)", "def feature(board: chess.Board) -> float:\n    \"Evaluates the king's safety based on the number of squares it can move to.\"\n    king_square = [square for square, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color == board.turn]\n    if not king_square:\n        return 0.0\n    king_square = king_square[0]\n    safe_squares = sum(1 for move in board.legal_moves if chess.square_distance(move.from_square, king_square) == 1 and not board.is_attacked_by(not board.turn, move.to_square))\n    return float(safe_squares)", "def feature(board: chess.Board) -> float:\n    \"Calculates who has a majority of pawns on one wing of the board (A/B/C vs. D/E/F/G/H).\"\n    wing_majority = [0, 0]  # 0 = left wing, 1 = right wing\n    for file in range(4):\n        if board.piece_at(chess.square(file, 1)) == chess.PAWN:\n            wing_majority[0] += 1\n        if board.piece_at(chess.square(file + 4, 1)) == chess.PAWN:\n            wing_majority[1] += 1\n    return float(wing_majority[0] - wing_majority[1])", "def feature(board: chess.Board) -> float:\n    \"Measures the number of pawns advanced past the 4th rank for White and 3rd rank for Black.\"\n    advanced_pawns = sum(1 for square, piece in board.piece_map().items() if piece.piece_type == chess.PAWN and (\n        (piece.color == chess.WHITE and chess.square_rank(square) >= 4) or\n        (piece.color == chess.BLACK and chess.square_rank(square) <= 3)))\n    return float(advanced_pawns)", "def feature(board: chess.Board) -> float:\n    \"Counts the total number of pieces of both colors on the board.\"\n    total_pieces = len(board.piece_map())\n    return float(total_pieces)", "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in the number of total pieces between White and Black.\"\n    white_pieces = len([p for p in board.piece_map().values() if p.color == chess.WHITE])\n    black_pieces = len([p for p in board.piece_map().values() if p.color == chess.BLACK])\n    return float(white_pieces - black_pieces)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of squares controlled by each side.\"\n    white_control = sum(board.is_attacked_by(chess.WHITE, square) for square in chess.SQUARES)\n    black_control = sum(board.is_attacked_by(chess.BLACK, square) for square in chess.SQUARES)\n    return float(white_control - black_control)", "def feature(board: chess.Board) -> float:\n    \"Counts the mobility of the current player's pieces as the number of legal moves.\"\n    mobility = len(list(board.legal_moves))\n    return float(mobility)", "def feature(board: chess.Board) -> float:\n    \"Calculates the distance of the kings from the center of the board for both players.\"\n    white_king_square = next((sq for sq, p in board.piece_map().items() if p.piece_type == chess.KING and p.color == chess.WHITE), None)\n    black_king_square = next((sq for sq, p in board.piece_map().items() if p.piece_type == chess.KING and p.color == chess.BLACK), None)\n    white_distance = chess.square_distance(white_king_square, chess.E4)\n    black_distance = chess.square_distance(black_king_square, chess.E4)\n    return float(white_distance - black_distance)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of major pieces (rooks and queens) for the current player.\"\n    major_pieces_count = sum(1 for piece in board.piece_map().values() if piece.piece_type in [chess.ROOK, chess.QUEEN] and piece.color == board.turn)\n    return float(major_pieces_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the tempo based on the full move number.\"\n    return float(board.fullmove_number)", "def feature(board: chess.Board) -> float:\n    \"Evaluates if the current player's king is in check and returns a penalty.\"\n    return float(-1 if board.is_check() else 0)", "def feature(board: chess.Board) -> float:\n    \"Measures the difference in the number of pawns each player has on the board.\"\n    white_pawns = len([p for p in board.piece_map().values() if p.piece_type == chess.PAWN and p.color == chess.WHITE])\n    black_pawns = len([p for p in board.piece_map().values() if p.piece_type == chess.PAWN and p.color == chess.BLACK])\n    return float(white_pawns - black_pawns)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces for each player and computes the ratio.\"\n    white_pieces = len([p for p in board.piece_map().values() if p.color == chess.WHITE])\n    black_pieces = len([p for p in board.piece_map().values() if p.color == chess.BLACK])\n    return float(white_pieces / max(1, black_pieces))", "def feature(board: chess.Board) -> float:\n    \"Calculates the total value of the pieces on the board for each player.\"\n    piece_values = {chess.PAWN: 100, chess.KNIGHT: 320, chess.BISHOP: 330, chess.ROOK: 500, chess.QUEEN: 900, chess.KING: 20000}\n    white_value = sum(piece_values[p.piece_type] for p in board.piece_map().values() if p.color == chess.WHITE)\n    black_value = sum(piece_values[p.piece_type] for p in board.piece_map().values() if p.color == chess.BLACK)\n    return float(white_value - black_value)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of pieces that are currently attacking the opponent's king.\"\n    attackers_count = len(board.attackers(chess.BLACK, chess.parse_square('e8')))  # Assuming the black king is on e8\n    return float(attackers_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the mobility of the current player by counting legal moves.\"\n    mobility = len(list(board.legal_moves))\n    return float(mobility)", "def feature(board: chess.Board) -> float:\n    \"Calculates the ratio of minor pieces to total pieces for each player.\"\n    white_minor = len([p for p in board.piece_map().values() if p.color == chess.WHITE and p.piece_type in (chess.KNIGHT, chess.BISHOP)])\n    black_minor = len([p for p in board.piece_map().values() if p.color == chess.BLACK and p.piece_type in (chess.KNIGHT, chess.BISHOP)])\n    total_white = len([p for p in board.piece_map().values() if p.color == chess.WHITE])\n    total_black = len([p for p in board.piece_map().values() if p.color == chess.BLACK])\n    return float((white_minor / max(1, total_white)) - (black_minor / max(1, total_black)))", "def feature(board: chess.Board) -> float:\n    \"Counts the number of doubled pawns for both players.\"\n    def doubled_pawns(color):\n        pawns = [square for square, piece in board.piece_map().items() if piece.color == color and piece.piece_type == chess.PAWN]\n        files = [chess.square_file(pawn) for pawn in pawns]\n        return len(files) - len(set(files))\n    \n    white_doubled = doubled_pawns(chess.WHITE)\n    black_doubled = doubled_pawns(chess.BLACK)\n    return float(white_doubled - black_doubled)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of isolated pawns for the current player.\"\n    def is_isolated(color):\n        pawns = [square for square, piece in board.piece_map().items() if piece.color == color and piece.piece_type == chess.PAWN]\n        isolated = 0\n        for pawn in pawns:\n            file = chess.square_file(pawn)\n            if not ((file > 0 and board.piece_at(chess.square(pawn // 8, file - 1)) is None) and\n                     (file < 7 and board.piece_at(chess.square(pawn // 8, file + 1)) is None)):\n                isolated += 1\n        return isolated\n    \n    if board.turn == chess.WHITE:\n        return float(is_isolated(chess.WHITE))\n    else:\n        return float(-is_isolated(chess.BLACK))  # Return negative for black to keep consistent with evaluation direction", "def feature(board: chess.Board) -> float:\n    \"Counts pieces in the opponent's half of the board and returns the difference.\"\n    opponent_half_count = sum(1 for square, piece in board.piece_map().items() if \n                               piece.color == (chess.BLACK if board.turn == chess.WHITE else chess.WHITE) and chess.square_rank(square) >= 4)\n    return float(opponent_half_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of pieces attacking the opponent's king.\"\n    king_square = next(sq for sq, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color == (chess.WHITE if board.turn else chess.BLACK))\n    attackers = len(board.attackers(board.turn, king_square))\n    return float(attackers)", "def feature(board: chess.Board) -> float:\n    \"Counts the total number of pawns on the board.\"\n    total_pawns = sum(1 for piece in board.piece_map().values() if piece.piece_type == chess.PAWN)\n    return float(total_pawns)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of double attacked pieces (attacked by two opponent pieces).\"\n    double_attacked_count = sum(1 for square in board.piece_map() if (piece := board.piece_at(square)) and piece.color == board.turn and \n                                 len(board.attackers(not board.turn, square)) > 1)\n    return float(double_attacked_count)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of times the opponent's king can be attacked in the next turn.\"\n    king_square = next(sq for sq, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color == (chess.WHITE if board.turn else chess.BLACK))\n    possible_attacks = sum(1 for move in board.legal_moves if move.to_square == king_square)\n    return float(possible_attacks)", "def feature(board: chess.Board) -> float:\n    \"Calculates the ratio of minor pieces to major pieces for the player to move.\"\n    piece_counts = {chess.WHITE: {chess.PAWN: 0, chess.KNIGHT: 0, chess.BISHOP: 0, chess.ROOK: 0, chess.QUEEN: 0, chess.KING: 0},\n                    chess.BLACK: {chess.PAWN: 0, chess.KNIGHT: 0, chess.BISHOP: 0, chess.ROOK: 0, chess.QUEEN: 0, chess.KING: 0}}\n    \n    for piece in board.piece_map().values():\n        piece_counts[piece.color][piece.piece_type] += 1\n    \n    total_minors = piece_counts[board.turn][chess.KNIGHT] + piece_counts[board.turn][chess.BISHOP]\n    total_majors = piece_counts[board.turn][chess.ROOK] + piece_counts[board.turn][chess.QUEEN]\n    \n    return float(total_minors / (total_majors + 1))  # adding 1 to avoid division by zero", "def feature(board: chess.Board) -> float:\n    \"Counts how many squares the opponent's king can legally move.\"\n    king_square = next(sq for sq, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color == (chess.WHITE if not board.turn else chess.BLACK))\n    legal_moves = sum(1 for move in board.legal_moves if move.from_square == king_square)\n    return float(legal_moves)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of defended pieces for the current player.\"\n    defended_count = sum(1 for square in board.piece_map() if (piece := board.piece_at(square)) and piece.color == board.turn and \n                         any(board.is_attacked_by(not board.turn, square) for square in board.attackers(board.turn, square)))\n    return float(defended_count)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of potential pawn promotions (pawns reaching the opponent's back rank).\"\n    promotion_count = sum(1 for square in board.piece_map() if (piece := board.piece_at(square)) and piece.piece_type == chess.PAWN and \n                          (square // 8 == (0 if piece.color == chess.WHITE else 7)))\n    return float(promotion_count)", "def feature(board: chess.Board) -> float:\n    \"Counts the total number of pawns on the board.\"\n    num_pawns = sum(1 for piece in board.piece_map().values() if piece.piece_type == chess.PAWN)\n    return float(num_pawns)", "def feature(board: chess.Board) -> float:\n    \"Measures the distance of the closest piece to the opponent's king.\"\n    opponent_king = chess.KING if board.turn == chess.WHITE else chess.KING\n    opponent_king_square = next((sq for sq, p in board.piece_map().items() if p.piece_type == opponent_king and p.color != board.turn), None)\n    if opponent_king_square is None:\n        return float('inf')  # If no king is found, return a large distance\n    min_distance = min(chess.square_distance(sq, opponent_king_square) for sq, p in board.piece_map().items() if p.color == board.turn)\n    return float(min_distance)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces protected by other pieces.\"\n    protected_count = sum(1 for square in board.piece_map() if board.piece_at(square) and any(board.is_attacked_by(piece.color, square) for piece in board.piece_map().values() if piece.color != board.piece_at(square).color))\n    return float(protected_count)", "def feature(board: chess.Board) -> float:\n    \"Measures the central control by counting the number of pieces on central squares.\"\n    central_squares = {chess.E4, chess.E5, chess.D4, chess.D5}\n    central_control = sum(1 for square in central_squares if board.piece_at(square) is not None)\n    return float(central_control)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces on the back rank for each player and calculates their difference.\"\n    white_back_rank = sum(1 for square in range(chess.A1, chess.H1 + 1) if board.piece_at(square) and board.piece_at(square).color == chess.WHITE)\n    black_back_rank = sum(1 for square in range(chess.A8, chess.H8 + 1) if board.piece_at(square) and board.piece_at(square).color == chess.BLACK)\n    return float(white_back_rank - black_back_rank)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces attacking the opponent's pawns.\"\n    attacking_pawns_count = sum(1 for square in board.piece_map() if board.piece_at(square).piece_type == chess.PAWN and any(board.attackers(not board.piece_at(square).color, square)))\n    return float(attacking_pawns_count)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of pieces in the opponent's half of the board.\"\n    opponent_half = 4  # ranks 0 to 3 are considered the opponent's half for White, and 4 to 7 for Black\n    pieces_in_opponent_half = sum(1 for sq in board.piece_map() if ((board.turn == chess.WHITE and chess.square_rank(sq) < opponent_half) or \n                                                                      (board.turn == chess.BLACK and chess.square_rank(sq) >= opponent_half)))\n    return float(pieces_in_opponent_half)", "def feature(board: chess.Board) -> float:\n    \"Calculates the king safety by counting the number of squares around the king that are attacked.\"\n    king_square = next((sq for sq, p in board.piece_map().items() if p.piece_type == chess.KING and p.color == board.turn), None)\n    if king_square is None:\n        return 0.0  # If no king is found, return neutral safety\n    attacked_squares_around_king = sum(1 for offset in [-1, 0, 1] for offset2 in [-1, 0, 1] if (offset != 0 or offset2 != 0) and \n                                          0 <= chess.square_rank(king_square) + offset < 8 and \n                                          0 <= chess.square_file(king_square) + offset2 < 8 and \n                                          board.is_attacked_by(not board.turn, chess.square(king_square // 8 + offset, king_square % 8 + offset2)))\n    return float(attacked_squares_around_king)", "def feature(board: chess.Board) -> float:\n    \"Calculates the mobility by counting the total number of legal moves available to both players.\"\n    white_moves = len(list(board.legal_moves)) if board.turn == chess.WHITE else 0\n    black_moves = len(list(board.legal_moves)) if board.turn == chess.BLACK else 0\n    return float(white_moves - black_moves)", "def feature(board: chess.Board) -> float:\n    \"Evaluates the number of pawns each player has and returns the ratio.\"\n    white_pawns = len([p for p in board.piece_map().values() if p.color == chess.WHITE and p.piece_type == chess.PAWN])\n    black_pawns = len([p for p in board.piece_map().values() if p.color == chess.BLACK and p.piece_type == chess.PAWN])\n    return (white_pawns / (black_pawns + 1e-10)) if black_pawns > 0 else float('inf')", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces attacking the opponent's king.\"\n    attacking_pieces = sum(1 for square in board.piece_map() if board.is_attacked_by(not board.turn, square) and board.piece_at(square).color == board.turn)\n    return float(attacking_pieces)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of advanced pawns (pawns on ranks 4 or 5 for White, 4 or 3 for Black).\"\n    advanced_pawns = 0\n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.PAWN:\n            if (piece.color == chess.WHITE and chess.square_rank(square) >= 4) or (piece.color == chess.BLACK and chess.square_rank(square) <= 3):\n                advanced_pawns += 1\n    return float(advanced_pawns)", "def feature(board: chess.Board) -> float:\n    \"Calculates the total number of safe squares available for each side.\"\n    safe_squares_white = sum(1 for square in board.piece_map() if board.is_attacked_by(chess.BLACK, square) == False and board.piece_at(square).color == chess.WHITE)\n    safe_squares_black = sum(1 for square in board.piece_map() if board.is_attacked_by(chess.WHITE, square) == False and board.piece_at(square).color == chess.BLACK)\n    return float(safe_squares_white - safe_squares_black)", "def feature(board: chess.Board) -> float:\n    \"Calculates the total value of pieces for each player and returns the difference.\"\n    piece_values = {chess.PAWN: 100, chess.KNIGHT: 320, chess.BISHOP: 330, chess.ROOK: 500, chess.QUEEN: 900, chess.KING: 20000}\n    white_value = sum(piece_values[piece.piece_type] for piece in board.piece_map().values() if piece.color == chess.WHITE)\n    black_value = sum(piece_values[piece.piece_type] for piece in board.piece_map().values() if piece.color == chess.BLACK)\n    return float(white_value - black_value)", "def feature(board: chess.Board) -> float:\n    \"Measures the total number of pawns that are connected.\"\n    connected_pawns = 0\n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.PAWN:\n            file = chess.square_file(square)\n            rank = chess.square_rank(square)\n            if (board.piece_at(chess.square(file - 1, rank)) and board.piece_at(chess.square(file - 1, rank)).piece_type == chess.PAWN and\n                board.piece_at(chess.square(file - 1, rank)).color == piece.color) or \\\n               (board.piece_at(chess.square(file + 1, rank)) and board.piece_at(chess.square(file + 1, rank)).piece_type == chess.PAWN and\n                board.piece_at(chess.square(file + 1, rank)).color == piece.color):\n                connected_pawns += 1\n    return float(connected_pawns)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces occupying the back rank and returns this value.\"\n    back_rank_pieces = sum(1 for square in range(chess.A8, chess.H8 + 1) if board.piece_at(square) and board.piece_at(square).color == chess.BLACK) + \\\n                       sum(1 for square in range(chess.A1, chess.H1 + 1) if board.piece_at(square) and board.piece_at(square).color == chess.WHITE)\n    return float(back_rank_pieces)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of pieces that can deliver check in the next move.\"\n    checkable_pieces = sum(1 for move in board.legal_moves if board.is_check())\n    return float(checkable_pieces)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pawns on the 6th and 7th ranks for each player.\"\n    white_pawns = sum(1 for sq in board.piece_map() if board.piece_at(sq).piece_type == chess.PAWN and chess.square_rank(sq) >= 6 and board.piece_at(sq).color == chess.WHITE)\n    black_pawns = sum(1 for sq in board.piece_map() if board.piece_at(sq).piece_type == chess.PAWN and chess.square_rank(sq) <= 1 and board.piece_at(sq).color == chess.BLACK)\n    return float(white_pawns - black_pawns)", "def feature(board: chess.Board) -> float:\n    \"Calculates the total value of pieces on the board.\"\n    values = {chess.PAWN: 100, chess.KNIGHT: 300, chess.BISHOP: 300, chess.ROOK: 500, chess.QUEEN: 900, chess.KING: 0}\n    total_value = sum(values[piece.piece_type] for piece in board.piece_map().values())\n    return float(total_value)", "def feature(board: chess.Board) -> float:\n    \"Evaluates the potential for promotion by counting advanced pawns.\"\n    advanced_pawn_count = sum(1 for square in board.piece_map() if (board.piece_at(square).piece_type == chess.PAWN and\n                                                                     ((board.piece_at(square).color == chess.WHITE and chess.square_rank(square) >= 5) or\n                                                                      (board.piece_at(square).color == chess.BLACK and chess.square_rank(square) <= 2))))\n    return float(advanced_pawn_count)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces that are currently not defended.\"\n    undefended_count = sum(1 for square in board.piece_map() if board.is_attacked_by(not board.piece_at(square).color, square) and board.piece_at(square) is not None)\n    return float(undefended_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the distance from the king to the center of the board.\"\n    white_king = next((sq for sq in board.piece_map() if board.piece_at(sq).piece_type == chess.KING and board.piece_at(sq).color == chess.WHITE), None)\n    black_king = next((sq for sq in board.piece_map() if board.piece_at(sq).piece_type == chess.KING and board.piece_at(sq).color == chess.BLACK), None)\n    if white_king and black_king:\n        white_distance = chess.square_distance(white_king, chess.E4) + chess.square_distance(white_king, chess.D4)\n        black_distance = chess.square_distance(black_king, chess.E5) + chess.square_distance(black_king, chess.D5)\n        return float(white_distance - black_distance)\n    return 0.0", "def feature(board: chess.Board) -> float:\n    \"Evaluates the number of potential threats by counting pieces threatening enemy pieces.\"\n    threat_count = sum(1 for square in board.piece_map() if any(board.is_attacked_by(board.piece_at(square).color, attacked_square) for attacked_square in board.attackers(not board.piece_at(square).color, square)))\n    return float(threat_count)", "def feature(board: chess.Board) -> float:\n    \"Counts the total number of pieces for each color and computes the difference.\"\n    white_piece_count = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE)\n    black_piece_count = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK)\n    return float(white_piece_count - black_piece_count)", "def feature(board: chess.Board) -> float:\n    \"Counts the total number of vulnerable pieces on the board (pieces that are attacked by an opponent).\"\n    vulnerable_count = sum(1 for square, piece in board.piece_map().items() if board.is_attacked_by(not piece.color, square))\n    return float(vulnerable_count)", "def feature(board: chess.Board) -> float:\n    \"Measures the distance from the king to the nearest opposing piece for the currently active player.\"\n    active_color = board.turn\n    active_king_square = None\n    nearest_distance = float('inf')\n    \n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.KING and piece.color == active_color:\n            active_king_square = square\n            break\n    \n    for square, piece in board.piece_map().items():\n        if piece.color != active_color:\n            distance = chess.square_distance(active_king_square, square)\n            nearest_distance = min(nearest_distance, distance)\n    \n    return float(nearest_distance)", "def feature(board: chess.Board) -> float:\n    \"Calculates the mobility of the active player by counting the number of legal moves available.\"\n    mobility = len(list(board.legal_moves))\n    return float(mobility)", "def feature(board: chess.Board) -> float:\n    \"Measures the total material value of the pieces on board excluding pawns.\"\n    piece_values = {chess.PAWN: 1, chess.KNIGHT: 3, chess.BISHOP: 3, chess.ROOK: 5, chess.QUEEN: 9, chess.KING: 0}\n    total_value = sum(piece_values[piece.piece_type] for piece in board.piece_map().values())\n    return float(total_value)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of pieces on the seventh rank for each player, giving a stronger indication of position.\"\n    white_seventh_rank = sum(1 for square in board.piece_map() if board.piece_at(square).color == chess.WHITE and chess.square_rank(square) == 6)\n    black_seventh_rank = sum(1 for square in board.piece_map() if board.piece_at(square).color == chess.BLACK and chess.square_rank(square) == 1)\n    return float(white_seventh_rank - black_seventh_rank)", "def feature(board: chess.Board) -> float:\n    \"Evaluates the number of pieces within two squares of the center of the board (d4, d5, e4, e5).\"\n    central_squares = {chess.D4, chess.D5, chess.E4, chess.E5}\n    central_pieces_count = sum(1 for square in central_squares if board.piece_at(square) is not None)\n    return float(central_pieces_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the total number of advanced pawns (pawns in ranks 4 or 5 for White and 4 or 3 for Black).\"\n    advanced_pawns = 0\n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.PAWN:\n            rank = chess.square_rank(square)\n            if (piece.color == chess.WHITE and rank >= 3) or (piece.color == chess.BLACK and rank <= 4):\n                advanced_pawns += 1\n    return float(advanced_pawns)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of passed pawns for the active player.\"\n    passed_pawns = 0\n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.PAWN and piece.color == board.turn:\n            if (piece.color == chess.WHITE and chess.square_rank(square) >= 4) or \\\n               (piece.color == chess.BLACK and chess.square_rank(square) <= 3):\n                if not any(board.is_attacked_by(not piece.color, att_square) for att_square in board.attackers(not piece.color, square)):\n                    passed_pawns += 1\n    return float(passed_pawns)", "def feature(board: chess.Board) -> float:\n    \"Measures the king safety by counting the number of pawns around the king.\"\n    king_square = next(sq for sq, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color == board.turn)\n    safe_pawns = sum(1 for sq in board.piece_map() if board.piece_at(sq) and board.piece_at(sq).piece_type == chess.PAWN and \n                     abs(chess.square_file(sq) - chess.square_file(king_square)) <= 1 and \n                     abs(chess.square_rank(sq) - chess.square_rank(king_square)) <= 1)\n    return float(safe_pawns)", "def feature(board: chess.Board) -> float:\n    \"Calculates the distance of the active player's pieces from the opponent's back rank.\"\n    distance_sum = 0\n    active_color = board.turn\n    for square, piece in board.piece_map().items():\n        if piece.color == active_color:\n            distance = 7 - chess.square_rank(square) if active_color == chess.WHITE else chess.square_rank(square)\n            distance_sum += distance\n    return float(distance_sum)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces in the endgame stage (less than 10 pieces total).\"\n    total_pieces = len(board.piece_map())\n    return float(total_pieces <= 10)", "def feature(board: chess.Board) -> float:\n    \"Calculates the total number of pieces the opponent has attacked.\"\n    attacking_pieces_count = sum(len(board.attackers(not board.turn, sq)) for sq in board.piece_map() if board.piece_at(sq) and board.piece_at(sq).color == board.turn)\n    return float(attacking_pieces_count)", "def feature(board: chess.Board) -> float:\n    \"Measures the control of the center squares (d4, d5, e4, e5) by the active player.\"\n    center_squares = [chess.D4, chess.D5, chess.E4, chess.E5]\n    control_count = sum(1 for sq in center_squares if len(board.attackers(board.turn, sq)) > 0)\n    return float(control_count)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of knight pieces on the board for the active player.\"\n    knight_count = sum(1 for square, piece in board.piece_map().items() if piece.color == board.turn and piece.piece_type == chess.KNIGHT)\n    return float(knight_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in the number of pawns for each player.\"\n    white_pawns = sum(1 for piece in board.piece_map().values() if piece.piece_type == chess.PAWN and piece.color == chess.WHITE)\n    black_pawns = sum(1 for piece in board.piece_map().values() if piece.piece_type == chess.PAWN and piece.color == chess.BLACK)\n    return float(white_pawns - black_pawns)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of squares controlled by the active player.\"\n    controlled_squares = sum(len(board.attackers(board.turn, sq)) > 0 for sq in chess.SQUARES)\n    return float(controlled_squares)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of pawns on the 4th and 5th ranks for White and 3rd and 4th ranks for Black.\"\n    white_advanced_pawns = sum(1 for sq in board.piece_map() \n                                if board.piece_at(sq).color == chess.WHITE and chess.square_rank(sq) >= 4)\n    black_advanced_pawns = sum(1 for sq in board.piece_map() \n                                if board.piece_at(sq).color == chess.BLACK and chess.square_rank(sq) <= 4)\n    return float(white_advanced_pawns - black_advanced_pawns)", "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in the number of pieces currently on the board.\"\n    white_pieces = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE)\n    black_pieces = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK)\n    return float(white_pieces - black_pieces)", "def feature(board: chess.Board) -> float:\n    \"Measures the total distance of all pieces from the center of the board.\"\n    center_square = [chess.E4, chess.E5, chess.D4, chess.D5]\n    total_distance = sum(chess.square_distance(sq, center_sq) \n                         for sq in board.piece_map() \n                         for center_sq in center_square)\n    return float(total_distance)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of pieces that are pinned by the opponent's pieces.\"\n    pinned_pieces_count = sum(1 for square in board.piece_map() \n                               if board.is_attacked_by(not board.turn, square) \n                               and any((move.to_square == square for move in board.legal_moves)))\n    return float(pinned_pieces_count)", "def feature(board: chess.Board) -> float:\n    \"Measures the centralization of pieces on the board.\"\n    central_squares = {chess.D4, chess.D5, chess.E4, chess.E5}\n    central_piece_count = sum(1 for square in board.piece_map() \n                               if square in central_squares)\n    return float(central_piece_count)", "def feature(board: chess.Board) -> float:\n    \"Counts the pieces remaining for each color and returns the ratio.\"\n    total_white = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE)\n    total_black = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK)\n    return float(total_white / (total_black + 1e-5))", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces attacked by the opponent in the opponent's territory.\"\n    opponent = chess.BLACK if board.turn else chess.WHITE\n    attacked_count = sum(1 for square in board.piece_map() if board.is_attacked_by(opponent, square))\n    return float(attacked_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the total number of pawns for each side, giving a ratio to assess pawn structure.\"\n    white_pawns = len([p for p in board.piece_map().values() if p.color == chess.WHITE and p.piece_type == chess.PAWN])\n    black_pawns = len([p for p in board.piece_map().values() if p.color == chess.BLACK and p.piece_type == chess.PAWN])\n    return float(white_pawns / (black_pawns + 1))", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces that have mobility (legal moves) on the board.\"\n    mobile_pieces = sum(1 for _ in board.legal_moves)\n    return float(mobile_pieces)", "def feature(board: chess.Board) -> float:\n    \"Measures the difference in the number of major pieces (rooks, queens) on the board.\"\n    white_major = len([p for p in board.piece_map().values() if p.color == chess.WHITE and p.piece_type in (chess.ROOK, chess.QUEEN)])\n    black_major = len([p for p in board.piece_map().values() if p.color == chess.BLACK and p.piece_type in (chess.ROOK, chess.QUEEN)])\n    return float(white_major - black_major)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of squares occupied by the opponent's pawns in the player's back rank.\"\n    back_rank = 7 if board.turn else 0\n    opponent_pawns = [square for square, piece in board.piece_map().items() \n                      if piece.color != board.turn and piece.piece_type == chess.PAWN and chess.square_rank(square) == back_rank]\n    return float(len(opponent_pawns))", "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in the number of pieces within the center four squares.\"\n    center_squares = [chess.E4, chess.E5, chess.D4, chess.D5]\n    center_count = sum(1 for square in center_squares if board.piece_at(square) is not None)\n    return float(center_count)", "def feature(board: chess.Board) -> float:\n    \"Examines the number of pieces that are pinned by the opponent's pieces.\"\n    pinned_count = sum(1 for square in board.piece_map() if board.is_attacked_by(board.turn, square) and board.piece_at(square))\n    return float(pinned_count)", "def feature(board: chess.Board) -> float:\n    \"Measures the mobility of the last moved piece, indicated by its available legal moves.\"\n    last_move = board.fullmove_number % 2 == (0 if board.turn else 1)\n    if last_move:\n        last_piece_square = next((square for square in board.piece_map() if board.piece_at(square) is not None), None)\n        if last_piece_square:\n            return float(len(list(board.legal_moves)))\n    return 0.0", "def feature(board: chess.Board) -> float:\n    \"Computes a score based on the number of squares away the opponent's king is from the player's pieces.\"\n    opponent_king_square = next(square for square, piece in board.piece_map().items() \n                                 if piece.piece_type == chess.KING and piece.color != board.turn)\n    distance_sum = sum(chess.square_distance(square, opponent_king_square) for square in board.piece_map() if board.piece_at(square).color == board.turn)\n    return float(distance_sum)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of pawns for each player and computes the ratio of pawns on the board.\"\n    white_pawns = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE and piece.piece_type == chess.PAWN)\n    black_pawns = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK and piece.piece_type == chess.PAWN)\n    total_pawns = white_pawns + black_pawns\n    if total_pawns == 0:\n        return 0.0\n    return white_pawns / total_pawns", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces that can potentially be promoted for both players.\"\n    white_promotable = sum(1 for square, piece in board.piece_map().items() if piece.color == chess.WHITE and piece.piece_type == chess.PAWN and chess.square_rank(square) == 6)\n    black_promotable = sum(1 for square, piece in board.piece_map().items() if piece.color == chess.BLACK and piece.piece_type == chess.PAWN and chess.square_rank(square) == 1)\n    return float(white_promotable - black_promotable)", "def feature(board: chess.Board) -> float:\n    \"Measures the distance of each player's king from the center of the board.\"\n    white_king_square = next(square for square, piece in board.piece_map().items() if piece.color == chess.WHITE and piece.piece_type == chess.KING)\n    black_king_square = next(square for square, piece in board.piece_map().items() if piece.color == chess.BLACK and piece.piece_type == chess.KING)\n    white_distance = chess.square_distance(white_king_square, chess.parse_square('e4')) # Center square\n    black_distance = chess.square_distance(black_king_square, chess.parse_square('e4'))\n    return float(black_distance - white_distance)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces that are in the opponent's territory for both players.\"\n    white_in_enemy_territory = sum(1 for square, piece in board.piece_map().items() if piece.color == chess.WHITE and chess.square_rank(square) > 4)\n    black_in_enemy_territory = sum(1 for square, piece in board.piece_map().items() if piece.color == chess.BLACK and chess.square_rank(square) < 3)\n    return float(white_in_enemy_territory - black_in_enemy_territory)", "def feature(board: chess.Board) -> float:\n    \"Calculates the maximum distance between the two kings on the board.\"\n    white_king_square = next(square for square, piece in board.piece_map().items() if piece.color == chess.WHITE and piece.piece_type == chess.KING)\n    black_king_square = next(square for square, piece in board.piece_map().items() if piece.color == chess.BLACK and piece.piece_type == chess.KING)\n    return float(chess.square_distance(white_king_square, black_king_square))", "def feature(board: chess.Board) -> float:\n    \"Measures the control of the center squares by counting pieces occupying or attacking them.\"\n    center_squares = [chess.E4, chess.E5, chess.D4, chess.D5]\n    white_control = sum(1 for square in center_squares if board.is_attacked_by(chess.WHITE, square) or square in board.piece_map() and board.piece_map()[square].color == chess.WHITE)\n    black_control = sum(1 for square in center_squares if board.is_attacked_by(chess.BLACK, square) or square in board.piece_map() and board.piece_map()[square].color == chess.BLACK)\n    return float(white_control - black_control)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of major pieces (rooks and queens) for both players.\"\n    white_major = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE and piece.piece_type in {chess.ROOK, chess.QUEEN})\n    black_major = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK and piece.piece_type in {chess.ROOK, chess.QUEEN})\n    return float(white_major - black_major)", "def feature(board: chess.Board) -> float:\n    \"Measures the connectivity of pawns (counts isolated pawns) for both players.\"\n    isolated_pawns = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == chess.WHITE and piece.piece_type == chess.PAWN:\n            file = chess.square_file(square)\n            if not (board.piece_at(chess.parse_square(chess.square_name(square)[0] + str(chess.square_rank(square) + 1))) is not None or\n                    board.piece_at(chess.parse_square(chess.square_name(square)[0] + str(chess.square_rank(square) - 1))) is not None):\n                isolated_pawns += 1\n        elif piece.color == chess.BLACK and piece.piece_type == chess.PAWN:\n            file = chess.square_file(square)\n            if not (board.piece_at(chess.parse_square(chess.square_name(square)[0] + str(chess.square_rank(square) + 1))) is not None or\n                    board.piece_at(chess.parse_square(chess.square_name(square)[0] + str(chess.square_rank(square) - 1))) is not None):\n                isolated_pawns += 1\n    return float(isolated_pawns)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of pieces each player has on the back rank.\"\n    white_back_rank = sum(1 for square in range(chess.A1, chess.H1 + 1) if board.piece_at(square) and board.piece_at(square).color == chess.WHITE)\n    black_back_rank = sum(1 for square in range(chess.A8, chess.H8 + 1) if board.piece_at(square) and board.piece_at(square).color == chess.BLACK)\n    return float(white_back_rank - black_back_rank)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of squares attacked by each player's pieces.\"\n    white_attacks = sum(1 for square in chess.SQUARES if board.is_attacked_by(chess.WHITE, square))\n    black_attacks = sum(1 for square in chess.SQUARES if board.is_attacked_by(chess.BLACK, square))\n    return float(white_attacks - black_attacks)", "def feature(board: chess.Board) -> float:\n    \"Measures the mobility of pieces by counting the number of legal moves.\"\n    return float(len(list(board.legal_moves)))", "def feature(board: chess.Board) -> float:\n    \"Counts the number of attacked squares for each player and calculates the ratio.\"\n    white_attacks = sum(1 for square in board.piece_map() if board.piece_at(square).color == chess.WHITE and board.is_attacked_by(chess.BLACK, square))\n    black_attacks = sum(1 for square in board.piece_map() if board.piece_at(square).color == chess.BLACK and board.is_attacked_by(chess.WHITE, square))\n    return float(white_attacks) / (black_attacks + 1)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pawns on the seventh rank for both players.\"\n    white_seventh_rank = sum(1 for square in board.piece_map() if board.piece_at(square).color == chess.WHITE and chess.square_rank(square) == 6)\n    black_seventh_rank = sum(1 for square in board.piece_map() if board.piece_at(square).color == chess.BLACK and chess.square_rank(square) == 1)\n    return float(white_seventh_rank - black_seventh_rank)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of attacking pieces for each player and returns the difference.\"\n    white_attacking_pieces = sum(1 for square in board.piece_map() if board.piece_at(square).color == chess.WHITE and any(board.is_attacked_by(chess.BLACK, target) for target in board.attackers(chess.BLACK, square)))\n    black_attacking_pieces = sum(1 for square in board.piece_map() if board.piece_at(square).color == chess.BLACK and any(board.is_attacked_by(chess.WHITE, target) for target in board.attackers(chess.WHITE, square)))\n    return float(white_attacking_pieces - black_attacking_pieces)", "def feature(board: chess.Board) -> float:\n    \"Calculates the distance of all pieces from the center of the board.\"\n    center_squares = [chess.E4, chess.E5, chess.D4, chess.D5]\n    distance_sum = 0\n    for square in board.piece_map():\n        piece = board.piece_at(square)\n        if piece:\n            distance_sum += min(chess.square_distance(square, cs) for cs in center_squares)\n    return float(1 / (distance_sum + 1))", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces on the back ranks for both players.\"\n    white_back_rank = sum(1 for square in board.piece_map() if board.piece_at(square).color == chess.WHITE and chess.square_rank(square) == 7)\n    black_back_rank = sum(1 for square in board.piece_map() if board.piece_at(square).color == chess.BLACK and chess.square_rank(square) == 0)\n    return float(white_back_rank - black_back_rank)", "def feature(board: chess.Board) -> float:\n    \"Evaluates the control of the center squares (d4, d5, e4, e5) for both players.\"\n    center_squares = [chess.D4, chess.D5, chess.E4, chess.E5]\n    white_control = sum(1 for sq in center_squares if board.is_attacked_by(chess.WHITE, sq))\n    black_control = sum(1 for sq in center_squares if board.is_attacked_by(chess.BLACK, sq))\n    return float(white_control - black_control)", "def feature(board: chess.Board) -> float:\n    \"Measures the difference in the number of rook pairs (two rooks on the same file) for each player.\"\n    def rook_pairs(color):\n        return sum(1 for file in range(8) if sum(1 for rank in range(8) if board.piece_at(chess.square(file, rank)) and board.piece_at(chess.square(file, rank)).color == color and board.piece_at(chess.square(file, rank)).piece_type == chess.ROOK) > 1)\n\n    white_pairs = rook_pairs(chess.WHITE)\n    black_pairs = rook_pairs(chess.BLACK)\n    return float(white_pairs - black_pairs)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pawns on the board for both players and returns their difference.\"\n    white_pawns = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE and piece.piece_type == chess.PAWN)\n    black_pawns = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK and piece.piece_type == chess.PAWN)\n    return float(white_pawns - black_pawns)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of pieces in danger, defined as pieces that are attacked.\"\n    threatened_pieces = sum(1 for square, piece in board.piece_map().items() if board.is_attacked_by(not piece.color, square))\n    return float(threatened_pieces)", "def feature(board: chess.Board) -> float:\n    \"Calculates the average distance of all pieces from the center of the board (d4, e4, d5, e5).\"\n    center_squares = [chess.parse_square('d4'), chess.parse_square('e4'), chess.parse_square('d5'), chess.parse_square('e5')]\n    total_distance = sum(chess.square_distance(square, center) for square in board.piece_map() for center in center_squares)\n    piece_count = len(board.piece_map())\n    return float(total_distance / piece_count) if piece_count > 0 else 0.0", "def feature(board: chess.Board) -> float:\n    \"Counts the number of open ranks for all pieces, where open ranks are those with no opposing pawns.\"\n    open_ranks = set()\n    for rank in range(8):\n        if not any(board.piece_at(chess.square(file, rank)) is not None and board.piece_at(chess.square(file, rank)).piece_type == chess.PAWN\n                   for file in range(8)):\n            open_ranks.add(rank)\n    return float(len(open_ranks))", "def feature(board: chess.Board) -> float:\n    \"Evaluates the material balance focusing on major pieces (rooks and queens) only.\"\n    material_value = 0\n    for piece in board.piece_map().values():\n        if piece.piece_type in [chess.ROOK, chess.QUEEN]:\n            material_value += 5 if piece.color == chess.WHITE else -5\n    return float(material_value)", "def feature(board: chess.Board) -> float:\n    \"Calculates the attack density, the number of attackers for each piece on the board.\"\n    total_attack_density = sum(len(board.attackers(piece.color, square)) for square, piece in board.piece_map().items())\n    total_pieces = len(board.piece_map())\n    return float(total_attack_density / total_pieces) if total_pieces > 0 else 0.0", "def feature(board: chess.Board) -> float:\n    \"Measures the distance of the kings to their respective corners.\"\n    white_king_square = next(square for square, piece in board.piece_map().items() if piece.color == chess.WHITE and piece.piece_type == chess.KING)\n    black_king_square = next(square for square, piece in board.piece_map().items() if piece.color == chess.BLACK and piece.piece_type == chess.KING)\n    white_king_distance = min(chess.square_distance(white_king_square, chess.parse_square('a1')),\n                               chess.square_distance(white_king_square, chess.parse_square('h1')))\n    black_king_distance = min(chess.square_distance(black_king_square, chess.parse_square('a8')),\n                               chess.square_distance(black_king_square, chess.parse_square('h8')))\n    return float(white_king_distance - black_king_distance)", "def feature(board: chess.Board) -> float:\n    \"Calculates the control over the center squares by counting the pieces attacking them.\"\n    center_squares = [chess.parse_square('d4'), chess.parse_square('e4'), chess.parse_square('d5'), chess.parse_square('e5')]\n    control = sum(1 for square in center_squares if board.is_attacked_by(chess.WHITE, square)) - \\\n              sum(1 for square in center_squares if board.is_attacked_by(chess.BLACK, square))\n    return float(control)", "def feature(board: chess.Board) -> float:\n    \"Evaluates the number of pawns passed for each color.\"\n    white_passed = sum(1 for square in board.piece_map() if board.piece_map()[square].color == chess.WHITE and \n                       (board.piece_at(square).piece_type == chess.PAWN) and \n                       all(board.piece_at(chess.square(file, chess.square_rank(square))) is None\n                           for file in range(chess.square_file(square) + 1, 8)))\n    black_passed = sum(1 for square in board.piece_map() if board.piece_map()[square].color == chess.BLACK and \n                       (board.piece_at(square).piece_type == chess.PAWN) and \n                       all(board.piece_at(chess.square(file, chess.square_rank(square))) is None\n                           for file in range(0, chess.square_file(square))))\n    return float(white_passed - black_passed)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces on the back ranks.\"\n    back_rank_count_white = sum(1 for square in range(56, 64) if board.piece_at(square) is not None)\n    back_rank_count_black = sum(1 for square in range(0, 8) if board.piece_at(square) is not None)\n    return float(back_rank_count_white - back_rank_count_black)", "def feature(board: chess.Board) -> float:\n    \"Calculates the total value of pieces on the board for each player.\"\n    piece_values = {chess.PAWN: 100, chess.KNIGHT: 300, chess.BISHOP: 300, \n                    chess.ROOK: 500, chess.QUEEN: 900, chess.KING: 0}\n    total_value_white = sum(piece_values[piece.piece_type] for piece in board.piece_map().values() if piece.color == chess.WHITE)\n    total_value_black = sum(piece_values[piece.piece_type] for piece in board.piece_map().values() if piece.color == chess.BLACK)\n    return float(total_value_white - total_value_black)", "def feature(board: chess.Board) -> float:\n    \"Calculates the mobility for each player by counting legal moves.\"\n    legal_moves_white = len(list(board.legal_moves) if board.turn else [])\n    legal_moves_black = len(list(board.legal_moves) if not board.turn else [])\n    return float(legal_moves_white - legal_moves_black)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of doubled pawns for each player.\"\n    pawn_positions_white = [square for square in board.piece_map() if board.piece_map()[square].color == chess.WHITE and board.piece_map()[square].piece_type == chess.PAWN]\n    pawn_positions_black = [square for square in board.piece_map() if board.piece_map()[square].color == chess.BLACK and board.piece_map()[square].piece_type == chess.PAWN]\n\n    doubled_pawns_white = sum(1 for file in range(8) if sum(1 for square in pawn_positions_white if chess.square_file(square) == file) > 1)\n    doubled_pawns_black = sum(1 for file in range(8) if sum(1 for square in pawn_positions_black if chess.square_file(square) == file) > 1)\n\n    return float(doubled_pawns_white - doubled_pawns_black)", "def feature(board: chess.Board) -> float:\n    \"Measures the presence of pieces on central squares.\"\n    central_squares = [chess.E4, chess.E5, chess.D4, chess.D5]\n    central_piece_count_white = sum(1 for square in central_squares if board.piece_at(square) is not None and board.piece_at(square).color == chess.WHITE)\n    central_piece_count_black = sum(1 for square in central_squares if board.piece_at(square) is not None and board.piece_at(square).color == chess.BLACK)\n    return float(central_piece_count_white - central_piece_count_black)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of pieces with open lines to the opponent's king.\"\n    open_lines_white = sum(1 for square in board.piece_map() if board.piece_map()[square].color == chess.WHITE and board.is_attacked_by(chess.BLACK, square))\n    open_lines_black = sum(1 for square in board.piece_map() if board.piece_map()[square].color == chess.BLACK and board.is_attacked_by(chess.WHITE, square))\n    return float(open_lines_white - open_lines_black)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of pawns on the board for both players as a balance factor.\"\n    white_pawns = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE and piece.piece_type == chess.PAWN)\n    black_pawns = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK and piece.piece_type == chess.PAWN)\n    return float(white_pawns - black_pawns)", "def feature(board: chess.Board) -> float:\n    \"Calculates the total number of squares controlled by each player.\"\n    control_white = sum(1 for square in chess.SQUARES if board.is_attacked_by(chess.WHITE, square))\n    control_black = sum(1 for square in chess.SQUARES if board.is_attacked_by(chess.BLACK, square))\n    return float(control_white - control_black)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces attacking the opponent's back rank.\"\n    attacking_white = sum(1 for square in chess.SQUARES if board.is_attacked_by(chess.WHITE, square) and chess.square_rank(square) == 0)\n    attacking_black = sum(1 for square in chess.SQUARES if board.is_attacked_by(chess.BLACK, square) and chess.square_rank(square) == 7)\n    return float(attacking_white - attacking_black)", "def feature(board: chess.Board) -> float:\n    \"Measures the distance of the king(s) to their respective back rank.\"\n    def king_distance(color):\n        for square in board.piece_map():\n            piece = board.piece_at(square)\n            if piece and piece.piece_type == chess.KING and piece.color == color:\n                return 7 - chess.square_rank(square) if color == chess.WHITE else chess.square_rank(square)\n        return 0\n    \n    white_distance = king_distance(chess.WHITE)\n    black_distance = king_distance(chess.BLACK)\n    return float(white_distance - black_distance)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces on the board that are unprotected (attacked but without defenders).\"\n    unprotected_pieces = 0\n    for square, piece in board.piece_map().items():\n        if board.is_attacked_by(not piece.color, square):\n            if not any(board.is_attacked_by(piece.color, attacker_square) for attacker_square in board.attackers(piece.color, square)):\n                unprotected_pieces += 1\n    return float(unprotected_pieces)", "def feature(board: chess.Board) -> float:\n    \"Measures the control of central squares (e4, e5, d4, d5) by both players.\"\n    central_squares = [chess.parse_square(square) for square in ['e4', 'e5', 'd4', 'd5']]\n    control_white = sum(1 for square in central_squares if board.is_attacked_by(chess.WHITE, square))\n    control_black = sum(1 for square in central_squares if board.is_attacked_by(chess.BLACK, square))\n    return float(control_white - control_black)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of pieces on the 7th rank for both players.\"\n    white_seven = sum(1 for square in chess.SQUARES if board.piece_at(square) and \n                      board.piece_at(square).color == chess.WHITE and chess.square_rank(square) == 6)\n    black_seven = sum(1 for square in chess.SQUARES if board.piece_at(square) and \n                      board.piece_at(square).color == chess.BLACK and chess.square_rank(square) == 1)\n    return float(white_seven - black_seven)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of pieces that are pinned (unable to move without exposing the king).\"\n    pinned_pieces = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == board.turn:\n            for attacking_square in board.attackers(not piece.color, square):\n                if board.piece_at(attacking_square) and board.piece_at(attacking_square).color != piece.color:\n                    pinned_pieces += 1\n                    break\n    return float(pinned_pieces)", "def feature(board: chess.Board) -> float:\n    \"Calculates the distance from each pawn to the opponent's back rank.\"\n    distance_sum = 0\n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.PAWN:\n            target_rank = 0 if piece.color == chess.WHITE else 7\n            distance_sum += chess.square_rank(square) - target_rank\n    return float(distance_sum)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces that are pinned to a king.\"\n    pinned_count = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == board.turn:\n            if board.is_attacked_by(not piece.color, square):\n                pinned_count += 1\n    return float(pinned_count)", "def feature(board: chess.Board) -> float:\n    \"Measures the average mobility of all pieces on the board.\"\n    mobility_scores = []\n    for square, piece in board.piece_map().items():\n        mobility_scores.append(len(list(board.legal_moves for _ in board.legal_moves if board.piece_at(square) == piece)))\n    return float(sum(mobility_scores)) / len(mobility_scores) if mobility_scores else 0.0", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of squares controlled by pawns, influencing territory.\"\n    controlled_count = 0\n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.PAWN:\n            controlled_count += len(board.attackers(not piece.color, square))\n    return float(controlled_count)", "def feature(board: chess.Board) -> float:\n    \"Assesses king safety by counting number of squares around each king attacked by opposite pieces.\"\n    king_safety = 0\n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.KING:\n            attacked_squares = sum(board.is_attacked_by(not piece.color, sq) for sq in chess.SQUARES[square - 9:square + 10:8])\n            king_safety += attacked_squares\n    return float(king_safety)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces on the last two ranks, which can signify an advantage in control.\"\n    piece_count = sum(1 for square, piece in board.piece_map().items() if chess.square_rank(square) >= 6)\n    return float(piece_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in the number of open files for rooks.\"\n    white_rooks, black_rooks = 0, 0\n    for file in range(8):\n        if all(board.piece_at(chess.square(file, rank)) is None for rank in range(8)):\n            white_rooks += 1 if any(board.piece_at(chess.square(file, rank)).color == chess.WHITE for rank in range(8) if board.piece_at(chess.square(file, rank))) else 0\n            black_rooks += 1 if any(board.piece_at(chess.square(file, rank)).color == chess.BLACK for rank in range(8) if board.piece_at(chess.square(file, rank))) else 0\n    return float(white_rooks - black_rooks)", "def feature(board: chess.Board) -> float:\n    \"Counts the total number of defending pieces around both kings.\"\n    king_defense = 0\n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.KING:\n            for sq in chess.SQUARES[square - 9:square + 10:8]:\n                if board.is_attacked_by(not piece.color, sq):\n                    king_defense += 1\n    return float(king_defense)", "def feature(board: chess.Board) -> float:\n    \"Calculates the material imbalance considering the positions of the bishops.\"\n    bishop_count = 0\n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.BISHOP:\n            bishop_count += 1 if piece.color == board.turn else -1\n    return float(bishop_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in the number of pieces for each player on the board.\"\n    white_count = sum(1 for p in board.piece_map().values() if p.color == chess.WHITE)\n    black_count = sum(1 for p in board.piece_map().values() if p.color == chess.BLACK)\n    return float(white_count - black_count)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of attacks by each player's pieces.\"\n    white_attacks = sum(len(board.attackers(chess.WHITE, square)) for square in board.piece_map() if board.piece_map()[square].color == chess.WHITE)\n    black_attacks = sum(len(board.attackers(chess.BLACK, square)) for square in board.piece_map() if board.piece_map()[square].color == chess.BLACK)\n    return float(white_attacks - black_attacks)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of squares controlled by each player.\"\n    white_controlled = sum(1 for move in board.legal_moves if board.turn)\n    black_controlled = sum(1 for move in board.legal_moves if not board.turn)\n    return float(white_controlled - black_controlled)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces that are unprotected (not defended by other pieces).\"\n    unprotected_pieces = sum(1 for square in board.piece_map() if not board.attackers(board.piece_map()[square].color, square) and board.piece_map()[square].color == board.turn)\n    return float(unprotected_pieces)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of pieces that are attacking the opponent's king.\"\n    attacking_king = sum(1 for square in board.piece_map() if board.piece_map()[square].color == board.turn and board.is_attacked_by(not board.turn, square))\n    return float(attacking_king)", "def feature(board: chess.Board) -> float:\n    \"Calculates the total value of pieces on the board for the current player.\"\n    piece_values = {chess.PAWN: 100, chess.KNIGHT: 320, chess.BISHOP: 330, chess.ROOK: 500, chess.QUEEN: 900, chess.KING: 20000}\n    total_value = sum(piece_values[piece.piece_type] for square, piece in board.piece_map().items() if piece.color == board.turn)\n    return float(total_value)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of squares attacked and occupied by the current player's pieces.\"\n    control_count = sum(1 for square in range(64) if board.is_attacked_by(board.turn, square) or board.piece_at(square) is not None and board.piece_at(square).color == board.turn)\n    return float(control_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in the number of pieces defended by the current player.\"\n    defended_count = sum(1 for square in board.piece_map() if board.attackers(board.piece_map()[square].color, square) and board.piece_map()[square].color == board.turn)\n    return float(defended_count)", "def feature(board: chess.Board) -> float:\n    'Measures the difference in mobility between the two players.'\n    white_moves = len(list(board.legal_moves)) if board.turn else 0\n    black_moves = len(list(board.legal_moves)) if not board.turn else 0\n    return float(white_moves - black_moves)", "def feature(board: chess.Board) -> float:\n    'Counts the number of pieces that are attacking the opponent\u2019s king.'\n    attacking_pieces = sum(1 for square in board.piece_map() if board.is_attacked_by(not board.turn, square))\n    return float(attacking_pieces)", "def feature(board: chess.Board) -> float:\n    'Calculates the distance of the closest piece to the opposing king.'\n    opponent_king_square = next(square for square, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color != board.turn)\n    closest_piece_distance = min(chess.square_distance(square, opponent_king_square) for square in board.piece_map() if board.piece_at(square).color == board.turn)\n    return float(closest_piece_distance)", "def feature(board: chess.Board) -> float:\n    'Calculates the number of doubled pawns for the current player.'\n    pawns = [square for square, piece in board.piece_map().items() if piece.piece_type == chess.PAWN and piece.color == board.turn]\n    file_count = {}\n    for pawn in pawns:\n        file = chess.square_file(pawn)\n        file_count[file] = file_count.get(file, 0) + 1\n    doubled_count = sum(1 for count in file_count.values() if count > 1)\n    return float(doubled_count)", "def feature(board: chess.Board) -> float:\n    'Calculates the difference in piece activity between the two players.'\n    white_activity = sum(len(board.attackers(chess.WHITE, square)) for square in board.piece_map() if board.piece_at(square).color == chess.WHITE)\n    black_activity = sum(len(board.attackers(chess.BLACK, square)) for square in board.piece_map() if board.piece_at(square).color == chess.BLACK)\n    return float(white_activity - black_activity)", "def feature(board: chess.Board) -> float:\n    'Counts the number of pieces that are threatening to capture an opponent\u2019s piece.'\n    threats = sum(1 for square in board.piece_map() if board.is_attacked_by(board.turn, square))\n    return float(threats)", "def feature(board: chess.Board) -> float:\n    'Calculates the number of squares that are currently defended by pieces of the current player.'\n    defended_squares = sum(1 for square in chess.SQUARES if board.is_attacked_by(board.turn, square))\n    return float(defended_squares)", "def feature(board: chess.Board) -> float:\n    'Measures the material value disparity between the current player and the opponent.'\n    material_value = sum(piece.piece_type for piece in board.piece_map().values() if piece.color == board.turn) - sum(piece.piece_type for piece in board.piece_map().values() if piece.color != board.turn)\n    return float(material_value)", "def feature(board: chess.Board) -> float:\n    \"Calculates the total value of all pieces on the board.\"\n    total_value = 0\n    for piece in board.piece_map().values():\n        value = {\n            chess.PAWN: 100,\n            chess.KNIGHT: 320,\n            chess.BISHOP: 330,\n            chess.ROOK: 500,\n            chess.QUEEN: 900,\n            chess.KING: 0\n        }.get(piece.piece_type, 0)\n        total_value += value if piece.color == chess.WHITE else -value\n    return total_value", "def feature(board: chess.Board) -> float:\n    \"Counts the total number of squares attacked by each side.\"\n    white_attacks = sum(len(board.attackers(chess.WHITE, square)) for square in board.piece_map() if board.piece_map()[square].color == chess.WHITE)\n    black_attacks = sum(len(board.attackers(chess.BLACK, square)) for square in board.piece_map() if board.piece_map()[square].color == chess.BLACK)\n    return float(white_attacks - black_attacks)", "def feature(board: chess.Board) -> float:\n    \"Computes the ratio of pieces that have mobility options.\"\n    mobile_pieces = sum(1 for move in board.legal_moves)\n    total_pieces = len(board.piece_map())\n    return float(mobile_pieces / total_pieces) if total_pieces > 0 else 0.0", "def feature(board: chess.Board) -> float:\n    \"Counts the number of checks and potential checks on the opponent's king.\"\n    checks = int(board.is_check())\n    potential_checks = sum(1 for move in board.legal_moves if board.gives_check(move))\n    return float(checks + potential_checks)", "def feature(board: chess.Board) -> float:\n    \"Calculates the central control based on the number of pieces in the central squares.\"\n    central_squares = [chess.D4, chess.D5, chess.E4, chess.E5]\n    control = sum(1 for square in central_squares if board.piece_at(square) and board.piece_at(square).color == chess.WHITE)\n    control -= sum(1 for square in central_squares if board.piece_at(square) and board.piece_at(square).color == chess.BLACK)\n    return float(control)", "def feature(board: chess.Board) -> float:\n    \"Measures the distance of the pieces to the opponent's back rank.\"\n    distance_sum = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == chess.WHITE:\n            distance_sum += (7 - chess.square_rank(square))  # Closer to rank 0\n        else:\n            distance_sum -= (chess.square_rank(square))  # Closer to rank 7\n    return float(distance_sum)", "def feature(board: chess.Board) -> float:\n    \"Determines the king safety by counting the number of surrounding pawns.\"\n    white_king_square = next((square for square in board.piece_map() if board.piece_map()[square].color == chess.WHITE and board.piece_map()[square].piece_type == chess.KING), None)\n    black_king_square = next((square for square in board.piece_map() if board.piece_map()[square].color == chess.BLACK and board.piece_map()[square].piece_type == chess.KING), None)\n\n    def count_pawns(king_square):\n        if king_square is None:\n            return 0\n        surrounding_pawns = sum(1 for square in chess.SQUARES if chess.square_distance(king_square, square) == 1 and board.piece_at(square) and board.piece_at(square).piece_type == chess.PAWN)\n        return surrounding_pawns\n\n    return float(count_pawns(white_king_square) - count_pawns(black_king_square))", "def feature(board: chess.Board) -> float:\n    \"Evaluates the distribution of pieces across the board based on their ranks.\"\n    rank_distribution = [0] * 8\n    for square in board.piece_map():\n        rank = chess.square_rank(square)\n        rank_distribution[rank] += 1 if board.piece_map()[square].color == chess.WHITE else -1\n    return float(sum(rank_distribution))", "def feature(board: chess.Board) -> float:\n    \"Measures the total number of pawns on the board.\"\n    total_pawns = sum(1 for piece in board.piece_map().values() if piece.piece_type == chess.PAWN)\n    return float(total_pawns)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces attacking the opponent's king.\"\n    opponent_king_square = next(square for square, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color != board.turn)\n    attackers = board.attackers(board.turn, opponent_king_square)\n    return float(len(attackers))", "def feature(board: chess.Board) -> float:\n    \"Calculates the center control by counting pieces in the central squares.\"\n    central_squares = [chess.D4, chess.E4, chess.D5, chess.E5]\n    center_control = sum(1 for square in central_squares if board.piece_at(square) is not None)\n    return float(center_control)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of non-pawn pieces for each color.\"\n    non_pawn_count = sum(1 for piece in board.piece_map().values() if piece.piece_type != chess.PAWN)\n    return float(non_pawn_count)", "def feature(board: chess.Board) -> float:\n    \"Measures the mobility of the current player by counting legal moves.\"\n    legal_moves_count = len(list(board.legal_moves))\n    return float(legal_moves_count)", "def feature(board: chess.Board) -> float:\n    \"Checks if the current player's king is in check and returns a penalty if it is.\"\n    is_check = board.is_check()\n    return -1.0 if is_check else 0.0", "def feature(board: chess.Board) -> float:\n    \"Measures the distance of the opposite king from the current player's nearest piece.\"\n    opposite_king_square = next(square for square, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color != board.turn)\n    nearest_piece_distance = min(chess.square_distance(square, opposite_king_square) \n                                   for square, piece in board.piece_map().items() \n                                   if piece.color == board.turn)\n    return float(nearest_piece_distance)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces that are pinned against the king.\"\n    pinned_pieces = sum(1 for square, piece in board.piece_map().items() \n                        if piece.color == board.turn and board.is_attacked_by(not board.turn, square) and \n                        any(board.attackers(not board.turn, square))\n                        )\n    return float(pinned_pieces)", "def feature(board: chess.Board) -> float:\n    \"Calculates the total number of squares controlled by each player's pieces.\"\n    controlled_squares = set()\n    for square in range(64):\n        if board.piece_at(square):\n            controlled_squares.update(board.attacks(square))\n    return float(len(controlled_squares))", "def feature(board: chess.Board) -> float:\n    \"Measures the difference in tempo by calculating the number of possible moves for both players.\"\n    white_moves = len(list(board.legal_moves)) if board.turn else 0\n    black_moves = len(list(board.legal_moves)) if not board.turn else 0\n    return float(white_moves - black_moves)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces that are on their starting squares.\"\n    starting_positions = {chess.PAWN: [chess.A2, chess.B2, chess.C2, chess.D2, chess.E2, chess.F2, chess.G2, chess.H2],\n                          chess.ROOK: [chess.A1, chess.H1],\n                          chess.KNIGHT: [chess.B1, chess.G1],\n                          chess.BISHOP: [chess.C1, chess.F1],\n                          chess.QUEEN: [chess.D1],\n                          chess.KING: [chess.E1]}\n    count = 0\n    for piece in starting_positions:\n        for square in starting_positions[piece]:\n            if board.piece_at(square) and board.piece_at(square).piece_type == piece:\n                count += 1\n    return float(count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the average distance of pieces from their respective kings.\"\n    total_distance = 0\n    piece_count = 0\n    for square in range(64):\n        piece = board.piece_at(square)\n        if piece:\n            king_square = chess.square_name(board.king(piece.color))\n            distance = chess.square_distance(square, chess.parse_square(king_square))\n            total_distance += distance\n            piece_count += 1\n    return float(total_distance / piece_count) if piece_count > 0 else 0.0", "def feature(board: chess.Board) -> float:\n    \"Measures the mobility of the kings by counting available escape squares.\"\n    king_square = chess.square_name(board.king(board.turn))\n    escape_squares = board.attacks(chess.parse_square(king_square))\n    return float(len(escape_squares))", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of pieces attacked by enemy pieces.\"\n    attack_count = sum(1 for square in board.piece_map() if board.is_attacked_by(not board.turn, square))\n    return float(attack_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates imbalance based on the types of pawns on the board.\"\n    pawn_types = {'white': 0, 'black': 0}\n    for square in range(64):\n        piece = board.piece_at(square)\n        if piece and piece.piece_type == chess.PAWN:\n            color = 'white' if piece.color == chess.WHITE else 'black'\n            pawn_types[color] += 1\n    return float(pawn_types['white'] - pawn_types['black'])", "def feature(board: chess.Board) -> float:\n    \"Calculates the difference between the total values of the pieces on the board.\"\n    piece_value = {chess.PAWN: 100, chess.KNIGHT: 300, chess.BISHOP: 300,\n                   chess.ROOK: 500, chess.QUEEN: 900, chess.KING: 0}\n    white_value = sum(piece_value[piece.piece_type] for piece in board.piece_map().values() if piece.color == chess.WHITE)\n    black_value = sum(piece_value[piece.piece_type] for piece in board.piece_map().values() if piece.color == chess.BLACK)\n    return float(white_value - black_value)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of doubled pawns for both sides, with a penalty for each doubled pawn.\"\n    doubled_pawns = 0\n    pawn_files = {file: 0 for file in range(8)}\n    for square in range(64):\n        piece = board.piece_at(square)\n        if piece and piece.piece_type == chess.PAWN:\n            file = chess.square_file(square)\n            pawn_files[file] += 1\n    doubled_pawns = sum(max(0, count - 1) for count in pawn_files.values())\n    return float(doubled_pawns)", "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in the number of pieces on the board.\"\n    piece_count_white = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE)\n    piece_count_black = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK)\n    return float(piece_count_white - piece_count_black)", "def feature(board: chess.Board) -> float:\n    \"Measures the total attack potential by counting pieces that can attack.\"\n    attack_count = sum(len(board.attackers(piece.color, sq)) for sq, piece in board.piece_map().items())\n    return float(attack_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the average rank of all pieces for the current player.\"\n    total_rank = 0\n    piece_count = 0\n    for sq, piece in board.piece_map().items():\n        if piece.color == board.turn:\n            total_rank += chess.square_rank(sq)\n            piece_count += 1\n    return float(total_rank / piece_count) if piece_count > 0 else 0.0", "def feature(board: chess.Board) -> float:\n    \"Checks if a player has a potential check in the next move.\"\n    potential_check = any(board.is_attacked_by(not board.turn, sq) for sq in board.piece_map() if board.piece_map()[sq].color == board.turn)\n    return float(1.0 if potential_check else 0.0)", "def feature(board: chess.Board) -> float:\n    \"Evaluates the presence of threats: pieces attacking opponent's King directly.\"\n    threats_to_king = sum(1 for sq in board.piece_map() if board.is_attacked_by(not board.turn, sq) and board.piece_map()[sq].piece_type == chess.KING)\n    return float(threats_to_king)", "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in pawn structure between the two players.\"\n    white_pawns = sum(1 for sq, piece in board.piece_map().items() if piece.color == chess.WHITE and piece.piece_type == chess.PAWN)\n    black_pawns = sum(1 for sq, piece in board.piece_map().items() if piece.color == chess.BLACK and piece.piece_type == chess.PAWN)\n    return float(white_pawns - black_pawns)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of scattered pieces by summing distances between pieces of the same color.\"\n    positions = [sq for sq, piece in board.piece_map().items() if piece.color == board.turn]\n    if len(positions) < 2:\n        return 0.0\n    total_distance = sum(chess.square_distance(pos1, pos2) for i, pos1 in enumerate(positions) for pos2 in positions[i + 1:])\n    return float(total_distance)", "def feature(board: chess.Board) -> float:\n    \"Counts how many pieces are defending the King of the current player.\"\n    king_square = next(sq for sq, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color == board.turn)\n    defending_pieces = sum(1 for sq in board.piece_map() if board.is_attacked_by(not board.turn, sq) and board.attackers(board.turn, king_square))\n    return float(defending_pieces)", "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in control of the center squares (d4, d5, e4, e5).\"\n    center_squares = [chess.parse_square(sq) for sq in ['d4', 'd5', 'e4', 'e5']]\n    control_white = sum(1 for sq in center_squares if board.is_attacked_by(chess.WHITE, sq))\n    control_black = sum(1 for sq in center_squares if board.is_attacked_by(chess.BLACK, sq))\n    return float(control_white - control_black)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of pawns on the board, giving insight into endgame dynamics.\"\n    pawn_count = sum(1 for piece in board.piece_map().values() if piece.piece_type == chess.PAWN)\n    return float(pawn_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of squares attacked by each side's pieces.\"\n    white_attacks = sum(board.is_attacked_by(chess.WHITE, square) for square in chess.SQUARES)\n    black_attacks = sum(board.is_attacked_by(chess.BLACK, square) for square in chess.SQUARES)\n    return float(white_attacks - black_attacks)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of minor pieces (knights and bishops) on the board.\"\n    minor_pieces = sum(1 for piece in board.piece_map().values() if piece.piece_type in [chess.KNIGHT, chess.BISHOP])\n    return float(minor_pieces)", "def feature(board: chess.Board) -> float:\n    \"Calculates the total mobility by counting the legal moves available to both players.\"\n    white_moves = len(list(board.legal_moves)) if board.turn == chess.WHITE else 0\n    black_moves = len(list(board.legal_moves)) if not board.turn == chess.WHITE else 0\n    return float(white_moves - black_moves)", "def feature(board: chess.Board) -> float:\n    \"Measures the total number of pieces that are pinned against the respective kings.\"\n    pinned_pieces = sum(1 for square, piece in board.piece_map().items() \n                        if board.is_attacked_by(not piece.color, square) and board.is_attacked_by(piece.color, board.king(piece.color)))\n    return float(pinned_pieces)", "def feature(board: chess.Board) -> float:\n    \"Calculates the distance of the kings from each other for king safety consideration.\"\n    white_king_pos = board.king(chess.WHITE)\n    black_king_pos = board.king(chess.BLACK)\n    distance = chess.square_distance(white_king_pos, black_king_pos)\n    return float(distance)", "def feature(board: chess.Board) -> float:\n    \"Measures the total number of pieces on the 7th and 8th ranks, indicating endgame positioning.\"\n    seventh_rank_count = sum(1 for square in range(chess.A7, chess.H8 + 1) if board.piece_at(square) is not None)\n    eighth_rank_count = sum(1 for square in range(chess.A8, chess.H8 + 1) if board.piece_at(square) is not None)\n    return float(seventh_rank_count + eighth_rank_count)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of open files (files with no pawns) for both sides.\"\n    open_files = sum(1 for file in range(8) if not any(board.piece_at(chess.square(file, rank)) is not None and \n                                      board.piece_at(chess.square(file, rank)).piece_type == chess.PAWN for rank in range(8)))\n    return float(open_files)", "def feature(board: chess.Board) -> float:\n    \"Measures the difference in the number of rooks and queens for evaluating open-file advantage.\"\n    white_rooks_queens = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE and \n                              piece.piece_type in [chess.ROOK, chess.QUEEN])\n    black_rooks_queens = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK and \n                              piece.piece_type in [chess.ROOK, chess.QUEEN])\n    return float(white_rooks_queens - black_rooks_queens)", "def feature(board: chess.Board) -> float:\n    \"Calculates the effective piece activity by measuring the number of legal captures available.\"\n    captures = sum(1 for move in board.legal_moves if board.piece_at(move.to_square) is not None)\n    return float(captures)", "def feature(board: chess.Board) -> float:\n    \"Measures the total number of pieces on the board.\"\n    return float(len(board.piece_map()))", "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in the number of pawns between the two players.\"\n    white_pawns = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE and piece.piece_type == chess.PAWN)\n    black_pawns = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK and piece.piece_type == chess.PAWN)\n    return float(white_pawns - black_pawns)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of squares attacked by each player.\"\n    white_attacks = sum(board.is_attacked_by(chess.WHITE, square) for square in chess.SQUARES)\n    black_attacks = sum(board.is_attacked_by(chess.BLACK, square) for square in chess.SQUARES)\n    return float(white_attacks - black_attacks)", "def feature(board: chess.Board) -> float:\n    \"Measures the mobility of pieces by calculating the total number of legal moves.\"\n    return float(len(list(board.legal_moves)))", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces on the 7th rank for each player and returns the difference.\"\n    white_7th_rank = sum(1 for square in chess.SQUARES if board.piece_at(square) and \n                         board.piece_at(square).color == chess.WHITE and chess.square_rank(square) == 6)\n    black_7th_rank = sum(1 for square in chess.SQUARES if board.piece_at(square) and \n                         board.piece_at(square).color == chess.BLACK and chess.square_rank(square) == 6)\n    return float(white_7th_rank - black_7th_rank)", "def feature(board: chess.Board) -> float:\n    \"Measures the distance of the kings from the center of the board (squares d4, d5, e4, e5).\"\n    white_king_square = next(square for square, piece in board.piece_map().items() if piece.color == chess.WHITE and piece.piece_type == chess.KING)\n    black_king_square = next(square for square, piece in board.piece_map().items() if piece.color == chess.BLACK and piece.piece_type == chess.KING)\n    distance_white = chess.square_distance(white_king_square, chess.parse_square('e4'))\n    distance_black = chess.square_distance(black_king_square, chess.parse_square('e4'))\n    return float(distance_black - distance_white)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of pieces that are pinned by the opponent's pieces.\"\n    pinned_count = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == board.turn:  # Check for current player's pieces\n            for attacker_square in board.attackers(not board.turn, square):\n                # Check if the attacker can pin the piece\n                if board.piece_at(attacker_square).piece_type in {chess.ROOK, chess.QUEEN}:\n                    # Check if the attacking piece can 'see' the king\n                    for intermediate_square in chess.SQUARES:\n                        if board.piece_at(intermediate_square) and (intermediate_square != square and intermediate_square != attacker_square):\n                            continue\n                        if board.is_attacked_by(not board.turn, square) and not board.is_attacked_by(not board.turn, board.king(not board.turn)):\n                            pinned_count += 1\n                            break\n    return float(pinned_count)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of pieces each player has on the back rank.\"\n    white_back_rank = sum(1 for square in chess.SQUARES if board.piece_at(square) and \n                           board.piece_at(square).color == chess.WHITE and chess.square_rank(square) == 7)\n    black_back_rank = sum(1 for square in chess.SQUARES if board.piece_at(square) and \n                           board.piece_at(square).color == chess.BLACK and chess.square_rank(square) == 0)\n    return float(white_back_rank - black_back_rank)", "def feature(board: chess.Board) -> float:\n    \"Measures how many pieces are attacking the opponent's king.\"\n    white_king_square = next(square for square, piece in board.piece_map().items() if piece.color == chess.WHITE and piece.piece_type == chess.KING)\n    black_king_square = next(square for square, piece in board.piece_map().items() if piece.color == chess.BLACK and piece.piece_type == chess.KING)\n    white_attack_count = len(board.attackers(chess.WHITE, black_king_square))\n    black_attack_count = len(board.attackers(chess.BLACK, white_king_square))\n    return float(white_attack_count - black_attack_count)", "def feature(board: chess.Board) -> float:\n    \"Measures the total number of squares attacked by both players.\"\n    white_attacked = sum(1 for sq in chess.SQUARES if board.is_attacked_by(chess.WHITE, sq))\n    black_attacked = sum(1 for sq in chess.SQUARES if board.is_attacked_by(chess.BLACK, sq))\n    return float(white_attacked + black_attacked)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of potential checks available for both players.\"\n    white_checks = sum(1 for move in board.legal_moves if board.is_check() or board.gives_check(move))\n    black_checks = sum(1 for move in board.legal_moves if not board.is_check() or board.gives_check(move))\n    return float(white_checks + black_checks)", "def feature(board: chess.Board) -> float:\n    \"Calculates the mobility advantage by counting the difference in legal moves.\"\n    white_mobility = len(list(board.legal_moves))\n    return float(white_mobility)", "def feature(board: chess.Board) -> float:\n    \"Measures the distance of the kings to the center of the board.\"\n    white_king_square = board.king(chess.WHITE)\n    black_king_square = board.king(chess.BLACK)\n    white_distance = chess.square_distance(white_king_square, chess.E4)\n    black_distance = chess.square_distance(black_king_square, chess.E4)\n    return float(black_distance - white_distance)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of attacking pieces each player has.\"\n    white_attackers = sum(1 for sq in chess.SQUARES if board.attackers(chess.WHITE, sq))\n    black_attackers = sum(1 for sq in chess.SQUARES if board.attackers(chess.BLACK, sq))\n    return float(white_attackers - black_attackers)", "def feature(board: chess.Board) -> float:\n    \"Calculates the total value of pieces currently defended by other pieces.\"\n    total_defended_value = 0\n    for square, piece in board.piece_map().items():\n        if any(board.is_attacked_by(piece.color, attacker) for attacker in board.attackers(piece.color, square)):\n            total_defended_value += piece.piece_type\n    return float(total_defended_value)", "def feature(board: chess.Board) -> float:\n    \"Measures the density of pieces in the center 16 squares (d4, e4, d5, e5).\"\n    center_squares = [chess.D4, chess.D5, chess.E4, chess.E5]\n    center_density = sum(1 for sq in center_squares if board.piece_at(sq) is not None)\n    return float(center_density)", "def feature(board: chess.Board) -> float:\n    \"Evaluates the number of open files for both players.\"\n    white_open_files = len(set(chess.square_file(move.from_square) for move in board.legal_moves if board.piece_at(move.from_square).color == chess.WHITE))\n    black_open_files = len(set(chess.square_file(move.from_square) for move in board.legal_moves if board.piece_at(move.from_square).color == chess.BLACK))\n    return float(white_open_files - black_open_files)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of pieces that can potentially contribute to controlling the center.\"\n    center_control = 0\n    center_squares = [chess.D4, chess.D5, chess.E4, chess.E5]\n    for sq in center_squares:\n        if board.piece_at(sq) is not None:\n            center_control += 1\n    center_control += len(board.attackers(chess.WHITE, chess.D4)) + len(board.attackers(chess.WHITE, chess.E4))\n    center_control -= len(board.attackers(chess.BLACK, chess.D4)) + len(board.attackers(chess.BLACK, chess.E4))\n    return float(center_control)", "def feature(board: chess.Board) -> float:\n    \"Calculates the mobility advantage by measuring the difference in legal moves between players.\"\n    white_moves = len(list(board.legal_moves)) if board.turn else 0\n    black_moves = len(list(board.legal_moves)) if not board.turn else 0\n    return float(white_moves - black_moves)", "def feature(board: chess.Board) -> float:\n    \"Measures the total number of pieces within attacking distance of the opponent's king.\"\n    opponent_king_square = next(square for square in board.piece_map() if board.piece_at(square).piece_type == chess.KING and board.piece_at(square).color != board.turn)\n    attacking_pieces = sum(1 for piece_square in board.piece_map() if board.is_attacked_by(board.turn, piece_square) and board.piece_map()[piece_square].color == board.turn)\n    return float(attacking_pieces)", "def feature(board: chess.Board) -> float:\n    \"Evaluates the central control by counting pieces in the center squares (d4, d5, e4, e5).\"\n    center_squares = [chess.parse_square('d4'), chess.parse_square('d5'), chess.parse_square('e4'), chess.parse_square('e5')]\n    central_control = sum(1 for square in center_squares if board.piece_at(square) and board.piece_map()[square].color == board.turn)\n    return float(central_control)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of pieces potentially attacking the opponent's king.\"\n    opponent_king_square = next(square for square in board.piece_map() if board.piece_at(square).piece_type == chess.KING and board.piece_at(square).color != board.turn)\n    attacking_pieces = sum(1 for piece_square in board.piece_map() if board.is_attacked_by(board.turn, piece_square))\n    return float(attacking_pieces)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of doubled pawns on each side.\"\n    def count_doubled_pawns(color):\n        pawn_files = {}\n        for square in board.piece_map():\n            piece = board.piece_map()[square]\n            if piece.color == color and piece.piece_type == chess.PAWN:\n                file = chess.square_file(square)\n                pawn_files[file] = pawn_files.get(file, 0) + 1\n        return sum(1 for count in pawn_files.values() if count > 1)\n\n    white_doubled = count_doubled_pawns(chess.WHITE)\n    black_doubled = count_doubled_pawns(chess.BLACK)\n    return float(white_doubled - black_doubled)", "def feature(board: chess.Board) -> float:\n    \"Measures the total number of squares controlled by each player.\"\n    controlled_squares = {chess.WHITE: set(), chess.BLACK: set()}\n    for square in board.piece_map():\n        piece = board.piece_map()[square]\n        if piece.color == chess.WHITE:\n            controlled_squares[chess.WHITE].update(board.attackers(chess.BLACK, square))\n        else:\n            controlled_squares[chess.BLACK].update(board.attackers(chess.WHITE, square))\n    return float(len(controlled_squares[chess.WHITE]) - len(controlled_squares[chess.BLACK]))", "def feature(board: chess.Board) -> float:\n    \"Measures the king's distance from the center as a factor of safety.\"\n    king_square = next(square for square in board.piece_map() if board.piece_at(square).piece_type == chess.KING)\n    distance_to_center = chess.square_distance(king_square, chess.parse_square('e4')) + chess.square_distance(king_square, chess.parse_square('e5'))\n    return float(8 - distance_to_center)  # The closer to the center, the safer", "def feature(board: chess.Board) -> float:\n    \"Calculates the material advantage by summing the values of pieces for each side.\"\n    piece_values = {\n        chess.PAWN: 100,\n        chess.KNIGHT: 320,\n        chess.BISHOP: 330,\n        chess.ROOK: 500,\n        chess.QUEEN: 900,\n        chess.KING: 20000\n    }\n    white_value = sum(piece_values[piece.piece_type] for piece in board.piece_map().values() if piece.color == chess.WHITE)\n    black_value = sum(piece_values[piece.piece_type] for piece in board.piece_map().values() if piece.color == chess.BLACK)\n    result = white_value - black_value\n    return float(result)", "def feature(board: chess.Board) -> float:\n    \"Measures the difference in the number of pieces that can be captured in the next move.\"\n    white_captures = sum(1 for move in board.legal_moves if board.piece_at(move.to_square) and board.piece_at(move.to_square).color == chess.BLACK)\n    black_captures = sum(1 for move in board.legal_moves if board.piece_at(move.to_square) and board.piece_at(move.to_square).color == chess.WHITE)\n    result = white_captures - black_captures\n    return float(result)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces that are attacking the opponent's king.\"\n    attackers_to_king = sum(1 for square in chess.SQUARES if board.is_attacked_by(chess.WHITE, square) and board.piece_at(square) and board.piece_at(square).color == chess.BLACK)\n    result = float(attackers_to_king)\n    return result", "def feature(board: chess.Board) -> float:\n    \"Calculates the total number of pawns on the board.\"\n    total_pawns = sum(1 for piece in board.piece_map().values() if piece.piece_type == chess.PAWN)\n    result = float(total_pawns)\n    return result", "def feature(board: chess.Board) -> float:\n    \"Evaluates the position's balance of material concerning the average piece value.\"\n    piece_values = {\n        chess.PAWN: 100,\n        chess.KNIGHT: 320,\n        chess.BISHOP: 330,\n        chess.ROOK: 500,\n        chess.QUEEN: 900,\n        chess.KING: 20000\n    }\n    total_value = sum(piece_values[piece.piece_type] for piece in board.piece_map().values())\n    average_value = total_value / max(1, len(board.piece_map()))\n    return float(average_value)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of potential checks against the opponent's king.\"\n    potential_checks = 0\n    for move in board.legal_moves:\n        board.push(move)\n        if board.is_check():\n            potential_checks += 1\n        board.pop()\n    result = float(potential_checks)\n    return result", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces that are pinned (unable to move due to being attacked).\"\n    pinned_pieces = sum(1 for square in board.piece_map() if board.is_attacked_by(not board.turn, square) and board.piece_map()[square].color == board.turn)\n    result = float(pinned_pieces)\n    return result", "def feature(board: chess.Board) -> float:\n    \"Measures the number of pieces in a pinned state for both players.\"\n    pinned_pieces = 0\n    for square, piece in board.piece_map().items():\n        if board.is_attacked_by(not piece.color, square) and \\\n           not board.attackers(piece.color, square):\n            pinned_pieces += 1\n    return float(pinned_pieces)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces each player has on the 7th and 8th ranks.\"\n    white_back_rank = len([square for square in range(56, 64) if board.piece_at(square)])\n    black_back_rank = len([square for square in range(0, 8) if board.piece_at(square)])\n    return float(white_back_rank - black_back_rank)", "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in material value between both players considering only minor pieces.\"\n    minor_piece_values = {chess.KNIGHT: 3, chess.BISHOP: 3}\n    white_minor_value = sum(minor_piece_values.get(board.piece_at(square).piece_type, 0)\n                            for square in board.piece_map() if board.piece_at(square).color == chess.WHITE)\n    black_minor_value = sum(minor_piece_values.get(board.piece_at(square).piece_type, 0)\n                            for square in board.piece_map() if board.piece_at(square).color == chess.BLACK)\n    return float(white_minor_value - black_minor_value)", "def feature(board: chess.Board) -> float:\n    \"Measures the distance of the kings from the center of the board.\"\n    white_king_square = board.king(chess.WHITE)\n    black_king_square = board.king(chess.BLACK)\n    return float(chess.square_distance(white_king_square, chess.E4) - \n                 chess.square_distance(black_king_square, chess.E4))", "def feature(board: chess.Board) -> float:\n    \"Counts the number of doubled pawns for both players.\"\n    white_pawns = [square for square in board.piece_map() if board.piece_at(square).color == chess.WHITE and board.piece_at(square).piece_type == chess.PAWN]\n    black_pawns = [square for square in board.piece_map() if board.piece_at(square).color == chess.BLACK and board.piece_at(square).piece_type == chess.PAWN]\n    white_doubled = sum(1 for file in range(8) if len([sq for sq in white_pawns if chess.square_file(sq) == file]) > 1)\n    black_doubled = sum(1 for file in range(8) if len([sq for sq in black_pawns if chess.square_file(sq) == file]) > 1)\n    return float(white_doubled - black_doubled)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of attacks against the opponent's king.\"\n    opponent_king_square = board.king(not board.turn)\n    attacking_moves = len(list(board.attackers(board.turn, opponent_king_square)))\n    return float(attacking_moves)", "def feature(board: chess.Board) -> float:\n    \"Calculates the total number of captured pieces by each player.\"\n    white_captured = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK)\n    black_captured = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE)\n    return float(white_captured - black_captured)", "def feature(board: chess.Board) -> float:\n    \"Evaluates the number of isolated pawns for both players.\"\n    white_isolated = sum(1 for square in board.piece_map() if board.piece_at(square).color == chess.WHITE and\n                         board.piece_at(square).piece_type == chess.PAWN and\n                         not any(board.piece_at(chess.parse_square(chess.square_name(square + offset))) for offset in [-1, 1] if 0 <= chess.square_file(square + offset) < 8))\n    black_isolated = sum(1 for square in board.piece_map() if board.piece_at(square).color == chess.BLACK and\n                         board.piece_at(square).piece_type == chess.PAWN and\n                         not any(board.piece_at(chess.parse_square(chess.square_name(square + offset))) for offset in [-1, 1] if 0 <= chess.square_file(square + offset) < 8))\n    return float(white_isolated - black_isolated)", "def feature(board: chess.Board) -> float:\n    \"Measures the control of central squares (d4, d5, e4, e5) by both players.\"\n    central_squares = [chess.parse_square('d4'), chess.parse_square('d5'), chess.parse_square('e4'), chess.parse_square('e5')]\n    white_control = sum(1 for square in central_squares if board.is_attacked_by(chess.WHITE, square))\n    black_control = sum(1 for square in central_squares if board.is_attacked_by(chess.BLACK, square))\n    return float(white_control - black_control)", "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in mobility between both players based on the number of legal moves.\"\n    white_moves = len(list(board.legal_moves)) if board.turn else len(list(board.legal_moves))\n    black_moves = len(list(board.legal_moves)) if not board.turn else len(list(board.legal_moves))\n    return float(white_moves - black_moves)", "def feature(board: chess.Board) -> float:\n    \"Measures the presence of hanging pieces, counting pieces unprotected by any allied pieces.\"\n    hanging_count = 0\n    for square, piece in board.piece_map().items():\n        if board.is_attacked_by(not piece.color, square):\n            hanging_count += 1\n    return float(hanging_count)", "def feature(board: chess.Board) -> float:\n    \"Scores the distance of the kings from each other, representing potential threats.\"\n    white_king = board.king(chess.WHITE)\n    black_king = board.king(chess.BLACK)\n    distance = chess.square_distance(white_king, black_king)\n    return float(distance)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of pieces that are pinned against their own king.\"\n    pinned_count = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == board.turn:\n            attackers = board.attackers(not piece.color, square)\n            for attacker in attackers:\n                if board.is_attacked_by(piece.color, board.king(piece.color)):\n                    pinned_count += 1\n                    break\n    return float(pinned_count)", "def feature(board: chess.Board) -> float:\n    \"Counts the total number of pieces on the board excluding pawns.\"\n    non_pawn_count = sum(1 for piece in board.piece_map().values() if piece.piece_type != chess.PAWN)\n    return float(non_pawn_count)", "def feature(board: chess.Board) -> float:\n    \"Measures the aggressiveness of each side based on the number of pieces attacking the opponent's king.\"\n    white_attackers = len(board.attackers(chess.WHITE, board.king(chess.BLACK)))\n    black_attackers = len(board.attackers(chess.BLACK, board.king(chess.WHITE)))\n    return float(white_attackers - black_attackers)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of isolated pawns for both players.\"\n    isolated_pawns = 0\n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.PAWN:\n            file = chess.square_file(square)\n            if (board.piece_at(chess.parse_square(f'{chess.square_name(square)[0]}{chess.square_rank(square) + 1}')) is None and\n                board.piece_at(chess.parse_square(f'{chess.square_name(square)[0]}{chess.square_rank(square) - 1}')) is None):\n                isolated_pawns += 1\n    return float(isolated_pawns)", "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in material value between the two players.\"\n    material_value = {chess.PAWN: 100, chess.KNIGHT: 300, chess.BISHOP: 300, chess.ROOK: 500, chess.QUEEN: 900, chess.KING: 0}\n    white_value = sum(material_value[piece.piece_type] for piece in board.piece_map().values() if piece.color == chess.WHITE)\n    black_value = sum(material_value[piece.piece_type] for piece in board.piece_map().values() if piece.color == chess.BLACK)\n    return float(white_value - black_value)", "def feature(board: chess.Board) -> float:\n    \"Counts the total number of minority attacks both players have against the opponent.\"\n    minority_attacks = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == board.turn:\n            attackers = board.attackers(not piece.color, square)\n            if len(attackers) < 2:  # Check for minority attack condition\n                minority_attacks += 1\n    return float(minority_attacks)", "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in piece values between the two players.\"\n    material_values = {chess.PAWN: 100, chess.KNIGHT: 300, chess.BISHOP: 300,\n                       chess.ROOK: 500, chess.QUEEN: 900, chess.KING: 0}\n    white_value = sum(material_values[piece.piece_type] for piece in board.piece_map().values() if piece.color == chess.WHITE)\n    black_value = sum(material_values[piece.piece_type] for piece in board.piece_map().values() if piece.color == chess.BLACK)\n    return float(white_value - black_value)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of squares attacked by each player.\"\n    white_attacked = sum(1 for square in chess.SQUARES if board.is_attacked_by(chess.WHITE, square))\n    black_attacked = sum(1 for square in chess.SQUARES if board.is_attacked_by(chess.BLACK, square))\n    return float(white_attacked - black_attacked)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of pawns each player has advanced past the opponent's starting rank.\"\n    white_pawns = sum(1 for square, piece in board.piece_map().items() if piece.color == chess.WHITE and chess.square_rank(square) > 4)\n    black_pawns = sum(1 for square, piece in board.piece_map().items() if piece.color == chess.BLACK and chess.square_rank(square) < 3)\n    return float(white_pawns - black_pawns)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of piece pairings (two pieces defending each other) for each player.\"\n    white_pairings = sum(1 for square, piece in board.piece_map().items() if piece.color == chess.WHITE and \n                         any(board.is_attacked_by(piece.color, other_square) for other_square in board.attackers(piece.color, square)))\n    black_pairings = sum(1 for square, piece in board.piece_map().items() if piece.color == chess.BLACK and \n                         any(board.is_attacked_by(piece.color, other_square) for other_square in board.attackers(piece.color, square)))\n    return float(white_pairings - black_pairings)", "def feature(board: chess.Board) -> float:\n    \"Evaluates the safety of kings based on the number of attacking pieces near them.\"\n    white_king_square = next(square for square, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color == chess.WHITE)\n    black_king_square = next(square for square, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color == chess.BLACK)\n    white_king_safety = len(board.attackers(chess.BLACK, white_king_square))\n    black_king_safety = len(board.attackers(chess.WHITE, black_king_square))\n    return float(black_king_safety - white_king_safety)", "def feature(board: chess.Board) -> float:\n    \"Calculates the mobility advantage of the player to move.\"\n    if board.turn:\n        white_moves = len(list(board.legal_moves))\n        black_board = board.copy()\n        black_board.turn = chess.BLACK\n        black_moves = len(list(black_board.legal_moves))\n    else:\n        black_moves = len(list(board.legal_moves))\n        white_board = board.copy()\n        white_board.turn = chess.WHITE\n        white_moves = len(list(white_board.legal_moves))\n    return float(white_moves - black_moves)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of potential forks possible with knights.\"\n    knight_forks = 0\n    knight_positions = [square for square, piece in board.piece_map().items() if piece.piece_type == chess.KNIGHT]\n    for knight in knight_positions:\n        attacked_squares = set(board.attacks(knight))\n        if len(attacked_squares) > 1:\n            knight_forks += 1\n    return float(knight_forks)", "def feature(board: chess.Board) -> float:\n    \"Measures the distance of the center squares from the pieces of each player.\"\n    center_squares = [chess.E4, chess.E5, chess.D4, chess.D5]\n    white_distance = sum(min(chess.square_distance(square, center) for center in center_squares) for square, piece in board.piece_map().items() if piece.color == chess.WHITE)\n    black_distance = sum(min(chess.square_distance(square, center) for center in center_squares) for square, piece in board.piece_map().items() if piece.color == chess.BLACK)\n    return float(white_distance - black_distance)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of undeveloped pieces for each player.\"\n    undeveloped_white = sum(1 for square, piece in board.piece_map().items() if piece.color == chess.WHITE and piece.piece_type in [chess.KNIGHT, chess.BISHOP] and chess.square_rank(square) < 2)\n    undeveloped_black = sum(1 for square, piece in board.piece_map().items() if piece.color == chess.BLACK and piece.piece_type in [chess.KNIGHT, chess.BISHOP] and chess.square_rank(square) > 5)\n    return float(undeveloped_white - undeveloped_black)", "def feature(board: chess.Board) -> float:\n    \"Measures the total value of pieces for both players by summing their values.\"\n    value = 0\n    piece_values = {\n        chess.PAWN: 100,\n        chess.KNIGHT: 320,\n        chess.BISHOP: 330,\n        chess.ROOK: 500,\n        chess.QUEEN: 900,\n        chess.KING: 20000\n    }\n    for piece in board.piece_map().values():\n        value += piece_values[piece.piece_type] if piece.color == chess.WHITE else -piece_values[piece.piece_type]\n    return float(value)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces that are currently pinned (unable to move without exposing a more valuable piece).\"\n    pinned_count = 0\n    for square, piece in board.piece_map().items():\n        if board.is_attacked_by(not piece.color, square):\n            attackers = board.attackers(not piece.color, square)\n            for attacker in attackers:\n                if board.is_attacked_by(piece.color, attacker):\n                    pinned_count += 1\n                    break\n    return float(pinned_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in the number of pieces on the board between both players.\"\n    white_piece_count = len([p for p in board.piece_map().values() if p.color == chess.WHITE])\n    black_piece_count = len([p for p in board.piece_map().values() if p.color == chess.BLACK])\n    return float(white_piece_count - black_piece_count)", "def feature(board: chess.Board) -> float:\n    \"Measures the total advanced position of pawns for both players.\"\n    white_advanced_pawns = sum(1 for square, piece in board.piece_map().items() if piece.color == chess.WHITE and piece.piece_type == chess.PAWN and chess.square_rank(square) > 4)\n    black_advanced_pawns = sum(1 for square, piece in board.piece_map().items() if piece.color == chess.BLACK and piece.piece_type == chess.PAWN and chess.square_rank(square) < 3)\n    return float(white_advanced_pawns - black_advanced_pawns)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces supporting other pieces.\"\n    support_count = 0\n    for square, piece in board.piece_map().items():\n        for target in board.attackers(piece.color, square):\n            if board.piece_at(target) and board.piece_at(target).color == piece.color:\n                support_count += 1\n    return float(support_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the mobility advantage by counting potential moves for both players.\"\n    white_mobility = len(list(board.legal_moves)) if board.turn else 0\n    black_mobility = len(list(board.legal_moves)) if not board.turn else 0\n    return float(white_mobility - black_mobility)", "def feature(board: chess.Board) -> float:\n    \"Measures the distribution of pieces by calculating the average rank and file occupied.\"\n    total_rank = total_file = piece_count = 0\n    for square, piece in board.piece_map().items():\n        total_rank += chess.square_rank(square)\n        total_file += chess.square_file(square)\n        piece_count += 1\n    return float((total_rank + total_file) / piece_count) if piece_count > 0 else 0.0", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of discovered checks (pieces that could check the enemy king after moving).\"\n    discovered_check_count = 0\n    for square, piece in board.piece_map().items():\n        for move in board.legal_moves:\n            if move.from_square == square:\n                board.push(move)\n                if board.is_check():\n                    discovered_check_count += 1\n                board.pop()\n    return float(discovered_check_count)", "def feature(board: chess.Board) -> float:\n    \"Measures the level of control over central squares by counting pieces on central files and ranks.\"\n    central_squares = [chess.D4, chess.D5, chess.E4, chess.E5]\n    control_count = sum(1 for square in central_squares if board.piece_at(square) is not None)\n    return float(control_count)", "def feature(board: chess.Board) -> float:\n    \"Measures the average rank of pieces for the current player, higher values indicate stronger positioning.\"\n    pieces = [piece for piece in board.piece_map().values() if piece.color == board.turn]\n    if not pieces:\n        return 0.0\n    average_rank = sum(chess.square_rank(square) for square in board.piece_map() if board.piece_map()[square].color == board.turn) / len(pieces)\n    return float(average_rank)", "def feature(board: chess.Board) -> float:\n    \"Counts the total number of pieces currently attacking opponent's pieces.\"\n    attackers = sum(len(board.attackers(not board.turn, square)) for square in board.piece_map() if board.piece_map()[square].color != board.turn)\n    return float(attackers)", "def feature(board: chess.Board) -> float:\n    \"Measures the difference in the number of mobile pieces (pieces that can move) between both players.\"\n    white_mobile = sum(1 for move in board.legal_moves if board.turn)\n    black_mobile = sum(1 for move in board.legal_moves if not board.turn)\n    return float(white_mobile - black_mobile)", "def feature(board: chess.Board) -> float:\n    \"Calculates the distance of the nearest opponent's piece to the current player's king.\"\n    king_square = next(square for square, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color == board.turn)\n    opponent_positions = [square for square, piece in board.piece_map().items() if piece.color != board.turn]\n    distances = [chess.square_distance(king_square, pos) for pos in opponent_positions]\n    return float(min(distances)) if distances else 0.0", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces placed on the central squares (d4, d5, e4, e5) for the current player.\"\n    central_squares = [chess.D4, chess.D5, chess.E4, chess.E5]\n    central_count = sum(1 for square in central_squares if board.piece_at(square) and board.piece_at(square).color == board.turn)\n    return float(central_count)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of doubled pawns for the current player.\"\n    pawns = [square for square, piece in board.piece_map().items() if piece.piece_type == chess.PAWN and piece.color == board.turn]\n    files = {}\n    for pawn in pawns:\n        file = chess.square_file(pawn)\n        if file in files:\n            files[file] += 1\n        else:\n            files[file] = 1\n    doubled_pawns = sum(1 for count in files.values() if count > 1)\n    return float(doubled_pawns)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces currently pinned against the king for the current player.\"\n    pinned_count = sum(1 for square in board.piece_map() if board.is_attacked_by(not board.turn, square) and board.piece_map()[square].color == board.turn)\n    return float(pinned_count)", "def feature(board: chess.Board) -> float:\n    \"Counts how many pieces of the current player are placed on squares that are attacked by the opponent.\"\n    attacked_squares = {square for square in board.piece_map() if board.is_attacked_by(not board.turn, square) and board.piece_map()[square].color == board.turn}\n    return float(len(attacked_squares))", "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in material value between the two players, considering piece types.\"\n    material_values = {chess.PAWN: 100, chess.KNIGHT: 320, chess.BISHOP: 330, chess.ROOK: 500, chess.QUEEN: 900}\n    white_value = sum(material_values.get(piece.piece_type, 0) for piece in board.piece_map().values() if piece.color == chess.WHITE)\n    black_value = sum(material_values.get(piece.piece_type, 0) for piece in board.piece_map().values() if piece.color == chess.BLACK)\n    return float(white_value - black_value)", "def feature(board: chess.Board) -> float:\n    \"Measures the total value of pieces that are currently pinned.\"\n    pinned_value = 0.0\n    for square, piece in board.piece_map().items():\n        if board.is_attacked_by(not piece.color, square):\n            attacking_pieces = board.attackers(piece.color, square)\n            for attacker in attacking_pieces:\n                if board.is_attacked_by(piece.color, attacker):\n                    pinned_value += piece.piece_type\n                    break\n    return pinned_value", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pawns controlling the center squares.\"\n    center_squares = [chess.D4, chess.D5, chess.E4, chess.E5]\n    controlling_pawns = 0\n    for square in center_squares:\n        if board.piece_at(square) and board.piece_at(square).piece_type == chess.PAWN:\n            controlling_pawns += 1\n    return float(controlling_pawns)", "def feature(board: chess.Board) -> float:\n    \"Calculates the mobility ratio of the pieces for the current player.\"\n    current_moves = len(list(board.legal_moves))\n    opponent_moves = len(list(board.legal_moves))  # Temporarily think all moves are available\n    mobility_ratio = current_moves / max(1, opponent_moves)\n    return mobility_ratio", "def feature(board: chess.Board) -> float:\n    \"Measures the number of discovered attacks by each player's pieces.\"\n    discovered_attacks = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == board.turn:\n            legal_moves = [move for move in board.legal_moves if move.from_square == square]\n            for move in legal_moves:\n                if board.is_attacked_by(not piece.color, move.to_square):\n                    discovered_attacks += 1\n    return float(discovered_attacks)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of squares vulnerable to a discovered check.\"\n    vulnerable_squares = set()\n    for square, piece in board.piece_map().items():\n        if piece.color == board.turn:\n            for move in board.legal_moves:\n                if move.from_square == square:\n                    next_board = board.copy(stack=False)\n                    next_board.push(move)\n                    if next_board.is_check():\n                        for attack_move in next_board.legal_moves:\n                            vulnerable_squares.add(attack_move.to_square)\n    return float(len(vulnerable_squares))", "def feature(board: chess.Board) -> float:\n    \"Calculates the total value of the opponent's pieces that are attacked.\"\n    attacked_value = 0.0\n    for square, piece in board.piece_map().items():\n        if piece.color != board.turn and board.is_attacked_by(board.turn, square):\n            attacked_value += piece.piece_type\n    return attacked_value", "def feature(board: chess.Board) -> float:\n    \"Measures the total number of pieces that can move to the opponent's back rank.\"\n    back_rank_squares = [chess.A8, chess.B8, chess.C8, chess.D8, chess.E8, chess.F8, chess.G8, chess.H8] if board.turn == chess.BLACK else [chess.A1, chess.B1, chess.C1, chess.D1, chess.E1, chess.F1, chess.G1, chess.H1]\n    back_rank_attacking_pieces = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == board.turn:\n            for move in board.legal_moves:\n                if move.to_square in back_rank_squares:\n                    back_rank_attacking_pieces += 1\n                    break\n    return float(back_rank_attacking_pieces)", "def feature(board: chess.Board) -> float:\n    \"Calculates the material imbalance by considering the piece types only.\"\n    material_value = 0.0\n    for piece in board.piece_map().values():\n        if piece.color == board.turn:\n            material_value += piece.piece_type\n        else:\n            material_value -= piece.piece_type\n    return material_value", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of squares left unchecked by own pieces.\"\n    unchecked_squares = 0\n    for rank in range(8):\n        for file in range(8):\n            square = chess.square(file, rank)\n            if board.piece_at(square) is None and not board.is_attacked_by(board.turn, square):\n                unchecked_squares += 1\n    return float(unchecked_squares)", "def feature(board: chess.Board) -> float:\n    \"Measures the difference in material value between the two players based on piece types.\"\n    material_values = {\n        chess.PAWN: 100,\n        chess.KNIGHT: 300,\n        chess.BISHOP: 300,\n        chess.ROOK: 500,\n        chess.QUEEN: 900,\n        chess.KING: 0\n    }\n    white_value = sum(material_values[piece.piece_type] for piece in board.piece_map().values() if piece.color == chess.WHITE)\n    black_value = sum(material_values[piece.piece_type] for piece in board.piece_map().values() if piece.color == chess.BLACK)\n    return float(white_value - black_value)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces each player has on the board to assess material presence.\"\n    white_count = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE)\n    black_count = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK)\n    return float(white_count - black_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the degree of king safety by counting squares around the king that are attacked.\"\n    king_square = next((square for square, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color == board.turn), None)\n    if king_square is None:\n        return 0.0\n    attacked_squares = len(board.attackers(not board.turn, king_square))\n    return float(attacked_squares)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of pawns that are doubled for both players.\"\n    white_pawn_positions = [square for square in board.piece_map() if board.piece_map()[square].piece_type == chess.PAWN and board.piece_map()[square].color == chess.WHITE]\n    black_pawn_positions = [square for square in board.piece_map() if board.piece_map()[square].piece_type == chess.PAWN and board.piece_map()[square].color == chess.BLACK]\n    white_doubled = sum(1 for file in range(8) if sum(1 for sq in white_pawn_positions if chess.square_file(sq) == file) > 1)\n    black_doubled = sum(1 for file in range(8) if sum(1 for sq in black_pawn_positions if chess.square_file(sq) == file) > 1)\n    return float(white_doubled - black_doubled)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of open files (files with no pawns) available to each side.\"\n    open_files_white = sum(1 for file in range(8) if all(board.piece_at(chess.square(file, rank)) is None for rank in range(8) if board.piece_at(chess.square(file, rank)) is None or board.piece_at(chess.square(file, rank)).piece_type != chess.PAWN))\n    open_files_black = sum(1 for file in range(8) if all(board.piece_at(chess.square(file, rank)) is None for rank in range(8) if board.piece_at(chess.square(file, rank)) is None or board.piece_at(chess.square(file, rank)).piece_type != chess.PAWN))\n    return float(open_files_white - open_files_black)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces on the 7th rank for both players to gauge endgame potential.\"\n    white_7th_rank = sum(1 for square in board.piece_map() if chess.square_rank(square) == 6 and board.piece_map()[square].color == chess.WHITE)\n    black_7th_rank = sum(1 for square in board.piece_map() if chess.square_rank(square) == 1 and board.piece_map()[square].color == chess.BLACK)\n    return float(white_7th_rank - black_7th_rank)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of hanging pieces (pieces that can be taken without retaliation) for each player.\"\n    hanging_white = sum(1 for square in board.piece_map() if board.piece_map()[square].color == chess.WHITE and len(board.attackers(chess.BLACK, square)) == 0)\n    hanging_black = sum(1 for square in board.piece_map() if board.piece_map()[square].color == chess.BLACK and len(board.attackers(chess.WHITE, square)) == 0)\n    return float(hanging_white - hanging_black)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of piece interactions (attacks on opponent's pieces) to assess tactical chances.\"\n    interactions = sum(1 for square in board.piece_map() if board.piece_map()[square].color == board.turn and len(board.attackers(not board.turn, square)) > 0)\n    return float(interactions)", "def feature(board: chess.Board) -> float:\n    \"Measures the total number of pieces for both players, weighted by their values.\"\n    value_map = {\n        chess.PAWN: 100, chess.KNIGHT: 320, chess.BISHOP: 330,\n        chess.ROOK: 500, chess.QUEEN: 900, chess.KING: 20000\n    }\n    total_value = 0.0\n    for piece in board.piece_map().values():\n        total_value += value_map.get(piece.piece_type, 0) * (1 if piece.color == chess.WHITE else -1)\n    return total_value", "def feature(board: chess.Board) -> float:\n    \"Counts the total number of pawns on the board for both players.\"\n    pawn_count = sum(1 for piece in board.piece_map().values() if piece.piece_type == chess.PAWN)\n    return float(pawn_count)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of pieces in the opponent's back rank.\"\n    back_rank = 0\n    opponent_back_rank = 0 if board.turn else 7\n    \n    for file in range(8):\n        square = chess.square(file, opponent_back_rank)\n        piece = board.piece_at(square)\n        if piece and piece.color == (chess.WHITE if board.turn else chess.BLACK):\n            back_rank += 1\n    \n    return float(back_rank)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces that are on squares that their own pieces attack.\"\n    defending_pieces_count = 0\n    \n    for square, piece in board.piece_map().items():\n        if piece.color == (chess.WHITE if board.turn else chess.BLACK):\n            attackers = board.attackers(piece.color, square)\n            if attackers:\n                defending_pieces_count += 1\n    \n    return float(defending_pieces_count)", "def feature(board: chess.Board) -> float:\n    \"Measures the total number of free pawns for both players.\"\n    free_pawn_count = 0\n\n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.PAWN:\n            if not board.is_attacked_by(chess.WHITE if piece.color == chess.BLACK else chess.BLACK, square):\n                free_pawn_count += 1\n                \n    return float(free_pawn_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the presence of major pieces (queens and rooks) for both sides.\"\n    major_piece_count = sum(1 for piece in board.piece_map().values() if piece.piece_type in {chess.QUEEN, chess.ROOK})\n    return float(major_piece_count)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of squares available to the current player that are not attacked.\"\n    legal_moves = len(list(board.legal_moves))\n    unsafe_squares = sum(1 for square in chess.SQUARES if board.is_attacked_by(board.turn, square))\n    return float(legal_moves - unsafe_squares)", "def feature(board: chess.Board) -> float:\n    \"Counts the total number of minor pieces (knights and bishops) on the board.\"\n    minor_piece_count = sum(1 for piece in board.piece_map().values() if piece.piece_type in {chess.KNIGHT, chess.BISHOP})\n    return float(minor_piece_count)", "def feature(board: chess.Board) -> float:\n    \"Measures the difference in mobility of pieces between both players.\"\n    white_mobility = len(list(board.legal_moves)) if board.turn else len(list(board.legal_moves))\n    black_mobility = len(list(board.legal_moves)) if not board.turn else len(list(board.legal_moves))\n    return float(white_mobility - black_mobility)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces attacking opponent's back rank squares.\"\n    attacking_back_rank = 0\n    back_rank_squares = [chess.A8, chess.B8, chess.C8, chess.D8, chess.E8, chess.F8, chess.G8, chess.H8]\n    for square in back_rank_squares:\n        attacking_back_rank += len(board.attackers(chess.BLACK, square))\n    return float(attacking_back_rank)", "def feature(board: chess.Board) -> float:\n    \"Calculates the total number of pieces of each side in the center squares.\"\n    center_squares = [chess.E4, chess.E5, chess.D4, chess.D5]\n    white_center = sum(1 for square in center_squares if board.piece_at(square) and board.piece_at(square).color == chess.WHITE)\n    black_center = sum(1 for square in center_squares if board.piece_at(square) and board.piece_at(square).color == chess.BLACK)\n    return float(white_center - black_center)", "def feature(board: chess.Board) -> float:\n    \"Measures the presence of rooks on open files for both players.\"\n    open_files = [0] * 8  # 0-7 representing a-h files\n    for file in range(8):\n        if all(board.piece_at(chess.square(file, rank)) is None for rank in range(8)):\n            open_files[file] = 1  # Count this file as open\n\n    white_rooks_on_open_files = sum(1 for square in board.piece_map() if board.piece_at(square).piece_type == chess.ROOK and board.piece_at(square).color == chess.WHITE and open_files[chess.square_file(square)] == 1)\n    black_rooks_on_open_files = sum(1 for square in board.piece_map() if board.piece_at(square).piece_type == chess.ROOK and board.piece_at(square).color == chess.BLACK and open_files[chess.square_file(square)] == 1)\n\n    return float(white_rooks_on_open_files - black_rooks_on_open_files)", "def feature(board: chess.Board) -> float:\n    \"Measures the total piece value of each side in relation to the center control.\"\n    piece_values = {chess.PAWN: 100, chess.KNIGHT: 320, chess.BISHOP: 330, chess.ROOK: 500, chess.QUEEN: 900, chess.KING: 20000}\n    center_control_value = 0\n    center_squares = [chess.D4, chess.E4, chess.D5, chess.E5]\n\n    for square in center_squares:\n        piece = board.piece_at(square)\n        if piece:\n            value = piece_values[piece.piece_type] if piece.color == chess.WHITE else -piece_values[piece.piece_type]\n            center_control_value += value\n\n    return float(center_control_value)", "def feature(board: chess.Board) -> float:\n    \"Evaluates the difference in the number of pieces on the board for each player.\"\n    white_piece_count = len([p for p in board.piece_map().values() if p.color == chess.WHITE])\n    black_piece_count = len([p for p in board.piece_map().values() if p.color == chess.BLACK])\n    return float(white_piece_count - black_piece_count)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces threatened but not defended for both players.\"\n    threatened_undefeated = 0\n    for square, piece in board.piece_map().items():\n        if board.is_attacked_by(not piece.color, square) and not any(board.is_attacked_by(piece.color, att_square) for att_square in board.attackers(piece.color, square)):\n            threatened_undefeated += 1\n    return float(threatened_undefeated)", "def feature(board: chess.Board) -> float:\n    \"Measures the difference in the number of pieces on the board for each color.\"\n    white_count = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE)\n    black_count = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK)\n    return float(white_count - black_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the total material value for the current player based on piece type.\"\n    material_value = {chess.PAWN: 100, chess.KNIGHT: 300, chess.BISHOP: 300, \n                      chess.ROOK: 500, chess.QUEEN: 900, chess.KING: 0}\n    total_value = sum(material_value[piece.piece_type] for piece in board.piece_map().values() if piece.color == board.turn)\n    return float(total_value)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of opponent's pieces attacked by the current player's pieces.\"\n    attackers = sum(len(board.attackers(board.turn, square)) for square in board.piece_map() if board.piece_map()[square].color != board.turn)\n    return float(attackers)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of squares attacked by the current player's pieces.\"\n    attacked_squares = set()\n    for square in board.piece_map():\n        piece = board.piece_map()[square]\n        if piece.color == board.turn:\n            attacked_squares.update(board.attackers(board.turn, square))\n    return float(len(attacked_squares))", "def feature(board: chess.Board) -> float:\n    \"Calculates the mobility of the currently active color based on legal moves.\"\n    mobility = sum(1 for move in board.legal_moves if move.from_square in board.piece_map() and board.piece_map()[move.from_square].color == board.turn)\n    return float(mobility)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of pieces on the 7th rank for both players.\"\n    seventh_rank_white = sum(1 for square in range(chess.A7, chess.H7 + 1) if board.piece_at(square) and board.piece_at(square).color == chess.WHITE)\n    seventh_rank_black = sum(1 for square in range(chess.A2, chess.H2 + 1) if board.piece_at(square) and board.piece_at(square).color == chess.BLACK)\n    return float(seventh_rank_white - seventh_rank_black)", "def feature(board: chess.Board) -> float:\n    \"Measures the distance from the center for the pieces of the active player.\"\n    center_squares = [chess.D4, chess.D5, chess.E4, chess.E5]\n    distances = sum(chess.square_distance(square, center_square) for square in board.piece_map() if board.piece_map()[square].color == board.turn for center_square in center_squares)\n    return float(distances)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of pinned pieces for the current player's pieces.\"\n    pinned_count = 0\n    for square in board.piece_map():\n        piece = board.piece_map()[square]\n        if piece.color == board.turn and board.is_attacked_by(not board.turn, square):\n            if board.is_check():\n                pinned_count += 1\n    return float(pinned_count)", "def feature(board: chess.Board) -> float:\n    \"Measures the difference in the number of pieces on the board that are currently undefended.\"\n    undefended_count = 0\n    for square in board.piece_map():\n        piece = board.piece_map()[square]\n        if not board.attackers(piece.color, square) and piece.color == board.turn:\n            undefended_count += 1\n    return float(undefended_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the king safety based on the number of attacking pieces near the opponent's king.\"\n    opponent_king_square = next(square for square, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color != board.turn)\n    attacking_count = len(board.attackers(board.turn, opponent_king_square))\n    return float(attacking_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the average distance of pieces from their own king.\"\n    own_king = next((sq for sq in board.piece_map() if board.piece_at(sq).piece_type == chess.KING and board.piece_at(sq).color == (chess.WHITE if board.turn else chess.BLACK)), None)\n    if own_king is None:\n        return 0.0\n    total_distance = sum(chess.square_distance(own_king, sq) for sq in board.piece_map() if board.piece_at(sq).color == (chess.WHITE if board.turn else chess.BLACK))\n    return total_distance / len([sq for sq in board.piece_map() if board.piece_at(sq).color == (chess.WHITE if board.turn else chess.BLACK)]) if total_distance else 0.0", "def feature(board: chess.Board) -> float:\n    \"Returns a weighted sum of pieces based on their type and position.\"\n    piece_values = {\n        chess.PAWN: 100,\n        chess.KNIGHT: 300,\n        chess.BISHOP: 330,\n        chess.ROOK: 500,\n        chess.QUEEN: 900,\n        chess.KING: 20000\n    }\n    total_value = 0\n    for square, piece in board.piece_map().items():\n        value = piece_values[piece.piece_type]\n        if piece.color == board.turn:\n            total_value += value\n        else:\n            total_value -= value\n    return total_value", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces under attack by enemy pieces.\"\n    under_attack_count = sum(1 for square in board.piece_map() if board.is_attacked_by(not board.turn, square))\n    return float(under_attack_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the total value of pinned pieces.\"\n    total_pinned_value = 0\n    for square in board.piece_map():\n        piece = board.piece_at(square)\n        if piece and board.is_attacked_by(not piece.color, square):\n            # For simplicity, we assume that a pinned piece has no legal moves\n            if not any(board.piece_at(move.to_square) for move in board.legal_moves if move.from_square == square):\n                total_pinned_value += 100 * piece.piece_type\n    return total_pinned_value", "def feature(board: chess.Board) -> float:\n    \"Measures the control of central squares (d4, d5, e4, e5) by the current player.\"\n    central_squares = [chess.D4, chess.D5, chess.E4, chess.E5]\n    control_count = sum(1 for sq in central_squares if board.is_attacked_by(board.turn, sq))\n    return float(control_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the mobility of each player based on available legal moves.\"\n    white_moves = len([move for move in board.legal_moves if board.piece_at(move.from_square).color == chess.WHITE])\n    black_moves = len([move for move in board.legal_moves if board.piece_at(move.from_square).color == chess.BLACK])\n    return float(white_moves - black_moves)", "def feature(board: chess.Board) -> float:\n    \"Calculates the distance of the kings from the center of the board (e4 and d4).\"\n    center_squares = [chess.E4, chess.D4]\n    own_king = next((sq for sq in board.piece_map() if board.piece_at(sq).piece_type == chess.KING and board.piece_at(sq).color == (chess.WHITE if board.turn else chess.BLACK)), None)\n    return min(chess.square_distance(own_king, center_sq) for center_sq in center_squares) if own_king else 0.0", "def feature(board: chess.Board) -> float:\n    \"Returns the number of squares controlled by the player's pieces on the board.\"\n    controlled_squares = set()\n    for square in board.piece_map():\n        piece = board.piece_at(square)\n        if piece.color == board.turn:\n            controlled_squares.update(move.to_square for move in board.legal_moves if move.from_square == square)\n    return float(len(controlled_squares))", "def feature(board: chess.Board) -> float:\n    \"Calculates the value of the highest value piece that is currently on the board.\"\n    piece_values = {\n        chess.PAWN: 100,\n        chess.KNIGHT: 300,\n        chess.BISHOP: 330,\n        chess.ROOK: 500,\n        chess.QUEEN: 900,\n        chess.KING: 20000\n    }\n    max_value = 0\n    for piece in board.piece_map().values():\n        max_value = max(max_value, piece_values[piece.piece_type])\n    return float(max_value)", "def feature(board: chess.Board) -> float:\n    \"Measures the symmetry of piece distribution across the board.\"\n    piece_distribution = [0] * 8\n    for square in board.piece_map():\n        file = chess.square_file(square)\n        piece_distribution[file] += 1\n    return float(max(piece_distribution) - min(piece_distribution))", "def feature(board: chess.Board) -> float:\n    \"Calculates the total number of pieces that are pinned by opposing pieces.\"\n    pinned_count = 0\n    for square, piece in board.piece_map().items():\n        if board.is_attacked_by(not piece.color, square):\n            for attacker in board.attackers(not piece.color, square):\n                if board.is_attacked_by(piece.color, attacker):\n                    pinned_count += 1\n                    break\n    return float(pinned_count)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of squares attacked by the player's pieces.\"\n    attack_count = sum(len(board.attackers(piece.color, square)) for square, piece in board.piece_map().items() if piece.color == board.turn)\n    return float(attack_count)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of major pieces (rook, queen) currently on the board.\"\n    major_piece_count = sum(1 for piece in board.piece_map().values() if piece.piece_type in {chess.ROOK, chess.QUEEN})\n    return float(major_piece_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the total material value (in centipawns) of pieces in hand.\"\n    piece_values = {chess.PAWN: 100, chess.KNIGHT: 320, chess.BISHOP: 330, chess.ROOK: 500, chess.QUEEN: 900, chess.KING: 0}\n    total_value = sum(piece_values[piece.piece_type] for piece in board.piece_map().values())\n    return float(total_value)", "def feature(board: chess.Board) -> float:\n    \"Assesses the positional value of pawns based on their structure.\"\n    pawn_structure = 0\n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.PAWN:\n            rank = chess.square_rank(square)\n            if piece.color == chess.WHITE:\n                pawn_structure += (7 - rank)\n            else:\n                pawn_structure += rank\n    return float(pawn_structure)", "def feature(board: chess.Board) -> float:\n    \"Calculates the distance of the nearest pawns from the current player's king.\"\n    king_square = next(square for square, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color == board.turn)\n    nearest_distance = float('inf')\n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.PAWN and piece.color == board.turn:\n            distance = chess.square_distance(king_square, square)\n            if distance < nearest_distance:\n                nearest_distance = distance\n    return nearest_distance if nearest_distance != float('inf') else 0.0", "def feature(board: chess.Board) -> float:\n    \"Evaluates the number of squares the opposing king can escape to.\"\n    legal_moves = len(list(board.legal_moves))\n    opposing_king_square = next(square for square, piece in board.piece_map().items() if piece.color != board.turn and piece.piece_type == chess.KING)\n    escape_squares = 0\n    for square in chess.SQUARES:\n        if board.is_attacked_by(board.turn, square) and board.piece_at(square) is None:\n            escape_squares += 1\n    return float(escape_squares)", "def feature(board: chess.Board) -> float:\n    \"Assesses the initiative based on the number of threats to opposing pieces.\"\n    threats_count = sum(1 for square in board.piece_map() if board.is_attacked_by(not board.turn, square))\n    return float(threats_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of rooks on open files.\"\n    open_file_count = 0\n    for file in range(8):\n        if all(board.piece_at(chess.square(file, rank)) is None for rank in range(8)):\n            open_file_count += sum(1 for rank in range(8) if board.piece_at(chess.square(file, rank)) and \n                board.piece_at(chess.square(file, rank)).piece_type == chess.ROOK)\n    return float(open_file_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in the number of pawns for each side.\"\n    white_pawns = sum(1 for square in board.piece_map() if board.piece_at(square).color == chess.WHITE and board.piece_at(square).piece_type == chess.PAWN)\n    black_pawns = sum(1 for square in board.piece_map() if board.piece_at(square).color == chess.BLACK and board.piece_at(square).piece_type == chess.PAWN)\n    return float(white_pawns - black_pawns)", "def feature(board: chess.Board) -> float:\n    \"Measures the total distance of all pieces from the center of the board.\"\n    total_distance = 0\n    for square, piece in board.piece_map().items():\n        # calculate the Manhattan distance to the center (e4/e5)\n        center_distance = chess.square_distance(square, chess.parse_square('e4')) + chess.square_distance(square, chess.parse_square('e5'))\n        total_distance += center_distance\n    return float(total_distance)", "def feature(board: chess.Board) -> float:\n    \"Checks for the presence of potential back-rank checkmate threats.\"\n    back_rank_threats = 0\n    for square in (chess.A8, chess.B8, chess.C8, chess.D8, chess.E8, chess.F8, chess.G8, chess.H8):\n        if board.piece_at(square) is None and board.is_attacked_by(chess.BLACK, square):\n            back_rank_threats += 1\n    return float(back_rank_threats)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of pieces that are positioned on the 7th rank for each side.\"\n    white_7th_rank = sum(1 for square in board.piece_map() if board.piece_at(square).color == chess.WHITE and chess.square_rank(square) == 6)\n    black_7th_rank = sum(1 for square in board.piece_map() if board.piece_at(square).color == chess.BLACK and chess.square_rank(square) == 1)\n    return float(white_7th_rank - black_7th_rank)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pinned pieces for both colors.\"\n    def is_pinned(square, color):\n        piece = board.piece_at(square)\n        if piece is None or piece.color != color:\n            return False\n        for attacker in board.attackers(not color, square):\n            if board.is_attacked_by(color, attacker):\n                return True\n        return False\n\n    white_pinned = sum(1 for square in board.piece_map() if is_pinned(square, chess.WHITE))\n    black_pinned = sum(1 for square in board.piece_map() if is_pinned(square, chess.BLACK))\n    return float(white_pinned - black_pinned)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces under attack for each side.\"\n    white_attacked = sum(1 for square in board.piece_map() if board.piece_at(square).color == chess.WHITE and board.is_attacked_by(chess.BLACK, square))\n    black_attacked = sum(1 for square in board.piece_map() if board.piece_at(square).color == chess.BLACK and board.is_attacked_by(chess.WHITE, square))\n    return float(white_attacked - black_attacked)", "def feature(board: chess.Board) -> float:\n    \"Measures the material imbalance by counting the difference in piece values for each side.\"\n    piece_values = {chess.PAWN: 100, chess.KNIGHT: 320, chess.BISHOP: 330, chess.ROOK: 500, chess.QUEEN: 900, chess.KING: 0}\n    white_value = sum(piece_values[piece.piece_type] for square, piece in board.piece_map().items() if piece.color == chess.WHITE)\n    black_value = sum(piece_values[piece.piece_type] for square, piece in board.piece_map().items() if piece.color == chess.BLACK)\n    return float(white_value - black_value)", "def feature(board: chess.Board) -> float:\n    \"Measures the total number of pieces in the opponent's half of the board.\"\n    opponent_half_pieces = sum(1 for square in board.piece_map() if board.piece_at(square).color != board.turn and chess.square_rank(square) >= 4)\n    return float(opponent_half_pieces)", "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in the controlled squares between both players.\"\n    controlled_white = sum(1 for move in board.legal_moves if board.turn == chess.WHITE and board.is_attacked_by(chess.WHITE, move.to_square))\n    controlled_black = sum(1 for move in board.legal_moves if board.turn == chess.BLACK and board.is_attacked_by(chess.BLACK, move.to_square))\n    return float(controlled_white - controlled_black)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of attacking pieces each player has.\"\n    attacking_white = sum(1 for square in board.piece_map() if board.piece_at(square).color == chess.WHITE and board.attackers(chess.WHITE, square))\n    attacking_black = sum(1 for square in board.piece_map() if board.piece_at(square).color == chess.BLACK and board.attackers(chess.BLACK, square))\n    return float(attacking_white - attacking_black)", "def feature(board: chess.Board) -> float:\n    \"Counts the total number of pieces that are in danger of being captured next move.\"\n    in_danger = sum(1 for square in board.piece_map() if board.piece_at(square).color == board.turn and board.is_attacked_by(not board.turn, square))\n    return float(in_danger)", "def feature(board: chess.Board) -> float:\n    \"Measures the mobility advantage of the player to move.\"\n    mobility_white = len(list(board.legal_moves)) if board.turn == chess.WHITE else 0\n    mobility_black = len(list(board.legal_moves)) if board.turn == chess.BLACK else 0\n    return float(mobility_white - mobility_black)", "def feature(board: chess.Board) -> float:\n    \"Evaluates the potential safety of the king based on surrounding pieces.\"\n    king_square = next((square for square in board.piece_map() if board.piece_at(square).piece_type == chess.KING and board.piece_at(square).color == board.turn), None)\n    if king_square is None:\n        return 0.0\n    attacking_count = sum(1 for square in chess.SQUARES if board.is_attacked_by(not board.turn, square))\n    return float(10 - attacking_count)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of defended squares by the player's pieces.\"\n    defended_squares = sum(1 for square in chess.SQUARES if board.is_attacked_by(board.turn, square))\n    return float(defended_squares)", "def feature(board: chess.Board) -> float:\n    \"Measures the potential for a back rank mate based on the position of the king and rooks.\"\n    back_rank_cut_off = [chess.A1, chess.B1, chess.C1, chess.D1, chess.E1, chess.F1, chess.G1, chess.H1] if board.turn == chess.WHITE else [chess.A8, chess.B8, chess.C8, chess.D8, chess.E8, chess.F8, chess.G8, chess.H8]\n    rook_count = sum(1 for square in back_rank_cut_off if board.piece_at(square) and board.piece_at(square).piece_type == chess.ROOK and board.piece_at(square).color == board.turn)\n    king_square = next((square for square in board.piece_map() if board.piece_at(square).piece_type == chess.KING and board.piece_at(square).color == board.turn), None)\n    is_king_blocked = any(board.is_attacked_by(not board.turn, sq) for sq in back_rank_cut_off if sq != king_square)\n    return float(rook_count - int(is_king_blocked))", "def feature(board: chess.Board) -> float:\n    \"Measures the disparity in pawn structure between the opponents.\"\n    white_pawns = 0\n    black_pawns = 0\n    for square in board.piece_map():\n        piece = board.piece_at(square)\n        if piece.piece_type == chess.PAWN:\n            if piece.color == chess.WHITE:\n                white_pawns += 1\n            else:\n                black_pawns += 1\n    return float(white_pawns - black_pawns)", "def feature(board: chess.Board) -> float:\n    \"Measures the total number of pieces each player has on the board.\"\n    white_pieces = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE)\n    black_pieces = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK)\n    return float(white_pieces - black_pieces)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of pieces attacking the opponent's king.\"\n    white_king_square = next(square for square, piece in board.piece_map().items() if piece.color == chess.WHITE and piece.piece_type == chess.KING)\n    black_king_square = next(square for square, piece in board.piece_map().items() if piece.color == chess.BLACK and piece.piece_type == chess.KING)\n    white_attackers = len(board.attackers(chess.WHITE, black_king_square))\n    black_attackers = len(board.attackers(chess.BLACK, white_king_square))\n    return float(white_attackers - black_attackers)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces each player has on the first two ranks.\"\n    white_rank_pieces = sum(1 for square in range(0, 16) if board.piece_at(square) and board.piece_at(square).color == chess.WHITE)\n    black_rank_pieces = sum(1 for square in range(48, 64) if board.piece_at(square) and board.piece_at(square).color == chess.BLACK)\n    return float(white_rank_pieces - black_rank_pieces)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of pawn promotions potentially available for each side.\"\n    white_promotions = sum(1 for square in range(8, 16) if board.piece_at(square) and board.piece_at(square).piece_type == chess.PAWN)\n    black_promotions = sum(1 for square in range(48, 56) if board.piece_at(square) and board.piece_at(square).piece_type == chess.PAWN)\n    return float(white_promotions - black_promotions)", "def feature(board: chess.Board) -> float:\n    \"Calculates the material balance based on a simple weighted sum of pieces.\"\n    piece_value = {\n        chess.PAWN: 100,\n        chess.KNIGHT: 300,\n        chess.BISHOP: 300,\n        chess.ROOK: 500,\n        chess.QUEEN: 900,\n        chess.KING: 0\n    }\n    material_balance = sum(piece_value[piece.piece_type] * (1 if piece.color == chess.WHITE else -1) for piece in board.piece_map().values())\n    return float(material_balance)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of defended squares by each player.\"\n    defended_squares_white = sum(1 for square in range(64) if board.is_attacked_by(chess.BLACK, square) and any(board.piece_at(sq).color == chess.WHITE for sq in board.attackers(chess.WHITE, square)))\n    defended_squares_black = sum(1 for square in range(64) if board.is_attacked_by(chess.WHITE, square) and any(board.piece_at(sq).color == chess.BLACK for sq in board.attackers(chess.BLACK, square)))\n    return float(defended_squares_white - defended_squares_black)", "def feature(board: chess.Board) -> float:\n    \"Measures the flexibility of rooks by counting their legal moves.\"\n    rook_flexibility = sum(len(list(board.legal_moves)) for square in board.piece_map() if board.piece_map()[square].piece_type == chess.ROOK)\n    return float(rook_flexibility)", "def feature(board: chess.Board) -> float:\n    \"Calculates the distance from the opponent's king for all pieces, measuring engagement potential.\"\n    opponent_king_square = next(square for square, piece in board.piece_map().items() if piece.color != board.turn and piece.piece_type == chess.KING)\n    distance_sum = sum(chess.square_distance(square, opponent_king_square) for square in board.piece_map() if board.piece_map()[square].color == board.turn)\n    return float(distance_sum)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of potential checks that can be delivered in the next turn.\"\n    potential_checks = sum(1 for move in board.legal_moves if board.gives_check(move))\n    return float(potential_checks)", "def feature(board: chess.Board) -> float:\n    \"Calculates the total value of pieces that are currently attacking enemy pieces.\"\n    attack_value = 0.0\n    for square, piece in board.piece_map().items():\n        for attacker in board.attackers(piece.color, square):\n            attack_value += piece.piece_type * (1 if piece.color == chess.WHITE else -1)\n    return attack_value", "def feature(board: chess.Board) -> float:\n    \"Measures the average distance of all pieces from the center of the board.\"\n    total_distance = 0\n    piece_count = 0\n    for square, piece in board.piece_map().items():\n        distance = chess.square_distance(square, chess.parse_square('e4'))  # Center of the board\n        total_distance += distance\n        piece_count += 1\n    return total_distance / piece_count if piece_count > 0 else 0.0", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pawns that are passed pawns.\"\n    passed_pawns = 0\n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.PAWN:\n            if (piece.color == chess.WHITE and all(board.is_attacked_by(chess.BLACK, sq) for sq in range(chess.square_file(square), 64))) or \\\n               (piece.color == chess.BLACK and all(board.is_attacked_by(chess.WHITE, sq) for sq in range(0, chess.square_file(square) + 1))):\n                passed_pawns += 1\n    return float(passed_pawns)", "def feature(board: chess.Board) -> float:\n    \"Evaluates the control of the center squares (d4, d5, e4, e5) for both players.\"\n    center_control = 0.0\n    center_squares = [chess.parse_square('d4'), chess.parse_square('d5'), chess.parse_square('e4'), chess.parse_square('e5')]\n    for square in center_squares:\n        if board.piece_at(square):\n            if board.piece_at(square).color == chess.WHITE:\n                center_control += 1\n            else:\n                center_control -= 1\n    return center_control", "def feature(board: chess.Board) -> float:\n    \"Calculates the total number of pieces pinned by the opponent.\"\n    pinned_pieces = 0\n    for square, piece in board.piece_map().items():\n        if board.is_attacked_by(not piece.color, square):\n            # Check if the piece is pinned (cannot move without exposing the king)\n            if any(board.is_attacked_by(piece.color, to_sq) for to_sq in board.attackers(piece.color, square)):\n                pinned_pieces += 1\n    return float(pinned_pieces)", "def feature(board: chess.Board) -> float:\n    \"Calculates the ratio of major pieces (rooks and queens) to minor pieces (knights and bishops).\"\n    major_count = 0\n    minor_count = 0\n    for piece in board.piece_map().values():\n        if piece.piece_type in {chess.ROOK, chess.QUEEN}:\n            major_count += 1\n        elif piece.piece_type in {chess.KNIGHT, chess.BISHOP}:\n            minor_count += 1\n    return (major_count / (minor_count + 1)) if minor_count > 0 else float(major_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of doubled pawns on the board.\"\n    doubled_pawns = 0\n    pawn_files = {file: 0 for file in range(8)}\n    \n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.PAWN:\n            file = chess.square_file(square)\n            pawn_files[file] += 1\n            \n    for count in pawn_files.values():\n        if count > 1:\n            doubled_pawns += count - 1  # Subtract 1 as the first pawn isn't doubled\n            \n    return float(doubled_pawns)", "def feature(board: chess.Board) -> float:\n    \"Measures the total number of pawn structures on the board.\"\n    pawns_count = sum(1 for piece in board.piece_map().values() if piece.piece_type == chess.PAWN)\n    return float(pawns_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in the number of pieces on light and dark squares.\"\n    light_square_pieces = sum(1 for square in board.piece_map() if (chess.square_file(square) + chess.square_rank(square)) % 2 == 0)\n    dark_square_pieces = sum(1 for square in board.piece_map() if (chess.square_file(square) + chess.square_rank(square)) % 2 == 1)\n    return float(light_square_pieces - dark_square_pieces)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of pieces that can attack the opponent's king.\"\n    opponent_king_square = next(square for square, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color != board.turn)\n    attacking_piece_count = sum(1 for move in board.legal_moves if board.is_attacked_by(board.turn, opponent_king_square))\n    return float(attacking_piece_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the average distance of all pieces from the opponent's king.\"\n    opponent_king_square = next(square for square, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color != board.turn)\n    total_distance = sum(chess.square_distance(square, opponent_king_square) for square in board.piece_map() if board.piece_map()[square].color == board.turn)\n    piece_count = len([square for square in board.piece_map() if board.piece_map()[square].color == board.turn])\n    return total_distance / piece_count if piece_count > 0 else 0.0", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces that have mobility (can move to at least one legal square).\"\n    mobile_piece_count = sum(1 for square in board.piece_map() if board.piece_map()[square].color == board.turn and len(list(board.legal_moves)) > 0)\n    return float(mobile_piece_count)", "def feature(board: chess.Board) -> float:\n    \"Measures the total number of squares occupied by pieces on both sides.\"\n    occupied_squares = len(board.piece_map())\n    return float(occupied_squares)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of squares controlled by both players combined.\"\n    controlled_squares = set()\n    for square in board.piece_map():\n        controlled_squares.update(board.attackers(board.piece_map()[square].color, square))\n    return float(len(controlled_squares))", "def feature(board: chess.Board) -> float:\n    \"Measures the piece distribution over central squares (d4, d5, e4, e5).\"\n    central_squares = [chess.D4, chess.D5, chess.E4, chess.E5]\n    central_piece_count = sum(1 for square in central_squares if board.piece_at(square) is not None)\n    return float(central_piece_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the ratio of minor pieces (knights and bishops) to total pieces.\"\n    minor_pieces = sum(1 for piece in board.piece_map().values() if piece.piece_type in {chess.KNIGHT, chess.BISHOP})\n    total_pieces = len(board.piece_map())\n    return (minor_pieces / total_pieces) if total_pieces > 0 else 0.0", "def feature(board: chess.Board) -> float:\n    \"Measures the distance of the kings from each other.\"\n    white_king = board.king(chess.WHITE)\n    black_king = board.king(chess.BLACK)\n    if white_king is None or black_king is None:\n        return 0.0\n    distance = chess.square_distance(white_king, black_king)\n    return float(distance)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of opponent's pieces that are within one square of the king of the current player.\"\n    current_king = board.king(board.turn)\n    if current_king is None:\n        return 0.0\n    counter = sum(1 for square in board.attacks(current_king) if board.piece_at(square) is not None and board.piece_at(square).color != board.turn)\n    return float(counter)", "def feature(board: chess.Board) -> float:\n    \"Calculates the total number of Pawn promotions possible in the current position.\"\n    promotions = 0\n    for square in range(64):\n        piece = board.piece_at(square)\n        if piece and piece.piece_type == chess.PAWN:\n            direction = 1 if piece.color == chess.WHITE else -1\n            # Check if the pawn can promote\n            if chess.square_rank(square) + direction in [0, 7]: \n                promotions += 1\n    return float(promotions)", "def feature(board: chess.Board) -> float:\n    \"Calculates the average distance of all pieces from the nearest king.\"\n    total_distance = 0\n    piece_count = 0\n    white_king = board.king(chess.WHITE)\n    black_king = board.king(chess.BLACK)\n    for square in board.piece_map():\n        piece_distance = chess.square_distance(square, white_king) if board.piece_at(square).color == chess.WHITE else chess.square_distance(square, black_king)\n        total_distance += piece_distance\n        piece_count += 1\n    return total_distance / piece_count if piece_count > 0 else 0.0", "def feature(board: chess.Board) -> float:\n    \"Counts the number of squares controlled by the player's pieces that are adjacent to the opponent's king.\"\n    opponent_king = board.king(not board.turn)\n    controlled_squares = set()\n    if opponent_king is None:\n        return 0.0\n    for square in chess.SQUARES:\n        piece = board.piece_at(square)\n        if piece and piece.color == board.turn:\n            controlled_squares.update(board.attacks(square))\n    adjacent_squares = [s for s in chess.SQUARES if chess.square_distance(s, opponent_king) == 1]\n    return float(len(set(adjacent_squares) & controlled_squares))", "def feature(board: chess.Board) -> float:\n    \"Measures the total number of open files for rooks of the current player.\"\n    open_files = 0\n    for file in range(8):\n        if all(board.piece_at(chess.square(file, rank)) is None for rank in range(8)):\n            open_files += 1\n    return float(open_files)", "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in the number of possible escape squares for both kings.\"\n    white_king = board.king(chess.WHITE)\n    black_king = board.king(chess.BLACK)\n    if white_king is None or black_king is None:\n        return 0.0\n    white_escape = len([s for s in board.attacks(white_king) if board.piece_at(s) is None])\n    black_escape = len([s for s in board.attacks(black_king) if board.piece_at(s) is None])\n    return float(white_escape - black_escape)", "def feature(board: chess.Board) -> float:\n    \"Calculates the total number of pieces in the corner squares (A1, A8, H1, H8).\"\n    corner_squares = [chess.A1, chess.A8, chess.H1, chess.H8]\n    corner_pieces_count = sum(1 for square in corner_squares if board.piece_at(square) is not None)\n    return float(corner_pieces_count)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of checked pieces that can move to safety in the next turn.\"\n    checked_squares = [square for square in chess.SQUARES if board.is_attacked_by(not board.turn, square) and board.piece_at(square) and board.piece_at(square).color == board.turn]\n    safe_moves = sum(1 for square in checked_squares if any(move.to_square != square for move in board.legal_moves))\n    return float(safe_moves)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of discovered attacks possible by moving pieces out of the way of other pieces.\"\n    discovered_attacks = 0\n    for square in board.piece_map():\n        piece = board.piece_at(square)\n        if piece and piece.color == board.turn:\n            attacks = board.attacks(square)\n            for target in attacks:\n                if board.piece_at(target) and board.piece_at(target).color != piece.color:\n                    discovered_attacks += 1\n    return float(discovered_attacks)", "def feature(board: chess.Board) -> float:\n    'Evaluates the total mobility of each side by counting the number of legal moves available to each side.'\n    white_moves = len(list(board.legal_moves)) if board.turn else 0\n    black_moves = len(list(board.legal_moves)) if not board.turn else 0\n    return float(white_moves - black_moves)", "def feature(board: chess.Board) -> float:\n    'Measures the difference in the number of pieces remaining on each side.'\n    white_piece_count = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE)\n    black_piece_count = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK)\n    return float(white_piece_count - black_piece_count)", "def feature(board: chess.Board) -> float:\n    'Counts the number of pieces attacking the opponent\u2019s king.'\n    white_attacks = len(board.attackers(chess.WHITE, chess.parse_square('h8')))  \n    black_attacks = len(board.attackers(chess.BLACK, chess.parse_square('h1')))\n    return float(white_attacks - black_attacks)", "def feature(board: chess.Board) -> float:\n    'Calculates the total value of pieces on the board for each player and computes the difference.'\n    value_map = {chess.PAWN: 100, chess.KNIGHT: 320, chess.BISHOP: 330, chess.ROOK: 500, chess.QUEEN: 900, chess.KING: 20000}\n    white_value = sum(value_map[piece.piece_type] for piece in board.piece_map().values() if piece.color == chess.WHITE)\n    black_value = sum(value_map[piece.piece_type] for piece in board.piece_map().values() if piece.color == chess.BLACK)\n    return float(white_value - black_value)", "def feature(board: chess.Board) -> float:\n    'Counts the number of pieces that are pinned (unable to move without exposing the king).'\n    pinned = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == board.turn and board.is_attacked_by(not board.turn, square):\n            pinned += 1\n    return float(pinned)", "def feature(board: chess.Board) -> float:\n    'Evaluates the control of the center squares by counting how many pieces are occupying or attacking them.'\n    center_squares = [chess.E4, chess.E5, chess.D4, chess.D5]\n    control = sum(1 for square in center_squares if board.is_attacked_by(chess.WHITE, square)) - \\\n              sum(1 for square in center_squares if board.is_attacked_by(chess.BLACK, square))\n    return float(control)", "def feature(board: chess.Board) -> float:\n    'Measures the distance of the pieces from the opponent\u2019s back rank, rewarding deeper penetration.'\n    white_advance = sum(7 - chess.square_rank(square) for square, piece in board.piece_map().items() if piece.color == chess.WHITE)\n    black_advance = sum(chess.square_rank(square) for square, piece in board.piece_map().items() if piece.color == chess.BLACK)\n    return float(white_advance - black_advance)", "def feature(board: chess.Board) -> float:\n    'Determines if one side has more queen-side control compared to the other.'\n    queenside = [chess.A7, chess.B7, chess.C7, chess.D7, chess.A8, chess.B8, chess.C8, chess.D8]\n    white_control = sum(1 for square in queenside if board.is_attacked_by(chess.WHITE, square))\n    black_control = sum(1 for square in queenside if board.is_attacked_by(chess.BLACK, square))\n    return float(white_control - black_control)", "def feature(board: chess.Board) -> float:\n    \"Measures the total value of pieces on the board for both players.\"\n    piece_values = {chess.PAWN: 100, chess.KNIGHT: 320, chess.BISHOP: 330, chess.ROOK: 500, chess.QUEEN: 900, chess.KING: 20000}\n    total_value = 0.0\n    for piece in board.piece_map().values():\n        value = piece_values.get(piece.piece_type, 0)\n        total_value += value if piece.color == chess.WHITE else -value\n    return total_value", "def feature(board: chess.Board) -> float:\n    \"Counts the number of attacking pieces each color has against the opponent's king.\"\n    white_attackers = sum(1 for move in board.legal_moves if board.piece_at(move.to_square) and board.piece_at(move.to_square).color == chess.BLACK and board.is_attacked_by(chess.WHITE, move.to_square))\n    black_attackers = sum(1 for move in board.legal_moves if board.piece_at(move.to_square) and board.piece_at(move.to_square).color == chess.WHITE and board.is_attacked_by(chess.BLACK, move.to_square))\n    return float(white_attackers - black_attackers)", "def feature(board: chess.Board) -> float:\n    \"Measures the control of the central squares (d4, d5, e4, e5) by each player.\"\n    central_squares = [chess.parse_square('d4'), chess.parse_square('d5'), chess.parse_square('e4'), chess.parse_square('e5')]\n    white_control = sum(1 for sq in central_squares if board.is_attacked_by(chess.WHITE, sq))\n    black_control = sum(1 for sq in central_squares if board.is_attacked_by(chess.BLACK, sq))\n    return float(white_control - black_control)", "def feature(board: chess.Board) -> float:\n    \"Calculates the total mobility of the pieces based on the number of legal moves available.\"\n    white_mobility = len(list(board.legal_moves)) if board.turn else 0\n    black_mobility = len(list(board.legal_moves)) if not board.turn else 0\n    return float(white_mobility - black_mobility)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces that are blocked (cannot move due to being surrounded).\"\n    blocked_pieces = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == chess.WHITE:\n            legal_moves = sum(1 for move in board.legal_moves if move.from_square == square)\n            if legal_moves == 0:\n                blocked_pieces += 1\n    return float(blocked_pieces)", "def feature(board: chess.Board) -> float:\n    \"Measures the threat level: number of opponent's pieces directly threatening pieces on the board.\"\n    threat_level = 0.0\n    for square, piece in board.piece_map().items():\n        if piece.color == chess.WHITE:\n            threat_level += len(board.attackers(chess.BLACK, square))\n        else:\n            threat_level -= len(board.attackers(chess.WHITE, square))\n    return threat_level", "def feature(board: chess.Board) -> float:\n    \"Measures the imbalance of pawns compared to other pieces for both players.\"\n    white_pawn_count = len([p for p in board.piece_map().values() if p.color == chess.WHITE and p.piece_type == chess.PAWN])\n    black_pawn_count = len([p for p in board.piece_map().values() if p.color == chess.BLACK and p.piece_type == chess.PAWN])\n    white_non_pawn_count = len([p for p in board.piece_map().values() if p.color == chess.WHITE and p.piece_type != chess.PAWN])\n    black_non_pawn_count = len([p for p in board.piece_map().values() if p.color == chess.BLACK and p.piece_type != chess.PAWN])\n    if (white_non_pawn_count + black_non_pawn_count) == 0:\n        return 0.0\n    result = (white_pawn_count - black_pawn_count) / (white_non_pawn_count + black_non_pawn_count)\n    return result", "def feature(board: chess.Board) -> float:\n    \"Evaluates the control of the center squares (d4, d5, e4, e5) for both players.\"\n    center_squares = [chess.parse_square(sq) for sq in ['d4', 'd5', 'e4', 'e5']]\n    white_control = sum(1 for sq in center_squares if board.is_attacked_by(chess.WHITE, sq))\n    black_control = sum(1 for sq in center_squares if board.is_attacked_by(chess.BLACK, sq))\n    return float(white_control - black_control)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces attacking the opposing king.\"\n    white_king_square = next((sq for sq, piece in board.piece_map().items() if piece.color == chess.WHITE and piece.piece_type == chess.KING), None)\n    black_king_square = next((sq for sq, piece in board.piece_map().items() if piece.color == chess.BLACK and piece.piece_type == chess.KING), None)\n    white_attackers = len(board.attackers(chess.WHITE, black_king_square)) if black_king_square else 0\n    black_attackers = len(board.attackers(chess.BLACK, white_king_square)) if white_king_square else 0\n    return float(white_attackers - black_attackers)", "def feature(board: chess.Board) -> float:\n    \"Calculates the ratio of pieces in the opponent's half of the board.\"\n    white_pieces_in_enemy_half = sum(1 for sq, piece in board.piece_map().items() if piece.color == chess.WHITE and chess.square_rank(sq) >= 4)\n    black_pieces_in_enemy_half = sum(1 for sq, piece in board.piece_map().items() if piece.color == chess.BLACK and chess.square_rank(sq) <= 3)\n    total_pieces = len(board.piece_map())\n    if total_pieces == 0:\n        return 0.0\n    result = (white_pieces_in_enemy_half - black_pieces_in_enemy_half) / total_pieces\n    return result", "def feature(board: chess.Board) -> float:\n    \"Measures the number of doubled pawns for each color.\"\n    white_doubled_pawns = sum(1 for file in range(8) if sum(1 for rank in range(8) if board.piece_at(chess.square(file, rank)) == chess.PAWN and chess.WHITE and chess.square_file(chess.square(file, rank)) == file) > 1)\n    black_doubled_pawns = sum(1 for file in range(8) if sum(1 for rank in range(8) if board.piece_at(chess.square(file, rank)) == chess.PAWN and chess.BLACK and chess.square_file(chess.square(file, rank)) == file) > 1)\n    return float(white_doubled_pawns - black_doubled_pawns)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of passing pawns for both colors.\"\n    white_passing_pawns = sum(1 for sq, piece in board.piece_map().items() if piece.color == chess.WHITE and piece.piece_type == chess.PAWN and all(board.piece_at(chess.square(file, chess.square_rank(sq))) is None for file in range(chess.square_file(sq) + 1, 8)))\n    black_passing_pawns = sum(1 for sq, piece in board.piece_map().items() if piece.color == chess.BLACK and piece.piece_type == chess.PAWN and all(board.piece_at(chess.square(file, chess.square_rank(sq))) is None for file in range(0, chess.square_file(sq))))\n    return float(white_passing_pawns - black_passing_pawns)", "def feature(board: chess.Board) -> float:\n    \"Evaluates the number of open files for rooks on both sides.\"\n    white_rook_files = len(set(chess.square_file(sq) for sq, piece in board.piece_map().items() if piece.color == chess.WHITE and piece.piece_type == chess.ROOK and all(board.piece_at(chess.square(file, rank)) is None for rank in range(8) for file in range(chess.square_file(sq) + 1, 8))))\n    black_rook_files = len(set(chess.square_file(sq) for sq, piece in board.piece_map().items() if piece.color == chess.BLACK and piece.piece_type == chess.ROOK and all(board.piece_at(chess.square(file, rank)) is None for rank in range(8) for file in range(0, chess.square_file(sq)))))\n    return float(white_rook_files - black_rook_files)", "def feature(board: chess.Board) -> float:\n    \"Measures the relative king safety based on the number of squares around the king that are not attacked.\"\n    white_king_square = next((sq for sq, piece in board.piece_map().items() if piece.color == chess.WHITE and piece.piece_type == chess.KING), None)\n    black_king_square = next((sq for sq, piece in board.piece_map().items() if piece.color == chess.BLACK and piece.piece_type == chess.KING), None)\n    white_safe_squares = sum(1 for sq in chess.SQUARES_180 if board.is_attacked_by(chess.BLACK, sq) == False and chess.square_distance(sq, white_king_square) == 1)\n    black_safe_squares = sum(1 for sq in chess.SQUARES_180 if board.is_attacked_by(chess.WHITE, sq) == False and chess.square_distance(sq, black_king_square) == 1)\n    return float(white_safe_squares - black_safe_squares)", "def feature(board: chess.Board) -> float:\n    \"Measures the total number of pieces on the board.\"\n    return float(len(board.piece_map()))", "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in the number of pawns between both players.\"\n    white_pawns = len([square for square in board.piece_map() if board.piece_at(square).piece_type == chess.PAWN and board.piece_at(square).color == chess.WHITE])\n    black_pawns = len([square for square in board.piece_map() if board.piece_at(square).piece_type == chess.PAWN and board.piece_at(square).color == chess.BLACK])\n    return float(white_pawns - black_pawns)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces in the opponent's back rank.\"\n    back_rank = 0\n    for square in range(56, 64 if board.turn else 0, 1 if board.turn else -1):\n        piece = board.piece_at(square)\n        if piece and piece.color != board.turn:\n            back_rank += 1\n    return float(back_rank)", "def feature(board: chess.Board) -> float:\n    \"Measures the total number of legal moves for the side to move.\"\n    return float(len(list(board.legal_moves)))", "def feature(board: chess.Board) -> float:\n    \"Counts the number of squares attacked by both players.\"\n    attacked_squares = set()\n    for square in board.piece_map():\n        piece = board.piece_at(square)\n        if piece:\n            attacked_squares.update(board.attackers(piece.color, square))\n    return float(len(attacked_squares))", "def feature(board: chess.Board) -> float:\n    \"Calculates the distance of the kings to their respective back ranks.\"\n    if board.turn:\n        white_king_square = next(square for square in board.piece_map() if board.piece_at(square).piece_type == chess.KING and board.piece_at(square).color == chess.WHITE)\n        return float(chess.square_rank(white_king_square))\n    else:\n        black_king_square = next(square for square in board.piece_map() if board.piece_at(square).piece_type == chess.KING and board.piece_at(square).color == chess.BLACK)\n        return float(7 - chess.square_rank(black_king_square))", "def feature(board: chess.Board) -> float:\n    \"Calculates the ratio of pieces that are developed (not on original squares) to total pieces.\"\n    developed_pieces = 0\n    total_pieces = 0\n    initial_positions = {\n        chess.WHITE: {chess.A2, chess.B2, chess.C2, chess.D2, chess.E2, chess.F2, chess.G2, chess.H2, chess.A1, chess.B1, chess.C1, chess.D1, chess.E1, chess.F1, chess.G1, chess.H1},\n        chess.BLACK: {chess.A7, chess.B7, chess.C7, chess.D7, chess.E7, chess.F7, chess.G7, chess.H7, chess.A8, chess.B8, chess.C8, chess.D8, chess.E8, chess.F8, chess.G8, chess.H8}\n    }\n    \n    for square, piece in board.piece_map().items():\n        total_pieces += 1\n        if square not in initial_positions[piece.color]:\n            developed_pieces += 1\n\n    return float(developed_pieces) / total_pieces if total_pieces > 0 else 0.0", "def feature(board: chess.Board) -> float:\n    \"Measures the sum of the material values of all pieces for the player to move.\"\n    piece_values = {chess.PAWN: 100, chess.KNIGHT: 320, chess.BISHOP: 330, chess.ROOK: 500, chess.QUEEN: 900, chess.KING: 0}\n    total_value = 0\n\n    for square, piece in board.piece_map().items():\n        if piece.color == board.turn:\n            total_value += piece_values[piece.piece_type]\n\n    return float(total_value)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of pieces that are pinned against their king for the current player.\"\n    pinned_count = 0\n    king_square = next(square for square in board.piece_map() if board.piece_at(square).piece_type == chess.KING and board.piece_at(square).color == board.turn)\n    \n    for square in board.piece_map():\n        piece = board.piece_at(square)\n        if piece and piece.color == board.turn:\n            for target in board.attackers(not board.turn, king_square):\n                if board.is_attacked_by(not board.turn, square):\n                    pinned_count += 1\n                    break\n                    \n    return float(pinned_count)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces that are on their original squares.\"\n    original_positions = sum(1 for square, piece in board.piece_map().items() if piece.color == board.turn and (\n        (piece.piece_type == chess.PAWN and chess.square_rank(square) == (1 if piece.color == chess.WHITE else 6)) or\n        (piece.piece_type == chess.ROOK and chess.square_file(square) in [0, 7]) or\n        (piece.piece_type == chess.KNIGHT and chess.square_file(square) in [1, 6]) or\n        (piece.piece_type == chess.BISHOP and chess.square_file(square) in [2, 5]) or\n        (piece.piece_type == chess.QUEEN and chess.square_file(square) == 3) or\n        (piece.piece_type == chess.KING and chess.square_file(square) == 4)\n    ))\n    return float(original_positions)", "def feature(board: chess.Board) -> float:\n    \"Calculates the total number of pawns on the board for both players.\"\n    pawn_count = sum(1 for piece in board.piece_map().values() if piece.piece_type == chess.PAWN)\n    return float(pawn_count)", "def feature(board: chess.Board) -> float:\n    \"Computes the total value of the pieces currently on the board.\"\n    piece_values = {\n        chess.PAWN: 100,\n        chess.KNIGHT: 320,\n        chess.BISHOP: 330,\n        chess.ROOK: 500,\n        chess.QUEEN: 900,\n        chess.KING: 20000\n    }\n    total_value = sum(piece_values[piece.piece_type] for piece in board.piece_map().values())\n    return float(total_value)", "def feature(board: chess.Board) -> float:\n    \"Measures whether the position is double attacked by counting such instances.\"\n    double_attacked_count = sum(1 for square in board.piece_map() if board.is_attacked_by(not board.turn, square) and \n                                 len(board.attackers(not board.turn, square)) > 1)\n    return float(double_attacked_count)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of potential threats by calculating how many opponent pieces are attacked.\"\n    threats = sum(1 for square in board.piece_map() if board.is_attacked_by(board.turn, square))\n    return float(threats)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of pieces in the opponent's back rank.\"\n    opponent_back_rank = 0\n    for square in range(0, 8):\n        if board.piece_at(chess.parse_square(f'{chess.FILE_NAMES[square]}8' if board.turn == chess.WHITE else f'{chess.FILE_NAMES[square]}1')) is not None:\n            opponent_back_rank += 1\n    return float(opponent_back_rank)", "def feature(board: chess.Board) -> float:\n    \"Measures the total mobility by counting the number of legal moves available for each color.\"\n    white_moves = len(list(board.legal_moves))\n    board.turn = not board.turn  # Switch to the opponent's turn\n    black_moves = len(list(board.legal_moves))\n    return float(white_moves - black_moves)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pawns that are placed on the 7th rank (for White) or 2nd rank (for Black).\"\n    white_adv_pawns = sum(1 for sq in board.piece_map() if board.piece_at(sq).piece_type == chess.PAWN and chess.square_rank(sq) == 6)\n    black_adv_pawns = sum(1 for sq in board.piece_map() if board.piece_at(sq).piece_type == chess.PAWN and chess.square_rank(sq) == 1)\n    return float(white_adv_pawns - black_adv_pawns)", "def feature(board: chess.Board) -> float:\n    \"Assesses the safety of each king by checking their attacking squares.\"\n    white_king_square = next((sq for sq, piece in board.piece_map().items() if piece.color == chess.WHITE and piece.piece_type == chess.KING), None)\n    black_king_square = next((sq for sq, piece in board.piece_map().items() if piece.color == chess.BLACK and piece.piece_type == chess.KING), None)\n    white_defenses = sum(1 for sq in board.attackers(chess.WHITE, white_king_square))\n    black_defenses = sum(1 for sq in board.attackers(chess.BLACK, black_king_square))\n    return float(white_defenses - black_defenses)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces that are positioned on the back rank for each side.\"\n    white_back_rank = sum(1 for sq in range(0, 8) if board.piece_at(chess.square(sq, 0)) and board.piece_at(chess.square(sq, 0)).color == chess.WHITE)\n    black_back_rank = sum(1 for sq in range(0, 8) if board.piece_at(chess.square(sq, 7)) and board.piece_at(chess.square(sq, 7)).color == chess.BLACK)\n    return float(white_back_rank - black_back_rank)", "def feature(board: chess.Board) -> float:\n    \"Evaluates the presence of major pieces (queens and rooks) relative to minor pieces (knights and bishops).\"\n    major_pieces = sum(1 for piece in board.piece_map().values() if piece.piece_type in {chess.QUEEN, chess.ROOK})\n    minor_pieces = sum(1 for piece in board.piece_map().values() if piece.piece_type in {chess.KNIGHT, chess.BISHOP})\n    return float(major_pieces - minor_pieces)", "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in the number of coordinated pieces (total attack squares) between both players.\"\n    white_attack_squares = sum(len(board.attackers(chess.WHITE, sq)) for sq in board.piece_map() if board.piece_at(sq).color == chess.WHITE)\n    black_attack_squares = sum(len(board.attackers(chess.BLACK, sq)) for sq in board.piece_map() if board.piece_at(sq).color == chess.BLACK)\n    return float(white_attack_squares - black_attack_squares)", "def feature(board: chess.Board) -> float:\n    \"Measures the position of pieces on central squares (d4, d5, e4, e5) to evaluate control of the center.\"\n    central_squares = [chess.D4, chess.D5, chess.E4, chess.E5]\n    white_central_control = sum(1 for sq in central_squares if board.is_attacked_by(chess.WHITE, sq))\n    black_central_control = sum(1 for sq in central_squares if board.is_attacked_by(chess.BLACK, sq))\n    return float(white_central_control - black_central_control)", "def feature(board: chess.Board) -> float:\n    \"Counts the difference in the number of isolated pawns for both sides.\"\n    def is_isolated_pawn(square, color):\n        if color == chess.WHITE:\n            return (board.piece_at(square) and board.piece_at(square).piece_type == chess.PAWN and\n                    (not board.piece_at(square - 1) and not board.piece_at(square + 1)))\n        else:\n            return (board.piece_at(square) and board.piece_at(square).piece_type == chess.PAWN and\n                    (not board.piece_at(square - 1) and not board.piece_at(square + 1)))\n\n    white_isolated = sum(1 for sq in range(8) if is_isolated_pawn(chess.square(sq, 1), chess.WHITE))\n    black_isolated = sum(1 for sq in range(8) if is_isolated_pawn(chess.square(sq, 6), chess.BLACK))\n    return float(white_isolated - black_isolated)", "def feature(board: chess.Board) -> float:\n    \"Calculates the total number of protected pieces for the current player.\"\n    protected_pieces = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == board.turn:\n            attackers = board.attackers(not board.turn, square)\n            if all(board.piece_at(attacker) is None or board.piece_at(attacker).color == board.turn for attacker in attackers):\n                protected_pieces += 1\n    return float(protected_pieces)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of connected pawns for the current player.\"\n    connected_pawns = 0\n    pawns = [sq for sq, piece in board.piece_map().items() if piece.color == board.turn and piece.piece_type == chess.PAWN]\n    for pawn in pawns:\n        file = chess.square_file(pawn)\n        if (board.piece_at(chess.A1 + file - 1) and board.piece_at(chess.A1 + file - 1).color == board.turn) or \\\n           (board.piece_at(chess.A1 + file + 1) and board.piece_at(chess.A1 + file + 1).color == board.turn):\n            connected_pawns += 1\n    return float(connected_pawns)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces that are currently on open files.\"\n    open_file_count = 0\n    for file in range(8):\n        has_piece = any(board.piece_at(rank * 8 + file) for rank in range(8))\n        if not has_piece:\n            open_file_count += 1\n    return float(open_file_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in the number of major pieces (rooks and queens) for both players.\"\n    white_major_count = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE and piece.piece_type in (chess.ROOK, chess.QUEEN))\n    black_major_count = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK and piece.piece_type in (chess.ROOK, chess.QUEEN))\n    return float(white_major_count - black_major_count)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of squares controlled by the player's pieces.\"\n    controlled_squares = set()\n    for square, piece in board.piece_map().items():\n        if piece.color == board.turn:\n            for move in board.legal_moves:\n                if move.from_square == square:\n                    controlled_squares.add(move.to_square)\n    return float(len(controlled_squares))", "def feature(board: chess.Board) -> float:\n    \"Counts the number of isolated pawns for the current player.\"\n    isolated_pawns = 0\n    pawns = [sq for sq, piece in board.piece_map().items() if piece.color == board.turn and piece.piece_type == chess.PAWN]\n    for pawn in pawns:\n        file = chess.square_file(pawn)\n        if (file == 0 or board.piece_at(pawn - 1) is None or board.piece_at(pawn - 1).color != board.turn) and \\\n           (file == 7 or board.piece_at(pawn + 1) is None or board.piece_at(pawn + 1).color != board.turn):\n            isolated_pawns += 1\n    return float(isolated_pawns)", "def feature(board: chess.Board) -> float:\n    \"Calculates the average distance of the player's pieces from the opponent's king.\"\n    opponent_king_square = next(square for square, piece in board.piece_map().items() if piece.color != board.turn and piece.piece_type == chess.KING)\n    distances = []\n    for square, piece in board.piece_map().items():\n        if piece.color == board.turn:\n            distances.append(chess.square_distance(square, opponent_king_square))\n    return float(sum(distances) / len(distances)) if distances else 0.0", "def feature(board: chess.Board) -> float:\n    \"Calculates the total number of passed pawns for the current player.\"\n    passed_pawns = 0\n    pawns = [sq for sq, piece in board.piece_map().items() if piece.color == board.turn and piece.piece_type == chess.PAWN]\n    for pawn in pawns:\n        if all(board.piece_at(sq) is None or board.piece_at(sq).color != board.turn for sq in range(pawn, 64, 8) if sq > pawn):\n            passed_pawns += 1\n    return float(passed_pawns)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces each player has and gives a score based on the difference.\"\n    white_pieces = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE)\n    black_pieces = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK)\n    return float(white_pieces - black_pieces)", "def feature(board: chess.Board) -> float:\n    \"Measures the total value discrepancy of all pieces remaining for each side.\"\n    piece_values = {chess.PAWN: 100, chess.KNIGHT: 320, chess.BISHOP: 330,\n                    chess.ROOK: 500, chess.QUEEN: 900, chess.KING: 0}\n    white_value = sum(piece_values[piece.piece_type] for piece in board.piece_map().values() if piece.color == chess.WHITE)\n    black_value = sum(piece_values[piece.piece_type] for piece in board.piece_map().values() if piece.color == chess.BLACK)\n    return float(white_value - black_value)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces on the board for both players and computes their ratio.\"\n    white_count = len([p for p in board.piece_map().values() if p.color == chess.WHITE])\n    black_count = len([p for p in board.piece_map().values() if p.color == chess.BLACK])\n    return white_count / (black_count + 1)  # Avoid division by zero", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of controlled squares by the current player.\"\n    controlled_squares = sum(1 for sq in chess.SQUARES if board.is_attacked_by(board.turn, sq))\n    return float(controlled_squares)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pawns for each player and returns the difference in pawn count.\"\n    white_pawns = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE and piece.piece_type == chess.PAWN)\n    black_pawns = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK and piece.piece_type == chess.PAWN)\n    return float(white_pawns - black_pawns)", "def feature(board: chess.Board) -> float:\n    \"Calculates the overall mobility by summing the number of legal moves for both players.\"\n    white_moves = len(list(board.legal_moves)) if board.turn else 0\n    black_moves = len(list(board.legal_moves)) if not board.turn else 0\n    return float(white_moves - black_moves)", "def feature(board: chess.Board) -> float:\n    \"Measures how many pieces are on the back rank of each player.\"\n    white_back_rank = sum(1 for square in range(56, 64) if board.piece_at(square) and board.piece_at(square).color == chess.WHITE)\n    black_back_rank = sum(1 for square in range(0, 8) if board.piece_at(square) and board.piece_at(square).color == chess.BLACK)\n    return float(white_back_rank - black_back_rank)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of squares each side has available to their king, contributing to king safety.\"\n    white_king_square = next((s for s, p in board.piece_map().items() if p.color == chess.WHITE and p.piece_type == chess.KING), None)\n    black_king_square = next((s for s, p in board.piece_map().items() if p.color == chess.BLACK and p.piece_type == chess.KING), None)\n    \n    def count_king_squares(king_square):\n        if king_square is None:\n            return 0\n        return sum(1 for move in chess.SQUARES if board.is_legal(chess.Move(king_square, move)))\n\n    return float(count_king_squares(white_king_square) - count_king_squares(black_king_square))", "def feature(board: chess.Board) -> float:\n    \"Measures the effectiveness of the positioning of major pieces (queen and rooks) on the board.\"\n    white_major = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE and piece.piece_type in [chess.QUEEN, chess.ROOK])\n    black_major = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK and piece.piece_type in [chess.QUEEN, chess.ROOK])\n    return float(white_major - black_major)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces for each player and returns the difference.\"\n    white_count = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE)\n    black_count = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK)\n    return float(white_count - black_count)", "def feature(board: chess.Board) -> float:\n    \"Measures the total mobility of pieces for both sides.\"\n    white_mobility = sum(len(list(board.legal_moves)) for square, piece in board.piece_map().items() if piece.color == chess.WHITE)\n    black_mobility = sum(len(list(board.legal_moves)) for square, piece in board.piece_map().items() if piece.color == chess.BLACK)\n    return float(white_mobility - black_mobility)", "def feature(board: chess.Board) -> float:\n    \"Measures the king safety by counting the number of squares around the kings that are attacked.\"\n    white_king_square = next(square for square, piece in board.piece_map().items() if piece.color == chess.WHITE and piece.piece_type == chess.KING)\n    black_king_square = next(square for square, piece in board.piece_map().items() if piece.color == chess.BLACK and piece.piece_type == chess.KING)\n    white_king_safety = sum(board.is_attacked_by(chess.BLACK, square) for square in board.attacks(white_king_square))\n    black_king_safety = sum(board.is_attacked_by(chess.WHITE, square) for square in board.attacks(black_king_square))\n    return float(black_king_safety - white_king_safety)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of isolated pawns for each player.\"\n    white_isolated = sum(1 for square in board.piece_map() if board.piece_at(square).color == chess.WHITE and board.piece_at(square).piece_type == chess.PAWN and \n                         (board.piece_at(square + 1) is None) and (board.piece_at(square - 1) is None))\n    black_isolated = sum(1 for square in board.piece_map() if board.piece_at(square).color == chess.BLACK and board.piece_at(square).piece_type == chess.PAWN and \n                         (board.piece_at(square + 1) is None) and (board.piece_at(square - 1) is None))\n    return float(white_isolated - black_isolated)", "def feature(board: chess.Board) -> float:\n    \"Measures the influence of bishops on the board by counting the number of controlled squares for each.\"\n    white_bishop_influence = sum(len(board.attacks(square)) for square in board.piece_map() if board.piece_at(square).color == chess.WHITE and board.piece_at(square).piece_type == chess.BISHOP)\n    black_bishop_influence = sum(len(board.attacks(square)) for square in board.piece_map() if board.piece_at(square).color == chess.BLACK and board.piece_at(square).piece_type == chess.BISHOP)\n    return float(white_bishop_influence - black_bishop_influence)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces that are pinned on the board.\"\n    pinned_pieces = sum(1 for square in board.piece_map() if board.is_attacked_by(not board.piece_at(square).color, square) and \n                        any(board.is_attacked_by(board.piece_at(square).color, target) for target in board.attackers(board.piece_at(square).color, square)))\n    return float(pinned_pieces)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of squares that are defended but not occupied by pieces.\"\n    defended_squares = sum(1 for square in range(64) if board.is_attacked_by(chess.WHITE, square) and board.piece_at(square) is None)\n    return float(defended_squares)", "def feature(board: chess.Board) -> float:\n    \"Measures the central control by counting pieces placed in the center squares.\"\n    center_squares = [chess.E4, chess.E5, chess.D4, chess.D5]\n    white_center_control = sum(1 for square in center_squares if board.piece_at(square) is not None and board.piece_at(square).color == chess.WHITE)\n    black_center_control = sum(1 for square in center_squares if board.piece_at(square) is not None and board.piece_at(square).color == chess.BLACK)\n    return float(white_center_control - black_center_control)", "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in mobility between both players based on their legal moves.\"\n    white_moves = len(list(board.legal_moves)) if board.turn else 0\n    black_moves = len(list(board.legal_moves)) if not board.turn else 0\n    return float(white_moves - black_moves)", "def feature(board: chess.Board) -> float:\n    \"Measures the difference in material based on the value of pieces in play.\"\n    piece_values = {chess.PAWN: 100, chess.KNIGHT: 300, chess.BISHOP: 300,\n                    chess.ROOK: 500, chess.QUEEN: 900, chess.KING: 0}\n    white_score = sum(piece_values[piece.piece_type] for piece in board.piece_map().values() if piece.color == chess.WHITE)\n    black_score = sum(piece_values[piece.piece_type] for piece in board.piece_map().values() if piece.color == chess.BLACK)\n    return float(white_score - black_score)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces that are positioned on the back rank.\"\n    white_back_rank = sum(1 for sq in range(56, 64) if board.piece_at(sq) and board.piece_at(sq).color == chess.WHITE)\n    black_back_rank = sum(1 for sq in range(0, 8) if board.piece_at(sq) and board.piece_at(sq).color == chess.BLACK)\n    return float(white_back_rank - black_back_rank)", "def feature(board: chess.Board) -> float:\n    \"Calculates the total number of squares that are attacked by each player's pieces.\"\n    white_attacks = sum(board.is_attacked_by(chess.WHITE, sq) for sq in chess.SQUARES)\n    black_attacks = sum(board.is_attacked_by(chess.BLACK, sq) for sq in chess.SQUARES)\n    return float(white_attacks - black_attacks)", "def feature(board: chess.Board) -> float:\n    \"Measures the control over central squares by both players.\"\n    central_squares = [chess.E4, chess.E5, chess.D4, chess.D5]\n    white_control = sum(1 for sq in central_squares if board.is_attacked_by(chess.WHITE, sq))\n    black_control = sum(1 for sq in central_squares if board.is_attacked_by(chess.BLACK, sq))\n    return float(white_control - black_control)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of minor pieces (Knights and Bishops) each player has.\"\n    white_minor = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE and piece.piece_type in {chess.KNIGHT, chess.BISHOP})\n    black_minor = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK and piece.piece_type in {chess.KNIGHT, chess.BISHOP})\n    return float(white_minor - black_minor)", "def feature(board: chess.Board) -> float:\n    \"Measures the total distance of all pieces from their respective home ranks.\"\n    white_distance = sum(chess.square_rank(sq) for sq, piece in board.piece_map().items() if piece.color == chess.WHITE)\n    black_distance = sum(7 - chess.square_rank(sq) for sq, piece in board.piece_map().items() if piece.color == chess.BLACK)\n    return float(white_distance - black_distance)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of pieces each player has on the seventh rank.\"\n    white_seventh_rank = sum(1 for sq in range(56, 64) if board.piece_at(sq) and board.piece_at(sq).color == chess.WHITE)\n    black_seventh_rank = sum(1 for sq in range(0, 8) if board.piece_at(sq) and board.piece_at(sq).color == chess.BLACK)\n    return float(white_seventh_rank - black_seventh_rank)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pawns on the board and their potential passed status.\"\n    white_pawns = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE and piece.piece_type == chess.PAWN)\n    black_pawns = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK and piece.piece_type == chess.PAWN)\n    return float(white_pawns - black_pawns)", "def feature(board: chess.Board) -> float:\n    \"Measures the difference in the number of pieces for each side on the board.\"\n    white_pieces = sum(1 for p in board.piece_map().values() if p.color == chess.WHITE)\n    black_pieces = sum(1 for p in board.piece_map().values() if p.color == chess.BLACK)\n    return float(white_pieces - black_pieces)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pawns on the board for both players as a simple material measure.\"\n    white_pawns = sum(1 for sq in board.piece_map() if board.piece_at(sq).piece_type == chess.PAWN and board.piece_at(sq).color == chess.WHITE)\n    black_pawns = sum(1 for sq in board.piece_map() if board.piece_at(sq).piece_type == chess.PAWN and board.piece_at(sq).color == chess.BLACK)\n    return float(white_pawns - black_pawns)", "def feature(board: chess.Board) -> float:\n    \"Calculates the total number of moves available for the player to move.\"\n    return float(len(list(board.legal_moves)))", "def feature(board: chess.Board) -> float:\n    \"Measures the number of squares under attack by each player's pieces.\"\n    white_attacks = sum(1 for sq in range(64) if board.is_attacked_by(chess.WHITE, sq))\n    black_attacks = sum(1 for sq in range(64) if board.is_attacked_by(chess.BLACK, sq))\n    return float(white_attacks - black_attacks)", "def feature(board: chess.Board) -> float:\n    \"Calculates the total piece value based on standard material values for pieces.\"\n    piece_values = {chess.PAWN: 100, chess.KNIGHT: 300, chess.BISHOP: 300, chess.ROOK: 500, chess.QUEEN: 900, chess.KING: 0}\n    total_value = sum(piece_values[board.piece_at(sq).piece_type] for sq in board.piece_map() if board.piece_at(sq) is not None)\n    return float(total_value)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces developed (i.e., not on the starting ranks).\"\n    developed_white = sum(1 for sq in board.piece_map() if board.piece_at(sq).color == chess.WHITE and chess.square_rank(sq) > 1)\n    developed_black = sum(1 for sq in board.piece_map() if board.piece_at(sq).color == chess.BLACK and chess.square_rank(sq) < 6)\n    return float(developed_white - developed_black)", "def feature(board: chess.Board) -> float:\n    \"Measures the activity of the kings by counting the number of squares they can move to.\"\n    def king_activity(color):\n        king_square = next(sq for sq in board.piece_map() if board.piece_at(sq).piece_type == chess.KING and board.piece_at(sq).color == color)\n        return sum(1 for sq in range(64) if chess.square_distance(king_square, sq) == 1 and board.piece_at(sq) is None)\n    \n    return float(king_activity(chess.WHITE) - king_activity(chess.BLACK))", "def feature(board: chess.Board) -> float:\n    \"Evaluates the king safety based on the number of controlled squares around each king.\"\n    def king_safety(color):\n        king_square = next(sq for sq in board.piece_map() if board.piece_at(sq).piece_type == chess.KING and board.piece_at(sq).color == color)\n        controlled_squares = sum(1 for sq in range(64) if board.is_attacked_by(not color, sq) and chess.square_distance(king_square, sq) <= 1)\n        return controlled_squares\n    \n    return float(king_safety(chess.WHITE) - king_safety(chess.BLACK))", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces in the opponent's half of the board.\"\n    opponent_color = chess.BLACK if board.turn else chess.WHITE\n    return float(sum(1 for sq in board.piece_map() if board.piece_at(sq).color == opponent_color and chess.square_rank(sq) >= 4))", "def feature(board: chess.Board) -> float:\n    \"Measures the ratio of major pieces (Queens and Rooks) to minor pieces (Knights and Bishops).\"\n    major_white = sum(1 for sq in board.piece_map() if board.piece_at(sq).color == chess.WHITE and board.piece_at(sq).piece_type in [chess.QUEEN, chess.ROOK])\n    major_black = sum(1 for sq in board.piece_map() if board.piece_at(sq).color == chess.BLACK and board.piece_at(sq).piece_type in [chess.QUEEN, chess.ROOK])\n    minor_white = sum(1 for sq in board.piece_map() if board.piece_at(sq).color == chess.WHITE and board.piece_at(sq).piece_type in [chess.KNIGHT, chess.BISHOP])\n    minor_black = sum(1 for sq in board.piece_map() if board.piece_at(sq).color == chess.BLACK and board.piece_at(sq).piece_type in [chess.KNIGHT, chess.BISHOP])\n    return float((major_white + minor_white) - (major_black + minor_black))", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces for each player and returns the difference.\"\n    white_piece_count = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE)\n    black_piece_count = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK)\n    return float(white_piece_count - black_piece_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the total value of pieces for each player and returns the difference.\"\n    piece_values = {chess.PAWN: 100, chess.KNIGHT: 320, chess.BISHOP: 330, chess.ROOK: 500, chess.QUEEN: 900, chess.KING: 0}\n    white_value = sum(piece_values[piece.piece_type] for piece in board.piece_map().values() if piece.color == chess.WHITE)\n    black_value = sum(piece_values[piece.piece_type] for piece in board.piece_map().values() if piece.color == chess.BLACK)\n    return float(white_value - black_value)", "def feature(board: chess.Board) -> float:\n    \"Calculates the mobility of pieces by counting legal moves for all pieces.\"\n    mobility = sum(len(list(board.legal_moves)) for square in board.piece_map() if board.piece_at(square).color == board.turn)\n    return float(mobility)", "def feature(board: chess.Board) -> float:\n    \"Measures king safety by counting the number of squares the king can escape to.\"\n    king_square = next((square for square in board.piece_map() if board.piece_at(square).piece_type == chess.KING and board.piece_at(square).color == board.turn), None)\n    if king_square is None:\n        return 0.0\n    escape_squares = sum(1 for move in board.legal_moves if move.from_square == king_square)\n    return float(escape_squares)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of pieces directly controlling the central squares.\"\n    central_squares = [chess.D4, chess.D5, chess.E4, chess.E5]\n    control_count = sum(1 for square in central_squares if any(board.is_attacked_by(piece.color, square) for piece in board.piece_map().values()))\n    return float(control_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of pawns that are advanced (more than 4 ranks for white, less than 4 ranks for black).\"\n    forward_pawns = sum(1 for square, piece in board.piece_map().items() if piece.piece_type == chess.PAWN and \n                        ((piece.color == chess.WHITE and chess.square_rank(square) > 4) or \n                         (piece.color == chess.BLACK and chess.square_rank(square) < 4)))\n    return float(forward_pawns)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of knights on the board and checks if they are centralized (e.g., on squares D4, D5, E4, E5).\"\n    knight_positions = [chess.D4, chess.D5, chess.E4, chess.E5]\n    knight_count = sum(1 for square in board.piece_map() if (board.piece_at(square).piece_type == chess.KNIGHT and \n                                                              square in knight_positions))\n    return float(knight_count)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of open files for rooks.\"\n    open_files = [file for file in range(8) if all(board.piece_at(chess.square(file, rank)) is None for rank in range(8))]\n    return float(len(open_files))", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of pieces that are attacked (threatened by opponent).\"\n    attacked_count = sum(1 for square in board.piece_map() if board.is_attacked_by(not board.piece_at(square).color, square))\n    return float(attacked_count)", "def feature(board: chess.Board) -> float:\n    \"Measures the control of the back rank by counting pieces along the seventh rank for the opponent.\"\n    back_rank_pieces = [square for square in board.piece_map() if chess.square_rank(square) == (0 if board.turn == chess.WHITE else 7) and \n                        board.piece_at(square).color == (chess.WHITE if board.turn == chess.BLACK else chess.BLACK)]\n    return float(len(back_rank_pieces))", "def feature(board: chess.Board) -> float:\n    \"Measures the difference in pawn structure for both players.\"\n    white_pawns = sum(1 for sq in board.piece_map() if board.piece_at(sq).color == chess.WHITE and board.piece_at(sq).piece_type == chess.PAWN)\n    black_pawns = sum(1 for sq in board.piece_map() if board.piece_at(sq).color == chess.BLACK and board.piece_at(sq).piece_type == chess.PAWN)\n    return float(white_pawns - black_pawns)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of squares controlled by each player.\"\n    controlled_by_white = sum(1 for sq in chess.SQUARES if board.is_attacked_by(chess.WHITE, sq))\n    controlled_by_black = sum(1 for sq in chess.SQUARES if board.is_attacked_by(chess.BLACK, sq))\n    return float(controlled_by_white - controlled_by_black)", "def feature(board: chess.Board) -> float:\n    \"Calculates the mobility of the side to move by counting legal moves.\"\n    return float(len(list(board.legal_moves)))", "def feature(board: chess.Board) -> float:\n    \"Measures the total value of pieces remaining for each color.\"\n    piece_values = {chess.PAWN: 100, chess.KNIGHT: 320, chess.BISHOP: 330, chess.ROOK: 500, chess.QUEEN: 900, chess.KING: 0}\n    white_value = sum(piece_values[board.piece_at(sq).piece_type] for sq in board.piece_map() if board.piece_at(sq).color == chess.WHITE)\n    black_value = sum(piece_values[board.piece_at(sq).piece_type] for sq in board.piece_map() if board.piece_at(sq).color == chess.BLACK)\n    return float(white_value - black_value)", "def feature(board: chess.Board) -> float:\n    \"Measures the distance of the kings from the center of the board.\"\n    white_king_pos = next(sq for sq in board.piece_map() if board.piece_at(sq).color == chess.WHITE and board.piece_at(sq).piece_type == chess.KING)\n    black_king_pos = next(sq for sq in board.piece_map() if board.piece_at(sq).color == chess.BLACK and board.piece_at(sq).piece_type == chess.KING)\n    white_distance = chess.square_distance(white_king_pos, chess.E4)\n    black_distance = chess.square_distance(black_king_pos, chess.E4)\n    return float(black_distance - white_distance)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of pieces that are pinned.\"\n    pinned_pieces = sum(1 for sq in board.piece_map() if board.piece_at(sq).color == board.turn and len(board.attackers(not board.turn, sq)) > 0 and board.is_attacked_by(not board.turn, sq))\n    return float(pinned_pieces)", "def feature(board: chess.Board) -> float:\n    \"Measures the rook or queen placement on open files.\"\n    open_files = 0\n    for file in range(8):\n        if not any(board.piece_at(sq) for sq in chess.SQUARES if chess.square_file(sq) == file):\n            open_files += sum(1 for sq in chess.SQUARES if chess.square_file(sq) == file and board.piece_at(sq) and (board.piece_at(sq).piece_type == chess.ROOK or board.piece_at(sq).piece_type == chess.QUEEN) and board.piece_at(sq).color == board.turn)\n    return float(open_files)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of pieces each side has on the 7th and 8th ranks as a measure of activity.\"\n    pieces_on_7th_rank = sum(1 for sq in board.piece_map() if chess.square_rank(sq) == 6 and board.piece_at(sq).color == board.turn)\n    pieces_on_8th_rank = sum(1 for sq in board.piece_map() if chess.square_rank(sq) == 7 and board.piece_at(sq).color != board.turn)\n    return float(pieces_on_7th_rank - pieces_on_8th_rank)", "def feature(board: chess.Board) -> float:\n    \"Measures the total number of pawns on the board for both sides.\"\n    white_pawns = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE and piece.piece_type == chess.PAWN)\n    black_pawns = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK and piece.piece_type == chess.PAWN)\n    return float(white_pawns - black_pawns)", "def feature(board: chess.Board) -> float:\n    \"Calculates the total mobility for each side based on legal moves.\"\n    white_mobility = len(list(board.legal_moves)) if board.turn else 0\n    black_mobility = len(list(board.legal_moves)) if not board.turn else 0\n    return float(white_mobility - black_mobility)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of squares each side controls by their pieces.\"\n    controlled_squares = {chess.WHITE: set(), chess.BLACK: set()}\n    for square in range(64):\n        piece = board.piece_at(square)\n        if piece:\n            if piece.color == chess.WHITE:\n                controlled_squares[chess.WHITE].update(board.attackers(chess.WHITE, square))\n            else:\n                controlled_squares[chess.BLACK].update(board.attackers(chess.BLACK, square))\n    return float(len(controlled_squares[chess.WHITE]) - len(controlled_squares[chess.BLACK]))", "def feature(board: chess.Board) -> float:\n    \"Measures the relative position of kings based on distance.\"\n    white_king_square = next((sq for sq, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color == chess.WHITE), None)\n    black_king_square = next((sq for sq, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color == chess.BLACK), None)\n    if white_king_square is not None and black_king_square is not None:\n        return float(chess.square_distance(white_king_square, black_king_square))\n    return 0.0", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of pieces on the board for each side, normalized by total piece count.\"\n    piece_count_white = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE)\n    piece_count_black = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK)\n    total_pieces = piece_count_white + piece_count_black\n    return float(piece_count_white / total_pieces - piece_count_black / total_pieces) if total_pieces > 0 else 0.0", "def feature(board: chess.Board) -> float:\n    \"Measures the total value of pieces for each color based on standard values.\"\n    piece_values = {chess.PAWN: 100, chess.KNIGHT: 320, chess.BISHOP: 330, chess.ROOK: 500, chess.QUEEN: 900, chess.KING: 0}\n    white_value = sum(piece_values[piece.piece_type] for piece in board.piece_map().values() if piece.color == chess.WHITE)\n    black_value = sum(piece_values[piece.piece_type] for piece in board.piece_map().values() if piece.color == chess.BLACK)\n    return float(white_value - black_value)", "def feature(board: chess.Board) -> float:\n    \"Determines if either king is in check or checkmate.\"\n    if board.is_checkmate():\n        return -9999.0 if board.turn else 9999.0\n    return 1.0 if board.is_check() else 0.0", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces attacking the opponent's king.\"\n    white_king_square = next((sq for sq, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color == chess.WHITE), None)\n    black_king_square = next((sq for sq, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color == chess.BLACK), None)\n    white_attacks = len(board.attackers(chess.WHITE, black_king_square)) if black_king_square else 0\n    black_attacks = len(board.attackers(chess.BLACK, white_king_square)) if white_king_square else 0\n    return float(white_attacks - black_attacks)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of pieces under attack by opponent's pieces.\"\n    white_under_attack = sum(1 for sq, piece in board.piece_map().items() if piece.color == chess.WHITE and board.is_attacked_by(chess.BLACK, sq))\n    black_under_attack = sum(1 for sq, piece in board.piece_map().items() if piece.color == chess.BLACK and board.is_attacked_by(chess.WHITE, sq))\n    return float(white_under_attack - black_under_attack)", "def feature(board: chess.Board) -> float:\n    \"Measures the count of pawns for both sides, indicating potential endgame strength.\"\n    white_pawns = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE and piece.piece_type == chess.PAWN)\n    black_pawns = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK and piece.piece_type == chess.PAWN)\n    return float(white_pawns - black_pawns)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of squares occupied by pieces, indicating board control.\"\n    occupied_squares = sum(1 for square in board.piece_map() if board.piece_at(square) is not None)\n    return float(occupied_squares)", "def feature(board: chess.Board) -> float:\n    \"Evaluates the number of pieces in danger (attacked) for each player.\"\n    white_in_danger = sum(1 for square in board.piece_map() if board.piece_at(square).color == chess.WHITE and board.is_attacked_by(chess.BLACK, square))\n    black_in_danger = sum(1 for square in board.piece_map() if board.piece_at(square).color == chess.BLACK and board.is_attacked_by(chess.WHITE, square))\n    return float(white_in_danger - black_in_danger)", "def feature(board: chess.Board) -> float:\n    \"Measures the distance of the kings from the center of the board, indicating safety.\"\n    white_king_square = next(square for square in board.piece_map() if board.piece_at(square).color == chess.WHITE and board.piece_at(square).piece_type == chess.KING)\n    black_king_square = next(square for square in board.piece_map() if board.piece_at(square).color == chess.BLACK and board.piece_at(square).piece_type == chess.KING)\n    center_square = chess.parse_square('e4')\n    distance_white = chess.square_distance(white_king_square, center_square)\n    distance_black = chess.square_distance(black_king_square, center_square)\n    return float(distance_black - distance_white)", "def feature(board: chess.Board) -> float:\n    \"Calculates the total number of pieces remaining on the board, indicating endgame stage.\"\n    total_pieces = len(board.piece_map())\n    return float(total_pieces)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces attacking the opponent's king, reflecting tactical pressure.\"\n    white_king_square = next(square for square in board.piece_map() if board.piece_at(square).color == chess.WHITE and board.piece_at(square).piece_type == chess.KING)\n    black_king_square = next(square for square in board.piece_map() if board.piece_at(square).color == chess.BLACK and board.piece_at(square).piece_type == chess.KING)\n    white_attackers = len(board.attackers(chess.WHITE, black_king_square))\n    black_attackers = len(board.attackers(chess.BLACK, white_king_square))\n    return float(white_attackers - black_attackers)", "def feature(board: chess.Board) -> float:\n    \"Calculates the activity of rooks as a ratio to their total count.\"\n    white_rooks = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE and piece.piece_type == chess.ROOK)\n    black_rooks = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK and piece.piece_type == chess.ROOK)\n    active_white_rooks = sum(1 for square in board.piece_map() if board.piece_at(square).color == chess.WHITE and chess.square_file(square) in (0, 7))\n    active_black_rooks = sum(1 for square in board.piece_map() if board.piece_at(square).color == chess.BLACK and chess.square_file(square) in (0, 7))\n    return float(active_white_rooks / (white_rooks + 1e-5) - active_black_rooks / (black_rooks + 1e-5))", "def feature(board: chess.Board) -> float:\n    \"Measures the material difference between queens and knights.\"\n    white_queens = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE and piece.piece_type == chess.QUEEN)\n    black_queens = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK and piece.piece_type == chess.QUEEN)\n    white_knights = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE and piece.piece_type == chess.KNIGHT)\n    black_knights = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK and piece.piece_type == chess.KNIGHT)\n    return float((white_queens - black_queens) * 9 + (white_knights - black_knights) * 3)", "def feature(board: chess.Board) -> float:\n    \"Counts the total number of pawns that can promote, reflecting potential endgame advantage.\"\n    promoting_pawns = sum(1 for square in board.piece_map() if board.piece_at(square).piece_type == chess.PAWN and \n                          ((board.piece_at(square).color == chess.WHITE and chess.square_rank(square) == 6) or\n                           (board.piece_at(square).color == chess.BLACK and chess.square_rank(square) == 1)))\n    return float(promoting_pawns)", "def feature(board: chess.Board) -> float:\n    \"Evaluates the total number of attacking pieces for both sides.\"\n    white_attacks = sum(len(board.attackers(chess.WHITE, square)) for square in board.piece_map() if board.piece_at(square) and board.piece_at(square).color == chess.WHITE)\n    black_attacks = sum(len(board.attackers(chess.BLACK, square)) for square in board.piece_map() if board.piece_at(square) and board.piece_at(square).color == chess.BLACK)\n    return float(white_attacks - black_attacks)", "def feature(board: chess.Board) -> float:\n    \"Calculates the central control by counting pieces in central squares.\"\n    central_squares = [chess.D4, chess.D5, chess.E4, chess.E5]\n    control = sum(1 for square in central_squares if board.piece_at(square) and board.piece_at(square).color == chess.WHITE) - \\\n              sum(1 for square in central_squares if board.piece_at(square) and board.piece_at(square).color == chess.BLACK)\n    return float(control)", "def feature(board: chess.Board) -> float:\n    \"Measures the king safety by counting pawns around the kings.\"\n    def count_pawns_around(king_square):\n        return sum(1 for dx in [-1, 0, 1] for dy in [-1, 0, 1] \n                   if (0 <= chess.square_file(king_square) + dx <= 7 and \n                       0 <= chess.square_rank(king_square) + dy <= 7 and \n                       board.piece_at(chess.square_file(king_square) + dx + (chess.square_rank(king_square) + dy) * 8) == chess.PAWN))\n    \n    white_king_square = next(square for square in board.piece_map() if board.piece_at(square).piece_type == chess.KING and board.piece_at(square).color == chess.WHITE)\n    black_king_square = next(square for square in board.piece_map() if board.piece_at(square).piece_type == chess.KING and board.piece_at(square).color == chess.BLACK)\n    return float(count_pawns_around(white_king_square) - count_pawns_around(black_king_square))", "def feature(board: chess.Board) -> float:\n    \"Counts the number of open files for both rooks.\"\n    def count_open_files(color):\n        return sum(1 for file in range(8) if all(board.piece_at(8 * rank + file) is None or board.piece_at(8 * rank + file).color != color for rank in range(8)))\n\n    return float(count_open_files(chess.WHITE) - count_open_files(chess.BLACK))", "def feature(board: chess.Board) -> float:\n    \"Measures the number of pieces defending the most valuable piece on the board for each side.\"\n    def strongest_piece_defenders(color):\n        pieces = [piece for piece in board.piece_map().values() if piece.color == color]\n        if not pieces:\n            return 0\n        strongest = max(pieces, key=lambda p: p.piece_type)\n        return sum(1 for square in board.piece_map() if board.is_attacked_by(color, square) and board.piece_at(square).color == color)\n\n    return float(strongest_piece_defenders(chess.WHITE) - strongest_piece_defenders(chess.BLACK))", "def feature(board: chess.Board) -> float:\n    \"Calculates the mobility of the pieces by counting the legal moves.\"\n    white_mobility = len(list(board.legal_moves)) if board.turn == chess.WHITE else 0\n    black_mobility = len(list(board.legal_moves)) if board.turn == chess.BLACK else 0\n    return float(white_mobility - black_mobility)", "def feature(board: chess.Board) -> float:\n    \"Measures the disparity in piece values lost during the game.\"\n    def piece_value(piece):\n        value_dict = {chess.PAWN: 100, chess.KNIGHT: 300, chess.BISHOP: 300, chess.ROOK: 500, chess.QUEEN: 900, chess.KING: 0}\n        return value_dict.get(piece.piece_type, 0)\n\n    total_value = sum(piece_value(piece) for piece in board.piece_map().values())\n    return float(total_value)", "def feature(board: chess.Board) -> float:\n    \"Evaluates the coordination between major pieces (rooks and queens) on open ranks and files.\"\n    white_major_pieces = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE and piece.piece_type in [chess.ROOK, chess.QUEEN])\n    black_major_pieces = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK and piece.piece_type in [chess.ROOK, chess.QUEEN])\n    return float(white_major_pieces - black_major_pieces)", "def feature(board: chess.Board) -> float:\n    \"Assesses the position on the board by counting the number of isolated pawns.\"\n    def count_isolated_pawns(color):\n        isolated_count = 0\n        pawns = [square for square in board.piece_map() if board.piece_at(square).color == color and board.piece_at(square).piece_type == chess.PAWN]\n        for square in pawns:\n            file = chess.square_file(square)\n            if not (board.piece_at(square - 1) and board.piece_at(square - 1).color == color) and not (board.piece_at(square + 1) and board.piece_at(square + 1).color == color):\n                isolated_count += 1\n        return isolated_count\n\n    return float(count_isolated_pawns(chess.WHITE) - count_isolated_pawns(chess.BLACK))", "def feature(board: chess.Board) -> float:\n    \"Measures the total mobility of pieces by counting the number of legal moves for each side.\"\n    white_moves = sum(1 for _ in board.legal_moves if board.turn)\n    board.turn = not board.turn\n    black_moves = sum(1 for _ in board.legal_moves if board.turn)\n    board.turn = not board.turn\n    return float(white_moves - black_moves)", "def feature(board: chess.Board) -> float:\n    \"Calculates a simple heuristic for edge control by counting pieces on the a and h files.\"\n    edge_control = 0\n    for file in [0, 7]:  # a-file and h-file\n        for rank in range(8):\n            piece = board.piece_at(chess.square(file, rank))\n            if piece is not None:\n                if piece.color == chess.WHITE:\n                    edge_control += 1\n                else:\n                    edge_control -= 1\n    return float(edge_control)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of occupied centers by counting pieces on d4, e4, d5, and e5.\"\n    center_squares = [chess.square(3, 3), chess.square(4, 3), chess.square(3, 4), chess.square(4, 4)]\n    center_control = 0\n    for square in center_squares:\n        piece = board.piece_at(square)\n        if piece is not None:\n            if piece.color == chess.WHITE:\n                center_control += 1\n            else:\n                center_control -= 1\n    return float(center_control)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces that are pinned by the opponent's pieces.\"\n    pinned_count = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == board.turn:\n            for attacker in board.attackers(not board.turn, square):\n                if board.piece_at(attacker) and board.piece_at(attacker).piece_type in [chess.QUEEN, chess.ROOK]:\n                    pinned_count += 1\n                    break\n    return float(pinned_count)", "def feature(board: chess.Board) -> float:\n    \"Measures the difference in the number of protected pieces for both sides.\"\n    protected_pieces = {chess.WHITE: 0, chess.BLACK: 0}\n    for square, piece in board.piece_map().items():\n        if piece is not None:\n            if board.is_attacked_by(not piece.color, square) is False:\n                protected_pieces[piece.color] += 1\n    return float(protected_pieces[chess.WHITE] - protected_pieces[chess.BLACK])", "def feature(board: chess.Board) -> float:\n    \"Evaluates the number of doubled pawns for each player.\"\n    doubled_pawns = {chess.WHITE: 0, chess.BLACK: 0}\n    for file in range(8):\n        white_pawns = sum(1 for rank in range(8) if board.piece_at(chess.square(file, rank)) == chess.PAWN and board.piece_at(chess.square(file, rank)).color == chess.WHITE)\n        black_pawns = sum(1 for rank in range(8) if board.piece_at(chess.square(file, rank)) == chess.PAWN and board.piece_at(chess.square(file, rank)).color == chess.BLACK)\n        if white_pawns > 1:\n            doubled_pawns[chess.WHITE] += 1\n        if black_pawns > 1:\n            doubled_pawns[chess.BLACK] += 1\n    return float(doubled_pawns[chess.WHITE] - doubled_pawns[chess.BLACK])", "def feature(board: chess.Board) -> float:\n    \"Counts the number of hanging pieces (unprotected) for each player.\"\n    hanging_pieces = {chess.WHITE: 0, chess.BLACK: 0}\n    for square, piece in board.piece_map().items():\n        if piece is not None:\n            if board.is_attacked_by(not piece.color, square):\n                hanging_pieces[piece.color] += 1\n    return float(hanging_pieces[chess.WHITE] - hanging_pieces[chess.BLACK])", "def feature(board: chess.Board) -> float:\n    \"Calculates the material advantage based on scaled piece values relative to a certain threshold.\"\n    piece_values = {chess.PAWN: 100, chess.KNIGHT: 320, chess.BISHOP: 330, chess.ROOK: 500, chess.QUEEN: 900, chess.KING: 0}\n    material_score = 0\n    for piece in board.piece_map().values():\n        if piece is not None:\n            material_score += piece_values[piece.piece_type] if piece.color == chess.WHITE else -piece_values[piece.piece_type]\n    return float(material_score)", "def feature(board: chess.Board) -> float:\n    \"Measures the difference in the number of pawns for each player.\"\n    white_pawns = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE and piece.piece_type == chess.PAWN)\n    black_pawns = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK and piece.piece_type == chess.PAWN)\n    return float(white_pawns - black_pawns)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces for each player and gives the material ratio.\"\n    piece_values = {chess.PAWN: 100, chess.KNIGHT: 320, chess.BISHOP: 330, chess.ROOK: 500,\n                    chess.QUEEN: 900, chess.KING: 20000}\n    white_material = sum(piece_values[piece.piece_type] for piece in board.piece_map().values() if piece.color == chess.WHITE)\n    black_material = sum(piece_values[piece.piece_type] for piece in board.piece_map().values() if piece.color == chess.BLACK)\n    return float(white_material / max(1, black_material))", "def feature(board: chess.Board) -> float:\n    \"Measures the number of squares under attack by each player.\"\n    white_attack = sum(1 for square in chess.SQUARES if board.is_attacked_by(chess.WHITE, square))\n    black_attack = sum(1 for square in chess.SQUARES if board.is_attacked_by(chess.BLACK, square))\n    return float(white_attack - black_attack)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of legal moves for both players and checks for mobility.\"\n    white_moves = len(list(board.legal_moves) if board.turn else [])\n    black_moves = len(list(board.legal_moves) if not board.turn else [])\n    return float(white_moves - black_moves)", "def feature(board: chess.Board) -> float:\n    \"Evaluates the distance of kings from the center of the board as a safety measure.\"\n    white_king_square = next(square for square, piece in board.piece_map().items() if piece.color == chess.WHITE and piece.piece_type == chess.KING)\n    black_king_square = next(square for square, piece in board.piece_map().items() if piece.color == chess.BLACK and piece.piece_type == chess.KING)\n    white_king_distance = chess.square_distance(white_king_square, chess.E4) + chess.square_distance(white_king_square, chess.D4)\n    black_king_distance = chess.square_distance(black_king_square, chess.E4) + chess.square_distance(black_king_square, chess.D4)\n    return float(white_king_distance - black_king_distance)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of doubled pawns for each player.\"\n    white_doubled = sum(1 for file in range(8) if len([sq for sq in range(8) if board.piece_at(chess.square(file, sq)) and board.piece_at(chess.square(file, sq)).color == chess.WHITE]) > 1)\n    black_doubled = sum(1 for file in range(8) if len([sq for sq in range(8) if board.piece_at(chess.square(file, sq)) and board.piece_at(chess.square(file, sq)).color == chess.BLACK]) > 1)\n    return float(white_doubled - black_doubled)", "def feature(board: chess.Board) -> float:\n    \"Measures the difference in the number of pieces protected by other pieces for each player.\"\n    def protected_count(color):\n        return sum(1 for square, piece in board.piece_map().items() if piece.color == color and any(board.is_attacked_by(not color, square) for _ in board.attackers(color, square)))\n    \n    white_protected = protected_count(chess.WHITE)\n    black_protected = protected_count(chess.BLACK)\n    return float(white_protected - black_protected)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of open files for both players.\"\n    def open_file_count(color):\n        return sum(1 for file in range(8) if all(board.piece_at(chess.square(file, rank)) is None or board.piece_at(chess.square(file, rank)).color != color for rank in range(8)))\n    \n    white_open_files = open_file_count(chess.WHITE)\n    black_open_files = open_file_count(chess.BLACK)\n    return float(white_open_files - black_open_files)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of available squares for each player's pieces.\"\n    white_available_squares = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE and len(list(board.legal_moves)) > 0)\n    black_available_squares = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK and len(list(board.legal_moves)) > 0)\n    return float(white_available_squares - black_available_squares)", "def feature(board: chess.Board) -> float:\n    \"Measures the presence of connected pawns (pawns next to each other).\"\n    connected_pawns = 0\n    for square in range(64):\n        if board.piece_at(square) and board.piece_at(square).piece_type == chess.PAWN:\n            file = chess.square_file(square)\n            if (board.piece_at(square + 1) and board.piece_at(square + 1).piece_type == chess.PAWN) or \\\n               (board.piece_at(square - 1) and board.piece_at(square - 1).piece_type == chess.PAWN):\n                connected_pawns += 1\n    return float(connected_pawns)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pinned pieces on the board.\"\n    pinned_count = 0\n    for square in range(64):\n        piece = board.piece_at(square)\n        if piece and piece.color == board.turn:\n            for attacker in board.attackers(not board.turn, square):\n                if board.is_attacked_by(board.turn, attacker):\n                    pinned_count += 1\n                    break\n    return float(pinned_count)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces on the back rank for each player.\"\n    white_back_rank = sum(1 for f in range(8) if board.piece_at(chess.square(f, 7)) and board.piece_at(chess.square(f, 7)).color == chess.WHITE)\n    black_back_rank = sum(1 for f in range(8) if board.piece_at(chess.square(f, 0)) and board.piece_at(chess.square(f, 0)).color == chess.BLACK)\n    return float(white_back_rank - black_back_rank)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of open files for both players.\"\n    open_files = 0\n    for file in range(8):\n        if all(board.piece_at(chess.square(file, rank)) is None for rank in range(8)):\n            open_files += 1\n    return float(open_files)", "def feature(board: chess.Board) -> float:\n    \"Counts the total number of isolated pawns on the board.\"\n    isolated_pawn_count = 0\n    for square in chess.SQUARES:\n        piece = board.piece_at(square)\n        if piece and piece.piece_type == chess.PAWN:\n            file = chess.square_file(square)\n            if ((file == 0 or board.piece_at(chess.square(file - 1, chess.square_rank(square))) is None) and \n                (file == 7 or board.piece_at(chess.square(file + 1, chess.square_rank(square))) is None)):\n                isolated_pawn_count += 1\n    return float(isolated_pawn_count)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of hanging pieces (pieces that can be captured without retaliation).\"\n    hanging_count = 0\n    for square in chess.SQUARES:\n        piece = board.piece_at(square)\n        if piece and piece.color == board.turn:\n            attackers = board.attackers(not piece.color, square)\n            if not any(board.is_attacked_by(piece.color, attacker) for attacker in attackers):\n                hanging_count += 1\n    return float(hanging_count)", "def feature(board: chess.Board) -> float:\n    \"Evaluates the number of pieces that control the center squares (d4, d5, e4, e5).\"\n    center_control_count = 0\n    center_squares = [chess.D4, chess.D5, chess.E4, chess.E5]\n    for square in center_squares:\n        if board.is_attacked_by(chess.WHITE, square):\n            center_control_count += 1\n        if board.is_attacked_by(chess.BLACK, square):\n            center_control_count -= 1\n    return float(center_control_count)", "def feature(board: chess.Board) -> float:\n    \"Counts the total number of pieces for both colors and computes a ratio of material presence\"\n    white_piece_count = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE)\n    black_piece_count = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK)\n    if black_piece_count == 0:\n        return float('inf')\n    return float(white_piece_count / black_piece_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the mobility by counting the number of legal moves available for the current player\"\n    legal_moves_count = len(list(board.legal_moves))\n    return float(legal_moves_count)", "def feature(board: chess.Board) -> float:\n    \"Measures the total value of pieces on the board for the current player\"\n    piece_values = {\n        chess.PAWN: 100,\n        chess.KNIGHT: 320,\n        chess.BISHOP: 330,\n        chess.ROOK: 500,\n        chess.QUEEN: 900,\n        chess.KING: 20000\n    }\n    total_value = sum(piece_values[piece.piece_type] for piece in board.piece_map().values() if piece.color == board.turn)\n    return float(total_value)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pawns on the 7th rank for both players as a potential promotion measure\"\n    white_pawns_on_7th = sum(1 for sq in range(8) if board.piece_at(chess.square(sq, 6)) == chess.PAWN and board.piece_at(chess.square(sq, 6)).color == chess.WHITE)\n    black_pawns_on_7th = sum(1 for sq in range(8) if board.piece_at(chess.square(sq, 1)) == chess.PAWN and board.piece_at(chess.square(sq, 1)).color == chess.BLACK)\n    return float(white_pawns_on_7th - black_pawns_on_7th)", "def feature(board: chess.Board) -> float:\n    \"Measures the king's safety by counting the number of squares around the king that are attacked\"\n    king_square = next((square for square, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color == board.turn), None)\n    if king_square is None:\n        return 0.0\n    attacked_squares_count = sum(1 for sq in chess.SQUARES if board.is_attacked_by(not board.turn, sq) and chess.square_distance(sq, king_square) <= 1)\n    return float(attacked_squares_count)", "def feature(board: chess.Board) -> float:\n    \"Tracks the balance of the material considering pieces defended by others\"\n    material_balance = 0\n    piece_values = {\n        chess.PAWN: 100,\n        chess.KNIGHT: 320,\n        chess.BISHOP: 330,\n        chess.ROOK: 500,\n        chess.QUEEN: 900,\n        chess.KING: 20000\n    }\n    for square, piece in board.piece_map().items():\n        if piece.color == board.turn:\n            material_balance += piece_values[piece.piece_type]\n            if any(board.is_attacked_by(not board.turn, square) for square in board.attackers(board.turn, square)):\n                material_balance -= piece_values[piece.piece_type] / 2\n        else:\n            material_balance -= piece_values[piece.piece_type]\n    return float(material_balance)", "def feature(board: chess.Board) -> float:\n    \"Calculates the mobility of the player whose turn it is by counting their legal moves.\"\n    legal_moves_count = sum(1 for move in board.legal_moves)\n    return float(legal_moves_count)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of undefended pieces for the player whose turn it is.\"\n    color = board.turn\n    undefended_count = sum(1 for square, piece in board.piece_map().items() \n                            if piece.color == color and not board.attackers(not color, square))\n    return float(undefended_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of pieces on the board that are pinned to the king.\"\n    color = board.turn\n    pinned_count = sum(1 for square, piece in board.piece_map().items() \n                       if piece.color == color and board.is_attacked_by(not color, square))\n    return float(pinned_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of squares controlled by the player whose turn it is.\"\n    color = board.turn\n    controlled_squares = set()\n    for move in board.legal_moves:\n        controlled_squares.add(move.to_square)\n        if move.promotion:\n            controlled_squares.add(move.to_square)  # account for promotion\n    return float(len(controlled_squares))", "def feature(board: chess.Board) -> float:\n    \"Calculates the total number of pieces for the player whose turn it is.\"\n    color = board.turn\n    piece_count = sum(1 for piece in board.piece_map().values() if piece.color == color)\n    return float(piece_count)", "def feature(board: chess.Board) -> float:\n    \"Measures the distance of the closest enemy piece to the player\u2019s king.\"\n    color = board.turn\n    king_square = [square for square, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color == color][0]\n    enemy_pieces_squares = [square for square, piece in board.piece_map().items() if piece.color != color]\n    distances = [chess.square_distance(king_square, square) for square in enemy_pieces_squares]\n    return float(min(distances)) if distances else float('inf')", "def feature(board: chess.Board) -> float:\n    \"Counts the number of open files in front of player's rooks.\"\n    color = board.turn\n    open_files = 0\n    for file in range(8):\n        if all(board.piece_at(chess.square(file, rank)) is None for rank in range(8) if rank != (0 if color == chess.WHITE else 7)):\n            open_files += 1\n    return float(open_files)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of advanced pawns (pawns on the 4th or 5th rank for White, 4th or 3rd rank for Black).\"\n    color = board.turn\n    advanced_pawns = sum(1 for square, piece in board.piece_map().items() \n                         if piece.piece_type == chess.PAWN and \n                         ((color == chess.WHITE and chess.square_rank(square) >= 3) or \n                          (color == chess.BLACK and chess.square_rank(square) <= 4)))\n    return float(advanced_pawns)", "def feature(board: chess.Board) -> float:\n    \"Measures the king's safety by counting the number of squares around the king that are attacked.\"\n    color = board.turn\n    king_square = [square for square, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color == color][0]\n    attacked_count = sum(1 for square in chess.SQUARES_180 if board.is_attacked_by(not color, square))\n    return float(attacked_count)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of non-pawn pieces for both players and gives their difference\"\n    white_non_pawns = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE and piece.piece_type != chess.PAWN)\n    black_non_pawns = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK and piece.piece_type != chess.PAWN)\n    return float(white_non_pawns - black_non_pawns)", "def feature(board: chess.Board) -> float:\n    \"Measures the mobility of both sides by counting the number of legal moves\"\n    white_moves = len(list(board.legal_moves))\n    board.turn = chess.BLACK\n    black_moves = len(list(board.legal_moves))\n    return float(white_moves - black_moves)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of pieces in the back rank for both players\"\n    white_back_rank = sum(1 for square, piece in board.piece_map().items() if piece.color == chess.WHITE and chess.square_rank(square) == 0)\n    black_back_rank = sum(1 for square, piece in board.piece_map().items() if piece.color == chess.BLACK and chess.square_rank(square) == 7)\n    return float(white_back_rank - black_back_rank)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces pinned against the king for both players\"\n    white_pins = sum(1 for square in board.piece_map() if board.is_attacked_by(chess.BLACK, square) and board.piece_at(square).color == chess.WHITE)\n    black_pins = sum(1 for square in board.piece_map() if board.is_attacked_by(chess.WHITE, square) and board.piece_at(square).color == chess.BLACK)\n    return float(white_pins - black_pins)", "def feature(board: chess.Board) -> float:\n    \"Calculates the distance of the nearest enemy pieces to the kings of both players\"\n    white_king_square = next(square for square, piece in board.piece_map().items() if piece.color == chess.WHITE and piece.piece_type == chess.KING)\n    black_king_square = next(square for square, piece in board.piece_map().items() if piece.color == chess.BLACK and piece.piece_type == chess.KING)\n\n    white_nearest_enemy_distance = min((chess.square_distance(white_king_square, enemy) for enemy in board.piece_map() if board.piece_at(enemy).color == chess.BLACK), default=8)\n    black_nearest_enemy_distance = min((chess.square_distance(black_king_square, enemy) for enemy in board.piece_map() if board.piece_at(enemy).color == chess.WHITE), default=8)\n\n    return float(black_nearest_enemy_distance - white_nearest_enemy_distance)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of advanced pawns (pawns on the 4th or 5th rank for White, 4th or 3rd for Black)\"\n    white_advanced_pawns = sum(1 for square in board.piece_map() if board.piece_at(square).color == chess.WHITE and chess.square_rank(square) >= 3)\n    black_advanced_pawns = sum(1 for square in board.piece_map() if board.piece_at(square).color == chess.BLACK and chess.square_rank(square) <= 4)\n    return float(white_advanced_pawns - black_advanced_pawns)", "def feature(board: chess.Board) -> float:\n    \"Measures the total number of pieces that are under attack by the opponent\"\n    white_attacked = sum(1 for square in board.piece_map() if board.piece_at(square).color == chess.WHITE and board.is_attacked_by(chess.BLACK, square))\n    black_attacked = sum(1 for square in board.piece_map() if board.piece_at(square).color == chess.BLACK and board.is_attacked_by(chess.WHITE, square))\n    return float(white_attacked - black_attacked)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pawns on the 7th rank for both players\"\n    white_seventh_rank_pawns = sum(1 for square in board.piece_map() if board.piece_at(square).color == chess.WHITE and chess.square_rank(square) == 6)\n    black_seventh_rank_pawns = sum(1 for square in board.piece_map() if board.piece_at(square).color == chess.BLACK and chess.square_rank(square) == 1)\n    return float(white_seventh_rank_pawns - black_seventh_rank_pawns)", "def feature(board: chess.Board) -> float:\n    \"Calculates the total number of pieces for each player and returns their difference\"\n    white_total_pieces = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE)\n    black_total_pieces = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK)\n    return float(white_total_pieces - black_total_pieces)", "def feature(board: chess.Board) -> float:\n    \"Measures the total number of pieces on the board.\"\n    total_pieces = len(board.piece_map())\n    return float(total_pieces)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pawns for each player and returns their difference.\"\n    white_pawns = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE and piece.piece_type == chess.PAWN)\n    black_pawns = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK and piece.piece_type == chess.PAWN)\n    return float(white_pawns - black_pawns)", "def feature(board: chess.Board) -> float:\n    \"Calculates the total value of pieces on the board, weighing each piece type.\"\n    piece_values = {chess.PAWN: 100, chess.KNIGHT: 320, chess.BISHOP: 330, chess.ROOK: 500, chess.QUEEN: 900, chess.KING: 0}\n    total_value = sum(piece_values[piece.piece_type] for piece in board.piece_map().values())\n    return float(total_value)", "def feature(board: chess.Board) -> float:\n    \"Evaluates the number of pieces attacking the opponent's king.\"\n    opponent_king_square = next((square for square, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color != board.turn), None)\n    if opponent_king_square is None:\n        return 0.0\n    attackers_count = len(board.attackers(board.turn, opponent_king_square))\n    return float(attackers_count)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of squares that pawn pieces can advance to.\"\n    advanceable_squares = 0\n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.PAWN:\n            if piece.color == chess.WHITE:\n                advance_squares = [square + 8, square + 16] if chess.square_rank(square) == 1 else [square + 8]\n            else:\n                advance_squares = [square - 8, square - 16] if chess.square_rank(square) == 6 else [square - 8]\n            advanceable_squares += sum(1 for sq in advance_squares if 0 <= sq < 64 and board.piece_at(sq) is None)\n    return float(advanceable_squares)", "def feature(board: chess.Board) -> float:\n    \"Checks if there are pieces that are pinned (unable to move due to attack on the king).\"\n    pinned_count = 0\n    for square, piece in board.piece_map().items():\n        if board.is_attacked_by(not piece.color, square):\n            king_square = next((sqr for sqr, piece_ in board.piece_map().items() if piece_.piece_type == chess.KING and piece_.color == piece.color), None)\n            # If king cannot move to a safe square\n            if king_square and board.is_attacked_by(not piece.color, king_square):\n                pinned_count += 1\n    return float(pinned_count)", "def feature(board: chess.Board) -> float:\n    \"Measures the distance of the two kings from each other.\"\n    white_king_square = next((square for square, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color == chess.WHITE), None)\n    black_king_square = next((square for square, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color == chess.BLACK), None)\n    if white_king_square is None or black_king_square is None:\n        return 0.0\n    distance = chess.square_distance(white_king_square, black_king_square)\n    return float(distance)", "def feature(board: chess.Board) -> float:\n    \"Measures the total number of pawns on the board.\"\n    result = sum(1 for piece in board.piece_map().values() if piece.piece_type == chess.PAWN)\n    return float(result)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of pieces that are pinned (unable to move without exposing a king to check).\"\n    pinned_count = 0\n    for square, piece in board.piece_map().items():\n        if board.is_attacked_by(not piece.color, square):\n            pinned_count += 1\n    return float(pinned_count)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of squares controlled by the player whose turn it is.\"\n    controlled_squares = set()\n    for move in board.legal_moves:\n        controlled_squares.add(move.to_square)\n    return float(len(controlled_squares))", "def feature(board: chess.Board) -> float:\n    \"Measures the distance of all pawns from their promotion ranks.\"\n    distance_sum = 0\n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.PAWN:\n            if piece.color == chess.WHITE:\n                distance_sum += 7 - chess.square_rank(square)\n            else:\n                distance_sum += chess.square_rank(square)\n    return float(distance_sum)", "def feature(board: chess.Board) -> float:\n    \"Calculates the safety of the king based on the number of pieces defending it.\"\n    king_square = board.king(board.turn)\n    defending_pieces = board.attackers(board.turn, king_square)\n    return float(len(defending_pieces))", "def feature(board: chess.Board) -> float:\n    \"Counts the number of advanced pawns, defined as pawns on their opponent's side of the board.\"\n    advanced_pawn_count = 0\n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.PAWN:\n            if (piece.color == chess.WHITE and chess.square_rank(square) >= 4) or \\\n               (piece.color == chess.BLACK and chess.square_rank(square) <= 3):\n                advanced_pawn_count += 1\n    return float(advanced_pawn_count)", "def feature(board: chess.Board) -> float:\n    \"Measures the total number of squares occupied by pieces for both players.\"\n    occupied_squares = len(board.piece_map())\n    return float(occupied_squares)", "def feature(board: chess.Board) -> float:\n    \"Calculates the mobility of the player whose turn it is, based on the number of legal moves.\"\n    mobility = len(list(board.legal_moves))\n    return float(mobility)", "def feature(board: chess.Board) -> float:\n    \"Checks if there are any pieces that can capture an opponent's major piece (rook or queen).\"\n    major_piece_threat_count = 0\n    major_pieces = {chess.ROOK, chess.QUEEN}\n    for square, piece in board.piece_map().items():\n        if piece.color == board.turn and piece.piece_type in major_pieces:\n            for move in board.legal_moves:\n                if move.from_square == square and board.piece_at(move.to_square) and \\\n                   board.piece_at(move.to_square).color != piece.color and \\\n                   board.piece_at(move.to_square).piece_type in major_pieces:\n                    major_piece_threat_count += 1\n    return float(major_piece_threat_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the total value of pieces on the board for both players.\"\n    total_value = 0\n    piece_values = {chess.PAWN: 100, chess.KNIGHT: 320, chess.BISHOP: 330, \n                    chess.ROOK: 500, chess.QUEEN: 900, chess.KING: 10000}\n    \n    for piece in board.piece_map().values():\n        total_value += piece_values[piece.piece_type] if piece.color == chess.WHITE else -piece_values[piece.piece_type]\n    \n    return float(total_value)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of pieces for each player and gives their difference.\"\n    white_count = len([p for p in board.piece_map().values() if p.color == chess.WHITE])\n    black_count = len([p for p in board.piece_map().values() if p.color == chess.BLACK])\n    \n    return float(white_count - black_count)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of advanced pawns (pawns on ranks 4 or 5 for White and 4 or 3 for Black).\"\n    advanced_pawns = 0\n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.PAWN:\n            if (piece.color == chess.WHITE and chess.square_rank(square) >= 4) or \\\n               (piece.color == chess.BLACK and chess.square_rank(square) <= 4):\n                advanced_pawns += 1\n    \n    return float(advanced_pawns)", "def feature(board: chess.Board) -> float:\n    \"Calculates the mobility of each player based on the number of legal moves.\"\n    white_moves = len(list(board.legal_moves)) if board.turn else 0\n    black_moves = len(list(board.legal_moves)) if not board.turn else 0\n    \n    return float(white_moves - black_moves)", "def feature(board: chess.Board) -> float:\n    \"Measures the ratio of major pieces (rooks and queens) to total pieces.\"\n    major_pieces = sum(1 for p in board.piece_map().values() if p.piece_type in {chess.ROOK, chess.QUEEN})\n    total_pieces = len(board.piece_map())\n    \n    return float(major_pieces / total_pieces) if total_pieces > 0 else 0.0", "def feature(board: chess.Board) -> float:\n    \"Calculates the total distance of all pieces from their back rank to assess development.\"\n    total_distance = 0\n    for square, piece in board.piece_map().items():\n        rank_distance = chess.square_rank(square) if piece.color == chess.WHITE else 7 - chess.square_rank(square)\n        total_distance += rank_distance\n    \n    return float(total_distance)", "def feature(board: chess.Board) -> float:\n    \"Measures how many pieces are under attack.\"\n    attacked_count = sum(1 for square in board.piece_map() if board.is_attacked_by(not board.turn, square))\n    \n    return float(attacked_count)", "def feature(board: chess.Board) -> float:\n    \"Checks if the position is in check for the current player and returns a penalty.\"\n    return float(-100 if board.is_check() else 0)", "def feature(board: chess.Board) -> float:\n    \"Calculates the central control by counting pieces in the central squares.\"\n    central_squares = [chess.D4, chess.D5, chess.E4, chess.E5]\n    central_control = sum(1 for square in central_squares if board.is_attacked_by(chess.WHITE, square)) - \\\n                     sum(1 for square in central_squares if board.is_attacked_by(chess.BLACK, square))\n    \n    return float(central_control)", "def feature(board: chess.Board) -> float:\n    \"Measures the total material value of each side on the board.\"\n    piece_values = {chess.PAWN: 100, chess.KNIGHT: 300, chess.BISHOP: 300,\n                    chess.ROOK: 500, chess.QUEEN: 900, chess.KING: 0}\n    white_material = sum(piece_values[piece.piece_type] for piece in board.piece_map().values() if piece.color == chess.WHITE)\n    black_material = sum(piece_values[piece.piece_type] for piece in board.piece_map().values() if piece.color == chess.BLACK)\n    return float(white_material - black_material)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pawn structures that are connected and potentially passed.\"\n    connected_pawns = 0\n    for file in range(8):\n        for rank in range(8):\n            square = chess.square(file, rank)\n            if board.piece_at(square) and board.piece_at(square).piece_type == chess.PAWN:\n                if board.piece_at(square).color == chess.WHITE:\n                    if (board.piece_at(chess.square(file, rank + 1)) and \n                        board.piece_at(chess.square(file, rank + 1)).piece_type == chess.PAWN):\n                        connected_pawns += 1\n                elif board.piece_at(square).color == chess.BLACK:\n                    if (board.piece_at(chess.square(file, rank - 1)) and \n                        board.piece_at(chess.square(file, rank - 1)).piece_type == chess.PAWN):\n                        connected_pawns += 1\n    return float(connected_pawns)", "def feature(board: chess.Board) -> float:\n    \"Calculates the presence of open files for rooks.\"\n    open_files = 0\n    for file in range(8):\n        if all(board.piece_at(chess.square(file, rank)) is None for rank in range(8)):\n            open_files += 1\n    return float(open_files)", "def feature(board: chess.Board) -> float:\n    \"Measures the control of center squares by counting the pieces in central positions.\"\n    center_squares = [chess.E4, chess.E5, chess.D4, chess.D5]\n    control = sum(1 for square in center_squares if board.is_attacked_by(chess.WHITE, square)) - \\\n              sum(1 for square in center_squares if board.is_attacked_by(chess.BLACK, square))\n    return float(control)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of threats to the opponent's king.\"\n    threats_to_king = 0\n    king_square = next((square for square, piece in board.piece_map().items() \n                        if piece.piece_type == chess.KING and piece.color == chess.BLACK), None)\n    if king_square is not None:\n        threats_to_king = sum(1 for move in board.legal_moves if move.to_square == king_square)\n    return float(threats_to_king)", "def feature(board: chess.Board) -> float:\n    \"Quantifies the number of pinned pieces.\"\n    pinned_count = 0\n    for square in board.piece_map():\n        piece = board.piece_at(square)\n        if piece and piece.color == board.turn:\n            for attacker in board.attackers(not board.turn, square):\n                if board.is_attacked_by(board.turn, attacker):\n                    pinned_count += 1\n    return float(pinned_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the ratio of piece types (minor vs major) on the board.\"\n    minor_pieces = sum(1 for piece in board.piece_map().values() if piece.piece_type in [chess.KNIGHT, chess.BISHOP])\n    major_pieces = sum(1 for piece in board.piece_map().values() if piece.piece_type in [chess.ROOK, chess.QUEEN])\n    return float(minor_pieces / (major_pieces + 1e-5))  # Adding a small value to avoid division by zero", "def feature(board: chess.Board) -> float:\n    \"Counts the number of squares controlled by each player's pieces.\"\n    white_control = sum(board.is_attacked_by(chess.WHITE, square) for square in chess.SQUARES)\n    black_control = sum(board.is_attacked_by(chess.BLACK, square) for square in chess.SQUARES)\n    return float(white_control - black_control)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces protected by other pieces for both players.\"\n    protected_count = 0\n    for square, piece in board.piece_map().items():\n        if board.attackers(piece.color, square):\n            protected_count += 1\n    return float(protected_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the average rank of all pieces for both players.\"\n    total_rank = 0\n    piece_count = 0\n    for square, piece in board.piece_map().items():\n        total_rank += chess.square_rank(square)\n        piece_count += 1\n    return float(total_rank / piece_count) if piece_count > 0 else 0.0", "def feature(board: chess.Board) -> float:\n    \"Measures the mobility of pieces by counting all legal moves for pieces of the current turn.\"\n    legal_moves_count = len(list(board.legal_moves))\n    return float(legal_moves_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the distance in ranks between the kings to assess king safety.\"\n    white_king = board.king(chess.WHITE)\n    black_king = board.king(chess.BLACK)\n    if white_king is not None and black_king is not None:\n        distance = chess.square_rank(white_king) - chess.square_rank(black_king)\n        return float(abs(distance))\n    return 0.0", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pawns for each player on the 7th or 2nd rank (promotion potential).\"\n    promotion_count = 0\n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.PAWN:\n            if (piece.color == chess.WHITE and chess.square_rank(square) == 6) or \\\n               (piece.color == chess.BLACK and chess.square_rank(square) == 1):\n                promotion_count += 1\n    return float(promotion_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the ratio of pieces that are on the opponent's half of the board.\"\n    opponent_half_count = 0\n    total_pieces_count = len(board.piece_map())\n    for square, piece in board.piece_map().items():\n        if (piece.color == chess.WHITE and chess.square_rank(square) >= 4) or \\\n           (piece.color == chess.BLACK and chess.square_rank(square) <= 3):\n            opponent_half_count += 1\n    return float(opponent_half_count / total_pieces_count) if total_pieces_count > 0 else 0.0", "def feature(board: chess.Board) -> float:\n    \"Measures the number of doubled pawns for both players.\"\n    pawn_counts = {}\n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.PAWN:\n            file_index = chess.square_file(square)\n            if piece.color not in pawn_counts:\n                pawn_counts[piece.color] = [0] * 8\n            pawn_counts[piece.color][file_index] += 1\n    doubled_pawns = sum(max(0, count - 1) for counts in pawn_counts.values() for count in counts)\n    return float(doubled_pawns)", "def feature(board: chess.Board) -> float:\n    \"Evaluates the pressure on the opponent's king by counting attacking pieces.\"\n    attacking_count = sum(1 for square, piece in board.piece_map().items()\n                          if piece.color != board.turn and board.is_attacked_by(board.turn, square))\n    return float(attacking_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of pieces attacking the opponent's back rank.\"\n    back_rank_attacks = 0\n    for square in range(8):\n        if board.is_attacked_by(chess.WHITE, chess.parse_square(f'h{8}')):  # Black's back rank\n            back_rank_attacks += len(board.attackers(chess.WHITE, chess.parse_square(f'h{8}')))\n        if board.is_attacked_by(chess.BLACK, chess.parse_square(f'h{1}')):  # White's back rank\n            back_rank_attacks += len(board.attackers(chess.BLACK, chess.parse_square(f'h{1}')))\n    return float(back_rank_attacks)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pawns on their respective 6th or 7th ranks.\"\n    pawns_on_6th_or_7th = sum(1 for square, piece in board.piece_map().items() if piece.piece_type == chess.PAWN and \n                               ((piece.color == chess.WHITE and chess.square_rank(square) in [6, 7]) or \n                                (piece.color == chess.BLACK and chess.square_rank(square) in [1, 2])))\n    return float(pawns_on_6th_or_7th)", "def feature(board: chess.Board) -> float:\n    \"Measures the total distance of all pieces to their opponent's back rank.\"\n    distance_sum = sum(chess.square_rank(square) if piece.color == chess.WHITE else 7 - chess.square_rank(square) \n                       for square, piece in board.piece_map().items())\n    return float(distance_sum)", "def feature(board: chess.Board) -> float:\n    \"Calculates the ratio of knights to other pieces on the board for each player.\"\n    white_knights = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE and piece.piece_type == chess.KNIGHT)\n    black_knights = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK and piece.piece_type == chess.KNIGHT)\n    total_pieces_white = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE)\n    total_pieces_black = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK)\n    white_knight_ratio = white_knights / total_pieces_white if total_pieces_white > 0 else 0\n    black_knight_ratio = black_knights / total_pieces_black if total_pieces_black > 0 else 0\n    return float(white_knight_ratio - black_knight_ratio)", "def feature(board: chess.Board) -> float:\n    \"Scores based on how many pieces are attacking the opponent's king square.\"\n    attacks_on_king = sum(1 for square in board.attackers(chess.WHITE, board.king(chess.BLACK)) if board.is_attacked_by(chess.WHITE, square))\n    return float(attacks_on_king)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of advanced pawns (pawns on ranks 5 or 6 for White and 3 or 4 for Black).\"\n    advanced_pawns = sum(1 for square, piece in board.piece_map().items() if piece.piece_type == chess.PAWN and \n                         ((piece.color == chess.WHITE and chess.square_rank(square) in [5, 6]) or \n                          (piece.color == chess.BLACK and chess.square_rank(square) in [3, 4])))\n    return float(advanced_pawns)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces that are pinned to the king.\"\n    pinned_pieces = sum(1 for square, piece in board.piece_map().items() if piece.color == board.turn and \n                        board.is_attacked_by(not board.turn, square) and \n                        (piece.piece_type != chess.KING) and (board.attackers(not board.turn, square)))\n    return float(pinned_pieces)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of squares occupied by bishops and their influence over diagonals.\"\n    bishop_squares = sum(1 for piece in board.piece_map().values() if piece.piece_type == chess.BISHOP)\n    return float(bishop_squares)", "def feature(board: chess.Board) -> float:\n    \"Measures how many pieces are located in the opponent's half of the board.\"\n    opponent_half_pieces = sum(1 for square, piece in board.piece_map().items() if piece.color == board.turn and \n                                (piece.color == chess.WHITE and chess.square_rank(square) >= 4) or \n                                (piece.color == chess.BLACK and chess.square_rank(square) <= 3))\n    return float(opponent_half_pieces)", "def feature(board: chess.Board) -> float:\n    \"Scores based on the number of pawns that can potentially promote in the next turn.\"\n    promotable_pawns = sum(1 for square, piece in board.piece_map().items() if piece.piece_type == chess.PAWN and \n                           ((piece.color == chess.WHITE and chess.square_rank(square) == 6) or \n                            (piece.color == chess.BLACK and chess.square_rank(square) == 1)))\n    return float(promotable_pawns)", "def feature(board: chess.Board) -> float:\n    \"Measures the total mobility of pieces by counting the number of legal moves.\"\n    total_legal_moves = sum(1 for _ in board.legal_moves)\n    return float(total_legal_moves)", "def feature(board: chess.Board) -> float:\n    \"Measures the difference in the number of pawns for each player.\"\n    white_pawns = sum(1 for piece in board.piece_map().values() if piece.piece_type == chess.PAWN and piece.color == chess.WHITE)\n    black_pawns = sum(1 for piece in board.piece_map().values() if piece.piece_type == chess.PAWN and piece.color == chess.BLACK)\n    return float(white_pawns - black_pawns)", "def feature(board: chess.Board) -> float:\n    \"Calculates the sum of piece values for the player to move.\"\n    piece_values = {chess.PAWN: 100, chess.KNIGHT: 320, chess.BISHOP: 330, chess.ROOK: 500, chess.QUEEN: 900, chess.KING: 20000}\n    total_value = sum(piece_values[piece.piece_type] for piece in board.piece_map().values() if piece.color == board.turn)\n    return float(total_value)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces that are attacked by the opponent.\"\n    opponent_color = chess.WHITE if board.turn == chess.BLACK else chess.BLACK\n    attacked_pieces = sum(1 for square in board.piece_map() if board.is_attacked_by(opponent_color, square))\n    return float(attacked_pieces)", "def feature(board: chess.Board) -> float:\n    \"Evaluates the control of central squares by counting pieces on d4, d5, e4, and e5.\"\n    center_squares = [chess.parse_square('d4'), chess.parse_square('d5'), chess.parse_square('e4'), chess.parse_square('e5')]\n    control_count = sum(1 for square in center_squares if board.piece_at(square) is not None and board.piece_at(square).color == board.turn)\n    return float(control_count)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of potential checks available to the player to move.\"\n    check_moves = sum(1 for move in board.legal_moves if board.gives_check(move))\n    return float(check_moves)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of pawns on the 6th and 7th ranks.\"\n    advanced_pawns = sum(1 for square, piece in board.piece_map().items() if piece.piece_type == chess.PAWN and \n                         ((piece.color == chess.WHITE and chess.square_rank(square) >= 6) or \n                          (piece.color == chess.BLACK and chess.square_rank(square) <= 1)))\n    return float(advanced_pawns)", "def feature(board: chess.Board) -> float:\n    \"Evaluates the presence of pieces threatening the opponent's king.\"\n    threats = sum(1 for square in range(64) if board.piece_at(square) is not None and board.piece_at(square).color == board.turn and \n                  any(board.is_attacked_by(opponent_color, square) for opponent_color in [chess.WHITE, chess.BLACK] if opponent_color != board.turn))\n    return float(threats)", "def feature(board: chess.Board) -> float:\n    \"Evaluates the potential for promotion by counting pawns on the 7th and 2nd ranks.\"\n    promoting_pawns = sum(1 for square, piece in board.piece_map().items() if piece.piece_type == chess.PAWN and \n                          ((piece.color == chess.WHITE and chess.square_rank(square) == 6) or \n                           (piece.color == chess.BLACK and chess.square_rank(square) == 1)))\n    return float(promoting_pawns)\n\ndef is_piece_pinned(board: chess.Board, square: int) -> bool:\n    \"Helper function that determines if a piece is pinned.\"\n    piece = board.piece_at(square)\n    if not piece:\n        return False\n    directions = [1, -1, 8, -8, 7, 9, -7, -9]  # all possible straight and diagonal directions\n    opponent_color = chess.WHITE if piece.color == chess.BLACK else chess.BLACK\n    for direction in directions:\n        target_square = square\n        while True:\n            target_square += direction\n            if not (0 <= target_square < 64):\n                break  # out of bounds\n            target_piece = board.piece_at(target_square)\n            if target_piece:\n                if target_piece.color == opponent_color and (target_piece.piece_type == chess.QUEEN or target_piece.piece_type == chess.ROOK or (\n                        target_piece.piece_type == chess.BISHOP and (direction in [7, 9, -7, -9]))):\n                    return True  # found a pinning piece\n                elif target_piece.color == piece.color:\n                    break  # our own piece\n                else:\n                    continue  # empty square or our own piece, continue\n\n    return False  # no pinning piece found", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pawns on the board for each player and returns the difference\"\n    white_pawns = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE and piece.piece_type == chess.PAWN)\n    black_pawns = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK and piece.piece_type == chess.PAWN)\n    return float(white_pawns - black_pawns)", "def feature(board: chess.Board) -> float:\n    \"Calculates the total piece mobility for both players and returns the difference\"\n    white_mobility = sum(1 for move in board.legal_moves if board.turn)\n    board.turn = not board.turn\n    black_mobility = sum(1 for move in board.legal_moves if not board.turn)\n    return float(white_mobility - black_mobility)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of doubled pawns for each player and returns the difference\"\n    white_doubled = sum(1 for file in range(8) if sum(1 for square in range(8) if board.piece_at(chess.square(file, square)) == chess.PAWN and chess.square_file(square) == file) > 1)\n    black_doubled = sum(1 for file in range(8) if sum(1 for square in range(8) if board.piece_at(chess.square(file, square)) == chess.PAWN and chess.square_file(square) == file) > 1)\n    return float(white_doubled - black_doubled)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces on the back rank for both players and returns the difference\"\n    white_back_rank_count = sum(1 for square in range(chess.A1, chess.H1 + 1) if board.piece_at(square) and board.piece_at(square).color == chess.WHITE)\n    black_back_rank_count = sum(1 for square in range(chess.A8, chess.H8 + 1) if board.piece_at(square) and board.piece_at(square).color == chess.BLACK)\n    return float(white_back_rank_count - black_back_rank_count)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of connected pawns for each player and returns the difference\"\n    def connected_pawns(color):\n        connected = 0\n        for file in range(8):\n            for rank in range(8):\n                square = chess.square(file, rank)\n                if board.piece_at(square) and board.piece_at(square).color == color:\n                    if color == chess.WHITE:\n                        if rank > 0 and board.piece_at(chess.square(file, rank - 1)) and board.piece_at(chess.square(file, rank - 1)).color == color:\n                            connected += 1\n                    else:\n                        if rank < 7 and board.piece_at(chess.square(file, rank + 1)) and board.piece_at(chess.square(file, rank + 1)).color == color:\n                            connected += 1\n        return connected\n\n    return float(connected_pawns(chess.WHITE) - connected_pawns(chess.BLACK))", "def feature(board: chess.Board) -> float:\n    \"Calculates the total material value of all pieces on the board and returns it\"\n    piece_values = {\n        chess.PAWN: 100,\n        chess.KNIGHT: 320,\n        chess.BISHOP: 330,\n        chess.ROOK: 500,\n        chess.QUEEN: 900,\n        chess.KING: 0\n    }\n    total_value = 0\n    for piece in board.piece_map().values():\n        total_value += piece_values[piece.piece_type] if piece.color == chess.WHITE else -piece_values[piece.piece_type]\n    \n    return float(total_value)", "def feature(board: chess.Board) -> float:\n    \"Measures the mobility of the pieces by counting the total number of legal moves available.\"\n    return float(len(list(board.legal_moves)))", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces in the opponent's back rank to measure pressure on their king.\"\n    opponent_back_rank = 7 if board.turn == chess.WHITE else 0\n    return float(len([square for square, piece in board.piece_map().items() if chess.square_rank(square) == opponent_back_rank and piece.color != board.turn]))", "def feature(board: chess.Board) -> float:\n    \"Measures the distance of the king from the center of the board for safety evaluation.\"\n    king_square = next(square for square, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color == board.turn)\n    center_square = chess.square_distance(king_square, chess.parse_square('e4')) + chess.square_distance(king_square, chess.parse_square('d4'))\n    return float(center_square)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of major pieces (rooks and queens) on the board to assess piece activity.\"\n    major_piece_count = sum(1 for piece in board.piece_map().values() if piece.piece_type in {chess.ROOK, chess.QUEEN})\n    return float(major_piece_count)", "def feature(board: chess.Board) -> float:\n    \"Evaluates the material imbalance by comparing the difference in value of pieces of each color.\"\n    piece_values = {chess.PAWN: 100, chess.KNIGHT: 300, chess.BISHOP: 300, chess.ROOK: 500, chess.QUEEN: 900, chess.KING: 0}\n    white_value = sum(piece_values[piece.piece_type] for piece in board.piece_map().values() if piece.color == chess.WHITE)\n    black_value = sum(piece_values[piece.piece_type] for piece in board.piece_map().values() if piece.color == chess.BLACK)\n    return float(white_value - black_value)", "def feature(board: chess.Board) -> float:\n    \"Calculates the ratio of pieces left on the board to the starting count to evaluate material retention.\"\n    total_pieces = sum(1 for piece in board.piece_map().values())\n    starting_pieces = 32  # Each side starts with 16 pieces\n    return total_pieces / starting_pieces", "def feature(board: chess.Board) -> float:\n    \"Measures the number of pieces that can move to attack the opponent's king directly.\"\n    opponent_king_square = next(square for square, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color != board.turn)\n    attacking_moves = sum(1 for piece in board.piece_map().values() if piece.color == board.turn for move in board.legal_moves if move.from_square == piece and move.to_square == opponent_king_square)\n    return float(attacking_moves)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of isolated pawns (pawns with no adjacent pawns)\"\n    isolated_count = 0\n    for sq in range(64):\n        piece = board.piece_at(sq)\n        if piece is not None and piece.piece_type == chess.PAWN:\n            file = chess.square_file(sq)\n            if (file > 0 and board.piece_at(sq - 1) is None) and (file < 7 and board.piece_at(sq + 1) is None):\n                isolated_count += 1\n    return float(isolated_count)", "def feature(board: chess.Board) -> float:\n    \"Measures the control of central squares (d4, d5, e4, e5) by each player\"\n    central_control = sum(1 if board.is_attacked_by(chess.WHITE, chess.parse_square(sq)) else 0 for sq in ['d4', 'd5', 'e4', 'e5'])\n    central_control -= sum(1 if board.is_attacked_by(chess.BLACK, chess.parse_square(sq)) else 0 for sq in ['d4', 'd5', 'e4', 'e5'])\n    return float(central_control)", "def feature(board: chess.Board) -> float:\n    \"Calculates the total mobility by counting all legal moves for both players\"\n    white_moves = len(list(board.legal_moves)) if board.turn else 0\n    black_moves = len(list(board.legal_moves)) if not board.turn else 0\n    return float(white_moves - black_moves)", "def feature(board: chess.Board) -> float:\n    \"Calculates a pawn structure score based on doubled, isolated, and passed pawns\"\n    score = 0\n    for sq in range(64):\n        piece = board.piece_at(sq)\n        if piece is not None and piece.piece_type == chess.PAWN:\n            file = chess.square_file(sq)\n            rank = chess.square_rank(sq)\n            if (file > 0 and board.piece_at(sq - 1) is not None and board.piece_at(sq - 1).piece_type == chess.PAWN) or \\\n               (file < 7 and board.piece_at(sq + 1) is not None and board.piece_at(sq + 1).piece_type == chess.PAWN):\n                score -= 0.5  # penalty for doubled pawns\n            if (file > 0 and board.piece_at(sq - 1) is None) and (file < 7 and board.piece_at(sq + 1) is None):\n                score += 0.5  # bonus for isolated pawns\n            if (piece.color == chess.WHITE and rank == 6) or (piece.color == chess.BLACK and rank == 1):\n                score += 1.0  # bonus for advanced pawns\n    return float(score)", "def feature(board: chess.Board) -> float:\n    \"Calculates the material imbalance based on the piece types and their weights\"\n    piece_values = {chess.PAWN: 100, chess.KNIGHT: 320, chess.BISHOP: 330, chess.ROOK: 500, chess.QUEEN: 900}\n    white_material = sum(piece_values.get(board.piece_at(sq).piece_type, 0) for sq in board.piece_map() if board.piece_at(sq).color == chess.WHITE)\n    black_material = sum(piece_values.get(board.piece_at(sq).piece_type, 0) for sq in board.piece_map() if board.piece_at(sq).color == chess.BLACK)\n    return float(white_material - black_material)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of pieces in the opponent's camp (ranks 1 and 2 for White, ranks 7 and 8 for Black)\"\n    opponent_camp_count = sum(1 for sq in range(64) if board.piece_at(sq) is not None and \n                               ((board.piece_at(sq).color == chess.WHITE and chess.square_rank(sq) >= 6) or \n                                (board.piece_at(sq).color == chess.BLACK and chess.square_rank(sq) <= 1)))\n    return float(opponent_camp_count)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of potential discovered attacks by counting pieces behind others\"\n    discovered_attacks = 0\n    for sq in range(64):\n        piece = board.piece_at(sq)\n        if piece is not None:\n            for attack_sq in board.attackers(piece.color, sq):\n                if board.piece_at(attack_sq) is None:  # something behind the piece could potentially reveal an attack\n                    discovered_attacks += 1\n    return float(discovered_attacks)", "def feature(board: chess.Board) -> float:\n    \"Evaluates the rook activity by counting the number of open files for rooks\"\n    open_file_count = 0\n    for file in range(8):\n        if all(board.piece_at(chess.square(file, rank)) is None for rank in range(8)):  # check if the file is open\n            open_file_count += sum(1 for rank in range(8) if board.piece_at(chess.square(file, rank)) is not None and \n                                    board.piece_at(chess.square(file, rank)).piece_type == chess.ROOK)\n    return float(open_file_count)", "def feature(board: chess.Board) -> float:\n    \"Measures the king safety by counting the number of squares attacking the king's position\"\n    king_square = board.king(chess.WHITE) if board.turn else board.king(chess.BLACK)\n    attacking_squares = len(board.attackers(chess.WHITE if board.turn else chess.BLACK, king_square))\n    return float(attacking_squares)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of pawns advanced past the fifth rank for White and the third rank for Black.\"\n    white_advanced_pawns = sum(1 for square in board.piece_map() if board.piece_at(square).color == chess.WHITE and chess.square_rank(square) >= 4)\n    black_advanced_pawns = sum(1 for square in board.piece_map() if board.piece_at(square).color == chess.BLACK and chess.square_rank(square) <= 4)\n    return float(white_advanced_pawns - black_advanced_pawns)", "def feature(board: chess.Board) -> float:\n    \"Measures the difference in the number of safe squares for each king.\"\n    white_king_square = next(square for square in board.piece_map() if board.piece_at(square).piece_type == chess.KING and board.piece_at(square).color == chess.WHITE)\n    black_king_square = next(square for square in board.piece_map() if board.piece_at(square).piece_type == chess.KING and board.piece_at(square).color == chess.BLACK)\n    white_safe_squares = sum(1 for square in chess.SQUARES if board.is_attacked_by(chess.BLACK, square) and not board.is_attacked_by(chess.WHITE, square))\n    black_safe_squares = sum(1 for square in chess.SQUARES if board.is_attacked_by(chess.WHITE, square) and not board.is_attacked_by(chess.BLACK, square))\n    return float(white_safe_squares - black_safe_squares)", "def feature(board: chess.Board) -> float:\n    \"Determines the structural vulnerability of pawns by counting doubled pawns.\"\n    doubled_pawns = 0\n    pawn_files = {}\n    for square in board.piece_map():\n        piece = board.piece_at(square)\n        if piece.piece_type == chess.PAWN:\n            file = chess.square_file(square)\n            if file in pawn_files:\n                pawn_files[file].append(square)\n            else:\n                pawn_files[file] = [square]\n    for pawns in pawn_files.values():\n        if len(pawns) > 1:\n            doubled_pawns += len(pawns) - 1\n    return float(doubled_pawns)", "def feature(board: chess.Board) -> float:\n    \"Evaluates the distance of kings from the center of the board.\"\n    white_king_square = next(square for square in board.piece_map() if board.piece_at(square).piece_type == chess.KING and board.piece_at(square).color == chess.WHITE)\n    black_king_square = next(square for square in board.piece_map() if board.piece_at(square).piece_type == chess.KING and board.piece_at(square).color == chess.BLACK)\n    white_distance = chess.square_distance(white_king_square, chess.E4)\n    black_distance = chess.square_distance(black_king_square, chess.E5)\n    return float(black_distance - white_distance)", "def feature(board: chess.Board) -> float:\n    \"Counts the total minor pieces each side has left.\"\n    white_minors = sum(1 for square in board.piece_map() if board.piece_at(square).color == chess.WHITE and board.piece_at(square).piece_type in (chess.BISHOP, chess.KNIGHT))\n    black_minors = sum(1 for square in board.piece_map() if board.piece_at(square).color == chess.BLACK and board.piece_at(square).piece_type in (chess.BISHOP, chess.KNIGHT))\n    return float(white_minors - black_minors)", "def feature(board: chess.Board) -> float:\n    \"Measures king safety by counting the number of squares around the king that are attacked.\"\n    white_king_square = next(square for square in board.piece_map() if board.piece_at(square).piece_type == chess.KING and board.piece_at(square).color == chess.WHITE)\n    black_king_square = next(square for square in board.piece_map() if board.piece_at(square).piece_type == chess.KING and board.piece_at(square).color == chess.BLACK)\n    white_attacked_squares = sum(1 for square in chess.SQUARES if board.is_attacked_by(chess.BLACK, square) and chess.square_distance(square, white_king_square) <= 1)\n    black_attacked_squares = sum(1 for square in chess.SQUARES if board.is_attacked_by(chess.WHITE, square) and chess.square_distance(square, black_king_square) <= 1)\n    return float(white_attacked_squares - black_attacked_squares)", "def feature(board: chess.Board) -> float:\n    \"Evaluates the positional control by counting central squares occupied by each player's pieces.\"\n    central_squares = [chess.D4, chess.D5, chess.E4, chess.E5]\n    white_control = sum(1 for square in central_squares if board.piece_at(square) and board.piece_at(square).color == chess.WHITE)\n    black_control = sum(1 for square in central_squares if board.piece_at(square) and board.piece_at(square).color == chess.BLACK)\n    return float(white_control - black_control)", "def feature(board: chess.Board) -> float:\n    \"Calculates the control of the center squares (d4, d5, e4, e5) based on pieces.\"\n    center_squares = [chess.D4, chess.D5, chess.E4, chess.E5]\n    control = 0\n    for square in center_squares:\n        if board.is_attacked_by(chess.WHITE, square):\n            control += 1\n        if board.is_attacked_by(chess.BLACK, square):\n            control -= 1\n    return float(control)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces each side has on the 6th and 7th ranks.\"\n    white_pieces_on_ranks = sum(1 for square in board.piece_map() if board.piece_at(square).color == chess.WHITE and chess.square_rank(square) >= 5)\n    black_pieces_on_ranks = sum(1 for square in board.piece_map() if board.piece_at(square).color == chess.BLACK and chess.square_rank(square) <= 2)\n    return float(white_pieces_on_ranks - black_pieces_on_ranks)", "def feature(board: chess.Board) -> float:\n    \"Computes the mobility of the player with the turn by counting legal moves.\"\n    legal_moves_count = len(list(board.legal_moves))\n    return float(legal_moves_count)", "def feature(board: chess.Board) -> float:\n    \"Checks if the player to move is in check and assigns a penalty.\"\n    return float(-1 if board.is_check() else 0)", "def feature(board: chess.Board) -> float:\n    \"Measures the ratio of advanced pawns for the active player.\"\n    advanced_pawns_count = sum(1 for square in board.piece_map() if board.piece_at(square).piece_type == chess.PAWN and \n                               ((board.piece_at(square).color == chess.WHITE and chess.square_rank(square) >= 4) or \n                                (board.piece_at(square).color == chess.BLACK and chess.square_rank(square) <= 3)))\n    total_pawns_count = sum(1 for square in board.piece_map() if board.piece_at(square).piece_type == chess.PAWN and board.piece_at(square).color == board.turn)\n    return float(advanced_pawns_count / (total_pawns_count + 1e-5))  # +1e-5 to avoid division by zero", "def feature(board: chess.Board) -> float:\n    \"Measures the total value of pieces that are currently on the back rank.\"\n    back_rank_value = 0\n    back_rank_squares = range(0, 8) if board.turn == chess.WHITE else range(56, 64)\n    for square in back_rank_squares:\n        piece = board.piece_at(square)\n        if piece:\n            back_rank_value += piece.piece_type\n    return float(back_rank_value)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of squares controlled by each player based on their pieces' attacking potential.\"\n    white_control = sum(1 for square in chess.SQUARES if board.is_attacked_by(chess.WHITE, square))\n    black_control = sum(1 for square in chess.SQUARES if board.is_attacked_by(chess.BLACK, square))\n    return float(white_control - black_control)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pawns that are on the 6th or 7th rank for both colors.\"\n    white_pawns = sum(1 for square in board.piece_map() if board.piece_at(square).piece_type == chess.PAWN and chess.square_rank(square) >= 5 and board.piece_at(square).color == chess.WHITE)\n    black_pawns = sum(1 for square in board.piece_map() if board.piece_at(square).piece_type == chess.PAWN and chess.square_rank(square) <= 2 and board.piece_at(square).color == chess.BLACK)\n    return float(white_pawns - black_pawns)", "def feature(board: chess.Board) -> float:\n    \"Evaluates the pawn structure by counting isolated pawns for both sides.\"\n    def is_isolated(square, color):\n        file = chess.square_file(square)\n        return (board.piece_at(chess.parse_square(chess.square_name(square - 1))) is None and\n                board.piece_at(chess.parse_square(chess.square_name(square + 1))) is None and\n                board.piece_at(square).color == color)\n    isolated_pawns = sum(1 for square in board.piece_map() if board.piece_at(square).piece_type == chess.PAWN and is_isolated(square, board.piece_at(square).color))\n    return float(isolated_pawns)", "def feature(board: chess.Board) -> float:\n    \"Calculates the distance of all pieces from their back rank as a measure of piece activity.\"\n    distance_sum = sum(7 - chess.square_rank(square) for square in board.piece_map())\n    total_pieces = len(board.piece_map())\n    return distance_sum / total_pieces if total_pieces > 0 else 0.0", "def feature(board: chess.Board) -> float:\n    \"Measures the difference between the number of minor pieces (knights and bishops) for both players.\"\n    white_minors = sum(1 for square in board.piece_map() if board.piece_at(square).piece_type in (chess.KNIGHT, chess.BISHOP) and board.piece_at(square).color == chess.WHITE)\n    black_minors = sum(1 for square in board.piece_map() if board.piece_at(square).piece_type in (chess.KNIGHT, chess.BISHOP) and board.piece_at(square).color == chess.BLACK)\n    return float(white_minors - black_minors)", "def feature(board: chess.Board) -> float:\n    \"Counts how many pieces are placed on the third rank or further for both colors.\"\n    white_third_rank = sum(1 for square in board.piece_map() if chess.square_rank(square) >= 2 and board.piece_at(square).color == chess.WHITE)\n    black_third_rank = sum(1 for square in board.piece_map() if chess.square_rank(square) <= 5 and board.piece_at(square).color == chess.BLACK)\n    return float(white_third_rank - black_third_rank)", "def feature(board: chess.Board) -> float:\n    \"Calculates the ratio of pieces that are defended to total pieces for both colors.\"\n    def defended_ratio(color):\n        defended_count = sum(1 for square in board.piece_map() if board.piece_at(square).color == color and any(board.is_attacked_by(not color, attacking_square) for attacking_square in board.attackers(color, square)))\n        total_count = sum(1 for square in board.piece_map() if board.piece_at(square).color == color)\n        return defended_count / total_count if total_count > 0 else 0.0\n    return float(defended_ratio(chess.WHITE) - defended_ratio(chess.BLACK))", "def feature(board: chess.Board) -> float:\n    \"Measures activity of kings by counting the number of empty squares adjacent to each king.\"\n    def adjacent_squares_king(color):\n        king_square = next((square for square in board.piece_map() if board.piece_at(square).piece_type == chess.KING and board.piece_at(square).color == color), None)\n        if king_square is None:\n            return 0\n        return sum(1 for square in chess.SQUARES if chess.square_distance(king_square, square) == 1 and board.piece_at(square) is None)\n    return float(adjacent_squares_king(chess.WHITE) - adjacent_squares_king(chess.BLACK))", "def feature(board: chess.Board) -> float:\n    \"Assesses pawn majorities by counting the number of pawns on each side of the center.\"\n    white_majority = sum(1 for square in board.piece_map() if board.piece_at(square).piece_type == chess.PAWN and chess.square_file(square) >= 4 and board.piece_at(square).color == chess.WHITE)\n    black_majority = sum(1 for square in board.piece_map() if board.piece_at(square).piece_type == chess.PAWN and chess.square_file(square) <= 3 and board.piece_at(square).color == chess.BLACK)\n    return float(white_majority - black_majority)", "def feature(board: chess.Board) -> float:\n    \"Measures the central control by counting pieces on the central squares.\"\n    central_squares = [chess.D4, chess.D5, chess.E4, chess.E5]\n    count = sum(1 for square in central_squares if board.piece_at(square) is not None)\n    return float(count)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pawns for both players and calculates the pawn structure score.\"\n    white_pawns = len([p for p in board.piece_map().values() if p.piece_type == chess.PAWN and p.color == chess.WHITE])\n    black_pawns = len([p for p in board.piece_map().values() if p.piece_type == chess.PAWN and p.color == chess.BLACK])\n    return float(white_pawns - black_pawns)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of pieces attacking the opponent's king.\"\n    king_square = next((square for square, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color == chess.BLACK), None)\n    if king_square is None:\n        return 0.0\n    attackers = len(board.attackers(chess.WHITE, king_square))\n    return float(attackers)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of minor pieces (knights and bishops) for both players.\"\n    white_minors = len([p for p in board.piece_map().values() if p.piece_type in {chess.KNIGHT, chess.BISHOP} and p.color == chess.WHITE])\n    black_minors = len([p for p in board.piece_map().values() if p.piece_type in {chess.KNIGHT, chess.BISHOP} and p.color == chess.BLACK])\n    return float(white_minors - black_minors)", "def feature(board: chess.Board) -> float:\n    \"Measures the total number of pawns on the board.\"\n    total_pawns = len([p for p in board.piece_map().values() if p.piece_type == chess.PAWN])\n    return float(total_pawns)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of pieces pinned to the king for the current player.\"\n    pinned_count = sum(1 for square, piece in board.piece_map().items() if piece.color == board.turn and board.is_attacked_by(not board.turn, square) and board.is_attacked_by(board.turn, square))\n    return float(pinned_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the total potential mobility by counting legal moves for the current player.\"\n    mobility_current_player = len(list(board.legal_moves))\n    return float(mobility_current_player)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of passed pawns for the active color\"\n    passed_pawns = 0\n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.PAWN and piece.color == board.turn:\n            if board.turn == chess.WHITE:\n                if all(board.piece_at(sq) is None for sq in range(square + 8, 64) if chess.square_file(sq) == chess.square_file(square)):\n                    passed_pawns += 1\n            else:\n                if all(board.piece_at(sq) is None for sq in range(0, square) if chess.square_file(sq) == chess.square_file(square)):\n                    passed_pawns += 1\n    return float(passed_pawns)", "def feature(board: chess.Board) -> float:\n    \"Measures the safety of the king by counting attacked squares around it\"\n    king_square = None\n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.KING and piece.color == board.turn:\n            king_square = square\n            break\n    if king_square is None:\n        return 0.0\n    attacked_squares = sum(board.is_attacked_by(not board.turn, square) for square in chess.SQUARES)\n    return float(8 - attacked_squares)", "def feature(board: chess.Board) -> float:\n    \"Calculates the piece activity for the active color by counting the number of legal moves\"\n    return float(len(list(board.legal_moves)))", "def feature(board: chess.Board) -> float:\n    \"Evaluates the pawn structure by measuring the number of isolated pawns\"\n    isolated_pawns = 0\n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.PAWN:\n            file = chess.square_file(square)\n            if (file > 0 and board.piece_at(square - 1) is None) and (file < 7 and board.piece_at(square + 1) is None):\n                isolated_pawns += 1\n    return float(isolated_pawns)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of pieces placed on central squares (d4, e4, d5, e5)\"\n    center_squares = [chess.D4, chess.E4, chess.D5, chess.E5]\n    central_piece_count = sum(1 for square in center_squares if board.piece_at(square) is not None)\n    return float(central_piece_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the material difference considering only pieces in the last two ranks\"\n    material_value = 0\n    for square, piece in board.piece_map().items():\n        if chess.square_rank(square) >= 6 or chess.square_rank(square) <= 1:\n            material_value += 5 if piece.piece_type == chess.QUEEN else 3 if piece.piece_type in [chess.ROOK, chess.BISHOP] else 3 if piece.piece_type == chess.KNIGHT else 1 if piece.piece_type == chess.PAWN else 0\n    return float(material_value)", "def feature(board: chess.Board) -> float:\n    \"Measures the distance of pawns to the opponent's back rank\"\n    total_distance = 0\n    pawn_count = 0\n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.PAWN:\n            pawn_count += 1\n            if piece.color == chess.WHITE:\n                total_distance += (7 - chess.square_rank(square))\n            else:\n                total_distance += (chess.square_rank(square))\n    return float(total_distance / pawn_count) if pawn_count > 0 else 0.0", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pinned pieces for the active player\"\n    pinned_pieces = 0\n    king_square = next((square for square, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color == board.turn), None)\n    for square, piece in board.piece_map().items():\n        if piece.color == board.turn and piece.piece_type != chess.KING:\n            if board.is_attacked_by(not board.turn, square) and any(board.is_attacked_by(not board.turn, sq) for sq in board.attackers(board.turn, square)):\n                pinned_pieces += 1\n    return float(pinned_pieces)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of squares controlled by the active color\"\n    controlled_squares = set()\n    for square, piece in board.piece_map().items():\n        if piece.color == board.turn:\n            controlled_squares.update(board.attackers(board.turn, square))\n    return float(len(controlled_squares)) ", "def feature(board: chess.Board) -> float:\n    \"Calculates the average distance of pieces from the opponent's back rank\"\n    total_distance = 0\n    piece_count = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == (chess.WHITE if board.turn else chess.BLACK):\n            piece_count += 1\n            total_distance += (7 - chess.square_rank(square) if piece.color == chess.WHITE else chess.square_rank(square))\n    return float(total_distance / piece_count) if piece_count > 0 else 0.0", "def feature(board: chess.Board) -> float:\n    \"Measures the number of pawns on the 7th rank for each player.\"\n    white_pawns_7th = sum(1 for square in board.piece_map() if board.piece_at(square).color == chess.WHITE and chess.square_rank(square) == 6)\n    black_pawns_7th = sum(1 for square in board.piece_map() if board.piece_at(square).color == chess.BLACK and chess.square_rank(square) == 6)\n    return float(white_pawns_7th - black_pawns_7th)", "def feature(board: chess.Board) -> float:\n    \"Calculates the total number of pieces within the opponent's territory.\"\n    white_pieces_in_black_territory = sum(1 for square in board.piece_map() if board.piece_at(square).color == chess.WHITE and chess.square_rank(square) >= 4)\n    black_pieces_in_white_territory = sum(1 for square in board.piece_map() if board.piece_at(square).color == chess.BLACK and chess.square_rank(square) <= 3)\n    return float(white_pieces_in_black_territory - black_pieces_in_white_territory)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of rook pairs on the same file.\"\n    rook_pairs_on_same_file = sum(1 for file in range(8) if len([square for square in range(file, 56 + file, 8) if board.piece_at(square) and board.piece_at(square).piece_type == chess.ROOK]) > 1)\n    return float(rook_pairs_on_same_file)", "def feature(board: chess.Board) -> float:\n    \"Calculates the distance to the opponent's king from the closest piece of the player.\"\n    own_king_square = next(square for square in board.piece_map() if board.piece_at(square).piece_type == chess.KING and board.piece_at(square).color == board.turn)\n    opponent_king_square = next(square for square in board.piece_map() if board.piece_at(square).piece_type == chess.KING and board.piece_at(square).color != board.turn)\n    distance_to_opponent_king = min(chess.square_distance(own_king_square, piece_square) for piece_square in board.piece_map() if board.piece_at(piece_square).color == board.turn)\n    return float(distance_to_opponent_king)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of dangerous squares around the kings.\"\n    dangerous_squares = sum(1 for king_square in (square for square in board.piece_map() if board.piece_at(square).piece_type == chess.KING) for square in chess.SQUARES if board.is_attacked_by(not board.turn, square))\n    return float(dangerous_squares)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of pieces on the 4th and 5th ranks for both players.\"\n    pieces_on_4th_rank = sum(1 for square in board.piece_map() if chess.square_rank(square) == 3)\n    pieces_on_5th_rank = sum(1 for square in board.piece_map() if chess.square_rank(square) == 4)\n    return float(pieces_on_4th_rank + pieces_on_5th_rank) ", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pawns in the opponent's territory.\"\n    opponent_color = chess.WHITE if board.turn == chess.BLACK else chess.BLACK\n    count = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == opponent_color and piece.piece_type == chess.PAWN:\n            if chess.square_rank(square) > 4:  # Assuming opponent's territory is ranks 5-8\n                count += 1\n    return float(count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the average distance of all pieces from the opponent's back rank.\"\n    total_distance = 0\n    pieces_count = 0\n    opponent_back_rank = 0 if board.turn == chess.WHITE else 7\n    for square, piece in board.piece_map().items():\n        total_distance += chess.square_rank(square) - opponent_back_rank\n        pieces_count += 1\n    return total_distance / pieces_count if pieces_count > 0 else 0.0", "def feature(board: chess.Board) -> float:\n    \"Evaluates the number of connected pawns for the current player.\"\n    count = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == board.turn and piece.piece_type == chess.PAWN:\n            rank = chess.square_rank(square)\n            file = chess.square_file(square)\n            # Check horizontally and vertically connected pawns\n            connected = [\n                (file - 1, rank), (file + 1, rank), \n                (file, rank - 1), (file, rank + 1)\n            ]\n            for conn in connected:\n                if 0 <= conn[0] < 8 and 0 <= conn[1] < 8:\n                    if board.piece_at(chess.square(conn[0], conn[1])) and \\\n                            board.piece_at(chess.square(conn[0], conn[1])).color == board.turn:\n                        count += 1\n                        break\n    return float(count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the mobility of the pieces for the current player.\"\n    mobility = 0\n    for move in board.legal_moves:\n        if move.from_square not in board.piece_map():\n            continue\n        piece = board.piece_at(move.from_square)\n        if piece.color == board.turn:\n            mobility += 1\n    return float(mobility)", "def feature(board: chess.Board) -> float:\n    \"Measures how many squares are controlled by the current player's pieces.\"\n    controlled_squares = set()\n    for square, piece in board.piece_map().items():\n        if piece.color == board.turn:\n            controlled_squares.add(square)\n            if piece.piece_type == chess.PAWN:\n                controlled_squares.add(square + 7)  # Diagonal left\n                controlled_squares.add(square + 9)  # Diagonal right\n            elif piece.piece_type == chess.ROOK or piece.piece_type == chess.QUEEN:\n                for i in range(1, 8):\n                    controlled_squares.add(square + i)  # Horizontal right\n                    controlled_squares.add(square - i)  # Horizontal left\n            elif piece.piece_type == chess.BISHOP or piece.piece_type == chess.QUEEN:\n                for i in range(1, 8):\n                    controlled_squares.add(square + 8 * i + i)  # Diagonal up right\n                    controlled_squares.add(square + 8 * i - i)  # Diagonal up left\n    return float(len(controlled_squares))", "def feature(board: chess.Board) -> float:\n    \"Calculates the ratio of major pieces to pawns for the current player.\"\n    major_pieces_count = 0\n    pawns_count = 0\n    for piece in board.piece_map().values():\n        if piece.color == board.turn:\n            if piece.piece_type in [chess.QUEEN, chess.ROOK, chess.KNIGHT, chess.BISHOP]:\n                major_pieces_count += 1\n            elif piece.piece_type == chess.PAWN:\n                pawns_count += 1\n    return (major_pieces_count / pawns_count) if pawns_count > 0 else 0.0", "def feature(board: chess.Board) -> float:\n    \"Measures the number of threats against the king of the current player.\"\n    threats = 0\n    king_square = None\n    for square, piece in board.piece_map().items():\n        if piece.color == board.turn and piece.piece_type == chess.KING:\n            king_square = square\n            break\n    if king_square is not None:\n        for attacker in board.attackers(not board.turn, king_square):\n            threats += 1\n    return float(threats)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of isolated pawns for the current player.\"\n    isolated_count = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == board.turn and piece.piece_type == chess.PAWN:\n            rank = chess.square_rank(square)\n            file = chess.square_file(square)\n            # Check for neighboring pawns\n            has_neighbor = (\n                (file > 0 and board.piece_at(chess.square(file - 1, rank)) is None) and\n                (file < 7 and board.piece_at(chess.square(file + 1, rank)) is None)\n            )\n            if has_neighbor:\n                isolated_count += 1\n    return float(isolated_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the parity of pawns on the board to identify potential for promotion.\"\n    pawns_white = sum(1 for piece in board.piece_map().values() if piece.piece_type == chess.PAWN and piece.color == chess.WHITE)\n    pawns_black = sum(1 for piece in board.piece_map().values() if piece.piece_type == chess.PAWN and piece.color == chess.BLACK)\n    return float(pawns_white % 2) - float(pawns_black % 2)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of pieces each player has in the center (d4, d5, e4, e5).\"\n    center_squares = [chess.D4, chess.D5, chess.E4, chess.E5]\n    white_center = sum(1 for sq in center_squares if board.piece_at(sq) and board.piece_at(sq).color == chess.WHITE)\n    black_center = sum(1 for sq in center_squares if board.piece_at(sq) and board.piece_at(sq).color == chess.BLACK)\n    return float(white_center - black_center)", "def feature(board: chess.Board) -> float:\n    \"Calculates the total mobility of both players by counting legal moves.\"\n    white_mobility = len(list(board.legal_moves)) if board.turn == chess.WHITE else 0\n    black_mobility = len(list(board.legal_moves)) if board.turn == chess.BLACK else 0\n    return float(white_mobility - black_mobility)", "def feature(board: chess.Board) -> float:\n    \"Evaluates the number of backward pawns for both players.\"\n    backward_pawns_white = sum(1 for sq in chess.SQUARES if board.piece_at(sq) and \n                                  board.piece_at(sq).color == chess.WHITE and\n                                  board.piece_at(sq).piece_type == chess.PAWN and\n                                  (sq in [chess.A7, chess.B7, chess.C7, chess.D7, chess.E7, chess.F7, chess.G7, chess.H7] and \n                                   board.piece_at(sq + 8) is None))\n    backward_pawns_black = sum(1 for sq in chess.SQUARES if board.piece_at(sq) and \n                                  board.piece_at(sq).color == chess.BLACK and\n                                  board.piece_at(sq).piece_type == chess.PAWN and\n                                  (sq in [chess.A2, chess.B2, chess.C2, chess.D2, chess.E2, chess.F2, chess.G2, chess.H2] and \n                                   board.piece_at(sq - 8) is None))\n    return float(backward_pawns_white - backward_pawns_black)", "def feature(board: chess.Board) -> float:\n    \"Computes the number of pieces pinned by either player's pieces.\"\n    pinned_count = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == board.turn:\n            for attacker in board.attackers(not piece.color, square):\n                if board.piece_at(attacker).piece_type == chess.QUEEN or \\\n                   board.piece_at(attacker).piece_type == chess.ROOK:\n                    pinned_count += 1\n                    break\n    return float(pinned_count)", "def feature(board: chess.Board) -> float:\n    \"Measures the distance of kings from the center of the board.\"\n    white_king = next(square for square, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color == chess.WHITE)\n    black_king = next(square for square, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color == chess.BLACK)\n    center = chess.square_distance(white_king, chess.E4) + chess.square_distance(black_king, chess.E4)\n    return 24.0 - float(center) # Maximum distance on board is 24 (moronically far away)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of unprotected pieces on the board.\"\n    unprotected_count = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == board.turn:\n            if board.attackers(not piece.color, square):\n                continue\n        unprotected_count += 1\n    return float(unprotected_count)", "def feature(board: chess.Board) -> float:\n    \"Evaluates the material advantage of minor pieces (knights and bishops) between players.\"\n    white_minor = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE and piece.piece_type in [chess.BISHOP, chess.KNIGHT])\n    black_minor = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK and piece.piece_type in [chess.BISHOP, chess.KNIGHT])\n    return float(white_minor - black_minor)", "def feature(board: chess.Board) -> float:\n    \"Calculates the difference between the total number of rooks and kings on the board.\"\n    num_rooks_white = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE and piece.piece_type == chess.ROOK)\n    num_rooks_black = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK and piece.piece_type == chess.ROOK)\n    total_kings = 2  # Always 1 king each for both players\n    return float((num_rooks_white - num_rooks_black + total_kings))", "def feature(board: chess.Board) -> float:\n    \"Calculates the total number of pawns on the board.\"\n    return float(len([p for p in board.piece_map().values() if p.piece_type == chess.PAWN]))", "def feature(board: chess.Board) -> float:\n    \"Counts the number of squares attacked by each player's pieces.\"\n    white_attacks = sum(board.is_attacked_by(chess.WHITE, sq) for sq in chess.SQUARES)\n    black_attacks = sum(board.is_attacked_by(chess.BLACK, sq) for sq in chess.SQUARES)\n    return float(white_attacks - black_attacks)", "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in material value of pieces on the board.\"\n    piece_value = {chess.PAWN: 100, chess.KNIGHT: 320, chess.BISHOP: 330, chess.ROOK: 500, chess.QUEEN: 900, chess.KING: 0}\n    material_white = sum(piece_value[p.piece_type] for p in board.piece_map().values() if p.color == chess.WHITE)\n    material_black = sum(piece_value[p.piece_type] for p in board.piece_map().values() if p.color == chess.BLACK)\n    return float(material_white - material_black)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of king's moves available for each player.\"\n    white_king_square = next((sq for sq, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color == chess.WHITE), None)\n    black_king_square = next((sq for sq, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color == chess.BLACK), None)\n    white_moves = sum(1 for move in board.legal_moves if move.from_square == white_king_square)\n    black_moves = sum(1 for move in board.legal_moves if move.from_square == black_king_square)\n    return float(white_moves - black_moves)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of unguarded pieces on the board.\"\n    unguarded_count = sum(1 for square, piece in board.piece_map().items() if not board.is_attacked_by(not piece.color, square))\n    return float(unguarded_count)", "def feature(board: chess.Board) -> float:\n    \"Measures the material score based on the types of pieces remaining on the board.\"\n    material_score = 0\n    piece_values = {chess.PAWN: 100, chess.KNIGHT: 320, chess.BISHOP: 330, chess.ROOK: 500, chess.QUEEN: 900}\n    \n    for piece in board.piece_map().values():\n        value = piece_values.get(piece.piece_type, 0)\n        material_score += value if piece.color == chess.WHITE else -value\n    \n    return float(material_score)", "def feature(board: chess.Board) -> float:\n    \"Counts the total number of pawns remaining on the board for both players.\"\n    pawn_count = sum(1 for piece in board.piece_map().values() if piece.piece_type == chess.PAWN)\n    return float(pawn_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the central control by counting pieces on central squares.\"\n    central_squares = [chess.D4, chess.D5, chess.E4, chess.E5]\n    central_control = sum(1 for square in central_squares if board.piece_at(square) is not None)\n    return float(central_control)", "def feature(board: chess.Board) -> float:\n    \"Measures the average rank of pieces for the player to move.\"\n    total_rank = 0\n    total_pieces = 0\n    color = chess.WHITE if board.turn else chess.BLACK\n    \n    for square, piece in board.piece_map().items():\n        if piece.color == color:\n            total_rank += chess.square_rank(square) + 1  # ranks are 1-8\n            total_pieces += 1\n            \n    if total_pieces == 0:\n        return 0.0  # Avoid division by zero\n    return float(total_rank / total_pieces)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of defended pieces for the player to move.\"\n    defended_count = 0\n    color = chess.WHITE if board.turn else chess.BLACK\n    \n    for square, piece in board.piece_map().items():\n        if piece.color == color and board.is_attacked_by(not color, square):\n            defended_count += 1\n            \n    return float(defended_count)", "def feature(board: chess.Board) -> float:\n    \"Measures the spatial distribution of pieces by calculating the variance of their positions.\"\n    color = chess.WHITE if board.turn else chess.BLACK\n    positions = [chess.square_file(square) + chess.square_rank(square) * 10 for square, piece in board.piece_map().items() if piece.color == color]\n    \n    if not positions:\n        return 0.0\n    \n    mean_position = sum(positions) / len(positions)\n    variance = sum((x - mean_position) ** 2 for x in positions) / len(positions)\n    return float(variance)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of threatening pieces for the player to move, considering attacks.\"\n    attacking_count = sum(1 for move in board.legal_moves if board.is_attacked_by(not board.turn, move.to_square))\n    return float(attacking_count)", "def feature(board: chess.Board) -> float:\n    \"Counts unprotected pieces for the player to move.\"\n    unprotected_count = 0\n    color = chess.WHITE if board.turn else chess.BLACK\n    \n    for square, piece in board.piece_map().items():\n        if piece.color == color and not board.is_attacked_by(not color, square):\n            unprotected_count += 1\n            \n    return float(unprotected_count)", "def feature(board: chess.Board) -> float:\n    \"Measures mobility by counting the number of legal moves available to the player to move.\"\n    mobility = len(list(board.legal_moves))\n    return float(mobility)", "def feature(board: chess.Board) -> float:\n    \"Calculates the total number of pieces on the 7th rank for both players.\"\n    seventh_rank_count = sum(1 for square in chess.SQUARES[56:64] if board.piece_at(square) is not None)\n    return float(seventh_rank_count)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of pawns per player on the board, as pawns are critical in endgame scenarios.\"\n    white_pawns = sum(1 for p in board.piece_map().values() if p.color == chess.WHITE and p.piece_type == chess.PAWN)\n    black_pawns = sum(1 for p in board.piece_map().values() if p.color == chess.BLACK and p.piece_type == chess.PAWN)\n    return float(white_pawns - black_pawns)", "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in king safety, based on the number of pieces attacking the square around each king.\"\n    white_king_safety = sum(board.is_attacked_by(chess.BLACK, square) for square in board.piece_map() if board.piece_map()[square].color == chess.WHITE and board.piece_map()[square].piece_type == chess.KING)\n    black_king_safety = sum(board.is_attacked_by(chess.WHITE, square) for square in board.piece_map() if board.piece_map()[square].color == chess.BLACK and board.piece_map()[square].piece_type == chess.KING)\n    return float(black_king_safety - white_king_safety)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of doubled pawns for both players, as this can weaken pawn structure.\"\n    white_doubled_pawns = sum(1 for f in range(8) if sum(1 for r in range(8) if board.piece_at(chess.square(f, r)) and board.piece_at(chess.square(f, r)).color == chess.WHITE and board.piece_at(chess.square(f, r)).piece_type == chess.PAWN) > 1)\n    black_doubled_pawns = sum(1 for f in range(8) if sum(1 for r in range(8) if board.piece_at(chess.square(f, r)) and board.piece_at(chess.square(f, r)).color == chess.BLACK and board.piece_at(chess.square(f, r)).piece_type == chess.PAWN) > 1)\n    return float(white_doubled_pawns - black_doubled_pawns)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces on the board for each player to help assess piece activity.\"\n    num_white_pieces = len([p for p in board.piece_map().values() if p.color == chess.WHITE])\n    num_black_pieces = len([p for p in board.piece_map().values() if p.color == chess.BLACK])\n    return float(num_white_pieces - num_black_pieces)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of pieces each player has on squares adjacent to the opponent's king, signifying pressure.\"\n    white_pressure = sum(1 for square in board.piece_map() if board.piece_map()[square].color == chess.WHITE and (chess.square_distance(chess.parse_square('e8'), square) == 1))\n    black_pressure = sum(1 for square in board.piece_map() if board.piece_map()[square].color == chess.BLACK and (chess.square_distance(chess.parse_square('e1'), square) == 1))\n    return float(white_pressure - black_pressure)", "def feature(board: chess.Board) -> float:\n    \"Measures how many pieces are pinned against the respective kings of both players, which can impact mobility.\"\n    white_pinned = sum(1 for square in board.piece_map() if board.piece_map()[square].color == chess.WHITE and board.is_attacked_by(chess.BLACK, square))\n    black_pinned = sum(1 for square in board.piece_map() if board.piece_map()[square].color == chess.BLACK and board.is_attacked_by(chess.WHITE, square))\n    return float(white_pinned - black_pinned)", "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in the number of legal moves available for each player.\"\n    white_moves = len(list(board.legal_moves) if board.turn == chess.WHITE else [])\n    black_moves = len(list(board.legal_moves) if board.turn == chess.BLACK else [])\n    return float(white_moves - black_moves)", "def feature(board: chess.Board) -> float:\n    \"Measures the potential mobility by counting the total legal moves available for both players.\"\n    mobility_white = len(list(board.legal_moves)) if board.turn else 0\n    mobility_black = len(list(board.legal_moves)) if not board.turn else 0\n    return float(mobility_white - mobility_black)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces on the back rank that can be mobilized in the next few moves.\"\n    back_rank = 0\n    rank = 0 if board.turn else 7\n    for file in range(8):\n        piece = board.piece_at(chess.square(rank, file))\n        if piece and piece.color == board.turn:\n            back_rank += 1\n    return float(back_rank)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of king's pawn (2nd/7th rank) controlling squares nearby the opponent's king.\"\n    opponent_king_square = None\n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.KING and piece.color != board.turn:\n            opponent_king_square = square\n    \n    control_count = 0\n    if opponent_king_square is not None:\n        for move in board.legal_moves:\n            if board.is_attacked_by(board.turn, opponent_king_square):\n                control_count += 1\n                \n    return float(control_count)", "def feature(board: chess.Board) -> float:\n    \"Measures the control of center squares (d4, d5, e4, e5) in relation to total pieces.\"\n    center_control = 0\n    center_squares = [chess.parse_square('d4'), chess.parse_square('d5'), chess.parse_square('e4'), chess.parse_square('e5')]\n    for sq in center_squares:\n        if board.is_attacked_by(board.turn, sq):\n            center_control += 1\n        if board.is_attacked_by(not board.turn, sq):\n            center_control -= 1\n    return float(center_control)", "def feature(board: chess.Board) -> float:\n    \"Calculate the difference between the number of pawns on the 7th and 2nd ranks.\"\n    white_pawns_on_7th = len([1 for sq in board.piece_map() if board.piece_at(sq).piece_type == chess.PAWN and board.piece_at(sq).color == chess.WHITE and chess.square_rank(sq) == 6])\n    black_pawns_on_2nd = len([1 for sq in board.piece_map() if board.piece_at(sq).piece_type == chess.PAWN and board.piece_at(sq).color == chess.BLACK and chess.square_rank(sq) == 1])\n    return float(white_pawns_on_7th - black_pawns_on_2nd)", "def feature(board: chess.Board) -> float:\n    \"Evaluates the safety of the kings by counting the number of pieces attacking each king.\"\n    white_king_square = board.king(chess.WHITE)\n    black_king_square = board.king(chess.BLACK)\n    \n    white_king_attackers = len(board.attackers(chess.BLACK, white_king_square))\n    black_king_attackers = len(board.attackers(chess.WHITE, black_king_square))\n    \n    return float(white_king_attackers - black_king_attackers)", "def feature(board: chess.Board) -> float:\n    \"Measures the distance from all bishops to the opponent's pieces as an indicator of their activity.\"\n    opponent_pieces_squares = [sq for sq, piece in board.piece_map().items() if piece.color != board.turn]\n    bishops_squares = [sq for sq, piece in board.piece_map().items() if piece.piece_type == chess.BISHOP and piece.color == board.turn]\n    \n    total_distance = 0\n    for bishop in bishops_squares:\n        for opponent_piece in opponent_pieces_squares:\n            total_distance += chess.square_distance(bishop, opponent_piece)\n    \n    return float(total_distance)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of pieces that have a direct attack towards the opponent's king.\"\n    opponent_king_square = board.king(not board.turn)\n    attack_count = 0\n    \n    for square, piece in board.piece_map().items():\n        if piece.color == board.turn and (piece.piece_type in [chess.QUEEN, chess.ROOK, chess.BISHOP]):\n            if board.is_attacked_by(not board.turn, opponent_king_square):\n                attack_count += 1\n    \n    return float(attack_count)", "def feature(board: chess.Board) -> float:\n    \"Measures the distance of the closest piece to the opponent's king.\"\n    king_square = board.king(chess.BLACK) if board.turn else board.king(chess.WHITE)\n    closest_distance = min(chess.square_distance(king_square, sq) for sq, piece in board.piece_map().items() if piece.color == (chess.WHITE if board.turn else chess.BLACK))\n    return float(closest_distance)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces that are attacking the opponent's back rank.\"\n    back_rank = 0 if board.turn else 7\n    attacking_pieces = sum(1 for sq in chess.SQUARES if board.is_attacked_by(chess.WHITE if board.turn else chess.BLACK, sq) and chess.square_rank(sq) == back_rank)\n    return float(attacking_pieces)", "def feature(board: chess.Board) -> float:\n    \"Calculates the ratio of pawns to total pieces for the current player.\"\n    pieces_count = len([piece for piece in board.piece_map().values() if piece.color == (chess.WHITE if board.turn else chess.BLACK)])\n    pawns_count = len([piece for piece in board.piece_map().values() if piece.color == (chess.WHITE if board.turn else chess.BLACK) and piece.piece_type == chess.PAWN])\n    return float(pawns_count / pieces_count) if pieces_count > 0 else 0.0", "def feature(board: chess.Board) -> float:\n    \"Measures control of the center by counting pieces in central squares.\"\n    central_squares = [chess.E4, chess.E5, chess.D4, chess.D5]\n    control_count = sum(1 for sq in central_squares if board.piece_at(sq) and board.piece_at(sq).color == (chess.WHITE if board.turn else chess.BLACK))\n    return float(control_count)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces for each player on squares that are attacked by the opponent.\"\n    opponent_color = chess.BLACK if board.turn else chess.WHITE\n    attacking_squares = [sq for sq in chess.SQUARES if board.is_attacked_by(opponent_color, sq)]\n    defending_pieces_count = sum(1 for sq in attacking_squares if board.piece_at(sq) and board.piece_at(sq).color == (chess.WHITE if board.turn else chess.BLACK))\n    return float(defending_pieces_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of pieces behind the pawns for the current player.\"\n    color = chess.WHITE if board.turn else chess.BLACK\n    back_rank = 0 if color == chess.WHITE else 7\n    pieces_behind_pawns = sum(1 for sq, piece in board.piece_map().items() if piece.color == color and chess.square_rank(sq) > back_rank and piece.piece_type != chess.PAWN)\n    return float(pieces_behind_pawns)", "def feature(board: chess.Board) -> float:\n    \"Measures the mobility difference by counting the potential legal moves.\"\n    white_moves = len(list(board.legal_moves)) if board.turn else 0\n    black_moves = len(list(board.legal_moves)) if not board.turn else 0\n    mobility_difference = white_moves - black_moves\n    return float(mobility_difference)", "def feature(board: chess.Board) -> float:\n    \"Measures how many pieces are on squares with two or more attacks for the current player.\"\n    color = chess.WHITE if board.turn else chess.BLACK\n    strong_squares = [sq for sq in chess.SQUARES if len(board.attackers(color, sq)) >= 2]\n    strong_piece_count = sum(1 for sq in strong_squares if board.piece_at(sq) and board.piece_at(sq).color == color)\n    return float(strong_piece_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the total value of the player's pieces that are currently on the board.\"\n    piece_values = {chess.PAWN: 100, chess.KNIGHT: 300, chess.BISHOP: 300, chess.ROOK: 500, chess.QUEEN: 900, chess.KING: 0}\n    total_value = sum(piece_values[piece.piece_type] for piece in board.piece_map().values() if piece.color == (chess.WHITE if board.turn else chess.BLACK))\n    return float(total_value)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces placed on squares that control key central squares (d4, d5, e4, e5).\"\n    central_squares = [chess.parse_square(sq) for sq in ['d4', 'd5', 'e4', 'e5']]\n    return float(sum(1 for sq in board.piece_map() if sq in central_squares))", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces remaining for each player and computes a ratio.\"\n    white_piece_count = len([1 for p in board.piece_map().values() if p.color == chess.WHITE])\n    black_piece_count = len([1 for p in board.piece_map().values() if p.color == chess.BLACK])\n    return float(white_piece_count / (black_piece_count + 1e-5))", "def feature(board: chess.Board) -> float:\n    \"Counts the total number of legal moves available to the player to move.\"\n    return float(len(list(board.legal_moves)))", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of pawns each player has on the board.\"\n    white_pawns = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE and piece.piece_type == chess.PAWN)\n    black_pawns = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK and piece.piece_type == chess.PAWN)\n    return float(white_pawns - black_pawns)", "def feature(board: chess.Board) -> float:\n    \"Measures the distance of the closest king to the center of the board.\"\n    king_square = next((square for square, piece in board.piece_map().items() if piece.piece_type == chess.KING), None)\n    if king_square is None:\n        return 0.0\n    center_square = chess.square(3, 3)  # e4\n    return float(chess.square_distance(king_square, center_square))", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces for each player and gives a ratio of white to black pieces.\"\n    white_count = len([piece for piece in board.piece_map().values() if piece.color == chess.WHITE])\n    black_count = len([piece for piece in board.piece_map().values() if piece.color == chess.BLACK])\n    return float(white_count / (black_count + 1))  # Avoid division by zero", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of squares controlled by each player's pawns.\"\n    def controlled_squares(color):\n        return sum(1 for square in board.piece_map() if board.piece_at(square) and board.piece_at(square).color == color and \n                   (chess.square_file(square) > 0 and board.is_attacked_by(not color, square - 1)) or \n                   (chess.square_file(square) < 7 and board.is_attacked_by(not color, square + 1)))\n    return float(controlled_squares(chess.WHITE) - controlled_squares(chess.BLACK))", "def feature(board: chess.Board) -> float:\n    \"Counts the number of moves left for each player and returns the difference.\"\n    white_moves = len(list(board.legal_moves))\n    black_moves = len(list(board.legal_moves)) - white_moves  # Total moves minus white moves\n    return float(white_moves - black_moves)", "def feature(board: chess.Board) -> float:\n    \"Measures the tempo advantage by seeing how many halfmoves each player has made.\"\n    return float(board.halfmove_clock)", "def feature(board: chess.Board) -> float:\n    \"Evaluates pawn structure by counting isolated pawns for each player.\"\n    def isolated_pawns(color):\n        return sum(1 for square in board.piece_map()\n                   if board.piece_at(square).color == color and \n                   (board.piece_at(square).piece_type == chess.PAWN and \n                   (board.piece_at(square - 1) is None and board.piece_at(square + 1) is None)))\n    return float(isolated_pawns(chess.WHITE) - isolated_pawns(chess.BLACK))", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces on the back rank for each side and returns the difference.\"\n    def back_rank_pieces(color):\n        return sum(1 for square in range(chess.A8, chess.H8 + 1) \n                   if board.piece_at(square) and board.piece_at(square).color == color)\n    return float(back_rank_pieces(chess.WHITE) - back_rank_pieces(chess.BLACK))", "def feature(board: chess.Board) -> float:\n    \"Calculates the total mobility score based on the mobility of queens alone.\"\n    def queen_mobility(color):\n        return sum(len(list(board.legal_moves)) for square in board.piece_map() \n                   if board.piece_at(square).color == color and board.piece_at(square).piece_type == chess.QUEEN)\n    return float(queen_mobility(chess.WHITE) - queen_mobility(chess.BLACK))", "def feature(board: chess.Board) -> float:\n    \"Measures the difference in piece value between the two players.\"\n    white_value = sum(piece.piece_type for piece in board.piece_map().values() if piece.color == chess.WHITE)\n    black_value = sum(piece.piece_type for piece in board.piece_map().values() if piece.color == chess.BLACK)\n    return float(white_value - black_value)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of squares under attack by each player.\"\n    white_attacks = sum(board.is_attacked_by(chess.WHITE, square) for square in chess.SQUARES)\n    black_attacks = sum(board.is_attacked_by(chess.BLACK, square) for square in chess.SQUARES)\n    return float(white_attacks - black_attacks)", "def feature(board: chess.Board) -> float:\n    \"Calculates the central control by counting pieces on central squares.\"\n    central_squares = [chess.D4, chess.D5, chess.E4, chess.E5]\n    white_central = sum(1 for sq in central_squares if board.piece_at(sq) and board.piece_at(sq).color == chess.WHITE)\n    black_central = sum(1 for sq in central_squares if board.piece_at(sq) and board.piece_at(sq).color == chess.BLACK)\n    return float(white_central - black_central)", "def feature(board: chess.Board) -> float:\n    \"Records the total number of pieces on the board.\"\n    return float(len(board.piece_map()))", "def feature(board: chess.Board) -> float:\n    \"Checks for king safety by measuring the number of escape squares for the king.\"\n    king_square = next((sq for sq, piece in board.piece_map().items() if piece.piece_type == chess.KING), None)\n    if king_square is None:\n        return 0.0\n    return float(len(list(board.legal_moves)) - len(board.attackers(chess.WHITE if board.turn else chess.BLACK, king_square)))", "def feature(board: chess.Board) -> float:\n    \"Measures the number of unoccupied squares on the board.\"\n    return float(len([sq for sq in chess.SQUARES if board.piece_at(sq) is None]))", "def feature(board: chess.Board) -> float:\n    \"Calculates the material disparity, assigning different weights to pieces.\"\n    piece_values = {chess.PAWN: 100, chess.KNIGHT: 300, chess.BISHOP: 300, chess.ROOK: 500, chess.QUEEN: 900}\n    material_balance = sum(piece_values.get(piece.piece_type, 0) for piece in board.piece_map().values() if piece.color == chess.WHITE) - \\\n                      sum(piece_values.get(piece.piece_type, 0) for piece in board.piece_map().values() if piece.color == chess.BLACK)\n    return float(material_balance)", "def feature(board: chess.Board) -> float:\n    \"Evaluates the mobility potential based on the difference in legal moves available.\"\n    white_moves = sum(1 for move in board.legal_moves if move.from_square not in board.piece_map() or board.piece_at(move.from_square).color == chess.WHITE)\n    black_moves = sum(1 for move in board.legal_moves if move.from_square not in board.piece_map() or board.piece_at(move.from_square).color == chess.BLACK)\n    return float(white_moves - black_moves)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces controlled by the player that are in enemy territory.\"\n    controlled_in_enemy_territory = 0\n    for sq, piece in board.piece_map().items():\n        if piece.color == board.turn and chess.square_rank(sq) > 4:  # Past the 4th rank for White\n            controlled_in_enemy_territory += 1\n    return float(controlled_in_enemy_territory)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of squares controlled by each player's pieces.\"\n    controlled_squares = {chess.WHITE: set(), chess.BLACK: set()}\n    for sq, piece in board.piece_map().items():\n        if piece.color == chess.WHITE:\n            controlled_squares[chess.WHITE].update(board.attacks(sq))\n        else:\n            controlled_squares[chess.BLACK].update(board.attacks(sq))\n    return float(len(controlled_squares[chess.WHITE]) - len(controlled_squares[chess.BLACK]))", "def feature(board: chess.Board) -> float:\n    \"Calculates the ratio of minor pieces to major pieces on the board.\"\n    minor_pieces = 0\n    major_pieces = 0\n    for piece in board.piece_map().values():\n        if piece.piece_type in (chess.KNIGHT, chess.BISHOP):\n            minor_pieces += 1\n        elif piece.piece_type in (chess.ROOK, chess.QUEEN):\n            major_pieces += 1\n    return float(minor_pieces) / (major_pieces + 1)  # Prevent division by zero", "def feature(board: chess.Board) -> float:\n    \"Measures the mobility of the player by counting the available legal moves.\"\n    return float(len(list(board.legal_moves)))", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of pieces that are attacking the opponent's king.\"\n    attacking_kings = len(board.attackers(not board.turn, board.king(board.turn)))\n    return float(attacking_kings)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of squares occupied by pawns of the current player.\"\n    pawn_count = sum(1 for piece in board.piece_map().values() if piece.piece_type == chess.PAWN and piece.color == board.turn)\n    return float(pawn_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the proximity of the kings (Manhattan distance between kings).\"\n    white_king_square = board.king(chess.WHITE)\n    black_king_square = board.king(chess.BLACK)\n    distance = chess.square_distance(white_king_square, black_king_square)\n    return float(distance)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of doubles, where two pieces can attack the same opponent piece.\"\n    double_attack_count = 0\n    for sq in board.piece_map().keys():\n        attackers = board.attackers(not board.turn, sq)\n        if len(attackers) > 1:\n            double_attack_count += 1\n    return float(double_attack_count)", "def feature(board: chess.Board) -> float:\n    \"Checks if any pieces are on the 7th rank (2nd rank for Black), indicating strong positioning.\"\n    strong_positions = sum(1 for sq, piece in board.piece_map().items() if piece.color == board.turn and chess.square_rank(sq) == 6)\n    return float(strong_positions)", "def feature(board: chess.Board) -> float:\n    \"Measures the total number of squares controlled by each player.\"\n    white_control = sum(1 for square in board.piece_map() if board.piece_at(square).color == chess.WHITE and board.attackers(chess.WHITE, square))\n    black_control = sum(1 for square in board.piece_map() if board.piece_at(square).color == chess.BLACK and board.attackers(chess.BLACK, square))\n    return float(white_control - black_control)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pawns for each player and returns the difference.\"\n    white_pawns = len([p for p in board.piece_map().values() if p.color == chess.WHITE and p.piece_type == chess.PAWN])\n    black_pawns = len([p for p in board.piece_map().values() if p.color == chess.BLACK and p.piece_type == chess.PAWN])\n    return float(white_pawns - black_pawns)", "def feature(board: chess.Board) -> float:\n    \"Calculates the total mobility of pieces for each player.\"\n    white_mobility = len(list(board.legal_moves)) if board.turn else 0\n    black_mobility = len(list(board.legal_moves)) if not board.turn else 0\n    return float(white_mobility - black_mobility)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of pieces that are currently unprotected.\"\n    unprotected_pieces = sum(1 for square, piece in board.piece_map().items() if piece.color == board.turn and not board.attackers(not board.turn, square))\n    return float(unprotected_pieces)", "def feature(board: chess.Board) -> float:\n    \"Measures the distance of the nearest opponent's piece to the current player's king.\"\n    king_square = next(square for square, piece in board.piece_map().items() if piece.color == board.turn and piece.piece_type == chess.KING)\n    opponent_pieces = [square for square, piece in board.piece_map().items() if piece.color != board.turn]\n    if not opponent_pieces:\n        return float('inf')  # No opponent pieces on the board\n    nearest_distance = min(chess.square_distance(king_square, sq) for sq in opponent_pieces)\n    return float(nearest_distance)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of isolated pawns for the current player.\"\n    color = chess.WHITE if board.turn else chess.BLACK\n    isolated_pawns = 0\n    for square in range(64):\n        piece = board.piece_at(square)\n        if piece and piece.color == color and piece.piece_type == chess.PAWN:\n            file = chess.square_file(square)\n            if (board.piece_at(chess.parse_square(f'{chr(file + 97)}{chess.square_rank(square) + 1}')) is None and\n                board.piece_at(chess.parse_square(f'{chr(file + 97)}{chess.square_rank(square) - 1}')) is None):\n                isolated_pawns += 1\n    return float(isolated_pawns)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of pieces attacking the opponent's king.\"\n    color = chess.WHITE if board.turn else chess.BLACK\n    king_square = next((square for square, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color != color), None)\n    if king_square is None:\n        return 0.0\n    attacking_pieces_count = sum(1 for square in board.piece_map() if board.is_attacked_by(color, square))\n    return float(attacking_pieces_count)", "def feature(board: chess.Board) -> float:\n    \"Counts the total number of check threats on both sides.\"\n    white_check_threats = sum(1 for move in board.legal_moves if board.is_check())\n    black_check_threats = sum(1 for move in board.legal_moves if board.is_check())\n    return float(white_check_threats - black_check_threats)", "def feature(board: chess.Board) -> float:\n    \"Calculates the average distance of all pieces from the opponent's king.\"\n    opponent_king_square = next(square for square in board.piece_map() \n                                 if board.piece_at(square).piece_type == chess.KING and \n                                 board.piece_at(square).color != board.turn)\n    total_distance = sum(chess.square_distance(square, opponent_king_square) \n                         for square in board.piece_map() \n                         if board.piece_at(square).color == board.turn)\n    piece_count = len(list(board.piece_map().keys()))\n    return total_distance / piece_count if piece_count > 0 else 0.0", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pawns that are passed for the player to move.\"\n    passed_pawns = 0\n    for square in board.pieces(chess.PAWN, board.turn):\n        file = chess.square_file(square)\n        ranks_to_check = [rank for rank in range(chess.square_rank(square) + 1, 8)] if board.turn == chess.WHITE else \\\n                         [rank for rank in range(0, chess.square_rank(square))]\n        if all(board.piece_at(chess.square(file, rank)) is None for rank in ranks_to_check):\n            passed_pawns += 1\n    return float(passed_pawns)", "def feature(board: chess.Board) -> float:\n    \"Calculates the ratio of pieces on the back rank for both players.\"\n    back_rank_count = {chess.WHITE: 0, chess.BLACK: 0}\n    for square in board.piece_map():\n        piece = board.piece_at(square)\n        if piece is not None and chess.square_rank(square) == (0 if piece.color == chess.WHITE else 7):\n            back_rank_count[piece.color] += 1\n    total_pieces = len(board.piece_map())\n    return (back_rank_count[board.turn] / total_pieces) if total_pieces > 0 else 0.0", "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in the number of pieces in the center of the board for both players.\"\n    center_squares = [chess.E4, chess.E5, chess.D4, chess.D5]\n    white_center_count = sum(1 for square in center_squares if board.piece_at(square) is not None and \n                              board.piece_at(square).color == chess.WHITE)\n    black_center_count = sum(1 for square in center_squares if board.piece_at(square) is not None and \n                              board.piece_at(square).color == chess.BLACK)\n    return float(white_center_count - black_center_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the presence of any major pieces (rooks or queens) controlling the same file.\"\n    controlling_files = {}\n    for square in board.piece_map():\n        piece = board.piece_at(square)\n        if piece is not None and piece.piece_type in [chess.ROOK, chess.QUEEN]:\n            controlling_files.setdefault(chess.square_file(square), []).append(piece.color)\n    control_count = sum(1 for colors in controlling_files.values() if len(set(colors)) > 1)\n    return float(control_count)", "def feature(board: chess.Board) -> float:\n    \"Counts the pieces on the 7th rank for the player to move.\"\n    seventh_rank_count = 0\n    rank = 6 if board.turn == chess.WHITE else 1\n    for file in range(8):\n        square = chess.square(file, rank)\n        if board.piece_at(square) is not None and board.piece_at(square).color == board.turn:\n            seventh_rank_count += 1\n    return float(seventh_rank_count)", "def feature(board: chess.Board) -> float:\n    \"Measures the total number of checks available by the current player.\"\n    check_count = sum(1 for move in board.legal_moves if board.gives_check(move))\n    return float(check_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of pawn chains for the current player.\"\n    pawns = [s for s in board.piece_map() if board.piece_at(s).piece_type == chess.PAWN]\n    pawn_chains = 0\n    visited = set()\n    \n    for pawn in pawns:\n        if pawn in visited:\n            continue\n        chain = 1\n        visited.add(pawn)\n        \n        # Check upward and diagonal connections\n        for rank_offset in [-1, 0, 1]:\n            connected_pawn = chess.square(pawn_file := chess.square_file(pawn), pawn_rank := chess.square_rank(pawn) + rank_offset)\n            if board.piece_at(connected_pawn) and board.piece_at(connected_pawn).piece_type == chess.PAWN:\n                chain += 1\n                visited.add(connected_pawn)\n        \n        pawn_chains += chain > 1\n\n    return float(pawn_chains)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces on the back rank for both players.\"\n    back_rank_count = {chess.WHITE: 0, chess.BLACK: 0}\n    for square in range(64):\n        piece = board.piece_at(square)\n        if piece and (chess.square_rank(square) == 0 or chess.square_rank(square) == 7):\n            back_rank_count[piece.color] += 1\n\n    return float(back_rank_count[chess.WHITE] - back_rank_count[chess.BLACK])", "def feature(board: chess.Board) -> float:\n    \"Calculates the ratio of pieces in the opponent's territory.\"\n    opponent_territory_count = sum(1 for square in board.piece_map() if (chess.square_rank(square) == 0 and board.piece_at(square).color == chess.BLACK) or (chess.square_rank(square) == 7 and board.piece_at(square).color == chess.WHITE))\n    total_pieces = len(board.piece_map())\n    \n    return float(opponent_territory_count) / total_pieces if total_pieces > 0 else 0.0", "def feature(board: chess.Board) -> float:\n    \"Calculates the total value of pieces that are currently pinned.\"\n    pinned_value = 0\n    for square, piece in board.piece_map().items():\n        if board.is_attacked_by(not piece.color, square):\n            pinned_value += {chess.PAWN: 100, chess.KNIGHT: 320, chess.BISHOP: 330, chess.ROOK: 500, chess.QUEEN: 900, chess.KING: 20000}.get(piece.piece_type, 0)\n    \n    return float(pinned_value)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of threatening pieces (pieces that attack opponent's pieces).\"\n    threats = 0\n    for square in board.piece_map().keys():\n        if board.is_attacked_by(not board.piece_at(square).color, square):\n            threats += 1\n    \n    return float(threats)", "def feature(board: chess.Board) -> float:\n    \"Calculates the average depth of the positions for pieces on the board.\"\n    total_depth = sum(chess.square_rank(square) for square in board.piece_map())\n    total_pieces = len(board.piece_map())\n    \n    return float(total_depth) / total_pieces if total_pieces > 0 else 0.0", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of unprotected pieces on the board.\"\n    unprotected_count = sum(1 for square, piece in board.piece_map().items() if not board.is_attacked_by(not piece.color, square))\n    return float(unprotected_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the proportion of pieces developed (not on their starting ranks).\"\n    total_developed = sum(1 for square, piece in board.piece_map().items() if (piece.color == chess.WHITE and chess.square_rank(square) > 1) or (piece.color == chess.BLACK and chess.square_rank(square) < 6))\n    total_pieces = len(board.piece_map())\n    \n    return float(total_developed) / total_pieces if total_pieces > 0 else 0.0", "def feature(board: chess.Board) -> float:\n    \"Calculates the total number of available squares for each player's king.\"\n    white_king_square = board.king(chess.WHITE)\n    black_king_square = board.king(chess.BLACK)\n    white_king_moves = sum(1 for move in board.legal_moves if move.from_square == white_king_square)\n    black_king_moves = sum(1 for move in board.legal_moves if move.from_square == black_king_square)\n    return float(white_king_moves - black_king_moves)", "def feature(board: chess.Board) -> float:\n    \"Measures the difference in mobility between both players based on their legal moves.\"\n    white_moves = len(list(board.legal_moves))\n    board.push(chess.Move.null())  # Avoid move iterator issue\n    black_moves = len(list(board.legal_moves))\n    board.pop()  # Remove the null move\n    return float(white_moves - black_moves)", "def feature(board: chess.Board) -> float:\n    \"Counts the total number of pieces on the board for both players.\"\n    total_pieces = sum(1 for piece in board.piece_map().values())\n    return float(total_pieces)", "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in the number of Knights controlled by both players.\"\n    white_knights = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE and piece.piece_type == chess.KNIGHT)\n    black_knights = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK and piece.piece_type == chess.KNIGHT)\n    return float(white_knights - black_knights)", "def feature(board: chess.Board) -> float:\n    \"Calculates the total number of pawns that are passed for both players.\"\n    def is_passed_pawn(square, color):\n        if color == chess.WHITE:\n            return all(board.piece_at(s) is None for s in range(square + 8, chess.H8 + 1))\n        else:\n            return all(board.piece_at(s) is None for s in range(square - 8, chess.A1 - 1))\n    \n    passed_count = sum(1 for square, piece in board.piece_map().items() if piece.piece_type == chess.PAWN and is_passed_pawn(square, piece.color))\n    return float(passed_count)", "def feature(board: chess.Board) -> float:\n    \"Measures the active pieces by counting non-pawn pieces for both players.\"\n    active_white = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE and piece.piece_type != chess.PAWN)\n    active_black = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK and piece.piece_type != chess.PAWN)\n    return float(active_white - active_black)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of checks that can be delivered next move by each player.\"\n    white_checks = sum(1 for move in board.legal_moves if board.piece_at(move.from_square).color == chess.WHITE and board.is_check())\n    board.push(chess.Move.null())  # Avoid move iterator issue\n    black_checks = sum(1 for move in board.legal_moves if board.piece_at(move.from_square).color == chess.BLACK and board.is_check())\n    board.pop()  # Remove the null move\n    return float(white_checks - black_checks)", "def feature(board: chess.Board) -> float:\n    \"Evaluates the configuration of rooks on open files.\"\n    open_files = [file for file in range(8) if all(board.piece_at(chess.square(file, rank)) is None for rank in range(8))]\n    return float(len(open_files))", "def feature(board: chess.Board) -> float:\n    \"Measures the ratio of total material value for both players.\"\n    piece_values = {chess.PAWN: 100, chess.KNIGHT: 320, chess.BISHOP: 330, chess.ROOK: 500, chess.QUEEN: 900, chess.KING: 0}\n    white_value = sum(piece_values[piece.piece_type] for piece in board.piece_map().values() if piece.color == chess.WHITE)\n    black_value = sum(piece_values[piece.piece_type] for piece in board.piece_map().values() if piece.color == chess.BLACK)\n    return float(white_value / (black_value + 1))  # Avoid division by zero", "def feature(board: chess.Board) -> float:\n    \"Counts the number of squares under attack by both players.\"\n    white_attacks = sum(1 for square in chess.SQUARES if board.is_attacked_by(chess.WHITE, square))\n    black_attacks = sum(1 for square in chess.SQUARES if board.is_attacked_by(chess.BLACK, square))\n    return float(white_attacks - black_attacks)", "def feature(board: chess.Board) -> float:\n    \"Calculates the ratio of active pieces (those that can move) to total pieces for the current player.\"\n    active_pieces = sum(1 for move in board.legal_moves)\n    total_pieces = len(board.piece_map())\n    return active_pieces / total_pieces if total_pieces > 0 else 0.0", "def feature(board: chess.Board) -> float:\n    \"Counts the number of connected pieces for the current player (pieces adjacent to each other).\"\n    player = chess.WHITE if board.turn else chess.BLACK\n    connected_count = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == player:\n            for direction in (-1, 1):  # Check left and right\n                adjacent_square = square + direction\n                if chess.square_file(square) + direction in range(8) and board.piece_at(adjacent_square) and board.piece_at(adjacent_square).color == player:\n                    connected_count += 1\n    return float(connected_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of squares attacked by the current player's pieces.\"\n    player = chess.WHITE if board.turn else chess.BLACK\n    attacked_squares = set()\n    for square in board.piece_map():\n        piece = board.piece_at(square)\n        if piece and piece.color == player:\n            attacked_squares.update(board.attackers(player, square))\n    return float(len(attacked_squares))", "def feature(board: chess.Board) -> float:\n    \"Measures king activity by counting squares the king can move to and is not currently attacked.\"\n    player = board.turn\n    king_square = next(square for square, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color == player)\n    legal_king_moves = [move for move in board.legal_moves if move.from_square == king_square]\n    safe_moves = sum(1 for move in legal_king_moves if not board.is_attacked_by(not player, move.to_square))\n    return float(safe_moves)", "def feature(board: chess.Board) -> float:\n    \"Measures central control by counting pieces in the central squares (d4, e4, d5, e5) for the current player.\"\n    central_squares = [chess.D4, chess.E4, chess.D5, chess.E5]\n    player = chess.WHITE if board.turn else chess.BLACK\n    central_control = sum(1 for square in central_squares if board.piece_at(square) and board.piece_at(square).color == player)\n    return float(central_control)", "def feature(board: chess.Board) -> float:\n    \"Calculates the remaining material on the board and gives a value based on its significance.\"\n    material_values = {\n        chess.PAWN: 100,\n        chess.KNIGHT: 320,\n        chess.BISHOP: 330,\n        chess.ROOK: 500,\n        chess.QUEEN: 900,\n        chess.KING: 0\n    }\n    total_material = sum(material_values[piece.piece_type] for piece in board.piece_map().values())\n    return float(total_material)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of pieces that are double attacked by enemy pieces.\"\n    double_attacked = 0\n    for square in board.piece_map():\n        if board.is_attacked_by(chess.WHITE, square) and board.is_attacked_by(chess.BLACK, square):\n            double_attacked += 1\n    return float(double_attacked)", "def feature(board: chess.Board) -> float:\n    \"Measures the distance of the king to the nearest enemy piece and returns it.\"\n    king_square = None\n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.KING and piece.color == board.turn:\n            king_square = square\n            break\n    if king_square is None:\n        return 0.0\n    nearest_enemy_distance = float('inf')\n    for square, piece in board.piece_map().items():\n        if piece.color != board.turn:\n            distance = chess.square_distance(king_square, square)\n            nearest_enemy_distance = min(nearest_enemy_distance, distance)\n    return float(nearest_enemy_distance)", "def feature(board: chess.Board) -> float:\n    \"Calculates the total number of pawns for each color and returns their ratio.\"\n    white_pawn_count = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE and piece.piece_type == chess.PAWN)\n    black_pawn_count = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK and piece.piece_type == chess.PAWN)\n    return float(white_pawn_count / (black_pawn_count + 1) - black_pawn_count / (white_pawn_count + 1))", "def feature(board: chess.Board) -> float:\n    \"Counts the number of total possible checks that can be made by both players.\"\n    total_checks = 0\n    for move in board.legal_moves:\n        board.push(move)\n        if board.is_check():\n            total_checks += 1\n        board.pop()\n    return float(total_checks)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces pinned against the king by each player.\"\n    pinned_count = 0\n    for square in board.piece_map():\n        piece = board.piece_at(square)\n        if piece is not None and piece.color == board.turn:\n            for attacker in board.attackers(not board.turn, square):\n                if board.piece_at(attacker) and board.is_attacked_by(board.turn, attacker):\n                    pinned_count += 1\n                    break\n    return float(pinned_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in the number of legal moves available to each player.\"\n    white_moves = len(list(board.legal_moves)) if board.turn == chess.WHITE else len(list(board.legal_moves)) \n    black_moves = len(list(board.legal_moves)) if board.turn == chess.BLACK else len(list(board.legal_moves))\n    return float(white_moves - black_moves)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of unprotected pieces for both players.\"\n    unprotected_count = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == board.turn and not board.is_attacked_by(not board.turn, square):\n            unprotected_count += 1\n    return float(unprotected_count)", "def feature(board: chess.Board) -> float:\n    \"Evaluates the distribution of pieces based on their attack capabilities.\"\n    attacking_positions = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == board.turn:\n            attack_squares = board.attacks(square)\n            if attack_squares:\n                attacking_positions += 1\n    return float(attacking_positions)", "def feature(board: chess.Board) -> float:\n    \"Measures the difference in the total number of pawns for both players.\"\n    white_pawns = sum(1 for piece in board.piece_map().values() if piece.piece_type == chess.PAWN and piece.color == chess.WHITE)\n    black_pawns = sum(1 for piece in board.piece_map().values() if piece.piece_type == chess.PAWN and piece.color == chess.BLACK)\n    return float(white_pawns - black_pawns)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of squares attacked by both players.\"\n    white_attacks = sum(1 for square in chess.SQUARES if board.is_attacked_by(chess.WHITE, square))\n    black_attacks = sum(1 for square in chess.SQUARES if board.is_attacked_by(chess.BLACK, square))\n    return float(white_attacks - black_attacks)", "def feature(board: chess.Board) -> float:\n    \"Scores the central control based on pieces occupying central squares (d4, d5, e4, e5).\"\n    central_squares = [chess.D4, chess.D5, chess.E4, chess.E5]\n    central_control = sum(1 for square in central_squares if board.piece_at(square) and board.piece_at(square).color == chess.WHITE)\n    central_control -= sum(1 for square in central_squares if board.piece_at(square) and board.piece_at(square).color == chess.BLACK)\n    return float(central_control)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces that are pinned by the opponent's pieces.\"\n    pinned_count = 0\n    for square in chess.SQUARES:\n        piece = board.piece_at(square)\n        if piece and piece.color == board.turn:\n            attackers = board.attackers(not piece.color, square)\n            for attacker in attackers:\n                if board.is_attacked_by(piece.color, attacker):\n                    pinned_count += 1\n                    break\n    return float(pinned_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of pieces on the back rank (first rank for each player).\"\n    white_back_rank = sum(1 for square in range(chess.A1, chess.H1 + 1) if board.piece_at(square) and board.piece_at(square).color == chess.WHITE)\n    black_back_rank = sum(1 for square in range(chess.A8, chess.H8 + 1) if board.piece_at(square) and board.piece_at(square).color == chess.BLACK)\n    return float(white_back_rank - black_back_rank)", "def feature(board: chess.Board) -> float:\n    \"Measures the mobility by counting the number of legal moves available to both players.\"\n    return float(len(list(board.legal_moves)))", "def feature(board: chess.Board) -> float:\n    \"Scores the number of pieces attacking the enemy king.\"\n    king_square = next((square for square in chess.SQUARES if board.piece_at(square) and board.piece_at(square).piece_type == chess.KING and board.piece_at(square).color == (chess.BLACK if board.turn else chess.WHITE)), None)\n    if king_square is None:\n        return 0.0\n    attackers_count = len(board.attackers(not board.turn, king_square))\n    return float(attackers_count)", "def feature(board: chess.Board) -> float:\n    \"Measures the distance of the pawns to promotion for each player.\"\n    white_pawn_distance = sum(7 - chess.square_rank(square) for square in chess.SQUARES if board.piece_at(square) and board.piece_at(square).piece_type == chess.PAWN and board.piece_at(square).color == chess.WHITE)\n    black_pawn_distance = sum(chess.square_rank(square) for square in chess.SQUARES if board.piece_at(square) and board.piece_at(square).piece_type == chess.PAWN and board.piece_at(square).color == chess.BLACK)\n    return float(white_pawn_distance - black_pawn_distance)", "def feature(board: chess.Board) -> float:\n    \"Measures the total number of pawns on the board\"\n    pawn_count = sum(1 for piece in board.piece_map().values() if piece.piece_type == chess.PAWN)\n    return float(pawn_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in the number of pieces controlled in the opponent's territory\"\n    control_count = 0\n    for square in board.piece_map():\n        piece = board.piece_at(square)\n        if piece and piece.color == board.turn and chess.square_rank(square) > 4:\n            control_count += 1\n    return float(control_count)", "def feature(board: chess.Board) -> float:\n    \"Scores the center control based on the pieces occupied in central squares\"\n    central_squares = [chess.D4, chess.D5, chess.E4, chess.E5]\n    central_control = sum(1 for square in central_squares if board.piece_at(square) is not None)\n    return float(central_control)", "def feature(board: chess.Board) -> float:\n    \"Scores the distance of kings from the center of the board\"\n    king_square = board.king(board.turn)\n    center_distance = chess.square_distance(king_square, chess.E4) + chess.square_distance(king_square, chess.E5)\n    return float(16 - center_distance)  # Max distance in center is 8 (2 ranks and 2 files)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of pieces that are currently pinned\"\n    pinned_count = sum(1 for square in board.piece_map() if board.is_attacked_by(not board.turn, square) and board.piece_at(square).piece_type != chess.KING)\n    return float(pinned_count)", "def feature(board: chess.Board) -> float:\n    \"Evaluates the number of squares controlled by each color and returns their difference\"\n    white_control = sum(1 for square in range(64) if board.is_attacked_by(chess.WHITE, square))\n    black_control = sum(1 for square in range(64) if board.is_attacked_by(chess.BLACK, square))\n    return float(white_control - black_control)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of backward pawns (pawns that cannot advance without being captured)\"\n    backward_pawns = 0\n    for pawn_square in board.pieces(chess.PAWN, board.turn):\n        file = chess.square_file(pawn_square)\n        if any(board.piece_at(chess.square(file, rank)) is None for rank in range(chess.square_rank(pawn_square) + 1, 8)):\n            backward_pawns += 1\n    return float(backward_pawns)", "def feature(board: chess.Board) -> float:\n    \"Measures the total number of pieces on the board.\"\n    return float(len(board.piece_map()))", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of open files for rooks and queens.\"\n    open_files = 0\n    for file in range(8):\n        if all(board.piece_at(chess.square(file, rank)) is None for rank in range(8)):\n            open_files += 1\n    return float(open_files)", "def feature(board: chess.Board) -> float:\n    \"Scores the central control by counting pieces in central squares.\"\n    central_squares = [chess.E4, chess.E5, chess.D4, chess.D5]\n    center_control = sum(1 for square in central_squares if board.piece_at(square) is not None)\n    return float(center_control)", "def feature(board: chess.Board) -> float:\n    \"Measures the mobility of the queens by counting their legal moves.\"\n    queen_moves = sum(1 for move in board.legal_moves if board.piece_at(move.from_square).piece_type == chess.QUEEN)\n    return float(queen_moves)", "def feature(board: chess.Board) -> float:\n    \"Calculates the distance of the kings from the center of the board.\"\n    white_king_square = next((square for square, piece in board.piece_map().items() if piece.color == chess.WHITE and piece.piece_type == chess.KING), None)\n    black_king_square = next((square for square, piece in board.piece_map().items() if piece.color == chess.BLACK and piece.piece_type == chess.KING), None)\n    if white_king_square is None or black_king_square is None:\n        return 0.0\n    white_distance = chess.square_distance(white_king_square, chess.E4) + chess.square_distance(white_king_square, chess.E5)\n    black_distance = chess.square_distance(black_king_square, chess.E4) + chess.square_distance(black_king_square, chess.E5)\n    return float(white_distance + black_distance)", "def feature(board: chess.Board) -> float:\n    \"Measures the proportion of defended pieces with respect to total pieces.\"\n    defended_count = sum(1 for square, piece in board.piece_map().items() if board.attackers(piece.color, square) and piece.color == board.turn)\n    total_piece_count = len(board.piece_map())\n    return defended_count / total_piece_count if total_piece_count > 0 else 0.0", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of pieces in the back rank for both players.\"\n    back_rank_count = sum(1 for square in range(8) for color in [chess.WHITE, chess.BLACK] if board.piece_at(chess.square(square, 0 if color == chess.WHITE else 7)) is not None and board.piece_at(chess.square(square, 0 if color == chess.WHITE else 7)).color == color)\n    return float(back_rank_count)", "def feature(board: chess.Board) -> float:\n    \"Measures the total number of pieces each side has on the board.\"\n    result = sum(1 for piece in board.piece_map().values())\n    return float(result)", "def feature(board: chess.Board) -> float:\n    \"Evaluates the presence of threats against the king by counting attacked squares.\"\n    white_king_square = next(sq for sq, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color == chess.WHITE)\n    black_king_square = next(sq for sq, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color == chess.BLACK)\n    result = len(board.attackers(chess.BLACK, white_king_square)) - len(board.attackers(chess.WHITE, black_king_square))\n    return float(result)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of pawns each side has on the board.\"\n    white_pawns = sum(1 for piece in board.piece_map().values() if piece.piece_type == chess.PAWN and piece.color == chess.WHITE)\n    black_pawns = sum(1 for piece in board.piece_map().values() if piece.piece_type == chess.PAWN and piece.color == chess.BLACK)\n    result = white_pawns - black_pawns\n    return float(result)", "def feature(board: chess.Board) -> float:\n    \"Calculates the distance of the kings from their respective back ranks.\"\n    white_king_square = next(sq for sq, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color == chess.WHITE)\n    black_king_square = next(sq for sq, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color == chess.BLACK)\n    white_distance = 7 - chess.square_rank(white_king_square)\n    black_distance = 7 - chess.square_rank(black_king_square)\n    result = white_distance - black_distance\n    return float(result)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of moves that are checks for the current player.\"\n    check_moves = sum(1 for move in board.legal_moves if board.gives_check(move))\n    return float(check_moves)", "def feature(board: chess.Board) -> float:\n    \"Calculates material imbalance by evaluating the difference in piece values.\"\n    piece_value = {chess.PAWN: 100, chess.KNIGHT: 300, chess.BISHOP: 300,\n                   chess.ROOK: 500, chess.QUEEN: 900, chess.KING: 0}\n    white_value = sum(piece_value[piece.piece_type] for piece in board.piece_map().values() if piece.color == chess.WHITE)\n    black_value = sum(piece_value[piece.piece_type] for piece in board.piece_map().values() if piece.color == chess.BLACK)\n    result = white_value - black_value\n    return float(result)", "def feature(board: chess.Board) -> float:\n    \"Measures the mobility of pieces by counting actionable legal moves for the current player.\"\n    legal_moves_count = len(list(board.legal_moves))\n    result = float(legal_moves_count)\n    return result", "def feature(board: chess.Board) -> float:\n    \"Counts the number of positions of the opponent's pieces in relation to the player's pieces.\"\n    opponent_positions = sum(1 for sq, piece in board.piece_map().items() if piece.color != board.turn)\n    return float(opponent_positions)", "def feature(board: chess.Board) -> float:\n    \"Measures the difference in the number of attacking pieces for both players.\"\n    white_attackers = sum(1 for sq in board.piece_map() if board.piece_at(sq).color == chess.WHITE and board.attackers(chess.WHITE, sq))\n    black_attackers = sum(1 for sq in board.piece_map() if board.piece_at(sq).color == chess.BLACK and board.attackers(chess.BLACK, sq))\n    result = float(white_attackers - black_attackers)\n    return result", "def feature(board: chess.Board) -> float:\n    \"Calculates the total value of pieces attacking the opponent's king.\"\n    king_square = next((sq for sq, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color == (chess.WHITE if board.turn else chess.BLACK)), None)\n    if king_square is None:\n        return 0.0\n    attacking_value = sum(board.piece_at(square).piece_type for square in board.attackers(chess.WHITE if board.turn else chess.BLACK, king_square))\n    result = float(attacking_value)\n    return result", "def feature(board: chess.Board) -> float:\n    \"Counts the number of doubled pawns for both players on the board.\"\n    doubled_pawns = {chess.WHITE: 0, chess.BLACK: 0}\n    for file in range(8):\n        white_pawns = sum(1 for rank in range(8) if board.piece_at(chess.square(file, rank)) == chess.PAWN)\n        black_pawns = sum(1 for rank in range(8) if board.piece_at(chess.square(file, rank)) == chess.PAWN)\n        if white_pawns > 1:\n            doubled_pawns[chess.WHITE] += 1\n        if black_pawns > 1:\n            doubled_pawns[chess.BLACK] += 1\n    result = float(doubled_pawns[chess.WHITE] - doubled_pawns[chess.BLACK])\n    return result", "def feature(board: chess.Board) -> float:\n    \"Measures the distance of the kings from the edge of the board.\"\n    white_king = next((sq for sq, piece in board.piece_map().items() if piece.color == chess.WHITE and piece.piece_type == chess.KING), None)\n    black_king = next((sq for sq, piece in board.piece_map().items() if piece.color == chess.BLACK and piece.piece_type == chess.KING), None)\n    if white_king is None or black_king is None:\n        return 0.0\n    distance = (8 - chess.square_rank(white_king)) + (8 - chess.square_rank(black_king))\n    result = float(distance)\n    return result", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of pieces pinned by an opponent's piece.\"\n    pinned_pieces = 0\n    for sq, piece in board.piece_map().items():\n        if piece.color == (chess.WHITE if board.turn else chess.BLACK):\n            for attacker in board.attackers(chess.WHITE if board.turn else chess.BLACK, sq):\n                if board.piece_at(attacker) and board.piece_at(attacker).color == (chess.WHITE if board.turn else chess.BLACK):\n                    pinned_pieces += 1\n    result = float(pinned_pieces)\n    return result", "def feature(board: chess.Board) -> float:\n    \"Counts the number of squares attacked by each player.\"\n    white_attacks = len(set(square for sq in board.piece_map() if board.piece_at(sq).color == chess.WHITE for square in board.attackers(chess.WHITE, sq)))\n    black_attacks = len(set(square for sq in board.piece_map() if board.piece_at(sq).color == chess.BLACK for square in board.attackers(chess.BLACK, sq)))\n    result = float(white_attacks - black_attacks)\n    return result", "def feature(board: chess.Board) -> float:\n    \"Measures the pawn structure's strength based on isolated pawns.\"\n    isolated_pawns = 0\n    for file in range(8):\n        if (board.piece_at(chess.square(file, 1)) == chess.PAWN and \n            (file == 0 or board.piece_at(chess.square(file - 1, 1)) != chess.PAWN) and \n            (file == 7 or board.piece_at(chess.square(file + 1, 1)) != chess.PAWN)):\n            isolated_pawns += 1\n        if (board.piece_at(chess.square(file, 6)) == chess.PAWN and \n            (file == 0 or board.piece_at(chess.square(file - 1, 6)) != chess.PAWN) and \n            (file == 7 or board.piece_at(chess.square(file + 1, 6)) != chess.PAWN)):\n            isolated_pawns += 1\n    result = float(isolated_pawns)\n    return result", "def feature(board: chess.Board) -> float:\n    \"Measures the number of pieces threatening the opponent's king.\"\n    threats = sum(1 for square in board.piece_map() if board.is_attacked_by(not board.turn, square))\n    return float(threats)", "def feature(board: chess.Board) -> float:\n    \"Calculates the average distance of all pieces to the opponent's king.\"\n    if board.is_checkmate() or board.is_stalemate():\n        return float('nan')\n    opponent_king_square = next(square for square, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color != board.turn)\n    distances = [chess.square_distance(square, opponent_king_square) for square in board.piece_map() if board.piece_map()[square].color == board.turn]\n    return sum(distances) / len(distances) if distances else 0.0", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces on the back rank for each player.\"\n    back_rank_white = sum(1 for square in range(56, 64) if board.piece_at(square) and board.piece_at(square).color == chess.WHITE)\n    back_rank_black = sum(1 for square in range(0, 8) if board.piece_at(square) and board.piece_at(square).color == chess.BLACK)\n    return float(back_rank_white - back_rank_black)", "def feature(board: chess.Board) -> float:\n    \"Measures the ratio of minor pieces (knights and bishops) to major pieces (rooks and queens) for each player.\"\n    minor_white = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE and piece.piece_type in [chess.KNIGHT, chess.BISHOP])\n    major_white = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE and piece.piece_type in [chess.ROOK, chess.QUEEN])\n    minor_black = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK and piece.piece_type in [chess.KNIGHT, chess.BISHOP])\n    major_black = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK and piece.piece_type in [chess.ROOK, chess.QUEEN])\n    \n    return float((minor_white / max(1, major_white)) - (minor_black / max(1, major_black)))", "def feature(board: chess.Board) -> float:\n    \"Calculates the value of pieces that are pinned to their own king.\"\n    pinned_pieces_value = 0\n    for square in board.piece_map():\n        piece = board.piece_map()[square]\n        if piece.color == board.turn and board.is_attacked_by(not board.turn, square):\n            if board.attackers(piece.color, square):\n                pinned_pieces_value += piece.piece_type\n    return float(pinned_pieces_value)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of doubled pawns for both players.\"\n    white_doubled_pawns = sum(1 for file in range(8) if sum(1 for rank in range(8) if board.piece_at(chess.square(file, rank)) == chess.PAWN and chess.WHITE) > 1)\n    black_doubled_pawns = sum(1 for file in range(8) if sum(1 for rank in range(8) if board.piece_at(chess.square(file, rank)) == chess.PAWN and chess.BLACK) > 1)\n    return float(white_doubled_pawns - black_doubled_pawns)", "def feature(board: chess.Board) -> float:\n    \"Measures the control of center squares (d4, d5, e4, e5) by both players.\"\n    center_squares = [chess.D4, chess.D5, chess.E4, chess.E5]\n    control_white = sum(1 for sq in center_squares if board.is_attacked_by(chess.WHITE, sq))\n    control_black = sum(1 for sq in center_squares if board.is_attacked_by(chess.BLACK, sq))\n    return float(control_white - control_black)", "def feature(board: chess.Board) -> float:\n    \"Calculates the total number of unprotected pieces for each player.\"\n    unprotected_white = sum(1 for square in board.piece_map() if board.piece_map()[square].color == chess.WHITE and not any(board.is_attacked_by(chess.BLACK, square) for attacker in board.attackers(chess.BLACK, square)))\n    unprotected_black = sum(1 for square in board.piece_map() if board.piece_map()[square].color == chess.BLACK and not any(board.is_attacked_by(chess.WHITE, square) for attacker in board.attackers(chess.WHITE, square)))\n    return float(unprotected_white - unprotected_black)", "def feature(board: chess.Board) -> float:\n    \"Measures the material value of pieces that are attacking opponent's pieces with no defenders.\"\n    attacking_value = 0\n    for square in board.piece_map():\n        piece = board.piece_map()[square]\n        if piece.color == board.turn:\n            for target in board.legal_moves:\n                if target.from_square == square:\n                    target_piece = board.piece_at(target.to_square)\n                    if target_piece and not any(board.is_attacked_by(not piece.color, target.to_square) for attacker in board.attackers(not piece.color, target.to_square)):\n                        attacking_value += target_piece.piece_type\n    return float(attacking_value)", "def feature(board: chess.Board) -> float:\n    \"Measures the total number of hanging pieces on the board, which are undefended.\"\n    hanging_pieces = 0\n    for square, piece in board.piece_map().items():\n        if not board.attackers(piece.color, square):  # No attackers on this piece\n            hanging_pieces += 1\n    return float(hanging_pieces)", "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in the number of pawns on the board for both players.\"\n    white_pawns = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE and piece.piece_type == chess.PAWN)\n    black_pawns = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK and piece.piece_type == chess.PAWN)\n    return float(white_pawns - black_pawns)", "def feature(board: chess.Board) -> float:\n    \"Counts the total number of pieces that can potentially move given the current board state.\"\n    movable_pieces = 0\n    for move in board.legal_moves:\n        movable_pieces += 1\n    return float(movable_pieces)", "def feature(board: chess.Board) -> float:\n    \"Scores the material imbalance based on the weight of the pieces for both sides.\"\n    piece_values = {chess.PAWN: 100, chess.KNIGHT: 300, chess.BISHOP: 300, chess.ROOK: 500, chess.QUEEN: 900, chess.KING: 0}\n    material_score = sum(piece_values[piece.piece_type] for piece in board.piece_map().values())\n    return float(material_score)", "def feature(board: chess.Board) -> float:\n    \"Measures total piece mobility by counting how many pieces can move from their current position.\"\n    mobility_score = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == board.turn:\n            mobility_score += len(list(board.legal_moves))\n    return float(mobility_score)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of squares that threaten the opponent's king.\"\n    opponent_king_square = next(square for square, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color != board.turn)\n    threats_count = sum(1 for square in board.attackers(board.turn, opponent_king_square))\n    return float(threats_count)", "def feature(board: chess.Board) -> float:\n    \"Measures how many pieces are defending the king.\"\n    king_square = next(square for square, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color == board.turn)\n    defenders_count = sum(1 for square in board.attackers(board.turn, king_square))\n    return float(defenders_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in potential threats to each king.\"\n    white_king_square = next(square for square, piece in board.piece_map().items() if piece.color == chess.WHITE and piece.piece_type == chess.KING)\n    black_king_square = next(square for square, piece in board.piece_map().items() if piece.color == chess.BLACK and piece.piece_type == chess.KING)\n    \n    white_threats = len(board.attackers(chess.BLACK, white_king_square))\n    black_threats = len(board.attackers(chess.WHITE, black_king_square))\n    \n    return float(white_threats - black_threats)", "def feature(board: chess.Board) -> float:\n    \"Measures the positional score based on the number of pawns on the 6th and 7th ranks.\"\n    pawn_position_score = 0\n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.PAWN:\n            if chess.square_rank(square) in [5, 6]:  # 6th or 7th rank\n                pawn_position_score += 1\n    return float(pawn_position_score)", "def feature(board: chess.Board) -> float:\n    'Measures the material imbalance by calculating the difference in total piece values for both players.'\n    piece_values = {chess.PAWN: 100, chess.KNIGHT: 300, chess.BISHOP: 300,\n                    chess.ROOK: 500, chess.QUEEN: 900, chess.KING: 0}\n    white_value = sum(piece_values[piece.piece_type] for piece in board.piece_map().values() if piece.color == chess.WHITE)\n    black_value = sum(piece_values[piece.piece_type] for piece in board.piece_map().values() if piece.color == chess.BLACK)\n    return float(white_value - black_value)", "def feature(board: chess.Board) -> float:\n    'Counts the number of pieces that are currently pinned (unable to move due to tactical threats).'\n    pinned_pieces = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == board.turn:\n            for attacker_square in board.attackers(board.turn, square):\n                if board.piece_at(attacker_square) and board.piece_at(attacker_square).color != piece.color:\n                    pinned_pieces += 1\n                    break\n    return float(pinned_pieces)", "def feature(board: chess.Board) -> float:\n    'Calculates the difference in mobility (number of legal moves) between both players.'\n    white_moves = len(list(board.legal_moves)) if board.turn else 0\n    black_moves = len(list(board.legal_moves)) if not board.turn else 0\n    return float(white_moves - black_moves)", "def feature(board: chess.Board) -> float:\n    'Scores the proximity of kings to each other based on the Manhattan distance between them.'\n    white_king_square = [sq for sq, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color == chess.WHITE]\n    black_king_square = [sq for sq, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color == chess.BLACK]\n    if white_king_square and black_king_square:\n        distance = chess.square_distance(white_king_square[0], black_king_square[0])\n        return float(distance)\n    return 0.0", "def feature(board: chess.Board) -> float:\n    'Counts the total number of attacking moves available to the current player.'\n    attackers_count = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == board.turn:\n            attackers_count += len(board.attackers(not board.turn, square))\n    return float(attackers_count)", "def feature(board: chess.Board) -> float:\n    'Calculates the average distance of pieces from their respective kings.'\n    total_distance = 0\n    piece_count = 0\n    king_square = [sq for sq in board.piece_map() if board.piece_map()[sq].piece_type == chess.KING and board.piece_map()[sq].color == board.turn]\n    \n    if not king_square:\n        return 0.0\n    \n    for square, piece in board.piece_map().items():\n        if piece.color == board.turn and piece.piece_type != chess.KING:\n            total_distance += chess.square_distance(square, king_square[0])\n            piece_count += 1\n            \n    return float(total_distance / piece_count) if piece_count > 0 else 0.0", "def feature(board: chess.Board) -> float:\n    'Measures the value of pieces that are attacked but not defended.'\n    attacked_unprotected_value = 0\n    for square in board.piece_map():\n        piece = board.piece_at(square)\n        if piece and piece.color == board.turn and board.is_attacked_by(not board.turn, square):\n            attacked_unprotected_value += {\n                chess.PAWN: 100, chess.KNIGHT: 300, chess.BISHOP: 300,\n                chess.ROOK: 500, chess.QUEEN: 900, chess.KING: 0\n            }[piece.piece_type]\n    return float(attacked_unprotected_value)", "def feature(board: chess.Board) -> float:\n    'Counts the number of potential discovered checks the current player can create.'\n    discovered_checks = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == board.turn:\n            for potential_check_square in board.attackers(not board.turn, square):\n                if board.piece_at(potential_check_square) and board.piece_at(potential_check_square).color != piece.color:\n                    discovered_checks += 1\n                    break\n    return float(discovered_checks)", "def feature(board: chess.Board) -> float:\n    'Measures the presence of passed pawns for the current player.'\n    passed_pawn_count = 0\n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.PAWN and piece.color == board.turn:\n            file = chess.square_file(square)\n            rank = chess.square_rank(square)\n            if all(board.piece_at(chess.square(file, r)) is None for r in range(rank + 1, 8 if piece.color == chess.WHITE else -1, 1 if piece.color == chess.WHITE else -1)):\n                passed_pawn_count += 1\n    return float(passed_pawn_count)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces in the seventh rank for both players.\"\n    white_seventh = sum(1 for sq, piece in board.piece_map().items() if piece.color == chess.WHITE and chess.square_rank(sq) == 6)\n    black_seventh = sum(1 for sq, piece in board.piece_map().items() if piece.color == chess.BLACK and chess.square_rank(sq) == 1)\n    return float(white_seventh - black_seventh)", "def feature(board: chess.Board) -> float:\n    \"Measures the total distance of pieces from their optimal squares based on piece type.\"\n    optimal_positions = {\n        chess.PAWN: [chess.A7, chess.B7, chess.C7, chess.D7, chess.E7, chess.F7, chess.G7, chess.H7],\n        chess.ROOK: [chess.A8, chess.H8],\n        chess.KNIGHT: [chess.B8, chess.G8],\n        chess.BISHOP: [chess.C8, chess.F8],\n        chess.QUEEN: [chess.D8],\n        chess.KING: [chess.E8]\n    }\n    total_distance = 0\n    for sq, piece in board.piece_map().items():\n        optimal = optimal_positions.get(piece.piece_type, [])\n        distances = [chess.square_distance(sq, opt) for opt in optimal]\n        total_distance += min(distances, default=0)\n    return float(total_distance)", "def feature(board: chess.Board) -> float:\n    \"Scores the adjacency of pieces, benefitting connected pawns and rooks.\"\n    score = 0\n    for square, piece in board.piece_map().items():\n        if piece.piece_type in (chess.PAWN, chess.ROOK):\n            adjacent_squares = [square + 1, square - 1, square + 8, square - 8]\n            for adj in adjacent_squares:\n                if adj in board.piece_map() and board.piece_map()[adj].color == piece.color:\n                    score += 1\n    return float(score)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of squares attacked by pieces of each color.\"\n    white_attack = sum(board.is_attacked_by(chess.WHITE, sq) for sq in board.piece_map().keys() if board.piece_map()[sq].color == chess.WHITE)\n    black_attack = sum(board.is_attacked_by(chess.BLACK, sq) for sq in board.piece_map().keys() if board.piece_map()[sq].color == chess.BLACK)\n    return float(white_attack - black_attack)", "def feature(board: chess.Board) -> float:\n    \"Counts active pieces that are not currently attacked.\"\n    safe_pieces = 0\n    for square, piece in board.piece_map().items():\n        if not board.is_attacked_by(board.turn, square):\n            safe_pieces += 1\n    return float(safe_pieces)", "def feature(board: chess.Board) -> float:\n    \"Calculates the central control, counting pieces in the central squares (d4, d5, e4, e5).\"\n    central_squares = [chess.D4, chess.D5, chess.E4, chess.E5]\n    control = sum(1 for sq in central_squares if sq in board.piece_map())\n    return float(control)", "def feature(board: chess.Board) -> float:\n    \"Scores the presence of pieces on the back rank of the opponent.\"\n    enemy_back_rank = {chess.BLACK: (0, 1), chess.WHITE: (7, 6)}[board.turn]\n    pieces_on_back_rank = sum(1 for sq, piece in board.piece_map().items() if chess.square_rank(sq) == enemy_back_rank[0] and piece.color != board.turn)\n    return float(pieces_on_back_rank)", "def feature(board: chess.Board) -> float:\n    \"Calculates material disparity by counting pieces above a certain threshold of value.\"\n    high_value_pieces = [piece.piece_type for piece in board.piece_map().values() if piece.color == board.turn and piece.piece_type in (chess.QUEEN, chess.ROOK)]\n    return float(len(high_value_pieces))", "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in pawn structure between both sides\"\n    white_pawns = len([p for p in board.piece_map().values() if p.color == chess.WHITE and p.piece_type == chess.PAWN])\n    black_pawns = len([p for p in board.piece_map().values() if p.color == chess.BLACK and p.piece_type == chess.PAWN])\n    return float(white_pawns - black_pawns)", "def feature(board: chess.Board) -> float:\n    \"Measures the total number of pieces that are pinned by opponent pieces\"\n    pinned_count = 0\n    for square in board.piece_map():\n        piece = board.piece_at(square)\n        if piece and piece.color == board.turn:\n            if board.is_attacked_by(not piece.color, square):\n                for move in board.legal_moves:\n                    if move.from_square == square and board.is_attacked_by(not piece.color, move.to_square):\n                        pinned_count += 1\n                        break\n    return float(pinned_count)", "def feature(board: chess.Board) -> float:\n    \"Evaluates the number of controlling pieces each player has over the center squares\"\n    center_squares = [chess.D4, chess.D5, chess.E4, chess.E5]\n    white_control = sum(1 for square in center_squares if board.is_attacked_by(chess.WHITE, square))\n    black_control = sum(1 for square in center_squares if board.is_attacked_by(chess.BLACK, square))\n    return float(white_control - black_control)", "def feature(board: chess.Board) -> float:\n    \"Calculates the king's distance in squares from the center of the board\"\n    king_square = board.king(board.turn)\n    center_sq = chess.D4  # Central square\n    return float(chess.square_distance(king_square, center_sq))", "def feature(board: chess.Board) -> float:\n    \"Counts the number of rooks on open files\"\n    file_rook_count = 0\n    for file in range(8):\n        if all(board.piece_at(chess.square(file, rank)) is None for rank in range(8)):\n            for rank in range(8):\n                piece = board.piece_at(chess.square(file, rank))\n                if piece and piece.piece_type == chess.ROOK:\n                    file_rook_count += 1\n                    break\n    return float(file_rook_count)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of pieces that are hanging (not defended)\"\n    hanging_count = 0\n    for square in board.piece_map():\n        piece = board.piece_at(square)\n        if piece and piece.color == board.turn:\n            if not board.attackers(not piece.color, square):\n                hanging_count += 1\n    return float(hanging_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the material imbalance by counting the absolute difference in total piece values\"\n    piece_values = {\n        chess.PAWN: 100,\n        chess.KNIGHT: 320,\n        chess.BISHOP: 330,\n        chess.ROOK: 500,\n        chess.QUEEN: 900,\n        chess.KING: 0\n    }\n    white_material = sum(piece_values[piece.piece_type] for piece in board.piece_map().values() if piece.color == chess.WHITE)\n    black_material = sum(piece_values[piece.piece_type] for piece in board.piece_map().values() if piece.color == chess.BLACK)\n    return float(abs(white_material - black_material))", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces on the back rank that are not pawns\"\n    back_rank_piece_count = 0\n    back_rank = 0 if board.turn == chess.WHITE else 7\n    for file in range(8):\n        piece = board.piece_at(chess.square(file, back_rank))\n        if piece and piece.piece_type != chess.PAWN:\n            back_rank_piece_count += 1\n    return float(back_rank_piece_count)", "def feature(board: chess.Board) -> float:\n    \"Evaluates the number of squares each player can move to from their pieces\"\n    white_moves = sum(1 for move in board.legal_moves if board.piece_at(move.from_square).color == chess.WHITE)\n    black_moves = sum(1 for move in board.legal_moves if board.piece_at(move.from_square).color == chess.BLACK)\n    return float(white_moves - black_moves)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of squares around the opponent's king that are controlled by pieces\"\n    opponent_king_square = board.king(not board.turn)\n    controlled_count = sum(1 for square in chess.SQUARES if board.is_attacked_by(board.turn, square) and chess.square_distance(square, opponent_king_square) <= 1)\n    return float(controlled_count)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of attacking pieces for both players.\"\n    white_attacks = sum(1 for square in board.piece_map() if board.piece_at(square).color == chess.WHITE and board.attackers(chess.BLACK, square))\n    black_attacks = sum(1 for square in board.piece_map() if board.piece_at(square).color == chess.BLACK and board.attackers(chess.WHITE, square))\n    total_attacks = white_attacks - black_attacks\n    return float(total_attacks)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of pieces that are currently pinned (cannot move without exposing the king).\"\n    pinned_pieces = 0\n    for piece_square, piece in board.piece_map().items():\n        if piece.color == board.turn:\n            for attacker in board.attackers(not piece.color, piece_square):\n                if board.is_attacked_by(piece.color, piece_square) and board.is_check():\n                    pinned_pieces += 1\n                    break\n    return float(pinned_pieces)", "def feature(board: chess.Board) -> float:\n    \"Measures the imbalance of piece types (counting the difference between pieces of the same type).\"\n    piece_count = {chess.PAWN: 0, chess.KNIGHT: 0, chess.BISHOP: 0, chess.ROOK: 0, chess.QUEEN: 0, chess.KING: 0}\n    for square, piece in board.piece_map().items():\n        piece_count[piece.piece_type] += 1 if piece.color == chess.WHITE else -1\n    imbalance = sum(abs(count) for count in piece_count.values())\n    return float(imbalance)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of squares that are currently attacked but not defended.\"\n    attacked_not_defended = 0\n    for square in chess.SQUARES:\n        if board.is_attacked_by(chess.WHITE, square) and not board.is_attacked_by(chess.BLACK, square):\n            attacked_not_defended += 1\n        elif board.is_attacked_by(chess.BLACK, square) and not board.is_attacked_by(chess.WHITE, square):\n            attacked_not_defended += 1\n    return float(attacked_not_defended)", "def feature(board: chess.Board) -> float:\n    \"Measures the total material value of the remaining pieces for each color.\"\n    value_map = {\n        chess.PAWN: 100,\n        chess.KNIGHT: 300,\n        chess.BISHOP: 300,\n        chess.ROOK: 500,\n        chess.QUEEN: 900,\n        chess.KING: 0  # King is invaluable but we'll ignore it in evaluation\n    }\n    material_score = 0\n    for square, piece in board.piece_map().items():\n        material_score += value_map[piece.piece_type] if piece.color == chess.WHITE else -value_map[piece.piece_type]\n    return float(material_score)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of pawns for both players that are on the 3rd rank or in front of their opponent's pawns.\"\n    white_pawns = sum(1 for square in board.piece_map() if board.piece_at(square).color == chess.WHITE and chess.square_rank(square) >= 3)\n    black_pawns = sum(1 for square in board.piece_map() if board.piece_at(square).color == chess.BLACK and chess.square_rank(square) <= 4)\n    pawn_position_score = white_pawns - black_pawns\n    return float(pawn_position_score)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces each player has advanced (specifically the number of ranks the pawns are from their starting position).\"\n    advanced_pawns = {chess.WHITE: 0, chess.BLACK: 0}\n    for square in board.piece_map():\n        piece = board.piece_at(square)\n        if piece.piece_type == chess.PAWN:\n            if piece.color == chess.WHITE:\n                advanced_pawns[chess.WHITE] += chess.square_rank(square)  # Count ranks as advancement\n            else:\n                advanced_pawns[chess.BLACK] += 7 - chess.square_rank(square)  # Count as 7-rank for Black\n    advancement_difference = advanced_pawns[chess.WHITE] - advanced_pawns[chess.BLACK]\n    return float(advancement_difference)", "def feature(board: chess.Board) -> float:\n    \"Calculates the distance of each player's king from the center of the board.\"\n    white_king_square = next(square for square, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color == chess.WHITE)\n    black_king_square = next(square for square, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color == chess.BLACK)\n    white_distance = chess.square_distance(white_king_square, chess.parse_square('e4'))  # Center square\n    black_distance = chess.square_distance(black_king_square, chess.parse_square('e5'))  # Center square\n    distance_imbalance = black_distance - white_distance\n    return float(distance_imbalance)", "def feature(board: chess.Board) -> float:\n    \"Measures the total value of pieces on the board for the current player.\"\n    value = 0\n    piece_values = {\n        chess.PAWN: 100,\n        chess.KNIGHT: 300,\n        chess.BISHOP: 300,\n        chess.ROOK: 500,\n        chess.QUEEN: 900,\n        chess.KING: 2000,\n    }\n    for piece in board.piece_map().values():\n        if piece.color == board.turn:\n            value += piece_values[piece.piece_type]\n    return float(value)", "def feature(board: chess.Board) -> float:\n    \"Measures the difference in the number of pawns for both players.\"\n    white_pawns = len([p for p in board.piece_map().values() if p.color == chess.WHITE and p.piece_type == chess.PAWN])\n    black_pawns = len([p for p in board.piece_map().values() if p.color == chess.BLACK and p.piece_type == chess.PAWN])\n    return float(white_pawns - black_pawns)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces that can potentially be developed in one move.\"\n    developable_pieces = sum(1 for move in board.legal_moves if board.piece_at(move.from_square) is not None)\n    return float(developable_pieces)", "def feature(board: chess.Board) -> float:\n    \"Measures the material balance only by counting the value of major pieces (rooks, queens).\"\n    value = 0\n    major_piece_values = {\n        chess.ROOK: 500,\n        chess.QUEEN: 900,\n    }\n    for piece in board.piece_map().values():\n        if piece.color == board.turn and piece.piece_type in major_piece_values:\n            value += major_piece_values[piece.piece_type]\n    return float(value)", "def feature(board: chess.Board) -> float:\n    \"Checks if the current player is in check and assigns a value based on that.\"\n    return float(1.0 if board.is_check() else 0.0)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of squares occupied by the player's pieces.\"\n    occupied_squares = sum(1 for piece in board.piece_map().values() if piece.color == board.turn)\n    return float(occupied_squares)", "def feature(board: chess.Board) -> float:\n    \"Measures the potential for back-rank checkmate based on piece placement.\"\n    back_rank_squares = [chess.A8, chess.B8, chess.C8, chess.D8, chess.E8, chess.F8, chess.G8, chess.H8] if board.turn == chess.WHITE else [chess.A1, chess.B1, chess.C1, chess.D1, chess.E1, chess.F1, chess.G1, chess.H1]\n    return float(len([sq for sq in back_rank_squares if board.piece_at(sq) is None]))", "def feature(board: chess.Board) -> float:\n    \"Measures the distance of all pieces to the opponent's king, averaged.\"\n    opponent_king_square = next((square for square, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color != board.turn), None)\n    if opponent_king_square is None:\n        return 0.0\n    total_distance = sum(chess.square_distance(square, opponent_king_square) for square in board.piece_map() if board.piece_map()[square].color == board.turn)\n    piece_count = len([1 for square in board.piece_map() if board.piece_map()[square].color == board.turn])\n    return float(total_distance / piece_count) if piece_count > 0 else 0.0", "def feature(board: chess.Board) -> float:\n    \"Calculates the value of pieces that are directly supported by other pieces.\"\n    defended_value = 0\n    piece_values = {\n        chess.PAWN: 100,\n        chess.KNIGHT: 300,\n        chess.BISHOP: 300,\n        chess.ROOK: 500,\n        chess.QUEEN: 900,\n        chess.KING: 2000,\n    }\n    for square, piece in board.piece_map().items():\n        if piece.color == board.turn:\n            defenders = board.attackers(piece.color, square)\n            if defenders:\n                defended_value += piece_values[piece.piece_type]\n    return float(defended_value)", "def feature(board: chess.Board) -> float:\n    \"Measures the activity of pieces by counting the number of pieces that can move.\"\n    active_piece_count = sum(1 for move in board.legal_moves)\n    return float(active_piece_count)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of pieces attacked by the opponent.\"\n    attacked_count = sum(1 for square in board.piece_map() if board.is_attacked_by(not board.turn, square))\n    return float(attacked_count)", "def feature(board: chess.Board) -> float:\n    \"Measures the central control by counting pieces on central squares.\"\n    central_squares = [chess.D4, chess.D5, chess.E4, chess.E5]\n    central_control = sum(1 for square in central_squares if board.piece_at(square) is not None)\n    return float(central_control)", "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in number of pieces on the seventh rank for both players.\"\n    white_seventh_rank = sum(1 for square in range(chess.A7, chess.H8) if board.piece_at(square) and board.piece_at(square).color == chess.WHITE)\n    black_seventh_rank = sum(1 for square in range(chess.A2, chess.H3) if board.piece_at(square) and board.piece_at(square).color == chess.BLACK)\n    return float(white_seventh_rank - black_seventh_rank)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces attacking the opponent's king.\"\n    king_square = next(square for square, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color != board.turn)\n    attackers_count = len(board.attackers(board.turn, king_square))\n    return float(attackers_count)", "def feature(board: chess.Board) -> float:\n    \"Measures the value of pieces on the back rank.\"\n    back_rank_pieces_value = sum(piece.piece_type for square, piece in board.piece_map().items() if chess.square_rank(square) == (0 if board.turn == chess.WHITE else 7))\n    return float(back_rank_pieces_value)", "def feature(board: chess.Board) -> float:\n    \"Calculates the average piece value for pieces of the current player.\"\n    piece_values = {chess.PAWN: 100, chess.KNIGHT: 320, chess.BISHOP: 330, chess.ROOK: 500, chess.QUEEN: 900, chess.KING: 20000}\n    total_value = sum(piece_values[piece.piece_type] for piece in board.piece_map().values() if piece.color == board.turn)\n    piece_count = sum(1 for piece in board.piece_map().values() if piece.color == board.turn)\n    return total_value / piece_count if piece_count > 0 else 0.0", "def feature(board: chess.Board) -> float:\n    \"Counts the number of isolated pawns for the current player.\"\n    isolated_pawn_count = sum(1 for square in board.piece_map() if board.piece_at(square).piece_type == chess.PAWN and is_isolated_pawn(board, square))\n    return float(isolated_pawn_count)\n\ndef is_isolated_pawn(board: chess.Board, square: int) -> bool:\n    \"Helper function to check if a pawn is isolated.\"\n    file = chess.square_file(square)\n    if (file > 0 and board.piece_at(chess.square_rank(square) * 8 + (file - 1)) and board.piece_at(chess.square_rank(square) * 8 + (file - 1)).piece_type == chess.PAWN) or \\\n       (file < 7 and board.piece_at(chess.square_rank(square) * 8 + (file + 1)) and board.piece_at(chess.square_rank(square) * 8 + (file + 1)).piece_type == chess.PAWN):\n        return False\n    return True", "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in the number of controlled squares between both players.\"\n    white_controlled = sum(1 for sq in chess.SQUARES if board.is_attacked_by(chess.WHITE, sq))\n    black_controlled = sum(1 for sq in chess.SQUARES if board.is_attacked_by(chess.BLACK, sq))\n    return float(white_controlled - black_controlled)", "def feature(board: chess.Board) -> float:\n    \"Measures the average distance of pieces from the center of the board.\"\n    center_squares = [chess.E4, chess.E5, chess.D4, chess.D5]\n    total_distance = 0.0\n    piece_count = 0\n    \n    for square in board.piece_map():\n        piece = board.piece_at(square)\n        if piece.color == board.turn:\n            distance = min(chess.square_distance(square, center) for center in center_squares)\n            total_distance += distance\n            piece_count += 1\n            \n    return float(total_distance / piece_count) if piece_count > 0 else 0.0", "def feature(board: chess.Board) -> float:\n    \"Calculates the mobility score based on legal moves available to both players.\"\n    white_moves = len(list(board.legal_moves)) if board.turn == chess.WHITE else 0\n    black_moves = len(list(board.legal_moves)) if board.turn == chess.BLACK else 0\n    return float(white_moves - black_moves)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces protected by other pieces for the current player.\"\n    protected_count = 0\n    for square in board.piece_map():\n        piece = board.piece_at(square)\n        if piece.color == board.turn:\n            for attacker in board.attackers(not piece.color, square):\n                if piece.color == board.piece_at(attacker).color:\n                    protected_count += 1\n                    break\n    return float(protected_count)", "def feature(board: chess.Board) -> float:\n    \"Measures the king safety by counting the number of pieces attacking the opponent's king.\"\n    opponent_king_square = None\n    \n    for square in board.piece_map():\n        if board.piece_at(square).piece_type == chess.KING and board.piece_at(square).color != board.turn:\n            opponent_king_square = square\n            break\n            \n    if opponent_king_square is None:\n        return 0.0\n    \n    attacking_count = len(board.attackers(board.turn, opponent_king_square))\n    return float(attacking_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in the number of pieces between both players.\"\n    white_piece_count = len([p for p in board.piece_map().values() if p.color == chess.WHITE])\n    black_piece_count = len([p for p in board.piece_map().values() if p.color == chess.BLACK])\n    return float(white_piece_count - black_piece_count)", "def feature(board: chess.Board) -> float:\n    \"Measures the piece value difference based on piece types for both players.\"\n    piece_value = {chess.PAWN: 100, chess.KNIGHT: 320, chess.BISHOP: 330, chess.ROOK: 500, chess.QUEEN: 900}\n    white_value = sum(piece_value.get(board.piece_at(square).piece_type, 0) for square in board.piece_map() if board.piece_at(square).color == chess.WHITE)\n    black_value = sum(piece_value.get(board.piece_at(square).piece_type, 0) for square in board.piece_map() if board.piece_at(square).color == chess.BLACK)\n    return float(white_value - black_value)", "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in the number of attacking moves from both players.\"\n    white_attacks = sum(1 for sq in chess.SQUARES if board.is_attacked_by(chess.WHITE, sq))\n    black_attacks = sum(1 for sq in chess.SQUARES if board.is_attacked_by(chess.BLACK, sq))\n    return float(white_attacks - black_attacks)", "def feature(board: chess.Board) -> float:\n    \"Evaluates the number of pieces on the seventh rank for both players.\"\n    white_seventh_rank = len([sq for sq in chess.SQUARES[56:64] if board.piece_at(sq) and board.piece_at(sq).color == chess.WHITE])\n    black_seventh_rank = len([sq for sq in chess.SQUARES[48:56] if board.piece_at(sq) and board.piece_at(sq).color == chess.BLACK])\n    return float(white_seventh_rank - black_seventh_rank)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of squares attacked by all pieces of the current player.\"\n    attack_squares = set()\n    for piece_square in board.piece_map().keys():\n        piece = board.piece_at(piece_square)\n        if piece is not None and piece.color == board.turn:\n            for move in board.legal_moves:\n                if move.from_square == piece_square:\n                    attack_squares.add(move.to_square)\n    return float(len(attack_squares))", "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in total piece value for both players.\"\n    piece_values = {chess.PAWN: 100, chess.KNIGHT: 320, chess.BISHOP: 330,\n                    chess.ROOK: 500, chess.QUEEN: 900, chess.KING: 20000}\n    white_value = sum(piece_values[piece.piece_type] for piece in board.piece_map().values() if piece.color == chess.WHITE)\n    black_value = sum(piece_values[piece.piece_type] for piece in board.piece_map().values() if piece.color == chess.BLACK)\n    return float(white_value - black_value)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces pinned by the opponent's pieces for the current player.\"\n    pinned_count = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == board.turn:\n            for attacking_square in board.attackers(not board.turn, square):\n                if board.is_attacked_by(board.turn, attacking_square):\n                    pinned_count += 1\n                    break\n    return float(pinned_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of isolated pawns for the current player.\"\n    isolated_count = 0\n    for square in board.piece_map().keys():\n        piece = board.piece_at(square)\n        if piece is not None and piece.color == board.turn and piece.piece_type == chess.PAWN:\n            file = chess.square_file(square)\n            if (board.piece_at(chess.square(file - 1, chess.square_rank(square))) is None and\n                    board.piece_at(chess.square(file + 1, chess.square_rank(square))) is None):\n                isolated_count += 1\n    return float(isolated_count)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of double pawns for the current player.\"\n    double_pawns = 0\n    pawns = [square for square, piece in board.piece_map().items() if piece.color == board.turn and piece.piece_type == chess.PAWN]\n    files = {}\n    for pawn in pawns:\n        file = chess.square_file(pawn)\n        if file in files:\n            files[file] += 1\n        else:\n            files[file] = 1\n    for count in files.values():\n        if count > 1:\n            double_pawns += count - 1\n    return float(double_pawns)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of pieces controlling the center squares for the current player.\"\n    center_squares = [chess.E4, chess.E5, chess.D4, chess.D5]\n    control_count = sum(1 for square in board.piece_map().keys() if board.piece_at(square).color == board.turn and square in center_squares)\n    return float(control_count)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of major pieces (rooks and queens) for the current player.\"\n    major_piece_count = sum(1 for piece in board.piece_map().values() if piece.color == board.turn and piece.piece_type in [chess.ROOK, chess.QUEEN])\n    return float(major_piece_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the enclosed spaces for the opponent pieces on the current player's side.\"\n    opponent_squares = [square for square, piece in board.piece_map().items() if piece.color != board.turn]\n    enclosed_count = sum(1 for square in opponent_squares if \n                         all(board.is_attacked_by(board.turn, neighbor) for neighbor in board.attackers(board.turn, square)))\n    return float(enclosed_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the total piece value difference between the two players.\"\n    piece_values = {chess.PAWN: 100, chess.KNIGHT: 320, chess.BISHOP: 330, chess.ROOK: 500, chess.QUEEN: 900, chess.KING: 20000}\n    white_value = sum(piece_values[piece.piece_type] for piece in board.piece_map().values() if piece.color == chess.WHITE)\n    black_value = sum(piece_values[piece.piece_type] for piece in board.piece_map().values() if piece.color == chess.BLACK)\n    return float(white_value - black_value)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of pieces attacking the opponent's king.\"\n    king_square = None\n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.KING and piece.color == chess.BLACK:\n            king_square = square\n            break\n    if king_square is None:\n        return 0.0\n    attackers = sum(1 for move in board.legal_moves if move.to_square == king_square and board.piece_at(move.from_square).color == chess.WHITE)\n    return float(attackers)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of doubled pawns for both players.\"\n    doubled_pawns = 0\n    for file in range(8):\n        white_pawns = [board.piece_at(chess.square(file, rank)) for rank in range(8) if board.piece_at(chess.square(file, rank)) and board.piece_at(chess.square(file, rank)).color == chess.WHITE and board.piece_at(chess.square(file, rank)).piece_type == chess.PAWN]\n        black_pawns = [board.piece_at(chess.square(file, rank)) for rank in range(8) if board.piece_at(chess.square(file, rank)) and board.piece_at(chess.square(file, rank)).color == chess.BLACK and board.piece_at(chess.square(file, rank)).piece_type == chess.PAWN]\n        if len(white_pawns) > 1:\n            doubled_pawns += len(white_pawns) - 1\n        if len(black_pawns) > 1:\n            doubled_pawns += len(black_pawns) - 1\n    return float(doubled_pawns)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of major pieces (rooks and queens) per player.\"\n    major_pieces_count = {chess.WHITE: 0, chess.BLACK: 0}\n    for piece in board.piece_map().values():\n        if piece.piece_type in [chess.ROOK, chess.QUEEN]:\n            major_pieces_count[piece.color] += 1\n    return float(major_pieces_count[chess.WHITE] - major_pieces_count[chess.BLACK])", "def feature(board: chess.Board) -> float:\n    \"Measures the mobility of pieces for the player to move.\"\n    mobility = len(list(board.legal_moves))\n    return float(mobility)", "def feature(board: chess.Board) -> float:\n    \"Counts pieces attacking the central squares (d4, d5, e4, e5).\"\n    central_squares = [chess.parse_square('d4'), chess.parse_square('d5'), chess.parse_square('e4'), chess.parse_square('e5')]\n    attackers = sum(1 for square in central_squares if board.is_attacked_by(board.turn, square))\n    return float(attackers)", "def feature(board: chess.Board) -> float:\n    \"Measures the total number of isolated pawns for both players.\"\n    isolated_pawns = 0\n    \n    for file in range(8):\n        white_pawn = any(board.piece_at(chess.square(file, rank)) for rank in range(8) if board.piece_at(chess.square(file, rank)) and board.piece_at(chess.square(file, rank)).color == chess.WHITE and board.piece_at(chess.square(file, rank)).piece_type == chess.PAWN)\n        black_pawn = any(board.piece_at(chess.square(file, rank)) for rank in range(8) if board.piece_at(chess.square(file, rank)) and board.piece_at(chess.square(file, rank)).color == chess.BLACK and board.piece_at(chess.square(file, rank)).piece_type == chess.PAWN)\n        \n        if white_pawn and (file == 0 or not any(board.piece_at(chess.square(file - 1, rank)) and board.piece_at(chess.square(file - 1, rank)).color == chess.WHITE for rank in range(8))):\n            isolated_pawns += 1\n        if black_pawn and (file == 7 or not any(board.piece_at(chess.square(file + 1, rank)) and board.piece_at(chess.square(file + 1, rank)).color == chess.BLACK for rank in range(8))):\n            isolated_pawns += 1\n            \n    return float(isolated_pawns)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces pinned to the king.\"\n    pinned_pieces = 0\n    king_square = next(square for square, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color == board.turn)\n\n    for square, piece in board.piece_map().items():\n        if piece.color == board.turn:\n            for attacker in board.attackers(not board.turn, square):\n                if board.piece_at(attacker).piece_type in [chess.ROOK, chess.QUEEN]:\n                    if board.is_attacked_by(not board.turn, king_square):\n                        pinned_pieces += 1\n    return float(pinned_pieces)", "def feature(board: chess.Board) -> float:\n    \"Evaluates the distribution of pawns on the board, with a focus on pawn structure.\"\n    pawn_structure_score = 0\n    for file in range(8):\n        file_pawns_count = sum(1 for rank in range(8) if board.piece_at(chess.square(file, rank)) and board.piece_at(chess.square(file, rank)).piece_type == chess.PAWN)\n        if file_pawns_count > 0:\n            pawn_structure_score += 1 / (file_pawns_count + 1)  # Less pawns in a file gives a higher score, promoting better structure.\n    return float(pawn_structure_score)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of pieces that are currently pinned to their king.\"\n    pinned_count = 0\n    for square, piece in board.piece_map().items():\n        if board.is_attacked_by(not piece.color, square):\n            if (piece.color == chess.WHITE and board.is_attacked_by(chess.BLACK, board.king(chess.WHITE))) or \\\n               (piece.color == chess.BLACK and board.is_attacked_by(chess.WHITE, board.king(chess.BLACK))):\n                pinned_count += 1\n    return float(pinned_count)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces on the back rank for each player.\"\n    back_rank_white = sum(1 for sq in range(chess.A1, chess.H1 + 1) if board.piece_at(sq) and board.piece_at(sq).color == chess.WHITE)\n    back_rank_black = sum(1 for sq in range(chess.A8, chess.H8 + 1) if board.piece_at(sq) and board.piece_at(sq).color == chess.BLACK)\n    return float(back_rank_white - back_rank_black)", "def feature(board: chess.Board) -> float:\n    \"Calculates the total mobility of pieces, defined as the sum of legal moves available to all pieces.\"\n    total_mobility = sum(len(list(board.legal_moves)) for square, piece in board.piece_map().items())\n    return float(total_mobility)", "def feature(board: chess.Board) -> float:\n    \"Measures the distance of pieces from the center of the board (files d and e, ranks 4 and 5).\"\n    center_squares = [chess.D4, chess.D5, chess.E4, chess.E5]\n    central_distance = sum(chess.square_distance(square, center_sq) for square in board.piece_map() for center_sq in center_squares)\n    return float(central_distance)", "def feature(board: chess.Board) -> float:\n    \"Counts how many pieces are on the 7th rank for each player.\"\n    seventh_rank_white = sum(1 for sq in range(chess.A7, chess.H7 + 1) if board.piece_at(sq) and board.piece_at(sq).color == chess.WHITE)\n    seventh_rank_black = sum(1 for sq in range(chess.A2, chess.H2 + 1) if board.piece_at(sq) and board.piece_at(sq).color == chess.BLACK)\n    return float(seventh_rank_white - seventh_rank_black)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of squares attacked by each player's pieces.\"\n    attacked_white = sum(1 for sq in chess.SQUARES if board.is_attacked_by(chess.WHITE, sq))\n    attacked_black = sum(1 for sq in chess.SQUARES if board.is_attacked_by(chess.BLACK, sq))\n    return float(attacked_white - attacked_black)", "def feature(board: chess.Board) -> float:\n    \"Measures the presence and strength of pawns on the opponent's side of the board.\"\n    opponent_pawns = [square for square in board.piece_map() if board.piece_map()[square].piece_type == chess.PAWN and board.piece_map()[square].color != board.turn]\n    opponent_pawn_strength = sum(1 for square in opponent_pawns if chess.square_rank(square) >= 4)\n    return float(opponent_pawn_strength)", "def feature(board: chess.Board) -> float:\n    \"Calculates the safety level by counting undefended pieces.\"\n    undefended_count = sum(1 for square in board.piece_map() if board.piece_at(square) and len(board.attackers(not board.piece_at(square).color, square)) == 0)\n    return float(undefended_count)", "def feature(board: chess.Board) -> float:\n    \"Measures the imbalance in minor pieces (knights and bishops).\"\n    white_minors = sum(1 for square in board.piece_map() if board.piece_map()[square].color == chess.WHITE and board.piece_map()[square].piece_type in [chess.BISHOP, chess.KNIGHT])\n    black_minors = sum(1 for square in board.piece_map() if board.piece_map()[square].color == chess.BLACK and board.piece_map()[square].piece_type in [chess.BISHOP, chess.KNIGHT])\n    return float(white_minors - black_minors)", "def feature(board: chess.Board) -> float:\n    \"Measures the difference in the number of pawns for both players.\"\n    white_pawns = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE and piece.piece_type == chess.PAWN)\n    black_pawns = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK and piece.piece_type == chess.PAWN)\n    result = white_pawns - black_pawns\n    return float(result)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of pieces on the back rank for each player.\"\n    white_back_rank = sum(1 for square, piece in board.piece_map().items() if piece.color == chess.WHITE and chess.square_rank(square) == 7)\n    black_back_rank = sum(1 for square, piece in board.piece_map().items() if piece.color == chess.BLACK and chess.square_rank(square) == 0)\n    result = white_back_rank - black_back_rank\n    return float(result)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of squares attacking the opponent's king for the current player.\"\n    king_square = next((square for square, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color != board.turn), None)\n    if king_square is None:\n        return 0.0\n    result = sum(1 for move in board.legal_moves if move.to_square == king_square and move.from_square != king_square)\n    return float(result)", "def feature(board: chess.Board) -> float:\n    \"Measures the total mobility of both players' pieces.\"\n    white_mobility = len(list(board.legal_moves)) if board.turn == chess.WHITE else 0\n    black_mobility = len(list(board.legal_moves)) if board.turn == chess.BLACK else 0\n    result = white_mobility - black_mobility\n    return float(result)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of tiles occupied by each player's pieces.\"\n    white_tiles = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE)\n    black_tiles = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK)\n    result = white_tiles - black_tiles\n    return float(result)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of isolated pawns for both players.\"\n    isolated_pawns = 0\n    for square in board.piece_map():\n        piece = board.piece_at(square)\n        if piece is not None and piece.piece_type == chess.PAWN:\n            file = chess.square_file(square)\n            if board.piece_at(chess.parse_square(chess.square_name(square)[0] + '7')) is None and board.piece_at(chess.parse_square(chess.square_name(square)[0] + '5')) is None:\n                isolated_pawns += 1 if piece.color == chess.WHITE else -1\n    return float(isolated_pawns)", "def feature(board: chess.Board) -> float:\n    \"Measures the distance of pieces from their respective home ranks.\"\n    total_distance = sum((chess.square_rank(square) if piece.color == chess.WHITE else 7 - chess.square_rank(square)) for square, piece in board.piece_map().items())\n    return float(total_distance)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of potential pawn promotions for both players.\"\n    promotions = sum(1 for square in board.piece_map() if board.piece_at(square).piece_type == chess.PAWN and\n                     (chess.square_rank(square) == 6 if board.piece_at(square).color == chess.WHITE else chess.square_rank(square) == 1))\n    return float(promotions)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of outposts (squares where knights can be safely placed).\"\n    outposts = 0\n    knight_positions = [square for square in board.piece_map() if board.piece_at(square).piece_type == chess.KNIGHT]\n    for square in knight_positions:\n        if board.is_attacked_by(not board.piece_at(square).color, square):\n            continue\n        rank = chess.square_rank(square)\n        if (rank == 4 and board.piece_at(square).color == chess.WHITE) or (rank == 3 and board.piece_at(square).color == chess.BLACK):\n            outposts += 1\n    return float(outposts) ", "def feature(board: chess.Board) -> float:\n    \"Measures the piece activity by counting the number of pieces that have legal moves.\"\n    active_pieces = sum(1 for square in board.piece_map() if len(list(board.legal_moves)) > 0)\n    return float(active_pieces)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of pieces attacking the opponent's king.\"\n    king_square = next((square for square, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color != board.turn), None)\n    attack_count = len(board.attackers(board.turn, king_square)) if king_square else 0\n    return float(attack_count)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces on the second rank for each player.\"\n    white_second_rank = sum(1 for square, piece in board.piece_map().items() if piece.color == chess.WHITE and chess.square_rank(square) == 1)\n    black_second_rank = sum(1 for square, piece in board.piece_map().items() if piece.color == chess.BLACK and chess.square_rank(square) == 6)\n    return float(white_second_rank - black_second_rank)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of squares occupied by each player's pieces.\"\n    white_occupied = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE)\n    black_occupied = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK)\n    return float(white_occupied - black_occupied)", "def feature(board: chess.Board) -> float:\n    \"Measures the mobility by counting the total number of legal moves available to both players.\"\n    total_moves = len(list(board.legal_moves))\n    return float(total_moves)", "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in the number of pawns each player has on the 7th rank.\"\n    white_pawns_on_seventh = sum(1 for square in range(8) if board.piece_at(chess.square(square, 6)) == chess.PAWN)\n    black_pawns_on_seventh = sum(1 for square in range(8) if board.piece_at(chess.square(square, 1)) == chess.PAWN)\n    return float(white_pawns_on_seventh - black_pawns_on_seventh)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of squares that each player's pieces can move to.\"\n    white_controlled_squares = len(set(move.to_square for move in board.legal_moves if board.turn == chess.WHITE))\n    black_controlled_squares = len(set(move.to_square for move in board.legal_moves if board.turn == chess.BLACK))\n    return float(white_controlled_squares - black_controlled_squares)", "def feature(board: chess.Board) -> float:\n    \"Measures the distance of the nearest opposing piece to the player's king.\"\n    player_king_square = next(square for square, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color == board.turn)\n    nearest_distance = float('inf')\n    \n    for square, piece in board.piece_map().items():\n        if piece.color != board.turn:\n            distance = chess.square_distance(player_king_square, square)\n            if distance < nearest_distance:\n                nearest_distance = distance\n    \n    return nearest_distance if nearest_distance != float('inf') else 0.0", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pinned pieces for both players.\"\n    pinned_white = sum(1 for square, piece in board.piece_map().items() if piece.color == chess.WHITE and is_pinned(board, square))\n    pinned_black = sum(1 for square, piece in board.piece_map().items() if piece.color == chess.BLACK and is_pinned(board, square))\n    return float(pinned_white - pinned_black)\n\ndef is_pinned(board: chess.Board, square: int) -> bool:\n    \"Determines if a piece is pinned against the king.\"\n    piece = board.piece_at(square)\n    if piece is None or piece.piece_type == chess.KING:\n        return False\n    \n    king_square = next((sq for sq, p in board.piece_map().items() if p.piece_type == chess.KING and p.color == piece.color), None)\n    return board.is_attacked_by(not piece.color, square) and not board.is_attacked_by(piece.color, king_square)", "def feature(board: chess.Board) -> float:\n    'Measures the mobility of pieces by counting the total number of legal moves for all pieces.'\n    return float(sum(len(list(board.legal_moves)) for piece in board.piece_map().values()))", "def feature(board: chess.Board) -> float:\n    'Counts the number of pieces attacked by the opponent.'\n    opponent_color = chess.WHITE if board.turn is chess.BLACK else chess.BLACK\n    attacked_count = sum(1 for square in board.piece_map() if board.is_attacked_by(opponent_color, square))\n    return float(attacked_count)", "def feature(board: chess.Board) -> float:\n    'Calculates the difference in material value between the two sides.'\n    piece_values = {chess.PAWN: 100, chess.KNIGHT: 300, chess.BISHOP: 300, \n                    chess.ROOK: 500, chess.QUEEN: 900, chess.KING: 0}\n    material_balance = sum(piece_values[piece.piece_type] * (1 if piece.color == chess.WHITE else -1)\n                           for piece in board.piece_map().values())\n    return float(material_balance)", "def feature(board: chess.Board) -> float:\n    'Measures the defensive structure by counting the number of connected pieces for the current player.'\n    def count_connected_pieces(color):\n        connected_count = 0\n        for piece in board.piece_map().values():\n            if piece.color == color:\n                for move in board.legal_moves:\n                    if board.piece_at(move.to_square) and board.piece_at(move.to_square).color == color:\n                        connected_count += 1\n        return connected_count\n    \n    return float(count_connected_pieces(chess.WHITE if board.turn else chess.BLACK))", "def feature(board: chess.Board) -> float:\n    'Measures the number of pieces in the centre control (d4, d5, e4, e5).'\n    center_squares = [chess.D4, chess.D5, chess.E4, chess.E5]\n    center_control = sum(1 for square in center_squares if board.piece_at(square) and board.piece_at(square).color == (chess.WHITE if board.turn else chess.BLACK))\n    return float(center_control)", "def feature(board: chess.Board) -> float:\n    'Evaluates the positional strength by counting the number of pieces on their ideal squares.'\n    ideal_positions = {chess.WHITE: [chess.D4, chess.E4, chess.D5, chess.E5], chess.BLACK: [chess.D3, chess.E3, chess.D2, chess.E2]}\n    piece_positions = sum(1 for square in board.piece_map() if square in ideal_positions[board.piece_map()[square].color])\n    return float(piece_positions)", "def feature(board: chess.Board) -> float:\n    'Counts the number of pawns on the 7th rank for both players.'\n    seventh_rank_count = sum(1 for square in range(chess.A7, chess.H7+1) if board.piece_at(square) and board.piece_at(square).piece_type == chess.PAWN)\n    return float(seventh_rank_count)", "def feature(board: chess.Board) -> float:\n    'Measures the distance of the farthest piece from the opponent\u2019s king.'\n    opponent_king_square = board.king(chess.WHITE if board.turn is chess.BLACK else chess.BLACK)\n    farthest_distance = 0\n    for square in board.piece_map():\n        piece_distance = chess.square_distance(square, opponent_king_square)\n        if piece_distance > farthest_distance:\n            farthest_distance = piece_distance\n    return float(farthest_distance)", "def feature(board: chess.Board) -> float:\n    'Measures the potential for future threats by counting the number of pieces that can attack the opponent in one move.'\n    attacking_potential = sum(1 for move in board.legal_moves if board.is_attacked_by(chess.WHITE if board.turn else chess.BLACK, move.to_square))\n    return float(attacking_potential)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of squares where a player's pieces are attacking.\"\n    square_control = sum(1 for square in range(64) if board.is_attacked_by(chess.WHITE, square))\n    result = float(square_control)\n    return result", "def feature(board: chess.Board) -> float:\n    \"Counts the number of defending pieces that shield a king from attacks.\"\n    king_square = next(square for square, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color == board.turn)\n    defending_pieces = sum(1 for square in board.attackers(not board.turn, king_square) if board.piece_at(square) and board.piece_at(square).color == board.turn)\n    result = float(defending_pieces)\n    return result", "def feature(board: chess.Board) -> float:\n    \"Measures how many pieces can move to a square that is currently unoccupied.\"\n    open_squares = sum(1 for square in range(64) if board.piece_at(square) is None and any(move.to_square == square for move in board.legal_moves))\n    result = float(open_squares)\n    return result", "def feature(board: chess.Board) -> float:\n    \"Calculates the average distance from the king to all of its pieces, indicating potential safety.\"\n    king_square = next(square for square in board.piece_map() if board.piece_at(square).piece_type == chess.KING and board.piece_at(square).color == board.turn)\n    distances = [chess.square_distance(king_square, piece_square) for piece_square in board.piece_map() if board.piece_at(piece_square).color == board.turn]\n    result = sum(distances) / len(distances) if distances else 0.0\n    return float(result)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces in prominent positions (center squares) for the current player's pieces.\"\n    center_squares = [chess.E4, chess.E5, chess.D4, chess.D5]\n    prominent_piece_count = sum(1 for square in board.piece_map() if square in center_squares and board.piece_at(square).color == board.turn)\n    result = float(prominent_piece_count)\n    return result", "def feature(board: chess.Board) -> float:\n    \"Measures the king's mobility, counting the number of legal squares it can move to.\"\n    king_square = next(square for square in board.piece_map() if board.piece_at(square).piece_type == chess.KING and board.piece_at(square).color == board.turn)\n    mobility = sum(1 for move in board.legal_moves if move.from_square == king_square)\n    result = float(mobility)\n    return result", "def feature(board: chess.Board) -> float:\n    \"Calculates the total number of pawns on the board, indicating potential for advancement.\"\n    pawn_count = sum(1 for piece in board.piece_map().values() if piece.piece_type == chess.PAWN)\n    result = float(pawn_count)\n    return result", "def feature(board: chess.Board) -> float:\n    \"Measures diversity of piece types (not counting pawns) on the current player's side.\"\n    piece_types = set(piece.piece_type for piece in board.piece_map().values() if piece.color == board.turn and piece.piece_type != chess.PAWN)\n    result = float(len(piece_types))\n    return result", "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in king position between the two sides to assess king safety.\"\n    white_king_square = next(square for square in board.piece_map() if board.piece_at(square).color == chess.WHITE and board.piece_at(square).piece_type == chess.KING)\n    black_king_square = next(square for square in board.piece_map() if board.piece_at(square).color == chess.BLACK and board.piece_at(square).piece_type == chess.KING)\n    result = chess.square_distance(white_king_square, black_king_square)\n    return float(result)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pinned pieces for each player.\"\n    pinned_white = len([square for square in board.piece_map() if board.is_attacked_by(chess.BLACK, square) and \n                        any(board.is_attacked_by(chess.BLACK, square2) for square2 in board.attackers(chess.WHITE, square))])\n    pinned_black = len([square for square in board.piece_map() if board.is_attacked_by(chess.WHITE, square) and \n                        any(board.is_attacked_by(chess.WHITE, square2) for square2 in board.attackers(chess.BLACK, square))])\n    result = float(pinned_white - pinned_black)\n    return result", "def feature(board: chess.Board) -> float:\n    \"Calculates the mobility of the pieces based on the number of legal moves.\"\n    white_mobility = len(list(board.legal_moves)) if board.turn else 0\n    black_mobility = len(list(board.legal_moves)) if not board.turn else 0\n    result = float(white_mobility - black_mobility)\n    return result", "def feature(board: chess.Board) -> float:\n    \"Measures the square control advantage by comparing controlled squares by both players.\"\n    controlled_white = sum(1 for square in chess.SQUARES if board.is_attacked_by(chess.WHITE, square))\n    controlled_black = sum(1 for square in chess.SQUARES if board.is_attacked_by(chess.BLACK, square))\n    result = float(controlled_white - controlled_black)\n    return result", "def feature(board: chess.Board) -> float:\n    \"Counts the number of double attacks available to both players.\"\n    double_attacks_white = sum(1 for square in board.piece_map() if board.is_attacked_by(chess.BLACK, square) and \n                                len(board.attackers(chess.BLACK, square)) > 1)\n    double_attacks_black = sum(1 for square in board.piece_map() if board.is_attacked_by(chess.WHITE, square) and \n                                len(board.attackers(chess.WHITE, square)) > 1)\n    result = float(double_attacks_white - double_attacks_black)\n    return result", "def feature(board: chess.Board) -> float:\n    \"Measures the presence of passed pawns for both players.\"\n    passed_pawns_white = sum(1 for square in board.pieces(chess.PAWN, chess.WHITE) if \n                              all(board.piece_at(square + i) is None for i in range(0, 8) if (square + i) < 64))\n    passed_pawns_black = sum(1 for square in board.pieces(chess.PAWN, chess.BLACK) if \n                              all(board.piece_at(square - i) is None for i in range(8, 0, -1) if (square - i) >= 0))\n    result = float(passed_pawns_white - passed_pawns_black)\n    return result", "def feature(board: chess.Board) -> float:\n    \"Evaluates king safety by counting the number of squares around the king that are attacked.\"\n    king_square = board.king(chess.WHITE) if board.turn else board.king(chess.BLACK)\n    attack_count = sum(1 for square in chess.SQUARES if board.is_attacked_by(chess.BLACK if board.turn else chess.WHITE, square))\n    result = float(attack_count)\n    return result", "def feature(board: chess.Board) -> float:\n    \"Measures the material imbalance due to isolated pawns.\"\n    isolated_pawns_white = sum(1 for square in board.pieces(chess.PAWN, chess.WHITE) if \n                                (chess.square_file(square) > 0 and board.piece_at(square - 1) is None) and \n                                (chess.square_file(square) < 7 and board.piece_at(square + 1) is None))\n    isolated_pawns_black = sum(1 for square in board.pieces(chess.PAWN, chess.BLACK) if \n                                (chess.square_file(square) > 0 and board.piece_at(square - 1) is None) and \n                                (chess.square_file(square) < 7 and board.piece_at(square + 1) is None))\n    result = float(isolated_pawns_white - isolated_pawns_black)\n    return result", "def feature(board: chess.Board) -> float:\n    \"Counts the number of major pieces (rook and queen) for each player.\"\n    major_pieces_white = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE and \n                              piece.piece_type in (chess.ROOK, chess.QUEEN))\n    major_pieces_black = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK and \n                              piece.piece_type in (chess.ROOK, chess.QUEEN))\n    result = float(major_pieces_white - major_pieces_black)\n    return result", "def feature(board: chess.Board) -> float:\n    \"Measures the difference in the number of pawns for each side.\"\n    white_pawns = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE and piece.piece_type == chess.PAWN)\n    black_pawns = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK and piece.piece_type == chess.PAWN)\n    return float(white_pawns - black_pawns)", "def feature(board: chess.Board) -> float:\n    \"Counts the total number of pieces for both players.\"\n    return float(len(board.piece_map()))", "def feature(board: chess.Board) -> float:\n    \"Measures the number of pieces on the back rank for the current player.\"\n    back_rank = 0\n    if board.turn == chess.WHITE:\n        back_rank = sum(1 for square in range(56, 64) if board.piece_at(square) is not None)\n    else:\n        back_rank = sum(1 for square in range(0, 8) if board.piece_at(square) is not None)\n    return float(back_rank)", "def feature(board: chess.Board) -> float:\n    \"Calculates the sum of the values of all pieces on the board.\"\n    piece_values = {\n        chess.PAWN: 100,\n        chess.KNIGHT: 300,\n        chess.BISHOP: 300,\n        chess.ROOK: 500,\n        chess.QUEEN: 900,\n        chess.KING: 0  # King has no value but it is essential to the game\n    }\n    total_value = sum(piece_values[piece.piece_type] for piece in board.piece_map().values())\n    return float(total_value)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of squares occupied by the opponent\u2019s pieces.\"\n    opponent_occupied = sum(1 for piece in board.piece_map().values() if piece.color != board.turn)\n    return float(opponent_occupied)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of checks given by the current player.\"\n    return float(len([move for move in board.legal_moves if board.is_check()]))", "def feature(board: chess.Board) -> float:\n    \"Measures how many pieces are attacking the opponent's king.\"\n    opponent_king_square = next(square for square, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color != board.turn)\n    attackers = board.attackers(board.turn, opponent_king_square)\n    return float(len(attackers))", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of pieces that are pinned by the opponent's pieces.\"\n    pinned = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == board.turn:\n            if any(board.is_attacked_by(piece.color, target_square) for target_square in board.attackers(piece.color, square)):\n                pinned += 1\n    return float(pinned)", "def feature(board: chess.Board) -> float:\n    \"Measures the maximum piece activity of both players based on legal moves.\"\n    max_activity = max(len(list(board.legal_moves)), 1)  # Prevent division by zero\n    return float(max_activity)", "def feature(board: chess.Board) -> float:\n    \"Measures the material threat by counting the number of attacking pieces.\"\n    threats = sum(1 for square in board.piece_map() if board.is_attacked_by(not board.turn, square))\n    return float(threats)", "def feature(board: chess.Board) -> float:\n    \"Measures the total number of pawns remaining on the board, offering insight into potential endgame scenarios.\"\n    pawns_count = sum(1 for piece in board.piece_map().values() if piece.piece_type == chess.PAWN)\n    return float(pawns_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the difference between the number of pieces attacking key squares (e.g., center squares) for both players.\"\n    center_squares = [chess.E4, chess.E5, chess.D4, chess.D5]\n    white_attackers = sum(1 for sq in center_squares if board.is_attacked_by(chess.WHITE, sq))\n    black_attackers = sum(1 for sq in center_squares if board.is_attacked_by(chess.BLACK, sq))\n    return float(white_attackers - black_attackers)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces on the back rank for both sides, giving insights into their development and safety.\"\n    white_back_rank = sum(1 for sq in range(chess.A1, chess.H1 + 1) if board.piece_at(sq) and board.piece_at(sq).color == chess.WHITE)\n    black_back_rank = sum(1 for sq in range(chess.A8, chess.H8 + 1) if board.piece_at(sq) and board.piece_at(sq).color == chess.BLACK)\n    return float(white_back_rank - black_back_rank)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of pinned pieces on the board, indicating the vulnerability of position.\"\n    pinned_count = 0\n    for sq in board.piece_map():\n        piece = board.piece_at(sq)\n        if piece and board.is_attacked_by(not piece.color, sq):\n            continue\n        for attacker in board.attackers(not piece.color, sq):\n            if board.piece_at(attacker) and board.piece_at(attacker).piece_type == chess.KING:\n                pinned_count += 1\n                break\n    return float(pinned_count)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of isolated pawns on the board, providing insight into pawn structure.\"\n    isolated_pawns_count = 0\n    for sq in range(chess.A2, chess.H7 + 1):\n        if board.piece_at(sq) and board.piece_at(sq).piece_type == chess.PAWN:\n            file = chess.square_file(sq)\n            if not (board.piece_at(chess.square(file - 1, chess.square_rank(sq))) or board.piece_at(chess.square(file + 1, chess.square_rank(sq)))):\n                isolated_pawns_count += 1\n    return float(isolated_pawns_count)", "def feature(board: chess.Board) -> float:\n    \"Measures the distance from the nearest enemy piece to the player's king, indicating safety level.\"\n    king_square = board.king(board.turn)\n    nearest_enemy_distance = float('inf')\n    for square in board.piece_map():\n        if board.piece_at(square).color != board.turn:\n            distance = chess.square_distance(king_square, square)\n            nearest_enemy_distance = min(nearest_enemy_distance, distance)\n    return nearest_enemy_distance if nearest_enemy_distance != float('inf') else 0.0", "def feature(board: chess.Board) -> float:\n    \"Counts the total number of defended pieces for both players.\"\n    defended_white = sum(1 for square, piece in board.piece_map().items() if piece.color == chess.WHITE and any(board.is_attacked_by(chess.BLACK, square) for square in board.attackers(chess.WHITE, square)))\n    defended_black = sum(1 for square, piece in board.piece_map().items() if piece.color == chess.BLACK and any(board.is_attacked_by(chess.WHITE, square) for square in board.attackers(chess.BLACK, square)))\n    return float(defended_white - defended_black)", "def feature(board: chess.Board) -> float:\n    \"Counts isolated pawns for both players.\"\n    isolated_white = sum(1 for square, piece in board.piece_map().items() if piece.color == chess.WHITE and piece.piece_type == chess.PAWN and (board.piece_at(square - 1) is None and board.piece_at(square + 1) is None))\n    isolated_black = sum(1 for square, piece in board.piece_map().items() if piece.color == chess.BLACK and piece.piece_type == chess.PAWN and (board.piece_at(square - 1) is None and board.piece_at(square + 1) is None))\n    return float(isolated_white - isolated_black)", "def feature(board: chess.Board) -> float:\n    \"Calculates the total piece mobility for both players.\"\n    white_moves = sum(len(list(board.legal_moves)) for square, piece in board.piece_map().items() if piece.color == chess.WHITE)\n    black_moves = sum(len(list(board.legal_moves)) for square, piece in board.piece_map().items() if piece.color == chess.BLACK)\n    return float(white_moves - black_moves)", "def feature(board: chess.Board) -> float:\n    \"Measures the position of the king in relation to its safety.\"\n    white_king_square = next(square for square, piece in board.piece_map().items() if piece.color == chess.WHITE and piece.piece_type == chess.KING)\n    black_king_square = next(square for square, piece in board.piece_map().items() if piece.color == chess.BLACK and piece.piece_type == chess.KING)\n    white_safety = sum(1 for square in board.attackers(chess.BLACK, white_king_square))\n    black_safety = sum(1 for square in board.attackers(chess.WHITE, black_king_square))\n    return float(white_safety - black_safety)", "def feature(board: chess.Board) -> float:\n    \"Counts the total number of pieces that are on central squares.\"\n    central_squares = [chess.D4, chess.D5, chess.E4, chess.E5]\n    central_piece_count = sum(1 for square in central_squares if board.piece_at(square) is not None)\n    return float(central_piece_count)", "def feature(board: chess.Board) -> float:\n    \"Measures the difference in piece values of pieces under threat.\"\n    white_threatened_value = sum(piece.piece_type for square, piece in board.piece_map().items() if piece.color == chess.WHITE and board.is_attacked_by(chess.BLACK, square))\n    black_threatened_value = sum(piece.piece_type for square, piece in board.piece_map().items() if piece.color == chess.BLACK and board.is_attacked_by(chess.WHITE, square))\n    return float(white_threatened_value - black_threatened_value)", "def feature(board: chess.Board) -> float:\n    \"Calculates the difference between the values of pieces on the board.\"\n    piece_value = {chess.PAWN: 100, chess.KNIGHT: 320, chess.BISHOP: 330, chess.ROOK: 500, chess.QUEEN: 900, chess.KING: 20000}\n    white_value = sum(piece_value[piece.piece_type] for piece in board.piece_map().values() if piece.color == chess.WHITE)\n    black_value = sum(piece_value[piece.piece_type] for piece in board.piece_map().values() if piece.color == chess.BLACK)\n    return float(white_value - black_value)", "def feature(board: chess.Board) -> float:\n    \"Calculates the total distance of all pieces from their respective kings.\"\n    white_king_square = next(square for square, piece in board.piece_map().items() if piece.color == chess.WHITE and piece.piece_type == chess.KING)\n    black_king_square = next(square for square, piece in board.piece_map().items() if piece.color == chess.BLACK and piece.piece_type == chess.KING)\n    \n    white_distance = sum(chess.square_distance(white_king_square, square) for square, piece in board.piece_map().items() if piece.color == chess.WHITE)\n    black_distance = sum(chess.square_distance(black_king_square, square) for square, piece in board.piece_map().items() if piece.color == chess.BLACK)\n    \n    return float(white_distance - black_distance)", "def feature(board: chess.Board) -> float:\n    \"Calculates the material value of all pieces on the board, weighted by piece types.\"\n    material_values = {\n        chess.PAWN: 100,\n        chess.KNIGHT: 300,\n        chess.BISHOP: 300,\n        chess.ROOK: 500,\n        chess.QUEEN: 900,\n        chess.KING: 0\n    }\n    total_value = 0.0\n    for piece in board.piece_map().values():\n        value = material_values[piece.piece_type] if piece.color == chess.WHITE else -material_values[piece.piece_type]\n        total_value += value\n    return total_value", "def feature(board: chess.Board) -> float:\n    \"Counts the number of squares controlled (attacked) by each side, providing a control measure.\"\n    white_control = len(set(move.to_square for move in board.legal_moves if board.piece_at(move.to_square) is None))\n    black_control = len(set(move.to_square for move in board.legal_moves if board.piece_at(move.to_square) is None))\n    return float(white_control - black_control)", "def feature(board: chess.Board) -> float:\n    \"Calculates the distance of the two kings from each other, contributing to king safety evaluation.\"\n    white_king_square = board.king(chess.WHITE)\n    black_king_square = board.king(chess.BLACK)\n    if white_king_square is None or black_king_square is None:\n        return 0.0\n    return float(chess.square_distance(white_king_square, black_king_square))", "def feature(board: chess.Board) -> float:\n    \"Measures the concentration of pawns in the center of the board, indicating potential control.\"\n    center_squares = [chess.D4, chess.D5, chess.E4, chess.E5]\n    central_pawn_count = sum(1 for square in center_squares if board.piece_at(square) == chess.PAWN)\n    return float(central_pawn_count)", "def feature(board: chess.Board) -> float:\n    \"Evaluates the mobility of both kings by counting their legal moves.\"\n    white_king_moves = len(list(board.legal_moves)) if board.turn == chess.WHITE else 0\n    black_king_moves = len(list(board.legal_moves)) if board.turn == chess.BLACK else 0\n    return float(white_king_moves - black_king_moves)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces on the back rank for both sides, indicating completion of development.\"\n    white_back_rank = sum(1 for square in range(chess.A1, chess.H1 + 1) if board.piece_at(square) and board.piece_at(square).color == chess.WHITE)\n    black_back_rank = sum(1 for square in range(chess.A8, chess.H8 + 1) if board.piece_at(square) and board.piece_at(square).color == chess.BLACK)\n    return float(white_back_rank - black_back_rank)", "def feature(board: chess.Board) -> float:\n    \"Calculates the safety of the king by counting the number of attackers.\"\n    white_king_square = board.king(chess.WHITE)\n    black_king_square = board.king(chess.BLACK)\n    white_king_safety = len(board.attackers(chess.BLACK, white_king_square)) if white_king_square else 0\n    black_king_safety = len(board.attackers(chess.WHITE, black_king_square)) if black_king_square else 0\n    return float(black_king_safety - white_king_safety)", "def feature(board: chess.Board) -> float:\n    \"Measures the differences in the number of pieces attacking the opponent's king, reflecting threats.\"\n    white_king_square = board.king(chess.WHITE)\n    black_king_square = board.king(chess.BLACK)\n    white_threats = len(board.attackers(chess.BLACK, white_king_square)) if white_king_square else 0\n    black_threats = len(board.attackers(chess.WHITE, black_king_square)) if black_king_square else 0\n    return float(white_threats - black_threats)", "def feature(board: chess.Board) -> float:\n    \"Evaluates the number of minor pieces (knights and bishops) present on the board for both sides.\"\n    minor_pieces_count = sum(1 for piece in board.piece_map().values() if piece.piece_type in {chess.KNIGHT, chess.BISHOP})\n    return float(minor_pieces_count)", "def feature(board: chess.Board) -> float:\n    \"Measures the mobility of queens by counting their legal moves.\"\n    queen_moves = len([move for move in board.legal_moves if board.piece_at(move.from_square) is not None and board.piece_at(move.from_square).piece_type == chess.QUEEN])\n    return float(queen_moves)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of defended pawns for the current player.\"\n    defended_pawns = sum(1 for square, piece in board.piece_map().items() \n                         if piece.piece_type == chess.PAWN and piece.color == board.turn and \n                         any(board.is_attacked_by(not board.turn, attacker) for attacker in board.attackers(piece.color, square)))\n    return float(defended_pawns)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces attacking the opponent's king.\"\n    king_square = next((square for square, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color != board.turn), None)\n    if king_square is None:\n        return 0.0\n    attacking_pieces = len(board.attackers(board.turn, king_square))\n    return float(attacking_pieces)", "def feature(board: chess.Board) -> float:\n    \"Evaluates the distance from both kings to the center of the board.\"\n    white_king_square = next((square for square, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color == chess.WHITE), None)\n    black_king_square = next((square for square, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color == chess.BLACK), None)\n    if white_king_square is None or black_king_square is None:\n        return 0.0\n    distance_white = chess.square_distance(white_king_square, chess.parse_square('e4'))\n    distance_black = chess.square_distance(black_king_square, chess.parse_square('e4'))\n    return float(distance_white + distance_black)", "def feature(board: chess.Board) -> float:\n    \"Measures the total value of pieces currently under attack.\"\n    total_value_under_attack = sum(piece.piece_type for square, piece in board.piece_map().items() \n                                    if board.is_attacked_by(not piece.color, square))\n    return float(total_value_under_attack)", "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in the number of pieces each player has.\"\n    white_piece_count = len([p for p in board.piece_map().values() if p.color == chess.WHITE])\n    black_piece_count = len([p for p in board.piece_map().values() if p.color == chess.BLACK])\n    return float(white_piece_count - black_piece_count)", "def feature(board: chess.Board) -> float:\n    \"Evaluates the number of squares controlled by each color.\"\n    controlled_squares_white = len({move.to_square for move in board.legal_moves if board.turn})\n    controlled_squares_black = len({move.to_square for move in board.legal_moves if not board.turn})\n    return float(controlled_squares_white - controlled_squares_black)", "def feature(board: chess.Board) -> float:\n    \"Counts the total number of pieces on the board to gauge material density.\"\n    total_pieces_count = len(board.piece_map())\n    return float(total_pieces_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of squares available for each player's pieces to move.\"\n    legal_moves_count = sum(1 for move in board.legal_moves)\n    return float(legal_moves_count)", "def feature(board: chess.Board) -> float:\n    \"Measures how many pieces are hanging (undefended) for both players.\"\n    hanging_pieces = sum(1 for square, piece in board.piece_map().items() \n                         if not any(board.is_attacked_by(piece.color, square) for square in board.attackers(not piece.color, square)))\n    return float(hanging_pieces)", "def feature(board: chess.Board) -> float:\n    \"Calculate the difference in the number of pieces each player has.\"\n    count_white = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE)\n    count_black = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK)\n    return float(count_white - count_black)", "def feature(board: chess.Board) -> float:\n    \"Count the total number of pieces attacked by both players.\"\n    attacked_pieces = sum(1 for square, piece in board.piece_map().items() if board.is_attacked_by(not piece.color, square))\n    return float(attacked_pieces)", "def feature(board: chess.Board) -> float:\n    \"Measure the potential pawn structure by counting doubled or isolated pawns.\"\n    doubled_pawns = 0\n    isolated_pawns = 0\n    for file in range(8):\n        pawns_in_file = [square for square in range(8) if board.piece_at(chess.square(file, square)) == chess.PAWN]\n        if len(pawns_in_file) > 1:\n            doubled_pawns += len(pawns_in_file) - 1\n        if not (file > 0 and board.piece_at(chess.square(file - 1, 0)) == chess.PAWN) and \\\n           not (file < 7 and board.piece_at(chess.square(file + 1, 0)) == chess.PAWN):\n            isolated_pawns += len(pawns_in_file)\n    return float(doubled_pawns + isolated_pawns)", "def feature(board: chess.Board) -> float:\n    \"Count the number of rook files or ranks that are open (no pieces blocking the rooks).\"\n    open_files = sum(1 for file in range(8) if all(board.piece_at(chess.square(file, rank)) is None for rank in range(8)))\n    open_ranks = sum(1 for rank in range(8) if all(board.piece_at(chess.square(file, rank)) is None for file in range(8)))\n    return float(open_files + open_ranks)", "def feature(board: chess.Board) -> float:\n    \"Measure the king's activity by counting how many squares around the king are controlled by the opponent.\"\n    king_square = next((square for square in board.piece_map() if board.piece_map()[square].piece_type == chess.KING), None)\n    if not king_square:\n        return 0.0\n    opponent_controlled_squares = sum(1 for square in chess.SQUARES if board.is_attacked_by(not board.turn, square))\n    return float(opponent_controlled_squares)", "def feature(board: chess.Board) -> float:\n    \"Measure the number of pieces that are pinned by the opponent's pieces.\"\n    pinned_pieces = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == board.turn and any(board.attackers(not board.turn, square)):\n            pinned_pieces += 1\n    return float(pinned_pieces)", "def feature(board: chess.Board) -> float:\n    \"Count the number of pieces that have squares they control which cannot be attacked.\"\n    controlled_safe_squares = 0\n    for square, piece in board.piece_map().items():\n        controlled_squares = set(board.attackers(piece.color, square))\n        safe_controlled_squares = sum(1 for sq in controlled_squares if not board.is_attacked_by(not piece.color, sq))\n        controlled_safe_squares += safe_controlled_squares\n    return float(controlled_safe_squares)", "def feature(board: chess.Board) -> float:\n    \"Evaluate the activity of pieces by counting how many pieces are developed (not on the original squares).\"\n    developed_pieces = 0\n    starting_positions = {\n        chess.PAWN: range(8, 16),\n        chess.ROOK: {0, 7},\n        chess.KNIGHT: {1, 6},\n        chess.BISHOP: {2, 5},\n        chess.QUEEN: {3},\n        chess.KING: {4},\n    }\n    for square, piece in board.piece_map().items():\n        if piece.color == board.turn:\n            if piece.piece_type in starting_positions:\n                start_range = starting_positions[piece.piece_type]\n                if piece.piece_type == chess.ROOK or piece.piece_type == chess.KNIGHT:\n                    if chess.square_file(square) not in start_range:\n                        developed_pieces += 1\n                else:\n                    developed_pieces += 1 if chess.square_rank(square) > 1 else 0\n    return float(developed_pieces)", "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in the number of pawns between both players.\"\n    white_pawns = sum(1 for piece in board.piece_map().values() if piece.piece_type == chess.PAWN and piece.color == chess.WHITE)\n    black_pawns = sum(1 for piece in board.piece_map().values() if piece.piece_type == chess.PAWN and piece.color == chess.BLACK)\n    return float(white_pawns - black_pawns)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of pieces attacking the opponent's king.\"\n    opponent_king_square = next(square for square, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color != board.turn)\n    attacking_count = sum(1 for square in board.legal_moves if board.is_attacked_by(board.turn, opponent_king_square))\n    return float(attacking_count)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces in the opponent's back rank.\"\n    back_rank = 0 if board.turn == chess.WHITE else 7\n    opponent_pieces = sum(1 for square, piece in board.piece_map().items() if piece.color != board.turn and chess.square_rank(square) == back_rank)\n    return float(opponent_pieces)", "def feature(board: chess.Board) -> float:\n    \"Calculates the mobility difference between the players based on legal moves.\"\n    white_mobility = len(list(board.legal_moves)) if board.turn == chess.WHITE else len(list(board.legal_moves))\n    black_mobility = len(list(board.legal_moves)) if board.turn == chess.BLACK else len(list(board.legal_moves))\n    return float(white_mobility - black_mobility)", "def feature(board: chess.Board) -> float:\n    \"Measures the distance of all pieces from the center of the board.\"\n    center_squares = [chess.E4, chess.E5, chess.D4, chess.D5]\n    total_distance = sum(chess.square_distance(square, center_square) for square in board.piece_map() for center_square in center_squares)\n    return float(total_distance)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces that are pinned (cannot move without exposing the king).\"\n    pinned_count = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == board.turn:\n            for target_square in board.attackers(board.turn, square):\n                if board.piece_at(target_square) is None:  # No piece blocking the line\n                    pinned_count += 1\n                    break\n    return float(pinned_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of pieces that can be easily forked (attack more than one piece).\"\n    forking_count = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == board.turn:\n            for target_square in board.attackers(board.turn, square):\n                if len(board.attackers(not board.turn, target_square)) > 1:  # More than 1 attacker\n                    forking_count += 1\n                    break\n    return float(forking_count)", "def feature(board: chess.Board) -> float:\n    \"Measures the total value of pieces currently on the board.\"\n    total_value = 0\n    piece_values = {\n        chess.PAWN: 100,\n        chess.KNIGHT: 300,\n        chess.BISHOP: 300,\n        chess.ROOK: 500,\n        chess.QUEEN: 900,\n        chess.KING: 0\n    }\n    for piece in board.piece_map().values():\n        total_value += piece_values[piece.piece_type] if piece.color == chess.WHITE else -piece_values[piece.piece_type]\n    return total_value", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pinned pieces for the current player.\"\n    pinned_count = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == board.turn and board.is_attacked_by(not board.turn, square):\n            for attacker in board.attackers(not board.turn, square):\n                if board.piece_at(attacker).piece_type == chess.QUEEN or board.piece_at(attacker).piece_type == chess.ROOK:\n                    pinned_count += 1\n                    break\n    return float(pinned_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of squares occupied by each side's pawns.\"\n    white_pawn_count = sum(1 for square in board.piece_map() if board.piece_at(square).piece_type == chess.PAWN and board.piece_at(square).color == chess.WHITE)\n    black_pawn_count = sum(1 for square in board.piece_map() if board.piece_at(square).piece_type == chess.PAWN and board.piece_at(square).color == chess.BLACK)\n    return float(white_pawn_count - black_pawn_count)", "def feature(board: chess.Board) -> float:\n    \"Returns the difference in the number of pieces that control the center squares.\"\n    center_squares = [chess.E4, chess.E5, chess.D4, chess.D5]\n    white_control = sum(1 for square in center_squares if board.is_attacked_by(chess.WHITE, square))\n    black_control = sum(1 for square in center_squares if board.is_attacked_by(chess.BLACK, square))\n    return float(white_control - black_control)", "def feature(board: chess.Board) -> float:\n    \"Measures the mobility of the current player by counting legal moves.\"\n    mobility = len(list(board.legal_moves))\n    return float(mobility)", "def feature(board: chess.Board) -> float:\n    \"Calculates the average piece value for the current player.\"\n    total_value = 0\n    count = 0\n    piece_values = {\n        chess.PAWN: 100,\n        chess.KNIGHT: 300,\n        chess.BISHOP: 300,\n        chess.ROOK: 500,\n        chess.QUEEN: 900,\n        chess.KING: 0\n    }\n    for piece in board.piece_map().values():\n        if piece.color == board.turn:\n            total_value += piece_values[piece.piece_type]\n            count += 1\n    return total_value / count if count > 0 else 0.0", "def feature(board: chess.Board) -> float:\n    \"Counts the number of squares that are defended by pieces of the current player.\"\n    defended_squares = set()\n    for square, piece in board.piece_map().items():\n        if piece.color == board.turn:\n            for move in board.legal_moves:\n                if move.from_square == square:\n                    defended_squares.add(move.to_square)\n    return float(len(defended_squares))", "def feature(board: chess.Board) -> float:\n    \"Calculates the distance of the king to the center for the current player.\"\n    king_square = next((square for square, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color == board.turn), None)\n    if king_square is None:\n        return float('inf')\n    center_square = chess.E4  # Choosing one of the central squares\n    distance = chess.square_distance(king_square, center_square)\n    return float(distance)  # Less distance is better", "def feature(board: chess.Board) -> float:\n    \"Measures the number of attacking pieces that can attack the opponent's king.\"\n    opponent_king_square = next((square for square, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color != board.turn), None)\n    attack_count = sum(1 for square, piece in board.piece_map().items() if piece.color == board.turn and board.is_attacked_by(not board.turn, opponent_king_square))\n    return float(attack_count)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of minor pieces remaining on the board.\"\n    minor_piece_count = sum(1 for piece in board.piece_map().values() if piece.piece_type in {chess.KNIGHT, chess.BISHOP})\n    return float(minor_piece_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of pieces in the second to last rank for both players.\"\n    white_pieces_in_rank = sum(1 for square, piece in board.piece_map().items() if piece.color == chess.WHITE and chess.square_rank(square) == 6)\n    black_pieces_in_rank = sum(1 for square, piece in board.piece_map().items() if piece.color == chess.BLACK and chess.square_rank(square) == 1)\n    return float(white_pieces_in_rank - black_pieces_in_rank)", "def feature(board: chess.Board) -> float:\n    \"Calculates the mobility advantage based on the difference in total legal moves.\"\n    white_legal_moves = len(list(board.legal_moves)) if board.turn else 0\n    black_legal_moves = len(list(board.legal_moves)) if not board.turn else 0\n    return float(white_legal_moves - black_legal_moves)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces that are pinned by the opponent's pieces.\"\n    pinned_pieces = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == (chess.WHITE if board.turn else chess.BLACK):\n            for attacker in board.attackers(chess.BLACK if board.turn else chess.WHITE, square):\n                if board.piece_at(attacker) and board.piece_at(attacker).piece_type in (chess.ROOK, chess.QUEEN):\n                    if board.piece_at(square).piece_type in (chess.KING, chess.PAWN):\n                        pinned_pieces += 1\n    return float(pinned_pieces)", "def feature(board: chess.Board) -> float:\n    \"Measures the average rank of the pieces for the current player.\"\n    total_rank = 0\n    count = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == (chess.WHITE if board.turn else chess.BLACK):\n            total_rank += chess.square_rank(square)\n            count += 1\n    return float(total_rank / count) if count > 0 else 0.0", "def feature(board: chess.Board) -> float:\n    \"Calculates the total number of squares that are under attack by each player's pieces.\"\n    white_attacks = sum(1 for square in chess.SQUARES_180 if board.is_attacked_by(chess.WHITE, square))\n    black_attacks = sum(1 for square in chess.SQUARES_180 if board.is_attacked_by(chess.BLACK, square))\n    return float(white_attacks - black_attacks)", "def feature(board: chess.Board) -> float:\n    \"Measures the proportion of pieces on the board that are developed (not on the back rank).\"\n    developed_pieces = 0\n    total_pieces = len(board.piece_map())\n    for square, piece in board.piece_map().items():\n        if piece.color == (chess.WHITE if board.turn else chess.BLACK) and chess.square_rank(square) > 0:\n            developed_pieces += 1\n    return float(developed_pieces / total_pieces) if total_pieces > 0 else 0.0", "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in the number of rooks for both players.\"\n    white_rooks = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE and piece.piece_type == chess.ROOK)\n    black_rooks = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK and piece.piece_type == chess.ROOK)\n    return float(white_rooks - black_rooks)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces that can be developed in the next move for the player to move.\"\n    possible_developers = sum(1 for square, piece in board.piece_map().items()\n                               if piece.color == (chess.WHITE if board.turn else chess.BLACK) and \n                               (piece.piece_type in (chess.KNIGHT, chess.BISHOP) or (piece.piece_type == chess.PAWN and (chess.square_rank(square) < 6))))\n    return float(possible_developers)", "def feature(board: chess.Board) -> float:\n    \"Measures the total value of pieces that are currently attacked.\"\n    total_attacked_value = 0\n    for square, piece in board.piece_map().items():\n        if board.is_attacked_by(not piece.color, square):\n            total_attacked_value += piece.piece_type\n    return float(total_attacked_value)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of squares that are controlled by each side.\"\n    white_control = len(set(move.to_square for move in board.legal_moves if board.turn))\n    black_control = len(set(move.to_square for move in board.legal_moves if not board.turn))\n    return float(white_control - black_control)", "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in piece mobility between the two players.\"\n    white_mobility = len(list(board.legal_moves)) if board.turn else 0\n    black_mobility = len(list(board.legal_moves)) if not board.turn else 0\n    return float(white_mobility - black_mobility)", "def feature(board: chess.Board) -> float:\n    \"Measures the difference in the number of pawns for each color.\"\n    white_pawns = len([p for p in board.piece_map().values() if p.color == chess.WHITE and p.piece_type == chess.PAWN])\n    black_pawns = len([p for p in board.piece_map().values() if p.color == chess.BLACK and p.piece_type == chess.PAWN])\n    return float(white_pawns - black_pawns)", "def feature(board: chess.Board) -> float:\n    \"Measures the distance of the kings to the center of the board.\"\n    white_king = next(square for square, piece in board.piece_map().items() if piece.color == chess.WHITE and piece.piece_type == chess.KING)\n    black_king = next(square for square, piece in board.piece_map().items() if piece.color == chess.BLACK and piece.piece_type == chess.KING)\n    center_distance = (chess.square_distance(white_king, chess.E4) + chess.square_distance(black_king, chess.E4)) / 2\n    return float(center_distance)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of pieces that are pinned against the king.\"\n    pinned_pieces = 0\n    for square in board.piece_map():\n        piece = board.piece_at(square)\n        if piece and board.is_attacked_by(not piece.color, square):\n            for attacker in board.attackers(not piece.color, square):\n                if board.piece_at(attacker).piece_type == chess.ROOK or board.piece_at(attacker).piece_type == chess.QUEEN:\n                    pinned_pieces += 1\n                    break\n    return float(pinned_pieces)", "def feature(board: chess.Board) -> float:\n    \"Calculates the average distance of all pieces from their respective kings.\"\n    white_king = next(square for square, piece in board.piece_map().items() if piece.color == chess.WHITE and piece.piece_type == chess.KING)\n    black_king = next(square for square, piece in board.piece_map().items() if piece.color == chess.BLACK and piece.piece_type == chess.KING)\n    total_distance = 0\n    piece_count = 0\n    \n    for square in board.piece_map():\n        piece = board.piece_at(square)\n        total_distance += chess.square_distance(square, white_king) if piece.color == chess.WHITE else chess.square_distance(square, black_king)\n        piece_count += 1\n    \n    return float(total_distance / piece_count) if piece_count else 0.0", "def feature(board: chess.Board) -> float:\n    \"Counts the total number of pieces that can capture on the next move.\"\n    capture_moves = sum(1 for move in board.legal_moves if board.piece_at(move.to_square) is not None and board.piece_at(move.to_square).color != board.turn)\n    return float(capture_moves)", "def feature(board: chess.Board) -> float:\n    \"Measures the overall attacking potential by counting the number of pieces attacking opponent's squares.\"\n    attack_count = sum(len(board.attackers(chess.WHITE if board.turn else chess.BLACK, square)) \n                       for square in board.piece_map() if board.piece_at(square) and board.piece_at(square).color != board.turn)\n    return float(attack_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in material value of pieces attacking the opponent's king.\"\n    king_square = next((sq for sq, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color != board.turn), None)\n    if king_square is None:\n        return 0.0\n    attacking_material_value = sum(board.piece_at(sq).piece_type for sq in board.attackers(board.turn, king_square))\n    return float(attacking_material_value)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of passed pawns for both players.\"\n    passed_pawns = 0\n    for pawn_square, piece in board.piece_map().items():\n        if piece.piece_type == chess.PAWN:\n            if (piece.color == chess.WHITE and \n                all(board.piece_at(sq) is None for sq in range(pawn_square + 8, 64, 8))):\n                passed_pawns += 1\n            elif (piece.color == chess.BLACK and  \n                  all(board.piece_at(sq) is None for sq in range(pawn_square - 8, -1, -8))):\n                passed_pawns += 1\n    return float(passed_pawns)", "def feature(board: chess.Board) -> float:\n    \"Evaluates the center control by counting the pieces occupying or controlling central squares.\"\n    central_squares = [chess.E4, chess.E5, chess.D4, chess.D5]\n    center_control = sum(1 for square in central_squares if board.is_attacked_by(chess.WHITE, square)) - \\\n                    sum(1 for square in central_squares if board.is_attacked_by(chess.BLACK, square))\n    return float(center_control)", "def feature(board: chess.Board) -> float:\n    \"Calculates the mobility of the player's pieces based on legal moves.\"\n    legal_moves_count = len(list(board.legal_moves))\n    return float(legal_moves_count)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of pins in the position.\"\n    pin_count = 0\n    for square in board.piece_map():\n        piece = board.piece_at(square)\n        if piece.color == board.turn:\n            for target_square in board.attackers(chess.WHITE if board.turn else chess.BLACK, square):\n                if board.is_attacked_by(chess.WHITE if board.turn else chess.BLACK, target_square):\n                    pin_count += 1\n    return float(pin_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the total number of squares each player's pieces control.\"\n    white_control = sum(len(board.attacks(square)) for square in board.piece_map() if board.piece_at(square).color == chess.WHITE)\n    black_control = sum(len(board.attacks(square)) for square in board.piece_map() if board.piece_at(square).color == chess.BLACK)\n    return float(white_control - black_control)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces each player has that are attacking the opponent's pieces.\"\n    attacking_piece_count = sum(1 for square in board.piece_map() if board.piece_at(square).color == board.turn \n                                 and board.piece_at(square).piece_type != chess.KING \n                                 and len(board.attackers(chess.WHITE if board.turn else chess.BLACK, square)) > 0)\n    return float(attacking_piece_count)", "def feature(board: chess.Board) -> float:\n    \"Measures the difference in the total number of pieces on the board.\"\n    total_white_pieces = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE)\n    total_black_pieces = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK)\n    result = float(total_white_pieces - total_black_pieces)\n    return result", "def feature(board: chess.Board) -> float:\n    \"Calculates the average distance of all pieces from their respective starting positions.\"\n    total_distance = 0\n    piece_count = 0\n    for square, piece in board.piece_map().items():\n        starting_rank = 7 if piece.color == chess.WHITE else 0\n        distance = chess.square_rank(square) - starting_rank\n        total_distance += abs(distance)\n        piece_count += 1\n    result = total_distance / piece_count if piece_count > 0 else 0.0\n    return result", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces controlling the center squares (d4, d5, e4, e5).\"\n    center_squares = [chess.D4, chess.D5, chess.E4, chess.E5]\n    control_count = sum(1 for square in center_squares if board.is_attacked_by(chess.WHITE, square)) - \\\n                   sum(1 for square in center_squares if board.is_attacked_by(chess.BLACK, square))\n    result = float(control_count)\n    return result", "def feature(board: chess.Board) -> float:\n    \"Measures the number of doubled pawns on the board for both players.\"\n    pawns = []\n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.PAWN:\n            pawns.append(chess.square_file(square))\n    doubled = len(pawns) - len(set(pawns))\n    result = float(doubled)\n    return result", "def feature(board: chess.Board) -> float:\n    \"Calculates the ratio of minor pieces (knights and bishops) to major pieces (rooks and queens).\"\n    minor_count = sum(1 for piece in board.piece_map().values() if piece.piece_type in [chess.KNIGHT, chess.BISHOP])\n    major_count = sum(1 for piece in board.piece_map().values() if piece.piece_type in [chess.ROOK, chess.QUEEN])\n    result = minor_count / (major_count + 1)  # Avoid division by zero\n    return result", "def feature(board: chess.Board) -> float:\n    \"Counts the number of squares attacked by both players.\"\n    white_attack_count = sum(1 for move in board.legal_moves if board.is_attacked_by(chess.WHITE, move.to_square))\n    black_attack_count = sum(1 for move in board.legal_moves if board.is_attacked_by(chess.BLACK, move.to_square))\n    result = float(white_attack_count - black_attack_count)\n    return result", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of pieces on the seventh rank for both players.\"\n    seventh_rank_count = sum(1 for square in board.piece_map() if chess.square_rank(square) == 6 or chess.square_rank(square) == 1)\n    result = float(seventh_rank_count)\n    return result", "def feature(board: chess.Board) -> float:\n    \"Measures the number of pieces defending the king for both players.\"\n    white_king_square = next(square for square, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color == chess.WHITE)\n    black_king_square = next(square for square, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color == chess.BLACK)\n    white_defenders = sum(1 for square in board.piece_map() if board.is_attacked_by(chess.WHITE, white_king_square))\n    black_defenders = sum(1 for square in board.piece_map() if board.is_attacked_by(chess.BLACK, black_king_square))\n    result = float(white_defenders - black_defenders)\n    return result", "def feature(board: chess.Board) -> float:\n    \"Measures the number of pieces that are currently pinned.\"\n    pinned_count = sum(1 for square in board.piece_map() if board.is_attacked_by(not board.turn, square) and not board.is_check())\n    return float(pinned_count)", "def feature(board: chess.Board) -> float:\n    \"Counts the total mobility of both players based on the legal moves available.\"\n    mobility_white = sum(1 for move in board.legal_moves if board.turn)\n    mobility_black = sum(1 for move in board.legal_moves if not board.turn)\n    return float(mobility_white - mobility_black)", "def feature(board: chess.Board) -> float:\n    \"Evaluates the coordination between pieces by counting pairs of attacking pieces.\"\n    pair_count = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == board.turn:\n            for attack_square in board.attackers(not board.turn, square):\n                if board.piece_at(attack_square) and board.piece_at(attack_square).color == board.turn:\n                    pair_count += 1\n    return float(pair_count)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of squares attacked by each player.\"\n    attacking_squares_white = {move.to_square for move in board.legal_moves if move.from_square in board.attackers(chess.WHITE, move.to_square)}\n    attacking_squares_black = {move.to_square for move in board.legal_moves if move.from_square in board.attackers(chess.BLACK, move.to_square)}\n    return float(len(attacking_squares_white) - len(attacking_squares_black))", "def feature(board: chess.Board) -> float:\n    \"Counts the number of central control squares (d4, d5, e4, e5) occupied by each player.\"\n    central_squares = [chess.parse_square(sq) for sq in ['d4', 'd5', 'e4', 'e5']]\n    control_white = sum(1 for square in central_squares if board.piece_at(square) and board.piece_at(square).color == chess.WHITE)\n    control_black = sum(1 for square in central_squares if board.piece_at(square) and board.piece_at(square).color == chess.BLACK)\n    return float(control_white - control_black)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of potential discovered attacks available.\"\n    discovered_count = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == board.turn:\n            if board.is_attacked_by(not board.turn, square):\n                discovered_count += 1\n    return float(discovered_count)", "def feature(board: chess.Board) -> float:\n    \"Computes the difference between the number of pieces on the back rank for both players.\"\n    back_rank_white = sum(1 for square in range(chess.A1, chess.H1 + 1) if board.piece_at(square) and board.piece_at(square).color == chess.WHITE)\n    back_rank_black = sum(1 for square in range(chess.A8, chess.H8 + 1) if board.piece_at(square) and board.piece_at(square).color == chess.BLACK)\n    return float(back_rank_white - back_rank_black)", "def feature(board: chess.Board) -> float:\n    \"Measures the difference in the number of knights for both players.\"\n    knights_white = len([square for square in board.piece_map() if board.piece_at(square).piece_type == chess.KNIGHT and board.piece_at(square).color == chess.WHITE])\n    knights_black = len([square for square in board.piece_map() if board.piece_at(square).piece_type == chess.KNIGHT and board.piece_at(square).color == chess.BLACK])\n    return float(knights_white - knights_black)", "def feature(board: chess.Board) -> float:\n    \"Evaluates the distance of kings from the center of the board as a safety measure.\"\n    king_square_white = [square for square in board.piece_map() if board.piece_at(square).piece_type == chess.KING and board.piece_at(square).color == chess.WHITE][0]\n    king_square_black = [square for square in board.piece_map() if board.piece_at(square).piece_type == chess.KING and board.piece_at(square).color == chess.BLACK][0]\n    distance_white = chess.square_distance(king_square_white, chess.E4)\n    distance_black = chess.square_distance(king_square_black, chess.E4)\n    return float(distance_black - distance_white)", "def feature(board: chess.Board) -> float:\n    'Measures the difference in the number of pieces at the edge or center of the board for both players.'\n    edge_count_white = sum(1 for sq in board.piece_map() if board.piece_map()[sq].color == chess.WHITE and (chess.square_file(sq) == 0 or chess.square_file(sq) == 7 or chess.square_rank(sq) == 0 or chess.square_rank(sq) == 7))\n    edge_count_black = sum(1 for sq in board.piece_map() if board.piece_map()[sq].color == chess.BLACK and (chess.square_file(sq) == 0 or chess.square_file(sq) == 7 or chess.square_rank(sq) == 0 or chess.square_rank(sq) == 7))\n    return float(edge_count_white - edge_count_black)", "def feature(board: chess.Board) -> float:\n    'Counts the number of pawns on the 7th rank for both sides and measures their potential promotion.'\n    pawns_white = sum(1 for sq in board.piece_map() if board.piece_map()[sq].color == chess.WHITE and chess.square_rank(sq) == 6)\n    pawns_black = sum(1 for sq in board.piece_map() if board.piece_map()[sq].color == chess.BLACK and chess.square_rank(sq) == 1)\n    return float(pawns_white - pawns_black)", "def feature(board: chess.Board) -> float:\n    'Calculates the control points based on the number of opponent\u2019s pieces attacked by the player\u2019s pieces.'\n    control_points = 0\n    for sq in board.piece_map():\n        piece = board.piece_map()[sq]\n        if piece.color == board.turn:\n            control_points += len(board.attackers(not board.turn, sq))\n    return float(control_points)", "def feature(board: chess.Board) -> float:\n    'Evaluates the number of rooks on open files for both players, which can indicate control of the board.'\n    open_file_count = 0\n    for file in range(8):\n        if all(board.piece_at(chess.square(file, rank)) is None or board.piece_at(chess.square(file, rank)).piece_type == chess.ROOK for rank in range(8)):\n            open_file_count += 1\n    return float(open_file_count)", "def feature(board: chess.Board) -> float:\n    'Measures the difference in the number of kings that are actively behind pawn structures.'\n    active_kings = sum(1 for sq in board.piece_map() if board.piece_map()[sq].piece_type == chess.KING and chess.square_rank(sq) > 0 and (any(board.piece_at(chess.square(sq_file, sq_rank)) is not None for sq_file in range(8) for sq_rank in range(chess.square_rank(sq) + 1, 8))))\n    return float(active_kings)", "def feature(board: chess.Board) -> float:\n    'Measures the distance of the king to the nearest piece for each side.'\n    white_king = board.king(chess.WHITE)\n    black_king = board.king(chess.BLACK)\n    nearest_white_distance = float('inf')\n    nearest_black_distance = float('inf')\n    \n    for square, piece in board.piece_map().items():\n        if piece.color == chess.WHITE:\n            nearest_white_distance = min(nearest_white_distance, chess.square_distance(white_king, square))\n        elif piece.color == chess.BLACK:\n            nearest_black_distance = min(nearest_black_distance, chess.square_distance(black_king, square))\n    \n    return nearest_white_distance - nearest_black_distance", "def feature(board: chess.Board) -> float:\n    'Counts the total mobility of each player by summing legal moves of all their pieces.'\n    white_mobility = sum(1 for move in board.legal_moves if board.piece_at(move.from_square).color == chess.WHITE)\n    black_mobility = sum(1 for move in board.legal_moves if board.piece_at(move.from_square).color == chess.BLACK)\n    \n    return white_mobility - black_mobility", "def feature(board: chess.Board) -> float:\n    'Measures the central control by counting the number of pieces in the central 4 squares.'\n    central_squares = [chess.D4, chess.D5, chess.E4, chess.E5]\n    white_control = sum(1 for square in central_squares if board.piece_at(square) and board.piece_at(square).color == chess.WHITE)\n    black_control = sum(1 for square in central_squares if board.piece_at(square) and board.piece_at(square).color == chess.BLACK)\n    \n    return white_control - black_control", "def feature(board: chess.Board) -> float:\n    'Calculates the number of squares controlled by each side by their pieces.'\n    white_controlled = len([square for square in chess.SQUARES if board.is_attacked_by(chess.WHITE, square)])\n    black_controlled = len([square for square in chess.SQUARES if board.is_attacked_by(chess.BLACK, square)])\n    \n    return white_controlled - black_controlled", "def feature(board: chess.Board) -> float:\n    'Measures the difference between the number of pieces that can capture the opponent\\'s king.'\n    white_threats = len([square for square in chess.SQUARES if board.is_attacked_by(chess.WHITE, board.king(chess.BLACK))])\n    black_threats = len([square for square in chess.SQUARES if board.is_attacked_by(chess.BLACK, board.king(chess.WHITE))])\n    \n    return white_threats - black_threats", "def feature(board: chess.Board) -> float:\n    'Counts the number of pieces each player has within 3 squares of the opponent\\'s king.'\n    white_in_range = sum(1 for square in board.piece_map() if board.piece_map()[square].color == chess.WHITE and \n                         chess.square_distance(square, board.king(chess.BLACK)) <= 3)\n    black_in_range = sum(1 for square in board.piece_map() if board.piece_map()[square].color == chess.BLACK and \n                         chess.square_distance(square, board.king(chess.WHITE)) <= 3)\n    \n    return white_in_range - black_in_range", "def feature(board: chess.Board) -> float:\n    'Measures the difference in pawn structure by counting isolated pawns for each side.'\n    def count_isolated_pawns(color):\n        isolated = 0\n        for square in chess.SQUARES:\n            if board.piece_at(square) and board.piece_at(square).color == color and board.piece_at(square).piece_type == chess.PAWN:\n                file = chess.square_file(square)\n                if (file > 0 and not board.piece_at(chess.square(square // 8, file - 1))) and \\\n                   (file < 7 and not board.piece_at(chess.square(square // 8, file + 1))):\n                    isolated += 1\n        return isolated\n\n    white_isolated = count_isolated_pawns(chess.WHITE)\n    black_isolated = count_isolated_pawns(chess.BLACK)\n    \n    return white_isolated - black_isolated", "def feature(board: chess.Board) -> float:\n    'Calculates the king safety by counting the number of attacking pieces near each king.'\n    def count_near_attacks(king_square):\n        return sum(1 for square in chess.SQUARES if board.is_attacked_by(board.piece_at(king_square).color, square) and \n                   chess.square_distance(king_square, square) <= 2)\n\n    white_attacks = count_near_attacks(board.king(chess.WHITE))\n    black_attacks = count_near_attacks(board.king(chess.BLACK))\n    \n    return white_attacks - black_attacks", "def feature(board: chess.Board) -> float:\n    'Measures the value difference of protected pieces; pieces that are defended by another piece.'\n    def count_protected_value(color):\n        value = 0\n        for square in chess.SQUARES:\n            piece = board.piece_at(square)\n            if piece and piece.color == color:\n                attackers = board.attackers(board.piece_at(square).color, square)\n                if attackers:  # it's protected\n                    value += piece.piece_type\n        return value\n\n    white_protected_value = count_protected_value(chess.WHITE)\n    black_protected_value = count_protected_value(chess.BLACK)\n    \n    return white_protected_value - black_protected_value", "def feature(board: chess.Board) -> float:\n    'Assesses piece development by counting knights and bishops in the center of the board (squares d4, d5, e4, e5).'\n    center_squares = [chess.D4, chess.D5, chess.E4, chess.E5]\n    white_development = sum(1 for square in center_squares if board.piece_at(square) and \n                             board.piece_at(square).color == chess.WHITE and \n                             board.piece_at(square).piece_type in [chess.KNIGHT, chess.BISHOP])\n    black_development = sum(1 for square in center_squares if board.piece_at(square) and \n                             board.piece_at(square).color == chess.BLACK and \n                             board.piece_at(square).piece_type in [chess.KNIGHT, chess.BISHOP])\n    \n    return white_development - black_development", "def feature(board: chess.Board) -> float:\n    \"Measures the number of attacking pieces each player has.\"\n    white_attacking_pieces = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE and board.attackers(chess.WHITE, piece.color))\n    black_attacking_pieces = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK and board.attackers(chess.BLACK, piece.color))\n    result = float(white_attacking_pieces - black_attacking_pieces)\n    return result", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces each player has in the opponent's half of the board.\"\n    half_way_line = 4\n    white_pieces_in_enemy_half = sum(1 for square, piece in board.piece_map().items() if piece.color == chess.WHITE and chess.square_rank(square) >= half_way_line)\n    black_pieces_in_enemy_half = sum(1 for square, piece in board.piece_map().items() if piece.color == chess.BLACK and chess.square_rank(square) < half_way_line)\n    result = float(white_pieces_in_enemy_half - black_pieces_in_enemy_half)\n    return result", "def feature(board: chess.Board) -> float:\n    \"Evaluates the number of pieces that are actively participating in the game (not blocked).\"\n    active_white_pieces = sum(1 for square, piece in board.piece_map().items() if piece.color == chess.WHITE and board.legal_moves)\n    active_black_pieces = sum(1 for square, piece in board.piece_map().items() if piece.color == chess.BLACK and board.legal_moves)\n    result = float(active_white_pieces - active_black_pieces)\n    return result", "def feature(board: chess.Board) -> float:\n    \"Measures the vulnerability of each player's king based on attackers.\"\n    white_king_square = next(square for square, piece in board.piece_map().items() if piece.color == chess.WHITE and piece.piece_type == chess.KING)\n    black_king_square = next(square for square, piece in board.piece_map().items() if piece.color == chess.BLACK and piece.piece_type == chess.KING)\n    white_king_vulnerability = len(board.attackers(chess.BLACK, white_king_square))\n    black_king_vulnerability = len(board.attackers(chess.WHITE, black_king_square))\n    result = float(black_king_vulnerability - white_king_vulnerability)\n    return result", "def feature(board: chess.Board) -> float:\n    \"Evaluates the maximum distance of any piece from its base rank.\"\n    max_white_distance = max(chess.square_rank(square) for square, piece in board.piece_map().items() if piece.color == chess.WHITE) - 0\n    max_black_distance = max(7 - chess.square_rank(square) for square, piece in board.piece_map().items() if piece.color == chess.BLACK)\n    result = float(max_white_distance - max_black_distance)\n    return result", "def feature(board: chess.Board) -> float:\n    \"Measures the number of connected pawns for both players.\"\n    white_connected_pawns = sum(1 for square in board.piece_map() if board.piece_at(square).piece_type == chess.PAWN and \n        (board.piece_at(square + 1) and board.piece_at(square + 1).color == chess.WHITE or board.piece_at(square - 1) and board.piece_at(square - 1).color == chess.WHITE))\n    black_connected_pawns = sum(1 for square in board.piece_map() if board.piece_at(square).piece_type == chess.PAWN and \n        (board.piece_at(square + 1) and board.piece_at(square + 1).color == chess.BLACK or board.piece_at(square - 1) and board.piece_at(square - 1).color == chess.BLACK))\n    result = float(white_connected_pawns - black_connected_pawns)\n    return result", "def feature(board: chess.Board) -> float:\n    'Measures the value of pieces that are currently attacking the opponent\\'s king.'\n    attacking_pieces = 0\n    opponent_king_square = None\n    for square in range(64):\n        piece = board.piece_at(square)\n        if piece and piece.color == chess.BLACK:\n            opponent_king_square = square if piece.piece_type == chess.KING else opponent_king_square\n    if opponent_king_square is not None:\n        for square in range(64):\n            piece = board.piece_at(square)\n            if piece and piece.color == chess.WHITE and board.is_attacked_by(chess.WHITE, opponent_king_square):\n                attacking_pieces += piece.piece_type\n    return float(attacking_pieces)", "def feature(board: chess.Board) -> float:\n    'Calculates the mobility of the pieces by counting how many legally reachable squares there are.'\n    mobility_count = 0\n    for move in board.legal_moves:\n        mobility_count += 1\n    return float(mobility_count)", "def feature(board: chess.Board) -> float:\n    'Evaluates the pawn structure by counting isolated pawns.'\n    isolated_pawns = 0\n    for square in board.piece_map():\n        piece = board.piece_at(square)\n        if piece and piece.piece_type == chess.PAWN:\n            file = chess.square_file(square)\n            if (board.piece_at(chess.parse_square(chess.square_name(square)[0] + str(chess.square_rank(square) + 1))) is None and\n                board.piece_at(chess.parse_square(chess.square_name(square)[0] + str(chess.square_rank(square) - 1))) is None):\n                isolated_pawns += 1\n    return float(isolated_pawns)", "def feature(board: chess.Board) -> float:\n    'Measures the king safety based on how many pieces are protecting it.'\n    protection_count = 0\n    king_square = None\n    for square in range(64):\n        piece = board.piece_at(square)\n        if piece and piece.color == board.turn and piece.piece_type == chess.KING:\n            king_square = square\n            break\n    if king_square is not None:\n        for square in range(64):\n            piece = board.piece_at(square)\n            if piece and piece.color != board.turn and board.is_attacked_by(piece.color, king_square):\n                protection_count -= 1\n            elif piece and piece.color == board.turn and square != king_square:\n                protection_count += 1\n    return float(protection_count)", "def feature(board: chess.Board) -> float:\n    'Calculates the number of pieces placed on central squares.'\n    central_squares = [chess.E4, chess.D4, chess.E5, chess.D5]\n    central_piece_count = 0\n    for square in central_squares:\n        if board.piece_at(square) is not None:\n            central_piece_count += 1\n    return float(central_piece_count)", "def feature(board: chess.Board) -> float:\n    'Evaluates the positional value of pawns on the 6th rank.'\n    pawn_position_score = 0\n    for square in range(64):\n        piece = board.piece_at(square)\n        if piece and piece.piece_type == chess.PAWN and chess.square_rank(square) == 5:\n            pawn_position_score += 1\n    return float(pawn_position_score)", "def feature(board: chess.Board) -> float:\n    'Calculates the material ratio by dividing the total piece values of both players.'\n    piece_values = {chess.PAWN: 100, chess.KNIGHT: 320, chess.BISHOP: 330,\n                    chess.ROOK: 500, chess.QUEEN: 900, chess.KING: 0}\n    white_value = sum(piece_values[piece.piece_type] for piece in board.piece_map().values() if piece.color == chess.WHITE)\n    black_value = sum(piece_values[piece.piece_type] for piece in board.piece_map().values() if piece.color == chess.BLACK)\n    return float(white_value / (black_value + 1e-6))", "def feature(board: chess.Board) -> float:\n    'Counts the number of pieces on the back rank and evaluates development.'\n    back_rank_count = 0\n    back_rank = 0 if board.turn == chess.WHITE else 7\n    for file in range(8):\n        piece = board.piece_at(chess.square(file, back_rank))\n        if piece:\n            back_rank_count += 1\n    return float(back_rank_count)", "def feature(board: chess.Board) -> float:\n    \"Measures the total attacking pieces for both players.\"\n    white_attacking = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE and board.is_attacked_by(chess.BLACK, piece.piece_type))\n    black_attacking = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK and board.is_attacked_by(chess.WHITE, piece.piece_type))\n    return float(white_attacking - black_attacking)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pawns on the 6th rank for both players.\"\n    white_pawns_on_6th = sum(1 for square in board.piece_map() if board.piece_at(square).color == chess.WHITE and chess.square_rank(square) == 5)\n    black_pawns_on_6th = sum(1 for square in board.piece_map() if board.piece_at(square).color == chess.BLACK and chess.square_rank(square) == 5)\n    return float(white_pawns_on_6th - black_pawns_on_6th)", "def feature(board: chess.Board) -> float:\n    \"Calculates the distance of kings to the center squares.\"\n    white_king_square = next(square for square, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color == chess.WHITE)\n    black_king_square = next(square for square, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color == chess.BLACK)\n    white_distance = chess.square_distance(white_king_square, chess.parse_square('e4'))\n    black_distance = chess.square_distance(black_king_square, chess.parse_square('e4'))\n    return float(black_distance - white_distance)", "def feature(board: chess.Board) -> float:\n    \"Measures the total value of material that is pinned.\"\n    pinned_pieces_value = 0\n    for square in board.piece_map():\n        piece = board.piece_at(square)\n        if piece and board.is_attacked_by(board.turn, square):\n            pinned_pieces_value += piece.piece_type\n    return float(pinned_pieces_value)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of pieces that can be immediately captured in one move.\"\n    capturable_pieces = sum(1 for move in board.legal_moves if board.piece_at(move.to_square) is not None)\n    return float(capturable_pieces)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of pieces in the central squares (d4, d5, e4, e5).\"\n    central_squares = [chess.parse_square('d4'), chess.parse_square('d5'), chess.parse_square('e4'), chess.parse_square('e5')]\n    central_piece_count = sum(1 for square in central_squares if board.piece_at(square) is not None)\n    return float(central_piece_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the total number of potential discovered attacks based on the current position.\"\n    discovered_attacks = 0\n    for square in board.piece_map():\n        piece = board.piece_at(square)\n        if piece and piece.piece_type in {chess.ROOK, chess.QUEEN}:\n            if any(board.is_attacked_by(not piece.color, target_square) for target_square in board.attackers(not piece.color, square)):\n                discovered_attacks += 1\n    return float(discovered_attacks)", "def feature(board: chess.Board) -> float:\n    \"Measures the positional advantage based on the number of knight and bishop pairs.\"\n    knights = sum(1 for piece in board.piece_map().values() if piece.piece_type == chess.KNIGHT and piece.color == board.turn)\n    bishops = sum(1 for piece in board.piece_map().values() if piece.piece_type == chess.BISHOP and piece.color == board.turn)\n    return float(knights - bishops)", "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in the number of pieces on the second rank for both players.\"\n    white_second_rank = sum(1 for sq in range(chess.A2, chess.H2 + 1) if board.piece_at(sq) and board.piece_at(sq).color == chess.WHITE)\n    black_second_rank = sum(1 for sq in range(chess.A7, chess.H7 + 1) if board.piece_at(sq) and board.piece_at(sq).color == chess.BLACK)\n    return float(white_second_rank - black_second_rank)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of squares from which the opponent can check the king.\"\n    king_square = board.king(chess.BLACK) if board.turn else board.king(chess.WHITE)\n    if king_square is None:\n        return 0.0\n    return float(len(board.attackers(chess.WHITE if board.turn else chess.BLACK, king_square)))", "def feature(board: chess.Board) -> float:\n    \"Calculates the sum of the distances of all pieces from their respective back ranks.\"\n    total_distance = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == chess.WHITE:\n            total_distance += chess.square_rank(square)\n        else:\n            total_distance += (7 - chess.square_rank(square))\n    return float(total_distance)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of isolated pawns on the board.\"\n    isolated_pawns = 0\n    for sq in range(chess.A2, chess.H7 + 1):\n        if board.piece_at(sq) and board.piece_at(sq).piece_type == chess.PAWN:\n            file = chess.square_file(sq)\n            if not (board.piece_at(chess.square(file - 1, chess.square_rank(sq))) or \n                    board.piece_at(chess.square(file + 1, chess.square_rank(sq)))):\n                isolated_pawns += 1\n    return float(isolated_pawns)", "def feature(board: chess.Board) -> float:\n    \"Counts how many pieces are actively defending other pieces.\"\n    defending_pieces = 0\n    for square, piece in board.piece_map().items():\n        if board.is_attacked_by(not piece.color, square):\n            defending_pieces += 1\n    return float(defending_pieces)", "def feature(board: chess.Board) -> float:\n    \"Measures the control of the center squares (d4, d5, e4, e5).\"\n    center_squares = [chess.D4, chess.D5, chess.E4, chess.E5]\n    control_score = 0\n    for sq in center_squares:\n        if board.piece_at(sq) is not None:\n            control_score += 1 if board.piece_at(sq).color == chess.WHITE else -1\n    return float(control_score)", "def feature(board: chess.Board) -> float:\n    \"Calculates the ratio of minor pieces (Knights and Bishops) to rooks on the board.\"\n    minor_pieces = 0\n    rooks = 0\n    for piece in board.piece_map().values():\n        if piece.piece_type in [chess.KNIGHT, chess.BISHOP]:\n            minor_pieces += 1\n        elif piece.piece_type == chess.ROOK:\n            rooks += 1\n    return float(minor_pieces / (rooks + 1))  # Avoid division by zero", "def feature(board: chess.Board) -> float:\n    \"Counts the number of threats on the opponent's pieces.\"\n    threat_count = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == (chess.WHITE if board.turn else chess.BLACK):\n            if board.is_attacked_by(not piece.color, square):\n                threat_count += 1\n    return float(threat_count)", "def feature(board: chess.Board) -> float:\n    \"Measures the total number of pieces controlled by each player.\"\n    white_control = sum(1 for square in board.piece_map() if board.piece_at(square).color == chess.WHITE and board.is_attacked_by(chess.WHITE, square))\n    black_control = sum(1 for square in board.piece_map() if board.piece_at(square).color == chess.BLACK and board.is_attacked_by(chess.BLACK, square))\n    return float(white_control - black_control)", "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in piece mobility for both players.\"\n    white_mobility = sum(1 for move in board.legal_moves if board.turn and board.piece_at(move.from_square).color == chess.WHITE)\n    black_mobility = sum(1 for move in board.legal_moves if not board.turn and board.piece_at(move.from_square).color == chess.BLACK)\n    return float(white_mobility - black_mobility)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces on the board relative to the maximum possible.\"\n    total_pieces = len(board.piece_map())\n    max_pieces = 32  # 16 for each player\n    return float(total_pieces / max_pieces)", "def feature(board: chess.Board) -> float:\n    \"Evaluates the number of pieces near their opponent's back rank.\"\n    white_near_back_rank = sum(1 for square in board.piece_map() if board.piece_at(square).color == chess.WHITE and chess.square_rank(square) == 7)\n    black_near_back_rank = sum(1 for square in board.piece_map() if board.piece_at(square).color == chess.BLACK and chess.square_rank(square) == 0)\n    return float(white_near_back_rank - black_near_back_rank)", "def feature(board: chess.Board) -> float:\n    \"Calculates the relative value of attacked pieces for both players.\"\n    white_attacked_value = sum(board.piece_at(square).piece_type for square in board.piece_map() if board.is_attacked_by(chess.BLACK, square) and board.piece_at(square).color == chess.WHITE)\n    black_attacked_value = sum(board.piece_at(square).piece_type for square in board.piece_map() if board.is_attacked_by(chess.WHITE, square) and board.piece_at(square).color == chess.BLACK)\n    return float(white_attacked_value - black_attacked_value)", "def feature(board: chess.Board) -> float:\n    \"Measures the overall safety of the kings by counting the squares they control.\"\n    white_king_safety = len(board.attackers(chess.BLACK, chess.parse_square('e1')))  # King on e1 for White\n    black_king_safety = len(board.attackers(chess.WHITE, chess.parse_square('e8')))  # King on e8 for Black\n    return float(white_king_safety - black_king_safety)", "def feature(board: chess.Board) -> float:\n    \"Calculates the material advantage based only on queens.\"\n    white_queens = sum(9 for square in board.piece_map() if board.piece_at(square).color == chess.WHITE and board.piece_at(square).piece_type == chess.QUEEN)\n    black_queens = sum(9 for square in board.piece_map() if board.piece_at(square).color == chess.BLACK and board.piece_at(square).piece_type == chess.QUEEN)\n    return float(white_queens - black_queens)", "def feature(board: chess.Board) -> float:\n    \"Checks if either player is in check and how many checks their opponent has.\"\n    white_in_check = 1.0 if board.is_check() and board.turn else 0.0\n    black_in_check = 1.0 if board.is_check() and not board.turn else 0.0\n    return white_in_check - black_in_check", "def feature(board: chess.Board) -> float:\n    \"Evaluates the number of rook or queen pieces on open files.\"\n    file_open_count = sum(1 for file in range(8) if not any(board.piece_at(chess.square(file, rank)) for rank in range(8)))\n    return float(file_open_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the threats by counting the number of immediate attacks on pieces.\"\n    threat_count = sum(1 for square in board.piece_map() if board.is_attacked_by(not board.turn, square))\n    return float(threat_count)", "def feature(board: chess.Board) -> float:\n    \"Measures the average rank of all pieces on the board.\"\n    piece_ranks = [chess.square_rank(square) for square in board.piece_map()]\n    return float(sum(piece_ranks) / len(piece_ranks)) if piece_ranks else 0.0", "def feature(board: chess.Board) -> float:\n    \"Calculates the center control by counting the pieces in the central four squares.\"\n    center_squares = [chess.D4, chess.D5, chess.E4, chess.E5]\n    center_control = sum(1 for square in center_squares if board.piece_at(square) is not None)\n    return float(center_control)", "def feature(board: chess.Board) -> float:\n    \"Measures the difference in pawn structure by counting doubled pawns.\"\n    doubled_pawns = 0\n    pawn_files = {}\n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.PAWN:\n            file = chess.square_file(square)\n            pawn_files[file] = pawn_files.get(file, 0) + 1\n    \n    doubled_pawns = sum(max(0, count - 1) for count in pawn_files.values())\n    return float(doubled_pawns)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of pieces that are completely unprotected on the board.\"\n    unprotected_count = sum(1 for square in board.piece_map() if not board.attackers(board.piece_map()[square].color, square))\n    return float(unprotected_count)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of forks available for each player based on legal moves.\"\n    fork_count = 0\n    for move in board.legal_moves:\n        board.push(move)\n        attack_squares = set(board.attackers(not board.turn, move.to_square))\n        if len(attack_squares) > 1:  # More than one piece attacked\n            fork_count += 1\n        board.pop()\n    return float(fork_count)", "def feature(board: chess.Board) -> float:\n    \"Measures king safety by counting the number of squares around the king that are attacked.\"\n    king_square = next(square for square in board.piece_map() if board.piece_map()[square].piece_type == chess.KING)\n    attacked_count = sum(1 for square in chess.SQUARES if board.is_attacked_by(not board.turn, square) and chess.square_distance(king_square, square) <= 1)\n    return float(attacked_count)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces that are pinned (cannot move without exposing their king).\"\n    pinned_count = 0\n    for square, piece in board.piece_map().items():\n        for attacker in board.attackers(board.turn, square):\n            if board.piece_at(attacker) and board.piece_at(attacker).piece_type in [chess.ROOK, chess.QUEEN]:\n                if board.is_check():\n                    pinned_count += 1\n                break\n    return float(pinned_count)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of pieces that are on the back rank (1st rank for White, 8th for Black).\"\n    back_rank_pieces = sum(1 for square, piece in board.piece_map().items() if \n                           ((piece.color == chess.WHITE and chess.square_rank(square) == 7) or \n                            (piece.color == chess.BLACK and chess.square_rank(square) == 0)))\n    return float(back_rank_pieces)", "def feature(board: chess.Board) -> float:\n    \"Checks the number of squares controlled by each player's pieces.\"\n    white_control = len({square for piece in board.piece_map().values() if piece.color == chess.WHITE \n                          for square in board.attacks(piece.piece_type)})\n    black_control = len({square for piece in board.piece_map().values() if piece.color == chess.BLACK\n                          for square in board.attacks(piece.piece_type)})\n    control_difference = white_control - black_control\n    return float(control_difference)", "def feature(board: chess.Board) -> float:\n    \"Evaluates the material score based on a custom piece value system.\"\n    piece_values = {\n        chess.PAWN: 100,\n        chess.KNIGHT: 320,\n        chess.BISHOP: 330,\n        chess.ROOK: 500,\n        chess.QUEEN: 900,\n        chess.KING: 0,\n    }\n    material_score = sum(piece_values[piece.piece_type] * (1 if piece.color == chess.WHITE else -1) \n                         for piece in board.piece_map().values())\n    return float(material_score)", "def feature(board: chess.Board) -> float:\n    \"Measures the overall king safety by evaluating the number of squares around the king.\"\n    king_square = next((square for square, piece in board.piece_map().items() if piece.piece_type == chess.KING), None)\n    if king_square is None:\n        return float(0)\n    safe_squares = 0\n    for square in chess.SQUARES:\n        if board.is_attacked_by(not board.turn, square):\n            continue\n        if chess.square_distance(king_square, square) <= 1:\n            safe_squares += 1\n    return float(safe_squares)", "def feature(board: chess.Board) -> float:\n    \"Measures the total distance of all pieces from their home squares.\"\n    total_distance = 0\n    home_ranks = {\n        chess.WHITE: (6, 7),\n        chess.BLACK: (0, 1)\n    }\n    for square, piece in board.piece_map().items():\n        home_rank = home_ranks[piece.color][1 if piece.piece_type in [chess.KNIGHT, chess.BISHOP] else 0]\n        total_distance += chess.square_distance(square, chess.square(chess.square_file(square), home_rank))\n    return float(total_distance)", "def feature(board: chess.Board) -> float:\n    \"Calculates the total number of pieces remaining on the board for each color.\"\n    white_count = len([p for p in board.piece_map().values() if p.color == chess.WHITE])\n    black_count = len([p for p in board.piece_map().values() if p.color == chess.BLACK])\n    return float(white_count - black_count)", "def feature(board: chess.Board) -> float:\n    \"Counts the difference in the number of pieces in the opponent's half of the board.\"\n    white_pieces_in_opponent_half = len([p for sq, p in board.piece_map().items() if p.color == chess.WHITE and chess.square_rank(sq) > 3])\n    black_pieces_in_opponent_half = len([p for sq, p in board.piece_map().items() if p.color == chess.BLACK and chess.square_rank(sq) < 4])\n    return float(white_pieces_in_opponent_half - black_pieces_in_opponent_half)", "def feature(board: chess.Board) -> float:\n    \"Calculates the ratio of rooks to pawns for the player to move.\"\n    player_color = chess.WHITE if board.turn else chess.BLACK\n    rooks = sum(1 for p in board.piece_map().values() if p.color == player_color and p.piece_type == chess.ROOK)\n    pawns = sum(1 for p in board.piece_map().values() if p.color == player_color and p.piece_type == chess.PAWN)\n    return float(rooks / (pawns + 1) if pawns > 0 else rooks)", "def feature(board: chess.Board) -> float:\n    \"Measures positional advancement of pawns on the board.\"\n    white_advanced_pawns = len([p for sq, p in board.piece_map().items() if p.color == chess.WHITE and chess.square_rank(sq) > 4])\n    black_advanced_pawns = len([p for sq, p in board.piece_map().items() if p.color == chess.BLACK and chess.square_rank(sq) < 4])\n    return float(white_advanced_pawns - black_advanced_pawns)", "def feature(board: chess.Board) -> float:\n    \"Measures the central control by counting the number of pieces controlling center squares (d4, d5, e4, e5).\"\n    center_squares = [chess.D4, chess.D5, chess.E4, chess.E5]\n    white_control = sum(1 for sq in center_squares if board.is_attacked_by(chess.WHITE, sq))\n    black_control = sum(1 for sq in center_squares if board.is_attacked_by(chess.BLACK, sq))\n    return float(white_control - black_control)", "def feature(board: chess.Board) -> float:\n    \"Counts the pieces attacking the enemy king's position.\"\n    player_color = chess.WHITE if board.turn else chess.BLACK\n    enemy_king_square = next(sq for sq, p in board.piece_map().items() if p.color != player_color and p.piece_type == chess.KING)\n    attacking_pieces_count = len(board.attackers(player_color, enemy_king_square))\n    return float(attacking_pieces_count)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces pinned against the king for the current player.\"\n    player_color = board.turn\n    pinned_pieces = sum(1 for sq, p in board.piece_map().items() if p.color == player_color and len(board.attackers(not player_color, sq)) > 0)\n    return float(pinned_pieces)", "def feature(board: chess.Board) -> float:\n    \"Calculates the piece activity by summing the number of legal moves available for both sides.\"\n    white_moves = len(list(board.legal_moves)) if board.turn else 0\n    black_moves = len(list(board.legal_moves)) if not board.turn else 0\n    return float(white_moves - black_moves)", "def feature(board: chess.Board) -> float:\n    \"Measures how many pieces are on the 7th rank for both sides.\"\n    seventh_rank_whites = len([p for sq, p in board.piece_map().items() if p.color == chess.WHITE and chess.square_rank(sq) == 6])\n    seventh_rank_blacks = len([p for sq, p in board.piece_map().items() if p.color == chess.BLACK and chess.square_rank(sq) == 1])\n    return float(seventh_rank_whites - seventh_rank_blacks)", "def feature(board: chess.Board) -> float:\n    \"Calculates the total mobility of all pieces on the board.\"\n    total_mobility = sum(len(list(board.legal_moves)) for square, piece in board.piece_map().items())\n    return float(total_mobility)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of piece types present for each player.\"\n    piece_types = {piece.color: set() for piece in board.piece_map().values()}\n    for square, piece in board.piece_map().items():\n        piece_types[piece.color].add(piece.piece_type)\n    return float(len(piece_types[chess.WHITE]) - len(piece_types[chess.BLACK]))", "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in central control by counting pieces on central squares.\"\n    central_squares = [chess.D4, chess.D5, chess.E4, chess.E5]\n    white_control = sum(1 for square in central_squares if board.piece_at(square) and board.piece_at(square).color == chess.WHITE)\n    black_control = sum(1 for square in central_squares if board.piece_at(square) and board.piece_at(square).color == chess.BLACK)\n    return float(white_control - black_control)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pinned pieces for each color.\"\n    pinned_count = 0\n    for square, piece in board.piece_map().items():\n        if board.is_attacked_by(not piece.color, square) and board.is_check():\n            pinned_count += 1\n    return float(pinned_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the combined value of pieces that are on the 7th rank for both players.\"\n    value = 0\n    for square, piece in board.piece_map().items():\n        if chess.square_rank(square) == 6:  # 7th rank for White\n            value += piece.piece_type if piece.color == chess.WHITE else -piece.piece_type\n    return float(value)", "def feature(board: chess.Board) -> float:\n    \"Measures the mobility of the opponent's pieces by calculating their potential moves.\"\n    opponent_color = not board.turn\n    mobility = sum(len(list(board.legal_moves)) for square, piece in board.piece_map().items() if piece.color == opponent_color)\n    return float(mobility)", "def feature(board: chess.Board) -> float:\n    \"Measures the safety of the kings based on the number of attackers.\"\n    white_king_square = board.king(chess.WHITE)\n    black_king_square = board.king(chess.BLACK)\n    white_king_attackers = len(board.attackers(chess.BLACK, white_king_square))\n    black_king_attackers = len(board.attackers(chess.WHITE, black_king_square))\n    return float(white_king_attackers - black_king_attackers)", "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in piece mobility between both players.\"\n    white_mobility = len(list(board.legal_moves)) if board.turn else 0\n    black_mobility = len(list(board.legal_moves)) if not board.turn else 0\n    return float(white_mobility - black_mobility)", "def feature(board: chess.Board) -> float:\n    \"Measures the total number of defending pieces around each king.\"\n    white_king_square = board.king(chess.WHITE)\n    black_king_square = board.king(chess.BLACK)\n    white_defenders = sum(1 for sq in board.piece_map() if board.is_attacked_by(chess.BLACK, sq) and board.piece_at(sq).color == chess.WHITE)\n    black_defenders = sum(1 for sq in board.piece_map() if board.is_attacked_by(chess.WHITE, sq) and board.piece_at(sq).color == chess.BLACK)\n    return float(white_defenders - black_defenders)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces that are on open files.\"\n    open_files = 0\n    for file in range(8):\n        if all(board.piece_at(chess.square(file, rank)) is None for rank in range(8)):\n            open_files += 1\n    return float(open_files)", "def feature(board: chess.Board) -> float:\n    \"Calculates the distance of the closest enemy piece to the king.\"\n    white_king_square = board.king(chess.WHITE)\n    black_king_square = board.king(chess.BLACK)\n    closest_white_distance = min(chess.square_distance(white_king_square, sq) for sq in board.piece_map() if board.piece_at(sq).color == chess.BLACK)\n    closest_black_distance = min(chess.square_distance(black_king_square, sq) for sq in board.piece_map() if board.piece_at(sq).color == chess.WHITE)\n    return float(closest_white_distance - closest_black_distance)", "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in the number of pawns in the center.\"\n    white_center_pawns = sum(1 for sq in (chess.D4, chess.D5, chess.E4, chess.E5) if board.piece_at(sq) and board.piece_at(sq).piece_type == chess.PAWN and board.piece_at(sq).color == chess.WHITE)\n    black_center_pawns = sum(1 for sq in (chess.D4, chess.D5, chess.E4, chess.E5) if board.piece_at(sq) and board.piece_at(sq).piece_type == chess.PAWN and board.piece_at(sq).color == chess.BLACK)\n    return float(white_center_pawns - black_center_pawns)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of pieces that are hanging.\"\n    hanging_pieces_count = sum(1 for sq, piece in board.piece_map().items() if board.is_attacked_by(not piece.color, sq) and piece.color == board.turn)\n    return float(hanging_pieces_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the total attacking potential for each side by summing the pieces attacking opponent's pawns.\"\n    white_attacks = sum(len(board.attackers(chess.WHITE, square)) for square in board.piece_map() if board.piece_at(square).piece_type == chess.PAWN and board.piece_at(square).color == chess.BLACK)\n    black_attacks = sum(len(board.attackers(chess.BLACK, square)) for square in board.piece_map() if board.piece_at(square).piece_type == chess.PAWN and board.piece_at(square).color == chess.WHITE)\n    result = white_attacks - black_attacks\n    return float(result)", "def feature(board: chess.Board) -> float:\n    \"Counts the total number of pieces in each player's back rank to assess safety.\"\n    white_back_rank = sum(1 for sq in range(chess.A1, chess.H1 + 1) if board.piece_at(sq) and board.piece_at(sq).color == chess.WHITE)\n    black_back_rank = sum(1 for sq in range(chess.A8, chess.H8 + 1) if board.piece_at(sq) and board.piece_at(sq).color == chess.BLACK)\n    result = white_back_rank - black_back_rank\n    return float(result)", "def feature(board: chess.Board) -> float:\n    \"Calculates the ratio of pieces on the board to total possible pieces for both sides.\"\n    total_pieces = 32  # 16 for each side\n    white_pieces = len([p for p in board.piece_map().values() if p.color == chess.WHITE])\n    black_pieces = len([p for p in board.piece_map().values() if p.color == chess.BLACK])\n    piece_ratio = (white_pieces + black_pieces) / total_pieces\n    result = piece_ratio\n    return float(result)", "def feature(board: chess.Board) -> float:\n    \"Measures piece mobility by counting the number of legal moves for all pieces on the board.\"\n    mobility = sum(len(list(board.legal_moves)) for sq in board.piece_map())\n    result = mobility\n    return float(result)", "def feature(board: chess.Board) -> float:\n    \"Calculates the average distance of all pieces from their opponent's back rank to assess offensive potential.\"\n    white_avg_distance = sum(chess.square_rank(sq) for sq in board.piece_map() if board.piece_at(sq).color == chess.WHITE) / len([1 for sq in board.piece_map() if board.piece_at(sq).color == chess.WHITE])\n    black_avg_distance = sum(7 - chess.square_rank(sq) for sq in board.piece_map() if board.piece_at(sq).color == chess.BLACK) / len([1 for sq in board.piece_map() if board.piece_at(sq).color == chess.BLACK])\n    result = white_avg_distance - black_avg_distance\n    return float(result)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pawn chains (connected pawns) on the board for both sides.\"\n    def count_chains(color):\n        pawns = [sq for sq in board.piece_map() if board.piece_at(sq).color == color and board.piece_at(sq).piece_type == chess.PAWN]\n        chains = 0\n        while pawns:\n            current_chain = [pawns.pop()]\n            while current_chain:\n                current = current_chain.pop()\n                for direction in (-1, 1):\n                    neighbor = current + direction\n                    if neighbor in pawns:\n                        current_chain.append(neighbor)\n                        pawns.remove(neighbor)\n            chains += 1\n        return chains\n\n    white_chains = count_chains(chess.WHITE)\n    black_chains = count_chains(chess.BLACK)\n    result = white_chains - black_chains\n    return float(result)", "def feature(board: chess.Board) -> float:\n    \"Measures the center control of pawns by counting the number of pawns in central squares.\"\n    central_squares = [chess.D4, chess.D5, chess.E4, chess.E5]\n    pawn_control = sum(1 for sq in central_squares if board.piece_at(sq) and board.piece_at(sq).piece_type == chess.PAWN)\n    return float(pawn_control)", "def feature(board: chess.Board) -> float:\n    \"Calculates the material value difference between pieces on the board.\"\n    piece_values = {chess.PAWN: 100, chess.KNIGHT: 320, chess.BISHOP: 330, chess.ROOK: 500, chess.QUEEN: 900, chess.KING: 0}\n    white_value = sum(piece_values[piece.piece_type] for piece in board.piece_map().values() if piece.color == chess.WHITE)\n    black_value = sum(piece_values[piece.piece_type] for piece in board.piece_map().values() if piece.color == chess.BLACK)\n    return float(white_value - black_value)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces pinned by the opponent's pieces.\"\n    pinned_pieces = 0\n    for square in board.piece_map():\n        piece = board.piece_at(square)\n        if piece and piece.color == board.turn:\n            for attacker in board.attackers(not board.turn, square):\n                if board.is_attacked_by(board.turn, attacker):\n                    pinned_pieces += 1\n                    break\n    return float(pinned_pieces)", "def feature(board: chess.Board) -> float:\n    \"Counts the total number of pieces remaining for each player and computes their ratio.\"\n    white_piece_count = len([piece for piece in board.piece_map().values() if piece.color == chess.WHITE])\n    black_piece_count = len([piece for piece in board.piece_map().values() if piece.color == chess.BLACK])\n    return float(white_piece_count / (black_piece_count + 1e-10))  # Avoid division by zero", "def feature(board: chess.Board) -> float:\n    \"Measures the presence of threats by counting how many pieces can capture opponent pieces next turn.\"\n    threat_count = sum(1 for move in board.legal_moves if board.is_attacked_by(not board.turn, move.to_square))\n    return float(threat_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in pawn structure based on the number of isolated pawns for both players.\"\n    isolated_pawns = 0\n    for file in range(8):\n        if (board.piece_at(chess.square(file, 1)) is not None and\n            board.piece_at(chess.square(file, 1)).piece_type == chess.PAWN and\n            (board.piece_at(chess.square(file - 1, 1)) is None and board.piece_at(chess.square(file + 1, 1)) is None)):\n            isolated_pawns += 1\n    return float(isolated_pawns)", "def feature(board: chess.Board) -> float:\n    \"Counts the total number of attacks on the kings to evaluate king safety.\"\n    white_king_square = board.king(chess.WHITE)\n    black_king_square = board.king(chess.BLACK)\n    white_attacks = sum(board.is_attacked_by(chess.WHITE, sq) for sq in chess.SQUARES)\n    black_attacks = sum(board.is_attacked_by(chess.BLACK, sq) for sq in chess.SQUARES)\n    return float(white_attacks + black_attacks)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of piece pins to determine tactical strength.\"\n    pinned_pieces = 0\n    for square in chess.SQUARES:\n        piece = board.piece_at(square)\n        if piece and piece.color == board.turn:\n            for move in board.legal_moves:\n                if move.from_square == square:\n                    if board.is_attacked_by(not piece.color, move.to_square):\n                        pinned_pieces += 1\n                        break\n    return float(pinned_pieces)", "def feature(board: chess.Board) -> float:\n    \"Calculates the average mobility of pieces on the board.\"\n    total_mobility = 0\n    piece_count = 0\n    for piece in board.piece_map().values():\n        legal_moves_count = len(list(board.legal_moves))\n        total_mobility += legal_moves_count\n        piece_count += 1\n    return total_mobility / piece_count if piece_count > 0 else 0.0", "def feature(board: chess.Board) -> float:\n    \"Measures the control of the center squares by counting attacks.\"\n    center_squares = [chess.E4, chess.E5, chess.D4, chess.D5]\n    center_control = sum(board.is_attacked_by(chess.WHITE, sq) for sq in center_squares) - \\\n                    sum(board.is_attacked_by(chess.BLACK, sq) for sq in center_squares)\n    return float(center_control)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of isolated pawns for both sides.\"\n    isolated_pawns = 0\n    for square in chess.SQUARES:\n        pawn = board.piece_at(square)\n        if pawn and pawn.piece_type == chess.PAWN:\n            if (board.piece_at(square - 1) is None and board.piece_at(square + 1) is None):\n                isolated_pawns += 1\n    return float(isolated_pawns)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of double pawns on the board.\"\n    double_pawns = 0\n    board_state = {}\n    for square in chess.SQUARES:\n        pawn = board.piece_at(square)\n        if pawn and pawn.piece_type == chess.PAWN:\n            file = chess.square_file(square)\n            if file not in board_state:\n                board_state[file] = 0\n            board_state[file] += 1\n            \n    for count in board_state.values():\n        if count > 1:\n            double_pawns += count - 1\n            \n    return float(double_pawns)", "def feature(board: chess.Board) -> float:\n    \"Calculates the variance of piece values on the board.\"\n    piece_values = {chess.PAWN: 100, chess.KNIGHT: 320, chess.BISHOP: 330,\n                    chess.ROOK: 500, chess.QUEEN: 900, chess.KING: 20000}\n    values = []\n    for piece in board.piece_map().values():\n        values.append(piece_values[piece.piece_type] * (1 if piece.color == chess.WHITE else -1))\n    mean_value = sum(values) / (len(values) if values else 1)\n    variance = sum((x - mean_value) ** 2 for x in values) / (len(values) if values else 1)\n    return float(variance)", "def feature(board: chess.Board) -> float:\n    \"Measures the total mobility of pieces by counting the number of legal moves for each player.\"\n    mobility_white = len([move for move in board.legal_moves if board.turn])\n    mobility_black = len([move for move in board.legal_moves if not board.turn])\n    return float(mobility_white - mobility_black)", "def feature(board: chess.Board) -> float:\n    \"Calculates the central control by counting the number of pieces in the central squares.\"\n    central_squares = [chess.E4, chess.E5, chess.D4, chess.D5]\n    control_white = sum(1 for sq in central_squares if board.piece_at(sq) and board.piece_at(sq).color == chess.WHITE)\n    control_black = sum(1 for sq in central_squares if board.piece_at(sq) and board.piece_at(sq).color == chess.BLACK)\n    return float(control_white - control_black)", "def feature(board: chess.Board) -> float:\n    \"Evaluates material safety by counting pieces that are not defending each other.\"\n    unsafe_pieces = 0\n    for square, piece in board.piece_map().items():\n        defenders = board.attackers(piece.color, square)\n        if not defenders:\n            unsafe_pieces += 1\n    return float(unsafe_pieces)", "def feature(board: chess.Board) -> float:\n    \"Measures the king's distance from the center of the board to assess safety.\"\n    king_square = next((sq for sq, piece in board.piece_map().items() if piece.piece_type == chess.KING), None)\n    if king_square is None:\n        return 0.0\n    center_squares = [chess.E4, chess.E5, chess.D4, chess.D5]\n    distance_to_center = min(chess.square_distance(king_square, cs) for cs in center_squares)\n    return float(10 - distance_to_center)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of doubled pawns for both players.\"\n    doubled_pawns = 0\n    for file in range(8):\n        white_pawns = sum(1 for rank in range(8) if board.piece_at(chess.square(file, rank)) == chess.PAWN and board.piece_at(chess.square(file, rank)).color == chess.WHITE)\n        black_pawns = sum(1 for rank in range(8) if board.piece_at(chess.square(file, rank)) == chess.PAWN and board.piece_at(chess.square(file, rank)).color == chess.BLACK)\n        if white_pawns > 1:\n            doubled_pawns += 1\n        if black_pawns > 1:\n            doubled_pawns += 1\n    return float(doubled_pawns)", "def feature(board: chess.Board) -> float:\n    \"Calculates the total number of potential discovered checks on the board.\"\n    discovered_checks = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == board.turn:\n            for move in board.legal_moves:\n                if move.from_square == square and board.is_check():\n                    discovered_checks += 1\n    return float(discovered_checks)", "def feature(board: chess.Board) -> float:\n    \"Evaluates pawn structure by counting isolated pawns.\"\n    isolated_pawns = 0\n    for file in range(8):\n        has_pawn = False\n        for rank in range(8):\n            if board.piece_at(chess.square(file, rank)) == chess.PAWN:\n                has_pawn = True\n                if (file > 0 and board.piece_at(chess.square(file - 1, rank)) != chess.PAWN) and (file < 7 and board.piece_at(chess.square(file + 1, rank)) != chess.PAWN):\n                    isolated_pawns += 1\n        has_pawn = False\n    return float(isolated_pawns)", "def feature(board: chess.Board) -> float:\n    \"Measures the total number of threats (pieces that can capture in one move) for each player.\"\n    threats_white = sum(1 for square in board.piece_map() if board.piece_map()[square].color == chess.WHITE and board.is_attacked_by(chess.BLACK, square))\n    threats_black = sum(1 for square in board.piece_map() if board.piece_map()[square].color == chess.BLACK and board.is_attacked_by(chess.WHITE, square))\n    return float(threats_white - threats_black)", "def feature(board: chess.Board) -> float:\n    \"Calculates the variance of pieces' distances from their home ranks as a measure of position strength.\"\n    distances = []\n    for square, piece in board.piece_map().items():\n        rank_distance = chess.square_rank(square) if piece.color == chess.WHITE else 7 - chess.square_rank(square)\n        distances.append(rank_distance)\n    if not distances:\n        return 0.0\n    return float(sum(distances) / len(distances))", "def feature(board: chess.Board) -> float:\n    \"Measures the total number of squares attacked by all pieces on the board.\"\n    total_attacks = sum(len(board.attackers(piece.color, square)) for square, piece in board.piece_map().items())\n    return float(total_attacks)", "def feature(board: chess.Board) -> float:\n    \"Computes the imbalance of minor pieces (knights and bishops) for both players.\"\n    white_minor = sum(piece.piece_type == chess.KNIGHT or piece.piece_type == chess.BISHOP for piece in board.piece_map().values() if piece.color == chess.WHITE)\n    black_minor = sum(piece.piece_type == chess.KNIGHT or piece.piece_type == chess.BISHOP for piece in board.piece_map().values() if piece.color == chess.BLACK)\n    return float(white_minor - black_minor)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pawns in the last two ranks for each player.\"\n    white_pawns = sum(1 for square in range(48, 56) if board.piece_at(square) == chess.PAWN)\n    black_pawns = sum(1 for square in range(8, 16) if board.piece_at(square) == chess.PAWN)\n    return float(white_pawns - black_pawns)", "def feature(board: chess.Board) -> float:\n    \"Calculates the distance from the king to the nearest enemy piece threatening it.\"\n    king_square = next(square for square, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color == board.turn)\n    threats = [chess.square_distance(king_square, square) for square in board.piece_map() if board.is_attacked_by(not board.turn, square)]\n    return float(min(threats)) if threats else float('inf')", "def feature(board: chess.Board) -> float:\n    \"Measures the number of pieces on the board with zero mobility (no legal moves).\"\n    immobile_count = sum(1 for piece in board.piece_map().values() if not list(board.legal_moves) and piece.color == board.turn)\n    return float(immobile_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of squares controlled by pawns (either protected or attacking).\"\n    controlled_squares = sum(1 for square in board.piece_map() if board.piece_at(square) == chess.PAWN and square in board.attackers(chess.WHITE, square) or square in board.attackers(chess.BLACK, square))\n    return float(controlled_squares)", "def feature(board: chess.Board) -> float:\n    \"Computes the total value of pieces that are pinned (immobilized by a threat).\"\n    pinned_value = 0\n    for square, piece in board.piece_map().items():\n        if board.is_attacked_by(not piece.color, square):\n            pinned_value += piece.piece_type  # Assuming a value mapping of piece types\n    return float(pinned_value)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces each player has in the outside ranks (the opponent's first rank).\"\n    white_outside = sum(1 for square in range(56, 64) if board.piece_at(square) is not None and board.piece_at(square).color == chess.WHITE)\n    black_outside = sum(1 for square in range(0, 8) if board.piece_at(square) is not None and board.piece_at(square).color == chess.BLACK)\n    return float(white_outside - black_outside)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of major pieces (rooks and queens) on the seventh rank.\"\n    white_major = sum(1 for square in range(56, 64) if board.piece_at(square) and board.piece_at(square).color == chess.WHITE and (board.piece_at(square).piece_type == chess.ROOK or board.piece_at(square).piece_type == chess.QUEEN))\n    black_major = sum(1 for square in range(0, 8) if board.piece_at(square) and board.piece_at(square).color == chess.BLACK and (board.piece_at(square).piece_type == chess.ROOK or board.piece_at(square).piece_type == chess.QUEEN))\n    return float(white_major - black_major)", "def feature(board: chess.Board) -> float:\n    \"Measures the difference in mobility by counting the number of legal moves available for each player.\"\n    white_moves = sum(1 for _ in board.legal_moves if board.turn)\n    board.turn = not board.turn\n    black_moves = sum(1 for _ in board.legal_moves if not board.turn)\n    board.turn = not board.turn\n    return float(white_moves - black_moves)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of pieces that are unprotected or attacked by the opponent's pieces.\"\n    unprotected_pieces = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == board.turn and not board.is_attacked_by(not board.turn, square):\n            unprotected_pieces += 1\n    return float(unprotected_pieces)", "def feature(board: chess.Board) -> float:\n    \"Measures the distance of the king from the center of the board, penalizing distant king positions.\"\n    king_square = next(square for square in board.piece_map() if board.piece_at(square).piece_type == chess.KING and board.piece_at(square).color == board.turn)\n    center_squares = [chess.square_name(square) for square in [chess.D4, chess.D5, chess.E4, chess.E5]]\n    return float(chess.square_distance(king_square, chess.D4) + chess.square_distance(king_square, chess.D5) + \n                 chess.square_distance(king_square, chess.E4) + chess.square_distance(king_square, chess.E5))", "def feature(board: chess.Board) -> float:\n    \"Calculates material imbalance focusing on the least valuable piece each player possesses.\"\n    white_least_value = float('inf')\n    black_least_value = float('inf')\n    for square, piece in board.piece_map().items():\n        if piece.color == chess.WHITE:\n            white_least_value = min(white_least_value, piece.piece_type)\n        else:\n            black_least_value = min(black_least_value, piece.piece_type)\n    return float(white_least_value - black_least_value)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pawns each side has on the 7th rank, indicating potential promotion threats.\"\n    white_pawns_on_seventh = sum(1 for square in board.piece_map() if board.piece_at(square).piece_type == chess.PAWN and \n                                  board.piece_at(square).color == chess.WHITE and chess.square_rank(square) == 6)\n    black_pawns_on_seventh = sum(1 for square in board.piece_map() if board.piece_at(square).piece_type == chess.PAWN and \n                                  board.piece_at(square).color == chess.BLACK and chess.square_rank(square) == 1)\n    return float(white_pawns_on_seventh - black_pawns_on_seventh)", "def feature(board: chess.Board) -> float:\n    \"Measures the control of the center squares (d4, d5, e4, e5) by counting how many pieces are occupying or attacking them.\"\n    center_squares = [chess.D4, chess.D5, chess.E4, chess.E5]\n    control_score = sum(1 for square in center_squares if board.is_attacked_by(chess.WHITE, square)) - sum(1 for square in center_squares if board.is_attacked_by(chess.BLACK, square))\n    return float(control_score)", "def feature(board: chess.Board) -> float:\n    \"Counts the total number of pieces each side has and returns the ratio of pieces present.\"\n    white_piece_count = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE)\n    black_piece_count = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK)\n    if black_piece_count == 0:\n        return float('inf')\n    return float(white_piece_count / black_piece_count)", "def feature(board: chess.Board) -> float:\n    \"Checks for any potential immediate threats by counting pieces that can deliver check in the next move.\"\n    threats = sum(1 for move in board.legal_moves if board.piece_at(move.to_square) is not None and \n                  board.piece_at(move.to_square).piece_type == chess.KING and board.is_check())\n    return float(threats)", "def feature(board: chess.Board) -> float:\n    \"Measures the average distance of pieces from the opponent's back rank, rewarding pieces closer to promotion.\"\n    total_distance = 0\n    piece_count = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == board.turn:\n            distance_to_back_rank = 7 - chess.square_rank(square) if piece.color == chess.WHITE else chess.square_rank(square)\n            total_distance += distance_to_back_rank\n            piece_count += 1\n    return float(total_distance / piece_count) if piece_count > 0 else 0.0", "def feature(board: chess.Board) -> float:\n    \"Calculates the central control score by counting the number of pieces in the central squares (d4, d5, e4, e5).\"\n    central_squares = [chess.D4, chess.D5, chess.E4, chess.E5]\n    central_control = sum(1 for square in central_squares if board.piece_at(square) is not None)\n    return float(central_control)", "def feature(board: chess.Board) -> float:\n    \"Evaluates the king safety by counting the number of squares around the king that are attacked by the opponent.\"\n    king_square = next(square for square in board.piece_map() if board.piece_map()[square].piece_type == chess.KING)\n    attacked_squares = sum(1 for square in chess.SQUARES if board.is_attacked_by(not board.turn, square))\n    return float(attacked_squares)", "def feature(board: chess.Board) -> float:\n    \"Measures the distance of the closest opponent's piece to the player's king.\"\n    king_square = next(square for square in board.piece_map() if board.piece_map()[square].piece_type == chess.KING and board.piece_map()[square].color == board.turn)\n    nearest_opponent_distance = min([chess.square_distance(king_square, square) for square, piece in board.piece_map().items() if piece.color != board.turn], default=9)\n    return float(nearest_opponent_distance)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pawns each player has potentially reached promotion, considering their rank.\"\n    white_pawn_promotion = sum(1 for square, piece in board.piece_map().items() if piece.color == chess.WHITE and piece.piece_type == chess.PAWN and chess.square_rank(square) == 6)\n    black_pawn_promotion = sum(1 for square, piece in board.piece_map().items() if piece.color == chess.BLACK and piece.piece_type == chess.PAWN and chess.square_rank(square) == 1)\n    return float(white_pawn_promotion - black_pawn_promotion)", "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in the number of pieces actively pinned against the opponent's king.\"\n    pinned_white = sum(1 for square in board.piece_map() if board.piece_map()[square].color == chess.WHITE and board.is_attacked_by(chess.BLACK, square))\n    pinned_black = sum(1 for square in board.piece_map() if board.piece_map()[square].color == chess.BLACK and board.is_attacked_by(chess.WHITE, square))\n    return float(pinned_white - pinned_black)", "def feature(board: chess.Board) -> float:\n    \"Measures the total number of unprotected pieces on the board for both players.\"\n    unprotected_white = sum(1 for square, piece in board.piece_map().items() if piece.color == chess.WHITE and len(board.attackers(chess.BLACK, square)) == 0)\n    unprotected_black = sum(1 for square, piece in board.piece_map().items() if piece.color == chess.BLACK and len(board.attackers(chess.WHITE, square)) == 0)\n    return float(unprotected_white - unprotected_black)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of potential checks available for both players' pieces.\"\n    check_count = sum(1 for move in board.legal_moves if board.is_check())\n    return float(check_count)", "def feature(board: chess.Board) -> float:\n    \"Evaluates the number of pieces that are currently on the back rank for each player.\"\n    back_rank_white = sum(1 for square, piece in board.piece_map().items() if piece.color == chess.WHITE and chess.square_rank(square) == 0)\n    back_rank_black = sum(1 for square, piece in board.piece_map().items() if piece.color == chess.BLACK and chess.square_rank(square) == 7)\n    return float(back_rank_white - back_rank_black) ", "def feature(board: chess.Board) -> float:\n    \"Measures the difference in piece types discrepancy, especially focusing on heavier pieces like rooks and queens.\"\n    heavy_white = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE and piece.piece_type in [chess.ROOK, chess.QUEEN])\n    heavy_black = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK and piece.piece_type in [chess.ROOK, chess.QUEEN])\n    return float(heavy_white - heavy_black)", "def feature(board: chess.Board) -> float:\n    \"Measures the total number of double pawns on the board.\"\n    double_pawn_count = 0\n    for file in range(8):\n        pawns_in_file = [sq for sq in range(8) if board.piece_at(chess.square(file, sq)) and board.piece_at(chess.square(file, sq)).piece_type == chess.PAWN]\n        if len(pawns_in_file) > 1:\n            double_pawn_count += len(pawns_in_file) - 1\n    return float(double_pawn_count)", "def feature(board: chess.Board) -> float:\n    \"Measures the pawn structure by counting isolated pawns.\"\n    isolated_pawn_count = 0\n    for square in board.piece_map():\n        if board.piece_at(square).piece_type == chess.PAWN:\n            file = chess.square_file(square)\n            # Check neighboring files for other pawns\n            if not (board.piece_at(chess.square(file - 1, chess.square_rank(square))) and\n                    board.piece_at(chess.square(file + 1, chess.square_rank(square)))):\n                isolated_pawn_count += 1\n    return float(isolated_pawn_count)", "def feature(board: chess.Board) -> float:\n    \"Measures the average distance of pieces from the center of the board.\"\n    center_squares = [chess.E4, chess.D4, chess.E5, chess.D5]\n    total_distance = 0\n    piece_count = 0\n    for square, piece in board.piece_map().items():\n        total_distance += min(chess.square_distance(square, csq) for csq in center_squares)\n        piece_count += 1\n    return total_distance / piece_count if piece_count > 0 else 0.0", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of open files for both players.\"\n    open_file_count = 0\n    for file in range(8):\n        if all(board.piece_at(chess.square(file, rank)) is None for rank in range(8)):\n            open_file_count += 1\n    return float(open_file_count)", "def feature(board: chess.Board) -> float:\n    \"Measures the safety of the king by counting the number of squares it can move to that are not attacked.\"\n    king_square = board.king(board.turn)\n    safe_move_count = 0\n    for move in board.legal_moves:\n        if move.from_square == king_square:\n            if not board.is_attacked_by(not board.turn, move.to_square):\n                safe_move_count += 1\n    return float(safe_move_count)", "def feature(board: chess.Board) -> float:\n    \"Counts how many pieces are aligned (same rank/file/diagonal) with the enemy king.\"\n    enemy_king_square = board.king(not board.turn)\n    aligned_count = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == board.turn:\n            if (chess.square_file(square) == chess.square_file(enemy_king_square) or\n                chess.square_rank(square) == chess.square_rank(enemy_king_square) or\n                chess.square_distance(square, enemy_king_square) in [1, 2]):  # Check diagonals up to 2 spaces\n                aligned_count += 1\n    return float(aligned_count)", "def feature(board: chess.Board) -> float:\n    \"Assesses the overall activity of pieces by counting the number of legal moves for each player.\"\n    white_moves = len(list(board.legal_moves)) if board.turn == chess.WHITE else 0\n    black_moves = len(list(board.legal_moves)) if board.turn == chess.BLACK else 0\n    return float(white_moves - black_moves)", "def feature(board: chess.Board) -> float:\n    \"Measures the total number of pawn moves made by both players.\"\n    pawn_move_count = 0\n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.PAWN:\n            pawn_move_count += board.halfmove_clock  # Using halfmove clock as an approximation of moves\n    return float(pawn_move_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of pieces in each player's back rank.\"\n    back_rank_count_white = sum(1 for sq in range(8) if board.piece_at(chess.square(sq, 0)) and board.piece_at(chess.square(sq, 0)).color == chess.WHITE)\n    back_rank_count_black = sum(1 for sq in range(8) if board.piece_at(chess.square(sq, 7)) and board.piece_at(chess.square(sq, 7)).color == chess.BLACK)\n    return float(back_rank_count_white - back_rank_count_black)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of pawns each side has on the board.\"\n    white_pawns = len([p for p in board.piece_map().values() if p.color == chess.WHITE and p.piece_type == chess.PAWN])\n    black_pawns = len([p for p in board.piece_map().values() if p.color == chess.BLACK and p.piece_type == chess.PAWN])\n    return float(white_pawns - black_pawns)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of major pieces (rooks and queens) for each side.\"\n    white_major_pieces = sum(1 for p in board.piece_map().values() if p.color == chess.WHITE and p.piece_type in {chess.ROOK, chess.QUEEN})\n    black_major_pieces = sum(1 for p in board.piece_map().values() if p.color == chess.BLACK and p.piece_type in {chess.ROOK, chess.QUEEN})\n    return float(white_major_pieces - black_major_pieces)", "def feature(board: chess.Board) -> float:\n    \"Evaluates the activity of knights based on the number of moves they can make.\"\n    knight_moves = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == board.turn and piece.piece_type == chess.KNIGHT:\n            knight_moves += len(list(board.legal_moves))  # Count legal moves for each knight\n    return float(knight_moves)", "def feature(board: chess.Board) -> float:\n    \"Measures the difference in the number of threatened pieces for both players.\"\n    white_threats = sum(1 for square in board.piece_map() if board.is_attacked_by(chess.WHITE, square))\n    black_threats = sum(1 for square in board.piece_map() if board.is_attacked_by(chess.BLACK, square))\n    return float(white_threats - black_threats)", "def feature(board: chess.Board) -> float:\n    \"Calculates the average distance of pieces from the center of the board.\"\n    total_distance = 0\n    piece_count = 0\n    for square, piece in board.piece_map().items():\n        distance = chess.square_distance(square, chess.E4) + chess.square_distance(square, chess.E5)  # Center squares\n        total_distance += distance\n        piece_count += 1\n    return total_distance / piece_count if piece_count > 0 else 0.0", "def feature(board: chess.Board) -> float:\n    \"Counts the total number of pawns on the board for both colors.\"\n    pawns_count = sum(1 for piece in board.piece_map().values() if piece.piece_type == chess.PAWN)\n    return float(pawns_count)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of squares with pieces that can move in one turn.\"\n    movable_pieces_count = sum(1 for move in board.legal_moves)\n    return float(movable_pieces_count)", "def feature(board: chess.Board) -> float:\n    \"Evaluates the number of pieces being attacked and not defended.\"\n    attacks_not_defended = sum(1 for square in board.piece_map() if board.is_attacked_by(chess.WHITE, square) and not board.attackers(chess.BLACK, square))\n    return float(attacks_not_defended)", "def feature(board: chess.Board) -> float:\n    \"Calculates the overall mobility by counting all possible legal moves for both players.\"\n    mobility = len(list(board.legal_moves))\n    return float(mobility)", "def feature(board: chess.Board) -> float:\n    \"Measures the total value of pieces that are pinned.\"\n    pinned_value = sum(piece.piece_type for square, piece in board.piece_map().items() if board.is_attacked_by(chess.WHITE, square) and board.is_check())\n    return float(pinned_value)", "def feature(board: chess.Board) -> float:\n    \"Evaluates the presence of major pieces (rooks and queens) on the seventh rank.\"\n    major_pieces_seventh_rank = sum(1 for square, piece in board.piece_map().items() if (piece.piece_type in {chess.ROOK, chess.QUEEN}) and chess.square_rank(square) == 6)\n    return float(major_pieces_seventh_rank)", "def feature(board: chess.Board) -> float:\n    \"Calculates whether there is a potential for promotion by counting the number of pawns on the board.\"\n    promotion_threat = sum(1 for square, piece in board.piece_map().items() if piece.piece_type == chess.PAWN and ((piece.color == chess.WHITE and chess.square_rank(square) == 6) or (piece.color == chess.BLACK and chess.square_rank(square) == 1)))\n    return float(promotion_threat)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of pieces surrounded on all four sides.\"\n    surrounded_pieces = sum(1 for square, piece in board.piece_map().items() if piece.color == chess.WHITE and all(board.is_attacked_by(chess.BLACK, sq) for sq in chess.SQUARES if chess.square_distance(square, sq) == 1))\n    return float(surrounded_pieces)", "def feature(board: chess.Board) -> float:\n    \"Calculates the sum of the ranks occupied by each player's pawns, reflecting their advancement.\"\n    white_pawn_ranks = sum(chess.square_rank(square) for square in board.piece_map() if board.piece_at(square).piece_type == chess.PAWN and board.piece_at(square).color == chess.WHITE)\n    black_pawn_ranks = sum(chess.square_rank(square) for square in board.piece_map() if board.piece_at(square).piece_type == chess.PAWN and board.piece_at(square).color == chess.BLACK)\n    return float(white_pawn_ranks - black_pawn_ranks)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces on different color squares for both players.\"\n    white_count_light = len([sq for sq in board.piece_map() if board.piece_at(sq).color == chess.WHITE and (chess.square_file(sq) + chess.square_rank(sq)) % 2 == 0])\n    white_count_dark = len([sq for sq in board.piece_map() if board.piece_at(sq).color == chess.WHITE and (chess.square_file(sq) + chess.square_rank(sq)) % 2 == 1])\n    black_count_light = len([sq for sq in board.piece_map() if board.piece_at(sq).color == chess.BLACK and (chess.square_file(sq) + chess.square_rank(sq)) % 2 == 0])\n    black_count_dark = len([sq for sq in board.piece_map() if board.piece_at(sq).color == chess.BLACK and (chess.square_file(sq) + chess.square_rank(sq)) % 2 == 1])\n    return float((white_count_light + white_count_dark) - (black_count_light + black_count_dark))", "def feature(board: chess.Board) -> float:\n    \"Evaluates the presence of pieces in key central squares (d4, d5, e4, e5).\"\n    central_squares = [chess.parse_square('d4'), chess.parse_square('d5'), chess.parse_square('e4'), chess.parse_square('e5')]\n    central_control = sum(1 if board.piece_at(sq) is not None else 0 for sq in central_squares)\n    return float(central_control)", "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in material value for pieces on the board.\"\n    piece_values = {chess.PAWN: 100, chess.KNIGHT: 320, chess.BISHOP: 330, chess.ROOK: 500, chess.QUEEN: 900, chess.KING: 0}\n    white_value = sum(piece_values[board.piece_at(square).piece_type] for square in board.piece_map() if board.piece_at(square).color == chess.WHITE)\n    black_value = sum(piece_values[board.piece_at(square).piece_type] for square in board.piece_map() if board.piece_at(square).color == chess.BLACK)\n    return float(white_value - black_value)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of undefended pieces for each player.\"\n    undefended_count = 0\n    for square in board.piece_map():\n        piece = board.piece_at(square)\n        if piece is not None:\n            attackers = board.attackers(not piece.color, square)\n            if not attackers:\n                undefended_count += 1\n    return float(undefended_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the distance in squares to the opponent's king for the most advanced piece of each side.\"\n    white_king_square = next((sq for sq in board.piece_map() if board.piece_at(sq).color == chess.WHITE and board.piece_at(sq).piece_type == chess.KING), None)\n    black_king_square = next((sq for sq in board.piece_map() if board.piece_at(sq).color == chess.BLACK and board.piece_at(sq).piece_type == chess.KING), None)\n    if white_king_square is None or black_king_square is None:\n        return 0.0\n    distance = chess.square_distance(white_king_square, black_king_square)\n    return float(distance)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces within the opponent's territory and returns the difference.\"\n    white_pieces_in_enemy_half = sum(1 for square, piece in board.piece_map().items() if piece.color == chess.WHITE and chess.square_rank(square) > 3)\n    black_pieces_in_enemy_half = sum(1 for square, piece in board.piece_map().items() if piece.color == chess.BLACK and chess.square_rank(square) < 4)\n    return float(white_pieces_in_enemy_half - black_pieces_in_enemy_half)", "def feature(board: chess.Board) -> float:\n    \"Evaluates the potential threats by counting the number of pieces vulnerable to attack.\"\n    vulnerable_white = sum(1 for square, piece in board.piece_map().items() if piece.color == chess.WHITE and board.is_attacked_by(chess.BLACK, square))\n    vulnerable_black = sum(1 for square, piece in board.piece_map().items() if piece.color == chess.BLACK and board.is_attacked_by(chess.WHITE, square))\n    return float(vulnerable_white - vulnerable_black)", "def feature(board: chess.Board) -> float:\n    \"Measures the king safety by counting the number of available escape squares for both kings.\"\n    white_king_square = next(square for square, piece in board.piece_map().items() if piece.color == chess.WHITE and piece.piece_type == chess.KING)\n    black_king_square = next(square for square, piece in board.piece_map().items() if piece.color == chess.BLACK and piece.piece_type == chess.KING)\n    \n    white_escape_squares = sum(1 for move in board.legal_moves if move.from_square == white_king_square)\n    black_escape_squares = sum(1 for move in board.legal_moves if move.from_square == black_king_square)\n    return float(white_escape_squares - black_escape_squares)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of isolated pawns for both players.\"\n    def count_isolated_pawns(color):\n        return sum(1 for square, piece in board.piece_map().items() \n                   if piece.color == color and piece.piece_type == chess.PAWN and \n                   (board.piece_at(square - 1) is None or board.piece_at(square + 1) is None))\n\n    return float(count_isolated_pawns(chess.WHITE) - count_isolated_pawns(chess.BLACK))", "def feature(board: chess.Board) -> float:\n    \"Measures the development of pieces by counting how many pieces are on their starting squares.\"\n    starting_positions = {\n        chess.WHITE: [chess.A1, chess.B1, chess.C1, chess.D1, chess.E1, chess.F1, chess.G1, chess.H1],\n        chess.BLACK: [chess.A8, chess.B8, chess.C8, chess.D8, chess.E8, chess.F8, chess.G8, chess.H8]\n    }\n    \n    undeveloped_white = sum(1 for square in starting_positions[chess.WHITE] if board.piece_at(square) is not None)\n    undeveloped_black = sum(1 for square in starting_positions[chess.BLACK] if board.piece_at(square) is not None)\n    \n    return float(undeveloped_black - undeveloped_white)", "def feature(board: chess.Board) -> float:\n    \"Evaluates the pawn structure by counting the number of doubled pawns for each player.\"\n    def count_doubled_pawns(color):\n        files = {}\n        for square, piece in board.piece_map().items():\n            if piece.color == color and piece.piece_type == chess.PAWN:\n                file = chess.square_file(square)\n                files[file] = files.get(file, 0) + 1\n        return sum(count - 1 for count in files.values() if count > 1)\n\n    return float(count_doubled_pawns(chess.WHITE) - count_doubled_pawns(chess.BLACK))", "def feature(board: chess.Board) -> float:\n    \"Calculates the control of the center squares (d4, d5, e4, e5) by both players.\"\n    center_squares = [chess.D4, chess.D5, chess.E4, chess.E5]\n    control_white = sum(1 for square in center_squares if board.is_attacked_by(chess.WHITE, square))\n    control_black = sum(1 for square in center_squares if board.is_attacked_by(chess.BLACK, square))\n    return float(control_white - control_black)", "def feature(board: chess.Board) -> float:\n    \"Measures the total number of pawns on the board.\"\n    return float(len([piece for piece in board.piece_map().values() if piece.piece_type == chess.PAWN]))", "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in the number of pieces that can move to attack the opposing king.\"\n    white_king_square = next(square for square, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color == chess.WHITE)\n    black_king_square = next(square for square, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color == chess.BLACK)\n    white_attacks = len(list(board.attackers(chess.WHITE, black_king_square)))\n    black_attacks = len(list(board.attackers(chess.BLACK, white_king_square)))\n    return float(white_attacks - black_attacks)", "def feature(board: chess.Board) -> float:\n    \"Measures the mobility of the pieces by counting the number of legal moves for all pieces.\"\n    return float(sum(len(list(board.legal_moves)) for piece in board.piece_map().values()))", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces that are currently undefended.\"\n    undefended_count = 0\n    for square, piece in board.piece_map().items():\n        if not board.is_attacked_by(not piece.color, square):\n            undefended_count += 1\n    return float(undefended_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the total distance of all pieces to their opposing king.\"\n    white_king_square = next(square for square, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color == chess.WHITE)\n    black_king_square = next(square for square, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color == chess.BLACK)\n    total_distance = sum(chess.square_distance(square, black_king_square) for square, piece in board.piece_map().items() if piece.color == chess.WHITE)\n    total_distance += sum(chess.square_distance(square, white_king_square) for square, piece in board.piece_map().items() if piece.color == chess.BLACK)\n    return float(total_distance)", "def feature(board: chess.Board) -> float:\n    \"Examines the total value of pieces controlled by each side.\"\n    piece_values = {chess.PAWN: 100, chess.KNIGHT: 320, chess.BISHOP: 330, chess.ROOK: 500, chess.QUEEN: 900, chess.KING: 0}\n    white_value = sum(piece_values[piece.piece_type] for piece in board.piece_map().values() if piece.color == chess.WHITE)\n    black_value = sum(piece_values[piece.piece_type] for piece in board.piece_map().values() if piece.color == chess.BLACK)\n    return float(white_value - black_value)", "def feature(board: chess.Board) -> float:\n    \"Measures the difference in the number of pieces attacking the center squares.\"\n    center_squares = [chess.E4, chess.E5, chess.D4, chess.D5]\n    white_control = sum(1 for sq in center_squares if board.is_attacked_by(chess.WHITE, sq))\n    black_control = sum(1 for sq in center_squares if board.is_attacked_by(chess.BLACK, sq))\n    return float(white_control - black_control)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of potential pins against the opposing side's pieces.\"\n    pin_count = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == chess.WHITE:\n            for attacker_sq in board.attackers(chess.BLACK, square):\n                if (board.piece_at(attacker_sq) and \n                    board.piece_at(attacker_sq).piece_type in [chess.ROOK, chess.QUEEN]):\n                    if not board.is_attacked_by(chess.WHITE, square):\n                        pin_count += 1\n    return float(pin_count)", "def feature(board: chess.Board) -> float:\n    \"Measures the total number of pawn moves available for both players.\"\n    white_pawn_moves = sum(1 for move in board.legal_moves if board.piece_at(move.from_square).piece_type == chess.PAWN and board.piece_at(move.from_square).color == chess.WHITE)\n    black_pawn_moves = sum(1 for move in board.legal_moves if board.piece_at(move.from_square).piece_type == chess.PAWN and board.piece_at(move.from_square).color == chess.BLACK)\n    return float(white_pawn_moves - black_pawn_moves)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of squares controlled by pawns for both players.\"\n    white_control = sum(1 for square in range(64) if board.piece_at(square) and board.piece_at(square).color == chess.WHITE and chess.square_rank(square) < 7)\n    black_control = sum(1 for square in range(64) if board.piece_at(square) and board.piece_at(square).color == chess.BLACK and chess.square_rank(square) > 0)\n    return float(white_control - black_control)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of pieces in attacked by the opponent.\"\n    attacking_pieces_count = sum(1 for square in range(64) if board.is_attacked_by(chess.WHITE, square) or board.is_attacked_by(chess.BLACK, square))\n    return float(attacking_pieces_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the mobility of the pieces by counting the number of legal moves for each player.\"\n    white_mobility = len(list(board.legal_moves)) if board.turn else 0\n    black_mobility = len(list(board.legal_moves)) if not board.turn else 0\n    return float(white_mobility - black_mobility)", "def feature(board: chess.Board) -> float:\n    \"Counts the material imbalance by only considering the major pieces (rooks and queens).\"\n    major_value = {chess.ROOK: 5, chess.QUEEN: 9}\n    white_material = sum(major_value.get(board.piece_at(square).piece_type, 0) for square in board.piece_map() if board.piece_at(square).color == chess.WHITE)\n    black_material = sum(major_value.get(board.piece_at(square).piece_type, 0) for square in board.piece_map() if board.piece_at(square).color == chess.BLACK)\n    return float(white_material - black_material)", "def feature(board: chess.Board) -> float:\n    \"Measures king proximity by counting the distance to the nearest enemy piece.\"\n    white_king_square = next((square for square in board.piece_map() if board.piece_at(square).piece_type == chess.KING and board.piece_at(square).color == chess.WHITE), None)\n    black_king_square = next((square for square in board.piece_map() if board.piece_at(square).piece_type == chess.KING and board.piece_at(square).color == chess.BLACK), None)\n    if white_king_square is None or black_king_square is None:\n        return 0.0\n    distance_to_enemy_king = chess.square_distance(white_king_square, black_king_square)\n    return float(distance_to_enemy_king)", "def feature(board: chess.Board) -> float:\n    \"Measures the control of the center squares by the pieces.\"\n    center_squares = [chess.D4, chess.D5, chess.E4, chess.E5]\n    white_control = sum(1 for sq in center_squares if board.is_attacked_by(chess.WHITE, sq))\n    black_control = sum(1 for sq in center_squares if board.is_attacked_by(chess.BLACK, sq))\n    return float(white_control - black_control)", "def feature(board: chess.Board) -> float:\n    \"Calculates the total number of pieces for both colors.\"\n    white_piece_count = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE)\n    black_piece_count = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK)\n    return float(white_piece_count - black_piece_count)", "def feature(board: chess.Board) -> float:\n    \"Measures the distance of all pieces from the center of the board.\"\n    center_square = chess.parse_square('e4')\n    total_distance = 0\n    for square, piece in board.piece_map().items():\n        total_distance += chess.square_distance(square, center_square)\n    return total_distance / len(board.piece_map()) if board.piece_map() else 0.0", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of open files for both players.\"\n    open_files = 0\n    for file in range(8):\n        file_squares = [board.piece_at(chess.square(file, rank)) for rank in range(8)]\n        if all(piece is None for piece in file_squares) or all(piece.color == chess.WHITE for piece in file_squares if piece is not None) or all(piece.color == chess.BLACK for piece in file_squares if piece is not None):\n            open_files += 1\n    return open_files / 8.0", "def feature(board: chess.Board) -> float:\n    \"Evaluates king safety by counting the number of surrounding squares that are not attacked.\"\n    king_square = next(square for square in board.piece_map() if board.piece_map()[square].piece_type == chess.KING)\n    safe_squares = 0\n    for square in chess.SQUARES:\n        if chess.square_distance(square, king_square) == 1 and not board.is_attacked_by(not board.turn, square):\n            safe_squares += 1\n    return safe_squares / 8.0  # Maximum 8 surrounding squares", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces that can attack the opponent's king.\"\n    opponent_king_square = next(square for square in board.piece_map() if board.piece_map()[square].piece_type == chess.KING and board.piece_map()[square].color != board.turn)\n    attacking_pieces = sum(1 for move in board.legal_moves if move.to_square == opponent_king_square)\n    return float(attacking_pieces)", "def feature(board: chess.Board) -> float:\n    \"Calculates the mobility advantage by counting legal moves of both players.\"\n    white_moves = sum(1 for _ in board.legal_moves if board.turn is chess.WHITE)\n    black_moves = sum(1 for _ in board.legal_moves if board.turn is chess.BLACK)\n    return float(white_moves - black_moves)", "def feature(board: chess.Board) -> float:\n    \"Measures potential pawn promotion opportunities at a critical distance.\"\n    promotion_squares = [chess.A7, chess.B7, chess.C7, chess.D7, chess.E7, chess.F7, chess.G7, chess.H7] if board.turn == chess.WHITE else [chess.A2, chess.B2, chess.C2, chess.D2, chess.E2, chess.F2, chess.G2, chess.H2]\n    pawns_ready_to_promote = sum(1 for square in promotion_squares if board.piece_at(square) and board.piece_at(square).piece_type == chess.PAWN)\n    return float(pawns_ready_to_promote)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of knights on the board, which can be strong in closed positions.\"\n    knight_count = sum(1 for piece in board.piece_map().values() if piece.piece_type == chess.KNIGHT)\n    return float(knight_count)", "def feature(board: chess.Board) -> float:\n    \"Measures imbalance in pawn structure by counting doubled or isolated pawns.\"\n    doubled_pawns = 0\n    isolated_pawns = 0\n    for file in range(8):\n        pawns_in_file = [board.piece_at(chess.square(file, rank)) for rank in range(8) if board.piece_at(chess.square(file, rank)) and board.piece_at(chess.square(file, rank)).piece_type == chess.PAWN]\n        if len(pawns_in_file) > 1:\n            doubled_pawns += len(pawns_in_file) - 1\n        if len(pawns_in_file) > 0:\n            total_rank = sum(1 for rank in range(8) if board.piece_at(chess.square(file, rank)) is not None)\n            if total_rank == 1:\n                isolated_pawns += 1\n    return float(doubled_pawns + isolated_pawns)", "def feature(board: chess.Board) -> float:\n    \"Evaluates the rook activity by counting the number of rooks on open files.\"\n    rook_count = 0\n    for file in range(8):\n        if any(board.piece_at(chess.square(file, rank)) is not None for rank in range(8)):\n            continue\n        rook_count += sum(1 for rank in range(8) if board.piece_at(chess.square(file, rank)) and board.piece_at(chess.square(file, rank)).piece_type == chess.ROOK)\n    return float(rook_count)", "def feature(board: chess.Board) -> float:\n    \"Measures the total piece value considering their positions on the board.\"\n    value_sum = 0\n    piece_values = {\n        chess.PAWN: 100,\n        chess.KNIGHT: 320,\n        chess.BISHOP: 330,\n        chess.ROOK: 500,\n        chess.QUEEN: 900,\n        chess.KING: 0  # We don't assign a value to the king as it can't be captured\n    }\n    for square, piece in board.piece_map().items():\n        value_sum += piece_values[piece.piece_type] if piece.color == chess.WHITE else -piece_values[piece.piece_type]\n    return float(value_sum)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pawns remaining for each side and returns their difference.\"\n    white_pawns = len([p for p in board.piece_map().values() if p.piece_type == chess.PAWN and p.color == chess.WHITE])\n    black_pawns = len([p for p in board.piece_map().values() if p.piece_type == chess.PAWN and p.color == chess.BLACK])\n    return float(white_pawns - black_pawns)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of pieces that are pinned, affecting tactical capabilities.\"\n    pinned_pieces = 0\n    for piece_square, piece in board.piece_map().items():\n        if piece.color == board.turn:  # Count only the player's pieces\n            for attacker_square in board.attackers(not board.turn, piece_square):\n                if board.is_attacked_by(not board.turn, piece_square):\n                    pinned_pieces += 1\n                    break\n    return float(pinned_pieces)", "def feature(board: chess.Board) -> float:\n    \"Evaluates the positional advantage based on the number of open files for rooks.\"\n    open_files = 0\n    for file in range(8):\n        if not any(board.piece_at(chess.square(file, rank)) for rank in range(8)):\n            open_files += 1\n    return float(open_files)", "def feature(board: chess.Board) -> float:\n    \"Calculates the mobility of the pieces by counting the legal moves available.\"\n    mobility_score = 0\n    for move in board.legal_moves:\n        mobility_score += 1  # Each legal move adds to the mobility score\n    return float(mobility_score)", "def feature(board: chess.Board) -> float:\n    \"Measures the control of central squares (d4, d5, e4, e5) as a positional feature.\"\n    central_squares = [chess.parse_square('d4'), chess.parse_square('d5'), chess.parse_square('e4'), chess.parse_square('e5')]\n    control_score = 0\n    for square in central_squares:\n        control_score += 1 if board.is_attacked_by(chess.WHITE, square) else -1 if board.is_attacked_by(chess.BLACK, square) else 0\n    return float(control_score)", "def feature(board: chess.Board) -> float:\n    \"Calculates the king safety score based on the number of squares around the king that are controlled by the opponent.\"\n    king_square = board.king(board.turn)\n    unsafe_squares = [\n        chess.square(king_square % 8 + dx, king_square // 8 + dy)\n        for dx in [-1, 0, 1] for dy in [-1, 0, 1]\n        if chess.square(king_square % 8 + dx, king_square // 8 + dy) in board.piece_map()\n    ]\n    safety_score = sum(1 for square in unsafe_squares if board.is_attacked_by(not board.turn, square))\n    return float(safety_score)", "def feature(board: chess.Board) -> float:\n    \"Differentiates contributions by counting the number of pieces on the back rank.\"\n    back_rank_count = 0\n    for square in range(0, 8):  # Check the first rank for White or the eighth for Black\n        if board.piece_at(chess.square(square, 0 if board.turn == chess.WHITE else 7)):\n            back_rank_count += 1\n    return float(back_rank_count)", "def feature(board: chess.Board) -> float:\n    \"Evaluates material imbalance based on the difference between minor and major pieces.\"\n    minor_pieces = 0  # Knights and Bishops\n    major_pieces = 0   # Rooks and Queens\n    for piece in board.piece_map().values():\n        if piece.piece_type in [chess.KNIGHT, chess.BISHOP]:\n            minor_pieces += 1 if piece.color == chess.WHITE else -1\n        elif piece.piece_type in [chess.ROOK, chess.QUEEN]:\n            major_pieces += 1 if piece.color == chess.WHITE else -1\n    return float(major_pieces - minor_pieces)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of attacking pieces each player has on the board.\"\n    white_attacking = sum(1 for square in board.piece_map() if board.piece_at(square).color == chess.WHITE and board.attackers(chess.WHITE, square))\n    black_attacking = sum(1 for square in board.piece_map() if board.piece_at(square).color == chess.BLACK and board.attackers(chess.BLACK, square))\n    return float(white_attacking - black_attacking)", "def feature(board: chess.Board) -> float:\n    \"Calculates the total number of pieces that are under attack for each player.\"\n    white_under_attack = sum(1 for square in board.piece_map() if board.piece_at(square).color == chess.WHITE and board.is_attacked_by(chess.BLACK, square))\n    black_under_attack = sum(1 for square in board.piece_map() if board.piece_at(square).color == chess.BLACK and board.is_attacked_by(chess.WHITE, square))\n    return float(white_under_attack - black_under_attack)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of doubled pawns for each player.\"\n    doubled_pawns_white = sum(1 for file in range(8) if len([square for square in board.piece_map() if board.piece_at(square).color == chess.WHITE and chess.square_file(square) == file]) > 1)\n    doubled_pawns_black = sum(1 for file in range(8) if len([square for square in board.piece_map() if board.piece_at(square).color == chess.BLACK and chess.square_file(square) == file]) > 1)\n    return float(doubled_pawns_white - doubled_pawns_black)", "def feature(board: chess.Board) -> float:\n    \"Measures the central control by counting the number of pieces in the center squares.\"\n    center_squares = [chess.D4, chess.D5, chess.E4, chess.E5]\n    white_center_control = sum(1 for sq in center_squares if board.is_attacked_by(chess.WHITE, sq))\n    black_center_control = sum(1 for sq in center_squares if board.is_attacked_by(chess.BLACK, sq))\n    return float(white_center_control - black_center_control)", "def feature(board: chess.Board) -> float:\n    \"Calculates the ratio of pieces to pawns for each player.\"\n    total_pieces_white = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE)\n    total_pawns_white = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE and piece.piece_type == chess.PAWN)\n    total_pieces_black = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK)\n    total_pawns_black = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK and piece.piece_type == chess.PAWN)\n\n    ratio_white = total_pieces_white / (total_pawns_white + 1e-5)\n    ratio_black = total_pieces_black / (total_pawns_black + 1e-5)\n    \n    return float(ratio_white - ratio_black)", "def feature(board: chess.Board) -> float:\n    \"Measures the mobility of each player by counting legal moves.\"\n    white_moves = len(list(board.legal_moves))\n    board.turn = False\n    black_moves = len(list(board.legal_moves))\n    board.turn = True\n    return float(white_moves - black_moves)", "def feature(board: chess.Board) -> float:\n    \"Calculates the positional advantage based on the number of pieces on the back rank.\"\n    white_back_rank = sum(1 for square in range(8) if board.piece_at(chess.parse_square(f'a{1}')) and board.piece_at(chess.parse_square(f'a{1}')).color == chess.WHITE)\n    black_back_rank = sum(1 for square in range(8) if board.piece_at(chess.parse_square(f'a{8}')) and board.piece_at(chess.parse_square(f'a{8}')).color == chess.BLACK)\n    return float(white_back_rank - black_back_rank)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of pieces that are attacking opponent's king.\"\n    attacking_pieces = sum(1 for square in board.piece_map() if board.is_attacked_by(not board.turn, square))\n    return float(attacking_pieces)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of advanced pawns for the current player.\"\n    current_color = board.turn\n    advanced_pawn_count = sum(1 for square, piece in board.piece_map().items() \n                               if piece.piece_type == chess.PAWN and piece.color == current_color and\n                               (chess.square_rank(square) > (6 if current_color else 1)))\n    return float(advanced_pawn_count)", "def feature(board: chess.Board) -> float:\n    \"Measures control of the center by counting pawns in the central squares.\"\n    center_pawns = sum(1 for square, piece in board.piece_map().items() \n                       if piece.piece_type == chess.PAWN and chess.square_file(square) in [3, 4] and \n                       chess.square_rank(square) in [3, 4])\n    return float(center_pawns)", "def feature(board: chess.Board) -> float:\n    \"Calculates the total mobility by counting the legal moves available for the current player.\"\n    mobility = len(list(board.legal_moves))\n    return float(mobility)", "def feature(board: chess.Board) -> float:\n    \"Counts the isolated pawns for the current player.\"\n    current_color = board.turn\n    isolated_pawns = sum(1 for square, piece in board.piece_map().items() \n                         if piece.piece_type == chess.PAWN and piece.color == current_color and\n                         not (board.piece_at(square - 1) and board.piece_at(square - 1).color == current_color) and\n                         not (board.piece_at(square + 1) and board.piece_at(square + 1).color == current_color))\n    return float(isolated_pawns)", "def feature(board: chess.Board) -> float:\n    \"Measures the distance of pieces from the opponent's back rank.\"\n    opponent_back_rank = 7 if board.turn == chess.WHITE else 0\n    distance_sum = sum(chess.square_distance(square, opponent_back_rank * 8) for square, piece in board.piece_map().items() \n                       if piece.color == board.turn)\n    return float(distance_sum)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of pinned pieces belonging to the current player.\"\n    pinned_count = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == board.turn:\n            for attacker_square in board.attackers(not board.turn, square):\n                if board.is_check(): \n                    pinned_count += 1\n                    break\n    return float(pinned_count)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of potential passed pawns for the current player.\"\n    current_color = board.turn\n    passed_pawn_count = sum(1 for square, piece in board.piece_map().items() \n                             if piece.piece_type == chess.PAWN and piece.color == current_color and\n                             not any(board.piece_at(file + square) and board.piece_at(file + square).color != current_color \n                                     for file in range(-1, 2) if 0 <= chess.square_file(square) + file <= 7))\n    return float(passed_pawn_count)", "def feature(board: chess.Board) -> float:\n    \"Measures the difference in total piece value for both players.\"\n    piece_values = {chess.PAWN: 100, chess.KNIGHT: 300, chess.BISHOP: 300, \n                    chess.ROOK: 500, chess.QUEEN: 900, chess.KING: 0}\n    white_value = sum(piece_values[piece.piece_type] for piece in board.piece_map().values() if piece.color == chess.WHITE)\n    black_value = sum(piece_values[piece.piece_type] for piece in board.piece_map().values() if piece.color == chess.BLACK)\n    return float(white_value - black_value)", "def feature(board: chess.Board) -> float:\n    \"Measures the mobility of pieces by counting the legal moves available for both players.\"\n    white_moves = len(list(board.legal_moves)) if board.turn else 0\n    black_moves = len(list(board.legal_moves)) if not board.turn else 0\n    result = white_moves - black_moves\n    return float(result)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of protected pawns for both players.\"\n    protected_pawns = 0\n    for square in chess.SQUARES:\n        piece = board.piece_at(square)\n        if piece and piece.piece_type == chess.PAWN:\n            attackers = board.attackers(piece.color, square)\n            if attackers:\n                num_protectors = len(board.attackers(not piece.color, square))\n                if num_protectors > 0:\n                    protected_pawns += 1\n    return float(protected_pawns)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of pieces in the opponent's half of the board.\"\n    opponent_half_pieces = 0\n    for square in chess.SQUARES:\n        piece = board.piece_at(square)\n        if piece and piece.color != board.turn and chess.square_rank(square) > 3:\n            opponent_half_pieces += 1\n    return float(opponent_half_pieces)", "def feature(board: chess.Board) -> float:\n    \"Measures the distribution of pawn structures by calculating the number of doubled pawns.\"\n    doubled_pawns = 0\n    pawn_files = {}\n    for square in chess.SQUARES:\n        piece = board.piece_at(square)\n        if piece and piece.piece_type == chess.PAWN:\n            file = chess.square_file(square)\n            if file in pawn_files:\n                pawn_files[file] += 1\n            else:\n                pawn_files[file] = 1\n    for count in pawn_files.values():\n        if count > 1:\n            doubled_pawns += count - 1\n    return float(doubled_pawns)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces threatened by opponent's attack.\"\n    threatened_pieces = 0\n    for square in chess.SQUARES:\n        piece = board.piece_at(square)\n        if piece and piece.color == board.turn:\n            if board.is_attacked_by(not piece.color, square):\n                threatened_pieces += 1\n    return float(threatened_pieces)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of pieces with no legal moves (stuck pieces) for the current player.\"\n    stuck_pieces = 0\n    for square in chess.SQUARES:\n        piece = board.piece_at(square)\n        if piece and piece.color == board.turn:\n            # Create a temporary board state to check moves without modifying the original board\n            temp_board = board.copy()\n            temp_board.remove_piece_at(square)\n            moves = len(list(temp_board.legal_moves))\n            if moves == 0:\n                stuck_pieces += 1\n    return float(stuck_pieces)", "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in the number of pieces on the back rank for both players.\"\n    white_back_rank = sum(1 for square in chess.SQUARES[56:64] if board.piece_at(square) and board.piece_at(square).color == chess.WHITE)\n    black_back_rank = sum(1 for square in chess.SQUARES[0:8] if board.piece_at(square) and board.piece_at(square).color == chess.BLACK)\n    result = white_back_rank - black_back_rank\n    return float(result)", "def feature(board: chess.Board) -> float:\n    \"Measures the king's safety by checking if the king has escape squares.\"\n    king_square = board.king(board.turn)\n    escape_squares = 0\n    for move in board.legal_moves:\n        if move.from_square == king_square:\n            escape_squares += 1\n    return float(escape_squares)", "def feature(board: chess.Board) -> float:\n    \"Calculates the pawn structure advantage by counting isolated pawns.\"\n    isolated_pawns = 0\n    for square in chess.SQUARES:\n        piece = board.piece_at(square)\n        if piece and piece.piece_type == chess.PAWN:\n            file = chess.square_file(square)\n            has_neighbor = (board.piece_at(chess.square(file - 1, chess.square_rank(square))) if file > 0 else None) or \\\n                           (board.piece_at(chess.square(file + 1, chess.square_rank(square))) if file < 7 else None)\n            if not has_neighbor:\n                isolated_pawns += 1\n    return float(isolated_pawns)", "def feature(board: chess.Board) -> float:\n    \"Measures potential for long-term threats by counting piece combinations that can attack over distances.\"\n    long_range_threats = 0\n    for square in chess.SQUARES:\n        piece = board.piece_at(square)\n        if piece and piece.color == board.turn:\n            for move in board.legal_moves:\n                if move.from_square == square:\n                    if chess.square_distance(move.to_square, square) >= 2:\n                        long_range_threats += 1\n    return float(long_range_threats)", "def feature(board: chess.Board) -> float:\n    \"Measures the total number of pawns on the board, which can indicate endgame dynamics.\"\n    pawn_count = sum(1 for piece in board.piece_map().values() if piece.piece_type == chess.PAWN)\n    return float(pawn_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in the number of pieces controlled by each player.\"\n    white_control = sum(1 for square in board.legal_moves if board.turn)\n    black_control = sum(1 for square in board.legal_moves if not board.turn)\n    return float(white_control - black_control)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces attacked by both sides and returns the ratio.\"\n    white_attacks = sum(len(board.attackers(chess.WHITE, sq)) for sq in board.piece_map())\n    black_attacks = sum(len(board.attackers(chess.BLACK, sq)) for sq in board.piece_map())\n    return float(white_attacks / (black_attacks + 1))", "def feature(board: chess.Board) -> float:\n    \"Measures the distance of the king to the center of the board, which can indicate positional strength.\"\n    king_square = next((sq for sq, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color == board.turn), None)\n    center_squares = [chess.E4, chess.E5, chess.D4, chess.D5]\n    distance_to_center = min(chess.square_distance(king_square, sq) for sq in center_squares)\n    return float(distance_to_center)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of legal moves available to the player to move.\"\n    return float(len(list(board.legal_moves)))", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of advanced pawns over rank 5 for White and rank 4 for Black.\"\n    advanced_pawns = sum(1 for sq, piece in board.piece_map().items() if piece.piece_type == chess.PAWN and \n                         ((piece.color == chess.WHITE and chess.square_rank(sq) >= 5) or\n                          (piece.color == chess.BLACK and chess.square_rank(sq) <= 3)))\n    return float(advanced_pawns)", "def feature(board: chess.Board) -> float:\n    \"Checks for the presence of back rank threats (where a player's king is vulnerable).\"\n    back_rank_squares = [chess.A1, chess.B1, chess.C1, chess.D1, chess.E1, chess.F1, chess.G1, chess.H1] if board.turn else \\\n                        [chess.A8, chess.B8, chess.C8, chess.D8, chess.E8, chess.F8, chess.G8, chess.H8]\n    threats = sum(1 for square in back_rank_squares if board.is_attacked_by(not board.turn, square))\n    return float(threats)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of pieces vulnerable to capture by the opponent.\"\n    vulnerable_pieces = sum(1 for sq, piece in board.piece_map().items() if board.is_attacked_by(not piece.color, sq))\n    return float(vulnerable_pieces)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of pieces controlled by each player's pawns.\"\n    white_pawn_control = sum(len(board.attackers(chess.WHITE, square)) for square in board.piece_map() if board.piece_at(square).piece_type == chess.PAWN and board.piece_at(square).color == chess.WHITE)\n    black_pawn_control = sum(len(board.attackers(chess.BLACK, square)) for square in board.piece_map() if board.piece_at(square).piece_type == chess.PAWN and board.piece_at(square).color == chess.BLACK)\n    return float(white_pawn_control - black_pawn_control)", "def feature(board: chess.Board) -> float:\n    \"Calculates the distance of the nearest piece to the center of the board for each color.\"\n    center_squares = [chess.E4, chess.E5, chess.D4, chess.D5]\n    white_closest_distance = min((chess.square_distance(square, center_square) for square in board.piece_map() if board.piece_at(square).color == chess.WHITE for center_square in center_squares), default=float('inf'))\n    black_closest_distance = min((chess.square_distance(square, center_square) for square in board.piece_map() if board.piece_at(square).color == chess.BLACK for center_square in center_squares), default=float('inf'))\n    return float(black_closest_distance - white_closest_distance)", "def feature(board: chess.Board) -> float:\n    \"Calculates material value difference only accounting for rooks and queens.\"\n    piece_values = {chess.QUEEN: 9, chess.ROOK: 5}\n    white_material = sum(piece_values.get(board.piece_at(square).piece_type, 0) for square in board.piece_map() if board.piece_at(square).color == chess.WHITE)\n    black_material = sum(piece_values.get(board.piece_at(square).piece_type, 0) for square in board.piece_map() if board.piece_at(square).color == chess.BLACK)\n    return float(white_material - black_material)", "def feature(board: chess.Board) -> float:\n    \"Measures the highest-ranked piece (by basic value) for both colors.\"\n    rank_values = {chess.KING: 0, chess.QUEEN: 9, chess.ROOK: 5, chess.BISHOP: 3, chess.KNIGHT: 3, chess.PAWN: 1}\n    highest_white = max((rank_values[board.piece_at(square).piece_type] for square in board.piece_map() if board.piece_at(square).color == chess.WHITE), default=-1)\n    highest_black = max((rank_values[board.piece_at(square).piece_type] for square in board.piece_map() if board.piece_at(square).color == chess.BLACK), default=-1)\n    return float(highest_white - highest_black)", "def feature(board: chess.Board) -> float:\n    \"Measures the total number of pieces that are unprotected (attacked but not defended).\"\n    unprotected_white = sum(1 for square in board.piece_map() if board.piece_at(square).color == chess.WHITE and board.is_attacked_by(chess.BLACK, square) and not any(board.is_attacked_by(chess.WHITE, attacking) for attacking in board.attackers(chess.BLACK, square)))\n    unprotected_black = sum(1 for square in board.piece_map() if board.piece_at(square).color == chess.BLACK and board.is_attacked_by(chess.WHITE, square) and not any(board.is_attacked_by(chess.BLACK, attacking) for attacking in board.attackers(chess.WHITE, square)))\n    return float(unprotected_white - unprotected_black)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of pawns on the 4th and 5th ranks for White and 3rd and 4th ranks for Black.\"\n    white_advanced_pawns = sum(1 for square in board.piece_map() if board.piece_at(square).piece_type == chess.PAWN and board.piece_at(square).color == chess.WHITE and chess.square_rank(square) in (4, 5))\n    black_advanced_pawns = sum(1 for square in board.piece_map() if board.piece_at(square).piece_type == chess.PAWN and board.piece_at(square).color == chess.BLACK and chess.square_rank(square) in (3, 4))\n    return float(white_advanced_pawns - black_advanced_pawns)", "def feature(board: chess.Board) -> float:\n    \"Calculates the total number of pieces for each player and their ratio.\"\n    white_pieces = len([p for p in board.piece_map().values() if p.color == chess.WHITE])\n    black_pieces = len([p for p in board.piece_map().values() if p.color == chess.BLACK])\n    return float(white_pieces / (black_pieces + 1e-5))", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pinned pieces for each side and returns the difference.\"\n    def count_pinned(color):\n        pinned_count = 0\n        for square in board.piece_map():\n            piece = board.piece_at(square)\n            if piece and piece.color == color:\n                for target in board.legal_moves:\n                    if board.is_attacked_by(not color, target.to_square):\n                        if target.from_square != square:\n                            pinned_count += 1\n        return pinned_count\n    \n    return float(count_pinned(chess.WHITE) - count_pinned(chess.BLACK))", "def feature(board: chess.Board) -> float:\n    \"Measures the distance of all pieces from their respective home squares.\"\n    distance_sum = 0\n    for square in board.piece_map():\n        piece = board.piece_at(square)\n        if piece:\n            home_rank = 0 if piece.color == chess.WHITE else 7\n            distance_sum += chess.square_rank(square) - home_rank\n    return float(distance_sum)", "def feature(board: chess.Board) -> float:\n    \"Evaluates the king safety by checking the number of attacks on each king's square.\"\n    white_king_square = next(square for square, piece in board.piece_map().items() if piece.color == chess.WHITE and piece.piece_type == chess.KING)\n    black_king_square = next(square for square, piece in board.piece_map().items() if piece.color == chess.BLACK and piece.piece_type == chess.KING)\n    return float(sum((board.is_attacked_by(chess.WHITE, black_king_square), board.is_attacked_by(chess.BLACK, white_king_square))))", "def feature(board: chess.Board) -> float:\n    \"Checks the number of pieces blocked by pawns for each player.\"\n    def count_blocked(color):\n        blocked = 0\n        for square in board.piece_map():\n            piece = board.piece_at(square)\n            if piece and piece.color == color:\n                file = chess.square_file(square)\n                rank = chess.square_rank(square)\n                if color == chess.WHITE and rank < 6:\n                    if board.piece_at(chess.square(file, rank + 1)) and board.piece_at(chess.square(file, rank + 1)).color == chess.WHITE: \n                        blocked += 1\n                elif color == chess.BLACK and rank > 1:\n                    if board.piece_at(chess.square(file, rank - 1)) and board.piece_at(chess.square(file, rank - 1)).color == chess.BLACK:\n                        blocked += 1\n        return blocked\n    \n    return float(count_blocked(chess.WHITE) - count_blocked(chess.BLACK))", "def feature(board: chess.Board) -> float:\n    \"Counts total threats each side has on the opposite side's pawns.\"\n    threats_white = sum(1 for square in board.piece_map() if board.piece_at(square).color == chess.WHITE and square in board.attackers(chess.BLACK, square))\n    threats_black = sum(1 for square in board.piece_map() if board.piece_at(square).color == chess.BLACK and square in board.attackers(chess.WHITE, square))\n    return float(threats_white - threats_black)", "def feature(board: chess.Board) -> float:\n    \"Measures the control of key central squares (d4, d5, e4, e5) by each player.\"\n    central_squares = [chess.parse_square('d4'), chess.parse_square('d5'), chess.parse_square('e4'), chess.parse_square('e5')]\n    white_control = sum(1 for square in central_squares if board.is_attacked_by(chess.WHITE, square))\n    black_control = sum(1 for square in central_squares if board.is_attacked_by(chess.BLACK, square))\n    return float(white_control - black_control)", "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in mobility for each player based on the number of legal moves.\"\n    white_mobility = len(list(board.legal_moves)) if board.turn else 0\n    black_mobility = len(list(board.legal_moves)) if not board.turn else 0\n    return float(white_mobility - black_mobility)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of pieces in the endgame compared to the midgame.\"\n    piece_count = sum(1 for piece in board.piece_map().values())\n    return float(piece_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the total value of pieces on both sides for balance assessment.\"\n    piece_values = {chess.PAWN: 100, chess.KNIGHT: 320, chess.BISHOP: 330,\n                    chess.ROOK: 500, chess.QUEEN: 900, chess.KING: 0}\n    total_value = sum(piece_values[piece.piece_type] for piece in board.piece_map().values())\n    return float(total_value)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pawns that are on the 6th and 7th ranks.\"\n    advanced_pawns = sum(1 for square in board.piece_map() if \n                         board.piece_at(square).piece_type == chess.PAWN and\n                         (chess.square_rank(square) in (6, 7)))\n    return float(advanced_pawns)", "def feature(board: chess.Board) -> float:\n    \"Measures the control of the center (squares d4, d5, e4, e5) for both colors.\"\n    center_squares = [chess.parse_square('d4'), chess.parse_square('d5'),\n                      chess.parse_square('e4'), chess.parse_square('e5')]\n    control_count = sum(1 for square in center_squares if board.is_attacked_by(chess.WHITE, square)) - \\\n                    sum(1 for square in center_squares if board.is_attacked_by(chess.BLACK, square))\n    return float(control_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of pieces that are pinned by the opponent's pieces.\"\n    pinned_piece_count = sum(1 for square, piece in board.piece_map().items() if \n                              piece.color == board.turn and \n                              any(board.is_attacked_by(not piece.color, square) \n                                  for square in board.attackers(not piece.color, square)))\n    return float(pinned_piece_count)", "def feature(board: chess.Board) -> float:\n    \"Measures the distance from both kings to the center of the board.\"\n    white_king = board.king(chess.WHITE)\n    black_king = board.king(chess.BLACK)\n    center_distance = (chess.square_distance(white_king, chess.parse_square('e4')) + \n                       chess.square_distance(black_king, chess.parse_square('e4')))\n    return float(center_distance)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of squares that are currently defended by pieces.\"\n    defended_squares = sum(1 for square in range(64) if board.is_attacked_by(chess.WHITE, square) or \n                                                    board.is_attacked_by(chess.BLACK, square))\n    return float(defended_squares)", "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in mobility of both players (number of legal moves).\"\n    white_mobility = sum(1 for move in board.legal_moves if board.turn)\n    black_mobility = sum(1 for move in board.legal_moves if not board.turn)\n    mobility_difference = white_mobility - black_mobility\n    return float(mobility_difference)", "def feature(board: chess.Board) -> float:\n    \"Measures the total potential attack threats each side has.\"\n    white_threats = sum(1 for move in board.legal_moves if board.turn)\n    black_threats = sum(1 for move in board.legal_moves if not board.turn)\n    threats_difference = white_threats - black_threats\n    return float(threats_difference)", "def feature(board: chess.Board) -> float:\n    \"Checks the number of pieces positioned on the back rank for each player.\"\n    back_rank_pieces = sum(1 for square in range(8) if board.piece_at(chess.parse_square(chess.square_name(square))) is not None)\n    return float(back_rank_pieces)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of pawns on the 6th and 7th ranks for both players.\"\n    white_pawns = sum(1 for square in board.piece_map() if board.piece_at(square).color == chess.WHITE and chess.square_rank(square) in [6, 7])\n    black_pawns = sum(1 for square in board.piece_map() if board.piece_at(square).color == chess.BLACK and chess.square_rank(square) in [1, 2])\n    return float(white_pawns - black_pawns)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of advanced pieces (pieces on ranks 4 or 5 for White and 4 or 3 for Black).\"\n    advanced_pieces = sum(1 for square in board.piece_map() if (board.piece_at(square).color == chess.WHITE and chess.square_rank(square) in [4, 5]) or\n                          (board.piece_at(square).color == chess.BLACK and chess.square_rank(square) in [3, 4]))\n    return float(advanced_pieces)", "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in the number of major pieces (rooks and queens) between players.\"\n    white_major = sum(1 for square in board.piece_map() if board.piece_at(square).color == chess.WHITE and board.piece_at(square).piece_type in [chess.ROOK, chess.QUEEN])\n    black_major = sum(1 for square in board.piece_map() if board.piece_at(square).color == chess.BLACK and board.piece_at(square).piece_type in [chess.ROOK, chess.QUEEN])\n    return float(white_major - black_major)", "def feature(board: chess.Board) -> float:\n    \"Measures the imbalance of pieces on the board (more pieces concentrated on one side).\"\n    white_pieces = len([piece for piece in board.piece_map().values() if piece.color == chess.WHITE])\n    black_pieces = len([piece for piece in board.piece_map().values() if piece.color == chess.BLACK])\n    imbalance = abs(white_pieces - black_pieces) / max(1, white_pieces + black_pieces)\n    return float(imbalance)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pawns that have advanced past their starting ranks.\"\n    advanced_pawns = sum(1 for square in board.piece_map() if (board.piece_at(square).color == chess.WHITE and chess.square_rank(square) > 1 and board.piece_at(square).piece_type == chess.PAWN) or\n                               (board.piece_at(square).color == chess.BLACK and chess.square_rank(square) < 6 and board.piece_at(square).piece_type == chess.PAWN))\n    return float(advanced_pawns)", "def feature(board: chess.Board) -> float:\n    \"Computes the number of pieces in the opponent's half of the board.\"\n    opponent_half = sum(1 for square in board.piece_map() if (board.piece_at(square).color == chess.WHITE and chess.square_rank(square) >= 4) or\n                        (board.piece_at(square).color == chess.BLACK and chess.square_rank(square) <= 3))\n    return float(opponent_half)", "def feature(board: chess.Board) -> float:\n    \"Calculates the total number of pieces remaining on the board as a measure of material integrity.\"\n    total_pieces = len(board.piece_map())\n    return float(total_pieces)", "def feature(board: chess.Board) -> float:\n    \"Checks whether a player has a passed pawn and returns a value accordingly.\"\n    passed_pawns = sum(1 for square in board.piece_map() if (board.piece_at(square).piece_type == chess.PAWN and\n                            ((board.piece_at(square).color == chess.WHITE and all(board.piece_at(sq) is None for sq in range(0, chess.parse_square(chess.square_name(square))))) or \n                             (board.piece_at(square).color == chess.BLACK and all(board.piece_at(sq) is None for sq in range(chess.parse_square(chess.square_name(square)) + 1, 8))))))\n    return float(passed_pawns)", "def feature(board: chess.Board) -> float:\n    \"Evaluates whether a player is in check or checkmate.\"\n    return float(board.is_check() or board.is_checkmate())", "def feature(board: chess.Board) -> float:\n    \"Measures the total number of pieces on the board.\"\n    return float(len(board.piece_map()))", "def feature(board: chess.Board) -> float:\n    \"Counts the number of squares controlled by each player.\"\n    white_control = sum(board.is_attacked_by(chess.WHITE, square) for square in chess.SQUARES)\n    black_control = sum(board.is_attacked_by(chess.BLACK, square) for square in chess.SQUARES)\n    return float(white_control - black_control)", "def feature(board: chess.Board) -> float:\n    \"Calculates the mobility of each player based on the number of legal moves.\"\n    white_moves = len(list(board.legal_moves)) if board.turn else 0\n    black_moves = len(list(board.legal_moves)) if not board.turn else 0\n    return float(white_moves - black_moves)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pawns on the 7th rank.\"\n    white_pawns = sum(1 for sq in board.piece_map() if board.piece_at(sq).piece_type == chess.PAWN and chess.square_rank(sq) == 6)\n    black_pawns = sum(1 for sq in board.piece_map() if board.piece_at(sq).piece_type == chess.PAWN and chess.square_rank(sq) == 1)\n    return float(white_pawns - black_pawns)", "def feature(board: chess.Board) -> float:\n    \"Measures the threat level of major pieces (rooks and queens) against the opponent's king.\"\n    threats = sum(1 for square in chess.SQUARES if board.is_attacked_by(chess.WHITE, square) and board.piece_at(square) in [chess.ROOK, chess.QUEEN] and board.is_attacked_by(chess.BLACK, chess.KING))\n    return float(threats)", "def feature(board: chess.Board) -> float:\n    \"Calculates the distance (in ranks and files) from each player's king to the center of the board.\"\n    white_king_square = next((sq for sq in board.piece_map() if board.piece_at(sq).piece_type == chess.KING and board.piece_at(sq).color == chess.WHITE), None)\n    black_king_square = next((sq for sq in board.piece_map() if board.piece_at(sq).piece_type == chess.KING and board.piece_at(sq).color == chess.BLACK), None)\n    \n    if white_king_square is not None:\n        white_distance = chess.square_distance(white_king_square, chess.parse_square('e4'))  # Center square for evaluation\n    else:\n        white_distance = 8  # Maximum distance\n\n    if black_king_square is not None:\n        black_distance = chess.square_distance(black_king_square, chess.parse_square('e5'))  # Center square for evaluation\n    else:\n        black_distance = 8  # Maximum distance\n\n    return float(black_distance - white_distance)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces attacked by each color.\"\n    white_attacked = sum(1 for square in chess.SQUARES if board.is_attacked_by(chess.WHITE, square))\n    black_attacked = sum(1 for square in chess.SQUARES if board.is_attacked_by(chess.BLACK, square))\n    return float(white_attacked - black_attacked)", "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in total piece values between players.\"\n    piece_values = {chess.PAWN: 100, chess.KNIGHT: 300, chess.BISHOP: 300, chess.ROOK: 500, chess.QUEEN: 900, chess.KING: 0}\n    white_value = sum(piece_values[board.piece_at(sq).piece_type] for sq in board.piece_map() if board.piece_at(sq).color == chess.WHITE)\n    black_value = sum(piece_values[board.piece_at(sq).piece_type] for sq in board.piece_map() if board.piece_at(sq).color == chess.BLACK)\n    return float(white_value - black_value)", "def feature(board: chess.Board) -> float:\n    \"Assesses positional strength based on pawn structure (isolated, doubled pawns).\"\n    pawn_structure_score = 0\n    for sq in board.piece_map():\n        piece = board.piece_at(sq)\n        if piece.piece_type == chess.PAWN:\n            rank = chess.square_rank(sq)\n            file = chess.square_file(sq)\n            # Check for doubled pawns\n            if board.piece_at(chess.parse_square(chess.square_name(sq)[0] + str(rank + 1))): \n                pawn_structure_score -= 1  # Penalize for being doubled\n            # Check for isolated pawns (no adjacent pawns)\n            if not (board.piece_at(chess.parse_square(chess.square_name(sq)[0] + str(rank))) or \n                      board.piece_at(chess.parse_square(chess.square_name(sq)[0] + str(rank + 1)))): \n                pawn_structure_score += 1  # Reward for being isolated\n\n    return float(pawn_structure_score)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of advanced pawns for both players.\"\n    white_advanced_pawns = sum(1 for square in board.piece_map() \n                               if board.piece_at(square).color == chess.WHITE and chess.square_rank(square) >= 4)\n    black_advanced_pawns = sum(1 for square in board.piece_map() \n                               if board.piece_at(square).color == chess.BLACK and chess.square_rank(square) <= 4)\n    return float(white_advanced_pawns - black_advanced_pawns)", "def feature(board: chess.Board) -> float:\n    \"Measures the total number of pieces remaining for both players.\"\n    total_pieces = len(board.piece_map())\n    return float(total_pieces)", "def feature(board: chess.Board) -> float:\n    \"Calculates the king safety based on the number of squares attacked near kings.\"\n    white_king = next((sq for sq in board.piece_map() if board.piece_at(sq).piece_type == chess.KING and board.piece_at(sq).color == chess.WHITE), None)\n    black_king = next((sq for sq in board.piece_map() if board.piece_at(sq).piece_type == chess.KING and board.piece_at(sq).color == chess.BLACK), None)\n    \n    white_king_safety = sum(1 for sq in chess.SQUARES if board.is_attacked_by(chess.BLACK, sq))\n    black_king_safety = sum(1 for sq in chess.SQUARES if board.is_attacked_by(chess.WHITE, sq))\n    \n    return float(white_king_safety - black_king_safety)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of connected pawns for each player and calculates their difference.\"\n    def connected_pawns(color):\n        pawns = [square for square in board.piece_map() if board.piece_at(square).piece_type == chess.PAWN and board.piece_at(square).color == color]\n        connected = 0\n        for square in pawns:\n            rank = chess.square_rank(square)\n            file = chess.square_file(square)\n            if board.piece_at(chess.square(file, rank + 1)) and board.piece_at(chess.square(file, rank + 1)).color == color: \n                connected += 1\n            if board.piece_at(chess.square(file, rank - 1)) and board.piece_at(chess.square(file, rank - 1)).color == color: \n                connected += 1\n        return connected\n\n    white_connected = connected_pawns(chess.WHITE)\n    black_connected = connected_pawns(chess.BLACK)\n    return float(white_connected - black_connected)", "def feature(board: chess.Board) -> float:\n    \"Measures the control of the center squares (d4, d5, e4, e5) for both players.\"\n    center_squares = [chess.D4, chess.D5, chess.E4, chess.E5]\n    control_white = sum(1 for sq in center_squares if board.is_attacked_by(chess.WHITE, sq))\n    control_black = sum(1 for sq in center_squares if board.is_attacked_by(chess.BLACK, sq))\n    return float(control_white - control_black)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of pieces on the back rank for each player.\"\n    white_back_rank = sum(1 for sq in range(56, 64) if board.piece_at(sq) and board.piece_at(sq).color == chess.WHITE)\n    black_back_rank = sum(1 for sq in range(0, 8) if board.piece_at(sq) and board.piece_at(sq).color == chess.BLACK)\n    return float(white_back_rank - black_back_rank)", "def feature(board: chess.Board) -> float:\n    \"Measures the distance of all pawns from their final ranks.\"\n    def pawn_distance(color):\n        return sum(7 - chess.square_rank(sq) if color == chess.WHITE else chess.square_rank(sq) for sq in board.piece_map() \n                   if board.piece_at(sq).piece_type == chess.PAWN and board.piece_at(sq).color == color)\n\n    white_distance = pawn_distance(chess.WHITE)\n    black_distance = pawn_distance(chess.BLACK)\n    return float(white_distance - black_distance)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of double pawns for each player and computes the difference.\"\n    def double_pawns(color):\n        files = {}\n        for square in board.piece_map():\n            piece = board.piece_at(square)\n            if piece.piece_type == chess.PAWN and piece.color == color:\n                file = chess.square_file(square)\n                if file not in files:\n                    files[file] = 0\n                files[file] += 1\n        return sum(1 for count in files.values() if count > 1)\n\n    white_doubles = double_pawns(chess.WHITE)\n    black_doubles = double_pawns(chess.BLACK)\n    return float(white_doubles - black_doubles)", "def feature(board: chess.Board) -> float:\n    \"Calculates the material disadvantage based on the most valuable piece lost by each player.\"\n    def material_difference(color):\n        pieces_values = {chess.PAWN: 100, chess.KNIGHT: 320, chess.BISHOP: 330, chess.ROOK: 500, chess.QUEEN: 900}\n        max_value_lost = 0\n        for square in board.piece_map():\n            piece = board.piece_at(square)\n            if piece.color == color:\n                max_value_lost = max(max_value_lost, pieces_values.get(piece.piece_type, 0))\n        return max_value_lost\n\n    white_loss = material_difference(chess.WHITE)\n    black_loss = material_difference(chess.BLACK)\n    return float(white_loss - black_loss)", "def feature(board: chess.Board) -> float:\n    \"Measures the total mobility of pieces for both players by counting the number of legal moves.\"\n    mobility_white = len(list(board.legal_moves)) if board.turn else 0\n    mobility_black = len(list(board.legal_moves)) if not board.turn else 0\n    return float(mobility_white - mobility_black)", "def feature(board: chess.Board) -> float:\n    \"Calculates the value difference based on material, considering advanced pawns (pawns on 4th and 5th ranks for White, 3rd and 4th for Black).\"\n    material_value = 0\n    for square, piece in board.piece_map().items():\n        value = piece.piece_type\n        if piece.color == chess.WHITE:\n            if chess.square_rank(square) >= 4:\n                value += 1  # Add point for advanced pawns (White)\n            material_value += value\n        else:\n            if chess.square_rank(square) <= 4:\n                value += 1  # Add point for advanced pawns (Black)\n            material_value -= value\n    return float(material_value)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of exposed pieces (pieces that are not defended by another piece).\"\n    exposed_count = 0\n    for square, piece in board.piece_map().items():\n        if not any(board.is_attacked_by(piece.color, target) for target in board.attackers(not piece.color, square)):\n            exposed_count += 1\n    return float(exposed_count)", "def feature(board: chess.Board) -> float:\n    \"Counts the total number of pieces on the board and calculates the ratio of minor to major pieces.\"\n    minor_count = 0\n    major_count = 0\n    for piece in board.piece_map().values():\n        if piece.piece_type in (chess.KNIGHT, chess.BISHOP):\n            minor_count += 1\n        elif piece.piece_type in (chess.ROOK, chess.QUEEN):\n            major_count += 1\n    total_pieces = minor_count + major_count\n    return float(minor_count / total_pieces) if total_pieces > 0 else 0.0", "def feature(board: chess.Board) -> float:\n    \"Measures the distance of the king from its starting position (to evaluate king safety).\"\n    king_square = board.king(chess.WHITE) if board.turn else board.king(chess.BLACK)\n    if king_square is None:\n        return 0.0\n    distance_from_start = chess.square_distance(king_square, chess.E1 if board.turn else chess.E8)\n    return float(8 - distance_from_start)  # Closer to start is safer; further away is more dangerous.", "def feature(board: chess.Board) -> float:\n    \"Calculates the total number of pawn structures (connected pawns and isolated pawns) for both players.\"\n    pawn_structure_score = 0\n    for square in range(64):\n        piece = board.piece_at(square)\n        if piece and piece.piece_type == chess.PAWN:\n            file = chess.square_file(square)\n            rank = chess.square_rank(square)\n            if (board.piece_at(chess.square(file, rank + 1)) if rank < 7 else None) or \\\n               (board.piece_at(chess.square(file, rank - 1)) if rank > 0 else None):\n                pawn_structure_score += 1  # Connected pawn\n            else:\n                pawn_structure_score -= 1  # Isolated pawn\n    return float(pawn_structure_score)", "def feature(board: chess.Board) -> float:\n    \"Calculates the ratio of knights to total pieces on the board.\"\n    knight_count = sum(1 for piece in board.piece_map().values() if piece.piece_type == chess.KNIGHT)\n    total_pieces = len(board.piece_map())\n    return float(knight_count / total_pieces) if total_pieces > 0 else 0.0", "def feature(board: chess.Board) -> float:\n    \"Measures the number of pins (pieces that are unable to move due to a threat to the king).\"\n    pin_count = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == board.turn:\n            for target in board.attackers(not piece.color, square):\n                if board.is_attacked_by(piece.color, target):\n                    pin_count += 1\n                    break\n    return float(pin_count)", "def feature(board: chess.Board) -> float:\n    \"Evaluates the control of the center by counting pieces on the central squares (d4, d5, e4, e5).\"\n    central_squares = [chess.D4, chess.D5, chess.E4, chess.E5]\n    control_count = 0\n    for square in central_squares:\n        if board.piece_at(square) is not None:\n            if board.piece_at(square).color == board.turn:\n                control_count += 1\n            else:\n                control_count -= 1\n    return float(control_count)", "def feature(board: chess.Board) -> float:\n    \"Evaluates the king's pawn structure by counting the number of pawns that can help defend the king.\"\n    king_square = board.king(chess.WHITE) if board.turn else board.king(chess.BLACK)\n    if king_square is None:\n        return 0.0\n    defending_pawns = 0\n    for dx in [-1, 0, 1]:  # Check the files left, right, and the same\n        if 0 <= (chess.square_file(king_square) + dx) < 8:\n            defending_square = chess.square(chess.square_file(king_square) + dx, chess.square_rank(king_square) - (1 if board.turn else -1))\n            if board.piece_at(defending_square) and board.piece_at(defending_square).piece_type == chess.PAWN:\n                defending_pawns += 1\n    return float(defending_pawns)", "def feature(board: chess.Board) -> float:\n    \"Measures the total number of pieces for each side to assess material balance.\"\n    white_pieces = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE)\n    black_pieces = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK)\n    return float(white_pieces - black_pieces)", "def feature(board: chess.Board) -> float:\n    \"Calculates the sum of piece values for both sides based on standard piece values.\"\n    piece_values = {\n        chess.PAWN: 100,\n        chess.KNIGHT: 320,\n        chess.BISHOP: 330,\n        chess.ROOK: 500,\n        chess.QUEEN: 900,\n        chess.KING: 0\n    }\n    white_value = sum(piece_values[piece.piece_type] for piece in board.piece_map().values() if piece.color == chess.WHITE)\n    black_value = sum(piece_values[piece.piece_type] for piece in board.piece_map().values() if piece.color == chess.BLACK)\n    return float(white_value - black_value)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pawns advanced for both sides and returns the difference.\"\n    white_advanced_pawns = sum(1 for square, piece in board.piece_map().items() if piece.color == chess.WHITE and chess.square_rank(square) >= 4)\n    black_advanced_pawns = sum(1 for square, piece in board.piece_map().items() if piece.color == chess.BLACK and chess.square_rank(square) <= 3)\n    return float(white_advanced_pawns - black_advanced_pawns)", "def feature(board: chess.Board) -> float:\n    \"Calculates the ratio of major pieces (Rooks and Queens) to total pieces.\"\n    total_major_pieces = sum(1 for piece in board.piece_map().values() if piece.piece_type in {chess.ROOK, chess.QUEEN})\n    total_pieces = len(board.piece_map())\n    return float(total_major_pieces) / total_pieces if total_pieces > 0 else 0.0", "def feature(board: chess.Board) -> float:\n    \"Measures the number of pieces in the opponent's territory (ranks 6-8 for White and 1-3 for Black).\"\n    white_pieces_in_opponent_territory = sum(1 for square, piece in board.piece_map().items() if piece.color == chess.WHITE and chess.square_rank(square) >= 6)\n    black_pieces_in_opponent_territory = sum(1 for square, piece in board.piece_map().items() if piece.color == chess.BLACK and chess.square_rank(square) <= 2)\n    return float(white_pieces_in_opponent_territory - black_pieces_in_opponent_territory)", "def feature(board: chess.Board) -> float:\n    \"Checks if there are any pieces in check and gives a score based on that.\"\n    return float(board.is_check())  # Returns 1.0 if in check, else 0.0", "def feature(board: chess.Board) -> float:\n    \"Calculates the average distance of all pieces from their back rank to assess piece development.\"\n    distance_sum = 0\n    pieces_count = 0\n\n    for square, piece in board.piece_map().items():\n        distance = chess.square_rank(square) if piece.color == chess.WHITE else 7 - chess.square_rank(square)\n        distance_sum += distance\n        pieces_count += 1\n\n    return distance_sum / pieces_count if pieces_count > 0 else 0.0", "def feature(board: chess.Board) -> float:\n    \"Measures the total number of legal moves available for each player to assess mobility.\"\n    legal_moves_white = len(list(board.legal_moves)) if board.turn else 0\n    board.turn = not board.turn\n    legal_moves_black = len(list(board.legal_moves)) if board.turn else 0\n    board.turn = not board.turn  # Reset turn\n    return float(legal_moves_white - legal_moves_black)", "def feature(board: chess.Board) -> float:\n    \"Calculates the imbalance based on the types of pieces remaining on the board.\"\n    piece_count = {chess.PAWN: 0, chess.KNIGHT: 0, chess.BISHOP: 0, chess.ROOK: 0, chess.QUEEN: 0, chess.KING: 0}\n    for piece in board.piece_map().values():\n        piece_count[piece.piece_type] += 1\n    imbalance_score = sum(piece_count.values())\n    return float(piece_count[chess.QUEEN] + piece_count[chess.ROOK]) - float(piece_count[chess.PAWN] + piece_count[chess.KNIGHT] + piece_count[chess.BISHOP]) / imbalance_score if imbalance_score > 0 else 0.0", "def feature(board: chess.Board) -> float:\n    \"Counts the total number of pieces on the board and returns it as a feature.\"\n    return float(len(board.piece_map()))", "def feature(board: chess.Board) -> float:\n    \"Measures the total material value of all pieces currently on the board.\"\n    piece_values = {\n        chess.PAWN: 100, chess.KNIGHT: 320, chess.BISHOP: 330,\n        chess.ROOK: 500, chess.QUEEN: 900, chess.KING: 0\n    }\n    total_value = sum(piece_values[piece.piece_type] for piece in board.piece_map().values())\n    return float(total_value)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of advanced pawns for both players.\"\n    advanced_pawns = 0\n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.PAWN:\n            if (piece.color == chess.WHITE and chess.square_rank(square) >= 4) or \\\n               (piece.color == chess.BLACK and chess.square_rank(square) <= 3):\n                advanced_pawns += 1\n    return float(advanced_pawns)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of pieces that are currently in check.\"\n    check_count = 0\n    for square, piece in board.piece_map().items():\n        if board.is_attacked_by(not piece.color, square):\n            check_count += 1\n    return float(check_count)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of safe squares for each player's king.\"\n    white_king = board.king(chess.WHITE)\n    black_king = board.king(chess.BLACK)\n    \n    def safe_squares_count(king_square):\n        safe_count = 0\n        for move in board.legal_moves:\n            if move.from_square == king_square:\n                safe_count += 1\n        return safe_count\n    \n    return float(safe_squares_count(white_king) + safe_squares_count(black_king))", "def feature(board: chess.Board) -> float:\n    \"Measures the maximum rank of pawns for White and Black.\"\n    max_rank_white = max((chess.square_rank(square) for square in board.piece_map() \n                          if board.piece_map()[square].color == chess.WHITE and \n                          board.piece_map()[square].piece_type == chess.PAWN), default=-1)\n    \n    max_rank_black = max((chess.square_rank(square) for square in board.piece_map() \n                          if board.piece_map()[square].color == chess.BLACK and \n                          board.piece_map()[square].piece_type == chess.PAWN), default=-1)\n    \n    return float(max_rank_white - max_rank_black)", "def feature(board: chess.Board) -> float:\n    \"Calculates the ratio of major pieces (rooks and queens) to total pieces on the board.\"\n    major_pieces = sum(1 for piece in board.piece_map().values() \n                       if piece.piece_type in [chess.ROOK, chess.QUEEN])\n    total_pieces = len(board.piece_map())\n    return float(major_pieces / total_pieces) if total_pieces > 0 else 0.0", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of pieces on the board that are attacked.\"\n    attacked_pieces_count = sum(1 for square in board.piece_map() \n                                 if board.is_attacked_by(not board.piece_map()[square].color, square))\n    return float(attacked_pieces_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the average distance of pieces from their respective back ranks.\"\n    total_distance = 0.0\n    piece_count = 0\n    \n    for square, piece in board.piece_map().items():\n        if piece.color == chess.WHITE:\n            distance = chess.square_rank(square)\n        else:\n            distance = 7 - chess.square_rank(square)\n        \n        total_distance += distance\n        piece_count += 1\n    \n    return total_distance / piece_count if piece_count > 0 else 0.0", "def feature(board: chess.Board) -> float:\n    \"Measures the difference in material evaluated by color (positive if White's material is higher).\"\n    white_value = sum(piece.piece_type for square, piece in board.piece_map().items() \n                      if piece.color == chess.WHITE)\n    black_value = sum(piece.piece_type for square, piece in board.piece_map().items() \n                      if piece.color == chess.BLACK)\n    return float(white_value - black_value)", "def feature(board: chess.Board) -> float:\n    \"Calculates the central control by counting the number of pieces on central squares (d4, d5, e4, e5).\"\n    central_squares = [chess.D4, chess.D5, chess.E4, chess.E5]\n    control_count = sum(1 for square in central_squares if board.piece_at(square))\n    return float(control_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the total mobility of all pieces by counting legal moves.\"\n    mobility = sum(len(list(board.legal_moves)) for piece in board.piece_map().values() if piece.color == board.turn)\n    return float(mobility)", "def feature(board: chess.Board) -> float:\n    \"Calculates the total value of pieces on the board for each player, returning the difference.\"\n    values = {chess.PAWN: 100, chess.KNIGHT: 320, chess.BISHOP: 330, chess.ROOK: 500, chess.QUEEN: 900, chess.KING: 0}\n    total_white = sum(values[piece.piece_type] for piece in board.piece_map().values() if piece.color == chess.WHITE)\n    total_black = sum(values[piece.piece_type] for piece in board.piece_map().values() if piece.color == chess.BLACK)\n    return float(total_white - total_black)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces threatening the opponent's king to assess direct threats.\"\n    opponent_king_square = next(square for square, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color != board.turn)\n    threats = sum(1 for piece in board.piece_map().values() if piece.color == board.turn and board.is_attacked_by(not piece.color, opponent_king_square))\n    return float(threats)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of advanced pawns for each player and returns the difference.\"\n    white_advanced_pawns = sum(1 for sq in board.piece_map() if board.piece_at(sq).color == chess.WHITE and chess.square_rank(sq) >= 4)\n    black_advanced_pawns = sum(1 for sq in board.piece_map() if board.piece_at(sq).color == chess.BLACK and chess.square_rank(sq) <= 3)\n    return float(white_advanced_pawns - black_advanced_pawns)", "def feature(board: chess.Board) -> float:\n    \"Calculates the material advantage based on piece value and returns it in centipawns.\"\n    piece_values = {chess.PAWN: 100, chess.KNIGHT: 320, chess.BISHOP: 330,\n                    chess.ROOK: 500, chess.QUEEN: 900, chess.KING: 20000}\n    material_balance = sum(piece_values[board.piece_at(sq).piece_type] * (1 if board.piece_at(sq).color == chess.WHITE else -1)\n                           for sq in board.piece_map())\n    return float(material_balance)", "def feature(board: chess.Board) -> float:\n    \"Measures the total number of pieces on the board and returns the ratio of active pieces.\"\n    total_pieces = len(board.piece_map())\n    active_pieces = len([piece for piece in board.piece_map().values() if piece.color == board.turn])\n    return float(active_pieces / total_pieces) if total_pieces > 0 else 0.0", "def feature(board: chess.Board) -> float:\n    \"Measures the mobility of each player by counting legal moves.\"\n    white_mobility = len(list(board.legal_moves)) if board.turn == chess.WHITE else 0\n    black_mobility = len(list(board.legal_moves)) if board.turn == chess.BLACK else 0\n    return float(white_mobility - black_mobility)", "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in the number of pawns left for each player.\"\n    white_pawns = sum(1 for sq in board.piece_map() if board.piece_at(sq).piece_type == chess.PAWN and board.piece_at(sq).color == chess.WHITE)\n    black_pawns = sum(1 for sq in board.piece_map() if board.piece_at(sq).piece_type == chess.PAWN and board.piece_at(sq).color == chess.BLACK)\n    return float(white_pawns - black_pawns)", "def feature(board: chess.Board) -> float:\n    \"Measures the distance of the king from the center of the board to assess safety.\"\n    king_square = next((sq for sq in board.piece_map() if board.piece_at(sq).piece_type == chess.KING), None)\n    if king_square is not None:\n        center_distance = chess.square_distance(king_square, chess.parse_square('e4')) + chess.square_distance(king_square, chess.parse_square('e5'))\n        return float(center_distance)\n    return 0.0", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pinned pieces for the current player.\"\n    pinned_count = 0\n    for sq in board.piece_map():\n        piece = board.piece_at(sq)\n        if piece.color == board.turn:\n            if board.is_attacked_by(not board.turn, sq):\n                pinned_count += 1\n    return float(pinned_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of squares attacked by each player.\"\n    white_attacks = sum(1 for sq in chess.SQUARES if board.is_attacked_by(chess.WHITE, sq))\n    black_attacks = sum(1 for sq in chess.SQUARES if board.is_attacked_by(chess.BLACK, sq))\n    return float(white_attacks - black_attacks)", "def feature(board: chess.Board) -> float:\n    \"Measures the average piece square value for each color and returns their difference.\"\n    piece_square_table = {\n        chess.PAWN: [0 for _ in range(64)],  # Simplification for zero contribution\n        chess.KNIGHT: [0 for _ in range(64)],\n        chess.BISHOP: [0 for _ in range(64)],\n        chess.ROOK: [0 for _ in range(64)],\n        chess.QUEEN: [0 for _ in range(64)],\n        chess.KING: [0 for _ in range(64)]\n    }\n    white_value = sum(piece_square_table[board.piece_at(sq).piece_type][sq] for sq in board.piece_map() if board.piece_at(sq).color == chess.WHITE)\n    black_value = sum(piece_square_table[board.piece_at(sq).piece_type][sq] for sq in board.piece_map() if board.piece_at(sq).color == chess.BLACK)\n    return float(white_value - black_value)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of opponent's pieces that are attacking the king's position.\"\n    king_square = next(square for square, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color == board.turn)\n    attackers = len(board.attackers(not board.turn, king_square))\n    return float(attackers)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pawns that have advanced to the 4th and 5th ranks for White, and 4th and 3rd ranks for Black.\"\n    white_advanced_pawns = sum(1 for square in board.piece_map() if board.piece_at(square).piece_type == chess.PAWN and square >= chess.A4)\n    black_advanced_pawns = sum(1 for square in board.piece_map() if board.piece_at(square).piece_type == chess.PAWN and square <= chess.H3)\n    return float(white_advanced_pawns - black_advanced_pawns)", "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in the number of pieces on squares with two or more attacks.\"\n    strong_squares_white = sum(1 for square in board.piece_map() if board.piece_at(square).color == chess.WHITE and len(board.attackers(chess.BLACK, square)) > 1)\n    strong_squares_black = sum(1 for square in board.piece_map() if board.piece_at(square).color == chess.BLACK and len(board.attackers(chess.WHITE, square)) > 1)\n    return float(strong_squares_white - strong_squares_black)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces within two squares of the center of the board.\"\n    center_squares = [chess.D4, chess.D5, chess.E4, chess.E5]\n    center_count = sum(1 for square in board.piece_map() if square in center_squares)\n    return float(center_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the mobility of the current player's pieces by counting legal moves available.\"\n    legal_moves_count = len(list(board.legal_moves))\n    return float(legal_moves_count)", "def feature(board: chess.Board) -> float:\n    \"Checks if the current player's king is in check and returns a higher penalty if so.\"\n    return float(-1000.0 if board.is_check() else 0.0)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of pieces around the opponent's king that are capable of delivering a check.\"\n    king_square = next(square for square, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color != board.turn)\n    attacking_pieces = sum(1 for move in board.legal_moves if move.to_square == king_square)\n    return float(attacking_pieces)", "def feature(board: chess.Board) -> float:\n    \"Calculates the disparity in defended versus undefended pieces for the current player.\"\n    defended_pieces = sum(1 for square in board.piece_map() if board.piece_at(square).color == board.turn and board.attackers(not board.turn, square))\n    undefended_pieces = sum(1 for square in board.piece_map() if board.piece_at(square).color == board.turn and not board.attackers(not board.turn, square))\n    return float(defended_pieces - undefended_pieces)", "def feature(board: chess.Board) -> float:\n    'Measures the number of connected pawns for the current player.'\n    connected_pawns = 0\n    for file in range(8):\n        pawns = [board.piece_at(chess.square(file, rank)) for rank in range(8) if board.piece_at(chess.square(file, rank)) and board.piece_at(chess.square(file, rank)).piece_type == chess.PAWN and board.piece_at(chess.square(file, rank)).color == board.turn]\n        connected_pawns += len(pawns)\n        if len(pawns) > 1:\n            connected_pawns += len(pawns) - 1  # Each pair of connected pawns adds to the score\n    return float(connected_pawns)", "def feature(board: chess.Board) -> float:\n    'Calculates the average distance of pieces from their respective back ranks.'\n    distance_sum = 0\n    piece_count = 0\n    for square, piece in board.piece_map().items():\n        distance = chess.square_rank(square) if piece.color == chess.WHITE else 7 - chess.square_rank(square)\n        distance_sum += distance\n        piece_count += 1\n    return distance_sum / piece_count if piece_count > 0 else 0.0", "def feature(board: chess.Board) -> float:\n    'Measures the material disparity in terms of piece types.'\n    material_score = 0\n    piece_values = {chess.PAWN: 100, chess.KNIGHT: 320, chess.BISHOP: 330, chess.ROOK: 500, chess.QUEEN: 900}\n    for piece in board.piece_map().values():\n        value = piece_values.get(piece.piece_type, 0)\n        material_score += value if piece.color == chess.WHITE else -value\n    return material_score", "def feature(board: chess.Board) -> float:\n    'Calculates the number of squares attacked by the opponent\u2019s pieces.'\n    attacked_squares = set()\n    for square, piece in board.piece_map().items():\n        if piece.color != board.turn:\n            attacked_squares.update(board.attackers(board.turn, square))\n    return float(len(attacked_squares))", "def feature(board: chess.Board) -> float:\n    'Measures the number of open files for rook potential.'\n    open_files = 0\n    for file in range(8):\n        if all(board.piece_at(chess.square(file, rank)) is None for rank in range(8)):\n            open_files += 1\n    return float(open_files)", "def feature(board: chess.Board) -> float:\n    'Counts the number of pieces on the board besides pawns.'\n    non_pawn_piece_count = sum(1 for piece in board.piece_map().values() if piece.piece_type != chess.PAWN)\n    return float(non_pawn_piece_count)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of pieces attacking the king of the opponent.\"\n    opponent_king_square = board.king(chess.WHITE) if board.turn else board.king(chess.BLACK)\n    attackers_count = len(board.attackers(chess.WHITE if board.turn else chess.BLACK, opponent_king_square))\n    return float(attackers_count)", "def feature(board: chess.Board) -> float:\n    \"Counts the total number of pawns for each player and returns the difference.\"\n    white_pawns = len([p for p in board.piece_map().values() if p.piece_type == chess.PAWN and p.color == chess.WHITE])\n    black_pawns = len([p for p in board.piece_map().values() if p.piece_type == chess.PAWN and p.color == chess.BLACK])\n    return float(white_pawns - black_pawns)", "def feature(board: chess.Board) -> float:\n    \"Calculates the control of central squares (d4, d5, e4, e5) by the current player.\"\n    central_squares = [chess.parse_square('d4'), chess.parse_square('d5'), chess.parse_square('e4'), chess.parse_square('e5')]\n    control_count = sum(1 for square in central_squares if board.is_attacked_by(board.turn, square))\n    return float(control_count)", "def feature(board: chess.Board) -> float:\n    \"Measures the total distance of all pieces from their opposing back rank.\"\n    total_distance = sum(chess.square_rank(square) for square, piece in board.piece_map().items() if piece.color == (chess.WHITE if board.turn else chess.BLACK))\n    return float(total_distance)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces near the opponent's king.\"\n    opponent_king_square = board.king(chess.WHITE) if board.turn else board.king(chess.BLACK)\n    near_count = sum(1 for square, piece in board.piece_map().items() \n                     if piece.color == (chess.WHITE if board.turn else chess.BLACK) and \n                     chess.square_distance(square, opponent_king_square) <= 2)\n    return float(near_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the total number of legal moves available for the current player.\"\n    legal_moves_count = len(list(board.legal_moves))\n    return float(legal_moves_count)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of pieces that are pinned (unable to move without exposing the king).\"\n    pinned_count = sum(1 for square, piece in board.piece_map().items() \n                       if board.is_attacked_by(not board.turn, square) and \n                       not board.is_attacked_by(board.turn, square))\n    return float(pinned_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the average distance of all pieces of the current player from the center of the board.\"\n    current_player = chess.WHITE if board.turn else chess.BLACK\n    total_distance = sum(chess.square_distance(square, chess.parse_square('e4')) for square, piece in board.piece_map().items() if piece.color == current_player)\n    pieces_count = len([piece for piece in board.piece_map().values() if piece.color == current_player])\n    avg_distance = total_distance / pieces_count if pieces_count > 0 else 0\n    return float(avg_distance)", "def feature(board: chess.Board) -> float:\n    \"Measures the difference between the number of rooks for both players.\"\n    white_rooks = len([p for p in board.piece_map().values() if p.piece_type == chess.ROOK and p.color == chess.WHITE])\n    black_rooks = len([p for p in board.piece_map().values() if p.piece_type == chess.ROOK and p.color == chess.BLACK])\n    return float(white_rooks - black_rooks)", "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in the number of pieces on the board between the two players.\"\n    white_pieces = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE)\n    black_pieces = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK)\n    return float(white_pieces - black_pieces)", "def feature(board: chess.Board) -> float:\n    \"Counts and returns the number of pawns present on the board.\"\n    pawn_count = sum(1 for piece in board.piece_map().values() if piece.piece_type == chess.PAWN)\n    return float(pawn_count)", "def feature(board: chess.Board) -> float:\n    \"Measures the distance of the closest king to the center of the board.\"\n    white_king_square = board.king(chess.WHITE)\n    black_king_square = board.king(chess.BLACK)\n    center_sq = chess.parse_square('e4')\n    white_distance = chess.square_distance(white_king_square, center_sq)\n    black_distance = chess.square_distance(black_king_square, center_sq)\n    return float(min(white_distance, black_distance))", "def feature(board: chess.Board) -> float:\n    \"Calculates the total value of all pieces remaining on the board for the current player.\"\n    piece_values = {\n        chess.PAWN: 100,\n        chess.KNIGHT: 320,\n        chess.BISHOP: 330,\n        chess.ROOK: 500,\n        chess.QUEEN: 900,\n        chess.KING: 0\n    }\n    total_value = sum(piece_values[piece.piece_type] for square, piece in board.piece_map().items() if piece.color == board.turn)\n    return float(total_value)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of squares in the opponent's half that are controlled by the current player's pieces.\"\n    controlled_squares = set()\n    for square in board.piece_map():\n        piece = board.piece_map()[square]\n        if piece.color == board.turn:\n            for move in board.legal_moves:\n                if move.from_square == square:\n                    controlled_squares.add(move.to_square)\n    opponent_half = {i for i in range(0, 32)} if board.turn == chess.WHITE else {i for i in range(32, 64)}\n    controlled_in_half = controlled_squares.intersection(opponent_half)\n    return float(len(controlled_in_half))", "def feature(board: chess.Board) -> float:\n    \"Measures the number of pieces currently in their ideal starting positions.\"\n    ideal_positions = {\n        chess.WHITE: [chess.A2, chess.B2, chess.C2, chess.D2, chess.E2, chess.F2, chess.G2, chess.H2],\n        chess.BLACK: [chess.A7, chess.B7, chess.C7, chess.D7, chess.E7, chess.F7, chess.G7, chess.H7]\n    }\n    ideal_count = sum(1 for square in ideal_positions[board.turn] if board.piece_at(square) is not None)\n    return float(ideal_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the average rank of all pieces for the current player.\"\n    total_rank = 0\n    piece_count = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == board.turn:\n            total_rank += chess.square_rank(square)\n            piece_count += 1\n    return float(total_rank / piece_count) if piece_count > 0 else 0.0", "def feature(board: chess.Board) -> float:\n    \"Calculates how many ranks the player's pieces have advanced compared to their starting positions.\"\n    advance_positions = {\n        chess.WHITE: range(0, 8), \n        chess.BLACK: range(8, 16)\n    }\n    rank_advance = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == board.turn:\n            rank_advance += chess.square_rank(square)\n    return float(rank_advance)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces pinned against the king by the opponent.\"\n    pinned_count = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == board.turn:\n            for attacker in board.attackers(not board.turn, board.king(board.turn)):\n                # Check if the piece is pinned\n                if board.is_attacked_by(not board.turn, square):\n                    pinned_count += 1\n                    break\n    return float(pinned_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of squares under attack by each player.\"\n    white_attacked = sum(board.is_attacked_by(chess.WHITE, square) for square in chess.SQUARES)\n    black_attacked = sum(board.is_attacked_by(chess.BLACK, square) for square in chess.SQUARES)\n    return float(white_attacked - black_attacked)", "def feature(board: chess.Board) -> float:\n    \"Measures the total value of all minor pieces on the board.\"\n    piece_values = {chess.KNIGHT: 3, chess.BISHOP: 3}\n    value = sum(piece_values[piece.piece_type] for piece in board.piece_map().values() if piece.piece_type in piece_values)\n    return float(value)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of available legal moves for the player to move.\"\n    return float(len(list(board.legal_moves)))", "def feature(board: chess.Board) -> float:\n    \"Measures the material balance by counting only pawns.\"\n    white_pawns = len([1 for piece in board.piece_map().values() if piece.color == chess.WHITE and piece.piece_type == chess.PAWN])\n    black_pawns = len([1 for piece in board.piece_map().values() if piece.color == chess.BLACK and piece.piece_type == chess.PAWN])\n    return float(white_pawns - black_pawns)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of pieces on the board and their distance to the center (files 3-4).\"\n    distance_sum = sum(\n        chess.square_distance(square, chess.E4) + chess.square_distance(square, chess.D4) \n        for square, piece in board.piece_map().items()\n    )\n    return float(distance_sum)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of discovered attacks available on the board.\"\n    discovered_check_count = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == board.turn:\n            for move in board.legal_moves:\n                if move.from_square == square and board.is_check():\n                    discovered_check_count += 1\n    return float(discovered_check_count)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of pieces contributing to control of the center squares (d4, d5, e4, e5).\"\n    center_squares = [chess.D4, chess.D5, chess.E4, chess.E5]\n    control_count = sum(1 for square in center_squares if board.is_attacked_by(chess.WHITE, square))\n    control_count -= sum(1 for square in center_squares if board.is_attacked_by(chess.BLACK, square))\n    return float(control_count)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pawns for each player on the board.\"\n    white_pawns = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE and piece.piece_type == chess.PAWN)\n    black_pawns = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK and piece.piece_type == chess.PAWN)\n    return float(white_pawns - black_pawns)", "def feature(board: chess.Board) -> float:\n    \"Calculates the total distance of all pieces from their respective back ranks.\"\n    total_distance = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == chess.WHITE:\n            total_distance += chess.square_rank(square)\n        else:\n            total_distance += 7 - chess.square_rank(square)\n    return float(total_distance)", "def feature(board: chess.Board) -> float:\n    \"Measures the ratio of pieces on the board for each player.\"\n    total_white = len([p for p in board.piece_map().values() if p.color == chess.WHITE])\n    total_black = len([p for p in board.piece_map().values() if p.color == chess.BLACK])\n    ratio = total_white / (total_black + 1e-5)  # Avoid division by zero\n    return float(ratio)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces that are attacking the opponent's king.\"\n    white_king_square = next((sq for sq, piece in board.piece_map().items() if piece.color == chess.WHITE and piece.piece_type == chess.KING), None)\n    black_king_square = next((sq for sq, piece in board.piece_map().items() if piece.color == chess.BLACK and piece.piece_type == chess.KING), None)\n    attacking_count = len(board.attackers(chess.WHITE, black_king_square)) + len(board.attackers(chess.BLACK, white_king_square))\n    return float(attacking_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the total material value of pieces on the board.\"\n    piece_value = {chess.PAWN: 100, chess.KNIGHT: 320, chess.BISHOP: 330, chess.ROOK: 500, chess.QUEEN: 900, chess.KING: 0}\n    total_value = sum(piece_value[piece.piece_type] for piece in board.piece_map().values())\n    return float(total_value)", "def feature(board: chess.Board) -> float:\n    \"Measures the pawn structure by counting isolated, doubled, and backward pawns.\"\n    pawn_structure_score = 0\n    for rank in range(8):\n        files = [(file, board.piece_at(chess.square_rank(rank) * 8 + file)) for file in range(8)]\n        pawns = [file for file, piece in files if piece and piece.piece_type == chess.PAWN]\n        isolated = [file for file in pawns if (file == 0 or board.piece_at(chess.square_rank(rank) * 8 + file - 1) is None) and\n                    (file == 7 or board.piece_at(chess.square_rank(rank) * 8 + file + 1) is None)]\n        pawn_structure_score += len(isolated)\n    return float(pawn_structure_score)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces attacking or defending the center squares (d4, d5, e4, e5).\"\n    center_squares = [chess.D4, chess.D5, chess.E4, chess.E5]\n    attack_defense_count = sum(1 for square in center_squares if board.attackers(chess.WHITE, square) or board.attackers(chess.BLACK, square))\n    return float(attack_defense_count)", "def feature(board: chess.Board) -> float:\n    \"Measures the total distance of all pieces from their opponent's back rank (8th for White, 1st for Black).\"\n    distance = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == chess.WHITE:\n            distance += (7 - chess.square_rank(square))\n        else:\n            distance += chess.square_rank(square)\n    return float(distance)", "def feature(board: chess.Board) -> float:\n    \"Measures the total number of pieces on the board for both players.\"\n    total_pieces = sum(1 for piece in board.piece_map().values())\n    return float(total_pieces)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pawns on the board, distinguishing their contribution to the position.\"\n    pawn_count = sum(1 for piece in board.piece_map().values() if piece.piece_type == chess.PAWN)\n    return float(pawn_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in the number of pieces between White and Black.\"\n    white_piece_count = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE)\n    black_piece_count = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK)\n    return float(white_piece_count - black_piece_count)", "def feature(board: chess.Board) -> float:\n    \"Measures how many pieces are attacking or defending the kings on the board.\"\n    white_king_square = next(square for square, piece in board.piece_map().items() if piece.color == chess.WHITE and piece.piece_type == chess.KING)\n    black_king_square = next(square for square, piece in board.piece_map().items() if piece.color == chess.BLACK and piece.piece_type == chess.KING)\n    attacking_white = sum(1 for square in board.attackers(chess.WHITE, black_king_square))\n    attacking_black = sum(1 for square in board.attackers(chess.BLACK, white_king_square))\n    return float(attacking_white - attacking_black)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of advanced pawns (pawns on the 4th or 5th rank for White and 4th or 3rd for Black).\"\n    advanced_pawns = sum(1 for square, piece in board.piece_map().items() if piece.piece_type == chess.PAWN and (\n        (piece.color == chess.WHITE and chess.square_rank(square) >= 4) or\n        (piece.color == chess.BLACK and chess.square_rank(square) <= 4)\n    ))\n    return float(advanced_pawns)", "def feature(board: chess.Board) -> float:\n    \"Measures the distance of all pieces from their starting positions, summing their distances.\"\n    distance_sum = sum(chess.square_distance(square, piece.piece_type) for square, piece in board.piece_map().items())\n    return float(distance_sum)", "def feature(board: chess.Board) -> float:\n    \"Calculates the proximity of the closest king to opposing pieces on the board.\"\n    white_king_square = next(square for square, piece in board.piece_map().items() if piece.color == chess.WHITE and piece.piece_type == chess.KING)\n    black_king_square = next(square for square, piece in board.piece_map().items() if piece.color == chess.BLACK and piece.piece_type == chess.KING)\n    min_distance = min(chess.square_distance(white_king_square, square) for square in board.piece_map() if board.piece_map()[square].color == chess.BLACK)\n    min_distance_black = min(chess.square_distance(black_king_square, square) for square in board.piece_map() if board.piece_map()[square].color == chess.WHITE)\n    return float(min(min_distance, min_distance_black))", "def feature(board: chess.Board) -> float:\n    \"Counts the total number of checks that player's pieces can deliver in the position.\"\n    checks = sum(1 for move in board.legal_moves if board.is_check())\n    return float(checks)", "def feature(board: chess.Board) -> float:\n    \"Assesses the activity of pieces by counting the number of legal moves available.\"\n    legal_moves_count = sum(1 for _ in board.legal_moves)\n    return float(legal_moves_count)", "def feature(board: chess.Board) -> float:\n    \"Measures the material imbalance based on the type and count of pieces.\"\n    piece_values = {\n        chess.PAWN: 100,\n        chess.KNIGHT: 320,\n        chess.BISHOP: 330,\n        chess.ROOK: 500,\n        chess.QUEEN: 900,\n        chess.KING: 0\n    }\n    material_balance = sum(piece_values[piece.piece_type] if piece.color == chess.WHITE else -piece_values[piece.piece_type]\n                           for piece in board.piece_map().values())\n    return float(material_balance)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces in the opponent's territory.\"\n    opponent_color = chess.BLACK if board.turn else chess.WHITE\n    count = sum(1 for sq in board.piece_map() if board.piece_at(sq).color == opponent_color and (chess.square_rank(sq) > 4 if board.turn else chess.square_rank(sq) < 4))\n    return float(count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the total value of all pieces for the current player.\"\n    piece_values = {chess.PAWN: 100, chess.KNIGHT: 320, chess.BISHOP: 330, chess.ROOK: 500, chess.QUEEN: 900, chess.KING: 20000}\n    total_value = sum(piece_values[board.piece_at(sq).piece_type] for sq in board.piece_map() if board.piece_at(sq).color == board.turn)\n    return float(total_value)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pawns on the 7th rank for promotion opportunities.\"\n    count = sum(1 for sq in board.piece_map() if board.piece_at(sq).piece_type == chess.PAWN and (chess.square_rank(sq) == 6 if board.turn else chess.square_rank(sq) == 1))\n    return float(count)", "def feature(board: chess.Board) -> float:\n    \"Measures the central control by counting pieces on central squares.\"\n    central_squares = [chess.E4, chess.D4, chess.E5, chess.D5]\n    count = sum(1 for sq in central_squares if board.piece_at(sq) is not None and board.piece_at(sq).color == board.turn)\n    return float(count)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of protected pieces for the current player.\"\n    protected_count = 0\n    for sq in board.piece_map():\n        piece = board.piece_at(sq)\n        if piece.color == board.turn:\n            if any(board.is_attacked_by(opponent_color, sq) for opponent_color in [chess.WHITE, chess.BLACK] if opponent_color != piece.color):\n                continue\n            protected_count += 1\n    return float(protected_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in pawns between players.\"\n    white_pawns = len([1 for sq in board.piece_map() if board.piece_at(sq).piece_type == chess.PAWN and board.piece_at(sq).color == chess.WHITE])\n    black_pawns = len([1 for sq in board.piece_map() if board.piece_at(sq).piece_type == chess.PAWN and board.piece_at(sq).color == chess.BLACK])\n    return float(white_pawns - black_pawns)", "def feature(board: chess.Board) -> float:\n    \"Calculates how many pieces are attacking the opponent's king.\"\n    opponent_king_square = next(sq for sq, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color != board.turn)\n    attackers_count = len(board.attackers(board.turn, opponent_king_square))\n    return float(attackers_count)", "def feature(board: chess.Board) -> float:\n    \"Measures distance of all opponent's pieces from the king for potential threats.\"\n    opponent_color = chess.BLACK if board.turn else chess.WHITE\n    opponent_king_square = next(sq for sq in board.piece_map() if board.piece_at(sq).piece_type == chess.KING and board.piece_at(sq).color == opponent_color)\n    total_distance = sum(chess.square_distance(opponent_king_square, sq) for sq in board.piece_map() if board.piece_at(sq).color == opponent_color)\n    return float(total_distance)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of rooks controlled on open files for each player.\"\n    rook_count = 0\n    for file in range(8):\n        if not board.piece_at(chess.square(file, 0)) and not board.piece_at(chess.square(file, 1)) and not board.piece_at(chess.square(file, 2)):\n            rook_count += len([1 for rank in range(3, 8) if board.piece_at(chess.square(file, rank)) and board.piece_at(chess.square(file, rank)).piece_type == chess.ROOK and board.piece_at(chess.square(file, rank)).color == board.turn])\n    return float(rook_count)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of pieces attacking the opponent's king.\"\n    opponent_king_square = chess.square_name(board.king(chess.WHITE) if board.turn else board.king(chess.BLACK))\n    attackers_count = len(board.attackers(chess.WHITE if board.turn else chess.BLACK, chess.parse_square(opponent_king_square)))\n    return float(attackers_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of passed pawns for both players.\"\n    passed_pawns = 0\n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.PAWN:\n            if (piece.color == chess.WHITE and square >= chess.A4) or (piece.color == chess.BLACK and square <= chess.H5):\n                if not any(board.is_attacked_by(chess.WHITE if piece.color == chess.BLACK else chess.BLACK, chess.parse_square(chess.square_name(file_index))) for file_index in range(chess.square_file(square) + (1 if piece.color == chess.WHITE else -1), chess.square_file(square) + (2 if piece.color == chess.WHITE else 1))):\n                    passed_pawns += 1\n    return float(passed_pawns)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of pieces on the back rank for each player.\"\n    back_rank_count = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == chess.WHITE and chess.square_rank(square) == 0:\n            back_rank_count += 1\n        elif piece.color == chess.BLACK and chess.square_rank(square) == 7:\n            back_rank_count += 1\n    return float(back_rank_count)", "def feature(board: chess.Board) -> float:\n    \"Evaluates the position of each player's pieces relative to the center of the board.\"\n    center_control = 0\n    center_squares = [chess.D4, chess.D5, chess.E4, chess.E5]\n    for square, piece in board.piece_map().items():\n        if square in center_squares:\n            center_control += 1 if piece.color == chess.WHITE else -1\n    return float(center_control)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pawns that are on the 7th rank.\"\n    seventh_rank_count = sum(1 for square, piece in board.piece_map().items() if piece.piece_type == chess.PAWN and \n                               ((piece.color == chess.WHITE and chess.square_rank(square) == 6) or \n                                (piece.color == chess.BLACK and chess.square_rank(square) == 1)))\n    return float(seventh_rank_count)", "def feature(board: chess.Board) -> float:\n    \"Evaluates the king's safety based on how many squares around it are attacked.\"\n    king_square = board.king(chess.WHITE) if board.turn else board.king(chess.BLACK)\n    threatened_squares = sum(1 for i in range(chess.D2, chess.H3) if board.is_attacked_by(chess.WHITE if board.turn else chess.BLACK, i))\n    return float(threatened_squares)", "def feature(board: chess.Board) -> float:\n    \"Counts the difference in the number of pieces each player has that are still on the board.\"\n    white_pieces = len([p for p in board.piece_map().values() if p.color == chess.WHITE])\n    black_pieces = len([p for p in board.piece_map().values() if p.color == chess.BLACK])\n    return float(white_pieces - black_pieces)", "def feature(board: chess.Board) -> float:\n    \"Measures the piece activity based on the total number of legal moves available for both players.\"\n    white_moves = len(list(board.legal_moves)) if board.turn == chess.WHITE else 0\n    black_moves = len(list(board.legal_moves)) if board.turn == chess.BLACK else 0\n    return float(white_moves - black_moves)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pawns advanced beyond their starting ranks.\"\n    advanced_pawns = 0\n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.PAWN:\n            if (piece.color == chess.WHITE and chess.square_rank(square) >= 4) or \\\n               (piece.color == chess.BLACK and chess.square_rank(square) <= 3):\n                advanced_pawns += 1\n    return float(advanced_pawns)", "def feature(board: chess.Board) -> float:\n    \"Measures the mobility of pieces by counting the total number of legal moves available.\"\n    total_legal_moves = sum(1 for _ in board.legal_moves)\n    return float(total_legal_moves)", "def feature(board: chess.Board) -> float:\n    \"Calculates the difference between the number of pieces on the board.\"\n    white_piece_count = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE)\n    black_piece_count = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK)\n    return float(white_piece_count - black_piece_count)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of threatened pieces for the current player's pieces.\"\n    threatened_count = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == board.turn and board.is_attacked_by(not board.turn, square):\n            threatened_count += 1\n    return float(threatened_count)", "def feature(board: chess.Board) -> float:\n    \"Estimates material balance weighted by piece positions (higher rank, higher value).\"\n    piece_value = {chess.PAWN: 100, chess.KNIGHT: 320, chess.BISHOP: 330,\n                   chess.ROOK: 500, chess.QUEEN: 900, chess.KING: 20000}\n    material_score = 0\n    for square, piece in board.piece_map().items():\n        value = piece_value[piece.piece_type]\n        rank_value = (chess.square_rank(square) + 1) if piece.color == chess.WHITE else (8 - chess.square_rank(square))\n        material_score += value * rank_value\n    return float(material_score)", "def feature(board: chess.Board) -> float:\n    \"Counts the total number of pieces developed (not on the back rank).\"\n    developed_pieces = 0\n    back_rank = 0 if board.turn == chess.WHITE else 7\n    for square, piece in board.piece_map().items():\n        if piece.color == board.turn and chess.square_rank(square) != back_rank:\n            developed_pieces += 1\n    return float(developed_pieces)", "def feature(board: chess.Board) -> float:\n    \"Measures the pawn structure by evaluating doubled, isolated, and connected pawns.\"\n    doubled_pawns = 0\n    isolated_pawns = 0\n    connected_pawns = 0\n    for file in range(8):\n        file_pawns = []\n        for rank in range(8):\n            square = chess.square(file, rank)\n            piece = board.piece_at(square)\n            if piece and piece.piece_type == chess.PAWN:\n                file_pawns.append(piece.color)\n        \n        if len(file_pawns) > 1:\n            doubled_pawns += len(file_pawns) - 1\n        if len(file_pawns) == 1:\n            isolated_pawns += 1\n        if len(file_pawns) == 2 and file_pawns[0] == file_pawns[1]:\n            connected_pawns += 1\n    \n    return float(doubled_pawns + isolated_pawns - connected_pawns)", "def feature(board: chess.Board) -> float:\n    \"Calculates the average distance of all pieces to their corresponding back rank.\"\n    total_distance = 0\n    piece_count = 0\n    for square, piece in board.piece_map().items():\n        distance = abs(chess.square_rank(square) - (0 if piece.color == chess.WHITE else 7))\n        total_distance += distance\n        piece_count += 1 if piece.color == board.turn else 0\n    return total_distance / piece_count if piece_count > 0 else 0.0", "def feature(board: chess.Board) -> float:\n    \"Measures the distance of the nearest king from the center of the board.\"\n    center_square = chess.parse_square('e4')  # Using e4 as the center reference\n    white_king_square = board.king(chess.WHITE)\n    black_king_square = board.king(chess.BLACK)\n    white_distance = chess.square_distance(white_king_square, center_square) if white_king_square else float('inf')\n    black_distance = chess.square_distance(black_king_square, center_square) if black_king_square else float('inf')\n    return float(min(white_distance, black_distance))", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pawns advanced past the 4th rank for White and 3rd rank for Black.\"\n    advanced_pawns = 0\n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.PAWN:\n            if piece.color == chess.WHITE and chess.square_rank(square) >= 4:\n                advanced_pawns += 1\n            elif piece.color == chess.BLACK and chess.square_rank(square) <= 2:\n                advanced_pawns += 1\n    return float(advanced_pawns)", "def feature(board: chess.Board) -> float:\n    \"Calculates the total number of pieces that are directly attacking the opponent's king.\"\n    attacking_moves = 0\n    black_king_square = board.king(chess.BLACK)\n    white_king_square = board.king(chess.WHITE)\n    \n    for square, piece in board.piece_map().items():\n        if piece.color == chess.WHITE:\n            if board.is_attacked_by(chess.BLACK, square):\n                attacking_moves += 1\n        if piece.color == chess.BLACK:\n            if board.is_attacked_by(chess.WHITE, square):\n                attacking_moves += 1\n    return float(attacking_moves)", "def feature(board: chess.Board) -> float:\n    \"Calculates the piece mobility by counting the number of legal moves for the active color.\"\n    active_color = board.turn\n    legal_moves_count = len(list(board.legal_moves)) if active_color else 0\n    return float(legal_moves_count)", "def feature(board: chess.Board) -> float:\n    \"Counts the total number of pieces in the opponent's half of the board.\"\n    opponent_half_count = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == (chess.WHITE if board.turn == chess.BLACK else chess.BLACK):\n            if (piece.color == chess.WHITE and chess.square_rank(square) >= 4) or \\\n               (piece.color == chess.BLACK and chess.square_rank(square) <= 3):\n                opponent_half_count += 1\n    return float(opponent_half_count)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of pieces pinned against the king of the active color.\"\n    pinned_piece_count = 0\n    active_king_square = board.king(board.turn)\n    \n    for square, piece in board.piece_map().items():\n        if piece.color == board.turn:\n            for target_square in board.attackers(not board.turn, active_king_square):\n                if board.is_attacked_by(board.turn, square):\n                    pinned_piece_count += 1\n                    break\n    return float(pinned_piece_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in the number of pieces for both colors.\"\n    piece_count = {chess.WHITE: 0, chess.BLACK: 0}\n    for piece in board.piece_map().values():\n        piece_count[piece.color] += 1\n    return float(piece_count[chess.WHITE] - piece_count[chess.BLACK])", "def feature(board: chess.Board) -> float:\n    \"Computes the total distance of all pieces from their starting squares.\"\n    total_distance = 0\n    for square, piece in board.piece_map().items():\n        start_rank = piece.color == chess.WHITE and 1 or 6\n        start_file = chess.square_file(square)\n        distance = chess.square_distance(square, chess.parse_square(chess.square_name(start_file * 8 + start_rank)))\n        total_distance += distance\n    return float(total_distance)", "def feature(board: chess.Board) -> float:\n    \"Calculates the ratio of attacking pieces to total pieces for the active color.\"\n    active_color = board.turn\n    attacking_pieces = 0\n    total_pieces = len(board.piece_map())\n    \n    for square, piece in board.piece_map().items():\n        if piece.color == active_color and board.is_attacked_by(not active_color, square):\n            attacking_pieces += 1\n    return float(attacking_pieces / total_pieces) if total_pieces > 0 else 0.0", "def feature(board: chess.Board) -> float:\n    \"Measures the pawn structure by counting isolated pawns.\"\n    isolated_pawns = 0\n    for square in board.piece_map():\n        piece = board.piece_at(square)\n        if piece and piece.piece_type == chess.PAWN:\n            file_index = chess.square_file(square)\n            if (board.piece_at(chess.parse_square(chess.square_name(file_index - 1))) is None and\n                board.piece_at(chess.parse_square(chess.square_name(file_index + 1))) is None):\n                isolated_pawns += 1\n    return float(isolated_pawns)", "def feature(board: chess.Board) -> float:\n    \"Measures the total number of pawns on the board.\"\n    pawn_count = sum(1 for piece in board.piece_map().values() if piece.piece_type == chess.PAWN)\n    return float(pawn_count)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces within the opponent's last three ranks.\"\n    opponent_color = chess.WHITE if board.turn == chess.BLACK else chess.BLACK\n    rank_count = sum(1 for square in board.piece_map() if board.piece_at(square).color == opponent_color and chess.square_rank(square) >= 5)\n    return float(rank_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the average distance of all pieces from their starting positions.\"\n    total_distance = 0\n    piece_count = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == board.turn:\n            piece_count += 1\n            start_square = chess.parse_square('a1') if piece.piece_type == chess.PAWN else chess.parse_square('e1' if piece.color == chess.WHITE else 'e8')\n            total_distance += chess.square_distance(square, start_square)\n    return total_distance / piece_count if piece_count > 0 else 0.0", "def feature(board: chess.Board) -> float:\n    \"Measures the mobility by counting legal moves available for both players.\"\n    white_moves = len(list(board.legal_moves)) if board.turn == chess.WHITE else 0\n    black_moves = len(list(board.legal_moves)) if board.turn == chess.BLACK else 0\n    return float(white_moves - black_moves)", "def feature(board: chess.Board) -> float:\n    \"Evaluates the king's safety by counting the number of attacking pieces near the king.\"\n    king_square = next(square for square, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color == board.turn)\n    attackers = len(board.attackers(chess.WHITE if board.turn == chess.BLACK else chess.BLACK, king_square))\n    return float(attackers)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces with no legal moves (i.e., trapped pieces).\"\n    trapped_count = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == board.turn and len(list(board.legal_moves)) == 0:\n            trapped_count += 1\n    return float(trapped_count)", "def feature(board: chess.Board) -> float:\n    \"Measures the control of center squares (d4, d5, e4, e5).\"\n    center_squares = [chess.parse_square('d4'), chess.parse_square('d5'), chess.parse_square('e4'), chess.parse_square('e5')]\n    control_count = sum(1 for square in center_squares if board.is_attacked_by(board.turn, square))\n    return float(control_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in piece values between the two players.\"\n    piece_values = {chess.PAWN: 100, chess.KNIGHT: 320, chess.BISHOP: 330, chess.ROOK: 500, chess.QUEEN: 900, chess.KING: 0}\n    white_value = sum(piece_values[piece.piece_type] for piece in board.piece_map().values() if piece.color == chess.WHITE)\n    black_value = sum(piece_values[piece.piece_type] for piece in board.piece_map().values() if piece.color == chess.BLACK)\n    return float(white_value - black_value)", "def feature(board: chess.Board) -> float:\n    \"Counts how many pieces are attacking the opponent's pieces.\"\n    attacker_count = sum(len(board.attackers(board.turn, square)) for square in board.piece_map() if board.piece_at(square).color != board.turn)\n    return float(attacker_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of pieces that are in their opponent's home rank.\"\n    count = sum(1 for square, piece in board.piece_map().items() if (piece.color == chess.WHITE and chess.square_rank(square) == 7) or (piece.color == chess.BLACK and chess.square_rank(square) == 0))\n    return float(count)", "def feature(board: chess.Board) -> float:\n    \"Measures the center control by counting pieces on central squares (d4, d5, e4, e5).\"\n    central_squares = [chess.parse_square(sq) for sq in ['d4', 'd5', 'e4', 'e5']]\n    control = sum(1 for square in central_squares if board.piece_at(square) is not None)\n    return float(control)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pawns on the seventh rank, which can promote soon.\"\n    count = sum(1 for square, piece in board.piece_map().items() if piece.piece_type == chess.PAWN and chess.square_rank(square) == 6)\n    return float(count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in the number of minor pieces (knights and bishops) for both colors.\"\n    white_minor = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE and piece.piece_type in [chess.KNIGHT, chess.BISHOP])\n    black_minor = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK and piece.piece_type in [chess.KNIGHT, chess.BISHOP])\n    return float(white_minor - black_minor)", "def feature(board: chess.Board) -> float:\n    \"Returns a measure of pawn structure by counting the number of doubled pawns.\"\n    doubled = 0\n    files = {}\n    \n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.PAWN:\n            file = chess.square_file(square)\n            files[file] = files.get(file, 0) + 1\n    \n    doubled = sum(max(0, count - 1) for count in files.values())\n    return float(doubled)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of pieces that are unprotected (not defended by another piece).\"\n    unprotected_count = 0\n    \n    for square in board.piece_map():\n        piece = board.piece_at(square)\n        if piece is not None:\n            attackers = board.attackers(piece.color, square)\n            if not attackers:\n                unprotected_count += 1\n                \n    return float(unprotected_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the total number of legal moves available for the active color.\"\n    return float(len(list(board.legal_moves)))", "def feature(board: chess.Board) -> float:\n    \"Measures the representation of major pieces (rooks and queens) on the board.\"\n    major_piece_count = sum(1 for piece in board.piece_map().values() if piece.piece_type in [chess.ROOK, chess.QUEEN])\n    return float(major_piece_count)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces that can attack the opponent's king.\"\n    king_square = next((square for square, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color != board.turn), None)\n    if king_square is None:\n        return 0.0\n    attacking_count = sum(1 for piece in board.piece_map().values() if piece.color == board.turn and board.is_attacked_by(not board.turn, king_square))\n    return float(attacking_count)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pawns on the second to last rank for both players.\"\n    white_pawns = sum(1 for sq in board.piece_map() if board.piece_at(sq).piece_type == chess.PAWN and chess.square_rank(sq) == 6)\n    black_pawns = sum(1 for sq in board.piece_map() if board.piece_at(sq).piece_type == chess.PAWN and chess.square_rank(sq) == 1)\n    return float(white_pawns - black_pawns)", "def feature(board: chess.Board) -> float:\n    \"Calculates the total number of pieces still on the board.\"\n    piece_count = len(board.piece_map())\n    return float(piece_count)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces within the opponent's third of the board.\"\n    opponent_third = [0, 1, 2]\n    count = sum(1 for sq in board.piece_map() if chess.square_rank(sq) in opponent_third)\n    return float(count)", "def feature(board: chess.Board) -> float:\n    \"Measures the maximum distance from the king to any piece for the current player.\"\n    king_square = next(sq for sq in board.piece_map() if board.piece_at(sq).piece_type == chess.KING and board.piece_at(sq).color == board.turn)\n    max_distance = max(chess.square_distance(king_square, sq) for sq in board.piece_map() if board.piece_at(sq).color == board.turn)\n    return float(max_distance)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces attacking the opponent's king.\"\n    opponent_king_square = next(sq for sq in board.piece_map() if board.piece_at(sq).piece_type == chess.KING and board.piece_at(sq).color != board.turn)\n    attacking_pieces = len(board.attackers(board.turn, opponent_king_square))\n    return float(attacking_pieces)", "def feature(board: chess.Board) -> float:\n    \"Calculates the total value of pieces for each player and returns the difference.\"\n    piece_values = {chess.PAWN: 100, chess.KNIGHT: 300, chess.BISHOP: 300, chess.ROOK: 500, chess.QUEEN: 900, chess.KING: 0}\n    white_value = sum(piece_values[board.piece_at(sq).piece_type] for sq in board.piece_map() if board.piece_at(sq).color == chess.WHITE)\n    black_value = sum(piece_values[board.piece_at(sq).piece_type] for sq in board.piece_map() if board.piece_at(sq).color == chess.BLACK)\n    return float(white_value - black_value)", "def feature(board: chess.Board) -> float:\n    \"Calculates the total number of legal moves for the current player.\"\n    legal_move_count = len(list(board.legal_moves))\n    return float(legal_move_count)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of pieces on the back rank for both players.\"\n    white_back_rank = sum(1 for sq in range(0, 8) if board.piece_at(chess.square(sq, 7)) is not None and board.piece_at(chess.square(sq, 7)).color == chess.WHITE)\n    black_back_rank = sum(1 for sq in range(0, 8) if board.piece_at(chess.square(sq, 0)) is not None and board.piece_at(chess.square(sq, 0)).color == chess.BLACK)\n    return float(white_back_rank - black_back_rank)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of squares attacked by both players.\"\n    white_attacks = sum(1 for sq in chess.SQUARES if board.is_attacked_by(chess.WHITE, sq))\n    black_attacks = sum(1 for sq in chess.SQUARES if board.is_attacked_by(chess.BLACK, sq))\n    return float(white_attacks - black_attacks)", "def feature(board: chess.Board) -> float:\n    \"Measures the structural integrity of pawns (counting doubled pawns).\"\n    pawn_positions = {}\n    for sq in board.piece_map():\n        piece = board.piece_at(sq)\n        if piece.piece_type == chess.PAWN:\n            file = chess.square_file(sq)\n            if file in pawn_positions:\n                pawn_positions[file] += 1\n            else:\n                pawn_positions[file] = 1\n    doubled_pawns = sum(count - 1 for count in pawn_positions.values() if count > 1)\n    return float(-doubled_pawns)  # The more doubled pawns, the worse the position for that player.", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of pieces remaining for each color and returns the difference.\"\n    white_pieces = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE)\n    black_pieces = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK)\n    return float(white_pieces - black_pieces)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of pawns that are on their opponent's half of the board.\"\n    white_advanced_pawns = sum(1 for square, piece in board.piece_map().items() \n                                if piece.color == chess.WHITE and chess.square_rank(square) >= 4)\n    black_advanced_pawns = sum(1 for square, piece in board.piece_map().items() \n                                if piece.color == chess.BLACK and chess.square_rank(square) <= 3)\n    return float(white_advanced_pawns + black_advanced_pawns)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of pieces in attack positions for each player.\"\n    white_attacking_pieces = sum(1 for square, piece in board.piece_map().items() \n                                  if piece.color == chess.WHITE and board.is_attacked_by(chess.BLACK, square))\n    black_attacking_pieces = sum(1 for square, piece in board.piece_map().items() \n                                  if piece.color == chess.BLACK and board.is_attacked_by(chess.WHITE, square))\n    return float(white_attacking_pieces + black_attacking_pieces)", "def feature(board: chess.Board) -> float:\n    \"Counts the total number of legal moves available for the active player.\"\n    legal_moves = list(board.legal_moves)\n    return float(len(legal_moves))", "def feature(board: chess.Board) -> float:\n    \"Evaluates the presence of pieces on the back rank for both players.\"\n    white_on_back_rank = sum(1 for square in range(chess.A8, chess.H8 + 1) if board.piece_at(square) and board.piece_at(square).color == chess.WHITE)\n    black_on_back_rank = sum(1 for square in range(chess.A1, chess.H1 + 1) if board.piece_at(square) and board.piece_at(square).color == chess.BLACK)\n    return float(white_on_back_rank - black_on_back_rank)", "def feature(board: chess.Board) -> float:\n    \"Calculates the distance of king from the center of the board (e4/e5 squares).\"\n    if board.turn == chess.WHITE:\n        king_square = board.king(chess.WHITE)\n        center_distance = chess.square_distance(king_square, chess.parse_square('e4'))\n    else:\n        king_square = board.king(chess.BLACK)\n        center_distance = chess.square_distance(king_square, chess.parse_square('e5'))\n    return float(center_distance)", "def feature(board: chess.Board) -> float:\n    \"Measures the pawn structure by counting doubled pawns.\"\n    doubled_pawns = 0\n    for file in range(8):\n        pawns_in_file = [square for square in range(chess.A7, chess.H7 + 1) if board.piece_at(square) and board.piece_at(square).piece_type == chess.PAWN and chess.square_file(square) == file]\n        if len(pawns_in_file) > 1:\n            doubled_pawns += len(pawns_in_file) - 1\n    return float(doubled_pawns)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of connected pawns for each color on the board.\"\n    def count_connected_pawns(color):\n        connected_count = 0\n        pawns_positions = [square for square, piece in board.piece_map().items() if piece.color == color and piece.piece_type == chess.PAWN]\n        for square in pawns_positions:\n            if (board.piece_at(square - 1) and board.piece_at(square - 1).color == color) or (board.piece_at(square + 1) and board.piece_at(square + 1).color == color):\n                connected_count += 1\n        return connected_count\n\n    white_connected = count_connected_pawns(chess.WHITE)\n    black_connected = count_connected_pawns(chess.BLACK)\n    return float(white_connected - black_connected)", "def feature(board: chess.Board) -> float:\n    \"Computes the depth of the position based on the fullmove number.\"\n    return float(board.fullmove_number)", "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in the number of pawns between both players.\"\n    white_pawns = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE and piece.piece_type == chess.PAWN)\n    black_pawns = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK and piece.piece_type == chess.PAWN)\n    return float(white_pawns - black_pawns)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of rook pairs (two rooks on the same rank or file for each player).\"\n    white_rooks = [sq for sq, piece in board.piece_map().items() if piece.color == chess.WHITE and piece.piece_type == chess.ROOK]\n    black_rooks = [sq for sq, piece in board.piece_map().items() if piece.color == chess.BLACK and piece.piece_type == chess.ROOK]\n    white_pairs = sum(1 for sq1 in white_rooks for sq2 in white_rooks if sq1 != sq2 and chess.square_file(sq1) == chess.square_file(sq2) or chess.square_rank(sq1) == chess.square_rank(sq2))\n    black_pairs = sum(1 for sq1 in black_rooks for sq2 in black_rooks if sq1 != sq2 and chess.square_file(sq1) == chess.square_file(sq2) or chess.square_rank(sq1) == chess.square_rank(sq2))\n    return float(white_pairs - black_pairs)", "def feature(board: chess.Board) -> float:\n    \"Measures the total number of potential checks available to the active player.\"\n    checks = sum(1 for move in board.legal_moves if board.gives_check(move))\n    return float(checks)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of protected pawns on the board for the active color.\"\n    color = chess.WHITE if board.turn else chess.BLACK\n    protected_pawns = sum(1 for sq in board.piece_map() if board.piece_at(sq) and board.piece_at(sq).color == color and board.piece_at(sq).piece_type == chess.PAWN and len(board.attackers(color, sq)) == 0)\n    return float(protected_pawns)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of pieces on the back rank for each player.\"\n    white_back_rank_pieces = sum(1 for sq in range(0, 8) if board.piece_at(chess.square(sq, 0)) and board.piece_at(chess.square(sq, 0)).color == chess.WHITE)\n    black_back_rank_pieces = sum(1 for sq in range(0, 8) if board.piece_at(chess.square(sq, 7)) and board.piece_at(chess.square(sq, 7)).color == chess.BLACK)\n    return float(white_back_rank_pieces - black_back_rank_pieces)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of pieces that are pinned (unable to move because they would expose the king to check).\"\n    pinned_pieces_count = sum(1 for square, piece in board.piece_map().items() if piece.color == board.turn and board.is_attacked_by(not piece.color, square))\n    return float(pinned_pieces_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the distance of the closest enemy piece to the active king.\"\n    color = chess.WHITE if board.turn else chess.BLACK\n    king_square = next(sq for sq, piece in board.piece_map().items() if piece.color == color and piece.piece_type == chess.KING)\n    enemy_pieces = [sq for sq, piece in board.piece_map().items() if piece.color != color]\n    distances = [chess.square_distance(king_square, sq) for sq in enemy_pieces]\n    return float(min(distances)) if distances else 0.0", "def feature(board: chess.Board) -> float:\n    \"Measures the total control of the center squares for the active color.\"\n    center_squares = [chess.D4, chess.D5, chess.E4, chess.E5]\n    control = sum(1 for sq in center_squares if board.is_attacked_by(board.turn, sq))\n    return float(control)", "def feature(board: chess.Board) -> float:\n    \"Calculates the ratio of developed pieces for each player.\"\n    developed_white = sum(1 for square, piece in board.piece_map().items() if piece.color == chess.WHITE and (piece.piece_type in [chess.KNIGHT, chess.BISHOP, chess.ROOK]) and chess.square_rank(square) >= 1)\n    developed_black = sum(1 for square, piece in board.piece_map().items() if piece.color == chess.BLACK and (piece.piece_type in [chess.KNIGHT, chess.BISHOP, chess.ROOK]) and chess.square_rank(square) <= 6)\n    return float(developed_white / (developed_black + 1))  # Add 1 to avoid division by zero", "def feature(board: chess.Board) -> float:\n    \"Measures the number of vulnerable pieces (attacked without protection) for the active color.\"\n    vulnerable_count = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == board.turn and board.is_attacked_by(not board.turn, square):\n            if any(board.is_attacked_by(piece.color, attacker) for attacker in board.attackers(not piece.color, square)):\n                vulnerable_count += 1\n    return float(vulnerable_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the total distance of all pieces to the opponent's back rank.\"\n    total_distance = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == board.turn:\n            rank_distance = 7 - chess.square_rank(square) if piece.color == chess.WHITE else chess.square_rank(square)\n            total_distance += rank_distance\n    return float(total_distance)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces that control key squares in the opponent's territory.\"\n    control_count = 0\n    target_squares = [chess.parse_square('e7'), chess.parse_square('f7'), chess.parse_square('g7')]\n    for square, piece in board.piece_map().items():\n        if piece.color == board.turn and square in target_squares:\n            control_count += 1\n    return float(control_count)", "def feature(board: chess.Board) -> float:\n    \"Measures the pawn structure by counting isolated pawns for each side.\"\n    isolated_count = 0\n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.PAWN and piece.color == board.turn:\n            file = chess.square_file(square)\n            if not (board.piece_at(chess.parse_square(chess.square_name(file-1))) or \n                    board.piece_at(chess.parse_square(chess.square_name(file+1)))):\n                isolated_count += 1\n    return float(isolated_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the total value of pieces that are not defended by any friendly pieces.\"\n    undefended_value = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == board.turn and not any(board.is_attacked_by(piece.color, attacker) for attacker in board.attackers(not piece.color, square)):\n            undefended_value += piece.piece_type\n    return float(undefended_value)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pawn majorities on one side of the board for the active color.\"\n    majority_count = 0\n    for file in range(8):\n        white_pawns = sum(1 for square in range(0, 8) if board.piece_at(chess.parse_square(f'{chess.FILE_NAMES[file]}{square + 1}')) == chess.PAWN)\n        black_pawns = sum(1 for square in range(0, 8) if board.piece_at(chess.parse_square(f'{chess.FILE_NAMES[file]}{8 - square}')) == chess.PAWN)\n        if (board.turn == chess.WHITE and white_pawns > black_pawns) or (board.turn == chess.BLACK and black_pawns > white_pawns):\n            majority_count += 1\n    return float(majority_count)", "def feature(board: chess.Board) -> float:\n    \"Measures the mobility by counting the number of legal moves available for the active color.\"\n    mobility_count = len(list(board.legal_moves))\n    return float(mobility_count)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of passed pawns for the active color.\"\n    passed_pawn_count = 0\n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.PAWN and piece.color == board.turn:\n            file = chess.square_file(square)\n            if (piece.color == chess.WHITE and not any(board.piece_at(chess.parse_square(f'{chess.FILE_NAMES[file]}{rank}')) for rank in range(6, 8))) or \\\n               (piece.color == chess.BLACK and not any(board.piece_at(chess.parse_square(f'{chess.FILE_NAMES[file]}{rank}')) for rank in range(1, 3))):\n                passed_pawn_count += 1\n    return float(passed_pawn_count)", "def feature(board: chess.Board) -> float:\n    \"Measures the difference in control of central squares (d4, d5, e4, e5).\"\n    central_squares = [chess.parse_square('d4'), chess.parse_square('d5'), chess.parse_square('e4'), chess.parse_square('e5')]\n    white_control = sum(1 for sq in central_squares if board.is_attacked_by(chess.WHITE, sq))\n    black_control = sum(1 for sq in central_squares if board.is_attacked_by(chess.BLACK, sq))\n    return float(white_control - black_control)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pawns remaining on the board for each player and returns the difference.\"\n    white_pawns = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE and piece.piece_type == chess.PAWN)\n    black_pawns = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK and piece.piece_type == chess.PAWN)\n    return float(white_pawns - black_pawns)", "def feature(board: chess.Board) -> float:\n    \"Calculates the total number of pieces on the board for each player and returns the ratio of pieces.\"\n    white_pieces = len([piece for piece in board.piece_map().values() if piece.color == chess.WHITE])\n    black_pieces = len([piece for piece in board.piece_map().values() if piece.color == chess.BLACK])\n    return float(white_pieces / black_pieces) if black_pieces > 0 else float(white_pieces)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of squares controlled by each color and returns the difference.\"\n    white_controlled = sum(1 for move in board.legal_moves if move.from_square in board.attackers(chess.WHITE, move.to_square))\n    black_controlled = sum(1 for move in board.legal_moves if move.from_square in board.attackers(chess.BLACK, move.to_square))\n    return float(white_controlled - black_controlled)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of minor pieces (knights and bishops) for each player and returns the difference.\"\n    white_minor = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE and piece.piece_type in {chess.KNIGHT, chess.BISHOP})\n    black_minor = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK and piece.piece_type in {chess.KNIGHT, chess.BISHOP})\n    return float(white_minor - black_minor)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of squares available for king movement for both players and returns the difference.\"\n    white_king_square = next((square for square, piece in board.piece_map().items() if piece.color == chess.WHITE and piece.piece_type == chess.KING), None)\n    black_king_square = next((square for square, piece in board.piece_map().items() if piece.color == chess.BLACK and piece.piece_type == chess.KING), None)\n\n    white_king_moves = len(list(board.legal_moves) if white_king_square is not None else [])\n    black_king_moves = len(list(board.legal_moves) if black_king_square is not None else [])\n\n    return float(white_king_moves - black_king_moves)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of checks delivered by each color and returns the difference.\"\n    white_checks = sum(1 for move in board.legal_moves if board.is_check())\n    black_checks = sum(1 for move in board.legal_moves if board.is_check())\n    return float(white_checks - black_checks)", "def feature(board: chess.Board) -> float:\n    \"Calculates the total distance of each player's pieces from their respective back ranks and returns the difference.\"\n    white_distance = sum(7 - chess.square_rank(square) for square, piece in board.piece_map().items() if piece.color == chess.WHITE)\n    black_distance = sum(chess.square_rank(square) for square, piece in board.piece_map().items() if piece.color == chess.BLACK)\n    return float(white_distance - black_distance)", "def feature(board: chess.Board) -> float:\n    \"Measures the total number of pawns that have advanced for each color and returns the difference.\"\n    advanced_white_pawns = sum(1 for square, piece in board.piece_map().items() if piece.color == chess.WHITE and chess.square_rank(square) >= 4)\n    advanced_black_pawns = sum(1 for square, piece in board.piece_map().items() if piece.color == chess.BLACK and chess.square_rank(square) <= 3)\n    return float(advanced_white_pawns - advanced_black_pawns)", "def feature(board: chess.Board) -> float:\n    \"Calculates the proportion of pieces on the board that are knights for each player and returns the difference.\"\n    total_white = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE)\n    total_black = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK)\n    white_knights = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE and piece.piece_type == chess.KNIGHT)\n    black_knights = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK and piece.piece_type == chess.KNIGHT)\n\n    white_ratio = white_knights / total_white if total_white > 0 else 0\n    black_ratio = black_knights / total_black if total_black > 0 else 0\n    return float(white_ratio - black_ratio)", "def feature(board: chess.Board) -> float:\n    \"Measures the total number of pawns on the board.\"\n    return float(len([p for p in board.piece_map().values() if p.piece_type == chess.PAWN]))", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pawns that are advanced (beyond the 4th rank) for both players.\"\n    return float(len([p for sq, p in board.piece_map().items() if p.piece_type == chess.PAWN and (p.color == chess.WHITE and chess.square_rank(sq) > 3 or p.color == chess.BLACK and chess.square_rank(sq) < 4)]))", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces threatening the opponent's king.\"\n    threats = sum(1 for square in chess.SQUARES if board.is_attacked_by(chess.WHITE, square) and board.piece_at(square) and board.piece_at(square).color == chess.BLACK) + \\\n              sum(1 for square in chess.SQUARES if board.is_attacked_by(chess.BLACK, square) and board.piece_at(square) and board.piece_at(square).color == chess.WHITE)\n    return float(threats)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of squares protected by pawns for both players.\"\n    protected_squares = 0\n    for sq, p in board.piece_map().items():\n        if p.piece_type == chess.PAWN:\n            if p.color == chess.WHITE:\n                protected_squares += sum(1 for delta in [-9, -7] if 0 <= sq + delta < 64 and chess.square_rank(sq + delta) < 8)\n            else:\n                protected_squares += sum(1 for delta in [7, 9] if 0 <= sq + delta < 64 and chess.square_rank(sq + delta) >= 0)\n    return float(protected_squares)", "def feature(board: chess.Board) -> float:\n    \"Measures the distance of the kings from the center of the board.\"\n    white_king_sq = next((sq for sq, p in board.piece_map().items() if p.piece_type == chess.KING and p.color == chess.WHITE), None)\n    black_king_sq = next((sq for sq, p in board.piece_map().items() if p.piece_type == chess.KING and p.color == chess.BLACK), None)\n    center_distance = (chess.square_distance(white_king_sq, chess.E4) + chess.square_distance(black_king_sq, chess.E4)) if white_king_sq and black_king_sq else 0\n    return float(center_distance)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of defenders on the back rank for both players.\"\n    defenders = 0\n    for rank in [0, 7]:  # Black back rank (0), White back rank (7)\n        for file in range(8):\n            sq = chess.square(file, rank)\n            if board.piece_at(sq) and board.piece_at(sq).color == chess.WHITE and rank == 7:\n                defenders += 1\n            if board.piece_at(sq) and board.piece_at(sq).color == chess.BLACK and rank == 0:\n                defenders += 1\n    return float(defenders)", "def feature(board: chess.Board) -> float:\n    \"Calculates the difference between the material score of the two players.\"\n    material_values = {chess.PAWN: 100, chess.KNIGHT: 320, chess.BISHOP: 330, chess.ROOK: 500, chess.QUEEN: 900, chess.KING: 0}\n    total_white = sum(material_values[p.piece_type] for p in board.piece_map().values() if p.color == chess.WHITE)\n    total_black = sum(material_values[p.piece_type] for p in board.piece_map().values() if p.color == chess.BLACK)\n    return float(total_white - total_black)", "def feature(board: chess.Board) -> float:\n    \"Measures the distance of pieces to the opponent's back rank.\"\n    opponent_back_rank = 0 if board.turn else 7\n    total_distance = 0\n    for square, piece in board.piece_map().items():\n        if piece.color != board.turn:\n            total_distance += chess.square_rank(square) - opponent_back_rank\n    return float(total_distance)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of pawns advanced past the fourth rank for each player.\"\n    white_pawns = sum(1 for square in board.piece_map() if board.piece_at(square).piece_type == chess.PAWN and board.piece_at(square).color == chess.WHITE and chess.square_rank(square) > 3)\n    black_pawns = sum(1 for square in board.piece_map() if board.piece_at(square).piece_type == chess.PAWN and board.piece_at(square).color == chess.BLACK and chess.square_rank(square) < 4)\n    return float(white_pawns - black_pawns)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces protected by a pawn for each color.\"\n    white_protected = sum(1 for square, piece in board.piece_map().items() if piece.color == chess.WHITE and any(board.is_attacked_by(chess.BLACK, square) for sq in board.attackers(chess.WHITE, square)))\n    black_protected = sum(1 for square, piece in board.piece_map().items() if piece.color == chess.BLACK and any(board.is_attacked_by(chess.WHITE, square) for sq in board.attackers(chess.BLACK, square)))\n    return float(white_protected - black_protected)", "def feature(board: chess.Board) -> float:\n    \"Measures the presence of pieces on the key squares of the opponent's pawn structure.\"\n    key_squares = [chess.parse_square('e7'), chess.parse_square('e6'), chess.parse_square('d7'), chess.parse_square('d6')]\n    opponent_color = chess.BLACK if board.turn else chess.WHITE\n    return float(sum(1 for square in key_squares if board.is_attacked_by(opponent_color, square)))", "def feature(board: chess.Board) -> float:\n    \"Evaluates the number of rooks on open files.\"\n    open_files = {file: True for file in range(8)}\n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.ROOK:\n            open_files[chess.square_file(square)] = False\n    return float(sum(1 for open in open_files.values() if open))", "def feature(board: chess.Board) -> float:\n    \"Scores the number of pieces within a distance of two squares to the opponent's king.\"\n    opponent_king_square = next(square for square, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color != board.turn)\n    distance_count = sum(1 for square, piece in board.piece_map().items() if chess.square_distance(opponent_king_square, square) <= 2 and piece.color == board.turn)\n    return float(distance_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the total number of piece attacks on the opponent's king.\"\n    opponent_king_square = next(square for square, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color != board.turn)\n    attack_count = sum(1 for square in board.legal_moves if board.is_attacked_by(board.turn, opponent_king_square))\n    return float(attack_count)", "def feature(board: chess.Board) -> float:\n    \"Counts the total number of squares attacked by both players.\"\n    white_attacks = sum(1 for square in board.piece_map() if board.is_attacked_by(chess.WHITE, square))\n    black_attacks = sum(1 for square in board.piece_map() if board.is_attacked_by(chess.BLACK, square))\n    return float(white_attacks - black_attacks)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of pawns on the board for each player.\"\n    white_pawns = sum(1 for piece in board.piece_map().values() if piece.piece_type == chess.PAWN and piece.color == chess.WHITE)\n    black_pawns = sum(1 for piece in board.piece_map().values() if piece.piece_type == chess.PAWN and piece.color == chess.BLACK)\n    return float(white_pawns - black_pawns)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces for each player and gives a difference score.\"\n    piece_count_white = len([piece for piece in board.piece_map().values() if piece.color == chess.WHITE])\n    piece_count_black = len([piece for piece in board.piece_map().values() if piece.color == chess.BLACK])\n    return float(piece_count_white - piece_count_black)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of squares that are occupied by pieces for each player.\"\n    occupied_squares = len(board.piece_map())\n    return float((occupied_squares / 64) * 100)  # Percentage of occupied squares", "def feature(board: chess.Board) -> float:\n    \"Calculates the material score based on a weighted piece value system.\"\n    piece_values = {\n        chess.PAWN: 100,\n        chess.KNIGHT: 300,\n        chess.BISHOP: 300,\n        chess.ROOK: 500,\n        chess.QUEEN: 900,\n        chess.KING: 10000\n    }\n    score = sum(piece_values[piece.piece_type] * (1 if piece.color == chess.WHITE else -1) for piece in board.piece_map().values())\n    return float(score)", "def feature(board: chess.Board) -> float:\n    \"Checks if either king is in check.\"\n    return float(board.is_check())", "def feature(board: chess.Board) -> float:\n    \"Measures the mobility of pieces by counting all legal moves available.\"\n    legal_moves = len(list(board.legal_moves))\n    return float(legal_moves)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of attackable squares for the opponent's king.\"\n    opponent_king_square = next((square for square, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color != board.turn), None)\n    if opponent_king_square is None:\n        return 0.0\n    attacked_squares = board.attackers(not board.turn, opponent_king_square)\n    return float(len(attacked_squares))", "def feature(board: chess.Board) -> float:\n    \"Measures the distance of major pieces (Rooks, Queens) from the starting rank.\"\n    major_pieces = [chess.ROOK, chess.QUEEN]\n    total_distance = sum(chess.square_rank(square) for square, piece in board.piece_map().items() if piece.piece_type in major_pieces)\n    return float(total_distance)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of pieces protected by other pieces.\"\n    protected_count = sum(1 for square in board.piece_map() if board.is_attacked_by(board.piece_map()[square].color, square))\n    return float(protected_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the average rank of all pieces on the board, assessing their development.\"\n    total_rank = sum(chess.square_rank(square) for square in board.piece_map())\n    num_pieces = len(board.piece_map())\n    return float(total_rank) / num_pieces if num_pieces > 0 else 0.0", "def feature(board: chess.Board) -> float:\n    \"Measures the total number of pieces on the board.\"\n    return float(len(board.piece_map()))", "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in the number of pawns between both players.\"\n    white_pawns = len([p for p in board.piece_map().values() if p.piece_type == chess.PAWN and p.color == chess.WHITE])\n    black_pawns = len([p for p in board.piece_map().values() if p.piece_type == chess.PAWN and p.color == chess.BLACK])\n    return float(white_pawns - black_pawns)", "def feature(board: chess.Board) -> float:\n    \"Calculates the distance of the nearest piece to the opponent's back rank.\"\n    pieces = board.piece_map()\n    opponent_back_rank = 0 if board.turn == chess.WHITE else 7\n    distances = [chess.square_rank(square) - opponent_back_rank for square in pieces if pieces[square].color != board.turn]\n    return float(min(distances)) if distances else float('inf')", "def feature(board: chess.Board) -> float:\n    \"Counts the number of squares attacked by each player's pieces.\"\n    white_attacks = sum(board.is_attacked_by(chess.WHITE, square) for square in chess.SQUARES)\n    black_attacks = sum(board.is_attacked_by(chess.BLACK, square) for square in chess.SQUARES)\n    return float(white_attacks - black_attacks)", "def feature(board: chess.Board) -> float:\n    \"Maps distance from king to the closest enemy piece.\"\n    pieces = board.piece_map()\n    my_king_square = next(square for square, p in pieces.items() if p.piece_type == chess.KING and p.color == board.turn)\n    enemy_piece_squares = [square for square, p in pieces.items() if p.color != board.turn]\n    distances = [chess.square_distance(my_king_square, square) for square in enemy_piece_squares]\n    return float(min(distances)) if distances else float('inf')", "def feature(board: chess.Board) -> float:\n    \"Measures the total number of captured pieces for both players.\"\n    total_captured_white = len([p for p in board.piece_map().values() if p.color == chess.WHITE and p.piece_type in (chess.PAWN, chess.KNIGHT, chess.BISHOP, chess.ROOK, chess.QUEEN)])\n    total_captured_black = len([p for p in board.piece_map().values() if p.color == chess.BLACK and p.piece_type in (chess.PAWN, chess.KNIGHT, chess.BISHOP, chess.ROOK, chess.QUEEN)])\n    return float(total_captured_white - total_captured_black)", "def feature(board: chess.Board) -> float:\n    \"Calculates the average rank of all pieces for the current player.\"\n    pieces = [square for square, p in board.piece_map().items() if p.color == board.turn]\n    avg_rank = sum(chess.square_rank(square) for square in pieces) / len(pieces) if pieces else 0\n    return avg_rank", "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in the number of rooks on the board between players.\"\n    white_rooks = len([p for p in board.piece_map().values() if p.piece_type == chess.ROOK and p.color == chess.WHITE])\n    black_rooks = len([p for p in board.piece_map().values() if p.piece_type == chess.ROOK and p.color == chess.BLACK])\n    return float(white_rooks - black_rooks)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of protected pieces for each side.\"\n    protected_pieces = sum(1 for square, p in board.piece_map().items() if p.color == board.turn and \n                           any(board.is_attacked_by(p.color, sq) for sq in board.attackers(p.color, square)))\n    return float(protected_pieces)", "def feature(board: chess.Board) -> float:\n    \"Measures the distance of the closest piece to the opponent's king.\"\n    opponent_king_square = next(square for square, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color != board.turn)\n    distances = [chess.square_distance(square, opponent_king_square) for square in board.piece_map() if board.piece_map()[square].color == board.turn]\n    return min(distances) if distances else float('inf')", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces in the opponent's back rank.\"\n    opponent_back_rank = 7 if board.turn == chess.WHITE else 0\n    return float(sum(1 for square in range(opponent_back_rank * 8, opponent_back_rank * 8 + 8) if board.piece_at(square) is not None))", "def feature(board: chess.Board) -> float:\n    \"Calculates the average rank of each player's pawns.\"\n    pawn_squares = [square for square, piece in board.piece_map().items() if piece.piece_type == chess.PAWN]\n    if not pawn_squares:\n        return 0.0\n    avg_rank = sum(chess.square_rank(square) for square in pawn_squares) / len(pawn_squares)\n    return avg_rank", "def feature(board: chess.Board) -> float:\n    \"Measures the number of discovered attacks each player has.\"\n    discovered_attacks = 0\n    for square in board.piece_map():\n        piece = board.piece_map()[square]\n        if piece.color == board.turn:\n            for move in board.legal_moves:\n                if move.from_square == square:\n                    if board.is_attacked_by(not piece.color, move.to_square):\n                        discovered_attacks += 1\n    return float(discovered_attacks)", "def feature(board: chess.Board) -> float:\n    \"Measures the difference in the number of knights each player has.\"\n    white_knights = len([1 for square, piece in board.piece_map().items() if piece.color == chess.WHITE and piece.piece_type == chess.KNIGHT])\n    black_knights = len([1 for square, piece in board.piece_map().items() if piece.color == chess.BLACK and piece.piece_type == chess.KNIGHT])\n    return float(white_knights - black_knights)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces attacking the opponent's king.\"\n    opponent_king_square = next(square for square, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color != board.turn)\n    attackers = board.attackers(board.turn, opponent_king_square)\n    return float(len(attackers))", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces on the first two ranks for each player.\"\n    player_ranks = sum(1 for square in range(16) if board.piece_at(square) is not None)  \n    opponent_ranks = sum(1 for square in range(48, 64) if board.piece_at(square) is not None)\n    return float(player_ranks - opponent_ranks)", "def feature(board: chess.Board) -> float:\n    \"Measures the difference in mobility between players by counting legal moves.\"\n    white_mobility = len(list(board.legal_moves)) if board.turn == chess.WHITE else 0\n    black_mobility = len(list(board.legal_moves)) if board.turn == chess.BLACK else 0\n    return float(white_mobility - black_mobility)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of pieces that are in positions to control the center squares.\"\n    center_control = 0\n    center_squares = [chess.E4, chess.E5, chess.D4, chess.D5]\n    for square in center_squares:\n        attackers_white = board.attackers(chess.WHITE, square)\n        attackers_black = board.attackers(chess.BLACK, square)\n        center_control += len(attackers_white) - len(attackers_black)\n    return float(center_control)", "def feature(board: chess.Board) -> float:\n    \"Assesses the king safety by determining how many pieces are defending the kings.\"\n    white_king_defenders = sum(1 for sq in board.piece_map() if board.is_attacked_by(chess.BLACK, board.king(chess.WHITE)))\n    black_king_defenders = sum(1 for sq in board.piece_map() if board.is_attacked_by(chess.WHITE, board.king(chess.BLACK)))\n    return float(white_king_defenders - black_king_defenders)", "def feature(board: chess.Board) -> float:\n    \"Calculates the piece activity by summing the number of legal moves each piece can make.\"\n    activity_score = 0\n    for square, piece in board.piece_map().items():\n        activity_score += len(list(board.legal_moves)) if piece.color == board.turn else -len(list(board.legal_moves))\n    return float(activity_score)", "def feature(board: chess.Board) -> float:\n    \"Measures the distance of each piece to the opponent's back rank to assess attacking potential.\"\n    distance_to_back_rank = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == chess.WHITE:\n            distance_to_back_rank += (7 - chess.square_rank(square))\n        else:\n            distance_to_back_rank -= (chess.square_rank(square))\n    return float(distance_to_back_rank)", "def feature(board: chess.Board) -> float:\n    \"Calculates the average distance of opponent's pieces from the player's back rank to analyze threats.\"\n    avg_distance = 0\n    piece_count = 0\n    for square, piece in board.piece_map().items():\n        if piece.color != board.turn:\n            avg_distance += chess.square_rank(square)\n            piece_count += 1\n    return avg_distance / piece_count if piece_count > 0 else 0.0", "def feature(board: chess.Board) -> float:\n    \"Measures the difference in the number of pawns for each player on the board.\"\n    white_pawns = sum(1 for p in board.piece_map().values() if p.color == chess.WHITE and p.piece_type == chess.PAWN)\n    black_pawns = sum(1 for p in board.piece_map().values() if p.color == chess.BLACK and p.piece_type == chess.PAWN)\n    return float(white_pawns - black_pawns)", "def feature(board: chess.Board) -> float:\n    \"Calculates the total number of attacking pieces for each player.\"\n    white_attackers = sum(len(board.attackers(chess.WHITE, square)) for square in board.piece_map() if board.piece_at(square).color == chess.WHITE)\n    black_attackers = sum(len(board.attackers(chess.BLACK, square)) for square in board.piece_map() if board.piece_at(square).color == chess.BLACK)\n    return float(white_attackers - black_attackers)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces attacking the opponent's king.\"\n    white_attacks_king = sum(board.is_attacked_by(chess.WHITE, square) for square in range(64) if board.piece_at(square) and board.piece_at(square).color == chess.BLACK and board.piece_at(square).piece_type == chess.KING)\n    black_attacks_king = sum(board.is_attacked_by(chess.BLACK, square) for square in range(64) if board.piece_at(square) and board.piece_at(square).color == chess.WHITE and board.piece_at(square).piece_type == chess.KING)\n    return float(white_attacks_king - black_attacks_king)", "def feature(board: chess.Board) -> float:\n    \"Calculates the mobility of both players by counting total legal moves.\"\n    white_mobility = sum(1 for _ in board.legal_moves if board.turn == chess.WHITE)\n    black_mobility = sum(1 for _ in board.legal_moves if board.turn == chess.BLACK)\n    return float(white_mobility - black_mobility)", "def feature(board: chess.Board) -> float:\n    \"Measures the difference in the number of pieces in the opponent's half of the board.\"\n    white_advanced_pieces = sum(1 for square in board.piece_map() if board.piece_at(square).color == chess.WHITE and chess.square_rank(square) > 3)\n    black_advanced_pieces = sum(1 for square in board.piece_map() if board.piece_at(square).color == chess.BLACK and chess.square_rank(square) < 4)\n    return float(white_advanced_pieces - black_advanced_pieces)", "def feature(board: chess.Board) -> float:\n    \"Counts how many pieces are pinned by the opponent's pieces.\"\n    pinned_pieces = sum(1 for square in board.piece_map() if board.is_attacked_by(chess.BLACK if board.piece_at(square).color == chess.WHITE else chess.WHITE, square))\n    return float(pinned_pieces)", "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in control of the center squares.\"\n    center_squares = [chess.D4, chess.D5, chess.E4, chess.E5]\n    white_control = sum(1 for square in center_squares if board.is_attacked_by(chess.WHITE, square))\n    black_control = sum(1 for square in center_squares if board.is_attacked_by(chess.BLACK, square))\n    return float(white_control - black_control)", "def feature(board: chess.Board) -> float:\n    \"Measures the average distance of all pieces from the center of the board.\"\n    total_distance = sum(chess.square_distance(square, chess.E4) + chess.square_distance(square, chess.E5) for square in board.piece_map())\n    piece_count = len(board.piece_map())\n    return total_distance / piece_count if piece_count > 0 else 0.0", "def feature(board: chess.Board) -> float:\n    \"Measures the activity of rooks by counting the number of open files they occupy.\"\n    open_files = sum(1 for file in range(8) if all((board.piece_at(chess.square(file, rank)) is not None) for rank in range(8)))\n    return float(open_files)", "def feature(board: chess.Board) -> float:\n    \"Calculates the distance of the king from its opponent's back rank.\"\n    if board.turn == chess.WHITE:\n        king_square = next((sq for sq in board.piece_map() if board.piece_at(sq).piece_type == chess.KING and board.piece_at(sq).color == chess.WHITE), None)\n        return 7 - chess.square_rank(king_square) if king_square is not None else 0.0\n    else:\n        king_square = next((sq for sq in board.piece_map() if board.piece_at(sq).piece_type == chess.KING and board.piece_at(sq).color == chess.BLACK), None)\n        return chess.square_rank(king_square) if king_square is not None else 0.0", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pawns for both players and computes the difference.\"\n    white_pawns = sum(1 for piece in board.piece_map().values() if piece.piece_type == chess.PAWN and piece.color == chess.WHITE)\n    black_pawns = sum(1 for piece in board.piece_map().values() if piece.piece_type == chess.PAWN and piece.color == chess.BLACK)\n    return float(white_pawns - black_pawns)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of pieces that are pinned by the opponent.\"\n    pinned_pieces = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == board.turn:\n            for attacker in board.attackers(not board.turn, square):\n                if board.piece_at(attacker).piece_type in (chess.ROOK, chess.QUEEN):\n                    if not board.is_attacked_by(board.turn, square):\n                        pinned_pieces += 1\n    return float(pinned_pieces)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of squares that are currently defended by the player's pieces.\"\n    defended_squares = set()\n    for square, piece in board.piece_map().items():\n        if piece.color == board.turn:\n            for move in board.legal_moves:\n                if move.from_square == square:\n                    defended_squares.add(move.to_square)\n    return float(len(defended_squares))", "def feature(board: chess.Board) -> float:\n    \"Measures the number of legal moves available for the player to move.\"\n    return float(len(list(board.legal_moves)))", "def feature(board: chess.Board) -> float:\n    \"Calculates the total number of squares that the player is attacking.\"\n    attacked_squares = set()\n    for square, piece in board.piece_map().items():\n        if piece.color == board.turn:\n            for move in board.legal_moves:\n                if move.from_square == square:\n                    attacked_squares.add(move.to_square)\n    return float(len(attacked_squares))", "def feature(board: chess.Board) -> float:\n    \"Evaluates the number of pieces on the back rank for each player.\"\n    white_back_rank = sum(1 for sq in range(0, 8) if board.piece_at(chess.square(sq, 0)) is not None and board.piece_at(chess.square(sq, 0)).color == chess.WHITE)\n    black_back_rank = sum(1 for sq in range(0, 8) if board.piece_at(chess.square(sq, 7)) is not None and board.piece_at(chess.square(sq, 7)).color == chess.BLACK)\n    return float(white_back_rank - black_back_rank)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of squares controlled by the player but unoccupied by pieces.\"\n    controlled_empty_squares = set()\n    for square, piece in board.piece_map().items():\n        if piece.color == board.turn:\n            for move in board.legal_moves:\n                if move.from_square == square:\n                    controlled_empty_squares.add(move.to_square)\n    return float(len([sq for sq in controlled_empty_squares if board.piece_at(sq) is None]))", "def feature(board: chess.Board) -> float:\n    \"Measures the maximum distance of pieces from their own back rank.\"\n    max_distance = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == board.turn:\n            distance = 7 - chess.square_rank(square) if board.turn == chess.WHITE else chess.square_rank(square)\n            max_distance = max(max_distance, distance)\n    return float(max_distance)", "def feature(board: chess.Board) -> float:\n    \"Calculates the check situation: returns 1.0 if in check, 0.0 otherwise.\"\n    return float(1.0 if board.is_check() else 0.0)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of pawn promotions possible for both sides\"\n    white_promotions = sum(1 for sq in board.piece_map() if board.piece_at(sq).color == chess.WHITE and chess.square_rank(sq) == 6)\n    black_promotions = sum(1 for sq in board.piece_map() if board.piece_at(sq).color == chess.BLACK and chess.square_rank(sq) == 1)\n    return float(white_promotions - black_promotions)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of legal moves available for each player and returns the difference\"\n    white_moves = len(list(board.legal_moves)) if board.turn else 0\n    black_moves = len(list(board.legal_moves)) if not board.turn else 0\n    return float(white_moves - black_moves)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of pieces on the back rank for both players\"\n    white_back_rank = sum(1 for sq in range(0, 8) if board.piece_at(chess.square(sq, 0)) is not None and board.piece_at(chess.square(sq, 0)).color == chess.WHITE)\n    black_back_rank = sum(1 for sq in range(0, 8) if board.piece_at(chess.square(sq, 7)) is not None and board.piece_at(chess.square(sq, 7)).color == chess.BLACK)\n    return float(white_back_rank - black_back_rank)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of squares controlled by each player's pieces\"\n    control_white = sum(1 for sq in board.piece_map() if board.piece_at(sq).color == chess.WHITE and board.is_attacked_by(chess.BLACK, sq))\n    control_black = sum(1 for sq in board.piece_map() if board.piece_at(sq).color == chess.BLACK and board.is_attacked_by(chess.WHITE, sq))\n    return float(control_white - control_black)", "def feature(board: chess.Board) -> float:\n    \"Measures the control of central squares (d4, d5, e4, e5) by both players\"\n    central_squares = [chess.D4, chess.D5, chess.E4, chess.E5]\n    control_white = sum(1 for sq in central_squares if board.is_attacked_by(chess.WHITE, sq))\n    control_black = sum(1 for sq in central_squares if board.is_attacked_by(chess.BLACK, sq))\n    return float(control_white - control_black)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of pieces that are pinned by the opponent's pieces\"\n    pinned_pieces = 0\n    for sq in board.piece_map():\n        piece = board.piece_at(sq)\n        if piece.color == board.turn:\n            attackers = board.attackers(not piece.color, sq)\n            if any(board.is_check() for attacker in attackers):\n                pinned_pieces += 1\n    return float(pinned_pieces)", "def feature(board: chess.Board) -> float:\n    \"Calculates the total distance of pieces to their respective back ranks\"\n    total_distance = 0\n    for sq in board.piece_map():\n        piece = board.piece_at(sq)\n        if piece.color == chess.WHITE:\n            total_distance += chess.square_distance(sq, chess.A8)\n        else:\n            total_distance += chess.square_distance(sq, chess.A1)\n    return float(total_distance)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of protected pawns (pawns defended by other pieces).\"\n    protected_pawns = 0\n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.PAWN:\n            defenders = board.attackers(piece.color, square)\n            if defenders:\n                protected_pawns += 1\n    return float(protected_pawns)", "def feature(board: chess.Board) -> float:\n    \"Calculates the total number of squares attacked by all pieces of the current player.\"\n    attacked_squares = set()\n    for square, piece in board.piece_map().items():\n        if piece.color == board.turn:\n            attacked_squares.update(board.attacks(square))\n    return float(len(attacked_squares))", "def feature(board: chess.Board) -> float:\n    \"Measures the number of pieces each player has on the 7th rank (enemy's second-to-last rank).\"\n    white_on_7th = sum(1 for square in range(56, 64) if board.piece_at(square) and board.piece_at(square).color == chess.WHITE)\n    black_on_7th = sum(1 for square in range(0, 8) if board.piece_at(square) and board.piece_at(square).color == chess.BLACK)\n    return float(white_on_7th - black_on_7th)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of hanging pieces (pieces that can be captured without retaliation).\"\n    hanging_count = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == board.turn:\n            continue\n        if not any(board.is_attacked_by(piece.color, target_square) for target_square in board.attackers(not piece.color, square)):\n            hanging_count += 1\n    return float(hanging_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of squares with less than 2 defenders from the player's perspective.\"\n    weak_squares_count = 0\n    for square in chess.SQUARES:\n        if board.piece_at(square) is None:\n            attackers = board.attackers(not board.turn, square)\n            if len(attackers) < 2:\n                weak_squares_count += 1\n    return float(weak_squares_count)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of pawn structures (isolated or doubled pawns) on the board.\"\n    pawn_structures = 0\n    pawn_files = {}\n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.PAWN:\n            file = chess.square_file(square)\n            if file in pawn_files:\n                pawn_files[file] += 1\n            else:\n                pawn_files[file] = 1\n    for count in pawn_files.values():\n        if count > 1:\n            pawn_structures += count - 1  # Count doubled pawns\n    return float(pawn_structures)", "def feature(board: chess.Board) -> float:\n    \"Measures the distance of the king to the nearest opponent piece.\"\n    king_square = board.king(board.turn)\n    min_distance = float('inf')\n    for square, piece in board.piece_map().items():\n        if piece.color != board.turn:\n            distance = chess.square_distance(king_square, square)\n            if distance < min_distance:\n                min_distance = distance\n    return float(min_distance)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of legal moves available to the current player.\"\n    legal_moves_count = len(list(board.legal_moves))\n    return float(legal_moves_count)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of backward pawns (pawns that cannot advance due to the presence of a friendly pawn behind them).\"\n    backward_pawn_count = 0\n    for square in chess.SQUARES:\n        piece = board.piece_at(square)\n        if piece and piece.piece_type == chess.PAWN:\n            if piece.color == chess.WHITE and square < 16:\n                behind_square = square + 8\n                if board.piece_at(behind_square) and board.piece_at(behind_square).color == chess.WHITE:\n                    backward_pawn_count += 1\n            elif piece.color == chess.BLACK and square > 47:\n                behind_square = square - 8\n                if board.piece_at(behind_square) and board.piece_at(behind_square).color == chess.BLACK:\n                    backward_pawn_count += 1\n    return float(backward_pawn_count)", "def feature(board: chess.Board) -> float:\n    \"Measures the central control (count of pieces in central squares e4, e5, d4, d5).\"\n    central_squares = [chess.parse_square('d4'), chess.parse_square('d5'), chess.parse_square('e4'), chess.parse_square('e5')]\n    central_control = 0\n    for square in central_squares:\n        piece = board.piece_at(square)\n        if piece and piece.color == board.turn:\n            central_control += 1\n    return float(central_control)", "def feature(board: chess.Board) -> float:\n    \"Measures the material difference, giving a score based on piece values.\"\n    material_balance = 0\n    piece_values = {chess.PAWN: 100, chess.KNIGHT: 300, chess.BISHOP: 300, chess.ROOK: 500, chess.QUEEN: 900, chess.KING: 0}\n    \n    for piece in board.piece_map().values():\n        value = piece_values[piece.piece_type]\n        if piece.color == chess.WHITE:\n            material_balance += value\n        else:\n            material_balance -= value\n    \n    return float(material_balance)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of squares attacked by each player.\"\n    white_attacks = len([square for square in board.piece_map() if board.is_attacked_by(chess.WHITE, square)])\n    black_attacks = len([square for square in board.piece_map() if board.is_attacked_by(chess.BLACK, square)])\n    \n    return float(white_attacks - black_attacks)", "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in distance of pieces to their opponent's king.\"\n    white_king = board.king(chess.WHITE)\n    black_king = board.king(chess.BLACK)\n    \n    if not white_king or not black_king:\n        return 0.0\n    \n    white_distance = sum(chess.square_distance(square, black_king) for square in board.piece_map() if board.piece_map()[square].color == chess.WHITE)\n    black_distance = sum(chess.square_distance(square, white_king) for square in board.piece_map() if board.piece_map()[square].color == chess.BLACK)\n    \n    return float(white_distance - black_distance)", "def feature(board: chess.Board) -> float:\n    \"Measures the total number of pieces on the board for each color.\"\n    white_count = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE)\n    black_count = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK)\n    \n    return float(white_count - black_count)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of doubled pawns for both players.\"\n    white_doubled_pawns = sum(1 for rank in range(8) if sum(1 for file in range(8) if board.piece_at(chess.parse_square(f'{chess.FILE_NAMES[file]}{rank + 1}')) == chess.PAWN) > 1)\n    black_doubled_pawns = sum(1 for rank in range(8) if sum(1 for file in range(8) if board.piece_at(chess.parse_square(f'{chess.FILE_NAMES[file]}{rank + 1}')) == chess.PAWN) > 1)\n    \n    return float(white_doubled_pawns - black_doubled_pawns)", "def feature(board: chess.Board) -> float:\n    \"Calculates the differential in rook activity (number of rooks on open files).\"\n    rook_activity = sum(1 for file in range(8) for rank in range(8) \n                        if board.piece_at(chess.parse_square(f'{chess.FILE_NAMES[file]}{rank + 1}')) == chess.ROOK and \n                        all(board.piece_at(chess.parse_square(f'{chess.FILE_NAMES[file]}{rank_i + 1}')) is None for rank_i in range(8)))    \n    \n    return float(rook_activity)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of checks delivered to the opponent by available pieces.\"\n    checks_delivered = sum(1 for move in board.legal_moves if board.gives_check(move))\n    \n    return float(checks_delivered)", "def feature(board: chess.Board) -> float:\n    \"Calculates the total number of pawns on the board for both players.\"\n    pawn_count = sum(1 for piece in board.piece_map().values() if piece.piece_type == chess.PAWN)\n    return float(pawn_count)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of unprotected pieces for the current player.\"\n    unprotected_count = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == board.turn and not board.is_attacked_by(not board.turn, square):\n            unprotected_count += 1\n    return float(unprotected_count)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of pieces of each type on the board for the current player.\"\n    type_count = {chess.PAWN: 0, chess.KNIGHT: 0, chess.BISHOP: 0, chess.ROOK: 0, chess.QUEEN: 0, chess.KING: 0}\n    for piece in board.piece_map().values():\n        if piece.color == board.turn:\n            type_count[piece.piece_type] += 1\n    return float(sum(type_count.values()))", "def feature(board: chess.Board) -> float:\n    \"Calculates the control of central squares (d4, d5, e4, e5) by counting attacked squares.\"\n    central_squares = [chess.D4, chess.D5, chess.E4, chess.E5]\n    control_count = sum(board.is_attacked_by(board.turn, square) for square in central_squares)\n    return float(control_count)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of checks available to the current player.\"\n    check_count = sum(1 for move in board.legal_moves if board.gives_check(move))\n    return float(check_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the mobility by counting the sum of legal moves available for all pieces of the current player.\"\n    mobility = sum(len(list(board.legal_moves)) for square, piece in board.piece_map().items() if piece.color == board.turn)\n    return float(mobility)", "def feature(board: chess.Board) -> float:\n    \"Evaluates the potential for pawn promotion by counting out-of-position pawns.\"\n    promotion_count = sum(1 for square, piece in board.piece_map().items() \n                          if piece.color == board.turn and piece.piece_type == chess.PAWN and (piece.color == chess.WHITE and chess.square_rank(square) == 6 or piece.color == chess.BLACK and chess.square_rank(square) == 1))\n    return float(promotion_count)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of pieces in a position where they can easily attack or influence the opponent's pieces.\"\n    active_piece_count = sum(1 for square, piece in board.piece_map().items() if piece.color == board.turn and len(list(board.attackers(not board.turn, square))) > 0)\n    return float(active_piece_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the parity of pawns on the board.\"\n    white_pawns = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE and piece.piece_type == chess.PAWN)\n    black_pawns = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK and piece.piece_type == chess.PAWN)\n    return float((white_pawns - black_pawns) % 2)", "def feature(board: chess.Board) -> float:\n    \"Measures the distance of the nearest piece for each color to the opponent's back rank.\"\n    white_distance = min(chess.square_rank(square) for square in board.piece_map() if board.piece_map()[square].color == chess.WHITE)\n    black_distance = min(7 - chess.square_rank(square) for square in board.piece_map() if board.piece_map()[square].color == chess.BLACK)\n    return float(white_distance - black_distance)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pawns that are on the 2nd and 7th ranks.\"\n    white_pawns_on_second = sum(1 for square in board.piece_map() if board.piece_map()[square].color == chess.WHITE and chess.square_rank(square) == 1)\n    black_pawns_on_seventh = sum(1 for square in board.piece_map() if board.piece_map()[square].color == chess.BLACK and chess.square_rank(square) == 6)\n    return float(white_pawns_on_second - black_pawns_on_seventh)", "def feature(board: chess.Board) -> float:\n    \"Calculates the value of pieces that are currently on the 1st and 8th ranks.\"\n    value_map = {chess.PAWN: 100, chess.KNIGHT: 320, chess.BISHOP: 330, chess.ROOK: 500, chess.QUEEN: 900, chess.KING: 20000}\n    value = 0.0\n    for square, piece in board.piece_map().items():\n        if chess.square_rank(square) in (0, 7):  # 1st or 8th rank\n            value += value_map[piece.piece_type] * (1 if piece.color == chess.WHITE else -1)\n    return value", "def feature(board: chess.Board) -> float:\n    \"Normalizes the number of pieces for each player based on the total number of pieces on the board.\"\n    total_pieces = len(board.piece_map())\n    if total_pieces == 0:\n        return 0.0\n    white_pieces = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE)\n    black_pieces = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK)\n    return float(white_pieces / total_pieces - black_pieces / total_pieces)", "def feature(board: chess.Board) -> float:\n    \"Estimates the potential for pawn structure by counting doubled pawns.\"\n    doubled_pawns = 0\n    files = {}\n    for square in board.piece_map():\n        piece = board.piece_map()[square]\n        if piece.piece_type == chess.PAWN:\n            file = chess.square_file(square)\n            files[file] = files.get(file, 0) + 1\n    doubled_pawns = sum(max(0, count - 1) for count in files.values())\n    return float(doubled_pawns)", "def feature(board: chess.Board) -> float:\n    \"Calculates the center control based on pieces occupying or attacking the center squares.\"\n    center_squares = [chess.D4, chess.D5, chess.E4, chess.E5]\n    control = 0.0\n\n    for square in center_squares:\n        if board.is_attacked_by(chess.WHITE, square):\n            control += 1.0\n        if board.is_attacked_by(chess.BLACK, square):\n            control -= 1.0\n    return control", "def feature(board: chess.Board) -> float:\n    \"Computes the total number of squares attacked by each player's pieces.\"\n    white_attacks = sum(1 for square in board.legal_moves if board.is_attacked_by(chess.WHITE, square.to_square))\n    black_attacks = sum(1 for square in board.legal_moves if board.is_attacked_by(chess.BLACK, square.to_square))\n    return float(white_attacks - black_attacks)", "def feature(board: chess.Board) -> float:\n    \"Calculates the sum of squares occupied by pieces for both players.\"\n    player_area = sum(1 for square in board.piece_map() if board.piece_at(square).color == board.turn)\n    opponent_area = sum(1 for square in board.piece_map() if board.piece_at(square).color != board.turn)\n    return float(player_area - opponent_area)", "def feature(board: chess.Board) -> float:\n    \"Calculates the total number of pieces each player has towards victory (pawns and major pieces).\"\n    player_value = sum(1 for piece in board.piece_map().values() if piece.color == board.turn and piece.piece_type in {chess.PAWN, chess.QUEEN, chess.ROOK})\n    opponent_value = sum(1 for piece in board.piece_map().values() if piece.color != board.turn and piece.piece_type in {chess.PAWN, chess.QUEEN, chess.ROOK})\n    return float(player_value - opponent_value)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of squares controlled by each player.\"\n    player_control = sum(1 for square in chess.SQUARES if board.is_attacked_by(board.turn, square))\n    opponent_control = sum(1 for square in chess.SQUARES if board.is_attacked_by(not board.turn, square))\n    return float(player_control - opponent_control)", "def feature(board: chess.Board) -> float:\n    \"Measures the total mobility by calculating the number of legal moves for both players.\"\n    player_moves = len(list(board.legal_moves))\n    opponent_moves = len(list(board.legal_moves))\n    return float(player_moves - opponent_moves)", "def feature(board: chess.Board) -> float:\n    \"Checks the pawn structure by counting the number of isolated pawns for each player.\"\n    def is_isolated(square):\n        file = chess.square_file(square)\n        return (file == 0 or not board.piece_at(chess.square_file(file - 1) + chess.square_rank(square))) and \\\n               (file == 7 or not board.piece_at(chess.square_file(file + 1) + chess.square_rank(square)))\n\n    player_isolated = sum(1 for square in board.piece_map() if board.piece_map()[square].piece_type == chess.PAWN and \n                          board.piece_map()[square].color == board.turn and is_isolated(square))\n    opponent_isolated = sum(1 for square in board.piece_map() if board.piece_map()[square].piece_type == chess.PAWN and \n                            board.piece_map()[square].color != board.turn and is_isolated(square))\n    return float(player_isolated - opponent_isolated)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of pieces experiencing potential threats (attacked by opponent).\"\n    threats = sum(1 for square in board.piece_map() if board.is_attacked_by(not board.turn, square))\n    return float(threats)", "def feature(board: chess.Board) -> float:\n    \"Evaluates the piece coordination based on distance between pieces of the current player.\"\n    piece_positions = [square for square in board.piece_map() if board.piece_map()[square].color == board.turn]\n    if not piece_positions:\n        return 0.0\n    distances = [chess.square_distance(piece_positions[i], piece_positions[j]) for i in range(len(piece_positions)) for j in range(i + 1, len(piece_positions))]\n    return float(sum(distances)) / len(distances) if distances else 0.0", "def feature(board: chess.Board) -> float:\n    \"Assesses the king safety by counting the number of squares around the king that are attacked.\"\n    for square in board.piece_map():\n        if board.piece_map()[square].piece_type == chess.KING and board.piece_map()[square].color == board.turn:\n            king_square = square\n            break\n    threatened_squares = sum(1 for sq in chess.SQUARES if board.is_attacked_by(not board.turn, sq) and chess.square_distance(king_square, sq) <= 1)\n    return float(threatened_squares)", "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in pawns on the 7th rank for both players.\"\n    player_pawns_on_7th = sum(1 for square in board.piece_map() if board.piece_map()[square].piece_type == chess.PAWN and \n                               board.piece_map()[square].color == board.turn and chess.square_rank(square) == 6)\n    opponent_pawns_on_7th = sum(1 for square in board.piece_map() if board.piece_map()[square].piece_type == chess.PAWN and \n                                 board.piece_map()[square].color != board.turn and chess.square_rank(square) == 6)\n    return float(player_pawns_on_7th - opponent_pawns_on_7th)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of squares controlled by the current player's pieces.\"\n    control_count = sum(1 for square in range(64) if board.is_attacked_by(board.turn, square))\n    return float(control_count)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of major pieces (rooks and queens) for both players.\"\n    major_pieces_count = sum(1 for piece in board.piece_map().values() if piece.piece_type in (chess.ROOK, chess.QUEEN))\n    return float(major_pieces_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of pawns remaining for both players.\"\n    pawn_count = sum(1 for piece in board.piece_map().values() if piece.piece_type == chess.PAWN)\n    return float(pawn_count)", "def feature(board: chess.Board) -> float:\n    \"Evaluates the average rank position of pieces for the current player.\"\n    total_rank = sum(chess.square_rank(square) for square in board.piece_map() if board.piece_map()[square].color == board.turn)\n    piece_count = sum(1 for square in board.piece_map() if board.piece_map()[square].color == board.turn)\n    if piece_count == 0:\n        return 0.0\n    return total_rank / piece_count", "def feature(board: chess.Board) -> float:\n    \"Measures the total distance of pieces from the opponent's back rank.\"\n    opponent_back_rank = 0 if board.turn == chess.WHITE else 7\n    total_distance = sum(chess.square_rank(square) - opponent_back_rank for square in board.piece_map() if board.piece_map()[square].color == board.turn)\n    return float(total_distance)", "def feature(board: chess.Board) -> float:\n    \"Calculates the king safety score based on the number of defenders around the king.\"\n    king_square = next(square for square, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color == board.turn)\n    defenders_count = len(board.attackers(board.turn, king_square))\n    return float(defenders_count)", "def feature(board: chess.Board) -> float:\n    \"Measures the distance of the current player's pieces from the center four squares.\"\n    center_squares = [chess.E4, chess.E5, chess.D4, chess.D5]\n    total_distance = sum(min(chess.square_distance(square, center_sq) for center_sq in center_squares) for square in board.piece_map() if board.piece_map()[square].color == board.turn)\n    piece_count = sum(1 for square in board.piece_map() if board.piece_map()[square].color == board.turn)\n    if piece_count == 0:\n        return 0.0\n    return total_distance / piece_count", "def feature(board: chess.Board) -> float:\n    \"Returns the impact of pawn structure by counting isolated pawns.\"\n    isolated_count = 0\n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.PAWN:\n            file = chess.square_file(square)\n            if (file > 0 and not board.piece_at(chess.parse_square(chess.square_name(square)[:-1] + chr(ord(chess.square_name(square)[-1]) - 1))) or \n                file < 7 and not board.piece_at(chess.parse_square(chess.square_name(square)[:-1] + chr(ord(chess.square_name(square)[-1]) + 1)))):\n                isolated_count += 1\n    return float(isolated_count)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of squares controlled by each player.\"\n    white_controlled = sum(board.is_attacked_by(chess.WHITE, square) for square in chess.SQUARES)\n    black_controlled = sum(board.is_attacked_by(chess.BLACK, square) for square in chess.SQUARES)\n    return float(white_controlled - black_controlled)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces that are attacking the opponent's king.\"\n    white_attacks = sum(1 for square in chess.SQUARES if board.is_attacked_by(chess.WHITE, square) \n                         and board.piece_at(square) and board.piece_at(square).piece_type == chess.KING)\n    black_attacks = sum(1 for square in chess.SQUARES if board.is_attacked_by(chess.BLACK, square) \n                         and board.piece_at(square) and board.piece_at(square).piece_type == chess.KING)\n    return float(white_attacks - black_attacks)", "def feature(board: chess.Board) -> float:\n    \"Calculates the mobility of the current player based on possible moves.\"\n    return float(len(list(board.legal_moves)))", "def feature(board: chess.Board) -> float:\n    \"Measures the distance between the kings of both players.\"\n    white_king_square = next((square for square in chess.SQUARES if board.piece_at(square) and \n                               board.piece_at(square).piece_type == chess.KING and \n                               board.piece_at(square).color == chess.WHITE), None)\n    black_king_square = next((square for square in chess.SQUARES if board.piece_at(square) and \n                               board.piece_at(square).piece_type == chess.KING and \n                               board.piece_at(square).color == chess.BLACK), None)\n    if white_king_square is not None and black_king_square is not None:\n        return float(chess.square_distance(white_king_square, black_king_square))\n    return 0.0", "def feature(board: chess.Board) -> float:\n    \"Evaluates the total material value for the opponent.\"\n    piece_values = {chess.PAWN: 100, chess.KNIGHT: 320, chess.BISHOP: 330, chess.ROOK: 500, \n                    chess.QUEEN: 900, chess.KING: 0}\n    total_value = sum(piece_values[piece.piece_type] for piece in board.piece_map().values() \n                      if piece.color != board.turn)\n    return float(total_value)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of squares that are defended by pieces for the current player.\"\n    defended_squares = set()\n    for piece in board.piece_map().values():\n        if piece.color == board.turn:\n            for move in board.legal_moves:\n                if board.piece_at(move.to_square) and board.piece_at(move.to_square).color != board.turn:\n                    defended_squares.add(move.to_square)\n    return float(len(defended_squares))", "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in the number of pawns each player has.\"\n    white_pawns = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE and \n                      piece.piece_type == chess.PAWN)\n    black_pawns = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK and \n                      piece.piece_type == chess.PAWN)\n    return float(white_pawns - black_pawns)", "def feature(board: chess.Board) -> float:\n    \"Measures the average distance of each player's pieces from their own king.\"\n    def average_distance(color):\n        king_square = next(square for square in chess.SQUARES if board.piece_at(square) and \n                           board.piece_at(square).piece_type == chess.KING and \n                           board.piece_at(square).color == color)\n        total_distance = sum(chess.square_distance(square, king_square) \n                              for square, piece in board.piece_map().items() if piece.color == color)\n        piece_count = sum(1 for piece in board.piece_map().values() if piece.color == color)\n        return total_distance / piece_count if piece_count > 0 else 0.0\n    \n    return float(average_distance(chess.WHITE) - average_distance(chess.BLACK))", "def feature(board: chess.Board) -> float:\n    \"Calculates the ratio of the number of pieces to the number of pawns.\"\n    total_pieces = len(board.piece_map())\n    pawns = sum(1 for piece in board.piece_map().values() if piece.piece_type == chess.PAWN)\n    return total_pieces / (pawns + 1e-9)  # Avoid division by zero", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces on the back rank for each player.\"\n    white_back_rank = sum(1 for square in range(56, 64) if board.piece_at(square) is not None)\n    black_back_rank = sum(1 for square in range(0, 8) if board.piece_at(square) is not None)\n    return float(white_back_rank - black_back_rank)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of unprotected opponent pieces in the position.\"\n    unprotected_opponent_pieces = sum(\n        1 for square, piece in board.piece_map().items() \n        if piece.color != board.turn and not board.is_attacked_by(board.turn, square)\n    )\n    return float(unprotected_opponent_pieces)", "def feature(board: chess.Board) -> float:\n    \"Calculates the distance of the player's king to the center of the board.\"\n    king_square = next((square for square, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color == board.turn), None)\n    if king_square is None:\n        return 0.0\n    return float(chess.square_distance(king_square, chess.parse_square('e4')))  # Center square e4", "def feature(board: chess.Board) -> float:\n    \"Counts the number of potential pawn advances for both players.\"\n    potential_advances = sum(\n        1 for square in board.piece_map() \n        if board.piece_map()[square].piece_type == chess.PAWN and \n        ((board.piece_map()[square].color == chess.WHITE and board.piece_at(square + 8) is None) or \n        (board.piece_map()[square].color == chess.BLACK and board.piece_at(square - 8) is None))\n    )\n    return float(potential_advances)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of pieces attacking the opponent's king.\"\n    king_square = next((square for square in board.piece_map() if board.piece_map()[square].piece_type == chess.KING and board.piece_map()[square].color != board.turn), None)\n    if king_square is None:\n        return 0.0\n    attackers_count = sum(1 for square in board.piece_map() if board.is_attacked_by(board.turn, square))\n    return float(attackers_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in piece safety score between both players.\"\n    safety_score = 0.0\n    for square, piece in board.piece_map().items():\n        if piece.color == board.turn:\n            safety_score += 1 if not board.is_attacked_by(not board.turn, square) else -1\n    return float(safety_score)", "def feature(board: chess.Board) -> float:\n    \"Checks for pieces that can fork the opponent's pieces next turn.\"\n    forking_count = 0\n    for move in board.legal_moves:\n        board.push(move)\n        if (board.is_check() or \n            sum(1 for square1 in board.legal_moves for square2 in board.legal_moves if square1 != square2) > 1):\n            forking_count += 1\n        board.pop()\n    return float(forking_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in control of the center squares.\"\n    central_squares = [chess.E4, chess.E5, chess.D4, chess.D5]\n    control_score = sum(1 for square in central_squares if board.is_attacked_by(chess.WHITE, square)) - \\\n                    sum(1 for square in central_squares if board.is_attacked_by(chess.BLACK, square))\n    return float(control_score)", "def feature(board: chess.Board) -> float:\n    \"Calculate the total number of relative piece advantages (value of player's pieces minus opponent's pieces).\"\n    total_value = 0\n    piece_values = {chess.PAWN: 100, chess.KNIGHT: 300, chess.BISHOP: 300, chess.ROOK: 500, chess.QUEEN: 900, chess.KING: 0}\n    \n    for square, piece in board.piece_map().items():\n        total_value += piece_values[piece.piece_type] if piece.color == board.turn else -piece_values[piece.piece_type]\n    \n    return float(total_value)", "def feature(board: chess.Board) -> float:\n    \"Count the total number of pawns on the board, as they are crucial in endgames.\"\n    pawn_count = sum(1 for piece in board.piece_map().values() if piece.piece_type == chess.PAWN)\n    return float(pawn_count)", "def feature(board: chess.Board) -> float:\n    \"Evaluate the position based on the center control by counting pieces on e4, e5, d4, and d5.\"\n    center_squares = [chess.E4, chess.E5, chess.D4, chess.D5]\n    center_control = 0\n    \n    for square in center_squares:\n        if board.piece_at(square) is not None:\n            center_control += 1 if board.piece_at(square).color == board.turn else -1\n            \n    return float(center_control)", "def feature(board: chess.Board) -> float:\n    \"Count the number of pieces that are pinned (cannot move without exposing the king).\"\n    pinned_count = 0\n    \n    for square, piece in board.piece_map().items():\n        if piece.color == board.turn:\n            if board.is_attacked_by(not board.turn, square):\n                pinned_count += 1\n    \n    return float(pinned_count)", "def feature(board: chess.Board) -> float:\n    \"Calculate the number of squares from which the opponent's king is attacked.\"\n    king_square = next((sq for sq, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color != board.turn), None)\n    attack_count = sum(1 for square in board.legal_moves if square.to_square == king_square)\n    \n    return float(attack_count)", "def feature(board: chess.Board) -> float:\n    \"Check if the opponent's king is the only piece left on the back rank, a potential sign of weakness.\"\n    back_rank_pieces = [board.piece_at(sq) for sq in range(chess.A8, chess.H8) if board.piece_at(sq) is not None]\n    is_weak_rank = len(back_rank_pieces) == 1 and back_rank_pieces[0].piece_type == chess.KING and back_rank_pieces[0].color != board.turn\n    \n    return float(1.0 if is_weak_rank else 0.0)", "def feature(board: chess.Board) -> float:\n    \"Assess the mobility of major pieces (rooks and queens) based on their available legal moves.\"\n    major_piece_count = sum(1 for piece in board.piece_map().values() if piece.piece_type in [chess.ROOK, chess.QUEEN] and piece.color == board.turn)\n    total_moves = sum(len(list(board.legal_moves)) for piece in board.piece_map().values() if piece.color == board.turn and piece.piece_type in [chess.ROOK, chess.QUEEN])\n    \n    return float(total_moves / (major_piece_count + 1e-6))  # prevent division by zero", "def feature(board: chess.Board) -> float:\n    \"Evaluate king safety by counting the number of pawns in front of the king.\"\n    king_square = next((sq for sq, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color == board.turn), None)\n    king_file = chess.square_file(king_square)\n    pawns_in_front = sum(1 for rank in range(chess.square_rank(king_square) + 1, 8) if board.piece_at(chess.square(king_file, rank)) == chess.PAWN)\n    \n    return float(pawns_in_front)", "def feature(board: chess.Board) -> float:\n    \"Calculates the ratio of major pieces (QUEENS and ROOKS) to total pieces.\"\n    major_piece_count = sum(1 for piece in board.piece_map().values() if piece.piece_type in {chess.QUEEN, chess.ROOK})\n    total_piece_count = len(board.piece_map())\n    return major_piece_count / total_piece_count if total_piece_count > 0 else 0.0", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces attacking the opponent's king.\"\n    opponent_king_square = next(square for square, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color != board.turn)\n    attacking_pieces_count = sum(1 for square in board.attackers(board.turn, opponent_king_square))\n    return float(attacking_pieces_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the average control range of the player's pieces.\"\n    piece_squares = [square for square, piece in board.piece_map().items() if piece.color == board.turn]\n    control_range = sum(len(board.attacks(square)) for square in piece_squares)\n    return control_range / len(piece_squares) if piece_squares else 0.0", "def feature(board: chess.Board) -> float:\n    \"Determines if the currently moving player has a major piece involvement in attacks (QUEENS and ROOKS).\"\n    major_attacks_count = sum(1 for square in board.legal_moves if board.piece_at(square.from_square) and board.piece_at(square.from_square).piece_type in {chess.QUEEN, chess.ROOK})\n    return float(major_attacks_count)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces pinned by the opponent's pieces.\"\n    pinned_count = sum(1 for square, piece in board.piece_map().items() if board.is_attacked_by(not board.turn, square) and len(board.attackers(board.turn, square)) == 0)\n    return float(pinned_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of advanced pawns for the current player (pawns on rank 4 or higher for White, and rank 5 or lower for Black).\"\n    advanced_pawn_count = sum(1 for square, piece in board.piece_map().items() if piece.piece_type == chess.PAWN and ((piece.color == chess.WHITE and chess.square_rank(square) >= 3) or (piece.color == chess.BLACK and chess.square_rank(square) <= 4)))\n    return float(advanced_pawn_count)", "def feature(board: chess.Board) -> float:\n    \"Measures mobility by calculating the number of legal moves available to the current player.\"\n    return float(len(list(board.legal_moves)))", "def feature(board: chess.Board) -> float:\n    \"Measures the total number of pieces on the board.\"\n    return float(len(board.piece_map()))", "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in unsupported pieces for both players.\"\n    white_unsupported = sum(1 for square, piece in board.piece_map().items() \n                             if piece.color == chess.WHITE and not board.attackers(chess.BLACK, square))\n    black_unsupported = sum(1 for square, piece in board.piece_map().items() \n                             if piece.color == chess.BLACK and not board.attackers(chess.WHITE, square))\n    return float(white_unsupported - black_unsupported)", "def feature(board: chess.Board) -> float:\n    \"Counts the total number of pawns on the board.\"\n    return float(len([piece for piece in board.piece_map().values() \n                      if piece.piece_type == chess.PAWN]))", "def feature(board: chess.Board) -> float:\n    \"Measures the total number of pieces in the back rank for each player.\"\n    white_back_rank = sum(1 for square, piece in board.piece_map().items() \n                           if piece.color == chess.WHITE and chess.square_rank(square) == 0)\n    black_back_rank = sum(1 for square, piece in board.piece_map().items() \n                           if piece.color == chess.BLACK and chess.square_rank(square) == 7)\n    return float(white_back_rank - black_back_rank)", "def feature(board: chess.Board) -> float:\n    \"Calculates the ratio of knights to total pieces for the current player.\"\n    current_player = chess.WHITE if board.turn else chess.BLACK\n    total_pieces = len(board.piece_map())\n    knight_count = len([piece for piece in board.piece_map().values() \n                        if piece.color == current_player and piece.piece_type == chess.KNIGHT])\n    return knight_count / total_pieces if total_pieces > 0 else 0.0", "def feature(board: chess.Board) -> float:\n    \"Measures the number of pawns that are doubled on files.\"\n    file_count = {}\n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.PAWN:\n            file = chess.square_file(square)\n            if file in file_count:\n                file_count[file] += 1\n            else:\n                file_count[file] = 1\n    doubled_pawns = sum(count - 1 for count in file_count.values() if count > 1)\n    return float(doubled_pawns)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces attacking a player's king.\"\n    current_player = chess.WHITE if board.turn else chess.BLACK\n    king_square = next(square for square, piece in board.piece_map().items() \n                       if piece.piece_type == chess.KING and piece.color == current_player)\n    attackers = len(board.attackers(not current_player, king_square))\n    return float(attackers)", "def feature(board: chess.Board) -> float:\n    \"Calculates the distance of the king from the center of the board.\"\n    current_player_king_square = next(square for square, piece in board.piece_map().items() \n                                        if piece.piece_type == chess.KING and piece.color == (chess.WHITE if board.turn else chess.BLACK))\n    distance_to_center = chess.square_distance(current_player_king_square, chess.E4) + \\\n                         chess.square_distance(current_player_king_square, chess.E5) + \\\n                         chess.square_distance(current_player_king_square, chess.D4) + \\\n                         chess.square_distance(current_player_king_square, chess.D5)\n    return float(distance_to_center)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of legal moves in total for both players.\"\n    return float(len(list(board.legal_moves)))", "def feature(board: chess.Board) -> float:\n    \"Calculates the total number of pawns on the board and compares the counts for both players.\"\n    white_pawn_count = sum(1 for piece in board.piece_map().values() if piece.piece_type == chess.PAWN and piece.color == chess.WHITE)\n    black_pawn_count = sum(1 for piece in board.piece_map().values() if piece.piece_type == chess.PAWN and piece.color == chess.BLACK)\n    result = white_pawn_count - black_pawn_count\n    return float(result)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of hanging pieces on the board for both players.\"\n    hanging_count = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == chess.WHITE:\n            if not board.is_attacked_by(chess.BLACK, square):\n                hanging_count += 1\n        else:\n            if not board.is_attacked_by(chess.WHITE, square):\n                hanging_count += 1\n    return float(hanging_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in number of pieces positioned on the central squares.\"\n    central_squares = [chess.D4, chess.D5, chess.E4, chess.E5]\n    white_center_count = sum(1 for square in central_squares if board.piece_at(square) and board.piece_at(square).color == chess.WHITE)\n    black_center_count = sum(1 for square in central_squares if board.piece_at(square) and board.piece_at(square).color == chess.BLACK)\n    result = float(white_center_count - black_center_count)\n    return result", "def feature(board: chess.Board) -> float:\n    \"Measures control of open files by counting rooks on open files for both players.\"\n    open_files = [f for f in range(8) if all(board.piece_at(sq) is None for sq in range(chess.A1 + f, chess.H1 + f, 8))]\n    white_rook_control = sum(1 for f in open_files for sq in range(chess.A1 + f, chess.H1 + f, 8) if board.piece_at(sq) and board.piece_at(sq).piece_type == chess.ROOK and board.piece_at(sq).color == chess.WHITE)\n    black_rook_control = sum(1 for f in open_files for sq in range(chess.A1 + f, chess.H1 + f, 8) if board.piece_at(sq) and board.piece_at(sq).piece_type == chess.ROOK and board.piece_at(sq).color == chess.BLACK)\n    result = float(white_rook_control - black_rook_control)\n    return result", "def feature(board: chess.Board) -> float:\n    \"Calculates the distance of pieces from the center of the board.\"\n    total_distance = sum(chess.square_distance(square, chess.E4) for square in board.piece_map())\n    return float(total_distance)", "def feature(board: chess.Board) -> float:\n    \"Counts the defensive pieces available protecting other pieces.\"\n    defense_count = 0\n    for square, piece in board.piece_map().items():\n        if any(board.is_attacked_by(piece.color, target_square) for target_square in board.attackers(piece.color, square)):\n            defense_count += 1\n    return float(defense_count)", "def feature(board: chess.Board) -> float:\n    \"Measures the imbalance of material by calculating the difference in value of pieces on board.\"\n    piece_values = {\n        chess.PAWN: 100,\n        chess.KNIGHT: 320,\n        chess.BISHOP: 330,\n        chess.ROOK: 500,\n        chess.QUEEN: 900,\n        chess.KING: 10000\n    }\n    material_balance = 0\n    for piece in board.piece_map().values():\n        material_balance += piece_values[piece.piece_type] if piece.color == chess.WHITE else -piece_values[piece.piece_type]\n    return float(material_balance)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of opposing pieces immediately reachable by the current player's pieces.\"\n    attacking_count = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == board.turn:\n            attacking_count += sum(1 for target in board.attackers(chess.WHITE if piece.color == chess.WHITE else chess.BLACK, square))\n    return float(attacking_count)", "def feature(board: chess.Board) -> float:\n    \"Measures the total number of pieces on the board for both players.\"\n    total_pieces = len(board.piece_map())\n    return float(total_pieces)", "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in the number of pieces controlled by each player.\"\n    white_control = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE)\n    black_control = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK)\n    return float(white_control - black_control)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces attacking the opponent's king.\"\n    king_square = None\n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.KING and piece.color == chess.BLACK:\n            king_square = square\n            break\n    if king_square is None:\n        return 0.0\n    attacks = board.attackers(chess.WHITE, king_square)\n    return float(len(attacks))", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of pawn structures (connected pawns) on the board.\"\n    pawn_structure_count = 0\n    pawn_positions = [square for square in board.piece_map() if board.piece_map()[square].piece_type == chess.PAWN]\n    \n    for square in pawn_positions:\n        if (board.piece_at(square - 8) and board.piece_at(square - 8).piece_type == chess.PAWN) or \\\n           (board.piece_at(square - 7) and board.piece_at(square - 7).piece_type == chess.PAWN):\n            pawn_structure_count += 1\n    return float(pawn_structure_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the mobility of pieces by counting the number of legal moves available.\"\n    legal_moves_count = sum(1 for move in board.legal_moves)\n    return float(legal_moves_count)", "def feature(board: chess.Board) -> float:\n    \"Measures the distance of the closest piece to the enemy's king.\"\n    king_square = board.king(chess.BLACK) if board.turn else board.king(chess.WHITE)\n    min_distance = float('inf')\n    \n    for square, piece in board.piece_map().items():\n        if piece.color == (chess.WHITE if board.turn else chess.BLACK):\n            distance = chess.square_distance(square, king_square)\n            min_distance = min(min_distance, distance)\n    \n    return float(min_distance if min_distance != float('inf') else 0)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of forks available to the current player.\"\n    fork_count = 0\n\n    for move in board.legal_moves:\n        board.push(move)\n        if any(board.is_check() and len(board.attackers(board.turn, board.king(board.turn))) > 1 for enemy_move in board.legal_moves):\n            fork_count += 1\n        board.pop()\n    \n    return float(fork_count)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces that are doubled (pawns on the same file).\"\n    doubled_pawns = 0\n    files = {}\n    \n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.PAWN:\n            file_index = chess.square_file(square)\n            files[file_index] = files.get(file_index, 0) + 1\n    \n    for count in files.values():\n        if count > 1:\n            doubled_pawns += 1\n            \n    return float(doubled_pawns)", "def feature(board: chess.Board) -> float:\n    \"Calculates the total value of all pieces on the board.\"\n    piece_values = {\n        chess.PAWN: 100,\n        chess.KNIGHT: 300,\n        chess.BISHOP: 300,\n        chess.ROOK: 500,\n        chess.QUEEN: 900,\n        chess.KING: 0  # King doesn't contribute to material value in terms of board evaluation\n    }\n    \n    total_value = 0\n    for piece in board.piece_map().values():\n        total_value += piece_values[piece.piece_type] * (1 if piece.color == chess.WHITE else -1)\n    \n    return float(total_value)", "def feature(board: chess.Board) -> float:\n    \"Calculates the total number of pieces on the board.\"\n    total_pieces = len(board.piece_map())\n    return float(total_pieces)", "def feature(board: chess.Board) -> float:\n    \"Measures the distance of the kings from the center of the board.\"\n    w_king_square = board.king(chess.WHITE)\n    b_king_square = board.king(chess.BLACK)\n    center = chess.parse_square('d4')  # Approximately center square\n    w_distance = chess.square_distance(w_king_square, center)\n    b_distance = chess.square_distance(b_king_square, center)\n    return float(w_distance - b_distance)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of squares attacked by both players.\"\n    white_attacks = sum(board.is_attacked_by(chess.WHITE, sq) for sq in board.piece_map())\n    black_attacks = sum(board.is_attacked_by(chess.BLACK, sq) for sq in board.piece_map())\n    return float(white_attacks - black_attacks)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of pieces occupying the back rank for both players.\"\n    white_back_rank = sum(1 for sq in range(56, 64) if board.piece_at(sq) is not None)\n    black_back_rank = sum(1 for sq in range(0, 8) if board.piece_at(sq) is not None)\n    return float(white_back_rank - black_back_rank)", "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in pawn structure between both sides, focusing on doubled pawns.\"\n    w_doubled_pawns = sum(1 for file in range(8) if len([sq for sq in board.pieces(chess.PAWN, chess.WHITE) if chess.square_file(sq) == file]) > 1)\n    b_doubled_pawns = sum(1 for file in range(8) if len([sq for sq in board.pieces(chess.PAWN, chess.BLACK) if chess.square_file(sq) == file]) > 1)\n    return float(w_doubled_pawns - b_doubled_pawns)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of rooks on open files for both players.\"\n    w_open_files = sum(1 for file in range(8) if all(board.piece_at(sq) is None for sq in range(file * 8, (file + 1) * 8)))\n    b_open_files = sum(1 for file in range(8) if all(board.piece_at(sq) is None for sq in range(file * 8, (file + 1) * 8)))\n    return float(w_open_files - b_open_files)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of minor pieces (knights and bishops) for both players.\"\n    w_minor_pieces = sum(1 for p in board.piece_map().values() if p.color == chess.WHITE and p.piece_type in (chess.KNIGHT, chess.BISHOP))\n    b_minor_pieces = sum(1 for p in board.piece_map().values() if p.color == chess.BLACK and p.piece_type in (chess.KNIGHT, chess.BISHOP))\n    return float(w_minor_pieces - b_minor_pieces)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of squares with a pawn in front of them for both players.\"\n    w_pawns_in_front = sum(1 for sq in board.pieces(chess.PAWN, chess.WHITE) if board.piece_at(sq + 8) is not None)\n    b_pawns_in_front = sum(1 for sq in board.pieces(chess.PAWN, chess.BLACK) if board.piece_at(sq - 8) is not None)\n    return float(w_pawns_in_front - b_pawns_in_front)", "def feature(board: chess.Board) -> float:\n    \"Calculates the average value of all pieces on the board.\"\n    piece_values = {\n        chess.PAWN: 100,\n        chess.KNIGHT: 320,\n        chess.BISHOP: 330,\n        chess.ROOK: 500,\n        chess.QUEEN: 900,\n        chess.KING: 20000\n    }\n    total_value = sum(piece_values[piece.piece_type] for piece in board.piece_map().values())\n    return float(total_value) / float(len(board.piece_map())) if len(board.piece_map()) > 0 else 0.0", "def feature(board: chess.Board) -> float:\n    \"Counts the number of enemy pieces that are attacked by player's pieces.\"\n    attacked_enemy_pieces = sum(1 for square, piece in board.piece_map().items() if piece.color == (chess.WHITE if board.turn else chess.BLACK) and board.is_attacked_by(not piece.color, square))\n    return float(attacked_enemy_pieces)", "def feature(board: chess.Board) -> float:\n    \"Measures the total number of squares that are currently defended by the player's pieces.\"\n    defended_squares = set()\n    for square, piece in board.piece_map().items():\n        if piece.color == (chess.WHITE if board.turn else chess.BLACK):\n            for move in board.legal_moves:\n                if move.from_square == square:\n                    defended_squares.add(move.to_square)\n    return float(len(defended_squares))", "def feature(board: chess.Board) -> float:\n    \"Calculates the ratio of minor pieces (knights and bishops) to the total piece count.\"\n    total_pieces = len(board.piece_map())\n    minor_piece_count = sum(1 for piece in board.piece_map().values() if piece.piece_type in {chess.KNIGHT, chess.BISHOP})\n    return float(minor_piece_count / total_pieces) if total_pieces > 0 else 0.0", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces in the opponent's back rank.\"\n    opponent_back_rank = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == (chess.WHITE if board.turn else chess.BLACK) and chess.square_rank(square) == (0 if piece.color == chess.WHITE else 7):\n            opponent_back_rank += 1\n    return float(opponent_back_rank)", "def feature(board: chess.Board) -> float:\n    \"Measures the distance of the opponent's king from the center of the board.\"\n    enemy_king_square = next((square for square, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color != (chess.WHITE if board.turn else chess.BLACK)), None)\n    center_square = chess.parse_square('e4')  # Center square \n    return float(chess.square_distance(center_square, enemy_king_square)) if enemy_king_square is not None else 0.0", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces that are pinned to the king.\"\n    pinned_pieces = sum(1 for square in range(64) if board.piece_at(square) and board.is_attacked_by(not board.piece_at(square).color, square) and board.is_check())\n    return float(pinned_pieces)", "def feature(board: chess.Board) -> float:\n    \"Calculates the safety of the king by summing the number of attacking squares around the opponent's king.\"\n    opponent_king_square = next((square for square, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color != (chess.WHITE if board.turn else chess.BLACK)), None)\n    if opponent_king_square is None:\n        return 0.0\n    safe_squares = sum(1 for x in range(-1, 2) for y in range(-1, 2) if (x, y) != (0, 0) and board.is_attacked_by(board.piece_at(opponent_king_square).color, chess.square_file(opponent_king_square) + x * 8 + y))\n    return float(max(0, 8 - safe_squares))  # Total squares around the king - attacked squares", "def feature(board: chess.Board) -> float:\n    \"Calculates the distance from each king to the center of the board.\"\n    king_square = board.king(chess.WHITE) if board.turn else board.king(chess.BLACK)\n    center_square = chess.parse_square('e4')\n    distance = chess.square_distance(king_square, center_square)\n    return float(distance)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces that can be promoted on the 7th rank.\"\n    promoting_pawns = sum(1 for square, piece in board.piece_map().items() \n                          if piece.piece_type == chess.PAWN and \n                          ((piece.color == chess.WHITE and chess.square_rank(square) == 6) or \n                           (piece.color == chess.BLACK and chess.square_rank(square) == 1)))\n    return float(promoting_pawns)", "def feature(board: chess.Board) -> float:\n    \"Measures the total number of half-open files for both players.\"\n    half_open_files = 0\n    for file in range(8):\n        white_pawn_in_file = any(board.piece_at(chess.square(file, rank)) == chess.PAWN and \n                                  chess.square_rank(chess.square(file, rank)) > 0 for rank in range(8))\n        black_pawn_in_file = any(board.piece_at(chess.square(file, rank)) == chess.PAWN and \n                                  chess.square_rank(chess.square(file, rank)) < 7 for rank in range(8))\n        if white_pawn_in_file != black_pawn_in_file:\n            half_open_files += 1\n    return float(half_open_files)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces on the 7th rank for each player.\"\n    pieces_on_seventh_rank = {\n        chess.WHITE: sum(1 for square in range(8) if board.piece_at(chess.square(square, 6))),\n        chess.BLACK: sum(1 for square in range(8) if board.piece_at(chess.square(square, 1)))\n    }\n    score = pieces_on_seventh_rank[chess.WHITE] - pieces_on_seventh_rank[chess.BLACK]\n    return float(score)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of squares under attack by each player's pieces.\"\n    white_attacks = sum(board.is_attacked_by(chess.WHITE, square) for square in chess.SQUARES)\n    black_attacks = sum(board.is_attacked_by(chess.BLACK, square) for square in chess.SQUARES)\n    return float(white_attacks - black_attacks)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of checks available to the current player and the opponent.\"\n    my_checks = sum(1 for move in board.legal_moves if board.gives_check(move))\n    opponent_checks = sum(1 for move in board.legal_moves if not board.turn and board.gives_check(move))\n    return float(my_checks - opponent_checks)", "def feature(board: chess.Board) -> float:\n    \"Measures the total value of pieces on the board for each color.\"\n    piece_values = {chess.PAWN: 100, chess.KNIGHT: 300, chess.BISHOP: 300,\n                    chess.ROOK: 500, chess.QUEEN: 900, chess.KING: 20000}\n    white_value = sum(piece_values[piece.piece_type] for piece in board.piece_map().values() if piece.color == chess.WHITE)\n    black_value = sum(piece_values[piece.piece_type] for piece in board.piece_map().values() if piece.color == chess.BLACK)\n    return white_value - black_value", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces that are currently pinned to the king.\"\n    pinned_count = 0\n    for square in chess.SQUARES:\n        piece = board.piece_at(square)\n        if piece is not None and piece.color == board.turn:\n            for attacker in board.attackers(not board.turn, square):\n                if board.piece_at(attacker).piece_type in {chess.ROOK, chess.QUEEN}:\n                    pinned_count += 1\n                    break\n    return float(pinned_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the central control by checking the number of pieces in the center squares.\"\n    central_squares = [chess.E4, chess.E5, chess.D4, chess.D5]\n    control_count = sum(1 for square in central_squares if board.piece_at(square) is not None)\n    return float(control_count)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of pawns that are doubled for each player.\"\n    white_doubled = sum(1 for file in range(8) if sum(1 for rank in range(8) if board.piece_at(chess.square(file, rank)) == chess.PAWN and rank in [6, 5]) > 1)\n    black_doubled = sum(1 for file in range(8) if sum(1 for rank in range(8) if board.piece_at(chess.square(file, rank)) == chess.PAWN and rank in [1, 2]) > 1)\n    return float(white_doubled - black_doubled)", "def feature(board: chess.Board) -> float:\n    \"Scores the activity of the rooks by counting their open files.\"\n    open_files = set()\n    for file in range(8):\n        if all(board.piece_at(chess.square(file, rank)) is None for rank in range(8)):\n            open_files.add(file)\n    rook_activity = sum(1 for square in board.piece_map() if board.piece_at(square).piece_type == chess.ROOK and chess.square_file(square) in open_files)\n    return float(rook_activity)", "def feature(board: chess.Board) -> float:\n    \"Measures the distance of each king to the center of the board.\"\n    white_king_square = next(square for square, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color == chess.WHITE)\n    black_king_square = next(square for square, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color == chess.BLACK)\n    white_distance = chess.square_distance(white_king_square, chess.E4) + chess.square_distance(white_king_square, chess.E5) + chess.square_distance(white_king_square, chess.D4) + chess.square_distance(white_king_square, chess.D5)\n    black_distance = chess.square_distance(black_king_square, chess.E4) + chess.square_distance(black_king_square, chess.E5) + chess.square_distance(black_king_square, chess.D4) + chess.square_distance(black_king_square, chess.D5)\n    return float(black_distance - white_distance)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of pieces in the endgame (total pieces remaining).\"\n    total_pieces = len(board.piece_map())\n    return float(total_pieces)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of squares that are attacked by each side.\"\n    white_attacks = len([square for square in chess.SQUARES if board.is_attacked_by(chess.WHITE, square)])\n    black_attacks = len([square for square in chess.SQUARES if board.is_attacked_by(chess.BLACK, square)])\n    return float(white_attacks - black_attacks)", "def feature(board: chess.Board) -> float:\n    \"Measures the total number of developed pieces for each player.\"\n    developed_white = sum(1 for square, piece in board.piece_map().items() if piece.color == chess.WHITE and piece.piece_type in {chess.KNIGHT, chess.BISHOP, chess.ROOK, chess.QUEEN} and chess.square_rank(square) > 0)\n    developed_black = sum(1 for square, piece in board.piece_map().items() if piece.color == chess.BLACK and piece.piece_type in {chess.KNIGHT, chess.BISHOP, chess.ROOK, chess.QUEEN} and chess.square_rank(square) < 7)\n    return float(developed_white - developed_black)", "def feature(board: chess.Board) -> float:\n    \"Measures the total value of pieces on the board, weighted by position (closer to the opponent's back rank).\"\n    value = 0.0\n    for square, piece in board.piece_map().items():\n        piece_value = {chess.PAWN: 100, chess.KNIGHT: 320, chess.BISHOP: 330, chess.ROOK: 500, chess.QUEEN: 900, chess.KING: 0}\n        position_weight = 1 + (7 - chess.square_rank(square)) / 10  # Add additional weight for pieces close to the opponent\n        value += piece_value[piece.piece_type] * position_weight if piece.color == chess.WHITE else -piece_value[piece.piece_type] * position_weight\n    return value", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of pieces controlling the opponent's back rank.\"\n    control_count = 0\n    opponent_back_rank = 0 if board.turn == chess.WHITE else 7\n    for file in range(8):\n        square = chess.square(file, opponent_back_rank)\n        if board.is_attacked_by(board.turn, square):\n            control_count += 1\n    return float(control_count)", "def feature(board: chess.Board) -> float:\n    \"Measures the alignment of rooks and queens on the same files or ranks.\"\n    alignment_count = 0\n    pieces = board.piece_map()\n    for square, piece in pieces.items():\n        if piece.piece_type in (chess.ROOK, chess.QUEEN):\n            for target_square, target_piece in pieces.items():\n                if target_piece.piece_type in (chess.ROOK, chess.QUEEN) and (chess.square_file(square) == chess.square_file(target_square) or chess.square_rank(square) == chess.square_rank(target_square)):\n                    alignment_count += 1\n    return float(alignment_count)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of discovered attacks available for both players.\"\n    discovered_attacks = 0\n    for square, piece in board.piece_map().items():\n        if piece.piece_type in (chess.ROOK, chess.QUEEN):\n            allies = board.attackers(board.turn, square)\n            for ally in allies:\n                if board.is_attacked_by(board.turn, ally):\n                    discovered_attacks += 1\n    return float(discovered_attacks)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of squares attacked by the player's pieces.\"\n    attacking_squares = set()\n    for square, piece in board.piece_map().items():\n        if piece.color == board.turn:\n            for target_square in board.attackers(board.turn, square):\n                attacking_squares.add(target_square)\n    return float(len(attacking_squares))", "def feature(board: chess.Board) -> float:\n    \"Measures the distance of pieces from the center (optimal positioning).\"\n    center_squares = [chess.square(3, 3), chess.square(3, 4), chess.square(4, 3), chess.square(4, 4)]\n    central_control_score = 0.0\n    for square, piece in board.piece_map().items():\n        distance = min(chess.square_distance(square, center_square) for center_square in center_squares)\n        central_control_score += (1 / (1 + distance)) if piece.color == board.turn else -(1 / (1 + distance))\n    return central_control_score", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of pieces that threaten the kings on each side.\"\n    threats_to_kings = {chess.WHITE: 0, chess.BLACK: 0}\n    for square in [board.king(chess.WHITE), board.king(chess.BLACK)]:\n        if square is not None:\n            for attacker in board.attackers(chess.WHITE if board.color_at(square) == chess.BLACK else chess.BLACK, square):\n                threats_to_kings[board.color_at(square)] += 1\n    return float(threats_to_kings[chess.WHITE] - threats_to_kings[chess.BLACK])  # Positive if White has more threats", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces in the opponent's territory (half of the board).\"\n    opponent_territory_count = 0\n    for square, piece in board.piece_map().items():\n        if (piece.color == chess.WHITE and chess.square_rank(square) >= 4) or (piece.color == chess.BLACK and chess.square_rank(square) <= 3):\n            opponent_territory_count += 1\n    return float(opponent_territory_count)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of advanced pawns towards the opponent's back rank.\"\n    advanced_pawns = 0\n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.PAWN:\n            if (piece.color == chess.WHITE and chess.square_rank(square) > 4) or \\\n               (piece.color == chess.BLACK and chess.square_rank(square) < 3):\n                advanced_pawns += 1\n    return float(advanced_pawns)", "def feature(board: chess.Board) -> float:\n    \"Calculates the total number of pieces that are in the back rank for each player.\"\n    back_rank_pieces = {chess.WHITE: 0, chess.BLACK: 0}\n    for square, piece in board.piece_map().items():\n        if piece.color == chess.WHITE and chess.square_rank(square) == 0:\n            back_rank_pieces[chess.WHITE] += 1\n        elif piece.color == chess.BLACK and chess.square_rank(square) == 7:\n            back_rank_pieces[chess.BLACK] += 1\n    return float(back_rank_pieces[chess.WHITE] - back_rank_pieces[chess.BLACK])", "def feature(board: chess.Board) -> float:\n    \"Measures the mobility advantage by counting the difference in legal moves.\"\n    white_moves = sum(1 for move in board.legal_moves if move.from_square in board.piece_map() and board.piece_map()[move.from_square].color == chess.WHITE)\n    black_moves = sum(1 for move in board.legal_moves if move.from_square in board.piece_map() and board.piece_map()[move.from_square].color == chess.BLACK)\n    return float(white_moves - black_moves)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of unprotected pieces for the current player.\"\n    unprotected_pieces = 0\n    color = board.turn\n    for square, piece in board.piece_map().items():\n        if piece.color == color:\n            if not board.attackers(not color, square):\n                unprotected_pieces += 1\n    return float(unprotected_pieces)", "def feature(board: chess.Board) -> float:\n    \"Measures the distance of the king from the center of the board.\"\n    king_square = board.king(chess.WHITE) if board.turn == chess.WHITE else board.king(chess.BLACK)\n    distance_from_center = chess.square_distance(king_square, chess.parse_square('e4')) + chess.square_distance(king_square, chess.parse_square('d4'))\n    return float(distance_from_center)", "def feature(board: chess.Board) -> float:\n    \"Quantifies the number of pieces that are controlling the center squares.\"\n    center_squares = [chess.E4, chess.D4, chess.E5, chess.D5]\n    control_count = 0\n    for square in center_squares:\n        control_count += len(board.attackers(chess.WHITE, square)) - len(board.attackers(chess.BLACK, square))\n    return float(control_count)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of checks available for the current player.\"\n    check_count = 0\n    for move in board.legal_moves:\n        board.push(move)\n        if board.is_check():\n            check_count += 1\n        board.pop()\n    return float(check_count)", "def feature(board: chess.Board) -> float:\n    \"Measures the total number of pieces occupying each player's back rank.\"\n    white_back_rank_pieces = sum(1 for square in range(0, 8) if board.piece_at(chess.square(square, 0)) is not None and board.piece_at(chess.square(square, 0)).color == chess.WHITE)\n    black_back_rank_pieces = sum(1 for square in range(0, 8) if board.piece_at(chess.square(square, 7)) is not None and board.piece_at(chess.square(square, 7)).color == chess.BLACK)\n    return float(white_back_rank_pieces - black_back_rank_pieces)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of pawns that are connected in a file.\"\n    connected_pawns = 0\n    pawn_files = {}\n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.PAWN:\n            file_index = chess.square_file(square)\n            if file_index not in pawn_files:\n                pawn_files[file_index] = []\n            pawn_files[file_index].append(piece)\n    for pawns in pawn_files.values():\n        if len(pawns) > 1:\n            connected_pawns += len(pawns) - 1\n    return float(connected_pawns)", "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in the number of pawns for each side.\"\n    white_pawns = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE and piece.piece_type == chess.PAWN)\n    black_pawns = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK and piece.piece_type == chess.PAWN)\n    return float(white_pawns - black_pawns)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces attacking each king.\"\n    white_king_square = next(square for square, piece in board.piece_map().items() if piece.color == chess.WHITE and piece.piece_type == chess.KING)\n    black_king_square = next(square for square, piece in board.piece_map().items() if piece.color == chess.BLACK and piece.piece_type == chess.KING)\n    white_attacks = len(board.attackers(chess.WHITE, black_king_square))\n    black_attacks = len(board.attackers(chess.BLACK, white_king_square))\n    return float(white_attacks - black_attacks)", "def feature(board: chess.Board) -> float:\n    \"Measures the mobility of pieces by counting the number of legal moves for all pieces.\"\n    move_count = sum(len(list(board.legal_moves)) for square in board.piece_map().keys())\n    return float(move_count)", "def feature(board: chess.Board) -> float:\n    \"Evaluates the number of squares controlled by the opponent.\"\n    opponent_color = chess.BLACK if board.turn else chess.WHITE\n    controlled_squares = {move.to_square for move in board.legal_moves if board.is_attacked_by(opponent_color, move.to_square)}\n    return float(len(controlled_squares))", "def feature(board: chess.Board) -> float:\n    \"Evaluates the distance of each player's king from the center of the board.\"\n    white_king_square = next(square for square, piece in board.piece_map().items() if piece.color == chess.WHITE and piece.piece_type == chess.KING)\n    black_king_square = next(square for square, piece in board.piece_map().items() if piece.color == chess.BLACK and piece.piece_type == chess.KING)\n    center_distance = chess.square_distance(white_king_square, chess.parse_square('e4')) + chess.square_distance(black_king_square, chess.parse_square('e5'))\n    return float(center_distance)", "def feature(board: chess.Board) -> float:\n    \"Quantifies the material advantage by summing the values of pieces on the board.\"\n    piece_values = {chess.PAWN: 100, chess.KNIGHT: 320, chess.BISHOP: 330, chess.ROOK: 500, chess.QUEEN: 900, chess.KING: 0}\n    total_value = sum(piece_values[piece.piece_type] for piece in board.piece_map().values())\n    return float(total_value)", "def feature(board: chess.Board) -> float:\n    \"Measures the vulnerability of the kings by counting the number of attackers on their squares.\"\n    white_king_square = next(square for square, piece in board.piece_map().items() if piece.color == chess.WHITE and piece.piece_type == chess.KING)\n    black_king_square = next(square for square, piece in board.piece_map().items() if piece.color == chess.BLACK and piece.piece_type == chess.KING)\n    white_king_vulnerability = len(board.attackers(chess.WHITE, white_king_square))\n    black_king_vulnerability = len(board.attackers(chess.BLACK, black_king_square))\n    return float(black_king_vulnerability - white_king_vulnerability)", "def feature(board: chess.Board) -> float:\n    \"Calculates the overall piece density on the board (pieces per square).\"\n    piece_count = len(board.piece_map())\n    total_squares = 64.0\n    return piece_count / total_squares", "def feature(board: chess.Board) -> float:\n    \"Measures the difference in the number of rooks each player has on open files.\"\n    open_files_white = sum(1 for file in range(8) if all(board.piece_at(chess.square(file, rank)) is None for rank in range(8) if board.piece_at(chess.square(file, rank)) and board.piece_at(chess.square(file, rank)).color == chess.WHITE))\n    open_files_black = sum(1 for file in range(8) if all(board.piece_at(chess.square(file, rank)) is None for rank in range(8) if board.piece_at(chess.square(file, rank)) and board.piece_at(chess.square(file, rank)).color == chess.BLACK))\n    return float(open_files_white - open_files_black)", "def feature(board: chess.Board) -> float:\n    \"Measures the total number of pieces attacking the opponent's king.\"\n    king_square = None\n    for square in board.piece_map():\n        if board.piece_at(square).piece_type == chess.KING and board.piece_at(square).color == (chess.WHITE if board.turn else chess.BLACK):\n            king_square = square\n            break\n    if king_square is None:\n        return 0.0\n    attackers = board.attackers(chess.BLACK if board.turn else chess.WHITE, king_square)\n    return float(len(attackers))", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of pieces placed on the back rank of the opponent.\"\n    opponent_back_rank = 0\n    if board.turn:\n        opponent_back_rank = 7\n    else:\n        opponent_back_rank = 0\n    back_rank_pieces = sum(1 for square in range(opponent_back_rank * 8, opponent_back_rank * 8 + 8) if board.piece_at(square) is not None)\n    return float(back_rank_pieces)", "def feature(board: chess.Board) -> float:\n    \"Measures the mobility of pieces by counting the total available squares for each side.\"\n    total_mobility = len(list(board.legal_moves))\n    return float(total_mobility)", "def feature(board: chess.Board) -> float:\n    \"Computes the number of pieces each side has that are unprotected.\"\n    unprotected = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == board.turn and not board.attackers(piece.color, square):\n            unprotected += 1\n    return float(unprotected)", "def feature(board: chess.Board) -> float:\n    \"Measures the distance from the opposing king for all pieces of the player to move.\"\n    total_distance = 0\n    opposing_king_square = None\n    for square in board.piece_map():\n        if board.piece_at(square).piece_type == chess.KING and board.piece_at(square).color != board.turn:\n            opposing_king_square = square\n            break\n    if opposing_king_square is None:\n        return 0.0\n    for square in board.piece_map():\n        if board.piece_at(square).color == board.turn:\n            total_distance += chess.square_distance(square, opposing_king_square)\n    return float(total_distance)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces controlling central squares (d4, d5, e4, e5).\"\n    central_squares = [chess.parse_square('d4'), chess.parse_square('d5'), chess.parse_square('e4'), chess.parse_square('e5')]\n    control_count = sum(1 for square in central_squares if board.is_attacked_by(board.turn, square))\n    return float(control_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the total number of pieces for both sides that could be attacked next move.\"\n    attackable_count = 0\n    for square in board.piece_map():\n        if board.is_attacked_by(chess.WHITE if board.turn else chess.BLACK, square):\n            attackable_count += 1\n    return float(attackable_count)", "def feature(board: chess.Board) -> float:\n    \"Assesses the average rank or file of the player's pieces, indicating board presence.\"\n    total_rank = 0\n    piece_count = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == board.turn:\n            total_rank += chess.square_rank(square)\n            piece_count += 1\n    return float(total_rank / piece_count) if piece_count > 0 else 0.0", "def feature(board: chess.Board) -> float:\n    \"Measures the number of squares where the player's king is attacked.\"\n    king_square = None\n    for square in board.piece_map():\n        if board.piece_at(square).piece_type == chess.KING and board.piece_at(square).color == board.turn:\n            king_square = square\n            break\n    if king_square is None:\n        return 0.0\n    return float(len([sq for sq in board.attackers(chess.WHITE if board.turn else chess.BLACK, king_square)]))", "def feature(board: chess.Board) -> float:\n    \"Measures the total value of pieces that are in danger (attacked by opponent)\"\n    endangered_value = 0\n    for square, piece in board.piece_map().items():\n        if board.is_attacked_by(not piece.color, square):\n            endangered_value += piece.piece_type\n    return float(endangered_value)", "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in piece activity for each color based on controlled squares\"\n    white_control = sum(board.is_attacked_by(chess.WHITE, sq) for sq in board.piece_map())\n    black_control = sum(board.is_attacked_by(chess.BLACK, sq) for sq in board.piece_map())\n    return float(white_control - black_control)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pawns both sides have on the 4th and 5th ranks\"\n    white_pawns = sum(1 for sq in board.pieces(chess.PAWN, chess.WHITE) if chess.square_rank(sq) in (3, 4))\n    black_pawns = sum(1 for sq in board.pieces(chess.PAWN, chess.BLACK) if chess.square_rank(sq) in (3, 4))\n    return float(white_pawns - black_pawns)", "def feature(board: chess.Board) -> float:\n    \"Measures the mobility advantage by comparing the number of legal moves for both players\"\n    white_moves = len(list(board.legal_moves)) if board.turn else 0\n    black_moves = len(list(board.legal_moves)) if not board.turn else 0\n    return float(white_moves - black_moves)", "def feature(board: chess.Board) -> float:\n    \"Assesses the strength of bishops on the board based on their control of squares\"\n    bishop_score = 0\n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.BISHOP:\n            bishop_score += len(board.attackers(not piece.color, square))\n    return float(bishop_score)", "def feature(board: chess.Board) -> float:\n    \"Assesses the presence of rooks on open files (files without pawns for both sides)\"\n    open_file_score = 0\n    for file in range(8):\n        if not any(board.piece_at(chess.square(file, rank)) for rank in range(8)):\n            open_file_score += 1\n    return float(open_file_score)", "def feature(board: chess.Board) -> float:\n    \"Evaluates the material balance based on the number of pieces of each type present\"\n    material_balance = sum(piece.piece_type for piece in board.piece_map().values())\n    return float(material_balance)", "def feature(board: chess.Board) -> float:\n    \"Measures the distance of kings from the center of the board (squares e4 and e5)\"\n    white_king = board.king(chess.WHITE)\n    black_king = board.king(chess.BLACK)\n    distance_white = chess.square_distance(white_king, chess.parse_square('e4'))\n    distance_black = chess.square_distance(black_king, chess.parse_square('e5'))\n    return float(distance_white - distance_black)", "def feature(board: chess.Board) -> float:\n    \"Counts the bishops each player has on opposite colored squares as a strength indicator\"\n    white_bishops = sum(1 for sq in board.pieces(chess.BISHOP, chess.WHITE) if (chess.square_file(sq) + chess.square_rank(sq)) % 2 == 0)\n    black_bishops = sum(1 for sq in board.pieces(chess.BISHOP, chess.BLACK) if (chess.square_file(sq) + chess.square_rank(sq)) % 2 == 0)\n    return float(white_bishops - black_bishops)", "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in opponent's checking pieces and the king's escaping squares\"\n    checks = len([sq for sq in board.attackers(not board.turn, board.king(board.turn))])\n    escape_squares = len([sq for sq in board.legal_moves if board.is_attacked_by(not board.turn, sq.to_square)])\n    return float(checks - escape_squares)", "def feature(board: chess.Board) -> float:\n    \"Measure the difference in piece value for pieces in the opponent's territory.\"\n    opponent_color = chess.BLACK if board.turn else chess.WHITE\n    value = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == opponent_color and chess.square_rank(square) >= 4:\n            value += piece.piece_type\n    return float(value)", "def feature(board: chess.Board) -> float:\n    \"Calculate the total number of pawns advanced past their starting rank.\"\n    white_pawns_advanced = sum(1 for square in board.piece_map() \n                                if board.piece_at(square).color == chess.WHITE and chess.square_rank(square) > 1)\n    black_pawns_advanced = sum(1 for square in board.piece_map() \n                                if board.piece_at(square).color == chess.BLACK and chess.square_rank(square) < 6)\n    return float(white_pawns_advanced + black_pawns_advanced)", "def feature(board: chess.Board) -> float:\n    \"Count the number of pieces attacking the opponent's king.\"\n    opponent_king_square = [square for square, piece in board.piece_map().items() \n                            if piece.piece_type == chess.KING and piece.color != board.turn][0]\n    attackers = board.attackers(board.turn, opponent_king_square)\n    return float(len(attackers))", "def feature(board: chess.Board) -> float:\n    \"Evaluate the total central control with a focus on pawns.\"\n    central_squares = [chess.D4, chess.D5, chess.E4, chess.E5]\n    control_score = sum(1 for square in central_squares if board.piece_at(square) and \n                        board.piece_at(square).color == board.turn)\n    return float(control_score)", "def feature(board: chess.Board) -> float:\n    \"Calculate the difference in the number of pieces between players.\"\n    white_piece_count = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE)\n    black_piece_count = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK)\n    return float(white_piece_count - black_piece_count)", "def feature(board: chess.Board) -> float:\n    \"Count the number of opponent's pieces pinned or attacked by the player's pieces.\"\n    pinned_count = sum(1 for square in board.piece_map() \n                       if board.is_attacked_by(board.turn, square) and \n                       any(board.is_attacked_by(board.turn, pin_square) for pin_square in board.attackers(board.turn, square)))\n    return float(pinned_count)", "def feature(board: chess.Board) -> float:\n    \"Measures the total value of pieces that are on the back rank.\"\n    back_rank_value = 0\n    for file in range(8):\n        piece = board.piece_at(chess.square(file, 0 if board.turn == chess.WHITE else 7))\n        if piece is not None:\n            back_rank_value += piece.piece_type\n    return float(back_rank_value)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces in the opponent's territory (ranks 5-8 for White, ranks 0-3 for Black).\"\n    opponent_territory_count = 0\n    for square in board.piece_map():\n        if (board.turn == chess.WHITE and chess.square_rank(square) >= 5) or \\\n           (board.turn == chess.BLACK and chess.square_rank(square) <= 3):\n            opponent_territory_count += 1\n    return float(opponent_territory_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the average distance of all pieces from the opponent's king.\"\n    opponent_king_square = next(square for square, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color != board.turn)\n    total_distance = sum(chess.square_distance(square, opponent_king_square) for square in board.piece_map())\n    piece_count = len(board.piece_map())\n    return float(total_distance / piece_count) if piece_count > 0 else 0.0", "def feature(board: chess.Board) -> float:\n    \"Measures the number of squares defended by at least two friendly pieces.\"\n    defended_squares = set()\n    for square in range(64):\n        if board.is_attacked_by(board.turn, square):\n            continue\n        defending_pieces = board.attackers(board.turn, square)\n        if len(defending_pieces) >= 2:\n            defended_squares.add(square)\n    return float(len(defended_squares))", "def feature(board: chess.Board) -> float:\n    \"Counts the number of hanging pieces (undefended by any pieces).\"\n    hanging_count = 0\n    for square, piece in board.piece_map().items():\n        if len(board.attackers(piece.color, square)) == 0:\n            hanging_count += 1\n    return float(hanging_count)", "def feature(board: chess.Board) -> float:\n    \"Evaluates the number of pieces occupying the center squares (d4, d5, e4, e5).\"\n    center_squares = [chess.D4, chess.D5, chess.E4, chess.E5]\n    center_piece_count = sum(1 for square in center_squares if board.piece_at(square) is not None)\n    return float(center_piece_count)", "def feature(board: chess.Board) -> float:\n    \"Measures the mobility of the player to move by counting their legal moves.\"\n    return float(len(list(board.legal_moves)))", "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in pawn structure by counting doubled pawns.\"\n    doubled_pawns = 0\n    pawn_files = {}\n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.PAWN:\n            file = chess.square_file(square)\n            if file in pawn_files:\n                pawn_files[file] += 1\n            else:\n                pawn_files[file] = 1\n    doubled_pawns = sum(count - 1 for count in pawn_files.values() if count > 1)\n    return float(doubled_pawns)", "def feature(board: chess.Board) -> float:\n    \"Scores the effectiveness of pawn structure by calculating connected pawns.\"\n    connected_pawns = 0\n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.PAWN:\n            rank = chess.square_rank(square)\n            file = chess.square_file(square)\n            if board.piece_at(chess.square(file - 1, rank)) == piece or \\\n               board.piece_at(chess.square(file + 1, rank)) == piece:\n                connected_pawns += 1\n    return float(connected_pawns)", "def feature(board: chess.Board) -> float:\n    \"Calculates the total number of pieces that are attacking the opponent's king.\"\n    opponent_king_square = next(square for square, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color != board.turn)\n    attacking_pieces_count = len(board.attackers(board.turn, opponent_king_square))\n    return float(attacking_pieces_count)", "def feature(board: chess.Board) -> float:\n    \"Evaluate king safety based on the number of attackers within one square distance.\"\n    king_square = next((sq for sq, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color == board.turn), None)\n    if king_square is None:\n        return 0.0\n    attackers = sum(1 for square in chess.SQUARES if board.is_attacked_by(not board.turn, square) and chess.square_distance(square, king_square) == 1)\n    return float(attackers)", "def feature(board: chess.Board) -> float:\n    \"Measure the relative central control by counting pieces in the center squares.\"\n    center_squares = [chess.E4, chess.E5, chess.D4, chess.D5]\n    control_count = sum(1 for sq in center_squares if board.piece_at(sq) and board.piece_at(sq).color == board.turn)\n    return float(control_count)", "def feature(board: chess.Board) -> float:\n    \"Calculate the distance of the kings from each other.\"\n    kings = [square for square in board.piece_map() if board.piece_map()[square].piece_type == chess.KING]\n    if len(kings) != 2:\n        return float('nan')\n    distance = chess.square_distance(kings[0], kings[1])\n    return float(distance)", "def feature(board: chess.Board) -> float:\n    \"Count the number of key squares controlled by the pawns.\"\n    pawn_controlled_squares = {chess.E4, chess.E5, chess.D4, chess.D5}\n    control_count = sum(1 for pawn in [piece for piece in board.piece_map().values() if piece.piece_type == chess.PAWN] for sq in pawn_controlled_squares if board.is_attacked_by(pawn.color, sq))\n    return float(control_count)", "def feature(board: chess.Board) -> float:\n    \"Evaluate the number of squares currently occupied by pieces versus empty squares.\"\n    occupied_count = len(board.piece_map())\n    empty_count = 64 - occupied_count\n    return float(occupied_count - empty_count)", "def feature(board: chess.Board) -> float:\n    \"Measure the amount of space (controlled squares) available for the current player.\"\n    controlled_squares = len(list(board.legal_moves))\n    return float(controlled_squares)", "def feature(board: chess.Board) -> float:\n    \"Calculate the total number of attack threats against each king.\"\n    white_king_attacks = len(board.attackers(chess.WHITE, chess.parse_square('e1')))\n    black_king_attacks = len(board.attackers(chess.BLACK, chess.parse_square('e8')))\n    return float(white_king_attacks + black_king_attacks)", "def feature(board: chess.Board) -> float:\n    \"Measures the total number of pawns on the board.\"\n    pawns = sum(1 for piece in board.piece_map().values() if piece.piece_type == chess.PAWN)\n    return float(pawns)", "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in the number of pieces between both players.\"\n    white_pieces = len([piece for piece in board.piece_map().values() if piece.color == chess.WHITE])\n    black_pieces = len([piece for piece in board.piece_map().values() if piece.color == chess.BLACK])\n    return float(white_pieces - black_pieces)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces threatened by opponent's pieces.\"\n    threats = sum(1 for square in board.piece_map() if board.is_attacked_by(chess.BLACK, square) if board.piece_at(square).color == chess.WHITE) + \\\n               sum(1 for square in board.piece_map() if board.is_attacked_by(chess.WHITE, square) if board.piece_at(square).color == chess.BLACK)\n    return float(threats)", "def feature(board: chess.Board) -> float:\n    \"Measures the central control by counting pieces on central squares (d4, d5, e4, e5).\"\n    central_squares = [chess.parse_square(sq) for sq in ['d4', 'd5', 'e4', 'e5']]\n    control = sum(1 for sq in central_squares if board.piece_at(sq) is not None)\n    return float(control)", "def feature(board: chess.Board) -> float:\n    \"Calculates the distance of both kings from the center of the board.\"\n    white_king = board.king(chess.WHITE)\n    black_king = board.king(chess.BLACK)\n    white_distance = chess.square_distance(white_king, chess.parse_square('e4'))\n    black_distance = chess.square_distance(black_king, chess.parse_square('e4'))\n    return float(black_distance - white_distance)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of undefended pieces for both colors.\"\n    undefended = sum(1 for square, piece in board.piece_map().items() if board.attackers(piece.color, square) == set())\n    return float(undefended)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of pieces with no legal moves.\"\n    no_move_pieces = sum(1 for piece in board.piece_map().values() if len(list(board.legal_moves)) == 0)\n    return float(no_move_pieces)", "def feature(board: chess.Board) -> float:\n    \"Scores the connectedness of pawns (number of pawns that are connected).\"\n    pawn_connections = 0\n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.PAWN:\n            if (board.piece_at(square + 1) == piece) or (board.piece_at(square - 1) == piece):\n                pawn_connections += 1\n    return float(pawn_connections)", "def feature(board: chess.Board) -> float:\n    \"Calculates the material advantage by summing the piece values for both players.\"\n    piece_values = {\n        chess.PAWN: 100,\n        chess.KNIGHT: 300,\n        chess.BISHOP: 300,\n        chess.ROOK: 500,\n        chess.QUEEN: 900,\n        chess.KING: 0  # king's value is not counted\n    }\n    \n    white_value = sum(piece_values[piece.piece_type] for piece in board.piece_map().values() if piece.color == chess.WHITE)\n    black_value = sum(piece_values[piece.piece_type] for piece in board.piece_map().values() if piece.color == chess.BLACK)\n    \n    return float(white_value - black_value)", "def feature(board: chess.Board) -> float:\n    \"Measures the distance of each king to the center of the board, indicating safety.\"\n    white_king = next((square for square, piece in board.piece_map().items() if piece.color == chess.WHITE and piece.piece_type == chess.KING), None)\n    black_king = next((square for square, piece in board.piece_map().items() if piece.color == chess.BLACK and piece.piece_type == chess.KING), None)\n    \n    if white_king is None or black_king is None:\n        return 0.0\n\n    white_distance = chess.square_distance(white_king, chess.E4)\n    black_distance = chess.square_distance(black_king, chess.E5)\n    \n    return float(black_distance - white_distance)", "def feature(board: chess.Board) -> float:\n    \"Calculates the center control score based on the number of pieces in the central squares.\"\n    central_squares = [chess.D4, chess.D5, chess.E4, chess.E5]\n    center_control = sum(1 for square in central_squares if board.piece_at(square) is not None)\n    \n    return float(center_control)", "def feature(board: chess.Board) -> float:\n    \"Measures the total number of threats each player has against the opponent's king.\"\n    white_threats = sum(1 for move in board.legal_moves if board.piece_at(move.from_square).color == chess.WHITE and move.to_square in board.attackers(chess.BLACK, chess.KING))\n    black_threats = sum(1 for move in board.legal_moves if board.piece_at(move.from_square).color == chess.BLACK and move.to_square in board.attackers(chess.WHITE, chess.KING))\n    \n    return float(white_threats - black_threats)", "def feature(board: chess.Board) -> float:\n    \"Measures the difference in total value of pieces between both sides.\"\n    white_value = sum(piece.piece_type for piece in board.piece_map().values() if piece.color == chess.WHITE)\n    black_value = sum(piece.piece_type for piece in board.piece_map().values() if piece.color == chess.BLACK)\n    return float(white_value - black_value)", "def feature(board: chess.Board) -> float:\n    \"Calculates the ratio of legal moves available to each player.\"\n    white_legal_moves = len(list(board.legal_moves)) if board.turn else 0\n    black_legal_moves = len(list(board.legal_moves)) if not board.turn else 0\n    return float(white_legal_moves / (black_legal_moves + 1))  # Avoid division by zero", "def feature(board: chess.Board) -> float:\n    \"Scores the total number of pieces attacking the opponent's king.\"\n    opponent_king_square = next(square for square, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color != board.turn)\n    total_attacks = len(board.attackers(board.turn, opponent_king_square))\n    return float(total_attacks)", "def feature(board: chess.Board) -> float:\n    \"Measures the potential mobility advantage of the player with fewer pieces on the board.\"\n    total_pieces = len(board.piece_map())\n    mobility = len(list(board.legal_moves))\n    return float((total_pieces + 1) / (mobility + 1))  # Avoid division by zero", "def feature(board: chess.Board) -> float:\n    \"Calculates the average distance of all pieces from their respective kings.\"\n    total_distance = 0\n    pieces_count = 0\n    kings_positions = [square for square, piece in board.piece_map().items() if piece.piece_type == chess.KING]\n    for square, piece in board.piece_map().items():\n        if piece.piece_type != chess.KING:\n            total_distance += chess.square_distance(square, kings_positions[piece.color])\n            pieces_count += 1\n    return float(total_distance / (pieces_count + 1))  # Avoid division by zero", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces that are directly controlling the center squares.\"\n    center_squares = [chess.D4, chess.D5, chess.E4, chess.E5]\n    control_count = sum(1 for square, piece in board.piece_map().items() if square in center_squares)\n    return float(control_count)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of pawn structures with connected pawns.\"\n    connected_pawns = 0\n    for file in range(8):\n        file_pawns = [rank for rank in range(8) if board.piece_at(chess.square(file, rank)) == chess.PAWN]\n        if len(file_pawns) > 1:\n            connected_pawns += 1\n    return float(connected_pawns)", "def feature(board: chess.Board) -> float:\n    \"Evaluates the presence of backward pawns and their potential impact on the position.\"\n    backward_pawns = 0\n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.PAWN:\n            if piece.color == chess.WHITE and (board.piece_at(square + 8) is None and board.piece_at(square + 8) is not None):\n                backward_pawns += 1\n            if piece.color == chess.BLACK and (board.piece_at(square - 8) is None and board.piece_at(square - 8) is not None):\n                backward_pawns += 1\n    return float(backward_pawns)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of squares controlled by the player.\"\n    controlled_squares = set()\n    for square, piece in board.piece_map().items():\n        if piece.color == board.turn:\n            controlled_squares.update(board.attackers(board.turn, square))\n    return float(len(controlled_squares))", "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in the number of pawns between both players.\"\n    white_pawns = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE and piece.piece_type == chess.PAWN)\n    black_pawns = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK and piece.piece_type == chess.PAWN)\n    return float(white_pawns - black_pawns)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces currently attacking the opponent's king.\"\n    opponent_king_position = next(square for square, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color != board.turn)\n    attacking_pieces = sum(1 for move in board.legal_moves if move.to_square == opponent_king_position)\n    return float(attacking_pieces)", "def feature(board: chess.Board) -> float:\n    \"Measures the proximity of pieces to the center of the board.\"\n    center_squares = [chess.E4, chess.E5, chess.D4, chess.D5]\n    piece_centers = sum(1 for square, piece in board.piece_map().items() if piece.color == board.turn and square in center_squares)\n    return float(piece_centers)", "def feature(board: chess.Board) -> float:\n    \"Calculates the total number of double attacks (two pieces attacking the same opponent piece).\"\n    double_attacks = 0\n    for square, piece in board.piece_map().items():\n        if piece.color != board.turn:\n            attackers = board.attackers(board.turn, square)\n            if len(attackers) > 1:\n                double_attacks += 1\n    return float(double_attacks)", "def feature(board: chess.Board) -> float:\n    \"Calculates the total number of squares attacked by the current player's pieces.\"\n    attacked_squares = set()\n    for square, piece in board.piece_map().items():\n        if piece.color == board.turn:\n            attacked_squares.update(board.attacks(square))\n    return float(len(attacked_squares))", "def feature(board: chess.Board) -> float:\n    \"Measures the average distance of pieces to the opponent's back rank.\"\n    opponent_back_rank = 7 if board.turn == chess.WHITE else 0\n    total_distance = sum(chess.square_distance(square, opponent_back_rank * 8 + file) for square, piece in board.piece_map().items() if piece.color == board.turn for file in range(8))\n    piece_count = sum(1 for piece in board.piece_map().values() if piece.color == board.turn)\n    return total_distance / (piece_count if piece_count > 0 else 1)", "def feature(board: chess.Board) -> float:\n    \"Calculates the total number of pieces that can potentially be a target for a capture next turn.\"\n    targetable_pieces = sum(1 for square, piece in board.piece_map().items() if piece.color != board.turn and board.is_attacked_by(board.turn, square))\n    return float(targetable_pieces)", "def feature(board: chess.Board) -> float:\n    \"Measures the numerical value of pieces on the board, assigning weights for different pieces.\"\n    piece_values = {chess.PAWN: 100, chess.KNIGHT: 320, chess.BISHOP: 330, chess.ROOK: 500, chess.QUEEN: 900, chess.KING: 10000}\n    total_value = sum(piece_values[piece.piece_type] for piece in board.piece_map().values() if piece.color == board.turn)\n    return float(total_value)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of major pieces (rook and queen) remaining for both players.\"\n    major_piece_count = sum(1 for piece in board.piece_map().values() if piece.color == board.turn and piece.piece_type in (chess.ROOK, chess.QUEEN))\n    return float(major_piece_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in piece values between the two players.\"\n    piece_value = {chess.PAWN: 100, chess.KNIGHT: 300, chess.BISHOP: 300, \n                   chess.ROOK: 500, chess.QUEEN: 900, chess.KING: 0}\n    white_value = sum(piece_value[piece.piece_type] for piece in board.piece_map().values() if piece.color == chess.WHITE)\n    black_value = sum(piece_value[piece.piece_type] for piece in board.piece_map().values() if piece.color == chess.BLACK)\n    return float(white_value - black_value)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of pawn majorities on each side.\"\n    white_pawns = sum(1 for square in board.piece_map() if board.piece_at(square).piece_type == chess.PAWN and board.piece_at(square).color == chess.WHITE and chess.square_rank(square) > 4)\n    black_pawns = sum(1 for square in board.piece_map() if board.piece_at(square).piece_type == chess.PAWN and board.piece_at(square).color == chess.BLACK and chess.square_rank(square) < 4)\n    return float(white_pawns - black_pawns)", "def feature(board: chess.Board) -> float:\n    \"Calculates the total number of major pieces (Rooks, Queens) on the board.\"\n    major_pieces = sum(1 for piece in board.piece_map().values() if piece.piece_type in (chess.ROOK, chess.QUEEN))\n    return float(major_pieces)", "def feature(board: chess.Board) -> float:\n    \"Evaluates the position based on the king's distance from the center of the board.\"\n    white_king = next((square for square in board.piece_map() if board.piece_at(square).piece_type == chess.KING and board.piece_at(square).color == chess.WHITE), None)\n    black_king = next((square for square in board.piece_map() if board.piece_at(square).piece_type == chess.KING and board.piece_at(square).color == chess.BLACK), None)\n    center_distance = (chess.square_distance(white_king, chess.E4) + chess.square_distance(black_king, chess.E5)) / 2\n    return float(center_distance)", "def feature(board: chess.Board) -> float:\n    \"Counts the pieces that are pinned by an opponent's piece.\"\n    pinned_pieces = sum(1 for square in board.piece_map() if board.is_attacked_by(not board.turn, square) and \n                        any(board.is_attacked_by(board.turn, target) for target in board.attackers(not board.turn, square)))\n    return float(pinned_pieces)", "def feature(board: chess.Board) -> float:\n    \"Measures the potential for piece activity by counting non-pawns of the current player that can move.\"\n    active_pieces = sum(1 for square in board.piece_map() if board.piece_at(square).color == board.turn and \n                        board.piece_at(square).piece_type != chess.PAWN and any(board.piece_at(move.to_square) is None for move in board.legal_moves if move.from_square == square))\n    return float(active_pieces)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces that are controlling the center squares (d4, d5, e4, e5).\"\n    center_squares = [chess.D4, chess.D5, chess.E4, chess.E5]\n    control_count = sum(1 for square in center_squares if board.is_attacked_by(board.turn, square))\n    return float(control_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of discovered attacks the player to move has.\"\n    discovered_attacks = sum(1 for square in board.piece_map() if \n                              board.is_attacked_by(board.turn, square) and \n                              any(board.is_attacked_by(not board.turn, target) for target in board.attackers(board.turn, square)))\n    return float(discovered_attacks)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of squares where pieces can move without being attacked.\"\n    safe_moves = 0\n    for square in board.piece_map():\n        piece = board.piece_at(square)\n        if piece.color == board.turn:\n            for move in board.legal_moves:\n                if move.from_square == square:\n                    if not board.is_attacked_by(not piece.color, move.to_square):\n                        safe_moves += 1\n    return float(safe_moves)", "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in pawn structure (isolated, doubled, or connected pawns).\"\n    pawn_positions = []\n    for square in board.piece_map():\n        piece = board.piece_at(square)\n        if piece and piece.piece_type == chess.PAWN:\n            pawn_positions.append(square)\n    \n    isolated = 0\n    doubled = 0\n    connected = 0\n    for square in pawn_positions:\n        file = chess.square_file(square)\n        rank = chess.square_rank(square)\n        \n        if (rank > 0 and board.piece_at(chess.square(file, rank - 1)) is None) and (rank < 7 and board.piece_at(chess.square(file, rank + 1)) is None):\n            isolated += 1\n        if board.piece_at(square) and board.piece_at(chess.square(file, rank + 1)) == piece:\n            doubled += 1\n        if file > 0 and board.piece_at(chess.square(file - 1, rank)) == piece and file < 7 and board.piece_at(chess.square(file + 1, rank)) == piece:\n            connected += 1\n    \n    return float(isolated - (doubled * 2) + connected)", "def feature(board: chess.Board) -> float:\n    \"Measures the activity of pieces by counting the number of pieces participating in attack.\"\n    active_piece_count = sum(1 for square in board.piece_map() if board.is_attacked_by(not board.turn, square))\n    return float(active_piece_count)", "def feature(board: chess.Board) -> float:\n    \"Provides a count of pieces that are pinned.\"\n    pinned_count = 0\n    for square in board.piece_map():\n        piece = board.piece_at(square)\n        if piece.color == board.turn:\n            for target in board.legal_moves:\n                if target.from_square == square:\n                    if board.is_attacked_by(not piece.color, target.to_square):\n                        pinned_count += 1\n    return float(pinned_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the king's safety based on the number of squares around it that are attacked.\"\n    king_square = board.king(board.turn)\n    unsafe_squares = 0\n    for square in chess.SQUARES:\n        if board.is_attacked_by(not board.turn, square):\n            if chess.square_distance(king_square, square) == 1:\n                unsafe_squares += 1\n    return float(unsafe_squares)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces on the 7th rank (7th rank being strong for pawns).\"\n    strong_rank_count = sum(1 for square in board.piece_map() if chess.square_rank(square) == 6 and board.piece_at(square).color == board.turn)\n    return float(strong_rank_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of pieces vulnerable to immediate capture.\"\n    vulnerable_count = 0\n    for square in board.piece_map():\n        piece = board.piece_at(square)\n        if piece.color == board.turn:\n            if any(board.is_attacked_by(not piece.color, square) for square in board.piece_map() if board.piece_at(square)):\n                vulnerable_count += 1\n    return float(vulnerable_count)", "def feature(board: chess.Board) -> float:\n    \"Measures the distance of pieces from their respective kings.\"\n    total_distance = 0\n    king_square = board.king(board.turn)\n    for square in board.piece_map():\n        piece = board.piece_at(square)\n        if piece.color == board.turn:\n            total_distance += chess.square_distance(square, king_square)\n    return float(total_distance / max(1, len(board.piece_map())))", "def feature(board: chess.Board) -> float:\n    \"Measures the difference in the number of pawns for both players.\"\n    white_pawns = sum(1 for piece in board.piece_map().values() if piece.piece_type == chess.PAWN and piece.color == chess.WHITE)\n    black_pawns = sum(1 for piece in board.piece_map().values() if piece.piece_type == chess.PAWN and piece.color == chess.BLACK)\n    return float(white_pawns - black_pawns)", "def feature(board: chess.Board) -> float:\n    \"Counts the total number of pieces for each player not yet moved from their starting position.\"\n    starting_positions = {\n        chess.PAWN: [chess.A2, chess.B2, chess.C2, chess.D2, chess.E2, chess.F2, chess.G2, chess.H2],\n        chess.ROOK: [chess.A1, chess.H1],\n        chess.KNIGHT: [chess.B1, chess.G1],\n        chess.BISHOP: [chess.C1, chess.F1],\n        chess.QUEEN: [chess.D1],\n        chess.KING: [chess.E1]\n    }\n    unmoveds = 0\n    for piece_type, squares in starting_positions.items():\n        for square in squares:\n            if board.piece_at(square) is not None and board.piece_at(square).piece_type == piece_type:\n                unmoveds += 1\n    return float(unmoveds)", "def feature(board: chess.Board) -> float:\n    \"Calculates the total number of squares under attack by each player's pieces.\"\n    white_attack = sum(1 for move in board.legal_moves if board.turn == chess.WHITE and board.is_attacked_by(chess.WHITE, move.to_square))\n    black_attack = sum(1 for move in board.legal_moves if board.turn == chess.BLACK and board.is_attacked_by(chess.BLACK, move.to_square))\n    return float(white_attack - black_attack)", "def feature(board: chess.Board) -> float:\n    \"Calculates the average distance of all pieces from their opponent's pawns.\"\n    total_distance = 0\n    pieces_count = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == board.turn:\n            for pawn_sq in [sq for sq in board.piece_map() if board.piece_map()[sq].piece_type == chess.PAWN and board.piece_map()[sq].color != board.turn]:\n                total_distance += chess.square_distance(square, pawn_sq)\n                pieces_count += 1\n    return float(total_distance / pieces_count) if pieces_count > 0 else 0.0", "def feature(board: chess.Board) -> float:\n    \"Measures the number of diagonal pieces (Bishops and Queens) attacking the opponent's king.\"\n    attacking_diagonal = 0\n    opponent_king_square = None\n    \n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.KING and piece.color != board.turn:\n            opponent_king_square = square\n            break\n    \n    for square, piece in board.piece_map().items():\n        if piece.color == board.turn and piece.piece_type in (chess.BISHOP, chess.QUEEN):\n            if board.is_attacked_by(piece.color, opponent_king_square):\n                attacking_diagonal += 1\n                \n    return float(attacking_diagonal)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces that could be pinned by the opponent's pieces.\"\n    pinned_count = 0\n    for square in board.piece_map():\n        piece = board.piece_at(square)\n        if piece and piece.color == board.turn:\n            for opponent_square in board.piece_map():\n                opponent_piece = board.piece_at(opponent_square)\n                if opponent_piece and opponent_piece.color != piece.color:\n                    # Check if the piece can attack the current square\n                    if board.is_attacked_by(opponent_piece.color, square):\n                        # Check if the piece could be pinned\n                        if board.is_attacked_by(piece.color, opponent_square):\n                            pinned_count += 1\n                            break\n    return float(pinned_count)", "def feature(board: chess.Board) -> float:\n    \"Measures the overall central control by counting pieces in central squares (d4, d5, e4, e5).\"\n    central_squares = [chess.parse_square(square) for square in ['d4', 'd5', 'e4', 'e5']]\n    control_count = sum(1 for square in central_squares if board.piece_at(square) is not None and board.piece_at(square).color == board.turn)\n    return float(control_count)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of discovered attacks available for the current player's pieces.\"\n    discovered_attacks = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == board.turn:\n            for move in board.legal_moves:\n                if move.from_square == square:\n                    if board.is_attacked_by(piece.color, move.to_square):\n                        discovered_attacks += 1\n                    \n    return float(discovered_attacks)", "def feature(board: chess.Board) -> float:\n    \"Calculates the total value of all remaining pieces on the board.\"\n    value_map = {chess.PAWN: 100, chess.KNIGHT: 320, chess.BISHOP: 330, \n                  chess.ROOK: 500, chess.QUEEN: 900, chess.KING: 20000}\n    total_value = sum(value_map[piece.piece_type] for piece in board.piece_map().values())\n    return float(total_value)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of potential discovered checks available for the current player.\"\n    check_count = 0\n    for move in board.legal_moves:\n        board.push(move)\n        if board.is_check():\n            check_count += 1\n        board.pop()\n    return float(check_count)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of piece types on the board for the current player.\"\n    piece_types = set()\n    for piece in board.piece_map().values():\n        if piece.color == board.turn:\n            piece_types.add(piece.piece_type)\n    return float(len(piece_types))", "def feature(board: chess.Board) -> float:\n    \"Measures the average distance of the opponent's pieces from the player's king.\"\n    king_square = next(square for square, piece in board.piece_map().items() \n                       if piece.color == board.turn and piece.piece_type == chess.KING)\n    distances = [chess.square_distance(king_square, square) for square, piece in board.piece_map().items() \n                 if piece.color != board.turn]\n    return float(sum(distances) / len(distances)) if distances else 0.0", "def feature(board: chess.Board) -> float:\n    \"Calculates the value of the pieces near the opponent's king.\"\n    opponent_king_square = next(square for square, piece in board.piece_map().items() \n                                 if piece.color != board.turn and piece.piece_type == chess.KING)\n    value_map = {chess.PAWN: 100, chess.KNIGHT: 320, chess.BISHOP: 330, \n                  chess.ROOK: 500, chess.QUEEN: 900}\n    nearby_value = sum(value_map.get(board.piece_at(square).piece_type, 0) \n                       for square in chess.SQUARES if chess.square_distance(opponent_king_square, square) == 1 \n                       and board.piece_at(square) is not None and board.piece_at(square).color == board.turn)\n    return float(nearby_value)", "def feature(board: chess.Board) -> float:\n    \"Calculates the material imbalance based on piece types.\"\n    piece_count_diff = sum(1 if piece.color == board.turn else -1 \n                            for piece in board.piece_map().values() \n                            if piece.piece_type in {chess.PAWN, chess.KNIGHT, chess.BISHOP, chess.ROOK, chess.QUEEN})\n    return float(piece_count_diff)", "def feature(board: chess.Board) -> float:\n    \"Measures the potential threats posed by pieces attacking the opponent's pieces.\"\n    threat_count = 0\n    for square, piece in board.piece_map().items():\n        if piece.color != board.turn and board.is_attacked_by(board.turn, square):\n            threat_count += 1\n    return float(threat_count)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of pawns for each side that are on the 7th rank (potential promotion).\"\n    white_pawns_on_7th = sum(1 for square in chess.SQUARES if board.piece_at(square) and \n                              board.piece_at(square).piece_type == chess.PAWN and \n                              board.piece_at(square).color == chess.WHITE and chess.square_rank(square) == 6)\n    black_pawns_on_7th = sum(1 for square in chess.SQUARES if board.piece_at(square) and \n                              board.piece_at(square).piece_type == chess.PAWN and \n                              board.piece_at(square).color == chess.BLACK and chess.square_rank(square) == 1)\n    return float(white_pawns_on_7th - black_pawns_on_7th)", "def feature(board: chess.Board) -> float:\n    \"Calculates the ratio of attacking pieces to defending pieces for the current player.\"\n    attackers = sum(1 for square in board.piece_map() if board.is_attacked_by(board.turn, square))\n    defenders = sum(1 for square in board.piece_map() if board.piece_at(square).color == board.turn and board.attackers(not board.turn, square))\n    return float(attackers - defenders)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of squares that are under threat from the opponent's pieces.\"\n    threatened_squares = set()\n    for square in board.piece_map():\n        if board.piece_at(square).color != board.turn:\n            threatened_squares.update(board.attackers(board.turn, square))\n    return float(len(threatened_squares))", "def feature(board: chess.Board) -> float:\n    \"Measures the number of open files for rooks for the current player's pieces.\"\n    open_files = 0\n    for file in range(8):\n        if all(board.piece_at(chess.parse_square(f'{chr(file + 97)}{rank + 1}')) is None for rank in range(8) if board.piece_at(chess.parse_square(f'{chr(file + 97)}{rank + 1}'))):\n            open_files += 1\n    return float(open_files)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of pieces that are attacking the opponent's king.\"\n    king_square = next(square for square, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color != board.turn)\n    attacking_pieces = sum(1 for square in board.piece_map() if board.is_attacked_by(board.turn, king_square))\n    return float(attacking_pieces)", "def feature(board: chess.Board) -> float:\n    \"Measures the average distance of pieces from the center of the board for the current player.\"\n    total_distance = 0\n    piece_count = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == board.turn:\n            total_distance += chess.square_distance(square, chess.parse_square('e4'))  # Center square for white, adjust for black as needed\n            piece_count += 1\n    return float(total_distance / piece_count) if piece_count > 0 else 0.0", "def feature(board: chess.Board) -> float:\n    \"Counts how many pieces of the opponent are on the back rank.\"\n    back_rank_attacks = sum(1 for square in range(8) if board.piece_at(chess.parse_square(f'a{1 if board.turn == chess.WHITE else 8}')) and board.piece_at(chess.parse_square(f'a{1 if board.turn == chess.WHITE else 8}')).color != board.turn)\n    return float(back_rank_attacks)", "def feature(board: chess.Board) -> float:\n    \"Measures the king's safety based on the number of pieces around it.\"\n    king_square = next(square for square, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color == board.turn)\n    safe_neighbor_count = sum(1 for square in board.attackers(not board.turn, king_square) if board.piece_at(square) is not None)\n    return float(safe_neighbor_count)", "def feature(board: chess.Board) -> float:\n    \"Measures the threat level posed to the opponent's pieces by the current player's pieces.\"\n    threat_level = 0\n    for square in board.piece_map():\n        if board.piece_at(square).color == board.turn:\n            for move in board.legal_moves:\n                if move.from_square == square:\n                    threatened_piece = board.piece_at(move.to_square)\n                    if threatened_piece and threatened_piece.color != board.turn:\n                        threat_level += 1\n    return float(threat_level)", "def feature(board: chess.Board) -> float:\n    'Measures the total mobility of the player to move by counting all their legal moves.'\n    return float(len(list(board.legal_moves)))", "def feature(board: chess.Board) -> float:\n    'Counts the number of pieces that are forked by the opponent\u2019s pieces.'\n    forked_count = 0\n    for square in board.piece_map():\n        piece = board.piece_at(square)\n        if piece.color == board.turn:\n            attackers = board.attackers(not piece.color, square)\n            if len(attackers) > 1:\n                forked_count += 1\n    return float(forked_count)", "def feature(board: chess.Board) -> float:\n    'Calculates the number of pawns on the 7th rank for both players, which indicates advancement.'\n    white_pawns_7th = sum(1 for sq in range(chess.A7, chess.H7 + 1) if board.piece_at(sq) == chess.PAWN)\n    black_pawns_7th = sum(1 for sq in range(chess.A2, chess.H2 + 1) if board.piece_at(sq) == chess.PAWN)\n    return float(white_pawns_7th - black_pawns_7th)", "def feature(board: chess.Board) -> float:\n    'Measures the number of squares attacked by the current player\u2019s pieces.'\n    attacked_squares = set()\n    for square in board.piece_map():\n        piece = board.piece_at(square)\n        if piece.color == board.turn:\n            for move in board.legal_moves:\n                if move.from_square == square:\n                    attacked_squares.add(move.to_square)\n    return float(len(attacked_squares))", "def feature(board: chess.Board) -> float:\n    'Counts the defending pieces for each major piece type for the player to move.'\n    defending_count = sum(1 for square in board.piece_map() if board.piece_at(square).color == board.turn and board.piece_at(square).piece_type >= chess.ROOK)\n    return float(defending_count)", "def feature(board: chess.Board) -> float:\n    'Calculates the average distance of the pieces from the opponent\u2019s king to measure piece activity.'\n    opponent_king_square = next(square for square in board.piece_map() if board.piece_at(square).piece_type == chess.KING and board.piece_at(square).color != board.turn)\n    total_distance = sum(chess.square_distance(square, opponent_king_square) for square in board.piece_map() if board.piece_at(square).color == board.turn)\n    piece_count = len([square for square in board.piece_map() if board.piece_at(square).color == board.turn])\n    return total_distance / piece_count if piece_count > 0 else 0.0", "def feature(board: chess.Board) -> float:\n    'Measures the number of checks the current player can deliver next move.'\n    check_count = 0\n    for move in board.legal_moves:\n        # Simulate the move\n        board.push(move)\n        if board.is_check():\n            check_count += 1\n        board.pop()\n    return float(check_count)", "def feature(board: chess.Board) -> float:\n    'Counts the number of squares controlled by the opponent\u2019s pieces around the player to move.'\n    controlled_by_opponent = set()\n    for square in board.piece_map():\n        piece = board.piece_at(square)\n        if piece.color != board.turn:\n            controlled_moves = board.legal_moves\n            controlled_by_opponent.update(chess.square_name(move.to_square) for move in controlled_moves if move.from_square == square)\n    return float(len(controlled_by_opponent))", "def feature(board: chess.Board) -> float:\n    'Calculates the ratio of major pieces (rooks and queens) to minor pieces (knights and bishops) for the player to move.'\n    major_count = sum(1 for sq in board.piece_map() if board.piece_at(sq).color == board.turn and board.piece_at(sq).piece_type in {chess.ROOK, chess.QUEEN})\n    minor_count = sum(1 for sq in board.piece_map() if board.piece_at(sq).color == board.turn and board.piece_at(sq).piece_type in {chess.KNIGHT, chess.BISHOP})\n    return major_count / (minor_count + 1)  # Avoid division by zero by adding 1 to minor_count", "def feature(board: chess.Board) -> float:\n    \"Measures the total value of the opponent's pieces that are attacked by the current player's pieces.\"\n    attacker_value = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == (chess.WHITE if board.turn else chess.BLACK):\n            for target in board.attackers(not piece.color, square):\n                target_piece = board.piece_at(target)\n                if target_piece:\n                    attacker_value += target_piece.piece_type\n    return float(attacker_value)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of isolated pawns on the board for both players.\"\n    isolated_pawns = 0\n    for file in range(8):\n        if (board.piece_at(chess.square(file, 1)) == chess.PAWN and\n            (board.piece_at(chess.square(file - 1, 1)) is None and board.piece_at(chess.square(file + 1, 1)) is None)) or \\\n           (board.piece_at(chess.square(file, 6)) == chess.PAWN and\n            (board.piece_at(chess.square(file - 1, 6)) is None and board.piece_at(chess.square(file + 1, 6)) is None)):\n            isolated_pawns += 1\n    return float(isolated_pawns)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of squares where a king is potentially checked by a rook or queen.\"\n    check_squares = 0\n    for square in chess.SQUARES:\n        if board.piece_at(square) and board.piece_at(square).piece_type in (chess.ROOK, chess.QUEEN):\n            for target in board.attackers(chess.WHITE if board.turn else chess.BLACK, square):\n                if board.is_attacked_by(chess.WHITE if board.turn else chess.BLACK, target):\n                    check_squares += 1\n    return float(check_squares)", "def feature(board: chess.Board) -> float:\n    \"Measures the distance of the pieces from the opponent's back rank on both sides.\"\n    white_distance = 0\n    black_distance = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == chess.WHITE:\n            white_distance += (7 - chess.square_rank(square))\n        else:\n            black_distance += chess.square_rank(square)\n    return float(white_distance - black_distance)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of potential pins on the board by evaluating the diagonal and straight-line pieces.\"\n    pin_count = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == (chess.WHITE if board.turn else chess.BLACK):\n            for target in board.attackers(not piece.color, square):\n                if (board.piece_at(target) and\n                    board.piece_at(target).piece_type in (chess.BISHOP, chess.ROOK, chess.QUEEN)):\n                    pin_count += 1\n    return float(pin_count)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of pieces in open files/columns for both players.\"\n    open_files = 0\n    for file in range(8):\n        if (all(board.piece_at(chess.square(file, rank)) is None for rank in range(8))):\n            open_files += 1\n    return float(open_files)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces that can move to the same square as an enemy piece in the next move.\"\n    threat_count = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == (chess.WHITE if board.turn else chess.BLACK):\n            for move in board.legal_moves:\n                if move.to_square == square:\n                    threat_count += 1\n    return float(threat_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the mobility score based on the available moves of pieces on the board.\"\n    mobility_score = len(list(board.legal_moves))\n    return float(mobility_score)", "def feature(board: chess.Board) -> float:\n    \"Evaluates how many pieces are safe and not under threat from the opponent.\"\n    safe_count = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == (chess.WHITE if board.turn else chess.BLACK) and not board.is_attacked_by(not piece.color, square):\n            safe_count += 1\n    return float(safe_count)", "def feature(board: chess.Board) -> float:\n    \"Measures the difference in total number of pieces on the board.\"\n    total_pieces_white = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE)\n    total_pieces_black = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK)\n    return float(total_pieces_white - total_pieces_black)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces that are attacking a king.\"\n    attacking_pieces = sum(1 for square in board.piece_map() if board.is_attacked_by(chess.WHITE, square) and board.piece_at(square).piece_type == chess.KING)\n    attacking_pieces += sum(1 for square in board.piece_map() if board.is_attacked_by(chess.BLACK, square) and board.piece_at(square).piece_type == chess.KING)\n    return float(attacking_pieces)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of pieces occupying the back rank for each player.\"\n    back_rank_white = sum(1 for square in range(56, 64) if board.piece_at(square) and board.piece_at(square).color == chess.WHITE)\n    back_rank_black = sum(1 for square in range(0, 8) if board.piece_at(square) and board.piece_at(square).color == chess.BLACK)\n    return float(back_rank_white - back_rank_black)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces developed (not on the back rank).\"\n    developed_pieces = sum(1 for square, piece in board.piece_map().items() \n                           if piece.color == board.turn and chess.square_rank(square) > 1)\n    return float(developed_pieces)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of pawns on the 6th rank for each player.\"\n    pawns_on_sixth_rank = sum(1 for square in board.piece_map() \n                               if board.piece_at(square).piece_type == chess.PAWN and chess.square_rank(square) == 5)\n    return float(pawns_on_sixth_rank)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces attacking the same square.\"\n    attacked_squares = {}\n    for move in board.legal_moves:\n        attacked_squares[move.to_square] = attacked_squares.get(move.to_square, 0) + 1\n    \n    return float(sum(1 for count in attacked_squares.values() if count > 1))", "def feature(board: chess.Board) -> float:\n    \"Measures the number of legal moves that involve the king of the current player.\"\n    king_square = next((square for square, piece in board.piece_map().items() \n                         if piece.color == board.turn and piece.piece_type == chess.KING), None)\n    king_moves = sum(1 for move in board.legal_moves if move.from_square == king_square)\n    return float(king_moves)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of potential forks for the current player.\"\n    forks = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == board.turn and (piece.piece_type == chess.KNIGHT or piece.piece_type == chess.QUEEN):\n            target_squares = {move.to_square for move in board.legal_moves if move.from_square == square}\n            for target in target_squares:\n                attackers = sum(1 for attacking_square in board.attackers(not board.turn, target))\n                if attackers >= 2:\n                    forks += 1\n    return float(forks)", "def feature(board: chess.Board) -> float:\n    \"Calculates the material value of pieces on the board.\"\n    piece_values = {chess.PAWN: 100, chess.KNIGHT: 320, chess.BISHOP: 330, \n                    chess.ROOK: 500, chess.QUEEN: 900, chess.KING: 0}\n    total_value = 0.0\n    for piece in board.piece_map().values():\n        value = piece_values[piece.piece_type]\n        total_value += value if piece.color == chess.WHITE else -value\n    return total_value", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of isolated pawns.\"\n    isolated_pawns = 0\n    for square in board.piece_map():\n        piece = board.piece_at(square)\n        if piece and piece.piece_type == chess.PAWN:\n            if (board.piece_at(square - 1) is None and\n                board.piece_at(square + 1) is None):\n                isolated_pawns += 1\n    return float(isolated_pawns)", "def feature(board: chess.Board) -> float:\n    \"Counts the mobility advantage by comparing legal moves.\"\n    white_moves = len(list(board.legal_moves) if board.turn else [])\n    black_moves = len(list(board.legal_moves) if not board.turn else [])\n    return float(white_moves - black_moves)", "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in number of pieces on the board.\"\n    white_piece_count = len([piece for piece in board.piece_map().values() if piece.color == chess.WHITE])\n    black_piece_count = len([piece for piece in board.piece_map().values() if piece.color == chess.BLACK])\n    return float(white_piece_count - black_piece_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the total number of pawns on the board for both players.\"\n    total_pawns = sum(1 for piece in board.piece_map().values() if piece.piece_type == chess.PAWN)\n    return float(total_pawns)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of squares that have multiple attackers from the current player's perspective.\"\n    controlled_squares = set()\n    for square in range(64):\n        if board.is_attacked_by(board.turn, square):\n            attackers = board.attackers(board.turn, square)\n            if len(attackers) > 1:\n                controlled_squares.add(square)\n    return float(len(controlled_squares))", "def feature(board: chess.Board) -> float:\n    \"Measures the distance of the king to the center of the board.\"\n    king_square = board.king(chess.WHITE) if board.turn else board.king(chess.BLACK)\n    center_squares = [chess.D4, chess.D5, chess.E4, chess.E5]\n    distances = [chess.square_distance(king_square, sq) for sq in center_squares]\n    return float(sum(distances))", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces that are pinned against the king.\"\n    pinned_pieces = 0\n    king_square = board.king(chess.WHITE) if board.turn else board.king(chess.BLACK)\n    for square, piece in board.piece_map().items():\n        if piece.color == board.turn and any(board.is_attacked_by(not board.turn, sq) for sq in board.attackers(board.turn, square)):\n            if board.is_attacked_by(not board.turn, king_square):\n                pinned_pieces += 1\n    return float(pinned_pieces)", "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in control over the center squares (D4, D5, E4, E5).\"\n    center_squares = [chess.D4, chess.D5, chess.E4, chess.E5]\n    control = {chess.WHITE: 0, chess.BLACK: 0}\n    for square in center_squares:\n        if board.is_attacked_by(chess.WHITE, square):\n            control[chess.WHITE] += 1\n        if board.is_attacked_by(chess.BLACK, square):\n            control[chess.BLACK] += 1\n    return float(control[chess.WHITE] - control[chess.BLACK])", "def feature(board: chess.Board) -> float:\n    \"Counts the number of free pawns (pawns without adjacent opponents).\"\n    free_pawns = 0\n    for square in range(64):\n        piece = board.piece_at(square)\n        if piece and piece.piece_type == chess.PAWN and piece.color == board.turn:\n            file = chess.square_file(square)\n            if (file > 0 and board.piece_at(square - 1) and board.piece_at(square - 1).color == piece.color) or \\\n               (file < 7 and board.piece_at(square + 1) and board.piece_at(square + 1).color == piece.color):\n                continue\n            free_pawns += 1\n    return float(free_pawns)", "def feature(board: chess.Board) -> float:\n    \"Measures the imbalance due to the number of active pieces (pieces on ranks 5-7) each side has.\"\n    active_pieces = {chess.WHITE: 0, chess.BLACK: 0}\n    for square, piece in board.piece_map().items():\n        rank = chess.square_rank(square)\n        if piece.color == chess.WHITE and 5 <= rank <= 7:\n            active_pieces[chess.WHITE] += 1\n        if piece.color == chess.BLACK and 5 <= rank <= 7:\n            active_pieces[chess.BLACK] += 1\n    return float(active_pieces[chess.WHITE] - active_pieces[chess.BLACK])", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of pairs of pieces that can attack each other.\"\n    attacking_pairs = 0\n    for square_from, piece_from in board.piece_map().items():\n        for square_to, piece_to in board.piece_map().items():\n            if piece_from.color != piece_to.color and board.is_attacked_by(piece_from.color, square_to):\n                attacking_pairs += 1\n    return float(attacking_pairs)", "def feature(board: chess.Board) -> float:\n    \"Measures the distance of all pieces to their respective end ranks.\"\n    total_distance = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == chess.WHITE:\n            total_distance += (7 - chess.square_rank(square))\n        else:\n            total_distance += (chess.square_rank(square))\n    return float(total_distance)", "def feature(board: chess.Board) -> float:\n    \"Measures the distance of all pieces from their starting positions.\"\n    distance_sum = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == board.turn:\n            distance_sum += chess.square_distance(square, piece.piece_type)\n    return float(distance_sum)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pawns that have advanced past the 4th rank.\"\n    pawns = [piece for piece in board.piece_map().values() if piece.piece_type == chess.PAWN and piece.color == board.turn]\n    advanced_pawns = sum(1 for square in board.piece_map() if board.piece_at(square) in pawns and chess.square_rank(square) > 3)\n    return float(advanced_pawns)", "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in control of the center squares (d4, e4, d5, e5).\"\n    center_control = 0\n    center_squares = [chess.parse_square('d4'), chess.parse_square('e4'), chess.parse_square('d5'), chess.parse_square('e5')]\n    for square in center_squares:\n        if board.is_attacked_by(chess.WHITE, square):\n            center_control += 1\n        if board.is_attacked_by(chess.BLACK, square):\n            center_control -= 1\n    return float(center_control)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces that can attack the opponent's king.\"\n    attacking_pieces = sum(1 for move in board.legal_moves if board.piece_at(move.from_square).color == board.turn and move.to_square == board.king(not board.turn))\n    return float(attacking_pieces)", "def feature(board: chess.Board) -> float:\n    \"Calculates the average piece mobility for each player.\"\n    mobility_white = sum(1 for move in board.legal_moves if board.piece_at(move.from_square) and board.piece_at(move.from_square).color == chess.WHITE)\n    mobility_black = sum(1 for move in board.legal_moves if board.piece_at(move.from_square) and board.piece_at(move.from_square).color == chess.BLACK)\n    return float(mobility_white - mobility_black)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pawns on the 7th rank.\"\n    pawns_on_seventh = sum(1 for square, piece in board.piece_map().items() if piece.piece_type == chess.PAWN and chess.square_rank(square) == 6)\n    return float(pawns_on_seventh)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of pieces trapped (unable to move).\"\n    trapped_count = sum(1 for square, piece in board.piece_map().items() if len(list(board.legal_moves)) == 0 and piece.color == board.turn)\n    return float(trapped_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of squares attacked by each player's pieces.\"\n    white_attacked = sum(1 for square in chess.SquareSet(chess.BB_ALL) if board.is_attacked_by(chess.WHITE, square))\n    black_attacked = sum(1 for square in chess.SquareSet(chess.BB_ALL) if board.is_attacked_by(chess.BLACK, square))\n    return float(white_attacked - black_attacked)", "def feature(board: chess.Board) -> float:\n    \"Measures the distance of the opposing king from the center of the board.\"\n    opposing_king_square = board.king(not board.turn)\n    distance_to_center = chess.square_distance(opposing_king_square, chess.parse_square('e4')) + chess.square_distance(opposing_king_square, chess.parse_square('d4'))\n    return float(8 - distance_to_center)  # Closer to center = higher value", "def feature(board: chess.Board) -> float:\n    \"Measures the total value of pieces for the current player.\"\n    total_value = 0\n    piece_value = {chess.PAWN: 100, chess.KNIGHT: 300, chess.BISHOP: 300, chess.ROOK: 500, chess.QUEEN: 900, chess.KING: 0}\n    for piece in board.piece_map().values():\n        if piece.color == board.turn:\n            total_value += piece_value[piece.piece_type]\n    return float(total_value)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of pinned pieces for the current player.\"\n    pinned_count = 0\n    for square in board.piece_map():\n        piece = board.piece_at(square)\n        if piece and piece.color == board.turn:\n            for attacker in board.attackers(not board.turn, square):\n                if board.is_attacked_by(not board.turn, square) and board.is_attacked_by(piece.color, square):\n                    pinned_count += 1\n                    break\n    return float(pinned_count)", "def feature(board: chess.Board) -> float:\n    \"Measures the distance of the current player's pieces to the opponent's king.\"\n    king_square = next(square for square in board.piece_map() if board.piece_at(square).piece_type == chess.KING and \n                       board.piece_at(square).color != board.turn)\n    distances = []\n    for square in board.piece_map():\n        piece = board.piece_at(square)\n        if piece and piece.color == board.turn:\n            distance = chess.square_distance(square, king_square)\n            distances.append(distance)\n    return float(sum(distances) / len(distances)) if distances else 0.0", "def feature(board: chess.Board) -> float:\n    \"Counts the number of potential threats towards the opponent's king.\"\n    threats = 0\n    king_square = next(square for square in board.piece_map() if board.piece_at(square).piece_type == chess.KING and \n                       board.piece_at(square).color != board.turn)\n    for move in board.legal_moves:\n        if move.to_square == king_square and board.piece_at(move.from_square) is not None:\n            threats += 1\n    return float(threats)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of pieces currently on the board.\"\n    piece_count = len(board.piece_map())\n    return float(piece_count)", "def feature(board: chess.Board) -> float:\n    \"Evaluates the number of central squares controlled by the current player.\"\n    central_squares = {chess.D4, chess.D5, chess.E4, chess.E5}\n    controlled_squares = 0\n    for square in central_squares:\n        if board.is_attacked_by(board.turn, square):\n            controlled_squares += 1\n    return float(controlled_squares)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of squares the current player has mobility on.\"\n    mobility_count = 0\n    for move in board.legal_moves:\n        mobility_count += 1\n    return float(mobility_count)", "def feature(board: chess.Board) -> float:\n    \"Measures the distance of the current player's king from the center of the board.\"\n    king_square = next(square for square in board.piece_map() if board.piece_at(square).piece_type == chess.KING and \n                       board.piece_at(square).color == board.turn)\n    center_squares = {chess.D4, chess.D5, chess.E4, chess.E5}\n    distances = [chess.square_distance(king_square, square) for square in center_squares]\n    return float(min(distances)) if distances else 0.0", "def feature(board: chess.Board) -> float:\n    \"Measures the number of pieces each player has on the back rank.\"\n    back_rank_count = {chess.WHITE: 0, chess.BLACK: 0}\n    for file in range(8):\n        for color in (chess.WHITE, chess.BLACK):\n            square = chess.square(file, 0 if color == chess.WHITE else 7)\n            if board.piece_at(square) is not None and board.piece_at(square).color == color:\n                back_rank_count[color] += 1\n    return float(back_rank_count[board.turn]) - float(back_rank_count[not board.turn])", "def feature(board: chess.Board) -> float:\n    \"Calculates the ratio of material on the board based on the number of pawns.\"\n    pawn_count = sum(1 for piece in board.piece_map().values() if piece.piece_type == chess.PAWN and piece.color == board.turn)\n    total_pieces = len(board.piece_map())\n    return float(pawn_count) / float(total_pieces) if total_pieces > 0 else 0.0", "def feature(board: chess.Board) -> float:\n    \"Measures the number of pieces in the opponent's half of the board.\"\n    opponent_half_count = 0\n    for square, piece in board.piece_map().items():\n        if piece.color != board.turn and chess.square_rank(square) > 3:\n            opponent_half_count += 1\n    return float(opponent_half_count)", "def feature(board: chess.Board) -> float:\n    \"Counts the total number of threats to the opponent's king.\"\n    threat_count = 0\n    opponent_king_square = None\n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.KING and piece.color != board.turn:\n            opponent_king_square = square\n            break\n    if opponent_king_square:\n        for square in board.legal_moves:\n            if board.is_attacked_by(board.turn, opponent_king_square):\n                threat_count += 1\n    return float(threat_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the average distance of pieces from the opponent's back rank.\"\n    total_distance = 0\n    piece_count = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == board.turn:\n            total_distance += chess.square_rank(square)\n            piece_count += 1\n    return total_distance / piece_count if piece_count > 0 else 0.0", "def feature(board: chess.Board) -> float:\n    \"Measures the total mobility of pieces for the current player.\"\n    mobility_count = sum(len(list(board.legal_moves)) for square, piece in board.piece_map().items() if piece.color == board.turn)\n    return float(mobility_count)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces on the opponent's 7th rank.\"\n    opponent_pieces_on_7th = sum(1 for square, piece in board.piece_map().items() if piece.color != board.turn and chess.square_rank(square) == 6)\n    return float(opponent_pieces_on_7th)", "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in controlled squares between both players.\"\n    controlled_squares_white = len([sq for sq in chess.SQUARES if board.is_attacked_by(chess.WHITE, sq)])\n    controlled_squares_black = len([sq for sq in chess.SQUARES if board.is_attacked_by(chess.BLACK, sq)])\n    return float(controlled_squares_white - controlled_squares_black)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of minor pieces (knights and bishops) on the board.\"\n    minor_piece_count = sum(1 for piece in board.piece_map().values() if piece.piece_type in (chess.KNIGHT, chess.BISHOP))\n    return float(minor_piece_count)", "def feature(board: chess.Board) -> float:\n    \"Measures the total value of all pieces on the board.\"\n    total_value = 0\n    piece_values = {\n        chess.PAWN: 100, chess.KNIGHT: 320, chess.BISHOP: 330,\n        chess.ROOK: 500, chess.QUEEN: 900, chess.KING: 0\n    }\n    for piece in board.piece_map().values():\n        total_value += piece_values[piece.piece_type] if piece.color == chess.WHITE else -piece_values[piece.piece_type]\n    return float(total_value)", "def feature(board: chess.Board) -> float:\n    \"Measures the difference in the number of pawns on the board for each player.\"\n    white_pawns = sum(1 for piece in board.piece_map().values() if piece.piece_type == chess.PAWN and piece.color == chess.WHITE)\n    black_pawns = sum(1 for piece in board.piece_map().values() if piece.piece_type == chess.PAWN and piece.color == chess.BLACK)\n    return float(white_pawns - black_pawns)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of pieces pinned against the king for the player to move.\"\n    pinned_count = 0\n    king_square = board.king(chess.WHITE if board.turn else chess.BLACK)\n    for piece_square, piece in board.piece_map().items():\n        if piece.color == (chess.WHITE if board.turn else chess.BLACK):\n            attackers = board.attackers(chess.WHITE if board.turn else chess.BLACK, piece_square)\n            if king_square in attackers:\n                pinned_count += 1\n    return float(pinned_count)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of major pieces (rooks and queens) for the player to move.\"\n    major_count = sum(1 for piece in board.piece_map().values() if piece.color == (chess.WHITE if board.turn else chess.BLACK) and piece.piece_type in [chess.ROOK, chess.QUEEN])\n    return float(major_count)", "def feature(board: chess.Board) -> float:\n    \"Measures the average distance of the player's pieces to the opponent's king.\"\n    total_distance = 0\n    piece_count = 0\n    opponent_king_square = board.king(chess.BLACK if board.turn else chess.WHITE)\n    for piece_square, piece in board.piece_map().items():\n        if piece.color == (chess.WHITE if board.turn else chess.BLACK):\n            total_distance += chess.square_distance(piece_square, opponent_king_square)\n            piece_count += 1\n    return float(total_distance / piece_count) if piece_count > 0 else 0.0", "def feature(board: chess.Board) -> float:\n    \"Calculates the mobility of pieces by counting the total legal moves for both players.\"\n    total_legal_moves = len(list(board.legal_moves))\n    return float(total_legal_moves)", "def feature(board: chess.Board) -> float:\n    \"Measures the total number of squares attacked by the pieces of the player to move.\"\n    attacked_squares = set()\n    for piece_square, piece in board.piece_map().items():\n        if piece.color == (chess.WHITE if board.turn else chess.BLACK):\n            for move in board.legal_moves:\n                if move.from_square == piece_square:\n                    attacked_squares.add(move.to_square)\n    return float(len(attacked_squares))", "def feature(board: chess.Board) -> float:\n    \"Measures the total number of pieces that are pinned by the opponent's pieces.\"\n    pinned_count = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == board.turn:  # Check pieces of the current player only\n            for attacker in board.attackers(not board.turn, square):\n                if board.piece_at(attacker).piece_type in {chess.QUEEN, chess.ROOK, chess.BISHOP}:\n                    direction = chess.square_distance(square, attacker)  # Check if it's pinned\n                    if direction in {1, 2, 3}:\n                        pinned_count += 1\n    return float(pinned_count)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of doubled pawns on the board.\"\n    pawn_count = {}\n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.PAWN:\n            file = chess.square_file(square)\n            if file not in pawn_count:\n                pawn_count[file] = 0\n            pawn_count[file] += 1\n    doubled_pawns = sum(1 for file in pawn_count if pawn_count[file] > 1)\n    return float(doubled_pawns)", "def feature(board: chess.Board) -> float:\n    \"Measures the total value of squares occupied by each player's pieces.\"\n    square_values = {chess.PAWN: 1, chess.KNIGHT: 3, chess.BISHOP: 3, chess.ROOK: 5, chess.QUEEN: 9, chess.KING: 0}\n    total_value = 0.0\n    for piece in board.piece_map().values():\n        total_value += square_values.get(piece.piece_type, 0) * (1 if piece.color == board.turn else -1)\n    return total_value", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces attacking the opponent's king.\"\n    attacking_count = len(board.attackers(not board.turn, chess.parse_square('e8' if board.turn else 'e1')))\n    return float(attacking_count)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of pieces that can be captured in the next move.\"\n    capturable_pieces = sum(1 for move in board.legal_moves if board.piece_at(move.to_square))\n    return float(capturable_pieces)", "def feature(board: chess.Board) -> float:\n    \"Calculates the average distance of pieces from the center of the board.\"\n    total_distance = 0.0\n    piece_count = 0\n    center_squares = [chess.parse_square('d4'), chess.parse_square('d5'), \n                      chess.parse_square('e4'), chess.parse_square('e5')]\n    \n    for square, piece in board.piece_map().items():\n        if piece.color == board.turn:  # Only consider current player's pieces\n            piece_count += 1\n            total_distance += min(chess.square_distance(square, center_square) for center_square in center_squares)\n    \n    return total_distance / piece_count if piece_count > 0 else 0.0", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces on each player's back rank.\"\n    back_rank_count = sum(1 for square in range(8) for piece in [board.piece_at(chess.square(square, 0 if board.turn else 7))] if piece)\n    return float(back_rank_count)", "def feature(board: chess.Board) -> float:\n    \"Measures the percentage of squares controlled by the current player's pieces.\"\n    controlled_squares = sum(1 for square in chess.SQUARES if board.is_attacked_by(board.turn, square))\n    return controlled_squares / 64.0  # Total squares on the board", "def feature(board: chess.Board) -> float:\n    \"Calculates the mobility advantage based on legal moves.\"\n    white_moves = sum(1 for move in board.legal_moves if move.from_square)\n    black_moves = sum(1 for move in board.legal_moves if move.from_square and board.piece_at(move.from_square).color == chess.BLACK)\n    mobility_advantage = white_moves - black_moves\n    return float(mobility_advantage)", "def feature(board: chess.Board) -> float:\n    \"Checks if a player has a passed pawn and counts them.\"\n    passed_pawn_count = 0\n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.PAWN and piece.color == board.turn:\n            file = chess.square_file(square)\n            if all(board.piece_at(chess.square(file, rank)) is None for rank in range((1 if piece.color == chess.WHITE else 0), (7 if piece.color == chess.WHITE else 8))):\n                passed_pawn_count += 1\n    return float(passed_pawn_count)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces that are pinned by an opponent's piece.\"\n    pinned_count = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == board.turn:\n            for attacker in board.attackers(not piece.color, square):\n                if board.is_attacked_by(piece.color, attacker):\n                    pinned_count += 1\n                    break\n    return float(pinned_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of safe squares for the current player's king.\"\n    king_square = next((sq for sq, p in board.piece_map().items() if p.piece_type == chess.KING and p.color == board.turn), None)\n    if king_square is None:\n        return 0.0\n    safe_squares = 0\n    for move in chess.SQUARES:\n        if board.is_legal(chess.Move(king_square, move)):\n            if not board.is_attacked_by(not board.turn, move):\n                safe_squares += 1\n    return float(safe_squares)", "def feature(board: chess.Board) -> float:\n    \"Evaluates the material imbalance by counting the difference between major and minor pieces.\"\n    material_value = 0\n    for piece in board.piece_map().values():\n        if piece.color == board.turn:\n            if piece.piece_type in (chess.QUEEN, chess.ROOK):\n                material_value += 5\n            elif piece.piece_type in (chess.BISHOP, chess.KNIGHT):\n                material_value += 3\n    return float(material_value)", "def feature(board: chess.Board) -> float:\n    \"Measures the total number of hanging pieces (undefended pieces) of the current player.\"\n    hanging_count = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == board.turn and not board.attackers(piece.color, square):\n            hanging_count += 1\n    return float(hanging_count)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of protected pawns for the current player.\"\n    protected_pawn_count = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == board.turn and piece.piece_type == chess.PAWN:\n            if any(board.is_attacked_by(not board.turn, attacker) for attacker in board.attackers(not board.turn, square)):\n                protected_pawn_count += 1\n    return float(protected_pawn_count)", "def feature(board: chess.Board) -> float:\n    \"Measures the distance of each player's pieces to their opponent's back rank.\"\n    total_distance = 0\n    for square, piece in board.piece_map().items():\n        distance = chess.square_rank(piece.color == chess.WHITE and square or (7 - chess.square_rank(square)))\n        total_distance += distance\n    return float(total_distance)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of open files for both players' rooks.\"\n    open_files = 0\n    for file in range(8):\n        if all(board.piece_at(chess.square(file, rank)) is None for rank in range(8)):\n            open_files += 1\n    return float(open_files)", "def feature(board: chess.Board) -> float:\n    \"Measures the development of pieces based on their proximity to the center.\"\n    centralization_score = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == board.turn:\n            centralization_score += 8 - (chess.square_file(square) + chess.square_rank(square))\n    return float(centralization_score)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces that are defended by two or more pieces.\"\n    defended_count = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == board.turn:\n            attackers = board.attackers(not piece.color, square)\n            if len(attackers) >= 2:\n                defended_count += 1\n    return float(defended_count)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of pieces in the opponent's back rank.\"\n    opponent_back_rank = 0\n    back_rank = 0 if board.turn == chess.WHITE else 7\n    for file in range(8):\n        square = chess.square(file, back_rank)\n        piece = board.piece_at(square)\n        if piece is not None and piece.color != board.turn:\n            opponent_back_rank += 1\n    return float(opponent_back_rank)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces that are unsupported by other pieces.\"\n    unsupported_count = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == board.turn:\n            attacked_squares = board.attackers(board.turn, square)\n            if not attacked_squares:\n                unsupported_count += 1\n    return float(unsupported_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in pawn structure by counting doubled pawns.\"\n    white_doubled_pawns = 0\n    black_doubled_pawns = 0\n    for file in range(8):\n        white_pawn_count = sum(1 for sq in range(8) if board.piece_at(chess.square(file, sq)) == chess.PAWN and sq in [1, 3, 5, 7])\n        black_pawn_count = sum(1 for sq in range(8) if board.piece_at(chess.square(file, sq)) == chess.PAWN and sq in [1, 3, 5, 7])\n        if white_pawn_count > 1:\n            white_doubled_pawns += white_pawn_count - 1\n        if black_pawn_count > 1:\n            black_doubled_pawns += black_pawn_count - 1\n    return float(white_doubled_pawns - black_doubled_pawns)", "def feature(board: chess.Board) -> float:\n    \"Measures the total distance of all pieces from the center of the board (d4, d5, e4, e5).\"\n    center_positions = [chess.parse_square('d4'), chess.parse_square('d5'), chess.parse_square('e4'), chess.parse_square('e5')]\n    total_distance = 0\n    for square, piece in board.piece_map().items():\n        distance = min(chess.square_distance(square, center) for center in center_positions)\n        total_distance += distance\n    return float(total_distance)", "def feature(board: chess.Board) -> float:\n    \"Calculates the ratio of pawns to the total number of pieces for the current player.\"\n    player_pawn_count = sum(1 for piece in board.piece_map().values() if piece.color == board.turn and piece.piece_type == chess.PAWN)\n    total_piece_count = sum(1 for piece in board.piece_map().values() if piece.color == board.turn)\n    return float(player_pawn_count / total_piece_count) if total_piece_count > 0 else 0.0", "def feature(board: chess.Board) -> float:\n    \"Counts the number of potential promotion squares for pawns of the current player.\"\n    promotion_squares = [chess.square(file, 7 if board.turn == chess.WHITE else 0) for file in range(8)]\n    potential_promotions = sum(1 for square in promotion_squares if board.piece_at(square) is None)\n    return float(potential_promotions)", "def feature(board: chess.Board) -> float:\n    \"Measures the king's proximity to the center of the board.\"\n    king_square = board.king(board.turn)\n    center_squares = [chess.square(3, 3), chess.square(3, 4), chess.square(4, 3), chess.square(4, 4)]\n    distance = min(chess.square_distance(king_square, center) for center in center_squares)\n    return float(distance)", "def feature(board: chess.Board) -> float:\n    \"Calculates the material imbalance based on the piece values of current player minus opponent.\"\n    piece_value = {chess.PAWN: 100, chess.KNIGHT: 320, chess.BISHOP: 330, chess.ROOK: 500, chess.QUEEN: 900, chess.KING: 0}\n    total_value = sum(piece_value[piece.piece_type] for piece in board.piece_map().values() if piece.color == board.turn)\n    opponent_value = sum(piece_value[piece.piece_type] for piece in board.piece_map().values() if piece.color != board.turn)\n    return float(total_value - opponent_value)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces that are controlling each other's squares.\"\n    controlling_count = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == board.turn:\n            controlled_squares = set()\n            for move in board.legal_moves:\n                if move.from_square == square:\n                    controlled_squares.add(move.to_square)\n            if any(board.is_attacked_by(piece.color, sq) for sq in controlled_squares):\n                controlling_count += 1\n    return float(controlling_count)", "def feature(board: chess.Board) -> float:\n    \"Measures the material value of all pieces on the board pertaining to the current player.\"\n    piece_value = {chess.PAWN: 100, chess.KNIGHT: 320, chess.BISHOP: 330, chess.ROOK: 500, chess.QUEEN: 900, chess.KING: 0}\n    total_value = sum(piece_value[piece.piece_type] for piece in board.piece_map().values() if piece.color == board.turn)\n    return float(total_value)", "def feature(board: chess.Board) -> float:\n    \"Measures the density of pieces in the center four squares of the board (d4, d5, e4, e5).\"\n    center_squares = [chess.D4, chess.D5, chess.E4, chess.E5]\n    piece_count = sum(1 for sq in center_squares if board.piece_at(sq) is not None)\n    return float(piece_count)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of squares attacked by the current player's pieces.\"\n    current_color = board.turn\n    attacked_squares = sum(1 for sq in chess.SQUARES if board.is_attacked_by(current_color, sq))\n    return float(attacked_squares)", "def feature(board: chess.Board) -> float:\n    \"Measures the distance between the current player's king and the opponent's pieces.\"\n    current_king_square = next(sq for sq, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color == board.turn)\n    opponent_pieces_squares = [sq for sq, piece in board.piece_map().items() if piece.color != board.turn]\n    distances = [chess.square_distance(current_king_square, sq) for sq in opponent_pieces_squares]\n    return float(sum(distances))", "def feature(board: chess.Board) -> float:\n    \"Evaluates the number of pieces on the back rank that can potentially move.\"\n    back_rank = 0 if board.turn == chess.WHITE else 7\n    movable_count = sum(1 for sq in range(back_rank * 8, (back_rank + 1) * 8) if board.piece_at(sq) and board.piece_at(sq).color == board.turn and board.legal_moves)\n    return float(movable_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the ratio of active pieces to total pieces for the current player.\"\n    total_pieces = len([piece for piece in board.piece_map().values() if piece.color == board.turn])\n    active_pieces = len([move for move in board.legal_moves])\n    return float(active_pieces / total_pieces) if total_pieces > 0 else 0.0", "def feature(board: chess.Board) -> float:\n    \"Calculates relative piece value based on piece positions (e.g., factors in the position contribution).\"\n    piece_values = {chess.PAWN: 100, chess.KNIGHT: 320, chess.BISHOP: 330, chess.ROOK: 500, chess.QUEEN: 900, chess.KING: 20000}\n    value = sum(piece_values[piece.piece_type] for piece in board.piece_map().values())\n    return float(value)", "def feature(board: chess.Board) -> float:\n    \"Measures the material imbalance calculated as the difference between the values of pieces on the board.\"\n    material_value = 0\n    piece_values = {chess.PAWN: 100, chess.KNIGHT: 320, chess.BISHOP: 330, chess.ROOK: 500, chess.QUEEN: 900, chess.KING: 0}\n    \n    for piece in board.piece_map().values():\n        value = piece_values[piece.piece_type]\n        if piece.color == chess.WHITE:\n            material_value += value\n        else:\n            material_value -= value\n            \n    return float(material_value)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of pieces in the central squares (d4, d5, e4, e5).\"\n    central_squares = [chess.D4, chess.D5, chess.E4, chess.E5]\n    central_piece_count = sum(1 for square in central_squares if board.piece_at(square) is not None)\n    return float(central_piece_count)", "def feature(board: chess.Board) -> float:\n    \"Measures how many pawns each side has advanced (ranks 4-7 for White, 4-2 for Black).\"\n    white_advanced = sum(1 for square in range(chess.A4, chess.H8) if board.piece_at(square) and board.piece_at(square).piece_type == chess.PAWN and board.piece_at(square).color == chess.WHITE)\n    black_advanced = sum(1 for square in range(chess.A2, chess.H5) if board.piece_at(square) and board.piece_at(square).piece_type == chess.PAWN and board.piece_at(square).color == chess.BLACK)\n    return float(white_advanced - black_advanced)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces that are currently pinned to the king.\"\n    pinned_count = 0\n    king_square = [square for square in board.piece_map() if board.piece_map()[square].piece_type == chess.KING][0]\n    \n    for piece_square, piece in board.piece_map().items():\n        if piece.color == board.turn:\n            continue\n        if board.is_attacked_by(board.turn, piece_square):\n            for attacker_square in board.attackers(board.turn, piece_square):\n                if board.is_attacked_by(piece.color, attacker_square):\n                    pinned_count += 1\n                    break\n    return float(pinned_count)", "def feature(board: chess.Board) -> float:\n    \"Measures the distance to the enemy king for all pieces of the current player.\"\n    current_player = board.turn\n    total_distance = 0\n    king_square = next(square for square in board.piece_map() if board.piece_map()[square].piece_type == chess.KING and board.piece_map()[square].color != current_player)\n    \n    for piece_square, piece in board.piece_map().items():\n        if piece.color == current_player:\n            total_distance += chess.square_distance(piece_square, king_square)\n    \n    return float(total_distance)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of double pawns for both players.\"\n    double_pawns = {chess.WHITE: 0, chess.BLACK: 0}\n    pawn_positions = [square for square in board.piece_map() if board.piece_map()[square].piece_type == chess.PAWN]\n\n    for position in pawn_positions:\n        file = chess.square_file(position)\n        if chess.square_name(position) in [chess.square_name(p) for p in pawn_positions if chess.square_file(p) == file]:\n            double_pawns[board.piece_map()[position].color] += 1\n            \n    return float(double_pawns[chess.WHITE] - double_pawns[chess.BLACK])", "def feature(board: chess.Board) -> float:\n    \"Counts the number of unprotected pieces, where a piece is unprotected if it is not defended by another piece.\"\n    unprotected_count = 0\n    \n    for piece_square, piece in board.piece_map().items():\n        if piece.color == board.turn:\n            continue\n        if not any(board.is_attacked_by(piece.color, attacker_square) for attacker_square in board.attackers(piece.color, piece_square)):\n            unprotected_count += 1\n            \n    return float(unprotected_count)", "def feature(board: chess.Board) -> float:\n    \"Measures the total number of pieces in the game.\"\n    total_pieces = len(board.piece_map())\n    return float(total_pieces)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of potential checks available by the current player's pieces.\"\n    potential_checks = 0\n    for move in board.legal_moves:\n        board.push(move)\n        if board.is_check():\n            potential_checks += 1\n        board.pop()\n    \n    return float(potential_checks)", "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in the number of pieces remaining for each player.\"\n    piece_count = {chess.WHITE: 0, chess.BLACK: 0}\n\n    for piece in board.piece_map().values():\n        piece_count[piece.color] += 1\n\n    return float(piece_count[chess.WHITE] - piece_count[chess.BLACK])", "def feature(board: chess.Board) -> float:\n    'Measures the total number of pawns present on the board.'\n    return float(len([p for p in board.piece_map().values() if p.piece_type == chess.PAWN]))", "def feature(board: chess.Board) -> float:\n    'Calculates the difference in material values of pieces currently in play for both colors.'\n    material_values = {\n        chess.PAWN: 100,\n        chess.KNIGHT: 320,\n        chess.BISHOP: 330,\n        chess.ROOK: 500,\n        chess.QUEEN: 900,\n        chess.KING: 20000,\n    }\n    white_material = sum(material_values[piece.piece_type] for piece in board.piece_map().values() if piece.color == chess.WHITE)\n    black_material = sum(material_values[piece.piece_type] for piece in board.piece_map().values() if piece.color == chess.BLACK)\n    return float(white_material - black_material)", "def feature(board: chess.Board) -> float:\n    'Counts the number of pieces in the last two ranks for both sides as an indicator of piece activity.'\n    white_pieces = sum(1 for sq in range(56, 64) if board.piece_at(sq) and board.piece_at(sq).color == chess.WHITE)\n    black_pieces = sum(1 for sq in range(0, 8) if board.piece_at(sq) and board.piece_at(sq).color == chess.BLACK)\n    return float(white_pieces - black_pieces)", "def feature(board: chess.Board) -> float:\n    'Calculates the number of attacked pieces by each color to assess risks.'\n    white_attacked = sum(1 for sq in board.piece_map() if board.is_attacked_by(chess.WHITE, sq))\n    black_attacked = sum(1 for sq in board.piece_map() if board.is_attacked_by(chess.BLACK, sq))\n    return float(white_attacked - black_attacked)", "def feature(board: chess.Board) -> float:\n    'Measures the number of squares each side has their pieces protected.'\n    white_protected = sum(1 for square in board.piece_map() if board.attackers(chess.WHITE, square) and len(board.attackers(chess.WHITE, square)) > 0)\n    black_protected = sum(1 for square in board.piece_map() if board.attackers(chess.BLACK, square) and len(board.attackers(chess.BLACK, square)) > 0)\n    return float(white_protected - black_protected)", "def feature(board: chess.Board) -> float:\n    'Measures the difference in the number of mobility squares for the kings of both colors to assess safety.'\n    white_king_square = next(square for square, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color == chess.WHITE)\n    black_king_square = next(square for square, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color == chess.BLACK)\n    white_king_mobility = sum(1 for move in chess.SQUARES if board.is_attacked_by(chess.BLACK, move) and chess.square_distance(white_king_square, move) <= 1)\n    black_king_mobility = sum(1 for move in chess.SQUARES if board.is_attacked_by(chess.WHITE, move) and chess.square_distance(black_king_square, move) <= 1)\n    return float(white_king_mobility - black_king_mobility)", "def feature(board: chess.Board) -> float:\n    'Calculates the total distance of pieces from the opposing king to quantify pressure.'\n    white_king_square = next(square for square, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color == chess.WHITE)\n    black_king_square = next(square for square, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color == chess.BLACK)\n    distance_sum = sum(chess.square_distance(square, black_king_square) for square, piece in board.piece_map().items() if piece.color == chess.WHITE)\n    return float(distance_sum)", "def feature(board: chess.Board) -> float:\n    'Counts the number of pawns that are promoting or close to promotion for both sides.'\n    white_pawn_promotions = sum(1 for sq in range(48, 56) if board.piece_at(sq) and board.piece_at(sq).piece_type == chess.PAWN and board.piece_at(sq).color == chess.WHITE)\n    black_pawn_promotions = sum(1 for sq in range(8, 16) if board.piece_at(sq) and board.piece_at(sq).piece_type == chess.PAWN and board.piece_at(sq).color == chess.BLACK)\n    return float(white_pawn_promotions - black_pawn_promotions)", "def feature(board: chess.Board) -> float:\n    'Calculates the difference in material value of the two sides.'\n    material_values = {chess.PAWN: 100, chess.KNIGHT: 320, chess.BISHOP: 330, chess.ROOK: 500, chess.QUEEN: 900, chess.KING: 20000}\n    white_value = sum(material_values[piece.piece_type] for piece in board.piece_map().values() if piece.color == chess.WHITE)\n    black_value = sum(material_values[piece.piece_type] for piece in board.piece_map().values() if piece.color == chess.BLACK)\n    return float(white_value - black_value)", "def feature(board: chess.Board) -> float:\n    'Counts the number of pieces that are pinned by the opponent.'\n    pinned_pieces = sum(1 for square in board.piece_map() if board.is_attacked_by(not board.turn, square) and any(\n        board.attackers(not board.turn, square)))\n    return float(pinned_pieces)", "def feature(board: chess.Board) -> float:\n    'Measures the number of squares under attack by the current player.'\n    attacking_squares = len(set(move.to_square for move in board.legal_moves))\n    return float(attacking_squares)", "def feature(board: chess.Board) -> float:\n    'Calculates the percentage of central control by counting pieces in central squares.'\n    central_squares = [chess.D4, chess.E4, chess.D5, chess.E5]\n    control_count = sum(1 for square in central_squares if board.piece_at(square) and board.piece_at(square).color == board.turn)\n    return float(control_count) / len(central_squares)", "def feature(board: chess.Board) -> float:\n    'Counts the number of pieces on the back rank.'\n    back_rank_pieces = sum(1 for square in range(chess.A8, chess.H8 + 1) if board.piece_at(square) and board.piece_at(square).color == (chess.BLACK if board.turn else chess.WHITE))\n    return float(back_rank_pieces)", "def feature(board: chess.Board) -> float:\n    'Measures the total distance of all pieces from the center of the board.'\n    total_distance = sum(chess.square_distance(square, chess.E4) + chess.square_distance(square, chess.D4) for square in board.piece_map())\n    return float(total_distance)", "def feature(board: chess.Board) -> float:\n    'Counts the number of squares defended by pawns.'\n    defended_squares = sum(1 for square in board.piece_map() if board.piece_at(square).piece_type == chess.PAWN and \n                             any(board.is_attacked_by(board.piece_at(square).color, dest) for dest in board.attackers(not board.piece_at(square).color, square)))\n    return float(defended_squares)", "def feature(board: chess.Board) -> float:\n    'Counts the number of pawn islands.'\n    pawns = {file: 0 for file in range(8)}\n    for square in board.piece_map():\n        if board.piece_at(square).piece_type == chess.PAWN:\n            pawns[chess.square_file(square)] += 1\n    islands = sum(1 for count in pawns.values() if count > 0)  # Count non-zero entries\n    return float(islands)", "def feature(board: chess.Board) -> float:\n    'Measures the activity of the rooks on the board.'\n    rook_activity = sum(len(list(board.legal_moves)) for square in board.piece_map() if board.piece_at(square).piece_type == chess.ROOK)\n    return float(rook_activity)", "def feature(board: chess.Board) -> float:\n    'Calculates the distance of the king to the center of the board.'\n    king_square = next(square for square in board.piece_map() if board.piece_at(square).piece_type == chess.KING and board.piece_at(square).color == board.turn)\n    distance_to_center = chess.square_distance(king_square, chess.E4) + chess.square_distance(king_square, chess.D4)\n    return float(distance_to_center)", "def feature(board: chess.Board) -> float:\n    \"Measures the relative activity of pieces on the center squares.\"\n    center_squares = [chess.E4, chess.E5, chess.D4, chess.D5]\n    white_activity = sum(1 for square in center_squares if board.piece_at(square) and board.piece_at(square).color == chess.WHITE)\n    black_activity = sum(1 for square in center_squares if board.piece_at(square) and board.piece_at(square).color == chess.BLACK)\n    return float(white_activity - black_activity)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces in the opponent's back rank.\"\n    back_rank = 0\n    for file in range(8):\n        square = chess.square(file, 0 if board.turn else 7)\n        piece = board.piece_at(square)\n        if piece and piece.color != board.turn:\n            back_rank += 1\n    return float(back_rank)", "def feature(board: chess.Board) -> float:\n    \"Evaluates the safety of the king by counting adjacent attacking pieces.\"\n    king_square = board.king(chess.WHITE if board.turn else chess.BLACK)\n    attackers = board.attackers(chess.WHITE if board.turn else chess.BLACK, king_square)\n    return float(len(attackers))", "def feature(board: chess.Board) -> float:\n    \"Measures the difference in piece distribution across the board.\"\n    piece_distribution = [0] * 8  # For each file\n    for square, piece in board.piece_map().items():\n        piece_distribution[chess.square_file(square)] += 1\n    variance = sum((x - (len(board.piece_map()) / 8)) ** 2 for x in piece_distribution) / len(piece_distribution)\n    return float(variance)", "def feature(board: chess.Board) -> float:\n    \"Computes the number of pinned pieces for the current player.\"\n    pinned_count = 0\n    for square in board.piece_map():\n        piece = board.piece_at(square)\n        if piece and piece.color == board.turn:\n            for target_square in board.legal_moves:\n                if board.is_check() or board.is_attacked_by(not board.turn, square):\n                    pinned_count += 1\n                    break\n    return float(pinned_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of potential threats towards the opponent's king.\"\n    king_square = board.king(chess.WHITE if board.turn else chess.BLACK)\n    threats = [move for move in board.legal_moves if move.to_square == king_square]\n    return float(len(threats))", "def feature(board: chess.Board) -> float:\n    \"Identifies the most valuable piece currently in jeopardy of being captured.\"\n    threatened_value = 0\n    for square in board.piece_map():\n        piece = board.piece_at(square)\n        if piece.color == board.turn and board.is_attacked_by(not board.turn, square):\n            threatened_value += piece.piece_type\n    return float(threatened_value)", "def feature(board: chess.Board) -> float:\n    \"Measures the overall board control by evaluating pieces on open files.\"\n    open_files = 0\n    for file in range(8):\n        if all(board.piece_at(chess.square(file, rank)) is None for rank in range(8)):\n            open_files += 1\n    return float(open_files)", "def feature(board: chess.Board) -> float:\n    \"Calculates the control of key squares (central and opponent's 7th rank).\"\n    control_score = 0\n    key_squares = [chess.E4, chess.E5, chess.D4, chess.D5, chess.D7, chess.E7]\n    for square in key_squares:\n        if board.is_attacked_by(board.turn, square):\n            control_score += 1\n        if board.is_attacked_by(not board.turn, square):\n            control_score -= 1\n    return float(control_score)", "def feature(board: chess.Board) -> float:\n    \"Measures the difference in the number of pawns for both players.\"\n    white_pawns = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE and piece.piece_type == chess.PAWN)\n    black_pawns = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK and piece.piece_type == chess.PAWN)\n    return float(white_pawns - black_pawns)", "def feature(board: chess.Board) -> float:\n    \"Calculates how many pieces are currently pinned.\"\n    pinned_pieces = sum(1 for square, piece in board.piece_map().items() if piece.color == board.turn and board.is_attacked_by(not piece.color, square))\n    return float(pinned_pieces)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces attacking each king.\"\n    white_king_square = next(square for square, piece in board.piece_map().items() if piece.color == chess.WHITE and piece.piece_type == chess.KING)\n    black_king_square = next(square for square, piece in board.piece_map().items() if piece.color == chess.BLACK and piece.piece_type == chess.KING)\n    white_attacks = len(board.attackers(chess.BLACK, white_king_square))\n    black_attacks = len(board.attackers(chess.WHITE, black_king_square))\n    return float(white_attacks - black_attacks)", "def feature(board: chess.Board) -> float:\n    \"Calculates the average rank of all pieces for each player.\"\n    white_rank_sum = sum(chess.square_rank(square) for square, piece in board.piece_map().items() if piece.color == chess.WHITE)\n    black_rank_sum = sum(chess.square_rank(square) for square, piece in board.piece_map().items() if piece.color == chess.BLACK)\n    white_piece_count = len([1 for piece in board.piece_map().values() if piece.color == chess.WHITE])\n    black_piece_count = len([1 for piece in board.piece_map().values() if piece.color == chess.BLACK])\n    \n    average_white_rank = white_rank_sum / white_piece_count if white_piece_count > 0 else 0.0\n    average_black_rank = black_rank_sum / black_piece_count if black_piece_count > 0 else 0.0\n    return float(average_white_rank - average_black_rank)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of major pieces (rooks and queens) on the board.\"\n    major_piece_count = sum(1 for piece in board.piece_map().values() if piece.piece_type in [chess.ROOK, chess.QUEEN])\n    return float(major_piece_count)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of squares attacked by each player.\"\n    white_attacked_squares = len(set(move.to_square for move in board.legal_moves if move.from_square in board.attackers(chess.WHITE, move.to_square)))\n    black_attacked_squares = len(set(move.to_square for move in board.legal_moves if move.from_square in board.attackers(chess.BLACK, move.to_square)))\n    return float(white_attacked_squares - black_attacked_squares)", "def feature(board: chess.Board) -> float:\n    \"Calculates the center control by counting pieces on central squares.\"\n    central_squares = [chess.D4, chess.D5, chess.E4, chess.E5]\n    control_count = sum(1 for square in central_squares if board.piece_at(square) is not None)\n    return float(control_count)", "def feature(board: chess.Board) -> float:\n    \"Computes the mobility of the currently active player by counting legal moves.\"\n    mobility = len(list(board.legal_moves))\n    return float(mobility)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of unprotected pieces on the board.\"\n    unprotected_count = sum(1 for square, piece in board.piece_map().items() if piece.color == board.turn and not board.is_attacked_by(not piece.color, square))\n    return float(unprotected_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in bishop control based on the color of the squares they occupy.\"\n    white_bishops = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE and piece.piece_type == chess.BISHOP)\n    black_bishops = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK and piece.piece_type == chess.BISHOP)\n    return float(white_bishops - black_bishops)", "def feature(board: chess.Board) -> float:\n    \"Measures the position value based on the number of pawn chains present.\"\n    pawn_chains = 0\n    for file in range(8):\n        chain = 0\n        for rank in range(8):\n            square = chess.square(file, rank)\n            if board.piece_at(square) and board.piece_at(square).piece_type == chess.PAWN:\n                chain += 1\n            else:\n                if chain > 0:\n                    pawn_chains += 1\n                chain = 0\n        if chain > 0:\n            pawn_chains += 1\n    return float(pawn_chains)", "def feature(board: chess.Board) -> float:\n    \"Calculates the mobility difference between the two players.\"\n    white_moves = sum(1 for _ in board.legal_moves if board.turn)\n    black_moves = sum(1 for _ in board.legal_moves if not board.turn)\n    mobility_difference = white_moves - black_moves\n    return float(mobility_difference)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces on the back rank for both players.\"\n    back_rank_white = sum(1 for file in range(8) if board.piece_at(chess.square(file, 7)) and board.piece_at(chess.square(file, 7)).color == chess.WHITE)\n    back_rank_black = sum(1 for file in range(8) if board.piece_at(chess.square(file, 0)) and board.piece_at(chess.square(file, 0)).color == chess.BLACK)\n    return float(back_rank_white - back_rank_black)", "def feature(board: chess.Board) -> float:\n    \"Calculates how many pieces are pinned by the opponent's pieces.\"\n    pinned_count = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == board.turn:\n            for attacker in board.attackers(not board.turn, square):\n                if board.piece_at(attacker).piece_type in [chess.QUEEN, chess.ROOK, chess.BISHOP]:\n                    pinned_count += 1\n                    break\n    return float(pinned_count)", "def feature(board: chess.Board) -> float:\n    \"Evaluates the central control based on the number of pieces in the central squares.\"\n    central_squares = [chess.E4, chess.E5, chess.D4, chess.D5]\n    control_count = sum(1 for square in central_squares if board.piece_at(square) and board.piece_at(square).color == board.turn)\n    return float(control_count)", "def feature(board: chess.Board) -> float:\n    \"Measures the distance of all pieces to the opponent's king.\"\n    opponent_king_square = next(square for square in board.piece_map() if board.piece_map()[square].piece_type == chess.KING and board.piece_map()[square].color != board.turn)\n    total_distance = sum(chess.square_distance(square, opponent_king_square) for square in board.piece_map() if board.piece_map()[square].color == board.turn)\n    return float(total_distance)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of undefended pieces for the current player.\"\n    undefended_count = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == board.turn and not board.attackers(not board.turn, square):\n            undefended_count += 1\n    return float(undefended_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in development between minor pieces (knights and bishops).\"\n    white_development = sum(1 for square, piece in board.piece_map().items() if piece.color == chess.WHITE and piece.piece_type in [chess.KNIGHT, chess.BISHOP] and chess.square_rank(square) >= 3)\n    black_development = sum(1 for square, piece in board.piece_map().items() if piece.color == chess.BLACK and piece.piece_type in [chess.KNIGHT, chess.BISHOP] and chess.square_rank(square) <= 4)\n    return float(white_development - black_development)", "def feature(board: chess.Board) -> float:\n    \"Measures the total number of isolated pawns.\"\n    isolated_pawns = 0\n    for file in range(8):\n        has_pawn = any(board.piece_at(chess.square(file, rank)) and board.piece_at(chess.square(file, rank)).piece_type == chess.PAWN for rank in range(8))\n        if has_pawn:\n            left_ok = file == 0 or not any(board.piece_at(chess.square(file - 1, rank)) and board.piece_at(chess.square(file - 1, rank)).piece_type == chess.PAWN for rank in range(8))\n            right_ok = file == 7 or not any(board.piece_at(chess.square(file + 1, rank)) and board.piece_at(chess.square(file + 1, rank)).piece_type == chess.PAWN for rank in range(8))\n            if left_ok and right_ok:\n                isolated_pawns += 1\n    return float(isolated_pawns)", "def feature(board: chess.Board) -> float:\n    \"Calculates the control of the center squares (d4, d5, e4, e5) by both players.\"\n    center_squares = [chess.D4, chess.D5, chess.E4, chess.E5]\n    control_white = sum(1 for sq in center_squares if board.is_attacked_by(chess.WHITE, sq))\n    control_black = sum(1 for sq in center_squares if board.is_attacked_by(chess.BLACK, sq))\n    return float(control_white - control_black)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces that are on their starting squares, indicating underdevelopment.\"\n    starting_positions_white = {chess.A1, chess.B1, chess.C1, chess.D1, chess.E1, chess.F1, chess.G1, chess.H1}\n    starting_positions_black = {chess.A8, chess.B8, chess.C8, chess.D8, chess.E8, chess.F8, chess.G8, chess.H8}\n    undeveloped_white = sum(1 for sq in starting_positions_white if board.piece_at(sq) is not None)\n    undeveloped_black = sum(1 for sq in starting_positions_black if board.piece_at(sq) is not None)\n    return float(undeveloped_white + undeveloped_black)", "def feature(board: chess.Board) -> float:\n    \"Measures the total number of pieces that are pinned to the king.\"\n    pinned_pieces = 0\n    for square in board.piece_map():\n        piece = board.piece_at(square)\n        if piece and ((piece.color == chess.WHITE and board.is_attacked_by(chess.BLACK, square)) or\n                      (piece.color == chess.BLACK and board.is_attacked_by(chess.WHITE, square))):\n            if board.is_attacked_by(piece.color, board.king(piece.color)):\n                pinned_pieces += 1\n    return float(pinned_pieces)", "def feature(board: chess.Board) -> float:\n    \"Evaluates the number of doubled pawns for each color.\"\n    def count_doubled_pawns(color):\n        pawn_files = {}\n        for square in board.piece_map():\n            piece = board.piece_at(square)\n            if piece and piece.color == color and piece.piece_type == chess.PAWN:\n                file_index = chess.square_file(square)\n                if file_index in pawn_files:\n                    pawn_files[file_index] += 1\n                else:\n                    pawn_files[file_index] = 1\n        return sum(1 for count in pawn_files.values() if count > 1)\n\n    doubled_white = count_doubled_pawns(chess.WHITE)\n    doubled_black = count_doubled_pawns(chess.BLACK)\n    return float(doubled_white + doubled_black)", "def feature(board: chess.Board) -> float:\n    \"Calculates the distance of the nearest enemy's pawn to each king.\"\n    white_king_square = board.king(chess.WHITE)\n    black_king_square = board.king(chess.BLACK)\n    white_distance = min((chess.square_distance(white_king_square, pawn) for pawn in board.piece_map() if board.piece_at(pawn).color == chess.BLACK and board.piece_at(pawn).piece_type == chess.PAWN), default=8)\n    black_distance = min((chess.square_distance(black_king_square, pawn) for pawn in board.piece_map() if board.piece_at(pawn).color == chess.WHITE and board.piece_at(pawn).piece_type == chess.PAWN), default=8)\n    return float(white_distance - black_distance)", "def feature(board: chess.Board) -> float:\n    \"Calculates the ratio of non-pawn pieces to total pieces on the board.\"\n    total_pieces = len(board.piece_map())\n    non_pawn_pieces = sum(1 for piece in board.piece_map().values() if piece.piece_type != chess.PAWN)\n    return float(non_pawn_pieces / total_pieces) if total_pieces > 0 else 0.0", "def feature(board: chess.Board) -> float:\n    \"Counts the number of checks being delivered by both players.\"\n    check_count = sum(1 for move in board.legal_moves if board.gives_check(move))\n    return float(check_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in piece activity based on squares attacked.\"\n    white_attacks = sum(1 for sq in board.piece_map() if board.piece_at(sq).color == chess.WHITE and board.is_attacked_by(chess.WHITE, sq))\n    black_attacks = sum(1 for sq in board.piece_map() if board.piece_at(sq).color == chess.BLACK and board.is_attacked_by(chess.BLACK, sq))\n    return float(white_attacks - black_attacks)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of squares occupied by other pieces in the back rank for each side.\"\n    white_back_rank = [chess.A1, chess.B1, chess.C1, chess.D1, chess.E1, chess.F1, chess.G1, chess.H1]\n    black_back_rank = [chess.A8, chess.B8, chess.C8, chess.D8, chess.E8, chess.F8, chess.G8, chess.H8]\n    white_blocked = sum(1 for sq in white_back_rank if board.piece_at(sq) is not None)\n    black_blocked = sum(1 for sq in black_back_rank if board.piece_at(sq) is not None)\n    return float(white_blocked - black_blocked)", "def feature(board: chess.Board) -> float:\n    \"Measures the difference in the number of pieces on the 7th and 8th ranks.\"\n    white_seventh = sum(1 for sq in board.piece_map() if board.piece_at(sq).color == chess.WHITE and chess.square_rank(sq) == 6)\n    black_seventh = sum(1 for sq in board.piece_map() if board.piece_at(sq).color == chess.BLACK and chess.square_rank(sq) == 6)\n    return float(white_seventh - black_seventh)", "def feature(board: chess.Board) -> float:\n    \"Calculates the total number of pieces in the center of the board (d4, d5, e4, e5).\"\n    center_squares = [chess.parse_square('d4'), chess.parse_square('d5'), chess.parse_square('e4'), chess.parse_square('e5')]\n    central_piece_count = sum(1 for sq in center_squares if board.piece_at(sq) is not None)\n    return float(central_piece_count)", "def feature(board: chess.Board) -> float:\n    \"Measures the total number of pawns on the board.\"\n    pawn_count = sum(1 for sq in board.piece_map() if board.piece_at(sq).piece_type == chess.PAWN)\n    return float(pawn_count)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces that are pinned and cannot move.\"\n    pinned_pieces_count = 0\n    for piece_sq, piece in board.piece_map().items():\n        if board.is_attacked_by(not piece.color, piece_sq):\n            attackers = board.attackers(not piece.color, piece_sq)\n            for attacker in attackers:\n                if board.is_attacked_by(piece.color, attacker):\n                    pinned_pieces_count += 1\n                    break\n    return float(pinned_pieces_count)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of consecutive pawns on the same file for both sides.\"\n    consecutive_pawn_count = 0\n    for file in range(8):\n        for rank in range(8):\n            if board.piece_at(chess.square(file, rank)) is not None:\n                if board.piece_at(chess.square(file, rank)).piece_type == chess.PAWN:\n                    consecutive_pawn_count += 1\n                    if rank < 7 and board.piece_at(chess.square(file, rank + 1)) is None:\n                        break\n    return float(consecutive_pawn_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in control of key squares in the center (d4, d5, e4, e5) by both sides.\"\n    central_squares = [chess.parse_square('d4'), chess.parse_square('d5'), chess.parse_square('e4'), chess.parse_square('e5')]\n    white_control = sum(1 for sq in central_squares if board.is_attacked_by(chess.WHITE, sq))\n    black_control = sum(1 for sq in central_squares if board.is_attacked_by(chess.BLACK, sq))\n    return float(white_control - black_control)", "def feature(board: chess.Board) -> float:\n    \"Measures the depth of the position by checking the halfmove clock.\"\n    return float(board.halfmove_clock)", "def feature(board: chess.Board) -> float:\n    'Measures the total value of pieces on the board for both players'\n    material_values = {\n        chess.PAWN: 100,\n        chess.KNIGHT: 320,\n        chess.BISHOP: 330,\n        chess.ROOK: 500,\n        chess.QUEEN: 900,\n        chess.KING: 0  # King's value is generally not counted\n    }\n    total_value = 0.0\n    for piece in board.piece_map().values():\n        total_value += material_values[piece.piece_type] if piece.color == chess.WHITE else -material_values[piece.piece_type]\n    return total_value", "def feature(board: chess.Board) -> float:\n    'Measures king safety by counting the number of attacks on the kings'\n    white_king_square = next(square for square, piece in board.piece_map().items() if piece.color == chess.WHITE and piece.piece_type == chess.KING)\n    black_king_square = next(square for square, piece in board.piece_map().items() if piece.color == chess.BLACK and piece.piece_type == chess.KING)\n    white_king_safety = len(board.attackers(chess.BLACK, white_king_square))\n    black_king_safety = len(board.attackers(chess.WHITE, black_king_square))\n    return float(black_king_safety - white_king_safety)", "def feature(board: chess.Board) -> float:\n    'Calculates the total number of pawn structure weaknesses (isolated, doubled, or backward pawns)'\n    def pawn_structure_weaknesses(color):\n        weaknesses = 0\n        pawns = [square for square, piece in board.piece_map().items() if piece.color == color and piece.piece_type == chess.PAWN]\n        for square in pawns:\n            file = chess.square_file(square)\n            rank = chess.square_rank(square)\n            if board.piece_at(chess.square(file, rank + 1)) is None and board.piece_at(chess.square(file, rank - 1)) is None:\n                weaknesses += 1  # Isolated pawn\n            if board.piece_at(chess.square(file, rank + 1)) is not None and board.piece_at(chess.square(file, rank - 1)) is not None:\n                weaknesses += 1  # Doubled pawns\n            # Check for backward pawns\n            if all(board.piece_at(chess.square(file, r)) is None for r in range(rank + 1, 8)):\n                weaknesses += 1  # Backward pawn\n        return weaknesses\n    return float(pawn_structure_weaknesses(chess.WHITE) - pawn_structure_weaknesses(chess.BLACK))", "def feature(board: chess.Board) -> float:\n    'Counts the number of squares attacked by both players to gauge control of the board'\n    attacked_squares_white = len(set(move.to_square for move in board.legal_moves if board.is_attacked_by(chess.WHITE, move.to_square)))\n    attacked_squares_black = len(set(move.to_square for move in board.legal_moves if board.is_attacked_by(chess.BLACK, move.to_square)))\n    return float(attacked_squares_white - attacked_squares_black)", "def feature(board: chess.Board) -> float:\n    'Measures the distribution of pieces across the board by calculating the variance of their ranks'\n    piece_ranks = [chess.square_rank(square) for square in board.piece_map()]\n    if not piece_ranks:\n        return 0.0\n    mean_rank = sum(piece_ranks) / len(piece_ranks)\n    variance = sum((rank - mean_rank) ** 2 for rank in piece_ranks) / len(piece_ranks)\n    return variance", "def feature(board: chess.Board) -> float:\n    'Counts the number of pieces that are pinned against the king'\n    def is_pinned(piece_square):\n        for attacker_square in board.attackers(board.color_at(piece_square), piece_square):\n            if board.is_attacked_by(board.color_at(piece_square), chess.KING):\n                return True\n        return False\n    \n    pinned_count = sum(1 for square in board.piece_map() if is_pinned(square))\n    return float(pinned_count)", "def feature(board: chess.Board) -> float:\n    'Measures the mobility of the game by counting the number of available moves for both players'\n    return float(len(list(board.legal_moves)))", "def feature(board: chess.Board) -> float:\n    'Evaluates the position based on the number of pieces on the board that are actively controlling the center squares (d4, d5, e4, e5)'\n    center_squares = [chess.parse_square(square) for square in ['d4', 'd5', 'e4', 'e5']]\n    control_count = sum(1 for square in center_squares for piece in board.attackers(chess.WHITE, square)) - \\\n                   sum(1 for square in center_squares for piece in board.attackers(chess.BLACK, square))\n    return float(control_count)", "def feature(board: chess.Board) -> float:\n    'Counts the number of pieces with double attacks (attacking two of the opponent\u2019s pieces).'\n    double_attacks = 0\n    for square in board.piece_map():\n        piece = board.piece_at(square)\n        if piece.color == board.turn:\n            attacking_squares = board.attackers(not piece.color, square)\n            for attack in attacking_squares:\n                if board.piece_at(attack) and board.piece_at(attack).color != piece.color:\n                    double_attacks += 1\n                    break\n    return float(double_attacks)", "def feature(board: chess.Board) -> float:\n    'Measures the activity of the kings by counting the number of safe squares they can move to.'\n    def king_safety(color):\n        king_square = next(sq for sq, p in board.piece_map().items() if p.piece_type == chess.KING and p.color == color)\n        safe_moves = 0\n        for move in chess.SQUARES:\n            if board.is_attacked_by(not color, move) and move != king_square:\n                continue\n            if chess.square_distance(king_square, move) == 1:\n                safe_moves += 1\n        return safe_moves\n    \n    return float(king_safety(chess.WHITE) + king_safety(chess.BLACK))", "def feature(board: chess.Board) -> float:\n    'Calculates the difference in mobility between the two players.'\n    white_moves = len(list(board.legal_moves)) if board.turn else 0\n    black_moves = len(list(board.legal_moves)) if not board.turn else 0\n    return float(white_moves - black_moves)", "def feature(board: chess.Board) -> float:\n    'Counts the number of pieces that are pinned against their own king.'\n    pinned_pieces = 0\n    for square in board.piece_map():\n        piece = board.piece_at(square)\n        if piece.color == board.turn:\n            if board.is_attacked_by(not piece.color, square) and board.is_attacked_by(piece.color, piece.color and board.king(piece.color)):\n                pinned_pieces += 1\n    return float(pinned_pieces)", "def feature(board: chess.Board) -> float:\n    'Measures the number of opposing pieces that are one square away from the player\u2019s pieces.'\n    adjacent_opponent_pieces = 0\n    for square in board.piece_map():\n        piece = board.piece_at(square)\n        if piece.color == board.turn:\n            for move in chess.SQUARES:\n                if chess.square_distance(square, move) == 1 and board.piece_at(move) and board.piece_at(move).color != piece.color:\n                    adjacent_opponent_pieces += 1\n    return float(adjacent_opponent_pieces)", "def feature(board: chess.Board) -> float:\n    'Counts the number of squares contested by both players (where both sides have attacking pieces).'\n    contested_squares = 0\n    for square in chess.SQUARES:\n        if board.is_attacked_by(chess.WHITE, square) and board.is_attacked_by(chess.BLACK, square):\n            contested_squares += 1\n    return float(contested_squares)", "def feature(board: chess.Board) -> float:\n    'Measures the average distance of each player\u2019s pieces to their opponent\u2019s king.'\n    def average_distance(color):\n        king_square = next(sq for sq, p in board.piece_map().items() if p.piece_type == chess.KING and p.color == color)\n        total_distance = 0\n        piece_count = 0\n        for square in board.piece_map():\n            piece = board.piece_at(square)\n            if piece.color == color:\n                total_distance += chess.square_distance(square, king_square)\n                piece_count += 1\n        return total_distance / piece_count if piece_count > 0 else 0\n    \n    return float(average_distance(chess.WHITE) - average_distance(chess.BLACK))", "def feature(board: chess.Board) -> float:\n    'Counts the number of pieces that are threatening the opponent\u2019s king directly.'\n    attacking_squares = 0\n    king_square = next(sq for sq, p in board.piece_map().items() if p.piece_type == chess.KING and p.color != board.turn)\n    for square in board.piece_map():\n        piece = board.piece_at(square)\n        if piece.color == board.turn and board.is_attacked_by(not piece.color, king_square):\n            attacking_squares += 1\n    return float(attacking_squares)", "def feature(board: chess.Board) -> float:\n    \"Calculates the total number of pieces on the board.\"\n    return float(len(board.piece_map()))", "def feature(board: chess.Board) -> float:\n    \"Counts the total number of pawns on both sides.\"\n    return float(sum(1 for piece in board.piece_map().values() if piece.piece_type == chess.PAWN))", "def feature(board: chess.Board) -> float:\n    \"Measures the number of squares that are under attack by each side.\"\n    white_attacks = sum(1 for square in chess.SQUARES if board.is_attacked_by(chess.WHITE, square))\n    black_attacks = sum(1 for square in chess.SQUARES if board.is_attacked_by(chess.BLACK, square))\n    return float(white_attacks - black_attacks)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of pieces that can move without being captured on the next turn.\"\n    safe_moves = 0\n    for move in board.legal_moves:\n        board.push(move)\n        if not board.is_check():\n            safe_moves += 1\n        board.pop()\n    return float(safe_moves)", "def feature(board: chess.Board) -> float:\n    \"Computes the sum of the values of all pieces currently on the board.\"\n    piece_values = {\n        chess.PAWN: 100,\n        chess.KNIGHT: 320,\n        chess.BISHOP: 330,\n        chess.ROOK: 500,\n        chess.QUEEN: 900,\n        chess.KING: 0\n    }\n    total_value = sum(piece_values[piece.piece_type] for piece in board.piece_map().values())\n    return float(total_value)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of pieces pinned by the opponent.\"\n    pinned_count = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == board.turn:  # Only check the current player's pieces\n            attackers = board.attackers(not board.turn, square)\n            if any(board.is_attacked_by(not board.turn, attacker) for attacker in attackers):\n                pinned_count += 1\n    return float(pinned_count)", "def feature(board: chess.Board) -> float:\n    \"Measures the total number of checks that can be delivered on the next move.\"\n    check_options = sum(1 for move in board.legal_moves if board.gives_check(move))\n    return float(check_options)", "def feature(board: chess.Board) -> float:\n    \"Computes the average rank of pieces for each color.\"\n    white_ranks = [chess.square_rank(square) for square, piece in board.piece_map().items() if piece.color == chess.WHITE]\n    black_ranks = [chess.square_rank(square) for square, piece in board.piece_map().items() if piece.color == chess.BLACK]\n    average_white_rank = sum(white_ranks) / len(white_ranks) if white_ranks else 0\n    average_black_rank = sum(black_ranks) / len(black_ranks) if black_ranks else 0\n    return float(average_white_rank - average_black_rank)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of doubled pawns for each side and returns the difference.\"\n    white_doubled = sum(1 for file in range(8) \n                        if sum(1 for rank in range(8) \n                        if board.piece_at(chess.square(file, rank)) == chess.PAWN and piece.color == chess.WHITE) > 1)\n    \n    black_doubled = sum(1 for file in range(8) \n                        if sum(1 for rank in range(8) \n                        if board.piece_at(chess.square(file, rank)) == chess.PAWN and piece.color == chess.BLACK) > 1)\n                        \n    return float(white_doubled - black_doubled)", "def feature(board: chess.Board) -> float:\n    \"Calculates the total value of all pieces on the board.\"\n    piece_values = {chess.PAWN: 100, chess.KNIGHT: 320, chess.BISHOP: 330,\n                    chess.ROOK: 500, chess.QUEEN: 900, chess.KING: 20000}\n    total_value = 0.0\n    for piece in board.piece_map().values():\n        total_value += piece_values[piece.piece_type] if piece.color == chess.WHITE else -piece_values[piece.piece_type]\n    return total_value", "def feature(board: chess.Board) -> float:\n    \"Counts the number of check opportunities for both players.\"\n    check_opps = 0\n    for move in board.legal_moves:\n        board.push(move)\n        if board.is_check():\n            check_opps += 1\n        board.pop()\n    return float(check_opps)", "def feature(board: chess.Board) -> float:\n    \"Calculates the ratio of pieces controlled by each side.\"\n    white_control = len([sq for sq in chess.SQUARES if board.is_attacked_by(chess.WHITE, sq)])\n    black_control = len([sq for sq in chess.SQUARES if board.is_attacked_by(chess.BLACK, sq)])\n    return float(white_control) / (black_control + 1)  # Avoid division by zero", "def feature(board: chess.Board) -> float:\n    \"Measures how many squares are attacked by the opponent's pieces.\"\n    opponent = chess.BLACK if board.turn else chess.WHITE\n    attacked_squares = sum(1 for sq in chess.SQUARES if board.is_attacked_by(opponent, sq))\n    return float(attacked_squares)", "def feature(board: chess.Board) -> float:\n    \"Counts the total number of pawns on the board.\"\n    pawn_count = sum(1 for piece in board.piece_map().values() if piece.piece_type == chess.PAWN)\n    return float(pawn_count)", "def feature(board: chess.Board) -> float:\n    \"Measures the total number of unprotected pieces on the board.\"\n    unprotected_count = 0\n    for square, piece in board.piece_map().items():\n        if not board.attackers(piece.color, square):\n            unprotected_count += 1\n    return float(unprotected_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of squares controlled by the player's pieces.\"\n    controlled_squares = len([sq for sq in chess.SQUARES if board.is_attacked_by(board.turn, sq)])\n    return float(controlled_squares)", "def feature(board: chess.Board) -> float:\n    \"Calculates the material difference considering only major pieces.\"\n    major_piece_types = {chess.ROOK, chess.QUEEN}\n    material_value = {chess.ROOK: 500, chess.QUEEN: 900}\n    total_value = 0.0\n    for piece in board.piece_map().values():\n        if piece.piece_type in major_piece_types:\n            total_value += material_value[piece.piece_type] if piece.color == chess.WHITE else -material_value[piece.piece_type]\n    return total_value", "def feature(board: chess.Board) -> float:\n    'Measures the difference in the number of pawns on the board between both players.'\n    white_pawns = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE and piece.piece_type == chess.PAWN)\n    black_pawns = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK and piece.piece_type == chess.PAWN)\n    return float(white_pawns - black_pawns)", "def feature(board: chess.Board) -> float:\n    'Counts how many of the opponent\u2019s pieces are attacked by player\u2019s pieces.'\n    color = board.turn\n    opponent_color = not color\n    attacked_pieces = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == opponent_color and board.is_attacked_by(color, square):\n            attacked_pieces += 1\n    return float(attacked_pieces)", "def feature(board: chess.Board) -> float:\n    'Calculates the average rank of the pieces for the current player, higher ranks indicate better positioning for pieces.'\n    color = board.turn\n    total_rank = 0\n    piece_count = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == color:\n            total_rank += chess.square_rank(square)\n            piece_count += 1\n    return total_rank / piece_count if piece_count > 0 else 0.0", "def feature(board: chess.Board) -> float:\n    'Measures the total number of doubled pawns for both players.'\n    doubled_pawns = 0\n    pawn_files = {file: 0 for file in range(8)}\n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.PAWN:\n            pawn_files[chess.square_file(square)] += 1\n    doubled_pawns = sum(max(0, count - 1) for count in pawn_files.values())\n    return float(doubled_pawns)", "def feature(board: chess.Board) -> float:\n    'Counts the number of pieces vulnerable to capture without any protection from other pieces.'\n    vulnerable_pieces = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == board.turn:\n            # See if the piece is attacked by any opponent's piece\n            if board.is_attacked_by(not board.turn, square):\n                attackers = board.attackers(not board.turn, square)\n                if all(board.piece_at(attacker) is None or board.piece_at(attacker).color == board.turn for attacker in attackers):\n                    vulnerable_pieces += 1\n    return float(vulnerable_pieces)", "def feature(board: chess.Board) -> float:\n    'Calculates the number of open files for both players.'\n    open_files = 0\n    for file in range(8):\n        pieces_in_file = [board.piece_at(chess.square(rank, file)) for rank in range(8)]\n        if all(piece is None or piece.color != board.turn for piece in pieces_in_file):\n            open_files += 1\n    return float(open_files)", "def feature(board: chess.Board) -> float:\n    'Counts the total number of pieces with no mobility (cannot make any legal moves).'\n    immobile_pieces = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == board.turn:\n            if not list(board.legal_moves):\n                immobile_pieces += 1\n    return float(immobile_pieces)", "def feature(board: chess.Board) -> float:\n    'Calculates the material value of each player based on piece types present on the board.'\n    piece_values = {\n        chess.PAWN: 100,\n        chess.KNIGHT: 320,\n        chess.BISHOP: 330,\n        chess.ROOK: 500,\n        chess.QUEEN: 900,\n        chess.KING: 20000\n    }\n    material_value = 0\n    for square, piece in board.piece_map().items():\n        material_value += piece_values[piece.piece_type] if piece.color == board.turn else -piece_values[piece.piece_type]\n    return float(material_value)", "def feature(board: chess.Board) -> float:\n    \"Calculates the sum of the ranks of all pieces for each color to assess piece placement.\"\n    white_ranks = sum(chess.square_rank(square) for square in board.piece_map() if board.piece_at(square).color == chess.WHITE)\n    black_ranks = sum(chess.square_rank(square) for square in board.piece_map() if board.piece_at(square).color == chess.BLACK)\n    return float(white_ranks - black_ranks)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces that are on the 7th and 8th ranks for each color.\"\n    white_back_row = sum(1 for square in board.piece_map() if board.piece_at(square).color == chess.WHITE and chess.square_rank(square) == 7)\n    black_back_row = sum(1 for square in board.piece_map() if board.piece_at(square).color == chess.BLACK and chess.square_rank(square) == 0)\n    return float(white_back_row - black_back_row)", "def feature(board: chess.Board) -> float:\n    \"Measures the imbalance in material value by counting only the more valuable pieces on the board.\"\n    valuable_pieces_value = 0\n    for piece in board.piece_map().values():\n        if piece.piece_type in [chess.QUEEN, chess.ROOK]:\n            value = 5 if piece.piece_type == chess.QUEEN else 3\n            if piece.color == chess.WHITE:\n                valuable_pieces_value += value\n            else:\n                valuable_pieces_value -= value\n    return float(valuable_pieces_value)", "def feature(board: chess.Board) -> float:\n    \"Calculates the distance of the king from its home row for both players.\"\n    white_king_square = next((square for square in board.piece_map() if board.piece_at(square).piece_type == chess.KING and board.piece_at(square).color == chess.WHITE), None)\n    black_king_square = next((square for square in board.piece_map() if board.piece_at(square).piece_type == chess.KING and board.piece_at(square).color == chess.BLACK), None)\n    white_king_distance = chess.square_rank(white_king_square) if white_king_square is not None else 8\n    black_king_distance = 7 - chess.square_rank(black_king_square) if black_king_square is not None else 8\n    return float(white_king_distance - black_king_distance)", "def feature(board: chess.Board) -> float:\n    \"Calculates the total number of pieces in the center of the board (d4, d5, e4, e5) for both players.\"\n    center_squares = [chess.D4, chess.D5, chess.E4, chess.E5]\n    center_piece_value = sum(1 for square in center_squares if board.piece_at(square) is not None)\n    return float(center_piece_value)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of check and checkmate threats posed to the opponent's king.\"\n    threats = 0\n    if board.is_check():\n        threats += 1\n    for move in board.legal_moves:\n        board.push(move)\n        if board.is_checkmate():\n            threats += 1\n        board.pop()\n    return float(threats)", "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in the number of pieces supported versus unsupported for each color.\"\n    supported_white = sum(1 for square in board.piece_map() if board.piece_at(square).color == chess.WHITE and any(board.is_attacked_by(chess.BLACK, square) for attacker in board.attackers(chess.BLACK, square)))\n    supported_black = sum(1 for square in board.piece_map() if board.piece_at(square).color == chess.BLACK and any(board.is_attacked_by(chess.WHITE, square) for attacker in board.attackers(chess.WHITE, square)))\n    return float(supported_white - supported_black)", "def feature(board: chess.Board) -> float:\n    \"Measures the difference in the number of pieces on the board for each side.\"\n    white_piece_count = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE)\n    black_piece_count = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK)\n    return float(white_piece_count - black_piece_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the sum of the ranks of all friendly pieces on the board.\"\n    friendly_pieces = [square for square, piece in board.piece_map().items() if piece.color == board.turn]\n    return float(sum(chess.square_rank(square) for square in friendly_pieces))", "def feature(board: chess.Board) -> float:\n    \"Counts how many pieces are on squares controlled by the opponent.\"\n    controlled_by_opponent = sum(1 for square in board.piece_map() if board.is_attacked_by(not board.turn, square))\n    return float(controlled_by_opponent)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of escaping squares available for the king in check.\"\n    if board.is_check():\n        king_square = next(square for square, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color == board.turn)\n        escape_squares = sum(1 for move in board.legal_moves if move.to_square != king_square)\n        return float(escape_squares)\n    return 0.0", "def feature(board: chess.Board) -> float:\n    \"Calculates the ratio of pieces compared to the total number of squares controlled.\"\n    total_controlled_squares = len(set().union(*[board.attackers(piece.color, square) for square, piece in board.piece_map().items()]))\n    total_pieces = len(board.piece_map())\n    return float(total_pieces) / float(total_controlled_squares) if total_controlled_squares > 0 else 0.0", "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in the number of pawn structures between players.\"\n    white_pawns = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE and piece.piece_type == chess.PAWN)\n    black_pawns = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK and piece.piece_type == chess.PAWN)\n    return float(white_pawns - black_pawns)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces that are pinned.\"\n    pinned_count = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == board.turn: \n            for move in board.legal_moves:\n                if board.is_check() and move.from_square == square: \n                    pinned_count += 1\n    return float(pinned_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the material score by assigning values to each piece present on the board.\"\n    piece_values = {\n        chess.PAWN: 100,\n        chess.KNIGHT: 320,\n        chess.BISHOP: 330,\n        chess.ROOK: 500,\n        chess.QUEEN: 900,\n        chess.KING: 0  # King does not contribute to material balance\n    }\n    score = sum(piece_values[piece.piece_type] * (1 if piece.color == board.turn else -1)\n                for piece in board.piece_map().values())\n    return float(score)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of pieces developed (not on the starting rank).\"\n    developed_count = sum(1 for square, piece in board.piece_map().items() if piece.color == board.turn and chess.square_rank(square) > 1)\n    return float(developed_count)", "def feature(board: chess.Board) -> float:\n    \"Measures the total number of pieces on the board for both players.\"\n    total_pieces = sum(1 for piece in board.piece_map().values())\n    return float(total_pieces)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pawns for both players and calculates their difference.\"\n    white_pawns = sum(1 for sq in board.piece_map() if board.piece_at(sq).piece_type == chess.PAWN and board.piece_at(sq).color == chess.WHITE)\n    black_pawns = sum(1 for sq in board.piece_map() if board.piece_at(sq).piece_type == chess.PAWN and board.piece_at(sq).color == chess.BLACK)\n    return float(white_pawns - black_pawns)", "def feature(board: chess.Board) -> float:\n    \"Evaluates the total distance of pieces from the center of the board.\"\n    total_distance = sum(chess.square_distance(sq, chess.square(3, 3)) for sq in board.piece_map())\n    return float(total_distance)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of checks each player can give on the next move.\"\n    white_checks = sum(1 for move in board.legal_moves if board.gives_check(move))\n    black_checks = sum(1 for move in board.legal_moves if board.gives_check(move) and board.turn is False)\n    return float(white_checks - black_checks)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of squares that are attacked by each player's pieces.\"\n    white_attacks = sum(1 for sq in range(64) if board.is_attacked_by(chess.WHITE, sq))\n    black_attacks = sum(1 for sq in range(64) if board.is_attacked_by(chess.BLACK, sq))\n    return float(white_attacks - black_attacks)", "def feature(board: chess.Board) -> float:\n    \"Measures the total number of isolated pawns for both players.\"\n    def is_isolated(square, color):\n        file = chess.square_file(square)\n        return (board.piece_at(square).piece_type == chess.PAWN and\n                (file == 0 or not board.piece_at(chess.square(square // 8, file - 1)) or\n                 board.piece_at(chess.square(square // 8, file - 1)).color != color) and\n                (file == 7 or not board.piece_at(chess.square(square // 8, file + 1)) or\n                 board.piece_at(chess.square(square // 8, file + 1)).color != color))\n\n    isolated_count = sum(1 for square in board.piece_map() if is_isolated(square, board.piece_at(square).color))\n    return float(isolated_count)", "def feature(board: chess.Board) -> float:\n    \"Counts how many pieces are being attacked by opposing pieces.\"\n    attacking_count = sum(1 for sq in board.piece_map() if board.is_attacked_by(not board.piece_at(sq).color, sq))\n    return float(attacking_count)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of potential threats to the king for each player.\"\n    white_threats = sum(1 for square in chess.SQUARES if board.is_attacked_by(chess.BLACK, square) and board.piece_at(square) and board.piece_at(square).color == chess.WHITE and board.piece_at(square).piece_type == chess.KING)\n    black_threats = sum(1 for square in chess.SQUARES if board.is_attacked_by(chess.WHITE, square) and board.piece_at(square) and board.piece_at(square).color == chess.BLACK and board.piece_at(square).piece_type == chess.KING)\n    return float(white_threats - black_threats)", "def feature(board: chess.Board) -> float:\n    \"Evaluates if either side has a passed pawn.\"\n    passed_pawns = 0\n    for sq in board.piece_map():\n        piece = board.piece_at(sq)\n        if piece.piece_type == chess.PAWN:\n            file = chess.square_file(sq)\n            if piece.color == chess.WHITE and all(not board.piece_at(chess.square(sq_rank, file))\n                                                   for sq_rank in range(chess.square_rank(sq) + 1, 8)):\n                passed_pawns += 1\n            elif piece.color == chess.BLACK and all(not board.piece_at(chess.square(sq_rank, file))\n                                                      for sq_rank in range(0, chess.square_rank(sq))):\n                passed_pawns += 1\n    return float(passed_pawns)", "def feature(board: chess.Board) -> float:\n    \"Calculates the total value of pieces that are currently attacking enemy pieces.\"\n    attack_value = 0.0\n    for square in board.piece_map():\n        piece = board.piece_at(square)\n        for attacker_square in board.attackers(board.turn, square):\n            attack_value += piece.piece_type\n    return float(attack_value)", "def feature(board: chess.Board) -> float:\n    \"Measures the difference in the number of pawns for both players.\"\n    white_pawns = len([p for p in board.piece_map().values() if p.color == chess.WHITE and p.piece_type == chess.PAWN])\n    black_pawns = len([p for p in board.piece_map().values() if p.color == chess.BLACK and p.piece_type == chess.PAWN])\n    return float(white_pawns - black_pawns)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces placed on the 7th rank, favoring the side with more pieces.\"\n    white_seventh_rank = len([square for square in range(56, 64) if board.piece_at(square) and board.piece_at(square).color == chess.WHITE])\n    black_seventh_rank = len([square for square in range(0, 8) if board.piece_at(square) and board.piece_at(square).color == chess.BLACK])\n    return float(white_seventh_rank - black_seventh_rank)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of pieces that are pinned to the king.\"\n    pinned_count = 0\n    for square in board.piece_map():\n        piece = board.piece_at(square)\n        if piece.color == board.turn:\n            for opponent in board.legal_moves:\n                if board.is_check() and opponent.to_square == square:\n                    pinned_count += 1\n    return float(pinned_count)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of pieces under attack that are not being defended.\"\n    undefended_count = 0\n    for square in board.piece_map():\n        piece = board.piece_at(square)\n        if piece.color == board.turn:\n            if board.is_attacked_by(not board.turn, square) and not board.attackers(piece.color, square):\n                undefended_count += 1\n    return float(undefended_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the total number of squares attacked by each player's pieces.\"\n    white_attacked_squares = len(set(square for piece_square in board.piece_map() if board.piece_at(piece_square).color == chess.WHITE \n                                       for square in board.attackers(chess.WHITE, piece_square)))\n    black_attacked_squares = len(set(square for piece_square in board.piece_map() if board.piece_at(piece_square).color == chess.BLACK \n                                       for square in board.attackers(chess.BLACK, piece_square)))\n    return float(white_attacked_squares - black_attacked_squares)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of pieces that are well-coordinated (supported by adjacent pieces).\"\n    coordinated_count = 0\n    for square in board.piece_map():\n        if board.piece_at(square).color == board.turn:\n            adjacent_squares = [square - 1, square + 1, square - 8, square + 8, square - 7, square + 7, square - 9, square + 9]\n            if any(board.piece_at(sq) and board.piece_at(sq).color == board.turn for sq in adjacent_squares if 0 <= sq < 64):\n                coordinated_count += 1\n    return float(coordinated_count)", "def feature(board: chess.Board) -> float:\n    \"Evaluates the imbalance of material by counting the difference in the number of pieces of each type.\"\n    piece_count_diff = {}\n    for piece_type in [chess.PAWN, chess.KNIGHT, chess.BISHOP, chess.ROOK, chess.QUEEN]:\n        white_count = len([p for p in board.piece_map().values() if p.color == chess.WHITE and p.piece_type == piece_type])\n        black_count = len([p for p in board.piece_map().values() if p.color == chess.BLACK and p.piece_type == piece_type])\n        piece_count_diff[piece_type] = float(white_count - black_count)\n    return sum(piece_count_diff.values())", "def feature(board: chess.Board) -> float:\n    \"Measures the number of legal moves available for pawns only.\"\n    pawn_moves = sum(1 for square in board.piece_map() if board.piece_at(square).piece_type == chess.PAWN \n                     and board.legal_moves)  # counting all legal moves of pawns\n    return float(pawn_moves)", "def feature(board: chess.Board) -> float:\n    \"Measures the mobility of pieces based on the total number of legal moves available for both players.\"\n    white_moves = sum(1 for _ in board.legal_moves if board.turn is True)\n    black_moves = sum(1 for _ in board.legal_moves if board.turn is False)\n    return float(white_moves - black_moves)", "def feature(board: chess.Board) -> float:\n    \"Calculates the total number of pieces on the board as a measure of activity.\"\n    return float(len(board.piece_map()))", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces attacking the opponent's king.\"\n    white_attacks = len(board.attackers(chess.WHITE, chess.parse_square('g8')))\n    black_attacks = len(board.attackers(chess.BLACK, chess.parse_square('g1')))\n    return float(white_attacks - black_attacks)", "def feature(board: chess.Board) -> float:\n    \"Evaluates the potential future threats by counting pieces that are currently in checks.\"\n    return float(int(board.is_check()))", "def feature(board: chess.Board) -> float:\n    \"Measures the pawn structure by counting doubled pawns for both players.\"\n    white_doubled_pawns = sum(1 for sq in chess.SQUARES if board.piece_at(sq) == chess.PAWN and \n                                any(board.piece_at(sq + offset) == chess.PAWN for offset in [-8, -16]))\n    black_doubled_pawns = sum(1 for sq in chess.SQUARES if board.piece_at(sq) == chess.PAWN and \n                                any(board.piece_at(sq + offset) == chess.PAWN for offset in [8, 16]))\n    return float(white_doubled_pawns - black_doubled_pawns)", "def feature(board: chess.Board) -> float:\n    \"Measures the distance of pieces from their starting ranks to evaluate the piece activity.\"\n    piece_distance = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == chess.WHITE:\n            piece_distance += chess.square_rank(square)\n        else:\n            piece_distance += (7 - chess.square_rank(square))\n    return float(piece_distance)", "def feature(board: chess.Board) -> float:\n    \"Evaluates the distribution of pawns across the board to determine control of center squares.\"\n    central_pawns = sum(1 for sq in [chess.D4, chess.D5, chess.E4, chess.E5] if board.piece_at(sq) == chess.PAWN)\n    return float(central_pawns)", "def feature(board: chess.Board) -> float:\n    \"Measures the total number of pieces that are pinned by the opponent's pieces.\"\n    pinned_count = sum(1 for square in chess.SQUARES if board.piece_at(square) is not None and \n                       board.is_attacked_by(board.piece_at(square).color, square))\n    return float(pinned_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the ratio of light-square vs dark-square control by each player.\"\n    white_light_control = len([sq for sq in chess.SQUARES if board.is_attacked_by(chess.WHITE, sq) and (sq % 2 == 0)])\n    white_dark_control = len([sq for sq in chess.SQUARES if board.is_attacked_by(chess.WHITE, sq) and (sq % 2 != 0)])\n    black_light_control = len([sq for sq in chess.SQUARES if board.is_attacked_by(chess.BLACK, sq) and (sq % 2 == 0)])\n    black_dark_control = len([sq for sq in chess.SQUARES if board.is_attacked_by(chess.BLACK, sq) and (sq % 2 != 0)])\n    return float(white_light_control + black_dark_control)", "def feature(board: chess.Board) -> float:\n    \"Measures the difference in pawn structure for both players by counting isolated pawns.\"\n    white_isolated_pawns = sum(1 for sq in chess.SQUARES if board.piece_at(sq) == chess.PAWN and \n                             (board.piece_at(sq - 1) != chess.PAWN and board.piece_at(sq + 1) != chess.PAWN))\n    black_isolated_pawns = sum(1 for sq in chess.SQUARES if board.piece_at(sq) == chess.PAWN and \n                             (board.piece_at(sq - 8) != chess.PAWN and board.piece_at(sq + 8) != chess.PAWN))\n    return float(white_isolated_pawns - black_isolated_pawns)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces that are attacking the opponent's king.\"\n    king_square = board.king(chess.BLACK) if board.turn else board.king(chess.WHITE)\n    attack_count = len(board.attackers(chess.WHITE if board.turn else chess.BLACK, king_square))\n    return float(attack_count)", "def feature(board: chess.Board) -> float:\n    \"Measures the total number of pawns for both players.\"\n    total_pawns = sum(1 for piece in board.piece_map().values() if piece.piece_type == chess.PAWN)\n    return float(total_pawns)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of potential check threats by both players.\"\n    check_threats = 0\n    for move in board.legal_moves:\n        if board.gives_check(move):\n            check_threats += 1\n    return float(check_threats)", "def feature(board: chess.Board) -> float:\n    \"Evaluates the number of doubled pawns for both players.\"\n    white_pawns = [square for square in board.piece_map() if board.piece_map()[square].color == chess.WHITE and board.piece_map()[square].piece_type == chess.PAWN]\n    black_pawns = [square for square in board.piece_map() if board.piece_map()[square].color == chess.BLACK and board.piece_map()[square].piece_type == chess.PAWN]\n    \n    white_doubled = len(set(chess.square_file(p) for p in white_pawns)) - len(white_pawns)\n    black_doubled = len(set(chess.square_file(p) for p in black_pawns)) - len(black_pawns)\n    \n    return float(white_doubled + black_doubled)", "def feature(board: chess.Board) -> float:\n    \"Calculates the value of pieces based on their position on the board.\"\n    piece_values = {\n        chess.PAWN: 100,\n        chess.KNIGHT: 320,\n        chess.BISHOP: 330,\n        chess.ROOK: 500,\n        chess.QUEEN: 900,\n        chess.KING: 0\n    }\n    weighted_value = sum(piece_values[piece.piece_type] for piece in board.piece_map().values())\n    return float(weighted_value)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces that are attacking the opponent's king.\"\n    opponent_king_square = None\n    for square in board.piece_map():\n        piece = board.piece_at(square)\n        if piece.piece_type == chess.KING and piece.color != board.turn:\n            opponent_king_square = square\n            break\n    if opponent_king_square is None:\n        return 0.0\n    attacking_pieces = sum(1 for move in board.legal_moves if move.to_square == opponent_king_square)\n    return float(attacking_pieces)", "def feature(board: chess.Board) -> float:\n    \"Measures the strength of the central control by counting pieces in the center squares.\"\n    center_squares = [chess.E4, chess.E5, chess.D4, chess.D5]\n    central_piece_count = sum(1 for square in center_squares if board.piece_at(square) is not None)\n    return float(central_piece_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in piece activity for minor pieces (knights and bishops).\"\n    white_minor_activity = sum(1 for square in board.piece_map() if board.piece_at(square).color == chess.WHITE and board.piece_at(square).piece_type in [chess.KNIGHT, chess.BISHOP] and board.attackers(chess.BLACK, square))\n    black_minor_activity = sum(1 for square in board.piece_map() if board.piece_at(square).color == chess.BLACK and board.piece_at(square).piece_type in [chess.KNIGHT, chess.BISHOP] and board.attackers(chess.WHITE, square))\n    return float(white_minor_activity - black_minor_activity)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of unopposed pieces on the last rank of each player.\"\n    white_pieces_on_last_rank = sum(1 for square in range(chess.A8, chess.H8 + 1) if board.piece_at(square) is not None and board.piece_at(square).color == chess.WHITE)\n    black_pieces_on_last_rank = sum(1 for square in range(chess.A1, chess.H1 + 1) if board.piece_at(square) is not None and board.piece_at(square).color == chess.BLACK)\n    return float(white_pieces_on_last_rank - black_pieces_on_last_rank)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of open files (files without pawns) for both players.\"\n    def open_file_count(color):\n        count = 0\n        for file in range(8):\n            if not any(board.piece_at(chess.square(file, rank)) and board.piece_at(chess.square(file, rank)).color == color for rank in range(8)):\n                count += 1\n        return count\n\n    return float(open_file_count(chess.WHITE) - open_file_count(chess.BLACK))", "def feature(board: chess.Board) -> float:\n    \"Computes the average distance of all pawns to the opponent's back rank.\"\n    pawn_squares = [square for square in board.piece_map() if board.piece_at(square).piece_type == chess.PAWN]\n    if not pawn_squares:\n        return 0.0\n    opponent_back_rank = 0 if board.turn == chess.WHITE else 7\n    average_distance = sum(chess.square_rank(square) - opponent_back_rank for square in pawn_squares) / len(pawn_squares)\n    return float(average_distance)", "def feature(board: chess.Board) -> float:\n    \"Measures the total number of squares that are defended by pawns for both sides.\"\n    def defended_squares_count(color):\n        defended_squares = set()\n        for square in board.piece_map():\n            piece = board.piece_at(square)\n            if piece.color == color and piece.piece_type == chess.PAWN:\n                defended_squares.add(square + 1)  # Right\n                defended_squares.add(square - 1)  # Left\n        return len(defended_squares)\n\n    return float(defended_squares_count(chess.WHITE) - defended_squares_count(chess.BLACK))", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of pieces that are pinned by the opponent's pieces on the board.\"\n    pinned_pieces = sum(1 for square in board.piece_map() if board.piece_at(square).color == board.turn and board.is_attacked_by(not board.turn, square))\n    return float(pinned_pieces)", "def feature(board: chess.Board) -> float:\n    \"Evaluates the proximity of the opponent's king to the center of the board.\"\n    opponent_king_square = next(square for square in board.piece_map() if board.piece_at(square).piece_type == chess.KING and board.piece_at(square).color != board.turn)\n    center_distance = chess.square_distance(opponent_king_square, chess.E4) + chess.square_distance(opponent_king_square, chess.D4)\n    return float(16 - center_distance)  # Closer to center = higher score", "def feature(board: chess.Board) -> float:\n    \"Counts the number of attacks each player has on the opponent's pieces.\"\n    white_attack_count = sum(1 for square in board.piece_map() if board.piece_at(square).color == chess.WHITE and board.attackers(chess.BLACK, square))\n    black_attack_count = sum(1 for square in board.piece_map() if board.piece_at(square).color == chess.BLACK and board.attackers(chess.WHITE, square))\n    return float(white_attack_count - black_attack_count)", "def feature(board: chess.Board) -> float:\n    \"Measures the total number of squares controlled by each player's pieces.\"\n    color_control = {chess.WHITE: 0, chess.BLACK: 0}\n    for square in chess.SQUARES:\n        for color in (chess.WHITE, chess.BLACK):\n            if board.is_attacked_by(color, square):\n                color_control[color] += 1\n    return float(color_control[chess.WHITE] - color_control[chess.BLACK])", "def feature(board: chess.Board) -> float:\n    \"Counts the difference in mobility between both players by measuring possible moves.\"\n    white_moves = len(list(board.legal_moves)) if board.turn else 0\n    black_moves = len(list(board.legal_moves)) if not board.turn else 0\n    return float(white_moves - black_moves)", "def feature(board: chess.Board) -> float:\n    \"Evaluates the influence of each player's pieces in the center of the board.\"\n    center_squares = [chess.E4, chess.E5, chess.D4, chess.D5]\n    center_control = {chess.WHITE: 0, chess.BLACK: 0}\n    for square in center_squares:\n        if board.is_attacked_by(chess.WHITE, square):\n            center_control[chess.WHITE] += 1\n        if board.is_attacked_by(chess.BLACK, square):\n            center_control[chess.BLACK] += 1\n    return float(center_control[chess.WHITE] - center_control[chess.BLACK])", "def feature(board: chess.Board) -> float:\n    \"Counts the number of major pieces (rooks and queens) each player has.\"\n    major_piece_count = {chess.WHITE: 0, chess.BLACK: 0}\n    for piece in board.piece_map().values():\n        if piece.piece_type in [chess.ROOK, chess.QUEEN]:\n            major_piece_count[piece.color] += 1\n    return float(major_piece_count[chess.WHITE] - major_piece_count[chess.BLACK])", "def feature(board: chess.Board) -> float:\n    \"Measures the king safety by counting the number of pieces protecting each king.\"\n    king_safety = {chess.WHITE: 0, chess.BLACK: 0}\n    for square in chess.SQUARES:\n        if board.piece_at(square) and board.piece_at(square).piece_type == chess.KING:\n            color = board.piece_at(square).color\n            for attacker_square in board.attackers(not color, square):\n                if board.piece_at(attacker_square) and board.piece_at(attacker_square).color == color:\n                    king_safety[color] += 1\n    return float(king_safety[chess.WHITE] - king_safety[chess.BLACK])", "def feature(board: chess.Board) -> float:\n    \"Counts the number of doubled pawns each player has.\"\n    doubled_pawns = {chess.WHITE: 0, chess.BLACK: 0}\n    for file in range(8):\n        white_pawns = sum(1 for rank in range(8) if board.piece_at(chess.square(file, rank)) and board.piece_at(chess.square(file, rank)).piece_type == chess.PAWN and board.piece_at(chess.square(file, rank)).color == chess.WHITE)\n        black_pawns = sum(1 for rank in range(8) if board.piece_at(chess.square(file, rank)) and board.piece_at(chess.square(file, rank)).piece_type == chess.PAWN and board.piece_at(chess.square(file, rank)).color == chess.BLACK)\n        doubled_pawns[chess.WHITE] += max(0, white_pawns - 1)\n        doubled_pawns[chess.BLACK] += max(0, black_pawns - 1)\n    return float(doubled_pawns[chess.WHITE] - doubled_pawns[chess.BLACK])", "def feature(board: chess.Board) -> float:\n    \"Measures the difference in piece mobility by counting the number of available legal moves for all pieces.\"\n    mobility_white = len(list(board.legal_moves)) if board.turn else 0\n    mobility_black = len(list(board.legal_moves)) if not board.turn else 0\n    return float(mobility_white - mobility_black)", "def feature(board: chess.Board) -> float:\n    \"Calculates the total value of all pieces currently attacked by each player.\"\n    total_attacked_value = 0\n    for square, piece in board.piece_map().items():\n        if board.is_attacked_by(chess.WHITE, square):\n            total_attacked_value += piece.piece_type\n        if board.is_attacked_by(chess.BLACK, square):\n            total_attacked_value -= piece.piece_type\n    return float(total_attacked_value)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces in the last two ranks for each player to assess development.\"\n    white_development = sum(1 for sq in range(56, 64) if board.piece_at(sq) and board.piece_at(sq).color == chess.WHITE)\n    black_development = sum(1 for sq in range(0, 8) if board.piece_at(sq) and board.piece_at(sq).color == chess.BLACK)\n    return float(white_development - black_development)", "def feature(board: chess.Board) -> float:\n    \"Calculates how many pieces are pinned against the king for the current player.\"\n    pinned_count = 0\n    king_square = board.king(chess.WHITE if board.turn else chess.BLACK)\n    for square, piece in board.piece_map().items():\n        if piece.color == (chess.WHITE if board.turn else chess.BLACK):\n            attackers = board.attackers(chess.WHITE if board.turn else chess.BLACK, square)\n            if king_square in attackers:\n                pinned_count += 1\n    return float(pinned_count)", "def feature(board: chess.Board) -> float:\n    \"Measures the distance of the nearest piece to the opponent's back rank.\"\n    distances = []\n    for square, piece in board.piece_map().items():\n        if piece.color == (chess.WHITE if board.turn else chess.BLACK):\n            distance = chess.square_distance(square, chess.square_rank(0) if board.turn else chess.square_rank(7))\n            distances.append(distance)\n    return float(min(distances)) if distances else 0.0", "def feature(board: chess.Board) -> float:\n    \"Calculates the ratio of attacked squares to total squares for the current player's pieces.\"\n    attacked_squares = set()\n    for square, piece in board.piece_map().items():\n        if piece.color == (chess.WHITE if board.turn else chess.BLACK):\n            attacked_squares.update(board.attackers(board.turn, square))\n    total_squares = len(board.piece_map())\n    return float(len(attacked_squares) / total_squares) if total_squares > 0 else 0.0 ", "def feature(board: chess.Board) -> float:\n    \"Additionally counts the number of pieces on the seventh rank for each player.\"\n    white_seventh_rank = sum(1 for sq in range(48, 56) if board.piece_at(sq) and board.piece_at(sq).color == chess.WHITE)\n    black_seventh_rank = sum(1 for sq in range(8, 16) if board.piece_at(sq) and board.piece_at(sq).color == chess.BLACK)\n    return float(white_seventh_rank - black_seventh_rank)", "def feature(board: chess.Board) -> float:\n    \"Measures the imbalance of pawn structure by counting isolated pawns.\"\n    isolated_pawns = 0\n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.PAWN:\n            file = chess.square_file(square)\n            # Check if the pawns on the same file are missing\n            if not (board.piece_at(chess.square(file, chess.square_rank(square) + 1)) or \n                    board.piece_at(chess.square(file, chess.square_rank(square) - 1))):\n                isolated_pawns += 1\n    return float(isolated_pawns)", "def feature(board: chess.Board) -> float:\n    \"Counts the total number of pieces captured by both players to assess material balance.\"\n    captured_value = 0\n    for square, piece in board.piece_map().items():\n        if piece.color != (chess.WHITE if board.turn else chess.BLACK):\n            captured_value += piece.piece_type\n    return float(captured_value)", "def feature(board: chess.Board) -> float:\n    \"Calculates the value of pieces that are attacked but not defended.\"\n    attacked_value = 0\n    for square in board.piece_map():\n        piece = board.piece_at(square)\n        if piece:\n            attackers = board.attackers(not piece.color, square)\n            defenders = board.attackers(piece.color, square)\n            if attackers and not defenders:\n                attacked_value += piece.piece_type\n    return float(attacked_value)", "def feature(board: chess.Board) -> float:\n    \"Measures the control of the center squares (d4, d5, e4, e5).\"\n    center_control = 0\n    center_squares = [chess.D4, chess.D5, chess.E4, chess.E5]\n    for square in center_squares:\n        if board.is_attacked_by(chess.WHITE, square):\n            center_control += 1\n        elif board.is_attacked_by(chess.BLACK, square):\n            center_control -= 1\n    return float(center_control)", "def feature(board: chess.Board) -> float:\n    \"Measures the distance of the closest piece to the opponent's king.\"\n    opponent_king_square = board.king(not board.turn)\n    min_distance = float('inf')\n    for square in board.piece_map():\n        piece = board.piece_at(square)\n        if piece and piece.color == board.turn:\n            distance = chess.square_distance(square, opponent_king_square)\n            min_distance = min(min_distance, distance)\n    return float(min_distance)", "def feature(board: chess.Board) -> float:\n    \"Counts pieces that are potentially exposed to attack based on adjacent squares.\"\n    exposed_count = 0\n    for square in board.piece_map():\n        piece = board.piece_at(square)\n        if piece and piece.color == board.turn:\n            for adj_square in chess.SQUARES:\n                if chess.square_distance(square, adj_square) == 1:  # Adjacent squares\n                    if board.is_attacked_by(not piece.color, square):\n                        exposed_count += 1\n                    break\n    return float(exposed_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the ratio of major pieces to total pieces.\"\n    major_pieces_count = sum(1 for piece in board.piece_map().values()\n                              if piece.piece_type in {chess.ROOK, chess.QUEEN, chess.KING})\n    total_pieces_count = len(board.piece_map())\n    return float(major_pieces_count / total_pieces_count) if total_pieces_count > 0 else 0.0", "def feature(board: chess.Board) -> float:\n    \"Measures the imbalance of bishop colors.\"\n    white_light_bishops = sum(1 for square in board.piece_map() if board.piece_at(square).piece_type == chess.BISHOP and square % 2 == 0 and board.piece_at(square).color == chess.WHITE)\n    white_dark_bishops = sum(1 for square in board.piece_map() if board.piece_at(square).piece_type == chess.BISHOP and square % 2 != 0 and board.piece_at(square).color == chess.WHITE)\n    black_light_bishops = sum(1 for square in board.piece_map() if board.piece_at(square).piece_type == chess.BISHOP and square % 2 == 0 and board.piece_at(square).color == chess.BLACK)\n    black_dark_bishops = sum(1 for square in board.piece_map() if board.piece_at(square).piece_type == chess.BISHOP and square % 2 != 0 and board.piece_at(square).color == chess.BLACK)\n    return float((white_light_bishops - white_dark_bishops) - (black_light_bishops - black_dark_bishops))", "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in development between pieces on the board.\"\n    development_score = 0\n    development_threshold = 4  # Example threshold for development\n    for square in board.piece_map():\n        piece = board.piece_at(square)\n        if piece and piece.color == board.turn:\n            if piece.piece_type in {chess.KNIGHT, chess.BISHOP}:\n                if (chess.square_rank(square) >= development_threshold):\n                    development_score += 1\n            elif piece.piece_type in {chess.ROOK, chess.QUEEN}:\n                if (square // 8 >= development_threshold):\n                    development_score += 1\n    return float(development_score)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pawn structures oriented towards the opponent's side.\"\n    pawns = sum(1 for square, piece in board.piece_map().items() if piece.piece_type == chess.PAWN)\n    return float(pawns)", "def feature(board: chess.Board) -> float:\n    \"Measures the total number of squares controlled by each player's pieces.\"\n    white_control = sum(1 for move in board.legal_moves if board.piece_at(move.from_square).color == chess.WHITE)\n    black_control = sum(1 for move in board.legal_moves if board.piece_at(move.from_square).color == chess.BLACK)\n    return float(white_control - black_control)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of hanging pieces for the current player.\"\n    hanging_pieces = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == board.turn and not board.is_attacked_by(not board.turn, square):\n            hanging_pieces += 1\n    return float(hanging_pieces)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces on the opponent's back rank that are unprotected.\"\n    unprotected_back_rank = 0\n    for file in range(8):\n        square = chess.square(file, 0 if board.turn == chess.BLACK else 7)\n        piece = board.piece_at(square)\n        if piece and piece.color != board.turn and not board.is_attacked_by(board.turn, square):\n            unprotected_back_rank += 1\n    return float(unprotected_back_rank)", "def feature(board: chess.Board) -> float:\n    \"Measures mobility by calculating the difference in available legal moves between players.\"\n    white_moves = len(list(board.legal_moves)) if board.turn == chess.WHITE else 0\n    black_moves = len(list(board.legal_moves)) if board.turn == chess.BLACK else 0\n    return float(white_moves - black_moves)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces defending the same square.\"\n    defense_count = 0\n    for square in chess.SQUARES:\n        if board.piece_at(square) is not None:\n            defending_pieces = board.attackers(board.piece_at(square).color, square)\n            defense_count += len(defending_pieces)\n    return float(defense_count)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of pieces targeting the opponent's king.\"\n    attacking_king = sum(1 for move in board.legal_moves if board.piece_at(move.from_square).color == board.turn and move.to_square == board.king(not board.turn))\n    return float(attacking_king)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces advanced onto the opponent's side of the board.\"\n    advanced_pieces = sum(1 for square in board.piece_map() if (board.piece_map()[square].color == chess.WHITE and chess.square_rank(square) >= 4) or (board.piece_map()[square].color == chess.BLACK and chess.square_rank(square) <= 3))\n    return float(advanced_pieces)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of pieces that can move in the next turn for each player.\"\n    white_moves = len([move for move in board.legal_moves if board.turn])\n    black_moves = len([move for move in board.legal_moves if not board.turn])\n    return float(white_moves - black_moves)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pawns that are on the 7th rank for both players.\"\n    white_pawns_on_7th = sum(1 for sq in board.piece_map() if board.piece_at(sq).piece_type == chess.PAWN and board.piece_at(sq).color == chess.WHITE and chess.square_rank(sq) == 6)\n    black_pawns_on_7th = sum(1 for sq in board.piece_map() if board.piece_at(sq).piece_type == chess.PAWN and board.piece_at(sq).color == chess.BLACK and chess.square_rank(sq) == 6)\n    return float(white_pawns_on_7th - black_pawns_on_7th)", "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in the number of attackers on key squares (the 4th rank).\"\n    key_squares = [chess.parse_square('a4'), chess.parse_square('b4'), chess.parse_square('c4'), chess.parse_square('d4'), chess.parse_square('e4'), chess.parse_square('f4'), chess.parse_square('g4'), chess.parse_square('h4')]\n    white_attackers = sum(board.is_attacked_by(chess.WHITE, sq) for sq in key_squares)\n    black_attackers = sum(board.is_attacked_by(chess.BLACK, sq) for sq in key_squares)\n    return float(white_attackers - black_attackers)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of pieces each player has in their opponent's half of the board.\"\n    white_pieces_in_opponent_half = sum(1 for sq in board.piece_map() if board.piece_at(sq).color == chess.WHITE and chess.square_rank(sq) > 3)\n    black_pieces_in_opponent_half = sum(1 for sq in board.piece_map() if board.piece_at(sq).color == chess.BLACK and chess.square_rank(sq) < 4)\n    return float(white_pieces_in_opponent_half - black_pieces_in_opponent_half)", "def feature(board: chess.Board) -> float:\n    \"Counts pieces that are on the back rank and adds a penalty for each.\"\n    white_back_rank = sum(1 for sq in range(chess.A1, chess.H1 + 1) if board.piece_at(sq) and board.piece_at(sq).color == chess.WHITE)\n    black_back_rank = sum(1 for sq in range(chess.A8, chess.H8 + 1) if board.piece_at(sq) and board.piece_at(sq).color == chess.BLACK)\n    return float(white_back_rank - black_back_rank)", "def feature(board: chess.Board) -> float:\n    \"Measures the total distance of all pieces from their respective starting positions.\"\n    def starting_distance(piece, square):\n        if piece.color == chess.WHITE:\n            start_rank = 6\n        else:\n            start_rank = 1\n        return chess.square_distance(square, chess.parse_square(chess.square_name(chess.square_file(square) + start_rank)))\n\n    total_distance = sum(starting_distance(piece, square) for square, piece in board.piece_map().items())\n    return float(total_distance)", "def feature(board: chess.Board) -> float:\n    \"Measures the distribution of pawns across ranks.\"\n    pawn_distribution = [0] * 8\n    for sq in board.piece_map():\n        if board.piece_at(sq).piece_type == chess.PAWN:\n            pawn_distribution[chess.square_rank(sq)] += 1\n    return float(max(pawn_distribution) - min(pawn_distribution))", "def feature(board: chess.Board) -> float:\n    \"Evaluates isolation of pawns by counting isolated and connected pawns.\"\n    connected_pawns = 0\n    isolated_pawns = 0\n    \n    for sq in board.piece_map():\n        if board.piece_at(sq).piece_type == chess.PAWN:\n            file = chess.square_file(sq)\n            if (board.piece_at(chess.square(file - 1, chess.square_rank(sq))) and \n                board.piece_at(chess.square(file + 1, chess.square_rank(sq))) and \n                board.piece_at(chess.square(file, chess.square_rank(sq)))): \n                connected_pawns += 1\n            else:\n                isolated_pawns += 1\n    return float(connected_pawns - isolated_pawns)", "def feature(board: chess.Board) -> float:\n    \"Measures king safety by counting the number of pieces around each king.\"\n    white_king_safety = sum(1 for sq in board.attackers(chess.WHITE, board.king(chess.WHITE)) if board.piece_at(sq))\n    black_king_safety = sum(1 for sq in board.attackers(chess.BLACK, board.king(chess.BLACK)) if board.piece_at(sq))\n    return float(white_king_safety - black_king_safety)", "def feature(board: chess.Board) -> float:\n    \"Measures the total number of pieces each player has on the board.\"\n    total_pieces_white = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE)\n    total_pieces_black = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK)\n    return float(total_pieces_white - total_pieces_black)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of legal moves available for the current player.\"\n    return float(len(list(board.legal_moves)))", "def feature(board: chess.Board) -> float:\n    \"Measures the material value lost on the board, logging captured pieces.\"\n    piece_values = {chess.PAWN: 100, chess.KNIGHT: 300, chess.BISHOP: 300,\n                    chess.ROOK: 500, chess.QUEEN: 900, chess.KING: 0}\n    total_material = sum(piece_values[piece.piece_type] for piece in board.piece_map().values())\n    return float(total_material)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of squares attacked by each side.\"\n    attacked_squares_white = sum(board.is_attacked_by(chess.WHITE, square) for square in chess.SQUARES)\n    attacked_squares_black = sum(board.is_attacked_by(chess.BLACK, square) for square in chess.SQUARES)\n    return float(attacked_squares_white - attacked_squares_black)", "def feature(board: chess.Board) -> float:\n    \"Measures how many pawns each side has on the board.\"\n    pawn_count_white = sum(1 for piece in board.piece_map().values() if piece.piece_type == chess.PAWN and piece.color == chess.WHITE)\n    pawn_count_black = sum(1 for piece in board.piece_map().values() if piece.piece_type == chess.PAWN and piece.color == chess.BLACK)\n    return float(pawn_count_white - pawn_count_black)", "def feature(board: chess.Board) -> float:\n    \"Calculates the total mobility of all pieces combined.\"\n    mobility = 0\n    for piece in board.piece_map().values():\n        mobility += len(list(board.legal_moves)) if piece.color == board.turn else 0\n    return float(mobility)", "def feature(board: chess.Board) -> float:\n    \"Evaluates the safety of the kings by counting attackers nearby.\"\n    king_square_white = next((square for square, piece in board.piece_map().items() if piece.color == chess.WHITE and piece.piece_type == chess.KING), None)\n    king_square_black = next((square for square, piece in board.piece_map().items() if piece.color == chess.BLACK and piece.piece_type == chess.KING), None)\n    attackers_white = len(board.attackers(chess.BLACK, king_square_white)) if king_square_white is not None else 0\n    attackers_black = len(board.attackers(chess.WHITE, king_square_black)) if king_square_black is not None else 0\n    return float(attackers_white - attackers_black)", "def feature(board: chess.Board) -> float:\n    \"Measures the distance of each side's pieces to the opponent's king.\"\n    king_square_white = next((square for square, piece in board.piece_map().items() if piece.color == chess.BLACK and piece.piece_type == chess.KING), None)\n    king_square_black = next((square for square, piece in board.piece_map().items() if piece.color == chess.WHITE and piece.piece_type == chess.KING), None)\n    distance_white = sum(chess.square_distance(piece_square, king_square_white) for piece_square in board.piece_map() if board.piece_map()[piece_square].color == chess.WHITE)\n    distance_black = sum(chess.square_distance(piece_square, king_square_black) for piece_square in board.piece_map() if board.piece_map()[piece_square].color == chess.BLACK)\n    return float(distance_black - distance_white)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces that are pinned for each player.\"\n    pinned_pieces_white = sum(1 for square in board.piece_map() if board.piece_map()[square].color == chess.WHITE and board.is_attacked_by(chess.BLACK, square))\n    pinned_pieces_black = sum(1 for square in board.piece_map() if board.piece_map()[square].color == chess.BLACK and board.is_attacked_by(chess.WHITE, square))\n    return float(pinned_pieces_white - pinned_pieces_black)", "def feature(board: chess.Board) -> float:\n    \"Measures the total pawn structure by counting doubled and isolated pawns.\"\n    doubled_pawns = 0\n    isolated_pawns = 0\n    for file in range(8):\n        pawns_on_file = sum(1 for rank in range(8) if board.piece_at(chess.square(file, rank)) == chess.PAWN)\n        if pawns_on_file > 1:\n            doubled_pawns += (pawns_on_file - 1)\n        if pawns_on_file == 1 and all(board.piece_at(chess.square(file + d, rank)) is None \n                                       for d in [-1, 1] for rank in range(8)):\n            isolated_pawns += 1\n    return float(doubled_pawns + isolated_pawns)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of attacking opportunities each side has on the opponent's king.\"\n    white_attacks = sum(1 for move in board.legal_moves if board.is_attacked_by(chess.WHITE, move.to_square) and move.to_square == chess.parse_square('e8'))\n    black_attacks = sum(1 for move in board.legal_moves if board.is_attacked_by(chess.BLACK, move.to_square) and move.to_square == chess.parse_square('e1'))\n    return float(white_attacks - black_attacks)", "def feature(board: chess.Board) -> float:\n    \"Calculates the average distance of all pieces to the opponent's king.\"\n    opponent_king_square = next(square for square, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color != board.turn)\n    total_distance = sum(chess.square_distance(square, opponent_king_square) for square in board.piece_map() if board.piece_map()[square].color == board.turn)\n    piece_count = len([square for square in board.piece_map() if board.piece_map()[square].color == board.turn])\n    return total_distance / piece_count if piece_count > 0 else 0.0", "def feature(board: chess.Board) -> float:\n    \"Measures the number of squares attacked by each player's pieces.\"\n    white_attacks = sum(1 for square in range(64) if board.is_attacked_by(chess.WHITE, square))\n    black_attacks = sum(1 for square in range(64) if board.is_attacked_by(chess.BLACK, square))\n    return float(white_attacks - black_attacks)", "def feature(board: chess.Board) -> float:\n    \"Measures the total value of pieces under attack for each player.\"\n    white_attacked_value = sum(board.piece_map()[square].piece_type for square in range(64) if board.is_attacked_by(chess.WHITE, square) and board.piece_map().get(square))\n    black_attacked_value = sum(board.piece_map()[square].piece_type for square in range(64) if board.is_attacked_by(chess.BLACK, square) and board.piece_map().get(square))\n    return float(white_attacked_value - black_attacked_value)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of connected pawns for each player.\"\n    white_connected = 0\n    black_connected = 0\n    for file in range(8):\n        if board.piece_at(chess.square(file, 1)) == chess.PAWN:\n            if file > 0 and board.piece_at(chess.square(file - 1, 1)) == chess.PAWN:\n                white_connected += 1\n            if file < 7 and board.piece_at(chess.square(file + 1, 1)) == chess.PAWN:\n                white_connected += 1\n        if board.piece_at(chess.square(file, 6)) == chess.PAWN:\n            if file > 0 and board.piece_at(chess.square(file - 1, 6)) == chess.PAWN:\n                black_connected += 1\n            if file < 7 and board.piece_at(chess.square(file + 1, 6)) == chess.PAWN:\n                black_connected += 1\n    return float(white_connected - black_connected)", "def feature(board: chess.Board) -> float:\n    \"Measures the total number of checks and potential threats to the opposing king.\"\n    checks = sum(1 for move in board.legal_moves if board.is_check())\n    threats = sum(1 for square in range(64) if board.is_attacked_by(not board.turn, square) and board.piece_map().get(square) and board.piece_map()[square].piece_type == chess.KING)\n    return float(checks + threats)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of pieces on squares that are generally more valuable (central squares).\"\n    central_squares = {chess.D4, chess.D5, chess.E4, chess.E5}\n    value_in_center = sum(1 for square in board.piece_map() if square in central_squares)\n    return float(value_in_center)", "def feature(board: chess.Board) -> float:\n    \"Counts the pieces that are pinned by the opponent's pieces.\"\n    pinned_pieces = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == board.turn:\n            for attacker in board.attackers(not piece.color, square):\n                if board.piece_at(attacker).piece_type in (chess.ROOK, chess.QUEEN) and board.piece_at(square).piece_type != chess.KING:\n                    pinned_pieces += 1\n                    break\n    return float(pinned_pieces)", "def feature(board: chess.Board) -> float:\n    \"Calculate the total mobility of both players based on the number of legal moves.\"\n    white_moves = len(list(board.legal_moves)) if board.turn else 0\n    black_moves = len(list(board.legal_moves)) if not board.turn else 0\n    return float(white_moves - black_moves)", "def feature(board: chess.Board) -> float:\n    \"Measure the total piece value difference including enforcement of pawn structure.\"\n    piece_value = {chess.PAWN: 100, chess.KNIGHT: 320, chess.BISHOP: 330,\n                   chess.ROOK: 500, chess.QUEEN: 900, chess.KING: 0}\n    white_value = sum(piece_value[piece.piece_type] for piece in board.piece_map().values() if piece.color == chess.WHITE)\n    black_value = sum(piece_value[piece.piece_type] for piece in board.piece_map().values() if piece.color == chess.BLACK)\n    return float(white_value - black_value)", "def feature(board: chess.Board) -> float:\n    \"Count the number of pieces that are positioned on the back rank.\"\n    back_rank_white = sum(1 for sq in range(56, 64) if board.piece_at(sq) and board.piece_at(sq).color == chess.WHITE)\n    back_rank_black = sum(1 for sq in range(0, 8) if board.piece_at(sq) and board.piece_at(sq).color == chess.BLACK)\n    return float(back_rank_white - back_rank_black)", "def feature(board: chess.Board) -> float:\n    \"Evaluate the average distance of all pawns from the promotion rank.\"\n    if board.turn:\n        promotion_rank = 7\n    else:\n        promotion_rank = 0\n\n    pawn_squares = [sq for sq, piece in board.piece_map().items() if piece.piece_type == chess.PAWN]\n    total_distance = sum(abs(chess.square_rank(sq) - promotion_rank) for sq in pawn_squares)\n    \n    return float(total_distance / len(pawn_squares)) if pawn_squares else 0.0", "def feature(board: chess.Board) -> float:\n    \"Measure how many pieces are obstructed or protecting each other.\"\n    obstructed_count = 0\n    protected_count = 0\n    \n    for sq, piece in board.piece_map().items():\n        if piece.color == chess.WHITE:\n            if board.is_attacked_by(chess.BLACK, sq):\n                obstructed_count += 1\n            for attacker in board.attackers(chess.WHITE, sq):\n                if board.is_attacked_by(chess.BLACK, attacker):\n                    protected_count += 1\n\n    return float(protected_count - obstructed_count)", "def feature(board: chess.Board) -> float:\n    \"Measure the number of discovered checks currently available on the board.\"\n    checks_available = 0\n    for move in board.legal_moves:\n        if board.gives_check(move):\n            checks_available += 1\n    return float(checks_available)", "def feature(board: chess.Board) -> float:\n    \"Evaluate the total control over the center squares of the board.\"\n    center_squares = [chess.E4, chess.E5, chess.D4, chess.D5]\n    control = 0\n    for sq in center_squares:\n        if board.is_attacked_by(chess.WHITE, sq):\n            control += 1\n        elif board.is_attacked_by(chess.BLACK, sq):\n            control -= 1\n    return float(control)", "def feature(board: chess.Board) -> float:\n    \"Calculate the number of pieces with less than optimal mobility (pawns on the back rank).\"\n    immobile_pawns = sum(1 for sq in range(48, 56) if board.piece_at(sq) and board.piece_at(sq).piece_type == chess.PAWN)\n    return float(immobile_pawns)", "def feature(board: chess.Board) -> float:\n    \"Measures the safety of the kings based on the number of surrounding attacking pieces.\"\n    white_king_square = board.king(chess.WHITE)\n    black_king_square = board.king(chess.BLACK)\n    white_safety = len(board.attackers(chess.BLACK, white_king_square))\n    black_safety = len(board.attackers(chess.WHITE, black_king_square))\n    return float(black_safety - white_safety)", "def feature(board: chess.Board) -> float:\n    \"Calculates a material value imbalance considering piece types and weights.\"\n    piece_values = {chess.PAWN: 100, chess.KNIGHT: 300, chess.BISHOP: 300, chess.ROOK: 500, chess.QUEEN: 900, chess.KING: 0}\n    material_score = sum(piece_values[piece.piece_type] for piece in board.piece_map().values())\n    return float(material_score)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of double attacks possible (pieces attacking two different targets).\"\n    double_attacks = 0\n    for piece_square in board.piece_map():\n        piece = board.piece_at(piece_square)\n        if piece:\n            attackers = board.attackers(piece.color, piece_square)\n            for target_square in attackers:\n                if board.is_attacked_by(piece.color, target_square):\n                    double_attacks += 1\n    return float(double_attacks)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of pieces on the board and the ratio of strong pieces (ROOK, QUEEN) to weak pieces (PAWN).\"\n    strong_piece_count = sum(1 for piece in board.piece_map().values() if piece.piece_type in {chess.ROOK, chess.QUEEN})\n    weak_piece_count = sum(1 for piece in board.piece_map().values() if piece.piece_type == chess.PAWN)\n    return float(strong_piece_count / (weak_piece_count + 1))  # Prevent division by zero", "def feature(board: chess.Board) -> float:\n    \"Calculates the distance of pieces from their respective back ranks to evaluate piece mobility.\"\n    white_distance = sum(7 - chess.square_rank(sq) for sq in board.piece_map() if board.piece_map()[sq].color == chess.WHITE)\n    black_distance = sum(chess.square_rank(sq) for sq in board.piece_map() if board.piece_map()[sq].color == chess.BLACK)\n    return float(white_distance - black_distance)", "def feature(board: chess.Board) -> float:\n    \"Counts the total number of pieces in the center four squares (d4, d5, e4, e5).\"\n    center_squares = [chess.parse_square(sq) for sq in ['d4', 'd5', 'e4', 'e5']]\n    center_piece_count = sum(1 for sq in center_squares if board.piece_at(sq) is not None)\n    return float(center_piece_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the average number of candidate moves per piece for both players.\"\n    white_moves = sum(len(list(board.legal_moves)) for sq in board.piece_map() if board.piece_map()[sq].color == chess.WHITE)\n    black_moves = sum(len(list(board.legal_moves)) for sq in board.piece_map() if board.piece_map()[sq].color == chess.BLACK)\n    return float(white_moves - black_moves)", "def feature(board: chess.Board) -> float:\n    \"Measures how many pieces are attacking the opponent's king.\"\n    white_king_square = board.king(chess.WHITE)\n    black_king_square = board.king(chess.BLACK)\n    white_king_attacks = len(board.attackers(chess.BLACK, black_king_square))\n    black_king_attacks = len(board.attackers(chess.WHITE, white_king_square))\n    return float(black_king_attacks - white_king_attacks)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of pawns held by each player and their advance toward the opponent's back rank.\"\n    white_pawn_advanced = sum(1 for sq in board.piece_map() if board.piece_map()[sq].piece_type == chess.PAWN and chess.square_rank(sq) > 4)\n    black_pawn_advanced = sum(1 for sq in board.piece_map() if board.piece_map()[sq].piece_type == chess.PAWN and chess.square_rank(sq) < 3)\n    return float(white_pawn_advanced - black_pawn_advanced)", "def feature(board: chess.Board) -> float:\n    \"Evaluates the piece development by counting the number of pieces that have moved off their starting squares.\"\n    initial_positions = {\n        chess.PAWN: {chess.A2, chess.B2, chess.C2, chess.D2, chess.E2, chess.F2, chess.G2, chess.H2},\n        chess.ROOK: {chess.A1, chess.H1, chess.A8, chess.H8},\n        chess.KNIGHT: {chess.B1, chess.G1, chess.B8, chess.G8},\n        chess.BISHOP: {chess.C1, chess.F1, chess.C8, chess.F8},\n        chess.QUEEN: {chess.D1, chess.D8},\n        chess.KING: {chess.E1, chess.E8}\n    }\n    developed_pieces = 0\n    for sq, piece in board.piece_map().items():\n        if sq not in initial_positions[piece.piece_type]:\n            developed_pieces += 1\n    return float(developed_pieces)", "def feature(board: chess.Board) -> float:\n    \"Measures the total piece value controlled by each player.\"\n    piece_values = {chess.PAWN: 100, chess.KNIGHT: 320, chess.BISHOP: 330, chess.ROOK: 500, chess.QUEEN: 900, chess.KING: 0}\n    white_value = sum(piece_values[piece.piece_type] for piece in board.piece_map().values() if piece.color == chess.WHITE)\n    black_value = sum(piece_values[piece.piece_type] for piece in board.piece_map().values() if piece.color == chess.BLACK)\n    return float(white_value - black_value)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces that are pinned.\"\n    pinned_count = 0\n    for square in board.piece_map():\n        piece = board.piece_at(square)\n        if piece and piece.color == board.turn:\n            if any(board.is_attacked_by(not board.turn, target_square) for target_square in board.attackers(piece.color, square)):\n                pinned_count += 1\n    return float(pinned_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the average distance of king safety from potential threats.\"\n    king_square = board.king(board.turn)\n    threat_squares = {attacker for square in board.piece_map() if board.piece_at(square).color != board.turn for attacker in board.attackers(board.turn, square)}\n    if not threat_squares:\n        return 0.0\n    distance_sum = sum(chess.square_distance(king_square, sq) for sq in threat_squares)\n    return float(distance_sum) / len(threat_squares)", "def feature(board: chess.Board) -> float:\n    \"Measures the control of the center squares (e4, e5, d4, d5).\"\n    center_squares = [chess.parse_square('e4'), chess.parse_square('e5'), chess.parse_square('d4'), chess.parse_square('d5')]\n    white_control = sum(1 for sq in center_squares if board.is_attacked_by(chess.WHITE, sq))\n    black_control = sum(1 for sq in center_squares if board.is_attacked_by(chess.BLACK, sq))\n    return float(white_control - black_control)", "def feature(board: chess.Board) -> float:\n    \"Evaluates the number of supported pieces on the board.\"\n    support_count = 0\n    for square in board.piece_map():\n        piece = board.piece_at(square)\n        if piece:\n            for target_square in board.attackers(piece.color, square):\n                if board.piece_at(target_square) and board.piece_at(target_square).color == piece.color:\n                    support_count += 1\n    return float(support_count)", "def feature(board: chess.Board) -> float:\n    \"Computes the number of isolated pawns.\"\n    isolated_count = 0\n    for square in range(8):\n        if board.piece_at(chess.parse_square(f'a{square + 1}')) == chess.PAWN:\n            if not board.piece_at(chess.parse_square(f'b{square + 1}')) and not board.piece_at(chess.parse_square(f'c{square + 1}')):\n                isolated_count += 1\n    return float(isolated_count)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of hanging pieces (not defended).\"\n    hanging_count = 0\n    for square in board.piece_map():\n        piece = board.piece_at(square)\n        if piece and not any(board.is_attacked_by(not piece.color, square) for square in board.attackers(piece.color, square)):\n            hanging_count += 1\n    return float(hanging_count)", "def feature(board: chess.Board) -> float:\n    \"Measures the total piece mobility by counting legal moves for all pieces.\"\n    mobility_count = sum(len(list(board.legal_moves)) for square in board.piece_map())\n    return float(mobility_count)", "def feature(board: chess.Board) -> float:\n    \"Counts the total number of pieces that are in danger (attacked but not defended).\"\n    threatened_count = 0\n    for square in board.piece_map():\n        piece = board.piece_at(square)\n        if piece and len(board.attackers(not piece.color, square)) > 0 and not any(board.is_attacked_by(piece.color, attacker_square) for attacker_square in board.attackers(piece.color, square)):\n            threatened_count += 1\n    return float(threatened_count)", "def feature(board: chess.Board) -> float:\n    \"Evaluates the total number of minor pieces (knights and bishops) remaining for each player.\"\n    minor_count = {chess.WHITE: 0, chess.BLACK: 0}\n    for piece in board.piece_map().values():\n        if piece.piece_type in [chess.KNIGHT, chess.BISHOP]:\n            minor_count[piece.color] += 1\n    return float(minor_count[chess.WHITE] - minor_count[chess.BLACK])", "def feature(board: chess.Board) -> float:\n    \"Measures the control over the center squares (d4, d5, e4, e5) for each player.\"\n    center_squares = [chess.D4, chess.D5, chess.E4, chess.E5]\n    white_control = sum(1 for square in center_squares if board.is_attacked_by(chess.WHITE, square))\n    black_control = sum(1 for square in center_squares if board.is_attacked_by(chess.BLACK, square))\n    return float(white_control - black_control)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces on the back rank for each player.\"\n    back_rank_white = sum(1 for square in range(chess.A1, chess.H1 + 1) if board.piece_at(square) and board.piece_at(square).color == chess.WHITE)\n    back_rank_black = sum(1 for square in range(chess.A8, chess.H8 + 1) if board.piece_at(square) and board.piece_at(square).color == chess.BLACK)\n    return float(back_rank_white - back_rank_black)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of pieces with open files for each player.\"\n    open_files_white = sum(1 for file in range(8) if all(board.piece_at(chess.square(file, rank)) is None for rank in range(1, 8)))\n    open_files_black = sum(1 for file in range(8) if all(board.piece_at(chess.square(file, rank)) is None for rank in range(0, 7)))\n    return float(open_files_white - open_files_black)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of unprotected pieces each player's pieces have.\"\n    unprotected_white = sum(1 for square, piece in board.piece_map().items() if piece.color == chess.WHITE and not board.is_attacked_by(chess.BLACK, square))\n    unprotected_black = sum(1 for square, piece in board.piece_map().items() if piece.color == chess.BLACK and not board.is_attacked_by(chess.WHITE, square))\n    return float(unprotected_white - unprotected_black)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of potential discovered attack opportunities based on piece positions.\"\n    potential_discovered_attacks = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == board.turn:\n            attacks = board.legal_moves\n            for move in attacks:\n                if move.from_square == square and board.piece_at(move.to_square) is not None:\n                    potential_discovered_attacks += 1\n    return float(potential_discovered_attacks)", "def feature(board: chess.Board) -> float:\n    \"Measures the pawn structure by counting doubled pawns for each player.\"\n    doubled_pawns_white = sum(1 for file in range(8) if sum(1 for rank in range(1, 8) if board.piece_at(chess.square(file, rank)) and board.piece_at(chess.square(file, rank)).color == chess.WHITE) > 1)\n    doubled_pawns_black = sum(1 for file in range(8) if sum(1 for rank in range(0, 7) if board.piece_at(chess.square(file, rank)) and board.piece_at(chess.square(file, rank)).color == chess.BLACK) > 1)\n    return float(doubled_pawns_white - doubled_pawns_black)", "def feature(board: chess.Board) -> float:\n    \"Calculates the control of the 7th rank by each player's pawns.\"\n    control_seventh_rank_white = sum(1 for file in range(8) if board.piece_at(chess.square(file, 6)) and board.piece_at(chess.square(file, 6)).color == chess.WHITE)\n    control_seventh_rank_black = sum(1 for file in range(8) if board.piece_at(chess.square(file, 1)) and board.piece_at(chess.square(file, 1)).color == chess.BLACK)\n    return float(control_seventh_rank_white - control_seventh_rank_black)", "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in mobility between both players.\"\n    white_legal_moves = len(list(board.legal_moves)) if board.turn else 0\n    black_legal_moves = len(list(board.legal_moves)) if not board.turn else 0\n    return float(white_legal_moves - black_legal_moves)", "def feature(board: chess.Board) -> float:\n    \"Measures the control of the center squares by counting the pieces attacking them.\"\n    center_squares = [chess.E4, chess.E5, chess.D4, chess.D5]\n    control = 0\n    for sq in center_squares:\n        control += len(board.attackers(chess.WHITE, sq)) - len(board.attackers(chess.BLACK, sq))\n    return float(control)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of doubled pawns for each side and returns the difference.\"\n    white_doubled = 0\n    black_doubled = 0\n    files = {}\n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.PAWN:\n            file = chess.square_file(square)\n            if file not in files:\n                files[file] = 0\n            files[file] += 1\n    \n    for count in files.values():\n        if count > 1:\n            if piece.color == chess.WHITE:\n                white_doubled += count - 1\n            else:\n                black_doubled += count - 1\n\n    return float(white_doubled - black_doubled)", "def feature(board: chess.Board) -> float:\n    \"Measures stability by counting the number of pinned pieces for each side.\"\n    pinned_count = 0\n    for square, piece in board.piece_map().items():\n        if board.is_attacked_by(not piece.color, square) and board.attackers(piece.color, square):\n            pinned_count += 1\n    return float(pinned_count)", "def feature(board: chess.Board) -> float:\n    \"Computes a score based on piece activity by gauging the distance of pieces from the home rank.\"\n    activity_score = 0\n    for square, piece in board.piece_map().items():\n        distance = chess.square_rank(square) if piece.color == chess.WHITE else 7 - chess.square_rank(square)\n        activity_score += distance\n    return float(activity_score)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces with no legal moves available and measures the impact.\"\n    immobile_pieces = sum(1 for square, piece in board.piece_map().items() if len(list(board.legal_moves)) == 0)\n    return float(immobile_pieces)", "def feature(board: chess.Board) -> float:\n    \"Measures the influence of queens on the board based on their attacking potential.\"\n    queen_control = 0\n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.QUEEN:\n            queen_control += len(board.attackers(board.turn, square))\n    return float(queen_control)", "def feature(board: chess.Board) -> float:\n    \"Calculates the total value of pieces for each color.\"\n    value = 0\n    piece_values = {chess.PAWN: 100, chess.KNIGHT: 320, chess.BISHOP: 330, chess.ROOK: 500, chess.QUEEN: 900, chess.KING: 0}\n    for piece in board.piece_map().values():\n        value += piece_values[piece.piece_type] if piece.color == chess.WHITE else -piece_values[piece.piece_type]\n    return float(value)", "def feature(board: chess.Board) -> float:\n    \"Counts the controlled squares by each color.\"\n    controlled_whites = len([square for square in chess.SQUARES if board.is_attacked_by(chess.WHITE, square)])\n    controlled_blacks = len([square for square in chess.SQUARES if board.is_attacked_by(chess.BLACK, square)])\n    return float(controlled_whites - controlled_blacks)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of pieces of each type on the board.\"\n    piece_count = {type: 0 for type in [chess.PAWN, chess.KNIGHT, chess.BISHOP, chess.ROOK, chess.QUEEN, chess.KING]}\n    for piece in board.piece_map().values():\n        piece_count[piece.piece_type] += 1 if piece.color == chess.WHITE else -1\n    total_count = sum(max(0, count) for count in piece_count.values()) - sum(max(0, -count) for count in piece_count.values())\n    return float(total_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of pieces that are pinned.\"\n    pinned = 0\n    for square in chess.SQUARES:\n        piece = board.piece_at(square)\n        if piece and piece.color == board.turn:\n            for attacker in board.attackers(not piece.color, square):\n                if board.is_attacked_by(piece.color, attacker):\n                    pinned += 1\n                    break\n    return float(pinned)", "def feature(board: chess.Board) -> float:\n    \"Checks king safety based on the number of threats to the king's square.\"\n    king_square = next(square for square, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color == board.turn)\n    threats = len(board.attackers(not board.turn, king_square))\n    return float(threats)", "def feature(board: chess.Board) -> float:\n    \"Calculates the distance of pieces from the opposing king.\"\n    opposing_king_square = next(square for square, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color != board.turn)\n    distance_sum = sum(chess.square_distance(square, opposing_king_square) for square in board.piece_map() if board.piece_map()[square].color == board.turn)\n    total_piece_count = len([square for square in board.piece_map() if board.piece_map()[square].color == board.turn])\n    return distance_sum / float(total_piece_count) if total_piece_count > 0 else 0.0", "def feature(board: chess.Board) -> float:\n    \"Measures the number of connected pieces for each color.\"\n    connected_white = 0\n    connected_black = 0\n    for square in chess.SQUARES:\n        piece = board.piece_at(square)\n        if piece:\n            if piece.color == chess.WHITE:\n                if square in board.piece_map():\n                    connected_white += len(board.attackers(chess.WHITE, square))\n            else:\n                if square in board.piece_map():\n                    connected_black += len(board.attackers(chess.BLACK, square))\n    return float(connected_white - connected_black)", "def feature(board: chess.Board) -> float:\n    \"Identifies if the current position is a draw due to lack of material.\"\n    insufficient_material = board.is_insufficient_material()\n    return float(1.0 if insufficient_material else 0.0)", "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in pawn structure, specifically doubled pawns.\"\n    doubled_pawns = 0\n    for file in range(8):\n        pawn_count = sum(1 for rank in range(8) if board.piece_at(chess.square(file, rank)) == chess.PAWN)\n        if pawn_count > 1:\n            doubled_pawns += (pawn_count - 1)\n    return float(doubled_pawns)", "def feature(board: chess.Board) -> float:\n    \"Measures the difference in the number of pawns on the board for each color.\"\n    white_pawns = sum(1 for piece in board.piece_map().values() if piece.piece_type == chess.PAWN and piece.color == chess.WHITE)\n    black_pawns = sum(1 for piece in board.piece_map().values() if piece.piece_type == chess.PAWN and piece.color == chess.BLACK)\n    return float(white_pawns - black_pawns)", "def feature(board: chess.Board) -> float:\n    \"Calculates the total number of pieces remaining for each player.\"\n    total_white = len([piece for piece in board.piece_map().values() if piece.color == chess.WHITE])\n    total_black = len([piece for piece in board.piece_map().values() if piece.color == chess.BLACK])\n    return float(total_white - total_black)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of squares attacked by each color.\"\n    white_attacked = sum(1 for square in chess.SQUARES if board.is_attacked_by(chess.WHITE, square))\n    black_attacked = sum(1 for square in chess.SQUARES if board.is_attacked_by(chess.BLACK, square))\n    return float(white_attacked - black_attacked)", "def feature(board: chess.Board) -> float:\n    \"Measures the king's safety by counting the number of opponent's pieces attacking adjacent squares.\"\n    king_square = board.king(chess.WHITE) if board.turn else board.king(chess.BLACK)\n    unsafe_squares = sum(1 for square in chess.SQUARES if board.is_attacked_by(not board.turn, square) and chess.square_distance(square, king_square) == 1)\n    return float(unsafe_squares)", "def feature(board: chess.Board) -> float:\n    \"Calculates the total number of open files for each side (files without pawns).\"\n    open_files_white = sum(1 for file in range(8) if all(board.piece_at(chess.square(file, rank)) is None for rank in range(7))) \n    open_files_black = sum(1 for file in range(8) if all(board.piece_at(chess.square(file, rank)) is None for rank in range(1, 8)))\n    return float(open_files_white - open_files_black)", "def feature(board: chess.Board) -> float:\n    \"Calculates the connectedness of pawns (number of pawn clusters).\"\n    pawns = [square for square, piece in board.piece_map().items() if piece.piece_type == chess.PAWN]\n    clusters = 0\n    visited = set()\n    \n    for square in pawns:\n        if square not in visited:\n            clusters += 1\n            stack = [square]\n            while stack:\n                current = stack.pop()\n                visited.add(current)\n                neighbors = [chess.square_file(current), chess.square_rank(current)-1, chess.square_rank(current)+1]\n                for file in neighbors:\n                    if chess.square_file(file) != chess.square_file(current):\n                        next_sq = chess.square(file, chess.square_rank(current))\n                        if next_sq in pawns and next_sq not in visited:\n                            stack.append(next_sq)\n    return float(clusters)", "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in mobility of pieces by counting legal moves.\"\n    mobile_white = len(list(board.legal_moves)) if board.turn else 0\n    mobile_black = len(list(board.legal_moves)) if not board.turn else 0\n    return float(mobile_white - mobile_black)", "def feature(board: chess.Board) -> float:\n    \"Estimates the potential of piece activity by counting pieces on the fifth rank and above.\"\n    active_white = len([1 for square in chess.SQUARES if board.piece_at(square) and board.piece_at(square).color == chess.WHITE and chess.square_rank(square) >= 4])\n    active_black = len([1 for square in chess.SQUARES if board.piece_at(square) and board.piece_at(square).color == chess.BLACK and chess.square_rank(square) <= 3])\n    return float(active_white - active_black)", "def feature(board: chess.Board) -> float:\n    \"Measures the symmetry of the board position, indicating strategic balance.\"\n    piece_counts = [0] * 8  # Counts for each file\n    for square in chess.SQUARES:\n        piece = board.piece_at(square)\n        if piece:\n            piece_counts[chess.square_file(square)] += 1\n    symmetry = sum((1 if piece_counts[i] == piece_counts[7-i] else 0) for i in range(4))\n    return float(symmetry)", "def feature(board: chess.Board) -> float:\n    \"Measures the total mobility of all pieces by counting the number of legal moves.\"\n    mobility = sum(len(list(board.legal_moves)) for square in board.piece_map())\n    return float(mobility)", "def feature(board: chess.Board) -> float:\n    \"Calculates the value based on the distance of the kings from the center of the board.\"\n    white_king = board.king(chess.WHITE)\n    black_king = board.king(chess.BLACK)\n    distance = chess.square_distance(white_king, chess.E4) + chess.square_distance(black_king, chess.E4)\n    return float(distance)", "def feature(board: chess.Board) -> float:\n    \"Measures the control of central squares by counting pieces that attack them.\"\n    center_squares = [chess.D4, chess.D5, chess.E4, chess.E5]\n    white_control = sum(1 for sq in center_squares if board.is_attacked_by(chess.WHITE, sq))\n    black_control = sum(1 for sq in center_squares if board.is_attacked_by(chess.BLACK, sq))\n    return float(white_control - black_control)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces that are pinned (unable to move without exposing the king).\"\n    pinned_count = sum(1 for square, piece in board.piece_map().items() if board.is_check() and board.attackers(piece.color, square))\n    return float(pinned_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in piece development by counting pieces on the back rank.\"\n    white_back_rank = sum(1 for square in board.piece_map() if board.piece_at(square).color == chess.WHITE and chess.square_rank(square) == 0)\n    black_back_rank = sum(1 for square in board.piece_map() if board.piece_at(square).color == chess.BLACK and chess.square_rank(square) == 7)\n    return float(white_back_rank - black_back_rank)", "def feature(board: chess.Board) -> float:\n    \"Measures the overall piece activity by calculating the distance of pieces from their starting positions.\"\n    activity = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == chess.WHITE:\n            activity += chess.square_distance(square, piece.piece_type)\n        else:\n            activity -= chess.square_distance(square, piece.piece_type)\n    return float(activity)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of squares controlled by each player's pieces.\"\n    white_control = 0\n    black_control = 0\n    for square in chess.SQUARES:\n        if board.is_attacked_by(chess.WHITE, square):\n            white_control += 1\n        if board.is_attacked_by(chess.BLACK, square):\n            black_control += 1\n    return white_control - black_control", "def feature(board: chess.Board) -> float:\n    \"Counts the total number of pieces each side has on the board and returns their difference.\"\n    white_count = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE)\n    black_count = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK)\n    return float(white_count - black_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the total value of pieces for each player.\"\n    piece_values = {chess.PAWN: 100, chess.KNIGHT: 320, chess.BISHOP: 330,\n                    chess.ROOK: 500, chess.QUEEN: 900, chess.KING: 0}\n    white_value = sum(piece_values[piece.piece_type] for piece in board.piece_map().values() if piece.color == chess.WHITE)\n    black_value = sum(piece_values[piece.piece_type] for piece in board.piece_map().values() if piece.color == chess.BLACK)\n    return float(white_value - black_value)", "def feature(board: chess.Board) -> float:\n    \"Measures the distance from the enemy king for all pieces, giving a sense of aggression.\"\n    white_king_square = next(square for square in board.piece_map() if board.piece_map()[square].color == chess.WHITE and board.piece_map()[square].piece_type == chess.KING)\n    distance_sum = sum(chess.square_distance(white_king_square, square) for square in board.piece_map() if board.piece_map()[square].color == chess.BLACK)\n    return float(distance_sum)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of pieces each player is currently threatening.\"\n    white_threats = sum(len(board.attackers(chess.WHITE, square)) for square in board.piece_map() if board.piece_map()[square].color == chess.WHITE)\n    black_threats = sum(len(board.attackers(chess.BLACK, square)) for square in board.piece_map() if board.piece_map()[square].color == chess.BLACK)\n    return float(white_threats - black_threats)", "def feature(board: chess.Board) -> float:\n    \"Measures the mobility of both players by counting legal moves.\"\n    white_legal_moves = len(list(board.legal_moves)) if board.turn else 0\n    black_legal_moves = len(list(board.legal_moves)) if not board.turn else 0\n    return float(white_legal_moves - black_legal_moves)", "def feature(board: chess.Board) -> float:\n    \"Checks for check possibly attacking the enemy king, returning the difference.\"\n    white_in_check = 1.0 if board.is_check() and board.turn else 0.0\n    black_in_check = 1.0 if board.is_check() and not board.turn else 0.0\n    return white_in_check - black_in_check", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of unprotected pieces for each side.\"\n    white_unprotected = sum(1 for square in board.piece_map() if board.piece_map()[square].color == chess.WHITE and not board.attackers(chess.BLACK, square))\n    black_unprotected = sum(1 for square in board.piece_map() if board.piece_map()[square].color == chess.BLACK and not board.attackers(chess.WHITE, square))\n    return float(white_unprotected - black_unprotected)", "def feature(board: chess.Board) -> float:\n    \"Measures the difference in mobility of both players by counting legal moves.\"\n    white_moves = len(list(board.legal_moves)) if board.turn else 0\n    black_moves = len(list(board.legal_moves)) if not board.turn else 0\n    result = float(white_moves - black_moves)\n    return result", "def feature(board: chess.Board) -> float:\n    \"Calculates the king's safety by checking the number of attacking pieces on its square.\"\n    king_square = next(sq for sq, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color == (chess.WHITE if board.turn else chess.BLACK))\n    result = float(len(board.attackers(chess.WHITE if board.turn else chess.BLACK, king_square)))\n    return result", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pawns on the board for each player and returns their difference.\"\n    white_pawns = sum(1 for piece in board.piece_map().values() if piece.piece_type == chess.PAWN and piece.color == chess.WHITE)\n    black_pawns = sum(1 for piece in board.piece_map().values() if piece.piece_type == chess.PAWN and piece.color == chess.BLACK)\n    result = float(white_pawns - black_pawns)\n    return result", "def feature(board: chess.Board) -> float:\n    \"Evaluates the control of the center squares by counting pieces in central positions.\"\n    center_squares = [chess.D4, chess.D5, chess.E4, chess.E5]\n    white_control = sum(1 for sq in center_squares if board.piece_at(sq) and board.piece_at(sq).color == chess.WHITE)\n    black_control = sum(1 for sq in center_squares if board.piece_at(sq) and board.piece_at(sq).color == chess.BLACK)\n    result = float(white_control - black_control)\n    return result", "def feature(board: chess.Board) -> float:\n    \"Measures the distance between the kings of both players.\"\n    white_king_square = next(sq for sq, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color == chess.WHITE)\n    black_king_square = next(sq for sq, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color == chess.BLACK)\n    result = float(chess.square_distance(white_king_square, black_king_square))\n    return result", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces on the 7th rank for each player and returns the difference.\"\n    white_seventh_rank = sum(1 for sq in range(chess.A7, chess.H7 + 1) if board.piece_at(sq) and board.piece_at(sq).color == chess.WHITE)\n    black_seventh_rank = sum(1 for sq in range(chess.A2, chess.H2 + 1) if board.piece_at(sq) and board.piece_at(sq).color == chess.BLACK)\n    result = float(white_seventh_rank - black_seventh_rank)\n    return result", "def feature(board: chess.Board) -> float:\n    \"Measures the total distance of all pieces from their starting positions.\"\n    total_distance = sum(chess.square_distance(start_square, square) for square, piece in board.piece_map().items() for start_square in [piece.piece_type + piece.color * 8]) \n    result = float(total_distance)\n    return result", "def feature(board: chess.Board) -> float:\n    \"Assesses the number of threats on opposite pieces by counting attackers.\"\n    threats = sum(len(board.attackers(piece.color, sq)) for sq, piece in board.piece_map().items() if piece.color != board.turn)\n    result = float(threats)\n    return result", "def feature(board: chess.Board) -> float:\n    \"Calculates how many pieces are unprotected for each player.\"\n    white_unprotected = sum(1 for sq, piece in board.piece_map().items() if piece.color == chess.WHITE and not board.is_attacked_by(chess.BLACK, sq))\n    black_unprotected = sum(1 for sq, piece in board.piece_map().items() if piece.color == chess.BLACK and not board.is_attacked_by(chess.WHITE, sq))\n    result = float(white_unprotected - black_unprotected)\n    return result", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces that can influence the outcome of the game (pieces near the opponent's king).\"\n    influential_count = 0\n    opponent_king_square = next((sq for sq, p in board.piece_map().items() if p.piece_type == chess.KING and p.color != board.turn), None)\n    if opponent_king_square:\n        for square, piece in board.piece_map().items():\n            if piece.color == board.turn and chess.square_distance(square, opponent_king_square) <= 2:\n                influential_count += 1\n    return float(influential_count)", "def feature(board: chess.Board) -> float:\n    \"Measures the 'activity' of the pieces by counting the number of legal moves available.\"\n    return float(len(list(board.legal_moves)))", "def feature(board: chess.Board) -> float:\n    \"Calculates the distance to the opponent's king for the nearest piece.\"\n    opponent_king_square = next((sq for sq, p in board.piece_map().items() if p.piece_type == chess.KING and p.color != board.turn), None)\n    if opponent_king_square is None:\n        return float('inf')\n    \n    min_distance = float('inf')\n    for square, piece in board.piece_map().items():\n        if piece.color == board.turn:\n            distance = chess.square_distance(square, opponent_king_square)\n            min_distance = min(min_distance, distance)\n    return float(min_distance)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of pawns that are passed and can promote.\"\n    passed_pawn_count = 0\n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.PAWN and piece.color == board.turn:\n            file = chess.square_file(square)\n            rank = chess.square_rank(square)\n            if all(board.piece_at(chess.square(file, r)) is None for r in range(rank + 1, 8) if piece.color == chess.WHITE) or \\\n               all(board.piece_at(chess.square(file, r)) is None for r in range(rank - 1, -1, -1) if piece.color == chess.BLACK):\n                passed_pawn_count += 1\n    return float(passed_pawn_count)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of opposing pieces that are under attack.\"\n    attacked_count = 0\n    for square, piece in board.piece_map().items():\n        if piece.color != board.turn and board.is_attacked_by(board.turn, square):\n            attacked_count += 1\n    return float(attacked_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the material advantage based on the values of pieces on the board.\"\n    material_value = 0\n    piece_values = {chess.PAWN: 100, chess.KNIGHT: 320, chess.BISHOP: 330, chess.ROOK: 500, chess.QUEEN: 900, chess.KING: 20000}\n    for square, piece in board.piece_map().items():\n        value = piece_values[piece.piece_type]\n        if piece.color == board.turn:\n            material_value += value\n        else:\n            material_value -= value\n    return float(material_value)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of pieces currently pinned to their own king.\"\n    pinned_count = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == board.turn:\n            attackers = board.attackers(not piece.color, square)\n            if any(board.is_attacked_by(not piece.color, piece_square) for piece_square in attackers):\n                pinned_count += 1\n    return float(pinned_count)", "def feature(board: chess.Board) -> float:\n    \"Measures the difference in control of the center squares.\"\n    center_squares = [chess.E4, chess.E5, chess.D4, chess.D5]\n    white_control = sum(1 for sq in center_squares if board.is_attacked_by(chess.WHITE, sq))\n    black_control = sum(1 for sq in center_squares if board.is_attacked_by(chess.BLACK, sq))\n    return float(white_control - black_control)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of checks available for each player.\"\n    checks_white = sum(1 for move in board.legal_moves if move.to_square in board.attackers(chess.WHITE, move.from_square))\n    checks_black = sum(1 for move in board.legal_moves if move.to_square in board.attackers(chess.BLACK, move.from_square))\n    return float(checks_white - checks_black)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pawns on the 7th rank for both players.\"\n    pawns_white_7th = sum(1 for square in board.piece_map() if board.piece_at(square).color == chess.WHITE and chess.square_rank(square) == 6)\n    pawns_black_7th = sum(1 for square in board.piece_map() if board.piece_at(square).color == chess.BLACK and chess.square_rank(square) == 1)\n    return float(pawns_white_7th - pawns_black_7th)", "def feature(board: chess.Board) -> float:\n    \"Measures the total distance of all pieces from their respective back ranks.\"\n    distance_white = sum(chess.square_rank(square) for square in board.piece_map() if board.piece_at(square).color == chess.WHITE)\n    distance_black = sum(7 - chess.square_rank(square) for square in board.piece_map() if board.piece_at(square).color == chess.BLACK)\n    return float(distance_white - distance_black)", "def feature(board: chess.Board) -> float:\n    \"Counts how many pieces are on the back ranks for each player.\"\n    back_rank_white = sum(1 for square in range(0, 8) if board.piece_at(chess.square(square, 0)) is not None and board.piece_at(chess.square(square, 0)).color == chess.WHITE)\n    back_rank_black = sum(1 for square in range(0, 8) if board.piece_at(chess.square(square, 7)) is not None and board.piece_at(chess.square(square, 7)).color == chess.BLACK)\n    return float(back_rank_white - back_rank_black)", "def feature(board: chess.Board) -> float:\n    \"Measures the mobility of each side by counting legal moves.\"\n    mobility_white = len(list(board.legal_moves) if board.turn == chess.WHITE else [])\n    mobility_black = len(list(board.legal_moves) if board.turn == chess.BLACK else [])\n    return float(mobility_white - mobility_black)", "def feature(board: chess.Board) -> float:\n    \"Measures the difference in the number of connected pawns for each player.\"\n    def count_connected_pawns(color):\n        connected = 0\n        pawns = [square for square in board.piece_map() if board.piece_at(square).color == color and board.piece_at(square).piece_type == chess.PAWN]\n        for square in pawns:\n            if (chess.square_file(square) - 1) in {chess.square_file(p) for p in pawns}:\n                connected += 1\n            if (chess.square_file(square) + 1) in {chess.square_file(p) for p in pawns}:\n                connected += 1\n        return connected\n\n    connected_white = count_connected_pawns(chess.WHITE)\n    connected_black = count_connected_pawns(chess.BLACK)\n    return float(connected_white - connected_black)", "def feature(board: chess.Board) -> float:\n    \"Measures the control of key squares in the center by both players.\"\n    key_center_squares = [chess.parse_square('d4'), chess.parse_square('d5'), chess.parse_square('e4'), chess.parse_square('e5')]\n    control_white = sum(1 for square in key_center_squares if board.is_attacked_by(chess.WHITE, square))\n    control_black = sum(1 for square in key_center_squares if board.is_attacked_by(chess.BLACK, square))\n    return float(control_white - control_black)", "def feature(board: chess.Board) -> float:\n    \"Measures the distance of the closest king to the center of the board.\"\n    white_king = board.king(chess.WHITE)\n    black_king = board.king(chess.BLACK)\n    center_square = chess.parse_square('e4')  # Center square\n    white_distance = chess.square_distance(white_king, center_square)\n    black_distance = chess.square_distance(black_king, center_square)\n    return float(black_distance - white_distance)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pawns for each side and returns their difference.\"\n    white_pawns = len([p for p in board.piece_map().values() if p.color == chess.WHITE and p.piece_type == chess.PAWN])\n    black_pawns = len([p for p in board.piece_map().values() if p.color == chess.BLACK and p.piece_type == chess.PAWN])\n    return float(white_pawns - black_pawns)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of pieces that are in opponent's territory.\"\n    white_pieces_in_enemy_territory = len([p for s, p in board.piece_map().items() if p.color == chess.WHITE and chess.square_rank(s) > 4])\n    black_pieces_in_enemy_territory = len([p for s, p in board.piece_map().items() if p.color == chess.BLACK and chess.square_rank(s) < 4])\n    return float(white_pieces_in_enemy_territory - black_pieces_in_enemy_territory)", "def feature(board: chess.Board) -> float:\n    \"Calculates the material value of pieces attacking the opponent's king.\"\n    opponent_king_square = board.king(chess.BLACK) if board.turn else board.king(chess.WHITE)\n    attacking_pieces_value = sum(piece.piece_type for sq, piece in board.piece_map().items() if board.is_attacked_by(chess.WHITE if board.turn else chess.BLACK, sq) and sq != opponent_king_square)\n    return float(attacking_pieces_value)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of defender pieces around each player's king.\"\n    white_king = board.king(chess.WHITE)\n    black_king = board.king(chess.BLACK)\n    white_defenders = len(board.attackers(chess.WHITE, white_king))\n    black_defenders = len(board.attackers(chess.BLACK, black_king))\n    return float(white_defenders - black_defenders)", "def feature(board: chess.Board) -> float:\n    \"Calculates the total value of pieces on the back rank for each side.\"\n    white_back_rank = sum(piece.piece_type for sq, piece in board.piece_map().items() if chess.square_rank(sq) == 0 and piece.color == chess.WHITE)\n    black_back_rank = sum(piece.piece_type for sq, piece in board.piece_map().items() if chess.square_rank(sq) == 7 and piece.color == chess.BLACK)\n    return float(white_back_rank - black_back_rank)", "def feature(board: chess.Board) -> float:\n    \"Measures the diagonal control of the board for both players.\"\n    white_diagonal_control = sum(1 for sq in chess.SQUARES if board.is_attacked_by(chess.WHITE, sq) and (chess.square_file(sq) - chess.square_rank(sq)) in [-1, 0, 1])\n    black_diagonal_control = sum(1 for sq in chess.SQUARES if board.is_attacked_by(chess.BLACK, sq) and (chess.square_file(sq) - chess.square_rank(sq)) in [-1, 0, 1])\n    return float(white_diagonal_control - black_diagonal_control)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of pieces on the board for each player.\"\n    white_pieces = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE)\n    black_pieces = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK)\n    return float(white_pieces - black_pieces)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pawns on the board for each player.\"\n    white_pawns = len([piece for piece in board.piece_map().values() if piece.color == chess.WHITE and piece.piece_type == chess.PAWN])\n    black_pawns = len([piece for piece in board.piece_map().values() if piece.color == chess.BLACK and piece.piece_type == chess.PAWN])\n    return float(white_pawns - black_pawns)", "def feature(board: chess.Board) -> float:\n    \"Calculates the average distance of pieces from the center of the board.\"\n    center_square = chess.parse_square('e4')\n    total_distance = 0\n    piece_count = 0\n    for square, piece in board.piece_map().items():\n        total_distance += chess.square_distance(square, center_square)\n        piece_count += 1\n    return total_distance / piece_count if piece_count > 0 else 0.0", "def feature(board: chess.Board) -> float:\n    \"Measures the difference between the number of safe squares for each player's king.\"\n    white_king_square = next(square for square, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color == chess.WHITE)\n    black_king_square = next(square for square, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color == chess.BLACK)\n\n    white_safe_squares = sum(1 for sq in chess.SQUARES if not board.is_attacked_by(chess.BLACK, sq) and board.piece_at(sq) is None)\n    black_safe_squares = sum(1 for sq in chess.SQUARES if not board.is_attacked_by(chess.WHITE, sq) and board.piece_at(sq) is None)\n    \n    return float(white_safe_squares - black_safe_squares)", "def feature(board: chess.Board) -> float:\n    \"Measures the proximity of kings to their opponent's pieces.\"\n    white_king_square = next(square for square, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color == chess.WHITE)\n    black_king_square = next(square for square, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color == chess.BLACK)\n\n    distance_to_opponent_pieces = sum(chess.square_distance(white_king_square, square) \n                                       for square in board.piece_map() if board.piece_at(square).color == chess.BLACK)\n    return float(distance_to_opponent_pieces)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of minor pieces (knights and bishops) for each player.\"\n    white_minor_pieces = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE and piece.piece_type in [chess.KNIGHT, chess.BISHOP])\n    black_minor_pieces = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK and piece.piece_type in [chess.KNIGHT, chess.BISHOP])\n    return float(white_minor_pieces - black_minor_pieces)", "def feature(board: chess.Board) -> float:\n    \"Measures the average rank of pawns for each player, indicating pawn structure.\"\n    white_pawn_ranks = [chess.square_rank(square) for square, piece in board.piece_map().items() if piece.color == chess.WHITE and piece.piece_type == chess.PAWN]\n    black_pawn_ranks = [chess.square_rank(square) for square, piece in board.piece_map().items() if piece.color == chess.BLACK and piece.piece_type == chess.PAWN]\n\n    white_avg_rank = sum(white_pawn_ranks) / len(white_pawn_ranks) if white_pawn_ranks else 0.0\n    black_avg_rank = sum(black_pawn_ranks) / len(black_pawn_ranks) if black_pawn_ranks else 0.0\n\n    return float(white_avg_rank - black_avg_rank)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of pawns remaining for each side.\"\n    white_pawns = sum(1 for p in board.piece_map().values() if p.piece_type == chess.PAWN and p.color == chess.WHITE)\n    black_pawns = sum(1 for p in board.piece_map().values() if p.piece_type == chess.PAWN and p.color == chess.BLACK)\n    return float(white_pawns - black_pawns)", "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in control of the center squares (d4, e4, d5, e5).\"\n    center_squares = [chess.parse_square('d4'), chess.parse_square('e4'), chess.parse_square('d5'), chess.parse_square('e5')]\n    white_control = sum(1 for sq in center_squares if board.is_attacked_by(chess.WHITE, sq))\n    black_control = sum(1 for sq in center_squares if board.is_attacked_by(chess.BLACK, sq))\n    return float(white_control - black_control)", "def feature(board: chess.Board) -> float:\n    \"Measures the distance of the closest king from the back rank (1 for White, 8 for Black).\"\n    white_king_square = next((sq for sq, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color == chess.WHITE), None)\n    black_king_square = next((sq for sq, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color == chess.BLACK), None)\n    white_distance = chess.square_rank(white_king_square) if white_king_square is not None else 8\n    black_distance = 8 - chess.square_rank(black_king_square) if black_king_square is not None else 8\n    return float(white_distance - black_distance)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces attacking each king and assesses safety.\"\n    white_king_square = next((sq for sq, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color == chess.WHITE), None)\n    black_king_square = next((sq for sq, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color == chess.BLACK), None)\n    white_attacks = len(board.attackers(chess.WHITE, black_king_square)) if black_king_square else 0\n    black_attacks = len(board.attackers(chess.BLACK, white_king_square)) if white_king_square else 0\n    return float(white_attacks - black_attacks)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of legal moves available for both players.\"\n    white_moves = len(list(board.legal_moves)) if board.turn else 0\n    board.turn = not board.turn\n    black_moves = len(list(board.legal_moves)) if not board.turn else 0\n    board.turn = not board.turn  # Reset turn\n    return float(white_moves - black_moves)", "def feature(board: chess.Board) -> float:\n    \"Calculates the sum of piece values for pieces on the back rank.\"\n    back_rank = range(chess.A8, chess.H8 + 1) if board.turn == chess.BLACK else range(chess.A1, chess.H1 + 1)\n    piece_values = {chess.PAWN: 100, chess.KNIGHT: 320, chess.BISHOP: 330, chess.ROOK: 500, chess.QUEEN: 900, chess.KING: 0}\n    total_value = sum(piece_values[board.piece_at(sq).piece_type] for sq in back_rank if board.piece_at(sq) is not None)\n    return float(total_value)", "def feature(board: chess.Board) -> float:\n    \"Assesses the alignment of major pieces (rooks and queens) on open files.\"\n    open_files = {file: True for file in range(8)}\n    for file in range(8):\n        for rank in range(8):\n            piece = board.piece_at(chess.square(file, rank))\n            if piece is not None:\n                if piece.piece_type in (chess.ROOK, chess.QUEEN):\n                    open_files[file] = False  # Not an open file if piece present\n    return float(sum(1 for v in open_files.values() if v))  # Number of open files", "def feature(board: chess.Board) -> float:\n    \"Measures the material imbalance ratio between minor pieces (knights and bishops).\"\n    white_bishops = sum(1 for p in board.piece_map().values() if p.piece_type == chess.BISHOP and p.color == chess.WHITE)\n    white_knights = sum(1 for p in board.piece_map().values() if p.piece_type == chess.KNIGHT and p.color == chess.WHITE)\n    black_bishops = sum(1 for p in board.piece_map().values() if p.piece_type == chess.BISHOP and p.color == chess.BLACK)\n    black_knights = sum(1 for p in board.piece_map().values() if p.piece_type == chess.KNIGHT and p.color == chess.BLACK)\n    \n    white_imblance = (white_bishops - white_knights) / (white_bishops + white_knights + 1e-5)  # add small epsilon to avoid division by zero\n    black_imblance = (black_bishops - black_knights) / (black_bishops + black_knights + 1e-5)\n    return float(white_imblance - black_imblance)", "def feature(board: chess.Board) -> float:\n    \"Measures material imbalance based on the difference in the number of pawns.\"\n    white_pawns = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE and piece.piece_type == chess.PAWN)\n    black_pawns = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK and piece.piece_type == chess.PAWN)\n    return float(white_pawns - black_pawns)", "def feature(board: chess.Board) -> float:\n    \"Calculates the total mobility of pieces for both sides.\"\n    white_mobility = sum(len(list(board.legal_moves)) for square, piece in board.piece_map().items() if piece.color == chess.WHITE)\n    black_mobility = sum(len(list(board.legal_moves)) for square, piece in board.piece_map().items() if piece.color == chess.BLACK)\n    return float(white_mobility - black_mobility)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces in aggressive positions (attacking opponent pieces).\"\n    aggressive_count = sum(1 for square, piece in board.piece_map().items() if piece.color == board.turn and board.attackers(not piece.color, square))\n    return float(aggressive_count)", "def feature(board: chess.Board) -> float:\n    \"Measures the distance of the closest king to the center of the board.\"\n    white_king_square = next(square for square, piece in board.piece_map().items() if piece.color == chess.WHITE and piece.piece_type == chess.KING)\n    black_king_square = next(square for square, piece in board.piece_map().items() if piece.color == chess.BLACK and piece.piece_type == chess.KING)\n    center_square = chess.square_name(chess.E4)\n\n    white_distance = chess.square_distance(white_king_square, chess.E4)\n    black_distance = chess.square_distance(black_king_square, chess.E4)\n\n    return float(white_distance - black_distance)", "def feature(board: chess.Board) -> float:\n    \"Calculates the value of pieces based on their positions (e.g., center control).\"\n    central_control_value = 0\n    center_squares = [chess.D4, chess.D5, chess.E4, chess.E5]\n    for square in center_squares:\n        if board.piece_at(square):\n            piece = board.piece_at(square)\n            if piece.color == chess.WHITE:\n                central_control_value += piece.piece_type\n            else:\n                central_control_value -= piece.piece_type\n    return float(central_control_value)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of pieces for each player that are attacking the opponent's king.\"\n    white_attackers = sum(1 for square in board.piece_map() if board.is_attacked_by(chess.WHITE, square) and board.piece_at(square).piece_type != chess.KING)\n    black_attackers = sum(1 for square in board.piece_map() if board.is_attacked_by(chess.BLACK, square) and board.piece_at(square).piece_type != chess.KING)\n    return float(white_attackers - black_attackers)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of isolated pawns for both players.\"\n    def count_isolated_pawns(color):\n        count = 0\n        for square in range(chess.A2, chess.H7):\n            piece = board.piece_at(square)\n            if piece and piece.color == color and piece.piece_type == chess.PAWN:\n                file = chess.square_file(square)\n                if (board.piece_at(chess.square(file - 1, chess.square_rank(square))) is None and\n                        board.piece_at(chess.square(file + 1, chess.square_rank(square))) is None):\n                    count += 1\n        return count\n\n    isolated_white = count_isolated_pawns(chess.WHITE)\n    isolated_black = count_isolated_pawns(chess.BLACK)\n    return float(isolated_white - isolated_black)", "def feature(board: chess.Board) -> float:\n    \"Measures the efficiency of piece development (pieces on the back rank).\"\n    back_rank_white = sum(1 for square in range(chess.A8, chess.H8) if board.piece_at(square) and board.piece_at(square).color == chess.WHITE)\n    back_rank_black = sum(1 for square in range(chess.A1, chess.H1) if board.piece_at(square) and board.piece_at(square).color == chess.BLACK)\n    return float(back_rank_white - back_rank_black)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of checks available to the current player.\"\n    checks_available = sum(1 for move in board.legal_moves if board.gives_check(move))\n    return float(checks_available)", "def feature(board: chess.Board) -> float:\n    \"Measures the material balance for the most valuable piece of each side.\"\n    white_material = sum(piece.piece_type for piece in board.piece_map().values() if piece.color == chess.WHITE)\n    black_material = sum(piece.piece_type for piece in board.piece_map().values() if piece.color == chess.BLACK)\n    return float(white_material - black_material)", "def feature(board: chess.Board) -> float:\n    \"Counts the total number of pieces for each player and returns the ratio of pieces on the board.\"\n    piece_count_white = len([p for p in board.piece_map().values() if p.color == chess.WHITE])\n    piece_count_black = len([p for p in board.piece_map().values() if p.color == chess.BLACK])\n    return float(piece_count_white / (piece_count_black + 1))  # Avoid division by zero", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of available legal moves for both players and returns their difference.\"\n    legal_moves_white = len(list(board.legal_moves)) if board.turn else 0\n    board.push(chess.Move.null())  # Ensure we remain in the same state\n    board.turn = not board.turn  # Switch to the other player\n    legal_moves_black = len(list(board.legal_moves))\n    board.pop()  # Undo the switch\n    return float(legal_moves_white - legal_moves_black)", "def feature(board: chess.Board) -> float:\n    \"Checks if a player's king is in check and returns a weighted score based on severity.\"\n    if board.is_check():\n        if board.turn:\n            return -1.0  # White is in check\n        else:\n            return 1.0  # Black is in check\n    return 0.0", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pawns on the board and returns a ratio of pawn presence.\"\n    pawn_count_white = len([p for p in board.piece_map().values() if p.color == chess.WHITE and p.piece_type == chess.PAWN])\n    pawn_count_black = len([p for p in board.piece_map().values() if p.color == chess.BLACK and p.piece_type == chess.PAWN])\n    total_pawns = pawn_count_white + pawn_count_black\n    return float(pawn_count_white / (total_pawns + 1))  # Avoid division by zero", "def feature(board: chess.Board) -> float:\n    \"Measures the number of squares attacked by each player.\"\n    attacked_squares_white = len([sq for sq in range(64) if board.is_attacked_by(chess.WHITE, sq)])\n    attacked_squares_black = len([sq for sq in range(64) if board.is_attacked_by(chess.BLACK, sq)])\n    return float(attacked_squares_white - attacked_squares_black)", "def feature(board: chess.Board) -> float:\n    \"Measures overall piece activity based on mobility of all pieces.\"\n    mobility_score = 0.0\n    for move in board.legal_moves:\n        mobility_score += 1.0  # Each legal move adds to mobility\n    return float(mobility_score)", "def feature(board: chess.Board) -> float:\n    \"Calculates the total number of checks available considering pieces that can give check.\"\n    checking_moves = 0\n    for move in board.legal_moves:\n        if move.to_square in [sq for sq in chess.SQUARES if board.is_attacked_by(board.turn, sq)]:\n            checking_moves += 1\n    return float(checking_moves)", "def feature(board: chess.Board) -> float:\n    \"Measures the distance of the kings to each other in terms of squares.\"\n    white_king_square = next((sq for sq, piece in board.piece_map().items() if piece.color == chess.WHITE and piece.piece_type == chess.KING), None)\n    black_king_square = next((sq for sq, piece in board.piece_map().items() if piece.color == chess.BLACK and piece.piece_type == chess.KING), None)\n    if white_king_square is not None and black_king_square is not None:\n        return float(chess.square_distance(white_king_square, black_king_square))\n    return 0.0  # Return 0 if either king is not present", "def feature(board: chess.Board) -> float:\n    \"Calculates the central control by counting pieces on central squares.\"\n    central_squares = [chess.D4, chess.D5, chess.E4, chess.E5]\n    control_count = sum(1 for sq in central_squares if board.piece_at(sq) and board.piece_at(sq).color == (chess.WHITE if board.turn else chess.BLACK))\n    return float(control_count)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of doubled pawns for both sides.\"\n    doubled_pawns = 0\n    pawns = [chess.PAWN]\n    for file in range(8):\n        if any(board.piece_at(chess.square(file, rank)) in pawns for rank in range(8)):\n            if sum(board.piece_at(chess.square(file, rank)).color == chess.WHITE for rank in range(8)) > 1:\n                doubled_pawns += 1\n            if sum(board.piece_at(chess.square(file, rank)).color == chess.BLACK for rank in range(8)) > 1:\n                doubled_pawns += 1\n    return float(doubled_pawns)", "def feature(board: chess.Board) -> float:\n    \"Computes the difference in mobility between the players by counting legal moves.\"\n    white_moves = len(list(board.legal_moves)) if board.turn else 0\n    black_moves = len(list(board.legal_moves)) if not board.turn else 0\n    mobility_difference = white_moves - black_moves\n    return float(mobility_difference)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of pieces attacking opponent's back rank.\"\n    back_rank_attacks = 0\n    opponent_back_rank = 0 if not board.turn else 7\n    for file in range(8):\n        square = chess.square(file, opponent_back_rank)\n        if board.is_attacked_by((chess.WHITE if board.turn else chess.BLACK), square):\n            back_rank_attacks += 1\n    return float(back_rank_attacks)", "def feature(board: chess.Board) -> float:\n    \"Calculates the ratio of minor pieces (knights and bishops) to major pieces (rooks and queens).\"\n    minor_pieces = sum(1 for p in board.piece_map().values() if p.piece_type in (chess.KNIGHT, chess.BISHOP))\n    major_pieces = sum(1 for p in board.piece_map().values() if p.piece_type in (chess.ROOK, chess.QUEEN))\n    ratio = minor_pieces / (major_pieces + 1e-6)  # Avoid division by zero\n    return float(ratio)", "def feature(board: chess.Board) -> float:\n    \"Measures the distance of the nearest piece to the opponent's king.\"\n    nearest_distance = float('inf')\n    king_square = next((sq for sq in board.piece_map() if board.piece_at(sq).piece_type == chess.KING and board.piece_at(sq).color == (chess.WHITE if board.turn else chess.BLACK)), None)\n    if king_square is not None:\n        for square in board.piece_map():\n            piece = board.piece_at(square)\n            if piece and piece.color != (chess.WHITE if board.turn else chess.BLACK):\n                distance = chess.square_distance(square, king_square)\n                nearest_distance = min(nearest_distance, distance)\n    return float(nearest_distance) if nearest_distance != float('inf') else 0.0", "def feature(board: chess.Board) -> float:\n    \"Measures the total number of pawns on the board.\"\n    pawn_count = sum(1 for piece in board.piece_map().values() if piece.piece_type == chess.PAWN)\n    return float(pawn_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the potential for piece advancement based on pawn structure.\"\n    advancement_score = 0.0\n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.PAWN:\n            if piece.color == chess.WHITE and chess.square_rank(square) < 7:\n                advancement_score += (7 - chess.square_rank(square))\n            elif piece.color == chess.BLACK and chess.square_rank(square) > 0:\n                advancement_score += chess.square_rank(square)\n    return advancement_score", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces on squares that are attacked by opponent's pieces.\"\n    attacked_by_opponent = sum(1 for square in board.piece_map() if board.is_attacked_by(not board.turn, square))\n    return float(attacked_by_opponent)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of open files for rooks by counting the number of empty squares in each file.\"\n    open_file_count = 0\n    for file in range(8):\n        if all(board.piece_at(chess.square(file, rank)) is None for rank in range(8)):\n            open_file_count += 1\n    return float(open_file_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the distance to the opponent's king for all pieces on the board.\"\n    opponent_king_square = next(square for square, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color != board.turn)\n    total_distance = sum(chess.square_distance(square, opponent_king_square) for square in board.piece_map() if board.piece_map()[square].color == board.turn)\n    return float(total_distance)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of pieces that can contribute to a potential pin against the opponent's king.\"\n    pin_count = 0\n    opponent_king_square = next(square for square, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color != board.turn)\n    for square in board.piece_map():\n        if board.is_attacked_by(not board.turn, square):\n            if board.piece_map()[square].piece_type in (chess.ROOK, chess.QUEEN):\n                pin_count += 1\n    return float(pin_count)", "def feature(board: chess.Board) -> float:\n    \"Measures the difference in the number of knight pieces for both players.\"\n    white_knights = sum(1 for piece in board.piece_map().values() if piece.piece_type == chess.KNIGHT and piece.color == chess.WHITE)\n    black_knights = sum(1 for piece in board.piece_map().values() if piece.piece_type == chess.KNIGHT and piece.color == chess.BLACK)\n    return float(white_knights - black_knights)", "def feature(board: chess.Board) -> float:\n    \"Calculates the activity level of the pieces based on the number of legal moves available.\"\n    legal_move_count = len(list(board.legal_moves))\n    return float(legal_move_count)", "def feature(board: chess.Board) -> float:\n    \"Evaluates the safety of the kings by counting the number of pieces that can attack each king.\"\n    white_king_square = next(square for square, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color == chess.WHITE)\n    black_king_square = next(square for square, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color == chess.BLACK)\n    white_king_attacks = sum(1 for square in board.piece_map() if board.is_attacked_by(chess.WHITE, black_king_square))\n    black_king_attacks = sum(1 for square in board.piece_map() if board.is_attacked_by(chess.BLACK, white_king_square))\n    return float(black_king_attacks - white_king_attacks) ", "def feature(board: chess.Board) -> float:\n    \"Measures the control of the center squares by counting pieces on d4, d5, e4, e5.\"\n    center_squares = [chess.D4, chess.D5, chess.E4, chess.E5]\n    control_count = sum(1 for square in center_squares if board.piece_at(square) is not None and board.piece_at(square).color == board.turn)\n    return float(control_count)", "def feature(board: chess.Board) -> float:\n    \"Measures the total number of pieces of each color on the board.\"\n    white_pieces = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE)\n    black_pieces = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK)\n    return float(white_pieces - black_pieces)", "def feature(board: chess.Board) -> float:\n    \"Counts total attacking pieces on the board for both colors.\"\n    white_attacks = sum(len(board.attackers(chess.WHITE, square)) for square in board.piece_map())\n    black_attacks = sum(len(board.attackers(chess.BLACK, square)) for square in board.piece_map())\n    return float(white_attacks - black_attacks)", "def feature(board: chess.Board) -> float:\n    \"Evaluates the material balance weighted by piece activity and positioning.\"\n    piece_values = {\n        chess.PAWN: 100, chess.KNIGHT: 320, chess.BISHOP: 330,\n        chess.ROOK: 500, chess.QUEEN: 900, chess.KING: 20000\n    }\n    material_balance = sum(piece_values[piece.piece_type] * (1 if piece.color == chess.WHITE else -1)\n                           for piece in board.piece_map().values())\n    return float(material_balance)", "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in the number of pawns for each side.\"\n    white_pawns = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE and piece.piece_type == chess.PAWN)\n    black_pawns = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK and piece.piece_type == chess.PAWN)\n    return float(white_pawns - black_pawns)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of checks available to the current player.\"\n    checks_available = len(list(board.legal_moves))  # Simplistic, assumes one check per legal move.\n    return float(checks_available)", "def feature(board: chess.Board) -> float:\n    \"Evaluates the king's safety based on the number of defending pieces around it.\"\n    king_square = next((square for square, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color == board.turn), None)\n    if king_square is None:\n        return 0.0\n    defending_squares = sum(1 for square in board.attackers(not board.turn, king_square))\n    return float(defending_squares)", "def feature(board: chess.Board) -> float:\n    \"Counts the difference in the number of minor pieces (Knights, Bishops) remaining for each side.\"\n    white_minor = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE and piece.piece_type in {chess.KNIGHT, chess.BISHOP})\n    black_minor = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK and piece.piece_type in {chess.KNIGHT, chess.BISHOP})\n    return float(white_minor - black_minor)", "def feature(board: chess.Board) -> float:\n    \"Measures the balance of rooks remaining for both sides.\"\n    white_rooks = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE and piece.piece_type == chess.ROOK)\n    black_rooks = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK and piece.piece_type == chess.ROOK)\n    return float(white_rooks - black_rooks)", "def feature(board: chess.Board) -> float:\n    \"Measures the total piece value for each color and returns their difference.\"\n    white_value = sum(piece.piece_type for piece in board.piece_map().values() if piece.color == chess.WHITE)\n    black_value = sum(piece.piece_type for piece in board.piece_map().values() if piece.color == chess.BLACK)\n    return float(white_value - black_value)", "def feature(board: chess.Board) -> float:\n    \"Counts and compares the number of pawns each player has and normalizes the result.\"\n    white_pawns = len([p for p in board.piece_map().values() if p.piece_type == chess.PAWN and p.color == chess.WHITE])\n    black_pawns = len([p for p in board.piece_map().values() if p.piece_type == chess.PAWN and p.color == chess.BLACK])\n    return float(white_pawns - black_pawns)", "def feature(board: chess.Board) -> float:\n    \"Measures the distance of each player's king to the center of the board.\"\n    white_king_square = board.king(chess.WHITE)\n    black_king_square = board.king(chess.BLACK)\n    white_distance = chess.square_distance(white_king_square, chess.parse_square('e4'))\n    black_distance = chess.square_distance(black_king_square, chess.parse_square('e4'))\n    return float(black_distance - white_distance)", "def feature(board: chess.Board) -> float:\n    \"Counts the available legal moves for each side and returns their difference.\"\n    white_moves = len(list(board.legal_moves))\n    black_moves = len([move for move in board.legal_moves if move.from_square in board.piece_map() and board.piece_map()[move.from_square].color == chess.BLACK])\n    return float(white_moves - black_moves)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of pieces in each player's last three ranks and returns the difference.\"\n    white_control = sum(1 for sq in range(48, 64) if board.piece_at(sq) and board.piece_at(sq).color == chess.WHITE)\n    black_control = sum(1 for sq in range(0, 16) if board.piece_at(sq) and board.piece_at(sq).color == chess.BLACK)\n    return float(white_control - black_control)", "def feature(board: chess.Board) -> float:\n    \"Measures the total number of pieces attacked by each player.\"\n    white_attacked = sum(1 for sq in board.piece_map().keys() if board.is_attacked_by(chess.WHITE, sq))\n    black_attacked = sum(1 for sq in board.piece_map().keys() if board.is_attacked_by(chess.BLACK, sq))\n    return float(white_attacked - black_attacked)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of open files for each player's rooks and returns their difference.\"\n    white_rooks_open_files = len(set(chess.square_file(square) for square in board.piece_map() if board.piece_map()[square].piece_type == chess.ROOK and board.piece_map()[square].color == chess.WHITE and all(board.piece_at(chess.square(rank, chess.square_file(square))) is None for rank in range(8))))\n    black_rooks_open_files = len(set(chess.square_file(square) for square in board.piece_map() if board.piece_map()[square].piece_type == chess.ROOK and board.piece_map()[square].color == chess.BLACK and all(board.piece_at(chess.square(rank, chess.square_file(square))) is None for rank in range(8))))\n    return float(white_rooks_open_files - black_rooks_open_files)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pawns for each side and returns their difference.\"\n    white_pawns = sum(1 for piece in board.piece_map().values() if piece.piece_type == chess.PAWN and piece.color == chess.WHITE)\n    black_pawns = sum(1 for piece in board.piece_map().values() if piece.piece_type == chess.PAWN and piece.color == chess.BLACK)\n    return float(white_pawns - black_pawns)", "def feature(board: chess.Board) -> float:\n    \"Measures the total distance of all pieces from the center of the board.\"\n    center_square = (chess.square(3, 3), chess.square(4, 4))\n    total_distance = sum(chess.square_distance(square, center_square[0]) + chess.square_distance(square, center_square[1])\n                         for square, piece in board.piece_map().items())\n    return float(total_distance)", "def feature(board: chess.Board) -> float:\n    \"Evaluates the number of pieces each player has in the opponent's half.\"\n    white_in_opponent_half = sum(1 for square, piece in board.piece_map().items() \n                                  if piece.color == chess.WHITE and chess.square_rank(square) > 3)\n    black_in_opponent_half = sum(1 for square, piece in board.piece_map().items() \n                                  if piece.color == chess.BLACK and chess.square_rank(square) < 4)\n    return float(white_in_opponent_half - black_in_opponent_half)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of checks each player can give based on current position.\"\n    white_checks = sum(1 for move in board.legal_moves if board.gives_check(move))\n    black_checks = sum(1 for move in board.legal_moves if board.gives_check(move))\n    return float(white_checks - black_checks)", "def feature(board: chess.Board) -> float:\n    \"Calculates the ratio of major pieces (rooks and queens) to total pieces on the board.\"\n    major_pieces = sum(1 for piece in board.piece_map().values() if piece.piece_type in {chess.ROOK, chess.QUEEN})\n    total_pieces = sum(1 for piece in board.piece_map().values())\n    return float(major_pieces) / (total_pieces + 1e-6)  # Avoid division by zero", "def feature(board: chess.Board) -> float:\n    \"Counts the number of protected pieces for each side and returns their difference.\"\n    white_protected = sum(1 for square, piece in board.piece_map().items() if piece.color == chess.WHITE \n                          and any(board.is_attacked_by(chess.BLACK, square) for square in board.attackers(chess.WHITE, square)))\n    black_protected = sum(1 for square, piece in board.piece_map().items() if piece.color == chess.BLACK \n                          and any(board.is_attacked_by(chess.WHITE, square) for square in board.attackers(chess.BLACK, square)))\n    return float(white_protected - black_protected)", "def feature(board: chess.Board) -> float:\n    \"Evaluates the material balance of pieces outside of the promotion rank.\"\n    non_promoted_material = sum(piece.piece_type for square, piece in board.piece_map().items() \n                                 if (piece.color == chess.WHITE and chess.square_rank(square) < 6) or \n                                    (piece.color == chess.BLACK and chess.square_rank(square) > 1))\n    return float(non_promoted_material)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of squares attacked by each player.\"\n    white_attacks = sum(1 for square in chess.SQUARES if board.is_attacked_by(chess.WHITE, square))\n    black_attacks = sum(1 for square in chess.SQUARES if board.is_attacked_by(chess.BLACK, square))\n    return float(white_attacks - black_attacks)", "def feature(board: chess.Board) -> float:\n    \"Measures central control by counting pieces in the central squares (d4, d5, e4, e5).\"\n    central_squares = [chess.parse_square('d4'), chess.parse_square('d5'), chess.parse_square('e4'), chess.parse_square('e5')]\n    central_control_white = sum(1 for square in central_squares if board.piece_at(square) and board.piece_at(square).color == chess.WHITE)\n    central_control_black = sum(1 for square in central_squares if board.piece_at(square) and board.piece_at(square).color == chess.BLACK)\n    return float(central_control_white - central_control_black)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of pieces attacking opponent's king.\"\n    attacking_pieces = sum(1 for square in board.piece_map() if board.is_attacked_by(not board.turn, square))\n    return float(attacking_pieces)", "def feature(board: chess.Board) -> float:\n    \"Calculates the total number of pawns on the board.\"\n    pawn_count = sum(1 for piece in board.piece_map().values() if piece.piece_type == chess.PAWN)\n    return float(pawn_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of pieces actively controlling each side's home rank.\"\n    white_home_control = sum(1 for square in range(chess.A7, chess.H8) if board.is_attacked_by(chess.WHITE, square))\n    black_home_control = sum(1 for square in range(chess.A1, chess.H2) if board.is_attacked_by(chess.BLACK, square))\n    return float(white_home_control - black_home_control)", "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in piece activity using center control.\"\n    center_control_white = sum(1 for sq in [chess.D4, chess.D5, chess.E4, chess.E5] if board.is_attacked_by(chess.WHITE, sq))\n    center_control_black = sum(1 for sq in [chess.D4, chess.D5, chess.E4, chess.E5] if board.is_attacked_by(chess.BLACK, sq))\n    return float(center_control_white - center_control_black)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces located on the 7th rank for both players.\"\n    pieces_on_seventh_rank = sum(1 for square in range(chess.A7, chess.H8) if board.piece_at(square) is not None)\n    return float(pieces_on_seventh_rank)", "def feature(board: chess.Board) -> float:\n    \"Measures the total value difference of pieces in the opponent's half.\"\n    opponent_half_value = sum(piece.piece_type for square, piece in board.piece_map().items()\n                               if (piece.color == board.turn and chess.square_rank(square) < 4) or\n                               (piece.color != board.turn and chess.square_rank(square) > 3))\n    return float(opponent_half_value)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of doubled pawns on the board.\"\n    pawn_file_counts = {}\n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.PAWN:\n            file = chess.square_file(square)\n            if file not in pawn_file_counts:\n                pawn_file_counts[file] = 0\n            pawn_file_counts[file] += 1\n    doubled_pawns = sum(max(0, count - 1) for count in pawn_file_counts.values())\n    return float(doubled_pawns)", "def feature(board: chess.Board) -> float:\n    \"Measures the total material imbalance on the board by simple point values.\"\n    material_values = {chess.PAWN: 100, chess.KNIGHT: 320, chess.BISHOP: 330, chess.ROOK: 500, chess.QUEEN: 900}\n    material_balance = sum(material_values.get(piece.piece_type, 0) * (1 if piece.color == chess.WHITE else -1)\n                           for piece in board.piece_map().values())\n    return float(material_balance)", "def feature(board: chess.Board) -> float:\n    \"Calculates the mobility of pieces by counting the total legal moves available.\"\n    mobility = sum(len(list(board.legal_moves)) for square in board.piece_map())\n    return float(mobility)", "def feature(board: chess.Board) -> float:\n    \"Measures the total material value of active pieces that are not blocked by pawns.\"\n    total_value = 0\n    for square, piece in board.piece_map().items():\n        if piece.piece_type in {chess.KING, chess.QUEEN, chess.ROOK, chess.BISHOP, chess.KNIGHT}:\n            if not board.is_attacked_by(chess.BLACK if piece.color == chess.WHITE else chess.WHITE, square):\n                total_value += piece.piece_type\n    return float(total_value)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of squares controlled by each player and measures the difference.\"\n    white_control = sum(1 for square in chess.SQUARES if board.is_attacked_by(chess.WHITE, square))\n    black_control = sum(1 for square in chess.SQUARES if board.is_attacked_by(chess.BLACK, square))\n    return float(white_control - black_control)", "def feature(board: chess.Board) -> float:\n    \"Evaluates the material balance considering the number of pieces away from their home ranks.\"\n    distance = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == chess.WHITE:\n            distance += chess.square_rank(square)\n        else:\n            distance += 7 - chess.square_rank(square)\n    return float(distance)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of doubled pawns for both players and returns their difference.\"\n    white_doubled = sum(1 for file in range(8) if len([s for s in range(chess.A2, chess.H2+1) if board.piece_at(s) and board.piece_at(s).color == chess.WHITE and chess.square_file(s) == file]) > 1)\n    black_doubled = sum(1 for file in range(8) if len([s for s in range(chess.A7, chess.H7+1) if board.piece_at(s) and board.piece_at(s).color == chess.BLACK and chess.square_file(s) == file]) > 1)\n    return float(white_doubled - black_doubled)", "def feature(board: chess.Board) -> float:\n    \"Measures the difference in king safety by counting the number of attacking pieces around each king.\"\n    white_king_attacks = sum(1 for square in chess.SQUARES if board.is_attacked_by(chess.BLACK, board.king(chess.WHITE)))\n    black_king_attacks = sum(1 for square in chess.SQUARES if board.is_attacked_by(chess.WHITE, board.king(chess.BLACK)))\n    return float(white_king_attacks - black_king_attacks)", "def feature(board: chess.Board) -> float:\n    \"Evaluates the structure of pawns by counting isolated pawns for each player.\"\n    white_isolated = sum(1 for file in range(8) if board.piece_at(chess.square(chess.square_file(chess.A2), 1)) and \n                         (file == 0 or not board.piece_at(chess.square(file - 1, 1))) and \n                         (file == 7 or not board.piece_at(chess.square(file + 1, 1))))\n    black_isolated = sum(1 for file in range(8) if board.piece_at(chess.square(chess.square_file(chess.A7), 6)) and \n                         (file == 0 or not board.piece_at(chess.square(file - 1, 6))) and \n                         (file == 7 or not board.piece_at(chess.square(file + 1, 6))))\n    return float(white_isolated - black_isolated)", "def feature(board: chess.Board) -> float:\n    \"Measures the potential for pawn promotion by counting pawns in the opponent's half.\"\n    white_pawns_in_opponent_half = sum(1 for square in range(chess.A7, chess.H7 + 1) if board.piece_at(square) and board.piece_at(square).color == chess.WHITE)\n    black_pawns_in_opponent_half = sum(1 for square in range(chess.A2, chess.H2 + 1) if board.piece_at(square) and board.piece_at(square).color == chess.BLACK)\n    return float(white_pawns_in_opponent_half - black_pawns_in_opponent_half)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of pieces of each type to assess piece diversity on the board.\"\n    piece_counts = {piece_type: 0 for piece_type in [chess.PAWN, chess.KNIGHT, chess.BISHOP, chess.ROOK, chess.QUEEN, chess.KING]}\n    for piece in board.piece_map().values():\n        piece_counts[piece.piece_type] += 1\n    diversity_score = sum(1 for count in piece_counts.values() if count > 0)\n    return float(diversity_score)", "def feature(board: chess.Board) -> float:\n    \"Calculates the control over central squares by counting pieces on d4, d5, e4, and e5.\"\n    central_squares = [chess.parse_square('d4'), chess.parse_square('d5'), chess.parse_square('e4'), chess.parse_square('e5')]\n    control_score = sum(1 for square in central_squares if board.piece_at(square) is not None)\n    return float(control_score)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces that are protected by other pieces to assess safety.\"\n    protected_count = sum(1 for square, piece in board.piece_map().items() if board.attackers(piece.color, square) and any(board.is_attacked_by(piece.color, attacker) for attacker in board.attackers(piece.color, square)))\n    return float(protected_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of pawn majority on the board for both sides to assess potential pawn advantages.\"\n    white_pawn_count = sum(1 for square in board.piece_map() if board.piece_at(square).piece_type == chess.PAWN and board.piece_at(square).color == chess.WHITE)\n    black_pawn_count = sum(1 for square in board.piece_map() if board.piece_at(square).piece_type == chess.PAWN and board.piece_at(square).color == chess.BLACK)\n    return float(white_pawn_count - black_pawn_count)", "def feature(board: chess.Board) -> float:\n    \"Measures the distance of the kings from the center to assess their safety.\"\n    king_positions = [square for square, piece in board.piece_map().items() if piece.piece_type == chess.KING]\n    distance_from_center = sum(chess.square_distance(king, chess.parse_square('e4')) for king in king_positions)\n    return float(distance_from_center)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of checks given by both players to evaluate tactical opportunities.\"\n    white_checks = sum(1 for move in board.legal_moves if board.is_check())\n    black_checks = sum(1 for move in board.legal_moves if board.is_check())\n    return float(white_checks - black_checks)", "def feature(board: chess.Board) -> float:\n    \"Evaluates the average rank of each side's pawns to gauge advancement.\"\n    white_pawn_ranks = [chess.square_rank(square) for square in board.piece_map() if board.piece_at(square).piece_type == chess.PAWN and board.piece_at(square).color == chess.WHITE]\n    black_pawn_ranks = [7 - chess.square_rank(square) for square in board.piece_map() if board.piece_at(square).piece_type == chess.PAWN and board.piece_at(square).color == chess.BLACK]\n    average_white_rank = sum(white_pawn_ranks) / max(len(white_pawn_ranks), 1)\n    average_black_rank = sum(black_pawn_ranks) / max(len(black_pawn_ranks), 1)\n    return float(average_white_rank - average_black_rank)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of hanging pieces for both sides to assess threats.\"\n    hanging_pieces = sum(1 for square, piece in board.piece_map().items() if piece and not board.attackers(piece.color, square))\n    return float(hanging_pieces)", "def feature(board: chess.Board) -> float:\n    \"Calculates potential passed pawns for both sides to measure endgame potential.\"\n    passed_pawn_count = 0\n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.PAWN:\n            if piece.color == chess.WHITE:\n                if all(board.piece_at(chess.square_file(square) + i * 8) is None for i in range(1, 8)): \n                    passed_pawn_count += 1\n            else:\n                if all(board.piece_at(chess.square_file(square) - i * 8) is None for i in range(1, 8)):\n                    passed_pawn_count += 1\n    return float(passed_pawn_count)", "def feature(board: chess.Board) -> float:\n    \"Measures the total number of square threats each player's pieces pose to assess aggression.\"\n    total_threats = sum(len(board.attackers(piece.color, square)) for square, piece in board.piece_map().items())\n    return float(total_threats)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of pieces attacking the opponent's king.\"\n    opponent_king_square = board.king(not board.turn)\n    attackers_count = len(board.attackers(board.turn, opponent_king_square))\n    return float(attackers_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the total mobility of pieces for both players.\"\n    white_mobility = sum(1 for move in board.legal_moves if board.turn)\n    board.turn = False\n    black_mobility = sum(1 for move in board.legal_moves if not board.turn)\n    board.turn = True\n    return float(white_mobility - black_mobility)", "def feature(board: chess.Board) -> float:\n    \"Evaluates the presence of doubled pawns for each side.\"\n    def count_doubled_pawns(color):\n        count = 0\n        pawns = [sq for sq, piece in board.piece_map().items() if piece.piece_type == chess.PAWN and piece.color == color]\n        files = {}\n        for pawn in pawns:\n            file = chess.square_file(pawn)\n            if file in files:\n                files[file] += 1\n            else:\n                files[file] = 1\n        count = sum(1 for file_count in files.values() if file_count > 1)\n        return count\n\n    white_doubled = count_doubled_pawns(chess.WHITE)\n    black_doubled = count_doubled_pawns(chess.BLACK)\n    return float(white_doubled - black_doubled)", "def feature(board: chess.Board) -> float:\n    \"Measures the distance of pieces from the nearest back rank of the opponent.\"\n    distances = []\n    opponent_back_rank = 0 if board.turn else 7\n    for sq, piece in board.piece_map().items():\n        if piece.color == board.turn:\n            distance = chess.square_rank(sq) - opponent_back_rank\n            distances.append(distance)\n    return float(sum(distances) / len(distances)) if distances else 0.0", "def feature(board: chess.Board) -> float:\n    \"Counts the number of unresolved attacks on pieces of both players.\"\n    unresolved_attacks = 0\n    for square in board.piece_map():\n        piece = board.piece_at(square)\n        if piece:\n            attacking_squares = board.attackers(not piece.color, square)\n            if any(board.piece_at(att_square) is None for att_square in attacking_squares):\n                unresolved_attacks += 1\n    return float(unresolved_attacks)", "def feature(board: chess.Board) -> float:\n    \"Checks the number of pieces pinned by opponents on the board.\"\n    pinned_count = 0\n    for square in board.piece_map():\n        piece = board.piece_at(square)\n        if piece and piece.color == board.turn:\n            for attacker_square in board.attackers(not board.turn, square):\n                attacker = board.piece_at(attacker_square)\n                if attacker and attacker.piece_type in [chess.ROOK, chess.QUEEN]:\n                    pinned_count += 1\n    return float(pinned_count)", "def feature(board: chess.Board) -> float:\n    \"Evaluates the number of squares controlled by each side.\"\n    white_control = sum(board.is_attacked_by(chess.WHITE, sq) for sq in chess.SQUARES)\n    black_control = sum(board.is_attacked_by(chess.BLACK, sq) for sq in chess.SQUARES)\n    return float(white_control - black_control)", "def feature(board: chess.Board) -> float:\n    \"Checks how many pieces are undeveloped (not moved from their starting positions).\"\n    undeveloped_count = 0\n    starting_positions = {\n        chess.WHITE: [chess.A1, chess.B1, chess.C1, chess.D1, chess.E1, chess.F1, chess.G1, chess.H1, chess.A2, chess.B2, chess.C2, chess.D2, chess.E2, chess.F2, chess.G2, chess.H2],\n        chess.BLACK: [chess.A8, chess.B8, chess.C8, chess.D8, chess.E8, chess.F8, chess.G8, chess.H8, chess.A7, chess.B7, chess.C7, chess.D7, chess.E7, chess.F7, chess.G7, chess.H7],\n    }\n    for sq in starting_positions[board.turn]:\n        if board.piece_at(sq) is not None:\n            undeveloped_count += 1\n    return float(undeveloped_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the material imbalance in terms of minor pieces (knights and bishops).\"\n    def piece_count(color, piece_type):\n        return sum(1 for piece in board.piece_map().values() if piece.color == color and piece.piece_type == piece_type)\n\n    white_minor = piece_count(chess.WHITE, chess.KNIGHT) + piece_count(chess.WHITE, chess.BISHOP)\n    black_minor = piece_count(chess.BLACK, chess.KNIGHT) + piece_count(chess.BLACK, chess.BISHOP)\n    return float(white_minor - black_minor)", "def feature(board: chess.Board) -> float:\n    \"Measures the difference in the number of pieces on the board for each player.\"\n    white_pieces = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE)\n    black_pieces = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK)\n    return float(white_pieces - black_pieces)", "def feature(board: chess.Board) -> float:\n    \"Calculates the sum of the values of all pieces on the board for both players.\"\n    piece_values = {chess.PAWN: 100, chess.KNIGHT: 320, chess.BISHOP: 330, chess.ROOK: 500, chess.QUEEN: 900, chess.KING: 0}\n    total_value = sum(piece_values[piece.piece_type] for piece in board.piece_map().values())\n    return float(total_value)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pawns on the board and assigns a penalty for each side.\"\n    white_pawn_count = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE and piece.piece_type == chess.PAWN)\n    black_pawn_count = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK and piece.piece_type == chess.PAWN)\n    return float(white_pawn_count - black_pawn_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the distance of kings from the center of the board.\"\n    white_king_square = next(square for square, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color == chess.WHITE)\n    black_king_square = next(square for square, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color == chess.BLACK)\n    white_distance = chess.square_distance(white_king_square, chess.parse_square('e4'))\n    black_distance = chess.square_distance(black_king_square, chess.parse_square('e4'))\n    return float(white_distance - black_distance)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of squares controlled by each player's pieces.\"\n    controlled_squares = {chess.WHITE: set(), chess.BLACK: set()}\n    for square, piece in board.piece_map().items():\n        if piece.color == chess.WHITE:\n            for move in board.legal_moves:\n                if move.from_square == square:\n                    controlled_squares[chess.WHITE].add(move.to_square)\n        elif piece.color == chess.BLACK:\n            for move in board.legal_moves:\n                if move.from_square == square:\n                    controlled_squares[chess.BLACK].add(move.to_square)\n    return float(len(controlled_squares[chess.WHITE]) - len(controlled_squares[chess.BLACK]))", "def feature(board: chess.Board) -> float:\n    \"Checks how many pieces are attacking the opponent's king.\"\n    white_king_square = next(square for square, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color == chess.WHITE)\n    black_king_square = next(square for square, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color == chess.BLACK)\n    white_attacks = len(board.attackers(chess.WHITE, black_king_square))\n    black_attacks = len(board.attackers(chess.BLACK, white_king_square))\n    return float(white_attacks - black_attacks)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of loose pieces for each player (not defended by any other piece).\"\n    loose_pieces = {chess.WHITE: 0, chess.BLACK: 0}\n    for square, piece in board.piece_map().items():\n        attackers = board.attackers(piece.color, square)\n        if not attackers:\n            loose_pieces[piece.color] += 1\n    return float(loose_pieces[chess.WHITE] - loose_pieces[chess.BLACK])", "def feature(board: chess.Board) -> float:\n    \"Evaluates the king safety by considering the number of pawns in front of each king.\"\n    white_king_square = next(square for square, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color == chess.WHITE)\n    black_king_square = next(square for square, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color == chess.BLACK)\n    white_pawns_in_front = sum(1 for square, piece in board.piece_map().items() if piece.color == chess.WHITE and piece.piece_type == chess.PAWN and chess.square_rank(square) > chess.square_rank(white_king_square))\n    black_pawns_in_front = sum(1 for square, piece in board.piece_map().items() if piece.color == chess.BLACK and piece.piece_type == chess.PAWN and chess.square_rank(square) < chess.square_rank(black_king_square))\n    return float(white_pawns_in_front - black_pawns_in_front)", "def feature(board: chess.Board) -> float:\n    \"Measures the material balance of major pieces (rooks and queens) between both players.\"\n    white_major_piece_value = sum(piece.piece_type in (chess.ROOK, chess.QUEEN) for piece in board.piece_map().values() if piece.color == chess.WHITE)\n    black_major_piece_value = sum(piece.piece_type in (chess.ROOK, chess.QUEEN) for piece in board.piece_map().values() if piece.color == chess.BLACK)\n    return float(white_major_piece_value - black_major_piece_value)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of pawns on the 7th rank for both players.\"\n    white_pawns_seventh = sum(1 for sq in board.piece_map() if board.piece_at(sq).color == chess.WHITE and chess.square_rank(sq) == 6)\n    black_pawns_seventh = sum(1 for sq in board.piece_map() if board.piece_at(sq).color == chess.BLACK and chess.square_rank(sq) == 1)\n    return float(white_pawns_seventh - black_pawns_seventh)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of connected pawns for each player.\"\n    def connected_pawns(color):\n        pawns = [sq for sq in board.piece_map() if board.piece_at(sq).color == color and board.piece_at(sq).piece_type == chess.PAWN]\n        connected = 0\n        for sq in pawns:\n            file = chess.square_file(sq)\n            rank = chess.square_rank(sq)\n            if (board.piece_at(chess.square(file + 1, rank)) and \n                board.piece_at(chess.square(file + 1, rank)).color == color):\n                connected += 1\n            if (board.piece_at(chess.square(file - 1, rank)) and \n                board.piece_at(chess.square(file - 1, rank)).color == color):\n                connected += 1\n        return connected\n    \n    return float(connected_pawns(chess.WHITE) - connected_pawns(chess.BLACK))", "def feature(board: chess.Board) -> float:\n    \"Calculates the ratio of pieces on the board compared to the expected count for mid-game.\"\n    piece_counts = {chess.WHITE: 0, chess.BLACK: 0}\n    for piece in board.piece_map().values():\n        piece_counts[piece.color] += 1\n\n    return float(piece_counts[chess.WHITE] / (piece_counts[chess.BLACK] + 1e-6)) ", "def feature(board: chess.Board) -> float:\n    \"Measures the number of rook files controlled by both players.\"\n    def controlled_rook_files(color):\n        files_controlled = set()\n        for sq in board.piece_map():\n            if board.piece_at(sq).color == color and board.piece_at(sq).piece_type == chess.ROOK:\n                files_controlled.add(chess.square_file(sq))\n                for move in board.legal_moves:\n                    if move.from_square == sq:\n                        files_controlled.add(chess.square_file(move.to_square))\n        return len(files_controlled)\n\n    return float(controlled_rook_files(chess.WHITE) - controlled_rook_files(chess.BLACK))", "def feature(board: chess.Board) -> float:\n    \"Counts the number of squares attacked by each player's pieces.\"\n    def attacked_squares(color):\n        attacked = set()\n        for move in board.legal_moves:\n            if board.piece_at(move.from_square).color == color:\n                attacked.add(move.to_square)\n        return len(attacked)\n\n    return float(attacked_squares(chess.WHITE) - attacked_squares(chess.BLACK))", "def feature(board: chess.Board) -> float:\n    \"Measures the number of squares controlled by pawns for each player.\"\n    def controlled_squares_by_pawns(color):\n        controlled = set()\n        for sq in board.piece_map():\n            if board.piece_at(sq).piece_type == chess.PAWN and board.piece_at(sq).color == color:\n                file = chess.square_file(sq)\n                rank = chess.square_rank(sq)\n                if color == chess.WHITE:\n                    controlled.update([chess.square(file - 1, rank + 1), chess.square(file + 1, rank + 1)])\n                else:\n                    controlled.update([chess.square(file - 1, rank - 1), chess.square(file + 1, rank - 1)])\n        return len(controlled)\n\n    return float(controlled_squares_by_pawns(chess.WHITE) - controlled_squares_by_pawns(chess.BLACK))", "def feature(board: chess.Board) -> float:\n    \"Measures the safety of the kings based on the number of attacking pieces near them.\"\n    def king_safety(color):\n        king_sq = next(sq for sq in board.piece_map() if board.piece_at(sq).piece_type == chess.KING and board.piece_at(sq).color == color)\n        attackers = board.attackers(not color, king_sq)\n        return len(attackers)\n\n    return float(king_safety(chess.WHITE) - king_safety(chess.BLACK))", "def feature(board: chess.Board) -> float:\n    \"Calculates the material imbalance based on the difference in the value of pieces for each player.\"\n    piece_values = {\n        chess.PAWN: 100,\n        chess.KNIGHT: 320,\n        chess.BISHOP: 330,\n        chess.ROOK: 500,\n        chess.QUEEN: 900,\n        chess.KING: 20000  # King is invaluable in terms of safety\n    }\n\n    white_value = sum(piece_values[board.piece_at(sq).piece_type] for sq in board.piece_map() if board.piece_at(sq).color == chess.WHITE)\n    black_value = sum(piece_values[board.piece_at(sq).piece_type] for sq in board.piece_map() if board.piece_at(sq).color == chess.BLACK)\n\n    return float(white_value - black_value)", "def feature(board: chess.Board) -> float:\n    \"Measures the average piece value for each side on the board.\"\n    piece_values = {chess.PAWN: 100, chess.KNIGHT: 300, chess.BISHOP: 300, chess.ROOK: 500, chess.QUEEN: 900, chess.KING: 0}\n    white_value = sum(piece_values[piece.piece_type] for piece in board.piece_map().values() if piece.color == chess.WHITE)\n    black_value = sum(piece_values[piece.piece_type] for piece in board.piece_map().values() if piece.color == chess.BLACK)\n    return float(white_value - black_value)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of attacking pieces each side has.\"\n    white_attacks = sum(len(board.attackers(chess.WHITE, square)) for square in board.piece_map() if board.piece_map()[square].color == chess.WHITE)\n    black_attacks = sum(len(board.attackers(chess.BLACK, square)) for square in board.piece_map() if board.piece_map()[square].color == chess.BLACK)\n    return float(white_attacks - black_attacks)", "def feature(board: chess.Board) -> float:\n    \"Calculates the material imbalance by counting the difference in effective pieces considering minor pieces versus major pieces.\"\n    minor_pieces_white = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE and piece.piece_type in (chess.KNIGHT, chess.BISHOP))\n    major_pieces_white = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE and piece.piece_type in (chess.ROOK, chess.QUEEN))\n    minor_pieces_black = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK and piece.piece_type in (chess.KNIGHT, chess.BISHOP))\n    major_pieces_black = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK and piece.piece_type in (chess.ROOK, chess.QUEEN))\n    return float((major_pieces_white - major_pieces_black) + 0.5 * (minor_pieces_white - minor_pieces_black))", "def feature(board: chess.Board) -> float:\n    \"Measures the distance of the kings from the center of the board.\"\n    white_king_square = next(square for square in board.piece_map() if board.piece_map()[square].color == chess.WHITE and board.piece_map()[square].piece_type == chess.KING)\n    black_king_square = next(square for square in board.piece_map() if board.piece_map()[square].color == chess.BLACK and board.piece_map()[square].piece_type == chess.KING)\n    white_distance = chess.square_distance(white_king_square, chess.parse_square('e4'))\n    black_distance = chess.square_distance(black_king_square, chess.parse_square('e4'))\n    return float(black_distance - white_distance)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of double pawns for each player.\"\n    white_double_pawns = sum(1 for file in range(8) if sum(1 for rank in range(8) if board.piece_at(chess.square(file, rank)) == chess.PAWN and chess.WHITE) > 1)\n    black_double_pawns = sum(1 for file in range(8) if sum(1 for rank in range(8) if board.piece_at(chess.square(file, rank)) == chess.PAWN and chess.BLACK) > 1)\n    return float(white_double_pawns - black_double_pawns)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of checks available to the current player.\"\n    checks = sum(1 for move in board.legal_moves if board.gives_check(move))\n    return float(checks)", "def feature(board: chess.Board) -> float:\n    \"Measures the difference in material value between players' pawns.\"\n    white_pawn_value = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE and piece.piece_type == chess.PAWN)\n    black_pawn_value = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK and piece.piece_type == chess.PAWN)\n    return float(white_pawn_value - black_pawn_value)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces each player has in the opponent's half of the board.\"\n    white_in_enemy_half = sum(1 for square, piece in board.piece_map().items() if piece.color == chess.WHITE and chess.square_rank(square) >= 4)\n    black_in_enemy_half = sum(1 for square, piece in board.piece_map().items() if piece.color == chess.BLACK and chess.square_rank(square) <= 3)\n    return float(white_in_enemy_half - black_in_enemy_half)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of squares controlled by each player's pieces.\"\n    controlled_squares_white = set()\n    controlled_squares_black = set()\n    for square, piece in board.piece_map().items():\n        if piece.color == chess.WHITE:\n            controlled_squares_white.update(board.attacks(square))\n        else:\n            controlled_squares_black.update(board.attacks(square))\n    return float(len(controlled_squares_white) - len(controlled_squares_black))", "def feature(board: chess.Board) -> float:\n    \"Measures the number of pieces that are attacking the opposing king.\"\n    white_attacking_king = sum(1 for square in board.attackers(chess.WHITE, chess.parse_square('e8')))\n    black_attacking_king = sum(1 for square in board.attackers(chess.BLACK, chess.parse_square('e1')))\n    return float(white_attacking_king - black_attacking_king)", "def feature(board: chess.Board) -> float:\n    \"Calculates the total mobility of pieces based on available legal moves.\"\n    mobility_white = sum(1 for move in board.legal_moves if board.turn and board.piece_at(move.from_square) and board.piece_at(move.from_square).color == chess.WHITE)\n    mobility_black = sum(1 for move in board.legal_moves if not board.turn and board.piece_at(move.from_square) and board.piece_at(move.from_square).color == chess.BLACK)\n    return float(mobility_white - mobility_black)", "def feature(board: chess.Board) -> float:\n    \"Measures the distribution of pieces on the board (central control).\"\n    center_squares = [chess.D4, chess.D5, chess.E4, chess.E5]\n    white_center_control = sum(1 for square in center_squares if board.is_attacked_by(chess.WHITE, square))\n    black_center_control = sum(1 for square in center_squares if board.is_attacked_by(chess.BLACK, square))\n    return float(white_center_control - black_center_control)", "def feature(board: chess.Board) -> float:\n    \"Calculates the total value of pieces for each player.\"\n    piece_values = {chess.PAWN: 100, chess.KNIGHT: 300, chess.BISHOP: 300, chess.ROOK: 500, chess.QUEEN: 900, chess.KING: 0}\n    white_value = sum(piece_values[piece.piece_type] for piece in board.piece_map().values() if piece.color == chess.WHITE)\n    black_value = sum(piece_values[piece.piece_type] for piece in board.piece_map().values() if piece.color == chess.BLACK)\n    return float(white_value - black_value)", "def feature(board: chess.Board) -> float:\n    \"Measures the total number of pieces for each player.\"\n    total_white = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE)\n    total_black = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK)\n    return float(total_white - total_black)", "def feature(board: chess.Board) -> float:\n    \"Counts the total material value for each player (in centipawns).\"\n    piece_values = {\n        chess.PAWN: 100,\n        chess.KNIGHT: 320,\n        chess.BISHOP: 330,\n        chess.ROOK: 500,\n        chess.QUEEN: 900,\n        chess.KING: 0\n    }\n    total_value_white = sum(piece_values[piece.piece_type] for piece in board.piece_map().values() if piece.color == chess.WHITE)\n    total_value_black = sum(piece_values[piece.piece_type] for piece in board.piece_map().values() if piece.color == chess.BLACK)\n    return float(total_value_white - total_value_black)", "def feature(board: chess.Board) -> float:\n    \"Calculates the total number of controlled squares by each player.\"\n    controlled_squares_white = len([square for square in chess.SQUARES if board.is_attacked_by(chess.WHITE, square)])\n    controlled_squares_black = len([square for square in chess.SQUARES if board.is_attacked_by(chess.BLACK, square)])\n    return float(controlled_squares_white - controlled_squares_black)", "def feature(board: chess.Board) -> float:\n    \"Measures the distance of kings to the center of the board.\"\n    white_king_square = board.king(chess.WHITE)\n    black_king_square = board.king(chess.BLACK)\n    center_distance_white = chess.square_distance(white_king_square, chess.parse_square('e4')) + chess.square_distance(white_king_square, chess.parse_square('e5'))\n    center_distance_black = chess.square_distance(black_king_square, chess.parse_square('e4')) + chess.square_distance(black_king_square, chess.parse_square('e5'))\n    return float(center_distance_black - center_distance_white)", "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in the number of attacks on each player's king.\"\n    white_king = board.king(chess.WHITE)\n    black_king = board.king(chess.BLACK)\n    attacks_on_white_king = len(board.attackers(chess.BLACK, white_king))\n    attacks_on_black_king = len(board.attackers(chess.WHITE, black_king))\n    return float(attacks_on_black_king - attacks_on_white_king)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces defending each king.\"\n    def count_defenders(king_square, color):\n        return sum(1 for square in board.piece_map() if board.is_attacked_by(color, king_square) and board.piece_at(square).color == color)\n    \n    white_king_square = board.king(chess.WHITE)\n    black_king_square = board.king(chess.BLACK)\n    \n    defenders_white = count_defenders(white_king_square, chess.WHITE)\n    defenders_black = count_defenders(black_king_square, chess.BLACK)\n    \n    return float(defenders_white - defenders_black)", "def feature(board: chess.Board) -> float:\n    \"Calculates the total mobility of each player based on legal moves.\"\n    mobility_white = len(list(board.legal_moves)) if board.turn else 0\n    mobility_black = len(list(board.legal_moves)) if not board.turn else 0\n    return float(mobility_white - mobility_black)", "def feature(board: chess.Board) -> float:\n    \"Evaluates the potential advancement of pawns toward promotion for each side.\"\n    white_pawn_advancement = sum(7 - chess.square_rank(square) for square, piece in board.piece_map().items() if piece.piece_type == chess.PAWN and piece.color == chess.WHITE)\n    black_pawn_advancement = sum(chess.square_rank(square) for square, piece in board.piece_map().items() if piece.piece_type == chess.PAWN and piece.color == chess.BLACK)\n    return float(white_pawn_advancement - black_pawn_advancement)", "def feature(board: chess.Board) -> float:\n    \"Measures the presence of pawns on the opponent's side of the board.\"\n    white_pawn_on_black_side = sum(1 for square, piece in board.piece_map().items() if piece.color == chess.WHITE and chess.square_rank(square) > 4)\n    black_pawn_on_white_side = sum(1 for square, piece in board.piece_map().items() if piece.color == chess.BLACK and chess.square_rank(square) < 4)\n    return float(black_pawn_on_white_side - white_pawn_on_black_side)", "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in pawn structure (isolated/doubled pawns) for each player.\"\n    def pawn_structure(color):\n        structure = 0\n        pawns = [square for square, piece in board.piece_map().items() if piece.piece_type == chess.PAWN and piece.color == color]\n        files = {}\n        for square in pawns:\n            file = chess.square_file(square)\n            if file in files:\n                structure += 1  # Count doubled pawns\n            files[file] = True\n            if file > 0 and (file - 1) in files:\n                structure += 1  # Count isolated pawns\n            if file < 7 and (file + 1) in files:\n                structure += 1  # Count isolated pawns\n        return structure\n \n    white_structure = pawn_structure(chess.WHITE)\n    black_structure = pawn_structure(chess.BLACK)\n    return float(black_structure - white_structure)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of pieces per player in relation to the total number of available squares.\"\n    total_pieces = len(board.piece_map())\n    total_squares = 64\n    white_pieces = len([p for p in board.piece_map().values() if p.color == chess.WHITE])\n    black_pieces = len([p for p in board.piece_map().values() if p.color == chess.BLACK])\n    return (white_pieces + black_pieces) / total_squares", "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in material value weighted by piece activity.\"\n    piece_values = {chess.PAWN: 100, chess.KNIGHT: 320, chess.BISHOP: 330, chess.ROOK: 500, chess.QUEEN: 900}\n    white_value = sum(piece_values.get(piece.piece_type, 0) for piece in board.piece_map().values() if piece.color == chess.WHITE)\n    black_value = sum(piece_values.get(piece.piece_type, 0) for piece in board.piece_map().values() if piece.color == chess.BLACK)\n    return float(white_value - black_value)", "def feature(board: chess.Board) -> float:\n    \"Calculates the safety of the kings by counting the number of uncontrolled attack squares around them.\"\n    white_king_square = next(square for square, piece in board.piece_map().items() if piece.color == chess.WHITE and piece.piece_type == chess.KING)\n    black_king_square = next(square for square, piece in board.piece_map().items() if piece.color == chess.BLACK and piece.piece_type == chess.KING)\n    \n    white_attacks = sum(board.is_attacked_by(chess.BLACK, square) for square in chess.SQUARES if chess.square_distance(white_king_square, square) <= 1)\n    black_attacks = sum(board.is_attacked_by(chess.WHITE, square) for square in chess.SQUARES if chess.square_distance(black_king_square, square) <= 1)\n    \n    return float(white_attacks - black_attacks)", "def feature(board: chess.Board) -> float:\n    \"Measures the control of the center squares by counting the pieces that influence them.\"\n    center_squares = [chess.D4, chess.D5, chess.E4, chess.E5]\n    white_control = sum(1 for square in center_squares if board.is_attacked_by(chess.WHITE, square))\n    black_control = sum(1 for square in center_squares if board.is_attacked_by(chess.BLACK, square))\n    return float(white_control - black_control)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces each player has on the back rank.\"\n    white_home_rank = [chess.A1, chess.B1, chess.C1, chess.D1, chess.E1, chess.F1, chess.G1, chess.H1]\n    black_home_rank = [chess.A8, chess.B8, chess.C8, chess.D8, chess.E8, chess.F8, chess.G8, chess.H8]\n    white_back_rank_count = sum(1 for square in white_home_rank if board.piece_at(square) is not None)\n    black_back_rank_count = sum(1 for square in black_home_rank if board.piece_at(square) is not None)\n    return float(white_back_rank_count - black_back_rank_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the piece imbalance considering only major pieces (rooks and queens).\"\n    white_major = sum(1 for p in board.piece_map().values() if p.color == chess.WHITE and p.piece_type in [chess.ROOK, chess.QUEEN])\n    black_major = sum(1 for p in board.piece_map().values() if p.color == chess.BLACK and p.piece_type in [chess.ROOK, chess.QUEEN])\n    return float(white_major - black_major)", "def feature(board: chess.Board) -> float:\n    \"Measures how many of the opponent's pieces are on the same rank or file as each king.\"\n    white_king_square = next(square for square, piece in board.piece_map().items() if piece.color == chess.WHITE and piece.piece_type == chess.KING)\n    black_king_square = next(square for square, piece in board.piece_map().items() if piece.color == chess.BLACK and piece.piece_type == chess.KING)\n    \n    white_threats = sum(1 for square in board.piece_map().keys() if board.piece_at(square).color == chess.BLACK and (chess.square_rank(square) == chess.square_rank(white_king_square) or chess.square_file(square) == chess.square_file(white_king_square)))\n    black_threats = sum(1 for square in board.piece_map().keys() if board.piece_at(square).color == chess.WHITE and (chess.square_rank(square) == chess.square_rank(black_king_square) or chess.square_file(square) == chess.square_file(black_king_square)))\n    \n    return float(white_threats - black_threats)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pawns on the 7th rank for both players as a potential promotion indicator.\"\n    white_seventh_rank = [chess.A7, chess.B7, chess.C7, chess.D7, chess.E7, chess.F7, chess.G7, chess.H7]\n    black_seventh_rank = [chess.A2, chess.B2, chess.C2, chess.D2, chess.E2, chess.F2, chess.G2, chess.H2]\n    white_pawns_on_7th = sum(1 for square in white_seventh_rank if board.piece_at(square) is not None and board.piece_at(square).piece_type == chess.PAWN)\n    black_pawns_on_7th = sum(1 for square in black_seventh_rank if board.piece_at(square) is not None and board.piece_at(square).piece_type == chess.PAWN)\n    return float(white_pawns_on_7th - black_pawns_on_7th)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of pieces in the opponent's back rank.\"\n    back_rank = 0\n    opponent = chess.BLACK if board.turn else chess.WHITE\n    for file in range(8):\n        square = chess.square(file, 0 if opponent == chess.WHITE else 7)\n        if board.piece_at(square) and board.piece_at(square).color == opponent:\n            back_rank += 1\n    return float(back_rank)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of pieces that are pinned.\"\n    pinned_pieces = 0\n    for square in board.piece_map():\n        piece = board.piece_at(square)\n        if piece.color == board.turn:\n            for target_square in board.legal_moves:\n                if target_square.from_square == square:\n                    if board.is_check() and not board.is_checkmate():\n                        pinned_pieces += 1\n    return float(pinned_pieces)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of potential discovered attacks available.\"\n    discovered_attacks = 0\n    for square in board.piece_map():\n        piece = board.piece_at(square)\n        if piece.color == board.turn:\n            # Check for possible discovered check or attack\n            for move in board.legal_moves:\n                if move.from_square == square:\n                    board.push(move)\n                    # Check if a check or attack is created\n                    if board.is_check() or any(board.is_attacked_by(board.turn, target) for target in board.attackers(board.turn, square)):\n                        discovered_attacks += 1\n                    board.pop()\n    return float(discovered_attacks)", "def feature(board: chess.Board) -> float:\n    \"Evaluates the central control by counting pieces on central squares.\"\n    central_squares = [chess.D4, chess.D5, chess.E4, chess.E5]\n    central_control = sum(1 for sq in central_squares if board.piece_at(sq) and board.piece_at(sq).color == board.turn)\n    return float(central_control)", "def feature(board: chess.Board) -> float:\n    \"Measures the mobility of pieces, defined as the number of legal moves.\"\n    mobility = len(list(board.legal_moves))\n    return float(mobility)", "def feature(board: chess.Board) -> float:\n    \"Calculates the ratio of pieces on the board to total possible squares.\"\n    total_pieces = len(board.piece_map())\n    total_squares = 64  # 8x8 board\n    ratio = total_pieces / total_squares\n    return float(ratio)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of squares controlled by each player.\"\n    controlled_squares = {chess.WHITE: 0, chess.BLACK: 0}\n    for square in range(64):\n        if board.is_attacked_by(chess.WHITE, square):\n            controlled_squares[chess.WHITE] += 1\n        if board.is_attacked_by(chess.BLACK, square):\n            controlled_squares[chess.BLACK] += 1\n    return float(controlled_squares[chess.WHITE] - controlled_squares[chess.BLACK])", "def feature(board: chess.Board) -> float:\n    \"Calculates the distance of all opponent pieces from the back rank.\"\n    opponent = chess.BLACK if board.turn else chess.WHITE\n    total_distance = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == opponent:\n            total_distance += chess.square_rank(square) + 1 if opponent == chess.BLACK else 8 - chess.square_rank(square)\n    return float(total_distance)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of isolated pawns.\"\n    isolated_pawns = 0\n    for file in range(8):\n        if board.piece_at(chess.square(file, 1)) == chess.PAWN or board.piece_at(chess.square(file, 6)) == chess.PAWN:\n            if (file > 0 and not board.piece_at(chess.square(file - 1, 1))) and (file < 7 and not board.piece_at(chess.square(file + 1, 1))):\n                isolated_pawns += 1\n    return float(isolated_pawns)", "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in the number of pawns a player has on the board.\"\n    white_pawns = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE and piece.piece_type == chess.PAWN)\n    black_pawns = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK and piece.piece_type == chess.PAWN)\n    return float(white_pawns - black_pawns)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of pieces within the opponent's territory (ranks 6-8 for White, 1-3 for Black).\"\n    opponent_territory_count = sum(1 for position, piece in board.piece_map().items() \n                                    if (piece.color == chess.WHITE and chess.square_rank(position) >= 6) or\n                                       (piece.color == chess.BLACK and chess.square_rank(position) <= 2))\n    return float(opponent_territory_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the total distance of all pieces from their starting positions.\"\n    total_distance = sum(chess.square_distance(position, piece.color) for position, piece in board.piece_map().items())\n    return float(total_distance)", "def feature(board: chess.Board) -> float:\n    \"Evaluates the mobility by counting the total number of legal moves available for the player to move.\"\n    return float(len(list(board.legal_moves)))", "def feature(board: chess.Board) -> float:\n    \"Measures the number of pieces on the back rank of each player.\"\n    back_rank_white = sum(1 for position, piece in board.piece_map().items() \n                           if piece.color == chess.WHITE and chess.square_rank(position) == 0)\n    back_rank_black = sum(1 for position, piece in board.piece_map().items() \n                           if piece.color == chess.BLACK and chess.square_rank(position) == 7)\n    return float(back_rank_white - back_rank_black)", "def feature(board: chess.Board) -> float:\n    \"Determines the presence of major and minor pieces for each color.\"\n    white_major_count = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE and piece.piece_type in [chess.ROOK, chess.QUEEN]) \n    black_major_count = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK and piece.piece_type in [chess.ROOK, chess.QUEEN])\n    return float(white_major_count - black_major_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the total value of pieces for the current position.\"\n    piece_values = {chess.PAWN: 100, chess.KNIGHT: 300, chess.BISHOP: 300, \n                    chess.ROOK: 500, chess.QUEEN: 900, chess.KING: 0}\n    total_value = sum(piece_values[piece.piece_type] for piece in board.piece_map().values())\n    return float(total_value)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of advanced pieces on the board (pieces on favorable ranks).\"\n    advanced_piece_count = sum(1 for position, piece in board.piece_map().items() \n                                if (piece.color == chess.WHITE and chess.square_rank(position) >= 4) or \n                                   (piece.color == chess.BLACK and chess.square_rank(position) <= 3))\n    return float(advanced_piece_count)", "def feature(board: chess.Board) -> float:\n    \"Measures the total number of moves available for the current player.\"\n    return float(len(list(board.legal_moves)))", "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in the number of pawns for each color.\"\n    white_pawns = sum(1 for piece in board.piece_map().values() if piece.piece_type == chess.PAWN and piece.color == chess.WHITE)\n    black_pawns = sum(1 for piece in board.piece_map().values() if piece.piece_type == chess.PAWN and piece.color == chess.BLACK)\n    return float(white_pawns - black_pawns)", "def feature(board: chess.Board) -> float:\n    \"Evaluates the distance of all pieces from the center of the board, favoring central control.\"\n    center_squares = [chess.E4, chess.E5, chess.D4, chess.D5]\n    distance_score = sum(1 / (chess.square_distance(square, center) + 1) for square in board.piece_map() for center in center_squares)\n    return float(distance_score)", "def feature(board: chess.Board) -> float:\n    \"Measures the average piece value distance from the opponent's king.\"\n    opponent_king_square = board.king(chess.BLACK if board.turn else chess.WHITE)\n    total_distance = sum(chess.square_distance(square, opponent_king_square) for square in board.piece_map() if board.piece_map()[square].color == (chess.WHITE if board.turn else chess.BLACK))\n    piece_count = len([square for square in board.piece_map() if board.piece_map()[square].color == (chess.WHITE if board.turn else chess.BLACK)])\n    return total_distance / (piece_count + 1)  # Avoid division by zero", "def feature(board: chess.Board) -> float:\n    \"Checks if there are any hanging pieces on the board.\"\n    hanging_count = sum(1 for square in board.piece_map() if board.is_attacked_by(not board.piece_map()[square].color, square))\n    return float(hanging_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the material imbalance taking into account the position of the knights.\"\n    knight_positions = sum(1 for square in board.piece_map() if board.piece_map()[square].piece_type == chess.KNIGHT)\n    total_value = sum(board.piece_map()[square].piece_type for square in board.piece_map())\n    return float(total_value - (knight_positions * chess.KNIGHT))", "def feature(board: chess.Board) -> float:\n    \"Returns the number of pieces attacking the opponent's king.\"\n    opponent_king_square = board.king(chess.BLACK if board.turn else chess.WHITE)\n    attacking_count = len(board.attackers(board.turn, opponent_king_square))\n    return float(attacking_count)", "def feature(board: chess.Board) -> float:\n    \"Measures the king's safety based on how many squares adjacent to it are attacked.\"\n    king_square = board.king(chess.WHITE if board.turn else chess.BLACK)\n    unsafe_count = sum(1 for square in chess.SQUARES_180 if board.is_attacked_by(not board.turn, square))\n    return float(unsafe_count)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of pawns advanced for both colors and returns their difference.\"\n    white_advanced_pawns = sum(1 for square in board.piece_map() \n                                if board.piece_at(square).piece_type == chess.PAWN and \n                                board.piece_at(square).color == chess.WHITE and \n                                chess.square_rank(square) >= 4)\n    black_advanced_pawns = sum(1 for square in board.piece_map() \n                                if board.piece_at(square).piece_type == chess.PAWN and \n                                board.piece_at(square).color == chess.BLACK and \n                                chess.square_rank(square) <= 3)\n    return float(white_advanced_pawns - black_advanced_pawns)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces for each player and calculates their material imbalance.\"\n    piece_values = {chess.PAWN: 100, chess.KNIGHT: 320, chess.BISHOP: 330, \n                    chess.ROOK: 500, chess.QUEEN: 900, chess.KING: 20000}\n    white_material = sum(piece_values[board.piece_at(square).piece_type] \n                         for square in board.piece_map() \n                         if board.piece_at(square).color == chess.WHITE)\n    black_material = sum(piece_values[board.piece_at(square).piece_type] \n                         for square in board.piece_map() \n                         if board.piece_at(square).color == chess.BLACK)\n    return float(white_material - black_material)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of checkmating threats for the side to move.\"\n    if board.is_checkmate() or board.is_stalemate():\n        return 0.0\n    threats = sum(1 for move in board.legal_moves \n                  if board.is_check() or board.gives_check(move))\n    return float(threats)", "def feature(board: chess.Board) -> float:\n    \"Calculates the pawn structure stability by returning the number of doubled pawns.\"\n    doubled_pawns = 0\n    pawn_files = [0] * 8  # Count pawns in each file\n    for square in board.piece_map():\n        if board.piece_at(square).piece_type == chess.PAWN:\n            pawn_files[chess.square_file(square)] += 1\n    doubled_pawns = sum(max(0, count - 1) for count in pawn_files)\n    return float(doubled_pawns)", "def feature(board: chess.Board) -> float:\n    \"Measures the mobility of the pieces for the player to move.\"\n    mobility = len(list(board.legal_moves))\n    return float(mobility)", "def feature(board: chess.Board) -> float:\n    \"Calculates the distance of the closest enemy piece to the king for both sides.\"\n    player_king_square = None\n    enemy_king_square = None\n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.KING:\n            if piece.color == board.turn:\n                player_king_square = square\n            else:\n                enemy_king_square = square\n    if player_king_square is None or enemy_king_square is None:\n        return float('inf')\n    return float(chess.square_distance(player_king_square, enemy_king_square))", "def feature(board: chess.Board) -> float:\n    \"Measures the number of squares attacked by the side to move.\"\n    color = chess.WHITE if board.turn else chess.BLACK\n    attacked_squares = set()\n    for square in board.piece_map():\n        if board.piece_at(square).color == color:\n            attacked_squares.update(board.attackers(color, square))\n    return float(len(attacked_squares))", "def feature(board: chess.Board) -> float:\n    \"Measures the difference in material of pieces above a certain rank.\"\n    piece_values = {chess.PAWN: 100, chess.KNIGHT: 320, chess.BISHOP: 330,\n                    chess.ROOK: 500, chess.QUEEN: 900, chess.KING: 20000}\n    critical_rank = 4\n    white_material = sum(piece_values[board.piece_at(square).piece_type] \n                         for square in board.piece_map() \n                         if board.piece_at(square).color == chess.WHITE and \n                         chess.square_rank(square) >= critical_rank)\n    black_material = sum(piece_values[board.piece_at(square).piece_type] \n                         for square in board.piece_map() \n                         if board.piece_at(square).color == chess.BLACK and \n                         chess.square_rank(square) < critical_rank)\n    return float(white_material - black_material)", "def feature(board: chess.Board) -> float:\n    \"Measures the availability of open files for rooks on the board.\"\n    open_files = 0\n    for file in range(8):\n        if not any(board.piece_at(chess.square(file, rank)) \n                   for rank in range(8)):  # File is open\n            open_files += 1\n    return float(open_files)", "def feature(board: chess.Board) -> float:\n    \"Measures the control of the center by counting the number of pieces in central squares (d4, d5, e4, e5).\"\n    center_squares = [chess.parse_square('d4'), chess.parse_square('d5'), chess.parse_square('e4'), chess.parse_square('e5')]\n    control = sum(1 for sq in center_squares if board.piece_at(sq) is not None)\n    return float(control)", "def feature(board: chess.Board) -> float:\n    \"Calculates the total number of protected pieces for the player whose turn it is.\"\n    color = board.turn\n    protected_count = 0\n    for square in board.piece_map():\n        piece = board.piece_at(square)\n        if piece.color == color:\n            if any(board.is_attacked_by(not color, attacker) for attacker in board.attackers(color, square)):\n                continue\n            protected_count += 1\n    return float(protected_count)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of doubled pawns for each player, favoring the player with fewer.\"\n    white_doubled = sum(1 for file in range(8) if board.piece_at(chess.square(file, 1)) and board.piece_at(chess.square(file, 3)))\n    black_doubled = sum(1 for file in range(8) if board.piece_at(chess.square(file, 6)) and board.piece_at(chess.square(file, 4)))\n    return float(white_doubled - black_doubled)", "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in the number of threats made by each player (pieces attacking opponent's pieces).\"\n    white_threats = sum(1 for square in board.piece_map() if board.piece_at(square).color == chess.WHITE and board.attackers(chess.BLACK, square))\n    black_threats = sum(1 for square in board.piece_map() if board.piece_at(square).color == chess.BLACK and board.attackers(chess.WHITE, square))\n    return float(white_threats - black_threats)", "def feature(board: chess.Board) -> float:\n    \"Measuring king safety by counting the number of squares around the king that are attacked by enemy pieces.\"\n    color = board.turn\n    king_square = next(square for square, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color == color)\n    attacked_squares = sum(1 for sq in chess.SQUARES if board.is_attacked_by(not color, sq) and chess.square_distance(king_square, sq) <= 1)\n    return float(attacked_squares)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of passed pawns for both players and returns the difference.\"\n    def is_passed_pawn(square, color):\n        if color == chess.WHITE:\n            return all(board.piece_at(chess.square(file, rank)) is None for file in range(chess.square_file(square), 8) for rank in range(chess.square_rank(square) + 1, 8))\n        else:\n            return all(board.piece_at(chess.square(file, rank)) is None for file in range(chess.square_file(square), -1, -1) for rank in range(chess.square_rank(square) - 1, -1, -1))\n\n    white_passed = sum(1 for sq in board.piece_map() if board.piece_at(sq).color == chess.WHITE and board.piece_at(sq).piece_type == chess.PAWN and is_passed_pawn(sq, chess.WHITE))\n    black_passed = sum(1 for sq in board.piece_map() if board.piece_at(sq).color == chess.BLACK and board.piece_at(sq).piece_type == chess.PAWN and is_passed_pawn(sq, chess.BLACK))\n    return float(white_passed - black_passed)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces each player has on the back rank.\"\n    white_back_rank = sum(1 for file in range(8) if board.piece_at(chess.square(file, 0)) is not None and board.piece_at(chess.square(file, 0)).color == chess.WHITE)\n    black_back_rank = sum(1 for file in range(8) if board.piece_at(chess.square(file, 7)) is not None and board.piece_at(chess.square(file, 7)).color == chess.BLACK)\n    return float(white_back_rank - black_back_rank)", "def feature(board: chess.Board) -> float:\n    \"Evaluates the pawn structure by counting isolated pawns for each player and returning the difference.\"\n    def is_isolated_pawn(square, color):\n        file = chess.square_file(square)\n        if color == chess.WHITE:\n            return (file == 0 or board.piece_at(chess.square(file - 1, 1)) is None) and (file == 7 or board.piece_at(chess.square(file + 1, 1)) is None)\n        else:\n            return (file == 0 or board.piece_at(chess.square(file - 1, 6)) is None) and (file == 7 or board.piece_at(chess.square(file + 1, 6)) is None)\n\n    white_isolated = sum(1 for sq in board.piece_map() if board.piece_at(sq).color == chess.WHITE and board.piece_at(sq).piece_type == chess.PAWN and is_isolated_pawn(sq, chess.WHITE))\n    black_isolated = sum(1 for sq in board.piece_map() if board.piece_at(sq).color == chess.BLACK and board.piece_at(sq).piece_type == chess.PAWN and is_isolated_pawn(sq, chess.BLACK))\n    return float(white_isolated - black_isolated)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of pieces per color on the board.\"\n    white_pieces = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE)\n    black_pieces = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK)\n    return float(white_pieces - black_pieces)", "def feature(board: chess.Board) -> float:\n    \"Calculates the total safety of the king based on the number of defenders.\"\n    king_square = board.king(chess.WHITE) if board.turn else board.king(chess.BLACK)\n    defenders = sum(1 for square in board.attackers(chess.WHITE if board.turn else chess.BLACK, king_square) if board.piece_at(square) is not None)\n    return float(defenders)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces still on their starting ranks for both players.\"\n    starting_ranks = [0, 1] if board.turn else [6, 7]\n    starting_pieces = sum(1 for square, piece in board.piece_map().items() if chess.square_rank(square) in starting_ranks)\n    return float(starting_pieces)", "def feature(board: chess.Board) -> float:\n    \"Evaluates pawn structure by counting doubled pawns for both sides.\"\n    doubled_pawns = 0\n    for file in range(8):\n        pawns = [square for square in board.piece_map() if board.piece_at(square).piece_type == chess.PAWN and chess.square_file(square) == file]\n        if len(pawns) > 1:\n            doubled_pawns += len(pawns) - 1\n    return float(doubled_pawns)", "def feature(board: chess.Board) -> float:\n    \"Measures the distance of pieces to the enemy king, indicating attacking potential.\"\n    enemy_king_square = board.king(chess.BLACK if board.turn else chess.WHITE)\n    distance_sum = sum(chess.square_distance(square, enemy_king_square) for square in board.piece_map() if board.piece_at(square).color == (chess.WHITE if board.turn else chess.BLACK))\n    return float(distance_sum)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces threatening the opponent's back rank.\"\n    back_rank = 0 if board.turn else 7\n    threats = sum(1 for square in board.legal_moves if chess.square_rank(square.to_square) == back_rank)\n    return float(threats)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of outposts held by the player whose turn it is.\"\n    outpost_count = 0\n    for square in board.piece_map():\n        piece = board.piece_at(square)\n        if piece.color == (chess.WHITE if board.turn else chess.BLACK):\n            rank_threshold = 4 if piece.color == chess.WHITE else 3\n            if chess.square_rank(square) > rank_threshold and not board.is_attacked_by(chess.BLACK if piece.color == chess.WHITE else chess.WHITE, square):\n                outpost_count += 1\n    return float(outpost_count)", "def feature(board: chess.Board) -> float:\n    \"Measures the control of central squares by counting pieces on d4, d5, e4, e5.\"\n    central_squares = [chess.D4, chess.D5, chess.E4, chess.E5]\n    control_count = sum(1 for square in central_squares if board.piece_at(square) is not None)\n    return float(control_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of pieces attacking the opponent's king.\"\n    opponent_king_square = board.king(chess.BLACK if board.turn else chess.WHITE)\n    attackers_count = len(board.attackers(board.turn, opponent_king_square))\n    return float(attackers_count)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces that have no legal moves.\"\n    zero_legal_moves_count = sum(1 for piece in board.piece_map().values() if not list(board.legal_moves))\n    return float(zero_legal_moves_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of pinned pieces on the board.\"\n    pinned_count = 0\n    for piece in board.piece_map().values():\n        if piece.color == board.turn:\n            for move in board.legal_moves:\n                if move.from_square == piece:\n                    if board.is_check() and not board.piece_at(move.to_square):\n                        pinned_count += 1\n    return float(pinned_count)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of discovered attacks present on the board.\"\n    discovered_attacks_count = 0\n    for piece in board.piece_map().values():\n        if piece.color == board.turn:\n            for move in board.legal_moves:\n                if board.is_attacked_by(not board.turn, move.to_square):\n                    discovered_attacks_count += 1\n    return float(discovered_attacks_count)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of pieces that are pinned to the king (both own and enemy).\"\n    pinned_count = sum(1 for square, piece in board.piece_map().items() if board.is_attacked_by(not piece.color, square) and piece.piece_type != chess.KING)\n    return float(pinned_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the total number of squares controlled by each player.\"\n    control_white = sum(1 for square in chess.SQUARES if board.attackers(chess.WHITE, square))\n    control_black = sum(1 for square in chess.SQUARES if board.attackers(chess.BLACK, square))\n    return float(control_white - control_black)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of open files for rooks for both players.\"\n    open_files = sum(1 for file in range(8) if all(board.piece_at(chess.square(file, rank)) is None for rank in range(8)))\n    return float(open_files)", "def feature(board: chess.Board) -> float:\n    \"Measures the density of pieces in the center (d4, e4, d5, e5 squares).\"\n    center_squares = [chess.D4, chess.E4, chess.D5, chess.E5]\n    center_density = sum(1 for square in center_squares if board.piece_at(square) is not None)\n    return float(center_density)", "def feature(board: chess.Board) -> float:\n    \"Calculates the mobility of each side based on legal moves available.\"\n    mobility_white = len(list(board.legal_moves)) if board.turn else 0\n    mobility_black = len(list(board.legal_moves)) if not board.turn else 0\n    return float(mobility_white - mobility_black)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of minor pieces each player has on the board.\"\n    minor_white = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE and piece.piece_type in [chess.KNIGHT, chess.BISHOP])\n    minor_black = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK and piece.piece_type in [chess.KNIGHT, chess.BISHOP])\n    return float(minor_white - minor_black)", "def feature(board: chess.Board) -> float:\n    \"Measures the king safety by counting the number of squares around the king that are attacked.\"\n    king_square = next(square for square, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color == (chess.WHITE if board.turn else chess.BLACK))\n    attacked_squares = sum(1 for square in chess.SQUARES if board.is_attacked_by(not board.turn, square) and chess.square_distance(king_square, square) <= 1)\n    return float(attacked_squares)", "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in the number of pawns above their starting rank.\"\n    pawns_above_start = lambda color: sum(1 for square, piece in board.piece_map().items() if piece.color == color and piece.piece_type == chess.PAWN and (\n        (color == chess.WHITE and chess.square_rank(square) > 1) or (color == chess.BLACK and chess.square_rank(square) < 6)))\n    return float(pawns_above_start(chess.WHITE) - pawns_above_start(chess.BLACK))", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces on the back rank (1st for White, 8th for Black) for each player.\"\n    back_rank_white = sum(1 for square in range(0, 8) if board.piece_at(chess.square(square, 0)) is not None)\n    back_rank_black = sum(1 for square in range(0, 8) if board.piece_at(chess.square(square, 7)) is not None)\n    return float(back_rank_white - back_rank_black)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of pawns on the 3rd and 4th ranks for both colors.\"\n    white_pawns = sum(1 for sq in range(8) if board.piece_at(chess.square(sq, 3)) == chess.PAWN or board.piece_at(chess.square(sq, 4)) == chess.PAWN)\n    black_pawns = sum(1 for sq in range(8) if board.piece_at(chess.square(sq, 4)) == chess.PAWN or board.piece_at(chess.square(sq, 3)) == chess.PAWN)\n    return float(white_pawns - black_pawns)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of squares controlled by each player's pieces.\"\n    def count_controlled_squares(color):\n        controlled = set()\n        for piece in board.piece_map().values():\n            if piece.color == color:\n                controlled.update(board.legal_moves)\n        return len(controlled)\n\n    white_controlled = count_controlled_squares(chess.WHITE)\n    black_controlled = count_controlled_squares(chess.BLACK)\n    return float(white_controlled - black_controlled)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces currently pinned by each player.\"\n    pinned_white = sum(1 for sq in board.piece_map() if board.is_attacked_by(chess.BLACK, sq) and board.piece_map()[sq].color == chess.WHITE)\n    pinned_black = sum(1 for sq in board.piece_map() if board.is_attacked_by(chess.WHITE, sq) and board.piece_map()[sq].color == chess.BLACK)\n    return float(pinned_white - pinned_black)", "def feature(board: chess.Board) -> float:\n    \"Calculates the distance from both kings to the nearest opposing piece.\"\n    white_king_sq = next((sq for sq, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color == chess.WHITE), None)\n    black_king_sq = next((sq for sq, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color == chess.BLACK), None)\n\n    white_distance = min(chess.square_distance(white_king_sq, sq) for sq, piece in board.piece_map().items() if piece.color == chess.BLACK)\n    black_distance = min(chess.square_distance(black_king_sq, sq) for sq, piece in board.piece_map().items() if piece.color == chess.WHITE)\n\n    return float(white_distance - black_distance)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of squares in the 2nd and 7th ranks occupied by pawns.\"\n    white_pawn_squares = sum(1 for sq in range(8) if board.piece_at(chess.square(sq, 1)) == chess.PAWN)\n    black_pawn_squares = sum(1 for sq in range(8) if board.piece_at(chess.square(sq, 6)) == chess.PAWN)\n    return float(white_pawn_squares - black_pawn_squares)", "def feature(board: chess.Board) -> float:\n    \"Calculates the total value of pieces within a certain range (for example, ranks 3 and 4).\"\n    def piece_value(piece):\n        if piece.piece_type == chess.PAWN:\n            return 100\n        elif piece.piece_type == chess.KNIGHT:\n            return 320\n        elif piece.piece_type == chess.BISHOP:\n            return 330\n        elif piece.piece_type == chess.ROOK:\n            return 500\n        elif piece.piece_type == chess.QUEEN:\n            return 900\n        elif piece.piece_type == chess.KING:\n            return 0 # King's value is heavily situational\n\n    total_value = 0\n    for sq, piece in board.piece_map().items():\n        if chess.square_rank(sq) in (2, 3):  # Only look at ranks 3 and 4 (0-indexed)\n            total_value += piece_value(piece)\n    \n    return float(total_value)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of major pieces (rooks and queens) each side has.\"\n    white_major_pieces = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE and piece.piece_type in (chess.ROOK, chess.QUEEN))\n    black_major_pieces = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK and piece.piece_type in (chess.ROOK, chess.QUEEN))\n    return float(white_major_pieces - black_major_pieces)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of legal moves available to each player.\"\n    white_legal_moves = len(list(board.legal_moves))\n    # Compute legal moves for the other player using a copy of the board\n    board.push(chess.Move.null())\n    black_legal_moves = len(list(board.legal_moves))\n    board.pop()  # Return to the original position\n    return float(white_legal_moves - black_legal_moves)", "def feature(board: chess.Board) -> float:\n    \"Measures the total number of pieces for each color on the board.\"\n    white_count = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE)\n    black_count = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK)\n    return float(white_count - black_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the distance from the king to the nearest enemy piece.\"\n    king_square = next(square for square, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color == board.turn)\n    enemy_pieces = [square for square, piece in board.piece_map().items() if piece.color != board.turn]\n    distances = [chess.square_distance(king_square, ep) for ep in enemy_pieces]\n    return float(min(distances)) if distances else float('inf')", "def feature(board: chess.Board) -> float:\n    \"Counts the number of advanced pawns on the board.\"\n    advanced_pawns = sum(1 for square, piece in board.piece_map().items() if piece.piece_type == chess.PAWN and \n                         (piece.color == chess.WHITE and chess.square_rank(square) >= 3) or \n                         (piece.color == chess.BLACK and chess.square_rank(square) <= 4))\n    return float(advanced_pawns)", "def feature(board: chess.Board) -> float:\n    \"Calculates the total value of all pieces present on the board.\"\n    piece_values = {\n        chess.PAWN: 100,\n        chess.KNIGHT: 300,\n        chess.BISHOP: 300,\n        chess.ROOK: 500,\n        chess.QUEEN: 900,\n        chess.KING: 0\n    }\n    total_value = sum(piece_values[piece.piece_type] for piece in board.piece_map().values())\n    return float(total_value)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces under attack for the current player.\"\n    total_attacked = sum(1 for square in board.piece_map() if board.is_attacked_by(board.turn, square))\n    return float(total_attacked)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of forced moves available to the current player.\"\n    forced_moves = sum(1 for move in board.legal_moves if board.is_check() and not board.is_checkmate())\n    return float(forced_moves)", "def feature(board: chess.Board) -> float:\n    \"Check if the current player is in a check position.\"\n    return float(board.is_check())", "def feature(board: chess.Board) -> float:\n    \"Measures the difference in the number of pawns on the seventh rank.\"\n    white_sevenths = sum(1 for square in board.piece_map() if board.piece_at(square).color == chess.WHITE and chess.square_rank(square) == 6)\n    black_sevenths = sum(1 for square in board.piece_map() if board.piece_at(square).color == chess.BLACK and chess.square_rank(square) == 1)\n    return float(white_sevenths - black_sevenths)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of pieces in the opponent's half of the board.\"\n    opponent_half_count = sum(1 for square in board.piece_map() if (board.piece_at(square).color == chess.WHITE and chess.square_rank(square) >= 4) or \n                                                                     (board.piece_at(square).color == chess.BLACK and chess.square_rank(square) <= 3))\n    return float(opponent_half_count)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces pinned against the king.\"\n    current_king_square = next(square for square, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color == board.turn)\n    pinned_count = sum(1 for square, piece in board.piece_map().items() if board.is_attacked_by(not board.turn, square) and \\\n                        chess.square_distance(square, current_king_square) < 3 and \\\n                        board.attackers(not board.turn, square))\n    return float(pinned_count)", "def feature(board: chess.Board) -> float:\n    \"Measures the total number of pieces that are pinned to the king.\"\n    pinned_count = 0\n    for square in board.piece_map():\n        piece = board.piece_at(square)\n        if piece and piece.color == board.turn:\n            attackers = board.attackers(not board.turn, square)\n            if any(board.is_attacked_by(not board.turn, king_square) for king_square in board.piece_map() if board.piece_at(king_square).piece_type == chess.KING):\n                pinned_count += 1\n    return float(pinned_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the material value of the least valuable piece of the current player.\"\n    material_values = {\n        chess.PAWN: 100,\n        chess.KNIGHT: 300,\n        chess.BISHOP: 300,\n        chess.ROOK: 500,\n        chess.QUEEN: 900,\n        chess.KING: 0\n    }\n    min_value = float('inf')\n    for piece in board.piece_map().values():\n        if piece.color == board.turn:\n            min_value = min(min_value, material_values[piece.piece_type])\n    return float(min_value) if min_value != float('inf') else 0.0", "def feature(board: chess.Board) -> float:\n    \"Calculates the average distance of the player's pawns to the 8th rank.\"\n    pawn_squares = [square for square in board.piece_map() if board.piece_at(square).piece_type == chess.PAWN and board.piece_at(square).color == board.turn]\n    if not pawn_squares:\n        return 0.0\n    average_distance = sum(7 - chess.square_rank(sq) for sq in pawn_squares) / len(pawn_squares)\n    return float(average_distance)", "def feature(board: chess.Board) -> float:\n    \"Measures the activity of rooks by counting their open files.\"\n    open_files = set()\n    for square in board.piece_map():\n        piece = board.piece_at(square)\n        if piece and piece.color == board.turn and piece.piece_type == chess.ROOK:\n            file = chess.square_file(square)\n            if not any(board.piece_at(chess.square(file, rank)) for rank in range(8)):\n                open_files.add(file)\n    return float(len(open_files))", "def feature(board: chess.Board) -> float:\n    \"Measures imbalance in knight and bishop presence for both players.\"\n    white_knights = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE and piece.piece_type == chess.KNIGHT)\n    black_knights = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK and piece.piece_type == chess.KNIGHT)\n    white_bishops = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE and piece.piece_type == chess.BISHOP)\n    black_bishops = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK and piece.piece_type == chess.BISHOP)\n    knight_bishop_difference = (white_knights + white_bishops) - (black_knights + black_bishops)\n    return float(knight_bishop_difference)", "def feature(board: chess.Board) -> float:\n    \"Calculates the king safety based on the number of pieces within one square of the king.\"\n    king_square = next((sq for sq in board.piece_map() if board.piece_at(sq).piece_type == chess.KING and board.piece_at(sq).color == board.turn), None)\n    if king_square is None:\n        return 0.0\n    surrounding_pieces = sum(1 for sq in chess.SQUARES if chess.square_distance(king_square, sq) == 1 and board.piece_at(sq) is not None)\n    return float(surrounding_pieces)", "def feature(board: chess.Board) -> float:\n    \"Measures the total number of pieces within the central 16 squares.\"\n    central_squares = [chess.D4, chess.D5, chess.E4, chess.E5, chess.D3, chess.D6, chess.E3, chess.E6]\n    total_pieces = sum(1 for square in central_squares if board.piece_at(square) is not None)\n    return float(total_pieces)", "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in mobility for both players.\"\n    white_moves = len(list(board.legal_moves) if board.turn else [])\n    black_moves = len(list(board.legal_moves) if not board.turn else [])\n    mobility_difference = white_moves - black_moves\n    return float(mobility_difference)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pawns on each side that are on their fifth or sixth ranks.\"\n    white_advanced_pawns = sum(1 for square in chess.SQUARES if board.piece_at(square) == chess.PAWN and chess.square_rank(square) >= 4 and board.piece_at(square).color == chess.WHITE)\n    black_advanced_pawns = sum(1 for square in chess.SQUARES if board.piece_at(square) == chess.PAWN and chess.square_rank(square) <= 3 and board.piece_at(square).color == chess.BLACK)\n    advanced_pawns_difference = white_advanced_pawns - black_advanced_pawns\n    return float(advanced_pawns_difference)", "def feature(board: chess.Board) -> float:\n    \"Calculates the total number of pieces that are being attacked.\"\n    total_attacked = sum(1 for square in board.piece_map() if board.is_attacked_by(not board.turn, square))\n    return float(total_attacked)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of minor pieces (knights and bishops) each player has on the board.\"\n    white_minor_pieces = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE and piece.piece_type in {chess.KNIGHT, chess.BISHOP})\n    black_minor_pieces = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK and piece.piece_type in {chess.KNIGHT, chess.BISHOP})\n    minor_piece_difference = white_minor_pieces - black_minor_pieces\n    return float(minor_piece_difference)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces that are pinned against the king.\"\n    pinned_count = sum(1 for square, piece in board.piece_map().items() if board.is_attacked_by(not piece.color, square) and piece.piece_type != chess.KING)\n    return float(pinned_count)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of squares controlled by each player's pieces.\"\n    white_controlled_squares = len(set(move.to_square for move in board.legal_moves if board.turn))\n    black_controlled_squares = len(set(move.to_square for move in board.legal_moves if not board.turn))\n    control_difference = white_controlled_squares - black_controlled_squares\n    return float(control_difference)", "def feature(board: chess.Board) -> float:\n    \"Calculates the total number of squares occupied by pawns for each player.\"\n    white_pawn_squares = sum(1 for square in chess.SQUARES if board.piece_at(square) == chess.PAWN and board.piece_at(square).color == chess.WHITE)\n    black_pawn_squares = sum(1 for square in chess.SQUARES if board.piece_at(square) == chess.PAWN and board.piece_at(square).color == chess.BLACK)\n    pawn_square_difference = white_pawn_squares - black_pawn_squares\n    return float(pawn_square_difference)", "def feature(board: chess.Board) -> float:\n    \"Measures the total number of rook files that are open (no pawns).\"\n    open_file_count = 0\n    for file in range(8):\n        if not any(board.piece_at(chess.square(file, rank)) == chess.PAWN for rank in range(8)):\n            open_file_count += 1\n    return float(open_file_count)", "def feature(board: chess.Board) -> float:\n    \"Measures the control of the center squares by counting pieces on d4, d5, e4, and e5.\"\n    center_squares = [chess.D4, chess.D5, chess.E4, chess.E5]\n    control_count = sum(1 for square in center_squares if board.piece_at(square) is not None)\n    return float(control_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of pieces that are pinned to the king by an opponent's piece.\"\n    pinned_count = sum(1 for square in board.piece_map() \n                       if board.is_attacked_by(not board.turn, square)\n                       and board.is_attacked_by(board.turn, square))\n    return float(pinned_count)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of advanced pawns for both sides and returns the difference.\"\n    white_advanced = sum(1 for square in range(8) if board.piece_at(chess.A2 + square) == chess.PAWN and chess.square_rank(chess.A2 + square) >= 4)\n    black_advanced = sum(1 for square in range(8) if board.piece_at(chess.A7 + square) == chess.PAWN and chess.square_rank(chess.A7 + square) <= 4)\n    return float(white_advanced - black_advanced)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of pawns on the 6th and 7th ranks for both players as a sign of advancement.\"\n    pawns_advanced = sum(1 for square in range(8) \n                         if (board.piece_at(chess.A7 + square) == chess.PAWN or board.piece_at(chess.A6 + square) == chess.PAWN))\n    return float(pawns_advanced)", "def feature(board: chess.Board) -> float:\n    \"Measures the total distance of all pieces from their respective back ranks to evaluate piece activity.\"\n    distance_sum = sum(chess.square_rank(square) * (1 if piece.color == chess.WHITE else -1) \n                       for square, piece in board.piece_map().items())\n    return float(distance_sum)", "def feature(board: chess.Board) -> float:\n    \"Measures the difference in the number of pieces that are attacked versus those that are defended.\"\n    attacked_count = sum(1 for square in board.piece_map() if board.is_attacked_by(not board.turn, square))\n    defended_count = sum(1 for square in board.piece_map() if board.is_attacked_by(board.turn, square))\n    return float(attacked_count - defended_count)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces on the back rank for both players.\"\n    back_rank_pieces = sum(1 for square in range(8) \n                           if (board.piece_at(chess.A1 + square) is not None and chess.square_rank(chess.A1 + square) == (0 if board.turn else 7)))\n    return float(back_rank_pieces)", "def feature(board: chess.Board) -> float:\n    \"Measures the amount of open files for rooks by counting the number of undoccupied squares in rook starting files.\"\n    open_file_count = sum(1 for file in range(8) \n                          if (all(board.piece_at(chess.square_file(file) + rank) is None for rank in range(8))))\n    return float(open_file_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the total number of pieces that are within two ranks of the opponent's back rank, indicating pressure.\"\n    pressure_count = sum(1 for square, piece in board.piece_map().items() \n                         if (piece.color == chess.WHITE and chess.square_rank(square) >= 6) or \n                            (piece.color == chess.BLACK and chess.square_rank(square) <= 1))\n    return float(pressure_count)", "def feature(board: chess.Board) -> float:\n    'Measures the number of pawns in advanced positions for both players.'\n    advanced_white = sum(1 for square in board.piece_map() if board.piece_at(square).color == chess.WHITE and chess.square_rank(square) > 3)\n    advanced_black = sum(1 for square in board.piece_map() if board.piece_at(square).color == chess.BLACK and chess.square_rank(square) < 4)\n    result = float(advanced_white - advanced_black)\n    return result", "def feature(board: chess.Board) -> float:\n    'Calculates the number of pieces in the last two ranks for each player.'\n    pieces_in_last_two_white = sum(1 for square in board.piece_map() if board.piece_at(square).color == chess.WHITE and chess.square_rank(square) > 5)\n    pieces_in_last_two_black = sum(1 for square in board.piece_map() if board.piece_at(square).color == chess.BLACK and chess.square_rank(square) < 2)\n    result = float(pieces_in_last_two_white - pieces_in_last_two_black)\n    return result", "def feature(board: chess.Board) -> float:\n    'Counts the number of isolated pawns for both players.'\n    isolated_white = sum(1 for square in board.piece_map() if board.piece_at(square).color == chess.WHITE and board.piece_at(square).piece_type == chess.PAWN and not (board.is_attacked_by(chess.BLACK, chess.square_file(square) - 1) or board.is_attacked_by(chess.BLACK, chess.square_file(square) + 1)))\n    isolated_black = sum(1 for square in board.piece_map() if board.piece_at(square).color == chess.BLACK and board.piece_at(square).piece_type == chess.PAWN and not (board.is_attacked_by(chess.WHITE, chess.square_file(square) - 1) or board.is_attacked_by(chess.WHITE, chess.square_file(square) + 1)))\n    result = float(isolated_white - isolated_black)\n    return result", "def feature(board: chess.Board) -> float:\n    'Calculates the mobility of the player to move based on available legal moves.'\n    mobility = len(list(board.legal_moves))\n    result = float(mobility)\n    return result", "def feature(board: chess.Board) -> float:\n    'Evaluates the center control by counting pieces on central squares.'\n    center_squares = [chess.D4, chess.D5, chess.E4, chess.E5]\n    control_white = sum(1 for square in center_squares if board.piece_at(square) and board.piece_at(square).color == chess.WHITE)\n    control_black = sum(1 for square in center_squares if board.piece_at(square) and board.piece_at(square).color == chess.BLACK)\n    result = float(control_white - control_black)\n    return result", "def feature(board: chess.Board) -> float:\n    'Counts the number of hanging pieces (pieces that are unprotected) on the board.'\n    hanging_pieces = sum(1 for square in board.piece_map() if board.piece_at(square) and not board.attackers(board.piece_at(square).color, square))\n    result = float(hanging_pieces)\n    return result", "def feature(board: chess.Board) -> float:\n    'Calculates the pawn structure by checking for pawn chains (connected pawns).'\n    pawn_chains = 0\n    for file in range(8):\n        file_pawns = [square for square in range(8) if board.piece_at(chess.square(file, square)) and board.piece_at(chess.square(file, square)).piece_type == chess.PAWN]\n        if len(file_pawns) > 1:\n            pawn_chains += len(file_pawns) - 1\n    result = float(pawn_chains)\n    return result", "def feature(board: chess.Board) -> float:\n    \"Measures the number of pieces that can capture enemy pieces in the next move.\"\n    attackers_count = sum(1 for move in board.legal_moves if board.is_attacked_by(board.turn, move.to_square))\n    return float(attackers_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the average distance of all pieces from the center of the board.\"\n    center_square = (chess.E4, chess.E5, chess.D4, chess.D5)\n    total_distance = sum(chess.square_distance(square, chess.E4) for square in board.piece_map().keys())\n    average_distance = total_distance / len(board.piece_map()) if board.piece_map() else 0.0\n    return average_distance", "def feature(board: chess.Board) -> float:\n    \"Counts the number of enemy pieces under attack and gives an advantage score.\"\n    attacked_enemy_count = sum(1 for square in board.piece_map() if board.is_attacked_by(not board.turn, square))\n    return float(attacked_enemy_count)", "def feature(board: chess.Board) -> float:\n    \"Checks if the king is on a corner square and gives an advantage value.\"\n    king_square = next((square for square, piece in board.piece_map().items() \n                        if piece.piece_type == chess.KING and piece.color == board.turn), None)\n    is_corner_king = chess.square_file(king_square) in (0, 7) and chess.square_rank(king_square) in (0, 7)\n    return 1.0 if is_corner_king else 0.0", "def feature(board: chess.Board) -> float:\n    \"Counts the number of unguarded pieces, which may indicate weak positions.\"\n    unguarded_count = sum(1 for square, piece in board.piece_map().items() \n                          if not board.is_attacked_by(not piece.color, square) and \n                             piece.color == board.turn)\n    return float(unguarded_count)", "def feature(board: chess.Board) -> float:\n    \"Measures the total number of pieces that are pinned against the kings.\"\n    pinned_pieces_count = sum(1 for square in board.piece_map() if \n                               board.is_attacked_by(not board.turn, square) and \n                               board.is_attacked_by(board.turn, square))\n    return float(pinned_pieces_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the sum of the values of pawns compared to other pieces on the board.\"\n    pawn_value = sum(1 for piece in board.piece_map().values() if piece.piece_type == chess.PAWN)\n    other_pieces_value = sum(2 for piece in board.piece_map().values() if piece.piece_type != chess.PAWN)\n    return float(pawn_value - other_pieces_value)", "def feature(board: chess.Board) -> float:\n    \"Estimates the mobility factor based on the total number of legal moves available for both sides.\"\n    white_moves = sum(1 for move in board.legal_moves if move.from_square & chess.WHITE)\n    black_moves = sum(1 for move in board.legal_moves if move.from_square & chess.BLACK)\n    return float(white_moves - black_moves)", "def feature(board: chess.Board) -> float:\n    \"Measures the total value of pieces for each player and returns the difference.\"\n    piece_values = {chess.PAWN: 100, chess.KNIGHT: 320, chess.BISHOP: 330, chess.ROOK: 500, chess.QUEEN: 900, chess.KING: 0}\n    white_value = sum(piece_values[p.piece_type] for p in board.piece_map().values() if p.color == chess.WHITE)\n    black_value = sum(piece_values[p.piece_type] for p in board.piece_map().values() if p.color == chess.BLACK)\n    return float(white_value - black_value)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of safe squares for the player's king.\"\n    king_square = next((sq for sq, p in board.piece_map().items() if p.color == board.turn and p.piece_type == chess.KING), None)\n    if king_square is None:\n        return 0.0\n    safe_squares = sum(1 for move in chess.SQUARES if not board.is_attacked_by(not board.turn, move) and board.is_legal(chess.Move(king_square, move)))\n    return float(safe_squares)", "def feature(board: chess.Board) -> float:\n    \"Calculates the depth of the most advanced piece of each player.\"\n    def max_advance(color):\n        return max((chess.square_rank(sq) if color == chess.WHITE else 7 - chess.square_rank(sq)) for sq, p in board.piece_map().items() if p.color == color)\n    white_advance = max_advance(chess.WHITE)\n    black_advance = max_advance(chess.BLACK)\n    return float(white_advance - black_advance)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces that are currently pinned.\"\n    pinned_count = sum(1 for sq, p in board.piece_map().items() if board.attackers(not p.color, sq) and p.piece_type != chess.KING)\n    return float(pinned_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the ratio of pieces in the center four squares relative to total pieces.\"\n    center_squares = {chess.E4, chess.E5, chess.D4, chess.D5}\n    total_pieces = len(board.piece_map())\n    center_piece_count = sum(1 for sq in center_squares if board.piece_at(sq) is not None)\n    return float(center_piece_count) / total_pieces if total_pieces > 0 else 0.0", "def feature(board: chess.Board) -> float:\n    \"Measures the difference in mobility of pieces: total legal moves for each player.\"\n    white_moves = len(list(board.legal_moves)) if board.turn == chess.WHITE else len(list(board.legal_moves))\n    black_moves = len(list(board.legal_moves)) if board.turn == chess.BLACK else len(list(board.legal_moves))\n    return float(white_moves - black_moves)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of pawns that are defended versus those that are attacked.\"\n    defended_pawns = sum(1 for sq in board.piece_map() \n                         if board.piece_at(sq).piece_type == chess.PAWN \n                         and len(board.attackers(board.piece_at(sq).color, sq)) == 0 \n                         and board.is_attacked_by(not board.piece_at(sq).color, sq))\n    attacked_pawns = sum(1 for sq in board.piece_map() \n                         if board.piece_at(sq).piece_type == chess.PAWN \n                         and len(board.attackers(not board.piece_at(sq).color, sq)) > 0)\n    return float(defended_pawns - attacked_pawns)", "def feature(board: chess.Board) -> float:\n    \"Calculates the total mobility by counting the number of legal moves available for each player.\"\n    white_mobility = len(list(board.legal_moves)) if board.turn else 0\n    black_mobility = len(list(board.legal_moves)) if not board.turn else 0\n    return float(white_mobility - black_mobility)", "def feature(board: chess.Board) -> float:\n    \"Measures the distance of each player's king from the center of the board.\"\n    white_king = next((sq for sq in board.piece_map() \n                       if board.piece_at(sq).piece_type == chess.KING \n                       and board.piece_at(sq).color == chess.WHITE), None)\n    black_king = next((sq for sq in board.piece_map() \n                       if board.piece_at(sq).piece_type == chess.KING \n                       and board.piece_at(sq).color == chess.BLACK), None)\n    if white_king is None or black_king is None:\n        return 0.0\n    distance = chess.square_distance(white_king, chess.E4) - chess.square_distance(black_king, chess.E4)\n    return float(distance)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pawns reached beyond their optimal ranks.\"\n    advanced_pawns = sum(1 for sq in board.piece_map() \n                         if board.piece_at(sq).piece_type == chess.PAWN \n                         and ((board.piece_at(sq).color == chess.WHITE and chess.square_rank(sq) > 4) or \n                              (board.piece_at(sq).color == chess.BLACK and chess.square_rank(sq) < 4)))\n    return float(advanced_pawns)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of pieces currently occupying the back rank for both players.\"\n    white_back_rank = sum(1 for sq in range(56, 64) \n                          if board.piece_at(sq) is not None and board.piece_at(sq).color == chess.WHITE)\n    black_back_rank = sum(1 for sq in range(0, 8) \n                          if board.piece_at(sq) is not None and board.piece_at(sq).color == chess.BLACK)\n    return float(white_back_rank - black_back_rank)", "def feature(board: chess.Board) -> float:\n    \"Measures the bishop pair advantage by checking the number of bishops each player has.\"\n    white_bishops = sum(1 for sq in board.piece_map() \n                        if board.piece_at(sq).piece_type == chess.BISHOP and board.piece_at(sq).color == chess.WHITE)\n    black_bishops = sum(1 for sq in board.piece_map() \n                        if board.piece_at(sq).piece_type == chess.BISHOP and board.piece_at(sq).color == chess.BLACK)\n    return float(white_bishops - black_bishops)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of doubled pawns for each player.\"\n    white_doubled = sum(1 for file in range(8) \n                        if sum(1 for rank in range(8) \n                               if board.piece_at(chess.square(file, rank)) == chess.PAWN \n                               and chess.pawn_color(board, rank) == chess.WHITE) > 1)\n    black_doubled = sum(1 for file in range(8) \n                        if sum(1 for rank in range(8) \n                               if board.piece_at(chess.square(file, rank)) == chess.PAWN \n                               and chess.pawn_color(board, rank) == chess.BLACK) > 1)\n    return float(white_doubled - black_doubled)", "def feature(board: chess.Board) -> float:\n    \"Measures the central control by counting pieces on central squares (d4, d5, e4, e5).\"\n    central_squares = [chess.D4, chess.D5, chess.E4, chess.E5]\n    control_count = sum(1 for square in central_squares if board.piece_at(square) is not None)\n    return float(control_count)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces that are pinned to a king.\"\n    pinned_pieces = 0\n    for square in board.piece_map():\n        piece = board.piece_at(square)\n        if board.is_attacked_by(not piece.color, square) and \\\n           any(board.is_attacked_by(piece.color, target_square) for target_square in board.attackers(not piece.color, square)):\n            pinned_pieces += 1\n    return float(pinned_pieces)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of threats made by each side (pieces attacking opponent pieces).\"\n    threats = sum(1 for square in board.piece_map() if board.is_attacked_by(not board.piece_at(square).color, square))\n    return float(threats)", "def feature(board: chess.Board) -> float:\n    \"Calculates the total number of pieces on the board excluding pawns.\"\n    piece_count = sum(1 for piece in board.piece_map().values() if piece.piece_type != chess.PAWN)\n    return float(piece_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of major pieces (rooks and queens) remaining on the board.\"\n    major_piece_count = sum(1 for piece in board.piece_map().values() if piece.piece_type in [chess.ROOK, chess.QUEEN])\n    return float(major_piece_count)", "def feature(board: chess.Board) -> float:\n    \"Measures the total number of pawn moves available for each player.\"\n    white_moves = sum(1 for move in board.legal_moves if board.piece_at(move.from_square).color == chess.WHITE and board.piece_at(move.from_square).piece_type == chess.PAWN)\n    black_moves = sum(1 for move in board.legal_moves if board.piece_at(move.from_square).color == chess.BLACK and board.piece_at(move.from_square).piece_type == chess.PAWN)\n    return float(white_moves - black_moves)", "def feature(board: chess.Board) -> float:\n    \"Calculates the total value of pieces for each player and returns the difference.\"\n    total_value_white = sum(piece.piece_type for piece in board.piece_map().values() if piece.color == chess.WHITE)\n    total_value_black = sum(piece.piece_type for piece in board.piece_map().values() if piece.color == chess.BLACK)\n    return float(total_value_white - total_value_black)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pawns for each player and returns the ratio.\"\n    pawns_white = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE and piece.piece_type == chess.PAWN)\n    pawns_black = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK and piece.piece_type == chess.PAWN)\n    return float(pawns_white / (pawns_black + 1))  # Adding 1 to avoid division by zero", "def feature(board: chess.Board) -> float:\n    \"Measures the number of squares occupied by pieces for each player.\"\n    occupied_squares_white = sum(1 for square in board.piece_map() if board.piece_at(square).color == chess.WHITE)\n    occupied_squares_black = sum(1 for square in board.piece_map() if board.piece_at(square).color == chess.BLACK)\n    return float(occupied_squares_white - occupied_squares_black)", "def feature(board: chess.Board) -> float:\n    \"Calculates the average rank of all pieces for the player to move.\"\n    pieces = [square for square, piece in board.piece_map().items() if piece.color == board.turn]\n    if not pieces:\n        return 0.0\n    average_rank = sum(chess.square_rank(square) for square in pieces) / len(pieces)\n    return float(average_rank)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces on the board and returns a normalized value.\"\n    total_pieces = len(board.piece_map())\n    return float(total_pieces / 32)  # Normalizing to the full board size", "def feature(board: chess.Board) -> float:\n    \"Measures distance of player's king from the center squares.\"\n    king_square = next(square for square, piece in board.piece_map().items() if piece.color == board.turn and piece.piece_type == chess.KING)\n    center_squares = [chess.E4, chess.E5, chess.D4, chess.D5]\n    distance = min(chess.square_distance(king_square, square) for square in center_squares)\n    return float(distance)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces attacked by opponent for each player.\"\n    attacked_by_opponent = sum(1 for square in board.piece_map() if board.is_attacked_by(not board.turn, square))\n    return float(attacked_by_opponent)", "def feature(board: chess.Board) -> float:\n    \"Measures the count of pieces that are defending each player's king.\"\n    king_square = next(square for square, piece in board.piece_map().items() if piece.color == board.turn and piece.piece_type == chess.KING)\n    defending_pieces = sum(1 for square in board.piece_map() if board.is_attacked_by(not board.turn, square) and square in board.attackers(board.turn, king_square))\n    return float(defending_pieces)", "def feature(board: chess.Board) -> float:\n    \"Calculates a score based on the mobility of pieces - number of legal moves.\"\n    legal_moves = len(list(board.legal_moves))\n    return float(legal_moves)", "def feature(board: chess.Board) -> float:\n    \"Assesses the central control by counting pieces in the center squares.\"\n    center_squares = [chess.D4, chess.D5, chess.E4, chess.E5]\n    central_control = sum(1 for square in center_squares if square in board.piece_map())\n    return float(central_control)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of connected pawns for each player.\"\n    white_connected = sum(1 for sq in board.piece_map() if board.piece_at(sq).color == chess.WHITE and (board.piece_at(sq + 1) if sq % 8 < 7 else None) and (board.piece_at(sq - 1) if sq % 8 > 0 else None))\n    black_connected = sum(1 for sq in board.piece_map() if board.piece_at(sq).color == chess.BLACK and (board.piece_at(sq + 1) if sq % 8 < 7 else None) and (board.piece_at(sq - 1) if sq % 8 > 0 else None))\n    return float(white_connected - black_connected)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces on the opponent's back rank to assess control.\"\n    opponent_back_rank = chess.square_rank(0) if board.turn else chess.square_rank(7)\n    opponent_pieces = sum(1 for sq in range(8) if board.piece_at(chess.square(sq, opponent_back_rank)) is not None)\n    return float(opponent_pieces)", "def feature(board: chess.Board) -> float:\n    \"Calculates the average piece value for each player.\"\n    piece_values = {chess.PAWN: 100, chess.KNIGHT: 300, chess.BISHOP: 300, chess.ROOK: 500, chess.QUEEN: 900, chess.KING: 0}\n    white_value = sum(piece_values[board.piece_at(sq).piece_type] for sq in board.piece_map() if board.piece_at(sq).color == chess.WHITE)\n    black_value = sum(piece_values[board.piece_at(sq).piece_type] for sq in board.piece_map() if board.piece_at(sq).color == chess.BLACK)\n    return float(white_value - black_value)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of pieces not developed (not on the 2nd or 7th rank for pawns, and not within the central area for other pieces).\"\n    undeveloped_pieces = sum(1 for sq in board.piece_map() if (\n        (board.piece_at(sq).piece_type == chess.PAWN and ((board.piece_at(sq).color == chess.WHITE and chess.square_rank(sq) < 3) or (board.piece_at(sq).color == chess.BLACK and chess.square_rank(sq) > 4))) or\n        (board.piece_at(sq).piece_type != chess.PAWN and (chess.square_file(sq) < 2 or chess.square_file(sq) > 5 or (board.piece_at(sq).color == chess.WHITE and chess.square_rank(sq) < 2) or (board.piece_at(sq).color == chess.BLACK and chess.square_rank(sq) > 5)))\n    ))\n    return float(undeveloped_pieces)", "def feature(board: chess.Board) -> float:\n    \"Calculates the sum of the distances of pieces from the center of the board.\"\n    center_squares = [chess.E4, chess.D4, chess.E5, chess.D5]\n    total_distance = sum(chess.square_distance(sq, center) for sq in board.piece_map() for center in center_squares)\n    return float(total_distance)", "def feature(board: chess.Board) -> float:\n    \"Checks if either player's king is exposed (not well defended and susceptible to checks).\"\n    exposed_kings = 0\n    for color in [chess.WHITE, chess.BLACK]:\n        king_sq = next(sq for sq, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color == color)\n        if not board.is_attacked_by(not color, king_sq):\n            exposed_kings += 1\n    return float(exposed_kings)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of attacks on the opponent's king to measure threats.\"\n    opponent_king_square = next(sq for sq, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color != board.turn)\n    attacking_pieces = sum(1 for sq in board.piece_map() if board.is_attacked_by(board.piece_at(sq).color, opponent_king_square))\n    return float(attacking_pieces)", "def feature(board: chess.Board) -> float:\n    \"Evaluates pawn structure by counting isolated pawns.\"\n    isolated_pawns = sum(1 for sq in [chess.A2, chess.B2, chess.C2, chess.D2, chess.E2, chess.F2, chess.G2, chess.H2] if (\n        board.piece_at(sq) and board.piece_at(sq).piece_type == chess.PAWN and\n        (not board.piece_at(sq + 1) if sq % 8 < 7 else True) and\n        (not board.piece_at(sq - 1) if sq % 8 > 0 else True)\n    ))\n    return float(isolated_pawns)", "def feature(board: chess.Board) -> float:\n    \"Calculates the influence of pieces in the center (d4, d5, e4, e5).\"\n    center_squares = [chess.D4, chess.E4, chess.D5, chess.E5]\n    influence = sum(1 for sq in center_squares if board.piece_at(sq))\n    return float(influence)", "def feature(board: chess.Board) -> float:\n    \"Calculates the sum of the values of pieces that are on the back rank.\"\n    back_rank_value = 0\n    back_rank = 0 if board.turn == chess.WHITE else 7\n    for file in range(8):\n        piece = board.piece_at(chess.square(file, back_rank))\n        if piece is not None and piece.color == board.turn:\n            back_rank_value += piece.piece_type\n    return float(back_rank_value)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pawns on the 4th and 5th ranks for White or 4th and 3rd ranks for Black.\"\n    pawn_count = 0\n    if board.turn == chess.WHITE:\n        ranks = [3, 4]\n    else:\n        ranks = [4, 5]\n    for rank in ranks:\n        for file in range(8):\n            piece = board.piece_at(chess.square(file, rank))\n            if piece is not None and piece.piece_type == chess.PAWN and piece.color == board.turn:\n                pawn_count += 1\n    return float(pawn_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the total distance of all pieces from their starting positions.\"\n    total_distance = 0\n    piece_map = board.piece_map()\n    for square, piece in piece_map.items():\n        start_rank = 7 if piece.color == chess.WHITE else 0\n        piece_start_square = chess.square(chess.square_file(square), start_rank)\n        total_distance += chess.square_distance(square, piece_start_square)\n    return float(total_distance)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of squares attacked by both players.\"\n    white_attacks = sum(1 for move in board.legal_moves if move.from_square != None and move.to_square != None and board.is_attacked_by(chess.BLACK, move.to_square))\n    black_attacks = sum(1 for move in board.legal_moves if move.from_square != None and move.to_square != None and board.is_attacked_by(chess.WHITE, move.to_square))\n    return float(white_attacks + black_attacks)", "def feature(board: chess.Board) -> float:\n    \"Measures the material balance considering the presence of major pieces.\"\n    major_piece_value = 0\n    for piece in board.piece_map().values():\n        if piece.piece_type in [chess.ROOK, chess.QUEEN]:\n            major_piece_value += piece.piece_type\n    return float(major_piece_value)", "def feature(board: chess.Board) -> float:\n    \"Assesses mobility by counting the number of legal moves for each player.\"\n    white_moves = len(list(board.legal_moves)) if board.turn == chess.WHITE else 0\n    black_moves = len(list(board.legal_moves)) if board.turn == chess.BLACK else 0\n    return float(white_moves - black_moves)", "def feature(board: chess.Board) -> float:\n    \"Calculates the ratio of advanced pieces to the total number of pieces on the board.\"\n    advanced_piece_count = sum(1 for square, piece in board.piece_map().items() if (piece.color == chess.WHITE and chess.square_rank(square) >= 4) or (piece.color == chess.BLACK and chess.square_rank(square) <= 3))\n    total_piece_count = len(board.piece_map())\n    return float(advanced_piece_count / total_piece_count) if total_piece_count > 0 else 0.0", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces located on the 7th and 8th ranks.\"\n    rank_count = 0\n    for rank in [6, 7]:  # 7th and 8th ranks in 0-indexed\n        for file in range(8):\n            piece = board.piece_at(chess.square(file, rank))\n            if piece is not None:\n                rank_count += 1\n    return float(rank_count)", "def feature(board: chess.Board) -> float:\n    \"Measures the distance of the kings from the center of the board.\"\n    white_king = board.king(chess.WHITE)\n    black_king = board.king(chess.BLACK)\n    white_distance = chess.square_distance(white_king, chess.parse_square('e4'))\n    black_distance = chess.square_distance(black_king, chess.parse_square('e4'))\n    return float(white_distance + black_distance)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of advanced pawns (pawns on ranks 4 or 5 for White and 4 or 3 for Black)\"\n    advanced_pawn_count = sum(1 for square, piece in board.piece_map().items()\n                               if piece.piece_type == chess.PAWN and\n                               ((piece.color == chess.WHITE and chess.square_rank(square) >= 4) or\n                                (piece.color == chess.BLACK and chess.square_rank(square) <= 3)))\n    return float(advanced_pawn_count)", "def feature(board: chess.Board) -> float:\n    \"Measures the piece safety based on the number of attackers on each piece\"\n    piece_safety_score = sum(len(board.attackers(piece.color, square))\n                              for square, piece in board.piece_map().items())\n    return float(piece_safety_score)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of connected pawns for both players\"\n    connected_pawns = 0\n    for file in range(8):\n        white_pawns = sum(1 for rank in range(8) if board.piece_at(chess.square(file, rank)) == chess.PAWN and chess.WHITE)\n        black_pawns = sum(1 for rank in range(8) if board.piece_at(chess.square(file, rank)) == chess.PAWN and chess.BLACK)\n        if white_pawns >= 2:\n            connected_pawns += white_pawns\n        if black_pawns >= 2:\n            connected_pawns += black_pawns\n    return float(connected_pawns)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of pieces on the board that are in front of their respective pawns\"\n    in_front_of_pawns = sum(1 for square, piece in board.piece_map().items()\n                             if piece.color == chess.WHITE and chess.square_rank(square) > 1 and \n                             board.piece_at(chess.square(chess.square_file(square), chess.square_rank(square) - 1)) == chess.PAWN or\n                             piece.color == chess.BLACK and chess.square_rank(square) < 6 and \n                             board.piece_at(chess.square(chess.square_file(square), chess.square_rank(square) + 1)) == chess.PAWN)\n    return float(in_front_of_pawns)", "def feature(board: chess.Board) -> float:\n    \"Measures the ratio of major pieces (rooks and queens) to minor pieces (knights and bishops) on the board\"\n    major_piece_count = sum(1 for piece in board.piece_map().values() \n                             if piece.piece_type in {chess.ROOK, chess.QUEEN})\n    minor_piece_count = sum(1 for piece in board.piece_map().values() \n                             if piece.piece_type in {chess.KNIGHT, chess.BISHOP})\n    return float(major_piece_count / (minor_piece_count + 1))", "def feature(board: chess.Board) -> float:\n    \"Counts how many pieces are on the seventh rank for both players\"\n    pieces_on_seventh_rank = sum(1 for square, piece in board.piece_map().items()\n                                  if (piece.color == chess.WHITE and chess.square_rank(square) == 6) or \n                                     (piece.color == chess.BLACK and chess.square_rank(square) == 1))\n    return float(pieces_on_seventh_rank)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of defending pieces around each king\"\n    white_king_defense = sum(1 for square in chess.SQUARES if board.is_attacked_by(chess.BLACK, square) and board.piece_at(square) and board.piece_at(square).color == chess.WHITE)\n    black_king_defense = sum(1 for square in chess.SQUARES if board.is_attacked_by(chess.WHITE, square) and board.piece_at(square) and board.piece_at(square).color == chess.BLACK)\n    return float(white_king_defense + black_king_defense)", "def feature(board: chess.Board) -> float:\n    \"Measures the distance of the queens from the center of the board (e4 and d4)\"\n    total_distance = sum(chess.square_distance(square, chess.parse_square('e4')) + \n                         chess.square_distance(square, chess.parse_square('d4'))\n                         for square, piece in board.piece_map().items()\n                         if piece.piece_type == chess.QUEEN)\n    return float(total_distance)", "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in the number of central control pieces between players\"\n    control_squares_white = sum(1 for square in [chess.D4, chess.D5, chess.E4, chess.E5]\n                                 if board.is_attacked_by(chess.WHITE, square))\n    control_squares_black = sum(1 for square in [chess.D4, chess.D5, chess.E4, chess.E5]\n                                 if board.is_attacked_by(chess.BLACK, square))\n    return float(control_squares_white - control_squares_black)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of pieces that are pinned\"\n    pinned_count = sum(1 for square, piece in board.piece_map().items() \n                       if board.is_attacked_by(not piece.color, square) and not board.legal_moves)\n    return float(pinned_count)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of pieces attacked by the opponent's pieces.\"\n    attacked_count = sum(1 for square in board.piece_map() if board.is_attacked_by(not board.turn, square))\n    return float(attacked_count)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of unprotected pieces that each player has.\"\n    unprotected_count = sum(1 for square, piece in board.piece_map().items() \n                             if piece.color == board.turn and \n                             len(board.attackers(not board.turn, square)) == 0)\n    return float(unprotected_count)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pawns on the 6th and 7th ranks for both players.\"\n    advanced_pawns = sum(1 for square, piece in board.piece_map().items() \n                         if piece.piece_type == chess.PAWN and \n                         ((piece.color == chess.WHITE and chess.square_rank(square) >= 5) or \n                          (piece.color == chess.BLACK and chess.square_rank(square) <= 2)))\n    return float(advanced_pawns)", "def feature(board: chess.Board) -> float:\n    \"Measures the distribution of pieces on the board, based on their ranks.\"\n    rank_distribution = [0] * 8\n    for square in board.piece_map():\n        rank_distribution[chess.square_rank(square)] += 1\n    return float(max(rank_distribution))", "def feature(board: chess.Board) -> float:\n    \"Calculates the ratio of major pieces (rooks and queens) that each player has compared to total pieces.\"\n    major_pieces_count = sum(1 for piece in board.piece_map().values() \n                              if piece.piece_type in (chess.ROOK, chess.QUEEN))\n    total_pieces_count = len(board.piece_map())\n    return float(major_pieces_count / total_pieces_count) if total_pieces_count > 0 else 0.0", "def feature(board: chess.Board) -> float:\n    \"Measures the total distance of all pieces from their home ranks.\"\n    total_distance = sum(chess.square_rank(square) if piece.color == chess.WHITE \n                          else 7 - chess.square_rank(square) \n                          for square, piece in board.piece_map().items())\n    return float(total_distance)", "def feature(board: chess.Board) -> float:\n    \"Measures the center control by counting the pieces in the center squares.\"\n    center_squares = [chess.D4, chess.D5, chess.E4, chess.E5]\n    center_control = sum(1 for square in center_squares if board.piece_at(square) is not None)\n    return float(center_control)", "def feature(board: chess.Board) -> float:\n    \"Calculates the pawn structure by counting isolated pawns.\"\n    isolated_pawn_count = 0\n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.PAWN:\n            file = chess.square_file(square)\n            if (board.piece_at(chess.square(file - 1, chess.square_rank(square))) is None and \n                board.piece_at(chess.square(file + 1, chess.square_rank(square))) is None):\n                isolated_pawn_count += 1\n    return float(isolated_pawn_count)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of minor pieces remaining on the board.\"\n    minor_pieces = sum(1 for piece in board.piece_map().values() if piece.piece_type in (chess.KNIGHT, chess.BISHOP))\n    return float(minor_pieces)", "def feature(board: chess.Board) -> float:\n    \"Calculates the mobility of major pieces by counting legal moves.\"\n    major_piece_moves = sum(len(list(board.legal_moves)) for piece in board.piece_map().values() if piece.piece_type in (chess.ROOK, chess.QUEEN) and piece.color == board.turn)\n    return float(major_piece_moves)", "def feature(board: chess.Board) -> float:\n    \"Evaluates the centralized position of the king, closer to the center is better.\"\n    white_king = next(square for square, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color == chess.WHITE)\n    black_king = next(square for square, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color == chess.BLACK)\n    white_distance = chess.square_distance(white_king, chess.E4) + chess.square_distance(white_king, chess.E5)\n    black_distance = chess.square_distance(black_king, chess.E4) + chess.square_distance(black_king, chess.E5)\n    return float(black_distance - white_distance)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of pieces that are poorly positioned, i.e., on the back rank without any attacking lines.\"\n    poorly_positioned_pieces = sum(1 for square, piece in board.piece_map().items() if piece.color == board.turn and chess.square_rank(square) == (0 if piece.color == chess.WHITE else 7) and not list(board.attackers(board.turn, square)))\n    return float(poorly_positioned_pieces)", "def feature(board: chess.Board) -> float:\n    \"Measures the total number of pieces available for potential trade.\"\n    tradeable_pieces = sum(1 for piece in board.piece_map().values() if piece.color == board.turn and piece.piece_type in (chess.QUEEN, chess.ROOK, chess.BISHOP, chess.KNIGHT, chess.PAWN))\n    return float(tradeable_pieces)", "def feature(board: chess.Board) -> float:\n    \"Calculates the overall balance of material by summing piece values and accounting for potential future threats.\"\n    piece_values = {chess.PAWN: 100, chess.KNIGHT: 320, chess.BISHOP: 330, chess.ROOK: 500, chess.QUEEN: 900, chess.KING: 20000}\n    material_balance = sum(piece_values[piece.piece_type] for piece in board.piece_map().values() if piece.color == board.turn)\n    return float(material_balance)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of pieces on the back ranks for both players.\"\n    back_rank_white = sum(1 for sq in range(56, 64) if board.piece_at(sq) and board.piece_at(sq).color == chess.WHITE)\n    back_rank_black = sum(1 for sq in range(0, 8) if board.piece_at(sq) and board.piece_at(sq).color == chess.BLACK)\n    return float(back_rank_white - back_rank_black)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pawns that have reached the 6th rank or higher.\"\n    advanced_pawns = sum(1 for sq in board.piece_map() if board.piece_map()[sq].piece_type == chess.PAWN and \n                         ((board.piece_map()[sq].color == chess.WHITE and chess.square_rank(sq) >= 5) or\n                          (board.piece_map()[sq].color == chess.BLACK and chess.square_rank(sq) <= 2)))\n    return float(advanced_pawns)", "def feature(board: chess.Board) -> float:\n    \"Calculates the total number of minor pieces (knights and bishops).\"\n    minor_pieces_white = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE and piece.piece_type in {chess.KNIGHT, chess.BISHOP})\n    minor_pieces_black = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK and piece.piece_type in {chess.KNIGHT, chess.BISHOP})\n    return float(minor_pieces_white - minor_pieces_black)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces attacked by each player.\"\n    attacked_pieces_white = sum(1 for sq in board.piece_map() if board.piece_map()[sq].color == chess.WHITE and board.is_attacked_by(chess.BLACK, sq))\n    attacked_pieces_black = sum(1 for sq in board.piece_map() if board.piece_map()[sq].color == chess.BLACK and board.is_attacked_by(chess.WHITE, sq))\n    return float(attacked_pieces_white - attacked_pieces_black)", "def feature(board: chess.Board) -> float:\n    \"Calculates the total distance of all pieces from the center of the board.\"\n    center_squares = [chess.E4, chess.E5, chess.D4, chess.D5]\n    total_distance = sum(chess.square_distance(sq, center_sq) for sq in board.piece_map() for center_sq in center_squares)\n    return float(total_distance)", "def feature(board: chess.Board) -> float:\n    \"Calculates the total value of material for each side based on standard piece values.\"\n    piece_values = {chess.PAWN: 100, chess.KNIGHT: 300, chess.BISHOP: 300, chess.ROOK: 500, chess.QUEEN: 900, chess.KING: 0}\n    total_value_white = sum(piece_values[board.piece_map()[sq].piece_type] for sq in board.piece_map() if board.piece_map()[sq].color == chess.WHITE)\n    total_value_black = sum(piece_values[board.piece_map()[sq].piece_type] for sq in board.piece_map() if board.piece_map()[sq].color == chess.BLACK)\n    return float(total_value_white - total_value_black)", "def feature(board: chess.Board) -> float:\n    \"Calculates the ratio of rooks and queens to total pieces on the board.\"\n    major_pieces_ratio = sum(1 for piece in board.piece_map().values() if piece.piece_type in {chess.ROOK, chess.QUEEN})\n    total_pieces = len(board.piece_map())\n    return float(major_pieces_ratio / total_pieces) if total_pieces > 0 else 0.0", "def feature(board: chess.Board) -> float:\n    \"Measures the control of central squares by counting the pieces on them.\"\n    control_squares = [chess.D4, chess.D5, chess.E4, chess.E5]\n    control_count = sum(1 for sq in control_squares if board.piece_at(sq) and board.piece_at(sq).color == board.turn)\n    return float(control_count)", "def feature(board: chess.Board) -> float:\n    \"Evaluates the presence of potential passed pawns.\"\n    passed_pawns = 0\n    for square in board.piece_map():\n        piece = board.piece_map()[square]\n        if piece.piece_type == chess.PAWN:\n            if (piece.color == chess.WHITE and all(board.piece_at(chess.square_file(square) + i * 8) is None \n                        for i in range(1, 8 - chess.square_rank(square)))):\n                passed_pawns += 1\n            elif (piece.color == chess.BLACK and all(board.piece_at(chess.square_file(square) + i * 8) is None \n                        for i in range(-1, chess.square_rank(square) + 1))):\n                passed_pawns += 1\n    return float(passed_pawns)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of available legal moves for the player to move.\"\n    return float(len(list(board.legal_moves)))", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces controlling the center squares (d4, d5, e4, e5).\"\n    center_squares = [chess.D4, chess.D5, chess.E4, chess.E5]\n    control_count = sum(1 for square in center_squares if board.is_attacked_by(chess.WHITE, square)) - \\\n                   sum(1 for square in center_squares if board.is_attacked_by(chess.BLACK, square))\n    return float(control_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of doubled pawns for both players.\"\n    pawn_positions = [square for square, piece in board.piece_map().items() if piece.piece_type == chess.PAWN]\n    doubled_pawn_count = sum(1 for file in range(8) if len([sq for sq in pawn_positions if chess.square_file(sq) == file]) > 1)\n    return float(doubled_pawn_count)", "def feature(board: chess.Board) -> float:\n    \"Measures the distance of the king from the center (e4 or d4).\"\n    king_square = [sq for sq, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color == board.turn]\n    if not king_square:\n        return 10.0  # Arbitrarily high distance if king is not found\n    distance_to_center = chess.square_distance(king_square[0], chess.E4) + chess.square_distance(king_square[0], chess.D4)\n    return float(distance_to_center)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pawn pushes (pawns that have moved at least one rank).\"\n    pawn_push_count = sum(1 for square, piece in board.piece_map().items() if piece.piece_type == chess.PAWN and \\\n                          ((piece.color == chess.WHITE and chess.square_rank(square) >= 3) or \\\n                          (piece.color == chess.BLACK and chess.square_rank(square) <= 4)))\n    return float(pawn_push_count)", "def feature(board: chess.Board) -> float:\n    \"Measures the difference in development of minor pieces (knights and bishops) between both players.\"\n    white_minor = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE and \\\n                     piece.piece_type in {chess.KNIGHT, chess.BISHOP})\n    black_minor = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK and \\\n                     piece.piece_type in {chess.KNIGHT, chess.BISHOP})\n    return float(white_minor - black_minor)", "def feature(board: chess.Board) -> float:\n    \"Calculates the ratio of pawns to total pieces on the board.\"\n    total_pieces = len(board.piece_map())\n    if total_pieces == 0:\n        return 0.0  # Prevent division by zero\n    pawn_count = sum(1 for piece in board.piece_map().values() if piece.piece_type == chess.PAWN)\n    return float(pawn_count) / total_pieces", "def feature(board: chess.Board) -> float:\n    \"Measures the number of pieces that are pinned against the king.\"\n    pinned_count = sum(1 for square, piece in board.piece_map().items() if piece.color == board.turn and \\\n                       any(king in board.attackers(board.turn, square) for king in [chess.WHITE if board.turn else chess.BLACK]))\n    return float(pinned_count)", "def feature(board: chess.Board) -> float:\n    \"Measures the total number of attacks from both sides at a position.\"\n    white_attack_count = sum(len(board.attackers(chess.WHITE, square)) for square in board.piece_map())\n    black_attack_count = sum(len(board.attackers(chess.BLACK, square)) for square in board.piece_map())\n    return float(white_attack_count - black_attack_count)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of squares occupied by enemy pieces that can be attacked (threatens).\"\n    threatened_squares = sum(1 for square in board.piece_map() if board.is_attacked_by(not board.turn, square))\n    return float(threatened_squares)", "def feature(board: chess.Board) -> float:\n    \"Calculates the total number of pieces on the board.\"\n    return float(len(board.piece_map()))", "def feature(board: chess.Board) -> float:\n    \"Measures the number of pieces that are on open files (files without pawns).\"\n    open_files = 0\n    for file in range(8):\n        if all(board.piece_at(chess.square(file, rank)) is None for rank in range(8)):\n            open_files += 1\n    return float(open_files)", "def feature(board: chess.Board) -> float:\n    \"Returns the total number of pieces attacking the opponent's king.\"\n    opponent_king_square = next(square for square, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color != board.turn)\n    return float(len(board.attackers(board.turn, opponent_king_square)))", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of pawns that are on the 4th and 5th ranks for White and 3rd and 4th ranks for Black.\"\n    advanced_pawns = 0\n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.PAWN:\n            if (piece.color == chess.WHITE and chess.square_rank(square) in (4, 5)) or (piece.color == chess.BLACK and chess.square_rank(square) in (3, 4)):\n                advanced_pawns += 1\n    return float(advanced_pawns)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of legal moves available to the player to move.\"\n    return float(len(list(board.legal_moves)))", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces in front of the opponent's king.\"\n    opponent_king_square = next(square for square, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color != board.turn)\n    count = 0\n    for square, piece in board.piece_map().items():\n        if (piece.color == board.turn and chess.square_file(square) == chess.square_file(opponent_king_square) and chess.square_rank(square) > chess.square_rank(opponent_king_square)):\n            count += 1\n    return float(count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of attacking pieces on squares that are defended by more than one piece.\"\n    count_defended_squares = 0\n    for square in range(64):\n        if board.is_attacked_by(board.turn, square) and len(board.attackers(board.turn, square)) > 1:\n            count_defended_squares += 1\n    return float(count_defended_squares)", "def feature(board: chess.Board) -> float:\n    \"Measures the imbalance in piece types between both players.\"\n    piece_counts = {chess.WHITE: {chess.PAWN: 0, chess.KNIGHT: 0, chess.BISHOP: 0, chess.ROOK: 0, chess.QUEEN: 0, chess.KING: 0},\n                    chess.BLACK: {chess.PAWN: 0, chess.KNIGHT: 0, chess.BISHOP: 0, chess.ROOK: 0, chess.QUEEN: 0, chess.KING: 0}}\n    \n    for piece in board.piece_map().values():\n        piece_counts[piece.color][piece.piece_type] += 1\n    \n    imbalance_score = sum(abs(piece_counts[chess.WHITE][ptype] - piece_counts[chess.BLACK][ptype]) for ptype in piece_counts[chess.WHITE])\n    return float(imbalance_score)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of pawns on the 7th rank for White or the 2nd rank for Black.\"\n    pawns_on_advanced_rank = sum(1 for sq in board.piece_map() if board.piece_at(sq).piece_type == chess.PAWN and ((board.piece_at(sq).color == chess.WHITE and chess.square_rank(sq) == 6) or (board.piece_at(sq).color == chess.BLACK and chess.square_rank(sq) == 1)))\n    return float(pawns_on_advanced_rank)", "def feature(board: chess.Board) -> float:\n    \"Evaluates the mobility of pieces by counting the number of legal moves for each player.\"\n    mobility_score = len(list(board.legal_moves))\n    return float(mobility_score)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of pieces threatened by enemy pieces for the current player.\"\n    threats = sum(1 for sq in board.piece_map() if board.piece_at(sq).color == (chess.WHITE if board.turn == chess.WHITE else chess.BLACK) and board.is_attacked_by(chess.WHITE if board.turn == chess.BLACK else chess.BLACK, sq))\n    return float(threats)", "def feature(board: chess.Board) -> float:\n    \"Calculates the distance of all pieces from their respective home ranks.\"\n    total_distance = sum(chess.square_rank(sq) if piece.color == chess.WHITE else (7 - chess.square_rank(sq)) for sq, piece in board.piece_map().items())\n    return float(total_distance)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of double pawns for the current player.\"\n    pawns = [sq for sq in board.piece_map() if board.piece_at(sq).piece_type == chess.PAWN and board.piece_at(sq).color == (chess.WHITE if board.turn == chess.WHITE else chess.BLACK)]\n    file_counts = {file: 0 for file in range(8)}\n    for sq in pawns:\n        file_counts[chess.square_file(sq)] += 1\n    double_pawns = sum(1 for count in file_counts.values() if count > 1)\n    return float(double_pawns)", "def feature(board: chess.Board) -> float:\n    \"Measures the potential for pawn promotion by counting the number of pawns on the 4th or 5th rank for White or 3rd or 2nd rank for Black.\"\n    potential_promotions = sum(1 for sq in board.piece_map() if board.piece_at(sq).piece_type == chess.PAWN and ((board.piece_at(sq).color == chess.WHITE and chess.square_rank(sq) >= 4) or (board.piece_at(sq).color == chess.BLACK and chess.square_rank(sq) <= 3)))\n    return float(potential_promotions)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of pieces in the opponent's territory (ranks 6 and 7 for White, and 1 and 2 for Black).\"\n    pieces_in_enemy_territory = sum(1 for sq in board.piece_map() if board.piece_at(sq).color == (chess.WHITE if board.turn == chess.WHITE else chess.BLACK) and ((board.turn == chess.WHITE and chess.square_rank(sq) >= 6) or (board.turn == chess.BLACK and chess.square_rank(sq) <= 1)))\n    return float(pieces_in_enemy_territory)", "def feature(board: chess.Board) -> float:\n    \"Calculates the distance of the nearest enemy piece for the current player's pieces.\"\n    min_distance = float('inf')\n    for sq in board.piece_map():\n        if board.piece_at(sq).color == (chess.WHITE if board.turn == chess.WHITE else chess.BLACK):\n            for enemy_sq in board.piece_map():\n                if board.piece_at(enemy_sq).color != board.piece_at(sq).color:\n                    distance = chess.square_distance(sq, enemy_sq)\n                    if distance < min_distance:\n                        min_distance = distance\n    return float(min_distance) if min_distance != float('inf') else 0.0", "def feature(board: chess.Board) -> float:\n    \"Measures the number of pawns supported by other pieces.\"\n    supported_pawns = sum(1 for square in board.piece_map() \n                          if board.piece_at(square).piece_type == chess.PAWN and \n                          any(board.is_attacked_by(not board.turn, square + direction) \n                              for direction in [1, -1] if square + direction in board.piece_map()))\n    return float(supported_pawns)", "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in the number of pawns between players.\"\n    white_pawns = len([p for p in board.piece_map().values() if p.piece_type == chess.PAWN and p.color == chess.WHITE])\n    black_pawns = len([p for p in board.piece_map().values() if p.piece_type == chess.PAWN and p.color == chess.BLACK])\n    return float(white_pawns - black_pawns)", "def feature(board: chess.Board) -> float:\n    \"Evaluates the presence of major pieces (rook and above) for current and opponent players.\"\n    major_pieces_current = len([p for p in board.piece_map().values() \n                                 if p.color == board.turn and p.piece_type >= chess.ROOK])\n    major_pieces_opponent = len([p for p in board.piece_map().values() \n                                  if p.color != board.turn and p.piece_type >= chess.ROOK])\n    return float(major_pieces_current - major_pieces_opponent)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of vulnerable pieces for the current player (unprotected pieces).\"\n    vulnerable_pieces = sum(1 for square, piece in board.piece_map().items()\n                            if piece.color == board.turn and not any(board.is_attacked_by(not board.turn, attacker) for attacker in board.attackers(not board.turn, square)))\n    return float(vulnerable_pieces)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of advanced pawns for both players and calculates the ratio.\"\n    advanced_white_pawns = len([1 for square in board.piece_map() \n                                 if board.piece_at(square).piece_type == chess.PAWN and \n                                 board.piece_at(square).color == chess.WHITE and chess.square_rank(square) >= 4])\n    advanced_black_pawns = len([1 for square in board.piece_map() \n                                 if board.piece_at(square).piece_type == chess.PAWN and \n                                 board.piece_at(square).color == chess.BLACK and chess.square_rank(square) <= 3])\n    return float(advanced_white_pawns / (advanced_black_pawns + 1))  # Avoid division by zero", "def feature(board: chess.Board) -> float:\n    \"Calculates the center control value based on pawn and piece positioning in the center.\"\n    center_squares = [chess.E4, chess.E5, chess.D4, chess.D5]\n    control = sum(1 for square in center_squares if board.piece_at(square) and board.piece_at(square).color == board.turn)\n    return float(control)", "def feature(board: chess.Board) -> float:\n    \"Calculates the mobility of the current player's pieces by counting legal moves.\"\n    mobility = len(list(board.legal_moves))\n    return float(mobility)", "def feature(board: chess.Board) -> float:\n    \"Evaluates whether the current player's king is more centralized (closer to the center of the board).\"\n    king_square = next((square for square, piece in board.piece_map().items() \n                        if piece.piece_type == chess.KING and piece.color == board.turn), None)\n    if king_square is not None:\n        center_distance = min(chess.square_distance(king_square, chess.E4), chess.square_distance(king_square, chess.E5),\n                              chess.square_distance(king_square, chess.D4), chess.square_distance(king_square, chess.D5))\n        return float(8 - center_distance)  # Closer to center scores higher\n    return 0.0", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces that are pinned (attacked and cannot move without exposing a more valuable piece)\"\n    pinned_count = 0\n    for square, piece in board.piece_map().items():\n        if board.is_attacked_by(not piece.color, square):\n            for attacker in board.attackers(not piece.color, square):\n                attacked_piece = board.piece_at(attacker)\n                if attacked_piece and attacked_piece.color == piece.color and attacked_piece.piece_type > piece.piece_type:\n                    pinned_count += 1\n                    break\n    return float(pinned_count)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of doubled pawns for both players\"\n    white_doubled = 0\n    black_doubled = 0\n    pawns = {chess.WHITE: [], chess.BLACK: []}\n    \n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.PAWN:\n            pawns[piece.color].append(chess.square_file(square))\n    \n    for file in range(8):\n        if pawns[chess.WHITE].count(file) > 1:\n            white_doubled += 1\n        if pawns[chess.BLACK].count(file) > 1:\n            black_doubled += 1\n            \n    return float(white_doubled - black_doubled)", "def feature(board: chess.Board) -> float:\n    \"Calculates the mobility of pieces by counting the total legal moves for all pieces\"\n    total_legal_moves = sum(len(list(board.legal_moves)) for square, piece in board.piece_map().items())\n    return float(total_legal_moves)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces on the board and divides by the total number of squares, representing density\"\n    piece_count = len(board.piece_map())\n    return float(piece_count) / 64.0", "def feature(board: chess.Board) -> float:\n    \"Measures the distance of each rook to the opponent's back rank, aggregated\"\n    total_distance = 0\n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.ROOK:\n            if piece.color == chess.WHITE:\n                total_distance += (7 - chess.square_rank(square))\n            else:\n                total_distance += chess.square_rank(square)\n    return float(total_distance)", "def feature(board: chess.Board) -> float:\n    \"Calculates the average piece value on the board to assess material imbalance\"\n    piece_values = {chess.PAWN: 100, chess.KNIGHT: 300, chess.BISHOP: 300, chess.ROOK: 500, chess.QUEEN: 900, chess.KING: 0}\n    total_value = 0\n    for piece in board.piece_map().values():\n        total_value += piece_values[piece.piece_type]\n    return float(total_value) / len(board.piece_map()) if len(board.piece_map()) > 0 else 0.0", "def feature(board: chess.Board) -> float:\n    \"Counts the number of advanced pawns for both sides on their respective ranks\"\n    advanced_white = sum(1 for square, piece in board.piece_map().items() if piece.color == chess.WHITE and chess.square_rank(square) >= 4)\n    advanced_black = sum(1 for square, piece in board.piece_map().items() if piece.color == chess.BLACK and chess.square_rank(square) <= 3)\n    return float(advanced_white - advanced_black)", "def feature(board: chess.Board) -> float:\n    \"Calculates the average distance of pawns from their starting ranks\"\n    total_distance = 0\n    pawn_count = 0\n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.PAWN:\n            pawn_count += 1\n            total_distance += abs(chess.square_rank(square) - (1 if piece.color == chess.WHITE else 6))\n    return float(total_distance) / pawn_count if pawn_count > 0 else 0.0", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of hanging pieces (pieces unprotected).\"\n    hanging_piece_count = 0\n    for square, piece in board.piece_map().items():\n        if piece is not None:\n            if not board.attackers(piece.color, square):\n                hanging_piece_count += 1\n    return float(hanging_piece_count)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of pawns in the opponent's territory.\"\n    opponent_territory_pawn_count = 0\n    for square, piece in board.piece_map().items():\n        if piece is not None and piece.piece_type == chess.PAWN:\n            if piece.color == chess.WHITE and chess.square_rank(square) > 4:\n                opponent_territory_pawn_count += 1\n            elif piece.color == chess.BLACK and chess.square_rank(square) < 3:\n                opponent_territory_pawn_count += 1\n    return float(opponent_territory_pawn_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the total piece activity score based on mobility.\"\n    activity_score = 0\n    for move in board.legal_moves:\n        activity_score += 1  # Count possible legal moves for active pieces\n    return float(activity_score)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces attacked by each player.\"\n    white_attacked_count = len([square for square in chess.SQUARES if board.is_attacked_by(chess.WHITE, square)])\n    black_attacked_count = len([square for square in chess.SQUARES if board.is_attacked_by(chess.BLACK, square)])\n    return float(white_attacked_count - black_attacked_count)", "def feature(board: chess.Board) -> float:\n    \"Measures the average distance of pieces to the opponent's king.\"\n    opponent_king_square = next(square for square, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color != board.turn)\n    total_distance = 0\n    piece_count = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == board.turn:\n            total_distance += chess.square_distance(square, opponent_king_square)\n            piece_count += 1\n    return total_distance / piece_count if piece_count > 0 else 0.0", "def feature(board: chess.Board) -> float:\n    \"Counts the number of forks available to each player.\"\n    fork_count = 0\n    for move in board.legal_moves:\n        board.push(move)\n        if len(board.attackers(chess.WHITE, move.to_square)) > 1 or len(board.attackers(chess.BLACK, move.to_square)) > 1:\n            fork_count += 1\n        board.pop()\n    return float(fork_count)", "def feature(board: chess.Board) -> float:\n    \"Measures the material difference between players in terms of piece values.\"\n    material_value = 0\n    piece_values = {chess.PAWN: 100, chess.KNIGHT: 320, chess.BISHOP: 330, chess.ROOK: 500, chess.QUEEN: 900}\n    for square, piece in board.piece_map().items():\n        value = piece_values.get(piece.piece_type, 0)\n        if piece.color == chess.WHITE:\n            material_value += value\n        else:\n            material_value -= value\n    return float(material_value)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of pieces in back rank while considering king safety.\"\n    back_rank_count = 0\n    for square, piece in board.piece_map().items():\n        if (piece.color == chess.WHITE and chess.square_rank(square) == 0) or (piece.color == chess.BLACK and chess.square_rank(square) == 7):\n            back_rank_count += 1\n    return float(back_rank_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the central control by counting pieces in central squares.\"\n    central_control = 0\n    central_squares = [chess.E4, chess.E5, chess.D4, chess.D5]\n    for square in central_squares:\n        if board.piece_at(square) is not None:\n            central_control += 1 if board.piece_at(square).color == board.turn else -1\n    return float(central_control)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of pawns on the 7th rank for both players.\"\n    white_pawns_on_7th = sum(1 for sq in board.piece_map() if board.piece_at(sq).piece_type == chess.PAWN and board.piece_at(sq).color == chess.WHITE and chess.square_rank(sq) == 6)\n    black_pawns_on_7th = sum(1 for sq in board.piece_map() if board.piece_at(sq).piece_type == chess.PAWN and board.piece_at(sq).color == chess.BLACK and chess.square_rank(sq) == 1)\n    return float(white_pawns_on_7th - black_pawns_on_7th)", "def feature(board: chess.Board) -> float:\n    \"Measures the total number of pieces attacking the opponent's king.\"\n    opponent_king_square = next(sq for sq in board.piece_map() if board.piece_at(sq).piece_type == chess.KING and board.piece_at(sq).color != board.turn)\n    attackers_count = sum(1 for move in board.legal_moves if move.to_square == opponent_king_square)\n    return float(attackers_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the average distance of pieces from their own back rank.\"\n    back_rank = 0 if board.turn == chess.WHITE else 7\n    piece_distances = [chess.square_rank(sq) - back_rank for sq in board.piece_map() if board.piece_at(sq).color == board.turn]\n    return float(sum(piece_distances) / len(piece_distances)) if piece_distances else 0.0", "def feature(board: chess.Board) -> float:\n    \"Counts the number of doubled pawns for both players.\"\n    pawn_files_white = {chess.square_file(sq) for sq in board.piece_map() if board.piece_at(sq).piece_type == chess.PAWN and board.piece_at(sq).color == chess.WHITE}\n    pawn_files_black = {chess.square_file(sq) for sq in board.piece_map() if board.piece_at(sq).piece_type == chess.PAWN and board.piece_at(sq).color == chess.BLACK}\n    doubled_pawns_white = sum(1 for f in pawn_files_white if sum(1 for sq in board.piece_map() if chess.square_file(sq) == f and board.piece_at(sq).color == chess.WHITE) > 1)\n    doubled_pawns_black = sum(1 for f in pawn_files_black if sum(1 for sq in board.piece_map() if chess.square_file(sq) == f and board.piece_at(sq).color == chess.BLACK) > 1)\n    return float(doubled_pawns_white - doubled_pawns_black)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of pieces that are pinned (unable to move without exposing the king).\"\n    pinned_count = sum(1 for sq in board.piece_map() if board.is_attacked_by(not board.piece_at(sq).color, sq) and not board.is_check())\n    return float(pinned_count)", "def feature(board: chess.Board) -> float:\n    \"Measures the total material value of pieces currently on the board.\"\n    piece_values = {chess.PAWN: 100, chess.KNIGHT: 320, chess.BISHOP: 330, chess.ROOK: 500, chess.QUEEN: 900, chess.KING: 0}\n    total_value = sum(piece_values[board.piece_at(sq).piece_type] for sq in board.piece_map())\n    return float(total_value)", "def feature(board: chess.Board) -> float:\n    \"Counts the squares that are central control (d4, d5, e4, e5) occupied by each player.\"\n    central_squares = {chess.parse_square(sq) for sq in ['d4', 'd5', 'e4', 'e5']}\n    control_white = sum(1 for sq in central_squares if board.piece_at(sq) and board.piece_at(sq).color == chess.WHITE)\n    control_black = sum(1 for sq in central_squares if board.piece_at(sq) and board.piece_at(sq).color == chess.BLACK)\n    return float(control_white - control_black)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of pieces in the opponent's territory (ranks 6 and 7 for White; ranks 2 and 3 for Black).\"\n    opponent_territory = range(6, 8) if board.turn == chess.WHITE else range(0, 2)\n    opponent_pieces_count = sum(1 for sq in board.piece_map() if chess.square_rank(sq) in opponent_territory and board.piece_at(sq).color != board.turn)\n    return float(opponent_pieces_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the total number of squares controlled by each player's pieces.\"\n    control_white = len(set(move.to_square for move in board.legal_moves if board.piece_at(move.from_square).color == chess.WHITE))\n    control_black = len(set(move.to_square for move in board.legal_moves if board.piece_at(move.from_square).color == chess.BLACK))\n    return float(control_white - control_black)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of advanced pawns (pawns on ranks 4 or 5 for White and 4 or 3 for Black)\"\n    advanced_pawns = sum(1 for square, piece in board.piece_map().items() if piece.piece_type == chess.PAWN and \n                         (piece.color == chess.WHITE and chess.square_rank(square) >= 4 or \n                          piece.color == chess.BLACK and chess.square_rank(square) <= 4))\n    return float(advanced_pawns)", "def feature(board: chess.Board) -> float:\n    \"Calculates the total mobility of all pieces (sum of legal moves for all pieces)\"\n    mobility = sum(len(list(board.legal_moves)) for square, piece in board.piece_map().items())\n    return float(mobility)", "def feature(board: chess.Board) -> float:\n    \"Calculates the ratio of active pieces (pieces that can move) to total pieces on the board\"\n    total_pieces = len(board.piece_map())\n    active_pieces = sum(1 for square, piece in board.piece_map().items() if len(list(board.legal_moves)) > 0)\n    return float(active_pieces / total_pieces) if total_pieces > 0 else 0.0", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces that protect their own pawns\"\n    protecting_pawns = sum(1 for square, piece in board.piece_map().items() if piece.piece_type != chess.PAWN and \n                           any(board.is_attacked_by(piece.color, pawn_square) for pawn_square in board.attackers(not piece.color, square) if board.piece_at(pawn_square) is not None and board.piece_at(pawn_square).piece_type == chess.PAWN))\n    return float(protecting_pawns)", "def feature(board: chess.Board) -> float:\n    \"Measures the distance of all pieces to their opponent's back rank\"\n    distance_to_back_rank = sum(8 - chess.square_rank(square) if piece.color == chess.WHITE else chess.square_rank(square) for square, piece in board.piece_map().items())\n    return float(distance_to_back_rank)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of doubled pawns (pawns on the same file)\"\n    pawn_files = {}\n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.PAWN:\n            file = chess.square_file(square)\n            if file in pawn_files:\n                pawn_files[file] += 1\n            else:\n                pawn_files[file] = 1\n    doubled_pawns = sum(1 for count in pawn_files.values() if count > 1)\n    return float(doubled_pawns)", "def feature(board: chess.Board) -> float:\n    \"Measures the total control of central squares (d4, d5, e4, e5)\"\n    central_squares = [chess.parse_square(sq) for sq in ['d4', 'd5', 'e4', 'e5']]\n    control = sum(1 for sq in central_squares if board.is_attacked_by(chess.WHITE, sq) or \n                  board.is_attacked_by(chess.BLACK, sq))\n    return float(control)", "def feature(board: chess.Board) -> float:\n    \"Calculates the ratio of major pieces (rooks and queens) to the total number of pieces on the board\"\n    major_pieces = sum(1 for piece in board.piece_map().values() if piece.piece_type in [chess.ROOK, chess.QUEEN])\n    total_pieces = len(board.piece_map())\n    return float(major_pieces / total_pieces) if total_pieces > 0 else 0.0", "def feature(board: chess.Board) -> float:\n    \"Measures the number of pawns on the board for each color.\"\n    pawn_count = sum(1 for piece in board.piece_map().values() if piece.piece_type == chess.PAWN)\n    return float(pawn_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of pieces that are currently attacked in the position.\"\n    attacked_count = sum(1 for square, piece in board.piece_map().items() if board.is_attacked_by(not piece.color, square))\n    return float(attacked_count)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces that are pinned.\"\n    pinned_count = 0\n    for square, piece in board.piece_map().items():\n        if piece.piece_type != chess.KING:\n            allies = board.attackers(piece.color, square)\n            if len(allies) > 0:\n                pinned_count += 1\n    return float(pinned_count)", "def feature(board: chess.Board) -> float:\n    \"Returns the count of advanced pawns more than a specific rank for each color.\"\n    white_advanced = sum(1 for square in board.piece_map() if board.piece_at(square).color == chess.WHITE and chess.square_rank(square) >= 4)\n    black_advanced = sum(1 for square in board.piece_map() if board.piece_at(square).color == chess.BLACK and chess.square_rank(square) <= 3)\n    return float(white_advanced - black_advanced)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of square attacks by major pieces (rooks/queens).\"\n    major_piece_attacks = sum(len(board.attackers(piece.color, square)) for square, piece in board.piece_map().items() if piece.piece_type in {chess.ROOK, chess.QUEEN})\n    return float(major_piece_attacks)", "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in total distance of all pieces to their home squares.\"\n    total_distance = 0\n    for square, piece in board.piece_map().items():\n        total_distance += chess.square_distance(square, chess.parse_square(chess.square_name(0 if piece.color == chess.WHITE else 7)))\n    return float(total_distance)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces in the opponent's half of the board.\"\n    opponent_half_count = sum(1 for square in board.piece_map() if (board.piece_at(square).color == chess.WHITE and chess.square_rank(square) > 3) or (board.piece_at(square).color == chess.BLACK and chess.square_rank(square) < 4))\n    return float(opponent_half_count)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of unprotected pieces on the board.\"\n    unprotected_count = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == board.turn and len(board.attackers(not piece.color, square)) == 0:\n            unprotected_count += 1\n    return float(unprotected_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the average distance of all pieces from the center of the board.\"\n    total_distance = sum(chess.square_distance(square, chess.parse_square('e4')) for square in board.piece_map())\n    average_distance = total_distance / len(board.piece_map()) if len(board.piece_map()) > 0 else 0\n    return float(average_distance)", "def feature(board: chess.Board) -> float:\n    \"Evaluates how many pieces are in the same file as the opponent's king.\"\n    opponent_king_square = next(square for square, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color != board.turn)\n    file_of_king = chess.square_file(opponent_king_square)\n    same_file_count = sum(1 for square in board.piece_map() if chess.square_file(square) == file_of_king)\n    return float(same_file_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in the number of advanced pawns for each side.\"\n    white_advanced_pawns = sum(1 for square in board.piece_map() if board.piece_at(square).color == chess.WHITE and chess.square_rank(square) >= 4)\n    black_advanced_pawns = sum(1 for square in board.piece_map() if board.piece_at(square).color == chess.BLACK and chess.square_rank(square) <= 3)\n    return float(white_advanced_pawns - black_advanced_pawns)", "def feature(board: chess.Board) -> float:\n    \"Measures the mobility of pieces by counting the number of legal moves available for each player.\"\n    white_mobility = len(list(board.legal_moves if board.turn else board.legal_moves))\n    board.turn = not board.turn\n    black_mobility = len(list(board.legal_moves))\n    board.turn = not board.turn\n    return float(white_mobility - black_mobility)", "def feature(board: chess.Board) -> float:\n    \"Counts the total value of all material on the board for both sides.\"\n    material_values = {chess.PAWN: 100, chess.KNIGHT: 320, chess.BISHOP: 330, chess.ROOK: 500, chess.QUEEN: 900, chess.KING: 0}\n    total_value = sum(material_values[piece.piece_type] for piece in board.piece_map().values())\n    return float(total_value)", "def feature(board: chess.Board) -> float:\n    \"Measures the control of central squares by counting pieces located in them.\"\n    central_squares = [chess.D4, chess.D5, chess.E4, chess.E5]\n    control_count = sum(1 for square in central_squares if board.piece_at(square) is not None and board.piece_at(square).color == board.turn)\n    return float(control_count)", "def feature(board: chess.Board) -> float:\n    \"Analyzes the opponent's king safety by counting the number of squares around it that are attacked.\"\n    opponent_color = chess.WHITE if board.turn == chess.BLACK else chess.BLACK\n    opponent_king_square = next(square for square, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color == opponent_color)\n    \n    attacked_count = sum(1 for square in chess.SQUARES if board.is_attacked_by(board.turn, square))\n    return float(attacked_count)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of isolated pawns on the board.\"\n    isolated_count = 0\n    for square in board.piece_map():\n        if board.piece_at(square).piece_type == chess.PAWN:\n            file = chess.square_file(square)\n            if not (board.piece_at(chess.parse_square(f\"{chr(file + ord('a'))}2\")) or board.piece_at(chess.parse_square(f\"{chr(file + ord('a'))}3\"))):\n                isolated_count += 1\n    return float(isolated_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the control of open files by counting rooks and queens on them.\"\n    open_files_count = 0\n    for file in range(8):\n        if all(board.piece_at(chess.parse_square(f\"{chr(file + ord('a'))}{rank + 1}\")) is None for rank in range(8)):\n            open_files_count += sum(1 for rank in range(8) if board.piece_at(chess.parse_square(f\"{chr(file + ord('a'))}{rank + 1}\")) in {chess.ROOK, chess.QUEEN})\n    return float(open_files_count)", "def feature(board: chess.Board) -> float:\n    \"Measures the total number of pawns on the board for both sides.\"\n    pawn_count = sum(1 for piece in board.piece_map().values() if piece.piece_type == chess.PAWN)\n    return float(pawn_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the material value difference between the two players.\"\n    piece_values = {chess.PAWN: 100, chess.KNIGHT: 320, chess.BISHOP: 330, chess.ROOK: 500, chess.QUEEN: 900}\n    white_value = sum(piece_values.get(piece.piece_type, 0) for piece in board.piece_map().values() if piece.color == chess.WHITE)\n    black_value = sum(piece_values.get(piece.piece_type, 0) for piece in board.piece_map().values() if piece.color == chess.BLACK)\n    return float(white_value - black_value)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces attacked by the opponent for each side.\"\n    white_attacks = sum(1 for square in board.piece_map() if board.is_attacked_by(chess.BLACK, square))\n    black_attacks = sum(1 for square in board.piece_map() if board.is_attacked_by(chess.WHITE, square))\n    return float(white_attacks - black_attacks)", "def feature(board: chess.Board) -> float:\n    \"Evaluates the king safety by counting the number of squares attacking the kings.\"\n    white_king_square = next(square for square, piece in board.piece_map().items() if piece.color == chess.WHITE and piece.piece_type == chess.KING)\n    black_king_square = next(square for square, piece in board.piece_map().items() if piece.color == chess.BLACK and piece.piece_type == chess.KING)\n    white_king_safety = len(board.attackers(chess.WHITE, black_king_square))\n    black_king_safety = len(board.attackers(chess.BLACK, white_king_square))\n    return float(black_king_safety - white_king_safety)", "def feature(board: chess.Board) -> float:\n    \"Measures the mobility of both players by counting legal moves.\"\n    white_mobility = len(list(board.legal_moves)) if board.turn else 0\n    black_mobility = len(list(board.legal_moves)) if not board.turn else 0\n    return float(white_mobility - black_mobility)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces pinned to their own king.\"\n    pinned_pieces = sum(1 for square, piece in board.piece_map().items() if board.is_attacked_by(piece.color, square) and board.is_attacked_by(not piece.color, square))\n    return float(pinned_pieces)", "def feature(board: chess.Board) -> float:\n    \"Computes the distance of both kings from their respective corners.\"\n    white_king_square = next(square for square, piece in board.piece_map().items() if piece.color == chess.WHITE and piece.piece_type == chess.KING)\n    black_king_square = next(square for square, piece in board.piece_map().items() if piece.color == chess.BLACK and piece.piece_type == chess.KING)\n    white_distance = chess.square_distance(white_king_square, chess.A1)\n    black_distance = chess.square_distance(black_king_square, chess.H8)\n    return float(black_distance - white_distance)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of advanced pawns that can potentially promote.\"\n    advanced_pawns = sum(1 for square, piece in board.piece_map().items() if piece.piece_type == chess.PAWN and \n                         ((piece.color == chess.WHITE and chess.square_rank(square) >= 6) or \n                          (piece.color == chess.BLACK and chess.square_rank(square) <= 1)))\n    return float(advanced_pawns)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of squares controlled by each player.\"\n    controlled_squares_white = sum(1 for square in range(64) if board.is_attacked_by(chess.WHITE, square))\n    controlled_squares_black = sum(1 for square in range(64) if board.is_attacked_by(chess.BLACK, square))\n    return float(controlled_squares_white - controlled_squares_black)", "def feature(board: chess.Board) -> float:\n    \"Assesses the pawn structure by counting doubled pawns.\"\n    doubled_pawns = 0\n    pawn_files = {}\n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.PAWN:\n            file = chess.square_file(square)\n            if file in pawn_files:\n                pawn_files[file] += 1\n            else:\n                pawn_files[file] = 1\n    doubled_pawns = sum(max(count - 1, 0) for count in pawn_files.values())\n    return float(doubled_pawns)", "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in the number of pawns between the two players.\"\n    white_pawns = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE and piece.piece_type == chess.PAWN)\n    black_pawns = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK and piece.piece_type == chess.PAWN)\n    return float(white_pawns - black_pawns)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces in the opponent's seventh rank.\"\n    opponent = chess.BLACK if board.turn else chess.WHITE\n    return float(sum(1 for square in range(56, 64) if board.piece_at(square) and board.piece_at(square).color == opponent))", "def feature(board: chess.Board) -> float:\n    \"Calculates the total mobility available for the current player.\"\n    return float(len(list(board.legal_moves)))", "def feature(board: chess.Board) -> float:\n    \"Measures the distance of pieces from the opponent's back rank. Closer pieces receive higher scores.\"\n    opponent_back_rank = range(0, 8) if board.turn else range(56, 64)\n    total_distance = sum(chess.square_distance(square, target) for square, piece in board.piece_map().items() if piece.color == (chess.WHITE if board.turn else chess.BLACK) for target in opponent_back_rank)\n    return 1.0 / (1.0 + total_distance) if total_distance > 0 else 1.0", "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in the number of rook pieces for both players.\"\n    white_rooks = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE and piece.piece_type == chess.ROOK)\n    black_rooks = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK and piece.piece_type == chess.ROOK)\n    return float(white_rooks - black_rooks)", "def feature(board: chess.Board) -> float:\n    \"Evaluates the control of the center by counting pieces on d4, d5, e4, and e5.\"\n    center_squares = [chess.parse_square('d4'), chess.parse_square('d5'), chess.parse_square('e4'), chess.parse_square('e5')]\n    control_score = sum(1 for square in center_squares if board.piece_at(square) and board.piece_at(square).color == (chess.WHITE if board.turn else chess.BLACK))\n    return float(control_score)", "def feature(board: chess.Board) -> float:\n    \"Measures the total piece activity by counting pieces that can move.\"\n    active_pieces = sum(1 for square in board.piece_map() if len(list(board.legal_moves)) > 0)\n    return float(active_pieces)", "def feature(board: chess.Board) -> float:\n    \"Calculates a ratio of major pieces (rooks and queens) to total pieces on the board.\"\n    major_pieces = sum(1 for piece in board.piece_map().values() if piece.piece_type in {chess.ROOK, chess.QUEEN})\n    total_pieces = len(board.piece_map())\n    return major_pieces / total_pieces if total_pieces > 0 else 0.0", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of pieces pinned by the opponent's pieces.\"\n    pinned_pieces = sum(1 for square, piece in board.piece_map().items() if piece.color == (chess.WHITE if board.turn else chess.BLACK) and board.is_attacked_by(not piece.color, square))\n    return float(pinned_pieces)", "def feature(board: chess.Board) -> float:\n    \"Evaluates the position based on the number of doubled pawns for each player.\"\n    white_doubled = sum(1 for file in range(8) if sum(1 for rank in range(8) if board.piece_at(chess.square(file, rank)) and board.piece_at(chess.square(file, rank)).color == chess.WHITE) > 1)\n    black_doubled = sum(1 for file in range(8) if sum(1 for rank in range(8) if board.piece_at(chess.square(file, rank)) and board.piece_at(chess.square(file, rank)).color == chess.BLACK) > 1)\n    return float(white_doubled - black_doubled)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of pawns promoting for each player.\"\n    white_promotions = sum(1 for square in board.piece_map() if board.piece_at(square).piece_type == chess.PAWN and chess.square_rank(square) == 7)\n    black_promotions = sum(1 for square in board.piece_map() if board.piece_at(square).piece_type == chess.PAWN and chess.square_rank(square) == 0)\n    return float(white_promotions - black_promotions)", "def feature(board: chess.Board) -> float:\n    \"Calculates the distance of the closest king to the opponent's king.\"\n    white_king_square = next(square for square in board.piece_map() if board.piece_at(square).piece_type == chess.KING and board.piece_at(square).color == chess.WHITE)\n    black_king_square = next(square for square in board.piece_map() if board.piece_at(square).piece_type == chess.KING and board.piece_at(square).color == chess.BLACK)\n    return float(chess.square_distance(white_king_square, black_king_square))", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces attacking the opponent's king.\"\n    black_king_square = next(square for square in board.piece_map() if board.piece_at(square).piece_type == chess.KING and board.piece_at(square).color == chess.BLACK)\n    attacking_pieces = len(board.attackers(chess.WHITE, black_king_square))\n    return float(attacking_pieces)", "def feature(board: chess.Board) -> float:\n    \"Calculates the average rank of all pieces for each player.\"\n    total_white_rank = sum(chess.square_rank(square) for square in board.piece_map() if board.piece_at(square).color == chess.WHITE)\n    total_black_rank = sum(chess.square_rank(square) for square in board.piece_map() if board.piece_at(square).color == chess.BLACK)\n    white_count = len([square for square in board.piece_map() if board.piece_at(square).color == chess.WHITE])\n    black_count = len([square for square in board.piece_map() if board.piece_at(square).color == chess.BLACK])\n    \n    avg_white_rank = total_white_rank / white_count if white_count > 0 else 0\n    avg_black_rank = total_black_rank / black_count if black_count > 0 else 0\n    return float(avg_white_rank - avg_black_rank)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of pieces on the back rank for each player.\"\n    white_back_rank_pieces = sum(1 for square in board.piece_map() if board.piece_at(square).color == chess.WHITE and chess.square_rank(square) == 0)\n    black_back_rank_pieces = sum(1 for square in board.piece_map() if board.piece_at(square).color == chess.BLACK and chess.square_rank(square) == 7)\n    return float(white_back_rank_pieces - black_back_rank_pieces)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of isolated pawns for each player.\"\n    isolated_pawns = 0\n    for square in board.piece_map():\n        if board.piece_at(square).piece_type == chess.PAWN:\n            file = chess.square_file(square)\n            isolated = True\n            if file > 0 and board.piece_at(chess.square(file - 1, chess.square_rank(square))) is not None:\n                isolated = False\n            if file < 7 and board.piece_at(chess.square(file + 1, chess.square_rank(square))) is not None:\n                isolated = False\n            if isolated:\n                isolated_pawns += 1 if board.piece_at(square).color == chess.WHITE else -1\n    return float(isolated_pawns)", "def feature(board: chess.Board) -> float:\n    \"Evaluates the balance of king safety by counting attacks on each king.\"\n    white_king_square = next(square for square in board.piece_map() if board.piece_at(square).piece_type == chess.KING and board.piece_at(square).color == chess.WHITE)\n    black_king_square = next(square for square in board.piece_map() if board.piece_at(square).piece_type == chess.KING and board.piece_at(square).color == chess.BLACK)\n    white_king_attacks = sum(1 for square in board.attackers(chess.BLACK, white_king_square))\n    black_king_attacks = sum(1 for square in board.attackers(chess.WHITE, black_king_square))\n    return float(black_king_attacks - white_king_attacks)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of passed pawns for each player.\"\n    passed_pawns_white = sum(1 for square in board.piece_map() if board.piece_at(square).color == chess.WHITE and chess.square_rank(square) >= 5 and not any(board.is_attacked_by(chess.BLACK, attack) for attack in board.attackers(chess.BLACK, square)))\n    passed_pawns_black = sum(1 for square in board.piece_map() if board.piece_at(square).color == chess.BLACK and chess.square_rank(square) <= 4 and not any(board.is_attacked_by(chess.WHITE, attack) for attack in board.attackers(chess.WHITE, square)))\n    return float(passed_pawns_white - passed_pawns_black)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces that are on the back rank for each player.\"\n    back_rank_white = sum(1 for square in range(56, 64) if board.piece_at(square) and board.piece_at(square).color == chess.WHITE)\n    back_rank_black = sum(1 for square in range(0, 8) if board.piece_at(square) and board.piece_at(square).color == chess.BLACK)\n    return float(back_rank_white - back_rank_black)", "def feature(board: chess.Board) -> float:\n    \"Measures the central control based on the number of pieces in the center squares.\"\n    center_squares = [chess.E4, chess.E5, chess.D4, chess.D5]\n    control_white = sum(1 for square in center_squares if board.is_attacked_by(chess.WHITE, square))\n    control_black = sum(1 for square in center_squares if board.is_attacked_by(chess.BLACK, square))\n    return float(control_white - control_black)", "def feature(board: chess.Board) -> float:\n    \"Calculates the total distance of each player's pieces from their respective pawns.\"\n    def total_distance(color):\n        total_dist = 0\n        pawns = [square for square in board.piece_map() if board.piece_at(square).color == color and board.piece_at(square).piece_type == chess.PAWN]\n        pieces = [square for square in board.piece_map() if board.piece_at(square).color == color and board.piece_at(square).piece_type != chess.PAWN]\n        for piece_square in pieces:\n            closest_distance = min(chess.square_distance(piece_square, pawn) for pawn in pawns) if pawns else 0\n            total_dist += closest_distance\n        return total_dist\n\n    white_distance = total_distance(chess.WHITE)\n    black_distance = total_distance(chess.BLACK)\n    return float(black_distance - white_distance)", "def feature(board: chess.Board) -> float:\n    \"Calculates the mobility of the pieces by counting legal moves.\"\n    mobility_white = len(list(board.legal_moves)) if board.turn else 0\n    mobility_black = len(list(board.legal_moves)) if not board.turn else 0\n    return float(mobility_white - mobility_black)", "def feature(board: chess.Board) -> float:\n    \"Measures the king safety based on threats to the king's position.\"\n    king_square = board.king(chess.WHITE) if board.turn else board.king(chess.BLACK)\n    threats = len(board.attackers(chess.WHITE if board.turn else chess.BLACK, king_square))\n    return float(threats)", "def feature(board: chess.Board) -> float:\n    \"Calculates the mobility difference: the count of legal moves for each player.\"\n    white_moves = len(list(board.legal_moves))\n    black_moves = len(list(board.legal_moves))  # This needs to be careful with the color\n    return float(white_moves - black_moves)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pawns on the 4th and 5th ranks for White and 4th and 3rd ranks for Black.\"\n    white_advanced_pawns = sum(1 for square, piece in board.piece_map().items() \n                                if piece.piece_type == chess.PAWN and \n                                chess.square_rank(square) >= 3)\n    black_advanced_pawns = sum(1 for square, piece in board.piece_map().items() \n                                if piece.piece_type == chess.PAWN and \n                                chess.square_rank(square) <= 4)\n    return float(white_advanced_pawns - black_advanced_pawns)", "def feature(board: chess.Board) -> float:\n    \"Measures the king safety by counting the number of squares attacked near the kings.\"\n    white_king_square = board.king(chess.WHITE)\n    black_king_square = board.king(chess.BLACK)\n    \n    white_attacked = sum(1 for square in chess.SQUARES if board.is_attacked_by(chess.BLACK, square))\n    black_attacked = sum(1 for square in chess.SQUARES if board.is_attacked_by(chess.WHITE, square))\n    \n    return float(white_attacked - black_attacked)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces within the opponent's 5 ranks.\"\n    white_in_opponent_territory = sum(1 for square, piece in board.piece_map().items() \n                                       if piece.color == chess.WHITE and chess.square_rank(square) >= 4)\n    black_in_opponent_territory = sum(1 for square, piece in board.piece_map().items() \n                                       if piece.color == chess.BLACK and chess.square_rank(square) <= 3)\n    return float(white_in_opponent_territory - black_in_opponent_territory)", "def feature(board: chess.Board) -> float:\n    \"Calculates the distance between the kings, measuring their proximity.\"\n    white_king_square = board.king(chess.WHITE)\n    black_king_square = board.king(chess.BLACK)\n    if white_king_square is None or black_king_square is None:\n        return 0.0\n    return float(chess.square_distance(white_king_square, black_king_square))", "def feature(board: chess.Board) -> float:\n    \"Counts the number of major pieces (rooks and queens) for each player on the board.\"\n    white_major_pieces = sum(1 for square, piece in board.piece_map().items() \n                              if piece.color == chess.WHITE and piece.piece_type in {chess.ROOK, chess.QUEEN})\n    black_major_pieces = sum(1 for square, piece in board.piece_map().items() \n                              if piece.color == chess.BLACK and piece.piece_type in {chess.ROOK, chess.QUEEN})\n    return float(white_major_pieces - black_major_pieces)", "def feature(board: chess.Board) -> float:\n    \"Evaluates the control of the center (squares d4, d5, e4, e5).\"\n    center_squares = [chess.D4, chess.D5, chess.E4, chess.E5]\n    white_control = sum(1 for square in center_squares if board.is_attacked_by(chess.WHITE, square))\n    black_control = sum(1 for square in center_squares if board.is_attacked_by(chess.BLACK, square))\n    return float(white_control - black_control)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of pawn majority on one side of the board.\"\n    white_pawn_count = sum(1 for square in board.piece_map() \n                            if board.piece_map()[square].piece_type == chess.PAWN and \n                            chess.square_file(square) < 4)\n    black_pawn_count = sum(1 for square in board.piece_map() \n                            if board.piece_map()[square].piece_type == chess.PAWN and \n                            chess.square_file(square) > 3)\n    return float(white_pawn_count - black_pawn_count)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pawns in advanced positions (ranks 4-5 for White and 3-4 for Black).\"\n    advanced_pawns = 0\n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.PAWN:\n            if piece.color == chess.WHITE and chess.square_rank(square) >= 4:\n                advanced_pawns += 1\n            elif piece.color == chess.BLACK and chess.square_rank(square) <= 4:\n                advanced_pawns += 1\n    return float(advanced_pawns)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of squares that each player's pieces can attack.\"\n    white_attacks = sum(1 for move in board.legal_moves if board.piece_at(move.from_square).color == chess.WHITE)\n    black_attacks = sum(1 for move in board.legal_moves if board.piece_at(move.from_square).color == chess.BLACK)\n    return float(white_attacks - black_attacks)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of pieces directly involved in the defense of the king.\"\n    def_count = 0\n    for square in [chess.E1, chess.E8]:  # King's positions\n        king_piece = board.piece_at(square)\n        if king_piece is not None and king_piece.piece_type == chess.KING:\n            for attacker in board.attackers(not king_piece.color, square):\n                if board.piece_at(attacker) is not None:\n                    def_count += 1\n    return float(def_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of pieces on the board that are pinned.\"\n    pinned_count = 0\n    for square, piece in board.piece_map().items():\n        if board.is_attacked_by(not piece.color, square):\n            potential_pins = [move for move in board.legal_moves if move.to_square == square]\n            if any(board.piece_at(move.from_square).piece_type in {chess.BISHOP, chess.ROOK, chess.QUEEN} for move in potential_pins):\n                pinned_count += 1\n    return float(pinned_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the average distance of all pieces from the opponent's back rank.\"\n    total_distance = 0\n    piece_count = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == board.turn:\n            target_rank = 0 if piece.color == chess.WHITE else 7\n            distance = chess.square_distance(square, chess.parse_square(f'a{target_rank + 1}'))\n            total_distance += distance\n            piece_count += 1\n    return total_distance / piece_count if piece_count > 0 else 0.0", "def feature(board: chess.Board) -> float:\n    \"Measures the number of pieces that have mobility restricted by their own teammates.\"\n    restricted_count = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == board.turn:\n            for move in board.legal_moves:\n                if move.from_square == square and board.is_attacked_by(not piece.color, move.to_square):\n                    restricted_count += 1\n                    break\n    return float(restricted_count)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of connected pawns for each player.\"\n    connected_pawns = 0\n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.PAWN:\n            adjacent_squares = [square - 1, square + 1]  # left and right\n            if piece.color == chess.WHITE and chess.square_rank(square) > 0:\n                for adj in adjacent_squares:\n                    if board.piece_at(adj) is not None and board.piece_at(adj).piece_type == chess.PAWN and board.piece_at(adj).color == chess.WHITE:\n                        connected_pawns += 1\n            elif piece.color == chess.BLACK and chess.square_rank(square) < 7:\n                for adj in adjacent_squares:\n                    if board.piece_at(adj) is not None and board.piece_at(adj).piece_type == chess.PAWN and board.piece_at(adj).color == chess.BLACK:\n                        connected_pawns += 1\n    return float(connected_pawns)", "def feature(board: chess.Board) -> float:\n    \"Calculates the potential for piece activity based on the number of open files.\"\n    open_files = 0\n    for file in range(8):\n        if all(board.piece_at(chess.square(file, rank)) is None for rank in range(8)):\n            open_files += 1\n    return float(open_files)", "def feature(board: chess.Board) -> float:\n    'Calculates the difference in the number of pawns on promotion rank for both sides.'\n    white_pawns = sum(1 for square in board.piece_map() if board.piece_at(square).piece_type == chess.PAWN and chess.square_rank(square) == 6)\n    black_pawns = sum(1 for square in board.piece_map() if board.piece_at(square).piece_type == chess.PAWN and chess.square_rank(square) == 1)\n    return float(white_pawns - black_pawns)", "def feature(board: chess.Board) -> float:\n    'Calculates the total number of pieces that are currently under attack.'\n    attacked_count = sum(1 for square in board.piece_map() if board.is_attacked_by(not board.turn, square))\n    return float(attacked_count)", "def feature(board: chess.Board) -> float:\n    'Counts the number of pieces protected by pawns for the active color.'\n    protecting_pieces_count = sum(1 for square in board.piece_map() if board.piece_at(square).color == board.turn and any(board.is_attacked_by(board.turn, adj_square) for adj_square in board.attackers(not board.turn, square)))\n    return float(protecting_pieces_count)", "def feature(board: chess.Board) -> float:\n    'Counts the number of pieces in front of the opponent\\'s position on the board.'\n    active_color = board.turn\n    file_control_count = sum(1 for square in board.piece_map() if board.piece_at(square).color == active_color and chess.square_file(square) <= 3)\n    return float(file_control_count)", "def feature(board: chess.Board) -> float:\n    'Calculates the total number of squares controlled by each player.'\n    controlled_squares = {chess.WHITE: set(), chess.BLACK: set()}\n    for square in range(64):\n        for move in board.legal_moves:\n            if move.from_square == square:\n                controlled_squares[board.piece_at(square).color].add(move.to_square)\n    return float(len(controlled_squares[chess.WHITE]) - len(controlled_squares[chess.BLACK]))", "def feature(board: chess.Board) -> float:\n    'Measures the total number of legal moves available to each player.'\n    return float(len(list(board.legal_moves)))", "def feature(board: chess.Board) -> float:\n    'Checks the material composition by counting specific piece types.'\n    piece_count = {piece: 0 for piece in [chess.PAWN, chess.KNIGHT, chess.BISHOP, chess.ROOK, chess.QUEEN]}\n    for square in board.piece_map():\n        piece = board.piece_at(square)\n        if piece.piece_type in piece_count:\n            piece_count[piece.piece_type] += 1\n    return float(sum(piece_count.values()))", "def feature(board: chess.Board) -> float:\n    'Calculates the number of pieces positioned on center squares (d4, d5, e4, e5).'\n    center_squares = {chess.D4, chess.D5, chess.E4, chess.E5}\n    center_piece_count = sum(1 for square in board.piece_map() if square in center_squares)\n    return float(center_piece_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of pawns in the 6th and 7th ranks for both players.\"\n    white_advanced_pawns = sum(1 for sq in board.piece_map() if board.piece_at(sq).color == chess.WHITE and chess.square_rank(sq) >= 6 and board.piece_at(sq).piece_type == chess.PAWN)\n    black_advanced_pawns = sum(1 for sq in board.piece_map() if board.piece_at(sq).color == chess.BLACK and chess.square_rank(sq) <= 1 and board.piece_at(sq).piece_type == chess.PAWN)\n    return float(white_advanced_pawns - black_advanced_pawns)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces on the back rank for both players.\"\n    white_back_rank = sum(1 for sq in range(56, 64) if board.piece_at(sq) and board.piece_at(sq).color == chess.WHITE)\n    black_back_rank = sum(1 for sq in range(0, 8) if board.piece_at(sq) and board.piece_at(sq).color == chess.BLACK)\n    return float(white_back_rank - black_back_rank)", "def feature(board: chess.Board) -> float:\n    \"Calculates the average square rank of all pieces on the board for both players.\"\n    piece_ranks = [chess.square_rank(sq) for sq in board.piece_map()]\n    return float(sum(piece_ranks) / len(piece_ranks)) if piece_ranks else 0.0", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces attacking the opponent's king.\"\n    white_king_square = next(sq for sq, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color == chess.WHITE)\n    black_king_square = next(sq for sq, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color == chess.BLACK)\n    white_attackers = len(board.attackers(chess.WHITE, black_king_square))\n    black_attackers = len(board.attackers(chess.BLACK, white_king_square))\n    return float(white_attackers - black_attackers)", "def feature(board: chess.Board) -> float:\n    \"Calculates the total distance of all pieces to their optimal square positions.\"\n    optimal_positions = {\n        chess.PAWN: [chess.A7, chess.B7, chess.C7, chess.D7, chess.E7, chess.F7, chess.G7, chess.H7],\n        chess.ROOK: [chess.A8, chess.H8],\n        chess.KNIGHT: [chess.B8, chess.G8],\n        chess.BISHOP: [chess.C8, chess.F8],\n        chess.QUEEN: [chess.D8],\n        chess.KING: [chess.E8]\n    }\n    total_distance = 0\n    piece_count = 0\n    for sq, piece in board.piece_map().items():\n        optimal_squares = optimal_positions.get(piece.piece_type, [])\n        for opt_sq in optimal_squares:\n            total_distance += chess.square_distance(sq, opt_sq)\n            piece_count += 1\n    return float(total_distance / piece_count) if piece_count > 0 else 0.0", "def feature(board: chess.Board) -> float:\n    \"Measures the total value of pieces that can be captured on the next move.\"\n    opponent_color = chess.WHITE if board.turn == chess.BLACK else chess.BLACK\n    total_value = sum(piece.piece_type for sq, piece in board.piece_map().items() if piece.color == opponent_color and board.is_attacked_by(board.turn, sq))\n    return float(total_value)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of moves available for the player to move.\"\n    return float(len(list(board.legal_moves)))", "def feature(board: chess.Board) -> float:\n    \"Measures the distance of pieces to their respective back ranks.\"\n    white_back_rank = 0\n    black_back_rank = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == chess.WHITE:\n            white_back_rank += 7 - chess.square_rank(square)\n        elif piece.color == chess.BLACK:\n            black_back_rank += chess.square_rank(square)\n    return float(white_back_rank - black_back_rank)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces each player has on the board and gives a ratio.\"\n    white_piece_count = len([piece for piece in board.piece_map().values() if piece.color == chess.WHITE])\n    black_piece_count = len([piece for piece in board.piece_map().values() if piece.color == chess.BLACK])\n    return float(white_piece_count / (black_piece_count + 1))  # Avoid division by zero", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of pieces that are pinned.\"\n    pinned_pieces = 0\n    for square, piece in board.piece_map().items():\n        if board.is_attacked_by(not piece.color, square):\n            for move in board.legal_moves:\n                if move.from_square == square and board.is_check():\n                    pinned_pieces += 1\n    return float(pinned_pieces)", "def feature(board: chess.Board) -> float:\n    \"Measures the potential central control by counting pieces in the central squares.\"\n    central_squares = [chess.E4, chess.E5, chess.D4, chess.D5]\n    central_control = 0\n    for square in central_squares:\n        if board.piece_at(square):\n            if board.piece_at(square).color == chess.WHITE:\n                central_control += 1\n            else:\n                central_control -= 1\n    return float(central_control)", "def feature(board: chess.Board) -> float:\n    \"Calculates the mobility of the active player by counting legal moves.\"\n    legal_moves_count = len(list(board.legal_moves))\n    return float(legal_moves_count)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of squares attacked by each player and returns the difference.\"\n    white_attacks = sum(1 for square in board.piece_map() if board.is_attacked_by(chess.WHITE, square))\n    black_attacks = sum(1 for square in board.piece_map() if board.is_attacked_by(chess.BLACK, square))\n    return float(white_attacks - black_attacks)", "def feature(board: chess.Board) -> float:\n    \"Measures the pawn structure by counting doubled and isolated pawns.\"\n    doubled_pawns = 0\n    isolated_pawns = 0\n    for file in range(8):\n        white_pawns = len([square for square in range(chess.A2, chess.H2 + 1) if chess.square_file(square) == file and board.piece_at(square) == chess.PAWN])\n        black_pawns = len([square for square in range(chess.A7, chess.H7 + 1) if chess.square_file(square) == file and board.piece_at(square) == chess.PAWN])\n\n        if white_pawns > 1:\n            doubled_pawns += 1\n        if white_pawns == 0 and black_pawns > 0:\n            isolated_pawns += 1\n            \n        if black_pawns > 1:\n            doubled_pawns += 1\n        if black_pawns == 0 and white_pawns > 0:\n            isolated_pawns += 1\n\n    return float(doubled_pawns - isolated_pawns)", "def feature(board: chess.Board) -> float:\n    \"Calculates the value of development based on piece movement.\"\n    development_value = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == chess.WHITE:\n            development_value += chess.square_rank(square)  # White pieces prefer higher ranks\n        else:\n            development_value -= chess.square_rank(square)  # Black pieces prefer lower ranks\n    return float(development_value)", "def feature(board: chess.Board) -> float:\n    \"Measures the king safety based on the number of attackers in proximity to the king.\"\n    white_king_square = board.king(chess.WHITE)\n    black_king_square = board.king(chess.BLACK)\n    white_attackers = len(board.attackers(chess.BLACK, white_king_square))\n    black_attackers = len(board.attackers(chess.WHITE, black_king_square))\n    return float(white_attackers - black_attackers)", "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in pawn structure between both players.\"\n    white_pawn_structure = 0\n    black_pawn_structure = 0\n    \n    for square in range(0, 64):\n        piece = board.piece_at(square)\n        if piece and piece.piece_type == chess.PAWN:\n            if piece.color == chess.WHITE:\n                white_pawn_structure += (chess.square_file(square) + 1)  # Encouraging central placement\n            else:\n                black_pawn_structure += (7 - chess.square_file(square))\n                \n    return float(white_pawn_structure - black_pawn_structure)", "def feature(board: chess.Board) -> float:\n    \"Calculates the central control of pieces by summing the pieces that occupy or control center squares.\"\n    center_squares = [chess.E4, chess.E5, chess.D4, chess.D5]\n    control_count = 0\n    for square in center_squares:\n        if board.piece_at(square) is not None:\n            control_count += 1\n        else:\n            attackers = board.attackers(chess.WHITE, square) if board.turn else board.attackers(chess.BLACK, square)\n            control_count += len(attackers)\n    return float(control_count)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of checks available to the current player.\"\n    check_count = sum(1 for move in board.legal_moves if board.gives_check(move))\n    return float(check_count)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces each player has on the board, returning the absolute difference.\"\n    white_count = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE)\n    black_count = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK)\n    return float(abs(white_count - black_count))", "def feature(board: chess.Board) -> float:\n    \"Calculates the total number of attacks on the opponent's king.\"\n    king_square = board.king(chess.BLACK) if board.turn else board.king(chess.WHITE)\n    attack_count = len(board.attackers(chess.WHITE if board.turn else chess.BLACK, king_square))\n    return float(attack_count)", "def feature(board: chess.Board) -> float:\n    \"Measures how many pieces are attacking the back rank of the opponent.\"\n    rank_to_attack = 0 if board.turn else 7\n    attack_count = sum(1 for square, piece in board.piece_map().items() if piece.color == board.turn and chess.square_rank(square) == rank_to_attack)\n    return float(attack_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the mobility of the current player by counting the number of legal moves.\"\n    mobility = len(list(board.legal_moves))\n    return float(mobility)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of doubled pawns present on the board.\"\n    pawns = [square for square, piece in board.piece_map().items() if piece.piece_type == chess.PAWN]\n    files = {}\n    for pawn in pawns:\n        file_index = chess.square_file(pawn)\n        if file_index in files:\n            files[file_index] += 1\n        else:\n            files[file_index] = 1\n    doubled_pawn_count = sum(max(0, count - 1) for count in files.values())\n    return float(doubled_pawn_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the distance of the kings from the corner in terms of ranks and files.\"\n    white_king = board.king(chess.WHITE)\n    black_king = board.king(chess.BLACK)\n    white_distance = chess.square_file(white_king) + chess.square_rank(white_king)\n    black_distance = (7 - chess.square_file(black_king)) + (7 - chess.square_rank(black_king))\n    return float(white_distance - black_distance)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of pieces that are pinned against the king of the current player.\"\n    pin_count = 0\n    king_square = board.king(chess.WHITE) if board.turn else board.king(chess.BLACK)\n    for square, piece in board.piece_map().items():\n        if piece.color == (chess.WHITE if board.turn else chess.BLACK):\n            if board.is_attacked_by(chess.BLACK if board.turn else chess.WHITE, square) and not list(board.attackers(board.turn, square)):\n                pin_count += 1\n    return float(pin_count)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of advanced pawns (on ranks 4 or 5 for White, 4 or 3 for Black) to measure pawn structure.\"\n    advanced_pawns = 0\n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.PAWN:\n            if (piece.color == chess.WHITE and chess.square_rank(square) >= 3) or \\\n               (piece.color == chess.BLACK and chess.square_rank(square) <= 4):\n                advanced_pawns += 1\n    return float(advanced_pawns)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of pieces attacking the opponent's king to assess pressure on the king.\"\n    opponent_king_square = next((square for square, piece in board.piece_map().items() \n                                  if piece.piece_type == chess.KING and piece.color != board.turn), None)\n    if opponent_king_square is None:\n        return 0.0\n    attackers = board.attackers(board.turn, opponent_king_square)\n    return float(len(attackers))", "def feature(board: chess.Board) -> float:\n    \"Calculates the ratio of major pieces (rooks, queens) to minor pieces (knights, bishops) present.\"\n    major_pieces = 0\n    minor_pieces = 0\n    for piece in board.piece_map().values():\n        if piece.piece_type in {chess.ROOK, chess.QUEEN}:\n            major_pieces += 1\n        elif piece.piece_type in {chess.KNIGHT, chess.BISHOP}:\n            minor_pieces += 1\n    if minor_pieces == 0:\n        return float(major_pieces)  # To avoid division by zero\n    return float(major_pieces) / minor_pieces", "def feature(board: chess.Board) -> float:\n    \"Measures the total value of pieces that are under attack to assess vulnerability.\"\n    total_value_under_attack = 0\n    piece_values = {\n        chess.PAWN: 100,\n        chess.KNIGHT: 320,\n        chess.BISHOP: 330,\n        chess.ROOK: 500,\n        chess.QUEEN: 900,\n        chess.KING: 0\n    }\n    for square, piece in board.piece_map().items():\n        if board.is_attacked_by(board.turn, square):\n            total_value_under_attack += piece_values[piece.piece_type]\n    return float(total_value_under_attack)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces that are pinned to assess the potential for tactical plays.\"\n    pinned_pieces_count = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == board.turn:\n            for attacker in board.attackers(not board.turn, square):\n                if board.is_attacked_by(not board.turn, attacker):\n                    pinned_pieces_count += 1\n                    break\n    return float(pinned_pieces_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the average rank of all pieces to measure piece activity.\"\n    total_rank = 0\n    piece_count = 0\n    for square, piece in board.piece_map().items():\n        total_rank += chess.square_rank(square)\n        piece_count += 1\n    return total_rank / piece_count if piece_count > 0 else 0.0", "def feature(board: chess.Board) -> float:\n    \"Counts the number of squares controlled by the pieces of the active color to gauge board control.\"\n    controlled_squares = set()\n    for square, piece in board.piece_map().items():\n        if piece.color == board.turn:\n            for move in board.legal_moves:\n                if move.from_square == square:\n                    controlled_squares.add(move.to_square)\n    return float(len(controlled_squares))", "def feature(board: chess.Board) -> float:\n    \"Measures the total potential pawn structure by counting doubled and isolated pawns.\"\n    doubled_pawns = 0\n    isolated_pawns = 0\n    white_pawn_files = [0] * 8\n    black_pawn_files = [0] * 8\n    \n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.PAWN:\n            if piece.color == chess.WHITE:\n                white_pawn_files[chess.square_file(square)] += 1\n            else:\n                black_pawn_files[chess.square_file(square)] += 1\n\n    doubled_pawns = sum(max(0, count - 1) for count in white_pawn_files) + \\\n                    sum(max(0, count - 1) for count in black_pawn_files)\n\n    isolated_pawns = sum(1 for file in range(8) if white_pawn_files[file] > 0 and \\\n                         (file == 0 or white_pawn_files[file - 1] == 0) and \\\n                         (file == 7 or white_pawn_files[file + 1] == 0)) + \\\n                      sum(1 for file in range(8) if black_pawn_files[file] > 0 and \\\n                         (file == 0 or black_pawn_files[file - 1] == 0) and \\\n                         (file == 7 or black_pawn_files[file + 1] == 0))\n\n    return float(doubled_pawns + isolated_pawns)", "def feature(board: chess.Board) -> float:\n    \"Measures the total number of pieces of each color on the board.\"\n    total_pieces_white = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE)\n    total_pieces_black = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK)\n    result = total_pieces_white - total_pieces_black\n    return float(result)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pawns that are on their starting rank for both players.\"\n    starting_rank_white = sum(1 for sq in board.piece_map() if board.piece_at(sq).color == chess.WHITE and chess.square_rank(sq) == 1)\n    starting_rank_black = sum(1 for sq in board.piece_map() if board.piece_at(sq).color == chess.BLACK and chess.square_rank(sq) == 6)\n    result = starting_rank_white - starting_rank_black\n    return float(result)", "def feature(board: chess.Board) -> float:\n    \"Calculates the difference between advanced pawns (ranks 4-5 for White, 3-4 for Black) and pawns on starting ranks.\"\n    advanced_pawns_white = sum(1 for sq in board.piece_map() if board.piece_at(sq).color == chess.WHITE and chess.square_rank(sq) >= 4)\n    advanced_pawns_black = sum(1 for sq in board.piece_map() if board.piece_at(sq).color == chess.BLACK and chess.square_rank(sq) <= 4)\n    starting_pawns_white = sum(1 for sq in board.piece_map() if board.piece_at(sq).color == chess.WHITE and chess.square_rank(sq) == 1)\n    starting_pawns_black = sum(1 for sq in board.piece_map() if board.piece_at(sq).color == chess.BLACK and chess.square_rank(sq) == 6)\n    result = (advanced_pawns_white - advanced_pawns_black) - (starting_pawns_white - starting_pawns_black)\n    return float(result)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of pieces developed past the third rank.\"\n    developed_pieces_white = sum(1 for sq in board.piece_map() if board.piece_at(sq).color == chess.WHITE and chess.square_rank(sq) > 2)\n    developed_pieces_black = sum(1 for sq in board.piece_map() if board.piece_at(sq).color == chess.BLACK and chess.square_rank(sq) < 5)\n    result = developed_pieces_white - developed_pieces_black\n    return float(result)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of squares controlled by each color's pieces.\"\n    control_white = sum(1 for sq in chess.SQUARES if board.is_attacked_by(chess.WHITE, sq))\n    control_black = sum(1 for sq in chess.SQUARES if board.is_attacked_by(chess.BLACK, sq))\n    result = control_white - control_black\n    return float(result)", "def feature(board: chess.Board) -> float:\n    \"Measures the distance of all pieces from their opponent's back rank.\"\n    distance_white = sum(chess.square_distance(sq, chess.square_rank(0)) for sq in board.piece_map() if board.piece_at(sq).color == chess.WHITE)\n    distance_black = sum(chess.square_distance(sq, chess.square_rank(7)) for sq in board.piece_map() if board.piece_at(sq).color == chess.BLACK)\n    result = distance_black - distance_white\n    return float(result)", "def feature(board: chess.Board) -> float:\n    \"Calculates a score based on the number of doubled pawns.\"\n    doubled_pawns_white = sum(1 for file in range(8) if sum(1 for rank in range(8) if board.piece_at(chess.square(file, rank)) and board.piece_at(chess.square(file, rank)).color == chess.WHITE) > 1)\n    doubled_pawns_black = sum(1 for file in range(8) if sum(1 for rank in range(8) if board.piece_at(chess.square(file, rank)) and board.piece_at(chess.square(file, rank)).color == chess.BLACK) > 1)\n    result = doubled_pawns_black - doubled_pawns_white\n    return float(result)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces that are pinned against their own king.\"\n    pinned_pieces_white = sum(1 for sq in board.piece_map() if board.piece_at(sq).color == chess.WHITE and any(board.is_attacked_by(chess.BLACK, sq2) for sq2 in board.attackers(chess.BLACK, board.king(chess.WHITE))))\n    pinned_pieces_black = sum(1 for sq in board.piece_map() if board.piece_at(sq).color == chess.BLACK and any(board.is_attacked_by(chess.WHITE, sq2) for sq2 in board.attackers(chess.WHITE, board.king(chess.BLACK))))\n    result = pinned_pieces_white - pinned_pieces_black\n    return float(result)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of potential forks by Knights on the board.\"\n    potential_forks = 0\n    knight_positions = [sq for sq in board.piece_map() if board.piece_at(sq).piece_type == chess.KNIGHT]\n    for sq in knight_positions:\n        attackers_count = sum(1 for target in board.legal_moves if target.from_square == sq)\n        if attackers_count >= 2:\n            potential_forks += 1\n    return float(potential_forks)", "def feature(board: chess.Board) -> float:\n    'Calculates the piece activity by counting the number of legal moves available for each player.'\n    white_moves = len(list(board.legal_moves)) if board.turn else 0\n    black_moves = len(list(board.legal_moves)) if not board.turn else 0\n    return float(white_moves - black_moves)", "def feature(board: chess.Board) -> float:\n    'Counts the number of pawns in the opponent\u2019s half of the board.'\n    opponent_pawns = sum(1 for square, piece in board.piece_map().items() \n                         if piece.piece_type == chess.PAWN and piece.color != board.turn and chess.square_rank(square) >= 4)\n    return float(opponent_pawns)", "def feature(board: chess.Board) -> float:\n    'Measures the number of pieces that are potentially pinned against the king.'\n    pinned_pieces = sum(1 for square, piece in board.piece_map().items() \n                        if piece.color == board.turn and board.is_attacked_by(not board.turn, square) \n                        and any(board.attackers(board.turn, square)))\n    return float(pinned_pieces)", "def feature(board: chess.Board) -> float:\n    'Calculates pawn structure stability based on isolated pawns.'\n    isolated_pawns = 0\n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.PAWN and piece.color == board.turn:\n            file = chess.square_file(square)\n            if (board.piece_at(chess.square(file - 1, chess.square_rank(square))) is None and \n                board.piece_at(chess.square(file + 1, chess.square_rank(square))) is None):\n                isolated_pawns += 1\n    return float(isolated_pawns)", "def feature(board: chess.Board) -> float:\n    'Measures the mobility advantage by calculating the difference in pawn mobility.'\n    white_pawn_mobility = sum(1 for square in board.piece_map() \n                              if board.piece_at(square) and board.piece_at(square).color == chess.WHITE \n                              and chess.square_rank(square) < 7)\n    black_pawn_mobility = sum(1 for square in board.piece_map() \n                              if board.piece_at(square) and board.piece_at(square).color == chess.BLACK \n                              and chess.square_rank(square) > 0)\n    return float(white_pawn_mobility - black_pawn_mobility)", "def feature(board: chess.Board) -> float:\n    'Calculates the king safety score based on the number of pieces defending the king.'\n    king_square = board.king(board.turn)\n    defending_pieces = 0\n    for square in board.piece_map():\n        piece = board.piece_at(square)\n        if piece and piece.color == board.turn and board.is_attacked_by(not board.turn, square):\n            defending_pieces += 1\n    return float(defending_pieces)", "def feature(board: chess.Board) -> float:\n    'Calculates the difference in piece types distributed on the board, emphasizing minor and major pieces.'\n    minor_pieces = 0\n    major_pieces = 0\n    for piece in board.piece_map().values():\n        if piece.color == board.turn:\n            if piece.piece_type in {chess.KNIGHT, chess.BISHOP}:\n                minor_pieces += 1\n            elif piece.piece_type in {chess.ROOK, chess.QUEEN}:\n                major_pieces += 1\n    return float(major_pieces - minor_pieces)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces that are attacking the opponent's king.\"\n    attacking_pieces = sum(1 for square in board.piece_map() \n                           if board.piece_map()[square].color != board.turn and \n                           board.is_attacked_by(board.turn, chess.KING))\n    return float(attacking_pieces)", "def feature(board: chess.Board) -> float:\n    \"Measures the control of the center by counting pieces on central squares.\"\n    center_squares = [chess.E4, chess.E5, chess.D4, chess.D5]\n    control_count = sum(1 for square in center_squares if board.piece_at(square) and board.piece_at(square).color == board.turn)\n    return float(control_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the mobility score based on legal moves available for the current player.\"\n    mobility_score = len(list(board.legal_moves))\n    return float(mobility_score)", "def feature(board: chess.Board) -> float:\n    \"Measures the distance of the farthest pawn from its promotion rank.\"\n    distance_measurements = []\n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.PAWN:\n            if piece.color == chess.WHITE:\n                distance = 7 - chess.square_rank(square)\n            else:\n                distance = chess.square_rank(square)\n            distance_measurements.append(distance)\n    return float(max(distance_measurements)) if distance_measurements else 0.0", "def feature(board: chess.Board) -> float:\n    \"Measures the number of pieces pinned by the opponent.\"\n    pinned_count = sum(1 for square, piece in board.piece_map().items() \n                       if piece.color == board.turn and board.is_attacked_by(not board.turn, square))\n    return float(pinned_count)", "def feature(board: chess.Board) -> float:\n    \"Measures the total positional value based on piece activity and placement.\"\n    positional_value = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == board.turn:\n            positional_value += 3 * (8 - chess.square_rank(square))  # Pawns get more value for advancing\n        else:\n            positional_value -= 3 * chess.square_rank(square)\n    return float(positional_value)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of rooks on open files.\"\n    open_file_rooks = 0\n    for file in range(8):\n        if not any(board.piece_at(chess.square(file, rank)) for rank in range(8)):\n            open_file_rooks += sum(1 for rank in range(8) \n                                    if board.piece_at(chess.square(file, rank)) and \n                                    board.piece_at(chess.square(file, rank)).piece_type == chess.ROOK \n                                    and board.piece_at(chess.square(file, rank)).color == board.turn)\n    return float(open_file_rooks)", "def feature(board: chess.Board) -> float:\n    \"Evaluates the king's safety based on the number of pieces around it that can block threats.\"\n    king_square = next(square for square, piece in board.piece_map().items() \n                       if piece.piece_type == chess.KING and piece.color == board.turn)\n    safe_piece_count = sum(1 for square in board.piece_map() \n                           if square != king_square and \n                           board.piece_map()[square].color == board.turn and \n                           board.is_attacked_by(not board.turn, square))\n    return float(safe_piece_count)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of pieces that are pinned against the king.\"\n    pinned_count = 0\n    for square in board.piece_map():\n        piece = board.piece_at(square)\n        if piece.color == board.turn:\n            for attacker in board.attackers(not piece.color, square):\n                if (board.piece_at(attacker).piece_type in [chess.ROOK, chess.QUEEN] and \n                    not board.is_attacked_by(piece.color, attacker)):\n                    pinned_count += 1\n                    break\n    return float(pinned_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the material imbalance based on piece types weighted by their values.\"\n    piece_values = {chess.PAWN: 100, chess.KNIGHT: 300, chess.BISHOP: 300, chess.ROOK: 500, chess.QUEEN: 900}\n    total_value = 0\n    for square, piece in board.piece_map().items():\n        total_value += piece_values.get(piece.piece_type, 0) * (1 if piece.color == board.turn else -1)\n    return float(total_value)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of squares controlled by the player's pieces.\"\n    controlled_squares = set()\n    for square, piece in board.piece_map().items():\n        if piece.color == board.turn:\n            controlled_squares.update(board.attacks(square))\n    return float(len(controlled_squares))", "def feature(board: chess.Board) -> float:\n    \"Calculates the average rank of pieces on the board for the active color.\"\n    total_rank = 0\n    piece_count = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == board.turn:\n            total_rank += chess.square_rank(square)\n            piece_count += 1\n    return total_rank / piece_count if piece_count > 0 else 0.0", "def feature(board: chess.Board) -> float:\n    \"Measures the number of advanced pawns that are less than two ranks away from promotion.\"\n    advanced_pawns = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == board.turn and piece.piece_type == chess.PAWN:\n            if (piece.color == chess.WHITE and chess.square_rank(square) >= 6) or \\\n               (piece.color == chess.BLACK and chess.square_rank(square) <= 1):\n                advanced_pawns += 1\n    return float(advanced_pawns)", "def feature(board: chess.Board) -> float:\n    \"Calculates the mobility score based on the number of legal moves available to the active player.\"\n    mobility_score = len(list(board.legal_moves))\n    return float(mobility_score)", "def feature(board: chess.Board) -> float:\n    \"Measures the distance of the kings from their respective promotion ranks.\"\n    king_square = board.king(board.turn)\n    if board.turn == chess.WHITE:\n        return float(7 - chess.square_rank(king_square))\n    else:\n        return float(chess.square_rank(king_square))", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces on the opponent's back rank (for potential threats).\"\n    opponent_back_rank = 0\n    for file in range(8):\n        square = chess.square(file, 0 if board.turn == chess.BLACK else 7)\n        if board.piece_at(square) and board.piece_at(square).color != board.turn:\n            opponent_back_rank += 1\n    return float(opponent_back_rank)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of doubled pawns for the active player.\"\n    pawn_files = [0] * 8\n    for square, piece in board.piece_map().items():\n        if piece.color == board.turn and piece.piece_type == chess.PAWN:\n            pawn_files[chess.square_file(square)] += 1\n    doubled_pawns = sum(1 for count in pawn_files if count > 1)\n    return float(doubled_pawns)", "def feature(board: chess.Board) -> float:\n    \"Calculates the total number of attacks on the opponent's king by the active player's pieces.\"\n    king_square = board.king(not board.turn)\n    attack_count = 0\n    for square in board.piece_map():\n        piece = board.piece_at(square)\n        if piece.color == board.turn:\n            if king_square in board.attacks(square):\n                attack_count += 1\n    return float(attack_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of pawns on the 4th and 5th ranks for White and 4th and 3rd ranks for Black.\"\n    white_advanced_pawns = sum(1 for sq in board.piece_map() if board.piece_at(sq).color == chess.WHITE and chess.square_rank(sq) >= 3)\n    black_advanced_pawns = sum(1 for sq in board.piece_map() if board.piece_at(sq).color == chess.BLACK and chess.square_rank(sq) <= 4)\n    return float(white_advanced_pawns + black_advanced_pawns)", "def feature(board: chess.Board) -> float:\n    \"Measures the mobility of each player's pieces by counting the number of legal moves available.\"\n    white_mobility = len(list(board.legal_moves)) if board.turn else 0\n    black_mobility = len(list(board.legal_moves)) if not board.turn else 0\n    return float(white_mobility - black_mobility)", "def feature(board: chess.Board) -> float:\n    \"Counts the total number of pieces for the current player on the board.\"\n    total_pieces = sum(1 for piece in board.piece_map().values() if piece.color == board.turn)\n    return float(total_pieces)", "def feature(board: chess.Board) -> float:\n    \"Calculates the distances of kings from the center of the board, normalizing for king safety.\"\n    king_pos = board.king(chess.WHITE) if board.turn else board.king(chess.BLACK)\n    distance_from_center = chess.square_distance(king_pos, chess.parse_square('e4'))  # Using the center square\n    return float(10 - distance_from_center)  # Higher values mean closer to the center", "def feature(board: chess.Board) -> float:\n    \"Measures the total value of pieces under attack for the current player.\"\n    value = 0\n    piece_values = {chess.PAWN: 100, chess.KNIGHT: 320, chess.BISHOP: 330, chess.ROOK: 500, chess.QUEEN: 900, chess.KING: 0}\n    for sq in board.piece_map():\n        if board.piece_at(sq).color == board.turn:\n            attackers = board.attackers(not board.turn, sq)\n            value += sum(piece_values[board.piece_at(attacker).piece_type] for attacker in attackers)\n    return float(value)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces each player has beyond the material count of pawns and knights.\"\n    strong_pieces_count = sum(1 for piece in board.piece_map().values() if piece.piece_type in (chess.BISHOP, chess.ROOK, chess.QUEEN) and piece.color == board.turn)\n    return float(strong_pieces_count)", "def feature(board: chess.Board) -> float:\n    \"Measures the positional strength of all pawns based on their ranks.\"\n    total_strength = sum(1 for sq in board.piece_map() if board.piece_at(sq).piece_type == chess.PAWN and \n                          (chess.square_rank(sq) - 1 if board.piece_at(sq).color == chess.WHITE else 6 - chess.square_rank(sq)))\n    return float(total_strength)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pawns each side has and normalizes the count.\"\n    white_pawns = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE and piece.piece_type == chess.PAWN)\n    black_pawns = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK and piece.piece_type == chess.PAWN)\n    total_pawns = white_pawns + black_pawns\n    return (white_pawns - black_pawns) / (total_pawns + 1)  # Adding 1 to avoid division by zero", "def feature(board: chess.Board) -> float:\n    \"Measures the total number of pieces on the board and normalizes the count.\"\n    total_pieces = len(board.piece_map())\n    return total_pieces / 32.0  # Normalized to max 32 pieces", "def feature(board: chess.Board) -> float:\n    \"Counts the number of passed pawns for both sides and returns the difference.\"\n    def is_passed_pawn(color):\n        return sum(1 for sq, piece in board.piece_map().items() if piece.color == color and piece.piece_type == chess.PAWN and not board.attackers(not color, sq))\n    return is_passed_pawn(chess.WHITE) - is_passed_pawn(chess.BLACK)", "def feature(board: chess.Board) -> float:\n    \"Calculates the average distance of pieces from the center of the board.\"\n    center_square = [chess.square_file(chess.E4), chess.square_file(chess.E5)]\n    total_distance = 0\n    count = 0\n    for square, piece in board.piece_map().items():\n        distance = chess.square_distance(square, chess.E4)\n        total_distance += distance\n        count += 1\n    return total_distance / (count + 1)  # Adding 1 to avoid division by zero", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of minor pieces (knights and bishops) each side has.\"\n    white_minor = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE and piece.piece_type in {chess.KNIGHT, chess.BISHOP})\n    black_minor = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK and piece.piece_type in {chess.KNIGHT, chess.BISHOP})\n    return white_minor - black_minor", "def feature(board: chess.Board) -> float:\n    \"Counts the number of squares each player's king can move to.\"\n    white_king_square = next(square for square, piece in board.piece_map().items() if piece.color == chess.WHITE and piece.piece_type == chess.KING)\n    black_king_square = next(square for square, piece in board.piece_map().items() if piece.color == chess.BLACK and piece.piece_type == chess.KING)\n    white_king_moves = sum(1 for move in board.legal_moves if move.from_square == white_king_square)\n    black_king_moves = sum(1 for move in board.legal_moves if move.from_square == black_king_square)\n    return white_king_moves - black_king_moves", "def feature(board: chess.Board) -> float:\n    \"Measures how many of the opponent's pieces are attacked by one's own pieces.\"\n    white_attacks = sum(1 for square in board.piece_map() if board.is_attacked_by(chess.WHITE, square))\n    black_attacks = sum(1 for square in board.piece_map() if board.is_attacked_by(chess.BLACK, square))\n    return white_attacks - black_attacks", "def feature(board: chess.Board) -> float:\n    \"Counts the number of squares controlled by pawns for both players.\"\n    def controlled_squares(color):\n        return sum(1 for sq in board.piece_map() if board.is_attacked_by(color, sq))\n    return controlled_squares(chess.WHITE) - controlled_squares(chess.BLACK)", "def feature(board: chess.Board) -> float:\n    \"Calculates the ratio of pieces to empty squares for both players.\"\n    total_empty_squares = 64 - len(board.piece_map())\n    pieces_count = len(board.piece_map())\n    return pieces_count / (total_empty_squares + 1)  # Adding 1 to avoid division by zero", "def feature(board: chess.Board) -> float:\n    \"Counts the number of developed pieces for both sides.\"\n    developed = {chess.WHITE: 0, chess.BLACK: 0}\n    for square, piece in board.piece_map().items():\n        if piece.piece_type in {chess.KNIGHT, chess.BISHOP}:\n            if (piece.color == chess.WHITE and chess.square_rank(square) >= 2) or (piece.color == chess.BLACK and chess.square_rank(square) <= 5):\n                developed[piece.color] += 1\n    return developed[chess.WHITE] - developed[chess.BLACK]", "def feature(board: chess.Board) -> float:\n    \"Calculates the distance of the two kings from each other.\"\n    king_positions = [square for square in board.piece_map() if board.piece_at(square).piece_type == chess.KING]\n    if len(king_positions) == 2:\n        distance = chess.square_distance(king_positions[0], king_positions[1])\n        return float(distance)\n    return 0.0", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces attacking opponent's pawns.\"\n    attacking_count = sum(1 for square in board.piece_map() if board.piece_at(square).color == board.turn and \n                          any(board.is_attacked_by(not board.turn, pawn_square) for pawn_square in board.pieces(chess.PAWN, not board.turn)))\n    return float(attacking_count)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of squares controlled by each player's pieces.\"\n    controlled_squares_white = sum(1 for square in chess.SQUARES if board.is_attacked_by(chess.WHITE, square))\n    controlled_squares_black = sum(1 for square in chess.SQUARES if board.is_attacked_by(chess.BLACK, square))\n    return float(controlled_squares_white - controlled_squares_black)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pawns each player has on the 7th rank.\"\n    rank_7_white = sum(1 for square in board.piece_map() if board.piece_at(square).color == chess.WHITE and chess.square_rank(square) == 6)\n    rank_7_black = sum(1 for square in board.piece_map() if board.piece_at(square).color == chess.BLACK and chess.square_rank(square) == 1)\n    return float(rank_7_white - rank_7_black)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of available pawn promotions for each player.\"\n    promotions_white = sum(1 for square in board.piece_map() if board.piece_at(square).color == chess.WHITE and chess.square_rank(square) == 6)\n    promotions_black = sum(1 for square in board.piece_map() if board.piece_at(square).color == chess.BLACK and chess.square_rank(square) == 1)\n    return float(promotions_white - promotions_black)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of 'friendly' pieces protecting each player's king.\"\n    white_king_square = next((square for square in board.piece_map() if board.piece_at(square).color == chess.WHITE and board.piece_at(square).piece_type == chess.KING), None)\n    black_king_square = next((square for square in board.piece_map() if board.piece_at(square).color == chess.BLACK and board.piece_at(square).piece_type == chess.KING), None)\n    \n    if white_king_square is not None:\n        white_protectors = sum(1 for square in board.piece_map() if board.piece_at(square).color == chess.WHITE and square != white_king_square and board.is_attacked_by(chess.BLACK, white_king_square))\n    else:\n        white_protectors = 0\n\n    if black_king_square is not None:\n        black_protectors = sum(1 for square in board.piece_map() if board.piece_at(square).color == chess.BLACK and square != black_king_square and board.is_attacked_by(chess.WHITE, black_king_square))\n    else:\n        black_protectors = 0\n\n    return float(white_protectors - black_protectors)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of squares on the 8th rank occupied by each player's pieces.\"\n    rank_8_white = sum(1 for square in board.piece_map() if board.piece_at(square).color == chess.WHITE and chess.square_rank(square) == 7)\n    rank_8_black = sum(1 for square in board.piece_map() if board.piece_at(square).color == chess.BLACK and chess.square_rank(square) == 0)\n    return float(rank_8_white - rank_8_black)", "def feature(board: chess.Board) -> float:\n    \"Calculates the total piece value of each player's pawns that are on the 5th rank.\"\n    value_white = sum(1 for square in board.piece_map() if board.piece_at(square).color == chess.WHITE and board.piece_at(square).piece_type == chess.PAWN and chess.square_rank(square) == 4)\n    value_black = sum(1 for square in board.piece_map() if board.piece_at(square).color == chess.BLACK and board.piece_at(square).piece_type == chess.PAWN and chess.square_rank(square) == 3)\n    return float(value_white - value_black)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of pieces on their starting squares.\"\n    starting_squares_white = {chess.A2, chess.B2, chess.C2, chess.D2, chess.E2, chess.F2, chess.G2, chess.H2}\n    starting_squares_black = {chess.A7, chess.B7, chess.C7, chess.D7, chess.E7, chess.F7, chess.G7, chess.H7}\n    \n    white_count = sum(1 for square in starting_squares_white if board.piece_at(square) is not None and board.piece_at(square).color == chess.WHITE)\n    black_count = sum(1 for square in starting_squares_black if board.piece_at(square) is not None and board.piece_at(square).color == chess.BLACK)\n    \n    return float(white_count - black_count)", "def feature(board: chess.Board) -> float:\n    \"Measures the proximity of kings to each other as an indication of safety.\"\n    white_king = board.king(chess.WHITE)\n    black_king = board.king(chess.BLACK)\n    if white_king is None or black_king is None:\n        return 0.0\n    distance = chess.square_distance(white_king, black_king)\n    return float(distance)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pawns each player has to assess potential endgame strength.\"\n    white_pawns = sum(1 for piece in board.piece_map().values() if piece.piece_type == chess.PAWN and piece.color == chess.WHITE)\n    black_pawns = sum(1 for piece in board.piece_map().values() if piece.piece_type == chess.PAWN and piece.color == chess.BLACK)\n    return float(white_pawns - black_pawns)", "def feature(board: chess.Board) -> float:\n    \"Calculates the total number of squares controlled by each player to measure influence.\"\n    white_controlled = sum(1 for square in board.piece_map() if board.is_attacked_by(chess.WHITE, square))\n    black_controlled = sum(1 for square in board.piece_map() if board.is_attacked_by(chess.BLACK, square))\n    return float(white_controlled - black_controlled)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of threats each player's pieces are making to evaluate aggression.\"\n    white_threats = sum(1 for move in board.legal_moves if board.is_attacked_by(chess.BLACK, move.to_square))\n    black_threats = sum(1 for move in board.legal_moves if board.is_attacked_by(chess.WHITE, move.to_square))\n    return float(white_threats - black_threats)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of pieces on the board to gauge material presence.\"\n    total_pieces = len(board.piece_map())\n    return float(total_pieces)", "def feature(board: chess.Board) -> float:\n    \"Evaluates the king's safety based on how many squares it can move to safely.\"\n    safe_moves = sum(1 for square in chess.SQUARES if board.is_attacked_by(not board.turn, square) and board.king(board.turn) == square)\n    return float(safe_moves)", "def feature(board: chess.Board) -> float:\n    \"Measures the average rank of all pieces to evaluate position strength.\"\n    total_rank = sum(chess.square_rank(square) for square in board.piece_map())\n    num_pieces = len(board.piece_map())\n    return float(total_rank / num_pieces) if num_pieces > 0 else 0.0", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces of each type for White and Black to assess balance.\"\n    piece_count = {piece_type: 0 for piece_type in range(1, 7)}\n    for piece in board.piece_map().values():\n        piece_count[piece.piece_type] += 1 if piece.color == chess.WHITE else -1\n    return float(sum(piece_count.values()))", "def feature(board: chess.Board) -> float:\n    \"Calculates the distance of all pieces from their respective back ranks.\"\n    distance_sum = sum(chess.square_rank(square) for square in board.piece_map())\n    num_pieces = len(board.piece_map())\n    return float(distance_sum / num_pieces) if num_pieces > 0 else 0.0", "def feature(board: chess.Board) -> float:\n    \"Measures the number of pawns on the board to determine potential for promotion.\"\n    return float(len([p for p in board.piece_map().values() if p.piece_type == chess.PAWN]))", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces within the last three ranks for both players to assess development.\"\n    white_dev = sum(1 for sq, piece in board.piece_map().items() if piece.color == chess.WHITE and chess.square_rank(sq) > 4)\n    black_dev = sum(1 for sq, piece in board.piece_map().items() if piece.color == chess.BLACK and chess.square_rank(sq) < 3)\n    return float(white_dev - black_dev)", "def feature(board: chess.Board) -> float:\n    \"Evaluates the number of pieces that are isolated with no pawns on adjacent files.\"\n    isolated_pieces = 0\n    pieces = board.piece_map()\n    for sq, piece in pieces.items():\n        if piece.color == chess.WHITE:\n            if (sq % 8 > 0 and chess.PAWN not in [pieces.get(sq - 1, None)] and \n                sq % 8 < 7 and chess.PAWN not in [pieces.get(sq + 1, None)]):\n                isolated_pieces += 1\n        else:\n            if (sq % 8 > 0 and chess.PAWN not in [pieces.get(sq - 1, None)] and \n                sq % 8 < 7 and chess.PAWN not in [pieces.get(sq + 1, None)]):\n                isolated_pieces += 1\n    return float(isolated_pieces)", "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in control of the center squares (d4, d5, e4, e5) to assess positional strength.\"\n    center_squares = [chess.D4, chess.D5, chess.E4, chess.E5]\n    white_control = sum(1 for sq in center_squares if board.is_attacked_by(chess.WHITE, sq))\n    black_control = sum(1 for sq in center_squares if board.is_attacked_by(chess.BLACK, sq))\n    return float(white_control - black_control)", "def feature(board: chess.Board) -> float:\n    \"Measures the exposed kings' safety based on the number of attacking pieces surrounding them.\"\n    white_king = next((sq for sq, piece in board.piece_map().items() if piece.color == chess.WHITE and piece.piece_type == chess.KING), None)\n    black_king = next((sq for sq, piece in board.piece_map().items() if piece.color == chess.BLACK and piece.piece_type == chess.KING), None)\n    white_safety = len(board.attackers(chess.WHITE, white_king))\n    black_safety = len(board.attackers(chess.BLACK, black_king))\n    return float(black_safety - white_safety)", "def feature(board: chess.Board) -> float:\n    \"Calculates the total distance of all pieces from their respective back ranks to assess piece activity.\"\n    distance = 0\n    for sq, piece in board.piece_map().items():\n        if piece.color == chess.WHITE:\n            distance += chess.square_rank(sq)\n        else:\n            distance += 7 - chess.square_rank(sq)\n    return float(distance)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of unprotected pieces on the board, indicating vulnerability.\"\n    unprotected_count = 0\n    for sq, piece in board.piece_map().items():\n        if not board.attackers(piece.color, sq):\n            unprotected_count += 1\n    return float(unprotected_count)", "def feature(board: chess.Board) -> float:\n    \"Evaluates the total material imbalance, considering only the pieces that are active (not pinned).\"\n    material_values = {chess.PAWN: 100, chess.KNIGHT: 300, chess.BISHOP: 300, chess.ROOK: 500, chess.QUEEN: 900}\n    total_value = 0\n    for sq, piece in board.piece_map().items():\n        total_value += material_values.get(piece.piece_type, 0) if piece else 0\n    return float(total_value)", "def feature(board: chess.Board) -> float:\n    \"Measures the total number of pieces on the board to assess material balance.\"\n    result = len(board.piece_map())\n    return float(result)", "def feature(board: chess.Board) -> float:\n    \"Evaluates the king safety by checking if the king is under attack.\"\n    king_square = next((square for square, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color == board.turn), None)\n    result = 1.0 if board.is_attacked_by(not board.turn, king_square) else 0.0\n    return result", "def feature(board: chess.Board) -> float:\n    \"Measures the number of mobility options (legal moves) available for the player to move.\"\n    legal_moves_count = len(list(board.legal_moves))\n    return float(legal_moves_count)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces close to the center of the board to assess control.\"\n    center_squares = [chess.D4, chess.D5, chess.E4, chess.E5]\n    central_piece_count = sum(1 for square in center_squares if board.piece_at(square) is not None)\n    return float(central_piece_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in advanced pawn positions for both players.\"\n    white_advanced_pawns = sum(1 for square, piece in board.piece_map().items() \n                                if piece.color == chess.WHITE and chess.square_rank(square) >= 4)\n    black_advanced_pawns = sum(1 for square, piece in board.piece_map().items() \n                                if piece.color == chess.BLACK and chess.square_rank(square) <= 4)\n    result = white_advanced_pawns - black_advanced_pawns\n    return float(result)", "def feature(board: chess.Board) -> float:\n    \"Measures how many rooks are on open files for both players.\"\n    open_file_count = sum(1 for file in range(8) \n                           if all(board.piece_at(chess.square(file, rank)) is None for rank in range(8)))\n    return float(open_file_count)", "def feature(board: chess.Board) -> float:\n    \"Checks for the presence of doubled pawns for both players.\"\n    doubled_pawns = 0\n    pawn_counts = {chess.WHITE: {}, chess.BLACK: {}}\n    \n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.PAWN:\n            file = chess.square_file(square)\n            pawn_counts[piece.color][file] = pawn_counts[piece.color].get(file, 0) + 1\n    \n    for counts in pawn_counts.values():\n        doubled_pawns += sum(1 for count in counts.values() if count > 1)\n\n    return float(doubled_pawns)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pawns each player has and returns the difference.\"\n    white_pawns = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE and piece.piece_type == chess.PAWN)\n    black_pawns = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK and piece.piece_type == chess.PAWN)\n    return float(white_pawns - black_pawns)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of squares controlled by each player's pieces.\"\n    controlled_squares_white = set()\n    controlled_squares_black = set()\n    \n    for square in board.piece_map():\n        piece = board.piece_map()[square]\n        if piece.color == chess.WHITE:\n            controlled_squares_white.update(board.legal_moves)\n        else:\n            controlled_squares_black.update(board.legal_moves)\n    \n    return float(len(controlled_squares_white) - len(controlled_squares_black))", "def feature(board: chess.Board) -> float:\n    \"Measures how many pieces are in the 7th rank of each player's side.\"\n    white_7th_rank = sum(1 for square in range(56, 64) if board.piece_at(square) and board.piece_at(square).color == chess.WHITE)\n    black_7th_rank = sum(1 for square in range(48, 56) if board.piece_at(square) and board.piece_at(square).color == chess.BLACK)\n    return float(white_7th_rank - black_7th_rank)", "def feature(board: chess.Board) -> float:\n    \"Calculates the total number of pieces in the endgame (only kings and pawns).\"\n    endgame_piece_count = sum(1 for piece in board.piece_map().values() if piece.piece_type in {chess.PAWN, chess.KING})\n    return float(endgame_piece_count)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces on the same file as an enemy king.\"\n    enemy_king_square = [square for square in board.piece_map() if board.piece_map()[square].piece_type == chess.KING and board.piece_map()[square].color == (chess.BLACK if board.turn else chess.WHITE)]\n    \n    if enemy_king_square:\n        king_file = chess.square_file(enemy_king_square[0])\n        return float(sum(1 for square in board.piece_map() if chess.square_file(square) == king_file and board.piece_map()[square].color != (chess.BLACK if board.turn else chess.WHITE)))\n    \n    return 0.0", "def feature(board: chess.Board) -> float:\n    \"Measures the total number of pieces on the board relative to the expected number.\"\n    total_pieces = len(board.piece_map())\n    return float(total_pieces) / 32.0  # 32 is the total pieces in a standard game", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces that are pinned by the enemy's pieces.\"\n    pinned_count = 0\n    for square in board.piece_map():\n        piece = board.piece_map()[square]\n        if piece.color == (chess.BLACK if board.turn else chess.WHITE) and board.is_attacked_by(chess.WHITE if board.turn else chess.BLACK, square):\n            pinned_count += 1\n    return float(pinned_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of squares that are attacked but not defended by each color.\"\n    attacked_not_defended_white = sum(1 for square in range(64) if board.is_attacked_by(chess.WHITE, square) and not board.is_attacked_by(chess.BLACK, square))\n    attacked_not_defended_black = sum(1 for square in range(64) if board.is_attacked_by(chess.BLACK, square) and not board.is_attacked_by(chess.WHITE, square))\n    return float(attacked_not_defended_white - attacked_not_defended_black)", "def feature(board: chess.Board) -> float:\n    \"Measures the distance of pawns from their final rank for each player.\"\n    pawn_distances_white = sum(7 - chess.square_rank(square) for square in board.piece_map() if board.piece_map()[square].color == chess.WHITE and board.piece_map()[square].piece_type == chess.PAWN)\n    pawn_distances_black = sum(chess.square_rank(square) for square in board.piece_map() if board.piece_map()[square].color == chess.BLACK and board.piece_map()[square].piece_type == chess.PAWN)\n    return float(pawn_distances_white - pawn_distances_black)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces attacking the opponent's king to assess immediate threats.\"\n    king_square = None\n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.KING and piece.color == chess.BLACK:\n            king_square = square\n            break\n    if king_square is None:\n        return 0.0\n    attackers = board.attackers(chess.WHITE, king_square)\n    return float(len(attackers))", "def feature(board: chess.Board) -> float:\n    \"Measures the number of pawns on the 7th rank for both players.\"\n    white_pawns = sum(1 for square in board.piece_map() if board.piece_at(square).color == chess.WHITE and chess.square_rank(square) == 6)\n    black_pawns = sum(1 for square in board.piece_map() if board.piece_at(square).color == chess.BLACK and chess.square_rank(square) == 1)\n    return float(white_pawns - black_pawns)", "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in the number of pieces in the center squares controlled by each player.\"\n    center_squares = [chess.D4, chess.D5, chess.E4, chess.E5]\n    white_control = sum(1 for square in center_squares if board.is_attacked_by(chess.WHITE, square))\n    black_control = sum(1 for square in center_squares if board.is_attacked_by(chess.BLACK, square))\n    return float(white_control - black_control)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of passed pawns for both players and returns the difference.\"\n    def is_passed_pawn(square, color):\n        if color == chess.WHITE:\n            return all(board.piece_at(sq) is None for sq in range(square + 8, chess.H8 + 1) if chess.square_file(sq) < chess.square_file(square))\n        else:\n            return all(board.piece_at(sq) is None for sq in range(square - 8, chess.A1 - 1) if chess.square_file(sq) > chess.square_file(square))\n    \n    white_passed = sum(1 for square in board.piece_map() if board.piece_at(square).piece_type == chess.PAWN and board.piece_at(square).color == chess.WHITE and is_passed_pawn(square, chess.WHITE))\n    black_passed = sum(1 for square in board.piece_map() if board.piece_at(square).piece_type == chess.PAWN and board.piece_at(square).color == chess.BLACK and is_passed_pawn(square, chess.BLACK))\n    return float(white_passed - black_passed)", "def feature(board: chess.Board) -> float:\n    \"Calculates the average distance of all pieces from the center of the board.\"\n    center = [chess.D4, chess.D5, chess.E4, chess.E5]\n    total_distance = 0\n    piece_count = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == chess.WHITE:\n            total_distance += min(chess.square_distance(square, csq) for csq in center)\n            piece_count += 1\n    return total_distance / piece_count if piece_count > 0 else 0.0", "def feature(board: chess.Board) -> float:\n    \"Measures the number of open files available for rooks for both players.\"\n    open_files = sum(1 for file in range(8) if all(board.piece_at(chess.square(file, rank)) is None for rank in range(8)))\n    return float(open_files)", "def feature(board: chess.Board) -> float:\n    \"Calculates the total number of pieces on the board for both players.\"\n    total_pieces = len(board.piece_map())\n    return float(total_pieces)", "def feature(board: chess.Board) -> float:\n    \"Calculates the material balance as a weighted sum based on piece values.\"\n    piece_values = {\n        chess.PAWN: 100, chess.KNIGHT: 320, chess.BISHOP: 330,\n        chess.ROOK: 500, chess.QUEEN: 900, chess.KING: 20000\n    }\n    material_balance = sum(piece_values[piece.piece_type] * (1 if piece.color == chess.WHITE else -1) for piece in board.piece_map().values())\n    return float(material_balance)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces on the center squares (d4, d5, e4, e5) for both players.\"\n    central_squares = [chess.D4, chess.D5, chess.E4, chess.E5]\n    center_piece_count = sum(1 for square in central_squares if board.piece_at(square) is not None)\n    return float(center_piece_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in total piece values held by each player.\"\n    piece_values = {chess.PAWN: 100, chess.KNIGHT: 320, chess.BISHOP: 330, chess.ROOK: 500, chess.QUEEN: 900, chess.KING: 0}\n    white_value = sum(piece_values[piece.piece_type] for piece in board.piece_map().values() if piece.color == chess.WHITE)\n    black_value = sum(piece_values[piece.piece_type] for piece in board.piece_map().values() if piece.color == chess.BLACK)\n    return float(white_value - black_value)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces attacking the opponent's king.\"\n    opponent_king_square = None\n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.KING and piece.color != board.turn:\n            opponent_king_square = square\n            break\n    if opponent_king_square is None:\n        return 0.0\n    attacking_pieces = sum(1 for piece in board.piece_map().values() if piece.color == board.turn and \n                           board.is_attacked_by(piece.color, opponent_king_square))\n    return float(attacking_pieces)", "def feature(board: chess.Board) -> float:\n    \"Evaluates the number of doubled pawns for both players.\"\n    white_pawns = {}\n    black_pawns = {}\n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.PAWN:\n            if piece.color == chess.WHITE:\n                white_pawns[chess.square_file(square)] = white_pawns.get(chess.square_file(square), 0) + 1\n            else:\n                black_pawns[chess.square_file(square)] = black_pawns.get(chess.square_file(square), 0) + 1\n    doubled_pawns = sum(1 for count in white_pawns.values() if count > 1) + sum(1 for count in black_pawns.values() if count > 1)\n    return float(doubled_pawns)", "def feature(board: chess.Board) -> float:\n    \"Measures the ratio of bishops to knights for each player.\"\n    white_bishops = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE and piece.piece_type == chess.BISHOP)\n    white_knights = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE and piece.piece_type == chess.KNIGHT)\n    black_bishops = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK and piece.piece_type == chess.BISHOP)\n    black_knights = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK and piece.piece_type == chess.KNIGHT)\n    white_ratio = white_bishops / (white_knights if white_knights > 0 else 1)\n    black_ratio = black_bishops / (black_knights if black_knights > 0 else 1)\n    return float(white_ratio - black_ratio)", "def feature(board: chess.Board) -> float:\n    \"Calculates the king safety metric based on the number of pieces around each king.\"\n    white_king_square = next((square for square, piece in board.piece_map().items() if piece.color == chess.WHITE and piece.piece_type == chess.KING), None)\n    black_king_square = next((square for square, piece in board.piece_map().items() if piece.color == chess.BLACK and piece.piece_type == chess.KING), None)\n    if not white_king_square or not black_king_square:\n        return 0.0\n\n    white_protection = sum(1 for square in chess.SQUARES if board.is_attacked_by(chess.BLACK, square) and chess.square_distance(square, white_king_square) <= 1)\n    black_protection = sum(1 for square in chess.SQUARES if board.is_attacked_by(chess.WHITE, square) and chess.square_distance(square, black_king_square) <= 1)\n    \n    return float(white_protection - black_protection)", "def feature(board: chess.Board) -> float:\n    \"Measures the total number of pawns on the board, indicating potential for promotion.\"\n    pawns_count = sum(1 for piece in board.piece_map().values() if piece.piece_type == chess.PAWN)\n    return float(pawns_count)", "def feature(board: chess.Board) -> float:\n    \"Evaluates the number of squares controlled by each player through their pawns.\"\n    white_control = sum(1 for square in board.piece_map() if board.piece_at(square).color == chess.WHITE and square < 56)\n    black_control = sum(1 for square in board.piece_map() if board.piece_at(square).color == chess.BLACK and square > 7)\n    return float(white_control - black_control)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of squares available for the king to escape, reflecting safety.\"\n    king_square = None\n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.KING and piece.color == (chess.WHITE if board.turn else chess.BLACK):\n            king_square = square\n            break\n    escape_squares = sum(1 for move in board.legal_moves if move.from_square == king_square)\n    return float(escape_squares)", "def feature(board: chess.Board) -> float:\n    \"Measures how many pieces are currently attacking the opponent's king, indicating pressure.\"\n    king_square = next(square for square, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color == (chess.BLACK if board.turn else chess.WHITE))\n    attackers_count = len(board.attackers(board.turn, king_square))\n    return float(attackers_count)", "def feature(board: chess.Board) -> float:\n    \"Evaluates the number of rooks on the seventh rank, indicating control and threat.\"\n    rooks_on_seventh = sum(1 for square, piece in board.piece_map().items() \n                           if piece.piece_type == chess.ROOK and \n                           (piece.color == chess.WHITE and chess.square_rank(square) == 6 or \n                            piece.color == chess.BLACK and chess.square_rank(square) == 1))\n    return float(rooks_on_seventh)", "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in the number of pieces protected by other pieces.\"\n    white_protected = sum(1 for square, piece in board.piece_map().items() if piece.color == chess.WHITE and \n                          any(board.is_attacked_by(chess.BLACK, square) for square in board.attackers(chess.WHITE, square)))\n    black_protected = sum(1 for square, piece in board.piece_map().items() if piece.color == chess.BLACK and \n                          any(board.is_attacked_by(chess.WHITE, square) for square in board.attackers(chess.BLACK, square)))\n    return float(white_protected - black_protected)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces that are pinned to their king, indicating weaknesses.\"\n    pinned_count = sum(1 for square, piece in board.piece_map().items() if \n                       piece.color == (chess.WHITE if board.turn else chess.BLACK) and \n                       board.is_attacked_by(chess.BLACK if board.turn else chess.WHITE, square) and \n                       piece.piece_type != chess.KING)\n    return float(pinned_count)", "def feature(board: chess.Board) -> float:\n    \"Evaluates the stability of each player's major pieces (rooks and queens) on the board.\"\n    stable_pieces = sum(1 for square, piece in board.piece_map().items() \n                        if piece.piece_type in (chess.ROOK, chess.QUEEN) and \n                        (len(list(board.attackers(chess.BLACK, square))) == 0 if piece.color == chess.WHITE else \n                         len(list(board.attackers(chess.WHITE, square))) == 0))\n    return float(stable_pieces)", "def feature(board: chess.Board) -> float:\n    \"Counts the difference in the number of pawns on the board between the two players.\"\n    white_pawns = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE and piece.piece_type == chess.PAWN)\n    black_pawns = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK and piece.piece_type == chess.PAWN)\n    return float(white_pawns - black_pawns)", "def feature(board: chess.Board) -> float:\n    \"Measures the combined distance of all pieces from their respective kings.\"\n    def distance_to_king(color):\n        king_square = next(square for square, piece in board.piece_map().items() if piece.color == color and piece.piece_type == chess.KING)\n        return sum(chess.square_distance(square, king_square) for square, piece in board.piece_map().items() if piece.color == color)\n\n    white_distance = distance_to_king(chess.WHITE)\n    black_distance = distance_to_king(chess.BLACK)\n    return float(white_distance - black_distance)", "def feature(board: chess.Board) -> float:\n    \"Calculates the total number of attacking pieces on the board for both players.\"\n    white_attacking = sum(1 for square in board.piece_map().keys() if board.is_attacked_by(chess.WHITE, square))\n    black_attacking = sum(1 for square in board.piece_map().keys() if board.is_attacked_by(chess.BLACK, square))\n    return float(white_attacking - black_attacking)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of inactive pieces (not attacking) for both players.\"\n    def inactive_pieces(color):\n        return sum(1 for square, piece in board.piece_map().items() if piece.color == color and not any(board.is_attacked_by(other_color, square) for other_color in [chess.WHITE, chess.BLACK] if other_color != color))\n\n    return float(inactive_pieces(chess.WHITE) - inactive_pieces(chess.BLACK))", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of pieces attacking the opponent's king, providing proximity to check.\"\n    attacking_white_king = sum(1 for square in chess.SQUARES if board.is_attacked_by(chess.WHITE, square) and board.piece_at(square) and board.piece_at(square).color == chess.BLACK and board.piece_at(square).piece_type == chess.KING)\n    attacking_black_king = sum(1 for square in chess.SQUARES if board.is_attacked_by(chess.BLACK, square) and board.piece_at(square) and board.piece_at(square).color == chess.WHITE and board.piece_at(square).piece_type == chess.KING)\n    return float(attacking_white_king - attacking_black_king)", "def feature(board: chess.Board) -> float:\n    \"Evaluates the material presence in the center of the board (controlled squares).\"\n    center_squares = [chess.D4, chess.D5, chess.E4, chess.E5]\n    white_control = sum(1 for square in center_squares if board.is_attacked_by(chess.WHITE, square))\n    black_control = sum(1 for square in center_squares if board.is_attacked_by(chess.BLACK, square))\n    return float(white_control - black_control)", "def feature(board: chess.Board) -> float:\n    \"Checks the relative safety of both kings, counting threatening pieces within one square.\"\n    def king_safety(color):\n        king_square = next(square for square, piece in board.piece_map().items() if piece.color == color and piece.piece_type == chess.KING)\n        enemy_color = chess.BLACK if color == chess.WHITE else chess.WHITE\n        return sum(1 for square in chess.SQUARES if board.is_attacked_by(enemy_color, square) and chess.square_distance(square, king_square) <= 1)\n\n    return float(king_safety(chess.WHITE) - king_safety(chess.BLACK))", "def feature(board: chess.Board) -> float:\n    \"Counts the number of doubled pawns for both players.\"\n    def doubled_pawns(color):\n        pawns = [square for square, piece in board.piece_map().items() if piece.color == color and piece.piece_type == chess.PAWN]\n        files = {}\n        for pawn in pawns:\n            file_index = chess.square_file(pawn)\n            if file_index in files:\n                files[file_index] += 1\n            else:\n                files[file_index] = 1\n        return sum(1 for count in files.values() if count > 1)\n\n    return float(doubled_pawns(chess.WHITE) - doubled_pawns(chess.BLACK))", "def feature(board: chess.Board) -> float:\n    \"Assesses king positioning in relation to the center of the board.\"\n    center_squares = [chess.D4, chess.D5, chess.E4, chess.E5]\n    white_king_square = next(square for square, piece in board.piece_map().items() if piece.color == chess.WHITE and piece.piece_type == chess.KING)\n    black_king_square = next(square for square, piece in board.piece_map().items() if piece.color == chess.BLACK and piece.piece_type == chess.KING)\n    \n    white_center_distance = min(chess.square_distance(white_king_square, sq) for sq in center_squares)\n    black_center_distance = min(chess.square_distance(black_king_square, sq) for sq in center_squares)\n    \n    return float(black_center_distance - white_center_distance)", "def feature(board: chess.Board) -> float:\n    \"Measures the distance of the closest king to the opponent's back rank.\"\n    player_king_square = board.king(chess.WHITE) if board.turn else board.king(chess.BLACK)\n    opponent_back_rank = 7 if board.turn else 0\n    distance = chess.square_rank(player_king_square) - opponent_back_rank\n    return float(distance)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces controlled by the player that are within one square of the opponent's back rank.\"\n    count = 0\n    opponent_back_rank = 7 if board.turn else 0\n    for square in range(64):\n        piece = board.piece_at(square)\n        if piece and piece.color == (chess.WHITE if board.turn else chess.BLACK):\n            if chess.square_rank(square) == opponent_back_rank - 1:\n                count += 1\n    return float(count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the total number of pieces for each player on the 3rd and 6th ranks.\"\n    count = 0\n    for square in range(64):\n        piece = board.piece_at(square)\n        if piece:\n            if chess.square_rank(square) in [2, 5]:  # 3rd and 6th ranks\n                count += 1\n    return float(count)", "def feature(board: chess.Board) -> float:\n    \"Measures the difference in pawns on the board.\"\n    white_pawns = len([p for p in board.piece_map().values() if p.color == chess.WHITE and p.piece_type == chess.PAWN])\n    black_pawns = len([p for p in board.piece_map().values() if p.color == chess.BLACK and p.piece_type == chess.PAWN])\n    return float(white_pawns - black_pawns)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces currently blocked by pawns of the same color.\"\n    count = 0\n    for square in range(64):\n        piece = board.piece_at(square)\n        if piece and piece.color == (chess.WHITE if board.turn else chess.BLACK):\n            for attack_square in board.attackers(piece.color, square):\n                if board.piece_at(attack_square) and board.piece_at(attack_square).color == piece.color:\n                    count += 1\n                    break\n    return float(count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of pieces each player has near the center squares (d4, d5, e4, e5).\"\n    center_squares = [chess.parse_square(sq) for sq in ['d4', 'd5', 'e4', 'e5']]\n    count_white = sum(1 for sq in center_squares if board.piece_at(sq) and board.piece_at(sq).color == chess.WHITE)\n    count_black = sum(1 for sq in center_squares if board.piece_at(sq) and board.piece_at(sq).color == chess.BLACK)\n    return float(count_white - count_black)", "def feature(board: chess.Board) -> float:\n    \"Measures the average distance of all pieces from the nearest opponent's king.\"\n    total_distance = 0\n    count = 0\n    opponent_king_square = board.king(chess.BLACK) if board.turn else board.king(chess.WHITE)\n    \n    for square in range(64):\n        piece = board.piece_at(square)\n        if piece and piece.color == (chess.WHITE if board.turn else chess.BLACK):\n            distance = chess.square_distance(square, opponent_king_square)\n            total_distance += distance\n            count += 1\n    \n    return total_distance / count if count > 0 else 0.0", "def feature(board: chess.Board) -> float:\n    \"Counts the number of squares where a player's pieces are attacking.\"\n    count = sum(1 for square in range(64) if board.is_attacked_by(board.turn, square))\n    return float(count)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of squares held by each player in their opponent's territory.\"\n    count_white = sum(1 for square in range(64) if board.turn == chess.BLACK and board.piece_at(square) is None and chess.square_rank(square) > 4)\n    count_black = sum(1 for square in range(64) if board.turn == chess.WHITE and board.piece_at(square) is None and chess.square_rank(square) < 3)\n    return float(count_white - count_black)", "def feature(board: chess.Board) -> float:\n    \"Returns the number of currently unoccupied squares that are under attack.\"\n    attacked_squares = {square for move in board.legal_moves for square in [move.to_square]}\n    unoccupied_attacked = sum(1 for square in attacked_squares if board.piece_at(square) is None)\n    return float(unoccupied_attacked)", "def feature(board: chess.Board) -> float:\n    \"Measures the total number of opposing pieces that can potentially attack the opponent's king.\"\n    opponent_king_square = None\n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.KING and piece.color != board.turn:\n            opponent_king_square = square\n            break\n    if opponent_king_square is None:\n        return 0.0\n    attack_count = sum(1 for move in board.legal_moves if move.to_square == opponent_king_square)\n    return float(attack_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of pawns each player has advanced past their initial ranks.\"\n    white_pawns_advanced = sum(1 for square, piece in board.piece_map().items()\n                                if piece.piece_type == chess.PAWN and piece.color == chess.WHITE \n                                and chess.square_rank(square) > 1)\n    black_pawns_advanced = sum(1 for square, piece in board.piece_map().items() \n                                if piece.piece_type == chess.PAWN and piece.color == chess.BLACK \n                                and chess.square_rank(square) < 6)\n    return float(white_pawns_advanced - black_pawns_advanced)", "def feature(board: chess.Board) -> float:\n    \"Evaluates the potential threats each player's pieces pose to the opponent's pieces.\"\n    threat_score = 0.0\n    for square, piece in board.piece_map().items():\n        if piece.color == board.turn:\n            threat_score += len(board.attackers(not piece.color, square))\n    return float(threat_score)", "def feature(board: chess.Board) -> float:\n    \"Calculates the distance from each player's king to the center of the board.\"\n    white_king_square = board.king(chess.WHITE)\n    black_king_square = board.king(chess.BLACK)\n    white_distance = chess.square_distance(white_king_square, chess.E4) + chess.square_distance(white_king_square, chess.D4)\n    black_distance = chess.square_distance(black_king_square, chess.E5) + chess.square_distance(black_king_square, chess.D5)\n    return float(white_distance - black_distance)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of pieces each player has on squares that are not attacked.\"\n    white_safe_pieces = sum(1 for square, piece in board.piece_map().items() \n                             if piece.color == chess.WHITE and not board.is_attacked_by(chess.BLACK, square))\n    black_safe_pieces = sum(1 for square, piece in board.piece_map().items() \n                             if piece.color == chess.BLACK and not board.is_attacked_by(chess.WHITE, square))\n    return float(white_safe_pieces - black_safe_pieces)", "def feature(board: chess.Board) -> float:\n    \"Evaluates how many pawn structures are broken for both players.\"\n    broken_structure_white = 0\n    broken_structure_black = 0\n    \n    for square, piece in board.piece_map().items():\n        if piece.color == chess.WHITE and piece.piece_type == chess.PAWN:\n            if board.piece_at(square + 8) is None and board.piece_at(square + 7) is None:\n                broken_structure_white += 1\n        elif piece.color == chess.BLACK and piece.piece_type == chess.PAWN:\n            if board.piece_at(square - 8) is None and board.piece_at(square - 7) is None:\n                broken_structure_black += 1\n    return float(broken_structure_white - broken_structure_black)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces of each player that are on the fifth rank or higher.\"\n    white_pieces_on_fifth_or_higher = sum(1 for square, piece in board.piece_map().items()\n                                           if piece.color == chess.WHITE and chess.square_rank(square) >= 4)\n    black_pieces_on_fifth_or_higher = sum(1 for square, piece in board.piece_map().items()\n                                           if piece.color == chess.BLACK and chess.square_rank(square) <= 3)\n    return float(white_pieces_on_fifth_or_higher - black_pieces_on_fifth_or_higher)", "def feature(board: chess.Board) -> float:\n    \"Measures the distance from the current player's king to the nearest opposing piece.\"\n    current_king_square = board.king(board.turn)\n    opponent_pieces = [sq for sq, piece in board.piece_map().items() if piece.color != board.turn]\n    if not opponent_pieces:\n        return float('inf')\n    distances = [chess.square_distance(current_king_square, sq) for sq in opponent_pieces]\n    return min(distances)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces on the back rank of each player.\"\n    back_rank_white = sum(1 for sq in range(chess.A8, chess.H8 + 1) if board.piece_at(sq) and board.piece_at(sq).color == chess.WHITE)\n    back_rank_black = sum(1 for sq in range(chess.A1, chess.H1 + 1) if board.piece_at(sq) and board.piece_at(sq).color == chess.BLACK)\n    return float(back_rank_white - back_rank_black)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of pieces attacking key squares (e4, d4, e5, d5).\"\n    key_squares = [chess.parse_square(sq) for sq in ['e4', 'd4', 'e5', 'd5']]\n    attacking_piece_count = sum(len(board.attackers(color, sq)) for sq in key_squares for color in [chess.WHITE, chess.BLACK])\n    return float(attacking_piece_count)", "def feature(board: chess.Board) -> float:\n    \"Measures the king's safety by counting the number of squares it can move to that are not attacked.\"\n    current_king_square = board.king(board.turn)\n    safe_squares = sum(1 for sq in board.attacks(current_king_square) if not board.is_attacked_by(not board.turn, sq))\n    return float(safe_squares)", "def feature(board: chess.Board) -> float:\n    \"Measures the total material value of the pieces currently on the board.\"\n    piece_values = {chess.PAWN: 100, chess.KNIGHT: 320, chess.BISHOP: 330,\n                    chess.ROOK: 500, chess.QUEEN: 900, chess.KING: 0}\n    total_value = sum(piece_values[piece.piece_type] for piece in board.piece_map().values())\n    return float(total_value)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of central control squares (d4, d5, e4, e5) occupied by each player.\"\n    central_squares = [chess.parse_square(sq) for sq in ['d4', 'd5', 'e4', 'e5']]\n    control_white = sum(1 for sq in central_squares if board.piece_at(sq) and board.piece_at(sq).color == chess.WHITE)\n    control_black = sum(1 for sq in central_squares if board.piece_at(sq) and board.piece_at(sq).color == chess.BLACK)\n    return float(control_white - control_black)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of pieces occupying the opponent's half of the board.\"\n    opponent_half = [sq for sq in range(chess.A1, chess.H5)]\n    pieces_in_opponent_half = sum(1 for sq in opponent_half if board.piece_at(sq) and board.piece_at(sq).color != board.turn)\n    return float(pieces_in_opponent_half)", "def feature(board: chess.Board) -> float:\n    \"Measures the total number of potential threats (attacking moves) by the current player's pieces.\"\n    threats = sum(1 for move in board.legal_moves)\n    return float(threats)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of rooks on open files for both players.\"\n    open_file_count = 0\n    for file in range(8):\n        if all(board.piece_at(chess.square(file, rank)) is None for rank in range(8)):\n            open_file_count += sum(1 for rank in range(8) if board.piece_at(chess.square(file, rank)) and \n                                 board.piece_at(chess.square(file, rank)).piece_type == chess.ROOK)\n    return float(open_file_count)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of squares available to the current player that are not attacked.\"\n    available_squares = sum(1 for sq in range(64) if board.is_attacked_by(not board.turn, sq) == False and \n                             board.piece_at(sq) is None)\n    return float(available_squares)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pawns on the board for both players.\"\n    white_pawns = len([p for p in board.piece_map().values() if p.color == chess.WHITE and p.piece_type == chess.PAWN])\n    black_pawns = len([p for p in board.piece_map().values() if p.color == chess.BLACK and p.piece_type == chess.PAWN])\n    return float(white_pawns - black_pawns)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of pieces on the back rank for both players.\"\n    white_back_rank = sum(1 for sq in range(chess.A8, chess.H8 + 1) if board.piece_at(sq) and board.piece_at(sq).color == chess.WHITE)\n    black_back_rank = sum(1 for sq in range(chess.A1, chess.H1 + 1) if board.piece_at(sq) and board.piece_at(sq).color == chess.BLACK)\n    return float(white_back_rank - black_back_rank)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of squares controlled by each player's pieces.\"\n    white_control = len(set(move.to_square for move in board.legal_moves if board.piece_at(move.from_square).color == chess.WHITE))\n    black_control = len(set(move.to_square for move in board.legal_moves if board.piece_at(move.from_square).color == chess.BLACK))\n    return float(white_control - black_control)", "def feature(board: chess.Board) -> float:\n    \"Measures the distance of the closest piece to the opponent's pawns.\"\n    closest_white_pawn = min((chess.square_distance(sq, chess.parse_square('a2')) for sq in board.piece_map() if board.piece_map()[sq].color == chess.WHITE and board.piece_map()[sq].piece_type != chess.KING), default=8)\n    closest_black_pawn = min((chess.square_distance(sq, chess.parse_square('a7')) for sq in board.piece_map() if board.piece_map()[sq].color == chess.BLACK and board.piece_map()[sq].piece_type != chess.KING), default=8)\n    return float(closest_white_pawn - closest_black_pawn)", "def feature(board: chess.Board) -> float:\n    \"Calculates the total number of possible checks that both players can deliver.\"\n    white_checks = sum(1 for move in board.legal_moves if board.piece_at(move.from_square).color == chess.WHITE and move.to_square in board.attackers(chess.BLACK, move.from_square))\n    black_checks = sum(1 for move in board.legal_moves if board.piece_at(move.from_square).color == chess.BLACK and move.to_square in board.attackers(chess.WHITE, move.from_square))\n    return float(white_checks - black_checks)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of doubled pawns for both players.\"\n    white_doubled = sum(1 for file in range(8) if len([sq for sq in chess.SQUARES if chess.square_file(sq) == file and board.piece_at(sq) and board.piece_at(sq).color == chess.WHITE]) > 1)\n    black_doubled = sum(1 for file in range(8) if len([sq for sq in chess.SQUARES if chess.square_file(sq) == file and board.piece_at(sq) and board.piece_at(sq).color == chess.BLACK]) > 1)\n    return float(white_doubled - black_doubled)", "def feature(board: chess.Board) -> float:\n    \"Evaluates the number of rooks on the board that are not on open files.\"\n    def is_open_file(file):\n        return all(board.piece_at(chess.square_rank(rank) * 8 + file) is None for rank in range(8))\n    \n    white_total = sum(1 for sq in board.piece_map() if board.piece_map()[sq].color == chess.WHITE and board.piece_map()[sq].piece_type == chess.ROOK and not is_open_file(chess.square_file(sq)))\n    black_total = sum(1 for sq in board.piece_map() if board.piece_map()[sq].color == chess.BLACK and board.piece_map()[sq].piece_type == chess.ROOK and not is_open_file(chess.square_file(sq)))\n    return float(white_total - black_total)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces on squares that are attacked by both players.\"\n    squares_attacked_by_white = {sq for sq in chess.SQUARES if board.is_attacked_by(chess.WHITE, sq)}\n    squares_attacked_by_black = {sq for sq in chess.SQUARES if board.is_attacked_by(chess.BLACK, sq)}\n    count_attacked = sum(1 for sq in squares_attacked_by_white.intersection(squares_attacked_by_black) if board.piece_at(sq) is not None)\n    return float(count_attacked)", "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in the number of pieces within a central control area (d4, d5, e4, e5).\"\n    central_squares = {chess.parse_square('d4'), chess.parse_square('d5'), chess.parse_square('e4'), chess.parse_square('e5')}\n    white_central = sum(1 for sq in central_squares if board.piece_at(sq) and board.piece_at(sq).color == chess.WHITE)\n    black_central = sum(1 for sq in central_squares if board.piece_at(sq) and board.piece_at(sq).color == chess.BLACK)\n    return float(white_central - black_central)", "def feature(board: chess.Board) -> float:\n    \"Calculates the distance of the nearest opposing king from the current player's king.\"\n    if board.is_checkmate() or board.is_stalemate():\n        return 0.0\n    own_king = board.king(board.turn)\n    opponent_king = board.king(not board.turn)\n    distance = chess.square_distance(own_king, opponent_king)\n    return float(distance)", "def feature(board: chess.Board) -> float:\n    \"Counts the total number of pieces for both players and normalizes by the total piece count.\"\n    piece_count = sum(1 for piece in board.piece_map().values())\n    if piece_count == 0:\n        return 0.0\n    return float(piece_count) / 32.0", "def feature(board: chess.Board) -> float:\n    \"Measures the number of pawns each player has on the 7th rank.\"\n    white_pawns_7th = sum(1 for sq in board.piece_map() if board.piece_at(sq).piece_type == chess.PAWN and chess.square_rank(sq) == 6 and board.piece_at(sq).color == chess.WHITE)\n    black_pawns_7th = sum(1 for sq in board.piece_map() if board.piece_at(sq).piece_type == chess.PAWN and chess.square_rank(sq) == 1 and board.piece_at(sq).color == chess.BLACK)\n    return float(white_pawns_7th - black_pawns_7th)", "def feature(board: chess.Board) -> float:\n    \"Calculates the ratio of pieces providing protection to each other's position.\"\n    protecting_pieces = 0\n    for square in board.piece_map():\n        piece = board.piece_at(square)\n        if piece is not None:\n            attackers = board.attackers(not piece.color, square)\n            if attackers:\n                protecting_pieces += 1\n    return float(protecting_pieces) / len(board.piece_map())", "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in the number of pieces on squares that are double-attacked.\"\n    double_attacked_squares = [sq for sq in chess.SQUARES if len(board.attackers(chess.WHITE, sq)) > 1 or len(board.attackers(chess.BLACK, sq)) > 1]\n    white_count = sum(1 for sq in double_attacked_squares if board.piece_at(sq) and board.piece_at(sq).color == chess.WHITE)\n    black_count = sum(1 for sq in double_attacked_squares if board.piece_at(sq) and board.piece_at(sq).color == chess.BLACK)\n    return float(white_count - black_count)", "def feature(board: chess.Board) -> float:\n    \"Measures the balance of material based on the types of pieces remaining for each player.\"\n    material_values = {chess.PAWN: 100, chess.KNIGHT: 320, chess.BISHOP: 330, chess.ROOK: 500, chess.QUEEN: 900}\n    white_material = sum(material_values.get(board.piece_at(sq).piece_type, 0) for sq in board.piece_map() if board.piece_at(sq).color == chess.WHITE)\n    black_material = sum(material_values.get(board.piece_at(sq).piece_type, 0) for sq in board.piece_map() if board.piece_at(sq).color == chess.BLACK)\n    return float(white_material - black_material)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of pieces attacked by both players and gives a ratio.\"\n    attacked_by_white = sum(1 for sq in board.piece_map() if board.is_attacked_by(chess.WHITE, sq))\n    attacked_by_black = sum(1 for sq in board.piece_map() if board.is_attacked_by(chess.BLACK, sq))\n    return float(attacked_by_white - attacked_by_black)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of open files for rooks for both players.\"\n    open_files = 0\n    for file in range(8):\n        if all(board.piece_at(chess.square(file, rank)) is None for rank in range(8)):\n            open_files += 1\n    return float(open_files)", "def feature(board: chess.Board) -> float:\n    \"Measures the difference in the number of pieces on the board.\"\n    white_piece_count = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE)\n    black_piece_count = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK)\n    result = float(white_piece_count - black_piece_count)\n    return result", "def feature(board: chess.Board) -> float:\n    \"Counts the number of squares attacked by each player.\"\n    white_attacks = sum(board.is_attacked_by(chess.WHITE, square) for square in chess.SQUARES)\n    black_attacks = sum(board.is_attacked_by(chess.BLACK, square) for square in chess.SQUARES)\n    result = float(white_attacks - black_attacks)\n    return result", "def feature(board: chess.Board) -> float:\n    \"Calculates the distance of the closest enemy piece from the player's king.\"\n    king_square = next((square for square in board.piece_map() if board.piece_at(square).piece_type == chess.KING), None)\n    if king_square is None:\n        return 0.0  # Safety check\n    enemy_pieces = [square for square in board.piece_map() if board.piece_at(square).color != board.turn]\n    distances = [chess.square_distance(king_square, piece) for piece in enemy_pieces]\n    result = float(min(distances)) if distances else float('inf')\n    return result", "def feature(board: chess.Board) -> float:\n    \"Measures the number of pawns on each side and returns their difference.\"\n    white_pawn_count = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE and piece.piece_type == chess.PAWN)\n    black_pawn_count = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK and piece.piece_type == chess.PAWN)\n    result = float(white_pawn_count - black_pawn_count)\n    return result", "def feature(board: chess.Board) -> float:\n    \"Calculates how many pieces are pinned by each side to their king.\"\n    def count_pinned(color):\n        pinned_count = 0\n        for square, piece in board.piece_map().items():\n            if piece.color == color:\n                for attacker in board.attackers(not color, square):\n                    if board.is_attacked_by(color, attacker):\n                        pinned_count += 1\n        return pinned_count\n\n    white_pinned = count_pinned(chess.WHITE)\n    black_pinned = count_pinned(chess.BLACK)\n    result = float(white_pinned - black_pinned)\n    return result", "def feature(board: chess.Board) -> float:\n    \"Measures the number of pieces on the back rank for each player.\"\n    white_back_rank = sum(1 for square in range(56, 64) if board.piece_at(square) and board.piece_at(square).color == chess.WHITE)\n    black_back_rank = sum(1 for square in range(0, 8) if board.piece_at(square) and board.piece_at(square).color == chess.BLACK)\n    result = float(white_back_rank - black_back_rank)\n    return result", "def feature(board: chess.Board) -> float:\n    \"Counts the number of squares controlled by pawns.\"\n    controlled_squares = sum(1 for square in chess.SQUARES if (\n        board.piece_at(square) and board.piece_at(square).piece_type == chess.PAWN and\n        (board.turn == chess.WHITE and chess.square_rank(square) < 7 or board.turn == chess.BLACK and chess.square_rank(square) > 0)\n    ))\n    result = float(controlled_squares)\n    return result", "def feature(board: chess.Board) -> float:\n    \"Measures the total number of threats created by all pieces.\"\n    threats_count = sum(1 for move in board.legal_moves)\n    result = float(threats_count)\n    return result", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of squares attacked by both players.\"\n    white_attacks = sum(board.is_attacked_by(chess.WHITE, square) for square in chess.SQUARES)\n    black_attacks = sum(board.is_attacked_by(chess.BLACK, square) for square in chess.SQUARES)\n    return float(white_attacks - black_attacks)", "def feature(board: chess.Board) -> float:\n    \"Measures the difference in mobility between both players.\"\n    white_moves = len(list(board.legal_moves)) if board.turn == chess.WHITE else len(list(board.legal_moves)) + len(list(board.legal_moves))\n    black_moves = len(list(board.legal_moves)) if board.turn == chess.BLACK else len(list(board.legal_moves)) + len(list(board.legal_moves))\n    return float(white_moves - black_moves)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of potential discovered checks available.\"\n    count = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == board.turn and piece.piece_type in (chess.ROOK, chess.QUEEN):\n            for move in board.legal_moves:\n                board.push(move)\n                if board.is_check():\n                    count += 1\n                board.pop()\n    return float(count)", "def feature(board: chess.Board) -> float:\n    \"Measures the material strength of the opponent's pieces that are developed.\"\n    development_value = 0\n    for square, piece in board.piece_map().items():\n        if piece.color != board.turn and chess.square_rank(square) in (5, 6, 7):  # developed ranks\n            development_value += piece.piece_type\n    return float(development_value)", "def feature(board: chess.Board) -> float:\n    \"Assesses the number of exposed pawns for both players.\"\n    exposed_pawns = 0\n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.PAWN and piece.color == board.turn:\n            if (square - 1 in board.piece_map() or square + 1 in board.piece_map()): \n                continue\n            exposed_pawns += 1\n    return float(exposed_pawns)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of open files for both players.\"\n    open_files = 0\n    files_controlled = [0] * 8\n    for square, piece in board.piece_map().items():\n        files_controlled[chess.square_file(square)] += 1\n    open_files = sum(1 for count in files_controlled if count == 0)  # count completely open files\n    return float(open_files) ", "def feature(board: chess.Board) -> float:\n    \"Calculates the imbalances in pawn structure for both players.\"\n    pawn_imbalance = 0\n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.PAWN:\n            pawn_imbalance += (-1 if piece.color == chess.BLACK else 1)\n    return float(pawn_imbalance)", "def feature(board: chess.Board) -> float:\n    'Calculates the total number of pieces on the board.'\n    total_pieces = len(board.piece_map())\n    return float(total_pieces)", "def feature(board: chess.Board) -> float:\n    'Counts the number of pieces in the second rank.'\n    second_rank_count = sum(1 for sq in range(chess.A2, chess.H2 + 1) if board.piece_at(sq) is not None)\n    return float(second_rank_count)", "def feature(board: chess.Board) -> float:\n    'Measures the number of pawns that can promote.'\n    pawn_promotions = sum(1 for sq in board.piece_map() if board.piece_at(sq).piece_type == chess.PAWN and (chess.square_rank(sq) == 6 if board.piece_at(sq).color == chess.WHITE else chess.square_rank(sq) == 1))\n    return float(pawn_promotions)", "def feature(board: chess.Board) -> float:\n    'Calculates the difference in pawn structure between both players.'\n    white_pawn_positions = [sq for sq in board.piece_map() if board.piece_at(sq).color == chess.WHITE and board.piece_at(sq).piece_type == chess.PAWN]\n    black_pawn_positions = [sq for sq in board.piece_map() if board.piece_at(sq).color == chess.BLACK and board.piece_at(sq).piece_type == chess.PAWN]\n    pawn_structure_value = len(white_pawn_positions) - len(black_pawn_positions)\n    return float(pawn_structure_value)", "def feature(board: chess.Board) -> float:\n    'Calculates the distance of the king from the nearest corner.'\n    king_square = next(sq for sq in board.piece_map() if board.piece_at(sq).piece_type == chess.KING and board.piece_at(sq).color == (chess.WHITE if board.turn else chess.BLACK))\n    corner_distances = [chess.square_distance(king_square, square) for square in [chess.A1, chess.A8, chess.H1, chess.H8]]\n    return float(min(corner_distances))", "def feature(board: chess.Board) -> float:\n    'Measures the position of rooks on open files (files without pawns).'\n    open_file_count = sum(1 for file in range(8) if not any(board.piece_at(chess.square(file, rank)) for rank in range(8) if board.piece_at(chess.square(file, rank)) is not None and board.piece_at(chess.square(file, rank)).piece_type == chess.PAWN))\n    rooks_on_open_files = sum(1 for sq in board.piece_map() if board.piece_at(sq).piece_type == chess.ROOK and chess.square_file(sq) in {file for file in range(8) if not any(board.piece_at(chess.square(file, rank)) for rank in range(8))})\n    return float(rooks_on_open_files)", "def feature(board: chess.Board) -> float:\n    'Calculates the average piece value of both players.'\n    piece_values = {chess.PAWN: 1, chess.KNIGHT: 3, chess.BISHOP: 3, chess.ROOK: 5, chess.QUEEN: 9, chess.KING: 0}\n    total_value = sum(piece_values[board.piece_at(sq).piece_type] for sq in board.piece_map())\n    average_piece_value = total_value / len(board.piece_map()) if len(board.piece_map()) > 0 else 0.0\n    return float(average_piece_value)", "def feature(board: chess.Board) -> float:\n    'Counts the number of pieces on the back rank for both players.'\n    back_rank_count = sum(1 for sq in range(chess.A8, chess.H8 + 1) if board.piece_at(sq) is not None) + sum(1 for sq in range(chess.A1, chess.H1 + 1) if board.piece_at(sq) is not None)\n    return float(back_rank_count)", "def feature(board: chess.Board) -> float:\n    'Calculates the number of threatened squares.'\n    threatened_squares = sum(1 for sq in chess.SQUARES if board.is_attacked_by(not board.turn, sq))\n    return float(threatened_squares)", "def feature(board: chess.Board) -> float:\n    'Calculates the ratio of major pieces (rooks, queens) to minor pieces (knights, bishops) for the current player.'\n    major_count = sum(1 for piece in board.piece_map().values() if piece.color == board.turn and piece.piece_type in [chess.ROOK, chess.QUEEN])\n    minor_count = sum(1 for piece in board.piece_map().values() if piece.color == board.turn and piece.piece_type in [chess.KNIGHT, chess.BISHOP])\n    return major_count / (minor_count + 1)  # Add 1 to avoid division by zero", "def feature(board: chess.Board) -> float:\n    'Counts the number of squares that are controlled by the current player\u2019s pieces.'\n    controlled_squares = set()\n    for piece in board.piece_map().values():\n        if piece.color == board.turn:\n            controlled_squares.update(board.legal_moves)\n    return float(len(controlled_squares))", "def feature(board: chess.Board) -> float:\n    'Determines the presence of opposite color bishops on the board.'\n    white_bishops = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE and piece.piece_type == chess.BISHOP)\n    black_bishops = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK and piece.piece_type == chess.BISHOP)\n    return float(1 if (white_bishops > 0) and (black_bishops > 0) else 0)", "def feature(board: chess.Board) -> float:\n    'Counts the number of rooks on open files (files with no enemy pawns).'\n    open_file_count = 0\n    for file in range(8):\n        column_has_enemy_pawn = any(board.piece_at(chess.square(file, rank)) == chess.PAWN and board.piece_map()[chess.square(file, rank)].color == chess.BLACK for rank in range(7))\n        if not column_has_enemy_pawn:\n            open_file_count += 1\n    return float(open_file_count)", "def feature(board: chess.Board) -> float:\n    'Calculates the number of squares with pieces that are defended by two or more pieces.'\n    defended_squares_count = sum(1 for square in board.piece_map() if board.is_attacked_by(not board.turn, square) and len(board.attackers(board.turn, square)) >= 2)\n    return float(defended_squares_count)", "def feature(board: chess.Board) -> float:\n    'Measures the difference in the number of pawns for both players.'\n    white_pawns = sum(1 for piece in board.piece_map().values() if piece.piece_type == chess.PAWN and piece.color == chess.WHITE)\n    black_pawns = sum(1 for piece in board.piece_map().values() if piece.piece_type == chess.PAWN and piece.color == chess.BLACK)\n    return float(white_pawns - black_pawns)", "def feature(board: chess.Board) -> float:\n    'Calculates the distance of the farthest piece from the player\u2019s king.'\n    king_square = next((square for square, piece in board.piece_map().items() if piece.color == board.turn and piece.piece_type == chess.KING), None)\n    if king_square is None:\n        return 0.0  # No king found, should not happen\n    max_distance = max(chess.square_distance(king_square, square) for square in board.piece_map() if board.piece_map()[square].color == board.turn)\n    return float(max_distance)", "def feature(board: chess.Board) -> float:\n    'Counts the number of forks (attacks on two or more pieces) available to the current player.'\n    forks = 0\n    for move in board.legal_moves:\n        board.push(move)\n        attacked_count = sum(1 for square in board.piece_map() if board.is_attacked_by(board.turn, square) and board.piece_map()[square].color != board.turn)\n        if attacked_count >= 2:\n            forks += 1\n        board.pop()\n    return float(forks)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of pins that each player's pieces have against the opposing king.\"\n    pins = 0\n    for square in board.piece_map():\n        piece = board.piece_at(square)\n        if piece.color == board.turn:\n            if board.is_attacked_by(not board.turn, square):\n                pins += 1\n    return float(pins)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of central control squares occupied by each player.\"\n    central_squares = [chess.E4, chess.E5, chess.D4, chess.D5]\n    white_control = sum(board.is_attacked_by(chess.WHITE, sq) for sq in central_squares)\n    black_control = sum(board.is_attacked_by(chess.BLACK, sq) for sq in central_squares)\n    return float(white_control - black_control)", "def feature(board: chess.Board) -> float:\n    \"Calculates the distance of all major pieces to the opponent's king.\"\n    total_distance = 0\n    opponent_king_square = next(square for square in board.piece_map() if board.piece_at(square).piece_type == chess.KING and board.piece_at(square).color != board.turn)\n    for square in board.piece_map():\n        piece = board.piece_at(square)\n        if piece.color == board.turn and piece.piece_type in {chess.QUEEN, chess.ROOK, chess.BISHOP}:\n            total_distance += chess.square_distance(square, opponent_king_square)\n    return float(total_distance)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces located on the back rank for each player.\"\n    back_rank = {chess.WHITE: 0, chess.BLACK: 0}\n    for square in range(0, 8):\n        for color in [chess.WHITE, chess.BLACK]:\n            piece = board.piece_at(chess.square(square, 0 if color == chess.WHITE else 7))\n            if piece and piece.color == color:\n                back_rank[color] += 1\n    return float(back_rank[chess.WHITE] - back_rank[chess.BLACK])", "def feature(board: chess.Board) -> float:\n    \"Evaluates the safety of the kings based on the number of pieces defending each king.\"\n    white_defenders = len(board.attackers(chess.WHITE, board.king(chess.WHITE)))\n    black_defenders = len(board.attackers(chess.BLACK, board.king(chess.BLACK)))\n    return float(white_defenders - black_defenders)", "def feature(board: chess.Board) -> float:\n    \"Count the number of pieces on the board that are on squares of the same color as the player to move.\"\n    color_control_count = 0\n    for square in board.piece_map():\n        piece = board.piece_at(square)\n        if piece.color == board.turn and (chess.square_file(square) + chess.square_rank(square)) % 2 == (0 if board.turn == chess.WHITE else 1):\n            color_control_count += 1\n    return float(color_control_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the mobility disadvantage based on the least number of legal moves available to either player.\"\n    white_moves = len(list(board.legal_moves)) if board.turn == chess.WHITE else 0\n    black_moves = len(list(board.legal_moves)) if board.turn == chess.BLACK else 0\n    return float(min(white_moves, black_moves))", "def feature(board: chess.Board) -> float:\n    \"Measures the aggression score based on the number of pieces attacking the opponent\u2019s pieces.\"\n    aggression_score = 0\n    for square in board.piece_map():\n        piece = board.piece_at(square)\n        if piece.color == board.turn:\n            aggression_score += len(board.attackers(not board.turn, square))\n    return float(aggression_score)", "def feature(board: chess.Board) -> float:\n    \"Measures the king's safety by counting the number of squares around it that are attacked.\"\n    king_square = board.king(board.turn)\n    attacked_squares = sum(board.is_attacked_by(not board.turn, square) for square in chess.SQUARES)\n    return float(attacked_squares)", "def feature(board: chess.Board) -> float:\n    \"Calculates the total number of pawns on the board.\"\n    pawns_count = sum(1 for piece in board.piece_map().values() if piece.piece_type == chess.PAWN)\n    return float(pawns_count)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of unprotected pieces for the current player.\"\n    unprotected_count = sum(1 for square, piece in board.piece_map().items() \n                            if piece.color == board.turn and len(board.attackers(not board.turn, square)) == 0)\n    return float(unprotected_count)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of major pieces (rooks and queens) for both players.\"\n    major_pieces_count = sum(1 for piece in board.piece_map().values() \n                              if piece.piece_type in [chess.ROOK, chess.QUEEN])\n    return float(major_pieces_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the distance of all kings from the center of the board (d4/e4).\"\n    center_squares = [chess.parse_square('d4'), chess.parse_square('e4')]\n    king_square = board.king(board.turn)\n    distance = min(chess.square_distance(king_square, center) for center in center_squares)\n    return float(distance)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces that are pinned.\"\n    pinned_count = sum(1 for square, piece in board.piece_map().items() \n                       if piece.color == board.turn and board.is_attacked_by(not board.turn, square))\n    return float(pinned_count)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of doubled pawns for both players.\"\n    pawn_files = {}\n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.PAWN:\n            file = chess.square_file(square)\n            if piece.color not in pawn_files:\n                pawn_files[piece.color] = set()\n            pawn_files[piece.color].add(file)\n    doubled_pawns = sum(max(0, len(files) - 1) for files in pawn_files.values())\n    return float(doubled_pawns)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of pieces on the 7th rank for both players.\"\n    rank_7_count = sum(1 for square, piece in board.piece_map().items() \n                       if chess.square_rank(square) == 6)  # 7th rank is rank 6 (0-indexed)\n    return float(rank_7_count)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces for both players that are on the 2nd rank.\"\n    rank_2_count = sum(1 for square, piece in board.piece_map().items() \n                       if chess.square_rank(square) == 1)  # 2nd rank is rank 1 (0-indexed)\n    return float(rank_2_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the ratio of pieces on the seventh and eighth ranks for each player.\"\n    white_seventh = sum(1 for sq in board.piece_map() if board.piece_at(sq).color == chess.WHITE and chess.square_rank(sq) == 6)\n    white_eighth = sum(1 for sq in board.piece_map() if board.piece_at(sq).color == chess.WHITE and chess.square_rank(sq) == 7)\n    black_seventh = sum(1 for sq in board.piece_map() if board.piece_at(sq).color == chess.BLACK and chess.square_rank(sq) == 6)\n    black_eighth = sum(1 for sq in board.piece_map() if board.piece_at(sq).color == chess.BLACK and chess.square_rank(sq) == 7)\n    result = (white_seventh + white_eighth) - (black_seventh + black_eighth)\n    return float(result)", "def feature(board: chess.Board) -> float:\n    \"Measures the difference in the number of pawns on the board.\"\n    white_pawns = sum(1 for sq in board.piece_map() if board.piece_at(sq).color == chess.WHITE and board.piece_at(sq).piece_type == chess.PAWN)\n    black_pawns = sum(1 for sq in board.piece_map() if board.piece_at(sq).color == chess.BLACK and board.piece_at(sq).piece_type == chess.PAWN)\n    result = float(white_pawns - black_pawns)\n    return result", "def feature(board: chess.Board) -> float:\n    \"Counts the number of attacking pieces for both players.\"\n    white_attacks = sum(len(board.attackers(chess.WHITE, sq)) for sq in board.piece_map() if board.piece_at(sq).color == chess.WHITE)\n    black_attacks = sum(len(board.attackers(chess.BLACK, sq)) for sq in board.piece_map() if board.piece_at(sq).color == chess.BLACK)\n    result = float(white_attacks - black_attacks)\n    return result", "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in piece mobility (number of legal moves) between players.\"\n    white_moves = sum(1 for move in board.legal_moves if board.turn == chess.WHITE)\n    black_moves = sum(1 for move in board.legal_moves if board.turn == chess.BLACK)\n    result = float(white_moves - black_moves)\n    return result", "def feature(board: chess.Board) -> float:\n    \"Measures the average distance of pieces from the opposing king.\"\n    if board.is_checkmate() or board.is_stalemate():\n        return 0.0\n    white_distance = sum(chess.square_distance(sq, board.king(chess.BLACK)) for sq in board.piece_map() if board.piece_at(sq).color == chess.WHITE)\n    black_distance = sum(chess.square_distance(sq, board.king(chess.WHITE)) for sq in board.piece_map() if board.piece_at(sq).color == chess.BLACK)\n    total_distance = white_distance + black_distance\n    piece_count = len(board.piece_map())\n    result = total_distance / piece_count if piece_count > 0 else 0.0\n    return result", "def feature(board: chess.Board) -> float:\n    \"Counts the number of unprotected pieces for both players.\"\n    white_unprotected = sum(1 for sq in board.piece_map() if board.piece_at(sq).color == chess.WHITE and not board.attackers(chess.BLACK, sq))\n    black_unprotected = sum(1 for sq in board.piece_map() if board.piece_at(sq).color == chess.BLACK and not board.attackers(chess.WHITE, sq))\n    result = float(white_unprotected - black_unprotected)\n    return result", "def feature(board: chess.Board) -> float:\n    \"Measures the symmetry of the position by looking at the board's piece distribution.\"\n    white_distribution = [0] * 8\n    black_distribution = [0] * 8\n    for sq in board.piece_map():\n        piece = board.piece_at(sq)\n        file_index = chess.square_file(sq)\n        if piece.color == chess.WHITE:\n            white_distribution[file_index] += 1\n        else:\n            black_distribution[file_index] += 1\n    result = float(sum(abs(white_distribution[i] - black_distribution[i]) for i in range(8)))\n    return result", "def feature(board: chess.Board) -> float:\n    \"Calculates the total number of pieces on the board for both players.\"\n    return float(len(board.piece_map()))", "def feature(board: chess.Board) -> float:\n    \"Counts the number of attacking threats each player poses on the board.\"\n    white_threats = sum(1 for move in board.legal_moves if board.is_attacked_by(chess.WHITE, move.to_square))\n    black_threats = sum(1 for move in board.legal_moves if board.is_attacked_by(chess.BLACK, move.to_square))\n    return float(white_threats - black_threats)", "def feature(board: chess.Board) -> float:\n    \"Measures the proportion of pawns on the board compared to the total number of pieces.\"\n    total_pieces = len(board.piece_map())\n    if total_pieces == 0:\n        return 0.0\n    pawn_count = sum(1 for piece in board.piece_map().values() if piece.piece_type == chess.PAWN)\n    return float(pawn_count) / total_pieces", "def feature(board: chess.Board) -> float:\n    \"Calculates the distance from the player's pieces to the opposing king.\"\n    player_color = chess.WHITE if board.turn else chess.BLACK\n    opponent_king_square = next(sq for sq, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color != player_color)\n    distances = [chess.square_distance(sq, opponent_king_square) for sq, piece in board.piece_map().items() if piece.color == player_color]\n    return float(sum(distances)) / len(distances) if distances else 0.0", "def feature(board: chess.Board) -> float:\n    \"Counts the number of potential passes for pawns towards promotion.\"\n    passable_pawns = sum(1 for sq, piece in board.piece_map().items() if piece.piece_type == chess.PAWN and (piece.color == chess.WHITE and chess.square_rank(sq) < 7 or piece.color == chess.BLACK and chess.square_rank(sq) > 0))\n    return float(passable_pawns)", "def feature(board: chess.Board) -> float:\n    \"Calculates the count of pieces on the back rank that are not activated.\"\n    back_rank = (0, 7) if board.turn == chess.WHITE else (7, 0)\n    inactive_pieces = sum(1 for sq in range(back_rank[0] * 8, back_rank[0] * 8 + 8) if board.piece_at(sq) is not None and not board.piece_at(sq).piece_type in [chess.ROOK, chess.KING])\n    return float(inactive_pieces)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of squares controlled by pieces on the back rank.\"\n    controlled_squares = set()\n    back_rank = (0, 7) if board.turn == chess.WHITE else (7, 0)\n    for sq in range(back_rank[0] * 8, back_rank[0] * 8 + 8):\n        piece = board.piece_at(sq)\n        if piece:\n            controlled_squares.update(board.attacks(sq))\n    return float(len(controlled_squares))", "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in the number of pieces that are pinned.\"\n    pinned_white = sum(1 for sq in board.piece_map() if board.is_attacked_by(chess.BLACK, sq) and board.is_check())\n    pinned_black = sum(1 for sq in board.piece_map() if board.is_attacked_by(chess.WHITE, sq) and board.is_check())\n    return float(pinned_white - pinned_black)", "def feature(board: chess.Board) -> float:\n    \"Calculates the ratio of pieces to available squares for each player.\"\n    total_pieces = len(board.piece_map())\n    available_squares = 64 - total_pieces\n    if available_squares == 0:\n        return 0.0\n    return float(total_pieces) / available_squares", "def feature(board: chess.Board) -> float:\n    \"Counts the number of unprotected pieces for the current player.\"\n    unprotected_pieces = sum(1 for sq, piece in board.piece_map().items() if piece.color == (chess.WHITE if board.turn else chess.BLACK) and board.attackers(piece.color, sq) == set())\n    return float(unprotected_pieces)", "def feature(board: chess.Board) -> float:\n    \"Measures the mobility of the player to move by counting the number of legal moves.\"\n    return float(len(list(board.legal_moves)))", "def feature(board: chess.Board) -> float:\n    \"Counts the difference in material value between the two players.\"\n    material_values = {\n        chess.PAWN: 100,\n        chess.KNIGHT: 320,\n        chess.BISHOP: 330,\n        chess.ROOK: 500,\n        chess.QUEEN: 900,\n        chess.KING: 20000\n    }\n    \n    white_value = sum(material_values[piece.piece_type] for piece in board.piece_map().values() if piece.color == chess.WHITE)\n    black_value = sum(material_values[piece.piece_type] for piece in board.piece_map().values() if piece.color == chess.BLACK)\n    return float(white_value - black_value)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of pinned pieces for the player to move.\"\n    def is_pinned(square):\n        piece = board.piece_at(square)\n        if not piece or piece.color != board.turn:\n            return False\n        for attacker in board.attackers(not board.turn, square):\n            if board.is_attacked_by(piece.color, attacker):\n                return True\n        return False\n    \n    pinned_count = sum(1 for square in board.piece_map() if is_pinned(square))\n    return float(pinned_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the ratio of pieces on the board for each player.\"\n    white_pieces = len([p for p in board.piece_map().values() if p.color == chess.WHITE])\n    black_pieces = len([p for p in board.piece_map().values() if p.color == chess.BLACK])\n    return float(white_pieces / (black_pieces + 1))  # Avoid division by zero", "def feature(board: chess.Board) -> float:\n    \"Measures the distance of the kings from each other.\"\n    white_king = next(square for square, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color == chess.WHITE)\n    black_king = next(square for square, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color == chess.BLACK)\n    distance = chess.square_distance(white_king, black_king)\n    return float(distance)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of unprotected pieces for the player to move.\"\n    unprotected_count = sum(1 for square, piece in board.piece_map().items() if piece.color == board.turn and not board.attackers(not board.turn, square))\n    return float(unprotected_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of pieces that can give a check on the next move.\"\n    check_count = sum(1 for move in board.legal_moves if board.gives_check(move))\n    return float(check_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the total value of the opponent's pieces currently on the board.\"\n    opponent_values = {\n        chess.PAWN: 100,\n        chess.KNIGHT: 320,\n        chess.BISHOP: 330,\n        chess.ROOK: 500,\n        chess.QUEEN: 900,\n        chess.KING: 20000\n    }\n    \n    opponent_total_value = sum(opponent_values[piece.piece_type] for piece in board.piece_map().values() if piece.color != board.turn)\n    return float(opponent_total_value)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of pieces that a player has in the opponent's half of the board.\"\n    opponent_half = 4  # Ranks 4 to 7 for White, 0 to 3 for Black\n    pieces_in_opponent_half = sum(1 for square in board.piece_map() if (board.turn == chess.WHITE and chess.square_rank(square) >= opponent_half) or (board.turn == chess.BLACK and chess.square_rank(square) < opponent_half))\n    return float(pieces_in_opponent_half)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of squares attacked by both players.\"\n    white_attacking_squares = set()\n    black_attacking_squares = set()\n    \n    for move in board.legal_moves:\n        if board.turn:  # White's turn\n            white_attacking_squares.add(move.to_square)\n        else:  # Black's turn\n            black_attacking_squares.add(move.to_square)\n\n    result = len(white_attacking_squares) - len(black_attacking_squares)\n    return float(result)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of isolated pawns on the board.\"\n    isolated_pawns = 0\n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.PAWN:\n            file = chess.square_file(square)\n            rank = chess.square_rank(square)\n            if (board.piece_at(chess.square(file - 1, rank)) is None and\n                board.piece_at(chess.square(file + 1, rank)) is None):\n                isolated_pawns += 1\n    return float(isolated_pawns)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of minor piece pairs on the board.\"\n    white_knights = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE and piece.piece_type == chess.KNIGHT)\n    black_knights = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK and piece.piece_type == chess.KNIGHT)\n    return float(white_knights + black_knights)", "def feature(board: chess.Board) -> float:\n    \"Calculates the mobility of the side to move, i.e., number of legal moves.\"\n    result = len(list(board.legal_moves))\n    return float(result)", "def feature(board: chess.Board) -> float:\n    \"Calculates the distance of the kings from the center of the board.\"\n    white_king_square = next(square for square, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color == chess.WHITE)\n    black_king_square = next(square for square, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color == chess.BLACK)\n    \n    white_distance = max(chess.square_file(white_king_square), 7 - chess.square_file(white_king_square)) + \\\n                     max(chess.square_rank(white_king_square), 7 - chess.square_rank(white_king_square))\n    \n    black_distance = max(chess.square_file(black_king_square), 7 - chess.square_file(black_king_square)) + \\\n                     max(chess.square_rank(black_king_square), 7 - chess.square_rank(black_king_square))\n    \n    result = white_distance - black_distance\n    return float(result)", "def feature(board: chess.Board) -> float:\n    \"Evaluates the number of potential discovered checks available.\"\n    discovered_checks = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == board.turn:  # Only consider pieces of the player to move\n            for target_square in chess.SQUARES:\n                if target_square != square and board.is_attacked_by(not board.turn, target_square):\n                    if piece.piece_type == chess.QUEEN or piece.piece_type == chess.ROOK or piece.piece_type == chess.BISHOP:\n                        discovered_checks += 1\n                    if piece.piece_type == chess.KNIGHT:\n                        discovered_checks += 1\n    return float(discovered_checks)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces pinned against a king.\"\n    pinned_pieces = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == board.turn:\n            for attacker in board.attackers(not board.turn, square):\n                if board.piece_at(attacker).piece_type in {chess.QUEEN, chess.ROOK, chess.BISHOP}:\n                    path_clear = True\n                    for path_square in board.pseudo_legal_moves:\n                        if path_square in range(min(square, attacker), max(square, attacker) + 1):\n                            if board.piece_at(path_square) is not None:\n                                path_clear = False\n                    if path_clear:\n                        pinned_pieces += 1\n    return float(pinned_pieces)", "def feature(board: chess.Board) -> float:\n    \"Measures the difference in piece activity, based on distance from the center.\"\n    activity_score = 0\n    center_squares = [chess.E4, chess.E5, chess.D4, chess.D5]\n    \n    for square, piece in board.piece_map().items():\n        distance_from_center = chess.square_distance(square, chess.E4)  # E4 is the center square\n        if piece.color == chess.WHITE:\n            activity_score += 1 / (1 + distance_from_center)  # Closer pieces have higher activity score\n        else:\n            activity_score -= 1 / (1 + distance_from_center)  # Closer pieces have lower activity score for black\n            \n    return float(activity_score)", "def feature(board: chess.Board) -> float:\n    \"Counts how many pieces are currently threatening the opponent's king.\"\n    opponent_king_square = next(square for square, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color != board.turn)\n    threats_to_king = sum(1 for square, piece in board.piece_map().items() \n                           if piece.color == board.turn and \n                           chess.square_distance(square, opponent_king_square) <= 2 \n                           and (piece.piece_type == chess.QUEEN or piece.piece_type == chess.ROOK or piece.piece_type == chess.BISHOP or piece.piece_type == chess.KNIGHT))\n    return float(threats_to_king)", "def feature(board: chess.Board) -> float:\n    'Calculates the difference in mobility between both players.'\n    white_moves = len(list(board.legal_moves))\n    black_moves = len(list(board.legal_moves)) if board.turn else 0\n    return float(white_moves - black_moves)", "def feature(board: chess.Board) -> float:\n    'Measures the total number of pieces per player.'\n    pieces_count = sum(1 for piece in board.piece_map().values())\n    return float(pieces_count)", "def feature(board: chess.Board) -> float:\n    'Counts the number of pieces attacking the opponent\u2019s king.'\n    white_attacks = len(board.attackers(chess.WHITE, chess.Board().king(chess.BLACK)))\n    black_attacks = len(board.attackers(chess.BLACK, chess.Board().king(chess.WHITE)))\n    return float(white_attacks - black_attacks)", "def feature(board: chess.Board) -> float:\n    'Calculates the number of pawns on the board for each color.'\n    white_pawns = sum(1 for piece in board.piece_map().values() if piece.piece_type == chess.PAWN and piece.color == chess.WHITE)\n    black_pawns = sum(1 for piece in board.piece_map().values() if piece.piece_type == chess.PAWN and piece.color == chess.BLACK)\n    return float(white_pawns - black_pawns)", "def feature(board: chess.Board) -> float:\n    'Measures the average distance of pieces to the opponent\u2019s back rank.'\n    total_distance = 0\n    piece_count = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == board.turn:\n            distance = chess.square_distance(square, chess.square_file(square) + (0 if piece.color == chess.WHITE else 7))\n            total_distance += distance\n            piece_count += 1\n    return total_distance / piece_count if piece_count > 0 else 0.0", "def feature(board: chess.Board) -> float:\n    'Counts the number of pinned pieces for each side.'\n    pinned_count = 0\n    for square, piece in board.piece_map().items():\n        if board.is_attacked_by(not piece.color, square) and board.is_attacked_by(piece.color, square):\n            pinned_count += 1\n    return float(pinned_count)", "def feature(board: chess.Board) -> float:\n    'Evaluates the ratio of major pieces (rooks and queens) to minor pieces (knights and bishops).'\n    major_pieces = sum(1 for piece in board.piece_map().values() if piece.piece_type in [chess.ROOK, chess.QUEEN])\n    minor_pieces = sum(1 for piece in board.piece_map().values() if piece.piece_type in [chess.KNIGHT, chess.BISHOP])\n    return major_pieces / minor_pieces if minor_pieces > 0 else float('inf')", "def feature(board: chess.Board) -> float:\n    'Counts how many pieces are on dark squares versus light squares.'\n    dark_squares = sum(1 for square in board.piece_map() if (chess.square_file(square) + chess.square_rank(square)) % 2 == 0)\n    light_squares = sum(1 for square in board.piece_map() if (chess.square_file(square) + chess.square_rank(square)) % 2 == 1)\n    return float(dark_squares - light_squares)", "def feature(board: chess.Board) -> float:\n    \"Measures the total number of pawns on the board and their respective locations.\"\n    pawn_counts = sum(1 for piece in board.piece_map().values() if piece.piece_type == chess.PAWN)\n    return float(pawn_counts)", "def feature(board: chess.Board) -> float:\n    \"Calculates the combined distance of all pieces to their opponent's back rank.\"\n    distance_sum = sum(7 - chess.square_rank(square) if board.piece_at(square).color == chess.WHITE else chess.square_rank(square) for square in board.piece_map())\n    return float(distance_sum)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces directly attacking the opponent's king.\"\n    opponent_king_square = next(square for square, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color != board.turn)\n    attacking_pieces = sum(1 for square in board.attackers(board.turn, opponent_king_square))\n    return float(attacking_pieces)", "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in piece values between the two players.\"\n    piece_values = {chess.PAWN: 100, chess.KNIGHT: 320, chess.BISHOP: 330, chess.ROOK: 500, chess.QUEEN: 900, chess.KING: 0}\n    white_value = sum(piece_values[piece.piece_type] for piece in board.piece_map().values() if piece.color == chess.WHITE)\n    black_value = sum(piece_values[piece.piece_type] for piece in board.piece_map().values() if piece.color == chess.BLACK)\n    return float(white_value - black_value)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of isolated pawns on the board.\"\n    isolated_pawns = 0\n    for square in board.piece_map():\n        piece = board.piece_at(square)\n        if piece is not None and piece.piece_type == chess.PAWN:\n            file = chess.square_file(square)\n            if (board.piece_at(chess.square(file - 1, chess.square_rank(square))) is None and\n                board.piece_at(chess.square(file + 1, chess.square_rank(square))) is None):\n                isolated_pawns += 1\n    return float(isolated_pawns)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of pieces within a distance of two squares from each king.\"\n    white_king_square = next(square for square, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color == chess.WHITE)\n    black_king_square = next(square for square, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color == chess.BLACK)\n    \n    white_distance = sum(1 for square in board.piece_map() if chess.square_distance(square, white_king_square) <= 2)\n    black_distance = sum(1 for square in board.piece_map() if chess.square_distance(square, black_king_square) <= 2)\n\n    return float(white_distance - black_distance)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of pieces that attack each player's back rank squares.\"\n    white_back_rank_attacks = sum(1 for square in [chess.A8, chess.B8, chess.C8, chess.D8, chess.E8, chess.F8, chess.G8, chess.H8] if board.is_attacked_by(chess.WHITE, square))\n    black_back_rank_attacks = sum(1 for square in [chess.A1, chess.B1, chess.C1, chess.D1, chess.E1, chess.F1, chess.G1, chess.H1] if board.is_attacked_by(chess.BLACK, square))\n\n    return float(white_back_rank_attacks - black_back_rank_attacks)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces that are directly supported by their own pieces.\"\n    supported_count = sum(1 for square in board.piece_map() if board.piece_at(square) and any(board.is_attacked_by(board.piece_at(square).color, sq) for sq in board.attackers(board.piece_at(square).color, square)))\n    return float(supported_count)", "def feature(board: chess.Board) -> float:\n    \"Measures the ratio of pieces attacking the opponent's king to the defending pieces.\"\n    attackers = sum(1 for square in chess.SQUARES if board.is_attacked_by(chess.WHITE, square))\n    defenders = sum(1 for square in chess.SQUARES if board.is_attacked_by(chess.BLACK, square))\n    return attackers / (defenders + 1e-6)  # add small epsilon to avoid division by zero", "def feature(board: chess.Board) -> float:\n    \"Counts the number of double attacks on the opponent's pieces.\"\n    double_attacks = 0\n    for square in board.piece_map():\n        piece = board.piece_at(square)\n        if piece.color == chess.BLACK:\n            attackers = len(board.attackers(chess.WHITE, square))\n            if attackers > 1:\n                double_attacks += attackers\n    return float(double_attacks)", "def feature(board: chess.Board) -> float:\n    \"Calculates the safety of the current player's king by counting available escape squares.\"\n    king_square = None\n    for square in chess.SQUARES:\n        piece = board.piece_at(square)\n        if piece and piece.piece_type == chess.KING and piece.color == board.turn:\n            king_square = square\n            break\n    escape_squares = sum(1 for square in chess.SQUARES if board.is_attacked_by(not board.turn, square))\n    return float(8 - escape_squares)  # maximum escape squares for a king is 8", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces not immediately threatened by an opponent's piece.\"\n    safe_piece_count = sum(1 for square in board.piece_map() if not board.is_attacked_by(not board.turn, square))\n    return float(safe_piece_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the presence of 'back rank' weaknesses for the current player.\"\n    back_rank = 0\n    if board.turn == chess.WHITE:\n        back_rank_squares = [chess.A1, chess.B1, chess.C1, chess.D1, chess.E1, chess.F1, chess.G1, chess.H1]\n    else:\n        back_rank_squares = [chess.A8, chess.B8, chess.C8, chess.D8, chess.E8, chess.F8, chess.G8, chess.H8]\n    \n    back_rank_empty = all(board.piece_at(square) is None for square in back_rank_squares)\n    if back_rank_empty and not board.is_check():\n        back_rank = 1.0\n    return float(back_rank)", "def feature(board: chess.Board) -> float:\n    \"Measures the difference in central control between both players.\"\n    central_squares = [chess.D4, chess.D5, chess.E4, chess.E5]\n    white_control = sum(1 for square in central_squares if board.is_attacked_by(chess.WHITE, square))\n    black_control = sum(1 for square in central_squares if board.is_attacked_by(chess.BLACK, square))\n    return float(white_control - black_control)", "def feature(board: chess.Board) -> float:\n    \"Measures the distance between pieces and the king of the current player.\"\n    piece_distance_sum = 0\n    piece_count = 0\n    king_square = None\n    for square in chess.SQUARES:\n        piece = board.piece_at(square)\n        if piece and piece.color == board.turn:\n            piece_count += 1\n            if piece.piece_type == chess.KING:\n                king_square = square\n    for square in chess.SQUARES:\n        piece = board.piece_at(square)\n        if piece and piece.color == board.turn and piece.piece_type != chess.KING:\n            piece_distance_sum += chess.square_distance(square, king_square)\n    return float(piece_distance_sum / (piece_count + 1e-6))  # so that we don\u2019t divide by zero", "def feature(board: chess.Board) -> float:\n    \"Measures the difference in the number of rooks for each player.\"\n    white_rooks = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE and piece.piece_type == chess.ROOK)\n    black_rooks = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK and piece.piece_type == chess.ROOK)\n    return float(white_rooks - black_rooks)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces on the back rank for each player.\"\n    white_back_rank = sum(1 for sq in range(56, 64) if board.piece_at(sq) is not None and board.piece_at(sq).color == chess.WHITE)\n    black_back_rank = sum(1 for sq in range(0, 8) if board.piece_at(sq) is not None and board.piece_at(sq).color == chess.BLACK)\n    return float(white_back_rank - black_back_rank)", "def feature(board: chess.Board) -> float:\n    \"Calculates the mobility advantage by summing the number of legal moves for each player.\"\n    white_moves = len(list(board.legal_moves)) if board.turn else 0\n    black_moves = len(list(board.legal_moves)) if not board.turn else 0\n    return float(white_moves - black_moves)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of pawns on the 5th and 6th ranks for each player.\"\n    white_pawns = sum(1 for sq in range(32, 48) if board.piece_at(sq) is not None and board.piece_at(sq).color == chess.WHITE and board.piece_at(sq).piece_type == chess.PAWN)\n    black_pawns = sum(1 for sq in range(16, 32) if board.piece_at(sq) is not None and board.piece_at(sq).color == chess.BLACK and board.piece_at(sq).piece_type == chess.PAWN)\n    return float(white_pawns - black_pawns)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of squares controlled by both players.\"\n    white_controlled = sum(1 for sq in chess.SQUARES if board.is_attacked_by(chess.WHITE, sq))\n    black_controlled = sum(1 for sq in chess.SQUARES if board.is_attacked_by(chess.BLACK, sq))\n    return float(white_controlled - black_controlled)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of undefended pieces for each player.\"\n    undefended_white = sum(1 for sq in board.piece_map() if board.piece_at(sq).color == chess.WHITE and not board.attackers(chess.BLACK, sq))\n    undefended_black = sum(1 for sq in board.piece_map() if board.piece_at(sq).color == chess.BLACK and not board.attackers(chess.WHITE, sq))\n    return float(undefended_white - undefended_black)", "def feature(board: chess.Board) -> float:\n    \"Measures the distance of the kings from each other.\"\n    white_king_sq = chess.square_name(board.king(chess.WHITE))\n    black_king_sq = chess.square_name(board.king(chess.BLACK))\n    distance = chess.square_distance(board.king(chess.WHITE), board.king(chess.BLACK))\n    return float(distance)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of pieces in the center squares.\"\n    center_squares = [chess.D4, chess.D5, chess.E4, chess.E5]\n    count = sum(1 for sq in center_squares if board.piece_at(sq) is not None)\n    return float(count)", "def feature(board: chess.Board) -> float:\n    \"Measures the total value of material that is currently under attack.\"\n    attack_value = 0\n    for sq in board.piece_map():\n        piece = board.piece_at(sq)\n        if piece:\n            if board.is_attacked_by(not piece.color, sq):\n                attack_value += piece.piece_type\n    return float(attack_value)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of hanging pieces for each side.\"\n    hanging_pieces = 0\n    for square, piece in board.piece_map().items():\n        if board.is_attacked_by(not piece.color, square):\n            hanging_pieces += 1\n    return float(hanging_pieces)", "def feature(board: chess.Board) -> float:\n    \"Calculates the total distance of all pieces from their respective home ranks.\"\n    total_distance = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == chess.WHITE:\n            total_distance += chess.square_rank(square)  # Distance from rank 0\n        else:\n            total_distance += 7 - chess.square_rank(square)  # Distance from rank 7\n    return float(total_distance)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces in the opponent's territory.\"\n    opponent_territory_count = 0\n    for square, piece in board.piece_map().items():\n        if piece.color != board.turn and chess.square_rank(square) > 3:\n            opponent_territory_count += 1\n    return float(opponent_territory_count)", "def feature(board: chess.Board) -> float:\n    \"Measures the imbalance in pawn structure by counting doubled and isolated pawns.\"\n    doubled_pawns = 0\n    isolated_pawns = 0\n    for file in range(8):\n        pawns_in_file = [square for square in range(8) if board.piece_at(chess.square(file, square)) == chess.PAWN]\n        if len(pawns_in_file) > 1:\n            doubled_pawns += 1\n        if len(pawns_in_file) == 1 and (file == 0 or file == 7 or not board.piece_at(chess.square(file - 1, pawns_in_file[0])) or not board.piece_at(chess.square(file + 1, pawns_in_file[0]))):\n            isolated_pawns += 1\n    return float(doubled_pawns + isolated_pawns)", "def feature(board: chess.Board) -> float:\n    \"Computes the mobility advantage using the difference in legal moves between players.\"\n    white_moves = len(list(board.legal_moves)) if board.turn else 0\n    black_moves = len(list(board.legal_moves)) if not board.turn else 0\n    return float(white_moves - black_moves)", "def feature(board: chess.Board) -> float:\n    \"Checks for potential back rank threats based on piece positions.\"\n    back_rank_threats = 0\n    for file in range(8):\n        if board.piece_at(chess.square(file, 0)) and board.piece_at(chess.square(file, 1)) is None and board.piece_at(chess.square(file, 2)) is None:\n            if board.is_attacked_by(chess.BLACK, chess.square(file, 0)):\n                back_rank_threats += 1\n    return float(back_rank_threats)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of piece pairs (two pieces of the same type) on the board.\"\n    piece_pairs = 0\n    piece_count = {}\n    for square, piece in board.piece_map().items():\n        piece_type = piece.piece_type\n        if piece_type not in piece_count:\n            piece_count[piece_type] = 0\n        piece_count[piece_type] += 1\n    for count in piece_count.values():\n        piece_pairs += count // 2\n    return float(piece_pairs)", "def feature(board: chess.Board) -> float:\n    \"Calculates the distance of each player's king from the center of the board.\"\n    white_king_square = chess.square(chess.square_file(board.king(chess.WHITE)), chess.square_rank(board.king(chess.WHITE)))\n    black_king_square = chess.square(chess.square_file(board.king(chess.BLACK)), chess.square_rank(board.king(chess.BLACK)))\n    white_distance = chess.square_distance(white_king_square, chess.parse_square('e4'))\n    black_distance = chess.square_distance(black_king_square, chess.parse_square('e5'))\n    return float(black_distance - white_distance)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of potential discovered checks a player can create.\"\n    discovered_checks = 0\n    for square in board.piece_map():\n        piece = board.piece_at(square)\n        if piece.color == board.turn:\n            for move in board.legal_moves:\n                if move.from_square == square and board.is_check():\n                    discovered_checks += 1\n    return float(discovered_checks)", "def feature(board: chess.Board) -> float:\n    \"Evaluates the closeness of both kings to being fully safe (protected by pieces).\"\n    white_king_square = chess.parse_square(chess.square_name(board.king(chess.WHITE)))\n    black_king_square = chess.parse_square(chess.square_name(board.king(chess.BLACK)))\n    white_defense = len(board.attackers(chess.WHITE, white_king_square))\n    black_defense = len(board.attackers(chess.BLACK, black_king_square))\n    return float(white_defense - black_defense)", "def feature(board: chess.Board) -> float:\n    \"Measures the mobility advantage by comparing the number of legal moves for both players.\"\n    white_moves = len(list(board.legal_moves)) if board.turn else 0\n    black_moves = len(list(board.legal_moves)) if not board.turn else 0\n    return float(white_moves - black_moves)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pawns advanced beyond the fourth rank for each player.\"\n    white_pawns = sum(1 for sq in board.piece_map() if board.piece_at(sq).piece_type == chess.PAWN and chess.square_rank(sq) > 3 and board.piece_at(sq).color == chess.WHITE)\n    black_pawns = sum(1 for sq in board.piece_map() if board.piece_at(sq).piece_type == chess.PAWN and chess.square_rank(sq) < 4 and board.piece_at(sq).color == chess.BLACK)\n    return float(white_pawns - black_pawns)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of uncovered checks available for the active player.\"\n    checks = sum(1 for move in board.legal_moves if board.is_check())\n    return float(checks)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces placed on open files for both players.\"\n    file_counts = [0] * 8\n    for sq in board.piece_map():\n        if len(board.attackers(board.piece_at(sq).color, sq)) == 0:\n            file_counts[chess.square_file(sq)] += 1\n    return float(max(file_counts))", "def feature(board: chess.Board) -> float:\n    \"Evaluates the piece coordination by counting pairs of pieces defending and attacking the same square.\"\n    coordination_count = 0\n    for sq in board.piece_map():\n        piece = board.piece_at(sq)\n        if piece:\n            attackers = board.attackers(piece.color, sq)\n            defenders = board.attackers(not piece.color, sq)\n            coordination_count += len(attackers) * len(defenders)\n    return float(coordination_count)", "def feature(board: chess.Board) -> float:\n    \"Scores the overall material presence of bishops in the game by counting their positions.\"\n    white_bishops = sum(1 for piece in board.piece_map().values() if piece.piece_type == chess.BISHOP and piece.color == chess.WHITE)\n    black_bishops = sum(1 for piece in board.piece_map().values() if piece.piece_type == chess.BISHOP and piece.color == chess.BLACK)\n    return float(white_bishops - black_bishops)", "def feature(board: chess.Board) -> float:\n    \"Assesses pawn structure by counting doubled pawns for each player.\"\n    doubled_pawns = 0\n    pawn_files = [0] * 8\n    for sq in board.piece_map():\n        if board.piece_at(sq).piece_type == chess.PAWN:\n            pawn_files[chess.square_file(sq)] += 1\n\n    for count in pawn_files:\n        if count > 1:\n            doubled_pawns += count - 1\n\n    return float(doubled_pawns)", "def feature(board: chess.Board) -> float:\n    \"Calculates the safety score based on the distance of pieces from the king.\"\n    king_square = [sq for sq, p in board.piece_map().items() if p.piece_type == chess.KING and p.color == (chess.WHITE if board.turn else chess.BLACK)]\n    if not king_square:\n        return 0.0\n\n    safety_score = 0\n    for sq in board.piece_map():\n        piece = board.piece_at(sq)\n        if piece and piece.color == (chess.WHITE if board.turn else chess.BLACK):\n            distance = chess.square_distance(sq, king_square[0])\n            safety_score += max(0, 5 - distance)  # Closer pieces add more safety\n\n    return float(safety_score)", "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in total material value between both players.\"\n    material_value = {chess.PAWN: 100, chess.KNIGHT: 320, chess.BISHOP: 330,\n                      chess.ROOK: 500, chess.QUEEN: 900, chess.KING: 0}\n    white_material = sum(material_value[piece.piece_type] for piece in board.piece_map().values() if piece.color == chess.WHITE)\n    black_material = sum(material_value[piece.piece_type] for piece in board.piece_map().values() if piece.color == chess.BLACK)\n    return float(white_material - black_material)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of squares directly attacked by each side.\"\n    white_attacks = sum(1 for square in board.piece_map() if board.piece_map()[square].color == chess.WHITE and board.is_attacked_by(chess.BLACK, square))\n    black_attacks = sum(1 for square in board.piece_map() if board.piece_map()[square].color == chess.BLACK and board.is_attacked_by(chess.WHITE, square))\n    return float(white_attacks - black_attacks)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of dangerous pieces that can be captured in the next move.\"\n    return float(sum(1 for move in board.legal_moves if board.piece_at(move.to_square) is not None and board.is_attacked_by(board.turn, move.to_square)))", "def feature(board: chess.Board) -> float:\n    \"Evaluates the control of the center by counting pieces on central squares.\"\n    center_squares = [chess.E4, chess.E5, chess.D4, chess.D5]\n    control_score = sum(1 for square in center_squares if board.piece_at(square) and board.piece_at(square).color == board.turn)\n    return float(control_score)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of pieces preventing the opponent's progress to promotion.\"\n    promotion_squares = [chess.A7, chess.B7, chess.C7, chess.D7, chess.E7, chess.F7, chess.G7, chess.H7] if board.turn == chess.WHITE else [chess.A2, chess.B2, chess.C2, chess.D2, chess.E2, chess.F2, chess.G2, chess.H2]\n    preventing_pieces = sum(1 for square in promotion_squares if board.is_attacked_by(board.turn, square))\n    return float(preventing_pieces)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of minor pieces (knights and bishops) on the board.\"\n    minor_piece_count = sum(1 for piece in board.piece_map().values() if piece.piece_type in (chess.KNIGHT, chess.BISHOP))\n    return float(minor_piece_count)", "def feature(board: chess.Board) -> float:\n    \"Measures the safety of the king based on the number of attackers within a range of squares.\"\n    king_square = chess.square_name(board.king(board.turn))\n    attacking_squares = sum(1 for square in chess.SQUARES if board.is_attacked_by(not board.turn, square))\n    return float(attacking_squares)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of pawns on the 7th rank for each side.\"\n    pawns_on_seventh = sum(1 for square, piece in board.piece_map().items() if piece.piece_type == chess.PAWN and (chess.square_rank(square) == 6 if piece.color == chess.WHITE else chess.square_rank(square) == 1))\n    return float(pawns_on_seventh)", "def feature(board: chess.Board) -> float:\n    \"Measures the material advantage based on the types of pieces remaining on the board.\"\n    piece_values = {chess.PAWN: 100, chess.KNIGHT: 320, chess.BISHOP: 330,\n                    chess.ROOK: 500, chess.QUEEN: 900, chess.KING: 0}\n    white_material = sum(piece_values[piece.piece_type] for piece in board.piece_map().values() if piece.color == chess.WHITE)\n    black_material = sum(piece_values[piece.piece_type] for piece in board.piece_map().values() if piece.color == chess.BLACK)\n    return float(white_material - black_material)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of squares controlled by each player's pieces.\"\n    controlled_squares = {chess.WHITE: set(), chess.BLACK: set()}\n    for square in board.piece_map():\n        piece = board.piece_map()[square]\n        if piece.color == chess.WHITE:\n            controlled_squares[chess.WHITE].update(board.attacks(square))\n        else:\n            controlled_squares[chess.BLACK].update(board.attacks(square))\n    return float(len(controlled_squares[chess.WHITE]) - len(controlled_squares[chess.BLACK]))", "def feature(board: chess.Board) -> float:\n    \"Measures the threat level by counting the number of pieces that are attacking the opponent's king.\"\n    threats_to_king = len(board.attackers(chess.BLACK, chess.parse_square('e8'))) if board.turn else len(board.attackers(chess.WHITE, chess.parse_square('e1')))\n    return float(threats_to_king)", "def feature(board: chess.Board) -> float:\n    \"Calculates the total number of pieces on the board.\"\n    total_pieces = len(board.piece_map())\n    return float(total_pieces)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of legal moves available to the side to move.\"\n    return float(len(list(board.legal_moves)))", "def feature(board: chess.Board) -> float:\n    \"Calculates the distance of the kings from their respective back ranks.\"\n    white_king_square = next(square for square, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color == chess.WHITE)\n    black_king_square = next(square for square, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color == chess.BLACK)\n    white_king_distance = 7 - chess.square_rank(white_king_square)\n    black_king_distance = chess.square_rank(black_king_square)\n    return float(white_king_distance - black_king_distance)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of pieces that are pinned to the king.\"\n    pinned_count = 0\n    color_to_check = chess.WHITE if board.turn else chess.BLACK\n    for square in board.piece_map():\n        piece = board.piece_map()[square]\n        if piece.color == color_to_check:\n            for attacker in board.attackers(not color_to_check, square):\n                if board.is_attacked_by(color_to_check, attacker):\n                    pinned_count += 1\n                    break\n    return float(pinned_count)", "def feature(board: chess.Board) -> float:\n    \"Scores king safety based on the number of pieces protecting the kings.\"\n    white_king_square = next(square for square, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color == chess.WHITE)\n    black_king_square = next(square for square, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color == chess.BLACK)\n    white_protections = len(board.attackers(chess.WHITE, white_king_square))\n    black_protections = len(board.attackers(chess.BLACK, black_king_square))\n    return float(white_protections - black_protections)", "def feature(board: chess.Board) -> float:\n    \"Measures the overall mobility of pawns by counting how many have moved forward.\"\n    forward_moving_pawns = 0\n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.PAWN:\n            if (piece.color == chess.WHITE and chess.square_rank(square) > 1) or (piece.color == chess.BLACK and chess.square_rank(square) < 6):\n                forward_moving_pawns += 1\n    return float(forward_moving_pawns)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of pawns on the 7th rank for both players.\"\n    return float(sum(1 for sq in board.piece_map() if board.piece_at(sq).piece_type == chess.PAWN and (chess.square_rank(sq) == 6 if board.piece_at(sq).color == chess.WHITE else chess.square_rank(sq) == 1)))", "def feature(board: chess.Board) -> float:\n    \"Counts the total number of pieces that are pinned to their own king.\"\n    pinned_count = 0\n    for square in board.piece_map():\n        piece = board.piece_at(square)\n        if piece.color == board.turn:\n            attackers = board.attackers(not piece.color, square)\n            if any(board.is_attacked_by(piece.color, king_sq) for king_sq in board.piece_map() if board.piece_at(king_sq).piece_type == chess.KING and board.piece_at(king_sq).color == piece.color):\n                pinned_count += 1\n    return float(pinned_count)", "def feature(board: chess.Board) -> float:\n    \"Measures the collective distance of all pawns from their respective promotion ranks.\"\n    white_pawn_distance = sum(7 - chess.square_rank(sq) for sq in board.piece_map() if board.piece_at(sq).piece_type == chess.PAWN and board.piece_at(sq).color == chess.WHITE)\n    black_pawn_distance = sum(chess.square_rank(sq) for sq in board.piece_map() if board.piece_at(sq).piece_type == chess.PAWN and board.piece_at(sq).color == chess.BLACK)\n    return float(white_pawn_distance + black_pawn_distance)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of squares occupied by opponent pieces.\"\n    opponent_piece_count = sum(1 for sq in board.piece_map() if board.piece_at(sq).color != board.turn)\n    return float(opponent_piece_count)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of legal checks available for the current player.\"\n    check_count = sum(1 for move in board.legal_moves if board.gives_check(move))\n    return float(check_count)", "def feature(board: chess.Board) -> float:\n    \"Counts the total pieces that are attacking the enemy king.\"\n    attacking_pieces_count = sum(1 for square in board.piece_map() if board.piece_at(square).color == board.turn and board.is_attacked_by(not board.turn, square))\n    return float(attacking_pieces_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the ratio of pieces controlled by each player.\"\n    white_control = len([sq for sq in board.piece_map() if board.is_attacked_by(chess.WHITE, sq)])\n    black_control = len([sq for sq in board.piece_map() if board.is_attacked_by(chess.BLACK, sq)])\n    return float(white_control / (black_control + 1))  # adding 1 to avoid division by zero", "def feature(board: chess.Board) -> float:\n    \"Measures the closeness of the kings to each other, in terms of distance.\"\n    white_king_sq = next((sq for sq in board.piece_map() if board.piece_at(sq).piece_type == chess.KING and board.piece_at(sq).color == chess.WHITE), None)\n    black_king_sq = next((sq for sq in board.piece_map() if board.piece_at(sq).piece_type == chess.KING and board.piece_at(sq).color == chess.BLACK), None)\n    if white_king_sq is not None and black_king_sq is not None:\n        return float(chess.square_distance(white_king_sq, black_king_sq))\n    return float(0)  # Return 0 if no king is found", "def feature(board: chess.Board) -> float:\n    \"Measures the total number of pieces for both players\"\n    piece_count = sum(1 for piece in board.piece_map().values())\n    return float(piece_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of squares attacked by each side\"\n    white_attacks = sum(board.is_attacked_by(chess.WHITE, square) for square in chess.SQUARES)\n    black_attacks = sum(board.is_attacked_by(chess.BLACK, square) for square in chess.SQUARES)\n    return float(white_attacks - black_attacks)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of pieces that are pinned (cannot move without exposing the king)\"\n    pinned_count = sum(1 for square in board.piece_map() if board.attackers(board.piece_at(square).color, square))\n    return float(pinned_count)", "def feature(board: chess.Board) -> float:\n    \"Measures the material value of pieces still on the board\"\n    material_values = {\n        chess.PAWN: 100,\n        chess.KNIGHT: 320,\n        chess.BISHOP: 330,\n        chess.ROOK: 500,\n        chess.QUEEN: 900,\n        chess.KING: 0  # King's value is not typically counted\n    }\n    material_value = sum(material_values[piece.piece_type] for piece in board.piece_map().values())\n    return float(material_value)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of squares each king can move to\"\n    white_king = next((square for square in board.piece_map() if board.piece_map()[square].piece_type == chess.KING and board.piece_map()[square].color == chess.WHITE), None)\n    black_king = next((square for square in board.piece_map() if board.piece_map()[square].piece_type == chess.KING and board.piece_map()[square].color == chess.BLACK), None)\n\n    white_moves = len(list(board.legal_moves)) if white_king else 0\n    black_moves = len(list(board.legal_moves)) if black_king else 0\n\n    return float(white_moves - black_moves)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of pieces on the board that can attack the opponent's king\"\n    attacking_pieces_count = sum(1 for square in board.piece_map() if board.is_attacked_by(chess.WHITE, square) and board.piece_map()[square].color == chess.BLACK) + \\\n                             sum(1 for square in board.piece_map() if board.is_attacked_by(chess.BLACK, square) and board.piece_map()[square].color == chess.WHITE)\n    return float(attacking_pieces_count)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of doubled pawns on the board\"\n    pawns = [square for square, piece in board.piece_map().items() if piece.piece_type == chess.PAWN]\n    files = {}\n    for pawn in pawns:\n        file = chess.square_file(pawn)\n        if file in files:\n            files[file].append(pawn)\n        else:\n            files[file] = [pawn]\n    doubled_pawns = sum(1 for file in files.values() if len(file) > 1)\n    return float(doubled_pawns)", "def feature(board: chess.Board) -> float:\n    \"Measures the distance of each player's king from the center squares\"\n    white_king_square = next((sq for sq, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color == chess.WHITE), None)\n    black_king_square = next((sq for sq, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color == chess.BLACK), None)\n\n    center_squares = [chess.E4, chess.E5, chess.D4, chess.D5]\n    white_distance = min(chess.square_distance(white_king_square, cs) for cs in center_squares) if white_king_square else 0\n    black_distance = min(chess.square_distance(black_king_square, cs) for cs in center_squares) if black_king_square else 0\n\n    return float(white_distance - black_distance)", "def feature(board: chess.Board) -> float:\n    \"Calculates the total number of pieces that are near the back ranks\"\n    back_rank_threshold = [0, 1] if board.turn else [6, 7]\n    near_back_rank_count = sum(1 for square, piece in board.piece_map().items() if chess.square_rank(square) in back_rank_threshold)\n    return float(near_back_rank_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the total number of pieces on the board.\"\n    return float(len(board.piece_map()))", "def feature(board: chess.Board) -> float:\n    \"Measures the mobility of both kings based on the number of legal moves available.\"\n    white_king_moves = len(list(board.legal_moves)) if board.turn else 0\n    black_king_moves = len(list(board.legal_moves)) if not board.turn else 0\n    return float(white_king_moves + black_king_moves)", "def feature(board: chess.Board) -> float:\n    \"Calculates the total number of pawns remaining on the board.\"\n    return float(sum(1 for piece in board.piece_map().values() if piece.piece_type == chess.PAWN))", "def feature(board: chess.Board) -> float:\n    \"Measures the number of squares occupied within the central four squares (d4, d5, e4, e5).\"\n    central_squares = [chess.parse_square('d4'), chess.parse_square('d5'), chess.parse_square('e4'), chess.parse_square('e5')]\n    occupied_centers = sum(1 for sq in central_squares if board.piece_at(sq) is not None)\n    return float(occupied_centers)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces that are pinned to the king.\"\n    pinned_count = 0\n    for opponent_piece in board.piece_map().values():\n        if opponent_piece.color != board.turn:\n            for square in board.attackers(board.turn, board.king(board.turn)):\n                if board.is_attacked_by(opponent_piece.color, square):\n                    pinned_count += 1\n                    break\n    return float(pinned_count)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of non-pawn pieces on the board.\"\n    non_pawn_count = sum(1 for piece in board.piece_map().values() if piece.piece_type != chess.PAWN)\n    return float(non_pawn_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the total value of pieces for each side.\"\n    piece_value = {chess.PAWN: 100, chess.KNIGHT: 300, chess.BISHOP: 300, chess.ROOK: 500, chess.QUEEN: 900, chess.KING: 0}\n    material_balance = sum(piece_value[piece.piece_type] * (1 if piece.color == chess.WHITE else -1)\n                            for piece in board.piece_map().values())\n    return float(material_balance)", "def feature(board: chess.Board) -> float:\n    \"Evaluates the king's safety based on the number of opposing pieces attacking the king.\"\n    king_square = board.king(chess.WHITE) if board.turn else board.king(chess.BLACK)\n    attackers_count = len(board.attackers(chess.BLACK if board.turn else chess.WHITE, king_square))\n    return float(attackers_count)", "def feature(board: chess.Board) -> float:\n    \"Assesses the piece efficiency by calculating the ratio of pieces to their attacking positions.\"\n    piece_count = sum(1 for piece in board.piece_map().values())\n    attacking_positions = sum(len(board.attackers(piece.color, square))\n                              for square, piece in board.piece_map().items())\n    return float(attacking_positions / piece_count) if piece_count > 0 else 0.0", "def feature(board: chess.Board) -> float:\n    \"Measures the distance of kings from the center squares (d4, e4, d5, e5).\"\n    center_squares = [chess.parse_square(sq) for sq in ['d4', 'e4', 'd5', 'e5']]\n    king_square = board.king(chess.WHITE) if board.turn else board.king(chess.BLACK)\n    distance = min(chess.square_distance(king_square, csq) for csq in center_squares)\n    return float(distance)", "def feature(board: chess.Board) -> float:\n    \"Counts the total number of open files available for the rooks.\"\n    open_files = 0\n    for file in range(8):\n        if all(board.piece_at(chess.square(file, rank)) is None for rank in range(8)):\n            open_files += 1\n    return float(open_files)", "def feature(board: chess.Board) -> float:\n    \"Calculates the total number of pieces for both sides.\"\n    total_pieces = len(board.piece_map())\n    return float(total_pieces)", "def feature(board: chess.Board) -> float:\n    \"Scores the number of advanced pawns for both players.\"\n    advanced_pawns = sum(1 for square, piece in board.piece_map().items() \n                         if piece.piece_type == chess.PAWN and \n                         ((piece.color == chess.WHITE and chess.square_rank(square) > 4) or \n                          (piece.color == chess.BLACK and chess.square_rank(square) < 3)))\n    return float(advanced_pawns)", "def feature(board: chess.Board) -> float:\n    \"Measures the total control of the center (d4, d5, e4, e5) squares.\"\n    center_squares = [chess.D4, chess.D5, chess.E4, chess.E5]\n    control = sum(1 for square in center_squares for piece in board.attackers(chess.WHITE, square)) - \\\n              sum(1 for square in center_squares for piece in board.attackers(chess.BLACK, square))\n    return float(control)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of fragmented pawns for each player.\"\n    fragmented_pawns = {chess.WHITE: 0, chess.BLACK: 0}\n    for file in range(8):\n        if board.piece_at(chess.parse_square(chess.square_name(chess.A1 + file))) == chess.PAWN:\n            fragmented_pawns[chess.WHITE] += 1\n        if board.piece_at(chess.parse_square(chess.square_name(chess.H1 - file))) == chess.PAWN:\n            fragmented_pawns[chess.BLACK] += 1\n    fragmentation_score = fragmented_pawns[chess.WHITE] - fragmented_pawns[chess.BLACK]\n    return float(fragmentation_score)", "def feature(board: chess.Board) -> float:\n    \"Scores the mobility of the queens by counting their legal moves.\"\n    queen_moves = 0\n    for piece in board.piece_map().values():\n        if piece.piece_type == chess.QUEEN:\n            queen_moves += len(list(board.legal_moves))\n    return float(queen_moves)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of squares controlled by pieces attacking the opponent's king.\"\n    opponent_king_square = next((sq for sq in board.piece_map() \n                                  if board.piece_at(sq).piece_type == chess.KING and \n                                  board.piece_at(sq).color != board.turn), None)\n    if opponent_king_square is None:\n        return 0.0\n    attacking_squares = set()\n    for piece in board.piece_map().values():\n        if piece.color == board.turn:\n            attacking_squares.update(board.attackers(board.turn, opponent_king_square))\n    return float(len(attacking_squares))", "def feature(board: chess.Board) -> float:\n    \"Scores the number of pawn promotions possible on the next move.\"\n    promotions = sum(1 for square in board.piece_map() if \n                     board.piece_at(square).piece_type == chess.PAWN and \n                     (square == chess.A7 or square == chess.B7 or square == chess.C7 or \n                      square == chess.D7 or square == chess.E7 or square == chess.F7 or \n                      square == chess.G7 or square == chess.H7))\n    return float(promotions)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of pieces on the seventh rank for both sides, indicating potential promotion threats.\"\n    seventh_rank_white = sum(1 for sq in range(56, 64) if board.piece_at(sq) and board.piece_at(sq).color == chess.WHITE)\n    seventh_rank_black = sum(1 for sq in range(0, 8) if board.piece_at(sq) and board.piece_at(sq).color == chess.BLACK)\n    return float(seventh_rank_white - seventh_rank_black)", "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in the number of open files for both players.\"\n    open_files_white = sum(1 for file in range(8) if not any(board.piece_at(sq) for sq in chess.SQUARES[file:64:8]))\n    open_files_black = sum(1 for file in range(8) if not any(board.piece_at(sq) for sq in chess.SQUARES[file:8]))\n    return float(open_files_white - open_files_black)", "def feature(board: chess.Board) -> float:\n    \"Scores the pawn structure by measuring doubled pawns for both players.\"\n    doubled_pawns_white = sum(1 for file in range(8) if sum(1 for rank in range(8) if board.piece_at(chess.square(file, rank)) and board.piece_at(chess.square(file, rank)).piece_type == chess.PAWN) > 1)\n    doubled_pawns_black = sum(1 for file in range(8) if sum(1 for rank in range(8) if board.piece_at(chess.square(file, rank)) and board.piece_at(chess.square(file, rank)).piece_type == chess.PAWN) > 1)\n    return float(doubled_pawns_white - doubled_pawns_black)", "def feature(board: chess.Board) -> float:\n    \"Measures the presence of pieces on the opponent's third rank, indicating potential threats.\"\n    opponent_third_rank = chess.SQUARES[16:24] if board.turn else chess.SQUARES[48:56]\n    white_threats = sum(1 for sq in opponent_third_rank if board.piece_at(sq) and board.piece_at(sq).color == chess.WHITE)\n    black_threats = sum(1 for sq in opponent_third_rank if board.piece_at(sq) and board.piece_at(sq).color == chess.BLACK)\n    return float(white_threats - black_threats)", "def feature(board: chess.Board) -> float:\n    \"Calculates the distance of pieces from the center of the board (d4, d5, e4, e5) to normalize piece placement.\"\n    center_squares = [chess.square(3, 3), chess.square(3, 4), chess.square(4, 3), chess.square(4, 4)]\n    white_distance = sum(chess.square_distance(sq, chess.square(4, 4)) for sq in board.piece_map() if board.piece_map()[sq].color == chess.WHITE)\n    black_distance = sum(chess.square_distance(sq, chess.square(3, 3)) for sq in board.piece_map() if board.piece_map()[sq].color == chess.BLACK)\n    return float(white_distance - black_distance)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of pieces attacking the opponent's king, representing direct threats.\"\n    opponent_king_square = chess.square(4, 0) if not board.turn else chess.square(4, 7)\n    attacking_pieces_white = sum(1 for sq in board.piece_map() if board.piece_map()[sq].color == chess.WHITE and sq in board.attackers(chess.WHITE, opponent_king_square))\n    attacking_pieces_black = sum(1 for sq in board.piece_map() if board.piece_map()[sq].color == chess.BLACK and sq in board.attackers(chess.BLACK, opponent_king_square))\n    return float(attacking_pieces_white - attacking_pieces_black)", "def feature(board: chess.Board) -> float:\n    \"Calculates the pawn structure by scoring isolated pawns for both players.\"\n    isolated_pawns_white = sum(1 for file in range(8) if board.piece_at(chess.square(file, 1)) == chess.PAWN and (file == 0 or file == 7 or (board.piece_at(chess.square(file - 1, 1)) is None and board.piece_at(chess.square(file + 1, 1)) is None)))\n    isolated_pawns_black = sum(1 for file in range(8) if board.piece_at(chess.square(file, 6)) == chess.PAWN and (file == 0 or file == 7 or (board.piece_at(chess.square(file - 1, 6)) is None and board.piece_at(chess.square(file + 1, 6)) is None)))\n    return float(isolated_pawns_white - isolated_pawns_black)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of pieces pinned on both sides, as pinned pieces cannot move effectively.\"\n    pinned_pieces_white = sum(1 for sq in board.piece_map() if board.piece_map()[sq].color == chess.WHITE and board.is_attacked_by(chess.BLACK, sq))\n    pinned_pieces_black = sum(1 for sq in board.piece_map() if board.piece_map()[sq].color == chess.BLACK and board.is_attacked_by(chess.WHITE, sq))\n    return float(pinned_pieces_white - pinned_pieces_black)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces attacking the opponent's king.\"\n    opponent_king_square = None\n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.KING and piece.color != board.turn:\n            opponent_king_square = square\n            break\n    if opponent_king_square is None:\n        return 0.0\n    attackers = len(board.attackers(board.turn, opponent_king_square))\n    return float(attackers)", "def feature(board: chess.Board) -> float:\n    \"Calculates the total material value for each side and returns the difference.\"\n    material_values = {chess.PAWN: 100, chess.KNIGHT: 300, chess.BISHOP: 300, chess.ROOK: 500, chess.QUEEN: 900, chess.KING: 0}\n    white_value = sum(material_values[piece.piece_type] for piece in board.piece_map().values() if piece.color == chess.WHITE)\n    black_value = sum(material_values[piece.piece_type] for piece in board.piece_map().values() if piece.color == chess.BLACK)\n    return float(white_value - black_value)", "def feature(board: chess.Board) -> float:\n    \"Measures king safety by counting the number of squares around the king that are attacked.\"\n    king_square = next((square for square, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color == board.turn), None)\n    if king_square is None:\n        return 0.0\n    attacked_squares = sum(board.is_attacked_by(not board.turn, square) for square in chess.SQUARES)\n    return float(attacked_squares)", "def feature(board: chess.Board) -> float:\n    \"Calculates the distance of the nearest enemy piece from the player's king.\"\n    king_square = next((square for square, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color == board.turn), None)\n    if king_square is None:\n        return float('inf')\n    distances = [chess.square_distance(king_square, enemy_square) for enemy_square, piece in board.piece_map().items() if piece.color != board.turn]\n    return float(min(distances)) if distances else float('inf')", "def feature(board: chess.Board) -> float:\n    \"Counts the number of isolated pawns for both colors and returns the difference.\"\n    def count_isolated_pawns(color):\n        isolated_count = 0\n        for square, piece in board.piece_map().items():\n            if piece.color == color and piece.piece_type == chess.PAWN:\n                file = chess.square_file(square)\n                if (board.piece_at(chess.parse_square(chess.square_name(square).replace(str(chess.square_rank(square)), str(chess.square_rank(square) - 1)))) is None and\n                    board.piece_at(chess.parse_square(chess.square_name(square).replace(str(chess.square_rank(square)), str(chess.square_rank(square) + 1)))) is None):\n                    isolated_count += 1\n        return isolated_count\n\n    white_isolated = count_isolated_pawns(chess.WHITE)\n    black_isolated = count_isolated_pawns(chess.BLACK)\n    return float(white_isolated - black_isolated)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of pieces occupying center squares for the current player.\"\n    center_squares = {chess.D4, chess.D5, chess.E4, chess.E5}\n    piece_count = sum(1 for square in board.piece_map() if square in center_squares and board.piece_map()[square].color == board.turn)\n    return float(piece_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of pieces pinned to the king for the current player.\"\n    pin_count = 0\n    king_square = next((square for square, piece in board.piece_map().items() if piece.color == board.turn and piece.piece_type == chess.KING), None)\n    if king_square is None:\n        return 0.0\n    for square, piece in board.piece_map().items():\n        if piece.color == board.turn and piece.piece_type != chess.KING:\n            for square_attacked in board.attackers(not board.turn, square):\n                if board.is_attacked_by(board.turn, square_attacked):\n                    pin_count += 1\n                    break\n    return float(pin_count)", "def feature(board: chess.Board) -> float:\n    \"Measures material advantage based on pawn structure of each side.\"\n    white_pawns = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE and piece.piece_type == chess.PAWN)\n    black_pawns = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK and piece.piece_type == chess.PAWN)\n    return float(white_pawns - black_pawns)", "def feature(board: chess.Board) -> float:\n    \"Measures the total mobility of both players by counting the number of legal moves.\"\n    white_moves = sum(1 for _ in board.legal_moves if board.turn is chess.WHITE)\n    black_moves = sum(1 for _ in board.legal_moves if board.turn is chess.BLACK)\n    return float(white_moves - black_moves)", "def feature(board: chess.Board) -> float:\n    \"Counts the total number of pawns present on the board.\"\n    pawns_count = sum(1 for piece in board.piece_map().values() if piece.piece_type == chess.PAWN)\n    return float(pawns_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the average distance of pieces from the center of the board, which may indicate piece activity.\"\n    center_square = chess.square(4, 4)  # e4 is often considered a center square\n    total_distance = sum(chess.square_distance(square, center_square) for square in board.piece_map())\n    num_pieces = len(board.piece_map())\n    return float(total_distance / num_pieces) if num_pieces > 0 else 0.0", "def feature(board: chess.Board) -> float:\n    \"Evaluates the control of open files by counting rooks on the same files without pawns.\"\n    open_file_count = 0\n    for file in range(8):\n        is_open = all(board.piece_at(chess.square(file, rank)) is None for rank in range(8))\n        if is_open and any(board.piece_at(chess.square(file, rank)) == chess.ROOK for rank in range(8)):\n            open_file_count += 1\n    return float(open_file_count)", "def feature(board: chess.Board) -> float:\n    \"Measures the king's proximity to the center to evaluate safety.\"\n    king_square = chess.square(0, 0)  # Placeholder\n    if board.turn is chess.WHITE:\n        king_square = next(square for square in board.piece_map() if board.piece_map()[square].piece_type == chess.KING and board.piece_map()[square].color == chess.WHITE)\n    else:\n        king_square = next(square for square in board.piece_map() if board.piece_map()[square].piece_type == chess.KING and board.piece_map()[square].color == chess.BLACK)\n    return 1.0 - (chess.square_distance(king_square, chess.square(4, 4)) / 7.0)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of squares attacked by the current player's pieces.\"\n    attacked_squares = set()\n    for square, piece in board.piece_map().items():\n        if piece.color == board.turn:\n            attacked_squares.update(board.attackers(piece.color, square))\n    return float(len(attacked_squares))", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of doubled pawns present for both players.\"\n    pawn_files = {}\n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.PAWN:\n            file_index = chess.square_file(square)\n            if piece.color not in pawn_files:\n                pawn_files[piece.color] = []\n            pawn_files[piece.color].append(file_index)\n    \n    doubled_pawns = sum(1 for files in pawn_files.values() for file in set(files) if files.count(file) > 1)\n    return float(doubled_pawns)", "def feature(board: chess.Board) -> float:\n    \"Measures the ratio of minor pieces (knights and bishops) to major pieces (rooks and queens).\"\n    minor_pieces = sum(1 for piece in board.piece_map().values() if piece.piece_type in (chess.KNIGHT, chess.BISHOP))\n    major_pieces = sum(1 for piece in board.piece_map().values() if piece.piece_type in (chess.ROOK, chess.QUEEN))\n    return float(minor_pieces / (major_pieces + 1))  # +1 to avoid division by zero", "def feature(board: chess.Board) -> float:\n    \"Measures the number of squares occupied by pawns for both players.\"\n    occupied_pawn_squares = sum(1 for piece in board.piece_map().values() if piece.piece_type == chess.PAWN)\n    return float(occupied_pawn_squares)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of pieces in the opponent's attack zone.\"\n    attacking_pieces = sum(1 for square in board.piece_map() if board.is_attacked_by(not board.turn, square))\n    return float(attacking_pieces)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of doubled pawns for each player.\"\n    pawns = [square for square, piece in board.piece_map().items() if piece.piece_type == chess.PAWN]\n    white_doubled = sum(1 for file in range(8) if len([p for p in pawns if chess.square_file(p) == file and board.piece_at(p).color == chess.WHITE]) > 1)\n    black_doubled = sum(1 for file in range(8) if len([p for p in pawns if chess.square_file(p) == file and board.piece_at(p).color == chess.BLACK]) > 1)\n    return float(white_doubled + black_doubled)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of squares controlled by both players.\"\n    controlled_squares_white = {move.to_square for move in board.legal_moves if board.turn}\n    controlled_squares_black = {move.to_square for move in board.legal_moves if not board.turn}\n    return float(len(controlled_squares_white) + len(controlled_squares_black))", "def feature(board: chess.Board) -> float:\n    \"Calculates the distance of the kings from the center of the board.\"\n    white_king_square = next(square for square, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color == chess.WHITE)\n    black_king_square = next(square for square, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color == chess.BLACK)\n    white_distance = chess.square_distance(white_king_square, chess.parse_square('e4'))\n    black_distance = chess.square_distance(black_king_square, chess.parse_square('e4'))\n    return float(white_distance - black_distance)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of open files for rooks.\"\n    open_files = sum(1 for file in range(8) if not any(board.piece_at(chess.square(file, rank)) for rank in range(8)))\n    return float(open_files)", "def feature(board: chess.Board) -> float:\n    \"Calculates the total material value of pieces currently on the board.\"\n    piece_value_map = {\n        chess.PAWN: 100,\n        chess.KNIGHT: 300,\n        chess.BISHOP: 300,\n        chess.ROOK: 500,\n        chess.QUEEN: 900,\n        chess.KING: 0\n    }\n    total_material_value = sum(piece_value_map[piece.piece_type] for piece in board.piece_map().values())\n    return float(total_material_value)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of different piece types for each player.\"\n    unique_white_pieces = {piece.piece_type for piece in board.piece_map().values() if piece.color == chess.WHITE}\n    unique_black_pieces = {piece.piece_type for piece in board.piece_map().values() if piece.color == chess.BLACK}\n    return float(len(unique_white_pieces) + len(unique_black_pieces))", "def feature(board: chess.Board) -> float:\n    \"Calculates the ratio of minor pieces to major pieces for each player.\"\n    minor_white = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE and piece.piece_type in [chess.KNIGHT, chess.BISHOP])\n    major_white = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE and piece.piece_type in [chess.ROOK, chess.QUEEN])\n    minor_black = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK and piece.piece_type in [chess.KNIGHT, chess.BISHOP])\n    major_black = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK and piece.piece_type in [chess.ROOK, chess.QUEEN])\n    ratio_white = minor_white / (major_white + 1e-10)  # Avoid division by zero\n    ratio_black = minor_black / (major_black + 1e-10)\n    return float(ratio_white - ratio_black)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of forks currently possible on the board.\"\n    forks = 0\n    for move in board.legal_moves:\n        board.push(move)\n        for target in board.legal_moves:\n            if target != move:\n                attacked = board.attackers(not board.turn, target.to_square)\n                if len(attacked) > 1:\n                    forks += 1\n        board.pop()\n    return float(forks)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of pieces on the board for each player and returns the difference.\"\n    white_pieces = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE)\n    black_pieces = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK)\n    return float(white_pieces - black_pieces)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of squares occupied by pieces for each side.\"\n    occupied_squares = sum(1 for piece in board.piece_map().values())\n    return float(occupied_squares)", "def feature(board: chess.Board) -> float:\n    \"Scores the mobility of the current player by counting their legal moves.\"\n    legal_moves_count = len(list(board.legal_moves))\n    return float(legal_moves_count)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of squares that are currently attacked by each player.\"\n    attacked_squares_white = sum(board.is_attacked_by(chess.WHITE, square) for square in range(64))\n    attacked_squares_black = sum(board.is_attacked_by(chess.BLACK, square) for square in range(64))\n    return float(attacked_squares_white - attacked_squares_black)", "def feature(board: chess.Board) -> float:\n    \"Calculates the distance of all kings from the center of the board.\"\n    white_king_distance = chess.square_distance(board.king(chess.WHITE), chess.parse_square('e4'))  # e4 is center\n    black_king_distance = chess.square_distance(board.king(chess.BLACK), chess.parse_square('e4'))\n    return float(white_king_distance - black_king_distance)", "def feature(board: chess.Board) -> float:\n    \"Measures the total number of squares that are available for each player's pieces.\"\n    available_squares_white = sum(1 for square in range(64) if board.piece_at(square) and board.piece_at(square).color == chess.WHITE and len(list(board.legal_moves)) > 0)\n    available_squares_black = sum(1 for square in range(64) if board.piece_at(square) and board.piece_at(square).color == chess.BLACK and len(list(board.legal_moves)) > 0)\n    return float(available_squares_white - available_squares_black)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces that are not supported by other pieces.\"\n    unsupported_pieces = sum(1 for square, piece in board.piece_map().items() if len(board.attackers(piece.color, square)) == 0)\n    return float(unsupported_pieces)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of pieces attacking the opposing king.\"\n    attackers_to_white_king = len(board.attackers(chess.BLACK, board.king(chess.WHITE)))\n    attackers_to_black_king = len(board.attackers(chess.WHITE, board.king(chess.BLACK)))\n    return float(attackers_to_white_king - attackers_to_black_king)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pawns each side has remaining.\"\n    white_pawns = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE and piece.piece_type == chess.PAWN)\n    black_pawns = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK and piece.piece_type == chess.PAWN)\n    return float(white_pawns - black_pawns)", "def feature(board: chess.Board) -> float:\n    \"Measures king safety by counting the number of available cover pieces.\"\n    white_king_safety = len(board.attackers(chess.WHITE, board.king(chess.WHITE)))\n    black_king_safety = len(board.attackers(chess.BLACK, board.king(chess.BLACK)))\n    return float(black_king_safety - white_king_safety)", "def feature(board: chess.Board) -> float:\n    \"Counts the total value of pieces on the board for each player.\"\n    material_value = {chess.PAWN: 100, chess.KNIGHT: 300, chess.BISHOP: 300, chess.ROOK: 500, chess.QUEEN: 900, chess.KING: 0}\n    total_value = 0.0\n    for piece in board.piece_map().values():\n        total_value += material_value[piece.piece_type] if piece.color == chess.WHITE else -material_value[piece.piece_type]\n    return total_value", "def feature(board: chess.Board) -> float:\n    \"Measures the number of pieces attacking the opponent's king.\"\n    opponent_king_square = next((square for square, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color == (chess.WHITE if board.turn else chess.BLACK)), None)\n    attacking_pieces_count = sum(1 for move in board.legal_moves if move.to_square == opponent_king_square)\n    return float(attacking_pieces_count)", "def feature(board: chess.Board) -> float:\n    \"Scores the pawn structure by counting isolated pawns.\"\n    isolated_pawns = 0\n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.PAWN:\n            file_index = chess.square_file(square)\n            if not (board.piece_at(chess.parse_square(chess.square_name(square)[:-1] + str(r))) for r in range(8) if chess.square_file(chess.parse_square(chess.square_name(square)[:-1] + str(r))) == file_index):\n                isolated_pawns += 1\n    return float(isolated_pawns)", "def feature(board: chess.Board) -> float:\n    \"Measures the mobility of the kings by counting their legal moves.\"\n    white_king_square = next(square for square, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color == chess.WHITE)\n    black_king_square = next(square for square, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color == chess.BLACK)\n    white_king_mobility = sum(1 for move in board.legal_moves if move.from_square == white_king_square)\n    black_king_mobility = sum(1 for move in board.legal_moves if move.from_square == black_king_square)\n    return float(white_king_mobility - black_king_mobility)", "def feature(board: chess.Board) -> float:\n    \"Calculates the average distance of all pieces from their respective kings.\"\n    def average_distance(color):\n        king_square = next(square for square, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color == color)\n        total_distance = sum(chess.square_distance(square, king_square) for square, piece in board.piece_map().items() if piece.color == color)\n        piece_count = sum(1 for piece in board.piece_map().values() if piece.color == color)\n        return total_distance / piece_count if piece_count > 0 else 0.0\n    \n    white_avg_distance = average_distance(chess.WHITE)\n    black_avg_distance = average_distance(chess.BLACK)\n    return float(white_avg_distance - black_avg_distance)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of doubled pawns for each side.\"\n    doubled_pawns = {chess.WHITE: 0, chess.BLACK: 0}\n    pawn_files = {file: 0 for file in range(8)}\n    \n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.PAWN:\n            pawn_files[chess.square_file(square)] += 1\n    \n    for count in pawn_files.values():\n        if count > 1:\n            doubled_pawns[chess.WHITE if board.turn else chess.BLACK] += count - 1\n    \n    return float(doubled_pawns[chess.WHITE] - doubled_pawns[chess.BLACK])", "def feature(board: chess.Board) -> float:\n    \"Measures the control of key squares surrounding the kings.\"\n    control_squares = []\n    for square in [chess.parse_square('e7'), chess.parse_square('e8'), chess.parse_square('d7'), chess.parse_square('d8'), chess.parse_square('f7'), chess.parse_square('f8')]:\n        if board.is_attacked_by(chess.WHITE, square):\n            control_squares.append(square)\n        if board.is_attacked_by(chess.BLACK, square):\n            control_squares.append(square)\n    return float(len(set(control_squares)))", "def feature(board: chess.Board) -> float:\n    \"Evaluates potential pawn promotion threats by counting advanced pawns.\"\n    advanced_pawns = 0\n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.PAWN:\n            if (piece.color == chess.WHITE and chess.square_rank(square) >= 5) or (piece.color == chess.BLACK and chess.square_rank(square) <= 2):\n                advanced_pawns += 1\n    return float(advanced_pawns)", "def feature(board: chess.Board) -> float:\n    \"Calculates the king's safety by measuring the number of pieces defending it.\"\n    king_square = next(square for square, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color == (chess.WHITE if board.turn else chess.BLACK))\n    defending_pieces = sum(1 for piece in board.piece_map().values() if piece.color == (chess.WHITE if board.turn else chess.BLACK) and king_square in board.attackers(piece.color, king_square))\n    return float(defending_pieces)", "def feature(board: chess.Board) -> float:\n    \"Measures the difference in mobility between the two players.\"\n    white_moves = len(list(board.legal_moves)) if board.turn else 0\n    black_moves = len(list(board.legal_moves)) if not board.turn else 0\n    return float(white_moves - black_moves)", "def feature(board: chess.Board) -> float:\n    \"Counts the total number of pieces on the board.\"\n    return float(len(board.piece_map()))", "def feature(board: chess.Board) -> float:\n    \"Calculates the total value of pieces for the current player.\"\n    piece_values = {\n        chess.PAWN: 100,\n        chess.KNIGHT: 320,\n        chess.BISHOP: 330,\n        chess.ROOK: 500,\n        chess.QUEEN: 900,\n        chess.KING: 20000\n    }\n    total_value = 0\n    for piece in board.piece_map().values():\n        if piece.color == board.turn:\n            total_value += piece_values[piece.piece_type]\n    return float(total_value)", "def feature(board: chess.Board) -> float:\n    \"Scores the defensive structure by counting the number of protected pieces.\"\n    defended_count = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == board.turn:\n            if any(board.is_attacked_by(not board.turn, attacker_square) for attacker_square in board.attackers(piece.color, square)):\n                defended_count += 1\n    return float(defended_count)", "def feature(board: chess.Board) -> float:\n    \"Measures the total number of squares attacked by each side.\"\n    white_attacked = len([square for square in chess.SQUARES if board.is_attacked_by(chess.WHITE, square)])\n    black_attacked = len([square for square in chess.SQUARES if board.is_attacked_by(chess.BLACK, square)])\n    return float(white_attacked - black_attacked)", "def feature(board: chess.Board) -> float:\n    \"Evaluates the number of pawns on the 7th rank for both players.\"\n    white_sevenths = sum(1 for square, piece in board.piece_map().items() \n                         if piece.color == chess.WHITE and chess.square_rank(square) == 6)\n    black_sevenths = sum(1 for square, piece in board.piece_map().items() \n                         if piece.color == chess.BLACK and chess.square_rank(square) == 1)\n    return float(white_sevenths - black_sevenths)", "def feature(board: chess.Board) -> float:\n    \"Calculates the distance of each king to the center of the board.\"\n    king_square = next((square for square, piece in board.piece_map().items() if piece.piece_type == chess.KING), None)\n    if king_square is None:\n        return 0.0\n    center_distance = chess.square_distance(king_square, chess.parse_square('e4'))  # Approximate center\n    return float(center_distance)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces pinned by each side.\"\n    pinned_count = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == board.turn:\n            for attacker in board.attackers(not piece.color, square):\n                if board.is_attacked_by(piece.color, attacker):\n                    pinned_count += 1\n                    break\n    return float(pinned_count)", "def feature(board: chess.Board) -> float:\n    \"Checks for the presence of back rank threats for each player.\"\n    back_rank_threats = 0\n    for file in range(8):\n        if (board.piece_at(chess.square(file, 0)) is not None and board.piece_at(chess.square(file, 0)).color == chess.WHITE and \n            board.is_attacked_by(chess.BLACK, chess.square(file, 0))):\n            back_rank_threats += 1\n        if (board.piece_at(chess.square(file, 7)) is not None and board.piece_at(chess.square(file, 7)).color == chess.BLACK and \n            board.is_attacked_by(chess.WHITE, chess.square(file, 7))):\n            back_rank_threats += 1\n    return float(back_rank_threats)", "def feature(board: chess.Board) -> float:\n    'Measures the total number of attacking pieces for each color.'\n    white_attacks = sum(1 for square in board.piece_map() if board.piece_at(square).color == chess.WHITE and board.attackers(chess.WHITE, square))\n    black_attacks = sum(1 for square in board.piece_map() if board.piece_at(square).color == chess.BLACK and board.attackers(chess.BLACK, square))\n    result = float(white_attacks - black_attacks)\n    return result", "def feature(board: chess.Board) -> float:\n    'Calculates the number of pawns that have advanced past the fourth rank.'\n    white_pawns = sum(1 for square in board.piece_map() if board.piece_at(square).color == chess.WHITE and chess.square_rank(square) > 3 and board.piece_at(square).piece_type == chess.PAWN)\n    black_pawns = sum(1 for square in board.piece_map() if board.piece_at(square).color == chess.BLACK and chess.square_rank(square) < 4 and board.piece_at(square).piece_type == chess.PAWN)\n    result = float(white_pawns - black_pawns)\n    return result", "def feature(board: chess.Board) -> float:\n    'Scores the difference in mobility based on legal moves available to both players.'\n    white_moves = len(list(board.legal_moves)) if board.turn else 0\n    black_moves = len(list(board.legal_moves)) if not board.turn else 0\n    result = float(white_moves - black_moves)\n    return result", "def feature(board: chess.Board) -> float:\n    'Counts the number of isolated pawns for both sides.'\n    def isolated_pawns(color):\n        count = 0\n        for square in board.piece_map():\n            piece = board.piece_at(square)\n            if piece.color == color and piece.piece_type == chess.PAWN:\n                file = chess.square_file(square)\n                if (board.piece_at(chess.square(file - 1, chess.square_rank(square))) is None and\n                    board.piece_at(chess.square(file + 1, chess.square_rank(square))) is None):\n                    count += 1\n        return count\n    \n    white_isolated = isolated_pawns(chess.WHITE)\n    black_isolated = isolated_pawns(chess.BLACK)\n    result = float(white_isolated - black_isolated)\n    return result", "def feature(board: chess.Board) -> float:\n    'Calculates the king distance from the center of the board for both players.'\n    white_king_square = next(square for square in board.piece_map() if board.piece_at(square).color == chess.WHITE and board.piece_at(square).piece_type == chess.KING)\n    black_king_square = next(square for square in board.piece_map() if board.piece_at(square).color == chess.BLACK and board.piece_at(square).piece_type == chess.KING)\n    white_distance = chess.square_distance(white_king_square, chess.parse_square('e4'))  # Center square\n    black_distance = chess.square_distance(black_king_square, chess.parse_square('e4'))\n    result = float(white_distance - black_distance)\n    return result", "def feature(board: chess.Board) -> float:\n    'Measures the quantity of undefended pieces for both colors.'\n    undefended_white = sum(1 for square in board.piece_map() if board.piece_at(square).color == chess.WHITE and not any(board.is_attacked_by(chess.BLACK, square) for attacker in board.attackers(chess.BLACK, square)))\n    undefended_black = sum(1 for square in board.piece_map() if board.piece_at(square).color == chess.BLACK and not any(board.is_attacked_by(chess.WHITE, square) for attacker in board.attackers(chess.WHITE, square)))\n    result = float(undefended_white - undefended_black)\n    return result", "def feature(board: chess.Board) -> float:\n    'Counts the number of back rank threats for both players.'\n    rank_threats = 0\n    if board.is_check():\n        return 0.0  # Check means no back rank threats\n    for file in range(8):\n        if board.piece_at(chess.square(file, 0)) and board.piece_at(chess.square(file, 0)).color == chess.BLACK and board.piece_at(chess.square(file, 1)) is None:\n            if board.is_attacked_by(chess.WHITE, chess.square(file, 0)):\n                rank_threats += 1\n        if board.piece_at(chess.square(file, 7)) and board.piece_at(chess.square(file, 7)).color == chess.WHITE and board.piece_at(chess.square(file, 6)) is None:\n            if board.is_attacked_by(chess.BLACK, chess.square(file, 7)):\n                rank_threats -= 1\n    return float(rank_threats)", "def feature(board: chess.Board) -> float:\n    'Calculates the piece activity based on the number of open files for rooks.'\n    def rooks_activity(color):\n        rooks_count = 0\n        open_files = [0] * 8\n        for square in board.piece_map():\n            piece = board.piece_at(square)\n            if piece.color == color and piece.piece_type == chess.ROOK:\n                rooks_count += 1\n                file = chess.square_file(square)\n                open_files[file] += 1\n        return rooks_count, open_files\n    \n    white_rooks, white_open_files = rooks_activity(chess.WHITE)\n    black_rooks, black_open_files = rooks_activity(chess.BLACK)\n    \n    white_activity = sum(1 for count in white_open_files if count == 0)\n    black_activity = sum(1 for count in black_open_files if count == 0)\n    \n    result = float(white_activity - black_activity)\n    return result", "def feature(board: chess.Board) -> float:\n    \"Measures the total mobility by counting the number of possible legal moves for both players.\"\n    return float(len(list(board.legal_moves)))", "def feature(board: chess.Board) -> float:\n    \"Calculates the average distance of all pieces from their opponent's king.\"\n    white_king_square = board.king(chess.WHITE)\n    black_king_square = board.king(chess.BLACK)\n    total_distance = 0\n    piece_count = 0\n    \n    for square, piece in board.piece_map().items():\n        if piece.color == chess.WHITE:\n            total_distance += chess.square_distance(square, black_king_square)\n            piece_count += 1\n        elif piece.color == chess.BLACK:\n            total_distance += chess.square_distance(square, white_king_square)\n            piece_count += 1\n\n    return total_distance / piece_count if piece_count > 0 else 0.0", "def feature(board: chess.Board) -> float:\n    \"Evaluates the number of unprotected pieces on the board.\"\n    unprotected_count = 0\n\n    for square, piece in board.piece_map().items():\n        if board.is_attacked_by(board.turn, square):\n            continue\n        if piece.color == board.turn:  # Only count pieces of the current player\n            unprotected_count += 1\n\n    return float(unprotected_count)", "def feature(board: chess.Board) -> float:\n    \"Scores the number of pieces on the back rank of each player.\"\n    white_back_rank = [square for square in range(0, 8) if board.piece_at(square) and board.piece_at(square).color == chess.WHITE and chess.square_rank(square) == 0]\n    black_back_rank = [square for square in range(56, 64) if board.piece_at(square) and board.piece_at(square).color == chess.BLACK and chess.square_rank(square) == 7]\n    return float(len(white_back_rank) - len(black_back_rank))", "def feature(board: chess.Board) -> float:\n    \"Measures the control of center squares (e4, e5, d4, d5).\"\n    control_squares = [chess.E4, chess.E5, chess.D4, chess.D5]\n    control = 0.0\n\n    for square in control_squares:\n        if board.is_attacked_by(chess.WHITE, square):\n            control += 1.0\n        if board.is_attacked_by(chess.BLACK, square):\n            control -= 1.0\n\n    return control", "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in the number of connected pawns for both players.\"\n    def connected_pawns(color):\n        pawn_squares = [square for square in board.piece_map() if board.piece_map()[square].piece_type == chess.PAWN and board.piece_map()[square].color == color]\n        connected_count = 0\n\n        for square in pawn_squares:\n            file = chess.square_file(square)\n            if board.piece_at(square + 1) and board.piece_at(square + 1).color == color:\n                connected_count += 1\n            if board.piece_at(square - 1) and board.piece_at(square - 1).color == color:\n                connected_count += 1\n\n        return connected_count\n\n    white_connected = connected_pawns(chess.WHITE)\n    black_connected = connected_pawns(chess.BLACK)\n    return float(white_connected - black_connected)", "def feature(board: chess.Board) -> float:\n    \"Measures the overall material advantage based on relative non-pawn pieces.\"\n    piece_values = {chess.KNIGHT: 3, chess.BISHOP: 3, chess.ROOK: 5, chess.QUEEN: 9}\n    white_material = sum(piece_values.get(board.piece_map()[square].piece_type, 0) for square in board.piece_map() if board.piece_map()[square].color == chess.WHITE)\n    black_material = sum(piece_values.get(board.piece_map()[square].piece_type, 0) for square in board.piece_map() if board.piece_map()[square].color == chess.BLACK)\n    return float(white_material - black_material)", "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in the number of threats to both kings.\"\n    threats_white = len(board.attackers(chess.BLACK, board.king(chess.WHITE)))\n    threats_black = len(board.attackers(chess.WHITE, board.king(chess.BLACK)))\n    return float(threats_white - threats_black)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of pieces in enemy territory for each player.\"\n    enemy_territory = 0\n\n    for square, piece in board.piece_map().items():\n        if piece.color == chess.WHITE and chess.square_rank(square) > 4:\n            enemy_territory += 1\n        elif piece.color == chess.BLACK and chess.square_rank(square) < 3:\n            enemy_territory -= 1\n\n    return float(enemy_territory)", "def feature(board: chess.Board) -> float:\n    \"Calculates the total piece activity score based on the number of squares a piece can move to.\"\n    piece_activity = 0\n    for piece in board.piece_map().values():\n        piece_activity += len(list(board.legal_moves))  # count legal moves for each piece\n    return float(piece_activity)", "def feature(board: chess.Board) -> float:\n    \"Counts the total number of squares controlled by the player to move.\"\n    controlled_squares = set()\n    for move in board.legal_moves:\n        controlled_squares.add(move.to_square)\n    return float(len(controlled_squares))", "def feature(board: chess.Board) -> float:\n    \"Measures the depth of the most advanced pawns in the current position.\"\n    white_pawn_depth = max([chess.square_rank(sq) for sq in board.piece_map() if board.piece_at(sq).piece_type == chess.PAWN and board.piece_at(sq).color == chess.WHITE], default=0)\n    black_pawn_depth = max([chess.square_rank(sq) for sq in board.piece_map() if board.piece_at(sq).piece_type == chess.PAWN and board.piece_at(sq).color == chess.BLACK], default=0)\n    return float(white_pawn_depth - black_pawn_depth)", "def feature(board: chess.Board) -> float:\n    \"Counts the total number of checks given by pieces attacking the opponent's king.\"\n    check_count = 0\n    opponent_king_square = board.king(chess.WHITE) if board.turn else board.king(chess.BLACK)\n    attackers = board.attackers(chess.WHITE if board.turn else chess.BLACK, opponent_king_square)\n    check_count += len(attackers)\n    return float(check_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in the overall pawn structure between players using isolated pawns.\"\n    isolated_pawns = 0\n    for file in range(8):\n        white_pawns = sum(1 for rank in range(8) if board.piece_at(chess.square(file, rank)) == chess.PAWN and board.piece_at(chess.square(file, rank)).color == chess.WHITE)\n        black_pawns = sum(1 for rank in range(8) if board.piece_at(chess.square(file, rank)) == chess.PAWN and board.piece_at(chess.square(file, rank)).color == chess.BLACK)\n        if white_pawns > 0 and (file == 0 or not any(board.piece_at(chess.square(file - 1, rank)) for rank in range(8))):\n            isolated_pawns += white_pawns\n        if black_pawns > 0 and (file == 7 or not any(board.piece_at(chess.square(file + 1, rank)) for rank in range(8))):\n            isolated_pawns -= black_pawns\n    return float(isolated_pawns)", "def feature(board: chess.Board) -> float:\n    \"Evaluates the mobility of the king based on its moving options.\"\n    king_square = board.king(chess.WHITE) if board.turn else board.king(chess.BLACK)\n    mobility = len(list(board.legal_moves))  # Moves the king can make considering the current board state\n    return float(mobility)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces that are currently attacking the opponent's king.\"\n    opponent_king_square = board.king(chess.WHITE) if board.turn else board.king(chess.BLACK)\n    attacking_piece_count = len(board.attackers(chess.WHITE if board.turn else chess.BLACK, opponent_king_square))\n    return float(attacking_piece_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in piece activity based on pieces' positions.\"\n    active_pieces = sum(1 for piece in board.piece_map().values() if piece.color == board.turn and piece.piece_type in [chess.QUEEN, chess.ROOK, chess.BISHOP, chess.KNIGHT] and len(list(board.legal_moves)) > 0)\n    return float(active_pieces)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of semi-open files controlled by each player.\"\n    semi_open_files = sum(1 for file in range(8) if (any(board.piece_at(chess.square(file, rank)) for rank in range(1, 8)) and not any(board.piece_at(chess.square(file, 0)) if board.turn == chess.WHITE else board.piece_at(chess.square(file, 7)) for rank in range(1, 8))))\n    return float(semi_open_files)", "def feature(board: chess.Board) -> float:\n    \"Calculates the central control by counting pieces on the central squares (d4, d5, e4, e5).\"\n    central_squares = [chess.parse_square(sq) for sq in ['d4', 'd5', 'e4', 'e5']]\n    control_count = sum(1 for square in central_squares if board.piece_at(square) is not None and board.piece_at(square).color == board.turn)\n    return float(control_count)", "def feature(board: chess.Board) -> float:\n    \"Measures the distance of all major pieces from the opponent's back rank.\"\n    enemy_back_rank = 0 if board.turn == chess.WHITE else 7\n    distance_sum = sum(chess.square_distance(square, chess.parse_square(f'h{enemy_back_rank+1}')) for square, piece in board.piece_map().items() if piece.color == board.turn and piece.piece_type in [chess.ROOK, chess.QUEEN])\n    return float(distance_sum)", "def feature(board: chess.Board) -> float:\n    \"Calculates the total material value of all pieces compared to the opponent.\"\n    material_value = sum(piece.piece_type for piece in board.piece_map().values() if piece.color == board.turn) - sum(piece.piece_type for piece in board.piece_map().values() if piece.color != board.turn)\n    return float(material_value)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pawns on the 6th rank, as this usually indicates strong positioning.\"\n    pawn_on_sixth = sum(1 for square in board.piece_map() if board.piece_map()[square].piece_type == chess.PAWN and (chess.square_rank(square) == 5 if board.turn == chess.WHITE else chess.square_rank(square) == 2))\n    return float(pawn_on_sixth)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of double-attacked pieces of the current player.\"\n    double_attacks = sum(1 for square in board.piece_map() if board.piece_map()[square].color == board.turn and len(board.attackers(not board.turn, square)) > 1)\n    return float(double_attacks)", "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in the number of defenders around each player's king.\"\n    white_defenders = sum(1 for square in board.attackers(chess.WHITE, chess.KING))\n    black_defenders = sum(1 for square in board.attackers(chess.BLACK, chess.KING))\n    return float(white_defenders - black_defenders)", "def feature(board: chess.Board) -> float:\n    \"Measures how many pieces are on squares that are attacked by the opponent.\"\n    attacked_pieces = sum(1 for square in board.piece_map() if board.is_attacked_by(not board.turn, square))\n    return float(attacked_pieces)", "def feature(board: chess.Board) -> float:\n    \"Calculates the total number of pawns on the board, weighted by their rank position.\"\n    total_pawn_value = 0\n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.PAWN:\n            total_pawn_value += (8 - chess.square_rank(square))  # Pawns gain value as they advance\n    return float(total_pawn_value)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of squares in the opponent's half of the board that are attacked by the current player's pieces.\"\n    attacking_squares = set()\n    for square in board.piece_map():\n        piece = board.piece_at(square)\n        for move in board.legal_moves:\n            if move.from_square == square:\n                attacking_squares.add(move.to_square)\n    opponent_half = range(0, 64) if board.turn else range(56, 64)\n    return float(len([sq for sq in attacking_squares if sq in opponent_half]))", "def feature(board: chess.Board) -> float:\n    \"Measures the mobility advantage by comparing the number of legal moves for both players.\"\n    white_moves = len(list(board.legal_moves)) if board.turn else 0\n    black_moves = len(list(board.legal_moves)) if not board.turn else 0\n    return float(white_moves - black_moves)", "def feature(board: chess.Board) -> float:\n    \"Calculates the king safety score based on the number of squares attacking the opponent's king.\"\n    if board.turn:\n        opponent_king_square = next(square for square, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color == chess.BLACK)\n    else:\n        opponent_king_square = next(square for square, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color == chess.WHITE)\n    return float(len(board.attackers(not board.turn, opponent_king_square)))", "def feature(board: chess.Board) -> float:\n    \"Scores the coordination among pieces by counting the number of pairs of pieces that can directly support each other.\"\n    support_count = 0\n    for square_a, piece_a in board.piece_map().items():\n        for square_b, piece_b in board.piece_map().items():\n            if piece_a.color == piece_b.color and square_a != square_b:\n                if board.is_attacked_by(piece_a.color, square_b):\n                    support_count += 1\n    return float(support_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the average distance of all pieces from their respective back ranks.\"\n    total_distance = 0\n    piece_count = 0\n    for square, piece in board.piece_map().items():\n        total_distance += chess.square_rank(square) if piece.color == chess.WHITE else (7 - chess.square_rank(square))\n        piece_count += 1\n    return float(total_distance / piece_count) if piece_count > 0 else 0.0", "def feature(board: chess.Board) -> float:\n    \"Calculates the total number of captured opponent pieces, weighted by their value.\"\n    captured_pieces_value = 0\n    if board.turn:  # White's turn, check Black's captured pieces\n        captured_pieces = [chess.PAWN, chess.KNIGHT, chess.BISHOP, chess.ROOK, chess.QUEEN, chess.KING]\n    else:  # Black's turn, check White's captured pieces\n        captured_pieces = [chess.PAWN, chess.KNIGHT, chess.BISHOP, chess.ROOK, chess.QUEEN, chess.KING]\n    for piece_type in captured_pieces:\n        if board.is_checkmate() or board.is_stalemate(): \n            continue  # Don't evaluate if checkmate or stalemate\n        captured_pieces_value += {chess.PAWN: 100, chess.KNIGHT: 320, chess.BISHOP: 330, chess.ROOK: 500, chess.QUEEN: 900}.get(piece_type, 0)\n    return float(captured_pieces_value)", "def feature(board: chess.Board) -> float:\n    \"Measures the activity level of pieces by quantifying how many pieces are on the 5th rank or higher.\"\n    active_piece_count = 0\n    for square, piece in board.piece_map().items():\n        if (piece.color == chess.WHITE and chess.square_rank(square) >= 4) or (piece.color == chess.BLACK and chess.square_rank(square) <= 3):\n            active_piece_count += 1\n    return float(active_piece_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the density of pieces in the center squares (d4, d5, e4, e5) for both players.\"\n    center_squares = [chess.D4, chess.D5, chess.E4, chess.E5]\n    density_count = sum(1 for square in center_squares if board.piece_at(square) is not None)\n    return float(density_count)", "def feature(board: chess.Board) -> float:\n    \"Measures the difference in material value between the players' strongest pieces.\"\n    white_strongest = max((piece.piece_type for piece in board.piece_map().values() if piece.color == chess.WHITE), default=0)\n    black_strongest = max((piece.piece_type for piece in board.piece_map().values() if piece.color == chess.BLACK), default=0)\n    result = chess.PAWN * (white_strongest - black_strongest)\n    return result", "def feature(board: chess.Board) -> float:\n    \"Calculates the total number of pieces attacking the opponent's king.\"\n    king_square = next((sq for sq, piece in board.piece_map().items() if piece.piece_type == chess.KING), None)\n    if king_square is None:\n        return 0.0\n    attackers = sum(1 for move in board.legal_moves if board.is_attacked_by(chess.WHITE, king_square) if move.from_square != king_square)\n    return float(attackers)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces each player has in the opponent's half.\"\n    white_in_opponent_half = sum(1 for sq, piece in board.piece_map().items() if piece.color == chess.WHITE and chess.square_rank(sq) > 3)\n    black_in_opponent_half = sum(1 for sq, piece in board.piece_map().items() if piece.color == chess.BLACK and chess.square_rank(sq) < 4)\n    result = float(white_in_opponent_half - black_in_opponent_half)\n    return result", "def feature(board: chess.Board) -> float:\n    \"Measures the average distance of pieces from center squares (d4, d5, e4, e5).\"\n    center_squares = [chess.parse_square(sq) for sq in ['d4', 'd5', 'e4', 'e5']]\n    total_distance = sum(chess.square_distance(sq, csq) for sq in board.piece_map() for csq in center_squares)\n    average_distance = total_distance / len(board.piece_map()) if board.piece_map() else 0.0\n    return float(average_distance)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of pawns on the 7th rank.\"\n    pawns_on_seventh = sum(1 for sq, piece in board.piece_map().items() if piece.piece_type == chess.PAWN and chess.square_rank(sq) == 6)\n    return float(pawns_on_seventh)", "def feature(board: chess.Board) -> float:\n    \"Counts the total number of pieces that are undefended.\"\n    undefended_pieces = sum(1 for sq, piece in board.piece_map().items() if piece.color == board.turn and not board.attackers(not board.turn, sq))\n    return float(undefended_pieces)", "def feature(board: chess.Board) -> float:\n    \"Measures the mobility ratio of the player's pieces over total pieces.\"\n    total_pieces = len(board.piece_map())\n    mobility = len(list(board.legal_moves))\n    mobility_ratio = mobility / total_pieces if total_pieces > 0 else 0.0\n    return mobility_ratio", "def feature(board: chess.Board) -> float:\n    \"Computes the total number of checks the player is capable of delivering on the next move.\"\n    check_count = sum(1 for move in board.legal_moves if board.is_check())\n    return float(check_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in the number of pawns for both players.\"\n    white_pawns = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE and piece.piece_type == chess.PAWN)\n    black_pawns = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK and piece.piece_type == chess.PAWN)\n    return float(white_pawns - black_pawns)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces that are pinned (unable to move without exposing a king).\"\n    pinned_pieces = 0\n    for square, piece in board.piece_map().items():\n        if (piece.color == board.turn and \n                len(list(board.attackers(not piece.color, square))) > 0): \n            for attacker_square in board.attackers(not piece.color, square):\n                if board.piece_at(attacker_square).piece_type == chess.KING:\n                    pinned_pieces += 1\n    return float(pinned_pieces)", "def feature(board: chess.Board) -> float:\n    \"Measures endangered king safety by checking the number of direct checks against the king.\"\n    king_square = next(square for square, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color == board.turn)\n    checks = len(list(board.attackers(not board.turn, king_square)))\n    return float(checks)", "def feature(board: chess.Board) -> float:\n    \"Evaluates the total distance from the king to all pieces of the same color.\"\n    king_square = next(square for square, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color == board.turn)\n    total_distance = sum(chess.square_distance(king_square, square) for square, piece in board.piece_map().items() if piece.color == board.turn)\n    return float(total_distance)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of undefended pieces on the board for the current player.\"\n    undefended_count = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == board.turn and not board.is_attacked_by(not board.turn, square):\n            undefended_count += 1\n    return float(undefended_count)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of major pieces (rooks and queens) for both sides.\"\n    major_pieces_white = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE and piece.piece_type in [chess.ROOK, chess.QUEEN])\n    major_pieces_black = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK and piece.piece_type in [chess.ROOK, chess.QUEEN])\n    return float(major_pieces_white - major_pieces_black)", "def feature(board: chess.Board) -> float:\n    \"Measures the control of the center by counting pieces on central squares (d4, d5, e4, e5).\"\n    center_squares = [chess.D4, chess.D5, chess.E4, chess.E5]\n    control_count = sum(1 for square in center_squares if board.piece_at(square) is not None and board.piece_at(square).color == board.turn)\n    return float(control_count)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of backward pawns present on the board for both players.\"\n    backward_pawns = 0\n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.PAWN and piece.color == board.turn:\n            file = chess.square_file(square)\n            rank = chess.square_rank(square)\n            if ((rank < 7 and board.piece_at(chess.square(file, rank + 1)) is None) and\n                    (file > 0 and board.piece_at(chess.square(file - 1, rank)) is None) and\n                    (file < 7 and board.piece_at(chess.square(file + 1, rank)) is None)):\n                backward_pawns += 1\n    return float(backward_pawns)", "def feature(board: chess.Board) -> float:\n    \"Measures the safety of the king based on the number of attacking pieces in proximity to the king.\"\n    king_square = [sq for sq in board.piece_map() if board.piece_at(sq).piece_type == chess.KING][0]\n    attacker_count = len(board.attackers(chess.WHITE if board.turn else chess.BLACK, king_square))\n    return float(attacker_count)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of potential checks available to both players.\"\n    white_checks = sum(1 for move in board.legal_moves if board.is_check() or (move.to_square == board.king(chess.WHITE) and board.is_check()))\n    black_checks = sum(1 for move in board.legal_moves if board.is_check() or (move.to_square == board.king(chess.BLACK) and board.is_check()))\n    return float(white_checks - black_checks)", "def feature(board: chess.Board) -> float:\n    \"Evaluates the pawn centralization by counting pawns on central squares.\"\n    central_pawns = sum(1 for square in board.piece_map() if board.piece_at(square).piece_type == chess.PAWN and chess.square_file(square) in [3, 4])\n    return float(central_pawns)", "def feature(board: chess.Board) -> float:\n    \"Measures the potential of passed pawns by counting them for both sides.\"\n    white_passed = sum(1 for square in board.piece_map() if board.piece_at(square).piece_type == chess.PAWN and board.piece_at(square).color == chess.WHITE and not board.is_attacked_by(chess.BLACK, square + 8) and not any(board.piece_at(square + i) for i in range(1, 8) if chess.square_file(square + i) <= 7))\n    black_passed = sum(1 for square in board.piece_map() if board.piece_at(square).piece_type == chess.PAWN and board.piece_at(square).color == chess.BLACK and not board.is_attacked_by(chess.WHITE, square - 8) and not any(board.piece_at(square - i) for i in range(1, 8) if chess.square_file(square - i) >= 0))\n    return float(white_passed - black_passed)", "def feature(board: chess.Board) -> float:\n    \"Assesses the development advantage by counting active pieces in the game.\"\n    active_white_pieces = sum(1 for square in board.piece_map() if board.piece_at(square).color == chess.WHITE and square > 15)\n    active_black_pieces = sum(1 for square in board.piece_map() if board.piece_at(square).color == chess.BLACK and square < 48)\n    return float(active_white_pieces - active_black_pieces)", "def feature(board: chess.Board) -> float:\n    \"Measures the distribution of pieces across the board to determine clustering.\"\n    cluster_score = sum(chess.square_file(square) for square in board.piece_map())\n    return float(cluster_score)", "def feature(board: chess.Board) -> float:\n    \"Calculates development value based on the position of knights.\"\n    knight_positions = [square for square in board.piece_map() if board.piece_at(square).piece_type == chess.KNIGHT]\n    development_score = sum(1 for square in knight_positions if chess.square_file(square) in [2, 5])\n    return float(development_score)", "def feature(board: chess.Board) -> float:\n    \"Evaluates the open file control for rooks by counting rooks on open files.\"\n    open_file_score = sum(1 for square in board.piece_map() if board.piece_at(square).piece_type == chess.ROOK and not any(board.piece_at(sq) for sq in range(chess.parse_square(chess.square_name(square)[0] + '1'), chess.parse_square(chess.square_name(square)[0] + '8') + 1)))\n    return float(open_file_score)", "def feature(board: chess.Board) -> float:\n    \"Calculates the total value of pieces that are currently unprotected.\"\n    unprotected_value = 0\n    for square, piece in board.piece_map().items():\n        if not board.attackers(piece.color, square):\n            unprotected_value += {\n                chess.PAWN: 100,\n                chess.KNIGHT: 320,\n                chess.BISHOP: 330,\n                chess.ROOK: 500,\n                chess.QUEEN: 900,\n                chess.KING: 20000\n            }[piece.piece_type]\n    return float(unprotected_value)", "def feature(board: chess.Board) -> float:\n    \"Measures the distance of the opponent's pieces to the player's king.\"\n    current_color = board.turn\n    king_square = next(square for square, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color == current_color)\n    total_distance = 0\n    for square, piece in board.piece_map().items():\n        if piece.color != current_color:\n            total_distance += chess.square_distance(square, king_square)\n    return float(total_distance)", "def feature(board: chess.Board) -> float:\n    \"Counts pieces that can attack the opponent's king.\"\n    current_color = board.turn\n    king_square = next(square for square, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color != current_color)\n    attacking_count = sum(1 for square, piece in board.piece_map().items() if piece.color == current_color and board.is_attacked_by(piece.color, king_square))\n    return float(attacking_count)", "def feature(board: chess.Board) -> float:\n    \"Evaluates the number of pieces placed on the back rank for both players.\"\n    back_rank_squares = [chess.A8, chess.B8, chess.C8, chess.D8, chess.E8, chess.F8, chess.G8, chess.H8] if board.turn == chess.BLACK else [chess.A1, chess.B1, chess.C1, chess.D1, chess.E1, chess.F1, chess.G1, chess.H1]\n    back_rank_piece_count = sum(1 for square in back_rank_squares if board.piece_at(square) is not None)\n    return float(back_rank_piece_count)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of pawns on the 7th rank for both players.\"\n    seventh_rank_squares = [chess.A7, chess.B7, chess.C7, chess.D7, chess.E7, chess.F7, chess.G7, chess.H7] if board.turn == chess.WHITE else [chess.A2, chess.B2, chess.C2, chess.D2, chess.E2, chess.F2, chess.G2, chess.H2]\n    pawn_count = sum(1 for square in seventh_rank_squares if board.piece_at(square) and board.piece_at(square).piece_type == chess.PAWN)\n    return float(pawn_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in the number of knights for both players.\"\n    white_knights = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE and piece.piece_type == chess.KNIGHT)\n    black_knights = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK and piece.piece_type == chess.KNIGHT)\n    return float(white_knights - black_knights)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of open files (no pawns) for both players.\"\n    open_files = 0\n    for file in range(8):\n        if all(board.piece_at(chess.square(file, rank)) is None for rank in range(8) if board.piece_at(chess.square(file, rank)) is not None):\n            open_files += 1\n    return float(open_files)", "def feature(board: chess.Board) -> float:\n    \"Measures the presence of doubled pawns for both players.\"\n    doubled_pawns = 0\n    pawns = {chess.WHITE: [], chess.BLACK: []}\n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.PAWN:\n            pawns[piece.color].append(chess.square_file(square))\n    for color in pawns:\n        file_counts = [pawns[color].count(f) for f in range(8)]\n        doubled_pawns += sum(max(0, count - 1) for count in file_counts)\n    return float(doubled_pawns)", "def feature(board: chess.Board) -> float:\n    \"Calculates the total mobility (number of legal moves) for both players.\"\n    white_moves = len(list(board.legal_moves)) if board.turn == chess.WHITE else 0\n    black_moves = len(list(board.legal_moves)) if board.turn == chess.BLACK else 0\n    return float(white_moves - black_moves)", "def feature(board: chess.Board) -> float:\n    \"Measures the total number of pinned pieces for both players.\"\n    pinned_count = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == board.turn:\n            for attacker_square in board.attackers(not piece.color, square):\n                if board.piece_at(attacker_square):\n                    attacker_piece = board.piece_at(attacker_square)\n                    if attacker_piece.piece_type in (chess.ROOK, chess.QUEEN, chess.KING):\n                        pinned_count += 1\n    return float(pinned_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the total value of pieces for the player to move.\"\n    total_value = 0\n    piece_values = {\n        chess.PAWN: 100,\n        chess.KNIGHT: 320,\n        chess.BISHOP: 330,\n        chess.ROOK: 500,\n        chess.QUEEN: 900,\n        chess.KING: 20000\n    }\n    for square, piece in board.piece_map().items():\n        if piece.color == board.turn:\n            total_value += piece_values.get(piece.piece_type, 0)\n    return float(total_value)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces that are attacking the enemy king.\"\n    attacking_pieces = 0\n    king_square = None\n    \n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.KING and piece.color != board.turn:\n            king_square = square\n            break\n    \n    if king_square:\n        attacking_pieces = len(board.attackers(board.turn, king_square))\n        \n    return float(attacking_pieces)", "def feature(board: chess.Board) -> float:\n    \"Measures the combined value of pieces that are positioned on the back rank.\"\n    back_rank_value = 0\n    back_rank = 0 if board.turn == chess.WHITE else 7\n    piece_values = {\n        chess.PAWN: 100,\n        chess.KNIGHT: 320,\n        chess.BISHOP: 330,\n        chess.ROOK: 500,\n        chess.QUEEN: 900,\n        chess.KING: 20000\n    }\n    \n    for square, piece in board.piece_map().items():\n        if chess.square_rank(square) == back_rank and piece.color == board.turn:\n            back_rank_value += piece_values.get(piece.piece_type, 0)\n            \n    return float(back_rank_value)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of squares controlled by the player to move.\"\n    controlled_squares = set()\n    \n    for square, piece in board.piece_map().items():\n        if piece.color == board.turn:\n            controlled_squares.update(board.attacks(square))\n    \n    return float(len(controlled_squares))", "def feature(board: chess.Board) -> float:\n    \"Calculates the mobility edge by computing the difference in legal moves between both players.\"\n    white_moves = len(list(board.legal_moves)) if board.turn == chess.WHITE else len(list(board.legal_moves))\n    black_moves = len(list(board.legal_moves)) if board.turn == chess.BLACK else len(list(board.legal_moves))\n    \n    return float(white_moves - black_moves)", "def feature(board: chess.Board) -> float:\n    \"Counts the pieces that are currently pinned by the opponent's pieces.\"\n    pinned_pieces = 0\n    \n    for square, piece in board.piece_map().items():\n        if piece.color == board.turn:\n            if board.is_attacked_by(not board.turn, square):\n                pinned_pieces += 1\n                \n    return float(pinned_pieces)", "def feature(board: chess.Board) -> float:\n    \"Calculates the total number of minor pieces (knights + bishops) on the board.\"\n    minor_pieces_count = 0\n    \n    for square, piece in board.piece_map().items():\n        if piece.piece_type in [chess.KNIGHT, chess.BISHOP]:\n            minor_pieces_count += 1\n            \n    return float(minor_pieces_count)", "def feature(board: chess.Board) -> float:\n    \"Returns the potential central control by summing the piece values of pieces on central squares.\"\n    center_squares = [chess.E4, chess.E5, chess.D4, chess.D5]\n    central_value = 0\n    piece_values = {\n        chess.PAWN: 100,\n        chess.KNIGHT: 320,\n        chess.BISHOP: 330,\n        chess.ROOK: 500,\n        chess.QUEEN: 900,\n        chess.KING: 20000\n    }\n    \n    for square in center_squares:\n        piece = board.piece_at(square)\n        if piece and piece.color == board.turn:\n            central_value += piece_values.get(piece.piece_type, 0)\n    \n    return float(central_value)", "def feature(board: chess.Board) -> float:\n    \"Calculate the ratio of active pieces to total pieces on the board.\"\n    total_pieces = len(board.piece_map())\n    active_pieces = sum(1 for move in board.legal_moves)\n    return float(active_pieces) / float(total_pieces) if total_pieces > 0 else 0.0", "def feature(board: chess.Board) -> float:\n    \"Measure the distance of pieces from the opponent's king.\"\n    opponent_king_square = [square for square, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color != board.turn][0]\n    total_distance = sum(chess.square_distance(square, opponent_king_square) for square in board.piece_map() if board.piece_map()[square].color == board.turn)\n    piece_count = len([square for square in board.piece_map() if board.piece_map()[square].color == board.turn])\n    return total_distance / piece_count if piece_count > 0 else 0.0", "def feature(board: chess.Board) -> float:\n    \"Count the number of central squares controlled by the current player.\"\n    central_squares = [chess.E4, chess.E5, chess.D4, chess.D5]\n    controlled_count = sum(1 for square in central_squares if board.is_attacked_by(board.turn, square))\n    return float(controlled_count)", "def feature(board: chess.Board) -> float:\n    \"Calculate the average piece value of the opponent's pieces that are currently attacked.\"\n    opponent_color = not board.turn\n    value_map = {chess.PAWN: 100, chess.KNIGHT: 320, chess.BISHOP: 330, chess.ROOK: 500, chess.QUEEN: 900, chess.KING: 0}\n    total_value = 0\n    attacked_count = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == opponent_color and board.is_attacked_by(board.turn, square):\n            total_value += value_map[piece.piece_type]\n            attacked_count += 1\n    return total_value / attacked_count if attacked_count > 0 else 0.0", "def feature(board: chess.Board) -> float:\n    \"Calculate the total number of pieces in the endgame (based on piece count).\"\n    piece_count = len(board.piece_map())\n    if piece_count <= 15:\n        return float(piece_count)\n    return 0.0", "def feature(board: chess.Board) -> float:\n    \"Measure the total number of pieces attacking the opponent's king.\"\n    opponent_king_square = [square for square, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color != board.turn]\n    attacking_count = 0\n    if opponent_king_square:\n        opponent_king_square = opponent_king_square[0]\n        attacking_count = sum(1 for square in board.piece_map() if board.is_attacked_by(board.turn, opponent_king_square))\n    return float(attacking_count)", "def feature(board: chess.Board) -> float:\n    \"Measures the tempo advantage by counting how many more legal moves the player to move has compared to the opponent.\"\n    my_moves = len(list(board.legal_moves))\n    board.turn = not board.turn  # Switch to the opponent\n    opponent_moves = len(list(board.legal_moves))\n    board.turn = not board.turn  # Restore original turn\n    return float(my_moves - opponent_moves)", "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in the number of pieces occupying the center squares (d4, d5, e4, e5).\"\n    center_squares = [chess.D4, chess.D5, chess.E4, chess.E5]\n    my_pieces = sum(1 for square in center_squares if board.piece_at(square) and board.piece_at(square).color == board.turn)\n    opponent_pieces = sum(1 for square in center_squares if board.piece_at(square) and board.piece_at(square).color != board.turn)\n    return float(my_pieces - opponent_pieces)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of doubled pawns for the player to move.\"\n    doubled_pawns = 0\n    pawn_files = [0] * 8  # Create a list to count pawns in each file\n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.PAWN and piece.color == board.turn:\n            file_index = chess.square_file(square)\n            pawn_files[file_index] += 1\n    doubled_pawns = sum(1 for count in pawn_files if count > 1)\n    return float(doubled_pawns)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of minor pieces (knights and bishops) present on the board for both players.\"\n    my_minor_pieces = sum(1 for piece in board.piece_map().values() if piece.color == board.turn and piece.piece_type in (chess.KNIGHT, chess.BISHOP))\n    opponent_minor_pieces = sum(1 for piece in board.piece_map().values() if piece.color != board.turn and piece.piece_type in (chess.KNIGHT, chess.BISHOP))\n    return float(my_minor_pieces - opponent_minor_pieces)", "def feature(board: chess.Board) -> float:\n    \"Measures the activity of rooks by counting the number of open and semi-open files they control.\"\n    open_files = 0\n    for file in range(8):\n        file_squares = [chess.square(rank, file) for rank in range(8)]\n        if any(board.piece_at(square) for square in file_squares):\n            if not any(board.piece_at(square) and board.piece_at(square).piece_type == chess.PAWN for square in file_squares):\n                open_files += 1\n            elif any(board.piece_at(square) and board.piece_at(square).color != board.turn and board.piece_at(square).piece_type == chess.PAWN for square in file_squares):\n                open_files += 0.5  # Semi-open file\n    return float(open_files)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of pieces that are more than 3 squares away from the nearest pawn of the same color.\"\n    my_pieces_far_from_pawns = 0\n    my_pawns = [square for square, piece in board.piece_map().items() if piece.color == board.turn and piece.piece_type == chess.PAWN]\n    \n    for square, piece in board.piece_map().items():\n        if piece.color == board.turn and piece.piece_type != chess.PAWN:\n            if all(chess.square_distance(square, pawn_square) > 3 for pawn_square in my_pawns):\n                my_pieces_far_from_pawns += 1\n                \n    return float(my_pieces_far_from_pawns)", "def feature(board: chess.Board) -> float:\n    \"Measures the sum of the values of pieces controlled by the current player's pawns.\"\n    value = 0.0\n    for square in board.piece_map():\n        piece = board.piece_at(square)\n        if piece.color == board.turn and piece.piece_type == chess.PAWN:\n            for target in board.attackers(not board.turn, square):\n                attacked_piece = board.piece_at(target)\n                if attacked_piece is not None:\n                    value += attacked_piece.piece_type\n    return float(value)", "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in the number of pieces controlling the center squares.\"\n    center_squares = [chess.D4, chess.D5, chess.E4, chess.E5]\n    white_control = sum(board.is_attacked_by(chess.WHITE, sq) for sq in center_squares)\n    black_control = sum(board.is_attacked_by(chess.BLACK, sq) for sq in center_squares)\n    return float(white_control - black_control)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces that have potential discovered attack threats.\"\n    threat_count = 0\n    for square in board.piece_map():\n        piece = board.piece_at(square)\n        if piece.color == board.turn:\n            for move in board.legal_moves:\n                if move.from_square == square and board.is_attacked_by(not board.turn, move.to_square):\n                    threat_count += 1\n                    break\n    return float(threat_count)", "def feature(board: chess.Board) -> float:\n    \"Measures the sum of distances from the player's pieces to the opponent's king.\"\n    king_square = next((sq for sq, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color != board.turn), None)\n    if king_square is None:\n        return 0.0\n    distance_sum = sum(chess.square_distance(square, king_square) for square in board.piece_map() if board.piece_at(square).color == board.turn)\n    return float(distance_sum)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces in the opponent's back rank that are not defended.\"\n    back_rank = 7 if board.turn == chess.WHITE else 0\n    undefended_count = 0\n    for file in range(8):\n        square = chess.square(file, back_rank)\n        piece = board.piece_at(square)\n        if piece is not None and piece.color != board.turn and not board.is_attacked_by(board.turn, square):\n            undefended_count += 1\n    return float(undefended_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the mobility of pieces by counting non-pawn moves.\"\n    mobility_count = sum(len(list(board.legal_moves)) for square in board.piece_map() if board.piece_at(square).color == board.turn and board.piece_at(square).piece_type != chess.PAWN)\n    return float(mobility_count)", "def feature(board: chess.Board) -> float:\n    \"Measures the total number of pieces with multiple attacking opportunities.\"\n    multiple_attack_count = 0\n    for square in board.piece_map():\n        piece = board.piece_at(square)\n        if piece.color == board.turn and len(board.attackers(not board.turn, square)) > 1:\n            multiple_attack_count += 1\n    return float(multiple_attack_count)", "def feature(board: chess.Board) -> float:\n    \"Scores the total number of protected pieces on the board.\"\n    protected_count = 0\n    for square in board.piece_map():\n        piece = board.piece_at(square)\n        if piece.color == board.turn:\n            defending_squares = board.attackers(piece.color, square)\n            if any(board.is_attacked_by(not piece.color, defend_square) for defend_square in defending_squares):\n                protected_count += 1\n    return float(protected_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of pieces that threaten the opponent's pieces.\"\n    threat_count = 0\n    for square in board.piece_map():\n        piece = board.piece_at(square)\n        if piece.color == board.turn:\n            for target in board.piece_map():\n                if board.is_attacked_by(board.turn, target) and board.piece_at(target) is not None:\n                    threat_count += 1\n    return float(threat_count)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of times pieces are defending each other.\"\n    defense_count = 0\n    for square in board.piece_map():\n        piece = board.piece_at(square)\n        if piece.color == board.turn:\n            for defender in board.attackers(piece.color, square):\n                if board.piece_at(defender) is not None and board.piece_at(defender).color == piece.color:\n                    defense_count += 1\n    return float(defense_count)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of active pieces on the board.\"\n    active_pieces = sum(1 for piece in board.piece_map().values() if piece.color == board.turn)\n    return float(active_pieces)", "def feature(board: chess.Board) -> float:\n    \"Measures the total mobility of all pieces for the current player.\"\n    mobility = sum(len(list(board.legal_moves)) for square, piece in board.piece_map().items() if piece.color == board.turn)\n    return float(mobility)", "def feature(board: chess.Board) -> float:\n    \"Calculates the percentage of squares attacked by the current player's pieces.\"\n    attacked_squares = set()\n    for square, piece in board.piece_map().items():\n        if piece.color == board.turn:\n            attacked_squares.update(board.attackers(piece.color, square))\n    total_squares = 64\n    return float(len(attacked_squares) / total_squares)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces in the opponent's half of the board.\"\n    active_half_pieces = sum(1 for square, piece in board.piece_map().items() if piece.color != board.turn and chess.square_rank(square) > 3)\n    return float(active_half_pieces)", "def feature(board: chess.Board) -> float:\n    \"Calculates the king safety by counting the number of pieces attacking the opponent's king.\"\n    opponent_king_square = next(square for square, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color != board.turn)\n    attacking_count = len(board.attackers(board.turn, opponent_king_square))\n    return float(attacking_count)", "def feature(board: chess.Board) -> float:\n    \"Measures the presence of major pieces (rooks and queens) in the center of the board.\"\n    central_count = sum(1 for square, piece in board.piece_map().items() if piece.color == board.turn and piece.piece_type in {chess.ROOK, chess.QUEEN} and chess.square_file(square) in {3, 4} and chess.square_rank(square) in {3, 4})\n    return float(central_count)", "def feature(board: chess.Board) -> float:\n    \"Determines the number of supported pawns for the current player.\"\n    supported_pawns = sum(1 for square, piece in board.piece_map().items() if piece.color == board.turn and piece.piece_type == chess.PAWN and any(board.is_attacked_by(board.turn, square) for square in board.attackers(board.turn, square)))\n    return float(supported_pawns)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces in active play that can threaten the opponent's king next move.\"\n    threat_count = sum(1 for square, piece in board.piece_map().items() if piece.color == board.turn and any(board.is_attacked_by(piece.color, move.to_square) for move in board.legal_moves))\n    return float(threat_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the total distance of all pieces from their ideal ranks.\"\n    total_distance = sum(chess.square_rank(square) for square, piece in board.piece_map().items() if piece.color == board.turn and piece.piece_type != chess.KING)\n    return float(total_distance)", "def feature(board: chess.Board) -> float:\n    \"Measures the total number of pieces that are pinned by opponent's pieces.\"\n    pinned_count = 0\n    for square in board.piece_map():\n        piece = board.piece_at(square)\n        if piece.color == board.turn:\n            for attacker in board.attackers(not piece.color, square):\n                if board.piece_at(attacker).piece_type in {chess.QUEEN, chess.ROOK, chess.BISHOP}:\n                    pinned_count += 1\n                    break\n    return float(pinned_count)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pawns on the 7th rank for both players.\"\n    white_pawns_7th_rank = sum(1 for square in board.piece_map() if board.piece_at(square).color == chess.WHITE and chess.square_rank(square) == 6)\n    black_pawns_7th_rank = sum(1 for square in board.piece_map() if board.piece_at(square).color == chess.BLACK and chess.square_rank(square) == 6)\n    return float(white_pawns_7th_rank - black_pawns_7th_rank)", "def feature(board: chess.Board) -> float:\n    \"Calculates the imbalance in mobility between the two players based on legal moves.\"\n    white_moves = len(list(board.legal_moves)) if board.turn else 0\n    black_moves = len(list(board.legal_moves)) if not board.turn else 0\n    return float(white_moves - black_moves)", "def feature(board: chess.Board) -> float:\n    \"Scores the king safety based on the number of squares around the king that are both safe and attacked.\"\n    king_square = chess.parse_square(chess.square_name(board.king(board.turn)))\n    safe_squares = [square for square in chess.SQUARES if not board.is_attacked_by(not board.turn, square)]\n    surrounding_squares = [chess.square_name(king_square + offset) for offset in [-1, 1, -8, 8, -7, 7, -9, 9] if 0 <= king_square + offset < 64]\n    safe_around_king = len(set(surrounding_squares) & set(safe_squares))\n    return float(safe_around_king)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of pieces currently attacking the opponent's king.\"\n    opponent_king_square = chess.square_name(board.king(not board.turn))\n    attacker_count = len(board.attackers(board.turn, chess.parse_square(opponent_king_square)))\n    return float(attacker_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the piece activity by assessing the number of pieces on high-value squares (central and opponent's side).\"\n    high_value_squares = [chess.E4, chess.E5, chess.D4, chess.D5, chess.C4, chess.C5, chess.F4, chess.F5]\n    active_piece_count = sum(1 for square in board.piece_map() if square in high_value_squares)\n    return float(active_piece_count)", "def feature(board: chess.Board) -> float:\n    \"Measures the control over the center by counting the number of pieces on central squares.\"\n    center_squares = {chess.D4, chess.D5, chess.E4, chess.E5}\n    center_control = sum(1 for square in board.piece_map() if square in center_squares)\n    return float(center_control)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces of each color that are on squares of the opposite color (color complex).\"\n    opposite_color_control = 0\n    for square in board.piece_map():\n        piece = board.piece_at(square)\n        if (piece.color == chess.WHITE and chess.square_file(square) % 2 == 0) or (piece.color == chess.BLACK and chess.square_file(square) % 2 == 1):\n            opposite_color_control += 1\n    return float(opposite_color_control)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of doubled pawns for both players.\"\n    white_doubled = 0\n    black_doubled = 0\n    pawn_count = {i: 0 for i in range(8)}\n    for square in board.piece_map():\n        piece = board.piece_at(square)\n        if piece.piece_type == chess.PAWN:\n            file = chess.square_file(square)\n            pawn_count[file] += 1\n    white_doubled = sum(1 for count in pawn_count.values() if count > 1)\n    black_doubled = sum(1 for count in pawn_count.values() if count > 1)\n    return float(white_doubled - black_doubled)", "def feature(board: chess.Board) -> float:\n    \"Measures the distance from the player\u2019s king to their back rank.\"\n    king_square = chess.parse_square(chess.square_name(board.king(board.turn)))\n    back_rank = 0 if board.turn == chess.WHITE else 7\n    distance_to_back_rank = chess.square_rank(king_square) - back_rank\n    return float(distance_to_back_rank)", "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in the number of pieces on the 7th rank for both players.\"\n    white_7th_rank = sum(1 for sq in range(chess.A7, chess.H7 + 1) if board.piece_at(sq) and board.piece_at(sq).color == chess.WHITE)\n    black_7th_rank = sum(1 for sq in range(chess.A2, chess.H2 + 1) if board.piece_at(sq) and board.piece_at(sq).color == chess.BLACK)\n    return float(white_7th_rank - black_7th_rank)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of attacking pieces each player has.\"\n    white_attacks = sum(1 for move in board.legal_moves if board.is_attacked_by(chess.WHITE, move.to_square))\n    black_attacks = sum(1 for move in board.legal_moves if board.is_attacked_by(chess.BLACK, move.to_square))\n    return float(white_attacks - black_attacks)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of pieces for each player on the opponent's half of the board.\"\n    white_in_enemy_half = sum(1 for sq in board.piece_map() if board.piece_at(sq).color == chess.WHITE and chess.square_rank(sq) > 3)\n    black_in_enemy_half = sum(1 for sq in board.piece_map() if board.piece_at(sq).color == chess.BLACK and chess.square_rank(sq) < 4)\n    return float(white_in_enemy_half - black_in_enemy_half)", "def feature(board: chess.Board) -> float:\n    \"Measures the distance of the kings to the center of the board.\"\n    white_king_square = next(sq for sq in board.piece_map() if board.piece_at(sq).piece_type == chess.KING and board.piece_at(sq).color == chess.WHITE)\n    black_king_square = next(sq for sq in board.piece_map() if board.piece_at(sq).piece_type == chess.KING and board.piece_at(sq).color == chess.BLACK)\n    distance_to_center = (chess.square_distance(white_king_square, chess.E4) + chess.square_distance(black_king_square, chess.E4)) / 2\n    return float(distance_to_center)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of pieces in open files for both players.\"\n    open_files_count_white = sum(1 for f in range(8) if all(board.piece_at(sq) is None for sq in range(chess.A1 + f, chess.H8 + f, 8)))\n    open_files_count_black = sum(1 for f in range(8) if all(board.piece_at(sq) is None for sq in range(chess.A8 + f, chess.H1 + f, -8)))\n    return float(open_files_count_white - open_files_count_black)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of isolated pawns per player.\"\n    def is_isolated_pawn(square):\n        file = chess.square_file(square)\n        if file > 0 and board.piece_at(square - 1) and board.piece_at(square - 1).piece_type == chess.PAWN:\n            return False\n        if file < 7 and board.piece_at(square + 1) and board.piece_at(square + 1).piece_type == chess.PAWN:\n            return False\n        return True\n\n    isolated_white = sum(1 for sq in board.piece_map() if board.piece_at(sq).color == chess.WHITE and board.piece_at(sq).piece_type == chess.PAWN and is_isolated_pawn(sq))\n    isolated_black = sum(1 for sq in board.piece_map() if board.piece_at(sq).color == chess.BLACK and board.piece_at(sq).piece_type == chess.PAWN and is_isolated_pawn(sq))\n    return float(isolated_white - isolated_black)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces that are currently pinned.\"\n    pinned_count = 0\n    for square in board.piece_map():\n        piece = board.piece_at(square)\n        if piece and board.is_attacked_by(not piece.color, square):\n            pinned_count += 1\n    return float(pinned_count)", "def feature(board: chess.Board) -> float:\n    \"Measures the total imbalanced material due to pawns on the 7th rank, favoring passed pawns.\"\n    passed_pawn_value = 0.0\n    for sq, piece in board.piece_map().items():\n        if piece.piece_type == chess.PAWN:\n            if (piece.color == chess.WHITE and chess.square_rank(sq) == 6) or \\\n               (piece.color == chess.BLACK and chess.square_rank(sq) == 1):\n                passed_pawn_value += 1.0  # Count passed pawns on the 7th rank\n    return passed_pawn_value", "def feature(board: chess.Board) -> float:\n    \"Counts the number of control squares for each player for pieces within the last two ranks.\"\n    control_value = 0.0\n    for sq, piece in board.piece_map().items():\n        if piece.color == board.turn and chess.square_rank(sq) >= 6:\n            control_value += len(board.attackers(not piece.color, sq))  # Counting control squares\n    return control_value", "def feature(board: chess.Board) -> float:\n    \"Calculates the ratio of major pieces (rooks and queens) to total pieces on the board.\"\n    major_piece_count = sum(1 for piece in board.piece_map().values() if piece.piece_type in {chess.ROOK, chess.QUEEN})\n    total_piece_count = len(board.piece_map())\n    return major_piece_count / total_piece_count if total_piece_count > 0 else 0.0", "def feature(board: chess.Board) -> float:\n    \"Measures the distance of kings from the center of the board.\"\n    center_squares = {chess.E4, chess.E5, chess.D4, chess.D5}\n    king_square = [sq for sq, piece in board.piece_map().items() if piece.piece_type == chess.KING]\n    if king_square:\n        king_distance = min(chess.square_distance(sq, csq) for sq in king_square for csq in center_squares)\n        return king_distance\n    return float('inf')  # No king on board is an edge case", "def feature(board: chess.Board) -> float:\n    \"Counts the number of potential discovered attacks by pieces on the back rank.\"\n    discovered_attacks = 0\n    for sq, piece in board.piece_map().items():\n        if piece.color == board.turn and chess.square_rank(sq) == 0:\n            for move in board.legal_moves:\n                if move.from_square == sq:\n                    attacked_square = move.to_square\n                    if board.is_attacked_by(not piece.color, attacked_square):\n                        discovered_attacks += 1\n    return float(discovered_attacks)", "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in distance of pieces to opponent's king.\"\n    opponent_king_square = [sq for sq, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color != board.turn]\n    total_distance = 0.0\n    if opponent_king_square:\n        for sq, piece in board.piece_map().items():\n            if piece.color == board.turn:\n                total_distance += chess.square_distance(sq, opponent_king_square[0])\n    return total_distance", "def feature(board: chess.Board) -> float:\n    \"Measures the number of knights and their control over center squares.\"\n    knight_control = 0.0\n    knight_positions = [sq for sq, piece in board.piece_map().items() if piece.piece_type == chess.KNIGHT and piece.color == board.turn]\n    center_squares = {chess.D4, chess.D5, chess.E4, chess.E5}\n    for square in knight_positions:\n        knight_control += len([cs for cs in center_squares if board.is_attacked_by(board.turn, cs)])\n    return knight_control", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces each side has on the opponent's 3rd rank.\"\n    opponent_third_rank = {chess.A3, chess.B3, chess.C3, chess.D3, chess.E3, chess.F3, chess.G3, chess.H3} if board.turn == chess.WHITE else {chess.A6, chess.B6, chess.C6, chess.D6, chess.E6, chess.F6, chess.G6, chess.H6}\n    piece_count = sum(1 for sq in opponent_third_rank if board.piece_at(sq) is not None)\n    return float(piece_count)", "def feature(board: chess.Board) -> float:\n    \"Measures the activity of pieces by counting the number of pieces that can move to an unoccupied square.\"\n    active_moves = sum(1 for move in board.legal_moves if not board.is_attacked_by(not board.turn, move.to_square))\n    return float(active_moves)", "def feature(board: chess.Board) -> float:\n    \"Calculates the total number of squares attacked by friendly pieces.\"\n    attacked_squares = sum(1 for piece in board.piece_map().values() if piece.color == board.turn for square in board.attackers(piece.color, list(board.piece_map().keys())[0]))\n    return float(attacked_squares)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of pieces that are isolated (not supported by adjacent pieces).\"\n    isolated_pieces = 0\n    for square in board.piece_map():\n        piece = board.piece_at(square)\n        if piece and piece.color == board.turn:\n            file = chess.square_file(square)\n            adjacent_pawns = [board.piece_at(chess.square(file + i, chess.square_rank(square))) for i in [-1, 1] if 0 <= file + i < 8]\n            if not any(pawn and pawn.piece_type == chess.PAWN for pawn in adjacent_pawns):\n                isolated_pieces += 1\n    return float(isolated_pieces)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of pawns for each player in the game.\"\n    white_pawn_count = sum(1 for square in board.piece_map() if board.piece_at(square).piece_type == chess.PAWN and board.piece_at(square).color == chess.WHITE)\n    black_pawn_count = sum(1 for square in board.piece_map() if board.piece_at(square).piece_type == chess.PAWN and board.piece_at(square).color == chess.BLACK)\n    return float(white_pawn_count - black_pawn_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the distance in squares of the King to the center of the board.\"\n    king_square = next(square for square in board.piece_map() if board.piece_at(square).piece_type == chess.KING and board.piece_at(square).color == board.turn)\n    center_distance = chess.square_distance(king_square, chess.parse_square('e4')) + chess.square_distance(king_square, chess.parse_square('d4')) + chess.square_distance(king_square, chess.parse_square('e5')) + chess.square_distance(king_square, chess.parse_square('d5'))\n    return float(center_distance)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of squares that are defended by more than one piece.\"\n    defended_squares = sum(1 for square in chess.SQUARES if board.is_attacked_by(board.turn, square) and len(board.attackers(board.turn, square)) > 1)\n    return float(defended_squares)", "def feature(board: chess.Board) -> float:\n    \"Calculates the stability of the position by counting the number of pieces on the back rank.\"\n    back_rank_pieces = sum(1 for square in board.piece_map() if board.piece_at(square).color == board.turn and (chess.square_rank(square) == 0 if board.turn == chess.WHITE else chess.square_rank(square) == 7))\n    return float(back_rank_pieces)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces involved in potential forks.\"\n    forkable_pieces = 0\n    for square in board.piece_map():\n        piece = board.piece_at(square)\n        if piece.color == board.turn:\n            attackers = board.attackers(not board.turn, square)\n            if len(attackers) >= 2:\n                forkable_pieces += 1\n    return float(forkable_pieces)", "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in material value of pieces on the 7th rank between both players.\"\n    white_value = sum(piece.piece_type for sq, piece in board.piece_map().items() if piece.color == chess.WHITE and chess.square_rank(sq) == 6)\n    black_value = sum(piece.piece_type for sq, piece in board.piece_map().items() if piece.color == chess.BLACK and chess.square_rank(sq) == 6)\n    return float(white_value - black_value)", "def feature(board: chess.Board) -> float:\n    \"Measures the total number of pieces attacking the opponent's king square.\"\n    king_sq = next(sq for sq, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color == chess.BLACK)\n    attackers_count = len(board.attackers(chess.WHITE, king_sq))\n    return float(attackers_count)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of defended squares by the current player's pieces.\"\n    defended_squares = sum(1 for sq in range(64) if board.is_attacked_by(chess.BLACK if board.turn else chess.WHITE, sq) and board.piece_at(sq) is None)\n    return float(defended_squares)", "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in piece types present on the board for both players.\"\n    white_types = {piece.piece_type for sq, piece in board.piece_map().items() if piece.color == chess.WHITE}\n    black_types = {piece.piece_type for sq, piece in board.piece_map().items() if piece.color == chess.BLACK}\n    return float(len(white_types) - len(black_types))", "def feature(board: chess.Board) -> float:\n    \"Measures the total number of pieces in the center (d4, d5, e4, e5) controlled by the current player.\"\n    center_squares = [chess.parse_square('d4'), chess.parse_square('d5'), chess.parse_square('e4'), chess.parse_square('e5')]\n    controlled_center = sum(1 for sq in center_squares if board.is_attacked_by(chess.WHITE if board.turn else chess.BLACK, sq))\n    return float(controlled_center)", "def feature(board: chess.Board) -> float:\n    \"Calculates the material value of pieces that are not protecting any pawns.\"\n    unprotected_pieces_value = sum(piece.piece_type for sq, piece in board.piece_map().items() if not any(board.is_attacked_by(board.piece_at(sq).color, pawn_sq) for pawn_sq in chess.SQUARES) and piece.color == (chess.WHITE if board.turn else chess.BLACK))\n    return float(unprotected_pieces_value)", "def feature(board: chess.Board) -> float:\n    \"Counts isolated pawns for both players, as both are weak points in the structure.\"\n    isolated_pawn_count = 0\n    for file in range(8):\n        column_pawns = [sq for sq in range(8) if board.piece_at(chess.square(file, sq)) is not None and board.piece_at(chess.square(file, sq)).piece_type == chess.PAWN]\n        if column_pawns and (len(column_pawns) > 1 or (file > 0 and board.piece_at(chess.square(file - 1, column_pawns[0])) is None) and (file < 7 and board.piece_at(chess.square(file + 1, column_pawns[0])) is None)):\n            isolated_pawn_count += 1\n    return float(isolated_pawn_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of squares of the opponent that are attacked by the current player's pieces.\"\n    attacked_squares = sum(1 for sq in range(64) if board.is_attacked_by(chess.WHITE if board.turn else chess.BLACK, sq))\n    return float(attacked_squares)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of hanging pieces for both players, where a hanging piece is unprotected.\"\n    hanging_pieces_count = sum(1 for sq, piece in board.piece_map().items() if len(board.attackers(piece.color, sq)) == 0)\n    return float(hanging_pieces_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the distance of each major piece (Rook, Queen) to the center of the board relative to their control.\"\n    major_pieces = [chess.ROOK, chess.QUEEN]\n    distance_sum = sum(chess.square_distance(sq, chess.parse_square('e4')) for sq, piece in board.piece_map().items() if piece.piece_type in major_pieces and piece.color == (chess.WHITE if board.turn else chess.BLACK))\n    return float(distance_sum)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of pieces attacking the opponent's king.\"\n    attacking_pieces = sum(1 for square in chess.SQUARES if board.is_attacked_by(not board.turn, square) and board.piece_at(square) is not None)\n    return float(attacking_pieces)", "def feature(board: chess.Board) -> float:\n    \"Calculates the material imbalance by taking the difference in total material value.\"\n    material_value = {chess.PAWN: 100, chess.KNIGHT: 300, chess.BISHOP: 300, chess.ROOK: 500, chess.QUEEN: 900, chess.KING: 0}\n    white_material = sum(material_value[piece.piece_type] for piece in board.piece_map().values() if piece.color == chess.WHITE)\n    black_material = sum(material_value[piece.piece_type] for piece in board.piece_map().values() if piece.color == chess.BLACK)\n    return float(white_material - black_material)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pawns on the 7th rank for the current player.\"\n    pawns_on_seventh = sum(1 for square, piece in board.piece_map().items() if piece.piece_type == chess.PAWN and piece.color == board.turn and chess.square_rank(square) == 6)\n    return float(pawns_on_seventh)", "def feature(board: chess.Board) -> float:\n    \"Calculates the total count of discovered checks available for both players.\"\n    discovered_checks = 0\n    for move in board.legal_moves:\n        board.push(move)\n        if board.is_check():\n            discovered_checks += 1\n        board.pop()\n    return float(discovered_checks)", "def feature(board: chess.Board) -> float:\n    \"Measures the distance between the kings of both players.\"\n    white_king_square = next(square for square, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color == chess.WHITE)\n    black_king_square = next(square for square, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color == chess.BLACK)\n    distance = chess.square_distance(white_king_square, black_king_square)\n    return float(distance)", "def feature(board: chess.Board) -> float:\n    \"Measures how many pieces of the current player are on the same file as the opponent's king.\"\n    opponent_king_square = next(square for square, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color != board.turn)\n    same_file_count = sum(1 for square in board.piece_map() if chess.square_file(square) == chess.square_file(opponent_king_square) and board.piece_at(square).color == board.turn)\n    return float(same_file_count)", "def feature(board: chess.Board) -> float:\n    \"Counts the total number of available checks for the current player.\"\n    check_count = sum(1 for move in board.legal_moves if board.gives_check(move))\n    return float(check_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of pieces currently pinned against the opposing king.\"\n    pinned_pieces = sum(1 for square, piece in board.piece_map().items() if piece.color == board.turn and board.is_attacked_by(not board.turn, square) and board.attackers(not board.turn, square))\n    return float(pinned_pieces)", "def feature(board: chess.Board) -> float:\n    \"Calculates the centralization of pieces for the current player.\"\n    central_squares = [chess.D4, chess.D5, chess.E4, chess.E5]\n    central_piece_count = sum(1 for square in board.piece_map() if square in central_squares and board.piece_at(square).color == board.turn)\n    return float(central_piece_count)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces in the back rank for both players.\"\n    white_back_rank = sum(1 for sq in range(56, 64) if board.piece_at(sq) and board.piece_at(sq).color == chess.WHITE)\n    black_back_rank = sum(1 for sq in range(0, 8) if board.piece_at(sq) and board.piece_at(sq).color == chess.BLACK)\n    return float(white_back_rank - black_back_rank)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of unprotected pieces for the current player.\"\n    color = board.turn\n    unprotected_count = sum(1 for sq, piece in board.piece_map().items() if piece.color == color and not board.attackers(not color, sq))\n    return float(unprotected_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the total distance of all pieces from their home ranks.\"\n    total_distance = sum(chess.square_rank(sq) if piece.color == chess.WHITE else 7 - chess.square_rank(sq)\n                         for sq, piece in board.piece_map().items())\n    return float(total_distance)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces that are on the opponent's side of the board.\"\n    opponent_rank = 4 if board.turn == chess.WHITE else 3\n    pieces_on_opponent_side = sum(1 for sq, piece in board.piece_map().items() if chess.square_rank(sq) > opponent_rank and piece.color != board.turn)\n    return float(pieces_on_opponent_side)", "def feature(board: chess.Board) -> float:\n    \"Measures the king safety by counting squares adjacent to the king that are not attacked.\"\n    king_square = board.king(board.turn)\n    if king_square is None:\n        return 0.0\n    safe_adjacent = sum(1 for sq in board.attacks(king_square) if not board.is_attacked_by(not board.turn, sq))\n    return float(safe_adjacent)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of pawn structures beyond the 5th rank for both players.\"\n    white_pawns = sum(1 for sq, piece in board.piece_map().items() if piece.piece_type == chess.PAWN and piece.color == chess.WHITE and chess.square_rank(sq) > 4)\n    black_pawns = sum(1 for sq, piece in board.piece_map().items() if piece.piece_type == chess.PAWN and piece.color == chess.BLACK and chess.square_rank(sq) < 4)\n    return float(white_pawns - black_pawns)", "def feature(board: chess.Board) -> float:\n    \"Measures the total number of doubled pawns on the board.\"\n    pawns = [sq for sq, piece in board.piece_map().items() if piece.piece_type == chess.PAWN]\n    doubled_pawns_count = sum(1 for file in range(8) if len([sq for sq in pawns if chess.square_file(sq) == file]) > 1)\n    return float(doubled_pawns_count)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of squares that are attacked by multiple pieces.\"\n    attacked_count = sum(1 for sq in range(64) if board.is_attacked_by(board.turn, sq) and len(board.attackers(board.turn, sq)) > 1)\n    return float(attacked_count)", "def feature(board: chess.Board) -> float:\n    \"Measures the total material value of pieces in front of the opponent's king.\"\n    opponent_king_sq = board.king(not board.turn)\n    material_value = 0\n    for sq, piece in board.piece_map().items():\n        if chess.square_distance(sq, opponent_king_sq) == 1:\n            material_value += piece.piece_type\n    return float(material_value)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pawns that are advanced past their starting ranks.\"\n    advanced_pawns = 0\n    for sq, piece in board.piece_map().items():\n        if piece.piece_type == chess.PAWN:\n            if (piece.color == chess.WHITE and chess.square_rank(sq) > 1) or (piece.color == chess.BLACK and chess.square_rank(sq) < 6):\n                advanced_pawns += 1\n    return float(advanced_pawns)", "def feature(board: chess.Board) -> float:\n    \"Measures the total number of squares controlled by each side's pawns.\"\n    controlled_squares = 0\n    for sq, piece in board.piece_map().items():\n        if piece.piece_type == chess.PAWN:\n            if piece.color == chess.WHITE:\n                controlled_squares += len(board.attackers(chess.BLACK, sq))\n            else:\n                controlled_squares += len(board.attackers(chess.WHITE, sq))\n    return float(controlled_squares)", "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in mobility for both players based on the available legal moves.\"\n    white_moves = len(list(board.legal_moves)) if board.turn else 0\n    black_moves = len(list(board.legal_moves)) if not board.turn else 0\n    return float(white_moves - black_moves)", "def feature(board: chess.Board) -> float:\n    \"Measures the difference in piece value between the current player and the opponent.\"\n    piece_value = {chess.PAWN: 100, chess.KNIGHT: 300, chess.BISHOP: 300, chess.ROOK: 500, chess.QUEEN: 900, chess.KING: 20000}\n    current_value = sum(piece_value[piece.piece_type] for piece in board.piece_map().values() if piece.color == board.turn)\n    opponent_value = sum(piece_value[piece.piece_type] for piece in board.piece_map().values() if piece.color != board.turn)\n    return float(current_value - opponent_value)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of pieces that are pinned by opposing pieces.\"\n    pinned_pieces = 0\n    for sq, piece in board.piece_map().items():\n        if piece.color == board.turn:\n            for target_square in range(64):\n                if board.is_attacked_by(not board.turn, sq) and board.piece_at(target_square) is not None:\n                    pinned_pieces += 1\n                    break\n    return float(pinned_pieces)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of developed pieces for both players (pieces not on their starting squares).\"\n    starting_positions = {\n        chess.WHITE: {chess.A1, chess.B1, chess.C1, chess.D1, chess.E1, chess.F1, chess.G1, chess.H1},\n        chess.BLACK: {chess.A8, chess.B8, chess.C8, chess.D8, chess.E8, chess.F8, chess.G8, chess.H8}\n    }\n    developed_pieces = 0\n    for sq, piece in board.piece_map().items():\n        if piece.color == board.turn and sq not in starting_positions[piece.color]:\n            developed_pieces += 1\n    return float(developed_pieces)", "def feature(board: chess.Board) -> float:\n    \"Measures the king's safety based on the number of enemy pieces in close proximity.\"\n    enemy_attacks = 0\n    king_square = next(square for square, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color == board.turn)\n    for sq in chess.SQUARES:\n        if board.is_attacked_by(not board.turn, sq) and chess.square_distance(sq, king_square) <= 1:\n            enemy_attacks += 1\n    return float(enemy_attacks)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of doubled pawns on the board.\"\n    pawn_files = {}\n    for sq, piece in board.piece_map().items():\n        if piece.piece_type == chess.PAWN:\n            file_index = chess.square_file(sq)\n            if file_index in pawn_files:\n                pawn_files[file_index] += 1\n            else:\n                pawn_files[file_index] = 1\n    doubled_pawns = sum(1 for count in pawn_files.values() if count > 1)\n    return float(doubled_pawns)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of squares controlled by pieces of the current player.\"\n    controlled_squares = set()\n    for sq, piece in board.piece_map().items():\n        if piece.color == board.turn:\n            controlled_squares.add(sq)\n            for move in board.legal_moves:\n                if move.from_square == sq:\n                    controlled_squares.add(move.to_square)\n    return float(len(controlled_squares))", "def feature(board: chess.Board) -> float:\n    \"Measures the total material imbalance based on piece values for both players.\"\n    piece_value = {chess.PAWN: 100, chess.KNIGHT: 300, chess.BISHOP: 300, chess.ROOK: 500, chess.QUEEN: 900, chess.KING: 20000}\n    material_score = 0\n    for piece in board.piece_map().values():\n        value = piece_value[piece.piece_type]\n        if piece.color == board.turn:\n            material_score += value\n        else:\n            material_score -= value\n    return float(material_score)", "def feature(board: chess.Board) -> float:\n    'Measures the advancement of pawns by calculating their rank positions.'\n    white_pawn_advancement = sum(7 - chess.square_rank(square) for square in board.piece_map() if board.piece_at(square).color == chess.WHITE and board.piece_at(square).piece_type == chess.PAWN)\n    black_pawn_advancement = sum(chess.square_rank(square) for square in board.piece_map() if board.piece_at(square).color == chess.BLACK and board.piece_at(square).piece_type == chess.PAWN)\n    result = white_pawn_advancement - black_pawn_advancement\n    return float(result)", "def feature(board: chess.Board) -> float:\n    'Counts the number of pieces that can be captured in one move by the opponent.'\n    opponent_pieces = len([square for square in board.piece_map() if board.piece_at(square).color == (chess.WHITE if board.turn else chess.BLACK) and board.is_attacked_by(not board.turn, square)])\n    return float(opponent_pieces)", "def feature(board: chess.Board) -> float:\n    'Calculates the square control as the difference in controlled squares by both players.'\n    white_control = sum(1 for square in chess.SQUARES if board.is_attacked_by(chess.WHITE, square))\n    black_control = sum(1 for square in chess.SQUARES if board.is_attacked_by(chess.BLACK, square))\n    result = white_control - black_control\n    return float(result)", "def feature(board: chess.Board) -> float:\n    'Measures material imbalance factoring in piece values.'\n    piece_values = {chess.PAWN: 100, chess.KNIGHT: 320, chess.BISHOP: 330, chess.ROOK: 500, chess.QUEEN: 900, chess.KING: float('inf')}\n    material_balance = sum(piece_values[board.piece_at(square).piece_type] if board.piece_at(square).color == chess.WHITE else -piece_values[board.piece_at(square).piece_type] for square in board.piece_map())\n    return float(material_balance)", "def feature(board: chess.Board) -> float:\n    'Assess king safety based on the number of attacking squares around the enemy king.'\n    enemy_king_square = next((s for s in board.piece_map() if board.piece_at(s).piece_type == chess.KING and board.piece_at(s).color == (chess.WHITE if not board.turn else chess.BLACK)), None)\n    if enemy_king_square is not None:\n        attacking_squares = len(board.attackers(not board.turn, enemy_king_square))\n        return float(attacking_squares)\n    return 0.0", "def feature(board: chess.Board) -> float:\n    'Evaluates the distribution of pieces across ranks for piece development.'\n    piece_distribution = [0] * 8\n    for square in board.piece_map():\n        piece_distribution[chess.square_rank(square)] += 1\n    return float(max(piece_distribution) - min(piece_distribution))  # Difference between max and min ranks with pieces", "def feature(board: chess.Board) -> float:\n    \"Calculates the total value of pieces that are currently unprotected.\"\n    unprotected_value = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == board.turn and not board.is_attacked_by(not board.turn, square):\n            unprotected_value += piece.piece_type\n    return float(unprotected_value)", "def feature(board: chess.Board) -> float:\n    \"Measures the mobility advantage by comparing the number of legal moves for both players.\"\n    white_moves = sum(1 for _ in board.legal_moves if board.turn)\n    black_moves = sum(1 for _ in board.legal_moves if not board.turn)\n    return float(white_moves - black_moves)", "def feature(board: chess.Board) -> float:\n    \"Evaluates the center control by counting pieces on the central squares.\"\n    central_squares = [chess.D4, chess.D5, chess.E4, chess.E5]\n    control_count = sum(1 for square in central_squares if board.piece_at(square) is not None)\n    return float(control_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the imbalance of pawn structure by counting doubled, isolated, and backward pawns.\"\n    pawn_structure_score = 0\n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.PAWN:\n            # Check for doubled pawns\n            if board.piece_at(square - 8) == piece: # Check for another pawn directly above\n                pawn_structure_score -= 1\n            if board.piece_at(square + 8) == piece: # Check for another pawn directly below\n                pawn_structure_score -= 1\n            # Check for isolated pawns\n            if (board.piece_at(square - 1) is None and board.piece_at(square + 1) is None):\n                pawn_structure_score -= 1\n    return float(pawn_structure_score)", "def feature(board: chess.Board) -> float:\n    \"Measures king safety by counting the number of attacking pieces around the opponent's king.\"\n    opponent_king_square = chess.KING if board.turn == chess.BLACK else chess.KING\n    attacker_count = sum(1 for square in chess.SQUARES if board.is_attacked_by(not board.turn, square))\n    return float(attacker_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the average piece distance from the opponent's king.\"\n    opponent_king_square = next(sq for sq, p in board.piece_map().items() if p.piece_type == chess.KING and p.color != board.turn)\n    total_distance = sum(chess.square_distance(sq, opponent_king_square) for sq, piece in board.piece_map().items() if piece.color == board.turn)\n    piece_count = len([p for p in board.piece_map().values() if p.color == board.turn])\n    return float(total_distance / piece_count) if piece_count else 0.0", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces attacking the opponent's king.\"\n    opponent_king_square = next(sq for sq, p in board.piece_map().items() if p.piece_type == chess.KING and p.color != board.turn)\n    attacking_pieces = board.attackers(board.turn, opponent_king_square)\n    return float(len(attacking_pieces))", "def feature(board: chess.Board) -> float:\n    \"Measures how many minor pieces (knights and bishops) each player has.\"\n    minor_piece_count = sum(1 for piece in board.piece_map().values() if piece.piece_type in {chess.KNIGHT, chess.BISHOP} and piece.color == board.turn)\n    return float(minor_piece_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the control of open files by counting the rooks on those files.\"\n    open_file_count = 0\n    for file in range(8):\n        if all(board.piece_at(chess.square(file, rank)) is None for rank in range(8)):  # Open file\n            open_file_count += sum(1 for rank in range(8) if board.piece_at(chess.square(file, rank)) and board.piece_at(chess.square(file, rank)).piece_type == chess.ROOK)\n    return float(open_file_count)", "def feature(board: chess.Board) -> float:\n    \"Measures the stability of the player's position by counting the number of fianchettoed bishops.\"\n    fianchetto_bishops = sum(1 for square, piece in board.piece_map().items() if piece.piece_type == chess.BISHOP and (chess.square_file(square) in (2, 5) and chess.square_rank(square) in (0, 7)))\n    return float(fianchetto_bishops)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of squares controlled by the opponent's pieces.\"\n    opponent_controlled_squares = set()\n    for square, piece in board.piece_map().items():\n        if piece.color != board.turn:\n            # Get all squares this piece attacks\n            for move in board.legal_moves:\n                if move.from_square == square:\n                    opponent_controlled_squares.add(move.to_square)\n    return float(len(opponent_controlled_squares))", "def feature(board: chess.Board) -> float:\n    \"Counts the total number of pieces on the board.\"\n    total_pieces = len(board.piece_map())\n    return float(total_pieces)", "def feature(board: chess.Board) -> float:\n    \"Measures the maximum distance from the center square for all pieces.\"\n    max_distance = 0\n    center_squares = [chess.E4, chess.E5, chess.D4, chess.D5]\n    for square in board.piece_map():\n        distance = min(chess.square_distance(square, cs) for cs in center_squares)\n        max_distance = max(max_distance, distance)\n    return float(max_distance)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of moves available for the player in turn.\"\n    move_count = len(list(board.legal_moves))\n    return float(move_count)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of squares attacked by the current player's pieces.\"\n    controlled_squares = set()\n    for square in board.piece_map():\n        piece = board.piece_at(square)\n        if piece.color == board.turn:\n            for move in board.legal_moves:\n                if move.from_square == square:\n                    controlled_squares.add(move.to_square)\n    return float(len(controlled_squares))", "def feature(board: chess.Board) -> float:\n    \"Calculates the difference between the number of major pieces for both sides.\"\n    white_major_count = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE and piece.piece_type in (chess.ROOK, chess.QUEEN))\n    black_major_count = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK and piece.piece_type in (chess.ROOK, chess.QUEEN))\n    return float(white_major_count - black_major_count)", "def feature(board: chess.Board) -> float:\n    \"Measures how many pieces of the current player are attacked.\"\n    attacked_count = sum(1 for square in board.piece_map() if board.is_attacked_by(not board.turn, square))\n    return float(attacked_count)", "def feature(board: chess.Board) -> float:\n    'Counts the total number of squares that can be attacked by the current player.'\n    attackable_squares = set()\n    for piece in board.piece_map().values():\n        if piece.color == board.turn:\n            for move in board.legal_moves:\n                if move.from_square == piece.piece_type:\n                    attackable_squares.add(move.to_square)\n    return float(len(attackable_squares))", "def feature(board: chess.Board) -> float:\n    'Measures the number of pieces that are pinned by the opponent\u2019s pieces.'\n    pinned_pieces = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == board.turn:\n            if board.is_attacked_by(not board.turn, square):\n                if board.attackers(not board.turn, square):\n                    pinned_pieces += 1\n    return float(pinned_pieces)", "def feature(board: chess.Board) -> float:\n    'Calculates the total value of all pieces currently on the board.'\n    piece_value = {chess.PAWN: 100, chess.KNIGHT: 300, chess.BISHOP: 330, chess.ROOK: 500, chess.QUEEN: 900, chess.KING: 0}\n    total_value = sum(piece_value[piece.piece_type] for piece in board.piece_map().values())\n    return float(total_value)", "def feature(board: chess.Board) -> float:\n    'Calculates the mobility of the current side based on the number of legal moves available.'\n    mobility = len(list(board.legal_moves))\n    return float(mobility)", "def feature(board: chess.Board) -> float:\n    'Measures the number of open files for both players based on the pawn structure.'\n    open_files = len([f for f in range(8) if not any(board.piece_at(chess.square(file, rank)) == chess.PAWN for rank in range(8) for file in [f])])\n    return float(open_files)", "def feature(board: chess.Board) -> float:\n    'Counts the number of rooks located on the back rank.'\n    back_rank_rooks = sum(1 for square, piece in board.piece_map().items() if piece.piece_type == chess.ROOK and \n                          ((piece.color == chess.WHITE and chess.square_rank(square) == 7) or\n                           (piece.color == chess.BLACK and chess.square_rank(square) == 0)))\n    return float(back_rank_rooks)", "def feature(board: chess.Board) -> float:\n    'Calculates the king distance to the nearest opponent piece.'\n    king_square = next(square for square, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color == board.turn)\n    opponent_pieces = [square for square, piece in board.piece_map().items() if piece.color != board.turn]\n    if not opponent_pieces:\n        return float('inf')\n    distances = [chess.square_distance(king_square, opp_sq) for opp_sq in opponent_pieces]\n    return float(min(distances))", "def feature(board: chess.Board) -> float:\n    'Measures the number of isolated pawns for the current player.'\n    isolated_pawns = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == board.turn and piece.piece_type == chess.PAWN:\n            file = chess.square_file(square)\n            if (board.piece_at(chess.square(file - 1, chess.square_rank(square))) is None and\n                board.piece_at(chess.square(file + 1, chess.square_rank(square))) is None):\n                isolated_pawns += 1\n    return float(isolated_pawns)", "def feature(board: chess.Board) -> float:\n    'Counts the number of central squares controlled by the current player.'\n    central_squares = [chess.E4, chess.E5, chess.D4, chess.D5]\n    control_count = sum(1 for square in central_squares if board.is_attacked_by(board.turn, square))\n    return float(control_count)", "def feature(board: chess.Board) -> float:\n    \"Measures the difference in material value between the two players.\"\n    material_white = sum(piece.piece_type for piece in board.piece_map().values() if piece.color == chess.WHITE)\n    material_black = sum(piece.piece_type for piece in board.piece_map().values() if piece.color == chess.BLACK)\n    return float(material_white - material_black)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces that are attacked but not defended.\"\n    attacked_unprotected = 0\n    for square, piece in board.piece_map().items():\n        if board.is_attacked_by(chess.WHITE if piece.color == chess.BLACK else chess.BLACK, square):\n            if not any(board.is_attacked_by(piece.color, attacker) for attacker in board.attackers(piece.color, square)):\n                attacked_unprotected += 1\n    return float(attacked_unprotected)", "def feature(board: chess.Board) -> float:\n    \"Calculates the king safety score based on the number of squares around the king that are controlled by the opponent.\"\n    king_square = board.king(chess.WHITE) if board.turn else board.king(chess.BLACK)\n    unsafe_neighbors = sum(1 for square in chess.SQUARES if board.is_attacked_by(chess.WHITE if board.turn else chess.BLACK, square))\n    return float(unsafe_neighbors)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces in the center squares (d4, e4, d5, e5).\"\n    center_squares = [chess.D4, chess.E4, chess.D5, chess.E5]\n    center_piece_count = sum(1 for square in center_squares if board.piece_at(square) is not None)\n    return float(center_piece_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the material balance favoring the side with the most attacking pieces.\"\n    attacking_white = sum(1 for square in board.piece_map() if board.is_attacked_by(chess.WHITE, square) and board.piece_at(square).color == chess.WHITE)\n    attacking_black = sum(1 for square in board.piece_map() if board.is_attacked_by(chess.BLACK, square) and board.piece_at(square).color == chess.BLACK)\n    return float(attacking_white - attacking_black)", "def feature(board: chess.Board) -> float:\n    \"Measures the total number of pawns for each side and their positions relative to promotion.\"\n    white_pawns = sum(1 for square, piece in board.piece_map().items() if piece.color == chess.WHITE and piece.piece_type == chess.PAWN and chess.square_rank(square) < 7)\n    black_pawns = sum(1 for square, piece in board.piece_map().items() if piece.color == chess.BLACK and piece.piece_type == chess.PAWN and chess.square_rank(square) > 0)\n    return float(white_pawns - black_pawns)", "def feature(board: chess.Board) -> float:\n    \"Counts the total number of defended squares by each team's pieces.\"\n    defended_white = sum(1 for square in chess.SQUARES if board.is_attacked_by(chess.WHITE, square))\n    defended_black = sum(1 for square in chess.SQUARES if board.is_attacked_by(chess.BLACK, square))\n    return float(defended_white - defended_black)", "def feature(board: chess.Board) -> float:\n    \"Checks if either side is in check and returns a value based on that.\"\n    if board.is_check():\n        return 1.0 if board.turn else -1.0\n    return 0.0", "def feature(board: chess.Board) -> float:\n    \"Calculates the total value of pieces controlled by the current player.\"\n    piece_value = {chess.PAWN: 100, chess.KNIGHT: 320, chess.BISHOP: 330, chess.ROOK: 500, chess.QUEEN: 900, chess.KING: 20000}\n    total_value = sum(piece_value[piece.piece_type] for piece in board.piece_map().values() if piece.color == board.turn)\n    return float(total_value)", "def feature(board: chess.Board) -> float:\n    \"Measures the piece activity by calculating the number of squares each piece can move to.\"\n    activity_score = 0\n    for piece in board.piece_map().values():\n        if piece.color == board.turn:\n            activity_score += len(list(board.legal_moves))  # Count of potential moves for this piece\n    return float(activity_score)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of double attacked pieces for the current player.\"\n    double_attacked = 0\n    for square in board.piece_map():\n        piece = board.piece_at(square)\n        if piece and piece.color == board.turn:\n            attacker_count = len(board.attackers(not board.turn, square))\n            if attacker_count > 1:\n                double_attacked += 1\n    return float(double_attacked)", "def feature(board: chess.Board) -> float:\n    \"Measures the central control by counting pieces on central squares (d4, d5, e4, e5).\"\n    central_squares = [chess.D4, chess.D5, chess.E4, chess.E5]\n    central_control = sum(1 for square in central_squares if board.piece_at(square) and board.piece_at(square).color == board.turn)\n    return float(central_control)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of hanging pieces for the current player.\"\n    hanging_count = 0\n    for square in board.piece_map():\n        piece = board.piece_at(square)\n        if piece and piece.color == board.turn:\n            if not board.attackers(not board.turn, square):\n                hanging_count += 1\n    return float(hanging_count)", "def feature(board: chess.Board) -> float:\n    \"Measures the material disparity by evaluating the difference in total material value of both players.\"\n    piece_value = {chess.PAWN: 100, chess.KNIGHT: 320, chess.BISHOP: 330, chess.ROOK: 500, chess.QUEEN: 900, chess.KING: 20000}\n    white_value = sum(piece_value[piece.piece_type] for piece in board.piece_map().values() if piece.color == chess.WHITE)\n    black_value = sum(piece_value[piece.piece_type] for piece in board.piece_map().values() if piece.color == chess.BLACK)\n    return float(white_value - black_value)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of squares that are defended by pieces of the current player.\"\n    defended_squares = set()\n    for square in board.piece_map():\n        piece = board.piece_at(square)\n        if piece and piece.color == board.turn:\n            for move in board.legal_moves:\n                if move.from_square == square:\n                    defended_squares.add(move.to_square)\n    return float(len(defended_squares))", "def feature(board: chess.Board) -> float:\n    \"Measures the ratio of pieces actively threatening opponent's pieces.\"\n    attackers_count = sum(1 for square in board.piece_map() if board.is_attacked_by(not board.turn, square))\n    return float(attackers_count) / len(board.piece_map()) if board.piece_map() else 0.0", "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in mobility between the two players by counting legal moves.\"\n    white_moves = len(list(board.legal_moves)) if board.turn else 0\n    black_moves = len(list(board.legal_moves)) if not board.turn else 0\n    return float(white_moves - black_moves)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces that are directly attacking the opponent's king.\"\n    king_square = next((sq for sq, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color != board.turn), None)\n    return float(len(board.attackers(not board.turn, king_square))) if king_square else 0.0", "def feature(board: chess.Board) -> float:\n    \"Measures the unblocked paths for major pieces to assess mobility.\"\n    major_pieces = [chess.ROOK, chess.QUEEN, chess.BISHOP]\n    mobility = 0\n    for square, piece in board.piece_map().items():\n        if piece.piece_type in major_pieces and piece.color == board.turn:\n            for move in board.legal_moves:\n                if move.from_square == square:\n                    mobility += 1\n    return float(mobility)", "def feature(board: chess.Board) -> float:\n    \"Calculates the presence of doubled pawns, which may represent a structural weakness.\"\n    pawn_count = {chess.WHITE: 0, chess.BLACK: 0}\n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.PAWN:\n            file = chess.square_file(square)\n            pawn_count[piece.color] += 1\n    doubled_pawns = abs(pawn_count[chess.WHITE] - pawn_count[chess.BLACK])\n    return float(doubled_pawns)", "def feature(board: chess.Board) -> float:\n    \"Measures the total number of squares attacked by pieces of the current player.\"\n    attacked_squares = set()\n    for square, piece in board.piece_map().items():\n        if piece.color == board.turn:\n            attacked_squares.update(board.attacks(square))\n    return float(len(attacked_squares))", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces that have direct lines of attack towards the king.\"\n    king_square = next((sq for sq, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color == board.turn), None)\n    if king_square is None:\n        return 0.0\n    direct_attackers = sum(1 for square in board.piece_map() if board.is_attacked_by(not board.turn, square) and board.piece_at(square).piece_type in (chess.ROOK, chess.QUEEN))\n    return float(direct_attackers)", "def feature(board: chess.Board) -> float:\n    \"Measures the distance from the king to the nearest enemy piece as an indicator of safety.\"\n    king_square = next((sq for sq, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color == board.turn), None)\n    if king_square is None:\n        return float('inf')\n    \n    nearest_enemy_distance = min((chess.square_distance(king_square, square) for square in board.piece_map() if board.piece_at(square).color != board.turn), default=float('inf'))\n    return float(nearest_enemy_distance) if nearest_enemy_distance != float('inf') else 0.0\n\ndef piece_value(piece):\n    \"Returns the value of the given chess piece.\"\n    values = {chess.PAWN: 100, chess.KNIGHT: 320, chess.BISHOP: 330, chess.ROOK: 500, chess.QUEEN: 900, chess.KING: 0}\n    return values.get(piece.piece_type, 0)", "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in connected pieces for both players.\"\n    white_connected = sum(1 for square, piece in board.piece_map().items() if piece.color == chess.WHITE and len(board.attackers(chess.BLACK, square)) == 0)\n    black_connected = sum(1 for square, piece in board.piece_map().items() if piece.color == chess.BLACK and len(board.attackers(chess.WHITE, square)) == 0)\n    return float(white_connected - black_connected)", "def feature(board: chess.Board) -> float:\n    \"Measures the total number of pawns on the board.\"\n    total_pawns = sum(1 for piece in board.piece_map().values() if piece.piece_type == chess.PAWN)\n    return float(total_pawns)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of attacking pieces for both players.\"\n    white_attackers = sum(len(board.attackers(chess.WHITE, square)) for square in board.piece_map() if board.piece_map()[square].color == chess.WHITE)\n    black_attackers = sum(len(board.attackers(chess.BLACK, square)) for square in board.piece_map() if board.piece_map()[square].color == chess.BLACK)\n    return float(white_attackers - black_attackers)", "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in piece value across the board positions.\"\n    value_map = {chess.PAWN: 100, chess.KNIGHT: 300, chess.BISHOP: 300, chess.ROOK: 500, chess.QUEEN: 900, chess.KING: 0}\n    total_value = sum(value_map[piece.piece_type] for piece in board.piece_map().values())\n    return float(total_value)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of pieces pinned by the opponent.\"\n    pinned_count = sum(1 for square in board.piece_map() if board.is_attacked_by(chess.BLACK if board.piece_map()[square].color == chess.WHITE else chess.WHITE, square))\n    return float(pinned_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in the number of squares attacked by pieces of both players.\"\n    white_attacked_squares = len(set(square for square in chess.SQUARES if board.is_attacked_by(chess.WHITE, square)))\n    black_attacked_squares = len(set(square for square in chess.SQUARES if board.is_attacked_by(chess.BLACK, square)))\n    return float(white_attacked_squares - black_attacked_squares)", "def feature(board: chess.Board) -> float:\n    \"Evaluates the balance of the board by counting the number of loose pieces for both sides.\"\n    white_loose_pieces = sum(1 for square in board.piece_map() if board.piece_map()[square].color == chess.WHITE and len(board.attackers(chess.BLACK, square)) == 0)\n    black_loose_pieces = sum(1 for square in board.piece_map() if board.piece_map()[square].color == chess.BLACK and len(board.attackers(chess.WHITE, square)) == 0)\n    return float(white_loose_pieces - black_loose_pieces)", "def feature(board: chess.Board) -> float:\n    \"Measures the material imbalance by calculating the difference in material strength between the two sides.\"\n    material_values = {\n        chess.PAWN: 100,\n        chess.KNIGHT: 320,\n        chess.BISHOP: 330,\n        chess.ROOK: 500,\n        chess.QUEEN: 900,\n        chess.KING: 20000\n    }\n    white_material = sum(material_values[piece.piece_type] for piece in board.piece_map().values() if piece.color == chess.WHITE)\n    black_material = sum(material_values[piece.piece_type] for piece in board.piece_map().values() if piece.color == chess.BLACK)\n    return float(white_material - black_material)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces that are pinned against the king by their opponents.\"\n    pinned_count = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == board.turn:\n            attackers = board.attackers(not board.turn, square)\n            if any(board.is_attacked_by(not board.turn, square) for square in attackers):\n                if square in board.attackers(board.turn, board.king(board.turn)):\n                    pinned_count += 1\n    return float(pinned_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the total number of knights on the board as a measure of tactical potential.\"\n    knight_count = sum(1 for piece in board.piece_map().values() if piece.piece_type == chess.KNIGHT)\n    return float(knight_count)", "def feature(board: chess.Board) -> float:\n    \"Measures the distance of the king to the center of the board, indicating its activity.\"\n    king_square = board.king(board.turn)\n    center_squares = [chess.E4, chess.E5, chess.D4, chess.D5]\n    king_distance = min(chess.square_distance(king_square, sq) for sq in center_squares)\n    return float(king_distance)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces that are defending each other's squares, contributing to formation strength.\"\n    defending_count = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == board.turn:\n            for target in board.legal_moves:\n                if target.from_square == square and board.piece_at(target.to_square) and board.is_attacked_by(board.turn, target.to_square):\n                    defending_count += 1\n    return float(defending_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of squares occupied by pieces of the current player to assess position density.\"\n    occupied_count = sum(1 for piece in board.piece_map().values() if piece.color == board.turn)\n    return float(occupied_count)", "def feature(board: chess.Board) -> float:\n    \"Evaluates the king's exposure by counting the number of direct threats against the king's square.\"\n    king_square = board.king(board.turn)\n    threats = len(board.attackers(not board.turn, king_square))\n    return float(threats)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of squares controlled by the opponent.\"\n    controlled_squares = set()\n    for piece in board.piece_map().values():\n        if piece.color == (chess.WHITE if board.turn else chess.BLACK):\n            continue\n        controlled_squares.update(board.legal_moves)\n    return float(len(controlled_squares))", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pawns remaining for each side and returns their difference.\"\n    white_pawns = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE and piece.piece_type == chess.PAWN)\n    black_pawns = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK and piece.piece_type == chess.PAWN)\n    return float(white_pawns - black_pawns)", "def feature(board: chess.Board) -> float:\n    \"Calculates the activity score based on the distance of each piece from the center of the board.\"\n    central_squares = [chess.D4, chess.D5, chess.E4, chess.E5]\n    total_distance = 0\n    piece_count = 0\n    for piece in board.piece_map().values():\n        if piece.color == (chess.WHITE if board.turn else chess.BLACK):\n            piece_count += 1\n            piece_square = next(sq for sq, p in board.piece_map().items() if p == piece)\n            total_distance += sum(chess.square_distance(piece_square, sq) for sq in central_squares)\n    if piece_count == 0:\n        return 0.0\n    return total_distance / piece_count", "def feature(board: chess.Board) -> float:\n    \"Measures the proportion of active pieces on the board, defined as having legal moves.\"\n    active_piece_count = sum(1 for piece in board.piece_map().values() if board.legal_moves)\n    total_piece_count = len(board.piece_map())\n    return float(active_piece_count / total_piece_count) if total_piece_count > 0 else 0.0", "def feature(board: chess.Board) -> float:\n    \"Evaluates the presence of major pieces (Queens and Rooks) remaining on the board.\"\n    major_piece_count = sum(1 for piece in board.piece_map().values() if piece.piece_type in {chess.QUEEN, chess.ROOK})\n    return float(major_piece_count)", "def feature(board: chess.Board) -> float:\n    \"Determines the impact of the position's pawn structure, counting doubled pawns.\"\n    doubled_pawns = 0\n    files = {}\n    for piece in board.piece_map().values():\n        if piece.piece_type == chess.PAWN:\n            file = chess.square_file(next(sq for sq, p in board.piece_map().items() if p == piece))\n            files[file] = files.get(file, 0) + 1\n    return float(sum(count > 1 for count in files.values()))", "def feature(board: chess.Board) -> float:\n    \"Counts the potential threats to the opponent's major pieces (Queens and Rooks).\"\n    threats = 0\n    for sq, piece in board.piece_map().items():\n        if piece.piece_type in {chess.QUEEN, chess.ROOK} and piece.color == (chess.WHITE if board.turn else chess.BLACK):\n            threats += len(board.attackers(not board.turn, sq))\n    return float(threats)", "def feature(board: chess.Board) -> float:\n    \"Measures the activity of major pieces (rooks, queens) based on their legal moves.\"\n    major_piece_count = 0\n    for piece in [chess.ROOK, chess.QUEEN]:\n        major_piece_count += sum(1 for _ in board.legal_moves if board.piece_at(_.from_square) and board.piece_at(_.from_square).piece_type == piece)\n    return float(major_piece_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of pieces attacking the opponent's king.\"\n    enemy_king_square = next(sq for sq, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color == chess.BLACK)\n    attack_count = sum(1 for sq in board.piece_map() if board.is_attacked_by(chess.WHITE, sq) and board.piece_map()[sq].color == chess.WHITE)\n    return float(attack_count)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces that can access the enemy's back rank (ranks 8 for white, 1 for black).\"\n    back_rank = 0\n    for sq, piece in board.piece_map().items():\n        if piece.color == chess.WHITE and chess.square_rank(sq) == 7:\n            back_rank += 1\n        elif piece.color == chess.BLACK and chess.square_rank(sq) == 0:\n            back_rank += 1\n    return float(back_rank)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of doubled pawns for both sides.\"\n    white_doubled = sum(1 for file in range(8) if len([sq for sq in board.piece_map() if chess.square_file(sq) == file and board.piece_map()[sq].piece_type == chess.PAWN and board.piece_map()[sq].color == chess.WHITE]) > 1)\n    black_doubled = sum(1 for file in range(8) if len([sq for sq in board.piece_map() if chess.square_file(sq) == file and board.piece_map()[sq].piece_type == chess.PAWN and board.piece_map()[sq].color == chess.BLACK]) > 1)\n    return float(white_doubled - black_doubled)", "def feature(board: chess.Board) -> float:\n    \"Calculates the material advantage by comparing points of both sides.\"\n    piece_values = {\n        chess.PAWN: 100, chess.KNIGHT: 300, chess.BISHOP: 320,\n        chess.ROOK: 500, chess.QUEEN: 900, chess.KING: 0\n    }\n    white_value = sum(piece_values[piece.piece_type] for piece in board.piece_map().values() if piece.color == chess.WHITE)\n    black_value = sum(piece_values[piece.piece_type] for piece in board.piece_map().values() if piece.color == chess.BLACK)\n    return float(white_value - black_value)", "def feature(board: chess.Board) -> float:\n    \"Measures pawn structure by counting isolated pawns for each side.\"\n    isolated_pawn_count = 0\n    for sq, piece in board.piece_map().items():\n        if piece.color == chess.WHITE and piece.piece_type == chess.PAWN:\n            if (sq - 1) not in board.piece_map() and (sq + 1) not in board.piece_map():\n                isolated_pawn_count += 1\n        elif piece.color == chess.BLACK and piece.piece_type == chess.PAWN:\n            if (sq - 1) not in board.piece_map() and (sq + 1) not in board.piece_map():\n                isolated_pawn_count -= 1\n    return float(isolated_pawn_count)", "def feature(board: chess.Board) -> float:\n    \"Measures the control of central squares (d4, d5, e4, e5) for both sides.\"\n    central_squares = [chess.parse_square('d4'), chess.parse_square('d5'), chess.parse_square('e4'), chess.parse_square('e5')]\n    white_control = sum(1 for sq in central_squares if board.is_attacked_by(chess.WHITE, sq))\n    black_control = sum(1 for sq in central_squares if board.is_attacked_by(chess.BLACK, sq))\n    return float(white_control - black_control)", "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in the number of pawns between both players.\"\n    white_pawns = sum(1 for piece in board.piece_map().values() if piece.piece_type == chess.PAWN and piece.color == chess.WHITE)\n    black_pawns = sum(1 for piece in board.piece_map().values() if piece.piece_type == chess.PAWN and piece.color == chess.BLACK)\n    return float(white_pawns - black_pawns)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces attacking the opponent's king.\"\n    king_square = next((square for square, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color == (chess.WHITE if board.turn else chess.BLACK)), None)\n    if king_square is None:\n        return 0.0\n    attackers = board.attackers(chess.WHITE if board.turn else chess.BLACK, king_square)\n    return float(len(attackers))", "def feature(board: chess.Board) -> float:\n    \"Calculates the total number of squares controlled by all pieces of the current player.\"\n    controlled_squares = set()\n    for square, piece in board.piece_map().items():\n        if piece.color == board.turn:\n            controlled_squares.update(board.attacks(square))\n    return float(len(controlled_squares))", "def feature(board: chess.Board) -> float:\n    \"Measures the number of pieces that are pinned.\"\n    pinned_pieces = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == board.turn:\n            for enemy_square in board.attackers(not board.turn, square):\n                if board.is_check() and board.piece_at(enemy_square).color != piece.color:\n                    pinned_pieces += 1\n                    break\n    return float(pinned_pieces)", "def feature(board: chess.Board) -> float:\n    \"Calculates the average material value of pieces per side.\"\n    piece_values = {\n        chess.PAWN: 100,\n        chess.KNIGHT: 300,\n        chess.BISHOP: 300,\n        chess.ROOK: 500,\n        chess.QUEEN: 900,\n        chess.KING: 0\n    }\n    white_material = sum(piece_values[piece.piece_type] for piece in board.piece_map().values() if piece.color == chess.WHITE)\n    black_material = sum(piece_values[piece.piece_type] for piece in board.piece_map().values() if piece.color == chess.BLACK)\n    total_material = white_material + black_material\n    return float((white_material - black_material) / (total_material + 1))  # Avoid division by zero", "def feature(board: chess.Board) -> float:\n    \"Counts the total number of safe squares for the current player's pieces.\"\n    safe_squares = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == board.turn:\n            if not board.is_attacked_by(not board.turn, square):\n                safe_squares += 1\n    return float(safe_squares)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of backward pawns for the current player.\"\n    backward_pawns = 0\n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.PAWN and piece.color == board.turn:\n            if (board.turn == chess.WHITE and square < chess.A7) or (board.turn == chess.BLACK and square > chess.A2):\n                if not any(board.piece_at(sq) and board.piece_at(sq).color == board.turn for sq in range(square + 8, 64 if board.turn == chess.WHITE else -1, -8)):\n                    backward_pawns += 1\n    return float(backward_pawns)", "def feature(board: chess.Board) -> float:\n    \"Measures the mobility of the current player by calculating the total legal moves.\"\n    return float(len(list(board.legal_moves)))", "def feature(board: chess.Board) -> float:\n    \"Calculates the average distance of pieces from their respective enemy king.\"\n    king_square = next((square for square, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color != board.turn), None)\n    if king_square is None:\n        return 0.0\n    total_distance = 0\n    piece_count = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == board.turn:\n            total_distance += chess.square_distance(square, king_square)\n            piece_count += 1\n    return float(total_distance / (piece_count if piece_count > 0 else 1))", "def feature(board: chess.Board) -> float:\n    \"Evaluates mobility by counting the maximum number of legal moves for any piece.\"\n    max_moves = max(len(list(board.legal_moves)) for piece in board.piece_map().values())\n    return float(max_moves)", "def feature(board: chess.Board) -> float:\n    \"Calculates the average material value of remaining pieces for each player.\"\n    material_values = {chess.PAWN: 100, chess.KNIGHT: 320, chess.BISHOP: 330, chess.ROOK: 500, chess.QUEEN: 900, chess.KING: 20000}\n    \n    white_material = sum(material_values[piece.piece_type] for piece in board.piece_map().values() if piece.color == chess.WHITE)\n    black_material = sum(material_values[piece.piece_type] for piece in board.piece_map().values() if piece.color == chess.BLACK)\n    \n    return float(white_material / max(1, len(board.piece_map().keys())) - black_material / max(1, len(board.piece_map().keys())))", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pawn structures (isolated and connected pawns).\"\n    pawn_clumps = 0\n    for file in range(8):\n        connected = 0\n        for rank in range(8):\n            pawn = board.piece_at(chess.square(file, rank))\n            if pawn and pawn.piece_type == chess.PAWN:\n                connected += 1\n            else:\n                if connected > 0:\n                    pawn_clumps += 1\n                    connected = 0\n        if connected > 0:\n            pawn_clumps += 1\n    return float(pawn_clumps)", "def feature(board: chess.Board) -> float:\n    \"Evaluates king safety by counting attackers on both kings.\"\n    white_king_square = next((sq for sq, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color == chess.WHITE), None)\n    black_king_square = next((sq for sq, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color == chess.BLACK), None)\n    \n    white_attacks = len(board.attackers(chess.BLACK, white_king_square)) if white_king_square else 0\n    black_attacks = len(board.attackers(chess.WHITE, black_king_square)) if black_king_square else 0\n    \n    return float(white_attacks - black_attacks)", "def feature(board: chess.Board) -> float:\n    \"Measures the central control by counting pieces in the center squares.\"\n    center_squares = [chess.E4, chess.E5, chess.D4, chess.D5]\n    center_count = sum(1 for sq in center_squares if board.piece_at(sq) is not None)\n    \n    return float(center_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the distance of the queens to the opponent's king.\"\n    white_queen_square = next((sq for sq, piece in board.piece_map().items() if piece.piece_type == chess.QUEEN and piece.color == chess.WHITE), None)\n    black_king_square = next((sq for sq, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color == chess.BLACK), None)\n    \n    if white_queen_square and black_king_square:\n        return float(chess.square_distance(white_queen_square, black_king_square))\n    return float(0)", "def feature(board: chess.Board) -> float:\n    \"Measures the average distance of all pieces to the center of the board.\"\n    total_distance = 0\n    piece_count = 0\n    center_squares = [chess.E4, chess.E5, chess.D4, chess.D5]\n    \n    for sq, piece in board.piece_map().items():\n        if piece.color == chess.WHITE or piece.color == chess.BLACK:\n            total_distance += min(chess.square_distance(sq, center_sq) for center_sq in center_squares)\n            piece_count += 1\n\n    return float(total_distance / (piece_count or 1))", "def feature(board: chess.Board) -> float:\n    \"Counts the number of isolated pawns on the board.\"\n    isolated_pawns = 0\n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.PAWN:\n            file = chess.square_file(square)\n            rank = chess.square_rank(square)\n            if ((file > 0 and board.piece_at(chess.square(file - 1, rank)) is None) and \n                (file < 7 and board.piece_at(chess.square(file + 1, rank)) is None)):\n                isolated_pawns += 1\n    return float(isolated_pawns)", "def feature(board: chess.Board) -> float:\n    \"Evaluates the safety of the kings based on the number of attacking squares.\"\n    king_square = board.king(chess.WHITE) if board.turn else board.king(chess.BLACK)\n    attackers = len(board.attackers(chess.WHITE if board.turn else chess.BLACK, king_square))\n    return float(attackers)", "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in the number of pawns each player has.\"\n    white_pawns = sum(1 for piece in board.piece_map().values() if piece.piece_type == chess.PAWN and piece.color == chess.WHITE)\n    black_pawns = sum(1 for piece in board.piece_map().values() if piece.piece_type == chess.PAWN and piece.color == chess.BLACK)\n    return float(white_pawns - black_pawns)", "def feature(board: chess.Board) -> float:\n    \"Measures control of the center by counting pieces on central squares.\"\n    central_squares = [chess.D4, chess.D5, chess.E4, chess.E5]\n    center_control = sum(1 for square in central_squares if board.piece_at(square) and board.piece_at(square).color == (chess.WHITE if board.turn else chess.BLACK))\n    return float(center_control)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of pieces attacking the opponent's king.\"\n    opponent_king_square = board.king(chess.BLACK if board.turn else chess.WHITE)\n    attacking_pieces = sum(1 for square in board.piece_map() if board.is_attacked_by(chess.WHITE if board.turn else chess.BLACK, square) and board.piece_map()[square].color == (chess.WHITE if board.turn else chess.BLACK))\n    return float(attacking_pieces)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of minor pieces (knights and bishops) for both players.\"\n    minor_piece_count = sum(1 for piece in board.piece_map().values() if piece.piece_type in (chess.KNIGHT, chess.BISHOP))\n    return float(minor_piece_count)", "def feature(board: chess.Board) -> float:\n    \"Measures the mobility of the pieces by counting potential moves.\"\n    mobility_count = sum(1 for move in board.legal_moves)\n    return float(mobility_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the distance from the opponent's back rank for all pieces, assessing offensive potential.\"\n    total_distance = 0\n    for square, piece in board.piece_map().items():\n        if piece.color != (chess.WHITE if board.turn else chess.BLACK):\n            distance = chess.square_rank(square) - (0 if piece.color == chess.BLACK else 7)\n            total_distance += max(distance, 0)\n    return float(total_distance)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces that are pinned (cannot move without exposing their king).\"\n    pinned_count = 0\n    for square, piece in board.piece_map().items():\n        if board.is_attacked_by(chess.WHITE if board.turn else chess.BLACK, square):\n            # Check if the piece is pinned against its own king\n            king_square = board.king(piece.color)\n            if any(board.is_attacked_by(piece.color, king_square) for square in board.attackers(piece.color, square)):\n                pinned_count += 1\n    return float(pinned_count)", "def feature(board: chess.Board) -> float:\n    'Measures the total value of pieces on the board for each color.'\n    piece_values = {chess.PAWN: 100, chess.KNIGHT: 320, chess.BISHOP: 330, chess.ROOK: 500, chess.QUEEN: 900, chess.KING: 20000}\n    total_value = 0.0\n    for piece in board.piece_map().values():\n        total_value += piece_values[piece.piece_type] if piece.color == chess.WHITE else -piece_values[piece.piece_type]\n    return total_value", "def feature(board: chess.Board) -> float:\n    'Measures the difference in development of pieces, counting developed pieces.'\n    developed_white = sum(1 for square in board.piece_map() if board.piece_map()[square].color == chess.WHITE and chess.square_rank(square) >= 1)\n    developed_black = sum(1 for square in board.piece_map() if board.piece_map()[square].color == chess.BLACK and chess.square_rank(square) <= 6)\n    return float(developed_white - developed_black)", "def feature(board: chess.Board) -> float:\n    'Calculates the average distance of pieces from the center of the board for both players.'\n    center_squares = [chess.E4, chess.E5, chess.D4, chess.D5]\n    distance_white = sum(chess.square_distance(square, chess.E4) for square in board.piece_map() if board.piece_map()[square].color == chess.WHITE)\n    distance_black = sum(chess.square_distance(square, chess.E5) for square in board.piece_map() if board.piece_map()[square].color == chess.BLACK)\n    return float(distance_white - distance_black)", "def feature(board: chess.Board) -> float:\n    'Calculates the material imbalance considering only pawns.'\n    white_pawns = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE and piece.piece_type == chess.PAWN)\n    black_pawns = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK and piece.piece_type == chess.PAWN)\n    return float(white_pawns - black_pawns)", "def feature(board: chess.Board) -> float:\n    'Measures the potential threats based on the number of pieces attacking other pieces.'\n    attack_count = sum(len(board.attackers(color, square)) for color in [chess.WHITE, chess.BLACK] for square in board.piece_map() if board.piece_map()[square].color == color)\n    return float(attack_count)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces that are pinned.\"\n    pinned_count = 0\n    for square in board.piece_map():\n        piece = board.piece_at(square)\n        if piece and piece.color == board.turn:\n            for enemy_square in board.attackers(not board.turn, square):\n                if board.is_attacked_by(not board.turn, enemy_square):\n                    pinned_count += 1\n                    break\n    return float(pinned_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the central control by counting pieces on central squares.\"\n    central_squares = [chess.D4, chess.D5, chess.E4, chess.E5]\n    control_count = sum(1 for sq in central_squares if board.piece_at(sq) and board.piece_at(sq).color == board.turn)\n    return float(control_count)", "def feature(board: chess.Board) -> float:\n    \"Measures the total mobility of pieces by summing legal moves for each piece.\"\n    mobility = sum(len(list(board.legal_moves)) for square in board.piece_map())\n    return float(mobility)", "def feature(board: chess.Board) -> float:\n    \"Computes a score based on the total number of threats each side has.\"\n    white_threats = sum(1 for square in board.piece_map() if board.piece_at(square).color == chess.WHITE and board.is_attacked_by(chess.BLACK, square))\n    black_threats = sum(1 for square in board.piece_map() if board.piece_at(square).color == chess.BLACK and board.is_attacked_by(chess.WHITE, square))\n    return float(white_threats - black_threats)", "def feature(board: chess.Board) -> float:\n    \"Measures the distance of pieces from the opponent's back rank.\"\n    distance_sum = 0\n    for square in board.piece_map():\n        piece = board.piece_at(square)\n        if piece and piece.color == board.turn:\n            distance_sum += chess.square_rank(square) if piece.color == chess.WHITE else (7 - chess.square_rank(square))\n    return float(distance_sum)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of squares around the king that are protected.\"\n    king_square = next(square for square in board.piece_map() if board.piece_at(square).piece_type == chess.KING and board.piece_at(square).color == board.turn)\n    protected_squares = sum(1 for sq in chess.SQUARES if board.is_attacked_by(not board.turn, sq))\n    return float(protected_squares)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of doubled pawns on the board.\"\n    pawn_positions = {}\n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.PAWN:\n            file = chess.square_file(square)\n            if file in pawn_positions:\n                pawn_positions[file] += 1\n            else:\n                pawn_positions[file] = 1\n    doubled_pawns = sum(1 for count in pawn_positions.values() if count > 1)\n    return float(doubled_pawns)", "def feature(board: chess.Board) -> float:\n    \"Assesses the potential for back rank checkmate by counting unprotected pieces in the back rank.\"\n    back_rank_squares = [chess.A1, chess.B1, chess.C1, chess.D1, chess.E1, chess.F1, chess.G1, chess.H1] if board.turn == chess.WHITE else \\\n                        [chess.A8, chess.B8, chess.C8, chess.D8, chess.E8, chess.F8, chess.G8, chess.H8]\n    unprotected_count = sum(1 for sq in back_rank_squares if board.piece_at(sq) and \\\n                            not any(board.is_attacked_by(not board.turn, attack_sq) for attack_sq in board.attackers(not board.turn, sq)))\n    return float(unprotected_count)", "def feature(board: chess.Board) -> float:\n    \"Measures the potential of each side for material gain based on hanging pieces.\"\n    hanging_count = 0\n    for square in board.piece_map():\n        piece = board.piece_at(square)\n        if piece and piece.color == board.turn:\n            if board.is_attacked_by(not board.turn, square):\n                hanging_count += 1\n    return float(hanging_count)", "def feature(board: chess.Board) -> float:\n    \"Measures the total mobility of both players by counting unique squares to which pieces can move.\"\n    mobility_white = len({chess.square_name(move.to_square) for move in board.legal_moves if board.turn})\n    mobility_black = len({chess.square_name(move.to_square) for move in board.legal_moves if not board.turn})\n    return float(mobility_white - mobility_black)", "def feature(board: chess.Board) -> float:\n    \"Counts the total number of pieces on the board to evaluate congestion.\"\n    total_pieces = sum(1 for piece in board.piece_map().values())\n    return float(total_pieces)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of defended pawns for both players and returns the difference.\"\n    defended_pawns = 0\n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.PAWN:\n            attackers = board.attackers(piece.color, square)\n            if attackers:\n                defended_pawns += 1\n    return float(defended_pawns)", "def feature(board: chess.Board) -> float:\n    \"Calculates and returns the difference in active pieces between both players.\"\n    active_white = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE)\n    active_black = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK)\n    return float(active_white - active_black)", "def feature(board: chess.Board) -> float:\n    \"Measures how many squares are currently controlled by each player.\"\n    control_white = sum(1 for square in chess.SQUARES if board.is_attacked_by(chess.WHITE, square))\n    control_black = sum(1 for square in chess.SQUARES if board.is_attacked_by(chess.BLACK, square))\n    return float(control_white - control_black)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces that have no legal moves available.\"\n    immobile_pieces = sum(1 for square, piece in board.piece_map().items() if not any(move.from_square == square for move in board.legal_moves))\n    return float(immobile_pieces)", "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in the number of pairs of pieces that can attack each other.\"\n    attacking_pairs = 0\n    for square, piece in board.piece_map().items():\n        for target_square in board.attackers(not piece.color, square):\n            if board.piece_at(target_square) and board.piece_at(target_square).color != piece.color:\n                attacking_pairs += 1\n    return float(attacking_pairs)", "def feature(board: chess.Board) -> float:\n    \"Measures the distribution of pawns by evaluating their placement on the board.\"\n    pawn_distribution = 0\n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.PAWN:\n            pawn_distribution += (8 - chess.square_rank(square)) if piece.color == chess.WHITE else (chess.square_rank(square) + 1)\n    return float(pawn_distribution)", "def feature(board: chess.Board) -> float:\n    \"Measures the total value of pieces currently attacking the opponent's king.\"\n    attackers = sum(1 for square in board.attackers(chess.BLACK, chess.parse_square('e8')))  # Considering White's target\n    for move in board.legal_moves:\n        if board.piece_at(move.from_square) and board.piece_at(move.from_square).color == chess.WHITE:\n            attackers += 1\n    return float(attackers)", "def feature(board: chess.Board) -> float:\n    \"Measures the number of pieces each player has on the 7th rank.\"\n    white_seventh_rank = sum(1 for square in range(56, 64) if board.piece_at(square) and board.piece_at(square).color == chess.WHITE)\n    black_seventh_rank = sum(1 for square in range(0, 8) if board.piece_at(square) and board.piece_at(square).color == chess.BLACK)\n    return float(white_seventh_rank - black_seventh_rank)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces in the center four squares of the board.\"\n    center_squares = [chess.E4, chess.E5, chess.D4, chess.D5]\n    center_count = sum(1 for square in center_squares if board.piece_at(square) is not None)\n    return float(center_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the average piece value for the current player.\"\n    piece_values = {\n        chess.PAWN: 100,\n        chess.KNIGHT: 320,\n        chess.BISHOP: 330,\n        chess.ROOK: 500,\n        chess.QUEEN: 900,\n        chess.KING: 0\n    }\n    total_value = 0\n    piece_count = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == board.turn:\n            total_value += piece_values[piece.piece_type]\n            piece_count += 1\n    return float(total_value / piece_count) if piece_count > 0 else 0.0", "def feature(board: chess.Board) -> float:\n    \"Measures the distance of the farthest piece from the opponent's back rank.\"\n    opponent_back_rank = 0 if board.turn == chess.WHITE else 7\n    max_distance = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == board.turn:\n            distance = chess.square_rank(square) - opponent_back_rank\n            if distance > max_distance:\n                max_distance = distance\n    return float(max_distance)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pawns on the 6th rank.\"\n    sixth_rank_count = sum(1 for square in range(48, 56) if board.piece_at(square) and board.piece_at(square).piece_type == chess.PAWN)\n    return float(sixth_rank_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the total number of checks available for the current player's pieces.\"\n    check_count = sum(1 for move in board.legal_moves if board.gives_check(move))\n    return float(check_count)", "def feature(board: chess.Board) -> float:\n    \"Measures how many pawns each player has on the same file as their respective kings.\"\n    king_square = chess.parse_square('e1' if board.turn == chess.WHITE else 'e8')\n    same_file_pawn_count = 0\n    for square in range(0, 64):\n        piece = board.piece_at(square)\n        if piece and piece.piece_type == chess.PAWN and chess.square_file(square) == chess.square_file(king_square):\n            same_file_pawn_count += 1\n    return float(same_file_pawn_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates how many squares are controlled by each player's pieces.\"\n    white_control_count = sum(1 for square in chess.SQUARES if board.is_attacked_by(chess.WHITE, square))\n    black_control_count = sum(1 for square in chess.SQUARES if board.is_attacked_by(chess.BLACK, square))\n    return float(white_control_count - black_control_count)", "def feature(board: chess.Board) -> float:\n    \"Counts the total number of pieces on the board.\"\n    result = len(board.piece_map())\n    return float(result)", "def feature(board: chess.Board) -> float:\n    \"Measures the distance of the kings from the center of the board.\"\n    white_king_square = board.king(chess.WHITE)\n    black_king_square = board.king(chess.BLACK)\n    distance = (chess.square_distance(white_king_square, chess.E4) + \n                chess.square_distance(black_king_square, chess.E4))\n    return float(distance)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of isolated pawns on the board.\"\n    isolated_pawns = 0\n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.PAWN:\n            file = chess.square_file(square)\n            is_isolated = (not board.piece_at(chess.parse_square(chess.square_name(file - 1))) if file > 0 else True) and \\\n                          (not board.piece_at(chess.parse_square(chess.square_name(file + 1))) if file < 7 else True)\n            if is_isolated:\n                isolated_pawns += 1\n    return float(isolated_pawns)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of pieces attacking the opponent's king.\"\n    opponent_king_square = board.king(chess.BLACK if board.turn else chess.WHITE)\n    attacking_pieces_count = len(board.attackers(chess.WHITE if board.turn else chess.BLACK, opponent_king_square))\n    return float(attacking_pieces_count)", "def feature(board: chess.Board) -> float:\n    \"Measures the total number of squares that are controlled by each player.\"\n    controlled_squares_white = len(set(square for square in board.piece_map() \n                                        if board.is_attacked_by(chess.WHITE, square)))\n    controlled_squares_black = len(set(square for square in board.piece_map() \n                                        if board.is_attacked_by(chess.BLACK, square)))\n    return float(controlled_squares_white - controlled_squares_black)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of unprotected pieces on the board.\"\n    unprotected_pieces_count = 0\n    for square, piece in board.piece_map().items():\n        if not board.is_attacked_by(chess.BLACK if piece.color == chess.WHITE else chess.WHITE, square):\n            unprotected_pieces_count += 1\n    return float(unprotected_pieces_count)", "def feature(board: chess.Board) -> float:\n    \"Measures the potential pawn structure by counting doubled pawns.\"\n    doubled_pawns_count = 0\n    files_with_pawns = {}\n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.PAWN:\n            file = chess.square_file(square)\n            if file in files_with_pawns:\n                files_with_pawns[file] += 1\n            else:\n                files_with_pawns[file] = 1\n    for count in files_with_pawns.values():\n        if count > 1:\n            doubled_pawns_count += count - 1\n    return float(doubled_pawns_count)", "def feature(board: chess.Board) -> float:\n    \"Measures the maximum distance of a piece from the player's king.\"\n    king_square = board.king(chess.WHITE if board.turn else chess.BLACK)\n    max_distance = max((chess.square_distance(king_square, square) \n                        for square in board.piece_map() if board.piece_map()[square].color == (chess.WHITE if board.turn else chess.BLACK)), \n                       default=0)\n    return float(max_distance)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of half moves since the last pawn movement or capture.\"\n    return float(board.halfmove_clock)", "def feature(board: chess.Board) -> float:\n    \"Calculates the total value of pieces for each color and returns their difference.\"\n    total_value_white = sum(piece.piece_type for piece in board.piece_map().values() if piece.color == chess.WHITE)\n    total_value_black = sum(piece.piece_type for piece in board.piece_map().values() if piece.color == chess.BLACK)\n    return float(total_value_white - total_value_black)", "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces that are pinned against their own king.\"\n    pinned_count = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == board.turn:\n            for attacker in board.attackers(not board.turn, square):\n                if board.piece_at(attacker).piece_type in {chess.QUEEN, chess.ROOK, chess.BISHOP}:\n                    if board.piece_at(square).color == piece.color:\n                        pinned_count += 1\n                        break\n    return float(pinned_count)", "def feature(board: chess.Board) -> float:\n    \"Measures the central control by counting the number of pieces occupying or attacking central squares.\"\n    central_squares = [chess.D4, chess.D5, chess.E4, chess.E5]\n    control_count = sum(1 for square in central_squares if board.piece_at(square) is not None)\n    return float(control_count)", "def feature(board: chess.Board) -> float:\n    \"Calculates the ratio of major pieces (rooks and queens) to total pieces on the board.\"\n    major_piece_count = sum(1 for piece in board.piece_map().values() if piece.piece_type in {chess.ROOK, chess.QUEEN})\n    total_piece_count = len(board.piece_map())\n    return float(major_piece_count / total_piece_count) if total_piece_count > 0 else 0.0", "def feature(board: chess.Board) -> float:\n    \"Counts the number of doubled pawns for both players.\"\n    pawn_counts = {chess.WHITE: 0, chess.BLACK: 0}\n    pawn_files = {chess.WHITE: set(), chess.BLACK: set()}\n    \n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.PAWN:\n            pawn_counts[piece.color] += 1\n            pawn_files[piece.color].add(chess.square_file(square))\n    \n    doubled_pawns = abs(len(pawn_files[chess.WHITE]) - pawn_counts[chess.WHITE]) + abs(len(pawn_files[chess.BLACK]) - pawn_counts[chess.BLACK])\n    return float(doubled_pawns)", "def feature(board: chess.Board) -> float:\n    \"Calculates the number of defended pieces on the board.\"\n    defended_count = sum(1 for square, piece in board.piece_map().items() if piece.color == board.turn and \n                         any(board.is_attacked_by(not board.turn, square) for square in board.attackers(not board.turn, square)))\n    return float(defended_count)", "def feature(board: chess.Board) -> float:\n    \"Measures the distances of all pieces from their respective home ranks.\"\n    distance_sum = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == chess.WHITE:\n            distance_sum += chess.square_rank(square)  # Distance from home rank (1)\n        else:\n            distance_sum += 7 - chess.square_rank(square)  # Distance from home rank (8)\n    return float(distance_sum)", "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in mobility between the two sides.\"\n    white_moves = len(list(board.legal_moves)) if board.turn == chess.WHITE else len(list(board.legal_moves))\n    black_moves = len(list(board.legal_moves)) if board.turn == chess.BLACK else len(list(board.legal_moves))\n    return float(white_moves - black_moves)"]}