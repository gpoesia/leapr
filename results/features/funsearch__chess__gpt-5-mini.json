{
  "used_features": [
    "def feature(board: chess.Board) -> float:\n    'Net king vicinity pressure: weighted sum of opponent attackers on/around each king (positive => advantage for White)'\n    values = {chess.PAWN:1.0, chess.KNIGHT:3.0, chess.BISHOP:3.0, chess.ROOK:5.0, chess.QUEEN:9.0, chess.KING:0.0}\n    try:\n        # White king square\n        wk_sq = next(sq for sq, p in board.piece_map().items() if p.piece_type == chess.KING and p.color == chess.WHITE)\n    except StopIteration:\n        wk_sq = None\n    try:\n        bk_sq = next(sq for sq, p in board.piece_map().items() if p.piece_type == chess.KING and p.color == chess.BLACK)\n    except StopIteration:\n        bk_sq = None\n    score_white = 0.0\n    score_black = 0.0\n    # For each square within distance <=1 of kings (king's neighborhood), sum attackers weighted by attacker piece type\n    if wk_sq is not None:\n        for sq in range(64):\n            if chess.square_distance(sq, wk_sq) <= 1:\n                attackers = board.attackers(chess.BLACK, sq)\n                for a in attackers:\n                    p = board.piece_at(a)\n                    if p:\n                        score_black += values.get(p.piece_type, 0.0)\n    if bk_sq is not None:\n        for sq in range(64):\n            if chess.square_distance(sq, bk_sq) <= 1:\n                attackers = board.attackers(chess.WHITE, sq)\n                for a in attackers:\n                    p = board.piece_at(a)\n                    if p:\n                        score_white += values.get(p.piece_type, 0.0)\n    # Positive means White has more pressure near enemy king (good for White)\n    return float(score_white - score_black)\n\n",
    "def feature(board: chess.Board) -> float:\n    'Passed pawn advancement advantage: sum of passed pawn progress for White minus Black (0..something)'\n    def is_passed(sq, color):\n        f = chess.square_file(sq)\n        r = chess.square_rank(sq)\n        if color == chess.WHITE:\n            # no black pawn ahead on same or adjacent file with rank > r\n            for bf_sq, p in board.piece_map().items():\n                if p.piece_type == chess.PAWN and p.color == chess.BLACK:\n                    bf = chess.square_file(bf_sq); br = chess.square_rank(bf_sq)\n                    if abs(bf - f) <= 1 and br > r:\n                        return False\n            return True\n        else:\n            for wf_sq, p in board.piece_map().items():\n                if p.piece_type == chess.PAWN and p.color == chess.WHITE:\n                    wf = chess.square_file(wf_sq); wr = chess.square_rank(wf_sq)\n                    if abs(wf - f) <= 1 and wr < r:\n                        return False\n            return True\n    score_w = 0.0\n    score_b = 0.0\n    for sq, p in board.piece_map().items():\n        if p.piece_type == chess.PAWN:\n            r = chess.square_rank(sq)\n            if p.color == chess.WHITE:\n                if is_passed(sq, chess.WHITE):\n                    # reward by advancement (rank 0..7; more advanced -> higher)\n                    score_w += (r / 7.0) + 0.5\n            else:\n                if is_passed(sq, chess.BLACK):\n                    score_b += ((7 - r) / 7.0) + 0.5\n    return float(score_w - score_b)\n\n",
    "def feature(board: chess.Board) -> float:\n    'Rooks on open or semi-open files: (white_score - black_score), open=1.0, semi-open=0.5'\n    def file_has_pawn(file_index):\n        for rank in range(8):\n            sq = chess.square(file_index, rank)\n            if board.piece_at(sq) and board.piece_at(sq).piece_type == chess.PAWN:\n                return True\n        return False\n    score_w = 0.0\n    score_b = 0.0\n    # Precompute per-file pawn presence and owner presence\n    file_pawn_owner = [None]*8  # None or set of colors\n    for f in range(8):\n        owners = set()\n        for r in range(8):\n            p = board.piece_at(chess.square(f, r))\n            if p and p.piece_type == chess.PAWN:\n                owners.add(p.color)\n        file_pawn_owner[f] = owners\n    for sq, p in board.piece_map().items():\n        if p.piece_type == chess.ROOK:\n            f = chess.square_file(sq)\n            owners = file_pawn_owner[f]\n            if not owners:\n                val = 1.0\n            elif owners == {p.color}:\n                val = 0.0\n            else:\n                # pawns of both colors -> not open; semi-open if no friendly pawns\n                if p.color not in owners:\n                    val = 0.5\n                else:\n                    val = 0.0\n            if p.color == chess.WHITE:\n                score_w += val\n            else:\n                score_b += val\n    return float(score_w - score_b)\n\n",
    "def feature(board: chess.Board) -> float:\n    'Bishop mobility + bishop-pair bonus: (white - black); counts legal bishop moves plus large pair bonus'\n    # We'll temporarily toggle turn to count legal moves for each side\n    orig_turn = board.turn\n    try:\n        # White\n        board.turn = chess.WHITE\n        white_bishop_moves = 0\n        for mv in board.legal_moves:\n            p = board.piece_at(mv.from_square)\n            if p and p.piece_type == chess.BISHOP and p.color == chess.WHITE:\n                white_bishop_moves += 1\n        white_bishops = sum(1 for p in board.piece_map().values() if p.piece_type == chess.BISHOP and p.color == chess.WHITE)\n        # Black\n        board.turn = chess.BLACK\n        black_bishop_moves = 0\n        for mv in board.legal_moves:\n            p = board.piece_at(mv.from_square)\n            if p and p.piece_type == chess.BISHOP and p.color == chess.BLACK:\n                black_bishop_moves += 1\n        black_bishops = sum(1 for p in board.piece_map().values() if p.piece_type == chess.BISHOP and p.color == chess.BLACK)\n    finally:\n        board.turn = orig_turn\n    white_score = white_bishop_moves + (10.0 if white_bishops >= 2 else 0.0)\n    black_score = black_bishop_moves + (10.0 if black_bishops >= 2 else 0.0)\n    return float(white_score - black_score)\n\n",
    "def feature(board: chess.Board) -> float:\n    'King tropism by queens: sum of 1/(1+distance) from queens to enemy king (white - black)'\n    def queen_tropism(color):\n        total = 0.0\n        king_sq = next((sq for sq, p in board.piece_map().items() if p.piece_type == chess.KING and p.color != color), None)\n        if king_sq is None:\n            return 0.0\n        for sq, p in board.piece_map().items():\n            if p.piece_type == chess.QUEEN and p.color == color:\n                d = chess.square_distance(sq, king_sq)\n                total += 1.0 / (1.0 + d)\n        return total\n    return float(queen_tropism(chess.WHITE) - queen_tropism(chess.BLACK))\n\n",
    "def feature(board: chess.Board) -> float:\n    'Material balance with mobility tie-break: material sum (W-B) using standard weights + 0.1 * (mobility diff)'\n    values = {chess.PAWN:1.0, chess.KNIGHT:3.2, chess.BISHOP:3.3, chess.ROOK:5.1, chess.QUEEN:9.0, chess.KING:0.0}\n    mat_w = 0.0\n    mat_b = 0.0\n    for p in board.piece_map().values():\n        if p.color == chess.WHITE:\n            mat_w += values.get(p.piece_type, 0.0)\n        else:\n            mat_b += values.get(p.piece_type, 0.0)\n    # mobility: number of legal moves for each side (toggle)\n    orig = board.turn\n    try:\n        board.turn = chess.WHITE\n        mob_w = sum(1 for _ in board.legal_moves)\n        board.turn = chess.BLACK\n        mob_b = sum(1 for _ in board.legal_moves)\n    finally:\n        board.turn = orig\n    return float((mat_w - mat_b) + 0.1 * (mob_w - mob_b))\n\n",
    "def feature(board: chess.Board) -> float:\n    'Piece centralization: sum over non-pawn pieces of 1/(1+distance_to_center) for White minus Black'\n    center_squares = [chess.parse_square(n) for n in ('d4','d5','e4','e5')]\n    def dist_to_center(sq):\n        # distance to nearest central square (Chebyshev-like using square_distance suffices)\n        return min(chess.square_distance(sq, c) for c in center_squares)\n    score_w = 0.0\n    score_b = 0.0\n    for sq, p in board.piece_map().items():\n        if p.piece_type == chess.PAWN or p.piece_type == chess.KING:\n            continue\n        d = dist_to_center(sq)\n        val = 1.0 / (1.0 + d)\n        if p.color == chess.WHITE:\n            score_w += val\n        else:\n            score_b += val\n    return float(score_w - score_b)\n\n",
    "def feature(board: chess.Board) -> float:\n    'Immobilized non-pawn pieces: number of non-pawn, non-king pieces that have no legal moves (white - black)'\n    # For each side, collect from-squares that have at least one legal move when that side is to move.\n    orig = board.turn\n    try:\n        board.turn = chess.WHITE\n        white_movers = set(mv.from_square for mv in board.legal_moves)\n        board.turn = chess.BLACK\n        black_movers = set(mv.from_square for mv in board.legal_moves)\n    finally:\n        board.turn = orig\n    imm_w = 0.0\n    imm_b = 0.0\n    for sq, p in board.piece_map().items():\n        if p.piece_type in (chess.PAWN, chess.KING):\n            continue\n        if p.color == chess.WHITE:\n            if sq not in white_movers:\n                imm_w += 1.0\n        else:\n            if sq not in black_movers:\n                imm_b += 1.0\n    return float(imm_w - imm_b)\n\n",
    "def feature(board: chess.Board) -> float:\n    'Direct attackers on kings: number of attackers on king square (white_attackers_on_black_king - black_attackers_on_white_king)'\n    wk_sq = next((sq for sq, p in board.piece_map().items() if p.piece_type == chess.KING and p.color == chess.WHITE), None)\n    bk_sq = next((sq for sq, p in board.piece_map().items() if p.piece_type == chess.KING and p.color == chess.BLACK), None)\n    atk_w = 0.0\n    atk_b = 0.0\n    if bk_sq is not None:\n        atk_w = float(len(board.attackers(chess.WHITE, bk_sq)))\n    if wk_sq is not None:\n        atk_b = float(len(board.attackers(chess.BLACK, wk_sq)))\n    return float(atk_w - atk_b)\n\n",
    "def feature(board: chess.Board) -> float:\n    'Outpost score: advanced supported knights/bishops on outpost-like squares (white - black)'\n    def is_supported_by_pawn(sq, color):\n        f = chess.square_file(sq); r = chess.square_rank(sq)\n        # pawns that could support are on previous rank (for White r-1) same or adjacent files\n        if color == chess.WHITE:\n            behind_rank = r - 1\n            if behind_rank < 0:\n                return False\n            for df in (-1, 0, 1):\n                ff = f + df\n                if 0 <= ff <= 7:\n                    p = board.piece_at(chess.square(ff, behind_rank))\n                    if p and p.piece_type == chess.PAWN and p.color == color:\n                        return True\n        else:\n            behind_rank = r + 1\n            if behind_rank > 7:\n                return False\n            for df in (-1, 0, 1):\n                ff = f + df\n                if 0 <= ff <= 7:\n                    p = board.piece_at(chess.square(ff, behind_rank))\n                    if p and p.piece_type == chess.PAWN and p.color == color:\n                        return True\n        return False\n    def is_attacked_by_pawn(sq, color):\n        # whether opponent pawns attack this square\n        opp = chess.WHITE if color == chess.BLACK else chess.BLACK\n        return any(board.piece_at(a) and board.piece_at(a).piece_type == chess.PAWN and board.piece_at(a).color == opp\n                   and ( (opp == chess.WHITE and chess.square_rank(a) < chess.square_rank(sq)) or (opp == chess.BLACK and chess.square_rank(a) > chess.square_rank(sq)) )\n                   for a in range(64))\n    score_w = 0.0\n    score_b = 0.0\n    for sq, p in board.piece_map().items():\n        if p.piece_type not in (chess.KNIGHT, chess.BISHOP):\n            continue\n        r = chess.square_rank(sq)\n        advanced = (p.color == chess.WHITE and r >= 3) or (p.color == chess.BLACK and r <= 4)\n        if not advanced:\n            continue\n        supported = is_supported_by_pawn(sq, p.color)\n        attacked_by_pawn = is_attacked_by_pawn(sq, p.color)\n        if supported and not attacked_by_pawn:\n            if p.color == chess.WHITE:\n                score_w += 1.0\n            else:\n                score_b += 1.0\n    return float(score_w - score_b)\n",
    "def feature(board: chess.Board) -> float:\n    'Pawn shield integrity in front of each king: fraction of ideal pawns present (white - black)'\n    values = {chess.PAWN:1.0}\n    # find kings\n    wk_sq = next((sq for sq, p in board.piece_map().items() if p.piece_type == chess.KING and p.color == chess.WHITE), None)\n    bk_sq = next((sq for sq, p in board.piece_map().items() if p.piece_type == chess.KING and p.color == chess.BLACK), None)\n    def shield_fraction(king_sq, color):\n        if king_sq is None:\n            return 0.0\n        f = chess.square_file(king_sq)\n        r = chess.square_rank(king_sq)\n        count = 0\n        # Ideal shield: pawns on f-1,f,f+1 on the next 1-2 ranks towards opponent\n        if color == chess.WHITE:\n            ranks = [r+1, r+2]\n        else:\n            ranks = [r-1, r-2]\n        for ff in (f-1, f, f+1):\n            for rr in ranks:\n                if 0 <= ff <= 7 and 0 <= rr <= 7:\n                    p = board.piece_at(chess.square(ff, rr))\n                    if p and p.piece_type == chess.PAWN and p.color == color:\n                        count += 1\n        # ideal max count is 6 (3 files * 2 ranks), normalize\n        return count / 6.0\n    return float((shield_fraction(wk_sq, chess.WHITE) - shield_fraction(bk_sq, chess.BLACK)))\n\n",
    "def feature(board: chess.Board) -> float:\n    'Weighted hanging pieces: sum of values of own pieces that are attacked and undefended (white - black)'\n    vals = {chess.PAWN:1.0, chess.KNIGHT:3.0, chess.BISHOP:3.0, chess.ROOK:5.0, chess.QUEEN:9.0, chess.KING:0.0}\n    hang_w = 0.0\n    hang_b = 0.0\n    pm = board.piece_map()\n    for sq, p in pm.items():\n        if p.piece_type == chess.KING:\n            continue\n        opp = chess.WHITE if p.color == chess.BLACK else chess.BLACK\n        attackers = board.attackers(opp, sq)\n        defenders = board.attackers(p.color, sq)\n        if attackers and not defenders:\n            if p.color == chess.WHITE:\n                hang_w += vals.get(p.piece_type, 0.0)\n            else:\n                hang_b += vals.get(p.piece_type, 0.0)\n    return float(hang_b * -1.0 + hang_w)  # hang_w - hang_b\n\n",
    "def feature(board: chess.Board) -> float:\n    'Rooks on the opponent seventh rank (classic outpost pressure): count (white - black)'\n    score_w = 0.0\n    score_b = 0.0\n    for sq, p in board.piece_map().items():\n        if p.piece_type == chess.ROOK:\n            r = chess.square_rank(sq)\n            if p.color == chess.WHITE and r == 6:\n                score_w += 1.0\n            if p.color == chess.BLACK and r == 1:\n                score_b += 1.0\n    return float(score_w - score_b)\n\n",
    "def feature(board: chess.Board) -> float:\n    'Normalized mobility per major/minor piece: average legal moves per (knight,bishop,rook,queen) piece (white - black)'\n    types = (chess.KNIGHT, chess.BISHOP, chess.ROOK, chess.QUEEN)\n    orig = board.turn\n    try:\n        board.turn = chess.WHITE\n        white_move_counts = {t:0 for t in types}\n        for mv in board.legal_moves:\n            p = board.piece_at(mv.from_square)\n            if p and p.piece_type in types and p.color == chess.WHITE:\n                white_move_counts[p.piece_type] += 1\n        board.turn = chess.BLACK\n        black_move_counts = {t:0 for t in types}\n        for mv in board.legal_moves:\n            p = board.piece_at(mv.from_square)\n            if p and p.piece_type in types and p.color == chess.BLACK:\n                black_move_counts[p.piece_type] += 1\n    finally:\n        board.turn = orig\n    # counts of pieces\n    white_counts = {t:0 for t in types}\n    black_counts = {t:0 for t in types}\n    for p in board.piece_map().values():\n        if p.piece_type in types:\n            if p.color == chess.WHITE:\n                white_counts[p.piece_type] += 1\n            else:\n                black_counts[p.piece_type] += 1\n    def avg_moves(move_counts, counts):\n        total_moves = 0\n        total_pieces = 0\n        for t in types:\n            total_moves += move_counts[t]\n            total_pieces += counts[t]\n        if total_pieces == 0:\n            return 0.0\n        return total_moves / float(total_pieces)\n    return float(avg_moves(white_move_counts, white_counts) - avg_moves(black_move_counts, black_counts))\n\n",
    "def feature(board: chess.Board) -> float:\n    'Pawn majority difference between queenside (files a-d) and kingside (files e-h): (white_diff - black_diff)'\n    w_qs = 0\n    w_ks = 0\n    b_qs = 0\n    b_ks = 0\n    for sq, p in board.piece_map().items():\n        if p.piece_type != chess.PAWN:\n            continue\n        f = chess.square_file(sq)\n        if f <= 3:\n            if p.color == chess.WHITE:\n                w_qs += 1\n            else:\n                b_qs += 1\n        else:\n            if p.color == chess.WHITE:\n                w_ks += 1\n            else:\n                b_ks += 1\n    w_diff = w_qs - w_ks\n    b_diff = b_qs - b_ks\n    return float(w_diff - b_diff)\n\n",
    "def feature(board: chess.Board) -> float:\n    'Rooks immobilized: number of rooks with no legal moves (white - black)'\n    orig = board.turn\n    try:\n        board.turn = chess.WHITE\n        white_movers = set(mv.from_square for mv in board.legal_moves)\n        board.turn = chess.BLACK\n        black_movers = set(mv.from_square for mv in board.legal_moves)\n    finally:\n        board.turn = orig\n    imm_w = 0.0\n    imm_b = 0.0\n    for sq, p in board.piece_map().items():\n        if p.piece_type != chess.ROOK:\n            continue\n        if p.color == chess.WHITE:\n            if sq not in white_movers:\n                imm_w += 1.0\n        else:\n            if sq not in black_movers:\n                imm_b += 1.0\n    return float(imm_w - imm_b)\n\n",
    "def feature(board: chess.Board) -> float:\n    'Open files adjacent to each king (files with no pawns); more open files near enemy king -> advantage for side attacking it'\n    def open_adjacent_files(king_sq, color):\n        if king_sq is None:\n            return 0\n        f = chess.square_file(king_sq)\n        count = 0\n        for ff in (f-1, f, f+1):\n            if 0 <= ff <= 7:\n                has_pawn = False\n                for rr in range(8):\n                    p = board.piece_at(chess.square(ff, rr))\n                    if p and p.piece_type == chess.PAWN:\n                        has_pawn = True\n                        break\n                if not has_pawn:\n                    count += 1\n        return count\n    wk_sq = next((sq for sq, p in board.piece_map().items() if p.piece_type == chess.KING and p.color == chess.WHITE), None)\n    bk_sq = next((sq for sq, p in board.piece_map().items() if p.piece_type == chess.KING and p.color == chess.BLACK), None)\n    # Open files near black king are good for White, near white king good for Black\n    open_near_black = open_adjacent_files(bk_sq, chess.BLACK)\n    open_near_white = open_adjacent_files(wk_sq, chess.WHITE)\n    return float(open_near_black - open_near_white)\n\n",
    "def feature(board: chess.Board) -> float:\n    'King centrality in simplified/endgame positions: advantage if White king is closer to center (only active when few non-pawn pieces remain)'\n    non_pawn_non_king = sum(1 for p in board.piece_map().values() if p.piece_type not in (chess.PAWN, chess.KING))\n    if non_pawn_non_king > 4:\n        return 0.0\n    center_squares = [chess.parse_square(n) for n in ('d4','d5','e4','e5')]\n    def dist_to_center(king_sq):\n        if king_sq is None:\n            return 10.0\n        return float(min(chess.square_distance(king_sq, c) for c in center_squares))\n    wk_sq = next((sq for sq, p in board.piece_map().items() if p.piece_type == chess.KING and p.color == chess.WHITE), None)\n    bk_sq = next((sq for sq, p in board.piece_map().items() if p.piece_type == chess.KING and p.color == chess.BLACK), None)\n    dw = dist_to_center(wk_sq)\n    db = dist_to_center(bk_sq)\n    # smaller distance is better; return (black_distance - white_distance) so positive favors White\n    return float(db - dw)\n\n",
    "def feature(board: chess.Board) -> float:\n    'Pawn island count imbalance: (black_islands - white_islands) so fewer white islands -> positive'\n    def pawn_islands(color):\n        files_with_pawn = [False]*8\n        for sq, p in board.piece_map().items():\n            if p.piece_type == chess.PAWN and p.color == color:\n                files_with_pawn[chess.square_file(sq)] = True\n        islands = 0\n        i = 0\n        while i < 8:\n            if files_with_pawn[i]:\n                islands += 1\n                while i < 8 and files_with_pawn[i]:\n                    i += 1\n            else:\n                i += 1\n        return islands\n    w_is = pawn_islands(chess.WHITE)\n    b_is = pawn_islands(chess.BLACK)\n    return float(b_is - w_is)\n\n",
    "def feature(board: chess.Board) -> float:\n    'Attacker/defender imbalance on opponent pieces: sum over opponent pieces of (attackers - defenders) weighted by piece value (white - black)'\n    vals = {chess.PAWN:1.0, chess.KNIGHT:3.0, chess.BISHOP:3.0, chess.ROOK:5.0, chess.QUEEN:9.0, chess.KING:0.0}\n    adv_w = 0.0\n    adv_b = 0.0\n    pm = board.piece_map()\n    for sq, p in pm.items():\n        opp = chess.WHITE if p.color == chess.BLACK else chess.BLACK\n        attackers_by_opp = len(board.attackers(opp, sq))\n        defenders_by_owner = len(board.attackers(p.color, sq))\n        imbalance = attackers_by_opp - defenders_by_owner\n        if imbalance <= 0:\n            continue\n        if opp == chess.WHITE:\n            adv_w += imbalance * vals.get(p.piece_type, 0.0)\n        else:\n            adv_b += imbalance * vals.get(p.piece_type, 0.0)\n    return float(adv_w - adv_b)\n",
    "def feature(board: chess.Board) -> float:\n    'Sum of values of hanging pieces attacked: (white_hanging_attacked - black_hanging_attacked)'\n    values = {chess.PAWN:1.0, chess.KNIGHT:3.0, chess.BISHOP:3.0, chess.ROOK:5.0, chess.QUEEN:9.0, chess.KING:0.0}\n    wm = 0.0\n    bm = 0.0\n    pm = board.piece_map()\n    for sq, p in pm.items():\n        if p is None:\n            continue\n        color = p.color\n        opp = not color\n        defenders = board.attackers(color, sq)\n        attackers = board.attackers(opp, sq)\n        # Hanging piece that is attacked and has no defenders (or fewer defenders than attackers)\n        if len(attackers) > 0 and len(defenders) == 0:\n            if color == chess.WHITE:\n                wm += values.get(p.piece_type, 0.0)\n            else:\n                bm += values.get(p.piece_type, 0.0)\n    return float(bm - wm)  # positive when White has more hanging enemy pieces (good for White)\n\n",
    "def feature(board: chess.Board) -> float:\n    'Pawn islands difference: (white_islands - black_islands) normalized by 4'\n    def pawn_islands(color):\n        files_with_pawns = [any(p.piece_type == chess.PAWN and p.color == color for sq,p in board.piece_map().items() if chess.square_file(sq) == f) for f in range(8)]\n        islands = 0\n        prev = False\n        for present in files_with_pawns:\n            if present and not prev:\n                islands += 1\n            prev = present\n        return islands\n    wi = pawn_islands(chess.WHITE)\n    bi = pawn_islands(chess.BLACK)\n    # Normalize roughly to [-2..2] by dividing by 4 (max islands ~4 common)\n    return float((wi - bi) / 4.0)\n\n",
    "def feature(board: chess.Board) -> float:\n    'Open and semi-open file control by major pieces: (white_score - black_score)'\n    def file_info():\n        # returns lists file_has_pawn[f] = True if any pawn on file, file_has_own_pawn[color][f]\n        file_has_pawn = [False]*8\n        file_has_own_pawn = {chess.WHITE:[False]*8, chess.BLACK:[False]*8}\n        for sq, p in board.piece_map().items():\n            f = chess.square_file(sq)\n            if p.piece_type == chess.PAWN:\n                file_has_pawn[f] = True\n                file_has_own_pawn[p.color][f] = True\n        return file_has_pawn, file_has_own_pawn\n    file_has_pawn, file_has_own_pawn = file_info()\n    white_score = 0.0\n    black_score = 0.0\n    # For each file, check if side has rook/queen that can occupy/control file (has at least one rook/queen)\n    for f in range(8):\n        # presence of side rook/queen on that file or can move to it? We'll check pieces on that file (control)\n        w_has_major = any(p.piece_type in (chess.ROOK, chess.QUEEN) and p.color == chess.WHITE and chess.square_file(sq) == f for sq,p in board.piece_map().items())\n        b_has_major = any(p.piece_type in (chess.ROOK, chess.QUEEN) and p.color == chess.BLACK and chess.square_file(sq) == f for sq,p in board.piece_map().items())\n        # Open file: no pawns at all\n        if not file_has_pawn[f]:\n            if w_has_major:\n                white_score += 1.0\n            if b_has_major:\n                black_score += 1.0\n        else:\n            # semi-open for a side: no friendly pawn on file but opponent pawn(s) may exist\n            if not file_has_pawn[f] or not file_has_own_pawn[chess.WHITE][f]:\n                if w_has_major and not file_has_own_pawn[chess.WHITE][f]:\n                    white_score += 0.5\n            if not file_has_pawn[f] or not file_has_own_pawn[chess.BLACK][f]:\n                if b_has_major and not file_has_own_pawn[chess.BLACK][f]:\n                    black_score += 0.5\n    return float(white_score - black_score)\n\n",
    "def feature(board: chess.Board) -> float:\n    'Knight outposts: knights supported by own pawn and not attacked by enemy pawns (white - black)'\n    pm = board.piece_map()\n    # Precompute pawn attack patterns\n    pawn_attack_from = {chess.WHITE: set(), chess.BLACK: set()}\n    for sq, p in pm.items():\n        if p and p.piece_type == chess.PAWN:\n            f = chess.square_file(sq); r = chess.square_rank(sq)\n            if p.color == chess.WHITE:\n                for df in (-1, 1):\n                    tf = f + df; tr = r + 1\n                    if 0 <= tf <= 7 and 0 <= tr <= 7:\n                        pawn_attack_from[chess.WHITE].add(chess.square(tf, tr))\n            else:\n                for df in (-1, 1):\n                    tf = f + df; tr = r - 1\n                    if 0 <= tf <= 7 and 0 <= tr <= 7:\n                        pawn_attack_from[chess.BLACK].add(chess.square(tf, tr))\n    w_score = 0.0\n    b_score = 0.0\n    for sq, p in pm.items():\n        if p and p.piece_type == chess.KNIGHT:\n            r = chess.square_rank(sq)\n            # consider central advanced ranks for outpost: ranks 2..5 (0-based)\n            if 2 <= r <= 5:\n                color = p.color\n                opp = chess.WHITE if color == chess.BLACK else chess.BLACK\n                attacked_by_opp_pawn = sq in pawn_attack_from[opp]\n                supported_by_own_pawn = sq in pawn_attack_from[color]\n                if supported_by_own_pawn and not attacked_by_opp_pawn:\n                    if color == chess.WHITE:\n                        w_score += 1.0\n                    else:\n                        b_score += 1.0\n    return float(w_score - b_score)\n\n",
    "def feature(board: chess.Board) -> float:\n    'Rooks behind passed pawns: counts rooks supporting passed pawns on same file (white - black)'\n    pm = board.piece_map()\n    # helper to detect passed pawn\n    def is_passed(sq, color):\n        f = chess.square_file(sq); r = chess.square_rank(sq)\n        if color == chess.WHITE:\n            for bf_sq, p in pm.items():\n                if p and p.piece_type == chess.PAWN and p.color == chess.BLACK:\n                    bf = chess.square_file(bf_sq); br = chess.square_rank(bf_sq)\n                    if abs(bf - f) <= 1 and br > r:\n                        return False\n            return True\n        else:\n            for wf_sq, p in pm.items():\n                if p and p.piece_type == chess.PAWN and p.color == chess.WHITE:\n                    wf = chess.square_file(wf_sq); wr = chess.square_rank(wf_sq)\n                    if abs(wf - f) <= 1 and wr < r:\n                        return False\n            return True\n    # count rooks supporting behind\n    w_score = 0.0\n    b_score = 0.0\n    for sq, p in pm.items():\n        if p and p.piece_type == chess.PAWN:\n            if is_passed(sq, p.color):\n                f = chess.square_file(sq); r = chess.square_rank(sq)\n                # search for rooks on same file with clear path\n                for rsq, rp in pm.items():\n                    if rp and rp.piece_type == chess.ROOK and rp.color == p.color and chess.square_file(rsq) == f:\n                        rr = chess.square_rank(rsq)\n                        # For white pawn, rook behind if rr < r; for black rr > r\n                        if p.color == chess.WHITE and rr < r:\n                            # check clear path between rook and pawn\n                            path_clear = True\n                            for mid_r in range(rr+1, r):\n                                if board.piece_at(chess.square(f, mid_r)) is not None:\n                                    path_clear = False; break\n                            if path_clear:\n                                w_score += 1.0\n                        if p.color == chess.BLACK and rr > r:\n                            path_clear = True\n                            for mid_r in range(r+1, rr):\n                                if board.piece_at(chess.square(f, mid_r)) is not None:\n                                    path_clear = False; break\n                            if path_clear:\n                                b_score += 1.0\n    return float(w_score - b_score)\n\n",
    "def feature(board: chess.Board) -> float:\n    'Bishop effectiveness vs pawn color complex: favors bishops with fewer same-color pawns (white - black)'\n    pm = board.piece_map()\n    def bishop_effect(color):\n        bishops = [sq for sq,p in pm.items() if p and p.piece_type == chess.BISHOP and p.color == color]\n        pawn_same_color = 0\n        total_pawns = 0\n        for sq,p in pm.items():\n            if p and p.piece_type == chess.PAWN and p.color == color:\n                total_pawns += 1\n                # pawn square color parity\n                if (chess.square_file(sq) + chess.square_rank(sq)) % 2 == 0:\n                    pawn_col = 0\n                else:\n                    pawn_col = 1\n                # count later by comparing to bishops' square colors\n        if not bishops:\n            return 0.0\n        # compute average fraction of friendly pawns sitting on the same square color as each bishop\n        total_effect = 0.0\n        for bsq in bishops:\n            bcol = (chess.square_file(bsq) + chess.square_rank(bsq)) % 2\n            same = sum(1 for sq,p in pm.items() if p and p.piece_type == chess.PAWN and p.color == color and ((chess.square_file(sq) + chess.square_rank(sq)) % 2) == bcol)\n            # fraction of same-color pawns (0..1)\n            frac = same / float(max(1, total_pawns))\n            # effectiveness reduced by pawn fraction\n            total_effect += (1.0 - frac)\n        return total_effect  # larger is better\n    return float(bishop_effect(chess.WHITE) - bishop_effect(chess.BLACK))\n\n",
    "def feature(board: chess.Board) -> float:\n    'Exposure of king files: number of adjacent files to king without friendly pawns in front (black_exposed - white_exposed)'\n    pm = board.piece_map()\n    def exposed_files(color):\n        ks = next((sq for sq,p in pm.items() if p and p.piece_type == chess.KING and p.color == color), None)\n        if ks is None:\n            return 2.0  # missing king treat as exposed\n        f = chess.square_file(ks); r = chess.square_rank(ks)\n        exposed = 0\n        for df in (-1,0,1):\n            tf = f + df\n            if not (0 <= tf <= 7):\n                continue\n            has_friendly_in_front = False\n            if color == chess.WHITE:\n                for rr in range(r+1,8):\n                    p = board.piece_at(chess.square(tf, rr))\n                    if p and p.piece_type == chess.PAWN and p.color == color:\n                        has_friendly_in_front = True\n                        break\n            else:\n                for rr in range(r-1, -1, -1):\n                    p = board.piece_at(chess.square(tf, rr))\n                    if p and p.piece_type == chess.PAWN and p.color == color:\n                        has_friendly_in_front = True\n                        break\n            if not has_friendly_in_front:\n                exposed += 1\n        return float(exposed)\n    w_exp = exposed_files(chess.WHITE)\n    b_exp = exposed_files(chess.BLACK)\n    # positive when White is less exposed (i.e., black_exposed - white_exposed)\n    return float(b_exp - w_exp)\n\n",
    "def feature(board: chess.Board) -> float:\n    'Connected rooks and rook coordination: counts connected rook pairs and rooks supporting each other (white - black)'\n    pm = board.piece_map()\n    def rook_coord(color):\n        rooks = [sq for sq,p in pm.items() if p and p.piece_type == chess.ROOK and p.color == color]\n        score = 0.0\n        for i in range(len(rooks)):\n            for j in range(i+1, len(rooks)):\n                a = rooks[i]; b = rooks[j]\n                # connected if same rank or file and no pieces between\n                if chess.square_file(a) == chess.square_file(b):\n                    f = chess.square_file(a)\n                    ra = chess.square_rank(a); rb = chess.square_rank(b)\n                    low = min(ra, rb)+1; high = max(ra, rb)\n                    clear = True\n                    for rr in range(low, high):\n                        if board.piece_at(chess.square(f, rr)) is not None:\n                            clear = False; break\n                    if clear:\n                        score += 2.0\n                if chess.square_rank(a) == chess.square_rank(b):\n                    rnk = chess.square_rank(a)\n                    fa = chess.square_file(a); fb = chess.square_file(b)\n                    low = min(fa, fb)+1; high = max(fa, fb)\n                    clear = True\n                    for ff in range(low, high):\n                        if board.piece_at(chess.square(ff, rnk)) is not None:\n                            clear = False; break\n                    if clear:\n                        score += 2.0\n                # support: one rook attacks the other square (i.e., can capture if opponent piece there) - add small bonus\n                if b in board.attackers(color, a) or a in board.attackers(color, b):\n                    score += 0.5\n        return score\n    return float(rook_coord(chess.WHITE) - rook_coord(chess.BLACK))\n\n",
    "def feature(board: chess.Board) -> float:\n    'Aggressive move potential: difference in number of capture-or-check legal moves (white - black) normalized'\n    orig = board.turn\n    try:\n        # White\n        board.turn = chess.WHITE\n        w_aggr = 0.0\n        for mv in board.legal_moves:\n            try:\n                is_cap = board.is_capture(mv)\n            except Exception:\n                # fallback: check destination occupied (may miss en-passant)\n                is_cap = (board.piece_at(mv.to_square) is not None)\n            # simulate to see if move gives check\n            bc = board.copy()\n            bc.push(mv)\n            gives_check = 1.0 if bc.is_check() else 0.0\n            if is_cap or gives_check:\n                w_aggr += 1.0\n        # Black\n        board.turn = chess.BLACK\n        b_aggr = 0.0\n        for mv in board.legal_moves:\n            try:\n                is_cap = board.is_capture(mv)\n            except Exception:\n                is_cap = (board.piece_at(mv.to_square) is not None)\n            bc = board.copy()\n            bc.push(mv)\n            gives_check = 1.0 if bc.is_check() else 0.0\n            if is_cap or gives_check:\n                b_aggr += 1.0\n    finally:\n        board.turn = orig\n    # Normalize by a typical scale (dividing by 10)\n    return float((w_aggr - b_aggr) / 10.0)\n\n",
    "def feature(board: chess.Board) -> float:\n    'Passed pawn menace score: advanced passed pawns weighted by proximity to enemy king (white - black)'\n    pm = board.piece_map()\n    # find kings\n    wk = next((sq for sq,p in pm.items() if p and p.piece_type == chess.KING and p.color == chess.WHITE), None)\n    bk = next((sq for sq,p in pm.items() if p and p.piece_type == chess.KING and p.color == chess.BLACK), None)\n    def is_passed(sq, color):\n        f = chess.square_file(sq); r = chess.square_rank(sq)\n        if color == chess.WHITE:\n            for bf_sq, p in pm.items():\n                if p and p.piece_type == chess.PAWN and p.color == chess.BLACK:\n                    bf = chess.square_file(bf_sq); br = chess.square_rank(bf_sq)\n                    if abs(bf - f) <= 1 and br > r:\n                        return False\n            return True\n        else:\n            for wf_sq, p in pm.items():\n                if p and p.piece_type == chess.PAWN and p.color == chess.WHITE:\n                    wf = chess.square_file(wf_sq); wr = chess.square_rank(wf_sq)\n                    if abs(wf - f) <= 1 and wr < r:\n                        return False\n            return True\n    w_score = 0.0\n    b_score = 0.0\n    for sq,p in pm.items():\n        if p and p.piece_type == chess.PAWN:\n            if is_passed(sq, p.color):\n                r = chess.square_rank(sq)\n                if p.color == chess.WHITE:\n                    # advancement factor (0..1)\n                    adv = r / 7.0\n                    if bk is not None:\n                        d = chess.square_distance(sq, bk)\n                        closeness = 1.0 / (1.0 + d)\n                    else:\n                        closeness = 0.5\n                    w_score += adv * closeness * 2.0\n                else:\n                    adv = (7 - r) / 7.0\n                    if wk is not None:\n                        d = chess.square_distance(sq, wk)\n                        closeness = 1.0 / (1.0 + d)\n                    else:\n                        closeness = 0.5\n                    b_score += adv * closeness * 2.0\n    return float(w_score - b_score)\n",
    "def feature(board: chess.Board) -> float:\n    'King pawn shield integrity: counts friendly pawns in front of each king and penalizes holes attacked by opponent (white - black)'\n    pm = board.piece_map()\n    def shield_score(king_sq, color):\n        if king_sq is None:\n            return 0.0\n        kf = chess.square_file(king_sq)\n        kr = chess.square_rank(king_sq)\n        score = 0.0\n        # For white pawns, forward is +rank; for black pawns, forward is -rank\n        forward = 1 if color == chess.WHITE else -1\n        opponent = chess.BLACK if color == chess.WHITE else chess.WHITE\n        for dr in (1, 2):  # two ranks in front\n            r = kr + forward * dr\n            if r < 0 or r > 7:\n                continue\n            for df in (-1, 0, 1):\n                f = kf + df\n                if f < 0 or f > 7:\n                    continue\n                sq = chess.square(f, r)\n                p = pm.get(sq)\n                if p and p.piece_type == chess.PAWN and p.color == color:\n                    score += 1.0  # pawn present strengthens shield\n                else:\n                    # hole: if opponent attacks this square it's more dangerous\n                    try:\n                        if board.is_attacked_by(opponent, sq):\n                            score -= 0.6\n                        else:\n                            score -= 0.1\n                    except Exception:\n                        score -= 0.1\n        return score\n    wk = next((sq for sq,p in pm.items() if p and p.piece_type == chess.KING and p.color == chess.WHITE), None)\n    bk = next((sq for sq,p in pm.items() if p and p.piece_type == chess.KING and p.color == chess.BLACK), None)\n    return float(shield_score(wk, chess.WHITE) - shield_score(bk, chess.BLACK))\n\n\n",
    "def feature(board: chess.Board) -> float:\n    'Central control: difference in number of attackers (white - black) to the central squares d4,e4,d5,e5 normalized'\n    central = [chess.parse_square(s) for s in ('d4','e4','d5','e5')]\n    w = 0.0\n    b = 0.0\n    for sq in central:\n        try:\n            w += float(len(board.attackers(chess.WHITE, sq)))\n            b += float(len(board.attackers(chess.BLACK, sq)))\n        except Exception:\n            # conservative fallback\n            pass\n    # normalize by 4\n    return float((w - b) / 4.0)\n\n\n",
    "def feature(board: chess.Board) -> float:\n    'Pawn structural weakness: penalizes doubled and isolated pawns (positive => advantage for White if Black has more weaknesses)'\n    pm = board.piece_map()\n    files_w = [0]*8\n    files_b = [0]*8\n    for sq,p in pm.items():\n        if not p or p.piece_type != chess.PAWN:\n            continue\n        f = chess.square_file(sq)\n        if p.color == chess.WHITE:\n            files_w[f] += 1\n        else:\n            files_b[f] += 1\n    def penalties(files):\n        doubled = sum(max(0, c-1) for c in files)\n        isolated = 0\n        for i,c in enumerate(files):\n            if c > 0:\n                left = files[i-1] if i-1 >= 0 else 0\n                right = files[i+1] if i+1 <= 7 else 0\n                if left == 0 and right == 0:\n                    isolated += 1\n        return doubled * 1.0 + isolated * 1.5\n    pen_w = penalties(files_w)\n    pen_b = penalties(files_b)\n    # positive means White advantage (Black has worse pawn structure)\n    return float(pen_b - pen_w)\n\n\n",
    "def feature(board: chess.Board) -> float:\n    'Rooks on open/semi-open files: rewards rooks on open (no pawns) and semi-open (no friendly pawns) files (white - black)'\n    pm = board.piece_map()\n    pawns_on_file = [0]*8\n    pawns_on_file_color = [{chess.WHITE:0, chess.BLACK:0} for _ in range(8)]\n    for sq,p in pm.items():\n        if p and p.piece_type == chess.PAWN:\n            f = chess.square_file(sq)\n            pawns_on_file[f] += 1\n            pawns_on_file_color[f][p.color] += 1\n    score_w = 0.0\n    score_b = 0.0\n    for sq,p in pm.items():\n        if not p or p.piece_type != chess.ROOK:\n            continue\n        f = chess.square_file(sq)\n        total = pawns_on_file[f]\n        friendly = pawns_on_file_color[f][p.color]\n        # open file (no pawns) more valuable than semi-open (no friendly pawn)\n        if total == 0:\n            val = 1.6\n        elif friendly == 0:\n            val = 0.9\n        else:\n            val = 0.0\n        if p.color == chess.WHITE:\n            score_w += val\n        else:\n            score_b += val\n    return float(score_w - score_b)\n\n\n",
    "def feature(board: chess.Board) -> float:\n    'Piece coordination: average pairwise manhattan distance among major/minor pieces (knight,bishop,rook,queen), smaller is better (white advantage if smaller than black)'\n    pm = board.piece_map()\n    types = (chess.KNIGHT, chess.BISHOP, chess.ROOK, chess.QUEEN)\n    def avg_pairwise(color):\n        squares = [sq for sq,p in pm.items() if p and p.piece_type in types and p.color == color]\n        n = len(squares)\n        if n < 2:\n            return None\n        total = 0.0\n        count = 0\n        for i in range(n):\n            for j in range(i+1, n):\n                total += chess.square_distance(squares[i], squares[j])\n                count += 1\n        return total / float(count) if count > 0 else None\n    ad_w = avg_pairwise(chess.WHITE)\n    ad_b = avg_pairwise(chess.BLACK)\n    if ad_w is None or ad_b is None:\n        # if one side has no pairable pieces, return difference favoring the side with more coordination (treat missing as large distance)\n        if ad_w is None and ad_b is None:\n            return 0.0\n        if ad_w is None:\n            return float(ad_b)  # black has average distance, white effectively large -> negative advantage so return positive ad_b\n        if ad_b is None:\n            return float(-ad_w)\n    # smaller distance = better coordination => positive when black avg > white avg\n    return float(ad_b - ad_w)\n\n\n",
    "def feature(board: chess.Board) -> float:\n    'Trapped/immobile high-value pieces under attack: sums values of opponent pieces with very low legal mobility and insufficient defenders (white advantage if black has more such pieces)'\n    values = {chess.PAWN:1.0, chess.KNIGHT:3.0, chess.BISHOP:3.0, chess.ROOK:5.0, chess.QUEEN:9.0, chess.KING:0.0}\n    pm = board.piece_map()\n    orig = board.turn\n    try:\n        # compute legal move counts for each color's pieces by toggling\n        move_counts = {chess.WHITE: {}, chess.BLACK: {}}\n        for color in (chess.WHITE, chess.BLACK):\n            board.turn = color\n            counts = {}\n            for mv in board.legal_moves:\n                counts[mv.from_square] = counts.get(mv.from_square, 0) + 1\n            move_counts[color] = counts\n    finally:\n        board.turn = orig\n    trapped_white = 0.0  # white pieces trapped and attacked by black\n    trapped_black = 0.0  # black pieces trapped and attacked by white\n    for sq,p in pm.items():\n        if not p or p.piece_type == chess.PAWN:\n            continue\n        mc = move_counts.get(p.color, {}).get(sq, 0)\n        # consider trapped if 0 or 1 legal moves\n        if mc <= 1:\n            opp = chess.BLACK if p.color == chess.WHITE else chess.WHITE\n            attackers = len(board.attackers(opp, sq))\n            defenders = len(board.attackers(p.color, sq))\n            if attackers > defenders:\n                val = values.get(p.piece_type, 0.0)\n                if p.color == chess.WHITE:\n                    trapped_white += val\n                else:\n                    trapped_black += val\n    # positive if White benefits (i.e., more trapped black pieces)\n    return float(trapped_black - trapped_white)\n\n\n",
    "def feature(board: chess.Board) -> float:\n    'Pawn island count difference: number of pawn islands (contiguous pawn-file groups) advantage (positive => White advantage if Black has more islands)'\n    pm = board.piece_map()\n    files_w = [0]*8\n    files_b = [0]*8\n    for sq,p in pm.items():\n        if not p or p.piece_type != chess.PAWN:\n            continue\n        f = chess.square_file(sq)\n        if p.color == chess.WHITE:\n            files_w[f] += 1\n        else:\n            files_b[f] += 1\n    def islands(files):\n        count = 0\n        i = 0\n        while i < 8:\n            if files[i] > 0:\n                count += 1\n                i += 1\n                while i < 8 and files[i] > 0:\n                    i += 1\n            else:\n                i += 1\n        return count\n    iw = islands(files_w)\n    ib = islands(files_b)\n    return float(ib - iw)\n\n\n",
    "def feature(board: chess.Board) -> float:\n    'Queen activity relative to minor piece activity: ratio queen_moves/(1+minor_moves) difference (white - black)'\n    orig = board.turn\n    try:\n        qm_w = 0\n        mm_w = 0\n        qm_b = 0\n        mm_b = 0\n        # White\n        board.turn = chess.WHITE\n        for mv in board.legal_moves:\n            p = board.piece_at(mv.from_square)\n            if not p:\n                continue\n            if p.color != chess.WHITE:\n                continue\n            if p.piece_type == chess.QUEEN:\n                qm_w += 1\n            if p.piece_type in (chess.KNIGHT, chess.BISHOP):\n                mm_w += 1\n        # Black\n        board.turn = chess.BLACK\n        for mv in board.legal_moves:\n            p = board.piece_at(mv.from_square)\n            if not p:\n                continue\n            if p.color != chess.BLACK:\n                continue\n            if p.piece_type == chess.QUEEN:\n                qm_b += 1\n            if p.piece_type in (chess.KNIGHT, chess.BISHOP):\n                mm_b += 1\n    finally:\n        board.turn = orig\n    ratio_w = qm_w / (1.0 + mm_w)\n    ratio_b = qm_b / (1.0 + mm_b)\n    return float(ratio_w - ratio_b)\n\n\n",
    "def feature(board: chess.Board) -> float:\n    'Non-pawn piece centralization: difference in average Euclidean distance of non-pawn pieces to board center (positive => White pieces more centralized)'\n    import math\n    pm = board.piece_map()\n    def avg_dist(color):\n        total = 0.0\n        count = 0\n        for sq,p in pm.items():\n            if not p or p.piece_type == chess.PAWN or p.piece_type == chess.KING:\n                continue\n            if p.color != color:\n                continue\n            f = chess.square_file(sq)\n            r = chess.square_rank(sq)\n            # center at (3.5, 3.5)\n            total += math.hypot(f - 3.5, r - 3.5)\n            count += 1\n        if count == 0:\n            return None\n        return total / count\n    adw = avg_dist(chess.WHITE)\n    adb = avg_dist(chess.BLACK)\n    if adw is None and adb is None:\n        return 0.0\n    if adw is None:\n        # white has no non-pawn non-king pieces => treat as far from center\n        adw = 10.0\n    if adb is None:\n        adb = 10.0\n    # smaller distance better, so positive if black avg > white avg\n    return float(adb - adw)\n\n\n",
    "def feature(board: chess.Board) -> float:\n    'Endgame king activity: in low-material positions rewards kings closer to center (positive => White king more central)'\n    import math\n    pm = board.piece_map()\n    # compute non-pawn non-king material\n    vals = {chess.KNIGHT:3.0, chess.BISHOP:3.0, chess.ROOK:5.0, chess.QUEEN:9.0}\n    tot = 0.0\n    for p in pm.values():\n        if p and p.piece_type in vals:\n            tot += vals[p.piece_type]\n    # threshold to consider endgame (no heavy material)\n    if tot > 10.0:\n        return 0.0\n    wk = next((sq for sq,p in pm.items() if p and p.piece_type == chess.KING and p.color == chess.WHITE), None)\n    bk = next((sq for sq,p in pm.items() if p and p.piece_type == chess.KING and p.color == chess.BLACK), None)\n    if wk is None or bk is None:\n        return 0.0\n    # Euclidean distance to center\n    def dist_to_center(sq):\n        f = chess.square_file(sq)\n        r = chess.square_rank(sq)\n        return math.hypot(f - 3.5, r - 3.5)\n    dw = dist_to_center(wk)\n    db = dist_to_center(bk)\n    # smaller distance is better for king activity, so positive if black is further than white\n    return float(db - dw)\n",
    "def feature(board: chess.Board) -> float:\n    'King pawn shield integrity: compares number of friendly pawns immediately in front of each king on the three central shield files (white - black)'\n    pm = board.piece_map()\n    def shield_count(color):\n        # find king\n        ks = next((sq for sq,p in pm.items() if p and p.piece_type == chess.KING and p.color == color), None)\n        if ks is None:\n            return 0.0\n        f = chess.square_file(ks); r = chess.square_rank(ks)\n        cnt = 0\n        for df in (-1,0,1):\n            tf = f + df\n            if not (0 <= tf <= 7):\n                continue\n            if color == chess.WHITE:\n                # count friendly pawns on the next two ranks in front of the king\n                for rr in (r+1, r+2):\n                    if 0 <= rr <= 7:\n                        p = board.piece_at(chess.square(tf, rr))\n                        if p and p.piece_type == chess.PAWN and p.color == color:\n                            cnt += 1\n            else:\n                for rr in (r-1, r-2):\n                    if 0 <= rr <= 7:\n                        p = board.piece_at(chess.square(tf, rr))\n                        if p and p.piece_type == chess.PAWN and p.color == color:\n                            cnt += 1\n        return float(cnt)\n    return float(shield_count(chess.WHITE) - shield_count(chess.BLACK))\n\n\n",
    "def feature(board: chess.Board) -> float:\n    'Rook file control: counts rooks on open files (no pawns) and semi-open files (only enemy pawns) (white - black)'\n    pm = board.piece_map()\n    def file_status(file_idx):\n        has_white_pawn = False\n        has_black_pawn = False\n        for r in range(8):\n            p = board.piece_at(chess.square(file_idx, r))\n            if p and p.piece_type == chess.PAWN:\n                if p.color == chess.WHITE:\n                    has_white_pawn = True\n                else:\n                    has_black_pawn = True\n        if not has_white_pawn and not has_black_pawn:\n            return 'open'\n        if has_white_pawn and not has_black_pawn:\n            return 'white'\n        if has_black_pawn and not has_white_pawn:\n            return 'black'\n        return 'mixed'\n    score_w = 0.0\n    score_b = 0.0\n    for sq, p in pm.items():\n        if not p or p.piece_type != chess.ROOK:\n            continue\n        f = chess.square_file(sq)\n        status = file_status(f)\n        if p.color == chess.WHITE:\n            if status == 'open':\n                score_w += 1.0\n            elif status == 'black':\n                score_w += 0.5\n        else:\n            if status == 'open':\n                score_b += 1.0\n            elif status == 'white':\n                score_b += 0.5\n    return float(score_w - score_b)\n\n\n",
    "def feature(board: chess.Board) -> float:\n    'Rooks on seventh rank: counts rooks sitting on the opponent seventh rank (white - black)'\n    pm = board.piece_map()\n    score_w = 0.0\n    score_b = 0.0\n    for sq, p in pm.items():\n        if not p or p.piece_type != chess.ROOK:\n            continue\n        r = chess.square_rank(sq)\n        if p.color == chess.WHITE and r == 6:\n            score_w += 1.0\n        if p.color == chess.BLACK and r == 1:\n            score_b += 1.0\n    return float(score_w - score_b)\n\n\n",
    "def feature(board: chess.Board) -> float:\n    'Bishop mobility and pair advantage: combines bishop legal mobility and bonus for bishop pair (white - black)'\n    orig = board.turn\n    try:\n        # mobility via legal move counts of bishops\n        board.turn = chess.WHITE\n        mob_w = 0\n        for mv in board.legal_moves:\n            p = board.piece_at(mv.from_square)\n            if p and p.piece_type == chess.BISHOP and p.color == chess.WHITE:\n                mob_w += 1\n        board.turn = chess.BLACK\n        mob_b = 0\n        for mv in board.legal_moves:\n            p = board.piece_at(mv.from_square)\n            if p and p.piece_type == chess.BISHOP and p.color == chess.BLACK:\n                mob_b += 1\n    finally:\n        board.turn = orig\n    # bishop pair bonus\n    bp_w = sum(1 for p in board.piece_map().values() if p and p.piece_type == chess.BISHOP and p.color == chess.WHITE) >= 2\n    bp_b = sum(1 for p in board.piece_map().values() if p and p.piece_type == chess.BISHOP and p.color == chess.BLACK) >= 2\n    score_w = float(mob_w) + (0.8 if bp_w else 0.0)\n    score_b = float(mob_b) + (0.8 if bp_b else 0.0)\n    return float((score_w - score_b) / 4.0)  # normalize somewhat\n\n\n",
    "def feature(board: chess.Board) -> float:\n    'Pawn structure weaknesses: penalizes doubled, isolated, and simple backward pawns (black - white, positive means Black worse)'\n    pm = board.piece_map()\n    # file pawn lists\n    files = {i: [] for i in range(8)}\n    for sq, p in pm.items():\n        if p and p.piece_type == chess.PAWN:\n            f = chess.square_file(sq)\n            files[f].append((sq, p.color))\n    def weakness(color):\n        doubled = 0.0\n        isolated = 0.0\n        backward = 0.0\n        # doubled\n        for f in range(8):\n            cnt = sum(1 for sq,c in files[f] if c == color)\n            if cnt > 1:\n                doubled += (cnt - 1) * 0.8\n        # isolated and backward (heuristic)\n        for f in range(8):\n            for sq,c in files[f]:\n                if c != color:\n                    continue\n                # isolated: no friendly pawn on adjacent files\n                adj = False\n                for af in (f-1, f+1):\n                    if 0 <= af <= 7 and any(pc == color for _, pc in files[af]):\n                        adj = True\n                        break\n                if not adj:\n                    isolated += 1.0\n                # backward: heuristic - no friendly pawn behind on adjacent files and forward square blocked by any piece\n                r = chess.square_rank(sq)\n                if color == chess.WHITE:\n                    ahead_r = r + 1\n                    behind_adj = any(( (chess.square_file(s2) in (f-1,f+1)) and (chess.square_rank(s2) < r) and pc == color) for s2,pc in pm.items() if pc and pc.piece_type==chess.PAWN) if False else False\n                    # due to API limitations, use simpler test:\n                    ahead_blocked = not (0 <= ahead_r <= 7) or (board.piece_at(chess.square(f, ahead_r)) is not None)\n                    if not adj and ahead_blocked:\n                        backward += 1.0\n                else:\n                    ahead_r = r - 1\n                    ahead_blocked = not (0 <= ahead_r <= 7) or (board.piece_at(chess.square(f, ahead_r)) is not None)\n                    if not adj and ahead_blocked:\n                        backward += 1.0\n        return doubled + isolated + backward\n    # positive if white has more weaknesses -> return white - black\n    w_weak = weakness(chess.WHITE)\n    b_weak = weakness(chess.BLACK)\n    return float(b_weak - w_weak)\n\n\n",
    "def feature(board: chess.Board) -> float:\n    'Pawn majority on sides: difference between maximal pawn majority on either wing (white - black), normalized'\n    pm = board.piece_map()\n    def counts(color):\n        left = 0\n        right = 0\n        for sq,p in pm.items():\n            if p and p.piece_type == chess.PAWN and p.color == color:\n                f = chess.square_file(sq)\n                if f <= 3:\n                    left += 1\n                else:\n                    right += 1\n        return max(left, right)\n    w = counts(chess.WHITE)\n    b = counts(chess.BLACK)\n    return float((w - b) / 8.0)\n\n\n",
    "def feature(board: chess.Board) -> float:\n    'Coordinated attacks: sum over squares of choose(n_attackers,2) for own pieces (white - black), measures multipiece coordination'\n    total_w = 0.0\n    total_b = 0.0\n    for sq in range(64):\n        aw = board.attackers(chess.WHITE, sq)\n        ab = board.attackers(chess.BLACK, sq)\n        nw = len(aw)\n        nb = len(ab)\n        if nw >= 2:\n            total_w += (nw * (nw - 1)) / 2.0\n        if nb >= 2:\n            total_b += (nb * (nb - 1)) / 2.0\n    # normalize by a reasonable factor\n    return float((total_w - total_b) / 10.0)\n\n\n",
    "def feature(board: chess.Board) -> float:\n    'Weighted pinned pieces: detects pieces pinned to the king by sliding opponents and sums their values (black - white)'\n    vals = {chess.PAWN:1.0, chess.KNIGHT:3.0, chess.BISHOP:3.0, chess.ROOK:5.0, chess.QUEEN:9.0}\n    pm = board.piece_map()\n    def pinned_sum(color):\n        # find king\n        ks = next((sq for sq,p in pm.items() if p and p.piece_type == chess.KING and p.color == color), None)\n        if ks is None:\n            return 0.0\n        kf = chess.square_file(ks); kr = chess.square_rank(ks)\n        pinned = 0.0\n        dirs = [(-1,-1),(-1,0),(-1,1),(0,-1),(0,1),(1,-1),(1,0),(1,1)]\n        for df, dr in dirs:\n            found_first = None\n            f = kf + df; r = kr + dr\n            while 0 <= f <= 7 and 0 <= r <= 7:\n                sq = chess.square(f, r)\n                p = board.piece_at(sq)\n                if p:\n                    if found_first is None:\n                        # first piece between king and potential attacker\n                        found_first = (sq, p)\n                    else:\n                        # second piece encountered -> could be attacker\n                        attacker_sq, attacker = sq, p\n                        # determine if attacker can slide along this direction\n                        if attacker.color != color:\n                            # orthogonal or diagonal?\n                            if df == 0 or dr == 0:\n                                if attacker.piece_type in (chess.ROOK, chess.QUEEN):\n                                    # first piece pinned\n                                    if found_first and found_first[1].color == color and found_first[1].piece_type != chess.KING:\n                                        pinned += vals.get(found_first[1].piece_type, 0.0)\n                                # else not pin\n                            else:\n                                if attacker.piece_type in (chess.BISHOP, chess.QUEEN):\n                                    if found_first and found_first[1].color == color and found_first[1].piece_type != chess.KING:\n                                        pinned += vals.get(found_first[1].piece_type, 0.0)\n                        # stop scanning this ray\n                        break\n                f += df; r += dr\n        return pinned\n    w_pinned = pinned_sum(chess.WHITE)\n    b_pinned = pinned_sum(chess.BLACK)\n    # positive means White is more pinned (worse), so return black - white to be positive if White better\n    return float(b_pinned - w_pinned)\n\n\n",
    "def feature(board: chess.Board) -> float:\n    'King centralization in endgames: advantage for side with more centralized king when non-pawn material is low (positive => White advantage)'\n    import math\n    pm = board.piece_map()\n    nonpawn_material = 0.0\n    vals = {chess.KNIGHT:3.0, chess.BISHOP:3.0, chess.ROOK:5.0, chess.QUEEN:9.0}\n    wk = None; bk = None\n    for sq,p in pm.items():\n        if not p:\n            continue\n        if p.piece_type == chess.KING:\n            if p.color == chess.WHITE:\n                wk = sq\n            else:\n                bk = sq\n            continue\n        nonpawn_material += vals.get(p.piece_type, 0.0)\n    if wk is None or bk is None:\n        return 0.0\n    if nonpawn_material > 10.0:\n        return 0.0\n    # distance to center\n    def center_dist(sq):\n        f = chess.square_file(sq); r = chess.square_rank(sq)\n        return math.hypot(f - 3.5, r - 3.5)\n    dw = center_dist(wk)\n    db = center_dist(bk)\n    # smaller is better; positive if White king is more centralized\n    return float((db - dw) / 4.0)\n\n\n",
    "def feature(board: chess.Board) -> float:\n    'Queen threat score: rewards positions where opponent queen is attacked more than defended (white advantage positive)'\n    pm = board.piece_map()\n    def threat_for_color(color):\n        score = 0.0\n        for sq,p in pm.items():\n            if p and p.piece_type == chess.QUEEN and p.color == color:\n                attackers = len(board.attackers(chess.WHITE if color == chess.BLACK else chess.BLACK, sq))\n                defenders = len(board.attackers(color, sq))\n                # threat intensity: more attackers than defenders\n                diff = max(0, attackers - defenders)\n                score += diff * 1.0  # each net attacker counts\n        return score\n    # positive if Black queen threatened (good for White)\n    b_threat = threat_for_color(chess.BLACK)\n    w_threat = threat_for_color(chess.WHITE)\n    return float(b_threat - w_threat)\n",
    "def feature(board: chess.Board) -> float:\n    'Pawn island difference: number of pawn islands (white - black), positive if White has fewer pawn islands (better)'\n    pm = board.piece_map()\n    def pawn_islands(color):\n        files = [False] * 8\n        for sq, p in pm.items():\n            if p and p.piece_type == chess.PAWN and p.color == color:\n                files[chess.square_file(sq)] = True\n        islands = 0\n        i = 0\n        while i < 8:\n            if files[i]:\n                islands += 1\n                while i < 8 and files[i]:\n                    i += 1\n            else:\n                i += 1\n        return islands\n    try:\n        w = pawn_islands(chess.WHITE)\n        b = pawn_islands(chess.BLACK)\n        # fewer islands is better; return (black - white) so positive favors White\n        return float(b - w)\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'King pawn shield strength: normalized count of friendly pawns in front of king within 2 ranks and adjacent files (white - black)'\n    import math\n    pm = board.piece_map()\n    def shield_strength(color):\n        # find king\n        ksq = next((sq for sq,p in pm.items() if p and p.piece_type == chess.KING and p.color == color), None)\n        if ksq is None:\n            return 0.0\n        kf = chess.square_file(ksq); kr = chess.square_rank(ksq)\n        count = 0\n        for df in (-1, 0, 1):\n            f = kf + df\n            if f < 0 or f > 7:\n                continue\n            # check one and two squares ahead depending on color\n            if color == chess.WHITE:\n                for dr in (1, 2):\n                    r = kr + dr\n                    if 0 <= r <= 7:\n                        if isinstance(board.piece_at(chess.square(f, r)), chess.Piece) and board.piece_at(chess.square(f, r)).piece_type == chess.PAWN and board.piece_at(chess.square(f, r)).color == color:\n                            count += 1\n            else:\n                for dr in (1, 2):\n                    r = kr - dr\n                    if 0 <= r <= 7:\n                        if isinstance(board.piece_at(chess.square(f, r)), chess.Piece) and board.piece_at(chess.square(f, r)).piece_type == chess.PAWN and board.piece_at(chess.square(f, r)).color == color:\n                            count += 1\n        # max possible is 6 (3 files * 2 ranks)\n        return float(count) / 6.0\n    try:\n        return float(shield_strength(chess.WHITE) - shield_strength(chess.BLACK))\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Structural weaknesses: weighted (doubled + isolated + backward pawn) penalty (white - black)'\n    pm = board.piece_map()\n    values = { 'doubled':1.0, 'isolated':0.8, 'backward':0.9 }\n    def counts(color):\n        # file pawn counts\n        file_counts = [0]*8\n        pawns = []\n        for sq,p in pm.items():\n            if p and p.piece_type == chess.PAWN and p.color == color:\n                f = chess.square_file(sq); r = chess.square_rank(sq)\n                file_counts[f] += 1\n                pawns.append((sq,f,r))\n        doubled = sum(max(0, c-1) for c in file_counts)\n        isolated = 0\n        backward = 0\n        for sq,f,r in pawns:\n            # isolated if no friendly pawn on adjacent files\n            adj = False\n            for af in (f-1, f+1):\n                if 0 <= af <= 7 and file_counts[af] > 0:\n                    adj = True; break\n            if not adj:\n                isolated += 1\n            # backward (approx): no friendly pawn on adjacent files with rank behind or equal and square ahead is attacked by enemy and not defended\n            if color == chess.WHITE:\n                ahead_r = r + 1\n                if ahead_r <= 7:\n                    ahead_sq = chess.square(f, ahead_r)\n                    enemy = chess.BLACK\n                    own = chess.WHITE\n                    attacked = board.is_attacked_by(enemy, ahead_sq)\n                    defended = board.is_attacked_by(own, ahead_sq)\n                    # check for friendly pawn on adjacent files on same or lower ranks\n                    support_adj = False\n                    for af in (f-1, f+1):\n                        if 0 <= af <= 7:\n                            for rr in range(0, r+1):\n                                p = board.piece_at(chess.square(af, rr))\n                                if p and p.piece_type == chess.PAWN and p.color == color:\n                                    support_adj = True; break\n                            if support_adj:\n                                break\n                    if attacked and not defended and not support_adj:\n                        backward += 1\n            else:\n                ahead_r = r - 1\n                if ahead_r >= 0:\n                    ahead_sq = chess.square(f, ahead_r)\n                    enemy = chess.WHITE\n                    own = chess.BLACK\n                    attacked = board.is_attacked_by(enemy, ahead_sq)\n                    defended = board.is_attacked_by(own, ahead_sq)\n                    support_adj = False\n                    for af in (f-1, f+1):\n                        if 0 <= af <= 7:\n                            for rr in range(r, 8):\n                                p = board.piece_at(chess.square(af, rr))\n                                if p and p.piece_type == chess.PAWN and p.color == color:\n                                    support_adj = True; break\n                            if support_adj:\n                                break\n                    if attacked and not defended and not support_adj:\n                        backward += 1\n        score = values['doubled'] * doubled + values['isolated'] * isolated + values['backward'] * backward\n        return score\n    try:\n        w = counts(chess.WHITE)\n        b = counts(chess.BLACK)\n        # penalty: lower is better, so positive if Black has higher penalty (good for White)\n        return float(b - w)\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Rook file activity: rooks on open files (1.0) or semi-open files (0.5) (white - black)'\n    pm = board.piece_map()\n    def score(color):\n        # pawn presence per file\n        pawns_on_file = [0]*8\n        own_pawns_on_file = [0]*8\n        for sq,p in pm.items():\n            if p and p.piece_type == chess.PAWN:\n                f = chess.square_file(sq)\n                pawns_on_file[f] += 1\n                if p.color == color:\n                    own_pawns_on_file[f] += 1\n        s = 0.0\n        for sq,p in pm.items():\n            if p and p.piece_type == chess.ROOK and p.color == color:\n                f = chess.square_file(sq)\n                if pawns_on_file[f] == 0:\n                    s += 1.0\n                elif own_pawns_on_file[f] == 0:\n                    s += 0.5\n        return s\n    try:\n        return float(score(chess.WHITE) - score(chess.BLACK))\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Knights on outposts: knights defended by a pawn and not challengeable by enemy pawns (white - black)'\n    pm = board.piece_map()\n    def outpost_count(color):\n        cnt = 0.0\n        for sq,p in pm.items():\n            if p and p.piece_type == chess.KNIGHT and p.color == color:\n                f = chess.square_file(sq); r = chess.square_rank(sq)\n                # defended by pawn?\n                defenders = board.attackers(color, sq)\n                defended_by_pawn = any((board.piece_at(a) and board.piece_at(a).piece_type == chess.PAWN and board.piece_at(a).color == color) for a in defenders)\n                if not defended_by_pawn:\n                    continue\n                # check enemy pawns on adjacent files that can challenge (on ranks on the advancing side)\n                contested = False\n                enemy = chess.BLACK if color == chess.WHITE else chess.WHITE\n                for af in (f-1, f+1):\n                    if 0 <= af <= 7:\n                        for sq2, pp in pm.items():\n                            if pp and pp.piece_type == chess.PAWN and pp.color == enemy:\n                                ff = chess.square_file(sq2); rr = chess.square_rank(sq2)\n                                if ff == af:\n                                    if color == chess.WHITE:\n                                        # enemy pawn ahead of or on same rank can challenge\n                                        if rr > r:\n                                            contested = True; break\n                                    else:\n                                        if rr < r:\n                                            contested = True; break\n                        if contested:\n                            break\n                if not contested:\n                    cnt += 1.0\n        return cnt\n    try:\n        return float(outpost_count(chess.WHITE) - outpost_count(chess.BLACK))\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Bishop mobility impairment: average number of same-color pawns on bishop-square-color (white - black), lower is better'\n    pm = board.piece_map()\n    def avg_block(color):\n        bishops = [sq for sq,p in pm.items() if p and p.piece_type == chess.BISHOP and p.color == color]\n        if not bishops:\n            return 0.0\n        pawns = [sq for sq,p in pm.items() if p and p.piece_type == chess.PAWN and p.color == color]\n        pawn_color_squares = set(((chess.square_file(sq) + chess.square_rank(sq)) & 1) for sq in pawns)\n        # For each bishop count number of friendly pawns on same colored squares (approx)\n        total = 0.0\n        for b in bishops:\n            b_color = (chess.square_file(b) + chess.square_rank(b)) & 1\n            same = 0\n            for p_sq in pawns:\n                if ((chess.square_file(p_sq) + chess.square_rank(p_sq)) & 1) == b_color:\n                    same += 1\n            total += same\n        return total / float(len(bishops))\n    try:\n        w = avg_block(chess.WHITE)\n        b = avg_block(chess.BLACK)\n        # fewer same-color pawns is better; positive if White is better => black_avg - white_avg\n        return float(b - w)\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'King centrality with phase awareness: central king is good in endgame, bad in middlegame; positive => White advantage'\n    import math\n    pm = board.piece_map()\n    vals = {chess.KNIGHT:3.0, chess.BISHOP:3.0, chess.ROOK:5.0, chess.QUEEN:9.0}\n    tot = 0.0\n    for p in pm.values():\n        if p and p.piece_type in vals:\n            tot += vals[p.piece_type]\n    wk = next((sq for sq,p in pm.items() if p and p.piece_type == chess.KING and p.color == chess.WHITE), None)\n    bk = next((sq for sq,p in pm.items() if p and p.piece_type == chess.KING and p.color == chess.BLACK), None)\n    if wk is None or bk is None:\n        return 0.0\n    def dist(sq):\n        f = chess.square_file(sq); r = chess.square_rank(sq)\n        return math.hypot(f - 3.5, r - 3.5)\n    dw = dist(wk); db = dist(bk)\n    # phase: if many pieces (middlegame) central king is bad (-), if few pieces (endgame) central is good (+)\n    sign = -1.0 if tot > 14.0 else 1.0\n    # smaller distance = more central; we want positive when white is advantaged\n    # So compute (db - dw) then apply sign: if sign=-1 and white more central (dw smaller) then (db-dw)>0 => sign*- => negative (bad for white)\n    return float(sign * (db - dw))\n\n",
    "def feature(board: chess.Board) -> float:\n    'Hanging piece net value: sum of values of attacked-but-underdefended pieces (black_hanging - white_hanging), positive favors White'\n    values = {chess.PAWN:1.0, chess.KNIGHT:3.0, chess.BISHOP:3.0, chess.ROOK:5.0, chess.QUEEN:9.0, chess.KING:0.0}\n    pm = board.piece_map()\n    white_hang = 0.0\n    black_hang = 0.0\n    for sq,p in pm.items():\n        if not p:\n            continue\n        own = p.color\n        enemy = chess.BLACK if own == chess.WHITE else chess.WHITE\n        attackers = len(board.attackers(enemy, sq))\n        defenders = len(board.attackers(own, sq))\n        if attackers > defenders:\n            val = values.get(p.piece_type, 0.0)\n            if own == chess.WHITE:\n                white_hang += val\n            else:\n                black_hang += val\n    # black_hang being large is good for white\n    try:\n        return float(black_hang - white_hang)\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Central control index: weighted attackers of d4,e4,d5,e5 (white - black), positive favors White'\n    centers = [chess.parse_square(s) for s in ('d4','e4','d5','e5')]\n    weights = {chess.PAWN:1.0, chess.KNIGHT:3.0, chess.BISHOP:3.0, chess.ROOK:5.0, chess.QUEEN:9.0, chess.KING:0.0}\n    total_w = 0.0\n    total_b = 0.0\n    pm = board.piece_map()\n    for c in centers:\n        aw = board.attackers(chess.WHITE, c)\n        for a in aw:\n            p = board.piece_at(a)\n            if p:\n                total_w += weights.get(p.piece_type, 0.0)\n        ab = board.attackers(chess.BLACK, c)\n        for a in ab:\n            p = board.piece_at(a)\n            if p:\n                total_b += weights.get(p.piece_type, 0.0)\n    return float(total_w - total_b)\n\n",
    "def feature(board: chess.Board) -> float:\n    'Pawn majority potential on a flank: max side-majority advantage for White minus Black (positive favors White)'\n    pm = board.piece_map()\n    def side_counts(color):\n        q = 0; k = 0\n        for sq,p in pm.items():\n            if p and p.piece_type == chess.PAWN and p.color == color:\n                f = chess.square_file(sq)\n                if f <= 3:\n                    q += 1\n                else:\n                    k += 1\n        return q, k\n    try:\n        wq, wk = side_counts(chess.WHITE)\n        bq, bk = side_counts(chess.BLACK)\n        w_adv = max(0, wq - bq, wk - bk)\n        b_adv = max(0, bq - wq, bk - wk)\n        return float(w_adv - b_adv)\n    except Exception:\n        return 0.0\n",
    "def feature(board: chess.Board) -> float:\n    'King proximity weighted by material imbalance: (white material - black material) * closeness factor (positive favors White)'\n    try:\n        vals = {chess.PAWN:1.0, chess.KNIGHT:3.0, chess.BISHOP:3.0, chess.ROOK:5.0, chess.QUEEN:9.0, chess.KING:0.0}\n        mat_w = 0.0; mat_b = 0.0\n        for p in board.piece_map().values():\n            if p.color == chess.WHITE:\n                mat_w += vals.get(p.piece_type, 0.0)\n            else:\n                mat_b += vals.get(p.piece_type, 0.0)\n        # find kings\n        pm = board.piece_map()\n        wk = next((sq for sq,p in pm.items() if p and p.piece_type == chess.KING and p.color == chess.WHITE), None)\n        bk = next((sq for sq,p in pm.items() if p and p.piece_type == chess.KING and p.color == chess.BLACK), None)\n        if wk is None or bk is None:\n            return 0.0\n        # Manhattan distance max = 14\n        d = chess.square_distance(wk, bk)\n        closeness = (14.0 - float(d)) / 14.0\n        return float((mat_w - mat_b) * closeness)\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Central control balance: sum of attackers on central squares (d4,e4,d5,e5) (white - black)'\n    try:\n        central = [chess.parse_square(s) for s in ('d4','e4','d5','e5')]\n        aw = 0.0; ab = 0.0\n        for sq in central:\n            aw += len(board.attackers(chess.WHITE, sq))\n            ab += len(board.attackers(chess.BLACK, sq))\n        # normalize by 4 squares\n        return float((aw - ab) / 4.0)\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Rook activity on open/semi-open files: +1 for each rook on open file, +0.5 for semi-open (white - black)'\n    try:\n        pm = board.piece_map()\n        file_pawn_counts = [0]*8\n        for sq,p in pm.items():\n            if p and p.piece_type == chess.PAWN:\n                file_pawn_counts[chess.square_file(sq)] += 1\n        def rook_score_for_color(color):\n            s = 0.0\n            for sq,p in pm.items():\n                if p and p.piece_type == chess.ROOK and p.color == color:\n                    f = chess.square_file(sq)\n                    if file_pawn_counts[f] == 0:\n                        s += 1.0\n                    else:\n                        # semi-open if no friendly pawns on that file\n                        friendly_pawns_on_file = any((pp and pp.piece_type==chess.PAWN and pp.color==color) for ss,pp in pm.items() if chess.square_file(ss)==f)\n                        if not friendly_pawns_on_file:\n                            s += 0.5\n            return s\n        return float(rook_score_for_color(chess.WHITE) - rook_score_for_color(chess.BLACK))\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Trapped/immobile high-value pieces: weighted penalty for non-pawn pieces with <=1 legal move and attacked>defended (black_penalty - white_penalty)'\n    try:\n        vals = {chess.KNIGHT:3.0, chess.BISHOP:3.0, chess.ROOK:5.0, chess.QUEEN:9.0, chess.KING:0.0}\n        pm = board.piece_map()\n        white_pen = 0.0; black_pen = 0.0\n        orig = board.turn\n        try:\n            for sq,p in list(pm.items()):\n                if p is None or p.piece_type == chess.PAWN:\n                    continue\n                # count legal moves for that piece by temporarily setting turn\n                board.turn = p.color\n                moves = 0\n                for mv in board.legal_moves:\n                    if mv.from_square == sq:\n                        moves += 1\n                        if moves > 1:\n                            break\n                attackers = len(board.attackers(not p.color, sq))\n                defenders = len(board.attackers(p.color, sq))\n                if moves <= 1 and attackers > defenders:\n                    weight = vals.get(p.piece_type, 0.0)\n                    if p.color == chess.WHITE:\n                        white_pen += weight\n                    else:\n                        black_pen += weight\n        finally:\n            board.turn = orig\n        # return black_pen - white_pen so positive favors White (Black more penalized)\n        return float(black_pen - white_pen)\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Passed pawn potential: sum distance-to-promotion for passed pawns (white - black), decreased if blocked by pieces'\n    try:\n        pm = board.piece_map()\n        def is_passed(sq, color):\n            f = chess.square_file(sq); r = chess.square_rank(sq)\n            if color == chess.WHITE:\n                # any black pawn on same or adjacent files with rank > r blocks/potentially prevents passedness\n                for af in (f-1, f, f+1):\n                    if 0 <= af <= 7:\n                        for rr in range(r+1, 8):\n                            p = board.piece_at(chess.square(af, rr))\n                            if p and p.piece_type == chess.PAWN and p.color == chess.BLACK:\n                                return False\n                return True\n            else:\n                for af in (f-1, f, f+1):\n                    if 0 <= af <= 7:\n                        for rr in range(0, r):\n                            p = board.piece_at(chess.square(af, rr))\n                            if p and p.piece_type == chess.PAWN and p.color == chess.WHITE:\n                                return False\n                return True\n        wpot = 0.0; bpot = 0.0\n        for sq,p in pm.items():\n            if p and p.piece_type == chess.PAWN:\n                if is_passed(sq, p.color):\n                    r = chess.square_rank(sq)\n                    # distance to promotion\n                    if p.color == chess.WHITE:\n                        dist = 7 - r\n                        # penalize if any enemy piece sits on direct file between pawn and promotion\n                        blocked = any(board.piece_at(chess.square(chess.square_file(sq), rr)) is not None for rr in range(r+1, 8))\n                        wpot += (dist * (0.5 if blocked else 1.0))\n                    else:\n                        dist = r\n                        blocked = any(board.piece_at(chess.square(chess.square_file(sq), rr)) is not None for rr in range(0, r))\n                        bpot += (dist * (0.5 if blocked else 1.0))\n        return float(wpot - bpot)\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Rooks supporting passed pawns: count of rooks behind own passed pawns (white - black)'\n    try:\n        pm = board.piece_map()\n        def is_passed_sq(sq, color):\n            f = chess.square_file(sq); r = chess.square_rank(sq)\n            if color == chess.WHITE:\n                for af in (f-1, f, f+1):\n                    if 0 <= af <= 7:\n                        for rr in range(r+1, 8):\n                            p = board.piece_at(chess.square(af, rr))\n                            if p and p.piece_type == chess.PAWN and p.color == chess.BLACK:\n                                return False\n                return True\n            else:\n                for af in (f-1, f, f+1):\n                    if 0 <= af <= 7:\n                        for rr in range(0, r):\n                            p = board.piece_at(chess.square(af, rr))\n                            if p and p.piece_type == chess.PAWN and p.color == chess.WHITE:\n                                return False\n                return True\n        wcount = 0; bcount = 0\n        # gather rooks positions\n        rooks_w = [sq for sq,p in pm.items() if p and p.piece_type==chess.ROOK and p.color==chess.WHITE]\n        rooks_b = [sq for sq,p in pm.items() if p and p.piece_type==chess.ROOK and p.color==chess.BLACK]\n        for sq,p in pm.items():\n            if p and p.piece_type==chess.PAWN:\n                if is_passed_sq(sq, p.color):\n                    f = chess.square_file(sq); r = chess.square_rank(sq)\n                    if p.color == chess.WHITE:\n                        for r_sq in rooks_w:\n                            rf = chess.square_file(r_sq); rr = chess.square_rank(r_sq)\n                            if rf == f and rr < r:\n                                wcount += 1; break\n                    else:\n                        for r_sq in rooks_b:\n                            rf = chess.square_file(r_sq); rr = chess.square_rank(r_sq)\n                            if rf == f and rr > r:\n                                bcount += 1; break\n        return float(wcount - bcount)\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Bishop-pair mobility advantage: average legal moves per bishop when side has both bishops (white - black)'\n    try:\n        pm = board.piece_map()\n        def bishop_mobility(color):\n            bishops = [sq for sq,p in pm.items() if p and p.piece_type==chess.BISHOP and p.color==color]\n            if len(bishops) < 2:\n                return 0.0\n            orig = board.turn\n            try:\n                board.turn = color\n                move_counts = {sq:0 for sq in bishops}\n                for mv in board.legal_moves:\n                    if mv.from_square in move_counts:\n                        move_counts[mv.from_square] += 1\n                total = sum(move_counts.values())\n                return total / float(len(bishops))\n            finally:\n                board.turn = orig\n        return float(bishop_mobility(chess.WHITE) - bishop_mobility(chess.BLACK))\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Knight outpost score: count knights on outpost squares (no enemy pawn can attack square and own attackers >= enemy attackers) (white - black)'\n    try:\n        pm = board.piece_map()\n        def enemy_pawn_attacks_square(sq, enemy_color):\n            # check specific pawn attack squares for enemy pawns attacking sq\n            f = chess.square_file(sq); r = chess.square_rank(sq)\n            if enemy_color == chess.BLACK:\n                # black pawns attack from rank+1 same adjacent files\n                for af in (f-1, f+1):\n                    rr = r+1\n                    if 0 <= af <= 7 and rr <= 7:\n                        p = board.piece_at(chess.square(af, rr))\n                        if p and p.piece_type==chess.PAWN and p.color==chess.BLACK:\n                            return True\n            else:\n                for af in (f-1, f+1):\n                    rr = r-1\n                    if 0 <= af <= 7 and rr >= 0:\n                        p = board.piece_at(chess.square(af, rr))\n                        if p and p.piece_type==chess.PAWN and p.color==chess.WHITE:\n                            return True\n            return False\n        def outposts(color):\n            count = 0\n            for sq,p in pm.items():\n                if p and p.piece_type==chess.KNIGHT and p.color==color:\n                    # no enemy pawn attack\n                    if enemy_pawn_attacks_square(sq, chess.BLACK if color==chess.WHITE else chess.WHITE):\n                        continue\n                    # attackers/defenders balance\n                    enemy = chess.BLACK if color==chess.WHITE else chess.WHITE\n                    att = len(board.attackers(color, sq))\n                    defn = len(board.attackers(enemy, sq))\n                    if att >= defn and att > 0:\n                        count += 1\n            return count\n        return float(outposts(chess.WHITE) - outposts(chess.BLACK))\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Material concentration towards the center: sum(piece_value * centrality) (white - black), centrality favors central squares'\n    try:\n        vals = {chess.PAWN:1.0, chess.KNIGHT:3.0, chess.BISHOP:3.0, chess.ROOK:5.0, chess.QUEEN:9.0, chess.KING:0.0}\n        pm = board.piece_map()\n        wscore = 0.0; bscore = 0.0\n        # central weight: (4 - abs(file-3.5)) * (4 - abs(rank-3.5)), normalized later\n        for sq,p in pm.items():\n            if not p:\n                continue\n            f = chess.square_file(sq); r = chess.square_rank(sq)\n            wf = 4.0 - abs(float(f) - 3.5)\n            wr = 4.0 - abs(float(r) - 3.5)\n            centrality = max(0.01, wf * wr)  # avoid zero\n            if p.color == chess.WHITE:\n                wscore += vals.get(p.piece_type, 0.0) * centrality\n            else:\n                bscore += vals.get(p.piece_type, 0.0) * centrality\n        # normalize by max centrality approx 12.25 * max piece value sum (~ maybe 40)\n        norm = 12.25 * 10.0\n        return float((wscore - bscore) / norm)\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Tempo/mobility advantage: difference in legal moves for White and Black (positive favors White)'\n    try:\n        orig = board.turn\n        try:\n            board.turn = chess.WHITE\n            mob_w = sum(1 for _ in board.legal_moves)\n            board.turn = chess.BLACK\n            mob_b = sum(1 for _ in board.legal_moves)\n        finally:\n            board.turn = orig\n        # normalize by a typical maximum (approx 60)\n        return float((mob_w - mob_b) / 60.0)\n    except Exception:\n        return 0.0\n",
    "def feature(board: chess.Board) -> float:\n    'Hanging pieces: material value sum of pieces attacked by opponent and not defended (white - black)'\n    try:\n        values = {chess.PAWN:1.0, chess.KNIGHT:3.0, chess.BISHOP:3.0, chess.ROOK:5.0, chess.QUEEN:9.0, chess.KING:0.0}\n        pm = board.piece_map()\n        hang_w = 0.0\n        hang_b = 0.0\n        for sq, p in pm.items():\n            if p is None:\n                continue\n            opp = chess.BLACK if p.color == chess.WHITE else chess.WHITE\n            attackers = board.attackers(opp, sq)\n            if not attackers:\n                continue\n            defenders = board.attackers(p.color, sq)\n            # if attacked and not defended -> hanging\n            if len(defenders) == 0:\n                if p.color == chess.WHITE:\n                    hang_w += values.get(p.piece_type, 0.0)\n                else:\n                    hang_b += values.get(p.piece_type, 0.0)\n        return float(hang_b - hang_w)\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Bishop-pair bonus minus bad-bishop penalty (white - black): rewards pair and penalizes bishops blocked by same-colored pawns'\n    try:\n        pm = board.piece_map()\n        def score(color):\n            bishops = [sq for sq,p in pm.items() if p and p.color==color and p.piece_type==chess.BISHOP]\n            pawns = [sq for sq,p in pm.items() if p and p.color==color and p.piece_type==chess.PAWN]\n            pair_bonus = 0.6 if len(bishops) >= 2 else 0.0\n            bad_pen = 0.0\n            # For each bishop, penalize if there are many same-colored pawns on the same square color\n            for b in bishops:\n                bf = chess.square_file(b); br = chess.square_rank(b)\n                b_color = (bf + br) & 1\n                same_color_pawns = 0\n                for psq in pawns:\n                    pf = chess.square_file(psq); pr = chess.square_rank(psq)\n                    if ((pf + pr) & 1) == b_color:\n                        same_color_pawns += 1\n                # if many same-colored pawns relative to total pawns -> more likely \"bad\"\n                if pawns:\n                    frac = same_color_pawns / float(len(pawns))\n                    bad_pen += 0.4 * frac  # up to 0.4 penalty per bishop\n                else:\n                    bad_pen += 0.0\n            return pair_bonus - bad_pen\n        return float(score(chess.WHITE) - score(chess.BLACK))\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Rook activity: counts rooks on open/semi-open files and rooks on opponent seventh rank (white - black)'\n    try:\n        pm = board.piece_map()\n        def rook_score(color):\n            score = 0.0\n            own_pawns_by_file = [0]*8\n            any_pawns_by_file = [0]*8\n            for sq,p in pm.items():\n                if not p:\n                    continue\n                f = chess.square_file(sq)\n                if p.piece_type == chess.PAWN:\n                    any_pawns_by_file[f] += 1\n                    if p.color == color:\n                        own_pawns_by_file[f] += 1\n            for sq,p in pm.items():\n                if not p or p.piece_type != chess.ROOK or p.color != color:\n                    continue\n                f = chess.square_file(sq)\n                r = chess.square_rank(sq)\n                # open file: no pawns at all on file\n                if any_pawns_by_file[f] == 0:\n                    score += 1.0\n                # semi-open: no own pawns on file\n                elif own_pawns_by_file[f] == 0:\n                    score += 0.5\n                # seventh rank bonus\n                if color == chess.WHITE and r == 6:\n                    score += 1.0\n                if color == chess.BLACK and r == 1:\n                    score += 1.0\n            return score\n        return float((rook_score(chess.WHITE) - rook_score(chess.BLACK)) / 4.0)\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Pawn-side majority: best pawn majority on either king- or queen-side (positive favors White)'\n    try:\n        pm = board.piece_map()\n        def counts():\n            w_qs = w_ks = b_qs = b_ks = 0\n            for sq,p in pm.items():\n                if not p or p.piece_type != chess.PAWN:\n                    continue\n                f = chess.square_file(sq)\n                # queen-side files a-d -> 0..3 ; king-side e-h -> 4..7\n                if f <= 3:\n                    if p.color == chess.WHITE:\n                        w_qs += 1\n                    else:\n                        b_qs += 1\n                else:\n                    if p.color == chess.WHITE:\n                        w_ks += 1\n                    else:\n                        b_ks += 1\n            return (w_qs - b_qs, w_ks - b_ks)\n        qside, kside = counts()\n        # choose the more relevant majority (could be negative)\n        return float(max(qside, kside, key=lambda x: x) if (qside or kside) else max(qside, kside))\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Outposted knights: knights on advanced/supportive squares not attacked by enemy pawns (white - black)'\n    try:\n        pm = board.piece_map()\n        def is_attacked_by_pawn(color, sq):\n            opp = chess.BLACK if color == chess.WHITE else chess.WHITE\n            for a in board.attackers(opp, sq):\n                p = board.piece_at(a)\n                if p and p.piece_type == chess.PAWN and p.color == opp:\n                    return True\n            return False\n        def has_friendly_pawn_behind(color, sq):\n            f = chess.square_file(sq); r = chess.square_rank(sq)\n            if color == chess.WHITE:\n                for rr in range(0, r):\n                    p = board.piece_at(chess.square(f, rr))\n                    if p and p.piece_type == chess.PAWN and p.color == color:\n                        return True\n            else:\n                for rr in range(r+1, 8):\n                    p = board.piece_at(chess.square(f, rr))\n                    if p and p.piece_type == chess.PAWN and p.color == color:\n                        return True\n            return False\n        def score(color):\n            cnt = 0.0\n            for sq,p in pm.items():\n                if not p or p.piece_type != chess.KNIGHT or p.color != color:\n                    continue\n                r = chess.square_rank(sq)\n                # advanced-ish ranks: white ranks 3..6 (index 3..6), black ranks 1..4 (index 1..4)\n                if color == chess.WHITE and r < 3:\n                    continue\n                if color == chess.BLACK and r > 4:\n                    continue\n                # no friendly pawn behind on same file\n                if has_friendly_pawn_behind(color, sq):\n                    continue\n                # not attacked by enemy pawn\n                if is_attacked_by_pawn(color, sq):\n                    continue\n                # supported by at least one friendly piece (defended)\n                if len(board.attackers(color, sq)) == 0:\n                    continue\n                cnt += 1.0\n            return cnt\n        return float(score(chess.WHITE) - score(chess.BLACK))\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'King file openness: difference in number of open/semi-open files adjacent to kings (positive favors White)'\n    try:\n        pm = board.piece_map()\n        def open_files_adjacent(king_color):\n            # find king\n            ksq = next((sq for sq,p in pm.items() if p and p.piece_type == chess.KING and p.color == king_color), None)\n            if ksq is None:\n                return 0\n            kf = chess.square_file(ksq)\n            files = [f for f in (kf-1, kf, kf+1) if 0 <= f <= 7]\n            open_cnt = 0\n            for f in files:\n                has_any_pawn = False\n                for r in range(8):\n                    p = board.piece_at(chess.square(f, r))\n                    if p and p.piece_type == chess.PAWN:\n                        has_any_pawn = True\n                        break\n                if not has_any_pawn:\n                    open_cnt += 1\n            return open_cnt\n        w_open = open_files_adjacent(chess.WHITE)\n        b_open = open_files_adjacent(chess.BLACK)\n        # If Black's king has more open adjacent files that's bad for Black => positive for White\n        return float(b_open - w_open)\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Attacking major proximity: inverse-distance-weighted sum of queens/rooks near enemy king (white - black)'\n    try:\n        pm = board.piece_map()\n        vals = {chess.ROOK:5.0, chess.QUEEN:9.0}\n        # find kings\n        wk = next((sq for sq,p in pm.items() if p and p.piece_type==chess.KING and p.color==chess.WHITE), None)\n        bk = next((sq for sq,p in pm.items() if p and p.piece_type==chess.KING and p.color==chess.BLACK), None)\n        score_w = 0.0\n        score_b = 0.0\n        for sq,p in pm.items():\n            if not p:\n                continue\n            if p.piece_type in (chess.ROOK, chess.QUEEN):\n                if p.color == chess.WHITE and bk is not None:\n                    d = chess.square_distance(sq, bk)\n                    score_w += vals.get(p.piece_type, 0.0) / (1.0 + float(d))\n                if p.color == chess.BLACK and wk is not None:\n                    d = chess.square_distance(sq, wk)\n                    score_b += vals.get(p.piece_type, 0.0) / (1.0 + float(d))\n        return float(score_w - score_b)\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Average pawn advancement (space): mean normalized pawn rank (white higher -> positive) (white - black)'\n    try:\n        pm = board.piece_map()\n        w_sum = 0.0; w_count = 0\n        b_sum = 0.0; b_count = 0\n        for sq,p in pm.items():\n            if not p or p.piece_type != chess.PAWN:\n                continue\n            r = chess.square_rank(sq)\n            if p.color == chess.WHITE:\n                w_sum += (r / 7.0)\n                w_count += 1\n            else:\n                b_sum += ((7 - r) / 7.0)\n                b_count += 1\n        if w_count == 0 and b_count == 0:\n            return 0.0\n        w_avg = (w_sum / w_count) if w_count else 0.0\n        b_avg = (b_sum / b_count) if b_count else 0.0\n        return float(w_avg - b_avg)\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Pinned pieces weighted penalty: sum of values of pieces pinned to king (positive if Black has more pinned material -> good for White)'\n    try:\n        pm = board.piece_map()\n        values = {chess.PAWN:1.0, chess.KNIGHT:3.0, chess.BISHOP:3.0, chess.ROOK:5.0, chess.QUEEN:9.0, chess.KING:0.0}\n        def is_between(a_sq, b_sq, c_sq):\n            # return True if b_sq is strictly between a_sq and c_sq on a straight ray (rank/file/diag)\n            af = chess.square_file(a_sq); ar = chess.square_rank(a_sq)\n            bf = chess.square_file(b_sq); br = chess.square_rank(b_sq)\n            cf = chess.square_file(c_sq); cr = chess.square_rank(c_sq)\n            df = cf - af; dr = cr - ar\n            # determine step direction\n            step_f = 0 if df == 0 else (1 if df > 0 else -1)\n            step_r = 0 if dr == 0 else (1 if dr > 0 else -1)\n            # must be collinear in rook or bishop sense\n            if not (df == 0 or dr == 0 or abs(df) == abs(dr)):\n                return False\n            f = af + step_f; r = ar + step_r\n            found_b = False\n            while 0 <= f <= 7 and 0 <= r <= 7:\n                sq = chess.square(f, r)\n                if sq == b_sq:\n                    found_b = True\n                if sq == c_sq:\n                    return found_b\n                f += step_f; r += step_r\n            return False\n        white_pinned = 0.0\n        black_pinned = 0.0\n        # collect sliding opponent pieces\n        for color in (chess.WHITE, chess.BLACK):\n            opp = chess.BLACK if color == chess.WHITE else chess.WHITE\n            # locate king\n            king_sq = next((sq for sq,p in pm.items() if p and p.color==color and p.piece_type==chess.KING), None)\n            if king_sq is None:\n                continue\n            # for every opponent sliding piece, check if it pins exactly one piece between it and king\n            for opp_sq, opp_p in pm.items():\n                if not opp_p or opp_p.color != opp or opp_p.piece_type not in (chess.ROOK, chess.BISHOP, chess.QUEEN):\n                    continue\n                # check collinearity and whether there's exactly one intervening piece that belongs to 'color'\n                af = chess.square_file(king_sq); ar = chess.square_rank(king_sq)\n                cf = chess.square_file(opp_sq); cr = chess.square_rank(opp_sq)\n                df = cf - af; dr = cr - ar\n                if not (df == 0 or dr == 0 or abs(df) == abs(dr)):\n                    continue\n                # step from king towards opp\n                step_f = 0 if df == 0 else (1 if df > 0 else -1)\n                step_r = 0 if dr == 0 else (1 if dr > 0 else -1)\n                f = af + step_f; r = ar + step_r\n                blockers = []\n                while 0 <= f <= 7 and 0 <= r <= 7:\n                    sq = chess.square(f, r)\n                    if sq == opp_sq:\n                        break\n                    piece = board.piece_at(sq)\n                    if piece:\n                        blockers.append((sq, piece))\n                    f += step_f; r += step_r\n                # If exactly one blocker and it belongs to the king's color, it's pinned\n                if len(blockers) == 1 and blockers[0][1].color == color:\n                    pinned_piece = blockers[0][1]\n                    if color == chess.WHITE:\n                        white_pinned += values.get(pinned_piece.piece_type, 0.0)\n                    else:\n                        black_pinned += values.get(pinned_piece.piece_type, 0.0)\n        # positive if Black has more pinned material (good for White)\n        return float(black_pinned - white_pinned)\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Queen activity: mobility of queens (legal moves from queen square) plus centralization (white - black)'\n    try:\n        pm = board.piece_map()\n        orig = board.turn\n        try:\n            # mobility: count legal queen moves for each side\n            board.turn = chess.WHITE\n            mob_w = 0\n            for mv in board.legal_moves:\n                p = board.piece_at(mv.from_square)\n                if p and p.piece_type == chess.QUEEN and p.color == chess.WHITE:\n                    mob_w += 1\n            board.turn = chess.BLACK\n            mob_b = 0\n            for mv in board.legal_moves:\n                p = board.piece_at(mv.from_square)\n                if p and p.piece_type == chess.QUEEN and p.color == chess.BLACK:\n                    mob_b += 1\n        finally:\n            board.turn = orig\n        # centralization: closeness to center squares d4,e4,d5,e5\n        centers = [chess.parse_square(s) for s in ('d4','e4','d5','e5')]\n        def central_score(color):\n            qs = [sq for sq,p in pm.items() if p and p.color==color and p.piece_type==chess.QUEEN]\n            if not qs:\n                return 0.0\n            score = 0.0\n            for q in qs:\n                dmin = min(chess.square_distance(q, c) for c in centers)\n                score += (14.0 - float(dmin)) / 14.0\n            return score / len(qs)\n        central_w = central_score(chess.WHITE)\n        central_b = central_score(chess.BLACK)\n        # combine: mobility normalized (approx max mobility 28) plus central weight\n        val_w = (mob_w / 28.0) + central_w\n        val_b = (mob_b / 28.0) + central_b\n        return float(val_w - val_b)\n    except Exception:\n        return 0.0\n",
    "def feature(board: chess.Board) -> float:\n    'Loose piece vulnerability: net value of under-defended attacked pieces (positive => Black is more vulnerable => favors White)'\n    try:\n        weights = {chess.PAWN:1.0, chess.KNIGHT:3.0, chess.BISHOP:3.0, chess.ROOK:5.0, chess.QUEEN:9.0, chess.KING:0.0}\n        pm = board.piece_map()\n        vuln_w = 0.0\n        vuln_b = 0.0\n        for sq, p in pm.items():\n            if not p:\n                continue\n            opp = chess.WHITE if p.color == chess.BLACK else chess.BLACK\n            attackers = board.attackers(opp, sq)\n            defenders = board.attackers(p.color, sq)\n            vuln = max(0, len(attackers) - len(defenders))\n            val = weights.get(p.piece_type, 0.0) * float(vuln)\n            if p.color == chess.WHITE:\n                vuln_w += val\n            else:\n                vuln_b += val\n        # Positive if Black's vulnerabilities exceed White's (good for White)\n        return float(vuln_b - vuln_w)\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Passed pawn potential: weighted sum of passed pawns where advanced pawns score more (white - black)'\n    try:\n        pm = board.piece_map()\n        def is_passed(sq, color):\n            f = chess.square_file(sq)\n            r = chess.square_rank(sq)\n            if color == chess.WHITE:\n                # no black pawns on same or adjacent files in front (higher ranks)\n                for rf in range(r+1, 8):\n                    for ff in (f-1, f, f+1):\n                        if 0 <= ff <= 7:\n                            other = chess.square(ff, rf)\n                            p = pm.get(other)\n                            if p and p.piece_type == chess.PAWN and p.color == chess.BLACK:\n                                return False\n                return True\n            else:\n                for rf in range(0, r):\n                    for ff in (f-1, f, f+1):\n                        if 0 <= ff <= 7:\n                            other = chess.square(ff, rf)\n                            p = pm.get(other)\n                            if p and p.piece_type == chess.PAWN and p.color == chess.WHITE:\n                                return False\n                return True\n        score_w = 0.0\n        score_b = 0.0\n        for sq, p in pm.items():\n            if not p or p.piece_type != chess.PAWN:\n                continue\n            r = chess.square_rank(sq)\n            if p.color == chess.WHITE:\n                if is_passed(sq, chess.WHITE):\n                    # more advanced gets higher weight\n                    closeness = (r / 7.0) if r <= 7 else 1.0\n                    score_w += 1.0 + closeness * 2.0\n            else:\n                if is_passed(sq, chess.BLACK):\n                    closeness = ((7 - r) / 7.0) if r >= 0 else 1.0\n                    score_b += 1.0 + closeness * 2.0\n        return float(score_w - score_b)\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'King shelter: pawn shield quality in front of each king (positive => White has better shelter)'\n    try:\n        pm = board.piece_map()\n        def shelter_for_king(king_color):\n            # find king\n            ksq = next((sq for sq,p in pm.items() if p and p.piece_type == chess.KING and p.color == king_color), None)\n            if ksq is None:\n                return 0.0\n            f = chess.square_file(ksq)\n            r = chess.square_rank(ksq)\n            count = 0.0\n            maxcount = 0\n            if king_color == chess.WHITE:\n                for dr in (1, 2):\n                    maxcount += 3\n                    for df in (-1, 0, 1):\n                        rf = r + dr\n                        ff = f + df\n                        if 0 <= rf <= 7 and 0 <= ff <= 7:\n                            sq = chess.square(ff, rf)\n                            p = pm.get(sq)\n                            if p and p.piece_type == chess.PAWN and p.color == chess.WHITE:\n                                count += 1.0\n            else:\n                for dr in (1, 2):\n                    maxcount += 3\n                    for df in (-1, 0, 1):\n                        rf = r - dr\n                        ff = f + df\n                        if 0 <= rf <= 7 and 0 <= ff <= 7:\n                            sq = chess.square(ff, rf)\n                            p = pm.get(sq)\n                            if p and p.piece_type == chess.PAWN and p.color == chess.BLACK:\n                                count += 1.0\n            if maxcount == 0:\n                return 0.0\n            return count / float(maxcount)\n        return float(shelter_for_king(chess.WHITE) - shelter_for_king(chess.BLACK))\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Bishop pair and long-range potential: bishop-pair bonus plus summed unobstructed diagonal reach (white - black)'\n    try:\n        pm = board.piece_map()\n        dirs = ((1,1),(1,-1),(-1,1),(-1,-1))\n        def diag_reach(sq):\n            f0 = chess.square_file(sq)\n            r0 = chess.square_rank(sq)\n            cnt = 0\n            for df, dr in dirs:\n                f = f0 + df\n                r = r0 + dr\n                while 0 <= f <= 7 and 0 <= r <= 7:\n                    target = chess.square(f, r)\n                    cnt += 1\n                    if pm.get(target) is not None:\n                        break\n                    f += df; r += dr\n            return float(cnt)\n        score_w = 0.0\n        score_b = 0.0\n        bishops_w = 0\n        bishops_b = 0\n        for sq, p in pm.items():\n            if not p or p.piece_type != chess.BISHOP:\n                continue\n            reach = diag_reach(sq)\n            if p.color == chess.WHITE:\n                bishops_w += 1\n                score_w += reach\n            else:\n                bishops_b += 1\n                score_b += reach\n        if bishops_w >= 2:\n            score_w += 3.0\n        if bishops_b >= 2:\n            score_b += 3.0\n        # normalize by a reasonable factor to keep scale modest\n        norm = max(1.0, (score_w + score_b) / 2.0)\n        return float((score_w - score_b) / norm)\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Knight outposts: counts of advanced knights not attacked by enemy pawns (white - black)'\n    try:\n        pm = board.piece_map()\n        out_w = 0.0\n        out_b = 0.0\n        for sq, p in pm.items():\n            if not p or p.piece_type != chess.KNIGHT:\n                continue\n            f = chess.square_file(sq); r = chess.square_rank(sq)\n            if p.color == chess.WHITE:\n                # advanced rank threshold for outpost\n                if r < 3:\n                    continue\n                # check if any black pawn attacks this square\n                attacked_by_black_pawn = False\n                for df in (-1, 1):\n                    ff = f + df; rf = r + 1\n                    if 0 <= ff <= 7 and 0 <= rf <= 7:\n                        sqp = chess.square(ff, rf)\n                        pp = pm.get(sqp)\n                        if pp and pp.piece_type == chess.PAWN and pp.color == chess.BLACK:\n                            attacked_by_black_pawn = True\n                            break\n                if not attacked_by_black_pawn:\n                    out_w += 1.0\n            else:\n                if r > 4:\n                    continue\n                attacked_by_white_pawn = False\n                for df in (-1, 1):\n                    ff = f + df; rf = r - 1\n                    if 0 <= ff <= 7 and 0 <= rf <= 7:\n                        sqp = chess.square(ff, rf)\n                        pp = pm.get(sqp)\n                        if pp and pp.piece_type == chess.PAWN and pp.color == chess.WHITE:\n                            attacked_by_white_pawn = True\n                            break\n                if not attacked_by_white_pawn:\n                    out_b += 1.0\n        return float(out_w - out_b)\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Trapped pieces: number of non-pawn, non-king pieces that have no legal moves and are attacked (white - black)'\n    try:\n        pm = board.piece_map()\n        orig = board.turn\n        try:\n            board.turn = chess.WHITE\n            white_movers = set(mv.from_square for mv in board.legal_moves)\n            board.turn = chess.BLACK\n            black_movers = set(mv.from_square for mv in board.legal_moves)\n        finally:\n            board.turn = orig\n        trapped_w = 0.0\n        trapped_b = 0.0\n        for sq, p in pm.items():\n            if not p or p.piece_type in (chess.PAWN, chess.KING):\n                continue\n            opp = chess.BLACK if p.color == chess.WHITE else chess.WHITE\n            attacked = board.is_attacked_by(opp, sq)\n            if p.color == chess.WHITE:\n                if sq not in white_movers and attacked:\n                    trapped_w += 1.0\n            else:\n                if sq not in black_movers and attacked:\n                    trapped_b += 1.0\n        return float(trapped_b - trapped_w)\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Queen centralization: normalized difference in queen distance to center (positive => White more centralized)'\n    try:\n        centers = [chess.parse_square(s) for s in ('d4','e4','d5','e5')]\n        def min_center_dist_for_color(color):\n            pm = board.piece_map()\n            qsq = next((sq for sq,p in pm.items() if p and p.piece_type == chess.QUEEN and p.color == color), None)\n            if qsq is None:\n                return 14.0\n            return min(chess.square_distance(qsq, c) for c in centers)\n        dw = min_center_dist_for_color(chess.WHITE)\n        db = min_center_dist_for_color(chess.BLACK)\n        # smaller distance is better; return positive if White better: (db - dw) normalized by max dist 14\n        return float((db - dw) / 14.0)\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Doubled rooks on same file and file openness bonus (white - black)'\n    try:\n        pm = board.piece_map()\n        any_pawns_by_file = [0]*8\n        rooks_by_file_w = [0]*8\n        rooks_by_file_b = [0]*8\n        for sq, p in pm.items():\n            if not p:\n                continue\n            f = chess.square_file(sq)\n            if p.piece_type == chess.PAWN:\n                any_pawns_by_file[f] += 1\n            if p.piece_type == chess.ROOK:\n                if p.color == chess.WHITE:\n                    rooks_by_file_w[f] += 1\n                else:\n                    rooks_by_file_b[f] += 1\n        score_w = 0.0\n        score_b = 0.0\n        for f in range(8):\n            if rooks_by_file_w[f] >= 2:\n                bonus = 1.0\n                if any_pawns_by_file[f] == 0:\n                    bonus += 1.0\n                elif any_pawns_by_file[f] == rooks_by_file_b[f] == 0:\n                    bonus += 0.5\n                score_w += bonus\n            if rooks_by_file_b[f] >= 2:\n                bonus = 1.0\n                if any_pawns_by_file[f] == 0:\n                    bonus += 1.0\n                elif any_pawns_by_file[f] == rooks_by_file_w[f] == 0:\n                    bonus += 0.5\n                score_b += bonus\n        return float(score_w - score_b)\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Tempo-to-promotion: difference in minimum pawn push distance to promotion (positive => White closer)'\n    try:\n        pm = board.piece_map()\n        min_white = 100\n        min_black = 100\n        for sq, p in pm.items():\n            if not p or p.piece_type != chess.PAWN:\n                continue\n            r = chess.square_rank(sq)\n            if p.color == chess.WHITE:\n                dist = 7 - r\n                if dist < min_white:\n                    min_white = dist\n            else:\n                dist = r\n                if dist < min_black:\n                    min_black = dist\n        if min_white == 100:\n            min_white = 10\n        if min_black == 100:\n            min_black = 10\n        # positive if White closer: (black_min - white_min) normalized by 8\n        return float((min_black - min_white) / 8.0)\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Coordination index: difference in number of common attacked squares by pairs of own pieces (white - black), higher = better coordination'\n    try:\n        pm = board.piece_map()\n        def coord_score(color):\n            # build attacked squares per piece by checking attackers sets\n            attacks = {}\n            for sq in range(64):\n                attackers = board.attackers(color, sq)\n                for a in attackers:\n                    attacks.setdefault(a, set()).add(sq)\n            pieces = [sq for sq,p in pm.items() if p and p.color == color and p.piece_type != chess.KING]\n            score = 0\n            L = len(pieces)\n            for i in range(L):\n                ai = attacks.get(pieces[i], set())\n                for j in range(i+1, L):\n                    aj = attacks.get(pieces[j], set())\n                    # count unique common targets\n                    common = ai.intersection(aj)\n                    score += len(common)\n            return float(score)\n        return float(coord_score(chess.WHITE) - coord_score(chess.BLACK))\n    except Exception:\n        return 0.0\n",
    "def feature(board: chess.Board) -> float:\n    'Passed pawn potential: advanced passed pawns weighted by progress (positive favors White)'\n    try:\n        pm = board.piece_map()\n        def is_passed(sq, color):\n            f = chess.square_file(sq); r = chess.square_rank(sq)\n            if color == chess.WHITE:\n                # any black pawn on same or adjacent file ahead blocks being passed\n                for af in (f-1, f, f+1):\n                    if 0 <= af <= 7:\n                        for ar in range(r+1, 8):\n                            a_sq = ar*8 + af\n                            p = pm.get(a_sq)\n                            if p and p.piece_type == chess.PAWN and p.color == chess.BLACK:\n                                return False\n                return True\n            else:\n                for af in (f-1, f, f+1):\n                    if 0 <= af <= 7:\n                        for ar in range(0, r):\n                            a_sq = ar*8 + af\n                            p = pm.get(a_sq)\n                            if p and p.piece_type == chess.PAWN and p.color == chess.WHITE:\n                                return False\n                return True\n        score_w = 0.0; score_b = 0.0\n        for sq,p in pm.items():\n            if not p or p.piece_type != chess.PAWN:\n                continue\n            r = chess.square_rank(sq)\n            if is_passed(sq, p.color):\n                # progress: how advanced toward promotion (0..1)\n                if p.color == chess.WHITE:\n                    progress = float(r) / 7.0\n                else:\n                    progress = float(7 - r) / 7.0\n                val = 1.0 + 1.5 * progress  # passed pawn base + progress bonus\n                if p.color == chess.WHITE:\n                    score_w += val\n                else:\n                    score_b += val\n        return float(score_w - score_b)\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Pawn structural weakness metric: doubled and isolated pawn penalties (white - black)'\n    try:\n        pm = board.piece_map()\n        pawns_files = {chess.WHITE: [0]*8, chess.BLACK: [0]*8}\n        for sq,p in pm.items():\n            if p and p.piece_type == chess.PAWN:\n                pawns_files[p.color][chess.square_file(sq)] += 1\n        def weaknesses(color):\n            doubled = sum(1 for c in pawns_files[color] if c > 1)\n            isolated = 0\n            for f in range(8):\n                if pawns_files[color][f] == 0:\n                    continue\n                left = pawns_files[color][f-1] if f-1 >= 0 else 0\n                right = pawns_files[color][f+1] if f+1 <= 7 else 0\n                if left + right == 0:\n                    isolated += pawns_files[color][f]  # each pawn on isolated file counts\n            # normalize roughly\n            return float(doubled)*0.7 + float(isolated)*1.0\n        return float(weaknesses(chess.BLACK) - weaknesses(chess.WHITE))\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'King pawn shield integrity: count of friendly pawns near king front (positive favors White)'\n    try:\n        pm = board.piece_map()\n        def shield_score(color):\n            # find king\n            king_sq = next((sq for sq,p in pm.items() if p and p.piece_type == chess.KING and p.color == color), None)\n            if king_sq is None:\n                return 0.0\n            kf = chess.square_file(king_sq); kr = chess.square_rank(king_sq)\n            score = 0\n            if color == chess.WHITE:\n                ranks = [kr+1, kr+2]\n            else:\n                ranks = [kr-1, kr-2]\n            for rf in ranks:\n                if rf < 0 or rf > 7:\n                    continue\n                for ff in (kf-1, kf, kf+1):\n                    if 0 <= ff <= 7:\n                        sq = rf*8 + ff\n                        p = pm.get(sq)\n                        if p and p.piece_type == chess.PAWN and p.color == color:\n                            score += 1\n            # small bonus if king appears castled (common squares)\n            if color == chess.WHITE:\n                if king_sq == chess.parse_square('g1') or king_sq == chess.parse_square('c1'):\n                    score += 0.8\n            else:\n                if king_sq == chess.parse_square('g8') or king_sq == chess.parse_square('c8'):\n                    score += 0.8\n            return float(score)\n        return float(shield_score(chess.WHITE) - shield_score(chess.BLACK))\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Knights on supported outposts (no enemy pawns can attack the square and supported by a pawn) (white - black)'\n    try:\n        pm = board.piece_map()\n        def is_supported_pawn(color, sq):\n            f = chess.square_file(sq); r = chess.square_rank(sq)\n            if color == chess.WHITE:\n                # white pawn defends square from behind (r-1)\n                for df in (f-1, f+1):\n                    rr = r-1\n                    if 0 <= df <= 7 and 0 <= rr <= 7:\n                        s = rr*8 + df\n                        p = pm.get(s)\n                        if p and p.piece_type == chess.PAWN and p.color == chess.WHITE:\n                            return True\n            else:\n                for df in (f-1, f+1):\n                    rr = r+1\n                    if 0 <= df <= 7 and 0 <= rr <= 7:\n                        s = rr*8 + df\n                        p = pm.get(s)\n                        if p and p.piece_type == chess.PAWN and p.color == chess.BLACK:\n                            return True\n            return False\n        def enemy_pawn_can_attack(color, sq):\n            # returns True if any enemy pawn could attack this square\n            f = chess.square_file(sq); r = chess.square_rank(sq)\n            if color == chess.WHITE:\n                # check black pawns at (f-1,r+1) or (f+1,r+1)\n                for df in (f-1, f+1):\n                    rr = r+1\n                    if 0 <= df <= 7 and 0 <= rr <= 7:\n                        s = rr*8 + df\n                        p = pm.get(s)\n                        if p and p.piece_type == chess.PAWN and p.color == chess.BLACK:\n                            return True\n            else:\n                for df in (f-1, f+1):\n                    rr = r-1\n                    if 0 <= df <= 7 and 0 <= rr <= 7:\n                        s = rr*8 + df\n                        p = pm.get(s)\n                        if p and p.piece_type == chess.PAWN and p.color == chess.WHITE:\n                            return True\n            return False\n        score_w = 0.0; score_b = 0.0\n        for sq,p in pm.items():\n            if not p or p.piece_type != chess.KNIGHT:\n                continue\n            r = chess.square_rank(sq)\n            if p.color == chess.WHITE:\n                if r >= 4 and not enemy_pawn_can_attack(chess.WHITE, sq) and is_supported_pawn(chess.WHITE, sq):\n                    score_w += 1.0\n            else:\n                if r <= 3 and not enemy_pawn_can_attack(chess.BLACK, sq) and is_supported_pawn(chess.BLACK, sq):\n                    score_b += 1.0\n        return float(score_w - score_b)\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Rooks on opponent 7th rank (powerful rooks that attack pawns/backrank) (white - black)'\n    try:\n        pm = board.piece_map()\n        score_w = 0.0; score_b = 0.0\n        for sq,p in pm.items():\n            if not p or p.piece_type != chess.ROOK:\n                continue\n            r = chess.square_rank(sq)\n            if p.color == chess.WHITE and r == 6:\n                score_w += 1.6\n            if p.color == chess.BLACK and r == 1:\n                score_b += 1.6\n        return float(score_w - score_b)\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Pinned material: sum of values of pieces pinned to their king (positive favors White if White has fewer pinned pieces)'\n    try:\n        pm = board.piece_map()\n        vals = {chess.PAWN:1.0, chess.KNIGHT:3.0, chess.BISHOP:3.0, chess.ROOK:5.0, chess.QUEEN:9.0, chess.KING:0.0}\n        def pinned_sum(color):\n            total = 0.0\n            # find king\n            king_sq = next((sq for sq,p in pm.items() if p and p.color == color and p.piece_type == chess.KING), None)\n            if king_sq is None:\n                return 0.0\n            kf = chess.square_file(king_sq); kr = chess.square_rank(king_sq)\n            for sq,p in pm.items():\n                if not p or p.color != color or p.piece_type == chess.KING:\n                    continue\n                sf = chess.square_file(sq); sr = chess.square_rank(sq)\n                df = kf - sf; dr = kr - sr\n                # determine direction unit\n                step_f = 0 if df == 0 else (1 if df > 0 else -1)\n                step_r = 0 if dr == 0 else (1 if dr > 0 else -1)\n                # check collinearity\n                if not (df == 0 or dr == 0 or abs(df) == abs(dr)):\n                    continue\n                # find if there is an enemy sliding attacker aligned\n                # step from the piece towards the king to ensure only this piece between attacker and king\n                between_count = 0\n                # step from sq towards king (exclude endpoints)\n                cf = sf + step_f; cr = sr + step_r\n                blocked = False\n                while 0 <= cf <= 7 and 0 <= cr <= 7:\n                    csq = cr*8 + cf\n                    if csq == king_sq:\n                        break\n                    if pm.get(csq) is not None:\n                        between_count += 1\n                    cf += step_f; cr += step_r\n                if between_count != 0:\n                    continue\n                # now search beyond the piece in opposite direction for attacker\n                af = sf - step_f; ar = sr - step_r\n                while 0 <= af <= 7 and 0 <= ar <= 7:\n                    asq = ar*8 + af\n                    attacker = pm.get(asq)\n                    if attacker:\n                        if attacker.color == color:\n                            break\n                        # check attacker type allowed on this ray\n                        if step_f != 0 and step_r != 0:\n                            # diagonal -> bishop or queen\n                            if attacker.piece_type in (chess.BISHOP, chess.QUEEN):\n                                total += vals.get(p.piece_type, 0.0)\n                                break\n                        else:\n                            # straight -> rook or queen\n                            if attacker.piece_type in (chess.ROOK, chess.QUEEN):\n                                total += vals.get(p.piece_type, 0.0)\n                                break\n                        break\n                    af -= step_f; ar -= step_r\n            return total\n        pinned_w = pinned_sum(chess.WHITE)\n        pinned_b = pinned_sum(chess.BLACK)\n        # fewer pinned material is better: return black_pinned - white_pinned so positive favors White\n        return float(pinned_b - pinned_w)\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Space control in enemy half: count of squares attacked in opponent half (white - black)'\n    try:\n        score_w = 0.0; score_b = 0.0\n        # white controls ranks 4..7 (indices 4..7), black controls 0..3\n        for r in range(4, 8):\n            for f in range(8):\n                sq = r*8 + f\n                if board.is_attacked_by(chess.WHITE, sq) and not board.is_attacked_by(chess.BLACK, sq):\n                    score_w += 1.0\n                if board.is_attacked_by(chess.BLACK, sq) and not board.is_attacked_by(chess.WHITE, sq):\n                    score_b += 1.0\n        return float(score_w - score_b)\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Loose (undefended) pieces under attack weighted by piece value (white - black)'\n    try:\n        pm = board.piece_map()\n        vals = {chess.PAWN:1.0, chess.KNIGHT:3.0, chess.BISHOP:3.0, chess.ROOK:5.0, chess.QUEEN:9.0, chess.KING:0.0}\n        score_w = 0.0; score_b = 0.0\n        for sq,p in pm.items():\n            if not p:\n                continue\n            attackers = board.attackers(not p.color, sq)\n            defenders = board.attackers(p.color, sq)\n            if attackers and not defenders:\n                if p.color == chess.WHITE:\n                    score_w -= vals.get(p.piece_type, 0.0)\n                else:\n                    score_b -= vals.get(p.piece_type, 0.0)\n        # since being loose is bad, invert so positive is advantage for White: (black_loose - white_loose)\n        return float(( -score_b) - ( -score_w)) if False else float((score_b) - (score_w))\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Bishop-pair effectiveness: bonus if having two bishops scaled by their reachable diagonals (white - black)'\n    try:\n        pm = board.piece_map()\n        def bishop_reach_and_pair(color):\n            bishops = [sq for sq,p in pm.items() if p and p.piece_type == chess.BISHOP and p.color == color]\n            if not bishops:\n                return 0.0\n            reach = 0\n            for sq in bishops:\n                f = chess.square_file(sq); r = chess.square_rank(sq)\n                # four diagonal directions\n                for df, dr in ((1,1),(1,-1),(-1,1),(-1,-1)):\n                    cf = f + df; cr = r + dr\n                    while 0 <= cf <= 7 and 0 <= cr <= 7:\n                        tsq = cr*8 + cf\n                        reach += 1\n                        if pm.get(tsq) is not None:\n                            break\n                        cf += df; cr += dr\n            pair_bonus = 0.8 if len(bishops) >= 2 else 0.0\n            return reach * 0.05 + pair_bonus\n        return float(bishop_reach_and_pair(chess.WHITE) - bishop_reach_and_pair(chess.BLACK))\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Castling and rook connectivity advantage: castled king bonus + connected rooks (white - black)'\n    try:\n        pm = board.piece_map()\n        def castle_and_connect(color):\n            bonus = 0.0\n            if color == chess.WHITE:\n                king_sq = next((sq for sq,p in pm.items() if p and p.piece_type == chess.KING and p.color == chess.WHITE), None)\n                rooks = [sq for sq,p in pm.items() if p and p.piece_type == chess.ROOK and p.color == chess.WHITE]\n            else:\n                king_sq = next((sq for sq,p in pm.items() if p and p.piece_type == chess.KING and p.color == chess.BLACK), None)\n                rooks = [sq for sq,p in pm.items() if p and p.piece_type == chess.ROOK and p.color == chess.BLACK]\n            if king_sq is None:\n                return 0.0\n            # castled heuristic\n            if color == chess.WHITE and (king_sq == chess.parse_square('g1') or king_sq == chess.parse_square('c1')):\n                bonus += 1.0\n            if color == chess.BLACK and (king_sq == chess.parse_square('g8') or king_sq == chess.parse_square('c8')):\n                bonus += 1.0\n            # rook connectivity: if two rooks on same rank and no pieces between them\n            if len(rooks) >= 2:\n                for i in range(len(rooks)):\n                    for j in range(i+1, len(rooks)):\n                        r1 = rooks[i]; r2 = rooks[j]\n                        rf1 = chess.square_rank(r1); ff1 = chess.square_file(r1)\n                        rf2 = chess.square_rank(r2); ff2 = chess.square_file(r2)\n                        if rf1 == rf2:\n                            low = min(ff1, ff2); high = max(ff1, ff2)\n                            blocked = False\n                            for fmid in range(low+1, high):\n                                mid_sq = rf1*8 + fmid\n                                if pm.get(mid_sq) is not None:\n                                    blocked = True; break\n                            if not blocked:\n                                bonus += 0.8\n            return bonus\n        return float(castle_and_connect(chess.WHITE) - castle_and_connect(chess.BLACK))\n    except Exception:\n        return 0.0\n",
    "def feature(board: chess.Board) -> float:\n    'Passed pawn presence and advancement (advanced passed pawns weighted more) (white - black)'\n    try:\n        vals = {chess.PAWN:1.0}\n        pm = board.piece_map()\n        def is_passed(sq, color):\n            if pm.get(sq) is None or pm[sq].piece_type != chess.PAWN or pm[sq].color != color:\n                return False\n            f = chess.square_file(sq); r = chess.square_rank(sq)\n            if color == chess.WHITE:\n                # no black pawns on same file or adjacent files on ranks > r\n                for rr in range(r+1, 8):\n                    for ff in (f-1, f, f+1):\n                        if 0 <= ff <= 7:\n                            p = board.piece_at(chess.square(ff, rr))\n                            if p and p.piece_type == chess.PAWN and p.color == chess.BLACK:\n                                return False\n                return True\n            else:\n                for rr in range(r-1, -1, -1):\n                    for ff in (f-1, f, f+1):\n                        if 0 <= ff <= 7:\n                            p = board.piece_at(chess.square(ff, rr))\n                            if p and p.piece_type == chess.PAWN and p.color == chess.WHITE:\n                                return False\n                return True\n        score_w = 0.0; score_b = 0.0\n        for sq,p in pm.items():\n            if p and p.piece_type == chess.PAWN:\n                if is_passed(sq, p.color):\n                    # advancement weight: higher rank => more dangerous\n                    rank = chess.square_rank(sq)\n                    adv = (rank / 7.0) if p.color == chess.WHITE else ((7 - rank) / 7.0)\n                    weight = 1.0 + 2.0 * adv\n                    if p.color == chess.WHITE:\n                        score_w += weight\n                    else:\n                        score_b += weight\n        return float(score_w - score_b)\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Pawn island difference (fewer pawn islands is better) measured as (black_islands - white_islands)'\n    try:\n        pm = board.piece_map()\n        def pawn_islands(color):\n            files_with_pawn = [False]*8\n            for sq,p in pm.items():\n                if p and p.piece_type == chess.PAWN and p.color == color:\n                    files_with_pawn[chess.square_file(sq)] = True\n            islands = 0\n            i = 0\n            while i < 8:\n                if files_with_pawn[i]:\n                    islands += 1\n                    while i < 8 and files_with_pawn[i]:\n                        i += 1\n                else:\n                    i += 1\n            return islands\n        wi = pawn_islands(chess.WHITE)\n        bi = pawn_islands(chess.BLACK)\n        return float(bi - wi)\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Rook effectiveness on open/semi-open files and doubled rooks (white - black)'\n    try:\n        pm = board.piece_map()\n        def rook_score(color):\n            score = 0.0\n            # files pawn occupancy\n            file_has_white_pawn = [False]*8\n            file_has_black_pawn = [False]*8\n            for sq,p in pm.items():\n                if p and p.piece_type == chess.PAWN:\n                    if p.color == chess.WHITE:\n                        file_has_white_pawn[chess.square_file(sq)] = True\n                    else:\n                        file_has_black_pawn[chess.square_file(sq)] = True\n            rooks = [sq for sq,p in pm.items() if p and p.piece_type == chess.ROOK and p.color == color]\n            # count doubled on same file\n            file_rook_counts = {}\n            for r in rooks:\n                f = chess.square_file(r)\n                file_rook_counts[f] = file_rook_counts.get(f, 0) + 1\n            for r in rooks:\n                f = chess.square_file(r)\n                # open file: no pawns of either color\n                if not file_has_white_pawn[f] and not file_has_black_pawn[f]:\n                    score += 1.6\n                # semi-open for this color: no own pawns on file\n                elif (color == chess.WHITE and not file_has_white_pawn[f]) or (color == chess.BLACK and not file_has_black_pawn[f]):\n                    score += 0.9\n                # doubled rooks bonus\n                if file_rook_counts.get(f, 0) > 1:\n                    score += 0.5\n            return score\n        return float(rook_score(chess.WHITE) - rook_score(chess.BLACK))\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Value of undefended/hanging pieces attacked by the opponent (positive => White has more hanging enemy material)'\n    try:\n        vals = {chess.PAWN:1.0, chess.KNIGHT:3.0, chess.BISHOP:3.25, chess.ROOK:5.0, chess.QUEEN:9.0, chess.KING:0.0}\n        pm = board.piece_map()\n        white_hang = 0.0; black_hang = 0.0\n        for sq,p in pm.items():\n            if p is None:\n                continue\n            enemy = chess.BLACK if p.color == chess.WHITE else chess.WHITE\n            attackers = board.attackers(enemy, sq)\n            if not attackers:\n                continue\n            defenders = board.attackers(p.color, sq)\n            # consider hanging if no defenders or defenders <= attackers (thinly defended)\n            if len(defenders) == 0 or len(defenders) <= len(attackers):\n                weight = vals.get(p.piece_type, 0.0)\n                if p.color == chess.WHITE:\n                    white_hang += weight\n                else:\n                    black_hang += weight\n        # positive means White has more hanging black material (good for White)\n        return float(black_hang - white_hang)\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'King pawn-shield weakness: measures missing pawns in front of the king and attacked open adjacent files (black_vulner - white_vulner)'\n    try:\n        pm = board.piece_map()\n        def king_vulnerability(color):\n            # find king\n            king_sq = next((sq for sq,p in pm.items() if p and p.piece_type == chess.KING and p.color == color), None)\n            if king_sq is None:\n                return 0.0\n            f = chess.square_file(king_sq); r = chess.square_rank(king_sq)\n            if color == chess.WHITE:\n                shield_rank = r+1\n                enemy = chess.BLACK\n            else:\n                shield_rank = r-1\n                enemy = chess.WHITE\n            vuln = 0.0\n            # missing pawns in three-file shield f-1,f,f+1\n            for ff in (f-1, f, f+1):\n                if 0 <= ff <= 7 and 0 <= shield_rank <= 7:\n                    p = board.piece_at(chess.square(ff, shield_rank))\n                    if not (p and p.piece_type == chess.PAWN and p.color == color):\n                        vuln += 0.8\n                else:\n                    vuln += 0.8\n            # adjacent files/open files attacked near king\n            for ff in (f-1, f, f+1):\n                for rr in (r,):\n                    if 0 <= ff <= 7 and 0 <= rr <= 7:\n                        sq = chess.square(ff, rr)\n                        # open file if no pawns at all on that file\n                        has_pawn_on_file = any((board.piece_at(chess.square(ff, rr2)) and board.piece_at(chess.square(ff, rr2)).piece_type==chess.PAWN) for rr2 in range(8))\n                        if not has_pawn_on_file and board.is_attacked_by(enemy, sq):\n                            vuln += 0.6\n            # additional vulnerability: number of attackers around king neighborhood\n            attackers = 0\n            for sq2 in range(64):\n                if chess.square_distance(king_sq, sq2) <= 1:\n                    attackers += len(board.attackers(enemy, sq2))\n            vuln += 0.1 * attackers\n            return vuln\n        w_v = king_vulnerability(chess.WHITE)\n        b_v = king_vulnerability(chess.BLACK)\n        # positive if Black king is more vulnerable (good for White)\n        return float(b_v - w_v)\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Bishop pair advantage indicator (1 if white has pair and black does not, -1 opposite, 0 otherwise)'\n    try:\n        pm = board.piece_map()\n        w_bishops = sum(1 for p in pm.values() if p and p.piece_type == chess.BISHOP and p.color == chess.WHITE)\n        b_bishops = sum(1 for p in pm.values() if p and p.piece_type == chess.BISHOP and p.color == chess.BLACK)\n        return float((1.0 if w_bishops >= 2 else 0.0) - (1.0 if b_bishops >= 2 else 0.0))\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Centralization score for minor/major pieces (knight, bishop, rook, queen) (white - black)'\n    try:\n        pm = board.piece_map()\n        central_sqs = [chess.parse_square(n) for n in ('d4','d5','e4','e5')]\n        weights = {chess.KNIGHT:1.2, chess.BISHOP:1.0, chess.ROOK:0.6, chess.QUEEN:1.5}\n        def piece_cent(color):\n            score = 0.0\n            for sq,p in pm.items():\n                if p and p.color == color and p.piece_type in weights:\n                    d = min(chess.square_distance(sq, c) for c in central_sqs)\n                    # transform so nearer center gives higher value; clamp\n                    centrality = max(0.0, (4.0 - float(d)) / 4.0)\n                    score += weights[p.piece_type] * centrality\n            return score\n        return float(piece_cent(chess.WHITE) - piece_cent(chess.BLACK))\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Rooks on the opponent's seventh rank (or second for the opponent) weighted by enemy pawn presence (white - black)\"\n    try:\n        pm = board.piece_map()\n        def seventh_score(color):\n            score = 0.0\n            if color == chess.WHITE:\n                target_rank = 6  # white's rook on rank 7 (index 6)\n                enemy_color = chess.BLACK\n            else:\n                target_rank = 1\n                enemy_color = chess.WHITE\n            for sq,p in pm.items():\n                if p and p.piece_type == chess.ROOK and p.color == color and chess.square_rank(sq) == target_rank:\n                    f = chess.square_file(sq)\n                    # number of enemy pawns on that rank\n                    enemy_pawns_on_rank = sum(1 for ff in range(8) if board.piece_at(chess.square(ff, target_rank)) and board.piece_at(chess.square(ff, target_rank)).piece_type==chess.PAWN and board.piece_at(chess.square(ff, target_rank)).color==enemy_color)\n                    bonus = 1.2 * (1.0 + max(0.0, (4 - enemy_pawns_on_rank)) * 0.1)\n                    # additional bonus if supported by another rook\n                    supported = any((r2 != sq and pm.get(r2) and pm[r2].piece_type==chess.ROOK and pm[r2].color==color and chess.square_file(r2)==f) for r2 in pm.keys())\n                    if supported:\n                        bonus += 0.4\n                    score += bonus\n            return score\n        return float(seventh_score(chess.WHITE) - seventh_score(chess.BLACK))\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'King mobility / safe squares around king (number of empty adjacent squares not attacked by opponent) (white - black)'\n    try:\n        pm = board.piece_map()\n        def king_safe_moves(color):\n            king_sq = next((sq for sq,p in pm.items() if p and p.piece_type == chess.KING and p.color == color), None)\n            if king_sq is None:\n                return 0.0\n            enemy = chess.BLACK if color == chess.WHITE else chess.WHITE\n            count = 0.0\n            for sq2 in range(64):\n                if chess.square_distance(king_sq, sq2) == 1:\n                    # consider square as candidate if not occupied by own piece and not attacked by enemy\n                    occ = board.piece_at(sq2)\n                    if occ and occ.color == color:\n                        continue\n                    # allow capture of enemy piece only if resulting square is not attacked by more than zero attackers (we can't simulate move; approximate by checking if square is attacked)\n                    if not board.is_attacked_by(enemy, sq2):\n                        count += 1.0\n            return count\n        return float(king_safe_moves(chess.WHITE) - king_safe_moves(chess.BLACK))\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Capture/recapture tactical potential: count of legal captures where captured piece value >= attacker value (white - black)'\n    try:\n        vals = {chess.PAWN:1.0, chess.KNIGHT:3.0, chess.BISHOP:3.25, chess.ROOK:5.0, chess.QUEEN:9.0, chess.KING:0.0}\n        orig = board.turn\n        try:\n            # white side captures\n            board.turn = chess.WHITE\n            white_cap = 0.0\n            for mv in board.legal_moves:\n                to = mv.to_square\n                frm = mv.from_square\n                captured = board.piece_at(to)\n                mover = board.piece_at(frm)\n                if captured and mover:\n                    if vals.get(captured.piece_type, 0.0) >= vals.get(mover.piece_type, 0.0):\n                        white_cap += vals.get(captured.piece_type, 0.0)  # weight by captured value\n            # black side captures\n            board.turn = chess.BLACK\n            black_cap = 0.0\n            for mv in board.legal_moves:\n                to = mv.to_square\n                frm = mv.from_square\n                captured = board.piece_at(to)\n                mover = board.piece_at(frm)\n                if captured and mover:\n                    if vals.get(captured.piece_type, 0.0) >= vals.get(mover.piece_type, 0.0):\n                        black_cap += vals.get(captured.piece_type, 0.0)\n        finally:\n            board.turn = orig\n        return float(white_cap - black_cap)\n    except Exception:\n        return 0.0\n",
    "def feature(board: chess.Board) -> float:\n    'Passed pawn urgency: sum over passed pawns of 1/(1+distance_to_promo) weighted by support (white - black)'\n    try:\n        vals = {chess.PAWN:1.0}\n        pm = board.piece_map()\n        def is_passed(sq, color):\n            f = chess.square_file(sq); r = chess.square_rank(sq)\n            if color == chess.WHITE:\n                for opp_sq, p in pm.items():\n                    if p and p.color == chess.BLACK and p.piece_type == chess.PAWN:\n                        pf = chess.square_file(opp_sq); pr = chess.square_rank(opp_sq)\n                        if abs(pf - f) <= 1 and pr > r:\n                            return False\n                return True\n            else:\n                for opp_sq, p in pm.items():\n                    if p and p.color == chess.WHITE and p.piece_type == chess.PAWN:\n                        pf = chess.square_file(opp_sq); pr = chess.square_rank(opp_sq)\n                        if abs(pf - f) <= 1 and pr < r:\n                            return False\n                return True\n        def support_count(sq, color):\n            # number of friendly pieces attacking the pawn square (excluding pawns behind maybe)\n            attackers = board.attackers(color, sq)\n            cnt = 0\n            for a in attackers:\n                p = board.piece_at(a)\n                if p and p.color == color:\n                    cnt += 1\n            return cnt\n        score_w = 0.0; score_b = 0.0\n        for sq, p in pm.items():\n            if not p or p.piece_type != chess.PAWN:\n                continue\n            if p.color == chess.WHITE:\n                if is_passed(sq, chess.WHITE):\n                    dist = 7 - chess.square_rank(sq)\n                    sup = support_count(sq, chess.WHITE)\n                    score_w += (1.0 / (1.0 + dist)) * (1.0 + 0.25 * sup)\n            else:\n                if is_passed(sq, chess.BLACK):\n                    dist = chess.square_rank(sq)\n                    sup = support_count(sq, chess.BLACK)\n                    score_b += (1.0 / (1.0 + dist)) * (1.0 + 0.25 * sup)\n        return float(score_w - score_b)\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Rooks on open or semi-open files: +1 for open, +0.5 for semi-open (white - black)'\n    try:\n        pm = board.piece_map()\n        score_w = 0.0; score_b = 0.0\n        for sq, p in pm.items():\n            if not p or p.piece_type != chess.ROOK:\n                continue\n            f = chess.square_file(sq)\n            has_white_pawn = False; has_black_pawn = False\n            for r in range(8):\n                sq2 = chess.square(f, r)\n                p2 = board.piece_at(sq2)\n                if p2 and p2.piece_type == chess.PAWN:\n                    if p2.color == chess.WHITE:\n                        has_white_pawn = True\n                    else:\n                        has_black_pawn = True\n            val = 0.0\n            if not has_white_pawn and not has_black_pawn:\n                val = 1.0\n            elif (p.color == chess.WHITE and not has_white_pawn) or (p.color == chess.BLACK and not has_black_pawn):\n                val = 0.5\n            if p.color == chess.WHITE:\n                score_w += val\n            else:\n                score_b += val\n        return float(score_w - score_b)\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'King pawn-shield integrity: count of friendly pawns directly in front/one-file-neighbor in 1..3 ranks (white - black)'\n    try:\n        pm = board.piece_map()\n        def shield_score(color):\n            # find king\n            king_sq = next((sq for sq,p in pm.items() if p and p.piece_type == chess.KING and p.color == color), None)\n            if king_sq is None:\n                return 0.0\n            kf = chess.square_file(king_sq); kr = chess.square_rank(king_sq)\n            score = 0.0\n            if color == chess.WHITE:\n                for rr in range(kr+1, min(8, kr+4)):\n                    for ff in range(max(0, kf-1), min(8, kf+2)):\n                        p = board.piece_at(chess.square(ff, rr))\n                        if p and p.piece_type == chess.PAWN and p.color == color:\n                            # closer pawns count more\n                            score += 1.0 / (1.0 + (rr - kr - 1))\n            else:\n                for rr in range(max(0, kr-3), kr):\n                    for ff in range(max(0, kf-1), min(8, kf+2)):\n                        p = board.piece_at(chess.square(ff, rr))\n                        if p and p.piece_type == chess.PAWN and p.color == color:\n                            score += 1.0 / (1.0 + (kr - rr - 1))\n            return score\n        return float(shield_score(chess.WHITE) - shield_score(chess.BLACK))\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Pawn islands difference: (fewer pawn islands is better) returns (black_islands - white_islands)'\n    try:\n        def pawn_islands(color):\n            files_with_pawn = [False]*8\n            for sq,p in board.piece_map().items():\n                if p and p.piece_type == chess.PAWN and p.color == color:\n                    files_with_pawn[chess.square_file(sq)] = True\n            islands = 0\n            i = 0\n            while i < 8:\n                if files_with_pawn[i]:\n                    islands += 1\n                    while i < 8 and files_with_pawn[i]:\n                        i += 1\n                else:\n                    i += 1\n            return islands\n        w = pawn_islands(chess.WHITE)\n        b = pawn_islands(chess.BLACK)\n        return float(b - w)\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Rooks on opponent seventh rank: counts rooks on rank 7 (white) / rank 2 (black) (white - black)'\n    try:\n        pm = board.piece_map()\n        score_w = 0.0; score_b = 0.0\n        for sq,p in pm.items():\n            if not p or p.piece_type != chess.ROOK:\n                continue\n            r = chess.square_rank(sq)\n            if p.color == chess.WHITE and r == 6:\n                score_w += 1.0\n            if p.color == chess.BLACK and r == 1:\n                score_b += 1.0\n        return float(score_w - score_b)\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Weighted pinned material: sum of material values of own pieces pinned to king (white - black)'\n    try:\n        vals = {chess.PAWN:1.0, chess.KNIGHT:3.0, chess.BISHOP:3.0, chess.ROOK:5.0, chess.QUEEN:9.0, chess.KING:0.0}\n        pm = board.piece_map()\n        pinned_w = 0.0; pinned_b = 0.0\n        orig_turn = board.turn\n        try:\n            for sq, p in list(pm.items()):\n                if not p or p.piece_type == chess.KING:\n                    continue\n                color = p.color\n                king_sq = next((sqp for sqp, pp in pm.items() if pp and pp.piece_type == chess.KING and pp.color == color), None)\n                if king_sq is None:\n                    continue\n                # remove piece temporarily and check if king becomes attacked by opponent\n                removed = board.remove_piece_at(sq)\n                try:\n                    opp = chess.BLACK if color == chess.WHITE else chess.WHITE\n                    if king_sq is not None and board.is_attacked_by(opp, king_sq):\n                        if color == chess.WHITE:\n                            pinned_w += vals.get(p.piece_type, 0.0)\n                        else:\n                            pinned_b += vals.get(p.piece_type, 0.0)\n                finally:\n                    # restore\n                    board.set_piece_at(sq, removed)\n        finally:\n            board.turn = orig_turn\n        return float(pinned_w - pinned_b)\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Bishop diagonal mobility: sum of unobstructed diagonal ray lengths for bishops (white - black)'\n    try:\n        pm = board.piece_map()\n        def diag_reach(sq):\n            f = chess.square_file(sq); r = chess.square_rank(sq)\n            total = 0\n            for df, dr in ((1,1),(1,-1),(-1,1),(-1,-1)):\n                ff, rr = f + df, r + dr\n                while 0 <= ff < 8 and 0 <= rr < 8:\n                    total += 1\n                    sq2 = chess.square(ff, rr)\n                    if board.piece_at(sq2) is not None:\n                        break\n                    ff += df; rr += dr\n            return total\n        score_w = 0.0; score_b = 0.0\n        for sq,p in pm.items():\n            if p and p.piece_type == chess.BISHOP:\n                if p.color == chess.WHITE:\n                    score_w += diag_reach(sq)\n                else:\n                    score_b += diag_reach(sq)\n        return float(score_w - score_b)\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Central control: occupancy (1.0) + influence (0.5 per attacker) of central 4 squares d4,e4,d5,e5 (white - black)'\n    try:\n        central = [chess.parse_square(s) for s in ('d4','e4','d5','e5')]\n        score_w = 0.0; score_b = 0.0\n        for sq in central:\n            p = board.piece_at(sq)\n            if p:\n                if p.color == chess.WHITE:\n                    score_w += 1.0\n                else:\n                    score_b += 1.0\n            # attacks\n            attackers_w = len([a for a in board.attackers(chess.WHITE, sq)])\n            attackers_b = len([a for a in board.attackers(chess.BLACK, sq)])\n            score_w += 0.5 * attackers_w\n            score_b += 0.5 * attackers_b\n        return float(score_w - score_b)\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'King centralization in endgame: normalized closeness-to-center if minor+major material <= 6 pawns (white - black)'\n    try:\n        vals = {chess.PAWN:0.0, chess.KNIGHT:1.0, chess.BISHOP:1.0, chess.ROOK:2.5, chess.QUEEN:4.0, chess.KING:0.0}\n        mat_sum = 0.0\n        pm = board.piece_map()\n        for p in pm.values():\n            if p:\n                mat_sum += vals.get(p.piece_type, 0.0)\n        # only meaningful in reduced material positions\n        if mat_sum > 6.0:\n            return 0.0\n        center_coords = [(3,3),(4,3),(3,4),(4,4)]  # d4,e4,d5,e5\n        def center_score(color):\n            king_sq = next((sq for sq,p in pm.items() if p and p.piece_type == chess.KING and p.color == color), None)\n            if king_sq is None:\n                return 0.0\n            kf = chess.square_file(king_sq); kr = chess.square_rank(king_sq)\n            # distance to nearest center square (Chebyshev style)\n            best = 8\n            for cf, cr in center_coords:\n                d = max(abs(cf - kf), abs(cr - kr))\n                if d < best:\n                    best = d\n            # convert to [0,1], 1 means on/adjacent central\n            return (4.0 - float(best)) / 4.0\n        return float(center_score(chess.WHITE) - center_score(chess.BLACK))\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Queen mobility minus small-piece threats: pseudo-legal queen ray mobility minus 0.5 * attackers by knights/bishops (white - black)'\n    try:\n        pm = board.piece_map()\n        dirs = [(1,0),(-1,0),(0,1),(0,-1),(1,1),(1,-1),(-1,1),(-1,-1)]\n        def queen_mobility_and_threats(color):\n            mob = 0.0; threats = 0.0\n            for sq,p in pm.items():\n                if p and p.piece_type == chess.QUEEN and p.color == color:\n                    f = chess.square_file(sq); r = chess.square_rank(sq)\n                    # rays\n                    for df, dr in dirs:\n                        ff, rr = f + df, r + dr\n                        while 0 <= ff < 8 and 0 <= rr < 8:\n                            mob += 1.0\n                            sq2 = chess.square(ff, rr)\n                            p2 = board.piece_at(sq2)\n                            if p2 is not None:\n                                break\n                            ff += df; rr += dr\n                    # attackers by knights/bishops\n                    opp = chess.BLACK if color == chess.WHITE else chess.WHITE\n                    for a in board.attackers(opp, sq):\n                        pa = board.piece_at(a)\n                        if pa and pa.piece_type in (chess.KNIGHT, chess.BISHOP):\n                            threats += 1.0\n            return mob - 0.5 * threats\n        return float(queen_mobility_and_threats(chess.WHITE) - queen_mobility_and_threats(chess.BLACK))\n    except Exception:\n        return 0.0\n",
    "def feature(board: chess.Board) -> float:\n    'Passed pawn potential: sum of passed pawns weighted by advancement (positive favors White)'\n    try:\n        pm = board.piece_map()\n        score_w = 0.0\n        score_b = 0.0\n        for sq, p in pm.items():\n            if not p or p.piece_type != chess.PAWN:\n                continue\n            f = chess.square_file(sq)\n            r = chess.square_rank(sq)\n            is_white = (p.color == chess.WHITE)\n            blocked = False\n            # check enemy pawns on same or adjacent files ahead of this pawn\n            for af in (f-1, f, f+1):\n                if af < 0 or af > 7:\n                    continue\n                for ar in range(8):\n                    if is_white:\n                        # enemy pawn ahead means higher rank\n                        if ar > r:\n                            psq = chess.square(af, ar)\n                            pp = board.piece_at(psq)\n                            if pp and pp.piece_type == chess.PAWN and pp.color == chess.BLACK:\n                                blocked = True\n                                break\n                    else:\n                        # black pawn ahead means lower rank\n                        if ar < r:\n                            psq = chess.square(af, ar)\n                            pp = board.piece_at(psq)\n                            if pp and pp.piece_type == chess.PAWN and pp.color == chess.WHITE:\n                                blocked = True\n                                break\n                if blocked:\n                    break\n            if not blocked:\n                # advancement factor: how far the pawn has progressed (0..1)\n                if is_white:\n                    adv = float(r) / 7.0\n                    score_w += 1.0 + adv\n                else:\n                    adv = float(7 - r) / 7.0\n                    score_b += 1.0 + adv\n        return float(score_w - score_b)\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Advanced knight outposts: knights on advanced squares without enemy pawn contest and with pawn support (white - black)'\n    try:\n        pm = board.piece_map()\n        def outpost_score_for(color):\n            s = 0.0\n            for sq, p in pm.items():\n                if not p or p.piece_type != chess.KNIGHT or p.color != color:\n                    continue\n                f = chess.square_file(sq)\n                r = chess.square_rank(sq)\n                # advanced threshold (white rank >=4, black rank <=3)\n                if color == chess.WHITE and r < 4:\n                    continue\n                if color == chess.BLACK and r > 3:\n                    continue\n                # check enemy pawn presence on adjacent files that can challenge (approx)\n                enemy = chess.BLACK if color == chess.WHITE else chess.WHITE\n                contested = False\n                for af in (f-1, f+1):\n                    if af < 0 or af > 7:\n                        continue\n                    # for white knight, enemy pawn anywhere at rank >= r-1 on adjacent file contests\n                    for ar in range(8):\n                        psq = chess.square(af, ar)\n                        pp = board.piece_at(psq)\n                        if not pp or pp.piece_type != chess.PAWN or pp.color != enemy:\n                            continue\n                        if color == chess.WHITE:\n                            if ar >= max(0, r-1):\n                                contested = True\n                                break\n                        else:\n                            if ar <= min(7, r+1):\n                                contested = True\n                                break\n                    if contested:\n                        break\n                if contested:\n                    continue\n                # pawn support: is there a friendly pawn on adjacent files behind the knight?\n                supported = False\n                for af in (f-1, f+1):\n                    if af < 0 or af > 7:\n                        continue\n                    if color == chess.WHITE:\n                        branks = range(0, r)\n                    else:\n                        branks = range(r+1, 8)\n                    for br in branks:\n                        pp = board.piece_at(chess.square(af, br))\n                        if pp and pp.piece_type == chess.PAWN and pp.color == color:\n                            supported = True\n                            break\n                    if supported:\n                        break\n                s += (1.5 if supported else 1.0)\n            return s\n        return float(outpost_score_for(chess.WHITE) - outpost_score_for(chess.BLACK))\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Pawn shield integrity in front of king: counts friendly pawns directly protecting king (white - black)'\n    try:\n        pm = board.piece_map()\n        def shield_for(color):\n            # locate king\n            king_sq = next((sq for sq,p in pm.items() if p and p.piece_type == chess.KING and p.color == color), None)\n            if king_sq is None:\n                return 0.0\n            f = chess.square_file(king_sq)\n            r = chess.square_rank(king_sq)\n            count = 0.0\n            # for white king, pawns on ranks r+1 and r+2 on files f-1,f,f+1\n            files = [ff for ff in (f-1, f, f+1) if 0 <= ff <= 7]\n            ranks = []\n            if color == chess.WHITE:\n                ranks = [r+1, r+2]\n            else:\n                ranks = [r-1, r-2]\n            for rr in ranks:\n                if rr < 0 or rr > 7:\n                    continue\n                for ff in files:\n                    pp = board.piece_at(chess.square(ff, rr))\n                    if pp and pp.piece_type == chess.PAWN and pp.color == color:\n                        # closer pawns count more\n                        if abs(rr - r) == 1:\n                            count += 1.0\n                        else:\n                            count += 0.5\n            return count\n        return float(shield_for(chess.WHITE) - shield_for(chess.BLACK))\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'King centralization weighted by stage: kings closer to center in endgames are better (white - black)'\n    try:\n        import math\n        pm = board.piece_map()\n        # compute non-king material to decide stage\n        vals = {chess.PAWN:1.0, chess.KNIGHT:3.0, chess.BISHOP:3.0, chess.ROOK:5.0, chess.QUEEN:9.0}\n        total_nonking = 0.0\n        for p in pm.values():\n            if p and p.piece_type != chess.KING:\n                total_nonking += vals.get(p.piece_type, 0.0)\n        # higher endgame weight when material is low\n        endgame_weight = max(0.0, (20.0 - total_nonking) / 20.0)  # 0..1\n        def central_score(color):\n            ks = next((sq for sq,p in pm.items() if p and p.piece_type==chess.KING and p.color==color), None)\n            if ks is None:\n                return 0.0\n            f = chess.square_file(ks)\n            r = chess.square_rank(ks)\n            # center at (3.5,3.5), max dist ~ sqrt( (3.5)^2*2 ) ~ 4.95\n            dx = (f - 3.5)\n            dy = (r - 3.5)\n            dist = math.sqrt(dx*dx + dy*dy)\n            maxd = math.sqrt(3.5*3.5*2)\n            centrality = (maxd - dist) / maxd  # 0..1\n            # weight more in endgame\n            return centrality * (0.5 + 0.5 * endgame_weight)\n        return float(central_score(chess.WHITE) - central_score(chess.BLACK))\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Hanging pieces weighted penalty: sum of values of pieces attacked and insufficiently defended (positive => Black worse)'\n    try:\n        vals = {chess.PAWN:1.0, chess.KNIGHT:3.0, chess.BISHOP:3.0, chess.ROOK:5.0, chess.QUEEN:9.0, chess.KING:0.0}\n        pm = board.piece_map()\n        white_hanging = 0.0\n        black_hanging = 0.0\n        for sq, p in pm.items():\n            if not p:\n                continue\n            color = p.color\n            enemy = chess.BLACK if color == chess.WHITE else chess.WHITE\n            attackers = len(board.attackers(enemy, sq))\n            defenders = len(board.attackers(color, sq))\n            # consider it hanging if attacked and defenders are fewer (attacker count > defender count)\n            if attackers > defenders:\n                if color == chess.WHITE:\n                    white_hanging += vals.get(p.piece_type, 0.0)\n                else:\n                    black_hanging += vals.get(p.piece_type, 0.0)\n        # positive means Black has more hanging material (good for White)\n        return float(black_hanging - white_hanging)\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Bishop pair bonus minus bad-bishop penalty (positive favors White): counts bishop pairs and bishops blocked by same-color pawns'\n    try:\n        pm = board.piece_map()\n        def bishop_stats(color):\n            bishops = [sq for sq,p in pm.items() if p and p.piece_type==chess.BISHOP and p.color==color]\n            pawns = [sq for sq,p in pm.items() if p and p.piece_type==chess.PAWN and p.color==color]\n            pawns_color_count = {0:0, 1:0}\n            for psq in pawns:\n                col = (chess.square_file(psq) + chess.square_rank(psq)) & 1\n                pawns_color_count[col] += 1\n            bad = 0\n            for b in bishops:\n                bcol = (chess.square_file(b) + chess.square_rank(b)) & 1\n                # if majority of pawns are on the bishop's square color, bishop tends to be bad\n                if pawns_color_count.get(bcol,0) > pawns_color_count.get(1-bcol,0):\n                    bad += 1\n            pair = 1 if len(bishops) >= 2 else 0\n            return pair, bad\n        wpair, wbad = bishop_stats(chess.WHITE)\n        bpair, bbad = bishop_stats(chess.BLACK)\n        # bonus for pair, penalty for bad bishops (scale)\n        return float((wpair - bpair) * 1.0 - (wbad - bbad) * 0.5)\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Rooks on the seventh rank (penetration): counts rooks occupying opponent seventh rank (white - black)'\n    try:\n        pm = board.piece_map()\n        w = 0.0\n        b = 0.0\n        for sq, p in pm.items():\n            if not p or p.piece_type != chess.ROOK:\n                continue\n            r = chess.square_rank(sq)\n            if p.color == chess.WHITE and r == 6:\n                w += 1.0\n            if p.color == chess.BLACK and r == 1:\n                b += 1.0\n        return float(w - b)\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Queen centrality minus exposure: bonus if queen is centralized but penalized by number of enemy attackers (white - black)'\n    try:\n        pm = board.piece_map()\n        def queen_score(color):\n            qs = next((sq for sq,p in pm.items() if p and p.piece_type==chess.QUEEN and p.color==color), None)\n            if qs is None:\n                return 0.0\n            f = chess.square_file(qs)\n            r = chess.square_rank(qs)\n            central = 1.0 if 2 <= f <= 5 and 2 <= r <= 5 else 0.0\n            enemy = chess.BLACK if color == chess.WHITE else chess.WHITE\n            attackers = len(board.attackers(enemy, qs))\n            return central * 1.0 - 0.25 * attackers\n        return float(queen_score(chess.WHITE) - queen_score(chess.BLACK))\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Capture tempo approximation: number of immediate capture moves available (white - black) (approximate via destination occupancy)'\n    try:\n        orig = board.turn\n        try:\n            board.turn = chess.WHITE\n            wc = 0\n            for mv in board.legal_moves:\n                # approximate capture if destination square contains an opponent piece\n                if board.piece_at(mv.to_square) is not None:\n                    wc += 1\n            board.turn = chess.BLACK\n            bc = 0\n            for mv in board.legal_moves:\n                if board.piece_at(mv.to_square) is not None:\n                    bc += 1\n        finally:\n            board.turn = orig\n        return float(wc - bc)\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Piece coordination: negative average pairwise distance among non-pawn non-king pieces (positive when White is more coordinated than Black)'\n    try:\n        pm = board.piece_map()\n        def avg_pair_dist(color):\n            squares = [sq for sq,p in pm.items() if p and p.color==color and p.piece_type not in (chess.PAWN, chess.KING)]\n            n = len(squares)\n            if n < 2:\n                return 0.0\n            total = 0.0\n            pairs = 0\n            for i in range(n):\n                for j in range(i+1, n):\n                    total += chess.square_distance(squares[i], squares[j])\n                    pairs += 1\n            return total / pairs if pairs > 0 else 0.0\n        wa = avg_pair_dist(chess.WHITE)\n        ba = avg_pair_dist(chess.BLACK)\n        # lower distance = better coordination, so return (black_avg - white_avg)\n        return float(ba - wa)\n    except Exception:\n        return 0.0\n",
    "def feature(board: chess.Board) -> float:\n    'Passed pawn potential weighted by proximity to promotion (positive favors White)'\n    try:\n        pm = board.piece_map()\n        def is_passed(sq, color):\n            # For white, no black pawn on same or adjacent files on any higher rank\n            f = chess.square_file(sq)\n            r = chess.square_rank(sq)\n            if color == chess.WHITE:\n                for ff in (f-1, f, f+1):\n                    if ff < 0 or ff > 7:\n                        continue\n                    for rr in range(r+1, 8):\n                        p = board.piece_at(chess.square(ff, rr))\n                        if p and p.piece_type == chess.PAWN and p.color == chess.BLACK:\n                            return False\n                return True\n            else:\n                for ff in (f-1, f, f+1):\n                    if ff < 0 or ff > 7:\n                        continue\n                    for rr in range(0, r):\n                        p = board.piece_at(chess.square(ff, rr))\n                        if p and p.piece_type == chess.PAWN and p.color == chess.WHITE:\n                            return False\n                return True\n        score_w = 0.0\n        score_b = 0.0\n        for sq, p in pm.items():\n            if not p or p.piece_type != chess.PAWN:\n                continue\n            r = chess.square_rank(sq)\n            # distance to promotion: 7 - r for white, r for black\n            if p.color == chess.WHITE:\n                dist = 7 - r\n                if is_passed(sq, chess.WHITE):\n                    # closer passed pawns are exponentially more dangerous\n                    score_w += (1.0 + (7.0 - dist) * 0.6)\n            else:\n                dist = r\n                if is_passed(sq, chess.BLACK):\n                    score_b += (1.0 + (7.0 - dist) * 0.6)\n        return float(score_w - score_b)\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Isolated pawn imbalance: (black isolated pawns - white isolated pawns) positive favors White if Black has more isolated pawns'\n    try:\n        files_white = [0]*8\n        files_black = [0]*8\n        for sq, p in board.piece_map().items():\n            if p and p.piece_type == chess.PAWN:\n                f = chess.square_file(sq)\n                if p.color == chess.WHITE:\n                    files_white[f] += 1\n                else:\n                    files_black[f] += 1\n        def isolated_count(files):\n            cnt = 0\n            for f in range(8):\n                if files[f] == 0:\n                    continue\n                left = files[f-1] if f-1 >= 0 else 0\n                right = files[f+1] if f+1 <= 7 else 0\n                if left == 0 and right == 0:\n                    cnt += 1\n            return cnt\n        w_iso = isolated_count(files_white)\n        b_iso = isolated_count(files_black)\n        # positive favors White: if Black has more isolated pawns -> positive\n        return float(b_iso - w_iso)\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Vulnerability of pieces: sum of high-value pieces attacked more times than defended (black_vul - white_vul) positive favors White'\n    try:\n        vals = {chess.PAWN:1.0, chess.KNIGHT:3.0, chess.BISHOP:3.0, chess.ROOK:5.0, chess.QUEEN:9.0, chess.KING:0.0}\n        pm = board.piece_map()\n        white_vul = 0.0\n        black_vul = 0.0\n        for sq, p in pm.items():\n            if not p:\n                continue\n            # attackers of opposite color and defenders of same color\n            attackers = board.attackers(not p.color, sq)\n            defenders = board.attackers(p.color, sq)\n            # count attackers/defenders (simple numeric)\n            na = len(attackers)\n            nd = len(defenders)\n            if na > nd:\n                # vulnerability proportional to piece value and how many attackers exceed defenders\n                extra = float(na - nd)\n                score = vals.get(p.piece_type, 0.0) * extra * 0.5\n                if p.color == chess.WHITE:\n                    white_vul += score\n                else:\n                    black_vul += score\n        # positive favors White: black pieces more vulnerable than white pieces\n        return float(black_vul - white_vul)\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Castling/completed-king-safety indicator: (white_castled?1:0) - (black_castled?1:0)'\n    try:\n        pm = board.piece_map()\n        white_king_sq = next((sq for sq,p in pm.items() if p and p.piece_type == chess.KING and p.color == chess.WHITE), None)\n        black_king_sq = next((sq for sq,p in pm.items() if p and p.piece_type == chess.KING and p.color == chess.BLACK), None)\n        w_castled = 0.0\n        b_castled = 0.0\n        if white_king_sq is not None:\n            # typical castled king squares: g1 (file 6 rank 0) or c1 (file 2 rank 0)\n            rf = (chess.square_file(white_king_sq), chess.square_rank(white_king_sq))\n            if rf == (6, 0) or rf == (2, 0):\n                w_castled = 1.0\n        if black_king_sq is not None:\n            rf = (chess.square_file(black_king_sq), chess.square_rank(black_king_sq))\n            if rf == (6, 7) or rf == (2, 7):\n                b_castled = 1.0\n        return float(w_castled - b_castled)\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Bishop-pair and long-diagonal mobility advantage (positive favors White)'\n    try:\n        pm = board.piece_map()\n        def bishop_stats(color):\n            count = 0\n            moves = 0\n            for sq,p in pm.items():\n                if p and p.color == color and p.piece_type == chess.BISHOP:\n                    count += 1\n                    # count pseudo-mobility by counting attacked squares by the bishop (use ray-attacks approximation via legal moves)\n                    # we approximate mobility by number of squares bishop attacks (board.attackers of opposite color irrelevant)\n                    # Use board.is_attacked_by with empty? Instead, iterate all squares and see if bishop could move there by ray (check same diagonal and no piece between)\n                    mob = 0\n                    sf = chess.square_file(sq); sr = chess.square_rank(sq)\n                    for tf in range(8):\n                        for tr in range(8):\n                            if tf == sf and tr == sr:\n                                continue\n                            if abs(tf - sf) == abs(tr - sr):\n                                # check path clear\n                                stepf = 1 if tf > sf else -1\n                                stepr = 1 if tr > sr else -1\n                                ff = sf + stepf; rr = sr + stepr\n                                blocked = False\n                                while ff != tf and rr != tr:\n                                    if board.piece_at(chess.square(ff, rr)):\n                                        blocked = True\n                                        break\n                                    ff += stepf; rr += stepr\n                                if not blocked:\n                                    # destination square can be empty or occupied by opponent\n                                    dest = board.piece_at(chess.square(tf, tr))\n                                    if dest is None or dest.color != color:\n                                        mob += 1\n                    moves += mob\n            avg_mob = moves / count if count > 0 else 0.0\n            return count, avg_mob\n        wc, wm = bishop_stats(chess.WHITE)\n        bc, bm = bishop_stats(chess.BLACK)\n        pair_bonus = (1.0 if wc >= 2 else 0.0) - (1.0 if bc >= 2 else 0.0)\n        return float(pair_bonus * 1.2 + (wm - bm) * 0.08)\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Knight outposts in central squares (d4,e4,d5,e5) supported by pawn and not attacked by enemy pawns (white - black)'\n    try:\n        central = {chess.parse_square(s) for s in ('d4','e4','d5','e5')}\n        pm = board.piece_map()\n        def outpost_count(color):\n            cnt = 0.0\n            enemy = not color\n            for sq,p in pm.items():\n                if not p or p.color != color or p.piece_type != chess.KNIGHT:\n                    continue\n                if sq not in central:\n                    continue\n                # supported by a friendly pawn attacking this square?\n                pawn_support = any(board.piece_at(a) and board.piece_at(a).piece_type==chess.PAWN and board.piece_at(a).color==color for a in board.attackers(color, sq))\n                # attacked by enemy pawn?\n                enemy_pawn_attacks = any(board.piece_at(a) and board.piece_at(a).piece_type==chess.PAWN and board.piece_at(a).color==enemy for a in board.attackers(enemy, sq))\n                if pawn_support and not enemy_pawn_attacks:\n                    cnt += 1.0\n            return cnt\n        w = outpost_count(chess.WHITE)\n        b = outpost_count(chess.BLACK)\n        return float(w - b)\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Queen activity: average queen mobility per queen (white - black), encourages central/active queens'\n    try:\n        orig = board.turn\n        try:\n            board.turn = chess.WHITE\n            w_moves = 0\n            w_q = 0\n            for mv in board.legal_moves:\n                p = board.piece_at(mv.from_square)\n                if p and p.color == chess.WHITE and p.piece_type == chess.QUEEN:\n                    w_moves += 1\n            # count white queens on board\n            for p in board.piece_map().values():\n                if p and p.color == chess.WHITE and p.piece_type == chess.QUEEN:\n                    w_q += 1\n            board.turn = chess.BLACK\n            b_moves = 0\n            b_q = 0\n            for mv in board.legal_moves:\n                p = board.piece_at(mv.from_square)\n                if p and p.color == chess.BLACK and p.piece_type == chess.QUEEN:\n                    b_moves += 1\n            for p in board.piece_map().values():\n                if p and p.color == chess.BLACK and p.piece_type == chess.QUEEN:\n                    b_q += 1\n        finally:\n            board.turn = orig\n        avg_w = (w_moves / w_q) if w_q > 0 else 0.0\n        avg_b = (b_moves / b_q) if b_q > 0 else 0.0\n        return float(avg_w - avg_b)\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Doubled pawn penalty difference: (black doubled pawns - white doubled pawns), positive favors White when Black has more doubled pawns'\n    try:\n        files_white = [0]*8\n        files_black = [0]*8\n        for sq,p in board.piece_map().items():\n            if p and p.piece_type == chess.PAWN:\n                f = chess.square_file(sq)\n                if p.color == chess.WHITE:\n                    files_white[f] += 1\n                else:\n                    files_black[f] += 1\n        def doubled(files):\n            cnt = 0\n            for f in range(8):\n                if files[f] > 1:\n                    cnt += files[f] - 1  # number of doubled beyond first\n            return cnt\n        w_d = doubled(files_white)\n        b_d = doubled(files_black)\n        return float(b_d - w_d)\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Capture opportunity imbalance (approx): number of likely captures for White - Black (positive favors White)'\n    try:\n        pm = board.piece_map()\n        # approximate capture if a legal move's to_square currently contains an opposite color piece\n        orig = board.turn\n        try:\n            board.turn = chess.WHITE\n            w_caps = 0\n            for mv in board.legal_moves:\n                if board.piece_at(mv.to_square) is not None and board.piece_at(mv.to_square).color == chess.BLACK:\n                    w_caps += 1\n            board.turn = chess.BLACK\n            b_caps = 0\n            for mv in board.legal_moves:\n                if board.piece_at(mv.to_square) is not None and board.piece_at(mv.to_square).color == chess.WHITE:\n                    b_caps += 1\n        finally:\n            board.turn = orig\n        return float(w_caps - b_caps)\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Closest pawn promotion race advantage: (black_min_distance - white_min_distance) positive when White has a closer pawn to promotion'\n    try:\n        pm = board.piece_map()\n        w_min = 8.0\n        b_min = 8.0\n        for sq,p in pm.items():\n            if not p or p.piece_type != chess.PAWN:\n                continue\n            r = chess.square_rank(sq)\n            if p.color == chess.WHITE:\n                d = float(7 - r)\n                if d < w_min:\n                    w_min = d\n            else:\n                d = float(r)\n                if d < b_min:\n                    b_min = d\n        if w_min == 8.0:\n            w_min = 12.0\n        if b_min == 8.0:\n            b_min = 12.0\n        # positive means White closer (since we return black_min - white_min)\n        return float(b_min - w_min)\n    except Exception:\n        return 0.0\n",
    "def feature(board: chess.Board) -> float:\n    'Passed pawn advancement balance: sum of passed-pawn advancement (white - black), weighted by rank advancement'\n    try:\n        pm = board.piece_map()\n        def is_passed(sq, color):\n            f = chess.square_file(sq); r = chess.square_rank(sq)\n            if color == chess.WHITE:\n                # no black pawn on same/adjacent files on any higher rank\n                for sq2, p2 in pm.items():\n                    if p2 and p2.piece_type == chess.PAWN and p2.color == chess.BLACK:\n                        f2 = chess.square_file(sq2); r2 = chess.square_rank(sq2)\n                        if abs(f2 - f) <= 1 and r2 > r:\n                            return False\n                return True\n            else:\n                for sq2, p2 in pm.items():\n                    if p2 and p2.piece_type == chess.PAWN and p2.color == chess.WHITE:\n                        f2 = chess.square_file(sq2); r2 = chess.square_rank(sq2)\n                        if abs(f2 - f) <= 1 and r2 < r:\n                            return False\n                return True\n        score_w = 0.0; score_b = 0.0\n        for sq, p in pm.items():\n            if not p or p.piece_type != chess.PAWN:\n                continue\n            r = chess.square_rank(sq)\n            if p.color == chess.WHITE:\n                if is_passed(sq, chess.WHITE):\n                    # advancement weight: closer to promotion -> higher\n                    weight = float(r) / 7.0\n                    score_w += weight\n            else:\n                if is_passed(sq, chess.BLACK):\n                    weight = float(7 - r) / 7.0\n                    score_b += weight\n        return float(score_w - score_b)\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Rook effectiveness: rooks on open/half-open files and on opponent 7th rank (white - black)'\n    try:\n        pm = board.piece_map()\n        # precompute pawns on files\n        pawns_on_file = {f: {'w':0, 'b':0} for f in range(8)}\n        for sq, p in pm.items():\n            if p and p.piece_type == chess.PAWN:\n                pawns_on_file[chess.square_file(sq)]['w' if p.color == chess.WHITE else 'b'] += 1\n        def rook_score_for_color(color):\n            score = 0.0\n            for sq, p in pm.items():\n                if not p or p.piece_type != chess.ROOK or p.color != color:\n                    continue\n                f = chess.square_file(sq); r = chess.square_rank(sq)\n                total_pawns_on_file = pawns_on_file[f]['w'] + pawns_on_file[f]['b']\n                if total_pawns_on_file == 0:\n                    score += 1.0  # open file\n                else:\n                    # half-open if no friendly pawn on file\n                    if pawns_on_file[f]['w' if color == chess.WHITE else 'b'] == 0:\n                        score += 0.6\n                # rook on opponent 7th rank (rank 6 for white rooks attacking black)\n                if color == chess.WHITE and r == 6:\n                    score += 0.8\n                if color == chess.BLACK and r == 1:\n                    score += 0.8\n            return score\n        sc_w = rook_score_for_color(chess.WHITE)\n        sc_b = rook_score_for_color(chess.BLACK)\n        return float(sc_w - sc_b)\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'King centralization adjusted for phase: positive if White king more centralized in endgame, penalize centralization in middlegame'\n    try:\n        pm = board.piece_map()\n        # compute non-pawn material (excluding kings and pawns)\n        values = {chess.KNIGHT:3.0, chess.BISHOP:3.0, chess.ROOK:5.0, chess.QUEEN:9.0}\n        nonpawn_total = 0.0\n        for p in pm.values():\n            if p and p.piece_type in values:\n                nonpawn_total += values[p.piece_type]\n        # find kings\n        wk = next((sq for sq,p in pm.items() if p and p.piece_type == chess.KING and p.color == chess.WHITE), None)\n        bk = next((sq for sq,p in pm.items() if p and p.piece_type == chess.KING and p.color == chess.BLACK), None)\n        def centrality(ksq):\n            if ksq is None:\n                return 0.0\n            f = chess.square_file(ksq); r = chess.square_rank(ksq)\n            # distance to board center (3.5,3.5)\n            dx = float(f) - 3.5; dy = float(r) - 3.5\n            dist = (dx*dx + dy*dy) ** 0.5\n            # normalized so center -> 1.0, corner approx -> 0.0 (max dist ~4.95)\n            return max(0.0, 1.0 - dist / 5.0)\n        w_cent = centrality(wk); b_cent = centrality(bk)\n        # endgame if low non-pawn material\n        if nonpawn_total <= 6.0:\n            factor = 1.0\n        else:\n            # in middlegame centralizing king is typically bad; negative small factor\n            factor = -0.25\n        return float((w_cent - b_cent) * factor)\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Hangingness: total value of pieces attacked more times than defended (white - black)'\n    try:\n        pm = board.piece_map()\n        vals = {chess.PAWN:1.0, chess.KNIGHT:3.0, chess.BISHOP:3.0, chess.ROOK:5.0, chess.QUEEN:9.0, chess.KING:0.0}\n        hang_w = 0.0; hang_b = 0.0\n        for sq, p in pm.items():\n            if not p:\n                continue\n            attackers = board.attackers(not p.color, sq)\n            defenders = board.attackers(p.color, sq)\n            att_count = len(attackers)\n            def_count = len(defenders)\n            if att_count > def_count:\n                # attacked more times than defended => tactically vulnerable\n                if p.color == chess.WHITE:\n                    hang_w += vals.get(p.piece_type, 0.0)\n                else:\n                    hang_b += vals.get(p.piece_type, 0.0)\n        return float(hang_w - hang_b)\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Mobility per unit material: (legal moves / material) difference (white - black), helps spot passive sides'\n    try:\n        pm = board.piece_map()\n        vals = {chess.PAWN:1.0, chess.KNIGHT:3.0, chess.BISHOP:3.0, chess.ROOK:5.0, chess.QUEEN:9.0}\n        mat_w = 0.0; mat_b = 0.0\n        for p in pm.values():\n            if not p:\n                continue\n            if p.color == chess.WHITE:\n                mat_w += vals.get(p.piece_type, 0.0)\n            else:\n                mat_b += vals.get(p.piece_type, 0.0)\n        # mobility measured by legal moves available to each side\n        orig = board.turn\n        try:\n            board.turn = chess.WHITE\n            mob_w = float(sum(1 for _ in board.legal_moves))\n            board.turn = chess.BLACK\n            mob_b = float(sum(1 for _ in board.legal_moves))\n        finally:\n            board.turn = orig\n        # avoid division by zero\n        mr_w = mob_w / (mat_w + 1.0)\n        mr_b = mob_b / (mat_b + 1.0)\n        return float(mr_w - mr_b)\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Outpost knights: count of knights on outpost squares supported by pawn and not attackable by enemy pawns (white - black)'\n    try:\n        pm = board.piece_map()\n        # compute pawn attack squares for each side\n        pawn_attacks_w = set()\n        pawn_attacks_b = set()\n        for sq, p in pm.items():\n            if not p or p.piece_type != chess.PAWN:\n                continue\n            f = chess.square_file(sq); r = chess.square_rank(sq)\n            if p.color == chess.WHITE:\n                # white pawns attack r+1, f\u00b11\n                for df in (-1, 1):\n                    rf = r + 1; ff = f + df\n                    if 0 <= rf <= 7 and 0 <= ff <= 7:\n                        pawn_attacks_w.add(chess.square(ff, rf))\n            else:\n                for df in (-1, 1):\n                    rf = r - 1; ff = f + df\n                    if 0 <= rf <= 7 and 0 <= ff <= 7:\n                        pawn_attacks_b.add(chess.square(ff, rf))\n        def outpost_count(color):\n            count = 0.0\n            for sq, p in pm.items():\n                if not p or p.piece_type != chess.KNIGHT or p.color != color:\n                    continue\n                # not attackable by enemy pawns\n                if color == chess.WHITE:\n                    if sq in pawn_attacks_b:\n                        continue\n                    # supported by own pawn from behind on adjacent file\n                    f = chess.square_file(sq); r = chess.square_rank(sq)\n                    supported = False\n                    for df in (-1, 1):\n                        ff = f + df; rf = r - 1\n                        if 0 <= ff <= 7 and 0 <= rf <= 7:\n                            p2 = pm.get(chess.square(ff, rf))\n                            if p2 and p2.piece_type == chess.PAWN and p2.color == chess.WHITE:\n                                supported = True; break\n                    if supported:\n                        count += 1.0\n                else:\n                    if sq in pawn_attacks_w:\n                        continue\n                    f = chess.square_file(sq); r = chess.square_rank(sq)\n                    supported = False\n                    for df in (-1, 1):\n                        ff = f + df; rf = r + 1\n                        if 0 <= ff <= 7 and 0 <= rf <= 7:\n                            p2 = pm.get(chess.square(ff, rf))\n                            if p2 and p2.piece_type == chess.PAWN and p2.color == chess.BLACK:\n                                supported = True; break\n                    if supported:\n                        count += 1.0\n            return count\n        return float(outpost_count(chess.WHITE) - outpost_count(chess.BLACK))\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'King escape safety: number of safe adjacent squares around king (not occupied by own piece and not attacked) (white - black)'\n    try:\n        pm = board.piece_map()\n        def safe_adjacent_for_color(color):\n            ksq = next((sq for sq,p in pm.items() if p and p.piece_type == chess.KING and p.color == color), None)\n            if ksq is None:\n                return 0.0\n            safe = 0.0\n            for sq in range(64):\n                if chess.square_distance(sq, ksq) <= 1:\n                    # square must not be occupied by friendly piece\n                    occ = board.piece_at(sq)\n                    if occ and occ.color == color:\n                        continue\n                    # square must not be attacked by opponent\n                    if not board.is_attacked_by(not color, sq):\n                        safe += 1.0\n            return safe / 9.0  # normalize (max 9 including staying put)\n        sw = safe_adjacent_for_color(chess.WHITE)\n        sb = safe_adjacent_for_color(chess.BLACK)\n        return float(sw - sb)\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Pawn island and kingside majority combined: (black_islands - white_islands) + 0.3*(white_kingside_majority - black_kingside_majority)'\n    try:\n        pm = board.piece_map()\n        def pawn_islands(color):\n            files_with_pawn = [False]*8\n            for sq, p in pm.items():\n                if p and p.piece_type == chess.PAWN and p.color == color:\n                    files_with_pawn[chess.square_file(sq)] = True\n            islands = 0\n            f = 0\n            while f < 8:\n                if files_with_pawn[f]:\n                    islands += 1\n                    while f < 8 and files_with_pawn[f]:\n                        f += 1\n                else:\n                    f += 1\n            return islands\n        def kingside_pawns(color):\n            # kingside files e-h indexes 4..7\n            count = 0\n            for sq, p in pm.items():\n                if p and p.piece_type == chess.PAWN and p.color == color and 4 <= chess.square_file(sq) <= 7:\n                    count += 1\n            return count\n        wi = pawn_islands(chess.WHITE); bi = pawn_islands(chess.BLACK)\n        wk = kingside_pawns(chess.WHITE); bk = kingside_pawns(chess.BLACK)\n        return float((bi - wi) + 0.3 * ((wk - bk)))\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Pins to the king: number of own pieces pinned to king by sliding enemy pieces (white - black)'\n    try:\n        pm = board.piece_map()\n        def pinned_count(color):\n            king_sq = next((sq for sq,p in pm.items() if p and p.piece_type == chess.KING and p.color == color), None)\n            if king_sq is None:\n                return 0.0\n            count = 0.0\n            for sq, p in pm.items():\n                if not p or p.color != color or p.piece_type == chess.KING:\n                    continue\n                fk = chess.square_file(king_sq); rk = chess.square_rank(king_sq)\n                fp = chess.square_file(sq); rp = chess.square_rank(sq)\n                df = fp - fk; dr = rp - rk\n                # must be aligned\n                if df == 0 and dr == 0:\n                    continue\n                step_f = 0 if df == 0 else (1 if df > 0 else -1)\n                step_r = 0 if dr == 0 else (1 if dr > 0 else -1)\n                # check alignment: same file, rank or diagonal\n                if not (df == 0 or dr == 0 or abs(df) == abs(dr)):\n                    continue\n                # ensure path from king to this piece contains no other pieces\n                cur_f = fk + step_f; cur_r = rk + step_r\n                blocked = False\n                while (cur_f, cur_r) != (fp, rp):\n                    if not (0 <= cur_f <= 7 and 0 <= cur_r <= 7):\n                        blocked = True; break\n                    sq_mid = chess.square(cur_f, cur_r)\n                    if board.piece_at(sq_mid) is not None:\n                        blocked = True; break\n                    cur_f += step_f; cur_r += step_r\n                if blocked:\n                    continue\n                # beyond the piece, search for first blocking piece; if it's opponent sliding piece of correct type then pinned\n                cur_f = fp + step_f; cur_r = rp + step_r\n                while 0 <= cur_f <= 7 and 0 <= cur_r <= 7:\n                    sq2 = chess.square(cur_f, cur_r)\n                    p2 = board.piece_at(sq2)\n                    if p2 is not None:\n                        if p2.color != color:\n                            # check if p2 can move along this line (rook for orth, bishop for diag, queen both)\n                            orth = (step_f == 0 or step_r == 0)\n                            diag = (abs(step_f) == abs(step_r) and step_f != 0)\n                            if p2.piece_type == chess.QUEEN or (orth and p2.piece_type == chess.ROOK) or (diag and p2.piece_type == chess.BISHOP):\n                                count += 1.0\n                        break\n                    cur_f += step_f; cur_r += step_r\n            return count\n        return float(pinned_count(chess.WHITE) - pinned_count(chess.BLACK))\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'High-value tactical targets: count of opponent rooks/queens attacked by >=2 attackers and defended insufficiently (white - black)'\n    try:\n        pm = board.piece_map()\n        vals = {chess.ROOK:5.0, chess.QUEEN:9.0}\n        def target_count(attacker_color):\n            # count opponent high-value pieces that are tactically threatened by attacker_color\n            tgt = 0.0\n            opp_color = not attacker_color\n            for sq, p in pm.items():\n                if not p or p.color != opp_color or p.piece_type not in (chess.ROOK, chess.QUEEN):\n                    continue\n                attackers = board.attackers(attacker_color, sq)\n                defenders = board.attackers(opp_color, sq)\n                if len(attackers) >= 2 and len(attackers) > len(defenders):\n                    tgt += 1.0\n            return tgt\n        return float(target_count(chess.WHITE) - target_count(chess.BLACK))\n    except Exception:\n        return 0.0\n",
    "def feature(board: chess.Board) -> float:\n    'Passed pawn potential: sum of passed-pawn strengths (white - black), weighting proximity to promotion, support and opponent king distance'\n    try:\n        pm = board.piece_map()\n        vals = {chess.PAWN:1.0, chess.KNIGHT:3.0, chess.BISHOP:3.0, chess.ROOK:5.0, chess.QUEEN:9.0, chess.KING:0.0}\n        # find kings\n        wk = next((sq for sq,p in pm.items() if p and p.piece_type==chess.KING and p.color==chess.WHITE), None)\n        bk = next((sq for sq,p in pm.items() if p and p.piece_type==chess.KING and p.color==chess.BLACK), None)\n        def is_passed(sq, color):\n            f = chess.square_file(sq); r = chess.square_rank(sq)\n            if color == chess.WHITE:\n                # no black pawn on same or adjacent files with rank > r\n                for rr in range(r+1, 8):\n                    for ff in (f-1, f, f+1):\n                        if 0 <= ff <= 7:\n                            p = board.piece_at(chess.square(ff, rr))\n                            if p and p.piece_type == chess.PAWN and p.color == chess.BLACK:\n                                return False\n                return True\n            else:\n                for rr in range(0, r):\n                    for ff in (f-1, f, f+1):\n                        if 0 <= ff <= 7:\n                            p = board.piece_at(chess.square(ff, rr))\n                            if p and p.piece_type == chess.PAWN and p.color == chess.WHITE:\n                                return False\n                return True\n        score_w = 0.0; score_b = 0.0\n        for sq,p in pm.items():\n            if not p or p.piece_type != chess.PAWN:\n                continue\n            f = chess.square_file(sq); r = chess.square_rank(sq)\n            if p.color == chess.WHITE:\n                if not is_passed(sq, chess.WHITE):\n                    continue\n                # normalized distance to promotion (closer => larger)\n                base = (7 - r) / 7.0\n                support = float(len(board.attackers(chess.WHITE, sq)) > 0)\n                king_dist = chess.square_distance(sq, bk) if bk is not None else 14\n                factor = 1.0 + 0.4 * support + 0.5 * (king_dist / 14.0)\n                score_w += base * factor\n            else:\n                if not is_passed(sq, chess.BLACK):\n                    continue\n                base = (r) / 7.0  # for black, rank 0 is promotion distance 7 -> larger when closer to 0\n                support = float(len(board.attackers(chess.BLACK, sq)) > 0)\n                king_dist = chess.square_distance(sq, wk) if wk is not None else 14\n                factor = 1.0 + 0.4 * support + 0.5 * (king_dist / 14.0)\n                score_b += base * factor\n        return float(score_w - score_b)\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Rook activity: counts rooks on open files, semi-open files and rooks on seventh rank (white - black)'\n    try:\n        pm = board.piece_map()\n        def file_has_any_pawn(file_idx):\n            for rr in range(8):\n                p = board.piece_at(chess.square(file_idx, rr))\n                if p and p.piece_type == chess.PAWN:\n                    return True\n            return False\n        def file_has_friendly_pawn(file_idx, color):\n            for rr in range(8):\n                p = board.piece_at(chess.square(file_idx, rr))\n                if p and p.piece_type == chess.PAWN and p.color == color:\n                    return True\n            return False\n        score_w = 0.0; score_b = 0.0\n        for sq,p in pm.items():\n            if not p or p.piece_type != chess.ROOK:\n                continue\n            f = chess.square_file(sq); r = chess.square_rank(sq)\n            open_file = not file_has_any_pawn(f)\n            semi_open = (not file_has_friendly_pawn(f, p.color)) and file_has_any_pawn(f)\n            seventh = False\n            if p.color == chess.WHITE:\n                seventh = (r == 6)\n            else:\n                seventh = (r == 1)\n            val = 0.0\n            if open_file:\n                val += 1.0\n            if semi_open:\n                val += 0.6\n            if seventh:\n                val += 0.9\n            if p.color == chess.WHITE:\n                score_w += val\n            else:\n                score_b += val\n        return float(score_w - score_b)\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Hanging pieces value: sum of values of pieces that are attacked and undefended (black_hanging - white_hanging) \u2014 positive favors White if Black has more hanging material'\n    try:\n        vals = {chess.PAWN:1.0, chess.KNIGHT:3.0, chess.BISHOP:3.0, chess.ROOK:5.0, chess.QUEEN:9.0, chess.KING:0.0}\n        pm = board.piece_map()\n        hang_w = 0.0; hang_b = 0.0\n        for sq,p in pm.items():\n            if not p or p.piece_type == chess.KING:\n                continue\n            attackers = board.attackers(not p.color, sq)\n            defenders = board.attackers(p.color, sq)\n            if len(attackers) > 0 and len(defenders) == 0:\n                if p.color == chess.WHITE:\n                    hang_w += vals.get(p.piece_type, 0.0)\n                else:\n                    hang_b += vals.get(p.piece_type, 0.0)\n        # positive means Black has more hanging material -> good for White\n        return float(hang_b - hang_w)\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'King tropism: sum over pieces of value/(distance_to_enemy_king+1) (white - black) measuring how focused pieces are toward opponent king'\n    try:\n        pm = board.piece_map()\n        vals = {chess.PAWN:0.8, chess.KNIGHT:3.0, chess.BISHOP:3.0, chess.ROOK:4.5, chess.QUEEN:8.5, chess.KING:0.0}\n        wk = next((sq for sq,p in pm.items() if p and p.piece_type==chess.KING and p.color==chess.WHITE), None)\n        bk = next((sq for sq,p in pm.items() if p and p.piece_type==chess.KING and p.color==chess.BLACK), None)\n        score_w = 0.0; score_b = 0.0\n        for sq,p in pm.items():\n            if not p:\n                continue\n            if p.color == chess.WHITE:\n                if bk is None:\n                    continue\n                d = chess.square_distance(sq, bk)\n                score_w += vals.get(p.piece_type, 0.0) / (float(d) + 1.0)\n            else:\n                if wk is None:\n                    continue\n                d = chess.square_distance(sq, wk)\n                score_b += vals.get(p.piece_type, 0.0) / (float(d) + 1.0)\n        return float(score_w - score_b)\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Defended piece ratio: fraction of non-king pieces adequately defended (defenders >= attackers) (white - black)'\n    try:\n        pm = board.piece_map()\n        def ratio_for(color):\n            total = 0\n            defended = 0\n            for sq,p in pm.items():\n                if not p or p.piece_type == chess.KING or p.color != color:\n                    continue\n                total += 1\n                atk = len(board.attackers(not color, sq))\n                defn = len(board.attackers(color, sq))\n                if defn >= atk:\n                    defended += 1\n            if total == 0:\n                return 0.0\n            return defended / float(total)\n        return float(ratio_for(chess.WHITE) - ratio_for(chess.BLACK))\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Minor-piece outposts: count of knights and bishops on enemy half not attacked by opponent pawns (white - black)'\n    try:\n        pm = board.piece_map()\n        score_w = 0.0; score_b = 0.0\n        for sq,p in pm.items():\n            if not p or p.piece_type not in (chess.KNIGHT, chess.BISHOP):\n                continue\n            r = chess.square_rank(sq)\n            enemy = chess.BLACK if p.color == chess.WHITE else chess.WHITE\n            # enemy half definition: ranks 4..7 for white pieces, 0..3 for black pieces\n            in_enemy_half = (p.color == chess.WHITE and r >= 4) or (p.color == chess.BLACK and r <= 3)\n            if not in_enemy_half:\n                continue\n            # attacked by opponent pawns?\n            pawn_attackers = [a for a in board.attackers(enemy, sq) if board.piece_at(a) and board.piece_at(a).piece_type == chess.PAWN]\n            if len(pawn_attackers) == 0:\n                if p.color == chess.WHITE:\n                    score_w += 1.0\n                else:\n                    score_b += 1.0\n        return float(score_w - score_b)\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'King escape squares: number of adjacent safe squares (not occupied by own piece and not attacked) around each king (white - black)'\n    try:\n        pm = board.piece_map()\n        def safe_adjacent(king_sq, color):\n            if king_sq is None:\n                return 0.0\n            cnt = 0\n            for sq2 in range(64):\n                if chess.square_distance(king_sq, sq2) == 1:\n                    occ = board.piece_at(sq2)\n                    if occ and occ.color == color:\n                        continue\n                    # square must be on board (always) and not attacked by opponent\n                    if not board.is_attacked_by(not color, sq2):\n                        cnt += 1\n            return float(cnt)\n        wk = next((sq for sq,p in pm.items() if p and p.piece_type==chess.KING and p.color==chess.WHITE), None)\n        bk = next((sq for sq,p in pm.items() if p and p.piece_type==chess.KING and p.color==chess.BLACK), None)\n        return float(safe_adjacent(wk, chess.WHITE) - safe_adjacent(bk, chess.BLACK))\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Queen centrality: closeness of queens to center (d4,e4,d5,e5) (white - black), higher means more centralized'\n    try:\n        centers = [chess.parse_square(s) for s in ('d4','e4','d5','e5')]\n        pm = board.piece_map()\n        def centrality(color):\n            q_sq = next((sq for sq,p in pm.items() if p and p.piece_type==chess.QUEEN and p.color==color), None)\n            if q_sq is None:\n                return 0.0\n            min_d = min(chess.square_distance(q_sq, c) for c in centers)\n            # normalize: max reasonable distance to center can be 7 (corner to center), use 7\n            return (7.0 - float(min_d)) / 7.0\n        return float(centrality(chess.WHITE) - centrality(chess.BLACK))\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Doubled pawns imbalance: total doubled pawns (pawns stacked on same file) (black - white) positive favors White if Black has more doubled pawns'\n    try:\n        files_white = [0]*8\n        files_black = [0]*8\n        for sq,p in board.piece_map().items():\n            if p and p.piece_type == chess.PAWN:\n                f = chess.square_file(sq)\n                if p.color == chess.WHITE:\n                    files_white[f] += 1\n                else:\n                    files_black[f] += 1\n        def doubled_count(files):\n            cnt = 0\n            for f in range(8):\n                if files[f] > 1:\n                    cnt += files[f] - 1\n            return cnt\n        w_dbl = doubled_count(files_white)\n        b_dbl = doubled_count(files_black)\n        return float(b_dbl - w_dbl)\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Rook connectivity and seventh-pressure: rewards connected rooks and rooks on the seventh rank (white - black)'\n    try:\n        pm = board.piece_map()\n        def rook_score(color):\n            rooks = [sq for sq,p in pm.items() if p and p.piece_type==chess.ROOK and p.color==color]\n            score = 0.0\n            # connected rooks: same rank or same file with no pieces between\n            for i in range(len(rooks)):\n                for j in range(i+1, len(rooks)):\n                    a = rooks[i]; b = rooks[j]\n                    af = chess.square_file(a); ar = chess.square_rank(a)\n                    bf = chess.square_file(b); br = chess.square_rank(b)\n                    between_clear = True\n                    if af == bf:\n                        step = 1 if br > ar else -1\n                        for rr in range(ar+step, br, step):\n                            if board.piece_at(chess.square(af, rr)):\n                                between_clear = False; break\n                    elif ar == br:\n                        step = 1 if bf > af else -1\n                        for ff in range(af+step, bf, step):\n                            if board.piece_at(chess.square(ff, ar)):\n                                between_clear = False; break\n                    else:\n                        between_clear = False\n                    if between_clear:\n                        score += 0.8\n            # seventh rank bonus per rook\n            for sq in rooks:\n                r = chess.square_rank(sq)\n                if color == chess.WHITE and r == 6:\n                    score += 0.7\n                if color == chess.BLACK and r == 1:\n                    score += 0.7\n            return score\n        return float(rook_score(chess.WHITE) - rook_score(chess.BLACK))\n    except Exception:\n        return 0.0\n",
    "def feature(board: chess.Board) -> float:\n    'Passed pawn potential: sum over passed pawns of (1.0 + 1/(distance to promotion+1)) weighted by piece value (black - white) positive favors White'\n    try:\n        vals = {chess.PAWN:1.0}\n        pm = board.piece_map()\n        score_w = 0.0\n        score_b = 0.0\n        # helper to detect passed pawn\n        for sq, p in pm.items():\n            if p is None or p.piece_type != chess.PAWN:\n                continue\n            f = chess.square_file(sq)\n            r = chess.square_rank(sq)\n            is_passed = True\n            if p.color == chess.WHITE:\n                for opp_sq, opp_p in pm.items():\n                    if opp_p and opp_p.piece_type == chess.PAWN and opp_p.color == chess.BLACK:\n                        of = chess.square_file(opp_sq); orank = chess.square_rank(opp_sq)\n                        if abs(of - f) <= 1 and orank > r:\n                            is_passed = False\n                            break\n                if is_passed:\n                    dist = 7 - r\n                    score_w += vals[chess.PAWN] * (1.0 + 1.0 / (float(dist) + 1.0))\n            else:\n                for opp_sq, opp_p in pm.items():\n                    if opp_p and opp_p.piece_type == chess.PAWN and opp_p.color == chess.WHITE:\n                        of = chess.square_file(opp_sq); orank = chess.square_rank(opp_sq)\n                        if abs(of - f) <= 1 and orank < r:\n                            is_passed = False\n                            break\n                if is_passed:\n                    dist = r\n                    score_b += vals[chess.PAWN] * (1.0 + 1.0 / (float(dist) + 1.0))\n        # positive favors White: more black passed pawn potential -> good for White, so return black - white\n        return float(score_b - score_w)\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Pawn structure impairment: penalty for doubled and isolated pawns (black_penalty - white_penalty), positive favors White'\n    try:\n        pm = board.piece_map()\n        # count pawns per file by color\n        files_white = [0]*8\n        files_black = [0]*8\n        pawns_white_sqs = []\n        pawns_black_sqs = []\n        for sq, p in pm.items():\n            if p and p.piece_type == chess.PAWN:\n                f = chess.square_file(sq)\n                if p.color == chess.WHITE:\n                    files_white[f] += 1\n                    pawns_white_sqs.append(sq)\n                else:\n                    files_black[f] += 1\n                    pawns_black_sqs.append(sq)\n        def compute_penalty(pawn_sqs, files_count):\n            doubled = 0\n            isolated = 0\n            for sq in pawn_sqs:\n                f = chess.square_file(sq)\n                if files_count[f] > 1:\n                    doubled += 1\n                # isolated if no friendly pawn on adjacent files\n                left = files_count[f-1] if f-1 >= 0 else 0\n                right = files_count[f+1] if f+1 <= 7 else 0\n                if left + right == 0:\n                    isolated += 1\n            # heavier penalty for isolated than doubled\n            return doubled * 0.7 + isolated * 1.2\n        pen_w = compute_penalty(pawns_white_sqs, files_white)\n        pen_b = compute_penalty(pawns_black_sqs, files_black)\n        # positive favors White: black penalty - white penalty\n        return float(pen_b - pen_w)\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'King pawn shield integrity: count of friendly pawns in the pawn-shield area in front of the king (white - black), positive favors White'\n    try:\n        pm = board.piece_map()\n        wk_sq = next((sq for sq,p in pm.items() if p and p.piece_type == chess.KING and p.color == chess.WHITE), None)\n        bk_sq = next((sq for sq,p in pm.items() if p and p.piece_type == chess.KING and p.color == chess.BLACK), None)\n        def shield_count(king_sq, color):\n            if king_sq is None:\n                return 0.0\n            kf = chess.square_file(king_sq)\n            kr = chess.square_rank(king_sq)\n            count = 0\n            if color == chess.WHITE:\n                ranks = [kr+1, kr+2]\n            else:\n                ranks = [kr-1, kr-2]\n            for rf in ranks:\n                if rf < 0 or rf > 7:\n                    continue\n                for ff in range(max(0, kf-1), min(7, kf+1)+1):\n                    sq = chess.square(ff, rf)\n                    p = board.piece_at(sq)\n                    if p and p.piece_type == chess.PAWN and p.color == color:\n                        count += 1\n            return float(count)\n        sw = shield_count(wk_sq, chess.WHITE)\n        sb = shield_count(bk_sq, chess.BLACK)\n        return float(sw - sb)\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Rooks on opponent second/seventh ranks: count white rooks on 7th minus black rooks on 2nd (positive favors White)'\n    try:\n        score_w = 0.0\n        score_b = 0.0\n        for sq, p in board.piece_map().items():\n            if p and p.piece_type == chess.ROOK:\n                rank = chess.square_rank(sq)\n                if p.color == chess.WHITE and rank == 6:\n                    score_w += 1.0\n                if p.color == chess.BLACK and rank == 1:\n                    score_b += 1.0\n        return float(score_w - score_b)\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Outposted knights: number of knights on enemy half that are supported by a pawn and not attacked by any enemy pawn (white - black)'\n    try:\n        pm = board.piece_map()\n        out_w = 0.0\n        out_b = 0.0\n        for sq, p in pm.items():\n            if p is None or p.piece_type != chess.KNIGHT:\n                continue\n            rank = chess.square_rank(sq)\n            file = chess.square_file(sq)\n            if p.color == chess.WHITE:\n                if rank < 4:\n                    continue\n                # defended by pawn?\n                defenders = board.attackers(chess.WHITE, sq)\n                has_pawn_def = any(board.piece_at(d) and board.piece_at(d).piece_type == chess.PAWN for d in defenders)\n                # attacked by enemy pawn?\n                attackers = board.attackers(chess.BLACK, sq)\n                attacked_by_pawn = any(board.piece_at(a) and board.piece_at(a).piece_type == chess.PAWN for a in attackers)\n                if has_pawn_def and not attacked_by_pawn:\n                    out_w += 1.0\n            else:\n                if rank > 3:\n                    continue\n                defenders = board.attackers(chess.BLACK, sq)\n                has_pawn_def = any(board.piece_at(d) and board.piece_at(d).piece_type == chess.PAWN for d in defenders)\n                attackers = board.attackers(chess.WHITE, sq)\n                attacked_by_pawn = any(board.piece_at(a) and board.piece_at(a).piece_type == chess.PAWN for a in attackers)\n                if has_pawn_def and not attacked_by_pawn:\n                    out_b += 1.0\n        return float(out_w - out_b)\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Hanging pieces weighted: sum of values of opponent pieces that are attacked and have zero defenders (black_hanging - white_hanging), positive favors White'\n    try:\n        vals = {chess.PAWN:1.0, chess.KNIGHT:3.0, chess.BISHOP:3.0, chess.ROOK:5.0, chess.QUEEN:9.0, chess.KING:0.0}\n        pm = board.piece_map()\n        hang_w = 0.0\n        hang_b = 0.0\n        for sq, p in pm.items():\n            if p is None:\n                continue\n            attackers_by_opp = len(board.attackers(not p.color, sq))\n            defenders_by_owner = len(board.attackers(p.color, sq))\n            if attackers_by_opp > 0 and defenders_by_owner == 0:\n                # piece p is hanging\n                if p.color == chess.WHITE:\n                    hang_w += vals.get(p.piece_type, 0.0)\n                else:\n                    hang_b += vals.get(p.piece_type, 0.0)\n        # positive favors White: black pieces hanging is good for White\n        return float(hang_b - hang_w)\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'King centralization advantage in low-material endgames: (white_center - black_center) if non-king material <= 6, else 0'\n    try:\n        vals = {chess.PAWN:1.0, chess.KNIGHT:3.0, chess.BISHOP:3.0, chess.ROOK:5.0, chess.QUEEN:9.0}\n        material = 0.0\n        pm = board.piece_map()\n        for p in pm.values():\n            if p and p.piece_type in vals:\n                material += vals[p.piece_type]\n        if material > 6.0:\n            return 0.0\n        # center squares: d4(3,3), e4(4,3), d5(3,4), e5(4,4) - compute min Manhattan distance to these\n        center_sqs = [chess.square(3,3), chess.square(4,3), chess.square(3,4), chess.square(4,4)]\n        def center_score(king_sq):\n            if king_sq is None:\n                return 0.0\n            dmin = min(chess.square_distance(king_sq, csq) for csq in center_sqs)\n            # normalize: max manhattan distance on board is 14\n            return (14.0 - float(dmin)) / 14.0\n        wk_sq = next((sq for sq,p in pm.items() if p and p.piece_type == chess.KING and p.color == chess.WHITE), None)\n        bk_sq = next((sq for sq,p in pm.items() if p and p.piece_type == chess.KING and p.color == chess.BLACK), None)\n        return float(center_score(wk_sq) - center_score(bk_sq))\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Coordination: count of squares in opponent half controlled by two or more friendly pieces (white - black), positive favors White'\n    try:\n        coord_w = 0.0\n        coord_b = 0.0\n        # white controls ranks 4..7 (indices 4..7) ; black controls 0..3\n        for r in range(4, 8):\n            for f in range(8):\n                sq = chess.square(f, r)\n                if len(board.attackers(chess.WHITE, sq)) >= 2:\n                    coord_w += 1.0\n                if len(board.attackers(chess.BLACK, sq)) >= 2:\n                    coord_b += 1.0\n        return float(coord_w - coord_b)\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Bishop-pair quality: +1 if player has two bishops on opposite-colored squares (white - black), positive favors White'\n    try:\n        pm = board.piece_map()\n        def bishop_opposite_color(color):\n            bishops = [sq for sq,p in pm.items() if p and p.color == color and p.piece_type == chess.BISHOP]\n            if len(bishops) < 2:\n                return 0.0\n            # compute parity (file+rank) %2; if parities differ they are on opposite colors\n            parities = [(chess.square_file(sq) + chess.square_rank(sq)) & 1 for sq in bishops]\n            return 1.0 if parities[0] != parities[1] else 0.0\n        return float(bishop_opposite_color(chess.WHITE) - bishop_opposite_color(chess.BLACK))\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Pawn majority by flank imbalance: (white_kingside - black_kingside) - (white_queenside - black_queenside) positive favors White having kingside majority'\n    try:\n        wk = 0; bk = 0; wq = 0; bq = 0\n        for sq, p in board.piece_map().items():\n            if p and p.piece_type == chess.PAWN:\n                f = chess.square_file(sq)\n                # queenside files 0..2, kingside files 5..7\n                if f <= 2:\n                    if p.color == chess.WHITE:\n                        wq += 1\n                    else:\n                        bq += 1\n                if f >= 5:\n                    if p.color == chess.WHITE:\n                        wk += 1\n                    else:\n                        bk += 1\n        kingside_diff = (wk - bk)\n        queenside_diff = (wq - bq)\n        return float(kingside_diff - queenside_diff)\n    except Exception:\n        return 0.0\n",
    "def feature(board: chess.Board) -> float:\n    'Passed pawn advancement potential: sum of passed pawn progress (white - black), weighted by advancement and basic support'\n    try:\n        pm = board.piece_map()\n        def is_passed_pawn(sq, color):\n            f = chess.square_file(sq)\n            r = chess.square_rank(sq)\n            if color == chess.WHITE:\n                # no black pawn on same or adjacent files ahead (higher ranks)\n                for rr in range(r+1, 8):\n                    for ff in (f-1, f, f+1):\n                        if 0 <= ff <= 7:\n                            p = pm.get(chess.square(ff, rr))\n                            if p and p.piece_type == chess.PAWN and p.color == chess.BLACK:\n                                return False\n                return True\n            else:\n                # black pawn: no white pawn on same or adjacent files ahead (lower ranks)\n                for rr in range(r-1, -1, -1):\n                    for ff in (f-1, f, f+1):\n                        if 0 <= ff <= 7:\n                            p = pm.get(chess.square(ff, rr))\n                            if p and p.piece_type == chess.PAWN and p.color == chess.WHITE:\n                                return False\n                return True\n        def pawn_progress_score(sq, color):\n            r = chess.square_rank(sq)\n            base = (r / 7.0) if color == chess.WHITE else ((7 - r) / 7.0)\n            support = 0.25 if any((board.piece_at(a) and board.piece_at(a).piece_type == chess.PAWN) for a in board.attackers(color, sq)) else 0.0\n            bonus = 0.5 if (color == chess.WHITE and r >= 6) or (color == chess.BLACK and r <= 1) else 0.0\n            return base + support + bonus\n        sum_w = 0.0; sum_b = 0.0\n        for sq, p in pm.items():\n            if not p or p.piece_type != chess.PAWN:\n                continue\n            if is_passed_pawn(sq, p.color):\n                sc = pawn_progress_score(sq, p.color)\n                if p.color == chess.WHITE:\n                    sum_w += sc\n                else:\n                    sum_b += sc\n        return float(sum_w - sum_b)\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Pawn structure weaknesses (isolated+doubled+backward) imbalance (black weaknesses - white weaknesses) positive favors White'\n    try:\n        pm = board.piece_map()\n        files_pawns = {f: {chess.WHITE: [], chess.BLACK: []} for f in range(8)}\n        for sq, p in pm.items():\n            if p and p.piece_type == chess.PAWN:\n                files_pawns[chess.square_file(sq)][p.color].append(sq)\n        def weaknesses_for(color):\n            iso = 0.0; doubled = 0.0; back = 0.0\n            for f in range(8):\n                pawns = files_pawns[f][color]\n                if not pawns:\n                    continue\n                # doubled: count beyond 1\n                if len(pawns) > 1:\n                    doubled += float(len(pawns) - 1)\n                for sq in pawns:\n                    # isolated: no friendly pawn on adjacent files\n                    adj_present = False\n                    for af in (f-1, f+1):\n                        if 0 <= af <= 7 and files_pawns[af][color]:\n                            adj_present = True; break\n                    if not adj_present:\n                        iso += 1.0\n                    # backward estimation: cannot advance safely and lacks adjacent pawn support from behind/same rank\n                    r = chess.square_rank(sq)\n                    forward_sq = None\n                    if color == chess.WHITE and r < 7:\n                        forward_sq = chess.square(f, r+1)\n                    if color == chess.BLACK and r > 0:\n                        forward_sq = chess.square(f, r-1)\n                    blocked_or_danger = False\n                    if forward_sq is None or pm.get(forward_sq) is not None:\n                        blocked_or_danger = True\n                    else:\n                        # if forward square is attacked by enemy and there is no friendly pawn on adjacent files on same or behind ranks to support, mark as backward\n                        enemy = not color\n                        if board.is_attacked_by(enemy, forward_sq):\n                            support_found = False\n                            for af in (f-1, f+1):\n                                if 0 <= af <= 7:\n                                    for psq in files_pawns[af][color]:\n                                        if (color == chess.WHITE and chess.square_rank(psq) <= r) or (color == chess.BLACK and chess.square_rank(psq) >= r):\n                                            support_found = True; break\n                                    if support_found:\n                                        break\n                            if not support_found:\n                                blocked_or_danger = True\n                    if blocked_or_danger:\n                        back += 1.0\n            # weighted sum: backward more severe\n            return iso * 0.8 + doubled * 0.6 + back * 1.2\n        w_weak = weaknesses_for(chess.WHITE)\n        b_weak = weaknesses_for(chess.BLACK)\n        # positive when Black has more weaknesses (favors White)\n        return float(b_weak - w_weak)\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'King castle pawn shield integrity: pawn presence minus enemy attacks on typical shield squares (white - black)'\n    try:\n        pm = board.piece_map()\n        def shield_score(color):\n            # identify king square\n            king_sq = next((sq for sq,p in pm.items() if p and p.piece_type == chess.KING and p.color == color), None)\n            if king_sq is None:\n                return 0.0\n            f = chess.square_file(king_sq); r = chess.square_rank(king_sq)\n            # approximate castled by being on g-file or c-file initial ranks\n            if color == chess.WHITE:\n                if king_sq == chess.parse_square('g1'):\n                    shield_sqs = [chess.parse_square(s) for s in ('f2', 'g2', 'h2')]\n                elif king_sq == chess.parse_square('c1'):\n                    shield_sqs = [chess.parse_square(s) for s in ('b2', 'c2', 'd2')]\n                else:\n                    # if not castled, consider three squares in front of king\n                    shield_sqs = []\n                    for df in (-1,0,1):\n                        ff = f + df\n                        rr = r + 1\n                        if 0 <= ff <= 7 and 0 <= rr <= 7:\n                            shield_sqs.append(chess.square(ff, rr))\n            else:\n                if king_sq == chess.parse_square('g8'):\n                    shield_sqs = [chess.parse_square(s) for s in ('f7', 'g7', 'h7')]\n                elif king_sq == chess.parse_square('c8'):\n                    shield_sqs = [chess.parse_square(s) for s in ('b7', 'c7', 'd7')]\n                else:\n                    shield_sqs = []\n                    for df in (-1,0,1):\n                        ff = f + df\n                        rr = r - 1\n                        if 0 <= ff <= 7 and 0 <= rr <= 7:\n                            shield_sqs.append(chess.square(ff, rr))\n            score = 0.0\n            enemy = not color\n            for sq in shield_sqs:\n                p = board.piece_at(sq)\n                if p and p.piece_type == chess.PAWN and p.color == color:\n                    score += 1.0\n                # penalize if attacked by enemy\n                if board.is_attacked_by(enemy, sq):\n                    score -= 0.5\n            return score\n        return float(shield_score(chess.WHITE) - shield_score(chess.BLACK))\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Central control value: weighted attackers on d4,e4,d5,e5 (white - black) using piece weights'\n    try:\n        center_names = ('d4','e4','d5','e5')\n        centers = [chess.parse_square(n) for n in center_names]\n        vals = {chess.PAWN:1.0, chess.KNIGHT:3.0, chess.BISHOP:3.0, chess.ROOK:5.0, chess.QUEEN:9.0, chess.KING:0.0}\n        score_w = 0.0; score_b = 0.0\n        for sq in centers:\n            for a in board.attackers(chess.WHITE, sq):\n                p = board.piece_at(a)\n                if p:\n                    score_w += vals.get(p.piece_type, 0.0)\n            for a in board.attackers(chess.BLACK, sq):\n                p = board.piece_at(a)\n                if p:\n                    score_b += vals.get(p.piece_type, 0.0)\n        return float(score_w - score_b)\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Knight outpost score: knights on squares not attackable by enemy pawns and (optionally) supported by a pawn (white - black)'\n    try:\n        pm = board.piece_map()\n        score_w = 0.0; score_b = 0.0\n        for sq, p in pm.items():\n            if not p or p.piece_type != chess.KNIGHT:\n                continue\n            enemy = not p.color\n            # if any enemy pawn can capture this square, it's not an outpost\n            pawn_attackers = [a for a in board.attackers(enemy, sq) if board.piece_at(a) and board.piece_at(a).piece_type == chess.PAWN]\n            # require some centralization: prefer ranks 4..6 for white and 1..4 for black (0-based rank)\n            r = chess.square_rank(sq)\n            central_bonus = 1.0 if (p.color == chess.WHITE and r >= 3) or (p.color == chess.BLACK and r <= 4) else 0.0\n            defended_by_pawn = any(board.piece_at(a) and board.piece_at(a).piece_type == chess.PAWN and board.piece_at(a).color == p.color for a in board.attackers(p.color, sq))\n            if not pawn_attackers and defended_by_pawn:\n                if p.color == chess.WHITE:\n                    score_w += 1.0 + 0.5 * central_bonus\n                else:\n                    score_b += 1.0 + 0.5 * central_bonus\n        return float(score_w - score_b)\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Immediate tactical checks available: number of legal checking moves for White minus Black (positive favors White)'\n    try:\n        orig_turn = board.turn\n        white_checks = 0\n        black_checks = 0\n        # Count checks for White\n        try:\n            board.turn = chess.WHITE\n            for mv in list(board.legal_moves):\n                board.push(mv)\n                if board.is_check():\n                    white_checks += 1\n                board.pop()\n            # Count checks for Black\n            board.turn = chess.BLACK\n            for mv in list(board.legal_moves):\n                board.push(mv)\n                if board.is_check():\n                    black_checks += 1\n                board.pop()\n        finally:\n            board.turn = orig_turn\n        return float(white_checks - black_checks)\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Trapped/immobile pieces under attack penalty: sum of attacked pieces with <=1 legal move weighted by value (black_penalty - white_penalty) positive favors White'\n    try:\n        pm = board.piece_map()\n        vals = {chess.PAWN:1.0, chess.KNIGHT:3.0, chess.BISHOP:3.0, chess.ROOK:5.0, chess.QUEEN:9.0, chess.KING:0.0}\n        orig = board.turn\n        pen_w = 0.0; pen_b = 0.0\n        try:\n            for color in (chess.WHITE, chess.BLACK):\n                board.turn = color\n                # build map from square to number of legal moves for piece\n                move_counts = {}\n                for mv in board.legal_moves:\n                    move_counts[mv.from_square] = move_counts.get(mv.from_square, 0) + 1\n                for sq, p in pm.items():\n                    if not p or p.color != color or p.piece_type == chess.KING:\n                        continue\n                    moves = move_counts.get(sq, 0)\n                    attacked = bool(board.attackers(not color, sq))\n                    if moves <= 1 and attacked:\n                        if color == chess.WHITE:\n                            pen_w += vals.get(p.piece_type, 0.0)\n                        else:\n                            pen_b += vals.get(p.piece_type, 0.0)\n        finally:\n            board.turn = orig\n        # advantage if opponent has more penalties (i.e., black_pen - white_pen)\n        return float(pen_b - pen_w)\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Queen exposure: sum of (attackers - defenders) on each queen (black_exposure - white_exposure), positive favors White'\n    try:\n        pm = board.piece_map()\n        exposure_w = 0.0; exposure_b = 0.0\n        for sq, p in pm.items():\n            if not p or p.piece_type != chess.QUEEN:\n                continue\n            attackers = list(board.attackers(not p.color, sq))\n            defenders = list(board.attackers(p.color, sq))\n            # only positive exposure (more attackers than defenders) matters\n            diff = max(0, len(attackers) - len(defenders))\n            # weight by attacker piece values crudely\n            weight = 0.0\n            for a in attackers:\n                ap = board.piece_at(a)\n                if ap:\n                    if ap.piece_type == chess.PAWN:\n                        weight += 1.0\n                    elif ap.piece_type in (chess.KNIGHT, chess.BISHOP):\n                        weight += 3.0\n                    elif ap.piece_type == chess.ROOK:\n                        weight += 4.5\n                    elif ap.piece_type == chess.QUEEN:\n                        weight += 6.0\n            # combine counts and weight\n            total_exposure = diff + 0.1 * weight\n            if p.color == chess.WHITE:\n                exposure_w += total_exposure\n            else:\n                exposure_b += total_exposure\n        return float(exposure_b - exposure_w)\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Minor vs major balance: (minor_value - major_value) difference (white - black). Positive favors White if White has more minors relative to majors'\n    try:\n        pm = board.piece_map()\n        def values(color):\n            minors = 0.0; majors = 0.0\n            for p in pm.values():\n                if not p or p.color != color:\n                    continue\n                if p.piece_type in (chess.KNIGHT, chess.BISHOP):\n                    minors += 1.0\n                if p.piece_type in (chess.ROOK, chess.QUEEN):\n                    majors += 1.0\n            # scale to approximate material: minors*3.0, majors*(~4.5)\n            return minors * 3.0 - majors * 4.5\n        return float(values(chess.WHITE) - values(chess.BLACK))\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'King centralization preference in endgames: (black_distance_to_center - white_distance_to_center) positive favors White when endgame'\n    try:\n        pm = board.piece_map()\n        # compute material excluding kings\n        total_mat = 0.0\n        matvals = {chess.PAWN:1.0, chess.KNIGHT:3.0, chess.BISHOP:3.0, chess.ROOK:5.0, chess.QUEEN:9.0}\n        for p in pm.values():\n            if p and p.piece_type in matvals:\n                total_mat += matvals[p.piece_type]\n        # only meaningful in endgames (low material)\n        if total_mat > 10.0:\n            return 0.0\n        centers = [chess.parse_square(n) for n in ('d4','e4','d5','e5')]\n        def avg_dist_to_center(king_sq):\n            if king_sq is None:\n                return 100.0\n            s = 0.0\n            for c in centers:\n                s += chess.square_distance(king_sq, c)\n            return s / len(centers)\n        wk = next((sq for sq,p in pm.items() if p and p.piece_type == chess.KING and p.color == chess.WHITE), None)\n        bk = next((sq for sq,p in pm.items() if p and p.piece_type == chess.KING and p.color == chess.BLACK), None)\n        if wk is None or bk is None:\n            return 0.0\n        wd = avg_dist_to_center(wk)\n        bd = avg_dist_to_center(bk)\n        # normalize by max possible (~7)\n        return float((bd - wd) / 7.0)\n    except Exception:\n        return 0.0\n",
    "def feature(board: chess.Board) -> float:\n    'King pawn-shield integrity: score of how intact and unassailed the three pawn-shield squares in front of each king are (white - black)'\n    try:\n        pm = board.piece_map()\n        def shield_score(color):\n            # find king\n            ks = next((sq for sq,p in pm.items() if p and p.piece_type == chess.KING and p.color == color), None)\n            if ks is None:\n                return 0.0\n            f = chess.square_file(ks); r = chess.square_rank(ks)\n            score = 0.0\n            # for white shield squares are at rank+1; for black at rank-1\n            dr = 1 if color == chess.WHITE else -1\n            opp = chess.BLACK if color == chess.WHITE else chess.WHITE\n            for df in (-1, 0, 1):\n                cf = f + df; cr = r + dr\n                if not (0 <= cf <= 7 and 0 <= cr <= 7):\n                    # off-board -> consider weak (no shield)\n                    score -= 0.5\n                    continue\n                sq = chess.square(cf, cr)\n                p = board.piece_at(sq)\n                if p and p.piece_type == chess.PAWN and p.color == color:\n                    # good pawn present; penalize if it's attacked by opponent\n                    if board.is_attacked_by(opp, sq):\n                        score += 0.0  # pawn present but threatened\n                    else:\n                        score += 1.0\n                else:\n                    # missing pawn -> penalize more if attacked square or occupied by opponent pawn\n                    if p and p.piece_type == chess.PAWN and p.color == opp:\n                        score -= 0.8\n                    else:\n                        score -= 0.6\n                    if board.is_attacked_by(opp, sq):\n                        score -= 0.2\n            return score\n        return float(shield_score(chess.WHITE) - shield_score(chess.BLACK))\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Passed pawn potential: weighted count of passed pawns by advancement (white - black)'\n    try:\n        pm = board.piece_map()\n        def passed_sum(color):\n            total = 0.0\n            for sq,p in pm.items():\n                if not p or p.piece_type != chess.PAWN or p.color != color:\n                    continue\n                f = chess.square_file(sq); r = chess.square_rank(sq)\n                passed = True\n                if color == chess.WHITE:\n                    for af in (f-1, f, f+1):\n                        for rr in range(r+1, 8):\n                            s2 = chess.square(af, rr) if 0 <= af <= 7 else None\n                            if s2 is not None:\n                                q = pm.get(s2)\n                                if q and q.piece_type == chess.PAWN and q.color == chess.BLACK:\n                                    passed = False; break\n                        if not passed:\n                            break\n                    if passed:\n                        # advancement weight: more advanced = more important\n                        weight = float(r) / 7.0\n                        total += 1.0 + weight * 2.0\n                else:\n                    for af in (f-1, f, f+1):\n                        for rr in range(r-1, -1, -1):\n                            s2 = chess.square(af, rr) if 0 <= af <= 7 else None\n                            if s2 is not None:\n                                q = pm.get(s2)\n                                if q and q.piece_type == chess.PAWN and q.color == chess.WHITE:\n                                    passed = False; break\n                        if not passed:\n                            break\n                    if passed:\n                        weight = float(7 - r) / 7.0\n                        total += 1.0 + weight * 2.0\n            return total\n        return float(passed_sum(chess.WHITE) - passed_sum(chess.BLACK))\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Rook file quality: count rooks on open (1.0) or semi-open (0.5) files (white - black)'\n    try:\n        pm = board.piece_map()\n        def rook_score(color):\n            score = 0.0\n            for sq,p in pm.items():\n                if not p or p.piece_type != chess.ROOK or p.color != color:\n                    continue\n                f = chess.square_file(sq)\n                pawns_on_file = [q for s2,q in pm.items() if q and q.piece_type == chess.PAWN and chess.square_file(s2) == f]\n                if not pawns_on_file:\n                    score += 1.0\n                else:\n                    # semi-open if there are pawns but none of them are friendly\n                    if all(q.color != color for q in pawns_on_file):\n                        score += 0.5\n            return score\n        return float(rook_score(chess.WHITE) - rook_score(chess.BLACK))\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Outpost knights: count of knights on opponent half that are not attackable by enemy pawns and are supported (white - black)'\n    try:\n        pm = board.piece_map()\n        def outposts(color):\n            cnt = 0.0\n            opp = chess.BLACK if color == chess.WHITE else chess.WHITE\n            for sq,p in pm.items():\n                if not p or p.piece_type != chess.KNIGHT or p.color != color:\n                    continue\n                f = chess.square_file(sq); r = chess.square_rank(sq)\n                # require in opponent half\n                if color == chess.WHITE and r < 4:\n                    continue\n                if color == chess.BLACK and r > 3:\n                    continue\n                # check if attacked by opponent pawns (pawns that could capture onto sq)\n                attackable_by_pawn = False\n                if color == chess.WHITE:\n                    # black pawns attack from r+1 at f-1,f+1\n                    for af in (f-1, f+1):\n                        ar = r+1\n                        if 0 <= af <= 7 and 0 <= ar <= 7:\n                            s2 = chess.square(af, ar)\n                            q = pm.get(s2)\n                            if q and q.piece_type == chess.PAWN and q.color == opp:\n                                attackable_by_pawn = True; break\n                else:\n                    for af in (f-1, f+1):\n                        ar = r-1\n                        if 0 <= af <= 7 and 0 <= ar <= 7:\n                            s2 = chess.square(af, ar)\n                            q = pm.get(s2)\n                            if q and q.piece_type == chess.PAWN and q.color == opp:\n                                attackable_by_pawn = True; break\n                if attackable_by_pawn:\n                    continue\n                # must be supported (at least one friendly attacker)\n                if len(board.attackers(color, sq)) >= 1:\n                    cnt += 1.0\n            return cnt\n        return float(outposts(chess.WHITE) - outposts(chess.BLACK))\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Rooks on seventh rank: difference in rooks occupying the opponent seventh rank (white - black)'\n    try:\n        pm = board.piece_map()\n        wr = 0\n        br = 0\n        for sq,p in pm.items():\n            if not p or p.piece_type != chess.ROOK:\n                continue\n            r = chess.square_rank(sq)\n            if p.color == chess.WHITE and r == 6:\n                wr += 1\n            if p.color == chess.BLACK and r == 1:\n                br += 1\n        return float(wr - br)\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'King centralization weighted by endgame closeness: kings closer to center receive bonus when material is low (white - black)'\n    try:\n        pm = board.piece_map()\n        center_sq = [chess.parse_square(s) for s in ('d4','e4','d5','e5')]\n        def king_central_score(color):\n            ks = next((sq for sq,p in pm.items() if p and p.piece_type == chess.KING and p.color == color), None)\n            if ks is None:\n                return 0.0\n            # material excluding kings and pawns and queens -> estimate endgame by low heavy/minor material\n            mat = 0.0\n            vals = {chess.KNIGHT:3.0, chess.BISHOP:3.0, chess.ROOK:5.0, chess.QUEEN:9.0}\n            for p in pm.values():\n                if p and p.piece_type in vals:\n                    mat += vals[p.piece_type]\n            # closeness\n            d = min(chess.square_distance(ks, cs) for cs in center_sq)\n            closeness = (7.0 - float(d)) / 7.0\n            # weight centralization more in endgames (smaller mat)\n            weight = 1.0 + max(0.0, (6.0 - mat) / 6.0)\n            return closeness * weight\n        return float(king_central_score(chess.WHITE) - king_central_score(chess.BLACK))\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Hanging pieces value: sum of values of undefended (defenders==0) pieces attacked by opponent (black_hanging_value - white_hanging_value) positive means White has more targets'\n    try:\n        pm = board.piece_map()\n        vals = {chess.PAWN:1.0, chess.KNIGHT:3.0, chess.BISHOP:3.0, chess.ROOK:5.0, chess.QUEEN:9.0, chess.KING:0.0}\n        white_hanging = 0.0\n        black_hanging = 0.0\n        for sq,p in pm.items():\n            if not p:\n                continue\n            attackers = board.attackers(not p.color, sq)\n            defenders = board.attackers(p.color, sq)\n            if len(attackers) > 0 and len(defenders) == 0:\n                if p.color == chess.WHITE:\n                    white_hanging += vals.get(p.piece_type, 0.0)\n                else:\n                    black_hanging += vals.get(p.piece_type, 0.0)\n        # we want positive when White has more targets (i.e., black pieces hanging)\n        return float(black_hanging - white_hanging)\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Safe king escape squares: count of adjacent/safe squares for king (not attacked by opponent and either empty or capturable) (white - black)'\n    try:\n        pm = board.piece_map()\n        def safe_squares(color):\n            ks = next((sq for sq,p in pm.items() if p and p.piece_type == chess.KING and p.color == color), None)\n            if ks is None:\n                return 0.0\n            opp = chess.BLACK if color == chess.WHITE else chess.WHITE\n            cnt = 0.0\n            for sq in range(64):\n                if chess.square_distance(sq, ks) <= 1:\n                    # square can be current square or neighbor\n                    if sq == ks:\n                        # current square safe if not attacked\n                        if not board.is_attacked_by(opp, sq):\n                            cnt += 0.5\n                        continue\n                    occ = board.piece_at(sq)\n                    if occ and occ.color == color:\n                        continue\n                    # is destination attacked by opponent?\n                    if board.is_attacked_by(opp, sq):\n                        continue\n                    # otherwise it's a safe destination (empty or capturable)\n                    cnt += 1.0\n            return cnt\n        return float(safe_squares(chess.WHITE) - safe_squares(chess.BLACK))\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Center control pressure: difference in number of attackers on central squares d4/e4/d5/e5 (white - black)'\n    try:\n        centers = [chess.parse_square(s) for s in ('d4','e4','d5','e5')]\n        w = 0.0; b = 0.0\n        for sq in centers:\n            w += len(board.attackers(chess.WHITE, sq))\n            b += len(board.attackers(chess.BLACK, sq))\n        return float(w - b)\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Minor-piece mobility-weighted imbalance: mobility of knights and bishops weighted per piece (white - black)'\n    try:\n        types = (chess.KNIGHT, chess.BISHOP)\n        orig = board.turn\n        try:\n            board.turn = chess.WHITE\n            white_moves = {t:0 for t in types}\n            for mv in board.legal_moves:\n                p = board.piece_at(mv.from_square)\n                if p and p.piece_type in types and p.color == chess.WHITE:\n                    white_moves[p.piece_type] += 1\n            board.turn = chess.BLACK\n            black_moves = {t:0 for t in types}\n            for mv in board.legal_moves:\n                p = board.piece_at(mv.from_square)\n                if p and p.piece_type in types and p.color == chess.BLACK:\n                    black_moves[p.piece_type] += 1\n        finally:\n            board.turn = orig\n        # counts\n        pm = board.piece_map()\n        white_counts = {t:0 for t in types}\n        black_counts = {t:0 for t in types}\n        for p in pm.values():\n            if p and p.piece_type in types:\n                if p.color == chess.WHITE:\n                    white_counts[p.piece_type] += 1\n                else:\n                    black_counts[p.piece_type] += 1\n        def mobility_score(move_counts, counts):\n            score = 0.0\n            for t in types:\n                # average mobility per piece type, add small smoothing\n                cnt = counts[t]\n                score += (move_counts[t] / float(cnt + 0.5))\n            return score\n        return float(mobility_score(white_moves, white_counts) - mobility_score(black_moves, black_counts))\n    except Exception:\n        return 0.0\n",
    "def feature(board: chess.Board) -> float:\n    'King pawn shield integrity: difference in counts of friendly pawns protecting the king (positive => Black worse => good for White)'\n    try:\n        pm = board.piece_map()\n        def shield_count(color):\n            # find king\n            king_sq = next((sq for sq,p in pm.items() if p and p.piece_type == chess.KING and p.color == color), None)\n            if king_sq is None:\n                return 0.0\n            f = chess.square_file(king_sq); r = chess.square_rank(king_sq)\n            cnt = 0\n            # for white, pawns in ranks r+1..r+3 on files f-1,f,f+1\n            if color == chess.WHITE:\n                for dr in range(1,4):\n                    rr = r + dr\n                    if rr > 7: break\n                    for df in (-1,0,1):\n                        ff = f + df\n                        if 0 <= ff <= 7:\n                            sq = chess.square(ff, rr)\n                            p = board.piece_at(sq)\n                            if p and p.piece_type == chess.PAWN and p.color == chess.WHITE:\n                                cnt += 1\n            else:\n                for dr in range(1,4):\n                    rr = r - dr\n                    if rr < 0: break\n                    for df in (-1,0,1):\n                        ff = f + df\n                        if 0 <= ff <= 7:\n                            sq = chess.square(ff, rr)\n                            p = board.piece_at(sq)\n                            if p and p.piece_type == chess.PAWN and p.color == chess.BLACK:\n                                cnt += 1\n            # normalize to max 9\n            return float(cnt) / 3.0\n        return float(shield_count(chess.BLACK) - shield_count(chess.WHITE))\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Pawn structure weaknesses: difference (Black weaknesses - White weaknesses) counting isolated and doubled pawns (positive favors White)'\n    try:\n        pm = board.piece_map()\n        def pawn_weakness(color):\n            files = {i:[] for i in range(8)}\n            for sq,p in pm.items():\n                if p and p.piece_type == chess.PAWN and p.color == color:\n                    files[chess.square_file(sq)].append(sq)\n            weak = 0.0\n            # doubled: more than one pawn on a file\n            for f, lst in files.items():\n                if len(lst) > 1:\n                    weak += 0.75 * (len(lst) - 1)\n            # isolated: no friendly pawns on adjacent files\n            for f, lst in files.items():\n                if not lst:\n                    continue\n                adj = False\n                for af in (f-1, f+1):\n                    if 0 <= af <= 7 and files[af]:\n                        adj = True; break\n                if not adj:\n                    weak += 1.0 * len(lst)\n            return weak\n        return float(pawn_weakness(chess.BLACK) - pawn_weakness(chess.WHITE))\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Knight outpost score: counts advanced knights on opponent half that are not attacked by enemy pawns and are supported (white - black)'\n    try:\n        pm = board.piece_map()\n        def knight_outpost(color):\n            score = 0.0\n            opp = chess.BLACK if color == chess.WHITE else chess.WHITE\n            for sq,p in pm.items():\n                if not p or p.piece_type != chess.KNIGHT or p.color != color:\n                    continue\n                r = chess.square_rank(sq)\n                # advanced threshold: white ranks 4..6 (indices 4..6), black ranks 1..3 (indices 1..3)\n                if color == chess.WHITE and not (4 <= r <= 6):\n                    continue\n                if color == chess.BLACK and not (1 <= r <= 3):\n                    continue\n                # not attacked by enemy pawns\n                pawn_attackers = [a for a in board.attackers(opp, sq) if board.piece_at(a) and board.piece_at(a).piece_type == chess.PAWN]\n                if pawn_attackers:\n                    continue\n                # supported by at least one friendly piece (including pawns)\n                supporters = [a for a in board.attackers(color, sq) if board.piece_at(a) and board.piece_at(a).color == color]\n                if not supporters:\n                    continue\n                # weight: +1 base, +0.5 if supported by pawn specifically\n                wpawn = 0.5 if any(board.piece_at(a).piece_type == chess.PAWN for a in supporters) else 0.0\n                score += 1.0 + wpawn\n            return score\n        return float(knight_outpost(chess.WHITE) - knight_outpost(chess.BLACK))\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Rook on seventh rank pressure: counts rooks on opponent seventh rank (white - black)'\n    try:\n        pm = board.piece_map()\n        w = 0.0; b = 0.0\n        for sq,p in pm.items():\n            if not p or p.piece_type != chess.ROOK:\n                continue\n            r = chess.square_rank(sq)\n            if p.color == chess.WHITE and r == 6:\n                w += 1.0\n            if p.color == chess.BLACK and r == 1:\n                b += 1.0\n        return float(w - b)\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Bishop mobility and pair: (white mobility+pair_bonus) - (black mobility+pair_bonus), rewards mobility and bishop pair'\n    try:\n        pm = board.piece_map()\n        def bishop_metrics(color):\n            mobility = 0.0\n            pair_bonus = 0.0\n            bishops = [sq for sq,p in pm.items() if p and p.piece_type == chess.BISHOP and p.color == color]\n            if len(bishops) >= 2:\n                pair_bonus = 0.6\n            for sq in bishops:\n                f = chess.square_file(sq); r = chess.square_rank(sq)\n                # explore four diagonals\n                for df, dr in ((1,1),(1,-1),(-1,1),(-1,-1)):\n                    ff, rr = f + df, r + dr\n                    while 0 <= ff <= 7 and 0 <= rr <= 7:\n                        tsq = chess.square(ff, rr)\n                        if board.piece_at(tsq) is None:\n                            mobility += 1.0\n                        else:\n                            # include capture possibility\n                            piece = board.piece_at(tsq)\n                            if piece and piece.color != color:\n                                mobility += 0.7\n                            break\n                        ff += df; rr += dr\n            return mobility + pair_bonus\n        return float(bishop_metrics(chess.WHITE) - bishop_metrics(chess.BLACK))\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Loose pieces penalty: weighted sum of opponent-attacked-more-than-defended pieces (positive => Black has more loose material => good for White)'\n    try:\n        vals = {chess.PAWN:1.0, chess.KNIGHT:3.0, chess.BISHOP:3.0, chess.ROOK:5.0, chess.QUEEN:9.0, chess.KING:0.0}\n        pm = board.piece_map()\n        loose_w = 0.0; loose_b = 0.0\n        for sq,p in pm.items():\n            if not p:\n                continue\n            color = p.color\n            opp = chess.BLACK if color == chess.WHITE else chess.WHITE\n            attackers = [a for a in board.attackers(opp, sq)]\n            defenders = [d for d in board.attackers(color, sq)]\n            atk = len(attackers); df = len(defenders)\n            if atk > df:\n                val = vals.get(p.piece_type, 0.0) * float(atk - df)\n                if color == chess.WHITE:\n                    loose_w += val\n                else:\n                    loose_b += val\n        return float(loose_b - loose_w)\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Queen proximity to enemy king and centralization: (white_score - black_score) where being close to opponent king and near center is good'\n    try:\n        pm = board.piece_map()\n        wk = next((sq for sq,p in pm.items() if p and p.piece_type==chess.KING and p.color==chess.WHITE), None)\n        bk = next((sq for sq,p in pm.items() if p and p.piece_type==chess.KING and p.color==chess.BLACK), None)\n        def queen_score(color):\n            score = 0.0\n            target = bk if color == chess.WHITE else wk\n            if target is None:\n                return 0.0\n            for sq,p in pm.items():\n                if p and p.piece_type == chess.QUEEN and p.color == color:\n                    # closeness (Manhattan) invert\n                    d = chess.square_distance(sq, target)\n                    score += (14.0 - float(d)) / 14.0 * 1.5\n                    # centralization bonus\n                    f = chess.square_file(sq); r = chess.square_rank(sq)\n                    center_dist = ((f - 3.5)**2 + (r - 3.5)**2)**0.5\n                    score += (4.95 - center_dist) / 4.95 * 0.5\n            return score\n        return float(queen_score(chess.WHITE) - queen_score(chess.BLACK))\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Battery/connectivity potential: counts aligned queen-rook/rook-rook pairs with clear path (white - black)'\n    try:\n        pm = board.piece_map()\n        def aligned_score(color):\n            pieces = [sq for sq,p in pm.items() if p and p.color==color and p.piece_type in (chess.ROOK, chess.QUEEN)]\n            score = 0.0\n            for i in range(len(pieces)):\n                for j in range(i+1, len(pieces)):\n                    a = pieces[i]; b = pieces[j]\n                    af = chess.square_file(a); ar = chess.square_rank(a)\n                    bf = chess.square_file(b); br = chess.square_rank(b)\n                    df = bf - af; dr = br - ar\n                    if not (df == 0 or dr == 0 or abs(df) == abs(dr)):\n                        continue\n                    step_f = 0 if df == 0 else (1 if df > 0 else -1)\n                    step_r = 0 if dr == 0 else (1 if dr > 0 else -1)\n                    ff = af + step_f; rr = ar + step_r\n                    clear = True\n                    while 0 <= ff <= 7 and 0 <= rr <= 7:\n                        sq = chess.square(ff, rr)\n                        if sq == b:\n                            break\n                        if board.piece_at(sq) is not None:\n                            clear = False; break\n                        ff += step_f; rr += step_r\n                    if clear:\n                        score += 1.0\n            return score\n        return float(aligned_score(chess.WHITE) - aligned_score(chess.BLACK))\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Endgame king safe mobility: if low material, number of safe squares king can move to (white - black), else 0'\n    try:\n        # count non-pawn non-king material pieces\n        pm = board.piece_map()\n        nonpawns = sum(1 for p in pm.values() if p and p.piece_type not in (chess.PAWN, chess.KING))\n        if nonpawns > 4:\n            return 0.0\n        def king_safe_moves(color):\n            king_sq = next((sq for sq,p in pm.items() if p and p.piece_type==chess.KING and p.color==color), None)\n            if king_sq is None:\n                return 0.0\n            safe = 0.0\n            for f in range(8):\n                for r in range(8):\n                    sq = chess.square(f, r)\n                    # adjacency including staying in place filtered to legal king squares (one square away)\n                    if chess.square_distance(sq, king_sq) > 1:\n                        continue\n                    # cannot move to a square occupied by friendly piece\n                    p = board.piece_at(sq)\n                    if p and p.color == color:\n                        continue\n                    opp = chess.BLACK if color == chess.WHITE else chess.WHITE\n                    # if square attacked by any opponent piece, not safe\n                    if board.is_attacked_by(opp, sq):\n                        continue\n                    safe += 1.0\n            return safe\n        return float(king_safe_moves(chess.WHITE) - king_safe_moves(chess.BLACK))\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Passed pawn blockade distance: average rank-distance to nearest enemy piece that can block (higher is better for pawn owner) (white - black)'\n    try:\n        pm = board.piece_map()\n        def is_passed(sq, color):\n            f = chess.square_file(sq); r = chess.square_rank(sq)\n            if color == chess.WHITE:\n                for opp_sq,p in pm.items():\n                    if p and p.piece_type == chess.PAWN and p.color == chess.BLACK:\n                        pf = chess.square_file(opp_sq); pr = chess.square_rank(opp_sq)\n                        if abs(pf - f) <= 1 and pr > r:\n                            return False\n                return True\n            else:\n                for opp_sq,p in pm.items():\n                    if p and p.piece_type == chess.PAWN and p.color == chess.WHITE:\n                        pf = chess.square_file(opp_sq); pr = chess.square_rank(opp_sq)\n                        if abs(pf - f) <= 1 and pr < r:\n                            return False\n                return True\n        def avg_block_distance(color):\n            opp = chess.BLACK if color == chess.WHITE else chess.WHITE\n            dists = []\n            for sq,p in pm.items():\n                if not p or p.piece_type != chess.PAWN or p.color != color:\n                    continue\n                if not is_passed(sq, color):\n                    continue\n                f = chess.square_file(sq); r = chess.square_rank(sq)\n                # find nearest enemy piece that could plausibly block along the pawn's file or adjacent\n                min_dist = None\n                for esq, ep in pm.items():\n                    if not ep or ep.color != opp:\n                        continue\n                    ef = chess.square_file(esq); er = chess.square_rank(esq)\n                    # consider distance in ranks (progress towards promotion)\n                    dist = abs(er - r) + abs(ef - f)\n                    if min_dist is None or dist < min_dist:\n                        min_dist = dist\n                if min_dist is None:\n                    # no enemy pieces -> treat as very safe\n                    dists.append(20.0)\n                else:\n                    # convert manhattan to a positive reward: larger better => invert (max_possible ~14)\n                    dists.append(float(min_dist))\n            if not dists:\n                return 0.0\n            # we want larger average to be better for the pawn owner\n            return sum(dists) / float(len(dists))\n        return float(avg_block_distance(chess.WHITE) - avg_block_distance(chess.BLACK))\n    except Exception:\n        return 0.0\n",
    "def feature(board: chess.Board) -> float:\n    'Pawn structure score: combines passed, isolated, doubled, connected and advancement (positive favors White)'\n    try:\n        pm = board.piece_map()\n        pawns = {chess.WHITE: [], chess.BLACK: []}\n        for sq, p in pm.items():\n            if p and p.piece_type == chess.PAWN:\n                pawns[p.color].append(sq)\n        def file_index(sq): return chess.square_file(sq)\n        def rank_index(sq): return chess.square_rank(sq)\n        def pawn_score_for(color):\n            score = 0.0\n            opp = chess.BLACK if color == chess.WHITE else chess.WHITE\n            files_count = [0]*8\n            for sq in pawns[color]:\n                files_count[file_index(sq)] += 1\n            opp_pawn_squares = set(pawns[opp])\n            for sq in pawns[color]:\n                f = file_index(sq); r = rank_index(sq)\n                # doubled\n                doubled = 1 if files_count[f] > 1 else 0\n                # isolated (no friendly pawn on adjacent files)\n                isolated = 1\n                for af in (f-1, f+1):\n                    if 0 <= af < 8 and files_count[af] > 0:\n                        isolated = 0\n                        break\n                # connected (friendly pawn on adjacent file near rank)\n                connected = 0\n                for af in (f-1, f+1):\n                    if 0 <= af < 8:\n                        for sq2 in pawns[color]:\n                            if file_index(sq2) == af and abs(rank_index(sq2) - r) <= 1:\n                                connected = 1\n                                break\n                        if connected:\n                            break\n                # passed pawn detection\n                passed = 1\n                if color == chess.WHITE:\n                    for sq2 in opp_pawn_squares:\n                        ff = file_index(sq2); rr = rank_index(sq2)\n                        if abs(ff - f) <= 1 and rr > r:\n                            passed = 0\n                            break\n                else:\n                    for sq2 in opp_pawn_squares:\n                        ff = file_index(sq2); rr = rank_index(sq2)\n                        if abs(ff - f) <= 1 and rr < r:\n                            passed = 0\n                            break\n                # advancement (normalized 0..1)\n                adv = float(r) / 7.0 if color == chess.WHITE else float(7 - r) / 7.0\n                # combine heuristics\n                score += passed * 2.0\n                score += connected * 0.5\n                score -= isolated * 1.0\n                score -= doubled * 0.8\n                score += adv * 0.3\n            return score\n        return float(pawn_score_for(chess.WHITE) - pawn_score_for(chess.BLACK))\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Trapped/immobile major-minor pieces: difference in count of pieces with <=1 legal move (positive if Black has more trapped pieces => good for White)'\n    try:\n        pm = board.piece_map()\n        targets = set(sq for sq,p in pm.items() if p and p.piece_type not in (chess.PAWN, chess.KING))\n        orig = board.turn\n        try:\n            trapped = {chess.WHITE:0, chess.BLACK:0}\n            for color in (chess.WHITE, chess.BLACK):\n                board.turn = color\n                # count legal moves leaving from each piece\n                moves_from = {}\n                for mv in board.legal_moves:\n                    moves_from.setdefault(mv.from_square, 0)\n                    moves_from[mv.from_square] += 1\n                for sq in targets:\n                    p = board.piece_at(sq)\n                    if not p or p.color != color:\n                        continue\n                    cnt = moves_from.get(sq, 0)\n                    if cnt <= 1:\n                        trapped[color] += 1\n            # positive value when black has more trapped pieces (advantage White)\n            return float(trapped[chess.BLACK] - trapped[chess.WHITE])\n        finally:\n            board.turn = orig\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Rook file control: reward rooks on open/semi-open files and advanced positions (positive favors White)'\n    try:\n        pm = board.piece_map()\n        # count pawns by file\n        pawn_files = {chess.WHITE:[0]*8, chess.BLACK:[0]*8, 'any':[0]*8}\n        for sq, p in pm.items():\n            if p and p.piece_type == chess.PAWN:\n                f = chess.square_file(sq)\n                pawn_files[p.color][f] += 1\n                pawn_files['any'][f] += 1\n        def rook_score(color):\n            s = 0.0\n            for sq,p in pm.items():\n                if not p or p.piece_type != chess.ROOK or p.color != color:\n                    continue\n                f = chess.square_file(sq); r = chess.square_rank(sq)\n                open_file = 1 if pawn_files['any'][f] == 0 else 0\n                semi_open = 1 if pawn_files[color][f] == 0 else 0\n                # advancement: rooks deeper in enemy half are slightly better\n                adv = (float(r)/7.0) if color == chess.WHITE else (float(7-r)/7.0)\n                s += open_file*1.5 + semi_open*0.7 + adv*0.25\n            return s\n        return float(rook_score(chess.WHITE) - rook_score(chess.BLACK))\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Bishop long-diagonal reach and bishop-pair bonus (positive favors White)'\n    try:\n        pm = board.piece_map()\n        def diag_reach(sq):\n            total = 0\n            f0 = chess.square_file(sq); r0 = chess.square_rank(sq)\n            dirs = ((1,1),(1,-1),(-1,1),(-1,-1))\n            for df, dr in dirs:\n                f = f0 + df; r = r0 + dr\n                steps = 0\n                while 0 <= f < 8 and 0 <= r < 8:\n                    steps += 1\n                    s = chess.square(f, r)\n                    if board.piece_at(s) is not None:\n                        break\n                    f += df; r += dr\n                total += steps\n            return total\n        def score_for(color):\n            s = 0.0\n            bishops = 0\n            for sq,p in pm.items():\n                if p and p.color == color and p.piece_type == chess.BISHOP:\n                    bishops += 1\n                    # include capture square even if blocked (approx): add 1 if blocked by opponent\n                    s += diag_reach(sq)\n            if bishops >= 2:\n                s += 3.0  # bishop pair bonus\n            return s\n        return float(score_for(chess.WHITE) - score_for(chess.BLACK))\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'King pawn shield: number of friendly pawns in the three-file shield in front of the king (positive favors White)'\n    try:\n        pm = board.piece_map()\n        def shield_score(color):\n            # find king\n            king_sq = next((sq for sq,p in pm.items() if p and p.piece_type==chess.KING and p.color==color), None)\n            if king_sq is None:\n                return 0.0\n            f = chess.square_file(king_sq); r = chess.square_rank(king_sq)\n            count = 0\n            if color == chess.WHITE:\n                for df in (-1,0,1):\n                    ff = f + df\n                    for dr in (1,2):\n                        rr = r + dr\n                        if 0 <= ff < 8 and 0 <= rr < 8:\n                            s = chess.square(ff, rr)\n                            p = board.piece_at(s)\n                            if p and p.piece_type==chess.PAWN and p.color==color:\n                                count += 1\n            else:\n                for df in (-1,0,1):\n                    ff = f + df\n                    for dr in (1,2):\n                        rr = r - dr\n                        if 0 <= ff < 8 and 0 <= rr < 8:\n                            s = chess.square(ff, rr)\n                            p = board.piece_at(s)\n                            if p and p.piece_type==chess.PAWN and p.color==color:\n                                count += 1\n            # normalized by at most 6 shield squares\n            return float(count) / 6.0\n        return float(shield_score(chess.WHITE) - shield_score(chess.BLACK))\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Outpost minor pieces: knights/bishops on opponent half protected by a pawn and not attacked by enemy pawns (white - black)'\n    try:\n        pm = board.piece_map()\n        def is_protected_by_pawn(color, sq):\n            atks = board.attackers(color, sq)\n            for a in atks:\n                p = board.piece_at(a)\n                if p and p.piece_type == chess.PAWN and p.color == color:\n                    return True\n            return False\n        def is_attacked_by_enemy_pawn(color, sq):\n            opp = chess.BLACK if color==chess.WHITE else chess.WHITE\n            atks = board.attackers(opp, sq)\n            for a in atks:\n                p = board.piece_at(a)\n                if p and p.piece_type == chess.PAWN and p.color == opp:\n                    return True\n            return False\n        def outpost_score(color):\n            score = 0.0\n            for sq,p in pm.items():\n                if not p or p.color != color or p.piece_type not in (chess.KNIGHT, chess.BISHOP):\n                    continue\n                r = chess.square_rank(sq)\n                # opponent half\n                if color == chess.WHITE and r < 4:\n                    continue\n                if color == chess.BLACK and r > 3:\n                    continue\n                if is_protected_by_pawn(color, sq) and not is_attacked_by_enemy_pawn(color, sq):\n                    score += 1.0 if p.piece_type == chess.KNIGHT else 0.7\n            return score\n        return float(outpost_score(chess.WHITE) - outpost_score(chess.BLACK))\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Available checking moves: number of legal moves that give check (white - black)'\n    try:\n        orig = board.turn\n        try:\n            checks = {chess.WHITE:0, chess.BLACK:0}\n            for color in (chess.WHITE, chess.BLACK):\n                board.turn = color\n                for mv in list(board.legal_moves):\n                    board.push(mv)\n                    try:\n                        # after move, board.is_check() reports if side to move is in check (i.e., opponent was put in check)\n                        if board.is_check():\n                            checks[color] += 1\n                    finally:\n                        board.pop()\n            return float(checks[chess.WHITE] - checks[chess.BLACK])\n        finally:\n            board.turn = orig\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Piece centralization: weighted centrality of all non-pawn pieces (positive favors White)'\n    try:\n        weights = {chess.KNIGHT:3.0, chess.BISHOP:3.0, chess.ROOK:5.0, chess.QUEEN:9.0, chess.KING:1.0}\n        pm = board.piece_map()\n        def cent_val(sq):\n            if sq is None:\n                return 0.0\n            f = chess.square_file(sq); r = chess.square_rank(sq)\n            dx = float(f) - 3.5; dy = float(r) - 3.5\n            dist = (dx*dx + dy*dy) ** 0.5\n            return max(0.0, 1.0 - dist / 5.0)\n        sumw = 0.0; sumb = 0.0\n        for sq,p in pm.items():\n            if not p:\n                continue\n            w = weights.get(p.piece_type, 0.0)\n            c = cent_val(sq)\n            if p.color == chess.WHITE:\n                sumw += w * c\n            else:\n                sumb += w * c\n        return float(sumw - sumb)\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Forward mobility: number of legal moves that move a piece into the opponent half (white - black)'\n    try:\n        orig = board.turn\n        try:\n            forward = {chess.WHITE:0, chess.BLACK:0}\n            for color in (chess.WHITE, chess.BLACK):\n                board.turn = color\n                for mv in board.legal_moves:\n                    to_sq = mv.to_square\n                    r = chess.square_rank(to_sq)\n                    if color == chess.WHITE and r >= 4:\n                        forward[color] += 1\n                    if color == chess.BLACK and r <= 3:\n                        forward[color] += 1\n            return float(forward[chess.WHITE] - forward[chess.BLACK])\n        finally:\n            board.turn = orig\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Pawn promotion proximity: difference in total pawn distances to promotion (positive if White pawns are closer overall)'\n    try:\n        pm = board.piece_map()\n        def pawn_distance_sum(color):\n            s = 0.0\n            opp = chess.BLACK if color==chess.WHITE else chess.WHITE\n            opp_pawns = set(sq for sq,p in pm.items() if p and p.piece_type==chess.PAWN and p.color==opp)\n            for sq,p in pm.items():\n                if not p or p.piece_type != chess.PAWN or p.color != color:\n                    continue\n                r = chess.square_rank(sq)\n                dist = float(7 - r) if color == chess.WHITE else float(r)\n                # detect passed pawn (no opposing pawn on same/adjacent files ahead)\n                f = chess.square_file(sq)\n                passed = True\n                for sq2 in opp_pawns:\n                    ff = chess.square_file(sq2); rr = chess.square_rank(sq2)\n                    if abs(ff - f) <= 1:\n                        if color == chess.WHITE and rr > r:\n                            passed = False; break\n                        if color == chess.BLACK and rr < r:\n                            passed = False; break\n                # reduce effective distance for passed pawns (they are more dangerous)\n                factor = 0.6 if passed else 1.0\n                s += dist * factor\n            return s\n        # smaller sum is better; return (black_sum - white_sum) so positive favors White\n        return float(pawn_distance_sum(chess.BLACK) - pawn_distance_sum(chess.WHITE))\n    except Exception:\n        return 0.0\n",
    "def feature(board: chess.Board) -> float:\n    'Endgame king centralization: rewards the side whose king is closer to the center when few non-pawn non-king pieces remain'\n    try:\n        pm = board.piece_map()\n        # count non-pawn non-king pieces\n        nonpawn_nonking = sum(1 for p in pm.values() if p and p.piece_type not in (chess.PAWN, chess.KING))\n        # only meaningful in reduced-material situations\n        if nonpawn_nonking > 6:\n            return 0.0\n        wk = next((sq for sq,p in pm.items() if p and p.piece_type == chess.KING and p.color == chess.WHITE), None)\n        bk = next((sq for sq,p in pm.items() if p and p.piece_type == chess.KING and p.color == chess.BLACK), None)\n        if wk is None or bk is None:\n            return 0.0\n        # distance to center point (files 3.5, ranks 3.5) approximated by chess.square_distance max 14\n        d_w = chess.square_distance(wk, chess.parse_square('d4')) + chess.square_distance(wk, chess.parse_square('e5'))\n        d_b = chess.square_distance(bk, chess.parse_square('d4')) + chess.square_distance(bk, chess.parse_square('e5'))\n        # average-like; invert so closer -> larger\n        clos_w = (28.0 - float(d_w)) / 28.0\n        clos_b = (28.0 - float(d_b)) / 28.0\n        # scale more strongly in very reduced material\n        scale = 1.0 + max(0.0, (6 - nonpawn_nonking)) * 0.25\n        return float((clos_w - clos_b) * scale)\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Passed pawn pressure: counts passed pawns weighted by how advanced they are (white - black)'\n    try:\n        pm = board.piece_map()\n        score_w = 0.0\n        score_b = 0.0\n        for sq, p in pm.items():\n            if not p or p.piece_type != chess.PAWN:\n                continue\n            f = chess.square_file(sq)\n            r = chess.square_rank(sq)\n            if p.color == chess.WHITE:\n                # check for opposing pawns on same or adjacent files ahead (higher ranks)\n                blocked = False\n                for ff in range(max(0, f-1), min(7, f+1)+1):\n                    for rr in range(r+1, 8):\n                        s2 = chess.square(ff, rr)\n                        q = pm.get(s2)\n                        if q and q.piece_type == chess.PAWN and q.color == chess.BLACK:\n                            blocked = True\n                            break\n                    if blocked:\n                        break\n                if not blocked:\n                    # weight by advancement: more advanced pawns matter more\n                    weight = (r / 7.0) + 0.2\n                    score_w += weight\n            else:\n                blocked = False\n                for ff in range(max(0, f-1), min(7, f+1)+1):\n                    for rr in range(0, r):\n                        s2 = chess.square(ff, rr)\n                        q = pm.get(s2)\n                        if q and q.piece_type == chess.PAWN and q.color == chess.WHITE:\n                            blocked = True\n                            break\n                    if blocked:\n                        break\n                if not blocked:\n                    weight = ((7 - r) / 7.0) + 0.2\n                    score_b += weight\n        return float(score_w - score_b)\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Bishop pair advantage: +1 for owning two or more bishops (white - black)'\n    try:\n        bishops_w = 0\n        bishops_b = 0\n        for p in board.piece_map().values():\n            if not p or p.piece_type != chess.BISHOP:\n                continue\n            if p.color == chess.WHITE:\n                bishops_w += 1\n            else:\n                bishops_b += 1\n        return float((1.0 if bishops_w >= 2 else 0.0) - (1.0 if bishops_b >= 2 else 0.0))\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Hanging pieces value: sum of opponent pieces that are attacked and undefended, weighted by piece values (positive favors White)'\n    try:\n        vals = {chess.PAWN:1.0, chess.KNIGHT:3.0, chess.BISHOP:3.0, chess.ROOK:5.0, chess.QUEEN:9.0, chess.KING:0.0}\n        pm = board.piece_map()\n        hang_w = 0.0  # value of White pieces hanging (bad for White)\n        hang_b = 0.0\n        for sq, p in pm.items():\n            if not p:\n                continue\n            color = p.color\n            opp = chess.BLACK if color == chess.WHITE else chess.WHITE\n            try:\n                opp_attackers = list(board.attackers(opp, sq))\n                own_defenders = list(board.attackers(color, sq))\n            except Exception:\n                opp_attackers = []\n                own_defenders = []\n            if len(opp_attackers) > 0 and len(own_defenders) == 0:\n                v = vals.get(p.piece_type, 0.0)\n                if color == chess.WHITE:\n                    hang_w += v\n                else:\n                    hang_b += v\n        # positive favors White, so if Black has more hanging pieces it's good for White\n        return float(hang_b - hang_w)\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Tactical availability: difference in number of immediate tactical legal moves (captures and promotions) (white - black)'\n    try:\n        orig = board.turn\n        tact = {chess.WHITE:0.0, chess.BLACK:0.0}\n        try:\n            for color in (chess.WHITE, chess.BLACK):\n                board.turn = color\n                for mv in board.legal_moves:\n                    is_cap = False\n                    is_prom = False\n                    try:\n                        # prefer Board.is_capture if available\n                        is_cap = board.is_capture(mv)\n                    except Exception:\n                        # fallback: destination occupied by opponent or en-passant id handled by is_capture normally\n                        to_p = board.piece_at(mv.to_square)\n                        if to_p and to_p.color != color:\n                            is_cap = True\n                    if getattr(mv, 'promotion', None):\n                        is_prom = True\n                    if is_cap or is_prom:\n                        tact[color] += 1.0\n        finally:\n            board.turn = orig\n        return float(tact[chess.WHITE] - tact[chess.BLACK])\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Rooks on seventh rank: rewards rooks on opponent\\'s second-from-top rank (white rooks on rank 7 vs black on rank 2)'\n    try:\n        pm = board.piece_map()\n        score_w = 0.0\n        score_b = 0.0\n        for sq, p in pm.items():\n            if not p or p.piece_type != chess.ROOK:\n                continue\n            r = chess.square_rank(sq)\n            if p.color == chess.WHITE and r == 6:\n                score_w += 1.5\n            if p.color == chess.BLACK and r == 1:\n                score_b += 1.5\n        return float(score_w - score_b)\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'King pawn shield: difference in available friendly pawns immediately in front of king (positive favors White)'\n    try:\n        pm = board.piece_map()\n        def shield_count(color):\n            ks = next((sq for sq,p in pm.items() if p and p.piece_type == chess.KING and p.color == color), None)\n            if ks is None:\n                return 0.0\n            f0 = chess.square_file(ks)\n            r0 = chess.square_rank(ks)\n            cnt = 0\n            # consider pawns in the three files f-1,f,f+1 and up to two ranks in front of the king\n            files = [i for i in (f0-1, f0, f0+1) if 0 <= i <= 7]\n            if color == chess.WHITE:\n                ranks = [r0+1, r0+2]\n            else:\n                ranks = [r0-1, r0-2]\n            for ff in files:\n                for rr in ranks:\n                    if 0 <= rr <= 7:\n                        s = chess.square(ff, rr)\n                        p = pm.get(s)\n                        if p and p.piece_type == chess.PAWN and p.color == color:\n                            cnt += 1\n            return float(cnt)\n        return float(shield_count(chess.WHITE) - shield_count(chess.BLACK))\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Knight outposts in central squares: knights supported by a pawn and not attacked by enemy pawns in central area (white - black)'\n    try:\n        pm = board.piece_map()\n        central_files = set(range(2, 6))  # c..f\n        central_ranks = set(range(2, 6))  # 3..6 logical (0-based)\n        out_w = 0.0\n        out_b = 0.0\n        for sq, p in pm.items():\n            if not p or p.piece_type != chess.KNIGHT:\n                continue\n            f = chess.square_file(sq)\n            r = chess.square_rank(sq)\n            if f not in central_files or r not in central_ranks:\n                continue\n            color = p.color\n            opp = chess.BLACK if color == chess.WHITE else chess.WHITE\n            # check no enemy pawn attacks this square\n            opp_pawn_attackers = [a for a in board.attackers(opp, sq) if board.piece_at(a) and board.piece_at(a).piece_type == chess.PAWN]\n            # check supported by friendly pawn\n            friendly_pawn_attackers = [a for a in board.attackers(color, sq) if board.piece_at(a) and board.piece_at(a).piece_type == chess.PAWN]\n            if len(opp_pawn_attackers) == 0 and len(friendly_pawn_attackers) > 0:\n                if color == chess.WHITE:\n                    out_w += 1.0\n                else:\n                    out_b += 1.0\n        return float(out_w - out_b)\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Non-pawn piece concentration: difference in average pairwise distance (white - black) for non-pawn non-king pieces (smaller = more concentrated)'\n    try:\n        pm = board.piece_map()\n        def avg_pairwise(color):\n            squares = [sq for sq,p in pm.items() if p and p.color == color and p.piece_type not in (chess.PAWN, chess.KING)]\n            n = len(squares)\n            if n <= 1:\n                return 0.0\n            total = 0.0\n            count = 0\n            for i in range(n):\n                for j in range(i+1, n):\n                    total += chess.square_distance(squares[i], squares[j])\n                    count += 1\n            if count == 0:\n                return 0.0\n            return total / float(count)\n        aw = avg_pairwise(chess.WHITE)\n        ab = avg_pairwise(chess.BLACK)\n        # smaller average distance can indicate better coordination (we invert so positive favors White when White is more concentrated)\n        return float((ab - aw))\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Minor-piece centralization mobility: normalized number of legal knight/bishop moves that go toward a central 4x4 region (white - black)'\n    try:\n        orig = board.turn\n        central_files = set(range(2, 6))\n        central_ranks = set(range(2, 6))\n        scores = {chess.WHITE:0.0, chess.BLACK:0.0}\n        counts = {chess.WHITE:0.0, chess.BLACK:0.0}\n        try:\n            for color in (chess.WHITE, chess.BLACK):\n                board.turn = color\n                for mv in board.legal_moves:\n                    p = board.piece_at(mv.from_square)\n                    if not p or p.color != color or p.piece_type not in (chess.KNIGHT, chess.BISHOP):\n                        continue\n                    counts[color] += 1.0\n                    to_f = chess.square_file(mv.to_square)\n                    to_r = chess.square_rank(mv.to_square)\n                    if to_f in central_files and to_r in central_ranks:\n                        scores[color] += 1.0\n        finally:\n            board.turn = orig\n        # normalize by number of minor piece moves available (avoid divide by zero)\n        val_w = (scores[chess.WHITE] / counts[chess.WHITE]) if counts[chess.WHITE] > 0 else 0.0\n        val_b = (scores[chess.BLACK] / counts[chess.BLACK]) if counts[chess.BLACK] > 0 else 0.0\n        return float(val_w - val_b)\n    except Exception:\n        return 0.0\n",
    "def feature(board: chess.Board) -> float:\n    'Passed pawn advancement difference: sum of progress of passed pawns (white - black), weighted by rank'\n    try:\n        pm = board.piece_map()\n        def is_passed(sq, color):\n            f = chess.square_file(sq)\n            r = chess.square_rank(sq)\n            # files to check for opposing pawns\n            files = [ff for ff in (f-1, f, f+1) if 0 <= ff <= 7]\n            for ff in files:\n                # iterate ranks ahead depending on pawn color\n                if color == chess.WHITE:\n                    for rr in range(r+1, 8):\n                        p = pm.get(chess.square(ff, rr))\n                        if p and p.piece_type == chess.PAWN and p.color == chess.BLACK:\n                            return False\n                else:\n                    for rr in range(0, r):\n                        p = pm.get(chess.square(ff, rr))\n                        if p and p.piece_type == chess.PAWN and p.color == chess.WHITE:\n                            return False\n            return True\n        score_w = 0.0\n        score_b = 0.0\n        for sq, p in pm.items():\n            if not p or p.piece_type != chess.PAWN:\n                continue\n            r = chess.square_rank(sq)\n            if p.color == chess.WHITE:\n                if is_passed(sq, chess.WHITE):\n                    progress = float(r) / 7.0\n                    score_w += 1.0 + 3.0 * progress  # base + advancement bonus\n            else:\n                if is_passed(sq, chess.BLACK):\n                    progress = float(7 - r) / 7.0\n                    score_b += 1.0 + 3.0 * progress\n        return float(score_w - score_b)\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Rook file strength: count of rooks on open files (1.0) and semi-open files (0.5) difference (white - black)'\n    try:\n        pm = board.piece_map()\n        # compute pawns presence per file\n        white_pawns = [False]*8\n        black_pawns = [False]*8\n        for sq,p in pm.items():\n            if p and p.piece_type == chess.PAWN:\n                if p.color == chess.WHITE:\n                    white_pawns[chess.square_file(sq)] = True\n                else:\n                    black_pawns[chess.square_file(sq)] = True\n        score_w = 0.0\n        score_b = 0.0\n        for sq, p in pm.items():\n            if not p or p.piece_type != chess.ROOK:\n                continue\n            f = chess.square_file(sq)\n            has_white = white_pawns[f]\n            has_black = black_pawns[f]\n            if not has_white and not has_black:\n                bonus = 1.0\n            elif (p.color == chess.WHITE and not has_white) or (p.color == chess.BLACK and not has_black):\n                bonus = 0.5\n            else:\n                bonus = 0.0\n            if p.color == chess.WHITE:\n                score_w += bonus\n            else:\n                score_b += bonus\n        return float(score_w - score_b)\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Bishop pair and mobility: small pair bonus + normalized bishop legal-move mobility difference (white - black)'\n    try:\n        pm = board.piece_map()\n        bcount = {chess.WHITE:0, chess.BLACK:0}\n        for p in pm.values():\n            if p and p.piece_type == chess.BISHOP:\n                bcount[p.color] += 1\n        orig = board.turn\n        try:\n            mob = {chess.WHITE:0, chess.BLACK:0}\n            for color in (chess.WHITE, chess.BLACK):\n                board.turn = color\n                for mv in board.legal_moves:\n                    p = board.piece_at(mv.from_square)\n                    if p and p.piece_type == chess.BISHOP and p.color == color:\n                        mob[color] += 1\n        finally:\n            board.turn = orig\n        score_w = (0.75 if bcount[chess.WHITE] >= 2 else 0.0) + 0.05 * float(mob[chess.WHITE])\n        score_b = (0.75 if bcount[chess.BLACK] >= 2 else 0.0) + 0.05 * float(mob[chess.BLACK])\n        return float(score_w - score_b)\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'King pawn-shield quality: counts friendly pawns in front/adjacent files of king with distance weighting (white - black)'\n    try:\n        pm = board.piece_map()\n        def shield_score(king_sq, color):\n            if king_sq is None:\n                return 0.0\n            kf = chess.square_file(king_sq); kr = chess.square_rank(king_sq)\n            score = 0.0\n            # consider two ranks ahead and three files (file-1..file+1)\n            for df in (-1,0,1):\n                ff = kf + df\n                if ff < 0 or ff > 7:\n                    continue\n                if color == chess.WHITE:\n                    ranks = [kr+1, kr+2]\n                else:\n                    ranks = [kr-1, kr-2]\n                for i, rr in enumerate(ranks):\n                    if 0 <= rr <= 7:\n                        p = pm.get(chess.square(ff, rr))\n                        if p and p.piece_type == chess.PAWN and p.color == color:\n                            # closer pawns give more protection\n                            score += 1.0 if i == 0 else 0.5\n            # penalize if king already in open file (no pawn on same file near)\n            same_file_pawn = False\n            for rr in range(max(0,kr-1), min(7,kr+1)+1):\n                p = pm.get(chess.square(kf, rr))\n                if p and p.piece_type == chess.PAWN and p.color == color:\n                    same_file_pawn = True\n                    break\n            if not same_file_pawn:\n                score -= 0.5\n            return score\n        wk = next((sq for sq,p in pm.items() if p and p.piece_type==chess.KING and p.color==chess.WHITE), None)\n        bk = next((sq for sq,p in pm.items() if p and p.piece_type==chess.KING and p.color==chess.BLACK), None)\n        return float(shield_score(wk, chess.WHITE) - shield_score(bk, chess.BLACK))\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Knight outposts: count of knights on opponent half supported by a pawn and not attackable by enemy pawns (white - black)'\n    try:\n        pm = board.piece_map()\n        def pawn_attacks_enemy_on(square, enemy_color):\n            # return True if enemy has a pawn that attacks this square\n            attackers = board.attackers(enemy_color, square)\n            for a in attackers:\n                p = pm.get(a)\n                if p and p.piece_type == chess.PAWN and p.color == enemy_color:\n                    return True\n            return False\n        score_w = 0.0\n        score_b = 0.0\n        for sq, p in pm.items():\n            if not p or p.piece_type != chess.KNIGHT:\n                continue\n            r = chess.square_rank(sq)\n            own = p.color\n            enemy = chess.BLACK if own == chess.WHITE else chess.WHITE\n            # in opponent half?\n            if (own == chess.WHITE and r >= 4) or (own == chess.BLACK and r <= 3):\n                # supported by a pawn?\n                supported_by_pawn = False\n                for a in board.attackers(own, sq):\n                    ap = pm.get(a)\n                    if ap and ap.piece_type == chess.PAWN and ap.color == own:\n                        supported_by_pawn = True\n                        break\n                if supported_by_pawn and not pawn_attacks_enemy_on(sq, enemy):\n                    if own == chess.WHITE:\n                        score_w += 1.0\n                    else:\n                        score_b += 1.0\n        return float(score_w - score_b)\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Pawn island imbalance: (black_islands - white_islands), more islands for opponent is good for the side'\n    try:\n        pm = board.piece_map()\n        def pawn_islands(color):\n            has = [False]*8\n            for sq,p in pm.items():\n                if p and p.piece_type == chess.PAWN and p.color == color:\n                    has[chess.square_file(sq)] = True\n            islands = 0\n            prev = False\n            for f in range(8):\n                if has[f] and not prev:\n                    islands += 1\n                    prev = True\n                elif not has[f]:\n                    prev = False\n            return islands\n        iw = pawn_islands(chess.WHITE)\n        ib = pawn_islands(chess.BLACK)\n        # positive means black has more islands => good for white\n        return float(ib - iw)\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Queen vulnerability and mobility: (white_score - black_score) where score = 0.2*moves - 1.0*min(attackers,2)'\n    try:\n        pm = board.piece_map()\n        q_squares = {chess.WHITE:[], chess.BLACK:[]}\n        for sq,p in pm.items():\n            if p and p.piece_type == chess.QUEEN:\n                q_squares[p.color].append(sq)\n        orig = board.turn\n        try:\n            q_moves = {chess.WHITE:0, chess.BLACK:0}\n            for color in (chess.WHITE, chess.BLACK):\n                board.turn = color\n                for mv in board.legal_moves:\n                    p = board.piece_at(mv.from_square)\n                    if p and p.piece_type == chess.QUEEN and p.color == color:\n                        q_moves[color] += 1\n        finally:\n            board.turn = orig\n        def q_score(color):\n            sqs = q_squares[color]\n            sc = 0.0\n            for sq in sqs:\n                attackers = len(board.attackers(chess.BLACK if color==chess.WHITE else chess.WHITE, sq))\n                sc += 0.2 * float(q_moves[color]) / max(1.0, float(len(sqs)))  # normalize by number of queens\n                sc -= float(min(2, attackers))\n            return sc\n        return float(q_score(chess.WHITE) - q_score(chess.BLACK))\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Squares controlled in opponent half: count of distinct squares controlled in enemy half (white - black)'\n    try:\n        controlled_w = 0.0\n        controlled_b = 0.0\n        # white controls ranks 4..7; black controls 0..3\n        for r in range(4,8):\n            for f in range(8):\n                sq = chess.square(f, r)\n                if len(board.attackers(chess.WHITE, sq)) > 0:\n                    controlled_w += 1.0\n        for r in range(0,4):\n            for f in range(8):\n                sq = chess.square(f, r)\n                if len(board.attackers(chess.BLACK, sq)) > 0:\n                    controlled_b += 1.0\n        return float(controlled_w - controlled_b)\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Check-giving move potential: number of legal moves that give check (white - black)'\n    try:\n        orig = board.turn\n        checks = {chess.WHITE:0.0, chess.BLACK:0.0}\n        try:\n            for color in (chess.WHITE, chess.BLACK):\n                board.turn = color\n                # need to iterate concrete list because we push/pop\n                for mv in list(board.legal_moves):\n                    try:\n                        board.push(mv)\n                        if board.is_check():\n                            checks[color] += 1.0\n                    except Exception:\n                        # ignore weird moves\n                        pass\n                    finally:\n                        try:\n                            board.pop()\n                        except Exception:\n                            # in case push failed, ensure board continues\n                            pass\n        finally:\n            board.turn = orig\n        return float(checks[chess.WHITE] - checks[chess.BLACK])\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Central pawn strength: weighted count of pawns on d/e files with advancement bonus and passed-central bonus (white - black)'\n    try:\n        pm = board.piece_map()\n        score_w = 0.0\n        score_b = 0.0\n        central_files = [3,4]  # d and e\n        for sq,p in pm.items():\n            if not p or p.piece_type != chess.PAWN:\n                continue\n            f = chess.square_file(sq)\n            r = chess.square_rank(sq)\n            if f in central_files:\n                if p.color == chess.WHITE:\n                    adv = float(r) / 7.0\n                    score_w += 1.0 + 2.0 * adv\n                else:\n                    adv = float(7 - r) / 7.0\n                    score_b += 1.0 + 2.0 * adv\n                # bonus if passed and central\n                # simple check: no enemy pawn ahead on same or adjacent file\n                files = [ff for ff in (f-1,f,f+1) if 0 <= ff <= 7]\n                passed = True\n                for ff in files:\n                    if p.color == chess.WHITE:\n                        for rr in range(r+1,8):\n                            q = pm.get(chess.square(ff, rr))\n                            if q and q.piece_type == chess.PAWN and q.color == chess.BLACK:\n                                passed = False\n                                break\n                        if not passed:\n                            break\n                    else:\n                        for rr in range(0, r):\n                            q = pm.get(chess.square(ff, rr))\n                            if q and q.piece_type == chess.PAWN and q.color == chess.WHITE:\n                                passed = False\n                                break\n                        if not passed:\n                            break\n                if passed:\n                    if p.color == chess.WHITE:\n                        score_w += 1.5\n                    else:\n                        score_b += 1.5\n        return float(score_w - score_b)\n    except Exception:\n        return 0.0\n",
    "def feature(board: chess.Board) -> float:\n    'Passed pawns strength difference: advanced passed pawns weighted by advancement and king-distance (white - black)'\n    try:\n        pm = board.piece_map()\n        # find kings\n        wk = next((sq for sq, p in pm.items() if p and p.piece_type == chess.KING and p.color == chess.WHITE), None)\n        bk = next((sq for sq, p in pm.items() if p and p.piece_type == chess.KING and p.color == chess.BLACK), None)\n        def is_passed(sq, color):\n            f = chess.square_file(sq); r = chess.square_rank(sq)\n            if color == chess.WHITE:\n                enemy = chess.BLACK\n                ahead_ranks = range(r+1, 8)\n            else:\n                enemy = chess.WHITE\n                ahead_ranks = range(0, r)\n            for ff in (f-1, f, f+1):\n                for rr in ahead_ranks:\n                    if 0 <= ff <= 7 and 0 <= rr <= 7:\n                        p = board.piece_at(chess.square(ff, rr))\n                        if p and p.piece_type == chess.PAWN and p.color == enemy:\n                            return False\n            return True\n        def pawn_score_for(color):\n            total = 0.0\n            for sq, p in pm.items():\n                if p and p.piece_type == chess.PAWN and p.color == color:\n                    if is_passed(sq, color):\n                        r = chess.square_rank(sq)\n                        # advancement normalized 0..1\n                        adv = (r / 7.0) if color == chess.WHITE else ((7 - r) / 7.0)\n                        # king proximity factor: farther enemy king increases value\n                        opp_king = bk if color == chess.WHITE else wk\n                        if opp_king is None:\n                            kfac = 1.0\n                        else:\n                            d = chess.square_distance(sq, opp_king)\n                            kfac = 1.0 + (d / 14.0) * 0.5  # between 1.0 and 1.5\n                        total += adv * kfac * 1.8\n            return total\n        return float(pawn_score_for(chess.WHITE) - pawn_score_for(chess.BLACK))\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Rook file control: rooks on open files (no pawns) and semi-open files (only enemy pawns) weighted (white - black)'\n    try:\n        pm = board.piece_map()\n        # precompute pawns on files\n        pawns_on_file = [0]*8  # count of any pawns\n        pawns_color_on_file = [{chess.WHITE:0, chess.BLACK:0} for _ in range(8)]\n        for sq, p in pm.items():\n            if p and p.piece_type == chess.PAWN:\n                f = chess.square_file(sq)\n                pawns_on_file[f] += 1\n                pawns_color_on_file[f][p.color] += 1\n        score = {chess.WHITE:0.0, chess.BLACK:0.0}\n        for sq, p in pm.items():\n            if p and p.piece_type == chess.ROOK:\n                f = chess.square_file(sq)\n                if pawns_on_file[f] == 0:\n                    score[p.color] += 1.2  # open file\n                elif pawns_color_on_file[f][p.color] == 0:\n                    score[p.color] += 0.7  # semi-open file\n        return float(score[chess.WHITE] - score[chess.BLACK])\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Bishop pair and activity: small bonus for having two bishops plus average bishop mobility (white - black)'\n    try:\n        pm = board.piece_map()\n        # count bishops\n        bishops = {chess.WHITE:[], chess.BLACK:[]}\n        for sq, p in pm.items():\n            if p and p.piece_type == chess.BISHOP:\n                bishops[p.color].append(sq)\n        # compute mobility per bishop by toggling turns\n        orig = board.turn\n        try:\n            mob = {chess.WHITE:0.0, chess.BLACK:0.0}\n            counts = {chess.WHITE:0, chess.BLACK:0}\n            for color in (chess.WHITE, chess.BLACK):\n                board.turn = color\n                from_sqs = {}\n                for mv in board.legal_moves:\n                    from_sqs.setdefault(mv.from_square, 0)\n                    from_sqs[mv.from_square] += 1\n                for sq in bishops[color]:\n                    counts[color] += 1\n                    mv_count = from_sqs.get(sq, 0)\n                    # normalize by a typical bishop max ~13\n                    mob[color] += min(mv_count / 13.0, 1.0)\n        finally:\n            board.turn = orig\n        score_w = (0.9 if len(bishops[chess.WHITE]) >= 2 else 0.0) + (mob[chess.WHITE] / max(1, len(bishops[chess.WHITE]))) if len(bishops[chess.WHITE])>0 else 0.0\n        score_b = (0.9 if len(bishops[chess.BLACK]) >= 2 else 0.0) + (mob[chess.BLACK] / max(1, len(bishops[chess.BLACK]))) if len(bishops[chess.BLACK])>0 else 0.0\n        return float(score_w - score_b)\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Knight outpost score: knights on advanced outpost squares not attackable by enemy pawns, weighted by being defended (white - black)'\n    try:\n        pm = board.piece_map()\n        def outpost_value(sq, color):\n            p = pm.get(sq)\n            if not p or p.piece_type != chess.KNIGHT or p.color != color:\n                return 0.0\n            r = chess.square_rank(sq)\n            # outpost ranks: white prefers ranks 4..6 (idx >=4), black prefers 1..3 (idx <=3)\n            if color == chess.WHITE and r < 4:\n                return 0.0\n            if color == chess.BLACK and r > 3:\n                return 0.0\n            # check if any enemy pawn attacks this square\n            enemy = not color\n            pawn_attackers = [a for a in board.attackers(enemy, sq) if board.piece_at(a) and board.piece_at(a).piece_type == chess.PAWN]\n            if pawn_attackers:\n                return 0.0\n            # base outpost\n            val = 1.0\n            # defended?\n            defenders = len(board.attackers(color, sq))\n            if defenders >= 1:\n                val += 0.6\n                # extra if defended by pawn specifically\n                if any(board.piece_at(a) and board.piece_at(a).piece_type == chess.PAWN for a in board.attackers(color, sq)):\n                    val += 0.4\n            return val\n        w = 0.0; b = 0.0\n        for sq, p in pm.items():\n            if p and p.piece_type == chess.KNIGHT:\n                if p.color == chess.WHITE:\n                    w += outpost_value(sq, chess.WHITE)\n                else:\n                    b += outpost_value(sq, chess.BLACK)\n        return float(w - b)\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'King-file pressure: counts open/semi-open adjacent files and enemy heavy-piece threats on them (black_vulner - white_vulner)'\n    try:\n        pm = board.piece_map()\n        def king_vuln(color):\n            king_sq = next((sq for sq, p in pm.items() if p and p.piece_type == chess.KING and p.color == color), None)\n            if king_sq is None:\n                return 0.0\n            f = chess.square_file(king_sq)\n            enemy = not color\n            vuln = 0.0\n            for ff in (f-1, f, f+1):\n                if not (0 <= ff <= 7):\n                    continue\n                # determine if file is open or semi-open with respect to king side\n                has_own_pawn = any((pm.get(chess.square(ff, rr)) and pm.get(chess.square(ff, rr)).piece_type == chess.PAWN and pm.get(chess.square(ff, rr)).color == color) for rr in range(8))\n                has_enemy_pawn = any((pm.get(chess.square(ff, rr)) and pm.get(chess.square(ff, rr)).piece_type == chess.PAWN and pm.get(chess.square(ff, rr)).color == enemy) for rr in range(8))\n                file_factor = 0.0\n                if not has_own_pawn and not has_enemy_pawn:\n                    file_factor = 1.0  # open\n                elif not has_own_pawn and has_enemy_pawn:\n                    file_factor = 0.6  # semi-open (enemy pawns only)\n                else:\n                    file_factor = 0.0\n                if file_factor == 0.0:\n                    continue\n                # check if any enemy rook/queen attacks any square on that file\n                threat = 0\n                for rr in range(8):\n                    sq = chess.square(ff, rr)\n                    for attacker_sq in board.attackers(enemy, sq):\n                        ap = board.piece_at(attacker_sq)\n                        if ap and (ap.piece_type == chess.ROOK or ap.piece_type == chess.QUEEN):\n                            threat = 1\n                            break\n                    if threat:\n                        break\n                vuln += file_factor * (0.9 if threat else 0.3)\n            return vuln\n        w_v = king_vuln(chess.WHITE)\n        b_v = king_vuln(chess.BLACK)\n        # positive value means Black more vulnerable (good for White)\n        return float(b_v - w_v)\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Trapped pieces: count of non-pawn pieces with zero legal moves for each side (black_trapped - white_trapped)'\n    try:\n        pm = board.piece_map()\n        orig = board.turn\n        trapped = {chess.WHITE:0, chess.BLACK:0}\n        try:\n            for color in (chess.WHITE, chess.BLACK):\n                board.turn = color\n                from_sqs = set(mv.from_square for mv in board.legal_moves)\n                for sq, p in pm.items():\n                    if p and p.color == color and p.piece_type != chess.PAWN:\n                        # if this piece cannot move at all\n                        if sq not in from_sqs:\n                            trapped[color] += 1\n        finally:\n            board.turn = orig\n        # positive favors White: black pieces trapped is good for White\n        return float(trapped[chess.BLACK] - trapped[chess.WHITE])\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Pawn structure weaknesses: weighted sum of doubled and isolated pawns (black_weak - white_weak)'\n    try:\n        pm = board.piece_map()\n        files = {i: {chess.WHITE:0, chess.BLACK:0} for i in range(8)}\n        for sq, p in pm.items():\n            if p and p.piece_type == chess.PAWN:\n                files[chess.square_file(sq)][p.color] += 1\n        def weaknesses(color):\n            doubled = 0\n            isolated = 0\n            for f in range(8):\n                if files[f][color] > 1:\n                    doubled += files[f][color] - 1\n                # isolated: no friendly pawn on adjacent files\n                if files[f][color] > 0:\n                    has_adj = False\n                    for af in (f-1, f+1):\n                        if 0 <= af <= 7 and files[af][color] > 0:\n                            has_adj = True\n                            break\n                    if not has_adj:\n                        isolated += files[f][color]\n            return doubled * 1.0 + isolated * 1.4\n        w = weaknesses(chess.WHITE)\n        b = weaknesses(chess.BLACK)\n        return float(b - w)\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Initiative potential: legal tactical moves (captures/promotions/checks) for each side (white - black)'\n    try:\n        orig = board.turn\n        try:\n            score = {chess.WHITE:0.0, chess.BLACK:0.0}\n            for color in (chess.WHITE, chess.BLACK):\n                board.turn = color\n                for mv in board.legal_moves:\n                    val = 0.0\n                    # capture\n                    try:\n                        if board.is_capture(mv):\n                            val += 1.0\n                    except Exception:\n                        # fallback: promotion or capturing target square occupied by opponent\n                        if mv.promotion is not None:\n                            val += 1.0\n                    # promotion\n                    if getattr(mv, 'promotion', None) is not None:\n                        val += 3.0\n                    # gives check if supported by library\n                    try:\n                        if board.gives_check(mv):\n                            val += 0.7\n                    except Exception:\n                        # best-effort: skip if method not available\n                        pass\n                    score[color] += val\n        finally:\n            board.turn = orig\n        return float(score[chess.WHITE] - score[chess.BLACK])\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Piece centralization weighted by material value: higher value pieces closer to center add more (white - black)'\n    try:\n        vals = {chess.PAWN:1.0, chess.KNIGHT:3.0, chess.BISHOP:3.0, chess.ROOK:5.0, chess.QUEEN:9.0, chess.KING:0.0}\n        pm = board.piece_map()\n        def centrality(sq):\n            f = chess.square_file(sq); r = chess.square_rank(sq)\n            # Manhattan distance to center (3.5,3.5)\n            dist = abs(f - 3.5) + abs(r - 3.5)\n            cent = max(0.0, (7.0 - dist) / 7.0)  # 0..1\n            return cent\n        tot = {chess.WHITE:0.0, chess.BLACK:0.0}\n        for sq, p in pm.items():\n            if p:\n                tot[p.color] += vals.get(p.piece_type, 0.0) * centrality(sq)\n        return float(tot[chess.WHITE] - tot[chess.BLACK])\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Bishop vs Knight suitability: favors bishops when the board is open and knights when closed (combined score positive favors White)'\n    try:\n        pm = board.piece_map()\n        pawns_on_file = [0]*8\n        counts = {chess.WHITE:{chess.BISHOP:0, chess.KNIGHT:0}, chess.BLACK:{chess.BISHOP:0, chess.KNIGHT:0}}\n        for sq, p in pm.items():\n            if p and p.piece_type == chess.PAWN:\n                pawns_on_file[chess.square_file(sq)] += 1\n            if p and p.piece_type in (chess.BISHOP, chess.KNIGHT):\n                counts[p.color][p.piece_type] += 1\n        openness = sum(1 for f in range(8) if pawns_on_file[f] == 0) / 8.0  # 0..1\n        bishop_factor = 1.8\n        knight_factor = 1.0\n        score = (counts[chess.WHITE][chess.BISHOP] - counts[chess.BLACK][chess.BISHOP]) * (openness * bishop_factor)\n        score += (counts[chess.WHITE][chess.KNIGHT] - counts[chess.BLACK][chess.KNIGHT]) * ((1.0 - openness) * knight_factor)\n        return float(score)\n    except Exception:\n        return 0.0\n",
    "def feature(board: chess.Board) -> float:\n    'Passed pawn advancement: weighted sum of passed pawns (white - black), weight by advancement toward promotion'\n    try:\n        pm = board.piece_map()\n        def is_passed(sq, color):\n            f = chess.square_file(sq); r = chess.square_rank(sq)\n            if color == chess.WHITE:\n                for af in (f-1, f, f+1):\n                    if 0 <= af <= 7:\n                        for ar in range(r, 8):\n                            sq2 = chess.square(af, ar)\n                            p = pm.get(sq2)\n                            if p and p.piece_type == chess.PAWN and p.color == chess.BLACK:\n                                return False\n                return True\n            else:\n                for af in (f-1, f, f+1):\n                    if 0 <= af <= 7:\n                        for ar in range(0, r+1):\n                            sq2 = chess.square(af, ar)\n                            p = pm.get(sq2)\n                            if p and p.piece_type == chess.PAWN and p.color == chess.WHITE:\n                                return False\n                return True\n        w = 0.0; b = 0.0\n        for sq, p in pm.items():\n            if p and p.piece_type == chess.PAWN:\n                r = chess.square_rank(sq)\n                adv = float(r) / 7.0 if p.color == chess.WHITE else float(7 - r) / 7.0\n                if is_passed(sq, p.color):\n                    if p.color == chess.WHITE:\n                        w += adv\n                    else:\n                        b += adv\n        return float(w - b)\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Rook file control: rooks on open files (no pawns) or semi-open files (no friendly pawns) (white - black)'\n    try:\n        pm = board.piece_map()\n        def file_pawn_counts(file_idx):\n            wp = 0; bp = 0\n            for r in range(8):\n                p = pm.get(chess.square(file_idx, r))\n                if p and p.piece_type == chess.PAWN:\n                    if p.color == chess.WHITE:\n                        wp += 1\n                    else:\n                        bp += 1\n            return wp, bp\n        score_w = 0.0; score_b = 0.0\n        for sq, p in pm.items():\n            if not p or p.piece_type != chess.ROOK:\n                continue\n            f = chess.square_file(sq)\n            wp, bp = file_pawn_counts(f)\n            if wp == 0 and bp == 0:\n                weight = 1.0\n            elif (p.color == chess.WHITE and wp == 0) or (p.color == chess.BLACK and bp == 0):\n                weight = 0.5\n            else:\n                weight = 0.0\n            if p.color == chess.WHITE:\n                score_w += weight\n            else:\n                score_b += weight\n        return float(score_w - score_b)\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'King-zone pressure: weighted sum of enemy attackers on the opponent king zone (white - black)'\n    try:\n        vals = {chess.PAWN:1.0, chess.KNIGHT:3.0, chess.BISHOP:3.0, chess.ROOK:5.0, chess.QUEEN:9.0, chess.KING:0.0}\n        pm = board.piece_map()\n        wk = next((sq for sq,p in pm.items() if p and p.piece_type == chess.KING and p.color == chess.WHITE), None)\n        bk = next((sq for sq,p in pm.items() if p and p.piece_type == chess.KING and p.color == chess.BLACK), None)\n        if wk is None or bk is None:\n            return 0.0\n        def pressure_on(king_sq, attacker_color):\n            total = 0.0\n            for f in range(8):\n                for r in range(8):\n                    sq = chess.square(f, r)\n                    if chess.square_distance(sq, king_sq) <= 2:\n                        attackers = board.attackers(attacker_color, sq)\n                        for a in attackers:\n                            pa = pm.get(a)\n                            if pa:\n                                total += vals.get(pa.piece_type, 0.0)\n            return total\n        w_on_b = pressure_on(bk, chess.WHITE)\n        b_on_w = pressure_on(wk, chess.BLACK)\n        return float(w_on_b - b_on_w)\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Pawn structure weaknesses: (black_structural_penalty - white_structural_penalty) positive favors White'\n    try:\n        pm = board.piece_map()\n        def penalties(color):\n            # doubled pawns\n            file_counts = [0]*8\n            for sq,p in pm.items():\n                if p and p.piece_type == chess.PAWN and p.color == color:\n                    file_counts[chess.square_file(sq)] += 1\n            doubled = sum(max(0, c-1) for c in file_counts)\n            # isolated pawns: pawn on a file with no friendly pawn on adjacent files\n            isolated = 0\n            for f in range(8):\n                if file_counts[f] == 0:\n                    continue\n                if file_counts[f] >= 1:\n                    for r in range(8):\n                        sq = chess.square(f, r)\n                        p = pm.get(sq)\n                        if not (p and p.piece_type == chess.PAWN and p.color == color):\n                            continue\n                        left = file_counts[f-1] if f-1 >= 0 else 0\n                        right = file_counts[f+1] if f+1 <= 7 else 0\n                        if left == 0 and right == 0:\n                            isolated += 1\n            # simple penalty weighting\n            return 1.0 * doubled + 1.25 * isolated\n        p_w = penalties(chess.WHITE)\n        p_b = penalties(chess.BLACK)\n        return float(p_b - p_w)\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Tactical pressure on high-value pieces: sum of values of opponent pieces where attackers > defenders (white - black)'\n    try:\n        vals = {chess.PAWN:1.0, chess.KNIGHT:3.0, chess.BISHOP:3.0, chess.ROOK:5.0, chess.QUEEN:9.0, chess.KING:0.0}\n        pm = board.piece_map()\n        def threat_score(color):\n            opp = chess.BLACK if color == chess.WHITE else chess.WHITE\n            s = 0.0\n            for sq,p in pm.items():\n                if not p or p.color != opp:\n                    continue\n                attackers = board.attackers(color, sq)\n                defenders = board.attackers(opp, sq)\n                if len(attackers) > len(defenders):\n                    s += vals.get(p.piece_type, 0.0)\n            return s\n        return float(threat_score(chess.WHITE) - threat_score(chess.BLACK))\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Passed pawn defensibility: rewards passed pawns far from enemy king and advanced (white - black)'\n    try:\n        pm = board.piece_map()\n        wk = next((sq for sq,p in pm.items() if p and p.piece_type == chess.KING and p.color == chess.WHITE), None)\n        bk = next((sq for sq,p in pm.items() if p and p.piece_type == chess.KING and p.color == chess.BLACK), None)\n        if wk is None or bk is None:\n            return 0.0\n        def is_passed_and_score(sq, color):\n            f = chess.square_file(sq); r = chess.square_rank(sq)\n            # passed test\n            if color == chess.WHITE:\n                for af in (f-1,f,f+1):\n                    if 0 <= af <= 7:\n                        for ar in range(r, 8):\n                            pp = pm.get(chess.square(af, ar))\n                            if pp and pp.piece_type == chess.PAWN and pp.color == chess.BLACK:\n                                return 0.0\n                # score: advancement * (distance to black king / 14)\n                adv = float(r) / 7.0\n                dist = chess.square_distance(sq, bk) / 14.0\n                return adv * dist\n            else:\n                for af in (f-1,f,f+1):\n                    if 0 <= af <= 7:\n                        for ar in range(0, r+1):\n                            pp = pm.get(chess.square(af, ar))\n                            if pp and pp.piece_type == chess.PAWN and pp.color == chess.WHITE:\n                                return 0.0\n                adv = float(7 - r) / 7.0\n                dist = chess.square_distance(sq, wk) / 14.0\n                return adv * dist\n        w = 0.0; b = 0.0\n        for sq,p in pm.items():\n            if p and p.piece_type == chess.PAWN:\n                if p.color == chess.WHITE:\n                    w += is_passed_and_score(sq, chess.WHITE)\n                else:\n                    b += is_passed_and_score(sq, chess.BLACK)\n        return float(w - b)\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Bishop-pair openness multiplier: bonus for having bishop pair scaled by board openness (white - black)'\n    try:\n        pm = board.piece_map()\n        def bishop_pair_score(color):\n            bishops = sum(1 for p in pm.values() if p and p.piece_type == chess.BISHOP and p.color == color)\n            if bishops < 2:\n                return 0.0\n            # openness = fraction of files with no pawns\n            pawn_files = set()\n            for sq,p in pm.items():\n                if p and p.piece_type == chess.PAWN:\n                    pawn_files.add(chess.square_file(sq))\n            openness = (8 - len(pawn_files)) / 8.0\n            return 1.5 * openness\n        return float(bishop_pair_score(chess.WHITE) - bishop_pair_score(chess.BLACK))\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Outpost knights: knights supported by friendly pawn and not attackable by enemy pawns in opponent half (white - black)'\n    try:\n        pm = board.piece_map()\n        def outpost_count(color):\n            cnt = 0.0\n            opp = chess.BLACK if color == chess.WHITE else chess.WHITE\n            for sq,p in pm.items():\n                if not p or p.piece_type != chess.KNIGHT or p.color != color:\n                    continue\n                f = chess.square_file(sq); r = chess.square_rank(sq)\n                # require to be in opponent half (more ambitious)\n                if color == chess.WHITE and r < 3:\n                    continue\n                if color == chess.BLACK and r > 4:\n                    continue\n                # attacked by friendly pawn?\n                pawn_support = any((pm.get(a) and pm.get(a).piece_type == chess.PAWN and pm.get(a).color == color) for a in board.attackers(color, sq))\n                # attacked by enemy pawn?\n                pawn_threat = any((pm.get(a) and pm.get(a).piece_type == chess.PAWN and pm.get(a).color == opp) for a in board.attackers(opp, sq))\n                if pawn_support and not pawn_threat:\n                    cnt += 1.0\n            return cnt\n        return float(outpost_count(chess.WHITE) - outpost_count(chess.BLACK))\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Safe material: sum of piece values that have as many or more defenders than attackers (white - black)'\n    try:\n        vals = {chess.PAWN:1.0, chess.KNIGHT:3.0, chess.BISHOP:3.0, chess.ROOK:5.0, chess.QUEEN:9.0, chess.KING:0.0}\n        pm = board.piece_map()\n        safe_w = 0.0; safe_b = 0.0\n        for sq,p in pm.items():\n            if not p:\n                continue\n            color = p.color\n            opp = chess.BLACK if color == chess.WHITE else chess.WHITE\n            attackers = board.attackers(opp, sq)\n            defenders = board.attackers(color, sq)\n            if len(defenders) >= len(attackers):\n                if color == chess.WHITE:\n                    safe_w += vals.get(p.piece_type, 0.0)\n                else:\n                    safe_b += vals.get(p.piece_type, 0.0)\n        return float(safe_w - safe_b)\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Pawn central control: number of central squares attacked by pawns, weighted by proximity (white - black)'\n    try:\n        pm = board.piece_map()\n        central_files = set(range(2,6))\n        central_ranks = set(range(2,6))\n        cw = 0.0; cb = 0.0\n        for sq,p in pm.items():\n            if not p or p.piece_type != chess.PAWN:\n                continue\n            f = chess.square_file(sq); r = chess.square_rank(sq)\n            if p.color == chess.WHITE:\n                targets = []\n                for df in (-1,1):\n                    tf = f + df; tr = r + 1\n                    if 0 <= tf <= 7 and 0 <= tr <= 7:\n                        targets.append(chess.square(tf, tr))\n                for t in targets:\n                    tf = chess.square_file(t); tr = chess.square_rank(t)\n                    if tf in central_files and tr in central_ranks:\n                        # give extra weight for deeper central influence\n                        cw += 1.0 + (tr - 2) * 0.1\n            else:\n                targets = []\n                for df in (-1,1):\n                    tf = f + df; tr = r - 1\n                    if 0 <= tf <= 7 and 0 <= tr <= 7:\n                        targets.append(chess.square(tf, tr))\n                for t in targets:\n                    tf = chess.square_file(t); tr = chess.square_rank(t)\n                    if tf in central_files and tr in central_ranks:\n                        cb += 1.0 + (3 - tr) * 0.1\n        return float(cw - cb)\n    except Exception:\n        return 0.0\n",
    "def feature(board: chess.Board) -> float:\n    'King pawn shield strength: counts friendly pawns on/near the king front (white - black), normalized'\n    try:\n        pm = board.piece_map()\n        wk = next((sq for sq,p in pm.items() if p and p.piece_type == chess.KING and p.color == chess.WHITE), None)\n        bk = next((sq for sq,p in pm.items() if p and p.piece_type == chess.KING and p.color == chess.BLACK), None)\n        def shield_score(king_sq, color):\n            if king_sq is None:\n                return 0.0\n            kf = chess.square_file(king_sq); kr = chess.square_rank(king_sq)\n            count = 0\n            if color == chess.WHITE:\n                ranks = range(kr, min(7, kr+2)+1)  # king rank and up to two ranks forward\n            else:\n                ranks = range(max(0, kr-2), kr+1)\n            for f in (kf-1, kf, kf+1):\n                if 0 <= f <= 7:\n                    for r in ranks:\n                        try:\n                            p = board.piece_at(chess.square(f, r))\n                        except Exception:\n                            p = None\n                        if p and p.piece_type == chess.PAWN and p.color == color:\n                            count += 1\n            # normalize by max possible = 9 (3 files * 3 ranks)\n            return float(count) / 9.0\n        return float(shield_score(wk, chess.WHITE) - shield_score(bk, chess.BLACK))\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Hanging material value: sum of opponent-attacked and undefended piece values (black_hanging - white_hanging), positive favors White'\n    try:\n        vals = {chess.PAWN:1.0, chess.KNIGHT:3.0, chess.BISHOP:3.0, chess.ROOK:5.0, chess.QUEEN:9.0, chess.KING:0.0}\n        pm = board.piece_map()\n        white_hung = 0.0\n        black_hung = 0.0\n        for sq, p in pm.items():\n            if p is None or p.piece_type == chess.KING:\n                continue\n            enemy = chess.BLACK if p.color == chess.WHITE else chess.WHITE\n            try:\n                attackers = board.attackers(enemy, sq)\n                defenders = board.attackers(p.color, sq)\n            except Exception:\n                attackers = set(); defenders = set()\n            if len(attackers) > 0 and len(defenders) == 0:\n                if p.color == chess.WHITE:\n                    white_hung += vals.get(p.piece_type, 0.0)\n                else:\n                    black_hung += vals.get(p.piece_type, 0.0)\n        return float(black_hung - white_hung)\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Pawn island difference: number of pawn islands (contiguous pawn files) for black minus white (positive favors White)'\n    try:\n        pm = board.piece_map()\n        files_has = {f: {'w':False, 'b':False} for f in range(8)}\n        for sq,p in pm.items():\n            if p and p.piece_type == chess.PAWN:\n                f = chess.square_file(sq)\n                files_has[f]['w' if p.color == chess.WHITE else 'b'] = True\n        def count_islands(color_key):\n            islands = 0\n            in_island = False\n            for f in range(8):\n                if files_has[f][color_key]:\n                    if not in_island:\n                        islands += 1\n                        in_island = True\n                else:\n                    in_island = False\n            return islands\n        w_islands = count_islands('w')\n        b_islands = count_islands('b')\n        return float(b_islands - w_islands)\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Bishop scope: total unobstructed diagonal reach (sum squares reachable before first blocker) (white - black)'\n    try:\n        pm = board.piece_map()\n        def reach_for_bishop(sq, color):\n            reach = 0\n            dirs = [(1,1),(1,-1),(-1,1),(-1,-1)]\n            f0 = chess.square_file(sq); r0 = chess.square_rank(sq)\n            for df,dr in dirs:\n                f = f0 + df; r = r0 + dr\n                while 0 <= f <= 7 and 0 <= r <= 7:\n                    try:\n                        occ = board.piece_at(chess.square(f, r))\n                    except Exception:\n                        occ = None\n                    # if occupied, bishop can capture if enemy then count that square and stop\n                    if occ is None:\n                        reach += 1\n                    else:\n                        if occ.color != color:\n                            reach += 1\n                        break\n                    f += df; r += dr\n            return reach\n        w_scope = 0.0; b_scope = 0.0\n        for sq,p in pm.items():\n            if p and p.piece_type == chess.BISHOP:\n                if p.color == chess.WHITE:\n                    w_scope += reach_for_bishop(sq, chess.WHITE)\n                else:\n                    b_scope += reach_for_bishop(sq, chess.BLACK)\n        # normalize by a reasonable cap (e.g., each bishop max ~13)\n        norm = max(1.0, (w_scope + b_scope))\n        return float((w_scope - b_scope) / norm)\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Queen mobility: number of legal queen moves (white - black), counts mobility rather than raw material'\n    try:\n        pm = board.piece_map()\n        orig = board.turn\n        try:\n            q_moves = {chess.WHITE:0, chess.BLACK:0}\n            for color in (chess.WHITE, chess.BLACK):\n                board.turn = color\n                for mv in board.legal_moves:\n                    p = board.piece_at(mv.from_square)\n                    if p and p.piece_type == chess.QUEEN and p.color == color:\n                        q_moves[color] += 1\n        finally:\n            board.turn = orig\n        return float(q_moves[chess.WHITE] - q_moves[chess.BLACK])\n    except Exception:\n        try:\n            board.turn = orig\n        except Exception:\n            pass\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Available captures difference: number of legal capture moves (white - black), fallback safe counting'\n    try:\n        orig = board.turn\n        try:\n            captures = {chess.WHITE:0, chess.BLACK:0}\n            for color in (chess.WHITE, chess.BLACK):\n                board.turn = color\n                for mv in board.legal_moves:\n                    # try board.is_capture if available\n                    is_cap = False\n                    try:\n                        is_cap = board.is_capture(mv)\n                    except Exception:\n                        # fallback: destination has piece of opposite color or en-passant heuristic\n                        to_sq = mv.to_square\n                        try:\n                            dest_piece = board.piece_at(to_sq)\n                        except Exception:\n                            dest_piece = None\n                        if dest_piece is not None:\n                            is_cap = True\n                        else:\n                            # en passant: if moving pawn and destination empty but move is diagonal from pawn start\n                            try:\n                                p = board.piece_at(mv.from_square)\n                            except Exception:\n                                p = None\n                            if p and p.piece_type == chess.PAWN and abs(chess.square_file(mv.from_square) - chess.square_file(mv.to_square)) == 1:\n                                # potential en-passant capture, count conservatively\n                                is_cap = True\n                    if is_cap:\n                        captures[color] += 1\n            return float(captures[chess.WHITE] - captures[chess.BLACK])\n        finally:\n            board.turn = orig\n    except Exception:\n        try:\n            board.turn = orig\n        except Exception:\n            pass\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Rook 7th rank pressure: number of rooks on or that can reach the opponent 7th rank in one move (white - black)'\n    try:\n        pm = board.piece_map()\n        orig = board.turn\n        try:\n            cnt = {chess.WHITE:0, chess.BLACK:0}\n            for color in (chess.WHITE, chess.BLACK):\n                target_rank = 6 if color == chess.WHITE else 1\n                # count rooks already on the rank\n                for sq,p in pm.items():\n                    if p and p.piece_type == chess.ROOK and p.color == color:\n                        if chess.square_rank(sq) == target_rank:\n                            cnt[color] += 1\n                # count rooks that have a legal move to that rank\n                board.turn = color\n                for mv in board.legal_moves:\n                    p = board.piece_at(mv.from_square)\n                    if p and p.piece_type == chess.ROOK and p.color == color:\n                        if chess.square_rank(mv.to_square) == target_rank:\n                            cnt[color] += 1\n            return float(cnt[chess.WHITE] - cnt[chess.BLACK])\n        finally:\n            board.turn = orig\n    except Exception:\n        try:\n            board.turn = orig\n        except Exception:\n            pass\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'King exposure: total enemy attackers to king neighborhood (squares around king) (black_exposure - white_exposure), positive favors White'\n    try:\n        pm = board.piece_map()\n        wk = next((sq for sq,p in pm.items() if p and p.piece_type == chess.KING and p.color == chess.WHITE), None)\n        bk = next((sq for sq,p in pm.items() if p and p.piece_type == chess.KING and p.color == chess.BLACK), None)\n        def exposure(king_sq, attacker_color):\n            if king_sq is None:\n                return 0.0\n            kf = chess.square_file(king_sq); kr = chess.square_rank(king_sq)\n            att = 0\n            for df in (-1,0,1):\n                for dr in (-1,0,1):\n                    f = kf + df; r = kr + dr\n                    if 0 <= f <= 7 and 0 <= r <= 7:\n                        try:\n                            attackers = board.attackers(attacker_color, chess.square(f, r))\n                        except Exception:\n                            attackers = set()\n                        att += len(attackers)\n            return float(att)\n        w_exp = exposure(wk, chess.BLACK)\n        b_exp = exposure(bk, chess.WHITE)\n        return float(b_exp - w_exp)\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Endgame king centrality: if low non-king material, measure king closeness to center (white - black), else 0'\n    try:\n        vals = {chess.PAWN:1.0, chess.KNIGHT:3.0, chess.BISHOP:3.0, chess.ROOK:5.0, chess.QUEEN:9.0, chess.KING:0.0}\n        total = 0.0\n        pm = board.piece_map()\n        wk = None; bk = None\n        for sq,p in pm.items():\n            if not p:\n                continue\n            total += vals.get(p.piece_type, 0.0) if p.piece_type != chess.KING else 0.0\n            if p.piece_type == chess.KING:\n                if p.color == chess.WHITE:\n                    wk = sq\n                else:\n                    bk = sq\n        # consider endgame threshold\n        if total > 10.0:\n            return 0.0\n        def centrality(king_sq):\n            if king_sq is None:\n                return 0.0\n            # central squares e4,d4,e5,d5 correspond to files 3..4 rank 3..4\n            kf = chess.square_file(king_sq); kr = chess.square_rank(king_sq)\n            # distance to nearest central square\n            best = 100\n            for cf in (3,4):\n                for cr in (3,4):\n                    d = abs(cf - kf) + abs(cr - kr)\n                    if d < best:\n                        best = d\n            # max manhattan to center corner approx 7\n            maxd = 7.0\n            return float((maxd - best) / maxd)\n        return float(centrality(wk) - centrality(bk))\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Flank pawn majority advantage: compares strongest white flank majority vs strongest black flank majority (white - black)'\n    try:\n        pm = board.piece_map()\n        # define queenside files 0..3, kingside files 4..7\n        def flank_counts(color):\n            k = 0; q = 0\n            for sq,p in pm.items():\n                if p and p.piece_type == chess.PAWN and p.color == color:\n                    f = chess.square_file(sq)\n                    if 4 <= f <= 7:\n                        k += 1\n                    else:\n                        q += 1\n            return k, q\n        wk, wq = flank_counts(chess.WHITE)\n        bk, bq = flank_counts(chess.BLACK)\n        w_best = max(wk - bk, wq - bq, 0)\n        b_best = max(bk - wk, bq - wq, 0)\n        return float(w_best - b_best)\n    except Exception:\n        return 0.0\n",
    "def feature(board: chess.Board) -> float:\n    'Passed pawn advancement potential: sum over passed pawns of (progress toward promotion), positive favors White'\n    try:\n        pm = board.piece_map()\n        def is_passed(sq, color):\n            f = chess.square_file(sq)\n            r = chess.square_rank(sq)\n            if color == chess.WHITE:\n                # no black pawn on same or adjacent files on any higher rank\n                for rf in range(r+1, 8):\n                    for ff in (f-1, f, f+1):\n                        if 0 <= ff < 8:\n                            p = pm.get(chess.square(ff, rf))\n                            if p and p.piece_type == chess.PAWN and p.color == chess.BLACK:\n                                return False\n                return True\n            else:\n                # no white pawn on same or adjacent files on any lower rank\n                for rf in range(r-1, -1, -1):\n                    for ff in (f-1, f, f+1):\n                        if 0 <= ff < 8:\n                            p = pm.get(chess.square(ff, rf))\n                            if p and p.piece_type == chess.PAWN and p.color == chess.WHITE:\n                                return False\n                return True\n        score_w = 0.0; score_b = 0.0\n        for sq, p in pm.items():\n            if not p or p.piece_type != chess.PAWN:\n                continue\n            r = chess.square_rank(sq)\n            if p.color == chess.WHITE:\n                if is_passed(sq, chess.WHITE):\n                    # progress: 0 at starting rank (1) to 1 at promotion (7)\n                    prog = (r - 1) / 6.0 if r >= 1 else 0.0\n                    score_w += prog\n            else:\n                if is_passed(sq, chess.BLACK):\n                    prog = (6 - r) / 6.0 if r <= 6 else 0.0\n                    score_b += prog\n        return float(score_w - score_b)\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'King attack pressure: number of enemy non-pawn attackers targeting squares adjacent to the king (white - black)'\n    try:\n        pm = board.piece_map()\n        def ring_attackers(king_color, attacker_color):\n            ksq = next((sq for sq,p in pm.items() if p and p.piece_type == chess.KING and p.color == king_color), None)\n            if ksq is None:\n                return 0.0\n            kf = chess.square_file(ksq); kr = chess.square_rank(ksq)\n            attackers = set()\n            for df in (-1, 0, 1):\n                for dr in (-1, 0, 1):\n                    if df == 0 and dr == 0:\n                        continue\n                    nf = kf + df; nr = kr + dr\n                    if 0 <= nf <= 7 and 0 <= nr <= 7:\n                        sq = chess.square(nf, nr)\n                        for from_sq in board.attackers(attacker_color, sq):\n                            p = board.piece_at(from_sq)\n                            if p and p.piece_type != chess.PAWN:\n                                attackers.add(from_sq)\n            return float(len(attackers))\n        w_on_b = ring_attackers(chess.BLACK, chess.WHITE)\n        b_on_w = ring_attackers(chess.WHITE, chess.BLACK)\n        return float(w_on_b - b_on_w)\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Undeveloped heavy/minor pieces on home rank: (black_undeveloped - white_undeveloped), positive favors White'\n    try:\n        pm = board.piece_map()\n        def undeveloped_count(color):\n            cnt = 0.0\n            home_rank = 0 if color == chess.WHITE else 7\n            for sq, p in pm.items():\n                if not p or p.color != color:\n                    continue\n                if p.piece_type in (chess.KNIGHT, chess.BISHOP, chess.ROOK, chess.QUEEN):\n                    if chess.square_rank(sq) == home_rank:\n                        cnt += 1.0\n            return cnt\n        uw = undeveloped_count(chess.WHITE)\n        ub = undeveloped_count(chess.BLACK)\n        return float(ub - uw)\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Rooks on the opponent seventh rank: count of rooks on 7th (white) / 2nd (black) ranks (white - black)'\n    try:\n        pm = board.piece_map()\n        score_w = 0.0; score_b = 0.0\n        for sq, p in pm.items():\n            if not p or p.piece_type != chess.ROOK:\n                continue\n            r = chess.square_rank(sq)\n            if p.color == chess.WHITE and r == 6:\n                score_w += 1.0\n            if p.color == chess.BLACK and r == 1:\n                score_b += 1.0\n        return float(score_w - score_b)\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Bishop diagonal reach: sum of unobstructed diagonal ray lengths for bishops (white - black)'\n    try:\n        pm = board.piece_map()\n        def diag_reach_for_bishop(sq):\n            f = chess.square_file(sq); r = chess.square_rank(sq)\n            total = 0\n            for step_f, step_r in ((1,1),(1,-1),(-1,1),(-1,-1)):\n                nf, nr = f + step_f, r + step_r\n                length = 0\n                while 0 <= nf < 8 and 0 <= nr < 8:\n                    if board.piece_at(chess.square(nf, nr)) is not None:\n                        break\n                    length += 1\n                    nf += step_f; nr += step_r\n                total += length\n            return total\n        sw = 0.0; sb = 0.0\n        for sq, p in pm.items():\n            if not p or p.piece_type != chess.BISHOP:\n                continue\n            if p.color == chess.WHITE:\n                sw += diag_reach_for_bishop(sq)\n            else:\n                sb += diag_reach_for_bishop(sq)\n        return float(sw - sb)\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Knight outposts: knights on advanced/central squares not attackable by enemy pawns and supported by a friendly piece (white - black)'\n    try:\n        pm = board.piece_map()\n        def is_supported_and_not_pawn_attacked(sq, color):\n            # square not attacked by enemy pawn\n            enemy = not color\n            # check if any attacker is an enemy pawn\n            for a in board.attackers(enemy, sq):\n                p = board.piece_at(a)\n                if p and p.piece_type == chess.PAWN:\n                    return False\n            # must have a friendly attacker/support (could be pawn or piece)\n            if len(board.attackers(color, sq)) == 0:\n                return False\n            return True\n        def knight_outposts(color):\n            cnt = 0.0\n            for sq, p in pm.items():\n                if not p or p.piece_type != chess.KNIGHT or p.color != color:\n                    continue\n                r = chess.square_rank(sq)\n                f = chess.square_file(sq)\n                # central or advanced preference: files 2..5 and ranks 3..5 for white-ish; use symmetrical\n                if 2 <= f <= 5 and 2 <= r <= 5:\n                    if is_supported_and_not_pawn_attacked(sq, color):\n                        cnt += 1.0\n            return cnt\n        return float(knight_outposts(chess.WHITE) - knight_outposts(chess.BLACK))\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Weak squares near king: number of squares within king neighborhood attacked by opponent and defended by <=1 friendly piece (black_weak - white_weak)'\n    try:\n        pm = board.piece_map()\n        def weak_near_king(king_color):\n            ksq = next((sq for sq,p in pm.items() if p and p.piece_type == chess.KING and p.color == king_color), None)\n            if ksq is None:\n                return 0.0\n            kf = chess.square_file(ksq); kr = chess.square_rank(ksq)\n            weak = 0.0\n            enemy = not king_color\n            for df in (-2,-1,0,1,2):\n                for dr in (-2,-1,0,1,2):\n                    nf = kf + df; nr = kr + dr\n                    if not (0 <= nf < 8 and 0 <= nr < 8):\n                        continue\n                    sq = chess.square(nf, nr)\n                    # skip square of the king\n                    if sq == ksq:\n                        continue\n                    atk = len(board.attackers(enemy, sq))\n                    defn = len(board.attackers(king_color, sq))\n                    if atk > 0 and defn <= 1:\n                        weak += 1.0\n            return weak\n        bw = weak_near_king(chess.BLACK)\n        ww = weak_near_king(chess.WHITE)\n        return float(bw - ww)\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Hanging/high-risk pieces: sum of values of pieces attacked more times than defended (black_hang - white_hang)'\n    try:\n        vals = {chess.PAWN:1.0, chess.KNIGHT:3.0, chess.BISHOP:3.0, chess.ROOK:5.0, chess.QUEEN:9.0, chess.KING:0.0}\n        pm = board.piece_map()\n        hang_w = 0.0; hang_b = 0.0\n        for sq, p in pm.items():\n            if not p:\n                continue\n            attackers = len(board.attackers(not p.color, sq))\n            defenders = len(board.attackers(p.color, sq))\n            if attackers > defenders:\n                extra = float(attackers - defenders)\n                score = vals.get(p.piece_type, 0.0) * extra\n                if p.color == chess.WHITE:\n                    hang_w += score\n                else:\n                    hang_b += score\n        return float(hang_b - hang_w)\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Doubled pawn penalty difference: (black doubled pawns - white doubled pawns), counts additional pawns on same file'\n    try:\n        pm = board.piece_map()\n        doubled_w = 0.0; doubled_b = 0.0\n        for f in range(8):\n            wp = 0; bp = 0\n            for r in range(8):\n                p = pm.get(chess.square(f, r))\n                if p and p.piece_type == chess.PAWN:\n                    if p.color == chess.WHITE:\n                        wp += 1\n                    else:\n                        bp += 1\n            if wp > 1:\n                doubled_w += float(wp - 1)\n            if bp > 1:\n                doubled_b += float(bp - 1)\n        return float(doubled_b - doubled_w)\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Pawn-shield in front of king: count of friendly pawns in first two ranks ahead of king across adjacent files (white - black)'\n    try:\n        pm = board.piece_map()\n        def shield_score(king_color):\n            ksq = next((sq for sq,p in pm.items() if p and p.piece_type == chess.KING and p.color == king_color), None)\n            if ksq is None:\n                return 0.0\n            kf = chess.square_file(ksq); kr = chess.square_rank(ksq)\n            score = 0.0\n            if king_color == chess.WHITE:\n                ranks = [kr+1, kr+2]\n            else:\n                ranks = [kr-1, kr-2]\n            for rf in ranks:\n                if not (0 <= rf < 8):\n                    continue\n                for ff in (kf-1, kf, kf+1):\n                    if 0 <= ff < 8:\n                        p = board.piece_at(chess.square(ff, rf))\n                        if p and p.piece_type == chess.PAWN and p.color == king_color:\n                            # closer pawns count more\n                            dist = abs(rf - kr)\n                            score += 1.0 / float(dist)\n            return score\n        return float(shield_score(chess.WHITE) - shield_score(chess.BLACK))\n    except Exception:\n        return 0.0\n",
    "def feature(board: chess.Board) -> float:\n    'King pawn-shield integrity: difference in the count of friendly pawns directly shielding each king (white - black)'\n    try:\n        pm = board.piece_map()\n        # find kings\n        wk_sq = next((sq for sq,p in pm.items() if p and p.piece_type == chess.KING and p.color == chess.WHITE), None)\n        bk_sq = next((sq for sq,p in pm.items() if p and p.piece_type == chess.KING and p.color == chess.BLACK), None)\n        if wk_sq is None or bk_sq is None:\n            return 0.0\n        def shield_count(king_sq, color):\n            f = chess.square_file(king_sq); r = chess.square_rank(king_sq)\n            cnt = 0\n            if color == chess.WHITE:\n                rr = r + 1\n                for df in (-1, 0, 1):\n                    ff = f + df\n                    if 0 <= ff <= 7 and 0 <= rr <= 7:\n                        p = pm.get(chess.square(ff, rr))\n                        if p and p.piece_type == chess.PAWN and p.color == chess.WHITE:\n                            cnt += 1\n            else:\n                rr = r - 1\n                for df in (-1, 0, 1):\n                    ff = f + df\n                    if 0 <= ff <= 7 and 0 <= rr <= 7:\n                        p = pm.get(chess.square(ff, rr))\n                        if p and p.piece_type == chess.PAWN and p.color == chess.BLACK:\n                            cnt += 1\n            return float(cnt)\n        return float(shield_count(wk_sq, chess.WHITE) - shield_count(bk_sq, chess.BLACK))\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Hanging pieces: difference in number of pieces attacked by enemy and not defended by friendly pieces (white - black)'\n    try:\n        pm = board.piece_map()\n        hang_w = 0.0; hang_b = 0.0\n        for sq, p in pm.items():\n            if not p:\n                continue\n            attackers = board.attackers(not p.color, sq)\n            defenders = board.attackers(p.color, sq)\n            if attackers and (not defenders or len(defenders) == 0):\n                if p.color == chess.WHITE:\n                    hang_w += 1.0\n                else:\n                    hang_b += 1.0\n        return float(hang_w - hang_b)\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Passed pawn advancement potential: sum of normalized advancement of passed pawns (white - black)'\n    try:\n        pm = board.piece_map()\n        def is_passed(sq, color):\n            f = chess.square_file(sq); r = chess.square_rank(sq)\n            if color == chess.WHITE:\n                for rf, rp in pm.items():\n                    pass\n                # no black pawn on same or adjacent files with rank > r\n                for s,p in pm.items():\n                    if not p or p.piece_type != chess.PAWN or p.color != chess.BLACK:\n                        continue\n                    pf = chess.square_file(s); pr = chess.square_rank(s)\n                    if abs(pf - f) <= 1 and pr > r:\n                        return False\n                return True\n            else:\n                for s,p in pm.items():\n                    if not p or p.piece_type != chess.PAWN or p.color != chess.WHITE:\n                        continue\n                    pf = chess.square_file(s); pr = chess.square_rank(s)\n                    if abs(pf - f) <= 1 and pr < r:\n                        return False\n                return True\n        score_w = 0.0; score_b = 0.0\n        for sq,p in pm.items():\n            if not p or p.piece_type != chess.PAWN:\n                continue\n            r = chess.square_rank(sq)\n            if p.color == chess.WHITE:\n                if is_passed(sq, chess.WHITE):\n                    # advanced pawns more valuable: normalized rank 0..1\n                    score_w += float(r) / 7.0\n            else:\n                if is_passed(sq, chess.BLACK):\n                    score_b += float(7 - r) / 7.0\n        return float(score_w - score_b)\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Rook on open or semi-open files advantage: open file = +1, semi-open (no friendly pawns) = +0.5 (white - black)'\n    try:\n        pm = board.piece_map()\n        def file_pawn_info(file_index):\n            friendly = {chess.WHITE:0, chess.BLACK:0}\n            for r in range(8):\n                p = pm.get(chess.square(file_index, r))\n                if p and p.piece_type == chess.PAWN:\n                    friendly[p.color] += 1\n            return friendly\n        score_w = 0.0; score_b = 0.0\n        for sq,p in pm.items():\n            if not p or p.piece_type != chess.ROOK:\n                continue\n            f = chess.square_file(sq)\n            fp = file_pawn_info(f)\n            if fp[chess.WHITE] == 0 and fp[chess.BLACK] == 0:\n                # fully open\n                if p.color == chess.WHITE:\n                    score_w += 1.0\n                else:\n                    score_b += 1.0\n            elif fp[p.color] == 0:\n                # semi-open for this rook\n                if p.color == chess.WHITE:\n                    score_w += 0.5\n                else:\n                    score_b += 0.5\n        return float(score_w - score_b)\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Queen mobility per queen (average legal queen moves per queen) difference (white - black)'\n    try:\n        pm = board.piece_map()\n        # count queens\n        wq = sum(1 for p in pm.values() if p and p.piece_type == chess.QUEEN and p.color == chess.WHITE)\n        bq = sum(1 for p in pm.values() if p and p.piece_type == chess.QUEEN and p.color == chess.BLACK)\n        orig = board.turn\n        try:\n            # count legal queen moves by toggling turn\n            board.turn = chess.WHITE\n            w_moves = 0\n            for mv in board.legal_moves:\n                p = board.piece_at(mv.from_square)\n                if p and p.piece_type == chess.QUEEN and p.color == chess.WHITE:\n                    w_moves += 1\n            board.turn = chess.BLACK\n            b_moves = 0\n            for mv in board.legal_moves:\n                p = board.piece_at(mv.from_square)\n                if p and p.piece_type == chess.QUEEN and p.color == chess.BLACK:\n                    b_moves += 1\n        finally:\n            board.turn = orig\n        avg_w = float(w_moves) / float(wq) if wq > 0 else 0.0\n        avg_b = float(b_moves) / float(bq) if bq > 0 else 0.0\n        return float(avg_w - avg_b)\n    except Exception:\n        try:\n            board.turn = orig\n        except Exception:\n            pass\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'King-zone attacker density: difference in number of distinct enemy attackers targeting the 5x5 king zone (black safe - white safe)'\n    try:\n        pm = board.piece_map()\n        wk_sq = next((sq for sq,p in pm.items() if p and p.piece_type == chess.KING and p.color == chess.WHITE), None)\n        bk_sq = next((sq for sq,p in pm.items() if p and p.piece_type == chess.KING and p.color == chess.BLACK), None)\n        if wk_sq is None or bk_sq is None:\n            return 0.0\n        def attackers_on_zone(king_sq, attacker_color):\n            kf = chess.square_file(king_sq); kr = chess.square_rank(king_sq)\n            attackers_set = set()\n            for df in range(-2, 3):\n                for dr in range(-2, 3):\n                    ff = kf + df; rr = kr + dr\n                    if 0 <= ff <= 7 and 0 <= rr <= 7:\n                        sq = chess.square(ff, rr)\n                        at = board.attackers(attacker_color, sq)\n                        for a in at:\n                            attackers_set.add(a)\n            return float(len(attackers_set))\n        atk_on_w = attackers_on_zone(wk_sq, chess.BLACK)\n        atk_on_b = attackers_on_zone(bk_sq, chess.WHITE)\n        # positive when white is safer (fewer attackers on white than on black)\n        return float(atk_on_b - atk_on_w)\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Bad bishops: counts bishops whose color-complex contains many friendly pawns (indicative of limited scope); returns (black_bad - white_bad)'\n    try:\n        pm = board.piece_map()\n        def square_color(sq):\n            return (chess.square_file(sq) + chess.square_rank(sq)) & 1\n        bad_w = 0.0; bad_b = 0.0\n        # compute friendly pawns on light/dark squares per color\n        pawn_count_by_color = { (chess.WHITE,0):0, (chess.WHITE,1):0, (chess.BLACK,0):0, (chess.BLACK,1):0 }\n        for sq,p in pm.items():\n            if not p:\n                continue\n            if p.piece_type == chess.PAWN:\n                pawn_count_by_color[(p.color, square_color(sq))] += 1\n        for sq,p in pm.items():\n            if not p or p.piece_type != chess.BISHOP:\n                continue\n            parity = square_color(sq)\n            cnt = pawn_count_by_color.get((p.color, parity), 0)\n            # if many friendly pawns on same color complex, bishop is likely bad\n            if cnt >= 3:\n                if p.color == chess.WHITE:\n                    bad_w += 1.0\n                else:\n                    bad_b += 1.0\n        return float(bad_b - bad_w)\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Centralized knights not attacked by enemy pawns: count of knights in central 4x4 that are not attacked by enemy pawns (white - black)'\n    try:\n        pm = board.piece_map()\n        score_w = 0.0; score_b = 0.0\n        # central 4x4 files 2..5, ranks 2..5\n        for sq,p in pm.items():\n            if not p or p.piece_type != chess.KNIGHT:\n                continue\n            f = chess.square_file(sq); r = chess.square_rank(sq)\n            if 2 <= f <= 5 and 2 <= r <= 5:\n                # check enemy pawns attacking this square\n                enemy = chess.BLACK if p.color == chess.WHITE else chess.WHITE\n                pawn_attack = False\n                # pawns attack differently by color\n                for df in (-1, 1):\n                    if p.color == chess.WHITE:\n                        rr = r + 1\n                    else:\n                        rr = r - 1\n                    ff = f + df\n                    if 0 <= ff <= 7 and 0 <= rr <= 7:\n                        sp = pm.get(chess.square(ff, rr))\n                        if sp and sp.piece_type == chess.PAWN and sp.color == enemy:\n                            pawn_attack = True\n                            break\n                if not pawn_attack:\n                    if p.color == chess.WHITE:\n                        score_w += 1.0\n                    else:\n                        score_b += 1.0\n        return float(score_w - score_b)\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Rooks on opponent seventh rank: counts rooks on the opponent\\'s second rank (white rooks on rank 6 zero-based) (white - black)'\n    try:\n        pm = board.piece_map()\n        wr7 = 0.0; br7 = 0.0\n        for sq,p in pm.items():\n            if not p or p.piece_type != chess.ROOK:\n                continue\n            r = chess.square_rank(sq)\n            if p.color == chess.WHITE and r == 6:\n                wr7 += 1.0\n            if p.color == chess.BLACK and r == 1:\n                br7 += 1.0\n        return float(wr7 - br7)\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Potential knight forks: number of landing squares where a knight could attack two or more high-value enemy pieces (queen/rook/rook/queen) (white - black)'\n    try:\n        pm = board.piece_map()\n        knight_deltas = [(1,2),(2,1),(-1,2),(-2,1),(1,-2),(2,-1),(-1,-2),(-2,-1)]\n        def potential_forks_for_color(color):\n            forks = 0\n            for sq,p in pm.items():\n                if not p or p.piece_type != chess.KNIGHT or p.color != color:\n                    continue\n                f = chess.square_file(sq); r = chess.square_rank(sq)\n                for df, dr in knight_deltas:\n                    tf = f + df; tr = r + dr\n                    if not (0 <= tf <= 7 and 0 <= tr <= 7):\n                        continue\n                    target = chess.square(tf, tr)\n                    dest_piece = pm.get(target)\n                    # knight can land on empty or capture enemy\n                    if dest_piece and dest_piece.color == color:\n                        continue\n                    # from landing square, count attacked high-value enemy pieces\n                    count_high = 0\n                    for df2, dr2 in knight_deltas:\n                        af = tf + df2; ar = tr + dr2\n                        if 0 <= af <= 7 and 0 <= ar <= 7:\n                            a_sq = chess.square(af, ar)\n                            ap = pm.get(a_sq)\n                            if ap and ap.color != color and (ap.piece_type == chess.QUEEN or ap.piece_type == chess.ROOK or ap.piece_type == chess.KNIGHT or ap.piece_type == chess.BISHOP):\n                                count_high += 1\n                    if count_high >= 2:\n                        forks += 1\n            return float(forks)\n        return float(potential_forks_for_color(chess.WHITE) - potential_forks_for_color(chess.BLACK))\n    except Exception:\n        return 0.0\n",
    "def feature(board: chess.Board) -> float:\n    'King attack pressure: weighted sum of attacker piece values targeting squares around each king (positive favors White attacking Black)'\n    try:\n        pm = board.piece_map()\n        # find kings\n        wk_sq = next((sq for sq,p in pm.items() if p and p.piece_type == chess.KING and p.color == chess.WHITE), None)\n        bk_sq = next((sq for sq,p in pm.items() if p and p.piece_type == chess.KING and p.color == chess.BLACK), None)\n        if wk_sq is None or bk_sq is None:\n            return 0.0\n        vals = {chess.PAWN:1.0, chess.KNIGHT:3.0, chess.BISHOP:3.0, chess.ROOK:5.0, chess.QUEEN:9.0, chess.KING:0.0}\n        def pressure_on(square, attacker_color):\n            total = 0.0\n            # consider attackers to the 8-neighborhood of the king (including the king square)\n            sqs = []\n            f = chess.square_file(square); r = chess.square_rank(square)\n            for df in (-1,0,1):\n                for dr in (-1,0,1):\n                    ff = f + df; rr = r + dr\n                    if 0 <= ff <= 7 and 0 <= rr <= 7:\n                        sqs.append(chess.square(ff, rr))\n            seen_attackers = set()\n            for s in sqs:\n                for att_from in board.attackers(attacker_color, s):\n                    if att_from in seen_attackers:\n                        continue\n                    seen_attackers.add(att_from)\n                    p = board.piece_at(att_from)\n                    if p:\n                        total += vals.get(p.piece_type, 0.0)\n            return total\n        # pressure_on_black = attackers by White on/near black king\n        p_on_b = pressure_on(bk_sq, chess.WHITE)\n        p_on_w = pressure_on(wk_sq, chess.BLACK)\n        # positive means White is exerting more pressure on black king\n        return float(p_on_b - p_on_w)\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Passed pawn advancement potential: sum of advanced passed-pawn scores (white - black), higher = better for White'\n    try:\n        pm = board.piece_map()\n        white_score = 0.0\n        black_score = 0.0\n        white_pawns = [sq for sq,p in pm.items() if p and p.piece_type == chess.PAWN and p.color == chess.WHITE]\n        black_pawns = [sq for sq,p in pm.items() if p and p.piece_type == chess.PAWN and p.color == chess.BLACK]\n        def is_passed(sq, color):\n            f = chess.square_file(sq); r = chess.square_rank(sq)\n            if color == chess.WHITE:\n                for bp in black_pawns:\n                    bf = chess.square_file(bp); br = chess.square_rank(bp)\n                    if abs(bf - f) <= 1 and br > r:\n                        return False\n                return True\n            else:\n                for wp in white_pawns:\n                    wf = chess.square_file(wp); wr = chess.square_rank(wp)\n                    if abs(wf - f) <= 1 and wr < r:\n                        return False\n                return True\n        for sq in white_pawns:\n            r = chess.square_rank(sq)\n            if is_passed(sq, chess.WHITE):\n                # score increases the more advanced the pawn is\n                white_score += 1.0 + float(r) / 7.0\n        for sq in black_pawns:\n            r = chess.square_rank(sq)\n            if is_passed(sq, chess.BLACK):\n                black_score += 1.0 + float(7 - r) / 7.0\n        return float(white_score - black_score)\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Outpost knight strength: count of knights on opponent half that are pawn-supported and not attacked by enemy pawns (white - black)'\n    try:\n        pm = board.piece_map()\n        def outpost_count(color):\n            cnt = 0.0\n            for sq,p in pm.items():\n                if not p or p.color != color or p.piece_type != chess.KNIGHT:\n                    continue\n                r = chess.square_rank(sq)\n                # require knight in opponent half\n                if color == chess.WHITE and r < 4:\n                    continue\n                if color == chess.BLACK and r > 3:\n                    continue\n                # defended by at least one friendly pawn\n                defenders = board.attackers(color, sq)\n                pawn_defended = any((board.piece_at(d) and board.piece_at(d).piece_type == chess.PAWN and board.piece_at(d).color == color) for d in defenders)\n                if not pawn_defended:\n                    continue\n                # not attacked by enemy pawns\n                enemy = not color\n                enemy_attackers = board.attackers(enemy, sq)\n                attacked_by_enemy_pawn = any((board.piece_at(a) and board.piece_at(a).piece_type == chess.PAWN and board.piece_at(a).color == enemy) for a in enemy_attackers)\n                if attacked_by_enemy_pawn:\n                    continue\n                cnt += 1.0\n            return cnt\n        return float(outpost_count(chess.WHITE) - outpost_count(chess.BLACK))\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'King mobility (escape squares): difference in number of legal king moves available for side to move (white - black)'\n    try:\n        orig = board.turn\n        try:\n            def king_moves_count(color):\n                board.turn = color\n                c = 0\n                for mv in board.legal_moves:\n                    p = board.piece_at(mv.from_square)\n                    if p and p.piece_type == chess.KING and p.color == color:\n                        c += 1\n                return float(c)\n            km_w = king_moves_count(chess.WHITE)\n            km_b = king_moves_count(chess.BLACK)\n            return float(km_w - km_b)\n        finally:\n            board.turn = orig\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Material-activity product: (material * mobility) difference (white - black) to reward active material'\n    try:\n        vals = {chess.PAWN:1.0, chess.KNIGHT:3.0, chess.BISHOP:3.0, chess.ROOK:5.0, chess.QUEEN:9.0, chess.KING:0.0}\n        mat_w = mat_b = 0.0\n        pm = board.piece_map()\n        for p in pm.values():\n            if not p:\n                continue\n            if p.color == chess.WHITE:\n                mat_w += vals.get(p.piece_type, 0.0)\n            else:\n                mat_b += vals.get(p.piece_type, 0.0)\n        orig = board.turn\n        try:\n            board.turn = chess.WHITE\n            mob_w = float(sum(1 for _ in board.legal_moves))\n            board.turn = chess.BLACK\n            mob_b = float(sum(1 for _ in board.legal_moves))\n        finally:\n            board.turn = orig\n        # scale down to keep magnitudes reasonable\n        return float((mat_w * (0.1 + 0.01*mob_w)) - (mat_b * (0.1 + 0.01*mob_b)))\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Bad pawn structure penalty: combined doubled, isolated and backward pawn penalties (black - white), positive favors White if Black has worse pawns'\n    try:\n        pm = board.piece_map()\n        pawns_by_color = {chess.WHITE:[], chess.BLACK:[]}\n        file_counts = {chess.WHITE: [0]*8, chess.BLACK: [0]*8}\n        for sq,p in pm.items():\n            if p and p.piece_type == chess.PAWN:\n                pawns_by_color[p.color].append(sq)\n                file_counts[p.color][chess.square_file(sq)] += 1\n        def pawn_penalty(color):\n            penalty = 0.0\n            opp = not color\n            for sq in pawns_by_color[color]:\n                f = chess.square_file(sq); r = chess.square_rank(sq)\n                # doubled: each extra pawn on file adds penalty\n                dcount = file_counts[color][f]\n                if dcount > 1:\n                    penalty += 0.4 * (dcount - 1)\n                # isolated: no friendly pawns on adjacent files\n                adj = 0\n                for af in (f-1, f+1):\n                    if 0 <= af <= 7 and file_counts[color][af] > 0:\n                        adj += 1\n                if adj == 0:\n                    penalty += 0.75\n                # backward-ish: no friendly pawn on adjacent files ahead (rough test)\n                support_ahead = False\n                if color == chess.WHITE:\n                    for af in (f-1, f+1):\n                        if 0 <= af <= 7:\n                            for psq in pawns_by_color[color]:\n                                if chess.square_file(psq) == af and chess.square_rank(psq) > r:\n                                    support_ahead = True; break\n                            if support_ahead: break\n                else:\n                    for af in (f-1, f+1):\n                        if 0 <= af <= 7:\n                            for psq in pawns_by_color[color]:\n                                if chess.square_file(psq) == af and chess.square_rank(psq) < r:\n                                    support_ahead = True; break\n                            if support_ahead: break\n                if not support_ahead:\n                    penalty += 0.3\n            return penalty\n        pen_w = pawn_penalty(chess.WHITE)\n        pen_b = pawn_penalty(chess.BLACK)\n        # positive if Black has worse pawn structure (favors White)\n        return float(pen_b - pen_w)\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Rooks on key ranks: count of rooks on opponent seventh (or second) rank (white - black)'\n    try:\n        pm = board.piece_map()\n        white_cnt = 0.0\n        black_cnt = 0.0\n        for sq,p in pm.items():\n            if not p or p.piece_type != chess.ROOK:\n                continue\n            r = chess.square_rank(sq)\n            if p.color == chess.WHITE and r == 6:\n                white_cnt += 1.0\n            if p.color == chess.BLACK and r == 1:\n                black_cnt += 1.0\n        return float(white_cnt - black_cnt)\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Multi-defended pieces: count of own pieces defended by two or more friendly pieces (white - black)'\n    try:\n        pm = board.piece_map()\n        def count_multi_defended(color):\n            cnt = 0.0\n            for sq,p in pm.items():\n                if not p or p.color != color:\n                    continue\n                # defenders are attackers of same color\n                defenders = board.attackers(color, sq)\n                # exclude the piece itself if it appears (shouldn't)\n                if len(defenders) >= 2:\n                    cnt += 1.0\n            return cnt\n        return float(count_multi_defended(chess.WHITE) - count_multi_defended(chess.BLACK))\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Queen centralization vs danger: centrality score minus penalty for being attacked (white - black)'\n    try:\n        pm = board.piece_map()\n        center_sqs = [chess.square(3,3), chess.square(4,3), chess.square(3,4), chess.square(4,4)]\n        def queen_score(color):\n            total = 0.0\n            for sq,p in pm.items():\n                if not p or p.color != color or p.piece_type != chess.QUEEN:\n                    continue\n                # distance to nearest center square (Manhattan)\n                dist = min(chess.square_distance(sq, c) for c in center_sqs)\n                cent = max(0.0, (4.0 - float(dist)) / 4.0)  # normalized centrality 0..1\n                # attackers on queen\n                attackers = len(board.attackers(not color, sq))\n                danger = 0.25 * float(attackers)  # each attacker subtracts 0.25\n                total += cent - danger\n            return total\n        return float(queen_score(chess.WHITE) - queen_score(chess.BLACK))\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Endgame king activity: rewards central/active kings in reduced-material positions (white - black)'\n    try:\n        pm = board.piece_map()\n        # count non-pawn non-king pieces\n        major_minor = sum(1 for p in pm.values() if p and p.piece_type not in (chess.PAWN, chess.KING))\n        # activity factor stronger when fewer pieces remain\n        factor = max(0.0, (6.0 - float(major_minor)) / 6.0)\n        center_sqs = [chess.square(3,3), chess.square(4,3), chess.square(3,4), chess.square(4,4)]\n        def king_activity(color):\n            ksq = next((sq for sq,p in pm.items() if p and p.piece_type == chess.KING and p.color == color), None)\n            if ksq is None:\n                return 0.0\n            dist = min(chess.square_distance(ksq, c) for c in center_sqs)\n            closeness = max(0.0, (4.0 - float(dist)) / 4.0)\n            return closeness * factor\n        return float(king_activity(chess.WHITE) - king_activity(chess.BLACK))\n    except Exception:\n        return 0.0\n",
    "def feature(board: chess.Board) -> float:\n    'Pawn structure weaknesses: (doubled + isolated + backward) weighted sum (white - black), higher positive favors White'\n    try:\n        pm = board.piece_map()\n        pawn_files = {chess.WHITE: {f:0 for f in range(8)}, chess.BLACK: {f:0 for f in range(8)}}\n        pawn_sqs = {chess.WHITE: [], chess.BLACK: []}\n        for sq, p in pm.items():\n            if p and p.piece_type == chess.PAWN:\n                f = chess.square_file(sq)\n                pawn_files[p.color][f] += 1\n                pawn_sqs[p.color].append(sq)\n        def weaknesses_for(color):\n            other = chess.BLACK if color == chess.WHITE else chess.WHITE\n            score = 0.0\n            # doubled pawns\n            for f in range(8):\n                if pawn_files[color][f] > 1:\n                    score += 0.9 * (pawn_files[color][f] - 1)\n            # isolated pawns\n            for sq in pawn_sqs[color]:\n                f = chess.square_file(sq)\n                if (f-1 < 0 or pawn_files[color][f-1] == 0) and (f+1 > 7 or pawn_files[color][f+1] == 0):\n                    score += 1.2\n            # backward pawns (approx): no friendly pawn on adjacent files behind it and enemy pawn controls forward squares\n            for sq in pawn_sqs[color]:\n                f = chess.square_file(sq); r = chess.square_rank(sq)\n                behind_found = False\n                for af in (f-1, f+1):\n                    if af < 0 or af > 7:\n                        continue\n                    if color == chess.WHITE:\n                        for br in range(0, r):\n                            pp = board.piece_at(chess.square(af, br))\n                            if pp and pp.piece_type == chess.PAWN and pp.color == color:\n                                behind_found = True\n                                break\n                    else:\n                        for br in range(r+1, 8):\n                            pp = board.piece_at(chess.square(af, br))\n                            if pp and pp.piece_type == chess.PAWN and pp.color == color:\n                                behind_found = True\n                                break\n                    if behind_found:\n                        break\n                if behind_found:\n                    continue\n                # check enemy pawn presence on adjacent files ahead (approx contest)\n                contested = False\n                for af in (f-1, f+1):\n                    if af < 0 or af > 7:\n                        continue\n                    if color == chess.WHITE:\n                        for ar in range(r+1, 8):\n                            pp = board.piece_at(chess.square(af, ar))\n                            if pp and pp.piece_type == chess.PAWN and pp.color == other:\n                                contested = True\n                                break\n                    else:\n                        for ar in range(0, r):\n                            pp = board.piece_at(chess.square(af, ar))\n                            if pp and pp.piece_type == chess.PAWN and pp.color == other:\n                                contested = True\n                                break\n                    if contested:\n                        break\n                if contested:\n                    score += 1.3\n            return score\n        return float(weaknesses_for(chess.WHITE) - weaknesses_for(chess.BLACK))\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Passed pawn potential: weighted sum of passed pawns by advancement and lack of enemy pawns (white - black)'\n    try:\n        pm = board.piece_map()\n        def is_passed(sq, color):\n            f = chess.square_file(sq); r = chess.square_rank(sq)\n            enemy = chess.BLACK if color == chess.WHITE else chess.WHITE\n            if color == chess.WHITE:\n                for af in (f-1, f, f+1):\n                    if af < 0 or af > 7:\n                        continue\n                    for ar in range(r+1, 8):\n                        pp = board.piece_at(chess.square(af, ar))\n                        if pp and pp.piece_type == chess.PAWN and pp.color == enemy:\n                            return False\n            else:\n                for af in (f-1, f, f+1):\n                    if af < 0 or af > 7:\n                        continue\n                    for ar in range(0, r):\n                        pp = board.piece_at(chess.square(af, ar))\n                        if pp and pp.piece_type == chess.PAWN and pp.color == enemy:\n                            return False\n            return True\n        score_w = 0.0; score_b = 0.0\n        for sq, p in pm.items():\n            if not p or p.piece_type != chess.PAWN:\n                continue\n            r = chess.square_rank(sq)\n            if is_passed(sq, p.color):\n                # advancement factor (0..1)\n                adv = r / 7.0 if p.color == chess.WHITE else (7 - r) / 7.0\n                # bonus for being further advanced and not blocked by piece directly in front\n                blocked = False\n                if p.color == chess.WHITE and r < 7:\n                    front = board.piece_at(chess.square(chess.square_file(sq), r+1))\n                    blocked = (front is not None and front.color != p.color)\n                if p.color == chess.BLACK and r > 0:\n                    front = board.piece_at(chess.square(chess.square_file(sq), r-1))\n                    blocked = (front is not None and front.color != p.color)\n                block_pen = 0.5 if blocked else 1.0\n                val = adv * 2.5 * block_pen\n                if p.color == chess.WHITE:\n                    score_w += val\n                else:\n                    score_b += val\n        return float(score_w - score_b)\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'King pawn shield integrity: counts friendly pawns in front/adjacent files near own king (white - black), higher is safer'\n    try:\n        pm = board.piece_map()\n        wk = next((sq for sq,p in pm.items() if p and p.piece_type == chess.KING and p.color == chess.WHITE), None)\n        bk = next((sq for sq,p in pm.items() if p and p.piece_type == chess.KING and p.color == chess.BLACK), None)\n        def shield_score(king_sq, color):\n            if king_sq is None:\n                return 0.0\n            f = chess.square_file(king_sq); r = chess.square_rank(king_sq)\n            score = 0.0\n            # examine up to two ranks in front (for white front is +, for black front is -)\n            drs = (1,2) if color == chess.WHITE else (-1,-2)\n            for dr_weight, dr in enumerate(drs, start=1):\n                rr = r + dr\n                if rr < 0 or rr > 7:\n                    continue\n                for af in (f-1, f, f+1):\n                    if af < 0 or af > 7:\n                        continue\n                    pp = board.piece_at(chess.square(af, rr))\n                    if pp and pp.piece_type == chess.PAWN and pp.color == color:\n                        # pawns closer contribute more\n                        score += (1.6 if dr_weight == 1 else 0.9)\n            return score\n        return float(shield_score(wk, chess.WHITE) - shield_score(bk, chess.BLACK))\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Attack density around king: weighted sum of attackers to squares near enemy king (white - black), weights by attacker piece value'\n    try:\n        vals = {chess.PAWN:1.0, chess.KNIGHT:3.0, chess.BISHOP:3.0, chess.ROOK:5.0, chess.QUEEN:9.0, chess.KING:0.0}\n        pm = board.piece_map()\n        wk = next((sq for sq,p in pm.items() if p and p.piece_type == chess.KING and p.color == chess.WHITE), None)\n        bk = next((sq for sq,p in pm.items() if p and p.piece_type == chess.KING and p.color == chess.BLACK), None)\n        if wk is None or bk is None:\n            return 0.0\n        def density_around(king_sq, attacker_color):\n            s = 0.0\n            kf = chess.square_file(king_sq); kr = chess.square_rank(king_sq)\n            for df in (-2,-1,0,1,2):\n                for dr in (-2,-1,0,1,2):\n                    f = kf + df; r = kr + dr\n                    if f < 0 or f > 7 or r < 0 or r > 7:\n                        continue\n                    sq = chess.square(f, r)\n                    try:\n                        atk = board.attackers(attacker_color, sq)\n                    except Exception:\n                        atk = set()\n                    for a in atk:\n                        p = board.piece_at(a)\n                        if p:\n                            # closer squares to king weigh more\n                            dist = max(abs(df), abs(dr))\n                            weight = (1.8 - 0.4*dist) if dist <= 2 else 0.2\n                            s += vals.get(p.piece_type, 0.0) * max(0.2, weight)\n            return s\n        # white attacking black king minus black attacking white king\n        return float(density_around(bk, chess.WHITE) - density_around(wk, chess.BLACK))\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Rooks on the seventh (and opponent second) rank: count and proximity bonus (white - black)'\n    try:\n        pm = board.piece_map()\n        score_w = 0.0; score_b = 0.0\n        for sq,p in pm.items():\n            if not p or p.piece_type != chess.ROOK:\n                continue\n            r = chess.square_rank(sq); f = chess.square_file(sq)\n            if p.color == chess.WHITE:\n                # white on rank 6 (7th rank)\n                if r == 6:\n                    score_w += 1.6\n                # near opponent king file and rank\n                bk = next((sqk for sqk,pk in pm.items() if pk and pk.piece_type == chess.KING and pk.color == chess.BLACK), None)\n                if bk is not None:\n                    dist = chess.square_distance(sq, bk)\n                    if dist <= 3:\n                        score_w += 0.4\n            else:\n                if r == 1:\n                    score_b += 1.6\n                wk = next((sqk for sqk,pk in pm.items() if pk and pk.piece_type == chess.KING and pk.color == chess.WHITE), None)\n                if wk is not None:\n                    dist = chess.square_distance(sq, wk)\n                    if dist <= 3:\n                        score_b += 0.4\n        return float(score_w - score_b)\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Mobility towards center: number of legal moves that move a piece closer to central squares (d4,e4,d5,e5) (white - black)'\n    try:\n        center_sqs = [chess.parse_square(s) for s in ('d4','e4','d5','e5')]\n        def dist_to_center(sq):\n            return min(chess.square_distance(sq, c) for c in center_sqs)\n        orig = board.turn\n        try:\n            moved_closer = {chess.WHITE:0.0, chess.BLACK:0.0}\n            for color in (chess.WHITE, chess.BLACK):\n                board.turn = color\n                for mv in board.legal_moves:\n                    from_sq = mv.from_square; to_sq = mv.to_square\n                    try:\n                        if dist_to_center(to_sq) < dist_to_center(from_sq):\n                            moved_closer[color] += 1.0\n                    except Exception:\n                        continue\n            return float(moved_closer[chess.WHITE] - moved_closer[chess.BLACK])\n        finally:\n            board.turn = orig\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'King flank openness: penalty for open/semi-open files adjacent to king file (positive favors White)'\n    try:\n        pm = board.piece_map()\n        wk = next((sq for sq,p in pm.items() if p and p.piece_type == chess.KING and p.color == chess.WHITE), None)\n        bk = next((sq for sq,p in pm.items() if p and p.piece_type == chess.KING and p.color == chess.BLACK), None)\n        def flank_penalty(king_sq, color):\n            if king_sq is None:\n                return 0.0\n            penalty = 0.0\n            kf = chess.square_file(king_sq)\n            for af in (kf-1, kf, kf+1):\n                if af < 0 or af > 7:\n                    continue\n                total = 0; friendly = 0\n                for rr in range(8):\n                    pp = board.piece_at(chess.square(af, rr))\n                    if pp and pp.piece_type == chess.PAWN:\n                        total += 1\n                        if pp.color == color:\n                            friendly += 1\n                if total == 0:\n                    penalty += 1.6\n                elif friendly == 0:\n                    penalty += 0.8\n            return penalty\n        # if black has more penalty (weaker king), that's good for White -> positive value\n        return float((flank_penalty(bk, chess.BLACK)) - (flank_penalty(wk, chess.WHITE)))\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Minor piece supply vs pawn mass: (minor pieces count / pawn count) difference (white - black), favors side with more minor-pieces per pawn'\n    try:\n        minors = {chess.WHITE:0, chess.BLACK:0}\n        pawns = {chess.WHITE:0, chess.BLACK:0}\n        for p in board.piece_map().values():\n            if not p:\n                continue\n            if p.piece_type in (chess.KNIGHT, chess.BISHOP):\n                minors[p.color] += 1\n            if p.piece_type == chess.PAWN:\n                pawns[p.color] += 1\n        def ratio(color):\n            if pawns[color] == 0:\n                return float(minors[color])  # if no pawns, minor pieces are especially valuable\n            return float(minors[color]) / float(pawns[color])\n        return float(ratio(chess.WHITE) - ratio(chess.BLACK))\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Queen activity minus threats: (queen legal moves - 0.6 * number_of_attacks_on_queen) (white - black)'\n    try:\n        pm = board.piece_map()\n        qsq = {chess.WHITE: None, chess.BLACK: None}\n        for sq, p in pm.items():\n            if p and p.piece_type == chess.QUEEN:\n                qsq[p.color] = sq\n        orig = board.turn\n        try:\n            qmob = {chess.WHITE:0.0, chess.BLACK:0.0}\n            for color in (chess.WHITE, chess.BLACK):\n                board.turn = color\n                for mv in board.legal_moves:\n                    p = board.piece_at(mv.from_square)\n                    if p and p.piece_type == chess.QUEEN and p.color == color:\n                        qmob[color] += 1.0\n            threats = {chess.WHITE:0.0, chess.BLACK:0.0}\n            for color in (chess.WHITE, chess.BLACK):\n                sq = qsq[color]\n                if sq is None:\n                    threats[color] = 0.0\n                    continue\n                opp = chess.BLACK if color == chess.WHITE else chess.WHITE\n                try:\n                    threats[color] = float(len(board.attackers(opp, sq)))\n                except Exception:\n                    threats[color] = 0.0\n            score_w = qmob[chess.WHITE] - 0.6 * threats[chess.WHITE]\n            score_b = qmob[chess.BLACK] - 0.6 * threats[chess.BLACK]\n            return float(score_w - score_b)\n        finally:\n            board.turn = orig\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Passed pawn urgency vs enemy king distance: for each passed pawn, (advancement * (1 - normalized king distance to promotion)) summed (white - black)'\n    try:\n        pm = board.piece_map()\n        wk = next((sq for sq,p in pm.items() if p and p.piece_type == chess.KING and p.color == chess.WHITE), None)\n        bk = next((sq for sq,p in pm.items() if p and p.piece_type == chess.KING and p.color == chess.BLACK), None)\n        def score_for(color):\n            s = 0.0\n            opp_king = bk if color == chess.WHITE else wk\n            for sq,p in pm.items():\n                if not p or p.piece_type != chess.PAWN or p.color != color:\n                    continue\n                # check passed\n                f = chess.square_file(sq); r = chess.square_rank(sq)\n                passed = True\n                if color == chess.WHITE:\n                    for af in (f-1,f,f+1):\n                        if af < 0 or af > 7:\n                            continue\n                        for ar in range(r+1, 8):\n                            pp = board.piece_at(chess.square(af, ar))\n                            if pp and pp.piece_type == chess.PAWN and pp.color != color:\n                                passed = False; break\n                        if not passed:\n                            break\n                else:\n                    for af in (f-1,f,f+1):\n                        if af < 0 or af > 7:\n                            continue\n                        for ar in range(0, r):\n                            pp = board.piece_at(chess.square(af, ar))\n                            if pp and pp.piece_type == chess.PAWN and pp.color != color:\n                                passed = False; break\n                        if not passed:\n                            break\n                if not passed:\n                    continue\n                # advancement (0..1)\n                adv = r / 7.0 if color == chess.WHITE else (7 - r) / 7.0\n                # distance of opposing king to promotion square\n                promo_sq = chess.square(f, 7) if color == chess.WHITE else chess.square(f, 0)\n                if opp_king is None:\n                    king_norm = 0.0\n                else:\n                    king_norm = float(chess.square_distance(opp_king, promo_sq)) / 14.0\n                s += adv * (1.0 - king_norm) * 2.2\n            return s\n        return float(score_for(chess.WHITE) - score_for(chess.BLACK))\n    except Exception:\n        return 0.0\n",
    "def feature(board: chess.Board) -> float:\n    'King pawn shield integrity: (white_shield_defenders - white_shield_attacks) - (black_shield_defenders - black_shield_attacks), positive favors White'\n    try:\n        pm = board.piece_map()\n        vals = {chess.PAWN:1.0}\n        def shield_score(king_color):\n            ksq = next((sq for sq,p in pm.items() if p and p.piece_type == chess.KING and p.color == king_color), None)\n            if ksq is None:\n                return 0.0\n            kf = chess.square_file(ksq); kr = chess.square_rank(ksq)\n            # examine up to two ranks in front (depending on color) and files f-1,f,f+1\n            defender_count = 0.0\n            attacker_count = 0.0\n            forward = 1 if king_color == chess.WHITE else -1\n            for step in (1, 2):\n                r = kr + forward * step\n                for df in (-1, 0, 1):\n                    f = kf + df\n                    if not (0 <= f < 8 and 0 <= r < 8):\n                        continue\n                    sq = chess.square(f, r)\n                    # defenders: friendly pawns occupying or attacking the square (pawn defenders preferred)\n                    for a in board.attackers(king_color, sq):\n                        p = board.piece_at(a)\n                        if p and p.piece_type == chess.PAWN and p.color == king_color:\n                            defender_count += 1.0\n                    # attackers: enemy pieces attacking shield squares\n                    for a in board.attackers(not king_color, sq):\n                        attacker_count += 1.0\n            # normalize by max possible roughly 6 squares * a few attackers; keep raw difference\n            return defender_count - 0.6 * attacker_count\n        return float(shield_score(chess.WHITE) - shield_score(chess.BLACK))\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Rook activity: weighted count of rooks on opponent 7th rank, open and semi-open files (white - black)'\n    try:\n        pm = board.piece_map()\n        # file pawn counts\n        files = [0]*8\n        files_white = [0]*8\n        files_black = [0]*8\n        for sq,p in pm.items():\n            if not p:\n                continue\n            f = chess.square_file(sq)\n            if p.piece_type == chess.PAWN:\n                files[f] += 1\n                if p.color == chess.WHITE:\n                    files_white[f] += 1\n                else:\n                    files_black[f] += 1\n        def rook_score(color):\n            score = 0.0\n            for sq,p in pm.items():\n                if not p or p.piece_type != chess.ROOK or p.color != color:\n                    continue\n                f = chess.square_file(sq); r = chess.square_rank(sq)\n                # opponent's 7th rank index: white wants rank 6, black wants rank 1\n                opponent_7th = 6 if color == chess.WHITE else 1\n                if r == opponent_7th:\n                    score += 2.2\n                # open file\n                if files[f] == 0:\n                    score += 1.6\n                else:\n                    # semi-open: no friendly pawn on file but opponent pawn present\n                    if color == chess.WHITE and files_white[f] == 0 and files_black[f] > 0:\n                        score += 1.0\n                    if color == chess.BLACK and files_black[f] == 0 and files_white[f] > 0:\n                        score += 1.0\n                # bonus for being on same file as enemy king (pressure)\n                king_sq = next((sqk for sqk,pp in pm.items() if pp and pp.piece_type == chess.KING and pp.color != color), None)\n                if king_sq is not None and chess.square_file(king_sq) == f:\n                    # ensure there is an unobstructed path (only allow if no friendly pieces block between)\n                    blocked = False\n                    kf = chess.square_file(king_sq); kr = chess.square_rank(king_sq)\n                    rf = f; rr = r\n                    step_f = 0\n                    step_r = 1 if kr > rr else -1 if kr < rr else 0\n                    # move along rank towards king\n                    rr = r + step_r\n                    while 0 <= rr < 8:\n                        sqmid = chess.square(f, rr)\n                        if sqmid == king_sq:\n                            break\n                        if board.piece_at(sqmid) is not None:\n                            blocked = True\n                            break\n                        rr += step_r\n                    if not blocked:\n                        score += 0.9\n            return score\n        return float(rook_score(chess.WHITE) - rook_score(chess.BLACK))\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Bishop reach and pair synergy: sum of unobstructed diagonal reach lengths, bonus for bishop pair (white - black)'\n    try:\n        pm = board.piece_map()\n        def bishop_reach_and_pair(color):\n            reach = 0.0\n            bishops = 0\n            for sq,p in pm.items():\n                if not p or p.piece_type != chess.BISHOP or p.color != color:\n                    continue\n                bishops += 1\n                f = chess.square_file(sq); r = chess.square_rank(sq)\n                for df,dr in ((1,1),(1,-1),(-1,1),(-1,-1)):\n                    nf = f + df; nr = r + dr\n                    while 0 <= nf < 8 and 0 <= nr < 8:\n                        reach += 1.0\n                        occ = board.piece_at(chess.square(nf, nr))\n                        if occ is not None:\n                            # can attack the first occupied square but cannot go beyond\n                            break\n                        nf += df; nr += dr\n            # small additional value for bishop pair\n            pair_bonus = 1.4 if bishops >= 2 else 0.0\n            return reach + pair_bonus\n        return float(bishop_reach_and_pair(chess.WHITE) - bishop_reach_and_pair(chess.BLACK))\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Weighted control of center and extended center by piece value (white - black)'\n    try:\n        center4 = [chess.parse_square(s) for s in ('d4','e4','d5','e5')]\n        ext_center = []\n        for f in range(2,6):\n            for r in range(2,6):\n                sq = chess.square(f, r)\n                if sq not in center4:\n                    ext_center.append(sq)\n        vals = {chess.PAWN:1.0, chess.KNIGHT:3.0, chess.BISHOP:3.0, chess.ROOK:5.0, chess.QUEEN:9.0, chess.KING:0.0}\n        def control_score(color):\n            score = 0.0\n            for sq in center4:\n                # heavy weight for central 4\n                for a in board.attackers(color, sq):\n                    p = board.piece_at(a)\n                    if p:\n                        score += vals.get(p.piece_type,0.0) * 1.6\n            for sq in ext_center:\n                for a in board.attackers(color, sq):\n                    p = board.piece_at(a)\n                    if p:\n                        score += vals.get(p.piece_type,0.0) * 0.9\n            return score\n        return float(control_score(chess.WHITE) - control_score(chess.BLACK))\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Knight outpost score: count and quality of knights on outposts (protected by pawn and not attacked by enemy pawn) in opponent half (white - black)'\n    try:\n        pm = board.piece_map()\n        score = {chess.WHITE:0.0, chess.BLACK:0.0}\n        for sq,p in pm.items():\n            if not p or p.piece_type != chess.KNIGHT:\n                continue\n            color = p.color\n            r = chess.square_rank(sq)\n            # in opponent half\n            if color == chess.WHITE and r < 4:\n                continue\n            if color == chess.BLACK and r > 3:\n                continue\n            # protected by friendly pawn?\n            pawn_protected = False\n            for a in board.attackers(color, sq):\n                pa = board.piece_at(a)\n                if pa and pa.piece_type == chess.PAWN and pa.color == color:\n                    pawn_protected = True\n                    break\n            # attacked by enemy pawn?\n            enemy_pawn_attacks = False\n            for a in board.attackers(not color, sq):\n                pa = board.piece_at(a)\n                if pa and pa.piece_type == chess.PAWN:\n                    enemy_pawn_attacks = True\n                    break\n            if pawn_protected and not enemy_pawn_attacks:\n                # reward stronger outposts slightly more if deeper into enemy half\n                depth = (chess.square_rank(sq) - 3) if color == chess.WHITE else (4 - chess.square_rank(sq))\n                depth = max(0, depth)\n                score[color] += 1.8 + 0.4 * float(depth)\n        return float(score[chess.WHITE] - score[chess.BLACK])\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Tactical capture potential: sum of favorable immediate captures (captured_value - 0.8*mover_value) for legal captures (white - black)'\n    try:\n        vals = {chess.PAWN:1.0, chess.KNIGHT:3.0, chess.BISHOP:3.0, chess.ROOK:5.0, chess.QUEEN:9.0, chess.KING:0.0}\n        orig = board.turn\n        try:\n            totals = {chess.WHITE:0.0, chess.BLACK:0.0}\n            for color in (chess.WHITE, chess.BLACK):\n                board.turn = color\n                for mv in board.legal_moves:\n                    # treat as capture if destination currently occupied\n                    captured = board.piece_at(mv.to_square)\n                    mover = board.piece_at(mv.from_square)\n                    if mover is None:\n                        continue\n                    if captured is None:\n                        # try to detect en-passant: square behind capture may have pawn when to-square empty\n                        # conservative: skip en-passant if unknown\n                        continue\n                    if captured.color == color:\n                        continue\n                    cv = vals.get(captured.piece_type, 0.0)\n                    mvv = vals.get(mover.piece_type, 0.0)\n                    gain = cv - 0.8 * mvv\n                    if gain > 0:\n                        totals[color] += gain\n            return float(totals[chess.WHITE] - totals[chess.BLACK])\n        finally:\n            board.turn = orig\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Queen mobility and vulnerability: (mobility_moves - 0.6*attackers_on_queen) for queen(s), summed (white - black)'\n    try:\n        pm = board.piece_map()\n        vals = {chess.QUEEN:9.0}\n        orig = board.turn\n        try:\n            move_counts = {chess.WHITE:0.0, chess.BLACK:0.0}\n            # count legal moves per originating square\n            per_from = {}\n            for color in (chess.WHITE, chess.BLACK):\n                board.turn = color\n                for mv in board.legal_moves:\n                    per_from[mv.from_square] = per_from.get(mv.from_square, 0) + 1\n            score = {chess.WHITE:0.0, chess.BLACK:0.0}\n            for sq,p in pm.items():\n                if not p or p.piece_type != chess.QUEEN:\n                    continue\n                color = p.color\n                mobility = float(per_from.get(sq, 0))\n                attackers = float(len(board.attackers(not color, sq)))\n                score[color] += mobility - 0.6 * attackers\n            return float(score[chess.WHITE] - score[chess.BLACK])\n        finally:\n            board.turn = orig\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Rook file pressure on king: count of rooks with unobstructed attack on enemy king file weighted by distance to king (white - black)'\n    try:\n        pm = board.piece_map()\n        def pressure(color):\n            total = 0.0\n            # opponent king square\n            king_sq = next((sq for sq,p in pm.items() if p and p.piece_type == chess.KING and p.color != color), None)\n            if king_sq is None:\n                return 0.0\n            kf = chess.square_file(king_sq); kr = chess.square_rank(king_sq)\n            for sq,p in pm.items():\n                if not p or p.piece_type != chess.ROOK or p.color != color:\n                    continue\n                f = chess.square_file(sq); r = chess.square_rank(sq)\n                if f != kf:\n                    continue\n                # check unobstructed path between rook and king (excluding rook square and king square)\n                step = 1 if kr > r else -1\n                rr = r + step\n                blocked = False\n                while rr != kr:\n                    if board.piece_at(chess.square(f, rr)) is not None:\n                        blocked = True\n                        break\n                    rr += step\n                if not blocked:\n                    # closer rooks get more pressure\n                    dist = abs(kr - r)\n                    total += 1.5 + (4.0 / (dist + 1.0))\n            return total\n        return float(pressure(chess.WHITE) - pressure(chess.BLACK))\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Net hanging pieces: sum of positive (attackers - defenders) * piece_value for pieces attacked more than defended (black - white), positive favors White'\n    try:\n        pm = board.piece_map()\n        vals = {chess.PAWN:1.0, chess.KNIGHT:3.0, chess.BISHOP:3.0, chess.ROOK:5.0, chess.QUEEN:9.0, chess.KING:0.0}\n        hang = {chess.WHITE:0.0, chess.BLACK:0.0}\n        for sq,p in pm.items():\n            if not p:\n                continue\n            color = p.color\n            atk = len(board.attackers(not color, sq))\n            defn = len(board.attackers(color, sq))\n            net = atk - defn\n            if net > 0:\n                hang[color] += net * vals.get(p.piece_type, 0.0)\n        # we want positive to favor White: so black_hang - white_hang (if black has more hanging pieces it's bad for Black => favors White)\n        return float(hang[chess.BLACK] - hang[chess.WHITE])\n    except Exception:\n        return 0.0\n",
    "def feature(board: chess.Board) -> float:\n    'Passed pawn potential: sum of passed-pawn weights (advancedness) (white - black).'\n    try:\n        pm = board.piece_map()\n        def passed_weight(sq, color):\n            f = chess.square_file(sq); r = chess.square_rank(sq)\n            # white pawns advance with increasing rank, black with decreasing rank\n            if color == chess.WHITE:\n                # check no opposing pawns in same or adjacent files ahead\n                for af in (f-1, f, f+1):\n                    if 0 <= af <= 7:\n                        for ar in range(r+1, 8):\n                            sq2 = chess.square(af, ar)\n                            p = pm.get(sq2)\n                            if p and p.piece_type == chess.PAWN and p.color == chess.BLACK:\n                                return 0.0\n                # weight by advancement (0..1)\n                return float(r) / 7.0\n            else:\n                for af in (f-1, f, f+1):\n                    if 0 <= af <= 7:\n                        for ar in range(r-1, -1, -1):\n                            sq2 = chess.square(af, ar)\n                            p = pm.get(sq2)\n                            if p and p.piece_type == chess.PAWN and p.color == chess.WHITE:\n                                return 0.0\n                return float(7 - r) / 7.0\n        w = 0.0; b = 0.0\n        for sq, p in pm.items():\n            if p and p.piece_type == chess.PAWN:\n                if p.color == chess.WHITE:\n                    w += passed_weight(sq, chess.WHITE)\n                else:\n                    b += passed_weight(sq, chess.BLACK)\n        return float(w - b)\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Pawn structural weakness: (isolated + doubled pawn penalty) difference (white - black).'\n    try:\n        pm = board.piece_map()\n        pawns_on_file = {f: {chess.WHITE:0, chess.BLACK:0} for f in range(8)}\n        for sq, p in pm.items():\n            if p and p.piece_type == chess.PAWN:\n                pawns_on_file[chess.square_file(sq)][p.color] += 1\n        def penalties(color):\n            iso = 0\n            doubled = 0\n            for sq, p in pm.items():\n                if not p or p.piece_type != chess.PAWN or p.color != color:\n                    continue\n                f = chess.square_file(sq)\n                # isolated if no friendly pawns on adjacent files\n                adj = False\n                for af in (f-1, f+1):\n                    if 0 <= af <= 7 and pawns_on_file[af][color] > 0:\n                        adj = True\n                        break\n                if not adj:\n                    iso += 1\n            for f in range(8):\n                cnt = pawns_on_file[f][color]\n                if cnt > 1:\n                    doubled += (cnt - 1)\n            # heavier penalty for isolated than doubled\n            return float(iso) * 1.2 + float(doubled) * 0.8\n        return float(penalties(chess.WHITE) - penalties(chess.BLACK))\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Rook support for passed pawns: +1 if a rook is directly behind a same-color passed pawn (white - black).'\n    try:\n        pm = board.piece_map()\n        # helper to detect passed pawn quickly (reuse same logic)\n        def is_passed(sq, color):\n            f = chess.square_file(sq); r = chess.square_rank(sq)\n            if color == chess.WHITE:\n                for af in (f-1, f, f+1):\n                    if 0 <= af <= 7:\n                        for ar in range(r+1, 8):\n                            p = pm.get(chess.square(af, ar))\n                            if p and p.piece_type == chess.PAWN and p.color == chess.BLACK:\n                                return False\n                return True\n            else:\n                for af in (f-1, f, f+1):\n                    if 0 <= af <= 7:\n                        for ar in range(r-1, -1, -1):\n                            p = pm.get(chess.square(af, ar))\n                            if p and p.piece_type == chess.PAWN and p.color == chess.WHITE:\n                                return False\n                return True\n        score_w = 0.0; score_b = 0.0\n        # map passed pawns by file to their furthest advanced square for each color\n        passed_by_file = {chess.WHITE: {}, chess.BLACK: {}}\n        for sq, p in pm.items():\n            if p and p.piece_type == chess.PAWN:\n                if is_passed(sq, p.color):\n                    f = chess.square_file(sq); r = chess.square_rank(sq)\n                    prev = passed_by_file[p.color].get(f)\n                    if prev is None:\n                        passed_by_file[p.color][f] = sq\n                    else:\n                        # keep the most advanced (highest rank for white, lowest for black)\n                        if p.color == chess.WHITE:\n                            if chess.square_rank(prev) < r:\n                                passed_by_file[p.color][f] = sq\n                        else:\n                            if chess.square_rank(prev) > r:\n                                passed_by_file[p.color][f] = sq\n        for sq, p in pm.items():\n            if not p or p.piece_type != chess.ROOK:\n                continue\n            f = chess.square_file(sq); r = chess.square_rank(sq)\n            if p.color == chess.WHITE:\n                pp = passed_by_file[chess.WHITE].get(f)\n                if pp is not None and chess.square_rank(pp) > r:\n                    score_w += 1.0\n            else:\n                pp = passed_by_file[chess.BLACK].get(f)\n                if pp is not None and chess.square_rank(pp) < r:\n                    score_b += 1.0\n        return float(score_w - score_b)\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'King centrality in endgame: (white - black) centrality score when material is low (otherwise 0).'\n    try:\n        vals = {chess.PAWN:1.0, chess.KNIGHT:3.0, chess.BISHOP:3.0, chess.ROOK:5.0, chess.QUEEN:9.0}\n        total = 0.0\n        pm = board.piece_map()\n        for p in pm.values():\n            if p and p.piece_type in vals:\n                total += vals[p.piece_type]\n        # only meaningful in endgame-ish positions\n        if total > 14.0:\n            return 0.0\n        # center as (3.5,3.5) maximum distance approx 4.95\n        max_d = ((3.5**2 + 3.5**2) ** 0.5)\n        def king_center_score(color):\n            ksq = next((sq for sq,p in pm.items() if p and p.piece_type == chess.KING and p.color == color), None)\n            if ksq is None:\n                return 0.0\n            fx = float(chess.square_file(ksq)); ry = float(chess.square_rank(ksq))\n            d = ((fx - 3.5)**2 + (ry - 3.5)**2) ** 0.5\n            return 1.0 - (d / max_d)\n        return float(king_center_score(chess.WHITE) - king_center_score(chess.BLACK))\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Functional bishop pair: bishop-pair bonus reduced if own pawns are mostly on same-colored squares blocking bishops (white - black).'\n    try:\n        pm = board.piece_map()\n        def bishop_pair_score(color):\n            bishops = [sq for sq,p in pm.items() if p and p.piece_type == chess.BISHOP and p.color == color]\n            if len(bishops) < 2:\n                return 0.0\n            # identify bishop square colors: 0 = light, 1 = dark (file+rank parity)\n            bcols = [((chess.square_file(sq) + chess.square_rank(sq)) & 1) for sq in bishops]\n            # if bishops on both colors -> full bonus\n            if len(set(bcols)) == 2:\n                base = 1.0\n            else:\n                base = 0.6  # two bishops but same-color placement (rare)\n            # count pawns on the color squares of bishops (which would block)\n            pawn_block = 0\n            total_pawns = 0\n            for sq,p in pm.items():\n                if p and p.piece_type == chess.PAWN and p.color == color:\n                    total_pawns += 1\n                    scol = ((chess.square_file(sq) + chess.square_rank(sq)) & 1)\n                    # if both bishops on same color, consider that color, else penalize proportionally\n                    if len(set(bcols)) == 1:\n                        if scol == bcols[0]:\n                            pawn_block += 1\n                    else:\n                        # if pawns split, consider pawns on both colors as modest blocking\n                        if scol == bcols[0] or scol == bcols[1]:\n                            pawn_block += 0.5\n            if total_pawns == 0:\n                block_factor = 0.0\n            else:\n                block_factor = float(pawn_block) / float(max(1, total_pawns))\n            # final score: base reduced by blocking fraction (0..1)\n            return base * (1.0 - 0.7 * block_factor)\n        return float(bishop_pair_score(chess.WHITE) - bishop_pair_score(chess.BLACK))\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Piece coordination: difference in average pairwise manhattan distance among non-pawn, non-king pieces (black_avg - white_avg). Higher => White more coordinated.'\n    try:\n        pm = board.piece_map()\n        def avg_pairwise(color):\n            sqs = [sq for sq,p in pm.items() if p and p.color == color and p.piece_type not in (chess.PAWN, chess.KING)]\n            n = len(sqs)\n            if n < 2:\n                return 0.0\n            total = 0.0\n            count = 0\n            for i in range(n):\n                for j in range(i+1, n):\n                    total += chess.square_distance(sqs[i], sqs[j])\n                    count += 1\n            return total / float(count) if count > 0 else 0.0\n        return float(avg_pairwise(chess.BLACK) - avg_pairwise(chess.WHITE))\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Immediate tactical opportunity: number of legal capture moves available (white - black) as quick measure of forcing potential.'\n    try:\n        orig = board.turn\n        try:\n            caps = {chess.WHITE:0.0, chess.BLACK:0.0}\n            for color in (chess.WHITE, chess.BLACK):\n                board.turn = color\n                for mv in board.legal_moves:\n                    # treat as capture if destination square currently occupied by opponent\n                    to_p = board.piece_at(mv.to_square)\n                    if to_p and to_p.color != color:\n                        caps[color] += 1.0\n                    else:\n                        # rough handling of en-passant-like captures: check if move is a pawn move that lands on empty but could be capture\n                        # (we avoid using board.is_en_passant to stay compatible with minimal API)\n                        pass\n            return float(caps[chess.WHITE] - caps[chess.BLACK])\n        finally:\n            board.turn = orig\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'King pressure score: weighted sum of unique attackers around the enemy king (white pressure on black king - black pressure on white king).'\n    try:\n        pm = board.piece_map()\n        values = {chess.PAWN:1.0, chess.KNIGHT:3.0, chess.BISHOP:3.0, chess.ROOK:5.0, chess.QUEEN:9.0, chess.KING:0.0}\n        def pressure_on(color_king, attacker_color):\n            king_sq = next((sq for sq,p in pm.items() if p and p.piece_type == chess.KING and p.color == color_king), None)\n            if king_sq is None:\n                return 0.0\n            kf = chess.square_file(king_sq); kr = chess.square_rank(king_sq)\n            attacker_sqs = set()\n            for df in (-1,0,1):\n                for dr in (-1,0,1):\n                    ff = kf + df; rr = kr + dr\n                    if 0 <= ff <= 7 and 0 <= rr <= 7:\n                        try:\n                            atks = board.attackers(attacker_color, chess.square(ff, rr))\n                        except Exception:\n                            atks = set()\n                        for a in atks:\n                            attacker_sqs.add(a)\n            score = 0.0\n            for a in attacker_sqs:\n                p = pm.get(a)\n                if not p:\n                    continue\n                # distance to king (manhattan)\n                d = chess.square_distance(a, king_sq)\n                # avoid division by zero; closer attackers weigh more\n                denom = 1.0 + float(d)\n                score += values.get(p.piece_type, 0.0) / denom\n            return score\n        w_on_b = pressure_on(chess.BLACK, chess.WHITE)\n        b_on_w = pressure_on(chess.WHITE, chess.BLACK)\n        return float(w_on_b - b_on_w)\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Back-rank congestion: count of non-king, non-pawn pieces on own back rank (black - white); higher favors side with opponent stuck pieces.'\n    try:\n        pm = board.piece_map()\n        w_cnt = 0.0; b_cnt = 0.0\n        for sq,p in pm.items():\n            if not p or p.piece_type in (chess.PAWN, chess.KING):\n                continue\n            r = chess.square_rank(sq)\n            if p.color == chess.WHITE and r == 0:\n                w_cnt += 1.0\n            if p.color == chess.BLACK and r == 7:\n                b_cnt += 1.0\n        return float(b_cnt - w_cnt)\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Stable outpost knights: number of knights on opponent half protected by a pawn and not attackable by enemy pawns (white - black).'\n    try:\n        pm = board.piece_map()\n        def is_outpost_knight(sq, color):\n            p = pm.get(sq)\n            if not p or p.piece_type != chess.KNIGHT or p.color != color:\n                return False\n            f = chess.square_file(sq); r = chess.square_rank(sq)\n            # must be in opponent half\n            if color == chess.WHITE and r < 4:\n                return False\n            if color == chess.BLACK and r > 3:\n                return False\n            # protected by friendly pawn (pawn captures to this square)\n            protected = False\n            if color == chess.WHITE:\n                for af in (f-1, f+1):\n                    ar = r-1\n                    if 0 <= af <= 7 and 0 <= ar <= 7:\n                        p2 = pm.get(chess.square(af, ar))\n                        if p2 and p2.piece_type == chess.PAWN and p2.color == chess.WHITE:\n                            protected = True\n                            break\n                # check not attackable by enemy pawn (black pawns capture downward from r+1)\n                attackable = False\n                for af in (f-1, f+1):\n                    ar = r+1\n                    if 0 <= af <= 7 and 0 <= ar <= 7:\n                        p2 = pm.get(chess.square(af, ar))\n                        if p2 and p2.piece_type == chess.PAWN and p2.color == chess.BLACK:\n                            attackable = True\n                            break\n            else:\n                for af in (f-1, f+1):\n                    ar = r+1\n                    if 0 <= af <= 7 and 0 <= ar <= 7:\n                        p2 = pm.get(chess.square(af, ar))\n                        if p2 and p2.piece_type == chess.PAWN and p2.color == chess.BLACK:\n                            protected = True\n                            break\n                attackable = False\n                for af in (f-1, f+1):\n                    ar = r-1\n                    if 0 <= af <= 7 and 0 <= ar <= 7:\n                        p2 = pm.get(chess.square(af, ar))\n                        if p2 and p2.piece_type == chess.PAWN and p2.color == chess.WHITE:\n                            attackable = True\n                            break\n            return protected and (not attackable)\n        w = 0.0; b = 0.0\n        for sq, p in pm.items():\n            if p and p.piece_type == chess.KNIGHT:\n                if is_outpost_knight(sq, p.color):\n                    if p.color == chess.WHITE:\n                        w += 1.0\n                    else:\n                        b += 1.0\n        return float(w - b)\n    except Exception:\n        return 0.0\n",
    "def feature(board: chess.Board) -> float:\n    'King zone attackers: difference in number of distinct attacking pieces targeting the 3x3 zone around the enemy king (white - black)'\n    try:\n        pm = board.piece_map()\n        # locate kings\n        wk = next((sq for sq,p in pm.items() if p and p.piece_type == chess.KING and p.color == chess.WHITE), None)\n        bk = next((sq for sq,p in pm.items() if p and p.piece_type == chess.KING and p.color == chess.BLACK), None)\n        if wk is None or bk is None:\n            return 0.0\n        def zone_attackers(king_sq, attacker_color):\n            attackers_set = set()\n            kf = chess.square_file(king_sq); kr = chess.square_rank(king_sq)\n            for df in (-1,0,1):\n                for dr in (-1,0,1):\n                    f = kf + df; r = kr + dr\n                    if 0 <= f <= 7 and 0 <= r <= 7:\n                        sq = chess.square(f, r)\n                        for a in board.attackers(attacker_color, sq):\n                            attackers_set.add(a)\n            return len(attackers_set)\n        white_pressure = zone_attackers(bk, chess.WHITE)\n        black_pressure = zone_attackers(wk, chess.BLACK)\n        return float(white_pressure - black_pressure)\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Kingside mobility proportion imbalance: (proportion of legal moves that go to kingside files for White) - (same for Black)'\n    try:\n        orig = board.turn\n        try:\n            prop = {chess.WHITE:0.0, chess.BLACK:0.0}\n            total = {chess.WHITE:0, chess.BLACK:0}\n            kingside_files = set(range(4,8))  # files e-h (4..7)\n            for color in (chess.WHITE, chess.BLACK):\n                board.turn = color\n                for mv in board.legal_moves:\n                    total[color] += 1\n                    if chess.square_file(mv.to_square) in kingside_files:\n                        prop[color] += 1\n            # avoid division by zero\n            pw = prop[chess.WHITE] / total[chess.WHITE] if total[chess.WHITE] > 0 else 0.0\n            pb = prop[chess.BLACK] / total[chess.BLACK] if total[chess.BLACK] > 0 else 0.0\n            return float(pw - pb)\n        finally:\n            board.turn = orig\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Linear pins to king: number of non-king pieces pinned to their king by opponent sliding pieces (white pinned_by_black - black pinned_by_white) negative favors White if White is pinned more'\n    try:\n        pm = board.piece_map()\n        dirs = [(1,0),(-1,0),(0,1),(0,-1),(1,1),(1,-1),(-1,1),(-1,-1)]\n        def pinned_count(color):\n            # count pieces of 'color' that are pinned to their king by opponents\n            king_sq = next((sq for sq,p in pm.items() if p and p.piece_type == chess.KING and p.color == color), None)\n            if king_sq is None:\n                return 0\n            pinned = set()\n            kf = chess.square_file(king_sq); kr = chess.square_rank(king_sq)\n            for dx,dy in dirs:\n                f = kf + dx; r = kr + dy\n                first_piece_sq = None\n                first_piece = None\n                blocked = False\n                while 0 <= f <= 7 and 0 <= r <= 7:\n                    sq = chess.square(f, r)\n                    piece = pm.get(sq)\n                    if piece:\n                        if first_piece is None:\n                            # first encountered piece along ray\n                            first_piece = (sq, piece)\n                        else:\n                            # second piece encountered blocks potential pin check\n                            second_sq, second_piece = sq, piece\n                            # check whether first_piece is friendly to king and second_piece is opponent sliding that pins\n                            if first_piece[1].color == color and second_piece.color != color:\n                                # determine if second_piece can attack along this ray\n                                dx0 = dx; dy0 = dy\n                                is_diag = abs(dx0) == abs(dy0) and dx0 != 0\n                                is_ortho = (dx0 == 0) ^ (dy0 == 0)\n                                t = second_piece.piece_type\n                                if (t == chess.QUEEN) or (t == chess.BISHOP and is_diag) or (t == chess.ROOK and is_ortho):\n                                    # pinned piece found\n                                    pinned.add(first_piece[0])\n                            break\n                    f += dx; r += dy\n            return len(pinned)\n        pinned_white = pinned_count(chess.WHITE)\n        pinned_black = pinned_count(chess.BLACK)\n        # positive value favors White (i.e., more black pieces pinned)\n        return float(pinned_black - pinned_white)\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Rooks on opponent seventh rank pressure (white rooks on rank 6 minus black rooks on rank 1)'\n    try:\n        pm = board.piece_map()\n        wr7 = 0; br7 = 0\n        for sq, p in pm.items():\n            if not p or p.piece_type != chess.ROOK:\n                continue\n            r = chess.square_rank(sq)\n            if p.color == chess.WHITE and r == 6:\n                wr7 += 1\n            if p.color == chess.BLACK and r == 1:\n                br7 += 1\n        return float(wr7 - br7)\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Pawn shield score: number of friendly pawns directly shielding the king (white - black); measures king pawn cover directly in front'\n    try:\n        pm = board.piece_map()\n        def shield_count(color):\n            king_sq = next((sq for sq,p in pm.items() if p and p.piece_type == chess.KING and p.color == color), None)\n            if king_sq is None:\n                return 0\n            kf = chess.square_file(king_sq); kr = chess.square_rank(king_sq)\n            count = 0\n            if color == chess.WHITE:\n                target_r = kr + 1\n                for df in (-1,0,1):\n                    f = kf + df\n                    if 0 <= f <= 7 and 0 <= target_r <= 7:\n                        sq = chess.square(f, target_r)\n                        p = pm.get(sq)\n                        if p and p.piece_type == chess.PAWN and p.color == chess.WHITE:\n                            count += 1\n            else:\n                target_r = kr - 1\n                for df in (-1,0,1):\n                    f = kf + df\n                    if 0 <= f <= 7 and 0 <= target_r <= 7:\n                        sq = chess.square(f, target_r)\n                        p = pm.get(sq)\n                        if p and p.piece_type == chess.PAWN and p.color == chess.BLACK:\n                            count += 1\n            return count\n        return float(shield_count(chess.WHITE) - shield_count(chess.BLACK))\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Coordination by piece-type diversity in opponent half: count of squares in opponent half attacked by two or more different piece types (white - black)'\n    try:\n        coord_w = 0.0\n        coord_b = 0.0\n        pm = board.piece_map()\n        for r in range(4, 8):\n            for f in range(8):\n                sq = chess.square(f, r)\n                atk_w = board.attackers(chess.WHITE, sq)\n                atk_b = board.attackers(chess.BLACK, sq)\n                types_w = set()\n                types_b = set()\n                for a in atk_w:\n                    p = pm.get(a)\n                    if p:\n                        types_w.add(p.piece_type)\n                for a in atk_b:\n                    p = pm.get(a)\n                    if p:\n                        types_b.add(p.piece_type)\n                if len(types_w) >= 2:\n                    coord_w += 1.0\n        for r in range(0, 4):\n            for f in range(8):\n                sq = chess.square(f, r)\n                atk_w = board.attackers(chess.WHITE, sq)\n                atk_b = board.attackers(chess.BLACK, sq)\n                types_w = set()\n                types_b = set()\n                for a in atk_w:\n                    p = pm.get(a)\n                    if p:\n                        types_w.add(p.piece_type)\n                for a in atk_b:\n                    p = pm.get(a)\n                    if p:\n                        types_b.add(p.piece_type)\n                if len(types_b) >= 2:\n                    coord_b += 1.0\n        # We counted white coordination on black half and black coordination on white half separately above\n        return float(coord_w - coord_b)\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Endgame king centralization bonus: in low-piece endgames, rewards more central king (positive if White king more central than Black)'\n    try:\n        # count non-pawn, non-king pieces to detect endgame-ish\n        nontrivial = 0\n        pm = board.piece_map()\n        for p in pm.values():\n            if p and p.piece_type not in (chess.KING, chess.PAWN):\n                nontrivial += 1\n        if nontrivial > 4:\n            return 0.0\n        # compute distance to center (center approx files 3..4 ranks 3..4); use min manhattan to center region\n        wk = next((sq for sq,p in pm.items() if p and p.piece_type == chess.KING and p.color == chess.WHITE), None)\n        bk = next((sq for sq,p in pm.items() if p and p.piece_type == chess.KING and p.color == chess.BLACK), None)\n        if wk is None or bk is None:\n            return 0.0\n        center_sqs = [chess.square(3,3), chess.square(4,3), chess.square(3,4), chess.square(4,4)]\n        def centrality(ksq):\n            d = min(chess.square_distance(ksq, c) for c in center_sqs)  # 0..14\n            # normalize so 0..1 where higher = more central\n            return (14.0 - float(d)) / 14.0\n        cw = centrality(wk)\n        cb = centrality(bk)\n        return float(cw - cb)\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Minor piece quality: bishop-pair and bishop-vs-knight preference (positive favors White)'\n    try:\n        pm = board.piece_map()\n        def minor_score(color):\n            bishops = sum(1 for p in pm.values() if p and p.color == color and p.piece_type == chess.BISHOP)\n            knights = sum(1 for p in pm.values() if p and p.color == color and p.piece_type == chess.KNIGHT)\n            score = 0.0\n            if bishops >= 2:\n                score += 0.5\n            # bishops slightly preferred versus knights in open positions; give modest weight\n            score += 0.25 * (bishops - knights)\n            return score\n        return float(minor_score(chess.WHITE) - minor_score(chess.BLACK))\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Mobility per heavy/minor piece: (legal moves originating from non-pawn non-king pieces) / count of such pieces (white - black)'\n    try:\n        orig = board.turn\n        try:\n            move_counts = {chess.WHITE:0, chess.BLACK:0}\n            for color in (chess.WHITE, chess.BLACK):\n                board.turn = color\n                for mv in board.legal_moves:\n                    p = board.piece_at(mv.from_square)\n                    if p and p.piece_type not in (chess.PAWN, chess.KING):\n                        move_counts[color] += 1\n            # piece counts\n            pm = board.piece_map()\n            piece_counts = {chess.WHITE:0, chess.BLACK:0}\n            for p in pm.values():\n                if p and p.piece_type not in (chess.PAWN, chess.KING):\n                    piece_counts[p.color] += 1\n            ratio_w = move_counts[chess.WHITE] / piece_counts[chess.WHITE] if piece_counts[chess.WHITE] > 0 else float(move_counts[chess.WHITE])\n            ratio_b = move_counts[chess.BLACK] / piece_counts[chess.BLACK] if piece_counts[chess.BLACK] > 0 else float(move_counts[chess.BLACK])\n            return float(ratio_w - ratio_b)\n        finally:\n            board.turn = orig\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Threats to high-value pieces: weighted number of attackers targeting opponent rooks and queens (1.5*attackers_on_queen + 1.0*attackers_on_rook) (white - black)'\n    try:\n        pm = board.piece_map()\n        def threat_score(attacker_color):\n            score = 0.0\n            defender = not attacker_color\n            for sq, p in pm.items():\n                if not p or p.color != defender:\n                    continue\n                if p.piece_type == chess.QUEEN:\n                    score += 1.5 * len(board.attackers(attacker_color, sq))\n                elif p.piece_type == chess.ROOK:\n                    score += 1.0 * len(board.attackers(attacker_color, sq))\n            return score\n        wscore = threat_score(chess.WHITE)\n        bscore = threat_score(chess.BLACK)\n        return float(wscore - bscore)\n    except Exception:\n        return 0.0\n",
    "def feature(board: chess.Board) -> float:\n    'Pawn-shield integrity around each king: (# friendly pawns in typical shield files in front of king) (white - black), higher better for that side'\n    try:\n        pm = board.piece_map()\n        def shield_score_for(color):\n            # find king\n            king_sq = next((sq for sq,p in pm.items() if p and p.piece_type == chess.KING and p.color == color), None)\n            if king_sq is None:\n                return 0.0\n            kf = chess.square_file(king_sq); kr = chess.square_rank(king_sq)\n            # decide typical shield files relative to king file: include king file and adjacent files\n            files = [kf-1, kf, kf+1]\n            score = 0.0\n            # for white look ahead (higher ranks); for black look down (lower ranks)\n            if color == chess.WHITE:\n                ranks = [kr+1, kr+2]  # immediate pawn shield squares ahead\n            else:\n                ranks = [kr-1, kr-2]\n            for f in files:\n                if f < 0 or f > 7:\n                    continue\n                for r in ranks:\n                    if r < 0 or r > 7:\n                        continue\n                    p = board.piece_at(chess.square(f, r))\n                    if p and p.piece_type == chess.PAWN and p.color == color:\n                        # closer pawn is more valuable\n                        dist = abs(r - kr)\n                        score += 1.0 / float(dist)\n            return score\n        return float(shield_score_for(chess.WHITE) - shield_score_for(chess.BLACK))\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Rooks on open/semi-open files: open file = no pawns, semi-open = no friendly pawns. Weighted (open=1.0, semi-open=0.5) (white - black)'\n    try:\n        pm = board.piece_map()\n        def rook_file_score(color):\n            score = 0.0\n            for sq,p in pm.items():\n                if not p or p.color != color or p.piece_type != chess.ROOK:\n                    continue\n                f = chess.square_file(sq)\n                has_white_pawn = False; has_black_pawn = False\n                for r in range(8):\n                    pp = board.piece_at(chess.square(f, r))\n                    if pp and pp.piece_type == chess.PAWN:\n                        if pp.color == chess.WHITE:\n                            has_white_pawn = True\n                        else:\n                            has_black_pawn = True\n                if not has_white_pawn and not has_black_pawn:\n                    score += 1.0\n                elif not (has_white_pawn if color == chess.WHITE else has_black_pawn):\n                    # no friendly pawn => semi-open\n                    score += 0.5\n            return score\n        return float(rook_file_score(chess.WHITE) - rook_file_score(chess.BLACK))\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Active bishop-pair coverage: for each side with two bishops, count attacked squares in opponent half (normalized) (white - black)'\n    try:\n        pm = board.piece_map()\n        def bishop_activity(color):\n            types = (chess.BISHOP,)\n            bishops = [sq for sq,p in pm.items() if p and p.color == color and p.piece_type == chess.BISHOP]\n            if len(bishops) < 2:\n                return 0.0\n            attacked = set()\n            for b_sq in bishops:\n                # accumulate attacked squares by considering rays (approx using board.attackers by flipping color and checking)\n                # use board.attackers to see which squares attack the bishop? Instead iterate all squares and test sliding reach via ray\n                # Simpler: count legal attack squares by generating pseudo moves: iterate all squares and if bishop can move there (ignoring turn) detect via ray\n                bf = chess.square_file(b_sq); br = chess.square_rank(b_sq)\n                for df in (-1,1):\n                    for dr in (-1,1):\n                        f = bf + df; r = br + dr\n                        while 0 <= f <= 7 and 0 <= r <= 7:\n                            attacked.add(chess.square(f, r))\n                            if board.piece_at(chess.square(f, r)) is not None:\n                                break\n                            f += df; r += dr\n            # count those in opponent half\n            half_count = 0\n            for sq in attacked:\n                r = chess.square_rank(sq)\n                if color == chess.WHITE and r >= 4:\n                    half_count += 1\n                if color == chess.BLACK and r <= 3:\n                    half_count += 1\n            # normalize by max possible attacked squares roughly 26 (2 bishops can reach many squares) -> keep safe divisor\n            return float(half_count) / 26.0\n        return float(bishop_activity(chess.WHITE) - bishop_activity(chess.BLACK))\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Rooks on enemy seventh rank (white rooks on rank 7, black rooks on rank 2) weighted by number of enemy pawns they attack (white - black)'\n    try:\n        pm = board.piece_map()\n        def seventh_score(color):\n            score = 0.0\n            target_rank = 6 if color == chess.WHITE else 1\n            enemy = not color\n            for sq,p in pm.items():\n                if not p or p.color != color or p.piece_type != chess.ROOK:\n                    continue\n                if chess.square_rank(sq) != target_rank:\n                    continue\n                # count attacked enemy pawns\n                attacks = board.attackers(color, sq)\n                pawn_attacks = 0\n                for a in attacks:\n                    ap = board.piece_at(a)\n                    if ap and ap.piece_type == chess.PAWN and ap.color == enemy:\n                        pawn_attacks += 1\n                score += 1.0 + 0.3 * pawn_attacks\n            return score\n        return float(seventh_score(chess.WHITE) - seventh_score(chess.BLACK))\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Pinned-piece weighted count: sum of values of pieces pinned to their king (black pinned_value - white pinned_value); positive favors White when opponent pinned more'\n    try:\n        vals = {chess.PAWN:1.0, chess.KNIGHT:3.0, chess.BISHOP:3.0, chess.ROOK:5.0, chess.QUEEN:9.0, chess.KING:0.0}\n        pm = board.piece_map()\n        # helper to detect pinned pieces using alignment with own king and enemy sliding piece\n        def pinned_value_for(color):\n            total = 0.0\n            king_sq = next((sq for sq,p in pm.items() if p and p.piece_type == chess.KING and p.color == color), None)\n            if king_sq is None:\n                return 0.0\n            # enemy sliding pieces\n            enemy = not color\n            enemy_sliders = [sq for sq,p in pm.items() if p and p.color == enemy and p.piece_type in (chess.ROOK, chess.BISHOP, chess.QUEEN)]\n            for slider_sq in enemy_sliders:\n                kf = chess.square_file(king_sq); kr = chess.square_rank(king_sq)\n                sf = chess.square_file(slider_sq); sr = chess.square_rank(slider_sq)\n                df = sf - kf; dr = sr - kr\n                # must be aligned\n                step_f = 0 if df == 0 else (1 if df > 0 else -1)\n                step_r = 0 if dr == 0 else (1 if dr > 0 else -1)\n                if not (df == 0 or dr == 0 or abs(df) == abs(dr)):\n                    continue\n                # walk from king to slider and count intervening pieces\n                f = kf + step_f; r = kr + step_r\n                intervening = []\n                while 0 <= f <= 7 and 0 <= r <= 7:\n                    sq = chess.square(f, r)\n                    if sq == slider_sq:\n                        break\n                    if board.piece_at(sq) is not None:\n                        intervening.append((sq, board.piece_at(sq)))\n                    f += step_f; r += step_r\n                # pinned if exactly one intervening piece and it belongs to color\n                if len(intervening) == 1:\n                    sqi, pi = intervening[0]\n                    if pi and pi.color == color:\n                        total += vals.get(pi.piece_type, 0.0)\n            return total\n        # The feature should favor the side with fewer pinned pieces -> return (black_pinned - white_pinned)\n        bp = pinned_value_for(chess.BLACK)\n        wp = pinned_value_for(chess.WHITE)\n        return float(bp - wp)\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Central control: net control of central squares (d4,e4,d5,e5) measured as (white_attackers - black_attackers) normalized, positive favors White'\n    try:\n        centers = [chess.parse_square(s) for s in ('d4','e4','d5','e5')]\n        total = 0.0\n        for sq in centers:\n            aw = len(board.attackers(chess.WHITE, sq))\n            ab = len(board.attackers(chess.BLACK, sq))\n            total += float(aw - ab)\n        # max possible roughly maybe 20, normalize to keep scale small\n        return float(total) / 8.0\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Pawn-structure defects: sum of doubled+isolated pawn counts (black_defects - white_defects), positive favors White (fewer white defects)'\n    try:\n        pm = board.piece_map()\n        files_pawns = {f:{chess.WHITE:0, chess.BLACK:0} for f in range(8)}\n        for sq,p in pm.items():\n            if p and p.piece_type == chess.PAWN:\n                f = chess.square_file(sq)\n                files_pawns[f][p.color] += 1\n        def defects(color):\n            d = 0.0\n            # doubled pawns\n            for f in range(8):\n                if files_pawns[f][color] > 1:\n                    d += float(files_pawns[f][color] - 1) * 1.0\n            # isolated pawns: no friendly pawns on adjacent files\n            for f in range(8):\n                if files_pawns[f][color] == 0:\n                    continue\n                adj = 0\n                if f-1 >= 0:\n                    adj += files_pawns[f-1][color]\n                if f+1 <= 7:\n                    adj += files_pawns[f+1][color]\n                if adj == 0:\n                    d += float(files_pawns[f][color]) * 1.2\n            return d\n        wd = defects(chess.WHITE)\n        bd = defects(chess.BLACK)\n        return float(bd - wd)\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'King-zone pressure: (white pressure on black king zone) - (black pressure on white king zone), pressure weights attacker pieces by piece value'\n    try:\n        vals = {chess.PAWN:0.7, chess.KNIGHT:2.7, chess.BISHOP:2.7, chess.ROOK:4.6, chess.QUEEN:8.5, chess.KING:0.0}\n        pm = board.piece_map()\n        def zone_pressure(king_color, attacker_color):\n            king_sq = next((sq for sq,p in pm.items() if p and p.piece_type == chess.KING and p.color == king_color), None)\n            if king_sq is None:\n                return 0.0\n            kf = chess.square_file(king_sq); kr = chess.square_rank(king_sq)\n            # king zone = king square + surrounding 8 squares\n            zone = []\n            for df in (-1,0,1):\n                for dr in (-1,0,1):\n                    f = kf + df; r = kr + dr\n                    if 0 <= f <= 7 and 0 <= r <= 7:\n                        zone.append(chess.square(f, r))\n            pressure = 0.0\n            for sq in zone:\n                for attacker_sq in board.attackers(attacker_color, sq):\n                    ap = board.piece_at(attacker_sq)\n                    if ap:\n                        pressure += vals.get(ap.piece_type, 0.0)\n            return pressure\n        w_on_b = zone_pressure(chess.BLACK, chess.WHITE)\n        b_on_w = zone_pressure(chess.WHITE, chess.BLACK)\n        return float(w_on_b - b_on_w)\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'King centralization benefit in endgames: (white_score - black_score) where score = central proximity * endgame factor; favors centralized king in low-material positions'\n    try:\n        pm = board.piece_map()\n        def material_excluding_kings():\n            s = 0.0\n            vals = {chess.PAWN:1.0, chess.KNIGHT:3.0, chess.BISHOP:3.0, chess.ROOK:5.0, chess.QUEEN:9.0}\n            for p in pm.values():\n                if p and p.piece_type in vals:\n                    s += vals[p.piece_type]\n            return s\n        total_mat = material_excluding_kings()\n        endgame_factor = max(0.0, 1.0 - total_mat / 28.0)  # 0..1, larger when less material\n        def king_center_score(color):\n            king_sq = next((sq for sq,p in pm.items() if p and p.piece_type == chess.KING and p.color == color), None)\n            if king_sq is None:\n                return 0.0\n            # center point between d4/e5 area -> treat center at (3.5,3.5)\n            kf = float(chess.square_file(king_sq)); kr = float(chess.square_rank(king_sq))\n            cx = 3.5; cy = 3.5\n            dist = ((kf - cx)**2 + (kr - cy)**2)**0.5\n            # maximum possible distance on board diagonal ~ sqrt((3.5)^2+(3.5)^2) ~ 4.95 -> use 5.0 for normalization\n            proximity = max(0.0, 1.0 - dist / 5.0)\n            return proximity * endgame_factor\n        return float(king_center_score(chess.WHITE) - king_center_score(chess.BLACK))\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Heavy-piece imbalance relevance: (white_heavy - black_heavy) scaled by how simplified the position is (more weight in simplified positions)'\n    try:\n        pm = board.piece_map()\n        white_heavy = 0.0; black_heavy = 0.0\n        for p in pm.values():\n            if not p:\n                continue\n            if p.piece_type == chess.ROOK:\n                val = 1.0\n            elif p.piece_type == chess.QUEEN:\n                val = 1.8\n            else:\n                val = 0.0\n            if val == 0.0:\n                continue\n            if p.color == chess.WHITE:\n                white_heavy += val\n            else:\n                black_heavy += val\n        # simplification factor based on total minor pieces (knights+bishops)\n        minors = sum(1 for p in pm.values() if p and p.piece_type in (chess.KNIGHT, chess.BISHOP))\n        simpl_factor = 1.0 - min(1.0, minors / 8.0)  # more simplified (fewer minors) -> closer to 1\n        return float((white_heavy - black_heavy) * simpl_factor)\n    except Exception:\n        return 0.0\n",
    "def feature(board: chess.Board) -> float:\n    'King pawn-shield safety: difference of pawn-shield score in front of kings (White - Black); 1.0 per pawn in typical shield squares, -0.5 per enemy pawn/open file'\n    try:\n        pm = board.piece_map()\n        def king_shield_score(color):\n            # find king\n            king_sq = next((sq for sq,p in pm.items() if p and p.piece_type == chess.KING and p.color == color), None)\n            if king_sq is None:\n                return 0.0\n            kf = chess.square_file(king_sq)\n            kr = chess.square_rank(king_sq)\n            score = 0.0\n            forward = 1 if color == chess.WHITE else -1\n            # typical pawn-shield squares are one rank in front and two files wide plus the next rank\n            for df in (-1, 0, 1):\n                for dr in (1,):\n                    f = kf + df\n                    r = kr + forward * dr\n                    if 0 <= f < 8 and 0 <= r < 8:\n                        sq = chess.square(f, r)\n                        p = board.piece_at(sq)\n                        if p and p.piece_type == chess.PAWN and p.color == color:\n                            score += 1.0\n                        elif p is None:\n                            score -= 0.25\n                        else:\n                            # enemy pawn in shield area penalizes\n                            if p.piece_type == chess.PAWN and p.color != color:\n                                score -= 0.5\n            # also reward pawns two ranks out (additional cover)\n            for df in (-1,0,1):\n                f = kf + df\n                r = kr + forward * 2\n                if 0 <= f < 8 and 0 <= r < 8:\n                    sq = chess.square(f, r)\n                    p = board.piece_at(sq)\n                    if p and p.piece_type == chess.PAWN and p.color == color:\n                        score += 0.5\n            # penalize open file of king: if there is a rook on same file of opponent and no pawn between -> subtract\n            opp = chess.BLACK if color == chess.WHITE else chess.WHITE\n            # find any opponent rook on same file\n            for sq,p in pm.items():\n                if p and p.piece_type == chess.ROOK and p.color == opp and chess.square_file(sq) == kf:\n                    # check pieces between\n                    rf = kf\n                    start = min(chess.square_rank(sq), kr)+1\n                    end = max(chess.square_rank(sq), kr)\n                    blocked = False\n                    for r in range(start, end):\n                        if board.piece_at(chess.square(rf, r)):\n                            blocked = True; break\n                    if not blocked:\n                        score -= 1.0\n            return score\n        return float(king_shield_score(chess.WHITE) - king_shield_score(chess.BLACK))\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Passed pawns advancement: sum of passed pawn advancement (ranks advanced) (White - Black), higher positive favors White'\n    try:\n        pm = board.piece_map()\n        def is_passed(sq, color):\n            f = chess.square_file(sq); r = chess.square_rank(sq)\n            opp = chess.BLACK if color == chess.WHITE else chess.WHITE\n            if color == chess.WHITE:\n                # no opposing pawns on same file or adjacent files on ranks > r\n                for f2 in (f-1, f, f+1):\n                    if 0 <= f2 < 8:\n                        for rr in range(r+1, 8):\n                            p = board.piece_at(chess.square(f2, rr))\n                            if p and p.piece_type == chess.PAWN and p.color == opp:\n                                return False\n                return True\n            else:\n                for f2 in (f-1, f, f+1):\n                    if 0 <= f2 < 8:\n                        for rr in range(0, r):\n                            p = board.piece_at(chess.square(f2, rr))\n                            if p and p.piece_type == chess.PAWN and p.color == opp:\n                                return False\n                return True\n        score_w = 0.0; score_b = 0.0\n        for sq,p in pm.items():\n            if not p or p.piece_type != chess.PAWN:\n                continue\n            if is_passed(sq, p.color):\n                r = chess.square_rank(sq)\n                if p.color == chess.WHITE:\n                    score_w += float(r)  # rank 0..7, higher is more advanced\n                else:\n                    score_b += float(7 - r)\n        return float(score_w - score_b)\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Centralization of active pieces: average inverse distance to center for knights, bishops, rooks, queens (White - Black)'\n    try:\n        pm = board.piece_map()\n        types = (chess.KNIGHT, chess.BISHOP, chess.ROOK, chess.QUEEN)\n        center_sq_coords = [(3,3),(3,4),(4,3),(4,4)]\n        center_indices = [chess.square(f, r) for f,r in center_sq_coords]\n        def inv_center_dist(sq):\n            # maximum Manhattan distance to center squares is 7? use square_distance to nearest center square\n            d = min(chess.square_distance(sq, c) for c in center_indices)\n            # map to inverse closeness: closer -> larger\n            return (1.0 - (d / 7.0))\n        sums = {chess.WHITE:0.0, chess.BLACK:0.0}\n        counts = {chess.WHITE:0, chess.BLACK:0}\n        for sq,p in pm.items():\n            if not p or p.piece_type not in types:\n                continue\n            sums[p.color] += inv_center_dist(sq)\n            counts[p.color] += 1\n        avg_w = sums[chess.WHITE] / counts[chess.WHITE] if counts[chess.WHITE] > 0 else 0.0\n        avg_b = sums[chess.BLACK] / counts[chess.BLACK] if counts[chess.BLACK] > 0 else 0.0\n        return float(avg_w - avg_b)\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Hanging pieces vulnerability: sum of values of pieces that are attacked and undefended (White - Black)'\n    try:\n        vals = {chess.PAWN:1.0, chess.KNIGHT:3.0, chess.BISHOP:3.0, chess.ROOK:5.0, chess.QUEEN:9.0, chess.KING:0.0}\n        pm = board.piece_map()\n        score_w = 0.0; score_b = 0.0\n        for sq,p in pm.items():\n            if not p:\n                continue\n            own = p.color\n            opp = chess.BLACK if own == chess.WHITE else chess.WHITE\n            attackers = board.attackers(opp, sq)\n            defenders = board.attackers(own, sq)\n            if len(attackers) > 0 and len(defenders) == 0:\n                if own == chess.WHITE:\n                    score_w -= vals.get(p.piece_type,0.0)  # white has hanging piece => bad for white\n                else:\n                    score_b -= vals.get(p.piece_type,0.0)\n        # we want positive when White is better, so compute -(white_hang) - ( - black_hang )? The above produced negative for hanging; invert\n        return float((-score_w) - (-score_b))\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'King ring attack pressure: sum of attacker piece-values targeting squares adjacent to enemy king (White - Black)'\n    try:\n        vals = {chess.PAWN:0.8, chess.KNIGHT:2.5, chess.BISHOP:2.8, chess.ROOK:4.5, chess.QUEEN:7.5, chess.KING:0.0}\n        pm = board.piece_map()\n        def ring_attack_sum(attacker_color):\n            total = 0.0\n            opp_color = chess.BLACK if attacker_color == chess.WHITE else chess.WHITE\n            # find opponent king\n            king_sq = next((sq for sq,p in pm.items() if p and p.piece_type == chess.KING and p.color == opp_color), None)\n            if king_sq is None:\n                return 0.0\n            kf = chess.square_file(king_sq); kr = chess.square_rank(king_sq)\n            # iterate ring squares\n            for df in (-1,0,1):\n                for dr in (-1,0,1):\n                    if df == 0 and dr == 0:\n                        continue\n                    f = kf + df; r = kr + dr\n                    if 0 <= f < 8 and 0 <= r < 8:\n                        sq = chess.square(f, r)\n                        atks = board.attackers(attacker_color, sq)\n                        for at_sq in atks:\n                            piece = board.piece_at(at_sq)\n                            if piece:\n                                total += vals.get(piece.piece_type, 0.0)\n            return total\n        w_on_b = ring_attack_sum(chess.WHITE)\n        b_on_w = ring_attack_sum(chess.BLACK)\n        return float(w_on_b - b_on_w)\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Passed-pawn race king proximity: for each passed pawn add (opponent king distance - own king distance), sum (White - Black)'\n    try:\n        pm = board.piece_map()\n        # identify kings\n        wk = next((sq for sq,p in pm.items() if p and p.piece_type == chess.KING and p.color == chess.WHITE), None)\n        bk = next((sq for sq,p in pm.items() if p and p.piece_type == chess.KING and p.color == chess.BLACK), None)\n        if wk is None or bk is None:\n            return 0.0\n        def is_passed(sq, color):\n            f = chess.square_file(sq); r = chess.square_rank(sq)\n            opp = chess.BLACK if color == chess.WHITE else chess.WHITE\n            if color == chess.WHITE:\n                for f2 in (f-1,f,f+1):\n                    if 0 <= f2 < 8:\n                        for rr in range(r+1,8):\n                            p = board.piece_at(chess.square(f2,rr))\n                            if p and p.piece_type == chess.PAWN and p.color == opp:\n                                return False\n                return True\n            else:\n                for f2 in (f-1,f,f+1):\n                    if 0 <= f2 < 8:\n                        for rr in range(0,r):\n                            p = board.piece_at(chess.square(f2,rr))\n                            if p and p.piece_type == chess.PAWN and p.color == opp:\n                                return False\n                return True\n        score_w = 0.0; score_b = 0.0\n        for sq,p in pm.items():\n            if not p or p.piece_type != chess.PAWN:\n                continue\n            if not is_passed(sq, p.color):\n                continue\n            if p.color == chess.WHITE:\n                d_own = chess.square_distance(wk, sq)\n                d_opp = chess.square_distance(bk, sq)\n                score_w += float(d_opp - d_own)\n            else:\n                d_own = chess.square_distance(bk, sq)\n                d_opp = chess.square_distance(wk, sq)\n                score_b += float(d_opp - d_own)\n        return float(score_w - score_b)\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Bishop pair and activity adjusted by pawn density: (White - Black), favors bishops more on open boards'\n    try:\n        pm = board.piece_map()\n        total_pawns = sum(1 for p in pm.values() if p and p.piece_type == chess.PAWN)\n        pawn_density = total_pawns / 16.0 if total_pawns >= 0 else 1.0\n        # helper: squares attacked by bishops\n        def bishop_activity(color):\n            activity = 0.0\n            for sq,p in pm.items():\n                if not p or p.piece_type != chess.BISHOP or p.color != color:\n                    continue\n                # count squares this bishop attacks by checking for which squares this bishop appears in attackers\n                attacked = 0\n                for s in range(64):\n                    # only consider squares not occupied by same color (captures or empty)\n                    occ = board.piece_at(s)\n                    if occ and occ.color == color:\n                        continue\n                    atks = board.attackers(color, s)\n                    if sq in atks:\n                        attacked += 1\n                activity += attacked\n            # bishop pair bonus\n            num_bishops = sum(1 for p in pm.values() if p and p.piece_type == chess.BISHOP and p.color == color)\n            pair_bonus = 1.0 if num_bishops >= 2 else 0.0\n            # on open boards, activity matters more\n            openness = 1.0 - min(1.0, pawn_density)\n            return pair_bonus * 1.0 + (activity / 28.0) * openness  # 28 is an approx max useful attacked squares\n        return float(bishop_activity(chess.WHITE) - bishop_activity(chess.BLACK))\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Queen activity: total number of distinct enemy-or-empty squares attacked by queens normalized (White - Black)'\n    try:\n        pm = board.piece_map()\n        def queen_attack_count(color):\n            cnt = 0\n            for sq,p in pm.items():\n                if not p or p.piece_type != chess.QUEEN or p.color != color:\n                    continue\n                seen = 0\n                for s in range(64):\n                    occ = board.piece_at(s)\n                    if occ and occ.color == color:\n                        continue\n                    atks = board.attackers(color, s)\n                    if sq in atks:\n                        seen += 1\n                cnt += seen\n            return float(cnt)\n        qa_w = queen_attack_count(chess.WHITE)\n        qa_b = queen_attack_count(chess.BLACK)\n        # normalize by typical mobility scale\n        norm = max(1.0, qa_w + qa_b)\n        return float((qa_w - qa_b) / norm * (qa_w + qa_b) / 32.0)\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Rooks aligned with enemy king without interposing pieces: count of such rooks (White - Black), indicates penetration potential'\n    try:\n        pm = board.piece_map()\n        def count_alignment(color):\n            cnt = 0.0\n            opp = chess.BLACK if color == chess.WHITE else chess.WHITE\n            king_sq = next((sq for sq,p in pm.items() if p and p.piece_type == chess.KING and p.color == opp), None)\n            if king_sq is None:\n                return 0.0\n            kf = chess.square_file(king_sq); kr = chess.square_rank(king_sq)\n            for sq,p in pm.items():\n                if not p or p.piece_type != chess.ROOK or p.color != color:\n                    continue\n                rf = chess.square_file(sq); rr = chess.square_rank(sq)\n                if rf == kf:\n                    start = min(rr, kr) + 1; end = max(rr, kr)\n                    blocked = False\n                    for r in range(start, end):\n                        if board.piece_at(chess.square(rf, r)):\n                            blocked = True; break\n                    if not blocked:\n                        cnt += 1.0\n                elif rr == kr:\n                    start = min(rf, kf) + 1; end = max(rf, kf)\n                    blocked = False\n                    for f in range(start, end):\n                        if board.piece_at(chess.square(f, rr)):\n                            blocked = True; break\n                    if not blocked:\n                        cnt += 1.0\n            return cnt\n        return float(count_alignment(chess.WHITE) - count_alignment(chess.BLACK))\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Pawn structure penalty aggregate: (doubled + isolated) pawns penalty (Black - White) so positive favors White when lower black penalty'\n    try:\n        pm = board.piece_map()\n        def pawn_penalty(color):\n            files = {i:[] for i in range(8)}\n            for sq,p in pm.items():\n                if p and p.piece_type == chess.PAWN and p.color == color:\n                    files[chess.square_file(sq)].append(chess.square_rank(sq))\n            doubled = 0\n            isolated = 0\n            for f in range(8):\n                if len(files[f]) > 1:\n                    doubled += (len(files[f]) - 1)\n                # isolated if no friendly pawns on adjacent files\n                if len(files[f]) > 0:\n                    adjacent = False\n                    for af in (f-1, f+1):\n                        if 0 <= af < 8 and len(files[af]) > 0:\n                            adjacent = True; break\n                    if not adjacent:\n                        isolated += len(files[f])\n            # penalty weighted: doubled heavier than isolated\n            return float(doubled * 1.0 + isolated * 0.6)\n        pen_w = pawn_penalty(chess.WHITE)\n        pen_b = pawn_penalty(chess.BLACK)\n        # return Black penalty minus White penalty so positive favors White (less black penalty)\n        return float(pen_b - pen_w)\n    except Exception:\n        return 0.0\n",
    "def feature(board: chess.Board) -> float:\n    'Pawn shield integrity: counts friendly pawns directly shielding each king (3-file window, up to 2 ranks in front) (white - black)'\n    try:\n        pm = board.piece_map()\n        def king_shield(color):\n            # find king\n            ks = next((sq for sq,p in pm.items() if p and p.piece_type==chess.KING and p.color==color), None)\n            if ks is None:\n                return 0.0\n            kf = chess.square_file(ks); kr = chess.square_rank(ks)\n            cnt = 0.0\n            # For white, shield pawns should be on ranks kr+1 and kr+2; for black kr-1 and kr-2\n            steps = [1,2] if color == chess.WHITE else [-1,-2]\n            for df in (-1,0,1):\n                for s in steps:\n                    rf = kr + s\n                    ff = kf + df\n                    if 0 <= rf <= 7 and 0 <= ff <= 7:\n                        sq = chess.square(ff, rf)\n                        p = pm.get(sq)\n                        if p and p.piece_type == chess.PAWN and p.color == color:\n                            cnt += 1.0\n            return cnt\n        return float(king_shield(chess.WHITE) - king_shield(chess.BLACK))\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Bishop pair and diagonal mobility: bonus for having two bishops and for long unobstructed diagonals (white - black)'\n    try:\n        pm = board.piece_map()\n        vals = {chess.BISHOP:1.0}\n        def bishop_score(color):\n            score = 0.0\n            for sq,p in pm.items():\n                if not p or p.piece_type != chess.BISHOP or p.color != color:\n                    continue\n                # bishop alive\n                score += 0.9\n                # diagonal reach: count empty squares along four diagonals until first blocker\n                reach = 0\n                for df, dr in ((1,1),(1,-1),(-1,1),(-1,-1)):\n                    ff = chess.square_file(sq); rr = chess.square_rank(sq)\n                    nf = ff + df; nr = rr + dr\n                    while 0 <= nf <= 7 and 0 <= nr <= 7:\n                        s2 = chess.square(nf, nr)\n                        if board.piece_at(s2) is None:\n                            reach += 1\n                        else:\n                            # can still capture but blocked beyond\n                            reach += 0\n                            break\n                        nf += df; nr += dr\n                score += 0.08 * reach\n            # bishop pair bonus\n            cnt = sum(1 for p in pm.values() if p and p.piece_type==chess.BISHOP and p.color==color)\n            if cnt >= 2:\n                score += 0.7\n            return score\n        return float(bishop_score(chess.WHITE) - bishop_score(chess.BLACK))\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Pawn-structure weaknesses: penalizes isolated, doubled, and backward pawns (white - black, negative is worse for White)'\n    try:\n        pm = board.piece_map()\n        pawns_by_file = {f: {chess.WHITE: [], chess.BLACK: []} for f in range(8)}\n        for sq,p in pm.items():\n            if p and p.piece_type == chess.PAWN:\n                pawns_by_file[chess.square_file(sq)][p.color].append(sq)\n        def pawn_weakness(color):\n            iso = 0.0; doubled = 0.0; backward = 0.0\n            enemy = not color\n            for f in range(8):\n                file_pawns = pawns_by_file[f][color]\n                # doubled: more than one pawn on file\n                if len(file_pawns) > 1:\n                    doubled += float(len(file_pawns) - 1)\n                for sq in file_pawns:\n                    rf = chess.square_rank(sq)\n                    # isolated: no friendly pawns on adjacent files\n                    adj_files = []\n                    if f-1 >= 0: adj_files.append(f-1)\n                    if f+1 <= 7: adj_files.append(f+1)\n                    has_adj = any(len(pawns_by_file[af][color]) > 0 for af in adj_files)\n                    if not has_adj:\n                        iso += 1.0\n                    # backward: no friendly pawn on adjacent files that is ahead (for white) / behind (for black)\n                    has_support_ahead = False\n                    for af in adj_files:\n                        for asq in pawns_by_file[af][color]:\n                            ar = chess.square_rank(asq)\n                            if color == chess.WHITE and ar > rf:\n                                has_support_ahead = True\n                            if color == chess.BLACK and ar < rf:\n                                has_support_ahead = True\n                    if not has_support_ahead:\n                        # check if square in front is controlled by enemy (makes it harder to advance)\n                        front_r = rf + (1 if color == chess.WHITE else -1)\n                        if 0 <= front_r <= 7:\n                            front_sq = chess.square(f, front_r)\n                            if board.is_attacked_by(enemy, front_sq):\n                                backward += 1.0\n            # weights: isolated=1.0, doubled=0.6, backward=0.9\n            return -(iso * 1.0 + doubled * 0.6 + backward * 0.9)\n        return float(pawn_weakness(chess.WHITE) - pawn_weakness(chess.BLACK))\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Central control weighted by attacker piece values on d4,e4,d5,e5 (white - black)'\n    try:\n        centers = [chess.parse_square(s) for s in ('d4','e4','d5','e5')]\n        vals = {chess.PAWN:1.0, chess.KNIGHT:3.0, chess.BISHOP:3.0, chess.ROOK:5.0, chess.QUEEN:9.0, chess.KING:0.0}\n        score = {chess.WHITE:0.0, chess.BLACK:0.0}\n        for sq in centers:\n            for color in (chess.WHITE, chess.BLACK):\n                attackers = board.attackers(color, sq)\n                for a in attackers:\n                    p = board.piece_at(a)\n                    if p:\n                        score[color] += vals.get(p.piece_type, 0.0)\n        return float(score[chess.WHITE] - score[chess.BLACK])\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Open and semi-open file control by heavy pieces (rooks/queens) (white - black)'\n    try:\n        pm = board.piece_map()\n        # determine files with pawns and which color\n        files_info = {f: {chess.WHITE:0, chess.BLACK:0, 'total':0} for f in range(8)}\n        for sq,p in pm.items():\n            if p and p.piece_type == chess.PAWN:\n                f = chess.square_file(sq)\n                files_info[f][p.color] += 1\n                files_info[f]['total'] += 1\n        def file_control_score(color):\n            s = 0.0\n            for sq,p in pm.items():\n                if not p or p.color != color or p.piece_type not in (chess.ROOK, chess.QUEEN):\n                    continue\n                f = chess.square_file(sq)\n                if files_info[f]['total'] == 0:\n                    s += 1.0  # open file\n                elif files_info[f][color] == 0:\n                    s += 0.6  # semi-open (opponent pawns only)\n                else:\n                    s += 0.0\n            return s\n        return float(file_control_score(chess.WHITE) - file_control_score(chess.BLACK))\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Hanging high-value pieces safety: total safe value (pieces minus hanging penalties) (white - black)'\n    try:\n        pm = board.piece_map()\n        vals = {chess.PAWN:1.0, chess.KNIGHT:3.0, chess.BISHOP:3.0, chess.ROOK:5.0, chess.QUEEN:9.0, chess.KING:0.0}\n        def safe_value(color):\n            total = 0.0\n            penalty = 0.0\n            for sq,p in pm.items():\n                if not p or p.color != color:\n                    continue\n                v = vals.get(p.piece_type, 0.0)\n                total += v\n                enemy = not color\n                attackers = len(board.attackers(enemy, sq))\n                defenders = len(board.attackers(color, sq))\n                if attackers > defenders:\n                    # penalize proportionally to value and excess attackers\n                    penalty += v * (attackers - defenders) * 0.5\n            return total - penalty\n        return float(safe_value(chess.WHITE) - safe_value(chess.BLACK))\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Tactical initiative: number of legal capture or checking moves available (white - black)'\n    try:\n        orig = board.turn\n        try:\n            tactical = {chess.WHITE:0.0, chess.BLACK:0.0}\n            for color in (chess.WHITE, chess.BLACK):\n                board.turn = color\n                for mv in board.legal_moves:\n                    if board.is_capture(mv):\n                        tactical[color] += 1.0\n                    else:\n                        # check if the move gives check by making the move on a copy-less simulation:\n                        # perform the move on the board (safe since we restore turn each time)\n                        try:\n                            board.push(mv)\n                            if board.is_check():\n                                tactical[color] += 1.0\n                            board.pop()\n                        except Exception:\n                            # in case push/pop fails, ignore\n                            pass\n            return float(tactical[chess.WHITE] - tactical[chess.BLACK])\n        finally:\n            board.turn = orig\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Connected passed pawns: counts passed pawns that have an allied passed pawn on an adjacent file, weighted by advancement (white - black)'\n    try:\n        pm = board.piece_map()\n        white_pawns = [sq for sq,p in pm.items() if p and p.piece_type==chess.PAWN and p.color==chess.WHITE]\n        black_pawns = [sq for sq,p in pm.items() if p and p.piece_type==chess.PAWN and p.color==chess.BLACK]\n        def is_passed(sq, color, opp_pawns):\n            f = chess.square_file(sq); r = chess.square_rank(sq)\n            if color == chess.WHITE:\n                for bp in opp_pawns:\n                    bf = chess.square_file(bp); br = chess.square_rank(bp)\n                    if abs(bf - f) <= 1 and br > r:\n                        return False\n                return True\n            else:\n                for wp in opp_pawns:\n                    wf = chess.square_file(wp); wr = chess.square_rank(wp)\n                    if abs(wf - f) <= 1 and wr < r:\n                        return False\n                return True\n        def connected_score(color):\n            my = white_pawns if color == chess.WHITE else black_pawns\n            opp = black_pawns if color == chess.WHITE else white_pawns\n            passed = set(sq for sq in my if is_passed(sq, color, opp))\n            score = 0.0\n            for sq in passed:\n                f = chess.square_file(sq); r = chess.square_rank(sq)\n                # check adjacent files for passed pawn\n                adj = False\n                for af in (f-1, f+1):\n                    if 0 <= af <= 7:\n                        for psq in passed:\n                            if chess.square_file(psq) == af:\n                                adj = True; break\n                        if adj:\n                            break\n                if adj:\n                    # advancement weight: more advanced is stronger\n                    weight = 1.0 + (r/7.0 if color==chess.WHITE else (7 - r)/7.0)\n                    score += weight\n            return score\n        return float(connected_score(chess.WHITE) - connected_score(chess.BLACK))\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Minor piece centralization: favor knights and bishops closer to board center (white - black)'\n    try:\n        pm = board.piece_map()\n        center_x = 3.5; center_y = 3.5\n        def centrality(sq):\n            f = chess.square_file(sq); r = chess.square_rank(sq)\n            dx = (f - center_x); dy = (r - center_y)\n            dist = (dx*dx + dy*dy) ** 0.5\n            # centrality score positive when closer; max distance ~4.95 so normalize\n            return max(0.0, 5.0 - dist)\n        def score(color):\n            s = 0.0\n            for sq,p in pm.items():\n                if not p or p.color != color or p.piece_type not in (chess.KNIGHT, chess.BISHOP):\n                    continue\n                s += centrality(sq)\n            return s\n        return float(score(chess.WHITE) - score(chess.BLACK))\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Endgame king centralization scaled by low non-pawn material: rewards central kings in endgames (white - black)'\n    try:\n        pm = board.piece_map()\n        vals = {chess.KNIGHT:3.0, chess.BISHOP:3.0, chess.ROOK:5.0, chess.QUEEN:9.0}\n        nonpawn_material = 0.0\n        for p in pm.values():\n            if p and p.piece_type in vals:\n                nonpawn_material += vals[p.piece_type]\n        # scale factor 0..1 where 1 means very low material (<=4), 0 means high material (>=20)\n        scale = 0.0\n        if nonpawn_material <= 4.0:\n            scale = 1.0\n        elif nonpawn_material >= 20.0:\n            scale = 0.0\n        else:\n            scale = max(0.0, 1.0 - (nonpawn_material - 4.0) / 16.0)\n        def king_centrality(color):\n            ks = next((sq for sq,p in pm.items() if p and p.piece_type==chess.KING and p.color==color), None)\n            if ks is None:\n                return 0.0\n            f = chess.square_file(ks); r = chess.square_rank(ks)\n            dx = abs(f - 3.5); dy = abs(r - 3.5)\n            dist = (dx*dx + dy*dy) ** 0.5\n            # central score higher when closer\n            return max(0.0, 5.0 - dist) * scale\n        return float(king_centrality(chess.WHITE) - king_centrality(chess.BLACK))\n    except Exception:\n        return 0.0\n",
    "def feature(board: chess.Board) -> float:\n    'Passed pawn progress: sum of advancement of passed pawns (white - black), 0..1 per pawn'\n    try:\n        pm = board.piece_map()\n        def is_passed(p_sq, color):\n            f = chess.square_file(p_sq); r = chess.square_rank(p_sq)\n            if color == chess.WHITE:\n                # no black pawn on same or adjacent files ahead of this pawn\n                for bf in (f-1, f, f+1):\n                    if 0 <= bf <= 7:\n                        for br in range(r+1, 8):\n                            p = pm.get(chess.square(bf, br))\n                            if p and p.piece_type == chess.PAWN and p.color == chess.BLACK:\n                                return False\n                return True\n            else:\n                for bf in (f-1, f, f+1):\n                    if 0 <= bf <= 7:\n                        for br in range(0, r):\n                            p = pm.get(chess.square(bf, br))\n                            if p and p.piece_type == chess.PAWN and p.color == chess.WHITE:\n                                return False\n                return True\n        white_score = 0.0; black_score = 0.0\n        for sq, p in pm.items():\n            if not p or p.piece_type != chess.PAWN:\n                continue\n            r = chess.square_rank(sq)\n            if is_passed(sq, p.color):\n                progress = float(r) / 7.0 if p.color == chess.WHITE else float(7 - r) / 7.0\n                if p.color == chess.WHITE:\n                    white_score += progress\n                else:\n                    black_score += progress\n        return float(white_score - black_score)\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Rook file quality: rooks on open file (1.0) or semi-open (0.5) weighted by advancement into opponent half (white - black)'\n    try:\n        pm = board.piece_map()\n        file_has_white = [0]*8\n        file_has_black = [0]*8\n        for sq,p in pm.items():\n            if p and p.piece_type == chess.PAWN:\n                file_has_white[chess.square_file(sq)] += (1 if p.color == chess.WHITE else 0)\n                file_has_black[chess.square_file(sq)] += (1 if p.color == chess.BLACK else 0)\n        def rook_score_for_color(color):\n            s = 0.0\n            for sq,p in pm.items():\n                if not p or p.piece_type != chess.ROOK or p.color != color:\n                    continue\n                f = chess.square_file(sq); r = chess.square_rank(sq)\n                open_file = (file_has_white[f] + file_has_black[f]) == 0\n                semi_open = (file_has_white[f] if color==chess.WHITE else file_has_black[f]) == 0 and not open_file\n                weight = 1.0 if open_file else (0.5 if semi_open else 0.0)\n                # advancement: rooks are better in opponent half\n                adv = (r / 7.0) if color == chess.WHITE else ((7 - r) / 7.0)\n                s += weight * (1.0 + 0.2 * adv)\n            return s\n        return float(rook_score_for_color(chess.WHITE) - rook_score_for_color(chess.BLACK))\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Local king safety balance: (defender_value - attacker_value) around each king (white - black)'\n    try:\n        vals = {chess.PAWN:1.0, chess.KNIGHT:3.0, chess.BISHOP:3.0, chess.ROOK:5.0, chess.QUEEN:9.0, chess.KING:0.0}\n        pm = board.piece_map()\n        wk = next((sq for sq,p in pm.items() if p and p.piece_type==chess.KING and p.color==chess.WHITE), None)\n        bk = next((sq for sq,p in pm.items() if p and p.piece_type==chess.KING and p.color==chess.BLACK), None)\n        if wk is None or bk is None:\n            return 0.0\n        def local_balance(king_sq, color):\n            # consider king square and 8-neighbors\n            kf = chess.square_file(king_sq); kr = chess.square_rank(king_sq)\n            att_val = 0.0; def_val = 0.0\n            for df in (-1,0,1):\n                for dr in (-1,0,1):\n                    f = kf + df; r = kr + dr\n                    if not (0 <= f <= 7 and 0 <= r <= 7):\n                        continue\n                    sq = chess.square(f, r)\n                    # attackers of this square by either color\n                    atk_by_enemy = board.attackers(1-color, sq)\n                    atk_by_friend = board.attackers(color, sq)\n                    for a in atk_by_enemy:\n                        p = board.piece_at(a)\n                        if p:\n                            att_val += vals.get(p.piece_type, 0.0)\n                    for a in atk_by_friend:\n                        p = board.piece_at(a)\n                        if p:\n                            def_val += vals.get(p.piece_type, 0.0)\n            return def_val - att_val\n        diff_w = local_balance(wk, chess.WHITE)\n        diff_b = local_balance(bk, chess.BLACK)\n        return float(diff_w - diff_b)\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Hanging pieces penalty: weighted sum of pieces attacked more times than defended (black_penalty - white_penalty), positive favors White'\n    try:\n        vals = {chess.PAWN:1.0, chess.KNIGHT:3.0, chess.BISHOP:3.0, chess.ROOK:5.0, chess.QUEEN:9.0, chess.KING:0.0}\n        pm = board.piece_map()\n        white_pen = 0.0; black_pen = 0.0\n        for sq,p in pm.items():\n            if not p:\n                continue\n            own = p.color\n            enemy = chess.BLACK if own == chess.WHITE else chess.WHITE\n            attackers = len(board.attackers(enemy, sq))\n            defenders = len(board.attackers(own, sq))\n            if attackers > defenders:\n                penalty = vals.get(p.piece_type, 0.0) * float(attackers - defenders)\n                if own == chess.WHITE:\n                    white_pen += penalty\n                else:\n                    black_pen += penalty\n        # return black_pen - white_pen so that positive means White is better (fewer hanging pieces)\n        return float(black_pen - white_pen)\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Pawn fragility (doubled + isolated) difference: (black_fragility - white_fragility), positive favors White'\n    try:\n        pm = board.piece_map()\n        file_counts_white = [0]*8\n        file_counts_black = [0]*8\n        pawn_sqs_white = []\n        pawn_sqs_black = []\n        for sq,p in pm.items():\n            if p and p.piece_type == chess.PAWN:\n                f = chess.square_file(sq)\n                if p.color == chess.WHITE:\n                    file_counts_white[f] += 1; pawn_sqs_white.append(sq)\n                else:\n                    file_counts_black[f] += 1; pawn_sqs_black.append(sq)\n        def frag_for_color(pawn_sqs, file_counts):\n            doubled = 0\n            isolated = 0\n            for sq in pawn_sqs:\n                f = chess.square_file(sq)\n                if file_counts[f] > 1:\n                    doubled += 1\n                # check adjacent files\n                adj = False\n                for af in (f-1, f+1):\n                    if 0 <= af <= 7 and file_counts[af] > 0:\n                        adj = True; break\n                if not adj:\n                    isolated += 1\n            return float(doubled + isolated)\n        frag_w = frag_for_color(pawn_sqs_white, file_counts_white)\n        frag_b = frag_for_color(pawn_sqs_black, file_counts_black)\n        return float(frag_b - frag_w)\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Knight outposts: knights on opponent half protected by a pawn and not attacked by enemy pawn (white - black)'\n    try:\n        pm = board.piece_map()\n        def count_outposts(color):\n            cnt = 0\n            for sq,p in pm.items():\n                if not p or p.piece_type != chess.KNIGHT or p.color != color:\n                    continue\n                r = chess.square_rank(sq)\n                if color == chess.WHITE and r < 4:\n                    continue\n                if color == chess.BLACK and r > 3:\n                    continue\n                attackers = board.attackers(color, sq)\n                # is there at least one friendly pawn attacking this square?\n                has_friendly_pawn_support = any((board.piece_at(a) and board.piece_at(a).piece_type==chess.PAWN and board.piece_at(a).color==color) for a in attackers)\n                # are there enemy pawns attacking this square?\n                enemy = chess.BLACK if color==chess.WHITE else chess.WHITE\n                enemy_pawn_attack = any((board.piece_at(a) and board.piece_at(a).piece_type==chess.PAWN and board.piece_at(a).color==enemy) for a in board.attackers(enemy, sq))\n                if has_friendly_pawn_support and not enemy_pawn_attack:\n                    cnt += 1\n            return cnt\n        return float(count_outposts(chess.WHITE) - count_outposts(chess.BLACK))\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Rooks on 7th rank count: white rooks on rank 7 (index 6) minus black rooks on rank 2 (index 1)'\n    try:\n        pm = board.piece_map()\n        w = 0; b = 0\n        for sq,p in pm.items():\n            if not p or p.piece_type != chess.ROOK:\n                continue\n            r = chess.square_rank(sq)\n            if p.color == chess.WHITE and r == 6:\n                w += 1\n            if p.color == chess.BLACK and r == 1:\n                b += 1\n        return float(w - b)\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Queen centralization: (black_dist - white_dist) where smaller distance to center is better for that side'\n    try:\n        import math\n        pm = board.piece_map()\n        def total_center_inverse(color):\n            s = 0.0\n            for sq,p in pm.items():\n                if p and p.piece_type == chess.QUEEN and p.color == color:\n                    f = chess.square_file(sq); r = chess.square_rank(sq)\n                    d = math.hypot(f - 3.5, r - 3.5)\n                    # invert so closer gives higher score; offset to keep positive\n                    s += max(0.0, 5.0 - d)\n            return s\n        return float(total_center_inverse(chess.WHITE) - total_center_inverse(chess.BLACK))\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Value-weighted piece activity: sum over non-pawn pieces of (piece_value * number_of_legal_moves_from_square) (white - black)'\n    try:\n        vals = {chess.KNIGHT:3.0, chess.BISHOP:3.0, chess.ROOK:5.0, chess.QUEEN:9.0, chess.KING:0.0, chess.PAWN:1.0}\n        orig = board.turn\n        try:\n            move_counts = {chess.WHITE: {}, chess.BLACK: {}}\n            for color in (chess.WHITE, chess.BLACK):\n                board.turn = color\n                for mv in board.legal_moves:\n                    sq = mv.from_square\n                    move_counts[color][sq] = move_counts[color].get(sq, 0) + 1\n            w_score = 0.0; b_score = 0.0\n            pm = board.piece_map()\n            for sq,p in pm.items():\n                if not p or p.piece_type == chess.PAWN:\n                    continue\n                mv_cnt = move_counts[p.color].get(sq, 0)\n                val = vals.get(p.piece_type, 0.0)\n                contrib = val * float(mv_cnt)\n                if p.color == chess.WHITE:\n                    w_score += contrib\n                else:\n                    b_score += contrib\n            # normalize by simple factor to keep numbers reasonable\n            norm = max(1.0, (w_score + b_score))\n            return float((w_score - b_score) / norm)\n        finally:\n            board.turn = orig\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Immediate tactical pressure: captures, checks, or promotions available summed for each side (white - black)'\n    try:\n        orig = board.turn\n        try:\n            score = {chess.WHITE:0.0, chess.BLACK:0.0}\n            for color in (chess.WHITE, chess.BLACK):\n                board.turn = color\n                for mv in board.legal_moves:\n                    s = 0.0\n                    # capture\n                    if board.is_capture(mv):\n                        s += 1.0\n                    # check - make a tentative push: use Board.gives_check(mv) if available, otherwise simulate\n                    try:\n                        if board.gives_check(mv):\n                            s += 1.2\n                    except Exception:\n                        # fallback: make move and test\n                        try:\n                            board_push = board.copy()\n                            board_push.push(mv)\n                            if board_push.is_check():\n                                s += 1.2\n                        except Exception:\n                            pass\n                    # promotion\n                    if mv.promotion is not None:\n                        s += 1.5\n                    score[color] += s\n            return float(score[chess.WHITE] - score[chess.BLACK])\n        finally:\n            board.turn = orig\n    except Exception:\n        return 0.0\n",
    "def feature(board: chess.Board) -> float:\n    'Passed pawn pressure: weighted sum of passed pawns proximity to promotion and whether they are protected (white - black)'\n    try:\n        pm = board.piece_map()\n        def is_passed(sq, color):\n            f = chess.square_file(sq)\n            r = chess.square_rank(sq)\n            opp = chess.BLACK if color == chess.WHITE else chess.WHITE\n            files = [ff for ff in (f-1, f, f+1) if 0 <= ff < 8]\n            if color == chess.WHITE:\n                for ff in files:\n                    for rr in range(r+1, 8):\n                        sq2 = chess.square(ff, rr)\n                        p2 = pm.get(sq2)\n                        if p2 and p2.piece_type == chess.PAWN and p2.color == opp:\n                            return False\n                return True\n            else:\n                for ff in files:\n                    for rr in range(0, r):\n                        sq2 = chess.square(ff, rr)\n                        p2 = pm.get(sq2)\n                        if p2 and p2.piece_type == chess.PAWN and p2.color == opp:\n                            return False\n                return True\n        vals = {chess.PAWN:1.0}\n        score_w = 0.0\n        score_b = 0.0\n        for sq, p in pm.items():\n            if not p or p.piece_type != chess.PAWN:\n                continue\n            f = chess.square_file(sq)\n            r = chess.square_rank(sq)\n            if is_passed(sq, p.color):\n                # closeness to promotion (closer -> larger)\n                if p.color == chess.WHITE:\n                    promot_dist = 7 - r\n                else:\n                    promot_dist = r\n                closeness = (8.0 - float(promot_dist)) / 8.0  # in (0..1]\n                # base weight increases with closeness\n                base = 1.0 + 2.0 * closeness\n                # support bonus if defended by own piece (including pawns)\n                defenders = board.attackers(p.color, sq)\n                support = 0.5 if any((pm.get(dp) and pm.get(dp).color == p.color) for dp in defenders) else 0.0\n                # bonus if more advanced (ranks)\n                adv_bonus = 0.2 * closeness\n                if p.color == chess.WHITE:\n                    score_w += base + support + adv_bonus\n                else:\n                    score_b += base + support + adv_bonus\n        return float(score_w - score_b)\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Pawn structure health: penalizes doubled, isolated pawns and many pawn islands (white - black), positive favors White structure'\n    try:\n        pm = board.piece_map()\n        def pawn_structure_penalty(color):\n            pawns_by_file = [0]*8\n            pawn_squares = []\n            for sq, p in pm.items():\n                if p and p.piece_type == chess.PAWN and p.color == color:\n                    f = chess.square_file(sq)\n                    pawns_by_file[f] += 1\n                    pawn_squares.append(sq)\n            doubled = sum(max(0, cnt-1) for cnt in pawns_by_file)\n            # isolated: pawn whose adjacent files have no friendly pawns\n            isolated = 0\n            for sq in pawn_squares:\n                f = chess.square_file(sq)\n                if (f == 0 or pawns_by_file[f-1] == 0) and (f == 7 or pawns_by_file[f+1] == 0):\n                    isolated += 1\n            # pawn islands: contiguous groups count\n            islands = 0\n            i = 0\n            while i < 8:\n                if pawns_by_file[i] > 0:\n                    islands += 1\n                    while i < 8 and pawns_by_file[i] > 0:\n                        i += 1\n                else:\n                    i += 1\n            # penalty combination\n            penalty = 0.5 * doubled + 0.9 * isolated + 0.35 * max(0, islands - 1)\n            return penalty\n        pw = pawn_structure_penalty(chess.WHITE)\n        pb = pawn_structure_penalty(chess.BLACK)\n        # positive if white structure better (lower penalty)\n        return float(pb - pw)\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'King pawn-shield and local heavy-piece pressure: (shield_strength - opponent_pressure) (white - black)'\n    try:\n        pm = board.piece_map()\n        vals = {chess.PAWN:1.0, chess.KNIGHT:3.0, chess.BISHOP:3.0, chess.ROOK:5.0, chess.QUEEN:9.0, chess.KING:0.0}\n        def king_safety(color):\n            king_sq = next((sq for sq, p in pm.items() if p and p.piece_type == chess.KING and p.color == color), None)\n            if king_sq is None:\n                return 0.0\n            f = chess.square_file(king_sq)\n            r = chess.square_rank(king_sq)\n            # shield squares: one and two ranks ahead (direction depends on color)\n            shield = 0\n            dirs = [1, 2] if color == chess.WHITE else [-1, -2]\n            for d in dirs:\n                rr = r + d\n                if 0 <= rr < 8:\n                    for ff in (f-1, f, f+1):\n                        if 0 <= ff < 8:\n                            sq = chess.square(ff, rr)\n                            p = pm.get(sq)\n                            if p and p.piece_type == chess.PAWN and p.color == color:\n                                shield += 1.0\n            # opponent pressure: sum of heavy attacker values attacking king vicinity\n            opp = chess.BLACK if color == chess.WHITE else chess.WHITE\n            pressure = 0.0\n            for ff in range(max(0, f-2), min(7, f+2)+1):\n                for rr in range(max(0, r-2), min(7, r+2)+1):\n                    sq = chess.square(ff, rr)\n                    attackers = board.attackers(opp, sq)\n                    for a in attackers:\n                        pa = pm.get(a)\n                        if pa:\n                            pressure += vals.get(pa.piece_type, 0.0) * 0.35\n            # safety = shield minus scaled pressure\n            return shield - 0.25 * pressure\n        ks_w = king_safety(chess.WHITE)\n        ks_b = king_safety(chess.BLACK)\n        return float(ks_w - ks_b)\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Knight outposts: count of knights on outpost squares (not attacked by enemy pawns and supported by own piece/pawn) (white - black)'\n    try:\n        pm = board.piece_map()\n        def outposts(color):\n            total = 0.0\n            opp = chess.BLACK if color == chess.WHITE else chess.WHITE\n            for sq, p in pm.items():\n                if not p or p.piece_type != chess.KNIGHT or p.color != color:\n                    continue\n                f = chess.square_file(sq)\n                r = chess.square_rank(sq)\n                # require to be in central/advanced area: for White rank >= 3, for Black rank <= 4\n                if color == chess.WHITE and r < 3:\n                    continue\n                if color == chess.BLACK and r > 4:\n                    continue\n                # check attacked by any enemy pawn\n                pawn_attackers = board.attackers(opp, sq)\n                attacked_by_pawn = any((pm.get(a) and pm.get(a).piece_type == chess.PAWN and pm.get(a).color == opp) for a in pawn_attackers)\n                if attacked_by_pawn:\n                    continue\n                # supported by own pawn or piece\n                defenders = board.attackers(color, sq)\n                supported = any((pm.get(d) and pm.get(d).color == color) for d in defenders)\n                if supported:\n                    total += 1.0\n            return total\n        return float(outposts(chess.WHITE) - outposts(chess.BLACK))\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Material vulnerability: weighted sum of pieces attacked more times than defended (black - white), positive favors White'\n    try:\n        pm = board.piece_map()\n        vals = {chess.PAWN:1.0, chess.KNIGHT:3.0, chess.BISHOP:3.0, chess.ROOK:5.0, chess.QUEEN:9.0, chess.KING:0.0}\n        vuln_w = 0.0\n        vuln_b = 0.0\n        for sq, p in pm.items():\n            if not p:\n                continue\n            color = p.color\n            opp = chess.BLACK if color == chess.WHITE else chess.WHITE\n            attackers = len(board.attackers(opp, sq))\n            defenders = len(board.attackers(color, sq))\n            if attackers > defenders:\n                weight = vals.get(p.piece_type, 0.0) * (attackers - defenders)\n                if color == chess.WHITE:\n                    vuln_w += weight\n                else:\n                    vuln_b += weight\n        # return the difference in vulnerabilities converted so positive favors White\n        return float(vuln_b - vuln_w)\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Central mobility: number of legal moves that land in central 4x4 area (c3-f6 region) (white - black)'\n    try:\n        orig = board.turn\n        central_ranks = set(range(2, 6))  # ranks 3..6 (0-indexed 2..5)\n        central_files = set(range(2, 6))  # files c..f (2..5)\n        counts = {chess.WHITE:0, chess.BLACK:0}\n        try:\n            for color in (chess.WHITE, chess.BLACK):\n                board.turn = color\n                for mv in board.legal_moves:\n                    to_sq = mv.to_square\n                    if chess.square_file(to_sq) in central_files and chess.square_rank(to_sq) in central_ranks:\n                        counts[color] += 1\n        finally:\n            board.turn = orig\n        # normalize by a small factor to keep scale reasonable\n        return float((counts[chess.WHITE] - counts[chess.BLACK]) / 8.0)\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'King activity in endgame: king centralization scaled by endgame likelihood (white - black)'\n    try:\n        pm = board.piece_map()\n        # compute non-pawn, non-king material\n        vals = {chess.KNIGHT:3.0, chess.BISHOP:3.0, chess.ROOK:5.0, chess.QUEEN:9.0}\n        nonpawn_material = 0.0\n        for p in pm.values():\n            if p and p.piece_type in vals:\n                nonpawn_material += vals[p.piece_type]\n        # endgame factor: when nonpawn material low, king activity matters more\n        endgame_factor = 1.0 if nonpawn_material <= 10.0 else max(0.0, (15.0 - nonpawn_material) / 5.0)\n        def king_centralization(color):\n            king_sq = next((sq for sq, p in pm.items() if p and p.piece_type == chess.KING and p.color == color), None)\n            if king_sq is None:\n                return 0.0\n            f = chess.square_file(king_sq)\n            r = chess.square_rank(king_sq)\n            # distance to central point (3.5,3.5)\n            dist = abs(float(f) - 3.5) + abs(float(r) - 3.5)\n            central = (7.0 - dist) / 7.0  # normalized 0..1\n            return central * endgame_factor\n        kc_w = king_centralization(chess.WHITE)\n        kc_b = king_centralization(chess.BLACK)\n        return float(kc_w - kc_b)\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'File control imbalance: counts files where one side controls more squares (attacks or occupancy) than the opponent (white - black)'\n    try:\n        pm = board.piece_map()\n        file_score = 0.0\n        for f in range(8):\n            white_control = 0\n            black_control = 0\n            for r in range(8):\n                sq = chess.square(f, r)\n                p = pm.get(sq)\n                if p:\n                    if p.color == chess.WHITE:\n                        white_control += 2  # occupancy counts stronger\n                    else:\n                        black_control += 2\n                # add attacks to that square\n                aw = board.attackers(chess.WHITE, sq)\n                ab = board.attackers(chess.BLACK, sq)\n                white_control += len(aw)\n                black_control += len(ab)\n            if white_control > black_control:\n                file_score += 1.0\n            elif black_control > white_control:\n                file_score -= 1.0\n        # normalize to -8..8 -> scale down\n        return float(file_score / 4.0)\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Battery/line pressure on kings: counts two-piece batteries aimed at opposing king (white - black), favors direct and x-ray alignments'\n    try:\n        pm = board.piece_map()\n        def battery_score(color):\n            score = 0.0\n            king_sq = next((sq for sq, p in pm.items() if p and p.piece_type == chess.KING and p.color != color), None)\n            if king_sq is None:\n                return 0.0\n            # sliding pieces that form batteries\n            sliding = (chess.QUEEN, chess.ROOK, chess.BISHOP)\n            for sq, p in pm.items():\n                if not p or p.color != color or p.piece_type not in sliding:\n                    continue\n                # check alignment with enemy king\n                sf = chess.square_file(sq); sr = chess.square_rank(sq)\n                kf = chess.square_file(king_sq); kr = chess.square_rank(king_sq)\n                df = kf - sf; dr = kr - sr\n                # same file, rank or diagonal?\n                step = None\n                if sf == kf:\n                    step = (0, 1 if dr > 0 else -1)\n                elif sr == kr:\n                    step = (1 if df > 0 else -1, 0)\n                elif abs(df) == abs(dr):\n                    step = (1 if df > 0 else -1, 1 if dr > 0 else -1)\n                if step is None:\n                    continue\n                # count pieces between\n                between = 0\n                cx, cy = sf + step[0], sr + step[1]\n                blocked_by_friendly = False\n                while cx != kf or cy != kr:\n                    sqb = chess.square(cx, cy)\n                    if pm.get(sqb):\n                        between += 1\n                    cx += step[0]; cy += step[1]\n                # battery value: stronger if fewer pieces between (0 immediate, 1 potential x-ray)\n                if between == 0:\n                    score += 1.5\n                elif between == 1:\n                    score += 1.0\n                elif between == 2:\n                    score += 0.25\n            return score\n        return float(battery_score(chess.WHITE) - battery_score(chess.BLACK))\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Pawn majority by flank and connected passed pawn bonus: (white - black), rewards flank majorities and neighboring passed pawns'\n    try:\n        pm = board.piece_map()\n        def flank_stats(color):\n            queen_side_files = set([0,1,2,3])\n            king_side_files = set([4,5,6,7])\n            q_p = 0; k_p = 0\n            passed_connected = 0.0\n            passed_positions = []\n            for sq,p in pm.items():\n                if p and p.piece_type == chess.PAWN and p.color == color:\n                    f = chess.square_file(sq)\n                    if f in queen_side_files:\n                        q_p += 1\n                    else:\n                        k_p += 1\n            # count connected passed pawns (adjacent files and both passed)\n            for sq,p in pm.items():\n                if not p or p.piece_type != chess.PAWN or p.color != color:\n                    continue\n                # reuse passed pawn test\n                def is_passed_local(sq2, color2):\n                    f2 = chess.square_file(sq2)\n                    r2 = chess.square_rank(sq2)\n                    opp = chess.BLACK if color2 == chess.WHITE else chess.WHITE\n                    files = [ff for ff in (f2-1, f2, f2+1) if 0 <= ff < 8]\n                    if color2 == chess.WHITE:\n                        for ff in files:\n                            for rr in range(r2+1, 8):\n                                sqx = chess.square(ff, rr)\n                                p2 = pm.get(sqx)\n                                if p2 and p2.piece_type == chess.PAWN and p2.color == opp:\n                                    return False\n                        return True\n                    else:\n                        for ff in files:\n                            for rr in range(0, r2):\n                                sqx = chess.square(ff, rr)\n                                p2 = pm.get(sqx)\n                                if p2 and p2.piece_type == chess.PAWN and p2.color == opp:\n                                    return False\n                        return True\n                if is_passed_local(sq, color):\n                    passed_positions.append(sq)\n            # connected passed: two passed pawns on adjacent files\n            used = set()\n            for a in passed_positions:\n                for b in passed_positions:\n                    if a == b or (a,b) in used or (b,a) in used:\n                        continue\n                    fa = chess.square_file(a); fb = chess.square_file(b)\n                    if abs(fa - fb) == 1:\n                        passed_connected += 1.5\n                        used.add((a,b))\n            # flank majority magnitude\n            flank_majority = max(0, k_p - q_p)  # not directional here, we'll include both in difference\n            return q_p, k_p, passed_connected\n        qw, kw, pcw = flank_stats(chess.WHITE)\n        qb, kb, pcb = flank_stats(chess.BLACK)\n        # compute majority advantage: (white_majority_sum - black_majority_sum)\n        maj_w = (kw - qw)\n        maj_b = (kb - qb)\n        score = 0.8 * (maj_w - maj_b) + 2.0 * (pcw - pcb)\n        return float(score)\n    except Exception:\n        return 0.0\n",
    "def feature(board: chess.Board) -> float:\n    'Passed pawn potential: weighted sum of passed pawn advancement and support (white - black)'\n    try:\n        pm = board.piece_map()\n        vals = {chess.PAWN:1.0}\n        def is_passed(sq, color):\n            f = chess.square_file(sq)\n            r = chess.square_rank(sq)\n            # For white, no enemy pawns on same file or adjacent files in front (r'>r)\n            for ff in (f-1, f, f+1):\n                if 0 <= ff <= 7:\n                    if color == chess.WHITE:\n                        for rr in range(r+1, 8):\n                            p = pm.get(chess.square(ff, rr))\n                            if p and p.piece_type == chess.PAWN and p.color != color:\n                                return False\n                    else:\n                        for rr in range(0, r):\n                            p = pm.get(chess.square(ff, rr))\n                            if p and p.piece_type == chess.PAWN and p.color != color:\n                                return False\n            return True\n        def support_count(sq, color):\n            attackers = board.attackers(color, sq)\n            return sum(1 for a in attackers if pm.get(a) and pm.get(a).piece_type == chess.PAWN)\n        score = {chess.WHITE:0.0, chess.BLACK:0.0}\n        for sq,p in pm.items():\n            if not p or p.piece_type != chess.PAWN:\n                continue\n            color = p.color\n            r = chess.square_rank(sq)\n            # advancement factor: closer to promotion -> higher\n            dist = (7 - r) if color == chess.WHITE else r\n            adv = 1.0 / (dist + 1.0)\n            passed = 1.0 if is_passed(sq, color) else 0.0\n            support = support_count(sq, color)\n            # weighted: passed pawns with support count more\n            score[color] += passed * adv * (1.0 + 0.3 * support)\n        return float(score[chess.WHITE] - score[chess.BLACK])\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Rook file activity: rooks on open files (1.0) and semi-open files (0.5) (white - black)'\n    try:\n        pm = board.piece_map()\n        def file_pawn_counts(file_idx):\n            c = {chess.WHITE:0, chess.BLACK:0}\n            for rr in range(8):\n                p = pm.get(chess.square(file_idx, rr))\n                if p and p.piece_type == chess.PAWN:\n                    c[p.color] += 1\n            return c\n        open_file = [False]*8\n        semi_open = {chess.WHITE:[False]*8, chess.BLACK:[False]*8}\n        for f in range(8):\n            cnt = file_pawn_counts(f)\n            if cnt[chess.WHITE] == 0 and cnt[chess.BLACK] == 0:\n                open_file[f] = True\n            if cnt[chess.WHITE] == 0:\n                semi_open[chess.BLACK][f] = True\n            if cnt[chess.BLACK] == 0:\n                semi_open[chess.WHITE][f] = True\n        score = {chess.WHITE:0.0, chess.BLACK:0.0}\n        for sq,p in pm.items():\n            if not p or p.piece_type != chess.ROOK:\n                continue\n            f = chess.square_file(sq)\n            if open_file[f]:\n                score[p.color] += 1.0\n            elif semi_open[p.color][f]:\n                score[p.color] += 0.5\n            # extra: rooks on seventh rank (very strong)\n            r = chess.square_rank(sq)\n            if (p.color == chess.WHITE and r == 6) or (p.color == chess.BLACK and r == 1):\n                score[p.color] += 0.8\n        return float(score[chess.WHITE] - score[chess.BLACK])\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Knight outposts: advanced knights on outpost squares (protected by pawn, not attacked by enemy pawns) (white - black)'\n    try:\n        pm = board.piece_map()\n        def is_outpost(sq, color):\n            p = pm.get(sq)\n            if not p or p.piece_type != chess.KNIGHT or p.color != color:\n                return False\n            r = chess.square_rank(sq)\n            # advanced criterion\n            if color == chess.WHITE and r < 4:\n                return False\n            if color == chess.BLACK and r > 3:\n                return False\n            # protected by a pawn\n            attackers = board.attackers(color, sq)\n            pawn_protect = any(pm.get(a) and pm.get(a).piece_type == chess.PAWN for a in attackers)\n            # attacked by enemy pawns\n            opp = not color\n            opp_pawn_attack = any(pm.get(a) and pm.get(a).piece_type == chess.PAWN and pm.get(a).color == opp for a in board.attackers(opp, sq))\n            return pawn_protect and (not opp_pawn_attack)\n        score_w = 0.0\n        score_b = 0.0\n        for sq,p in pm.items():\n            if not p or p.piece_type != chess.KNIGHT:\n                continue\n            if is_outpost(sq, p.color):\n                if p.color == chess.WHITE:\n                    score_w += 1.0\n                else:\n                    score_b += 1.0\n        return float(score_w - score_b)\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Hanging pieces vulnerability: sum of piece-value-weighted net attackers minus defenders (higher means opponent more vulnerable) (white - black)'\n    try:\n        pm = board.piece_map()\n        vals = {chess.PAWN:1.0, chess.KNIGHT:3.0, chess.BISHOP:3.0, chess.ROOK:5.0, chess.QUEEN:9.0}\n        vuln = {chess.WHITE:0.0, chess.BLACK:0.0}\n        for sq,p in pm.items():\n            if not p or p.piece_type == chess.KING:\n                continue\n            color = p.color\n            opp = not color\n            attackers = len(board.attackers(opp, sq))\n            defenders = len(board.attackers(color, sq))\n            net = max(0, attackers - defenders)\n            vuln[color] += net * vals.get(p.piece_type, 0.0)\n        # higher vuln for a side is bad for that side -> feature positive when black more vulnerable\n        return float(vuln[chess.BLACK] - vuln[chess.WHITE])\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Center influence: occupation and attacks on key central squares (weighted) (white - black)'\n    try:\n        centers = [chess.parse_square(s) for s in ('d4','e4','d5','e5','c4','f4','c5','f5')]\n        pm = board.piece_map()\n        score = {chess.WHITE:0.0, chess.BLACK:0.0}\n        for sq in centers:\n            occ = pm.get(sq)\n            if occ:\n                score[occ.color] += 0.9\n            # count attackers (each attacker contributes modestly)\n            aw = len(board.attackers(chess.WHITE, sq))\n            ab = len(board.attackers(chess.BLACK, sq))\n            score[chess.WHITE] += 0.25 * aw\n            score[chess.BLACK] += 0.25 * ab\n        return float(score[chess.WHITE] - score[chess.BLACK])\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Direct king-line threats: enemy heavy piece (rook/queen/bishop) aligned with king with clear path (black threats on white king - white threats on black king) negated to favor white'\n    try:\n        pm = board.piece_map()\n        def first_piece_in_direction(sq, df, dr):\n            f = chess.square_file(sq) + df\n            r = chess.square_rank(sq) + dr\n            while 0 <= f <= 7 and 0 <= r <= 7:\n                s = chess.square(f, r)\n                if pm.get(s) is not None:\n                    return s, pm.get(s)\n                f += df; r += dr\n            return None, None\n        directions = [(1,0),(-1,0),(0,1),(0,-1),(1,1),(1,-1),(-1,1),(-1,-1)]\n        def threats_to_king(king_sq, by_color):\n            t = 0.0\n            for df,dr in directions:\n                s,p = first_piece_in_direction(king_sq, df, dr)\n                if p:\n                    if p.color == by_color:\n                        # rank/file directions: rook/queen threaten, diagonal: bishop/queen\n                        if df == 0 or dr == 0:\n                            if p.piece_type in (chess.ROOK, chess.QUEEN):\n                                t += 1.0\n                        else:\n                            if p.piece_type in (chess.BISHOP, chess.QUEEN):\n                                t += 1.0\n            return t\n        wk = next((sq for sq,p in pm.items() if p and p.piece_type == chess.KING and p.color == chess.WHITE), None)\n        bk = next((sq for sq,p in pm.items() if p and p.piece_type == chess.KING and p.color == chess.BLACK), None)\n        if wk is None or bk is None:\n            return 0.0\n        threats_on_white = threats_to_king(wk, chess.BLACK)\n        threats_on_black = threats_to_king(bk, chess.WHITE)\n        # higher value when black's king is under more direct pressure relative to white's king\n        return float(threats_on_black - threats_on_white)\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Pawn structure fragmentation: pawn island count difference (black - white), normalized so positive favors White'\n    try:\n        pm = board.piece_map()\n        def pawn_islands(color):\n            files_with_pawn = [False]*8\n            for sq,p in pm.items():\n                if p and p.piece_type == chess.PAWN and p.color == color:\n                    files_with_pawn[chess.square_file(sq)] = True\n            islands = 0\n            i = 0\n            while i < 8:\n                if files_with_pawn[i]:\n                    islands += 1\n                    while i < 8 and files_with_pawn[i]:\n                        i += 1\n                else:\n                    i += 1\n            return islands\n        w = pawn_islands(chess.WHITE)\n        b = pawn_islands(chess.BLACK)\n        # normalize by max possible islands (8)\n        return float((b - w) / 8.0)\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'King centralization in endgame: prefers more centralized king when material is low (white - black)'\n    try:\n        pm = board.piece_map()\n        vals = {chess.PAWN:1.0, chess.KNIGHT:3.0, chess.BISHOP:3.0, chess.ROOK:5.0, chess.QUEEN:9.0}\n        mat = 0.0\n        for p in pm.values():\n            if p and p.piece_type != chess.KING:\n                mat += vals.get(p.piece_type, 0.0)\n        # endgame factor: more weight when material is low\n        endgame_factor = max(0.0, 1.0 - mat / 14.0)\n        centers = [chess.parse_square(s) for s in ('d4','e4','d5','e5')]\n        def king_centrality(color):\n            ksq = next((sq for sq,p in pm.items() if p and p.piece_type == chess.KING and p.color == color), None)\n            if ksq is None:\n                return 0.0\n            # centrality = inverse of min Manhattan distance to any central square\n            mind = min(chess.square_distance(ksq, c) for c in centers)\n            # max possible distance on board to center ~7 (use 7)\n            return (7.0 - float(mind)) / 7.0\n        kc_w = king_centrality(chess.WHITE)\n        kc_b = king_centrality(chess.BLACK)\n        return float(endgame_factor * (kc_w - kc_b))\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Tactical capture opportunities: sum of favorable capture value differences available immediately (white - black)'\n    try:\n        pm = board.piece_map()\n        vals = {chess.PAWN:1.0, chess.KNIGHT:3.0, chess.BISHOP:3.0, chess.ROOK:5.0, chess.QUEEN:9.0, chess.KING:0.0}\n        orig = board.turn\n        try:\n            scores = {chess.WHITE:0.0, chess.BLACK:0.0}\n            for color in (chess.WHITE, chess.BLACK):\n                board.turn = color\n                for mv in board.legal_moves:\n                    target = pm.get(mv.to_square)\n                    attacker = pm.get(mv.from_square)\n                    if target and attacker:\n                        gain = vals.get(target.piece_type, 0.0) - vals.get(attacker.piece_type, 0.0)\n                        if gain > 0:\n                            # prioritize captures that win material; closer moves (captures by higher mobility pieces) not considered here\n                            scores[color] += gain\n            return float(scores[chess.WHITE] - scores[chess.BLACK])\n        finally:\n            board.turn = orig\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Trapped/immobile heavy pieces: count of non-pawn non-king pieces with zero legal moves (white - black)'\n    try:\n        pm = board.piece_map()\n        orig = board.turn\n        try:\n            immobile = {chess.WHITE:0.0, chess.BLACK:0.0}\n            for color in (chess.WHITE, chess.BLACK):\n                board.turn = color\n                moves_from = {}\n                for mv in board.legal_moves:\n                    moves_from[mv.from_square] = moves_from.get(mv.from_square, 0) + 1\n                for sq,p in pm.items():\n                    if not p or p.color != color or p.piece_type in (chess.PAWN, chess.KING):\n                        continue\n                    if moves_from.get(sq, 0) == 0:\n                        immobile[color] += 1.0\n            return float(immobile[chess.BLACK] - immobile[chess.WHITE])\n        finally:\n            board.turn = orig\n    except Exception:\n        return 0.0\n",
    "def feature(board: chess.Board) -> float:\n    'Rook open/semi-open file and seventh-rank pressure (positive favors White)'\n    try:\n        pm = board.piece_map()\n        def rook_score(color):\n            score = 0.0\n            for sq, p in pm.items():\n                if not p or p.piece_type != chess.ROOK or p.color != color:\n                    continue\n                f = chess.square_file(sq)\n                r = chess.square_rank(sq)\n                # open file: no pawns of either color on that file\n                pawns_on_file = any((qp.piece_type == chess.PAWN) for qsq, qp in pm.items() if chess.square_file(qsq) == f and qp)\n                if not pawns_on_file:\n                    score += 1.2\n                else:\n                    # semi-open: no friendly pawns on that file\n                    friendly_pawn_on_file = any((qp.piece_type == chess.PAWN and qp.color == color) for qsq, qp in pm.items() if chess.square_file(qsq) == f and qp)\n                    if not friendly_pawn_on_file:\n                        score += 0.7\n                # seventh rank pressure bonus\n                if (color == chess.WHITE and r == 6) or (color == chess.BLACK and r == 1):\n                    score += 1.5\n            return score\n        return float(rook_score(chess.WHITE) - rook_score(chess.BLACK))\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Bishop pair and diagonal mobility minus own pawns on same color squares (positive favors White)'\n    try:\n        pm = board.piece_map()\n        def bishop_mobility_and_block(color):\n            score = 0.0\n            bishops = [sq for sq, p in pm.items() if p and p.piece_type == chess.BISHOP and p.color == color]\n            # bishop pair bonus\n            if len(bishops) >= 2:\n                score += 1.0\n            # approximate mobility: count ray squares reachable until blocked\n            for sq in bishops:\n                f = chess.square_file(sq); r = chess.square_rank(sq)\n                for df, dr in ((1,1),(1,-1),(-1,1),(-1,-1)):\n                    ff, rr = f+df, r+dr\n                    while 0 <= ff < 8 and 0 <= rr < 8:\n                        occ = pm.get(chess.square(ff, rr))\n                        # reachable at least one more square\n                        score += 0.08\n                        if occ:\n                            # if occupied by own pawn on same color-square as bishop, penalize (blocked)\n                            if occ.piece_type == chess.PAWN and occ.color == color:\n                                score -= 0.12\n                            break\n                        ff += df; rr += dr\n            return score\n        return float(bishop_mobility_and_block(chess.WHITE) - bishop_mobility_and_block(chess.BLACK))\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Passed pawn advancement potential: sum over passed pawns of (progress + support) (white - black)'\n    try:\n        pm = board.piece_map()\n        pawns = {chess.WHITE: [], chess.BLACK: []}\n        for sq, p in pm.items():\n            if p and p.piece_type == chess.PAWN:\n                pawns[p.color].append(sq)\n        def is_passed(sq, color):\n            f = chess.square_file(sq); r = chess.square_rank(sq)\n            opp = chess.BLACK if color == chess.WHITE else chess.WHITE\n            for sq2 in pawns[opp]:\n                ff = chess.square_file(sq2); rr = chess.square_rank(sq2)\n                if abs(ff - f) <= 1:\n                    if color == chess.WHITE and rr > r:\n                        return False\n                    if color == chess.BLACK and rr < r:\n                        return False\n            return True\n        def pawn_potential(color):\n            s = 0.0\n            for sq in pawns[color]:\n                f = chess.square_file(sq); r = chess.square_rank(sq)\n                if not is_passed(sq, color):\n                    continue\n                # progress: closeness to promotion\n                dist = (7 - r) if color == chess.WHITE else r\n                progress = (7.0 - dist) / 7.0  # 0..1\n                # support: friendly pieces attacking its forward squares\n                support = 0.0\n                if color == chess.WHITE:\n                    forward_sqs = []\n                    for df in (-1,1):\n                        ff = f + df; rr = r + 1\n                        if 0 <= ff < 8 and 0 <= rr < 8:\n                            forward_sqs.append(chess.square(ff, rr))\n                else:\n                    forward_sqs = []\n                    for df in (-1,1):\n                        ff = f + df; rr = r - 1\n                        if 0 <= ff < 8 and 0 <= rr < 8:\n                            forward_sqs.append(chess.square(ff, rr))\n                for fsq in forward_sqs:\n                    if board.is_attacked_by(color, fsq):\n                        support += 0.5\n                s += progress * 2.2 + support\n            return s\n        return float(pawn_potential(chess.WHITE) - pawn_potential(chess.BLACK))\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Weighted hanging pieces (attacked and undefended): (black_hanging - white_hanging) higher => favorable to White'\n    try:\n        vals = {chess.PAWN:1.0, chess.KNIGHT:3.0, chess.BISHOP:3.0, chess.ROOK:5.0, chess.QUEEN:9.0, chess.KING:0.0}\n        pm = board.piece_map()\n        hang = {chess.WHITE:0.0, chess.BLACK:0.0}\n        for sq, p in pm.items():\n            if not p:\n                continue\n            color = p.color\n            opp = chess.BLACK if color == chess.WHITE else chess.WHITE\n            opp_attackers = board.attackers(opp, sq)\n            defenders = board.attackers(color, sq)\n            if opp_attackers and not defenders:\n                hang[color] += vals.get(p.piece_type, 0.0)\n        # return black - white so positive means opponent (black) has more hanging weight => good for White\n        return float(hang[chess.BLACK] - hang[chess.WHITE])\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Local king shelter score: nearest friendly pawn distance minus nearby opponent attack count (white - black)'\n    try:\n        pm = board.piece_map()\n        def king_shelter(color):\n            king_sq = next((sq for sq,p in pm.items() if p and p.piece_type==chess.KING and p.color==color), None)\n            if king_sq is None:\n                return 0.0\n            kf = chess.square_file(king_sq); kr = chess.square_rank(king_sq)\n            # distance to nearest friendly pawn\n            min_dist = 100\n            for sq, p in pm.items():\n                if p and p.piece_type == chess.PAWN and p.color == color:\n                    d = chess.square_distance(king_sq, sq)\n                    if d < min_dist:\n                        min_dist = d\n            pawn_dist_score = 0.0 if min_dist == 100 else (1.0 / (1.0 + min_dist))\n            # opponent attack density around king (3x3 neighborhood)\n            opp = chess.BLACK if color == chess.WHITE else chess.WHITE\n            attack_count = 0\n            for ff in range(max(0, kf-1), min(7, kf+1)+1):\n                for rr in range(max(0, kr-1), min(7, kr+1)+1):\n                    if board.is_attacked_by(opp, chess.square(ff, rr)):\n                        attack_count += 1\n            return pawn_dist_score - 0.25 * attack_count\n        return float(king_shelter(chess.WHITE) - king_shelter(chess.BLACK))\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Knight and rook centralization heuristic: central knights and rooks on open files (white - black)'\n    try:\n        pm = board.piece_map()\n        def central_score(color):\n            score = 0.0\n            for sq, p in pm.items():\n                if not p or p.color != color:\n                    continue\n                f = chess.square_file(sq); r = chess.square_rank(sq)\n                # knight centralization: closer to center (d4/e4/d5/e5)\n                if p.piece_type == chess.KNIGHT:\n                    cd = ((f - 3.5)**2 + (r - 3.5)**2)**0.5\n                    score += max(0.0, (4.95 - cd) / 4.95) * 0.9\n                # rook: small bonus for being on open or semi-open file\n                if p.piece_type == chess.ROOK:\n                    pawns_on_file = any((qp.piece_type == chess.PAWN) for qsq, qp in pm.items() if chess.square_file(qsq) == f and qp)\n                    if not pawns_on_file:\n                        score += 1.0\n                    else:\n                        friendly_pawn_on_file = any((qp.piece_type == chess.PAWN and qp.color == color) for qsq, qp in pm.items() if chess.square_file(qsq) == f and qp)\n                        if not friendly_pawn_on_file:\n                            score += 0.5\n            return score\n        return float(central_score(chess.WHITE) - central_score(chess.BLACK))\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Material vs mobility disparity: (material - mobility*scale) difference (white - black); large positive means material advantage with low mobility'\n    try:\n        vals = {chess.PAWN:1.0, chess.KNIGHT:3.0, chess.BISHOP:3.0, chess.ROOK:5.0, chess.QUEEN:9.0, chess.KING:0.0}\n        pm = board.piece_map()\n        mat = {chess.WHITE:0.0, chess.BLACK:0.0}\n        for p in pm.values():\n            if p:\n                mat[p.color] += vals.get(p.piece_type, 0.0)\n        # mobility: count legal moves per side (all moves)\n        orig = board.turn\n        try:\n            mob = {chess.WHITE:0, chess.BLACK:0}\n            for color in (chess.WHITE, chess.BLACK):\n                board.turn = color\n                for mv in board.legal_moves:\n                    mob[color] += 1\n        finally:\n            board.turn = orig\n        scale = 0.06  # scale mobility to material units\n        disparity_w = mat[chess.WHITE] - mob[chess.WHITE] * scale\n        disparity_b = mat[chess.BLACK] - mob[chess.BLACK] * scale\n        return float(disparity_w - disparity_b)\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Trapped piece heuristic: count of pieces with <=1 legal move and attacked > defended (black - white)'\n    try:\n        pm = board.piece_map()\n        trapped = {chess.WHITE:0.0, chess.BLACK:0.0}\n        orig = board.turn\n        try:\n            for sq, p in list(pm.items()):\n                if not p or p.piece_type == chess.KING:\n                    continue\n                color = p.color\n                # count legal moves for that piece by temporarily setting turn\n                board.turn = color\n                move_count = 0\n                for mv in board.legal_moves:\n                    if mv.from_square == sq:\n                        move_count += 1\n                        if move_count > 1:\n                            break\n                opp = chess.BLACK if color == chess.WHITE else chess.WHITE\n                attackers = len(board.attackers(opp, sq))\n                defenders = len(board.attackers(color, sq))\n                if move_count <= 1 and attackers > defenders:\n                    # weight by piece value\n                    weight = {chess.PAWN:1.0, chess.KNIGHT:2.5, chess.BISHOP:2.5, chess.ROOK:4.0, chess.QUEEN:7.0}.get(p.piece_type, 0.0)\n                    trapped[color] += weight\n        finally:\n            board.turn = orig\n        # return black - white so positive means black is more trapped (good for White)\n        return float(trapped[chess.BLACK] - trapped[chess.WHITE])\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Central control: occupancy or attacks of central four squares (d4,e4,d5,e5) (white - black)'\n    try:\n        center_sqs = [chess.parse_square(s) for s in ('d4','e4','d5','e5')]\n        score = {chess.WHITE:0.0, chess.BLACK:0.0}\n        pm = board.piece_map()\n        for sq in center_sqs:\n            p = pm.get(sq)\n            if p:\n                score[p.color] += 1.0  # occupied\n            # attacked by each side\n            if board.is_attacked_by(chess.WHITE, sq):\n                score[chess.WHITE] += 0.6\n            if board.is_attacked_by(chess.BLACK, sq):\n                score[chess.BLACK] += 0.6\n        return float(score[chess.WHITE] - score[chess.BLACK])\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Endgame king activity metric: normalized centralization of kings in low-material positions (white - black)'\n    try:\n        # determine low-material: exclude kings\n        vals = {chess.PAWN:1.0, chess.KNIGHT:3.0, chess.BISHOP:3.0, chess.ROOK:5.0, chess.QUEEN:9.0}\n        total_nonking = 0.0\n        pm = board.piece_map()\n        for p in pm.values():\n            if p and p.piece_type != chess.KING:\n                total_nonking += vals.get(p.piece_type, 0.0)\n        # if not an endgame, still return small king activity signal\n        wk = next((sq for sq,p in pm.items() if p and p.piece_type==chess.KING and p.color==chess.WHITE), None)\n        bk = next((sq for sq,p in pm.items() if p and p.piece_type==chess.KING and p.color==chess.BLACK), None)\n        def king_activity(ksq):\n            if ksq is None:\n                return 0.0\n            f = chess.square_file(ksq); r = chess.square_rank(ksq)\n            dist = ((f - 3.5)**2 + (r - 3.5)**2)**0.5  # 0..~4.95\n            return (4.95 - dist) / 4.95\n        wact = king_activity(wk)\n        bact = king_activity(bk)\n        # scale up in true endgames (fewer pieces)\n        scale = 1.0 if total_nonking <= 12.0 else 0.35\n        return float((wact - bact) * scale)\n    except Exception:\n        return 0.0\n",
    "def feature(board: chess.Board) -> float:\n    'Material balance adjusted by activity of non-pawn pieces (white - black)'\n    try:\n        vals = {chess.PAWN:1.0, chess.KNIGHT:3.0, chess.BISHOP:3.0, chess.ROOK:5.0, chess.QUEEN:9.0, chess.KING:0.0}\n        pm = board.piece_map()\n        mat = {chess.WHITE:0.0, chess.BLACK:0.0}\n        counts = {chess.WHITE:0, chess.BLACK:0}\n        for sq,p in pm.items():\n            if not p: continue\n            mat[p.color] += vals.get(p.piece_type, 0.0)\n            if p.piece_type not in (chess.PAWN, chess.KING):\n                counts[p.color] += 1\n        # activity: average legal moves for non-pawn non-king pieces\n        orig = board.turn\n        try:\n            activity = {chess.WHITE:0.0, chess.BLACK:0.0}\n            for color in (chess.WHITE, chess.BLACK):\n                board.turn = color\n                move_counts = 0\n                piece_counts = 0\n                for mv in board.legal_moves:\n                    p = board.piece_at(mv.from_square)\n                    if p and p.piece_type not in (chess.PAWN, chess.KING) and p.color == color:\n                        move_counts += 1\n                        piece_counts += 0  # count per-move not per-piece\n                # To get average activity per piece, approximate by dividing total moves by number of pieces\n                activity[color] = (move_counts / counts[color]) if counts[color] > 0 else 0.0\n        finally:\n            board.turn = orig\n        # Combine static material and dynamic activity: activity amplifies material importance\n        mat_diff = mat[chess.WHITE] - mat[chess.BLACK]\n        act_diff = activity[chess.WHITE] - activity[chess.BLACK]\n        # scale activity influence modestly\n        result = float(mat_diff + 0.35 * act_diff)\n        return result\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Passed pawns weighted by advancement and pressure (white - black)'\n    try:\n        pm = board.piece_map()\n        def is_passed(sq, color):\n            f = chess.square_file(sq); r = chess.square_rank(sq)\n            if color == chess.WHITE:\n                # enemy pawns on same or adjacent files with rank > r\n                for af in (f-1, f, f+1):\n                    if 0 <= af <= 7:\n                        for rr in range(r+1, 8):\n                            p = board.piece_at(chess.square(af, rr))\n                            if p and p.piece_type == chess.PAWN and p.color == chess.BLACK:\n                                return False\n                return True\n            else:\n                for af in (f-1, f, f+1):\n                    if 0 <= af <= 7:\n                        for rr in range(0, r):\n                            p = board.piece_at(chess.square(af, rr))\n                            if p and p.piece_type == chess.PAWN and p.color == chess.WHITE:\n                                return False\n                return True\n        score_w = 0.0; score_b = 0.0\n        for sq,p in pm.items():\n            if not p or p.piece_type != chess.PAWN:\n                continue\n            if is_passed(sq, p.color):\n                r = chess.square_rank(sq)\n                if p.color == chess.WHITE:\n                    adv = float(r) / 7.0\n                    # if square is attacked by opponent, reduce value\n                    threatened = board.is_attacked_by(chess.BLACK, sq)\n                    score_w += (0.9 + 1.6 * adv) * (0.6 if threatened else 1.0)\n                else:\n                    adv = float(7 - r) / 7.0\n                    threatened = board.is_attacked_by(chess.WHITE, sq)\n                    score_b += (0.9 + 1.6 * adv) * (0.6 if threatened else 1.0)\n        return float(score_w - score_b)\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Bishop pair and long-diagonal mobility bonus (white - black)'\n    try:\n        pm = board.piece_map()\n        vals = {chess.BISHOP:0.5}\n        # count bishop pair bonus and mobility along diagonals (approx by legal moves from bishop)\n        orig = board.turn\n        try:\n            mobility = {chess.WHITE:0.0, chess.BLACK:0.0}\n            bishop_count = {chess.WHITE:0, chess.BLACK:0}\n            for color in (chess.WHITE, chess.BLACK):\n                board.turn = color\n                for mv in board.legal_moves:\n                    p = board.piece_at(mv.from_square)\n                    if p and p.piece_type == chess.BISHOP and p.color == color:\n                        mobility[color] += 1.0\n                # count bishops\n            for sq,p in pm.items():\n                if p and p.piece_type == chess.BISHOP:\n                    bishop_count[p.color] += 1\n            # average mobility per bishop\n            mob_avg_w = mobility[chess.WHITE] / max(1, bishop_count[chess.WHITE])\n            mob_avg_b = mobility[chess.BLACK] / max(1, bishop_count[chess.BLACK])\n        finally:\n            board.turn = orig\n        pair_bonus = 0.6 * (1 if bishop_count[chess.WHITE] >= 2 else 0) - 0.6 * (1 if bishop_count[chess.BLACK] >= 2 else 0)\n        # mobility difference scaled\n        mob_diff = 0.25 * (mob_avg_w - mob_avg_b)\n        return float(pair_bonus + mob_diff)\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Rooks on open or semi-open files (white - black); open=1.0, semi-open=0.5'\n    try:\n        pm = board.piece_map()\n        # precompute pawn presence by file\n        file_has_white_pawn = [False]*8\n        file_has_black_pawn = [False]*8\n        for sq,p in pm.items():\n            if p and p.piece_type == chess.PAWN:\n                file_has_white_pawn[chess.square_file(sq)] |= (p.color == chess.WHITE)\n                file_has_black_pawn[chess.square_file(sq)] |= (p.color == chess.BLACK)\n        score_w = 0.0; score_b = 0.0\n        for sq,p in pm.items():\n            if not p or p.piece_type != chess.ROOK:\n                continue\n            f = chess.square_file(sq)\n            any_pawn = file_has_white_pawn[f] or file_has_black_pawn[f]\n            friendly_pawn = file_has_white_pawn[f] if p.color == chess.WHITE else file_has_black_pawn[f]\n            if not any_pawn:\n                val = 1.0\n            elif not friendly_pawn:\n                val = 0.5\n            else:\n                val = 0.0\n            if p.color == chess.WHITE:\n                score_w += val\n            else:\n                score_b += val\n        return float(score_w - score_b)\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Piece coordination: average inverse Manhattan distance among major/minor pieces (white - black)'\n    try:\n        pm = board.piece_map()\n        def coord(color):\n            sqs = [sq for sq,p in pm.items() if p and p.color == color and p.piece_type in (chess.KNIGHT, chess.BISHOP, chess.ROOK, chess.QUEEN)]\n            n = len(sqs)\n            if n < 2:\n                return 0.0\n            total = 0.0\n            pairs = 0\n            for i in range(n):\n                for j in range(i+1, n):\n                    d = chess.square_distance(sqs[i], sqs[j])\n                    # inverse scaled: closer pieces -> higher contribution\n                    total += (8.0 - float(d)) / 8.0\n                    pairs += 1\n            return total / pairs if pairs > 0 else 0.0\n        return float(coord(chess.WHITE) - coord(chess.BLACK))\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'King centralization bonus in endgames: (black_distance - white_distance) positive if White more centralized'\n    try:\n        # determine endgame roughly: no queens or low non-pawn material\n        pm = board.piece_map()\n        vals = {chess.PAWN:1.0, chess.KNIGHT:3.0, chess.BISHOP:3.0, chess.ROOK:5.0, chess.QUEEN:9.0}\n        total_nonpawn = 0.0\n        has_queen = False\n        for p in pm.values():\n            if not p: continue\n            if p.piece_type == chess.QUEEN:\n                has_queen = True\n            if p.piece_type != chess.PAWN and p.piece_type != chess.KING:\n                total_nonpawn += vals.get(p.piece_type, 0.0)\n        if has_queen or total_nonpawn > 12.0:\n            return 0.0\n        # find kings\n        wk = next((sq for sq,p in pm.items() if p and p.piece_type == chess.KING and p.color == chess.WHITE), None)\n        bk = next((sq for sq,p in pm.items() if p and p.piece_type == chess.KING and p.color == chess.BLACK), None)\n        if wk is None or bk is None:\n            return 0.0\n        # center squares indices roughly at files 3,4 ranks 3,4 (d4,e4,d5,e5)\n        center_sqs = [chess.parse_square(name) for name in ('d4','e4','d5','e5')]\n        def min_center_dist(ksq):\n            return min(chess.square_distance(ksq, c) for c in center_sqs)\n        wd = float(min_center_dist(wk))\n        bd = float(min_center_dist(bk))\n        # normalize (max distance on board is 14); smaller distance better\n        return float((bd - wd) / 14.0)\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Trapped or near-trapped pieces weighted by value: sum(black_trapped) - sum(white_trapped)'\n    try:\n        pm = board.piece_map()\n        vals = {chess.PAWN:1.0, chess.KNIGHT:3.0, chess.BISHOP:3.0, chess.ROOK:5.0, chess.QUEEN:9.0, chess.KING:0.0}\n        orig = board.turn\n        try:\n            trapped = {chess.WHITE:0.0, chess.BLACK:0.0}\n            for color in (chess.WHITE, chess.BLACK):\n                board.turn = color\n                # build defenders/attackers counts\n                for sq,p in list(pm.items()):\n                    if not p or p.color != color or p.piece_type in (chess.PAWN, chess.KING):\n                        continue\n                    # mobility from this square\n                    mv_count = 0\n                    for mv in board.legal_moves:\n                        if mv.from_square == sq:\n                            mv_count += 1\n                    attackers = len(board.attackers(chess.BLACK if color==chess.WHITE else chess.WHITE, sq))\n                    defenders = len(board.attackers(color, sq))\n                    # heuristics: very low mobility and under-attacked and insufficient defenders -> trapped\n                    if mv_count <= 1 and attackers > defenders:\n                        trapped[color] += vals.get(p.piece_type, 0.0) * (1.0 + (attackers - defenders) * 0.4)\n                    # corner zero mobility is very bad\n                    rf = chess.square_file(sq); rr = chess.square_rank(sq)\n                    if mv_count == 0 and (rf in (0,7) and rr in (0,7)):\n                        trapped[color] += vals.get(p.piece_type, 0.0) * 0.8\n        finally:\n            board.turn = orig\n        return float(trapped[chess.BLACK] - trapped[chess.WHITE])\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Central control index: difference in number of attackers on the central 16 squares (white - black)'\n    try:\n        central = []\n        for f in range(2, 6):\n            for r in range(2, 6):\n                central.append(chess.square(f, r))\n        total_w = 0\n        total_b = 0\n        for sq in central:\n            # number of attackers (may count duplicates)\n            a_w = len(board.attackers(chess.WHITE, sq))\n            a_b = len(board.attackers(chess.BLACK, sq))\n            total_w += a_w\n            total_b += a_b\n        return float(total_w - total_b)\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Tactical capture pressure: difference in number of immediate capture moves available (white - black)'\n    try:\n        orig = board.turn\n        try:\n            captures = {chess.WHITE:0, chess.BLACK:0}\n            for color in (chess.WHITE, chess.BLACK):\n                board.turn = color\n                for mv in board.legal_moves:\n                    # treat a move as capture if destination square currently has a piece of opposite color\n                    target = board.piece_at(mv.to_square)\n                    if target and target.color != color:\n                        captures[color] += 1\n            return float(captures[chess.WHITE] - captures[chess.BLACK])\n        finally:\n            board.turn = orig\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'King pawn-shield gap score: (black_shield_worse - white_shield_worse) positive favors White when Black weaker'\n    try:\n        pm = board.piece_map()\n        def shield_worse(color):\n            ksq = next((sq for sq,p in pm.items() if p and p.piece_type==chess.KING and p.color==color), None)\n            if ksq is None:\n                return 0.0\n            f = chess.square_file(ksq); r = chess.square_rank(ksq)\n            missing = 0.0\n            attacker_pressure = 0.0\n            # consider up to two ranks in front and three files (diagonals included)\n            dirs = [1,2] if color==chess.WHITE else [-1,-2]\n            enemy = chess.BLACK if color==chess.WHITE else chess.WHITE\n            desired = 0\n            for d in dirs:\n                rr = r + d\n                if 0 <= rr <= 7:\n                    for ff in (f-1, f, f+1):\n                        if 0 <= ff <= 7:\n                            desired += 1\n                            p = board.piece_at(chess.square(ff, rr))\n                            if not (p and p.piece_type==chess.PAWN and p.color==color):\n                                missing += 1.0\n                            # pressure is number of enemy attackers on that square\n                            attacker_pressure += len(board.attackers(enemy, chess.square(ff, rr)))\n            # normalize by desired (avoid divide by zero)\n            if desired == 0:\n                return 0.0\n            # scale: missing is primary, pressure increases penalty\n            return (missing / desired) + 0.12 * (attacker_pressure / float(desired))\n        w = shield_worse(chess.WHITE)\n        b = shield_worse(chess.BLACK)\n        return float(b - w)\n    except Exception:\n        return 0.0\n",
    "def feature(board: chess.Board) -> float:\n    'Passed pawns weighted by advancement (white - black); advanced passed pawns score more'\n    try:\n        pm = board.piece_map()\n        def is_passed(sq, color):\n            f = chess.square_file(sq); r = chess.square_rank(sq)\n            opp = chess.BLACK if color == chess.WHITE else chess.WHITE\n            # for white, opposing pawns on same or adjacent files with rank > r block; for black rank < r\n            for df in (-1, 0, 1):\n                ff = f + df\n                if ff < 0 or ff > 7:\n                    continue\n                if color == chess.WHITE:\n                    for rr in range(r+1, 8):\n                        s = chess.square(ff, rr)\n                        p = pm.get(s)\n                        if p and p.piece_type == chess.PAWN and p.color == opp:\n                            return False\n                else:\n                    for rr in range(r-1, -1, -1):\n                        s = chess.square(ff, rr)\n                        p = pm.get(s)\n                        if p and p.piece_type == chess.PAWN and p.color == opp:\n                            return False\n            return True\n        score = {chess.WHITE:0.0, chess.BLACK:0.0}\n        for sq,p in pm.items():\n            if not p or p.piece_type != chess.PAWN:\n                continue\n            if is_passed(sq, p.color):\n                # advancement weight: pawns closer to promotion are more valuable\n                rank = chess.square_rank(sq)\n                adv = (rank / 7.0) if p.color == chess.WHITE else ((7 - rank) / 7.0)\n                score[p.color] += 1.0 + 2.0 * adv\n        return float(score[chess.WHITE] - score[chess.BLACK])\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Connected passed pawns bonus: extra for adjacent-file passed pawns (white - black)'\n    try:\n        pm = board.piece_map()\n        passed = {chess.WHITE:set(), chess.BLACK:set()}\n        # reuse passed detection similar to previous but simpler\n        def is_passed_quick(sq, color):\n            f = chess.square_file(sq); r = chess.square_rank(sq)\n            opp = chess.BLACK if color == chess.WHITE else chess.WHITE\n            for df in (-1, 0, 1):\n                ff = f + df\n                if ff < 0 or ff > 7:\n                    continue\n                if color == chess.WHITE:\n                    for rr in range(r+1, 8):\n                        p = pm.get(chess.square(ff, rr))\n                        if p and p.piece_type == chess.PAWN and p.color == opp:\n                            return False\n                else:\n                    for rr in range(r-1, -1, -1):\n                        p = pm.get(chess.square(ff, rr))\n                        if p and p.piece_type == chess.PAWN and p.color == opp:\n                            return False\n            return True\n        for sq,p in pm.items():\n            if p and p.piece_type == chess.PAWN and is_passed_quick(sq, p.color):\n                passed[p.color].add(sq)\n        score = 0.0\n        for color in (chess.WHITE, chess.BLACK):\n            # check for adjacent-file passed pawns\n            files = sorted(set(chess.square_file(sq) for sq in passed[color]))\n            conn = 0\n            for i in range(len(files)-1):\n                if files[i+1] == files[i] + 1:\n                    conn += 1\n            # reward connected passed pawns (each connection counts)\n            if color == chess.WHITE:\n                score += 0.0 + conn * 1.6\n            else:\n                score -= conn * 1.6\n        return float(score)\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Pawn structure weaknesses: isolated and doubled pawn penalties (white - black)'\n    try:\n        pm = board.piece_map()\n        isolated = {chess.WHITE:0.0, chess.BLACK:0.0}\n        doubled = {chess.WHITE:0.0, chess.BLACK:0.0}\n        pawns_by_file = {f:{chess.WHITE:[], chess.BLACK:[]} for f in range(8)}\n        for sq,p in pm.items():\n            if p and p.piece_type == chess.PAWN:\n                pawns_by_file[chess.square_file(sq)][p.color].append(sq)\n        for f in range(8):\n            for color in (chess.WHITE, chess.BLACK):\n                # doubled pawns: more than one pawn on same file\n                count = len(pawns_by_file[f][color])\n                if count > 1:\n                    doubled[color] += (count - 1) * 1.0\n                # isolated: no friendly pawn on adjacent files\n                has_adj = False\n                for af in (f-1, f+1):\n                    if 0 <= af < 8 and len(pawns_by_file[af][color]) > 0:\n                        has_adj = True\n                        break\n                if not has_adj and count > 0:\n                    isolated[color] += count * 1.2\n        # higher is worse, so produce (white - black) penalty\n        return float((isolated[chess.BLACK] + doubled[chess.BLACK]) - (isolated[chess.WHITE] + doubled[chess.WHITE]))\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Knight outpost count: knights on opponent half not attackable by enemy pawns and supported by a pawn (white - black)'\n    try:\n        pm = board.piece_map()\n        score = {chess.WHITE:0.0, chess.BLACK:0.0}\n        for sq,p in pm.items():\n            if not p or p.piece_type != chess.KNIGHT:\n                continue\n            f = chess.square_file(sq); r = chess.square_rank(sq)\n            color = p.color\n            opp = chess.BLACK if color == chess.WHITE else chess.WHITE\n            # must be in opponent half for potential outpost\n            if color == chess.WHITE and r < 4:\n                continue\n            if color == chess.BLACK and r > 3:\n                continue\n            # check if enemy pawn attacks this square\n            attacked_by_pawn = False\n            if color == chess.WHITE:\n                # black pawns that can attack sq would be at (f-1,r+1) or (f+1,r+1)\n                for df in (-1, 1):\n                    ff = f + df; rr = r + 1\n                    if 0 <= ff < 8 and 0 <= rr < 8:\n                        p2 = pm.get(chess.square(ff, rr))\n                        if p2 and p2.piece_type == chess.PAWN and p2.color == opp:\n                            attacked_by_pawn = True\n                            break\n            else:\n                for df in (-1, 1):\n                    ff = f + df; rr = r - 1\n                    if 0 <= ff < 8 and 0 <= rr < 8:\n                        p2 = pm.get(chess.square(ff, rr))\n                        if p2 and p2.piece_type == chess.PAWN and p2.color == opp:\n                            attacked_by_pawn = True\n                            break\n            if attacked_by_pawn:\n                continue\n            # supported by a friendly pawn behind (typical outpost support)\n            supported = False\n            if color == chess.WHITE:\n                for df in (-1, 1):\n                    ff = f + df; rr = r - 1\n                    if 0 <= ff < 8 and 0 <= rr < 8:\n                        p2 = pm.get(chess.square(ff, rr))\n                        if p2 and p2.piece_type == chess.PAWN and p2.color == color:\n                            supported = True\n                            break\n            else:\n                for df in (-1, 1):\n                    ff = f + df; rr = r + 1\n                    if 0 <= ff < 8 and 0 <= rr < 8:\n                        p2 = pm.get(chess.square(ff, rr))\n                        if p2 and p2.piece_type == chess.PAWN and p2.color == color:\n                            supported = True\n                            break\n            if supported:\n                # central files are more valuable outposts\n                central_bonus = 1.0 if f in (3,4) else 0.6 if f in (2,5) else 0.3\n                score[color] += central_bonus\n        return float(score[chess.WHITE] - score[chess.BLACK])\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Rook on seventh rank pressure: counts rooks on opponent\\'s seventh rank and attacks from there (white - black)'\n    try:\n        pm = board.piece_map()\n        score = {chess.WHITE:0.0, chess.BLACK:0.0}\n        for sq,p in pm.items():\n            if not p or p.piece_type != chess.ROOK:\n                continue\n            r = chess.square_rank(sq)\n            color = p.color\n            # white rook on rank 6 (7th rank) is strong, black rook on rank 1 (7th for black) is strong\n            if color == chess.WHITE and r == 6:\n                # bonus plus how many enemy pawns on that rank/file it attacks (pressure)\n                attacks = len(board.attackers(chess.WHITE, sq))\n                score[color] += 1.5\n            if color == chess.BLACK and r == 1:\n                score[color] += 1.5\n        return float(score[chess.WHITE] - score[chess.BLACK])\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Queen centralization and queen mobility combined: central placement bonus + normalized queen legal moves (white - black)'\n    try:\n        pm = board.piece_map()\n        centers = {chess.WHITE:0.0, chess.BLACK:0.0}\n        mobility = {chess.WHITE:0.0, chess.BLACK:0.0}\n        orig = board.turn\n        try:\n            for color in (chess.WHITE, chess.BLACK):\n                # centralization: queens on d4/d5/e4/e5\n                for sq,p in pm.items():\n                    if p and p.piece_type == chess.QUEEN and p.color == color:\n                        if chess.square_name(sq) in ('d4','d5','e4','e5'):\n                            centers[color] += 1.0\n                # mobility: count queen moves\n                board.turn = color\n                q_moves = 0\n                for mv in board.legal_moves:\n                    p = board.piece_at(mv.from_square)\n                    if p and p.piece_type == chess.QUEEN and p.color == color:\n                        q_moves += 1\n                # normalize by an expected ceiling (30)\n                mobility[color] = float(q_moves) / 30.0\n        finally:\n            board.turn = orig\n        return float((centers[chess.WHITE] + mobility[chess.WHITE]) - (centers[chess.BLACK] + mobility[chess.BLACK]))\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'King centralization bonus in endgames: favors centralized kings when few pieces remain (white - black)'\n    try:\n        pm = board.piece_map()\n        vals = {chess.PAWN:1.0, chess.KNIGHT:3.0, chess.BISHOP:3.0, chess.ROOK:5.0, chess.QUEEN:9.0}\n        total_mat = 0.0\n        for p in pm.values():\n            if p and p.piece_type in vals:\n                total_mat += vals[p.piece_type]\n        # endgame factor: stronger when less material\n        endgame_factor = min(1.0, max(0.0, (20.0 - total_mat) / 20.0))\n        def centralization(color):\n            ksq = next((sq for sq,p in pm.items() if p and p.piece_type == chess.KING and p.color == color), None)\n            if ksq is None:\n                return 0.0\n            # center square roughly at 3.5,3.5; use Manhattan distance to center and invert\n            f = chess.square_file(ksq); r = chess.square_rank(ksq)\n            dist = abs(f - 3.5) + abs(r - 3.5)\n            # normalize: max possible ~7.0 -> invert to 0..1\n            cent = max(0.0, (7.0 - dist) / 7.0)\n            return cent * endgame_factor\n        return float(centralization(chess.WHITE) - centralization(chess.BLACK))\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Piece coordination ratio: (fraction of pieces defended - fraction attacked) (white - black)'\n    try:\n        pm = board.piece_map()\n        coord = {chess.WHITE:0.0, chess.BLACK:0.0}\n        totals = {chess.WHITE:0, chess.BLACK:0}\n        for sq,p in pm.items():\n            if not p:\n                continue\n            color = p.color\n            totals[color] += 1\n            defenders = len(board.attackers(color, sq))\n            attackers = len(board.attackers(chess.BLACK if color==chess.WHITE else chess.WHITE, sq))\n            defended = 1 if defenders > 0 else 0\n            attacked = 1 if attackers > 0 else 0\n            coord[color] += defended - attacked\n        # normalize by piece counts\n        score_w = coord[chess.WHITE] / totals[chess.WHITE] if totals[chess.WHITE] > 0 else 0.0\n        score_b = coord[chess.BLACK] / totals[chess.BLACK] if totals[chess.BLACK] > 0 else 0.0\n        return float(score_w - score_b)\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Pinned pieces weighted by value: (black_pinned_total - white_pinned_total) -> positive favors White'\n    try:\n        pm = board.piece_map()\n        vals = {chess.PAWN:1.0, chess.KNIGHT:3.0, chess.BISHOP:3.0, chess.ROOK:5.0, chess.QUEEN:9.0, chess.KING:0.0}\n        pinned_value = {chess.WHITE:0.0, chess.BLACK:0.0}\n        # helper to check alignment and blocking between two squares\n        def sign(x):\n            return (1 if x>0 else -1 if x<0 else 0)\n        # find kings\n        kings = {chess.WHITE:None, chess.BLACK:None}\n        for sq,p in pm.items():\n            if p and p.piece_type == chess.KING:\n                kings[p.color] = sq\n        for sq,p in pm.items():\n            if not p or p.piece_type == chess.KING:\n                continue\n            color = p.color\n            opp = chess.BLACK if color == chess.WHITE else chess.WHITE\n            ksq = kings[color]\n            if ksq is None:\n                continue\n            # check attackers of this square\n            attackers = list(board.attackers(opp, sq))\n            for a in attackers:\n                ap = pm.get(a)\n                if not ap:\n                    continue\n                # only sliding pieces can pin (rook, bishop, queen)\n                if ap.piece_type not in (chess.ROOK, chess.BISHOP, chess.QUEEN):\n                    continue\n                af = chess.square_file(a); ar = chess.square_rank(a)\n                kf = chess.square_file(ksq); kr = chess.square_rank(ksq)\n                # direction from attacker to king\n                dx = kf - af; dy = kr - ar\n                sx = sign(dx); sy = sign(dy)\n                # ensure attacker and king are aligned in rook/bishop direction\n                if not ( (af == kf and ap.piece_type in (chess.ROOK, chess.QUEEN)) or\n                         (ar == kr and ap.piece_type in (chess.ROOK, chess.QUEEN)) or\n                         (abs(dx) == abs(dy) and ap.piece_type in (chess.BISHOP, chess.QUEEN)) ):\n                    continue\n                # check squares between attacker and king: should be exactly one blocker (our piece) or this piece should be on the ray between them\n                sq_between = []\n                x = af + sx; y = ar + sy\n                while 0 <= x < 8 and 0 <= y < 8:\n                    cur = chess.square(x, y)\n                    if cur == ksq:\n                        break\n                    sq_between.append(cur)\n                    x += sx; y += sy\n                # if our piece sq is in between and no other pieces between attacker and king except possibly our piece, it's pinned\n                blockers = [s for s in sq_between if pm.get(s) is not None]\n                # our piece square should be among blockers, and blockers length should be exactly 1 (only our piece)\n                if sq in blockers and len(blockers) == 1:\n                    pinned_value[color] += vals.get(p.piece_type, 0.0)\n                    break\n        # return (black_pinned - white_pinned) so positive means black is more pinned (good for white)\n        return float(pinned_value[chess.BLACK] - pinned_value[chess.WHITE])\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Hanging (undefended) pieces attacked by opponent: (black_hanging - white_hanging) positive favors White'\n    try:\n        pm = board.piece_map()\n        hanging = {chess.WHITE:0.0, chess.BLACK:0.0}\n        vals = {chess.PAWN:1.0, chess.KNIGHT:3.0, chess.BISHOP:3.0, chess.ROOK:5.0, chess.QUEEN:9.0, chess.KING:0.0}\n        for sq,p in pm.items():\n            if not p:\n                continue\n            color = p.color\n            opp = chess.BLACK if color == chess.WHITE else chess.WHITE\n            attackers = len(board.attackers(opp, sq))\n            defenders = len(board.attackers(color, sq))\n            if attackers > 0 and defenders == 0:\n                hanging[color] += vals.get(p.piece_type, 0.0)\n        # return black_hanging - white_hanging so positive means black has more hanging pieces (good for white)\n        return float(hanging[chess.BLACK] - hanging[chess.WHITE])\n    except Exception:\n        return 0.0\n",
    "def feature(board: chess.Board) -> float:\n    'Passed pawn score: advanced passed pawns weighted by advancement (white - black)'\n    try:\n        pm = board.piece_map()\n        def is_passed(sq, color):\n            f = chess.square_file(sq); r = chess.square_rank(sq)\n            if color == chess.WHITE:\n                # no enemy pawn on same or adjacent files on any higher rank\n                for rr in range(r+1, 8):\n                    for af in (f-1, f, f+1):\n                        if 0 <= af < 8:\n                            p = pm.get(chess.square(af, rr))\n                            if p and p.piece_type == chess.PAWN and p.color == chess.BLACK:\n                                return False\n                return True\n            else:\n                for rr in range(r-1, -1, -1):\n                    for af in (f-1, f, f+1):\n                        if 0 <= af < 8:\n                            p = pm.get(chess.square(af, rr))\n                            if p and p.piece_type == chess.PAWN and p.color == chess.WHITE:\n                                return False\n                return True\n        score_w = 0.0; score_b = 0.0\n        for sq,p in pm.items():\n            if not p or p.piece_type != chess.PAWN:\n                continue\n            if is_passed(sq, p.color):\n                r = chess.square_rank(sq)\n                # advancement: for white higher rank is better, for black lower rank is better\n                if p.color == chess.WHITE:\n                    adv = max(0.0, (r - 1) / 6.0)  # 0..1\n                    score_w += 1.0 + 3.0 * adv\n                else:\n                    adv = max(0.0, (6 - r) / 6.0)\n                    score_b += 1.0 + 3.0 * adv\n        return float(score_w - score_b)\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Rook activity: rooks on 7th/2nd rank and on open or semi-open files (white - black)'\n    try:\n        pm = board.piece_map()\n        pawn_files = {f: {'w':0, 'b':0} for f in range(8)}\n        for sq,p in pm.items():\n            if not p or p.piece_type != chess.PAWN:\n                continue\n            f = chess.square_file(sq)\n            pawn_files[f]['w' if p.color==chess.WHITE else 'b'] += 1\n        def rook_score(color):\n            score = 0.0\n            target_rank = 6 if color==chess.WHITE else 1\n            for sq,p in pm.items():\n                if not p or p.piece_type != chess.ROOK or p.color != color:\n                    continue\n                f = chess.square_file(sq); r = chess.square_rank(sq)\n                # 7th rank bonus\n                if r == target_rank:\n                    score += 2.0\n                # open/semi-open file\n                pf = pawn_files[f]\n                total_on_file = pf['w'] + pf['b']\n                if total_on_file == 0:\n                    score += 1.5\n                elif (pf['w'] == 0 and color==chess.WHITE) or (pf['b'] == 0 and color==chess.BLACK):\n                    score += 0.9\n            return score\n        return float(rook_score(chess.WHITE) - rook_score(chess.BLACK))\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Undefended/hanging material value: sum of piece values where attackers > defenders (positive when Black is more undefended so favors White)'\n    try:\n        vals = {chess.PAWN:1.0, chess.KNIGHT:3.0, chess.BISHOP:3.0, chess.ROOK:5.0, chess.QUEEN:9.0, chess.KING:0.0}\n        pm = board.piece_map()\n        undef = {chess.WHITE:0.0, chess.BLACK:0.0}\n        for sq,p in pm.items():\n            if not p:\n                continue\n            attackers = len(board.attackers(not p.color, sq))\n            defenders = len(board.attackers(p.color, sq))\n            if attackers > defenders:\n                undef[p.color] += vals.get(p.piece_type, 0.0) * (attackers - defenders)\n        # positive if Black has more undefended material => advantage for White\n        return float(undef[chess.BLACK] - undef[chess.WHITE])\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Pawn majority and advancement by sector: kingside/center/queenside majority weighted by advancement (white - black)'\n    try:\n        pm = board.piece_map()\n        sectors = {\n            'qs': range(0,3),  # a,b,c\n            'ctr': range(3,5), # d,e\n            'ks': range(5,8)   # f,g,h\n        }\n        def sector_score(color):\n            score = 0.0\n            for name, files in sectors.items():\n                count = 0; adv_sum = 0.0\n                for sq,p in pm.items():\n                    if not p or p.piece_type != chess.PAWN or p.color != color:\n                        continue\n                    f = chess.square_file(sq)\n                    if f in files:\n                        count += 1\n                        r = chess.square_rank(sq)\n                        # advancement normalized 0..1 (white higher rank better)\n                        if color == chess.WHITE:\n                            adv_sum += r / 7.0\n                        else:\n                            adv_sum += (7 - r) / 7.0\n                if count > 0:\n                    adv = adv_sum / count\n                else:\n                    adv = 0.0\n                weight = 0.9 if name=='ks' else (1.1 if name=='ctr' else 0.7)\n                score += weight * count * (0.5 + 0.5 * adv)\n            return score\n        return float(sector_score(chess.WHITE) - sector_score(chess.BLACK))\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Development gap for minor pieces: number of minor pieces developed off original squares (white - black)'\n    try:\n        pm = board.piece_map()\n        white_start = {chess.parse_square(s) for s in ('b1','g1','c1','f1')}\n        black_start = {chess.parse_square(s) for s in ('b8','g8','c8','f8')}\n        def developed(color):\n            total_minors = 0\n            on_start = 0\n            for sq,p in pm.items():\n                if not p or p.color != color or p.piece_type not in (chess.KNIGHT, chess.BISHOP):\n                    continue\n                total_minors += 1\n                if (color==chess.WHITE and sq in white_start) or (color==chess.BLACK and sq in black_start):\n                    on_start += 1\n            return float(total_minors - on_start)\n        return float(developed(chess.WHITE) - developed(chess.BLACK))\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'King exposure: number of adjacent files without friendly pawns (positive when Black is more exposed so favors White)'\n    try:\n        pm = board.piece_map()\n        def exposure(color):\n            ks = next((sq for sq,p in pm.items() if p and p.piece_type==chess.KING and p.color==color), None)\n            if ks is None:\n                return 0.0\n            f = chess.square_file(ks)\n            exp = 0\n            # gather friendly pawn files\n            pawn_files = set()\n            for sq,p in pm.items():\n                if p and p.piece_type==chess.PAWN and p.color==color:\n                    pawn_files.add(chess.square_file(sq))\n            for ff in (f-1, f, f+1):\n                if 0 <= ff <= 7:\n                    if ff not in pawn_files:\n                        exp += 1\n            return float(exp)\n        return float(exposure(chess.BLACK) - exposure(chess.WHITE))\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Control of the small center (d4,e4,d5,e5): number of central squares attacked (white - black)'\n    try:\n        center_sqs = [chess.parse_square(s) for s in ('d4','e4','d5','e5')]\n        cw = 0; cb = 0\n        for sq in center_sqs:\n            if board.is_attacked_by(chess.WHITE, sq):\n                cw += 1\n            if board.is_attacked_by(chess.BLACK, sq):\n                cb += 1\n        return float(cw - cb)\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Bishop pair value amplified by board openness: favors two bishops on open boards (white - black)'\n    try:\n        pm = board.piece_map()\n        # openness: fraction of files with no pawns\n        pawn_on_file = [0]*8\n        for sq,p in pm.items():\n            if p and p.piece_type==chess.PAWN:\n                pawn_on_file[chess.square_file(sq)] += 1\n        open_files = sum(1 for c in pawn_on_file if c==0)\n        openness = open_files / 8.0\n        def bishop_pair_score(color):\n            bishops = sum(1 for p in pm.values() if p and p.color==color and p.piece_type==chess.BISHOP)\n            return float((1 if bishops >= 2 else 0) * (1.0 + 2.0 * openness))\n        return float(bishop_pair_score(chess.WHITE) - bishop_pair_score(chess.BLACK))\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Tactical mobility: legal captures and checks available (white - black)'\n    try:\n        orig = board.turn\n        try:\n            score = {chess.WHITE:0.0, chess.BLACK:0.0}\n            for color in (chess.WHITE, chess.BLACK):\n                board.turn = color\n                moves = list(board.legal_moves)\n                caps = 0; checks = 0\n                for mv in moves:\n                    # approximate capture: piece on to_square or pawn diagonal move to empty (en-passant approximation)\n                    to_piece = board.piece_at(mv.to_square)\n                    from_piece = board.piece_at(mv.from_square)\n                    is_capture = to_piece is not None\n                    if not is_capture and from_piece and from_piece.piece_type==chess.PAWN and chess.square_file(mv.from_square)!=chess.square_file(mv.to_square):\n                        # likely en-passant capture\n                        is_capture = True\n                    if is_capture:\n                        caps += 1\n                    # check detection via push/pop\n                    try:\n                        board.push(mv)\n                        if board.is_check():\n                            checks += 1\n                        board.pop()\n                    except Exception:\n                        # in case push fails, ignore\n                        pass\n                score[color] = caps + 1.2 * checks\n            return float(score[chess.WHITE] - score[chess.BLACK])\n        finally:\n            board.turn = orig\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Net control of opponent half: number of squares in opponent half attacked by a side normalized by piece count (white - black)'\n    try:\n        pm = board.piece_map()\n        def control_in_opp_half(color):\n            count = 0\n            # opponent half definition\n            if color == chess.WHITE:\n                ranks = range(4,8)\n            else:\n                ranks = range(0,4)\n            for r in ranks:\n                for f in range(8):\n                    sq = chess.square(f, r)\n                    if board.is_attacked_by(color, sq):\n                        count += 1\n            # normalize by number of pieces (avoid division by zero)\n            pieces = sum(1 for p in pm.values() if p and p.color == color)\n            return float(count) / max(1.0, pieces)\n        return float(control_in_opp_half(chess.WHITE) - control_in_opp_half(chess.BLACK))\n    except Exception:\n        return 0.0\n",
    "def feature(board: chess.Board) -> float:\n    'Passed pawn pressure: sum of passed pawns weighted by advancement and pawn support (white - black)'\n    try:\n        pm = board.piece_map()\n        def is_passed(sq, color):\n            f = chess.square_file(sq); r = chess.square_rank(sq)\n            enemy = chess.BLACK if color == chess.WHITE else chess.WHITE\n            # for white, enemy pawns must not exist on same or adjacent files on ranks >= r+1\n            if color == chess.WHITE:\n                for af in (f-1, f, f+1):\n                    if af < 0 or af > 7:\n                        continue\n                    for ar in range(r+1, 8):\n                        psq = chess.square(af, ar)\n                        p = pm.get(psq)\n                        if p and p.piece_type == chess.PAWN and p.color == enemy:\n                            return False\n                return True\n            else:\n                for af in (f-1, f, f+1):\n                    if af < 0 or af > 7:\n                        continue\n                    for ar in range(0, r):\n                        psq = chess.square(af, ar)\n                        p = pm.get(psq)\n                        if p and p.piece_type == chess.PAWN and p.color == enemy:\n                            return False\n                return True\n        def supported_by_pawn(sq, color):\n            f = chess.square_file(sq); r = chess.square_rank(sq)\n            dirs = -1 if color == chess.WHITE else 1\n            for af in (f-1, f+1):\n                br = r + dirs\n                if 0 <= af <= 7 and 0 <= br <= 7:\n                    p = pm.get(chess.square(af, br))\n                    if p and p.piece_type == chess.PAWN and p.color == color:\n                        return True\n            return False\n        score_w = 0.0; score_b = 0.0\n        for sq, p in pm.items():\n            if not p or p.piece_type != chess.PAWN:\n                continue\n            color = p.color\n            if is_passed(sq, color):\n                r = chess.square_rank(sq)\n                adv = (r / 7.0) if color == chess.WHITE else ((7 - r) / 7.0)\n                sup = 0.4 if supported_by_pawn(sq, color) else 0.0\n                weight = 1.0 + 1.8 * adv + sup  # base + advancement bonus + support\n                if color == chess.WHITE:\n                    score_w += weight\n                else:\n                    score_b += weight\n        return float(score_w - score_b)\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Rook file control: rooks on open (no pawns) or semi-open (no friendly pawns) files (white - black)'\n    try:\n        pm = board.piece_map()\n        def rook_file_score(color):\n            s = 0.0\n            for sq, p in pm.items():\n                if not p or p.piece_type != chess.ROOK or p.color != color:\n                    continue\n                f = chess.square_file(sq)\n                pawns_on_file = [q for q, pp in pm.items() if pp and pp.piece_type == chess.PAWN and chess.square_file(q) == f]\n                if len(pawns_on_file) == 0:\n                    s += 1.6  # open file\n                else:\n                    friendly = any(pm[q].color == color for q in pawns_on_file)\n                    if not friendly:\n                        s += 1.0  # semi-open file\n            return s\n        return float(rook_file_score(chess.WHITE) - rook_file_score(chess.BLACK))\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Bishop-pair effectiveness: if a side has two bishops, reward mobility adjusted for overall pawn density (white - black)'\n    try:\n        pm = board.piece_map()\n        def bishop_mobility_sq(sq):\n            f = chess.square_file(sq); r = chess.square_rank(sq)\n            steps = 0\n            for df, dr in ((1,1),(1,-1),(-1,1),(-1,-1)):\n                ff, rr = f + df, r + dr\n                while 0 <= ff <= 7 and 0 <= rr <= 7:\n                    qs = chess.square(ff, rr)\n                    if pm.get(qs):\n                        steps += 1  # can capture or blocked on this square\n                        break\n                    steps += 1\n                    ff += df; rr += dr\n            return steps\n        total_pawns = sum(1 for p in pm.values() if p and p.piece_type == chess.PAWN)\n        denom = max(1.0, total_pawns)\n        score_w = 0.0; score_b = 0.0\n        for color in (chess.WHITE, chess.BLACK):\n            bishops = [sq for sq,p in pm.items() if p and p.piece_type == chess.BISHOP and p.color == color]\n            if len(bishops) >= 2:\n                mob = sum(bishop_mobility_sq(sq) for sq in bishops)\n                # fewer pawns increases bishop effectiveness\n                eff = mob * (1.0 + (12.0 - denom) / 30.0)\n            else:\n                eff = 0.0\n            if color == chess.WHITE:\n                score_w = eff\n            else:\n                score_b = eff\n        return float(score_w - score_b)\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Pawn majority on flanks: kingside and queenside pawn majority weighted by phase (white - black)'\n    try:\n        pm = board.piece_map()\n        def counts():\n            w = {'ks':0,'qs':0}; b = {'ks':0,'qs':0}\n            for sq,p in pm.items():\n                if not p or p.piece_type != chess.PAWN:\n                    continue\n                f = chess.square_file(sq)\n                # kingside files f,g,h -> 5,6,7 ; queenside a,b,c,d -> 0-3\n                if f >= 5:\n                    if p.color == chess.WHITE: w['ks'] += 1\n                    else: b['ks'] += 1\n                elif f <= 3:\n                    if p.color == chess.WHITE: w['qs'] += 1\n                    else: b['qs'] += 1\n            return w, b\n        # estimate phase by non-pawn material\n        vals = {chess.PAWN:1.0, chess.KNIGHT:3.0, chess.BISHOP:3.0, chess.ROOK:5.0, chess.QUEEN:9.0, chess.KING:0.0}\n        mat = 0.0\n        for p in pm.values():\n            if p and p.piece_type != chess.PAWN:\n                mat += vals.get(p.piece_type, 0.0)\n        phase = max(0.2, min(1.0, 1.0 - mat / 40.0))  # closer to 1 in endgame\n        w, b = counts()\n        ks_diff = (w['ks'] - b['ks']) * 0.9\n        qs_diff = (w['qs'] - b['qs']) * 0.6\n        return float(phase * (ks_diff * 1.2 + qs_diff * 1.0))\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Central influence: occupied and attacked control of core and extended center (weighted) (white - black)'\n    try:\n        central_names = ['d4','e4','d5','e5','c4','f4','c5','f5']\n        central_sqs = [chess.parse_square(n) for n in central_names]\n        score_w = 0.0; score_b = 0.0\n        for sq in central_sqs:\n            occ = board.piece_at(sq)\n            if occ:\n                if occ.color == chess.WHITE:\n                    score_w += 1.0\n                else:\n                    score_b += 1.0\n            else:\n                if board.is_attacked_by(chess.WHITE, sq):\n                    score_w += 0.45\n                if board.is_attacked_by(chess.BLACK, sq):\n                    score_b += 0.45\n        return float(score_w - score_b)\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'King centralization benefit in endgame: rewards more centralized king when material is low (white - black)'\n    try:\n        pm = board.piece_map()\n        vals = {chess.PAWN:1.0, chess.KNIGHT:3.0, chess.BISHOP:3.0, chess.ROOK:5.0, chess.QUEEN:9.0, chess.KING:0.0}\n        material = 0.0\n        for p in pm.values():\n            if p:\n                material += vals.get(p.piece_type, 0.0)\n        # exclude kings: material without kings\n        material_no_kings = material\n        # endgame factor: more when material low\n        phase = max(0.0, min(1.0, (20.0 - material_no_kings) / 20.0))\n        def center_score_for(color):\n            king_sq = next((sq for sq,p in pm.items() if p and p.piece_type == chess.KING and p.color == color), None)\n            if king_sq is None:\n                return 0.0\n            # center is between d4,e4,d5,e5 approximate center coord (3.5,3.5)\n            f = chess.square_file(king_sq); r = chess.square_rank(king_sq)\n            dist = abs(f - 3.5) + abs(r - 3.5)  # Manhattan-ish to center\n            # normalize: max around 7\n            cent = (7.0 - dist) / 7.0\n            return cent\n        return float(phase * (center_score_for(chess.WHITE) - center_score_for(chess.BLACK)))\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Number of pinned non-pawn pieces to the king (white - black), approximated by line-of-sight to sliding enemy pieces'\n    try:\n        pm = board.piece_map()\n        def pinned_count(color):\n            cnt = 0\n            king_sq = next((sq for sq,p in pm.items() if p and p.piece_type == chess.KING and p.color == color), None)\n            if king_sq is None:\n                return 0.0\n            kf = chess.square_file(king_sq); kr = chess.square_rank(king_sq)\n            enemy = chess.BLACK if color == chess.WHITE else chess.WHITE\n            for sq, p in pm.items():\n                if not p or p.color != color or p.piece_type == chess.PAWN or p.piece_type == chess.KING:\n                    continue\n                ff = chess.square_file(sq); rr = chess.square_rank(sq)\n                df = ff - kf; dr = rr - kr\n                # aligned?\n                if df == 0:\n                    step = (0, 1 if dr > 0 else -1)\n                elif dr == 0:\n                    step = (1 if df > 0 else -1, 0)\n                elif abs(df) == abs(dr):\n                    step = (1 if df > 0 else -1, 1 if dr > 0 else -1)\n                else:\n                    continue\n                # check squares between king and candidate are empty\n                tx, ty = kf + step[0], kr + step[1]\n                blocked = False\n                found_candidate = False\n                while 0 <= tx <= 7 and 0 <= ty <= 7:\n                    tsq = chess.square(tx, ty)\n                    if tsq == sq:\n                        found_candidate = True\n                        tx += step[0]; ty += step[1]\n                        break\n                    if pm.get(tsq):\n                        blocked = True\n                        break\n                    tx += step[0]; ty += step[1]\n                if blocked or not found_candidate:\n                    continue\n                # now scan further beyond candidate for first piece\n                while 0 <= tx <= 7 and 0 <= ty <= 7:\n                    tsq = chess.square(tx, ty)\n                    piece = pm.get(tsq)\n                    if piece:\n                        # if piece is opponent sliding piece with line matching, count as pin\n                        if piece.color == enemy:\n                            if step[0] == 0 or step[1] == 0:\n                                if piece.piece_type in (chess.ROOK, chess.QUEEN):\n                                    cnt += 1\n                                    break\n                            else:\n                                if piece.piece_type in (chess.BISHOP, chess.QUEEN):\n                                    cnt += 1\n                                    break\n                        break\n                    tx += step[0]; ty += step[1]\n            return float(cnt)\n        return float(pinned_count(chess.WHITE) - pinned_count(chess.BLACK))\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Undefended attacked material: sum of piece values attacked by opponent with zero defenders (white - black)'\n    try:\n        pm = board.piece_map()\n        vals = {chess.PAWN:1.0, chess.KNIGHT:3.0, chess.BISHOP:3.0, chess.ROOK:5.0, chess.QUEEN:9.0, chess.KING:0.0}\n        sum_w = 0.0; sum_b = 0.0\n        for sq, p in pm.items():\n            if not p:\n                continue\n            color = p.color\n            opp = chess.BLACK if color == chess.WHITE else chess.WHITE\n            attackers = len(board.attackers(opp, sq))\n            defenders = len(board.attackers(color, sq))\n            if attackers > 0 and defenders == 0:\n                val = vals.get(p.piece_type, 0.0)\n                if color == chess.WHITE:\n                    sum_w += val\n                else:\n                    sum_b += val\n        # positive favors White (if Black has more undefended attacked material then return positive)\n        return float(sum_b - sum_w)\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Rooks on the 7th/2nd ranks: rewards rooks penetrating opponent rank (white - black)'\n    try:\n        pm = board.piece_map()\n        r7_w = 0.0; r7_b = 0.0\n        for sq, p in pm.items():\n            if not p or p.piece_type != chess.ROOK:\n                continue\n            r = chess.square_rank(sq)\n            if p.color == chess.WHITE:\n                if r == 6:  # white rook on 7th rank\n                    r7_w += 1.0\n                # also reward a white rook on black back rank (rank 7)\n                if r == 7:\n                    r7_w += 1.5\n            else:\n                if r == 1:  # black rook on 2nd rank\n                    r7_b += 1.0\n                if r == 0:\n                    r7_b += 1.5\n        return float(r7_w - r7_b)\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Pawn structure fragility: doubled + backward pawns (black - white) positive favors White if Black is worse'\n    try:\n        pm = board.piece_map()\n        doubled_w = 0; doubled_b = 0\n        for f in range(8):\n            pawns_on_file = [sq for sq,p in pm.items() if p and p.piece_type == chess.PAWN and chess.square_file(sq) == f]\n            wcount = sum(1 for sq in pawns_on_file if pm[sq].color == chess.WHITE)\n            bcount = sum(1 for sq in pawns_on_file if pm[sq].color == chess.BLACK)\n            if wcount > 1: doubled_w += (wcount - 1)\n            if bcount > 1: doubled_b += (bcount - 1)\n        def backward_count(color):\n            cnt = 0\n            for sq,p in pm.items():\n                if not p or p.piece_type != chess.PAWN or p.color != color:\n                    continue\n                f = chess.square_file(sq); r = chess.square_rank(sq)\n                has_support = False\n                # check adjacent files for pawn behind (for white behind means r-1)\n                if color == chess.WHITE:\n                    for af in (f-1, f+1):\n                        if 0 <= af <= 7:\n                            for ar in range(0, r):\n                                psq = chess.square(af, ar)\n                                pp = pm.get(psq)\n                                if pp and pp.piece_type == chess.PAWN and pp.color == color:\n                                    has_support = True\n                                    break\n                            if has_support: break\n                    if not has_support:\n                        # consider it backward if there's an enemy pawn on adjacent file ahead that could exert pressure\n                        threat = False\n                        for af in (f-1, f+1):\n                            if 0 <= af <= 7:\n                                for ar in range(r+1, 8):\n                                    psq = chess.square(af, ar)\n                                    pp = pm.get(psq)\n                                    if pp and pp.piece_type == chess.PAWN and pp.color != color:\n                                        threat = True\n                                        break\n                                if threat: break\n                        if threat:\n                            cnt += 1\n                else:\n                    for af in (f-1, f+1):\n                        if 0 <= af <= 7:\n                            for ar in range(r+1, 8):\n                                psq = chess.square(af, ar)\n                                pp = pm.get(psq)\n                                if pp and pp.piece_type == chess.PAWN and pp.color == color:\n                                    has_support = True\n                                    break\n                            if has_support: break\n                    if not has_support:\n                        threat = False\n                        for af in (f-1, f+1):\n                            if 0 <= af <= 7:\n                                for ar in range(0, r):\n                                    psq = chess.square(af, ar)\n                                    pp = pm.get(psq)\n                                    if pp and pp.piece_type == chess.PAWN and pp.color != color:\n                                        threat = True\n                                        break\n                                if threat: break\n                        if threat:\n                            cnt += 1\n            return cnt\n        back_w = backward_count(chess.WHITE); back_b = backward_count(chess.BLACK)\n        # total fragility: doubled + backward\n        frag_w = doubled_w + back_w\n        frag_b = doubled_b + back_b\n        # positive favors White if Black is more fragile\n        return float(frag_b - frag_w)\n    except Exception:\n        return 0.0\n",
    "def feature(board: chess.Board) -> float:\n    'Net pressure on high-value pieces: sum over (attackers - defenders) weighted by target piece value for Q and R (white - black)'\n    try:\n        vals = {chess.QUEEN:9.0, chess.ROOK:5.0}\n        pm = board.piece_map()\n        def side_score(color):\n            total = 0.0\n            opp = not color\n            for sq,p in pm.items():\n                if not p or p.color != color or p.piece_type not in vals:\n                    continue\n                attackers_opp = board.attackers(opp, sq)\n                attackers_same = board.attackers(color, sq)\n                net = max(0, len(attackers_opp) - len(attackers_same))\n                total += net * vals[p.piece_type]\n            return total\n        return float(side_score(chess.WHITE) - side_score(chess.BLACK))\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Rook control of open/semi-open files and seventh rank occupancy (open=1, semi-open=0.5, plus bonus for 7th) (white - black)'\n    try:\n        pm = board.piece_map()\n        def file_pawn_state(f):\n            # returns 0 if open, 1 if semi-open for white only, -1 if semi-open for black only, 2 if both sides have pawns\n            has_w = False; has_b = False\n            for r in range(8):\n                sq = chess.square(f, r)\n                p = pm.get(sq)\n                if p and p.piece_type == chess.PAWN:\n                    if p.color == chess.WHITE: has_w = True\n                    else: has_b = True\n            if not has_w and not has_b:\n                return 0\n            if has_w and has_b:\n                return 2\n            if has_w and not has_b:\n                return 1\n            return -1\n        def score(color):\n            s = 0.0\n            for sq,p in pm.items():\n                if not p or p.piece_type != chess.ROOK or p.color != color:\n                    continue\n                f = chess.square_file(sq)\n                state = file_pawn_state(f)\n                # open file\n                if state == 0:\n                    s += 1.0\n                else:\n                    # semi-open if only opponent pawns absent\n                    if color == chess.WHITE and state == -1:\n                        s += 0.5\n                    if color == chess.BLACK and state == 1:\n                        s += 0.5\n                # bonus for rooks on opponent seventh rank\n                r = chess.square_rank(sq)\n                if color == chess.WHITE and r == 6:\n                    s += 0.7\n                if color == chess.BLACK and r == 1:\n                    s += 0.7\n            return s\n        return float(score(chess.WHITE) - score(chess.BLACK))\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Relative king pressure: sum of opponent piece values attacking the 3x3 zone around king (pressure on black - pressure on white) so positive favors White'\n    try:\n        vals = {chess.PAWN:1.0, chess.KNIGHT:3.0, chess.BISHOP:3.0, chess.ROOK:5.0, chess.QUEEN:9.0, chess.KING:0.0}\n        pm = board.piece_map()\n        def pressure_on(color):\n            # pressure on color's king by opponent pieces\n            king_sq = next((sq for sq,p in pm.items() if p and p.piece_type==chess.KING and p.color==color), None)\n            if king_sq is None:\n                return 0.0\n            opp = not color\n            kr = chess.square_rank(king_sq); kf = chess.square_file(king_sq)\n            total = 0.0\n            for rf in range(max(0, kf-1), min(7, kf+1)+1):\n                for rr in range(max(0, kr-1), min(7, kr+1)+1):\n                    sq = chess.square(rf, rr)\n                    attackers = board.attackers(opp, sq)\n                    for a in attackers:\n                        pa = pm.get(a)\n                        if pa:\n                            # weight central square (king square) heavier\n                            weight = 1.2 if sq == king_sq else 0.9\n                            total += vals.get(pa.piece_type, 0.0) * 0.35 * weight\n            return total\n        return float(pressure_on(chess.BLACK) - pressure_on(chess.WHITE))\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Pawn structure weakness differential: (doubled + 0.8*isolated) weaknesses of Black minus White (positive favors White)'\n    try:\n        pm = board.piece_map()\n        def pawn_file_counts(color):\n            counts = [0]*8\n            for sq,p in pm.items():\n                if p and p.piece_type == chess.PAWN and p.color == color:\n                    counts[chess.square_file(sq)] += 1\n            return counts\n        def weaknesses(color):\n            counts = pawn_file_counts(color)\n            doubled = sum(max(0, c-1) for c in counts)\n            isolated = 0\n            for f,c in enumerate(counts):\n                if c == 0:\n                    continue\n                left = counts[f-1] if f-1>=0 else 0\n                right = counts[f+1] if f+1<8 else 0\n                if left == 0 and right == 0:\n                    isolated += c  # each pawn on isolated file counts\n            return doubled + 0.8 * isolated\n        return float(weaknesses(chess.BLACK) - weaknesses(chess.WHITE))\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Piece coordination: difference of average pairwise Manhattan distances among non-pawn non-king pieces (black_avg - white_avg), higher means White pieces more clustered (better)'\n    try:\n        pm = board.piece_map()\n        def avg_pairwise(color):\n            locs = [sq for sq,p in pm.items() if p and p.color==color and p.piece_type not in (chess.PAWN, chess.KING)]\n            n = len(locs)\n            if n <= 1:\n                return 0.0\n            tot = 0.0; pairs = 0\n            for i in range(n):\n                for j in range(i+1, n):\n                    tot += chess.square_distance(locs[i], locs[j])\n                    pairs += 1\n            return tot / pairs if pairs>0 else 0.0\n        return float(avg_pairwise(chess.BLACK) - avg_pairwise(chess.WHITE))\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Knight outpost score: count of knights on advanced outpost squares (supported by own pawn and not attacked by opponent pawns) (white - black)'\n    try:\n        pm = board.piece_map()\n        def is_pawn_attacking(color, sq):\n            # does color have a pawn attacking sq?\n            for a in board.attackers(color, sq):\n                p = pm.get(a)\n                if p and p.piece_type == chess.PAWN:\n                    return True\n            return False\n        def outposts(color):\n            cnt = 0.0\n            opp = not color\n            for sq,p in pm.items():\n                if not p or p.color!=color or p.piece_type!=chess.KNIGHT:\n                    continue\n                r = chess.square_rank(sq)\n                # advanced criterion\n                if color == chess.WHITE and r < 4:  # ranks 4..7 -> indices 4..7, so r>=4\n                    continue\n                if color == chess.WHITE and r >= 4:\n                    pass\n                if color == chess.BLACK and r <= 3:\n                    pass\n                if color == chess.BLACK and r > 3:\n                    continue\n                # not attacked by opponent pawns\n                if is_pawn_attacking(opp, sq):\n                    continue\n                # supported by own pawn (a pawn attacks that square)\n                if is_pawn_attacking(color, sq):\n                    cnt += 1.0\n            return cnt\n        return float(outposts(chess.WHITE) - outposts(chess.BLACK))\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Open/semi-open files adjacent to king (exposure): (exposure of Black king - exposure of White king) so positive favors White when Black king is more exposed'\n    try:\n        pm = board.piece_map()\n        def file_state_value(f, color):\n            # open ->1, semi-open for that defending color ->0, semi-open for attacking color ->0.5\n            has_w = False; has_b = False\n            for r in range(8):\n                sq = chess.square(f, r)\n                p = pm.get(sq)\n                if p and p.piece_type == chess.PAWN:\n                    if p.color == chess.WHITE: has_w = True\n                    else: has_b = True\n            if not has_w and not has_b:\n                return 1.0\n            if has_w and has_b:\n                return 0.0\n            # if only one side has pawns, semi-open favors the side without pawns\n            if color == chess.WHITE:\n                return 0.5 if has_b and not has_w else 0.0\n            else:\n                return 0.5 if has_w and not has_b else 0.0\n        def exposure(color):\n            king_sq = next((sq for sq,p in pm.items() if p and p.piece_type==chess.KING and p.color==color), None)\n            if king_sq is None:\n                return 0.0\n            f = chess.square_file(king_sq)\n            total = 0.0\n            for ff in (f-1, f, f+1):\n                if 0 <= ff < 8:\n                    total += file_state_value(ff, color)\n            return total\n        return float(exposure(chess.BLACK) - exposure(chess.WHITE))\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Pawn wing majority: (white queenside pawn majority - black queenside pawn majority) where queenside = files a-d, kingside = e-h; positive favors White'\n    try:\n        pm = board.piece_map()\n        def wing_counts(color):\n            qs = 0; ks = 0\n            for sq,p in pm.items():\n                if not p or p.piece_type != chess.PAWN or p.color != color:\n                    continue\n                f = chess.square_file(sq)\n                if f <= 3:\n                    qs += 1\n                else:\n                    ks += 1\n            return qs, ks\n        w_qs, w_ks = wing_counts(chess.WHITE)\n        b_qs, b_ks = wing_counts(chess.BLACK)\n        # majority measure = (qs - ks)\n        return float((w_qs - w_ks) - (b_qs - b_ks))\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Immediate hanging material: sum of piece values that are attacked more times than defended (white - black)'\n    try:\n        vals = {chess.PAWN:1.0, chess.KNIGHT:3.0, chess.BISHOP:3.0, chess.ROOK:5.0, chess.QUEEN:9.0, chess.KING:0.0}\n        pm = board.piece_map()\n        def hanging_sum(color):\n            total = 0.0\n            for sq,p in pm.items():\n                if not p or p.color != color:\n                    continue\n                attackers = board.attackers(not color, sq)\n                defenders = board.attackers(color, sq)\n                if len(attackers) > len(defenders):\n                    total += vals.get(p.piece_type, 0.0)\n            return total\n        return float(hanging_sum(chess.WHITE) - hanging_sum(chess.BLACK))\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Capture/trade profitability: sum estimated net gain from legal captures for each side (white - black); approximates immediate favorable trades'\n    try:\n        vals = {chess.PAWN:1.0, chess.KNIGHT:3.0, chess.BISHOP:3.0, chess.ROOK:5.0, chess.QUEEN:9.0, chess.KING:0.0}\n        orig = board.turn\n        try:\n            scores = {chess.WHITE:0.0, chess.BLACK:0.0}\n            for color in (chess.WHITE, chess.BLACK):\n                board.turn = color\n                for mv in board.legal_moves:\n                    to_p = board.piece_at(mv.to_square)\n                    from_p = board.piece_at(mv.from_square)\n                    if to_p is None:\n                        # could be en-passant capture (to_square empty) -> handle by checking move.is_en_passant attribute not available; approximate skip\n                        continue\n                    if to_p and from_p and to_p.color != from_p.color:\n                        gain = vals.get(to_p.piece_type, 0.0) - 0.0  # captured value\n                        # penalize if capturing with much less-valued piece (possible recapture)\n                        mover_val = vals.get(from_p.piece_type, 0.0)\n                        # small penalty proportional to mover value to prefer low-value captures\n                        scores[color] += max(0.0, gain - 0.1 * mover_val)\n            return float(scores[chess.WHITE] - scores[chess.BLACK])\n        finally:\n            board.turn = orig\n    except Exception:\n        return 0.0\n",
    "def feature(board: chess.Board) -> float:\n    'Passed pawn advancement difference: sum of advancement-weighted passed pawns (white - black)'\n    try:\n        pm = board.piece_map()\n        passed = {chess.WHITE: 0.0, chess.BLACK: 0.0}\n        for sq, p in pm.items():\n            if not p or p.piece_type != chess.PAWN:\n                continue\n            f = chess.square_file(sq)\n            r = chess.square_rank(sq)\n            enemy = chess.BLACK if p.color == chess.WHITE else chess.WHITE\n            is_passed = True\n            for df in (-1, 0, 1):\n                ff = f + df\n                if not (0 <= ff < 8):\n                    continue\n                for rr in range(8):\n                    # for white pawns, enemy pawns that are ahead (higher rank) block passed status\n                    if p.color == chess.WHITE:\n                        if rr <= r:\n                            continue\n                    else:\n                        if rr >= r:\n                            continue\n                    sq2 = chess.square(ff, rr)\n                    pp = pm.get(sq2)\n                    if pp and pp.piece_type == chess.PAWN and pp.color == enemy:\n                        is_passed = False\n                        break\n                if not is_passed:\n                    break\n            if not is_passed:\n                continue\n            # advancement weight (0..1)\n            if p.color == chess.WHITE:\n                weight = float(r) / 7.0\n            else:\n                weight = float(7 - r) / 7.0\n            passed[p.color] += weight\n        return float(passed[chess.WHITE] - passed[chess.BLACK])\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Isolated pawn count difference: number of isolated pawns (white - black)'\n    try:\n        pm = board.piece_map()\n        isolated = {chess.WHITE: 0, chess.BLACK: 0}\n        # precompute pawn files by color\n        pawn_files = {chess.WHITE: [0]*8, chess.BLACK: [0]*8}\n        for sq, p in pm.items():\n            if p and p.piece_type == chess.PAWN:\n                pawn_files[p.color][chess.square_file(sq)] += 1\n        for color in (chess.WHITE, chess.BLACK):\n            for f in range(8):\n                if pawn_files[color][f] == 0:\n                    continue\n                left = pawn_files[color][f-1] if f-1 >= 0 else 0\n                right = pawn_files[color][f+1] if f+1 <= 7 else 0\n                if left + right == 0:\n                    isolated[color] += pawn_files[color][f]\n        return float(isolated[chess.WHITE] - isolated[chess.BLACK])\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Doubled pawn penalty difference: sum of extra pawns per file (white - black)'\n    try:\n        pm = board.piece_map()\n        file_counts = {chess.WHITE: [0]*8, chess.BLACK: [0]*8}\n        for sq, p in pm.items():\n            if p and p.piece_type == chess.PAWN:\n                file_counts[p.color][chess.square_file(sq)] += 1\n        penalty = {chess.WHITE: 0.0, chess.BLACK: 0.0}\n        for color in (chess.WHITE, chess.BLACK):\n            for f in range(8):\n                if file_counts[color][f] > 1:\n                    penalty[color] += float(file_counts[color][f] - 1)\n        return float(penalty[chess.WHITE] - penalty[chess.BLACK])\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Rooks on the 7th/2nd ranks advantage: count of rooks on opponent''s 7th rank (white - black)'\n    try:\n        pm = board.piece_map()\n        score = {chess.WHITE: 0.0, chess.BLACK: 0.0}\n        for sq, p in pm.items():\n            if not p or p.piece_type != chess.ROOK:\n                continue\n            r = chess.square_rank(sq)\n            if p.color == chess.WHITE and r == 6:\n                score[chess.WHITE] += 1.0\n            if p.color == chess.BLACK and r == 1:\n                score[chess.BLACK] += 1.0\n        return float(score[chess.WHITE] - score[chess.BLACK])\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Knight outpost advantage: knights on pawn-supported squares not attackable by enemy pawns (white - black)'\n    try:\n        pm = board.piece_map()\n        outpost = {chess.WHITE: 0.0, chess.BLACK: 0.0}\n        for sq, p in pm.items():\n            if not p or p.piece_type != chess.KNIGHT:\n                continue\n            color = p.color\n            enemy = chess.BLACK if color == chess.WHITE else chess.WHITE\n            r = chess.square_rank(sq)\n            # require some forward advancement to be meaningful\n            if color == chess.WHITE and r < 3:\n                continue\n            if color == chess.BLACK and r > 4:\n                continue\n            # check no enemy pawn attacks this square\n            enemy_attackers = board.attackers(enemy, sq)\n            pawn_attacked_by_enemy = any((pm.get(a) and pm.get(a).piece_type == chess.PAWN) for a in enemy_attackers)\n            if pawn_attacked_by_enemy:\n                continue\n            # check has at least one friendly pawn attacker (supported)\n            friendly_attackers = board.attackers(color, sq)\n            pawn_supported = any((pm.get(a) and pm.get(a).piece_type == chess.PAWN) for a in friendly_attackers)\n            if pawn_supported:\n                outpost[color] += 1.0\n        return float(outpost[chess.WHITE] - outpost[chess.BLACK])\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'King file exposure: enemy heavy-piece file pressure on king''s adjacent files (positive if Black king more exposed)'\n    try:\n        pm = board.piece_map()\n        def exposure_of(color):\n            king_sq = next((sq for sq, p in pm.items() if p and p.piece_type == chess.KING and p.color == color), None)\n            if king_sq is None:\n                return 0.0\n            f = chess.square_file(king_sq)\n            r = chess.square_rank(king_sq)\n            enemy = chess.BLACK if color == chess.WHITE else chess.WHITE\n            exposure = 0.0\n            for df in (-1, 0, 1):\n                ff = f + df\n                if ff < 0 or ff > 7:\n                    continue\n                # determine pawn presence\n                friendly_pawn_present = any((pm.get(chess.square(ff, rr)) and pm.get(chess.square(ff, rr)).piece_type == chess.PAWN and pm.get(chess.square(ff, rr)).color == color) for rr in range(8))\n                any_pawn_present = any((pm.get(chess.square(ff, rr)) and pm.get(chess.square(ff, rr)).piece_type == chess.PAWN) for rr in range(8))\n                if not any_pawn_present:\n                    file_score_multiplier = 1.5  # open\n                elif not friendly_pawn_present:\n                    file_score_multiplier = 0.9  # semi-open\n                else:\n                    continue  # pawn shield present, ignore\n                # look for enemy rook/queen on this file with clear path to king\n                for rr in range(8):\n                    sq2 = chess.square(ff, rr)\n                    piece = pm.get(sq2)\n                    if not piece or piece.color != enemy or piece.piece_type not in (chess.ROOK, chess.QUEEN):\n                        continue\n                    # check clear path between sq2 and king_sq along file\n                    clear = True\n                    low = min(rr, r) + 1\n                    high = max(rr, r) - 1\n                    for midr in range(low, high+1):\n                        if pm.get(chess.square(ff, midr)) is not None:\n                            clear = False\n                            break\n                    if clear:\n                        exposure += file_score_multiplier\n            return exposure\n        exp_w = exposure_of(chess.WHITE)\n        exp_b = exposure_of(chess.BLACK)\n        # positive means Black king more exposed -> favorable for White\n        return float(exp_b - exp_w)\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Queen centrality: sum of queen centrality scores (white - black), central squares weighted higher'\n    try:\n        pm = board.piece_map()\n        center_sqs = [chess.parse_square(s) for s in ('d4','e4','d5','e5')]\n        maxd = 7.0\n        cent = {chess.WHITE: 0.0, chess.BLACK: 0.0}\n        for sq, p in pm.items():\n            if not p or p.piece_type != chess.QUEEN:\n                continue\n            # distance to nearest central square\n            best = 100\n            for cs in center_sqs:\n                d = chess.square_distance(sq, cs)\n                if d < best:\n                    best = d\n            cent_val = float((maxd - best) / maxd)\n            cent[p.color] += cent_val\n        return float(cent[chess.WHITE] - cent[chess.BLACK])\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Bishop pair plus mobility: bishop-pair bonus plus bishop legal-move mobility (white - black)'\n    try:\n        pm = board.piece_map()\n        pair_bonus = {chess.WHITE: 0.0, chess.BLACK: 0.0}\n        moves = {chess.WHITE: 0.0, chess.BLACK: 0.0}\n        counts = {chess.WHITE: 0, chess.BLACK: 0}\n        for sq, p in pm.items():\n            if p and p.piece_type == chess.BISHOP:\n                counts[p.color] += 1\n        for color in (chess.WHITE, chess.BLACK):\n            if counts[color] >= 2:\n                pair_bonus[color] = 1.0\n        # bishop mobility via legal moves\n        orig = board.turn\n        try:\n            for color in (chess.WHITE, chess.BLACK):\n                board.turn = color\n                for mv in board.legal_moves:\n                    p = board.piece_at(mv.from_square)\n                    if p and p.piece_type == chess.BISHOP and p.color == color:\n                        moves[color] += 1.0\n        finally:\n            board.turn = orig\n        # combine (scale mobility modestly)\n        score_w = pair_bonus[chess.WHITE] * 1.0 + 0.06 * moves[chess.WHITE]\n        score_b = pair_bonus[chess.BLACK] * 1.0 + 0.06 * moves[chess.BLACK]\n        return float(score_w - score_b)\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Pawn majority on sides: weighted pawn majority (queenside and kingside) in White''s favor'\n    try:\n        pm = board.piece_map()\n        counts = {chess.WHITE: {'q': 0, 'k': 0}, chess.BLACK: {'q': 0, 'k': 0}}\n        for sq, p in pm.items():\n            if not p or p.piece_type != chess.PAWN:\n                continue\n            f = chess.square_file(sq)\n            side = 'q' if f <= 3 else 'k'\n            counts[p.color][side] += 1\n        white_major_q = counts[chess.WHITE]['q'] - counts[chess.BLACK]['q']\n        white_major_k = counts[chess.WHITE]['k'] - counts[chess.BLACK]['k']\n        # weight queenside majority slightly higher (common source of passed pawns)\n        return float(0.8 * white_major_q + 0.5 * white_major_k)\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Piece coordination: inverse average pairwise Manhattan distance of non-pawn non-king pieces (white - black)'\n    try:\n        pm = board.piece_map()\n        vals = {chess.WHITE: [], chess.BLACK: []}\n        for sq, p in pm.items():\n            if p and p.piece_type not in (chess.PAWN, chess.KING):\n                vals[p.color].append(sq)\n        def coord_score(sqs):\n            n = len(sqs)\n            if n <= 1:\n                return 0.0\n            total = 0.0\n            pairs = 0\n            for i in range(n):\n                for j in range(i+1, n):\n                    total += chess.square_distance(sqs[i], sqs[j])\n                    pairs += 1\n            avg = total / pairs if pairs > 0 else 14.0\n            # lower avg distance -> higher coordination; normalize to 0..1\n            return float((14.0 - avg) / 14.0)\n        sc_w = coord_score(vals[chess.WHITE])\n        sc_b = coord_score(vals[chess.BLACK])\n        return float(sc_w - sc_b)\n    except Exception:\n        return 0.0\n",
    "def feature(board: chess.Board) -> float:\n    'Passed pawn potential: weighted count of passed pawns by advancement (white - black)'\n    try:\n        pm = board.piece_map()\n        vals = {chess.WHITE:0.0, chess.BLACK:0.0}\n        for sq,p in pm.items():\n            if not p or p.piece_type != chess.PAWN:\n                continue\n            f = chess.square_file(sq)\n            r = chess.square_rank(sq)\n            color = p.color\n            opp = chess.BLACK if color == chess.WHITE else chess.WHITE\n            is_passed = True\n            # For white, check same file and adjacent files for opposing pawns on ranks ahead (r+1..7)\n            if color == chess.WHITE:\n                for ff in (f-1, f, f+1):\n                    if 0 <= ff <= 7:\n                        for rr in range(r+1, 8):\n                            sq2 = chess.square(ff, rr)\n                            p2 = pm.get(sq2)\n                            if p2 and p2.piece_type == chess.PAWN and p2.color == opp:\n                                is_passed = False\n                                break\n                        if not is_passed:\n                            break\n            else:\n                for ff in (f-1, f, f+1):\n                    if 0 <= ff <= 7:\n                        for rr in range(0, r):\n                            sq2 = chess.square(ff, rr)\n                            p2 = pm.get(sq2)\n                            if p2 and p2.piece_type == chess.PAWN and p2.color == opp:\n                                is_passed = False\n                                break\n                        if not is_passed:\n                            break\n            if is_passed:\n                # weight by advancement (more advanced => more valuable)\n                adv = (r if color == chess.WHITE else (7 - r)) / 7.0\n                vals[color] += 1.0 + 2.5 * adv\n        return float(vals[chess.WHITE] - vals[chess.BLACK])\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Piece centralization: aggregate closeness of non-pawn non-king pieces to board center (positive favors White)'\n    try:\n        import math\n        center_file = 3.5\n        center_rank = 3.5\n        pm = board.piece_map()\n        closeness = {chess.WHITE:0.0, chess.BLACK:0.0}\n        counts = {chess.WHITE:0, chess.BLACK:0}\n        for sq,p in pm.items():\n            if not p or p.piece_type in (chess.PAWN, chess.KING):\n                continue\n            f = chess.square_file(sq)\n            r = chess.square_rank(sq)\n            dist = math.hypot(f - center_file, r - center_rank)\n            # maximum possible distance ~ sqrt( (3.5)^2 + (3.5)^2 ) ~ 4.95\n            closeness_value = max(0.0, 4.95 - dist)\n            closeness[p.color] += closeness_value\n            counts[p.color] += 1\n        # normalize by piece counts to avoid scale bias\n        score_w = (closeness[chess.WHITE] / counts[chess.WHITE]) if counts[chess.WHITE] > 0 else 0.0\n        score_b = (closeness[chess.BLACK] / counts[chess.BLACK]) if counts[chess.BLACK] > 0 else 0.0\n        return float(score_w - score_b)\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Hanging high-value pieces: (value of black undefended-atacked pieces - value of white undefended-attacked pieces) (positive favors White)'\n    try:\n        vals = {chess.PAWN:1.0, chess.KNIGHT:3.0, chess.BISHOP:3.0, chess.ROOK:5.0, chess.QUEEN:9.0, chess.KING:0.0}\n        pm = board.piece_map()\n        hanging_value = {chess.WHITE:0.0, chess.BLACK:0.0}\n        for sq,p in pm.items():\n            if not p:\n                continue\n            color = p.color\n            opp = chess.BLACK if color == chess.WHITE else chess.WHITE\n            attackers = board.attackers(opp, sq)\n            if len(attackers) == 0:\n                continue\n            defenders = board.attackers(color, sq)\n            if len(defenders) == 0:\n                # piece is attacked and undefended -> hanging\n                hanging_value[color] += vals.get(p.piece_type, 0.0)\n        # positive when black has more hanging material (good for white)\n        return float(hanging_value[chess.BLACK] - hanging_value[chess.WHITE])\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'King centrality weighted by endgame stage (positive if White king is more central in endgame)'\n    try:\n        import math\n        pm = board.piece_map()\n        # compute non-pawn non-king material to detect endgame\n        vals = {chess.KNIGHT:3.0, chess.BISHOP:3.0, chess.ROOK:5.0, chess.QUEEN:9.0}\n        nonpawn_mat = 0.0\n        wk = bk = None\n        for sq,p in pm.items():\n            if not p:\n                continue\n            if p.piece_type in vals:\n                nonpawn_mat += vals[p.piece_type]\n            if p.piece_type == chess.KING:\n                if p.color == chess.WHITE:\n                    wk = sq\n                else:\n                    bk = sq\n        if wk is None or bk is None:\n            return 0.0\n        # weight increases as nonpawn material decreases (more endgame)\n        weight = max(0.0, 1.0 - (nonpawn_mat / 20.0))\n        center_file = 3.5; center_rank = 3.5\n        wf = chess.square_file(wk); wr = chess.square_rank(wk)\n        bf = chess.square_file(bk); br = chess.square_rank(bk)\n        wdist = math.hypot(wf - center_file, wr - center_rank)\n        bdist = math.hypot(bf - center_file, br - center_rank)\n        # smaller distance (more central) is better; positive favors white\n        return float((bdist - wdist) * weight)\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Battery and alignment potential: count of rook/queen and bishop/queen alignments pointing toward opponent king (white - black)'\n    try:\n        pm = board.piece_map()\n        def clear_path(sq1, sq2):\n            # returns True if all squares strictly between sq1 and sq2 are empty\n            f1,r1 = chess.square_file(sq1), chess.square_rank(sq1)\n            f2,r2 = chess.square_file(sq2), chess.square_rank(sq2)\n            df = f2 - f1; dr = r2 - r1\n            step_f = 0 if df == 0 else (1 if df > 0 else -1)\n            step_r = 0 if dr == 0 else (1 if dr > 0 else -1)\n            if step_f == 0 and step_r == 0:\n                return False\n            if abs(df) != 0 and abs(dr) != 0 and abs(abs(df) - abs(dr)) != 0:\n                return False\n            cur_f, cur_r = f1 + step_f, r1 + step_r\n            while (cur_f, cur_r) != (f2, r2):\n                if not (0 <= cur_f <= 7 and 0 <= cur_r <= 7):\n                    return False\n                if pm.get(chess.square(cur_f, cur_r)):\n                    return False\n                cur_f += step_f; cur_r += step_r\n            return True\n        score = {chess.WHITE:0.0, chess.BLACK:0.0}\n        # find kings\n        kings = {chess.WHITE:None, chess.BLACK:None}\n        for sq,p in pm.items():\n            if p and p.piece_type == chess.KING:\n                kings[p.color] = sq\n        for sq,p in pm.items():\n            if not p:\n                continue\n            color = p.color\n            opp = chess.BLACK if color == chess.WHITE else chess.WHITE\n            # rook/queen alignments (rank/file)\n            if p.piece_type in (chess.ROOK, chess.QUEEN):\n                for sq2,q in pm.items():\n                    if not q or q.color != color or q.piece_type not in (chess.ROOK, chess.QUEEN) or sq2 == sq:\n                        continue\n                    if clear_path(sq, sq2):\n                        # alignment counts; extra if line passes through opponent king\n                        bonus = 1.0\n                        ksq = kings[opp]\n                        if ksq is not None:\n                            # if king is beyond q along same line and path from q to king clear\n                            if (chess.square_file(ksq) - chess.square_file(sq)) * (chess.square_rank(ksq) - chess.square_rank(sq)) == 0:\n                                # quick coarse check: same file or same rank\n                                if clear_path(sq2, ksq):\n                                    bonus += 1.0\n                        score[color] += bonus\n            # bishop/queen diagonal battery\n            if p.piece_type in (chess.BISHOP, chess.QUEEN):\n                for sq2,q in pm.items():\n                    if not q or q.color != color or q.piece_type not in (chess.BISHOP, chess.QUEEN) or sq2 == sq:\n                        continue\n                    if clear_path(sq, sq2):\n                        bonus = 0.9\n                        ksq = kings[opp]\n                        if ksq is not None and clear_path(sq2, ksq):\n                            bonus += 1.1\n                        score[color] += bonus\n        return float(score[chess.WHITE] - score[chess.BLACK])\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Pawn structure fragility: penalty for doubled, isolated and backward pawns (lower is better); returns (black - white) so positive favors White'\n    try:\n        pm = board.piece_map()\n        pawns_on_file = {f:{chess.WHITE:[], chess.BLACK:[]} for f in range(8)}\n        for sq,p in pm.items():\n            if p and p.piece_type == chess.PAWN:\n                f = chess.square_file(sq); r = chess.square_rank(sq)\n                pawns_on_file[f][p.color].append((sq, r))\n        def fragility(color):\n            pen = 0.0\n            # doubled pawns: more than one pawn of same color on file\n            for f in range(8):\n                cnt = len(pawns_on_file[f][color])\n                if cnt > 1:\n                    pen += 0.8 * (cnt - 1)\n            # isolated pawns: no friendly pawns on adjacent files\n            for f in range(8):\n                for sq,r in pawns_on_file[f][color]:\n                    has_adj = False\n                    for af in (f-1, f+1):\n                        if 0 <= af <= 7 and len(pawns_on_file[af][color]) > 0:\n                            has_adj = True; break\n                    if not has_adj:\n                        pen += 1.0\n            # backward pawns: a pawn that cannot advance because opponent pawn controls the advance square and there is no friendly pawn behind to support\n            opp = chess.BLACK if color == chess.WHITE else chess.WHITE\n            for f in range(8):\n                for sq,r in pawns_on_file[f][color]:\n                    forward_r = r+1 if color == chess.WHITE else r-1\n                    if not (0 <= forward_r <= 7):\n                        continue\n                    forward_sq = chess.square(f, forward_r)\n                    # is forward square attacked by opponent pawn?\n                    attacked_by_opp_pawn = False\n                    for df in (-1,1):\n                        af = f + df\n                        if 0 <= af <= 7:\n                            psq = chess.square(af, r + (1 if color==chess.BLACK else -1))\n                            p = pm.get(psq)\n                            if p and p.piece_type == chess.PAWN and p.color == opp:\n                                attacked_by_opp_pawn = True\n                                break\n                    # no friendly pawn behind to support (behind means previous rank)\n                    behind_r = r-1 if color == chess.WHITE else r+1\n                    has_support_behind = False\n                    if 0 <= behind_r <= 7:\n                        for df in (-1,0,1):\n                            bf = f + df\n                            if 0 <= bf <= 7:\n                                pb = pm.get(chess.square(bf, behind_r))\n                                if pb and pb.piece_type == chess.PAWN and pb.color == color:\n                                    has_support_behind = True\n                                    break\n                    if attacked_by_opp_pawn and not has_support_behind:\n                        pen += 1.2\n            return pen\n        frag_w = fragility(chess.WHITE)\n        frag_b = fragility(chess.BLACK)\n        # positive if White structure is better (i.e., black more fragile)\n        return float(frag_b - frag_w)\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Queen forward activity: number of unique opponent-half squares attacked by queen that are not well-defended (white - black)'\n    try:\n        pm = board.piece_map()\n        score = {chess.WHITE:0.0, chess.BLACK:0.0}\n        for color in (chess.WHITE, chess.BLACK):\n            # find queens of that color\n            for sq,p in pm.items():\n                if not p or p.piece_type != chess.QUEEN or p.color != color:\n                    continue\n                attacked_sqs = set(board.attacks(sq)) if hasattr(board, 'attacks') else set()\n                # fallback: use board.generate_legal_moves? but attacks most accurate; if missing, iterate moves\n                if not attacked_sqs:\n                    try:\n                        # gather pseudo-legal targets by iterating moves for that queen\n                        orig = board.turn\n                        try:\n                            board.turn = color\n                            for mv in board.legal_moves:\n                                if mv.from_square == sq:\n                                    attacked_sqs.add(mv.to_square)\n                        finally:\n                            board.turn = orig\n                    except Exception:\n                        pass\n                for tsq in attacked_sqs:\n                    tr = chess.square_rank(tsq)\n                    # in opponent half\n                    if (color == chess.WHITE and tr >= 4) or (color == chess.BLACK and tr <= 3):\n                        # count as useful if square is not defended by opponent (i.e., attacking unprotected squares)\n                        opp = chess.BLACK if color == chess.WHITE else chess.WHITE\n                        if not board.is_attacked_by(opp, tsq):\n                            score[color] += 1.0\n        return float(score[chess.WHITE] - score[chess.BLACK])\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Bishop pair mobility and long-diagonal control (white - black): rewards bishop pair and number of empty long diagonals controlled'\n    try:\n        pm = board.piece_map()\n        score = {chess.WHITE:0.0, chess.BLACK:0.0}\n        for color in (chess.WHITE, chess.BLACK):\n            bishops = [sq for sq,p in pm.items() if p and p.piece_type == chess.BISHOP and p.color == color]\n            # bishop pair bonus\n            if len(bishops) >= 2:\n                score[color] += 1.2\n            # for each bishop, count number of unobstructed ray-length > 2 squares (long diagonals)\n            for sq in bishops:\n                f = chess.square_file(sq); r = chess.square_rank(sq)\n                for df,dr in ((1,1),(1,-1),(-1,1),(-1,-1)):\n                    length = 0\n                    cf,cr = f+df, r+dr\n                    while 0 <= cf <= 7 and 0 <= cr <= 7:\n                        if pm.get(chess.square(cf, cr)):\n                            break\n                        length += 1\n                        cf += df; cr += dr\n                    if length >= 3:\n                        score[color] += 0.4 + 0.1 * (length - 3)\n            # penalize if bishops blocked by own pawns in front of them (low mobility)\n            for sq in bishops:\n                f = chess.square_file(sq); r = chess.square_rank(sq)\n                ahead_r = r+1 if color == chess.WHITE else r-1\n                if 0 <= ahead_r <= 7:\n                    front_p = pm.get(chess.square(f, ahead_r))\n                    if front_p and front_p.piece_type == chess.PAWN and front_p.color == color:\n                        score[color] -= 0.35\n        return float(score[chess.WHITE] - score[chess.BLACK])\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Mobility imbalance: legal move count difference normalized (white - black); positive favors White mobility'\n    try:\n        orig = board.turn\n        try:\n            board.turn = chess.WHITE\n            w_moves = sum(1 for _ in board.legal_moves)\n            board.turn = chess.BLACK\n            b_moves = sum(1 for _ in board.legal_moves)\n        finally:\n            board.turn = orig\n        total = max(1.0, w_moves + b_moves)\n        return float((w_moves - b_moves) / total)\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Outpost control: number of knights/bishops on squares not attackable by opponent pawns and supported by own pawn or advanced in enemy half (white - black)'\n    try:\n        pm = board.piece_map()\n        score = {chess.WHITE:0.0, chess.BLACK:0.0}\n        for sq,p in pm.items():\n            if not p or p.piece_type not in (chess.KNIGHT, chess.BISHOP):\n                continue\n            color = p.color\n            f = chess.square_file(sq); r = chess.square_rank(sq)\n            opp = chess.BLACK if color == chess.WHITE else chess.WHITE\n            # check if square can be attacked by any opponent pawn\n            attacked_by_opp_pawn = False\n            for df in (-1, 1):\n                pf = f + df\n                pr = r + ( -1 if color == chess.WHITE else 1 )  # opponent pawn attack direction relative to piece\n                if 0 <= pf <= 7 and 0 <= pr <= 7:\n                    p2 = pm.get(chess.square(pf, pr))\n                    if p2 and p2.piece_type == chess.PAWN and p2.color == opp:\n                        attacked_by_opp_pawn = True\n                        break\n            if attacked_by_opp_pawn:\n                continue\n            # supported by own pawn?\n            supported = False\n            for df in (-1, 0, 1):\n                sf = f + df\n                sr = r - (1 if color == chess.WHITE else -1)  # pawn behind relative to color\n                if 0 <= sf <= 7 and 0 <= sr <= 7:\n                    p3 = pm.get(chess.square(sf, sr))\n                    if p3 and p3.piece_type == chess.PAWN and p3.color == color:\n                        supported = True\n                        break\n            # or advanced in enemy half (ranks >=4 for white, <=3 for black)\n            advanced = (color == chess.WHITE and r >= 4) or (color == chess.BLACK and r <= 3)\n            if supported:\n                score[color] += 1.0\n            elif advanced:\n                score[color] += 0.7\n        return float(score[chess.WHITE] - score[chess.BLACK])\n    except Exception:\n        return 0.0\n",
    "def feature(board: chess.Board) -> float:\n    'Passed pawn potential: counts and advances of passed pawns weighted by rank (white - black)'\n    try:\n        pm = board.piece_map()\n        def is_passed(sq, color):\n            f = chess.square_file(sq); r = chess.square_rank(sq)\n            if color == chess.WHITE:\n                # no black pawns ahead on same or adjacent files\n                for af in (f-1, f, f+1):\n                    if 0 <= af < 8:\n                        for ar in range(r+1, 8):\n                            s = chess.square(af, ar)\n                            p = pm.get(s)\n                            if p and p.piece_type == chess.PAWN and p.color == chess.BLACK:\n                                return False\n                return True\n            else:\n                for af in (f-1, f, f+1):\n                    if 0 <= af < 8:\n                        for ar in range(0, r):\n                            s = chess.square(af, ar)\n                            p = pm.get(s)\n                            if p and p.piece_type == chess.PAWN and p.color == chess.WHITE:\n                                return False\n                return True\n        score = {chess.WHITE:0.0, chess.BLACK:0.0}\n        for sq, p in pm.items():\n            if not p or p.piece_type != chess.PAWN:\n                continue\n            if is_passed(sq, p.color):\n                # weight by advancement: ranks closer to promotion score more\n                rank = chess.square_rank(sq)\n                adv = (rank / 7.0) if p.color == chess.WHITE else ((7 - rank) / 7.0)\n                # penalty if directly blocked by enemy piece in front\n                ahead_sq = None\n                if p.color == chess.WHITE and rank < 7:\n                    ahead_sq = chess.square(chess.square_file(sq), rank+1)\n                if p.color == chess.BLACK and rank > 0:\n                    ahead_sq = chess.square(chess.square_file(sq), rank-1)\n                block = 0.0\n                if ahead_sq is not None:\n                    pa = pm.get(ahead_sq)\n                    if pa and pa.color != p.color:\n                        block = 0.5\n                score[p.color] += (1.0 + adv * 2.0) - block\n        return float(score[chess.WHITE] - score[chess.BLACK])\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Knight outposts: knights on advanced stable squares not attackable by enemy pawns (white - black)'\n    try:\n        pm = board.piece_map()\n        def pawn_attacks_square_by(color, sq):\n            f = chess.square_file(sq); r = chess.square_rank(sq)\n            if color == chess.WHITE:\n                # white pawns attack (f\u00b11, r+1)\n                for pf in (f-1, f+1):\n                    pr = r-1\n                    if 0 <= pf < 8 and 0 <= pr < 8:\n                        s = chess.square(pf, pr)\n                        p = pm.get(s)\n                        if p and p.piece_type == chess.PAWN and p.color == chess.WHITE:\n                            return True\n            else:\n                # black pawns attack (f\u00b11, r-1)\n                for pf in (f-1, f+1):\n                    pr = r+1\n                    if 0 <= pf < 8 and 0 <= pr < 8:\n                        s = chess.square(pf, pr)\n                        p = pm.get(s)\n                        if p and p.piece_type == chess.PAWN and p.color == chess.BLACK:\n                            return True\n            return False\n        score = {chess.WHITE:0.0, chess.BLACK:0.0}\n        for sq,p in pm.items():\n            if not p or p.piece_type != chess.KNIGHT:\n                continue\n            r = chess.square_rank(sq)\n            # candidate outpost ranks (>=4 for white, <=3 for black)\n            if p.color == chess.WHITE and r >= 4:\n                if not pawn_attacks_square_by(chess.BLACK, sq):\n                    # bonus for being supported by a pawn behind or being on a central file\n                    support = 0.0\n                    behind_sq = chess.square(chess.square_file(sq), r-1) if r-1 >= 0 else None\n                    if behind_sq and pm.get(behind_sq) and pm.get(behind_sq).piece_type == chess.PAWN and pm.get(behind_sq).color == chess.WHITE:\n                        support += 0.6\n                    # centrality bonus\n                    cf = 3.5 - abs(3.5 - chess.square_file(sq))\n                    score[chess.WHITE] += 1.0 + support + (cf / 3.5) * 0.3\n            if p.color == chess.BLACK and r <= 3:\n                if not pawn_attacks_square_by(chess.WHITE, sq):\n                    support = 0.0\n                    behind_sq = chess.square(chess.square_file(sq), r+1) if r+1 <= 7 else None\n                    if behind_sq and pm.get(behind_sq) and pm.get(behind_sq).piece_type == chess.PAWN and pm.get(behind_sq).color == chess.BLACK:\n                        support += 0.6\n                    cf = 3.5 - abs(3.5 - chess.square_file(sq))\n                    score[chess.BLACK] += 1.0 + support + (cf / 3.5) * 0.3\n        return float(score[chess.WHITE] - score[chess.BLACK])\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Bishop pair effectiveness: bishop count weighted by clear diagonal mobility (white - black)'\n    try:\n        pm = board.piece_map()\n        def bishop_effect(color):\n            eff = 0.0\n            for sq,p in pm.items():\n                if not p or p.piece_type != chess.BISHOP or p.color != color:\n                    continue\n                # count blocking pawns on the four diagonals (closer blocks more)\n                blocks = 0.0\n                for df,dr in ((1,1),(1,-1),(-1,1),(-1,-1)):\n                    f = chess.square_file(sq) + df\n                    r = chess.square_rank(sq) + dr\n                    steps = 0\n                    while 0 <= f < 8 and 0 <= r < 8:\n                        s = chess.square(f, r)\n                        steps += 1\n                        q = pm.get(s)\n                        if q and q.piece_type == chess.PAWN:\n                            # closer blocks hurt more\n                            blocks += (1.0 / max(1, steps))\n                            break\n                        if q:\n                            # any piece blocks further mobility\n                            blocks += 0.15\n                            break\n                        f += df; r += dr\n                # mobility potential scaled: max diag steps ~7\n                mobility_score = max(0.0, 4.0 - blocks) / 4.0\n                eff += 1.0 * mobility_score\n            # small bonus for bishop pair\n            count = sum(1 for p in pm.values() if p and p.piece_type == chess.BISHOP and p.color == color)\n            if count >= 2:\n                eff += 0.6\n            return eff\n        return float(bishop_effect(chess.WHITE) - bishop_effect(chess.BLACK))\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'King centralization in endgames: centralization advantage when material is low (positive favors White)'\n    try:\n        pm = board.piece_map()\n        # approximate non-king material sum\n        vals = {chess.PAWN:1.0, chess.KNIGHT:3.0, chess.BISHOP:3.0, chess.ROOK:5.0, chess.QUEEN:9.0}\n        total_nonking = 0.0\n        for p in pm.values():\n            if p and p.piece_type != chess.KING:\n                total_nonking += vals.get(p.piece_type, 0.0)\n        # only meaningful in endgame-ish positions\n        if total_nonking > 18.0:\n            return 0.0\n        centers = [chess.parse_square('d4'), chess.parse_square('e4'), chess.parse_square('d5'), chess.parse_square('e5')]\n        def central_score(color):\n            ksq = next((sq for sq,p in pm.items() if p and p.piece_type == chess.KING and p.color == color), None)\n            if ksq is None:\n                return 0.0\n            d = min(chess.square_distance(ksq, c) for c in centers)\n            # normalize assuming max distance ~7\n            cent = (7.0 - float(d)) / 7.0\n            return cent\n        return float(central_score(chess.WHITE) - central_score(chess.BLACK))\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Forward piece presence: average advancement rank of non-pawn pieces (white - black)'\n    try:\n        pm = board.piece_map()\n        def avg_forward(color):\n            ranks = []\n            for sq,p in pm.items():\n                if not p or p.piece_type in (chess.PAWN, chess.KING) or p.color != color:\n                    continue\n                r = chess.square_rank(sq)\n                # normalize rank to [0,1] where 1 is deepest into opponent half\n                norm = (r / 7.0) if color == chess.WHITE else ((7 - r) / 7.0)\n                ranks.append(norm)\n            return (sum(ranks) / len(ranks)) if ranks else 0.0\n        return float(avg_forward(chess.WHITE) - avg_forward(chess.BLACK))\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Pawn structure fragility: isolated/doubled/backward pawn penalty (positive when Black more fragile)'\n    try:\n        pm = board.piece_map()\n        def fragility(color):\n            isolated = doubled = backward = 0.0\n            file_pawns = {f:[] for f in range(8)}\n            for sq,p in pm.items():\n                if p and p.piece_type == chess.PAWN and p.color == color:\n                    file_pawns[chess.square_file(sq)].append(chess.square_rank(sq))\n            for f, ranks in file_pawns.items():\n                if not ranks:\n                    continue\n                ranks.sort()\n                # doubled\n                if len(ranks) > 1:\n                    doubled += float(len(ranks)-1) * 1.0\n                for r in ranks:\n                    # isolated: no friendly pawns on adjacent files\n                    adj = False\n                    for af in (f-1, f+1):\n                        if 0 <= af < 8 and file_pawns.get(af):\n                            adj = True; break\n                    if not adj:\n                        isolated += 1.2\n                    # backward approximation: blocked ahead and no adjacent pawn behind to support\n                    if color == chess.WHITE:\n                        ahead = (r+1 <= 7 and pm.get(chess.square(f, r+1)))\n                        support = False\n                        for af in (f-1, f+1):\n                            if 0 <= af < 8:\n                                for sr in file_pawns.get(af, []):\n                                    if sr <= r:\n                                        support = True; break\n                                if support: break\n                        if ahead and not support:\n                            backward += 1.0\n                    else:\n                        ahead = (r-1 >= 0 and pm.get(chess.square(f, r-1)))\n                        support = False\n                        for af in (f-1, f+1):\n                            if 0 <= af < 8:\n                                for sr in file_pawns.get(af, []):\n                                    if sr >= r:\n                                        support = True; break\n                                if support: break\n                        if ahead and not support:\n                            backward += 1.0\n            return isolated + 0.8 * doubled + backward\n        frag_w = fragility(chess.WHITE)\n        frag_b = fragility(chess.BLACK)\n        # positive when Black more fragile\n        return float(frag_b - frag_w)\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Proximity of friendly pieces to own king (defenders) minus enemy attackers in vicinity (white - black)'\n    try:\n        pm = board.piece_map()\n        def king_support_minus_threats(color):\n            ksq = next((sq for sq,p in pm.items() if p and p.piece_type == chess.KING and p.color == color), None)\n            if ksq is None:\n                return 0.0\n            # defenders: friendly non-pawn pieces within chebyshev distance <=2\n            defenders = 0.0\n            attackers = 0.0\n            for sq,p in pm.items():\n                if not p: continue\n                d = chess.square_distance(ksq, sq)\n                if d <= 2:\n                    if p.color == color and p.piece_type not in (chess.PAWN, chess.KING):\n                        defenders += 1.0\n                    if p.color != color:\n                        # weight attackers by piece value\n                        vals = {chess.PAWN:1.0, chess.KNIGHT:3.0, chess.BISHOP:3.0, chess.ROOK:5.0, chess.QUEEN:9.0, chess.KING:0.0}\n                        attackers += vals.get(p.piece_type, 0.0)\n            return defenders - 0.22 * attackers\n        return float(king_support_minus_threats(chess.WHITE) - king_support_minus_threats(chess.BLACK))\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Trapped/immobile pieces: count of side pieces with very low legal mobility and unfavorable attacker/defender balance (positive when Black worse)'\n    try:\n        pm = board.piece_map()\n        orig = board.turn\n        try:\n            trapped = {chess.WHITE:0.0, chess.BLACK:0.0}\n            for color in (chess.WHITE, chess.BLACK):\n                board.turn = color\n                # count legal moves per piece\n                moves_per_piece = {}\n                for mv in board.legal_moves:\n                    moves_per_piece.setdefault(mv.from_square, 0)\n                    moves_per_piece[mv.from_square] += 1\n                for sq,p in pm.items():\n                    if not p or p.color != color or p.piece_type in (chess.PAWN, chess.KING):\n                        continue\n                    mobility = moves_per_piece.get(sq, 0)\n                    if mobility <= 1:\n                        # attacked/defended balance on the square\n                        opp = chess.BLACK if color == chess.WHITE else chess.WHITE\n                        attackers = len(board.attackers(opp, sq))\n                        defenders = len(board.attackers(color, sq))\n                        if attackers > defenders:\n                            trapped[color] += 1.0 + (attackers - defenders) * 0.4\n                        else:\n                            trapped[color] += 0.6\n            # positive when Black has more trapped pieces\n            return float(trapped[chess.BLACK] - trapped[chess.WHITE])\n        finally:\n            board.turn = orig\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Queen activity: mobility and presence in opponent half and on open files (white - black)'\n    try:\n        pm = board.piece_map()\n        orig = board.turn\n        try:\n            def queen_score(color):\n                score = 0.0\n                for sq,p in pm.items():\n                    if not p or p.piece_type != chess.QUEEN or p.color != color:\n                        continue\n                    r = chess.square_rank(sq)\n                    # on opponent half bonus\n                    half_bonus = 0.6 if (color == chess.WHITE and r >= 4) or (color == chess.BLACK and r <= 3) else 0.0\n                    # open file check\n                    f = chess.square_file(sq)\n                    pawns_on_file = any((pp and pp.piece_type == chess.PAWN) for s2,pp in pm.items() if chess.square_file(s2) == f)\n                    open_file_bonus = 0.8 if not pawns_on_file else 0.0\n                    # mobility: count legal queen moves\n                    board.turn = color\n                    mobility = 0\n                    for mv in board.legal_moves:\n                        if mv.from_square == sq:\n                            mobility += 1\n                    mobility_score = min(10.0, mobility) / 10.0\n                    score += 0.9 * mobility_score + half_bonus + open_file_bonus * 0.6\n                return score\n            return float(queen_score(chess.WHITE) - queen_score(chess.BLACK))\n        finally:\n            board.turn = orig\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Material skew adjustment: raw material difference with penalties for lone queen vs coordinated minor/rook setup (positive favors White)'\n    try:\n        pm = board.piece_map()\n        vals = {chess.PAWN:1.0, chess.KNIGHT:3.0, chess.BISHOP:3.0, chess.ROOK:5.0, chess.QUEEN:9.0, chess.KING:0.0}\n        mat = {chess.WHITE:0.0, chess.BLACK:0.0}\n        counts = {chess.WHITE:{'rooks':0,'minor':0,'queens':0}, chess.BLACK:{'rooks':0,'minor':0,'queens':0}}\n        for p in pm.values():\n            if not p: continue\n            mat[p.color] += vals.get(p.piece_type, 0.0)\n            if p.piece_type == chess.QUEEN:\n                counts[p.color]['queens'] += 1\n            if p.piece_type == chess.ROOK:\n                counts[p.color]['rooks'] += 1\n            if p.piece_type in (chess.BISHOP, chess.KNIGHT):\n                counts[p.color]['minor'] += 1\n        raw = mat[chess.WHITE] - mat[chess.BLACK]\n        adj = raw\n        # penalize \"lone queen\" advantage: if one side has a queen and opponent has >=2 rooks/minors combined, reduce advantage\n        for color in (chess.WHITE, chess.BLACK):\n            other = chess.BLACK if color == chess.WHITE else chess.WHITE\n            if counts[color]['queens'] >= 1:\n                if (counts[other]['rooks'] + counts[other]['minor']) >= 2 and (mat[color] - mat[other]) < 4.0:\n                    # reduce the side's material advantage\n                    if color == chess.WHITE:\n                        adj -= 1.4\n                    else:\n                        adj += 1.4\n        return float(adj)\n    except Exception:\n        return 0.0\n",
    "def feature(board: chess.Board) -> float:\n    'Passed pawn score weighted by advancement (white - black)'\n    try:\n        pm = board.piece_map()\n        def is_passed(sq, color):\n            f = chess.square_file(sq)\n            r = chess.square_rank(sq)\n            files = [ff for ff in (f-1, f, f+1) if 0 <= ff < 8]\n            if color == chess.WHITE:\n                for ff in files:\n                    for rr in range(r+1, 8):\n                        p = pm.get(chess.square(ff, rr))\n                        if p and p.piece_type == chess.PAWN and p.color == chess.BLACK:\n                            return False\n                return True\n            else:\n                for ff in files:\n                    for rr in range(r-1, -1, -1):\n                        p = pm.get(chess.square(ff, rr))\n                        if p and p.piece_type == chess.PAWN and p.color == chess.WHITE:\n                            return False\n                return True\n        score = 0.0\n        for sq, p in pm.items():\n            if not p or p.piece_type != chess.PAWN:\n                continue\n            r = chess.square_rank(sq)\n            adv = (r / 7.0) if p.color == chess.WHITE else ((7 - r) / 7.0)\n            if is_passed(sq, p.color):\n                score += (1.8 * adv) if p.color == chess.WHITE else (-1.8 * adv)\n        return float(score)\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Rook influence on files: open/semi-open file advantage (white - black)'\n    try:\n        pm = board.piece_map()\n        def file_info(file_idx):\n            has_white_pawn = False\n            has_black_pawn = False\n            for r in range(8):\n                p = pm.get(chess.square(file_idx, r))\n                if p and p.piece_type == chess.PAWN:\n                    if p.color == chess.WHITE:\n                        has_white_pawn = True\n                    else:\n                        has_black_pawn = True\n            return has_white_pawn, has_black_pawn\n        score = 0.0\n        for sq, p in pm.items():\n            if not p or p.piece_type != chess.ROOK:\n                continue\n            f = chess.square_file(sq)\n            wp, bp = file_info(f)\n            if not wp and not bp:\n                # fully open\n                score += (1.6 if p.color == chess.WHITE else -1.6)\n            elif (not wp and bp) or (wp and not bp):\n                # semi-open for one side: if opponent pawn absent but friendly pawn exists it's not semi-open for that side\n                if p.color == chess.WHITE and not bp:\n                    score += 0.9\n                if p.color == chess.BLACK and not wp:\n                    score -= 0.9\n        return float(score)\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Rook(s) on the seventh rank pressure: reward rooks on opponent\\'s seventh (white - black)'\n    try:\n        pm = board.piece_map()\n        score = 0.0\n        for sq, p in pm.items():\n            if not p or p.piece_type != chess.ROOK:\n                continue\n            r = chess.square_rank(sq)\n            if p.color == chess.WHITE and r == 6:\n                score += 1.2\n            if p.color == chess.BLACK and r == 1:\n                score -= 1.2\n        return float(score)\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'King centralization advantage in likely endgames (positive if White king more centralized)'\n    try:\n        pm = board.piece_map()\n        # approximate endgame by non-pawn non-king material\n        nonpawn_nonking = sum(1 for p in pm.values() if p and p.piece_type not in (chess.PAWN, chess.KING))\n        if nonpawn_nonking > 6:\n            # not an endgame - damp feature\n            damping = 0.5\n        else:\n            damping = 1.0\n        def king_centrality(color):\n            ksq = next((sq for sq, p in pm.items() if p and p.piece_type == chess.KING and p.color == color), None)\n            if ksq is None:\n                return 0.0\n            cf = chess.square_file(ksq)\n            cr = chess.square_rank(ksq)\n            # center at (3.5,3.5)\n            dx = (cf - 3.5)\n            dy = (cr - 3.5)\n            dist = (dx*dx + dy*dy) ** 0.5\n            # normalize by max possible ~5.0\n            return 1.0 - (dist / 5.0)\n        wc = king_centrality(chess.WHITE)\n        bc = king_centrality(chess.BLACK)\n        return float(damping * (wc - bc))\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Bishop pair & diagonal mobility advantage (white - black)'\n    try:\n        pm = board.piece_map()\n        dirs = [(1,1),(1,-1),(-1,1),(-1,-1)]\n        def bishop_mobility_and_pair(color):\n            mobility = 0.0\n            pair = 0.0\n            for sq,p in pm.items():\n                if not p or p.piece_type != chess.BISHOP or p.color != color:\n                    continue\n                # count available squares along diagonals until blocked\n                f = chess.square_file(sq); r = chess.square_rank(sq)\n                for df, dr in dirs:\n                    ff = f + df; rr = r + dr\n                    while 0 <= ff < 8 and 0 <= rr < 8:\n                        occ = pm.get(chess.square(ff, rr))\n                        if occ is None:\n                            mobility += 0.15\n                            ff += df; rr += dr\n                            continue\n                        else:\n                            # can capture opponent piece but blocked afterwards\n                            if occ.color != color:\n                                mobility += 0.6\n                            break\n                pair += 1.0\n            pair_bonus = 0.6 if pair >= 2 else 0.0\n            return mobility + pair_bonus\n        return float(bishop_mobility_and_pair(chess.WHITE) - bishop_mobility_and_pair(chess.BLACK))\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Trapped non-pawn pieces: count of pieces with <=1 pseudo-move and attacked (white - black)'\n    try:\n        pm = board.piece_map()\n        knight_moves = [(1,2),(2,1),(-1,2),(-2,1),(1,-2),(2,-1),(-1,-2),(-2,-1)]\n        rook_dirs = [(1,0),(-1,0),(0,1),(0,-1)]\n        bishop_dirs = [(1,1),(1,-1),(-1,1),(-1,-1)]\n        def pseudo_moves_count(sq, p):\n            f = chess.square_file(sq); r = chess.square_rank(sq)\n            cnt = 0\n            if p.piece_type == chess.KNIGHT:\n                for df, dr in knight_moves:\n                    ff, rr = f+df, r+dr\n                    if 0 <= ff < 8 and 0 <= rr < 8:\n                        occ = pm.get(chess.square(ff, rr))\n                        if occ is None or occ.color != p.color:\n                            cnt += 1\n            elif p.piece_type == chess.BISHOP:\n                for df, dr in bishop_dirs:\n                    ff, rr = f+df, r+dr\n                    while 0 <= ff < 8 and 0 <= rr < 8:\n                        occ = pm.get(chess.square(ff, rr))\n                        if occ is None:\n                            cnt += 1\n                            ff += df; rr += dr\n                            continue\n                        if occ.color != p.color:\n                            cnt += 1\n                        break\n            elif p.piece_type == chess.ROOK:\n                for df, dr in rook_dirs:\n                    ff, rr = f+df, r+dr\n                    while 0 <= ff < 8 and 0 <= rr < 8:\n                        occ = pm.get(chess.square(ff, rr))\n                        if occ is None:\n                            cnt += 1\n                            ff += df; rr += dr\n                            continue\n                        if occ.color != p.color:\n                            cnt += 1\n                        break\n            elif p.piece_type == chess.QUEEN:\n                for df, dr in rook_dirs + bishop_dirs:\n                    ff, rr = f+df, r+dr\n                    while 0 <= ff < 8 and 0 <= rr < 8:\n                        occ = pm.get(chess.square(ff, rr))\n                        if occ is None:\n                            cnt += 1\n                            ff += df; rr += dr\n                            continue\n                        if occ.color != p.color:\n                            cnt += 1\n                        break\n            elif p.piece_type == chess.KING:\n                for df in (-1,0,1):\n                    for dr in (-1,0,1):\n                        if df == 0 and dr == 0:\n                            continue\n                        ff, rr = f+df, r+dr\n                        if 0 <= ff < 8 and 0 <= rr < 8:\n                            occ = pm.get(chess.square(ff, rr))\n                            if occ is None or occ.color != p.color:\n                                cnt += 1\n            return cnt\n        score = 0.0\n        for sq,p in pm.items():\n            if not p or p.piece_type == chess.PAWN or p.piece_type == chess.KING:\n                continue\n            moves = pseudo_moves_count(sq, p)\n            attackers = len(board.attackers(not p.color, sq))\n            if moves <= 1 and attackers > 0:\n                # weighted by piece importance\n                val = 0.9 if p.piece_type == chess.QUEEN else (0.6 if p.piece_type == chess.ROOK else 0.4)\n                score += val if p.color == chess.BLACK else -val  # negative means White more trapped -> bad for White\n        # invert so positive favors White (fewer trapped white pieces)\n        return float(-score)\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Central square control: attacked central-16 squares advantage (white - black)'\n    try:\n        central_files = range(2, 6)  # c..f\n        central_ranks = range(2, 6)  # 3..6\n        w_control = 0\n        b_control = 0\n        for ff in central_files:\n            for rr in central_ranks:\n                sq = chess.square(ff, rr)\n                if board.is_attacked_by(chess.WHITE, sq):\n                    w_control += 1\n                if board.is_attacked_by(chess.BLACK, sq):\n                    b_control += 1\n        total = w_control + b_control\n        if total == 0:\n            return 0.0\n        return float((w_control - b_control) / float(total))\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Weak squares near king: how exposed are king vicinities (positive if Black king weaker)'\n    try:\n        pm = board.piece_map()\n        def weak_count(color):\n            ksq = next((sq for sq,p in pm.items() if p and p.piece_type == chess.KING and p.color == color), None)\n            if ksq is None:\n                return 0.0\n            kf = chess.square_file(ksq); kr = chess.square_rank(ksq)\n            opp = chess.BLACK if color == chess.WHITE else chess.WHITE\n            weak = 0.0\n            for ff in range(max(0, kf-2), min(7, kf+2)+1):\n                for rr in range(max(0, kr-2), min(7, kr+2)+1):\n                    sq = chess.square(ff, rr)\n                    if pm.get(sq) and pm.get(sq).color == color and pm.get(sq).piece_type == chess.PAWN:\n                        # pawn defender reduces weakness strongly\n                        continue\n                    if board.is_attacked_by(opp, sq) and not board.is_attacked_by(color, sq):\n                        weak += 1.0\n            return weak\n        return float(weak_count(chess.BLACK) - weak_count(chess.WHITE))\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Queen centrality and safety: reward centralized and well-defended queens (white - black)'\n    try:\n        pm = board.piece_map()\n        def queen_score(color):\n            score = 0.0\n            for sq,p in pm.items():\n                if not p or p.piece_type != chess.QUEEN or p.color != color:\n                    continue\n                f = chess.square_file(sq); r = chess.square_rank(sq)\n                # centrality: closer to center is better\n                dx = (f - 3.5); dy = (r - 3.5)\n                central = 1.0 - ((dx*dx + dy*dy) ** 0.5) / 5.0\n                attackers = len(board.attackers(not color, sq))\n                defenders = len(board.attackers(color, sq))\n                safety = 1.0 + 0.4 * max(0, defenders - attackers) - 0.7 * max(0, attackers - defenders)\n                score += central * safety\n            return score\n        return float(queen_score(chess.WHITE) - queen_score(chess.BLACK))\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Tactical potential: number of legal checking moves and high-value captures available (white - black)'\n    try:\n        orig_turn = board.turn\n        try:\n            stats = {chess.WHITE:0.0, chess.BLACK:0.0}\n            for color in (chess.WHITE, chess.BLACK):\n                board.turn = color\n                checks = 0\n                valuable_caps = 0\n                for mv in board.legal_moves:\n                    try:\n                        board.push(mv)\n                        if board.is_check():\n                            checks += 1\n                        board.pop()\n                        # count captures of high-value targets (queen/rook)\n                        if mv.to_square is not None:\n                            captured = board.piece_at(mv.to_square)\n                            # note: captured is before move in this context, so inspect via pm\n                            # safer to inspect move capture flag: mv.drop? use board.is_capture not available in doc\n                    except Exception:\n                        # if push/pop fails for some move, ensure board is consistent\n                        try:\n                            while len(board.move_stack) and board.move_stack[-1] != mv:\n                                board.pop()\n                        except Exception:\n                            pass\n                # For capture detection separately (without pushing all), use piece_map and see if any legal move.to_square contains opponent piece\n                for mv in board.legal_moves:\n                    occ = board.piece_at(mv.to_square)\n                    if occ and occ.color != color:\n                        if occ.piece_type == chess.QUEEN:\n                            valuable_caps += 2.0\n                        elif occ.piece_type == chess.ROOK:\n                            valuable_caps += 1.2\n                        elif occ.piece_type == chess.BISHOP or occ.piece_type == chess.KNIGHT:\n                            valuable_caps += 0.8\n                        else:\n                            valuable_caps += 0.3\n                stats[color] = checks * 1.4 + valuable_caps\n            return float(stats[chess.WHITE] - stats[chess.BLACK])\n        finally:\n            board.turn = orig_turn\n    except Exception:\n        return 0.0\n",
    "def feature(board: chess.Board) -> float:\n    'Rook pressure on open or half-open files: (#white rooks on open/half-open files - #black) weighted by file openness'\n    try:\n        pm = board.piece_map()\n        def file_pawns(file_idx):\n            pawns = [sq for sq,p in pm.items() if p and p.piece_type == chess.PAWN and chess.square_file(sq) == file_idx]\n            return pawns\n        score = {chess.WHITE:0.0, chess.BLACK:0.0}\n        for sq,p in pm.items():\n            if not p or p.piece_type != chess.ROOK:\n                continue\n            f = chess.square_file(sq)\n            pawns_on_file = file_pawns(f)\n            if len(pawns_on_file) == 0:\n                openness = 1.0  # open file\n            else:\n                # half-open if only opponent pawns present\n                colors = set(pp.color for pp in (pm.get(pp_sq) for pp_sq in pawns_on_file) if pp is not None)\n                if len(colors) == 1 and (p.color not in colors):\n                    openness = 0.7\n                else:\n                    openness = 0.0\n            score[p.color] += openness\n        return float(score[chess.WHITE] - score[chess.BLACK])\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Pawn-structure weaknesses: weighted count of doubled, isolated and likely-backward pawns (white - black)'\n    try:\n        pm = board.piece_map()\n        pawn_files = {chess.WHITE: {f:[] for f in range(8)}, chess.BLACK: {f:[] for f in range(8)}}\n        for sq,p in pm.items():\n            if p and p.piece_type == chess.PAWN:\n                pawn_files[p.color][chess.square_file(sq)].append(sq)\n        def weakness(color):\n            w = 0.0\n            other = chess.BLACK if color == chess.WHITE else chess.WHITE\n            for f in range(8):\n                pawns = pawn_files[color][f]\n                if len(pawns) > 1:\n                    # doubled or tripled\n                    w += 0.8 * (len(pawns) - 1)\n                # isolated: no friendly pawn on adjacent files\n                adj = []\n                if f-1 >= 0: adj.extend(pawn_files[color][f-1])\n                if f+1 <= 7: adj.extend(pawn_files[color][f+1])\n                if len(pawns) > 0 and len(adj) == 0:\n                    w += 1.0\n                    # backward approximation: if isolated and the square in front is attacked by opponent\n                    for sq in pawns:\n                        r = chess.square_rank(sq)\n                        forward_sq = chess.square(f, r+1) if color == chess.WHITE else chess.square(f, r-1)\n                        if 0 <= chess.square_rank(forward_sq) < 8:\n                            if board.is_attacked_by(other, forward_sq):\n                                w += 0.6\n            return w\n        return float(weakness(chess.WHITE) - weakness(chess.BLACK))\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Rooks on the 7th/2nd ranks and targets there: advantage from occupying opponent pawn rank (white - black)'\n    try:\n        pm = board.piece_map()\n        w_score = 0.0; b_score = 0.0\n        for sq,p in pm.items():\n            if not p or p.piece_type != chess.ROOK:\n                continue\n            r = chess.square_rank(sq)\n            f = chess.square_file(sq)\n            if p.color == chess.WHITE:\n                if r == 6:\n                    # on 7th rank: reward and count enemy pawns on that rank as potential targets\n                    targets = sum(1 for ff in range(8) if pm.get(chess.square(ff,6)) and pm.get(chess.square(ff,6)).color == chess.BLACK and pm.get(chess.square(ff,6)).piece_type == chess.PAWN)\n                    w_score += 1.2 + 0.5 * targets\n            else:\n                if r == 1:\n                    targets = sum(1 for ff in range(8) if pm.get(chess.square(ff,1)) and pm.get(chess.square(ff,1)).color == chess.WHITE and pm.get(chess.square(ff,1)).piece_type == chess.PAWN)\n                    b_score += 1.2 + 0.5 * targets\n        return float(w_score - b_score)\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Bishop long-diagonal mobility: sum of unobstructed diagonal squares reachable (white - black)'\n    try:\n        pm = board.piece_map()\n        def diag_length_from(sq):\n            f = chess.square_file(sq); r = chess.square_rank(sq)\n            total = 0\n            for df, dr in ((1,1),(1,-1),(-1,1),(-1,-1)):\n                ff, rr = f + df, r + dr\n                while 0 <= ff < 8 and 0 <= rr < 8:\n                    total += 1\n                    occ = pm.get(chess.square(ff, rr))\n                    if occ is not None:\n                        break\n                    ff += df; rr += dr\n            return total\n        score = {chess.WHITE:0.0, chess.BLACK:0.0}\n        for sq,p in pm.items():\n            if p and p.piece_type == chess.BISHOP:\n                score[p.color] += float(diag_length_from(sq))\n        # normalize by 14 (max approx) to keep values modest\n        return float((score[chess.WHITE] - score[chess.BLACK]) / 14.0)\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Enemy pawn storm near king: number of opponent pawns advanced on or adjacent to the files in front of the king (positive means White has more exposure for Black king)'\n    try:\n        pm = board.piece_map()\n        def storm_exposure(color):\n            king_sq = next((sq for sq,p in pm.items() if p and p.piece_type == chess.KING and p.color == color), None)\n            if king_sq is None:\n                return 0.0\n            opp = chess.BLACK if color == chess.WHITE else chess.WHITE\n            f = chess.square_file(king_sq); r = chess.square_rank(king_sq)\n            score = 0.0\n            # consider pawns on adjacent files and two ranks forward from king side perspective\n            ranks_ahead = [r+1, r+2] if color == chess.WHITE else [r-1, r-2]\n            for ff in range(max(0, f-1), min(7, f+1)+1):\n                for rr in ranks_ahead:\n                    if 0 <= rr < 8:\n                        sq = chess.square(ff, rr)\n                        p = pm.get(sq)\n                        if p and p.piece_type == chess.PAWN and p.color == opp:\n                            # more advanced pawns count higher\n                            dist = abs(rr - r)\n                            score += 1.0 + (1.0 if dist == 2 else 0.0)\n            return score\n        # positive means White king is more exposed to Black pawn storm; we want positive favoring White, so invert\n        return float(storm_exposure(chess.BLACK) - storm_exposure(chess.WHITE))\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Queen centralization and safety: central proximity penalized if queen is under attack (white - black)'\n    try:\n        pm = board.piece_map()\n        centers = [chess.parse_square('d4'), chess.parse_square('e4'), chess.parse_square('d5'), chess.parse_square('e5')]\n        def queen_score(color):\n            qsq = next((sq for sq,p in pm.items() if p and p.piece_type == chess.QUEEN and p.color == color), None)\n            if qsq is None:\n                return 0.0\n            # proximity: inverse of distance to nearest center (max ~7)\n            d = min(chess.square_distance(qsq, c) for c in centers)\n            prox = (7.0 - float(d)) / 7.0\n            # safety: penalize if attacked by opponent pieces\n            opp = chess.BLACK if color == chess.WHITE else chess.WHITE\n            attacked = 1.0 if board.is_attacked_by(opp, qsq) else 0.0\n            return prox - 0.6 * attacked\n        return float(queen_score(chess.WHITE) - queen_score(chess.BLACK))\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Non-pawn piece control of central 16 squares (c3-f6 block): weighted control difference (white - black)'\n    try:\n        pm = board.piece_map()\n        center_squares = []\n        for file in range(2,6):  # c..f\n            for rank in range(2,6):  # 3..6\n                center_squares.append(chess.square(file, rank))\n        vals = {chess.KNIGHT:1.0, chess.BISHOP:1.1, chess.ROOK:0.6, chess.QUEEN:1.4, chess.KING:0.2}\n        score = {chess.WHITE:0.0, chess.BLACK:0.0}\n        for sq in center_squares:\n            for color in (chess.WHITE, chess.BLACK):\n                attackers = board.attackers(color, sq)\n                # count only non-pawn attackers and weight by piece type (unique attackers counted by square)\n                counted = set()\n                for a in attackers:\n                    p = pm.get(a)\n                    if p and p.piece_type != chess.PAWN:\n                        # avoid double-counting same attacker for same center square\n                        if a in counted:\n                            continue\n                        counted.add(a)\n                        score[color] += vals.get(p.piece_type, 0.5)\n        return float(score[chess.WHITE] - score[chess.BLACK])\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Trapped or nearly-trapped high-value pieces: weighted value of opponent pieces with <=1 legal escape and attacked (white - black)'\n    try:\n        pm = board.piece_map()\n        orig = board.turn\n        try:\n            trapped_val = {chess.WHITE:0.0, chess.BLACK:0.0}\n            vals = {chess.PAWN:1.0, chess.KNIGHT:3.0, chess.BISHOP:3.0, chess.ROOK:5.0, chess.QUEEN:9.0, chess.KING:0.0}\n            for color in (chess.WHITE, chess.BLACK):\n                board.turn = color\n                # build mapping of legal moves from squares\n                moves_from = {}\n                for mv in board.legal_moves:\n                    moves_from.setdefault(mv.from_square, 0)\n                    moves_from[mv.from_square] += 1\n                for sq,p in pm.items():\n                    if not p or p.color != color:\n                        continue\n                    # consider high value pieces only (non-pawns preferably)\n                    if vals.get(p.piece_type,0.0) < 3.0:\n                        continue\n                    # if zero or one legal moves from this square and attacked by opponent, treat as trapped-ish\n                    cnt = moves_from.get(sq, 0)\n                    if cnt <= 1:\n                        if board.is_attacked_by(chess.BLACK if color == chess.WHITE else chess.WHITE, sq):\n                            weight = vals.get(p.piece_type,0.0)\n                            # penalize king less (cannot be trapped like others)\n                            trapped_val[color] += weight * (1.0 if cnt == 0 else 0.6)\n            return float(trapped_val[chess.BLACK] - trapped_val[chess.WHITE])\n        finally:\n            board.turn = orig\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Pawn majority and pawn-space on kingside vs queenside: advantage from majority and advanced pawns (white - black)'\n    try:\n        pm = board.piece_map()\n        def side_score(color):\n            files_k = range(5,8)  # f,g,h as kingside\n            files_q = range(0,3)  # a,b,c as queenside\n            ks = sum(1 for f in files_k for sq in (pm.get(chess.square(f,r)) for r in range(8)) if (pm.get(chess.square(f,0)) is not None) )  # dummy to avoid lint\n            # compute properly:\n            kpawns = sum(1 for f in files_k for r in range(8) if (pm.get(chess.square(f,r)) and pm.get(chess.square(f,r)).piece_type == chess.PAWN and pm.get(chess.square(f,r)).color == color))\n            qpawns = sum(1 for f in files_q for r in range(8) if (pm.get(chess.square(f,r)) and pm.get(chess.square(f,r)).piece_type == chess.PAWN and pm.get(chess.square(f,r)).color == color))\n            # advanced pawn factor: count pawns beyond half of board toward opponent\n            adv = 0\n            for sq,p in pm.items():\n                if p and p.piece_type == chess.PAWN and p.color == color:\n                    r = chess.square_rank(sq)\n                    if color == chess.WHITE and r >= 4:\n                        adv += 1\n                    if color == chess.BLACK and r <= 3:\n                        adv += 1\n            # score: majority plus advancement\n            return 0.9 * (kpawns - qpawns) + 0.5 * adv\n        return float(side_score(chess.WHITE) - side_score(chess.BLACK))\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Immediate simplification potential: sum of legal captures that exchange queens or rooks (white - black)'\n    try:\n        pm = board.piece_map()\n        orig = board.turn\n        try:\n            scores = {chess.WHITE:0.0, chess.BLACK:0.0}\n            major_types = (chess.ROOK, chess.QUEEN)\n            for color in (chess.WHITE, chess.BLACK):\n                board.turn = color\n                for mv in board.legal_moves:\n                    target = pm.get(mv.to_square)\n                    mover = pm.get(mv.from_square)\n                    if target and mover:\n                        if target.piece_type in major_types and mover.piece_type in major_types:\n                            # direct major-major capture indicates simplification\n                            scores[color] += 1.5 * (9.0 if target.piece_type == chess.QUEEN else 5.0)\n                        elif target.piece_type in major_types:\n                            scores[color] += 1.0 * (9.0 if target.piece_type == chess.QUEEN else 5.0)\n            return float(scores[chess.WHITE] - scores[chess.BLACK])\n        finally:\n            board.turn = orig\n    except Exception:\n        return 0.0\n",
    "def feature(board: chess.Board) -> float:\n    'Central control weighted by attacker piece values on central and extended-central squares (white - black)'\n    try:\n        pm = board.piece_map()\n        vals = {chess.PAWN:0.5, chess.KNIGHT:3.0, chess.BISHOP:3.0, chess.ROOK:5.0, chess.QUEEN:9.0, chess.KING:0.0}\n        central_names = ['d4','e4','d5','e5','c4','f4','c5','f5']\n        central_sqs = [chess.parse_square(n) for n in central_names]\n        score = {chess.WHITE:0.0, chess.BLACK:0.0}\n        for sq in central_sqs:\n            for color in (chess.WHITE, chess.BLACK):\n                attackers = board.attackers(color, sq)\n                for a in attackers:\n                    p = pm.get(a)\n                    if p:\n                        score[color] += vals.get(p.piece_type, 0.0)\n        return float(score[chess.WHITE] - score[chess.BLACK])\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Count of hanging or tactically vulnerable high-value pieces (weighted) (white - black)'\n    try:\n        pm = board.piece_map()\n        vals = {chess.PAWN:1.0, chess.KNIGHT:3.0, chess.BISHOP:3.0, chess.ROOK:5.0, chess.QUEEN:9.0, chess.KING:0.0}\n        vuln = {chess.WHITE:0.0, chess.BLACK:0.0}\n        for sq,p in list(pm.items()):\n            if not p: continue\n            color = p.color\n            opp = chess.BLACK if color == chess.WHITE else chess.WHITE\n            attackers = board.attackers(opp, sq)\n            if not attackers:\n                continue\n            # sum attacker values and defender values (excluding the piece itself)\n            atk_val = 0.0\n            for a in attackers:\n                pa = pm.get(a)\n                if pa:\n                    atk_val += vals.get(pa.piece_type, 0.0)\n            defenders = board.attackers(color, sq)\n            def_val = 0.0\n            for d in defenders:\n                pd = pm.get(d)\n                if pd:\n                    def_val += vals.get(pd.piece_type, 0.0)\n            # if attackers have more combined value than defenders by a margin, it's vulnerable\n            if atk_val > def_val + 0.5:\n                vuln[color] += vals.get(p.piece_type, 0.0)\n        # a higher value means that side has more vulnerable material; we want positive if White is better -> subtract white vuln from black vuln\n        return float(vuln[chess.BLACK] - vuln[chess.WHITE])\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Passed pawn promotion potential: sum of advancement and support for passed pawns (white - black)'\n    try:\n        pm = board.piece_map()\n        def is_passed_local(sq, color):\n            f = chess.square_file(sq); r = chess.square_rank(sq)\n            opp = chess.BLACK if color == chess.WHITE else chess.WHITE\n            files = [ff for ff in (f-1, f, f+1) if 0 <= ff < 8]\n            if color == chess.WHITE:\n                for ff in files:\n                    for rr in range(r+1, 8):\n                        sqx = chess.square(ff, rr)\n                        p2 = pm.get(sqx)\n                        if p2 and p2.piece_type == chess.PAWN and p2.color == opp:\n                            return False\n                return True\n            else:\n                for ff in files:\n                    for rr in range(0, r):\n                        sqx = chess.square(ff, rr)\n                        p2 = pm.get(sqx)\n                        if p2 and p2.piece_type == chess.PAWN and p2.color == opp:\n                            return False\n                return True\n        score = {chess.WHITE:0.0, chess.BLACK:0.0}\n        for sq,p in pm.items():\n            if not p or p.piece_type != chess.PAWN:\n                continue\n            color = p.color\n            if not is_passed_local(sq, color):\n                continue\n            r = chess.square_rank(sq)\n            # progress to promotion (0..1)\n            progress = (r / 7.0) if color == chess.WHITE else ((7 - r) / 7.0)\n            # support: count friendly pawns on adjacent files ahead (better if supporting)\n            support = 0.0\n            f = chess.square_file(sq)\n            for af in (f-1, f+1):\n                if 0 <= af < 8:\n                    if color == chess.WHITE:\n                        for rr in range(r+1, 8):\n                            psq = chess.square(af, rr)\n                            pp = pm.get(psq)\n                            if pp and pp.piece_type == chess.PAWN and pp.color == color:\n                                support += 0.5\n                                break\n                    else:\n                        for rr in range(0, r):\n                            psq = chess.square(af, rr)\n                            pp = pm.get(psq)\n                            if pp and pp.piece_type == chess.PAWN and pp.color == color:\n                                support += 0.5\n                                break\n            # more advanced passed pawns are exponentially more dangerous\n            score[color] += (progress ** 1.7) + support\n        return float(score[chess.WHITE] - score[chess.BLACK])\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Rook/queen control of open and semi-open files: weighted occupancy (white - black)'\n    try:\n        pm = board.piece_map()\n        files_pawns = {f:0 for f in range(8)}\n        files_pawns_color = {f:{chess.WHITE:0, chess.BLACK:0} for f in range(8)}\n        for sq,p in pm.items():\n            if p and p.piece_type == chess.PAWN:\n                f = chess.square_file(sq)\n                files_pawns[f] += 1\n                files_pawns_color[f][p.color] += 1\n        score = {chess.WHITE:0.0, chess.BLACK:0.0}\n        for sq,p in pm.items():\n            if not p or p.piece_type not in (chess.ROOK, chess.QUEEN):\n                continue\n            color = p.color\n            f = chess.square_file(sq)\n            fpawn = files_pawns[f]\n            own_pawn = files_pawns_color[f][color]\n            if fpawn == 0:\n                weight = 1.0  # open file\n            elif own_pawn == 0:\n                weight = 0.6  # semi-open\n            else:\n                weight = 0.0\n            # additional bonus if the piece is on opponent seventh rank\n            r = chess.square_rank(sq)\n            seventh = (6 if color == chess.WHITE else 1)\n            extra = 0.8 if r == seventh else 0.0\n            score[color] += weight + extra\n        return float(score[chess.WHITE] - score[chess.BLACK])\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Knight outpost score: stable advanced knights without opposing pawn attacks (white - black)'\n    try:\n        pm = board.piece_map()\n        def knight_outpost_score(sq, color):\n            if not (pm.get(sq) and pm.get(sq).piece_type == chess.KNIGHT and pm.get(sq).color == color):\n                return 0.0\n            f = chess.square_file(sq); r = chess.square_rank(sq)\n            opp = chess.BLACK if color == chess.WHITE else chess.WHITE\n            # check for opposing pawns on adjacent files behind the knight (would attack it)\n            for af in (f-1, f+1):\n                if 0 <= af < 8:\n                    if color == chess.WHITE:\n                        for rr in range(0, r):\n                            psq = chess.square(af, rr)\n                            pp = pm.get(psq)\n                            if pp and pp.piece_type == chess.PAWN and pp.color == opp:\n                                return 0.0\n                    else:\n                        for rr in range(r+1, 8):\n                            psq = chess.square(af, rr)\n                            pp = pm.get(psq)\n                            if pp and pp.piece_type == chess.PAWN and pp.color == opp:\n                                return 0.0\n            # it's an outpost if advanced (ranks 4-6 for white, 1-3 for black) or central\n            advanced = False\n            if color == chess.WHITE:\n                advanced = r >= 4\n            else:\n                advanced = r <= 3\n            base = 1.0 if advanced else 0.6\n            # bonus if supported by a pawn or a minor piece\n            supported = False\n            defenders = board.attackers(color, sq)\n            for d in defenders:\n                pd = pm.get(d)\n                if pd and (pd.piece_type == chess.PAWN or pd.piece_type in (chess.KNIGHT, chess.BISHOP)):\n                    supported = True\n                    break\n            if supported:\n                base += 0.7\n            # centrality bonus\n            central_file_bonus = 0.2 if 2 <= f <= 5 else 0.0\n            return base + central_file_bonus\n        score = {chess.WHITE:0.0, chess.BLACK:0.0}\n        for sq,p in pm.items():\n            if not p or p.piece_type != chess.KNIGHT:\n                continue\n            score[p.color] += knight_outpost_score(sq, p.color)\n        return float(score[chess.WHITE] - score[chess.BLACK])\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'King exposure on open/semi-open adjacent files weighted by enemy heavy presence (positive if Black king more exposed)'\n    try:\n        pm = board.piece_map()\n        def exposure_for(color):\n            king_sq = next((sq for sq,p in pm.items() if p and p.piece_type == chess.KING and p.color == color), None)\n            if king_sq is None:\n                return 0.0\n            f = chess.square_file(king_sq)\n            opp = chess.BLACK if color == chess.WHITE else chess.WHITE\n            exposure = 0.0\n            for af in (f-1, f, f+1):\n                if not (0 <= af < 8):\n                    continue\n                # count pawns on that file and friendly pawns\n                file_pawns = 0\n                friendly_pawns = 0\n                for rr in range(8):\n                    sqx = chess.square(af, rr)\n                    pp = pm.get(sqx)\n                    if pp and pp.piece_type == chess.PAWN:\n                        file_pawns += 1\n                        if pp.color == color:\n                            friendly_pawns += 1\n                if file_pawns == 0:\n                    file_status = 2.0\n                elif friendly_pawns == 0:\n                    file_status = 1.0\n                else:\n                    file_status = 0.0\n                if file_status == 0.0:\n                    continue\n                # count opponent heavy pieces (rook/queen) that attack or sit on that file\n                heavies = 0\n                for rr in range(8):\n                    sqx = chess.square(af, rr)\n                    # any opponent rook/queen on file\n                    p_here = pm.get(sqx)\n                    if p_here and p_here.color == opp and p_here.piece_type in (chess.ROOK, chess.QUEEN):\n                        heavies += 1\n                    # or attackers to that square by opp heavy piece\n                    attackers = board.attackers(opp, sqx)\n                    for a in attackers:\n                        pa = pm.get(a)\n                        if pa and pa.piece_type in (chess.ROOK, chess.QUEEN) and pa.color == opp:\n                            heavies += 0.5\n                exposure += file_status * heavies\n            # also small penalty for direct checks available against king (attacker count)\n            attackers_to_king = board.attackers(opp, king_sq)\n            attacker_val = 0.0\n            for a in attackers_to_king:\n                pa = pm.get(a)\n                if pa:\n                    if pa.piece_type in (chess.ROOK, chess.QUEEN):\n                        attacker_val += 1.2\n                    elif pa.piece_type in (chess.BISHOP, chess.KNIGHT):\n                        attacker_val += 0.6\n                    elif pa.piece_type == chess.PAWN:\n                        attacker_val += 0.2\n            exposure += attacker_val\n            return exposure\n        black_exposure = exposure_for(chess.BLACK)\n        white_exposure = exposure_for(chess.WHITE)\n        # positive if Black king more exposed (favors White)\n        return float(black_exposure - white_exposure)\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Minor-piece mobility balance: average legal moves per bishop/knight (white - black)'\n    try:\n        orig = board.turn\n        pm = board.piece_map()\n        result = {chess.WHITE:0.0, chess.BLACK:0.0}\n        counts = {chess.WHITE:0, chess.BLACK:0}\n        try:\n            for color in (chess.WHITE, chess.BLACK):\n                board.turn = color\n                move_count = 0\n                piece_count = 0\n                for mv in board.legal_moves:\n                    p = board.piece_at(mv.from_square)\n                    if p and p.color == color and p.piece_type in (chess.KNIGHT, chess.BISHOP):\n                        move_count += 1\n                # count pieces\n                for p in pm.values():\n                    if p and p.color == color and p.piece_type in (chess.KNIGHT, chess.BISHOP):\n                        piece_count += 1\n                result[color] = (move_count / piece_count) if piece_count > 0 else 0.0\n                counts[color] = piece_count\n        finally:\n            board.turn = orig\n        # also prefer bishop pair slightly\n        bp_w = sum(1 for p in pm.values() if p and p.color == chess.WHITE and p.piece_type == chess.BISHOP)\n        bp_b = sum(1 for p in pm.values() if p and p.color == chess.BLACK and p.piece_type == chess.BISHOP)\n        bishop_pair_bonus = 0.25 * ((1 if bp_w >= 2 else 0) - (1 if bp_b >= 2 else 0))\n        return float((result[chess.WHITE] - result[chess.BLACK]) + bishop_pair_bonus)\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Tempo and tactical opportunity proxy: legal moves that give check, capture a higher-value piece or create double attacks (white - black)'\n    try:\n        orig = board.turn\n        pm = board.piece_map()\n        vals = {chess.PAWN:1.0, chess.KNIGHT:3.0, chess.BISHOP:3.0, chess.ROOK:5.0, chess.QUEEN:9.0, chess.KING:0.0}\n        score = {chess.WHITE:0.0, chess.BLACK:0.0}\n        try:\n            for color in (chess.WHITE, chess.BLACK):\n                board.turn = color\n                for mv in list(board.legal_moves):\n                    try:\n                        board.push(mv)\n                    except Exception:\n                        continue\n                    bonus = 0.0\n                    # check giving moves\n                    if board.is_check():\n                        bonus += 1.2\n                    # capture of higher or equal value\n                    captured = mv.to_square\n                    # note: captured piece: we can inspect the move captured piece using mv object not directly, but after move we can check last move captured? Simpler: use 'captured_piece' by looking at mv and original board state before push via pm -- but pm changed; use pm snapshot above\n                    frm_p = pm.get(mv.from_square)\n                    captured_p = None\n                    # original captured piece is the piece previously at to-square in original pm\n                    captured_p = pm.get(mv.to_square)\n                    if captured_p and frm_p:\n                        if vals.get(captured_p.piece_type, 0.0) >= vals.get(frm_p.piece_type, 0.0):\n                            bonus += 0.9\n                        elif vals.get(captured_p.piece_type, 0.0) > 0.0:\n                            bonus += 0.4\n                    # double attack: moved piece now attacks two or more opponent pieces\n                    dest = mv.to_square\n                    attacks = board.attackers(color, dest)\n                    # count distinct opponent pieces attacked from the destination square\n                    attacked_count = 0\n                    for sq2,p2 in board.piece_map().items():\n                        if p2 and p2.color != color:\n                            if dest in board.attackers(color, sq2):\n                                attacked_count += 1\n                    if attacked_count >= 2:\n                        bonus += 0.8 * attacked_count\n                    # small bonus for creating a discovered attack (approx by if moved piece uncovering attack from another piece)\n                    # naive heuristic: if there exists a friendly piece that now attacks the original to-square and didn't before\n                    # skip precise check for speed\n                    score[color] += bonus\n                    board.pop()\n        finally:\n            board.turn = orig\n        return float(score[chess.WHITE] - score[chess.BLACK])\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'King centralization in endgames: king proximity to center (white - black), only relevant when minor/major material is low'\n    try:\n        pm = board.piece_map()\n        nonpawn_material = 0\n        for p in pm.values():\n            if p and p.piece_type not in (chess.PAWN, chess.KING):\n                nonpawn_material += 1\n        # treat as endgame when few non-pawn pieces remain\n        if nonpawn_material > 6:\n            return 0.0\n        # center squares considered as e4,d4,e5,d5\n        center_sqs = [chess.parse_square(n) for n in ('d4','e4','d5','e5')]\n        def center_proximity(color):\n            king_sq = next((sq for sq,p in pm.items() if p and p.piece_type == chess.KING and p.color == color), None)\n            if king_sq is None:\n                return 0.0\n            # proximity measured as inverse of Manhattan distance to nearest center square (normalized)\n            dmin = min(chess.square_distance(king_sq, csq) for csq in center_sqs)\n            # max manhattan on board is 14; map to 0..1 where closer -> higher\n            return (14.0 - float(dmin)) / 14.0\n        return float(center_proximity(chess.WHITE) - center_proximity(chess.BLACK))\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Space advantage: difference in number of squares in opponent half controlled by non-pawn pieces (white - black)'\n    try:\n        pm = board.piece_map()\n        def controlled_in_opponent_half(color):\n            cnt = 0\n            # define opponent half ranks\n            if color == chess.WHITE:\n                ranks = range(4,8)  # ranks 5-8 (0-indexed 4..7) -> opponent half for white\n            else:\n                ranks = range(0,4)  # ranks 1-4 for black\n            for r in ranks:\n                for f in range(8):\n                    sq = chess.square(f, r)\n                    # require at least one non-pawn piece of color attacking this square\n                    attackers = board.attackers(color, sq)\n                    found = False\n                    for a in attackers:\n                        pa = pm.get(a)\n                        if pa and pa.color == color and pa.piece_type != chess.PAWN:\n                            found = True\n                            break\n                    if found:\n                        cnt += 1\n            return float(cnt)\n        return float(controlled_in_opponent_half(chess.WHITE) - controlled_in_opponent_half(chess.BLACK))\n    except Exception:\n        return 0.0\n",
    "def feature(board: chess.Board) -> float:\n    'Pawn island count difference (white islands - black islands), fewer islands = healthier pawn structure'\n    try:\n        pm = board.piece_map()\n        def pawn_islands(color):\n            files_with = [False]*8\n            for sq,p in pm.items():\n                if p and p.piece_type == chess.PAWN and p.color == color:\n                    f = chess.square_file(sq)\n                    files_with[f] = True\n            islands = 0\n            prev = False\n            for f in range(8):\n                if files_with[f] and not prev:\n                    islands += 1\n                    prev = True\n                elif not files_with[f]:\n                    prev = False\n            return float(islands)\n        return float(pawn_islands(chess.WHITE) - pawn_islands(chess.BLACK))\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Passed pawns advancement and protection score (white - black): advanced and supported passed pawns contribute more'\n    try:\n        pm = board.piece_map()\n        def is_passed(sq, color):\n            f = chess.square_file(sq); r = chess.square_rank(sq)\n            opp = chess.BLACK if color == chess.WHITE else chess.WHITE\n            if color == chess.WHITE:\n                for af in (f-1, f, f+1):\n                    for rr in range(r+1, 8):\n                        if 0 <= af < 8:\n                            p = pm.get(chess.square(af, rr))\n                            if p and p.piece_type == chess.PAWN and p.color == opp:\n                                return False\n                return True\n            else:\n                for af in (f-1, f, f+1):\n                    for rr in range(0, r):\n                        if 0 <= af < 8:\n                            p = pm.get(chess.square(af, rr))\n                            if p and p.piece_type == chess.PAWN and p.color == opp:\n                                return False\n                return True\n        def passed_score(color):\n            score = 0.0\n            for sq,p in pm.items():\n                if not p or p.piece_type != chess.PAWN or p.color != color:\n                    continue\n                if is_passed(sq, color):\n                    r = chess.square_rank(sq)\n                    # advancement factor: closer to promotion gives higher weight\n                    adv = (r / 7.0) if color == chess.WHITE else ((7 - r) / 7.0)\n                    # support factor: friendly attackers of the pawn square\n                    support = len(board.attackers(color, sq))\n                    score += 1.0 + 2.5 * adv + 0.5 * min(support, 3)\n            return score\n        return float(passed_score(chess.WHITE) - passed_score(chess.BLACK))\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Number of rooks on the opponent seventh rank (white - black) \u2014 strong positional pressure indicator'\n    try:\n        pm = board.piece_map()\n        w_cnt = 0.0; b_cnt = 0.0\n        for sq,p in pm.items():\n            if not p or p.piece_type != chess.ROOK:\n                continue\n            r = chess.square_rank(sq)\n            if p.color == chess.WHITE and r == 6:\n                w_cnt += 1.0\n            if p.color == chess.BLACK and r == 1:\n                b_cnt += 1.0\n        return float(w_cnt - b_cnt)\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Bishop pair and active-bishop bonus (white - black): rewards having two bishops and mobility of bishops'\n    try:\n        pm = board.piece_map()\n        orig = board.turn\n        try:\n            move_counts = {chess.WHITE: {}, chess.BLACK: {}}\n            for color in (chess.WHITE, chess.BLACK):\n                board.turn = color\n                for mv in board.legal_moves:\n                    frm = mv.from_square\n                    move_counts[color][frm] = move_counts[color].get(frm, 0) + 1\n        finally:\n            board.turn = orig\n        def bishop_score(color):\n            count = 0\n            mobility = 0.0\n            for sq,p in pm.items():\n                if p and p.piece_type == chess.BISHOP and p.color == color:\n                    count += 1\n                    mobility += float(move_counts[color].get(sq, 0))\n            pair_bonus = 1.5 if count >= 2 else 0.0\n            return pair_bonus + mobility * 0.15\n        return float(bishop_score(chess.WHITE) - bishop_score(chess.BLACK))\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'King centrality advantage in endgames (white - black), more central in endgame is beneficial'\n    try:\n        pm = board.piece_map()\n        # quantify non-pawn non-king material to detect endgame\n        vals = {chess.KNIGHT:3.0, chess.BISHOP:3.0, chess.ROOK:5.0, chess.QUEEN:9.0}\n        material = 0.0\n        for p in pm.values():\n            if p and p.piece_type in vals:\n                material += vals[p.piece_type]\n        # weight depends on endgame proximity\n        weight = 1.0 if material <= 8.0 else 0.25\n        centers = [chess.parse_square(s) for s in ('d4','e4','d5','e5')]\n        def centrality(color):\n            ksq = next((sq for sq,p in pm.items() if p and p.piece_type == chess.KING and p.color == color), None)\n            if ksq is None:\n                return 0.0\n            # smallest Manhattan distance to center squares, max possible distance 7 (approx)\n            d = min(chess.square_distance(ksq, c) for c in centers)\n            # normalize: closer => higher\n            norm = (7.0 - float(d)) / 7.0\n            return norm\n        return float((centrality(chess.WHITE) - centrality(chess.BLACK)) * weight)\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Mobility per unit of non-pawn material (white - black) to detect poor piece efficiency'\n    try:\n        pm = board.piece_map()\n        vals = {chess.KNIGHT:3.0, chess.BISHOP:3.0, chess.ROOK:5.0, chess.QUEEN:9.0}\n        mat_nonpawn = {chess.WHITE:0.0, chess.BLACK:0.0}\n        for p in pm.values():\n            if p and p.piece_type in vals:\n                mat_nonpawn[p.color] += vals[p.piece_type]\n        orig = board.turn\n        try:\n            moves_nonpawn = {chess.WHITE:0.0, chess.BLACK:0.0}\n            for color in (chess.WHITE, chess.BLACK):\n                board.turn = color\n                for mv in board.legal_moves:\n                    p = board.piece_at(mv.from_square)\n                    if p and p.piece_type != chess.PAWN and p.color == color:\n                        moves_nonpawn[color] += 1.0\n        finally:\n            board.turn = orig\n        w_score = moves_nonpawn[chess.WHITE] / (1.0 + mat_nonpawn[chess.WHITE])\n        b_score = moves_nonpawn[chess.BLACK] / (1.0 + mat_nonpawn[chess.BLACK])\n        return float(w_score - b_score)\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Isolated pawns penalty difference (black isolated pawns - white isolated pawns), positive favors White if Black has more isolations'\n    try:\n        pm = board.piece_map()\n        def isolated_count(color):\n            files = [0]*8\n            for sq,p in pm.items():\n                if p and p.piece_type == chess.PAWN and p.color == color:\n                    files[chess.square_file(sq)] += 1\n            cnt = 0\n            for f in range(8):\n                if files[f] == 0:\n                    continue\n                adj = 0\n                if f-1 >= 0: adj += files[f-1]\n                if f+1 <= 7: adj += files[f+1]\n                if adj == 0:\n                    cnt += files[f]\n            return float(cnt)\n        return float(isolated_count(chess.BLACK) - isolated_count(chess.WHITE))\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'King pawn shelter strength difference (white - black): counts pawns in three-file shelter in front of king, penalized if those squares are attacked'\n    try:\n        pm = board.piece_map()\n        vals = {chess.PAWN:1.0}\n        def shelter(color):\n            ksq = next((sq for sq,p in pm.items() if p and p.piece_type == chess.KING and p.color == color), None)\n            if ksq is None:\n                return 0.0\n            f = chess.square_file(ksq); r = chess.square_rank(ksq)\n            dirs = [1,2] if color == chess.WHITE else [-1,-2]\n            score = 0.0\n            opp = chess.BLACK if color == chess.WHITE else chess.WHITE\n            for d in dirs:\n                rr = r + d\n                if 0 <= rr < 8:\n                    for ff in (f-1, f, f+1):\n                        if 0 <= ff < 8:\n                            sq = chess.square(ff, rr)\n                            p = pm.get(sq)\n                            if p and p.piece_type == chess.PAWN and p.color == color:\n                                # reduce value if attacked by opponent\n                                attackers = len(board.attackers(opp, sq))\n                                penalty = 0.4 * min(attackers, 2)\n                                score += (1.0 - penalty)\n            return score\n        return float(shelter(chess.WHITE) - shelter(chess.BLACK))\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Enemy queen exposure score difference (black_exposed - white_exposed): counts attacked/underdefended queens (good for side owning opponent-exposed queen)'\n    try:\n        pm = board.piece_map()\n        def exposed_score(color_of_victim):\n            # score how exposed the queen of color_of_victim is (higher = worse for that color)\n            score = 0.0\n            qsq = next((sq for sq,p in pm.items() if p and p.piece_type == chess.QUEEN and p.color == color_of_victim), None)\n            if qsq is None:\n                return 0.0\n            opp = chess.BLACK if color_of_victim == chess.WHITE else chess.WHITE\n            attackers = len(board.attackers(opp, qsq))\n            if attackers == 0:\n                return 0.0\n            defenders = len(board.attackers(color_of_victim, qsq))\n            # weighted exposure: more attackers and fewer defenders increases score\n            weight = float(attackers) * (1.0 if defenders == 0 else 0.5)\n            score += 9.0 * weight\n            return score\n        return float(exposed_score(chess.BLACK) - exposed_score(chess.WHITE))\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Control of open/half-open files by heavy pieces (white - black): rewards rooks/queens on files without own pawns, more if file is totally open'\n    try:\n        pm = board.piece_map()\n        # determine pawns presence per file\n        file_has_white_pawn = [False]*8\n        file_has_black_pawn = [False]*8\n        for sq,p in pm.items():\n            if p and p.piece_type == chess.PAWN:\n                f = chess.square_file(sq)\n                if p.color == chess.WHITE:\n                    file_has_white_pawn[f] = True\n                else:\n                    file_has_black_pawn[f] = True\n        def heavy_control(color):\n            score = 0.0\n            for sq,p in pm.items():\n                if not p or p.piece_type not in (chess.ROOK, chess.QUEEN) or p.color != color:\n                    continue\n                f = chess.square_file(sq)\n                # half-open for color if no friendly pawn; open if no pawn at all\n                half_open = not file_has_white_pawn[f] if color == chess.WHITE else not file_has_black_pawn[f]\n                open_file = not file_has_white_pawn[f] and not file_has_black_pawn[f]\n                if open_file:\n                    score += 1.5\n                elif half_open:\n                    score += 0.9\n                else:\n                    # still reward rooks/queens on files where they exert pressure (more mobile)\n                    score += 0.1\n            return score\n        return float(heavy_control(chess.WHITE) - heavy_control(chess.BLACK))\n    except Exception:\n        return 0.0\n",
    "def feature(board: chess.Board) -> float:\n    'Passed pawn pressure: sum of passed-pawn proximity-to-promotion (white - black)'\n    try:\n        pm = board.piece_map()\n        # Precompute pawn squares by color\n        pawn_squares = {chess.WHITE: set(), chess.BLACK: set()}\n        for sq, p in pm.items():\n            if p and p.piece_type == chess.PAWN:\n                pawn_squares[p.color].add(sq)\n        def passed_score(color):\n            score = 0.0\n            opp = chess.BLACK if color == chess.WHITE else chess.WHITE\n            for sq in list(pawn_squares[color]):\n                f = chess.square_file(sq); r = chess.square_rank(sq)\n                blocked = False\n                # For white, opponent pawns on same or adjacent files on any higher rank block passed status\n                if color == chess.WHITE:\n                    for ff in (f-1, f, f+1):\n                        if ff < 0 or ff > 7:\n                            continue\n                        for rr in range(r+1, 8):\n                            s2 = chess.square(ff, rr)\n                            if s2 in pawn_squares[opp]:\n                                blocked = True\n                                break\n                        if blocked:\n                            break\n                    if not blocked:\n                        # closer to promotion gets higher weight\n                        score += ((7 - r) / 7.0)\n                else:\n                    for ff in (f-1, f, f+1):\n                        if ff < 0 or ff > 7:\n                            continue\n                        for rr in range(r-1, -1, -1):\n                            s2 = chess.square(ff, rr)\n                            if s2 in pawn_squares[opp]:\n                                blocked = True\n                                break\n                        if blocked:\n                            break\n                    if not blocked:\n                        score += (r / 7.0)\n            return score\n        return float(passed_score(chess.WHITE) - passed_score(chess.BLACK))\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Hanging pieces value: sum of values of pieces attacked and undefended (white - black)'\n    try:\n        vals = {chess.PAWN:1.0, chess.KNIGHT:3.0, chess.BISHOP:3.0, chess.ROOK:5.0, chess.QUEEN:9.0, chess.KING:0.0}\n        pm = board.piece_map()\n        score = {chess.WHITE:0.0, chess.BLACK:0.0}\n        for sq, p in pm.items():\n            if not p:\n                continue\n            color = p.color\n            opp = chess.BLACK if color == chess.WHITE else chess.WHITE\n            # attacked by opponent?\n            if board.is_attacked_by(opp, sq):\n                # defenders are attackers from own color\n                defenders = board.attackers(color, sq)\n                if not defenders:\n                    score[color] += vals.get(p.piece_type, 0.0)\n        return float(score[chess.WHITE] - score[chess.BLACK])\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Bishop diagonal mobility: sum of available diagonal squares for bishops (white - black)'\n    try:\n        pm = board.piece_map()\n        def diag_mobility(color):\n            total = 0.0\n            for sq, p in pm.items():\n                if not p or p.piece_type != chess.BISHOP or p.color != color:\n                    continue\n                f = chess.square_file(sq); r = chess.square_rank(sq)\n                # four diagonal directions\n                for df, dr in ((1,1),(1,-1),(-1,1),(-1,-1)):\n                    nf, nr = f + df, r + dr\n                    steps = 0\n                    while 0 <= nf <= 7 and 0 <= nr <= 7:\n                        s2 = chess.square(nf, nr)\n                        if pm.get(s2) is None:\n                            steps += 1\n                            nf += df; nr += dr\n                            continue\n                        else:\n                            # blocked by any piece\n                            break\n                    total += float(steps)\n            return total\n        return float(diag_mobility(chess.WHITE) - diag_mobility(chess.BLACK))\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Rook file control: rooks on open files (1.0) or semi-open (0.5) (white - black)'\n    try:\n        pm = board.piece_map()\n        def rook_score(color):\n            s = 0.0\n            for sq, p in pm.items():\n                if not p or p.piece_type != chess.ROOK or p.color != color:\n                    continue\n                f = chess.square_file(sq)\n                pawn_present = False\n                own_pawn_present = False\n                opp_pawn_present = False\n                for rr in range(8):\n                    s2 = chess.square(f, rr)\n                    q = pm.get(s2)\n                    if q and q.piece_type == chess.PAWN:\n                        pawn_present = True\n                        if q.color == color:\n                            own_pawn_present = True\n                        else:\n                            opp_pawn_present = True\n                if not pawn_present:\n                    s += 1.0\n                elif not own_pawn_present and opp_pawn_present:\n                    s += 0.5\n            return s\n        return float(rook_score(chess.WHITE) - rook_score(chess.BLACK))\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'King centralization in endgames: centrality bonus when low material (white - black)'\n    try:\n        vals = {chess.PAWN:1.0, chess.KNIGHT:3.0, chess.BISHOP:3.0, chess.ROOK:5.0, chess.QUEEN:9.0}\n        total_mat = 0.0\n        pm = board.piece_map()\n        for p in pm.values():\n            if p and p.piece_type in vals:\n                total_mat += vals[p.piece_type]\n        # Only meaningful in simplified/endgame positions\n        if total_mat > 12.0:\n            return 0.0\n        centers = [chess.parse_square(s) for s in ('d4','e4','d5','e5')]\n        maxd = 6.0\n        def centrality(color):\n            ks = next((sq for sq,p in pm.items() if p and p.piece_type==chess.KING and p.color==color), None)\n            if ks is None:\n                return 0.0\n            dmin = min(chess.square_distance(ks, c) for c in centers)\n            return (maxd - float(dmin)) / maxd\n        return float(centrality(chess.WHITE) - centrality(chess.BLACK))\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Pawn islands difference: (black islands - white islands) positive favors White if fewer white islands'\n    try:\n        pm = board.piece_map()\n        def islands(color):\n            files_with = [False]*8\n            for sq,p in pm.items():\n                if p and p.piece_type == chess.PAWN and p.color == color:\n                    files_with[chess.square_file(sq)] = True\n            cnt = 0\n            i = 0\n            while i < 8:\n                if files_with[i]:\n                    cnt += 1\n                    while i < 8 and files_with[i]:\n                        i += 1\n                else:\n                    i += 1\n            return cnt\n        white_is = islands(chess.WHITE)\n        black_is = islands(chess.BLACK)\n        # positive when black has more islands (i.e., white better)\n        return float(black_is - white_is)\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'King pawn-shield gaps: count of missing shield pawns on three-file front window (black - white)'\n    try:\n        pm = board.piece_map()\n        def gaps(color):\n            ks = next((sq for sq,p in pm.items() if p and p.piece_type==chess.KING and p.color==color), None)\n            if ks is None:\n                return 0.0\n            kf = chess.square_file(ks); kr = chess.square_rank(ks)\n            gap = 0.0\n            steps = [1,2] if color==chess.WHITE else [-1,-2]\n            for df in (-1,0,1):\n                found = False\n                for s in steps:\n                    rf = kr + s; ff = kf + df\n                    if 0 <= rf <= 7 and 0 <= ff <= 7:\n                        sq = chess.square(ff, rf)\n                        p = pm.get(sq)\n                        if p and p.piece_type==chess.PAWN and p.color==color:\n                            found = True\n                            break\n                if not found:\n                    gap += 1.0\n            return gap\n        return float(gaps(chess.BLACK) - gaps(chess.WHITE))\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Minor vs major composition: (minor_weight - major_weight) (white - black) normalized'\n    try:\n        pm = board.piece_map()\n        def comp(color):\n            minors = 0.0\n            majors = 0.0\n            for p in pm.values():\n                if not p or p.color != color:\n                    continue\n                if p.piece_type in (chess.KNIGHT, chess.BISHOP):\n                    minors += 1.0\n                if p.piece_type in (chess.ROOK, chess.QUEEN):\n                    majors += 1.0\n            # weight minors ~1, majors ~1.8 to reflect mobility/power\n            return minors * 1.0 - majors * 1.8\n        return float(comp(chess.WHITE) - comp(chess.BLACK))\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Vulnerable high-value pieces: count of rooks/queens attacked by more attackers than defenders (white - black)'\n    try:\n        pm = board.piece_map()\n        vals = {chess.PAWN:1.0, chess.KNIGHT:3.0, chess.BISHOP:3.0, chess.ROOK:5.0, chess.QUEEN:9.0}\n        vuln = {chess.WHITE:0.0, chess.BLACK:0.0}\n        for sq, p in pm.items():\n            if not p or p.piece_type not in (chess.ROOK, chess.QUEEN):\n                continue\n            color = p.color\n            opp = chess.BLACK if color == chess.WHITE else chess.WHITE\n            attackers = board.attackers(opp, sq)\n            defenders = board.attackers(color, sq)\n            if attackers and len(attackers) > len(defenders):\n                # weight by piece value\n                vuln[color] += vals.get(p.piece_type, 0.0)\n        return float(vuln[chess.WHITE] - vuln[chess.BLACK])\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Capture mobility ratio for each side: normalized capture moves ratio difference (white - black)'\n    try:\n        orig = board.turn\n        try:\n            caps = {chess.WHITE:0, chess.BLACK:0}\n            totals = {chess.WHITE:0, chess.BLACK:0}\n            pm = board.piece_map()\n            for color in (chess.WHITE, chess.BLACK):\n                board.turn = color\n                for mv in board.legal_moves:\n                    totals[color] += 1\n                    # simple capture test: target square occupied by opponent piece\n                    to_sq = mv.to_square\n                    target = pm.get(to_sq)\n                    if target and target.color != color:\n                        caps[color] += 1\n                # If there were no moves, leave counts as zero\n            w_ratio = caps[chess.WHITE] / max(1, totals[chess.WHITE])\n            b_ratio = caps[chess.BLACK] / max(1, totals[chess.BLACK])\n            return float(w_ratio - b_ratio)\n        finally:\n            board.turn = orig\n    except Exception:\n        return 0.0\n",
    "def feature(board: chess.Board) -> float:\n    'Passed pawn potential weighted by distance to promotion and king proximity (white - black)'\n    try:\n        vals = {chess.PAWN:1.0, chess.KNIGHT:3.0, chess.BISHOP:3.0, chess.ROOK:5.0, chess.QUEEN:9.0, chess.KING:0.0}\n        pm = board.piece_map()\n        kings = {chess.WHITE: None, chess.BLACK: None}\n        for sq, p in pm.items():\n            if p and p.piece_type == chess.KING:\n                kings[p.color] = sq\n        def is_passed(sq, color):\n            f = chess.square_file(sq); r = chess.square_rank(sq)\n            opp = chess.BLACK if color == chess.WHITE else chess.WHITE\n            if color == chess.WHITE:\n                for of in (f-1, f, f+1):\n                    if 0 <= of < 8:\n                        for rr in range(r+1, 8):\n                            p = pm.get(chess.square(of, rr))\n                            if p and p.piece_type == chess.PAWN and p.color == opp:\n                                return False\n                return True\n            else:\n                for of in (f-1, f, f+1):\n                    if 0 <= of < 8:\n                        for rr in range(0, r):\n                            p = pm.get(chess.square(of, rr))\n                            if p and p.piece_type == chess.PAWN and p.color == opp:\n                                return False\n                return True\n        score = {chess.WHITE:0.0, chess.BLACK:0.0}\n        for sq, p in pm.items():\n            if not p or p.piece_type != chess.PAWN:\n                continue\n            color = p.color\n            if not is_passed(sq, color):\n                continue\n            f = chess.square_file(sq); r = chess.square_rank(sq)\n            if color == chess.WHITE:\n                dist_to_promo = 7 - r\n                promo_sq = chess.square(f, 7)\n            else:\n                dist_to_promo = r\n                promo_sq = chess.square(f, 0)\n            promo_bonus = 1.0 + (dist_to_promo / 7.0)  # farther from promotion gives higher numeric but normalized\n            # king support: closer own king to promotion square increases score\n            ksq = kings.get(color)\n            king_closeness = 0.0\n            if ksq is not None:\n                d = chess.square_distance(ksq, promo_sq)\n                king_closeness = (14.0 - float(d)) / 14.0\n            score[color] += promo_bonus * (0.6 + 0.8 * king_closeness)\n        return float(score[chess.WHITE] - score[chess.BLACK])\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Hanging valuable pieces: sum of values of undefended attacked pieces (white - black)'\n    try:\n        pm = board.piece_map()\n        vals = {chess.PAWN:1.0, chess.KNIGHT:3.0, chess.BISHOP:3.0, chess.ROOK:5.0, chess.QUEEN:9.0, chess.KING:0.0}\n        hang = {chess.WHITE:0.0, chess.BLACK:0.0}\n        for sq, p in pm.items():\n            if not p:\n                continue\n            color = p.color\n            opp = chess.BLACK if color == chess.WHITE else chess.WHITE\n            try:\n                attackers = board.attackers(opp, sq)\n                defenders = board.attackers(color, sq)\n            except Exception:\n                attackers = set(); defenders = set()\n            if attackers and not defenders and p.piece_type != chess.KING:\n                hang[color] += vals.get(p.piece_type, 0.0)\n        # higher hang for a side is bad => we return (white_hang - black_hang) negated so positive favors White\n        return float((hang[chess.BLACK] - hang[chess.WHITE]))\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Rooks on the seventh rank effectiveness: weighted presence by enemy pawn concentration (white - black)'\n    try:\n        pm = board.piece_map()\n        def rook_score(color):\n            score = 0.0\n            for sq, p in pm.items():\n                if not p or p.piece_type != chess.ROOK or p.color != color:\n                    continue\n                f = chess.square_file(sq); r = chess.square_rank(sq)\n                # seventh rank: for White rooks rank 6, for Black rank 1\n                target_rank = 6 if color == chess.WHITE else 1\n                if r != target_rank:\n                    continue\n                # count enemy pawns on that rank (these are often targets)\n                opp = chess.BLACK if color == chess.WHITE else chess.WHITE\n                pawns_on_rank = 0\n                for ff in range(8):\n                    p2 = board.piece_at(chess.square(ff, target_rank))\n                    if p2 and p2.piece_type == chess.PAWN and p2.color == opp:\n                        pawns_on_rank += 1\n                score += 1.0 + 0.4 * pawns_on_rank\n            return score\n        return float(rook_score(chess.WHITE) - rook_score(chess.BLACK))\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Locked central pawn confrontations on c/d/e/f files (white - black); counts face-to-face pawn pairs'\n    try:\n        pm = board.piece_map()\n        central_files = (2, 3, 4, 5)\n        locked_w = 0; locked_b = 0\n        seen_pairs = set()\n        for f in central_files:\n            for r in range(8):\n                sq = chess.square(f, r)\n                p = pm.get(sq)\n                if not p or p.piece_type != chess.PAWN:\n                    continue\n                if p.color == chess.WHITE:\n                    # check if a black pawn directly ahead (r+1) on same file\n                    rr = r + 1\n                    if rr < 8:\n                        sq2 = chess.square(f, rr)\n                        p2 = pm.get(sq2)\n                        if p2 and p2.piece_type == chess.PAWN and p2.color == chess.BLACK:\n                            key = (f, r, rr)\n                            if key not in seen_pairs:\n                                locked_w += 1\n                                seen_pairs.add(key)\n                else:\n                    rr = r - 1\n                    if rr >= 0:\n                        sq2 = chess.square(f, rr)\n                        p2 = pm.get(sq2)\n                        if p2 and p2.piece_type == chess.PAWN and p2.color == chess.WHITE:\n                            key = (f, rr, r)\n                            if key not in seen_pairs:\n                                locked_b += 1\n                                seen_pairs.add(key)\n        # locked_w counts pairs where white pawn faces black pawn with white on lower rank (normal). We want difference white - black from perspective of advantage for whoever has more locked central pawns? Usually having locked center can favor attacker; we return black - white to favor White if black has more locks (so reduce white advantage)\n        return float(locked_b - locked_w)\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'King centralization importance in endgames: centralization score scaled by low non-pawn material (white - black)'\n    try:\n        pm = board.piece_map()\n        nonpawn_material = 0.0\n        vals = {chess.KNIGHT:3.0, chess.BISHOP:3.0, chess.ROOK:5.0, chess.QUEEN:9.0}\n        kings = {}\n        for sq, p in pm.items():\n            if not p:\n                continue\n            if p.piece_type in vals:\n                nonpawn_material += vals[p.piece_type]\n            if p.piece_type == chess.KING:\n                kings[p.color] = sq\n        endgame_scale = 1.0 if nonpawn_material <= 6.0 else max(0.0, 1.0 - (nonpawn_material - 6.0) / 20.0)\n        center_sqs = [chess.parse_square(n) for n in ('d4','e4','d5','e5')]\n        def center_score(color):\n            ksq = kings.get(color)\n            if ksq is None:\n                return 0.0\n            d = min(chess.square_distance(ksq, cs) for cs in center_sqs)\n            centralization = (6.0 - float(d)) / 6.0\n            return centralization * endgame_scale\n        return float(center_score(chess.WHITE) - center_score(chess.BLACK))\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Minor-piece mutual defense count: number of minor pieces defended by another minor (white - black)'\n    try:\n        pm = board.piece_map()\n        score = {chess.WHITE:0.0, chess.BLACK:0.0}\n        for sq, p in pm.items():\n            if not p or p.piece_type not in (chess.KNIGHT, chess.BISHOP):\n                continue\n            color = p.color\n            try:\n                defenders = board.attackers(color, sq)\n            except Exception:\n                defenders = set()\n            # count whether any defender is a minor piece (not pawns/king/rooks/queens)\n            defended_by_minor = False\n            for d in defenders:\n                pd = pm.get(d)\n                if pd and pd.color == color and pd.piece_type in (chess.KNIGHT, chess.BISHOP):\n                    defended_by_minor = True\n                    break\n            if defended_by_minor:\n                score[color] += 1.0\n        return float(score[chess.WHITE] - score[chess.BLACK])\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Immediate capture swing (static): best single-capture material gain estimate (white - black)'\n    try:\n        pm = board.piece_map()\n        vals = {chess.PAWN:1.0, chess.KNIGHT:3.0, chess.BISHOP:3.0, chess.ROOK:5.0, chess.QUEEN:9.0, chess.KING:0.0}\n        best_gain = {chess.WHITE:-999.0, chess.BLACK:-999.0}\n        for color in (chess.WHITE, chess.BLACK):\n            opp = chess.BLACK if color == chess.WHITE else chess.WHITE\n            best = -999.0\n            for sq, p in pm.items():\n                if not p or p.color != opp:\n                    continue\n                captured_value = vals.get(p.piece_type, 0.0)\n                try:\n                    attackers = board.attackers(color, sq)\n                except Exception:\n                    attackers = set()\n                if not attackers:\n                    continue\n                # choose weakest attacker (least value) as likely to initiate capture\n                min_attacker_value = min((vals.get(pm.get(a).piece_type, 0.0) for a in attackers if pm.get(a)), default=0.0)\n                gain = captured_value - min_attacker_value\n                if gain > best:\n                    best = gain\n            best_gain[color] = best if best != -999.0 else 0.0\n        return float(best_gain[chess.WHITE] - best_gain[chess.BLACK])\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Space control in opponent half: empty squares attacked in opponent half (white - black)'\n    try:\n        pm = board.piece_map()\n        space = {chess.WHITE:0.0, chess.BLACK:0.0}\n        for color in (chess.WHITE, chess.BLACK):\n            for sq in range(64):\n                r = chess.square_rank(sq)\n                # opponent half definition\n                if color == chess.WHITE:\n                    if r < 4:\n                        continue\n                else:\n                    if r > 3:\n                        continue\n                if board.piece_at(sq) is not None:\n                    continue\n                try:\n                    if board.is_attacked_by(color, sq):\n                        space[color] += 1.0\n                except Exception:\n                    continue\n        return float(space[chess.WHITE] - space[chess.BLACK])\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Number of sliding pieces with unobstructed line to any square adjacent to the enemy king (white - black)'\n    try:\n        pm = board.piece_map()\n        def sign(x):\n            return (x > 0) - (x < 0)\n        def sliding_score(color):\n            score = 0.0\n            opp = chess.BLACK if color == chess.WHITE else chess.WHITE\n            king_sq = next((sq for sq,p in pm.items() if p and p.piece_type == chess.KING and p.color == opp), None)\n            if king_sq is None:\n                return 0.0\n            kf = chess.square_file(king_sq); kr = chess.square_rank(king_sq)\n            king_vicinity = []\n            for df in (-1, 0, 1):\n                for dr in (-1, 0, 1):\n                    nf = kf + df; nr = kr + dr\n                    if 0 <= nf < 8 and 0 <= nr < 8:\n                        king_vicinity.append(chess.square(nf, nr))\n            for sq, p in pm.items():\n                if not p or p.color != color or p.piece_type not in (chess.BISHOP, chess.ROOK, chess.QUEEN):\n                    continue\n                sf = chess.square_file(sq); sr = chess.square_rank(sq)\n                for target in king_vicinity:\n                    tf = chess.square_file(target); tr = chess.square_rank(target)\n                    dx = tf - sf; dy = tr - sr\n                    sx = sign(dx); sy = sign(dy)\n                    # determine if piece can move along that vector\n                    if p.piece_type == chess.ROOK and not (dx == 0 or dy == 0):\n                        continue\n                    if p.piece_type == chess.BISHOP and not (abs(dx) == abs(dy) and dx != 0):\n                        continue\n                    if p.piece_type == chess.QUEEN and not (dx == 0 or dy == 0 or abs(dx) == abs(dy)):\n                        continue\n                    step_f, step_r = sx, sy\n                    if step_f == 0 and step_r == 0:\n                        continue\n                    # step from piece towards target and ensure intermediate squares empty\n                    blocked = False\n                    cf = sf + step_f; cr = sr + step_r\n                    while (cf, cr) != (tf, tr):\n                        if not (0 <= cf < 8 and 0 <= cr < 8):\n                            blocked = True; break\n                        if board.piece_at(chess.square(cf, cr)) is not None:\n                            blocked = True; break\n                        cf += step_f; cr += step_r\n                    if not blocked:\n                        score += 1.0\n                        break  # count each piece once\n            return score\n        return float(sliding_score(chess.WHITE) - sliding_score(chess.BLACK))\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Low-mobility bishops (<=2 legal moves) count (white - black); indicates bad bishops constrained by pawns'\n    try:\n        pm = board.piece_map()\n        orig = board.turn\n        try:\n            score = {chess.WHITE:0.0, chess.BLACK:0.0}\n            for color in (chess.WHITE, chess.BLACK):\n                board.turn = color\n                # count legal moves per bishop square\n                bishop_moves = {}\n                for mv in board.legal_moves:\n                    p = board.piece_at(mv.from_square)\n                    if p and p.piece_type == chess.BISHOP and p.color == color:\n                        bishop_moves[mv.from_square] = bishop_moves.get(mv.from_square, 0) + 1\n                for sq, p in pm.items():\n                    if p and p.piece_type == chess.BISHOP and p.color == color:\n                        moves = bishop_moves.get(sq, 0)\n                        if moves <= 2:\n                            score[color] += 1.0\n            return float(score[chess.WHITE] - score[chess.BLACK])\n        finally:\n            board.turn = orig\n    except Exception:\n        return 0.0\n",
    "def feature(board: chess.Board) -> float:\n    'Pawn island difference: (black_islands - white_islands), fewer pawn islands is better'\n    try:\n        pm = board.piece_map()\n        def pawn_islands(color):\n            files_has = [False]*8\n            for sq,p in pm.items():\n                if p and p.piece_type == chess.PAWN and p.color == color:\n                    f = chess.square_file(sq)\n                    files_has[f] = True\n            islands = 0\n            i = 0\n            while i < 8:\n                if files_has[i]:\n                    islands += 1\n                    while i < 8 and files_has[i]:\n                        i += 1\n                else:\n                    i += 1\n            return islands\n        w = pawn_islands(chess.WHITE)\n        b = pawn_islands(chess.BLACK)\n        result = float(b - w)\n        return result\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Rook on open/semi-open file score (white - black): open=1.0, semi-open=0.5'\n    try:\n        pm = board.piece_map()\n        # Precompute pawns per file\n        pawns_on_file = {f: {'w':0, 'b':0} for f in range(8)}\n        for sq,p in pm.items():\n            if not p: continue\n            if p.piece_type == chess.PAWN:\n                f = chess.square_file(sq)\n                pawns_on_file[f]['w' if p.color == chess.WHITE else 'b'] += 1\n        def rook_score_for_color(color):\n            score = 0.0\n            for sq,p in pm.items():\n                if not p or p.piece_type != chess.ROOK or p.color != color:\n                    continue\n                f = chess.square_file(sq)\n                total_pawns = pawns_on_file[f]['w'] + pawns_on_file[f]['b']\n                friendly_pawns = pawns_on_file[f]['w'] if color == chess.WHITE else pawns_on_file[f]['b']\n                if total_pawns == 0:\n                    score += 1.0\n                elif friendly_pawns == 0:\n                    score += 0.5\n            return score\n        w = rook_score_for_color(chess.WHITE)\n        b = rook_score_for_color(chess.BLACK)\n        return float(w - b)\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Knights on outposts: knights supported by a pawn and not easily attacked by enemy pawns (white - black)'\n    try:\n        pm = board.piece_map()\n        def is_supported_by_pawn(sq, color):\n            f = chess.square_file(sq); r = chess.square_rank(sq)\n            if color == chess.WHITE:\n                candidates = []\n                for df in (-1, 1):\n                    ff = f + df; rr = r - 1\n                    if 0 <= ff < 8 and 0 <= rr < 8:\n                        candidates.append(chess.square(ff, rr))\n                return any(pm.get(c) and pm.get(c).piece_type == chess.PAWN and pm.get(c).color == color for c in candidates)\n            else:\n                candidates = []\n                for df in (-1, 1):\n                    ff = f + df; rr = r + 1\n                    if 0 <= ff < 8 and 0 <= rr < 8:\n                        candidates.append(chess.square(ff, rr))\n                return any(pm.get(c) and pm.get(c).piece_type == chess.PAWN and pm.get(c).color == color for c in candidates)\n        def is_threatened_by_enemy_pawn(sq, color):\n            f = chess.square_file(sq); r = chess.square_rank(sq)\n            opp = chess.BLACK if color == chess.WHITE else chess.WHITE\n            if opp == chess.BLACK:\n                # black pawns attack downwards: they attack (f-1, r-1) and (f+1, r-1)\n                for df in (-1,1):\n                    ff = f + df; rr = r - 1\n                    if 0 <= ff < 8 and 0 <= rr < 8:\n                        s = chess.square(ff, rr)\n                        p = pm.get(s)\n                        if p and p.piece_type == chess.PAWN and p.color == opp:\n                            return True\n                return False\n            else:\n                for df in (-1,1):\n                    ff = f + df; rr = r + 1\n                    if 0 <= ff < 8 and 0 <= rr < 8:\n                        s = chess.square(ff, rr)\n                        p = pm.get(s)\n                        if p and p.piece_type == chess.PAWN and p.color == opp:\n                            return True\n                return False\n        w_out = 0.0; b_out = 0.0\n        for sq,p in pm.items():\n            if not p or p.piece_type != chess.KNIGHT:\n                continue\n            color = p.color\n            r = chess.square_rank(sq)\n            advanced = (color == chess.WHITE and r >= 4) or (color == chess.BLACK and r <= 3)\n            if not advanced:\n                continue\n            if is_supported_by_pawn(sq, color) and not is_threatened_by_enemy_pawn(sq, color):\n                if color == chess.WHITE:\n                    w_out += 1.0\n                else:\n                    b_out += 1.0\n        return float(w_out - b_out)\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'King centralization weighted for endgame: endgame_factor * (white_center - black_center)'\n    try:\n        pm = board.piece_map()\n        # count non-pawn non-king pieces to gauge endgame\n        non_pawn_pieces = 0\n        for p in pm.values():\n            if p and p.piece_type not in (chess.PAWN, chess.KING):\n                non_pawn_pieces += 1\n        # continuous endgame factor: 1 when few pieces, 0 when many\n        endgame_factor = max(0.0, 1.0 - (non_pawn_pieces / 8.0))\n        # find kings\n        wk = next((sq for sq,p in pm.items() if p and p.piece_type == chess.KING and p.color == chess.WHITE), None)\n        bk = next((sq for sq,p in pm.items() if p and p.piece_type == chess.KING and p.color == chess.BLACK), None)\n        if wk is None or bk is None:\n            return 0.0\n        central_squares = [chess.square(f,r) for f in (3,4) for r in (3,4)]\n        def centrality(sq):\n            # closeness in manhattan sense normalized 0..1 (1 is in center)\n            d = min(chess.square_distance(sq, csq) for csq in central_squares)\n            return float(max(0.0, (7 - d) / 7.0))\n        wc = centrality(wk)\n        bc = centrality(bk)\n        result = float(endgame_factor * (wc - bc))\n        return result\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Queen exposure: (black_exposure - white_exposure) where exposure = max(0, attackers - defenders)'\n    try:\n        vals = {chess.QUEEN:9.0}\n        pm = board.piece_map()\n        def exposure_for_color(color):\n            total = 0.0\n            for sq,p in pm.items():\n                if not p or p.piece_type != chess.QUEEN or p.color != color:\n                    continue\n                opp = chess.BLACK if color == chess.WHITE else chess.WHITE\n                attackers = len(board.attackers(opp, sq))\n                defenders = len(board.attackers(color, sq))\n                diff = max(0, attackers - defenders)\n                total += diff * vals.get(chess.QUEEN, 9.0)\n            return total\n        exp_w = exposure_for_color(chess.WHITE)\n        exp_b = exposure_for_color(chess.BLACK)\n        # positive if white benefits (i.e., black more exposed)\n        return float(exp_b - exp_w)\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Average advancedness of non-pawn pieces (white - black) normalized 0..1 (higher means more advanced)'\n    try:\n        pm = board.piece_map()\n        def avg_advancedness(color):\n            total = 0.0\n            count = 0\n            for sq,p in pm.items():\n                if not p or p.piece_type == chess.PAWN or p.piece_type == chess.KING:\n                    continue\n                if p.color != color:\n                    continue\n                r = chess.square_rank(sq)\n                if color == chess.WHITE:\n                    norm = float(r) / 7.0\n                else:\n                    norm = float(7 - r) / 7.0\n                total += norm\n                count += 1\n            return (total / count) if count > 0 else 0.0\n        w = avg_advancedness(chess.WHITE)\n        b = avg_advancedness(chess.BLACK)\n        return float(w - b)\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Legal capture move imbalance: number of capture moves available (white - black)'\n    try:\n        orig = board.turn\n        try:\n            captures = {chess.WHITE:0, chess.BLACK:0}\n            for color in (chess.WHITE, chess.BLACK):\n                board.turn = color\n                cnt = 0\n                for mv in board.legal_moves:\n                    # Count as capture if destination occupied\n                    if board.piece_at(mv.to_square) is not None:\n                        cnt += 1\n                    else:\n                        # crude en-passant detection: pawn move into empty square where behind square has enemy pawn\n                        p = board.piece_at(mv.from_square)\n                        if p and p.piece_type == chess.PAWN:\n                            from_r = chess.square_rank(mv.from_square)\n                            to_r = chess.square_rank(mv.to_square)\n                            if abs(to_r - from_r) == 1 and board.piece_at(mv.to_square) is None:\n                                # possible en-passant; check adjacent enemy pawn\n                                ff = chess.square_file(mv.to_square)\n                                rr = from_r\n                                for df in (-1,1):\n                                    af = ff + df\n                                    if 0 <= af < 8:\n                                        a_sq = chess.square(af, rr)\n                                        ap = board.piece_at(a_sq)\n                                        if ap and ap.piece_type == chess.PAWN and ap.color != color:\n                                            cnt += 1\n                                            break\n                captures[color] = cnt\n            captures_w = captures[chess.WHITE]\n            captures_b = captures[chess.BLACK]\n            total = max(1.0, captures_w + captures_b)\n            return float((captures_w - captures_b) / total)\n        finally:\n            board.turn = orig\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Nearest passed pawn urgency: closeness to promotion for nearest passed pawn (white - black)'\n    try:\n        pm = board.piece_map()\n        def is_passed(sq, color):\n            f = chess.square_file(sq); r = chess.square_rank(sq)\n            if color == chess.WHITE:\n                for af in (f-1, f, f+1):\n                    if 0 <= af <= 7:\n                        for ar in range(r+1, 8):\n                            a_sq = ar*8 + af\n                            p = pm.get(a_sq)\n                            if p and p.piece_type == chess.PAWN and p.color == chess.BLACK:\n                                return False\n                return True\n            else:\n                for af in (f-1, f, f+1):\n                    if 0 <= af <= 7:\n                        for ar in range(0, r):\n                            a_sq = ar*8 + af\n                            p = pm.get(a_sq)\n                            if p and p.piece_type == chess.PAWN and p.color == chess.WHITE:\n                                return False\n                return True\n        min_dist = {chess.WHITE:9, chess.BLACK:9}\n        for sq,p in pm.items():\n            if not p or p.piece_type != chess.PAWN:\n                continue\n            if not is_passed(sq, p.color):\n                continue\n            r = chess.square_rank(sq)\n            if p.color == chess.WHITE:\n                dist = 7 - r\n            else:\n                dist = r\n            if dist < min_dist[p.color]:\n                min_dist[p.color] = dist\n        def urgency(dist):\n            if dist > 7:\n                return 0.0\n            return float((8 - dist) / 8.0)  # closer -> larger\n        u_w = urgency(min_dist[chess.WHITE])\n        u_b = urgency(min_dist[chess.BLACK])\n        return float(u_w - u_b)\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Backward pawn vulnerability: weighted count of backward/under-defended pawns (black_vuln - white_vuln), positive favors White'\n    try:\n        pm = board.piece_map()\n        def pawn_vulnerable(color):\n            vuln = 0.0\n            for sq,p in pm.items():\n                if not p or p.piece_type != chess.PAWN or p.color != color:\n                    continue\n                f = chess.square_file(sq); r = chess.square_rank(sq)\n                # check for friendly pawn on adjacent files ahead (makes pawn not backward)\n                has_supporting_adjacent = False\n                if color == chess.WHITE:\n                    # friendly pawn on f-1 or f+1 with rank > r\n                    for af in (f-1, f+1):\n                        if 0 <= af < 8:\n                            for ar in range(r+1, 8):\n                                s2 = ar*8 + af\n                                p2 = pm.get(s2)\n                                if p2 and p2.piece_type == chess.PAWN and p2.color == color:\n                                    has_supporting_adjacent = True\n                                    break\n                            if has_supporting_adjacent:\n                                break\n                else:\n                    for af in (f-1, f+1):\n                        if 0 <= af < 8:\n                            for ar in range(0, r):\n                                s2 = ar*8 + af\n                                p2 = pm.get(s2)\n                                if p2 and p2.piece_type == chess.PAWN and p2.color == color:\n                                    has_supporting_adjacent = True\n                                    break\n                            if has_supporting_adjacent:\n                                break\n                if has_supporting_adjacent:\n                    continue\n                # check attackers vs defenders on the pawn square\n                opp = chess.BLACK if color == chess.WHITE else chess.WHITE\n                attackers = len(board.attackers(opp, sq))\n                defenders = len(board.attackers(color, sq))\n                if attackers > defenders:\n                    # weight by how many attackers exceed defenders\n                    vuln += float(attackers - defenders)\n            return vuln\n        w_v = pawn_vulnerable(chess.WHITE)\n        b_v = pawn_vulnerable(chess.BLACK)\n        # positive if White benefits (i.e., black more vulnerable)\n        return float(b_v - w_v)\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Rooks on opponent seventh rank advantage (white - black), counts rooks on 7th rank'\n    try:\n        pm = board.piece_map()\n        w_cnt = 0.0; b_cnt = 0.0\n        for sq,p in pm.items():\n            if not p or p.piece_type != chess.ROOK:\n                continue\n            r = chess.square_rank(sq)\n            if p.color == chess.WHITE and r == 6:\n                w_cnt += 1.0\n            if p.color == chess.BLACK and r == 1:\n                b_cnt += 1.0\n        return float(w_cnt - b_cnt)\n    except Exception:\n        return 0.0\n",
    "def feature(board: chess.Board) -> float:\n    'Pawn island imbalance: (black_islands - white_islands) positive favors White when Black has more pawn islands (weaker structure)'\n    try:\n        pm = board.piece_map()\n        def pawn_islands(color):\n            files = [False] * 8\n            for sq, p in pm.items():\n                if p and p.piece_type == chess.PAWN and p.color == color:\n                    f = chess.square_file(sq)\n                    files[f] = True\n            islands = 0\n            prev = False\n            for present in files:\n                if present and not prev:\n                    islands += 1\n                prev = present\n            return islands\n        w_is = pawn_islands(chess.WHITE)\n        b_is = pawn_islands(chess.BLACK)\n        return float(b_is - w_is)\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Passed pawn progress: sum of normalized advancement of passed pawns (white - black)'\n    try:\n        pm = board.piece_map()\n        def is_passed(sq, color):\n            f = chess.square_file(sq)\n            r = chess.square_rank(sq)\n            enemy = chess.BLACK if color == chess.WHITE else chess.WHITE\n            for af in (f-1, f, f+1):\n                if af < 0 or af > 7:\n                    continue\n                for ar in range(8):\n                    psq = chess.square(af, ar)\n                    pp = pm.get(psq)\n                    if not pp or pp.piece_type != chess.PAWN or pp.color != enemy:\n                        continue\n                    # for white, any enemy pawn ahead (higher rank) on same/adj files blocks\n                    if color == chess.WHITE and ar > r:\n                        return False\n                    # for black, any enemy pawn ahead (lower rank) on same/adj files blocks\n                    if color == chess.BLACK and ar < r:\n                        return False\n            return True\n        w_score = 0.0; b_score = 0.0\n        for sq, p in pm.items():\n            if not p or p.piece_type != chess.PAWN:\n                continue\n            r = chess.square_rank(sq)\n            if is_passed(sq, p.color):\n                if p.color == chess.WHITE:\n                    # advancement: 0..1\n                    adv = r / 7.0\n                    w_score += adv + 0.2  # small base bonus for being passed\n                else:\n                    adv = (7 - r) / 7.0\n                    b_score += adv + 0.2\n        return float(w_score - b_score)\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Rook file control and 7th-rank pressure: weighted sum of open/semi-open file control and presence on opponent 7th (white - black)'\n    try:\n        pm = board.piece_map()\n        # precompute pawns per file\n        file_pawns = {f: {chess.WHITE:0, chess.BLACK:0} for f in range(8)}\n        for sq, p in pm.items():\n            if p and p.piece_type == chess.PAWN:\n                file_pawns[chess.square_file(sq)][p.color] += 1\n        w_score = 0.0; b_score = 0.0\n        for sq, p in pm.items():\n            if not p or p.piece_type != chess.ROOK:\n                continue\n            f = chess.square_file(sq)\n            r = chess.square_rank(sq)\n            pawns_on_file = file_pawns[f][chess.WHITE] + file_pawns[f][chess.BLACK]\n            if pawns_on_file == 0:\n                val = 1.0\n            elif file_pawns[f][p.color] == 0:\n                val = 0.6\n            else:\n                val = 0.0\n            # 7th rank pressure: for white a rook on rank 6 (7th), for black rank 1\n            if p.color == chess.WHITE and r == 6:\n                val += 0.9\n            if p.color == chess.BLACK and r == 1:\n                val += 0.9\n            if p.color == chess.WHITE:\n                w_score += val\n            else:\n                b_score += val\n        return float(w_score - b_score)\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Bishop pair and mobility: bonus for having two bishops plus mobility measured by legal bishop moves (white - black)'\n    try:\n        pm = board.piece_map()\n        orig = board.turn\n        try:\n            scores = {chess.WHITE:0.0, chess.BLACK:0.0}\n            for color in (chess.WHITE, chess.BLACK):\n                bishops = [sq for sq,p in pm.items() if p and p.piece_type == chess.BISHOP and p.color == color]\n                pair_bonus = 0.5 if len(bishops) >= 2 else 0.0\n                mobility = 0\n                board.turn = color\n                moves = list(board.legal_moves)\n                for mv in moves:\n                    p = board.piece_at(mv.from_square)\n                    if p and p.piece_type == chess.BISHOP and p.color == color:\n                        mobility += 1\n                scores[color] = pair_bonus + 0.12 * float(mobility)\n        finally:\n            board.turn = orig\n        return float(scores[chess.WHITE] - scores[chess.BLACK])\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Queen exposure: difference of (enemy attackers - defenders) at the queen square; positive favors White when Black queen is more exposed'\n    try:\n        pm = board.piece_map()\n        def exposure_for(color):\n            qsq = next((sq for sq,p in pm.items() if p and p.piece_type == chess.QUEEN and p.color == color), None)\n            if qsq is None:\n                return 0.0\n            enemy = chess.BLACK if color == chess.WHITE else chess.WHITE\n            attackers = len(board.attackers(enemy, qsq))\n            defenders = len(board.attackers(color, qsq))\n            return max(0, attackers - defenders)\n        w_exp = exposure_for(chess.WHITE)\n        b_exp = exposure_for(chess.BLACK)\n        # higher value means enemy queen more exposed => favors side (we return black - white so positive favors White)\n        return float(b_exp - w_exp)\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Trapped minor pieces on the rim: count of knights/bishops on edge with very low legal mobility (black - white)'\n    try:\n        pm = board.piece_map()\n        orig = board.turn\n        try:\n            trapped = {chess.WHITE:0.0, chess.BLACK:0.0}\n            for color in (chess.WHITE, chess.BLACK):\n                board.turn = color\n                moves = list(board.legal_moves)\n                # map from from_square to number of legal moves for that piece\n                move_count = {}\n                for mv in moves:\n                    move_count[mv.from_square] = move_count.get(mv.from_square, 0) + 1\n                for sq, p in pm.items():\n                    if not p or p.color != color or p.piece_type not in (chess.KNIGHT, chess.BISHOP):\n                        continue\n                    f = chess.square_file(sq); r = chess.square_rank(sq)\n                    on_rim = (f == 0 or f == 7 or r == 0 or r == 7)\n                    if not on_rim:\n                        continue\n                    cnt = move_count.get(sq, 0)\n                    if cnt <= 2:\n                        trapped[color] += 1.0\n            return float(trapped[chess.BLACK] - trapped[chess.WHITE])\n        finally:\n            board.turn = orig\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'King support for passed pawns: how well kings are positioned to assist their passed pawns (white - black)'\n    try:\n        pm = board.piece_map()\n        # find kings\n        wk = next((sq for sq,p in pm.items() if p and p.piece_type == chess.KING and p.color == chess.WHITE), None)\n        bk = next((sq for sq,p in pm.items() if p and p.piece_type == chess.KING and p.color == chess.BLACK), None)\n        if wk is None or bk is None:\n            return 0.0\n        def is_passed(sq, color):\n            f = chess.square_file(sq)\n            r = chess.square_rank(sq)\n            enemy = chess.BLACK if color == chess.WHITE else chess.WHITE\n            for af in (f-1, f, f+1):\n                if af < 0 or af > 7:\n                    continue\n                for ar in range(8):\n                    psq = chess.square(af, ar)\n                    pp = pm.get(psq)\n                    if not pp or pp.piece_type != chess.PAWN or pp.color != enemy:\n                        continue\n                    if color == chess.WHITE and ar > r:\n                        return False\n                    if color == chess.BLACK and ar < r:\n                        return False\n            return True\n        w_support = 0.0; b_support = 0.0\n        for sq, p in pm.items():\n            if not p or p.piece_type != chess.PAWN:\n                continue\n            if not is_passed(sq, p.color):\n                continue\n            r = chess.square_rank(sq)\n            if p.color == chess.WHITE:\n                dist = chess.square_distance(wk, sq)\n                adv = r / 7.0\n                w_support += (14.0 - dist) / 14.0 * (0.8 + 0.7 * adv)\n            else:\n                dist = chess.square_distance(bk, sq)\n                adv = (7 - r) / 7.0\n                b_support += (14.0 - dist) / 14.0 * (0.8 + 0.7 * adv)\n        return float(w_support - b_support)\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Non-pawn piece presence in opponent half: weighted piece-value sum of pieces advanced into enemy territory (white - black)'\n    try:\n        vals = {chess.KNIGHT:3.0, chess.BISHOP:3.0, chess.ROOK:5.0, chess.QUEEN:9.0}\n        pm = board.piece_map()\n        w_score = 0.0; b_score = 0.0\n        for sq, p in pm.items():\n            if not p or p.piece_type == chess.PAWN or p.piece_type == chess.KING:\n                continue\n            r = chess.square_rank(sq)\n            if p.color == chess.WHITE:\n                if r >= 4:\n                    w_score += vals.get(p.piece_type, 0.0)\n            else:\n                if r <= 3:\n                    b_score += vals.get(p.piece_type, 0.0)\n        # normalize by a typical maximum (e.g., two rooks + queen + two minors = ~25)\n        denom = 1.0\n        return float((w_score - b_score) / max(1.0, 25.0))\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Tactical opportunity index: weighted count of capture/promotional/checking moves available (white - black)'\n    try:\n        orig = board.turn\n        try:\n            scores = {chess.WHITE:0.0, chess.BLACK:0.0}\n            for color in (chess.WHITE, chess.BLACK):\n                board.turn = color\n                moves = list(board.legal_moves)\n                captures = 0\n                promotions = 0\n                checks = 0\n                for mv in moves:\n                    # capture detection (simple heuristic; may miss en-passant)\n                    target = board.piece_at(mv.to_square)\n                    if target and target.color != color:\n                        captures += 1\n                    if getattr(mv, 'promotion', None):\n                        promotions += 1\n                    # detect whether move gives check by pushing and testing\n                    try:\n                        board.push(mv)\n                        if board.is_check():\n                            checks += 1\n                        board.pop()\n                    except Exception:\n                        # if push/pop fails for some reason, ignore\n                        try:\n                            board.pop()\n                        except Exception:\n                            pass\n                # weights: captures 1.0, promotions 1.6, checks 0.8\n                scores[color] = float(captures) * 1.0 + float(promotions) * 1.6 + float(checks) * 0.8\n            # normalize by some typical tactical ceiling\n            return float((scores[chess.WHITE] - scores[chess.BLACK]) / max(1.0, (scores[chess.WHITE] + scores[chess.BLACK])))\n        finally:\n            board.turn = orig\n    except Exception:\n        return 0.0\n",
    "def feature(board: chess.Board) -> float:\n    'Central control: weighted sum of attackers of central squares (d4,e4,d5,e5,c4,f4,c5,f5) (white - black)'\n    try:\n        pm = board.piece_map()\n        central_names = ['d4','e4','d5','e5','c4','f4','c5','f5']\n        central = [chess.parse_square(n) for n in central_names]\n        vals = {chess.PAWN:1.0, chess.KNIGHT:3.0, chess.BISHOP:3.0, chess.ROOK:5.0, chess.QUEEN:9.0, chess.KING:0.0}\n        score = {chess.WHITE:0.0, chess.BLACK:0.0}\n        for sq in central:\n            for color in (chess.WHITE, chess.BLACK):\n                attackers = board.attackers(color, sq)\n                for a in attackers:\n                    p = pm.get(a)\n                    if p:\n                        score[color] += vals.get(p.piece_type, 0.0)\n        total = max(1.0, score[chess.WHITE] + score[chess.BLACK])\n        return float((score[chess.WHITE] - score[chess.BLACK]) / total)\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Rook activity: bonus for rooks on open/semi-open files and rooks on opponent 7th rank (white - black)'\n    try:\n        pm = board.piece_map()\n        def file_has_pawn(f):\n            for r in range(8):\n                p = pm.get(chess.square(f, r))\n                if p and p.piece_type == chess.PAWN:\n                    return True\n            return False\n        score = {chess.WHITE:0.0, chess.BLACK:0.0}\n        for sq,p in list(pm.items()):\n            if not p or p.piece_type != chess.ROOK:\n                continue\n            f = chess.square_file(sq); r = chess.square_rank(sq)\n            open_file = not file_has_pawn(f)\n            semi_open = True\n            for rr in range(8):\n                pp = pm.get(chess.square(f, rr))\n                if pp and pp.piece_type == chess.PAWN and pp.color == p.color:\n                    semi_open = False\n                    break\n            val = 0.0\n            if open_file:\n                val += 1.0\n            elif semi_open:\n                val += 0.6\n            # rook on opponent 7th rank\n            if p.color == chess.WHITE and r == 6:\n                val += 1.2\n            if p.color == chess.BLACK and r == 1:\n                val += 1.2\n            score[p.color] += val\n        return float(score[chess.WHITE] - score[chess.BLACK])\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Bishop pair and mobility: bishop-pair bonus plus normalized bishop mobility (white - black)'\n    try:\n        pm = board.piece_map()\n        def bishop_mobility(sq):\n            # slide on 4 diagonals until blocked; count empty squares + first capture square\n            dirs = [(1,1),(1,-1),(-1,1),(-1,-1)]\n            cnt = 0\n            f0 = chess.square_file(sq); r0 = chess.square_rank(sq)\n            for df,dr in dirs:\n                f = f0 + df; r = r0 + dr\n                while 0 <= f < 8 and 0 <= r < 8:\n                    s = chess.square(f, r)\n                    p = pm.get(s)\n                    cnt += 1\n                    if p is not None:\n                        break\n                    f += df; r += dr\n            return cnt\n        score = {chess.WHITE:0.0, chess.BLACK:0.0}\n        bishops_count = {chess.WHITE:0, chess.BLACK:0}\n        for sq,p in pm.items():\n            if not p or p.piece_type != chess.BISHOP:\n                continue\n            bishops_count[p.color] += 1\n            score[p.color] += 0.12 * bishop_mobility(sq)  # small mobility contribution\n        for color in (chess.WHITE, chess.BLACK):\n            if bishops_count[color] >= 2:\n                score[color] += 0.6\n        return float(score[chess.WHITE] - score[chess.BLACK])\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'King mobility: number of legal king moves available (white - black), normalized'\n    try:\n        pm = board.piece_map()\n        wk = next((sq for sq,p in pm.items() if p and p.piece_type==chess.KING and p.color==chess.WHITE), None)\n        bk = next((sq for sq,p in pm.items() if p and p.piece_type==chess.KING and p.color==chess.BLACK), None)\n        if wk is None or bk is None:\n            return 0.0\n        orig = board.turn\n        try:\n            km = {chess.WHITE:0.0, chess.BLACK:0.0}\n            for color, king_sq in ((chess.WHITE,wk),(chess.BLACK,bk)):\n                board.turn = color\n                for mv in board.legal_moves:\n                    if mv.from_square == king_sq:\n                        km[color] += 1.0\n            # max king moves is 8\n            return float((km[chess.WHITE] - km[chess.BLACK]) / 8.0)\n        finally:\n            board.turn = orig\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Hanging pieces: weighted count of undefended pieces attacked by opponent (black_hanging - white_hanging)'\n    try:\n        pm = board.piece_map()\n        vals = {chess.PAWN:1.0, chess.KNIGHT:3.0, chess.BISHOP:3.0, chess.ROOK:5.0, chess.QUEEN:9.0, chess.KING:0.0}\n        hanging = {chess.WHITE:0.0, chess.BLACK:0.0}\n        for sq, p in pm.items():\n            if not p:\n                continue\n            opp = chess.BLACK if p.color == chess.WHITE else chess.WHITE\n            # attacked by opponent?\n            if board.is_attacked_by(opp, sq):\n                # defended by own?\n                if not board.is_attacked_by(p.color, sq):\n                    hanging[p.color] += vals.get(p.piece_type, 0.0)\n        # positive favors White if Black has more hanging material\n        return float(hanging[chess.BLACK] - hanging[chess.WHITE])\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Pawn islands imbalance: (black pawn islands - white pawn islands) (positive favors White)'\n    try:\n        pm = board.piece_map()\n        files_with = {chess.WHITE:set(), chess.BLACK:set()}\n        for sq,p in pm.items():\n            if p and p.piece_type == chess.PAWN:\n                files_with[p.color].add(chess.square_file(sq))\n        def islands(fileset):\n            if not fileset:\n                return 0\n            cnt = 0\n            prev = -10\n            for f in sorted(fileset):\n                if f != prev + 1:\n                    cnt += 1\n                prev = f\n            return cnt\n        white_is = islands(files_with[chess.WHITE])\n        black_is = islands(files_with[chess.BLACK])\n        return float(black_is - white_is)\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Space occupancy: count of pieces (incl. pawns) occupying opponent half (white - black), normalized'\n    try:\n        pm = board.piece_map()\n        occ = {chess.WHITE:0.0, chess.BLACK:0.0}\n        for sq,p in pm.items():\n            if not p:\n                continue\n            r = chess.square_rank(sq)\n            if p.color == chess.WHITE and r >= 4:\n                occ[chess.WHITE] += 1.0\n            if p.color == chess.BLACK and r <= 3:\n                occ[chess.BLACK] += 1.0\n        total = max(1.0, occ[chess.WHITE] + occ[chess.BLACK])\n        return float((occ[chess.WHITE] - occ[chess.BLACK]) / total)\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Queen activity and vulnerability: mobility of queens minus vulnerability penalty (white - black)'\n    try:\n        pm = board.piece_map()\n        vals = {chess.PAWN:1.0, chess.KNIGHT:3.0, chess.BISHOP:3.0, chess.ROOK:5.0, chess.QUEEN:9.0}\n        def queen_mobility_and_vuln(sq, color):\n            # mobility: slide in 8 directions until blocked (count squares)\n            dirs = [(1,0),(-1,0),(0,1),(0,-1),(1,1),(1,-1),(-1,1),(-1,-1)]\n            f0 = chess.square_file(sq); r0 = chess.square_rank(sq)\n            mob = 0\n            for df,dr in dirs:\n                f = f0 + df; r = r0 + dr\n                while 0 <= f < 8 and 0 <= r < 8:\n                    s = chess.square(f, r)\n                    mob += 1\n                    if pm.get(s) is not None:\n                        break\n                    f += df; r += dr\n            vuln = 1.0 if board.is_attacked_by(not color, sq) else 0.0\n            return mob, vuln\n        score = {chess.WHITE:0.0, chess.BLACK:0.0}\n        for sq,p in pm.items():\n            if not p or p.piece_type != chess.QUEEN:\n                continue\n            mob, vuln = queen_mobility_and_vuln(sq, p.color)\n            score[p.color] += 0.08 * mob - 0.9 * vuln\n        return float(score[chess.WHITE] - score[chess.BLACK])\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Pressure on weak pawns: sum of attacker values on undefended pawns (black_pressure - white_pressure)'\n    try:\n        pm = board.piece_map()\n        vals = {chess.PAWN:1.0, chess.KNIGHT:3.0, chess.BISHOP:3.0, chess.ROOK:5.0, chess.QUEEN:9.0}\n        pressure = {chess.WHITE:0.0, chess.BLACK:0.0}\n        pawns = [(sq,p) for sq,p in pm.items() if p and p.piece_type == chess.PAWN]\n        for sq,p in pawns:\n            color = p.color\n            opp = chess.BLACK if color == chess.WHITE else chess.WHITE\n            # attacked by opponent and not defended by own\n            if board.is_attacked_by(opp, sq) and not board.is_attacked_by(color, sq):\n                attackers = board.attackers(opp, sq)\n                for a in attackers:\n                    pa = pm.get(a)\n                    if pa:\n                        pressure[opp] += vals.get(pa.piece_type,0.0)\n        # positive favors White when Black is under more pressure\n        return float(pressure[chess.BLACK] - pressure[chess.WHITE])\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Pinned pieces: count of pinned pieces to king using line detection (black_pinned - white_pinned)'\n    try:\n        pm = board.piece_map()\n        def sign(x):\n            return (x > 0) - (x < 0)\n        pinned = {chess.WHITE:0, chess.BLACK:0}\n        for color in (chess.WHITE, chess.BLACK):\n            king_sq = next((sq for sq,p in pm.items() if p and p.piece_type==chess.KING and p.color==color), None)\n            if king_sq is None:\n                continue\n            kf = chess.square_file(king_sq); kr = chess.square_rank(king_sq)\n            opp = chess.BLACK if color == chess.WHITE else chess.WHITE\n            # iterate opponent sliding pieces\n            for sq,p in pm.items():\n                if not p or p.color != opp or p.piece_type not in (chess.ROOK, chess.BISHOP, chess.QUEEN):\n                    continue\n                af = chess.square_file(sq); ar = chess.square_rank(sq)\n                df = kf - af; dr = kr - ar\n                # aligned?\n                if df == 0:\n                    step = (0, sign(dr))\n                elif dr == 0:\n                    step = (sign(df), 0)\n                elif abs(df) == abs(dr):\n                    step = (sign(df), sign(dr))\n                else:\n                    continue\n                # walk from attacker towards king and count intervening pieces\n                f = af + step[0]; r = ar + step[1]\n                intervening = []\n                blocked = False\n                while 0 <= f < 8 and 0 <= r < 8:\n                    s = chess.square(f, r)\n                    if s == king_sq:\n                        break\n                    if pm.get(s) is not None:\n                        intervening.append((s, pm.get(s)))\n                        # allow more than one but will check count later\n                    f += step[0]; r += step[1]\n                else:\n                    # didn't reach king\n                    continue\n                if len(intervening) == 1:\n                    sqi, p_i = intervening[0]\n                    if p_i.color == color and p_i.piece_type != chess.KING:\n                        # it's pinned\n                        pinned[color] += 1\n        return float(pinned[chess.BLACK] - pinned[chess.WHITE])\n    except Exception:\n        return 0.0\n",
    "def feature(board: chess.Board) -> float:\n    'Castling and pawn-shield advantage: rewards having a castled king and a healthy pawn shield (white - black)'\n    try:\n        pm = board.piece_map()\n        def king_castle_and_shield(color):\n            # find king square\n            king_sq = next((sq for sq,p in pm.items() if p and p.piece_type == chess.KING and p.color == color), None)\n            if king_sq is None:\n                return 0.0\n            f = chess.square_file(king_sq)\n            r = chess.square_rank(king_sq)\n            # simple castled detection: king on g-file or c-file typical castling squares\n            castled = 1.0 if (color == chess.WHITE and (r == 0 and f in (6,2))) or (color == chess.BLACK and (r == 7 and f in (6,2))) else 0.0\n            # pawn shield: count friendly pawns on up-to-two ranks ahead in adjacent files (approx)\n            shield = 0.0\n            dirs = [1,2] if color == chess.WHITE else [-1,-2]\n            for d in dirs:\n                rr = r + d\n                if 0 <= rr < 8:\n                    for ff in (f-1, f, f+1):\n                        if 0 <= ff < 8:\n                            sq = chess.square(ff, rr)\n                            p = pm.get(sq)\n                            if p and p.piece_type == chess.PAWN and p.color == color:\n                                shield += 1.0\n            return castled + 0.25 * shield\n        return float(king_castle_and_shield(chess.WHITE) - king_castle_and_shield(chess.BLACK))\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Rook file dominance: counts rooks on open (no pawns any color) and half-open files (no own pawns) (white - black)'\n    try:\n        pm = board.piece_map()\n        # compute pawns present per file by color\n        pawns_by_file = {f: {chess.WHITE:0, chess.BLACK:0} for f in range(8)}\n        for sq,p in pm.items():\n            if p and p.piece_type == chess.PAWN:\n                pawns_by_file[chess.square_file(sq)][p.color] += 1\n        score = {chess.WHITE:0.0, chess.BLACK:0.0}\n        for sq,p in pm.items():\n            if p and p.piece_type == chess.ROOK:\n                f = chess.square_file(sq)\n                total_pawns = pawns_by_file[f][chess.WHITE] + pawns_by_file[f][chess.BLACK]\n                if total_pawns == 0:\n                    score[p.color] += 1.6  # open file rook is strong\n                elif pawns_by_file[f][p.color] == 0:\n                    score[p.color] += 0.9  # half-open file\n        return float(score[chess.WHITE] - score[chess.BLACK])\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Knight outpost score: counts stable knight outposts (supported and not contestable by enemy pawns) (white - black)'\n    try:\n        pm = board.piece_map()\n        def is_outpost(sq, color):\n            # knights on more advanced ranks are more relevant\n            r = chess.square_rank(sq); f = chess.square_file(sq)\n            if color == chess.WHITE and r < 2:\n                return False\n            if color == chess.BLACK and r > 5:\n                return False\n            # check for enemy pawn presence on same/adjacent files ahead of the knight\n            if color == chess.WHITE:\n                for af in (f-1, f, f+1):\n                    if 0 <= af < 8:\n                        for ar in range(r+1, 8):\n                            sq2 = chess.square(af, ar)\n                            p = pm.get(sq2)\n                            if p and p.piece_type == chess.PAWN and p.color != color:\n                                return False\n            else:\n                for af in (f-1, f, f+1):\n                    if 0 <= af < 8:\n                        for ar in range(r-1, -1, -1):\n                            sq2 = chess.square(af, ar)\n                            p = pm.get(sq2)\n                            if p and p.piece_type == chess.PAWN and p.color != color:\n                                return False\n            # check it is defended by some friendly piece (pawn or piece)\n            defenders = board.attackers(color, sq)\n            return len(defenders) > 0\n        score_w = 0; score_b = 0\n        for sq,p in pm.items():\n            if not p or p.piece_type != chess.KNIGHT:\n                continue\n            if is_outpost(sq, p.color):\n                if p.color == chess.WHITE:\n                    score_w += 1\n                else:\n                    score_b += 1\n        return float(score_w - score_b)\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Bishop mobility minus bad-bishop penalty: favors bishops with long diagonals and penalizes severely blocked bishops (white - black)'\n    try:\n        pm = board.piece_map()\n        def bishop_score(sq, color):\n            # directions for bishop rays\n            dirs = [(1,1),(1,-1),(-1,1),(-1,-1)]\n            mobility = 0\n            f0 = chess.square_file(sq); r0 = chess.square_rank(sq)\n            for df,dr in dirs:\n                ff = f0 + df; rr = r0 + dr\n                while 0 <= ff < 8 and 0 <= rr < 8:\n                    sq2 = chess.square(ff, rr)\n                    p = pm.get(sq2)\n                    if p is None:\n                        mobility += 1\n                    else:\n                        # blocked by any piece, stop ray\n                        break\n                    ff += df; rr += dr\n            # bad-bishop heuristic: low mobility and own pawns blocking many diagonals\n            pawn_block = 0\n            for df,dr in dirs:\n                ff = f0 + df; rr = r0 + dr\n                steps = 0\n                while 0 <= ff < 8 and 0 <= rr < 8 and steps < 3:\n                    p = pm.get(chess.square(ff, rr))\n                    if p and p.piece_type == chess.PAWN and p.color == color:\n                        pawn_block += 1\n                    if p:\n                        break\n                    ff += df; rr += dr; steps += 1\n            bad = 0.0\n            if mobility <= 2:\n                bad += 0.9\n            bad += 0.15 * pawn_block\n            return mobility - bad\n        score = {chess.WHITE:0.0, chess.BLACK:0.0}\n        for sq,p in pm.items():\n            if p and p.piece_type == chess.BISHOP:\n                score[p.color] += bishop_score(sq, p.color)\n        return float(score[chess.WHITE] - score[chess.BLACK])\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Rooks on the seventh rank: rewards rooks placed on the opponent\\'s seventh rank (white - black)'\n    try:\n        pm = board.piece_map()\n        w = 0; b = 0\n        for sq,p in pm.items():\n            if not p or p.piece_type != chess.ROOK:\n                continue\n            r = chess.square_rank(sq)\n            if p.color == chess.WHITE and r == 6:\n                w += 1\n            if p.color == chess.BLACK and r == 1:\n                b += 1\n        return float(w - b)\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Hanging piece severity: material value of pieces that are attacked and have no defenders (black_hang - white_hang), positive favors White'\n    try:\n        vals = {chess.PAWN:1.0, chess.KNIGHT:3.0, chess.BISHOP:3.0, chess.ROOK:5.0, chess.QUEEN:9.0, chess.KING:0.0}\n        pm = board.piece_map()\n        hang = {chess.WHITE:0.0, chess.BLACK:0.0}\n        for sq,p in pm.items():\n            if not p:\n                continue\n            opp = not p.color\n            attackers = board.attackers(opp, sq)\n            if not attackers:\n                continue\n            defenders = board.attackers(p.color, sq)\n            if len(defenders) == 0:\n                # attacked and undefended: hanging\n                hang[p.color] += vals.get(p.piece_type, 0.0)\n        # feature positive when black has more hanging material (i.e., good for White)\n        return float(hang[chess.BLACK] - hang[chess.WHITE])\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Endgame king centralization: rewards placing the king toward the center when material is low (white - black); zero outside endgame'\n    try:\n        pm = board.piece_map()\n        vals = {chess.PAWN:1.0, chess.KNIGHT:3.0, chess.BISHOP:3.0, chess.ROOK:5.0, chess.QUEEN:9.0}\n        nonpawn_material = 0.0\n        for p in pm.values():\n            if p and p.piece_type not in (chess.PAWN, chess.KING):\n                nonpawn_material += vals.get(p.piece_type, 0.0)\n        # threshold for endgame-ish\n        if nonpawn_material > 8.0:\n            return 0.0\n        # center point approx (3.5,3.5)\n        maxdist = ((3.5**2)*2) ** 0.5\n        def king_centrality(color):\n            ksq = next((sq for sq,p in pm.items() if p and p.piece_type == chess.KING and p.color == color), None)\n            if ksq is None:\n                return 0.0\n            fx = chess.square_file(ksq)\n            ry = chess.square_rank(ksq)\n            dx = fx - 3.5\n            dy = ry - 3.5\n            dist = (dx*dx + dy*dy) ** 0.5\n            closeness = 1.0 - (dist / maxdist)\n            return closeness\n        return float(king_centrality(chess.WHITE) - king_centrality(chess.BLACK))\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Pawn structural weaknesses: summed doubled and isolated pawn penalty difference (black_weakness - white_weakness), positive favors White'\n    try:\n        pm = board.piece_map()\n        # counts per file\n        file_counts = {f:{chess.WHITE:0, chess.BLACK:0} for f in range(8)}\n        for sq,p in pm.items():\n            if p and p.piece_type == chess.PAWN:\n                file_counts[chess.square_file(sq)][p.color] += 1\n        def weaknesses(color):\n            doubled = 0\n            isolated = 0\n            for f in range(8):\n                cnt = file_counts[f][color]\n                if cnt > 1:\n                    doubled += (cnt - 1)\n                if cnt > 0:\n                    left = file_counts[f-1][color] if f-1 >= 0 else 0\n                    right = file_counts[f+1][color] if f+1 <= 7 else 0\n                    if left == 0 and right == 0:\n                        isolated += 1\n            # weighed penalty\n            return 0.95 * doubled + 1.15 * isolated\n        w = weaknesses(chess.WHITE)\n        b = weaknesses(chess.BLACK)\n        # positive when Black has worse pawn structure\n        return float(b - w)\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Central control: difference in number of attackers to the four central squares (d4,e4,d5,e5) (white - black)'\n    try:\n        centers = [chess.parse_square(s) for s in ('d4','e4','d5','e5')]\n        w = 0; b = 0\n        for sq in centers:\n            w += len(board.attackers(chess.WHITE, sq))\n            b += len(board.attackers(chess.BLACK, sq))\n        # normalize roughly by 8 to keep magnitude moderate\n        return float((w - b) / 8.0)\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Heavy-piece pressure on king: weighted sum of rook/queen attackers targeting squares around the enemy king (white - black)'\n    try:\n        pm = board.piece_map()\n        vals = {chess.ROOK:4.5, chess.QUEEN:9.0}\n        def pressure_on_king(king_color):\n            # compute pressure by opponent on king of king_color\n            king_sq = next((sq for sq,p in pm.items() if p and p.piece_type == chess.KING and p.color == king_color), None)\n            if king_sq is None:\n                return 0.0\n            opp = not king_color\n            f = chess.square_file(king_sq); r = chess.square_rank(king_sq)\n            total = 0.0\n            # squares in a 2x2 neighborhood (including the king square and immediate neighbors)\n            for ff in range(max(0, f-1), min(7, f+1)+1):\n                for rr in range(max(0, r-1), min(7, r+1)+1):\n                    sq = chess.square(ff, rr)\n                    attackers = board.attackers(opp, sq)\n                    for a in attackers:\n                        pa = pm.get(a)\n                        if pa and pa.piece_type in vals:\n                            total += vals[pa.piece_type]\n            return total\n        # pressure on black king by white minus pressure on white king by black\n        return float(pressure_on_king(chess.BLACK) - pressure_on_king(chess.WHITE))\n    except Exception:\n        return 0.0\n",
    "def feature(board: chess.Board) -> float:\n    'Net value of undefended (hanging) pieces that are attacked by the opponent (white - black)'\n    try:\n        vals = {chess.PAWN:1.0, chess.KNIGHT:3.0, chess.BISHOP:3.0, chess.ROOK:5.0, chess.QUEEN:9.0, chess.KING:0.0}\n        pm = board.piece_map()\n        hanging = {chess.WHITE:0.0, chess.BLACK:0.0}\n        for sq, p in pm.items():\n            if p is None:\n                continue\n            color = p.color\n            opp = chess.WHITE if color == chess.BLACK else chess.BLACK\n            # attackers from opponent to this square\n            attackers = board.attackers(opp, sq)\n            if not attackers:\n                continue\n            # defenders (friendly attackers) count\n            defenders = board.attackers(color, sq)\n            # consider as \"hanging\" if defenders are fewer than attackers and defenders count is zero\n            if len(defenders) == 0 and len(attackers) > 0:\n                hanging[color] += vals.get(p.piece_type, 0.0)\n        return float(hanging[chess.WHITE] - hanging[chess.BLACK])\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Pawn island imbalance: number of pawn islands (contiguous files with pawns) difference (white - black) (lower islands better)'\n    try:\n        pm = board.piece_map()\n        def pawn_islands(color):\n            files_with_pawn = [False]*8\n            for sq,p in pm.items():\n                if p and p.piece_type == chess.PAWN and p.color == color:\n                    f = chess.square_file(sq)\n                    files_with_pawn[f] = True\n            islands = 0\n            f = 0\n            while f < 8:\n                if files_with_pawn[f]:\n                    islands += 1\n                    while f < 8 and files_with_pawn[f]:\n                        f += 1\n                else:\n                    f += 1\n            return islands\n        return float(pawn_islands(chess.WHITE) - pawn_islands(chess.BLACK))\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Knights on outposts / central safe squares not attacked by enemy pawns (white - black)'\n    try:\n        pm = board.piece_map()\n        # central/outpost squares set (c4,d4,e4,c5,d5,e5 plus d3/e3/d6/e6 as secondary)\n        outposts = set()\n        for name in ('c4','d4','e4','c5','d5','e5','d3','e3','d6','e6'):\n            try:\n                outposts.add(chess.parse_square(name))\n            except Exception:\n                pass\n        def pawn_attacks_color_at_square(color, sq):\n            # returns True if color pawns attack square sq\n            f = chess.square_file(sq); r = chess.square_rank(sq)\n            if color == chess.WHITE:\n                # white pawn attacks from (f-1,r-1) and (f+1,r-1)\n                for df in (-1, 1):\n                    ff = f + df; rr = r - 1\n                    if 0 <= ff < 8 and 0 <= rr < 8:\n                        p = pm.get(chess.square(ff, rr))\n                        if p and p.piece_type == chess.PAWN and p.color == chess.WHITE:\n                            return True\n            else:\n                # black pawn attacks from (f-1,r+1) and (f+1,r+1)\n                for df in (-1, 1):\n                    ff = f + df; rr = r + 1\n                    if 0 <= ff < 8 and 0 <= rr < 8:\n                        p = pm.get(chess.square(ff, rr))\n                        if p and p.piece_type == chess.PAWN and p.color == chess.BLACK:\n                            return True\n            return False\n        score = {chess.WHITE:0.0, chess.BLACK:0.0}\n        for sq,p in pm.items():\n            if p and p.piece_type == chess.KNIGHT:\n                if sq in outposts:\n                    # is the square attacked by enemy pawns?\n                    opp = chess.BLACK if p.color == chess.WHITE else chess.WHITE\n                    if not pawn_attacks_color_at_square(opp, sq):\n                        # centrality bonus: closer to board center is better\n                        f = chess.square_file(sq); r = chess.square_rank(sq)\n                        center_dist = ((f-3.5)**2 + (r-3.5)**2)**0.5\n                        central_bonus = max(0.0, 3.0 - center_dist) / 3.0\n                        score[p.color] += 1.0 + 0.6 * central_bonus\n        return float(score[chess.WHITE] - score[chess.BLACK])\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Queen centrality and mobility: combines distance to center and legal moves for queens (white - black)'\n    try:\n        pm = board.piece_map()\n        def queen_score_for_color(color):\n            # centrality: sum of (4 - chebyshev distance to center) for queens\n            qs = 0.0\n            orig = board.turn\n            try:\n                board.turn = color\n                for sq,p in pm.items():\n                    if p and p.piece_type == chess.QUEEN and p.color == color:\n                        f = chess.square_file(sq); r = chess.square_rank(sq)\n                        # chebyshev distance to center (3.5,3.5)\n                        cheb = max(abs(f-3.5), abs(r-3.5))\n                        cent = max(0.0, 4.0 - cheb) / 4.0\n                        # mobility: count legal moves for this queen\n                        moves = 0\n                        for mv in board.legal_moves:\n                            if mv.from_square == sq:\n                                moves += 1\n                        mob = moves / 27.0  # roughly normalize by a high cap\n                        qs += cent * 0.6 + mob * 0.9\n            finally:\n                board.turn = orig\n            return qs\n        return float(queen_score_for_color(chess.WHITE) - queen_score_for_color(chess.BLACK))\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Weighted penalty for doubled and isolated pawns (positive favors fewer pawn-weaknesses for White - Black)'\n    try:\n        pm = board.piece_map()\n        doubled = {chess.WHITE:0, chess.BLACK:0}\n        isolated = {chess.WHITE:0, chess.BLACK:0}\n        pawns_on_file = {f:{chess.WHITE:0, chess.BLACK:0} for f in range(8)}\n        for sq,p in pm.items():\n            if p and p.piece_type == chess.PAWN:\n                f = chess.square_file(sq)\n                pawns_on_file[f][p.color] += 1\n        for f in range(8):\n            for color in (chess.WHITE, chess.BLACK):\n                if pawns_on_file[f][color] > 1:\n                    doubled[color] += (pawns_on_file[f][color] - 1)\n                # isolated: no friendly pawns on adjacent files\n                if pawns_on_file[f][color] > 0:\n                    left = pawns_on_file[f-1][color] if f-1 >= 0 else 0\n                    right = pawns_on_file[f+1][color] if f+1 <= 7 else 0\n                    if left + right == 0:\n                        isolated[color] += pawns_on_file[f][color]\n        # heavier penalty for isolated, lighter for doubled\n        score_w = -0.6 * doubled[chess.WHITE] - 1.0 * isolated[chess.WHITE]\n        score_b = -0.6 * doubled[chess.BLACK] - 1.0 * isolated[chess.BLACK]\n        return float(score_w - score_b)\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Rook dominion: rooks on the seventh rank, doubled rooks and connected rooks (white - black)'\n    try:\n        pm = board.piece_map()\n        score = {chess.WHITE:0.0, chess.BLACK:0.0}\n        # map files to rook squares for doubling detection\n        rooks_by_file = {f:{chess.WHITE:[], chess.BLACK:[]} for f in range(8)}\n        for sq,p in pm.items():\n            if p and p.piece_type == chess.ROOK:\n                f = chess.square_file(sq); r = chess.square_rank(sq)\n                rooks_by_file[f][p.color].append(sq)\n                seventh = 6 if p.color == chess.WHITE else 1\n                if r == seventh:\n                    score[p.color] += 1.6\n        # doubled rooks (same file)\n        for f in range(8):\n            for color in (chess.WHITE, chess.BLACK):\n                if len(rooks_by_file[f][color]) > 1:\n                    score[color] += 1.2 * (len(rooks_by_file[f][color]) - 1)\n        # connected rooks: two rooks on same rank with no pieces between\n        for color in (chess.WHITE, chess.BLACK):\n            rook_sqs = [sq for sq,p in pm.items() if p and p.piece_type == chess.ROOK and p.color == color]\n            for i in range(len(rook_sqs)):\n                for j in range(i+1, len(rook_sqs)):\n                    s1 = rook_sqs[i]; s2 = rook_sqs[j]\n                    f1 = chess.square_file(s1); r1 = chess.square_rank(s1)\n                    f2 = chess.square_file(s2); r2 = chess.square_rank(s2)\n                    if r1 == r2:\n                        # check emptiness between files\n                        clear = True\n                        for ff in range(min(f1,f2)+1, max(f1,f2)):\n                            if board.piece_at(chess.square(ff, r1)) is not None:\n                                clear = False; break\n                        if clear:\n                            score[color] += 1.0\n                    if f1 == f2:\n                        clear = True\n                        for rr in range(min(r1,r2)+1, max(r1,r2)):\n                            if board.piece_at(chess.square(f1, rr)) is not None:\n                                clear = False; break\n                        if clear:\n                            score[color] += 0.9\n        return float(score[chess.WHITE] - score[chess.BLACK])\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Aggregate attack pressure against the kings: sum of attacking piece values to king zone weighted by proximity (white - black)'\n    try:\n        vals = {chess.PAWN:1.0, chess.KNIGHT:3.0, chess.BISHOP:3.0, chess.ROOK:5.0, chess.QUEEN:9.0, chess.KING:0.0}\n        pm = board.piece_map()\n        def king_zone_score(color):\n            # compute score of opponent pieces attacking squares in/near the king\n            king_sq = next((sq for sq,p in pm.items() if p and p.piece_type == chess.KING and p.color == color), None)\n            if king_sq is None:\n                return 0.0\n            kf = chess.square_file(king_sq); kr = chess.square_rank(king_sq)\n            opp = chess.WHITE if color == chess.BLACK else chess.BLACK\n            score = 0.0\n            # consider a 2-square radius\n            for ff in range(max(0, kf-2), min(7, kf+2)+1):\n                for rr in range(max(0, kr-2), min(7, kr+2)+1):\n                    sq = chess.square(ff, rr)\n                    attackers = board.attackers(opp, sq)\n                    if not attackers:\n                        continue\n                    # distance penalty: closer squares matter more\n                    dist = max(1.0, ((kf-ff)**2 + (kr-rr)**2)**0.5)\n                    for a in attackers:\n                        pa = pm.get(a)\n                        if pa:\n                            score += vals.get(pa.piece_type, 0.0) / dist\n            return score\n        return float(king_zone_score(chess.WHITE) - king_zone_score(chess.BLACK))\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Count of low-mobility non-pawn pieces stuck on board edges (penalize trapped pieces) (white - black)'\n    try:\n        pm = board.piece_map()\n        trapped = {chess.WHITE:0.0, chess.BLACK:0.0}\n        # low mobility threshold: <=1 legal moves for that piece\n        orig = board.turn\n        try:\n            for color in (chess.WHITE, chess.BLACK):\n                board.turn = color\n                # build move count per piece\n                move_counts = {}\n                for mv in board.legal_moves:\n                    frm = mv.from_square\n                    move_counts[frm] = move_counts.get(frm, 0) + 1\n                for sq,p in pm.items():\n                    if not p or p.piece_type in (chess.PAWN, chess.KING) or p.color != color:\n                        continue\n                    f = chess.square_file(sq); r = chess.square_rank(sq)\n                    on_edge = (f == 0 or f == 7 or r == 0 or r == 7)\n                    mc = move_counts.get(sq, 0)\n                    if on_edge and mc <= 1:\n                        # heavier penalty for trapped on back rank or corner\n                        penalty = 1.5 if ( (r==0 and color==chess.BLACK) or (r==7 and color==chess.WHITE) ) else 1.0\n                        if (f == 0 or f == 7) and (r == 0 or r == 7):\n                            penalty += 0.5\n                        trapped[color] += penalty\n        finally:\n            board.turn = orig\n        return float(trapped[chess.WHITE] - trapped[chess.BLACK])\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Flank pawn majority and potential: difference in pawn majorities on king/queen flanks weighted by presence of rooks on that flank (white - black)'\n    try:\n        pm = board.piece_map()\n        def flank_score(color):\n            pawns_q = 0; pawns_k = 0\n            rooks_q = 0; rooks_k = 0\n            for sq,p in pm.items():\n                if p and p.piece_type == chess.PAWN and p.color == color:\n                    f = chess.square_file(sq)\n                    if f <= 3:\n                        pawns_q += 1\n                    else:\n                        pawns_k += 1\n                if p and p.piece_type == chess.ROOK and p.color == color:\n                    f = chess.square_file(sq)\n                    if f <= 3:\n                        rooks_q += 1\n                    else:\n                        rooks_k += 1\n            score = 0.0\n            # reward pawn majority on a flank, amplified if rooks present there\n            if pawns_q > pawns_k:\n                score += (pawns_q - pawns_k) * (1.0 + 0.5 * rooks_q)\n            if pawns_k > pawns_q:\n                score -= (pawns_k - pawns_q) * (1.0 + 0.5 * rooks_k)\n            return score\n        return float(flank_score(chess.WHITE) - flank_score(chess.BLACK))\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Immediate tactical resources: captures and checks available for each side (white - black)'\n    try:\n        pm = board.piece_map()\n        captures = {chess.WHITE:0.0, chess.BLACK:0.0}\n        checks = {chess.WHITE:0.0, chess.BLACK:0.0}\n        orig = board.turn\n        try:\n            for color in (chess.WHITE, chess.BLACK):\n                board.turn = color\n                # iterate legal moves; use a copy to test resulting check state\n                for mv in board.legal_moves:\n                    # capture detection: destination square occupied by opponent (approx; misses en-passant)\n                    to_piece = board.piece_at(mv.to_square)\n                    if to_piece and to_piece.color != color:\n                        captures[color] += 1.0\n                    # simulate move to detect if it gives check\n                    try:\n                        b2 = board.copy()\n                        b2.push(mv)\n                        if b2.is_check():\n                            checks[color] += 1.4\n                    except Exception:\n                        # if simulation fails, fallback to heuristic: if move attacks opponent king square directly\n                        opp_king_sq = next((s for s,p in pm.items() if p and p.piece_type == chess.KING and p.color != color), None)\n                        if opp_king_sq is not None and mv.to_square == opp_king_sq:\n                            checks[color] += 1.4\n        finally:\n            board.turn = orig\n        # combine captures and checks (checks weighted higher)\n        score_w = captures[chess.WHITE] + checks[chess.WHITE]\n        score_b = captures[chess.BLACK] + checks[chess.BLACK]\n        return float(score_w - score_b)\n    except Exception:\n        return 0.0\n",
    "def feature(board: chess.Board) -> float:\n    'Pawn structure weaknesses: counts doubled, isolated and backward pawns (white - black), penalizing structural defects'\n    try:\n        pm = board.piece_map()\n        scores = {chess.WHITE:0.0, chess.BLACK:0.0}\n        file_pawns = {chess.WHITE: {f:[] for f in range(8)}, chess.BLACK: {f:[] for f in range(8)}}\n        all_file_pawns = {f:[] for f in range(8)}\n        for sq, p in pm.items():\n            if p and p.piece_type == chess.PAWN:\n                f = chess.square_file(sq)\n                r = chess.square_rank(sq)\n                file_pawns[p.color][f].append((r, sq))\n                all_file_pawns[f].append((p.color, r, sq))\n        for color in (chess.WHITE, chess.BLACK):\n            enemy = chess.BLACK if color == chess.WHITE else chess.WHITE\n            for f in range(8):\n                pawns_on_file = file_pawns[color][f]\n                # doubled pawns\n                if len(pawns_on_file) > 1:\n                    scores[color] -= 0.6 * len(pawns_on_file)\n                for r, sq in pawns_on_file:\n                    # isolated: no friendly pawns on adjacent files\n                    adj_have = False\n                    for af in (f-1, f+1):\n                        if 0 <= af < 8 and len(file_pawns[color][af]) > 0:\n                            adj_have = True; break\n                    if not adj_have:\n                        scores[color] -= 0.5\n                    # backward: isolated and an enemy pawn exists ahead on same or adjacent file\n                    if not adj_have:\n                        enemy_block = False\n                        if color == chess.WHITE:\n                            for af in (f-1, f, f+1):\n                                if 0 <= af < 8:\n                                    for ec, er, esq in all_file_pawns[af]:\n                                        if ec == enemy and er > r:\n                                            enemy_block = True; break\n                                    if enemy_block: break\n                        else:\n                            for af in (f-1, f, f+1):\n                                if 0 <= af < 8:\n                                    for ec, er, esq in all_file_pawns[af]:\n                                        if ec == enemy and er < r:\n                                            enemy_block = True; break\n                                    if enemy_block: break\n                        if enemy_block:\n                            scores[color] -= 0.8\n        return float(scores[chess.WHITE] - scores[chess.BLACK])\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Bishop pair utility and bad-bishop penalty: rewards bishop pair and penalizes bishops blocked by own pawn color-complex (white - black)'\n    try:\n        pm = board.piece_map()\n        vals = {chess.WHITE:0.0, chess.BLACK:0.0}\n        for color in (chess.WHITE, chess.BLACK):\n            bishops = []\n            pawns_same_color_sq_count = 0\n            total_pawns = 0\n            for sq, p in pm.items():\n                if not p:\n                    continue\n                if p.piece_type == chess.BISHOP and p.color == color:\n                    bishops.append(sq)\n                if p.piece_type == chess.PAWN and p.color == color:\n                    total_pawns += 1\n                    # count pawn square color (0 light, 1 dark)\n                    pawns_same_color_sq_count += ((chess.square_file(sq) + chess.square_rank(sq)) & 1)\n            # bishop pair bonus\n            if len(bishops) >= 2:\n                vals[color] += 0.75\n            # assess \"bad\" bishops: if many own pawns occupy same-color squares as bishop's square\n            for b_sq in bishops:\n                b_color_sq = (chess.square_file(b_sq) + chess.square_rank(b_sq)) & 1\n                # count own pawns on same color squares\n                same_color_pawns = 0\n                for sq, p in pm.items():\n                    if p and p.piece_type == chess.PAWN and p.color == color:\n                        if ((chess.square_file(sq) + chess.square_rank(sq)) & 1) == b_color_sq:\n                            same_color_pawns += 1\n                # if a majority of the side's pawns are on bishop's color, bishop is likely \"bad\"\n                if total_pawns > 0 and same_color_pawns / total_pawns > 0.6:\n                    vals[color] -= 0.45\n        return float(vals[chess.WHITE] - vals[chess.BLACK])\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Rooks on open or semi-open files: open file = no pawns; semi-open = no friendly pawns (white - black)'\n    try:\n        pm = board.piece_map()\n        file_has_pawn = {f: False for f in range(8)}\n        file_has_friendly = {chess.WHITE: {f: False for f in range(8)}, chess.BLACK: {f: False for f in range(8)}}\n        for sq, p in pm.items():\n            if p and p.piece_type == chess.PAWN:\n                f = chess.square_file(sq)\n                file_has_pawn[f] = True\n                file_has_friendly[p.color][f] = True\n        score = {chess.WHITE: 0.0, chess.BLACK: 0.0}\n        for sq, p in pm.items():\n            if not p or p.piece_type != chess.ROOK:\n                continue\n            f = chess.square_file(sq)\n            if not file_has_pawn[f]:\n                score[p.color] += 1.0\n            elif not file_has_friendly[p.color][f]:\n                score[p.color] += 0.5\n        return float(score[chess.WHITE] - score[chess.BLACK])\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'King centrality advantage in endgames: rewards kings closer to center when material is low (white - black)'\n    try:\n        pm = board.piece_map()\n        vals = {chess.PAWN:1.0, chess.KNIGHT:3.0, chess.BISHOP:3.0, chess.ROOK:5.0, chess.QUEEN:9.0}\n        total_mat = 0.0\n        for p in pm.values():\n            if p and p.piece_type in vals:\n                total_mat += vals[p.piece_type]\n        # consider endgame when heavy material is low\n        if total_mat > 12.0:\n            return 0.0\n        wk = next((sq for sq, p in pm.items() if p and p.piece_type == chess.KING and p.color == chess.WHITE), None)\n        bk = next((sq for sq, p in pm.items() if p and p.piece_type == chess.KING and p.color == chess.BLACK), None)\n        if wk is None or bk is None:\n            return 0.0\n        center_sqs = [chess.square(f, r) for f in (3,4) for r in (3,4)]\n        def centrality(ksq):\n            d = min(chess.square_distance(ksq, c) for c in center_sqs)\n            maxd = 7.0\n            return (maxd - float(d)) / maxd\n        factor = 1.0 + (12.0 - total_mat) / 12.0  # slightly larger weight in very reduced material\n        return float((centrality(wk) - centrality(bk)) * factor)\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Trapped-piece metric: counts likely trapped non-pawn pieces (few legal moves while attacked) (white - black)'\n    try:\n        pm = board.piece_map()\n        trapped = {chess.WHITE:0.0, chess.BLACK:0.0}\n        orig = board.turn\n        try:\n            for color in (chess.WHITE, chess.BLACK):\n                board.turn = color\n                for sq, p in list(pm.items()):\n                    if not p or p.color != color or p.piece_type in (chess.PAWN, chess.KING):\n                        continue\n                    # count legal moves for that piece\n                    cnt = 0\n                    attacked = board.is_attacked_by(not color, sq)\n                    for mv in board.legal_moves:\n                        if mv.from_square == sq:\n                            cnt += 1\n                            if cnt > 2:\n                                break\n                    if cnt <= 1 and attacked:\n                        trapped[color] += 1.0\n        finally:\n            board.turn = orig\n        return float(trapped[chess.WHITE] - trapped[chess.BLACK])\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Piece coordination: inverse of average pairwise distance between non-pawn pieces (higher means better coordination) (white - black)'\n    try:\n        pm = board.piece_map()\n        def coord(color):\n            sqs = [sq for sq, p in pm.items() if p and p.color == color and p.piece_type not in (chess.PAWN, chess.KING)]\n            n = len(sqs)\n            if n < 2:\n                return 0.0\n            tot = 0.0\n            pairs = 0\n            for i in range(n):\n                for j in range(i+1, n):\n                    tot += chess.square_distance(sqs[i], sqs[j])\n                    pairs += 1\n            avg = tot / pairs if pairs > 0 else 14.0\n            # convert to coordination measure in [0,1]\n            return (14.0 - avg) / 14.0\n        return float(coord(chess.WHITE) - coord(chess.BLACK))\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Passed-pawn promotion tempo: scores passed pawns by distance to promotion and support (white - black)'\n    try:\n        pm = board.piece_map()\n        def is_passed(sq, color):\n            f = chess.square_file(sq); r = chess.square_rank(sq)\n            enemy = chess.BLACK if color == chess.WHITE else chess.WHITE\n            for af in (f-1, f, f+1):\n                if af < 0 or af > 7:\n                    continue\n                if color == chess.WHITE:\n                    for ar in range(r+1, 8):\n                        pp = pm.get(chess.square(af, ar))\n                        if pp and pp.piece_type == chess.PAWN and pp.color == enemy:\n                            return False\n                else:\n                    for ar in range(0, r):\n                        pp = pm.get(chess.square(af, ar))\n                        if pp and pp.piece_type == chess.PAWN and pp.color == enemy:\n                            return False\n            return True\n        score = {chess.WHITE:0.0, chess.BLACK:0.0}\n        for sq, p in pm.items():\n            if not p or p.piece_type != chess.PAWN:\n                continue\n            if not is_passed(sq, p.color):\n                continue\n            r = chess.square_rank(sq)\n            if p.color == chess.WHITE:\n                dist = 7 - r\n            else:\n                dist = r\n            # closer pawns score more; small bonus if defended by friendly piece\n            base = (8.0 - dist) / 8.0\n            defenders = board.attackers(p.color, sq)\n            defended = any((board.piece_at(d) and board.piece_at(d).color == p.color) for d in defenders)\n            bonus = 0.35 if defended else 0.0\n            score[p.color] += base + bonus\n        return float(score[chess.WHITE] - score[chess.BLACK])\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Pressure against castled king: sums weighted enemy attackers around a castled king; positive favors White (white - black)'\n    try:\n        pm = board.piece_map()\n        vals = {chess.PAWN:1.0, chess.KNIGHT:3.0, chess.BISHOP:3.0, chess.ROOK:5.0, chess.QUEEN:9.0, chess.KING:0.0}\n        def king_pressure(color):\n            king_sq = next((sq for sq, p in pm.items() if p and p.piece_type == chess.KING and p.color == color), None)\n            if king_sq is None:\n                return 0.0\n            f = chess.square_file(king_sq); r = chess.square_rank(king_sq)\n            # heuristically consider as \"castled\" if king on g1/g8 (file 6) or c1/c8 (file 2) or near edge first rank\n            if not ((r in (0,7) and f in (2,6)) or (f in (2,6))):\n                return 0.0\n            opp = chess.BLACK if color == chess.WHITE else chess.WHITE\n            pressure = 0.0\n            for ff in range(max(0, f-2), min(7, f+2)+1):\n                for rr in range(max(0, r-1), min(7, r+2)+1):\n                    sq = chess.square(ff, rr)\n                    for a in board.attackers(opp, sq):\n                        pa = pm.get(a)\n                        if pa:\n                            pressure += vals.get(pa.piece_type, 0.0) * (1.0 if (ff == f and rr == r) else 0.45)\n            return pressure\n        return float(king_pressure(chess.WHITE) - king_pressure(chess.BLACK))\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Queen centralization and tactical reach: centralization minus enemy adjacency defense, counts capture opportunities (white - black)'\n    try:\n        pm = board.piece_map()\n        orig = board.turn\n        try:\n            def queen_score(color):\n                qsq = next((sq for sq, p in pm.items() if p and p.piece_type == chess.QUEEN and p.color == color), None)\n                if qsq is None:\n                    return 0.0\n                # centralization\n                center_sqs = [chess.square(f, r) for f in (3,4) for r in (3,4)]\n                d = min(chess.square_distance(qsq, c) for c in center_sqs)\n                cent = (7.0 - float(d)) / 7.0\n                # capture opportunities: count legal queen captures\n                cap_count = 0\n                board.turn = color\n                for mv in board.legal_moves:\n                    if mv.from_square == qsq:\n                        target = board.piece_at(mv.to_square)\n                        if target and target.color != color:\n                            cap_count += 1\n                return cent + 0.55 * cap_count\n            return float(queen_score(chess.WHITE) - queen_score(chess.BLACK))\n        finally:\n            board.turn = orig\n    except Exception:\n        return 0.0\n",
    "def feature(board: chess.Board) -> float:\n    'Pawn-structure weaknesses: counts doubled, isolated, and backward pawns (positive => Black has worse structure than White)'\n    try:\n        pm = board.piece_map()\n        files = range(8)\n        penalties = {chess.WHITE:0.0, chess.BLACK:0.0}\n        pawns_by_color_file = {chess.WHITE: {f: [] for f in files}, chess.BLACK: {f: [] for f in files}}\n        for sq,p in pm.items():\n            if not p or p.piece_type != chess.PAWN:\n                continue\n            f = chess.square_file(sq)\n            pawns_by_color_file[p.color][f].append(sq)\n        for color in (chess.WHITE, chess.BLACK):\n            opp = chess.BLACK if color == chess.WHITE else chess.WHITE\n            # doubled pawns penalty\n            for f in files:\n                cnt = len(pawns_by_color_file[color][f])\n                if cnt > 1:\n                    penalties[color] += 0.7 * (cnt - 1)\n            # isolated pawns penalty\n            for f in files:\n                if len(pawns_by_color_file[color][f]) == 0:\n                    continue\n                left = f-1\n                right = f+1\n                if (left < 0 or len(pawns_by_color_file[color].get(left, [])) == 0) and (right > 7 or len(pawns_by_color_file[color].get(right, [])) == 0):\n                    penalties[color] += 1.0 * len(pawns_by_color_file[color][f])\n            # backward pawn: a pawn that has no friendly pawn on adjacent files on a more advanced rank\n            for f in files:\n                for sq in pawns_by_color_file[color][f]:\n                    r = chess.square_rank(sq)\n                    is_backward = True\n                    if color == chess.WHITE:\n                        for af in (f-1, f+1):\n                            if 0 <= af < 8:\n                                for asq in pawns_by_color_file[color][af]:\n                                    if chess.square_rank(asq) > r:\n                                        is_backward = False\n                                        break\n                                if not is_backward:\n                                    break\n                    else:\n                        for af in (f-1, f+1):\n                            if 0 <= af < 8:\n                                for asq in pawns_by_color_file[color][af]:\n                                    if chess.square_rank(asq) < r:\n                                        is_backward = False\n                                        break\n                                if not is_backward:\n                                    break\n                    if is_backward:\n                        penalties[color] += 0.9\n        # Positive means Black has worse structure than White (good for White)\n        return float(penalties[chess.BLACK] - penalties[chess.WHITE])\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Passed pawn promotion proximity: sums passed-pawn urgency weighted by distance to promotion (white - black)'\n    try:\n        pm = board.piece_map()\n        def is_passed_pawn(sq, color):\n            f = chess.square_file(sq); r = chess.square_rank(sq)\n            opp = chess.BLACK if color == chess.WHITE else chess.WHITE\n            if color == chess.WHITE:\n                # no enemy pawns on same file or adjacent files on ranks ahead (r+1 .. 7)\n                for af in (f-1, f, f+1):\n                    if 0 <= af < 8:\n                        for rr in range(r+1, 8):\n                            s = chess.square(af, rr)\n                            p = pm.get(s)\n                            if p and p.piece_type == chess.PAWN and p.color == opp:\n                                return False\n                return True\n            else:\n                for af in (f-1, f, f+1):\n                    if 0 <= af < 8:\n                        for rr in range(0, r):\n                            s = chess.square(af, rr)\n                            p = pm.get(s)\n                            if p and p.piece_type == chess.PAWN and p.color == opp:\n                                return False\n                return True\n        score = {chess.WHITE:0.0, chess.BLACK:0.0}\n        for sq,p in pm.items():\n            if not p or p.piece_type != chess.PAWN:\n                continue\n            if not is_passed_pawn(sq, p.color):\n                continue\n            r = chess.square_rank(sq)\n            # distance to promotion (0 = already 8th rank)\n            if p.color == chess.WHITE:\n                dist = max(0, 7 - r)\n            else:\n                dist = max(0, r - 0)\n            # urgency increases as distance shortens; weight central files slightly more\n            f = chess.square_file(sq)\n            central_bonus = 0.15 if f in (3,4) else 0.0\n            weight = 1.0 + (1.0 - float(dist) / 7.0) + central_bonus\n            score[p.color] += weight\n        return float(score[chess.WHITE] - score[chess.BLACK])\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Rook effectiveness: counts rooks on open/half-open files and rooks on the opponent 7th rank (white - black)'\n    try:\n        pm = board.piece_map()\n        # precompute pawns per file\n        pawns_on_file = {f: {'both':0, chess.WHITE:0, chess.BLACK:0} for f in range(8)}\n        for sq,p in pm.items():\n            if not p or p.piece_type != chess.PAWN:\n                continue\n            f = chess.square_file(sq)\n            pawns_on_file[f]['both'] += 1\n            pawns_on_file[f][p.color] += 1\n        score = {chess.WHITE:0.0, chess.BLACK:0.0}\n        for sq,p in pm.items():\n            if not p or p.piece_type != chess.ROOK:\n                continue\n            f = chess.square_file(sq); r = chess.square_rank(sq)\n            color = p.color\n            opp = chess.BLACK if color == chess.WHITE else chess.WHITE\n            # open file: no pawns on that file\n            if pawns_on_file[f]['both'] == 0:\n                score[color] += 1.0\n            else:\n                # half-open: no friendly pawns on that file\n                if pawns_on_file[f][color] == 0:\n                    score[color] += 0.5\n            # rook on 7th rank (opponent's second rank) is powerful\n            if (color == chess.WHITE and r == 6) or (color == chess.BLACK and r == 1):\n                # bonus reduced if there are pawns blocking on that rank of opponent\n                score[color] += 1.6\n        return float(score[chess.WHITE] - score[chess.BLACK])\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Bishop long-range potential: sums unobstructed ray lengths for bishops (white - black)'\n    try:\n        pm = board.piece_map()\n        directions = [(-1,-1), (-1,1), (1,-1), (1,1)]\n        def bishop_range(sq):\n            total = 0\n            f = chess.square_file(sq); r = chess.square_rank(sq)\n            for df,dr in directions:\n                nf, nr = f + df, r + dr\n                steps = 0\n                while 0 <= nf < 8 and 0 <= nr < 8:\n                    nsq = chess.square(nf, nr)\n                    if pm.get(nsq) is None:\n                        steps += 1\n                        nf += df; nr += dr\n                        continue\n                    else:\n                        # blocked by a piece, but if opponent piece it's still an attack square (count +1)\n                        steps += 1\n                        break\n                total += steps\n            return total\n        score = {chess.WHITE:0.0, chess.BLACK:0.0}\n        for sq,p in pm.items():\n            if not p or p.piece_type != chess.BISHOP:\n                continue\n            # bonus if bishop controls many squares\n            rng = bishop_range(sq)\n            # bishops on long diagonals and in opponent half get a bit more weight\n            r = chess.square_rank(sq); bonus_half = 0.3 if (p.color == chess.WHITE and r >= 4) or (p.color == chess.BLACK and r <= 3) else 0.0\n            score[p.color] += (0.12 * rng) + bonus_half\n        return float(score[chess.WHITE] - score[chess.BLACK])\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Advanced minor pieces: counts knights and bishops placed in opponent half and supported by pawns (white - black)'\n    try:\n        pm = board.piece_map()\n        score = {chess.WHITE:0.0, chess.BLACK:0.0}\n        for sq,p in pm.items():\n            if not p or p.piece_type not in (chess.KNIGHT, chess.BISHOP):\n                continue\n            r = chess.square_rank(sq); f = chess.square_file(sq)\n            advanced = (p.color == chess.WHITE and r >= 4) or (p.color == chess.BLACK and r <= 3)\n            if not advanced:\n                continue\n            # check pawn support: is there a friendly pawn attacking this square?\n            supporters = [a for a in board.attackers(p.color, sq) if board.piece_at(a) and board.piece_at(a).piece_type == chess.PAWN]\n            support_bonus = 0.6 if supporters else 0.0\n            # knights slightly prefer central squares\n            central = 0.4 if p.piece_type == chess.KNIGHT and f in (3,4) and r in (3,4) else 0.0\n            score[p.color] += 1.0 + support_bonus + central\n        return float(score[chess.WHITE] - score[chess.BLACK])\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'King-file exposure: counts open/weak pawn files near the king and enemy heavy-piece pressure there (positive => Black more exposed than White)'\n    try:\n        pm = board.piece_map()\n        def exposure_for(color):\n            ks = next((sq for sq,p in pm.items() if p and p.piece_type == chess.KING and p.color == color), None)\n            if ks is None:\n                return 0.0\n            f = chess.square_file(ks); r = chess.square_rank(ks)\n            opp = chess.BLACK if color == chess.WHITE else chess.WHITE\n            open_files = 0\n            heavy_pressure = 0.0\n            for df in (-2,-1,0,1,2):\n                ff = f + df\n                if not (0 <= ff < 8):\n                    continue\n                # if there are no pawns of king color on that file, it's more exposed\n                has_friendly_pawn = any((pm.get(chess.square(ff, rr)) and pm.get(chess.square(ff, rr)).piece_type == chess.PAWN and pm.get(chess.square(ff, rr)).color == color) for rr in range(8))\n                if not has_friendly_pawn:\n                    open_files += 1\n                # count heavy enemy pieces (rook/queen) located on that file that attack near king rank\n                for rr in range(8):\n                    sq = chess.square(ff, rr)\n                    p = pm.get(sq)\n                    if p and p.color == opp and p.piece_type in (chess.ROOK, chess.QUEEN):\n                        # check if that piece currently attacks any square on the king's rank or adjacent ranks (approx. pressure)\n                        for tr in range(max(0, r-1), min(7, r+1)+1):\n                            tsq = chess.square(ff, tr)\n                            if board.is_attacked_by(opp, tsq):\n                                heavy_pressure += 0.6\n                                break\n            return float(open_files) + 0.5 * heavy_pressure\n        exp_w = exposure_for(chess.WHITE)\n        exp_b = exposure_for(chess.BLACK)\n        # positive if Black more exposed (good for White)\n        return float(exp_b - exp_w)\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Coordinated pressure: counts squares in the opponent half attacked by two or more non-pawn friendly pieces (white - black)'\n    try:\n        pm = board.piece_map()\n        def coord(color):\n            total = 0.0\n            target_ranks = range(4,8) if color == chess.WHITE else range(0,4)\n            for rr in target_ranks:\n                for ff in range(8):\n                    sq = chess.square(ff, rr)\n                    attackers = board.attackers(color, sq)\n                    # count non-pawn unique attackers\n                    non_pawn_attackers = sum(1 for a in attackers if board.piece_at(a) and board.piece_at(a).piece_type != chess.PAWN)\n                    if non_pawn_attackers >= 2:\n                        total += 1.0\n            # normalize mildly by board size to keep values bounded\n            return total / 8.0\n        return float(coord(chess.WHITE) - coord(chess.BLACK))\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Tactical initiative proxy: difference in available captures and direct attacks on opponent king by legal moves (white - black) (approximate, avoids deep simulation)'\n    try:\n        orig = board.turn\n        try:\n            caps = {chess.WHITE:0.0, chess.BLACK:0.0}\n            king_attacks = {chess.WHITE:0.0, chess.BLACK:0.0}\n            for color in (chess.WHITE, chess.BLACK):\n                board.turn = color\n                opp = chess.BLACK if color == chess.WHITE else chess.WHITE\n                # locate opponent king\n                opp_king_sq = next((sq for sq,p in board.piece_map().items() if p and p.piece_type == chess.KING and p.color == opp), None)\n                for mv in board.legal_moves:\n                    # approximate capture if destination currently occupied by opponent\n                    dest_piece = board.piece_at(mv.to_square)\n                    if dest_piece and dest_piece.color == opp:\n                        caps[color] += 1.0\n                    else:\n                        # en passant possible: check if moving pawn and file differs and there is an opponent pawn behind to capture\n                        if board.piece_at(mv.from_square) and board.piece_at(mv.from_square).piece_type == chess.PAWN and chess.square_file(mv.from_square) != chess.square_file(mv.to_square):\n                            # heuristically count as capture possibility (en passant)\n                            if dest_piece is None:\n                                caps[color] += 0.9\n                    # approximate direct attacks on king by seeing if the move's destination would attack the king in the current board (ignoring discovered attacks)\n                    if opp_king_sq is not None:\n                        moved_piece = board.piece_at(mv.from_square)\n                        if moved_piece:\n                            # for jumps (knight) and king moves, check reachability\n                            pt = moved_piece.piece_type\n                            if pt == chess.KNIGHT:\n                                if any(mv.to_square == t for t in [sq for sq in board.attackers(color, opp_king_sq) if board.piece_at(sq) and board.piece_at(sq).piece_type == chess.KNIGHT]):\n                                    king_attacks[color] += 1.0\n                                else:\n                                    # simpler: if destination is one knight move from king\n                                    df = abs(chess.square_file(mv.to_square) - chess.square_file(opp_king_sq))\n                                    dr = abs(chess.square_rank(mv.to_square) - chess.square_rank(opp_king_sq))\n                                    if (df,dr) in ((1,2),(2,1)):\n                                        king_attacks[color] += 1.0\n                            elif pt == chess.BISHOP or pt == chess.ROOK or pt == chess.QUEEN:\n                                # if destination is on same rank/file/diagonal as king and path currently clear except possibly from_square\n                                df = chess.square_file(mv.to_square) - chess.square_file(opp_king_sq)\n                                dr = chess.square_rank(mv.to_square) - chess.square_rank(opp_king_sq)\n                                if df == 0 or dr == 0 or abs(df) == abs(dr):\n                                    # check line of sight ignoring moving piece original square\n                                    step_f = 0 if df == 0 else (1 if df > 0 else -1)\n                                    step_r = 0 if dr == 0 else (1 if dr > 0 else -1)\n                                    tf = chess.square_file(mv.to_square) - step_f\n                                    tr = chess.square_rank(mv.to_square) - step_r\n                                    blocked = False\n                                    while (tf, tr) != (chess.square_file(opp_king_sq), chess.square_rank(opp_king_sq)):\n                                        tsq = chess.square(tf, tr)\n                                        # treat the moving-from square as empty\n                                        if tsq == mv.from_square:\n                                            pass\n                                        else:\n                                            p = board.piece_at(tsq)\n                                            if p is not None:\n                                                blocked = True\n                                                break\n                                        tf -= step_f; tr -= step_r\n                                    if not blocked:\n                                        king_attacks[color] += 1.0\n                            else:\n                                # pawn or king: simple proximity check (pawn attacks or moving onto attack squares)\n                                if moved_piece.piece_type == chess.PAWN:\n                                    # pawn attacks king square?\n                                    if color == chess.WHITE:\n                                        if chess.square_file(mv.to_square) in (chess.square_file(opp_king_sq)-1, chess.square_file(opp_king_sq)+1) and chess.square_rank(mv.to_square) == chess.square_rank(opp_king_sq)-1:\n                                            king_attacks[color] += 1.0\n                                    else:\n                                        if chess.square_file(mv.to_square) in (chess.square_file(opp_king_sq)-1, chess.square_file(opp_king_sq)+1) and chess.square_rank(mv.to_square) == chess.square_rank(opp_king_sq)+1:\n                                            king_attacks[color] += 1.0\n                                elif moved_piece.piece_type == chess.KING:\n                                    df = abs(chess.square_file(mv.to_square) - chess.square_file(opp_king_sq))\n                                    dr = abs(chess.square_rank(mv.to_square) - chess.square_rank(opp_king_sq))\n                                    if max(df,dr) == 1:\n                                        king_attacks[color] += 0.8\n            # small normalization\n            caps[color] = caps[color] / 8.0\n            king_attacks[color] = king_attacks[color] / 6.0\n        finally:\n            board.turn = orig\n        return float((caps[chess.WHITE] - caps[chess.BLACK]) + 0.6 * (king_attacks[chess.WHITE] - king_attacks[chess.BLACK]))\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Trapped-piece heuristic: counts pieces that are attacked and have no legal destination square that is currently unattacked (black - white positive favors White)'\n    try:\n        pm = board.piece_map()\n        trapped = {chess.WHITE:0.0, chess.BLACK:0.0}\n        # build map of legal moves per piece\n        # iterate legal moves and group by from_square\n        moves_by_from = {}\n        orig = board.turn\n        try:\n            # use current turn for legality; to get moves for both sides temporarily switch\n            for color in (chess.WHITE, chess.BLACK):\n                board.turn = color\n                moves_by_from[color] = {}\n                for mv in board.legal_moves:\n                    moves_by_from[color].setdefault(mv.from_square, []).append(mv.to_square)\n        finally:\n            board.turn = orig\n        for sq,p in pm.items():\n            if not p:\n                continue\n            color = p.color\n            opp = chess.BLACK if color == chess.WHITE else chess.WHITE\n            # if piece is not attacked at all, skip\n            attackers = board.attackers(opp, sq)\n            if not attackers:\n                continue\n            # get legal moves for that piece (approximate using moves_by_from)\n            dests = moves_by_from.get(color, {}).get(sq, [])\n            # if there are no legal moves, it's already a captured/immobile piece -> count strongly\n            if not dests:\n                trapped[color] += 1.5\n                continue\n            # if all destinations are currently attacked by opponent (heuristic), consider trapped\n            safe_found = False\n            for to_sq in dests:\n                if not board.is_attacked_by(opp, to_sq):\n                    safe_found = True\n                    break\n            if not safe_found:\n                trapped[color] += 1.0\n        # positive if Black has more trapped pieces (good for White)\n        return float(trapped[chess.BLACK] - trapped[chess.WHITE])\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'High-value piece exposure: sums weighted exposures of rooks and queens when attackers outnumber defenders (positive => Black more exposed than White)'\n    try:\n        pm = board.piece_map()\n        vals = {chess.ROOK:5.0, chess.QUEEN:9.0}\n        expos = {chess.WHITE:0.0, chess.BLACK:0.0}\n        for sq,p in pm.items():\n            if not p or p.piece_type not in (chess.ROOK, chess.QUEEN):\n                continue\n            color = p.color\n            opp = chess.BLACK if color == chess.WHITE else chess.WHITE\n            attackers = len(board.attackers(opp, sq))\n            defenders = len(board.attackers(color, sq))\n            if attackers > defenders:\n                # exposure scaled by how many more attackers and piece value\n                exposure = (attackers - defenders) * vals.get(p.piece_type, 0.0) * 0.35\n                expos[color] += exposure\n        # positive if Black more exposed (good for White)\n        return float(expos[chess.BLACK] - expos[chess.WHITE])\n    except Exception:\n        return 0.0\n",
    "def feature(board: chess.Board) -> float:\n    'Passed pawns weighted by advancement (white - black)'\n    try:\n        pm = board.piece_map()\n        def is_passed(sq, color):\n            f = chess.square_file(sq)\n            r = chess.square_rank(sq)\n            opp = chess.BLACK if color == chess.WHITE else chess.WHITE\n            files = [ff for ff in (f-1, f, f+1) if 0 <= ff < 8]\n            if color == chess.WHITE:\n                for ff in files:\n                    for rr in range(r+1, 8):\n                        p = pm.get(chess.square(ff, rr))\n                        if p and p.piece_type == chess.PAWN and p.color == opp:\n                            return False\n                return True\n            else:\n                for ff in files:\n                    for rr in range(0, r):\n                        p = pm.get(chess.square(ff, rr))\n                        if p and p.piece_type == chess.PAWN and p.color == opp:\n                            return False\n                return True\n        w_score = 0.0; b_score = 0.0\n        for sq,p in pm.items():\n            if not p or p.piece_type != chess.PAWN:\n                continue\n            if is_passed(sq, p.color):\n                # weight by advancement: more advanced => higher weight\n                rank = chess.square_rank(sq)\n                if p.color == chess.WHITE:\n                    weight = float(rank) / 7.0\n                    w_score += 1.0 + weight\n                else:\n                    weight = float(7 - rank) / 7.0\n                    b_score += 1.0 + weight\n        return float(w_score - b_score)\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'King centrality advantage in endgames (positive favors White); 0 outside endgame'\n    try:\n        pm = board.piece_map()\n        # detect endgame: few major/minor pieces (excluding kings and pawns)\n        non_king_pieces = [p for p in pm.values() if p and p.piece_type not in (chess.KING, chess.PAWN)]\n        if len(non_king_pieces) > 6:\n            return 0.0\n        # center squares\n        center = [chess.parse_square(s) for s in ('d4','e4','d5','e5')]\n        def king_centrality(color):\n            ks = next((sq for sq,p in pm.items() if p and p.piece_type==chess.KING and p.color==color), None)\n            if ks is None:\n                return 0.0\n            # distance to nearest center square (Manhattan), max possible 7\n            d = min(chess.square_distance(ks, c) for c in center)\n            return (7.0 - float(d)) / 7.0\n        return float(king_centrality(chess.WHITE) - king_centrality(chess.BLACK))\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Outpost knights: count of knights on advanced outpost squares (white - black)'\n    try:\n        pm = board.piece_map()\n        def is_outpost(sq, color):\n            # advanced: white ranks >=4, black ranks <=3\n            r = chess.square_rank(sq)\n            if color == chess.WHITE and r < 4:\n                return False\n            if color == chess.BLACK and r > 3:\n                return False\n            # no enemy pawn attacks this square\n            opp = chess.BLACK if color == chess.WHITE else chess.WHITE\n            attackers = board.attackers(opp, sq)\n            for a in attackers:\n                pa = pm.get(a)\n                if pa and pa.piece_type == chess.PAWN:\n                    return False\n            # supported by at least one friendly piece or pawn\n            defenders = board.attackers(color, sq)\n            for d in defenders:\n                pd = pm.get(d)\n                if pd and pd.color == color:\n                    return True\n            return False\n        w = 0.0; b = 0.0\n        for sq,p in pm.items():\n            if not p or p.piece_type != chess.KNIGHT:\n                continue\n            if is_outpost(sq, p.color):\n                if p.color == chess.WHITE:\n                    w += 1.0\n                else:\n                    b += 1.0\n        return float(w - b)\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Isolated pawn imbalance (black_isolated - white_isolated), positive favors White'\n    try:\n        pm = board.piece_map()\n        isolated = {chess.WHITE:0, chess.BLACK:0}\n        pawn_files = {chess.WHITE: set(), chess.BLACK: set()}\n        for sq,p in pm.items():\n            if not p or p.piece_type != chess.PAWN:\n                continue\n            pawn_files[p.color].add(chess.square_file(sq))\n        for sq,p in pm.items():\n            if not p or p.piece_type != chess.PAWN:\n                continue\n            f = chess.square_file(sq)\n            # isolated if no friendly pawn on adjacent files\n            adj = [ff for ff in (f-1, f+1) if 0 <= ff < 8]\n            has_adj = any(ff in pawn_files[p.color] for ff in adj)\n            if not has_adj:\n                isolated[p.color] += 1\n        return float(isolated[chess.BLACK] - isolated[chess.WHITE])\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Normalized queen mobility difference ((white - black) / max_possible)'\n    try:\n        orig = board.turn\n        try:\n            mobility = {chess.WHITE:0, chess.BLACK:0}\n            max_moves = 1.0\n            for color in (chess.WHITE, chess.BLACK):\n                board.turn = color\n                # gather queen squares\n                q_sqs = [sq for sq,p in board.piece_map().items() if p and p.piece_type == chess.QUEEN and p.color == color]\n                cnt = 0\n                for mv in board.legal_moves:\n                    if mv.from_square in q_sqs:\n                        cnt += 1\n                mobility[color] = cnt\n                max_moves = max(max_moves, float(cnt))\n            # normalize by a soft maximum to keep values stable\n            denom = max(1.0, mobility[chess.WHITE] + mobility[chess.BLACK])\n            return float((mobility[chess.WHITE] - mobility[chess.BLACK]) / denom)\n        finally:\n            board.turn = orig\n    except Exception:\n        try:\n            board.turn = orig\n        except Exception:\n            pass\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Direct king attackers weighted by attacker value (white attacking black king - black attacking white king)'\n    try:\n        vals = {chess.PAWN:1.0, chess.KNIGHT:3.0, chess.BISHOP:3.0, chess.ROOK:5.0, chess.QUEEN:9.0, chess.KING:0.0}\n        pm = board.piece_map()\n        def attackers_value_on_king(king_color):\n            king_sq = next((sq for sq,p in pm.items() if p and p.piece_type==chess.KING and p.color==king_color), None)\n            if king_sq is None:\n                return 0.0\n            opp = chess.BLACK if king_color == chess.WHITE else chess.WHITE\n            atks = board.attackers(opp, king_sq)\n            s = 0.0\n            for a in atks:\n                pa = pm.get(a)\n                if pa:\n                    s += vals.get(pa.piece_type, 0.0)\n            # extra bonus if king is currently in check\n            if board.is_check() and board.turn != king_color:\n                # if the other side is checking this king\n                s += 0.5\n            return s\n        w_on_b = attackers_value_on_king(chess.BLACK)\n        b_on_w = attackers_value_on_king(chess.WHITE)\n        return float(w_on_b - b_on_w)\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Side-to-move material advantage (positive favors White)'\n    try:\n        vals = {chess.PAWN:1.0, chess.KNIGHT:3.0, chess.BISHOP:3.0, chess.ROOK:5.0, chess.QUEEN:9.0, chess.KING:0.0}\n        pm = board.piece_map()\n        mat = {chess.WHITE:0.0, chess.BLACK:0.0}\n        for p in pm.values():\n            if not p: continue\n            mat[p.color] += vals.get(p.piece_type, 0.0)\n        diff = mat[chess.WHITE] - mat[chess.BLACK]\n        # if white to move, return diff; if black to move, return -diff\n        return float(diff if board.turn == chess.WHITE else -diff)\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Pawn majority imbalance: kingside vs queenside structural difference favoring White'\n    try:\n        pm = board.piece_map()\n        def pawn_counts():\n            wk = qb = 0\n            counts = {chess.WHITE:{'ks':0,'qs':0}, chess.BLACK:{'ks':0,'qs':0}}\n            for sq,p in pm.items():\n                if not p or p.piece_type != chess.PAWN: continue\n                f = chess.square_file(sq)\n                # define kingside as files e-h (4..7), queenside as a-d (0..3)\n                if 4 <= f <= 7:\n                    counts[p.color]['ks'] += 1\n                else:\n                    counts[p.color]['qs'] += 1\n            return counts\n        counts = pawn_counts()\n        # white majority on kingside minus queenside majority difference relative to black\n        white_diff = counts[chess.WHITE]['ks'] - counts[chess.WHITE]['qs']\n        black_diff = counts[chess.BLACK]['ks'] - counts[chess.BLACK]['qs']\n        return float((white_diff - black_diff))\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Minor-piece cohesion: average pairwise distance among bishops/knights (positive if White minors are tighter)'\n    try:\n        pm = board.piece_map()\n        def avg_pairwise_distance(color):\n            sqs = [sq for sq,p in pm.items() if p and p.color==color and p.piece_type in (chess.BISHOP, chess.KNIGHT)]\n            if len(sqs) < 2:\n                return 14.0  # large default distance if few pieces\n            total = 0.0; pairs = 0\n            for i in range(len(sqs)):\n                for j in range(i+1, len(sqs)):\n                    total += chess.square_distance(sqs[i], sqs[j])\n                    pairs += 1\n            return total / pairs if pairs > 0 else 14.0\n        aw = avg_pairwise_distance(chess.WHITE)\n        ab = avg_pairwise_distance(chess.BLACK)\n        # smaller average distance is better cohesion; return normalized difference (ab - aw) / 14\n        return float((ab - aw) / 14.0)\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Rooks on open/semi-open files: weighted count (open=1.0, semi-open=0.6) (white - black)'\n    try:\n        pm = board.piece_map()\n        # precompute pawns by file\n        pawn_files = {chess.WHITE:set(), chess.BLACK:set()}\n        for sq,p in pm.items():\n            if p and p.piece_type == chess.PAWN:\n                pawn_files[p.color].add(chess.square_file(sq))\n        def rook_score(color):\n            s = 0.0\n            for sq,p in pm.items():\n                if not p or p.piece_type != chess.ROOK or p.color != color:\n                    continue\n                f = chess.square_file(sq)\n                any_pawns_on_file = any(f in pawn_files[c] for c in (chess.WHITE, chess.BLACK))\n                friendly_pawn_on_file = f in pawn_files[color]\n                opp_pawn_on_file = f in pawn_files[chess.BLACK if color == chess.WHITE else chess.WHITE]\n                if not any_pawns_on_file:\n                    s += 1.0\n                elif not friendly_pawn_on_file and opp_pawn_on_file:\n                    s += 0.6\n            return s\n        return float(rook_score(chess.WHITE) - rook_score(chess.BLACK))\n    except Exception:\n        return 0.0\n",
    "def feature(board: chess.Board) -> float:\n    'Passed pawn potential: sum of passed-pawn scores (advanced & protected) (white - black)'\n    try:\n        pm = board.piece_map()\n        vals = {chess.WHITE: 0.0, chess.BLACK: 0.0}\n        for sq, p in pm.items():\n            if not p or p.piece_type != chess.PAWN:\n                continue\n            f = chess.square_file(sq)\n            r = chess.square_rank(sq)\n            color = p.color\n            opponent = chess.BLACK if color == chess.WHITE else chess.WHITE\n            # check for opposing pawns on same or adjacent files ahead of this pawn\n            blocked = False\n            for df in (-1, 0, 1):\n                ff = f + df\n                if not (0 <= ff <= 7):\n                    continue\n                for rs in range(r + (1 if color == chess.WHITE else -1),\n                                8 if color == chess.WHITE else -1,\n                                1 if color == chess.WHITE else -1):\n                    sq2 = chess.square(ff, rs)\n                    pp = pm.get(sq2)\n                    if pp and pp.piece_type == chess.PAWN and pp.color == opponent:\n                        blocked = True\n                        break\n                if blocked:\n                    break\n            if blocked:\n                continue\n            # advancement bonus: farther advanced is stronger\n            adv = (r / 7.0) if color == chess.WHITE else ((7 - r) / 7.0)\n            # protection bonus: friendly pawn on adjacent file behind or same rank\n            protect = 0.0\n            for df in (-1, 1):\n                ff = f + df\n                if 0 <= ff <= 7:\n                    behind_rank = r - 1 if color == chess.WHITE else r + 1\n                    if 0 <= behind_rank <= 7:\n                        sqp = chess.square(ff, behind_rank)\n                        pp = pm.get(sqp)\n                        if pp and pp.piece_type == chess.PAWN and pp.color == color:\n                            protect = 0.4\n                            break\n            score = 0.6 + 1.4 * adv + protect  # base + adv-weight + protect\n            vals[color] += score\n        return float(vals[chess.WHITE] - vals[chess.BLACK])\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Rook on 7th rank pressure: count/weight rooks occupying opponent 7th (white - black)'\n    try:\n        pm = board.piece_map()\n        score_w = 0.0\n        score_b = 0.0\n        for sq, p in pm.items():\n            if not p or p.piece_type != chess.ROOK:\n                continue\n            r = chess.square_rank(sq)\n            f = chess.square_file(sq)\n            if p.color == chess.WHITE and r == 6:  # white rook on 7th rank\n                # reward more if there are enemy pawns on that rank (targets)\n                enemy_pawns = sum(1 for ff in range(8) if (pm.get(chess.square(ff, 6)) and pm.get(chess.square(ff, 6)).piece_type == chess.PAWN and pm.get(chess.square(ff, 6)).color == chess.BLACK))\n                score_w += 1.0 + 0.4 * enemy_pawns\n            if p.color == chess.BLACK and r == 1:  # black rook on 2nd rank (black's 7th)\n                enemy_pawns = sum(1 for ff in range(8) if (pm.get(chess.square(ff, 1)) and pm.get(chess.square(ff, 1)).piece_type == chess.PAWN and pm.get(chess.square(ff, 1)).color == chess.WHITE))\n                score_b += 1.0 + 0.4 * enemy_pawns\n        return float(score_w - score_b)\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Hanging pieces value imbalance: sum of opponent-piece-values that are insufficiently defended (black_hung - white_hung) so positive favors White'\n    try:\n        vals = {chess.PAWN:1.0, chess.KNIGHT:3.0, chess.BISHOP:3.0, chess.ROOK:5.0, chess.QUEEN:9.0, chess.KING:0.0}\n        pm = board.piece_map()\n        hung = {chess.WHITE:0.0, chess.BLACK:0.0}\n        for sq, p in pm.items():\n            if not p:\n                continue\n            color = p.color\n            opp = chess.BLACK if color == chess.WHITE else chess.WHITE\n            attackers = len(list(board.attackers(opp, sq)))\n            defenders = len(list(board.attackers(color, sq)))\n            # hanging if attacked and defenders < attackers (or undefended and attacked)\n            if attackers > 0 and defenders < attackers:\n                # give more weight if completely undefended\n                mult = 1.6 if defenders == 0 else 1.0\n                hung[color] += vals.get(p.piece_type, 0.0) * mult\n        # black_hung is good for white => positive result\n        return float(hung[chess.BLACK] - hung[chess.WHITE])\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'King centralization bonus in reduced-material positions (black - white): positive when White''s king is more centralized in endgame'\n    try:\n        vals = {chess.PAWN:1.0, chess.KNIGHT:3.0, chess.BISHOP:3.0, chess.ROOK:5.0, chess.QUEEN:9.0}\n        pm = board.piece_map()\n        mat_nonpawn = 0.0\n        for p in pm.values():\n            if not p: continue\n            if p.piece_type != chess.PAWN and p.piece_type != chess.KING:\n                mat_nonpawn += vals.get(p.piece_type, 0.0)\n        # if many pieces remain, king centralization is less relevant\n        if mat_nonpawn > 14.0:\n            return 0.0\n        # find kings\n        wk = next((sq for sq,p in pm.items() if p and p.piece_type == chess.KING and p.color == chess.WHITE), None)\n        bk = next((sq for sq,p in pm.items() if p and p.piece_type == chess.KING and p.color == chess.BLACK), None)\n        if wk is None or bk is None:\n            return 0.0\n        centers = [chess.parse_square(s) for s in ('d4','e4','d5','e5')]\n        def central_closeness(ksq):\n            dists = [chess.square_distance(ksq, c) for c in centers]\n            mn = min(dists)\n            # normalize: closer => higher (max meaningful manhattan is 7 maybe), clamp\n            clos = max(0.0, (4.0 - float(mn)) / 4.0)\n            return clos\n        wc = central_closeness(wk)\n        bc = central_closeness(bk)\n        # positive when white king more centralized => return black - white so invert\n        return float(bc - wc)\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Pawn-structure weakness index (isolated, doubled, backward) imbalance (black - white): positive favors White if Black is weak'\n    try:\n        pm = board.piece_map()\n        file_counts = {chess.WHITE:[0]*8, chess.BLACK:[0]*8}\n        pawns_by_side = {chess.WHITE:[], chess.BLACK:[]}\n        for sq,p in pm.items():\n            if not p or p.piece_type != chess.PAWN:\n                continue\n            f = chess.square_file(sq); r = chess.square_rank(sq)\n            file_counts[p.color][f] += 1\n            pawns_by_side[p.color].append((sq, f, r))\n        def compute_weakness(color):\n            iso = 0\n            doubled = 0\n            backward = 0\n            opp = chess.BLACK if color == chess.WHITE else chess.WHITE\n            # isolated\n            for sq,f,r in pawns_by_side[color]:\n                adj_has = False\n                for df in (-1,1):\n                    ff = f + df\n                    if 0 <= ff <= 7 and file_counts[color][ff] > 0:\n                        adj_has = True\n                        break\n                if not adj_has:\n                    iso += 1\n            # doubled: sum of extras on files\n            for f in range(8):\n                if file_counts[color][f] > 1:\n                    doubled += file_counts[color][f] - 1\n            # backward: heuristic - pawn that has no friendly pawn on adjacent files behind and opponent pawn ahead blocking\n            for sq,f,r in pawns_by_side[color]:\n                behind_exists = False\n                for df in (-1,1):\n                    ff = f + df\n                    if 0 <= ff <= 7:\n                        # search for friendly pawn behind (closer to home)\n                        if color == chess.WHITE:\n                            for rr in range(0, r):\n                                if pm.get(chess.square(ff, rr)) and pm.get(chess.square(ff, rr)).piece_type == chess.PAWN and pm.get(chess.square(ff, rr)).color == color:\n                                    behind_exists = True; break\n                        else:\n                            for rr in range(r+1, 8):\n                                if pm.get(chess.square(ff, rr)) and pm.get(chess.square(ff, rr)).piece_type == chess.PAWN and pm.get(chess.square(ff, rr)).color == color:\n                                    behind_exists = True; break\n                    if behind_exists:\n                        break\n                if behind_exists:\n                    continue\n                # check if opponent pawn ahead on same or adjacent files\n                blocked_by_enemy = False\n                for df in (-1,0,1):\n                    ff = f + df\n                    if not (0 <= ff <= 7):\n                        continue\n                    if color == chess.WHITE:\n                        for rr in range(r+1, 8):\n                            pp = pm.get(chess.square(ff, rr))\n                            if pp and pp.piece_type == chess.PAWN and pp.color == opp:\n                                blocked_by_enemy = True; break\n                        if blocked_by_enemy: break\n                    else:\n                        for rr in range(0, r):\n                            pp = pm.get(chess.square(ff, rr))\n                            if pp and pp.piece_type == chess.PAWN and pp.color == opp:\n                                blocked_by_enemy = True; break\n                        if blocked_by_enemy: break\n                if blocked_by_enemy:\n                    backward += 1\n            # weight components\n            return 0.9 * iso + 0.8 * doubled + 0.7 * backward\n        w_weak = compute_weakness(chess.WHITE)\n        b_weak = compute_weakness(chess.BLACK)\n        return float(b_weak - w_weak)\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Minor-piece outpost advantage: count of knights/bishops on supported advanced central files (white - black)'\n    try:\n        pm = board.piece_map()\n        score = {chess.WHITE:0.0, chess.BLACK:0.0}\n        for sq,p in pm.items():\n            if not p or p.piece_type not in (chess.KNIGHT, chess.BISHOP):\n                continue\n            f = chess.square_file(sq); r = chess.square_rank(sq)\n            color = p.color\n            opp = chess.BLACK if color == chess.WHITE else chess.WHITE\n            # define candidate outpost region roughly in central files c-f and ranks 3-5 for white\n            if not (2 <= f <= 5):\n                continue\n            if color == chess.WHITE and r < 3:\n                continue\n            if color == chess.BLACK and r > 4:\n                continue\n            # is it supported by friendly pawn from behind on adjacent file?\n            supported = False\n            for df in (-1,1):\n                ff = f + df\n                if not (0 <= ff <= 7):\n                    continue\n                if color == chess.WHITE:\n                    behind_rank = r - 1\n                    if behind_rank >= 0:\n                        pp = pm.get(chess.square(ff, behind_rank))\n                        if pp and pp.piece_type == chess.PAWN and pp.color == color:\n                            supported = True; break\n                else:\n                    behind_rank = r + 1\n                    if behind_rank <= 7:\n                        pp = pm.get(chess.square(ff, behind_rank))\n                        if pp and pp.piece_type == chess.PAWN and pp.color == color:\n                            supported = True; break\n            if not supported:\n                continue\n            # ensure enemy pawns cannot easily challenge (no enemy pawn on same file ahead)\n            challenged = False\n            for df in (0,):\n                ff = f + df\n                if not (0 <= ff <= 7):\n                    continue\n                if color == chess.WHITE:\n                    for rr in range(r+1, 8):\n                        pp = pm.get(chess.square(ff, rr))\n                        if pp and pp.piece_type == chess.PAWN and pp.color == opp:\n                            challenged = True; break\n                    if challenged: break\n                else:\n                    for rr in range(0, r):\n                        pp = pm.get(chess.square(ff, rr))\n                        if pp and pp.piece_type == chess.PAWN and pp.color == opp:\n                            challenged = True; break\n                    if challenged: break\n            if supported and not challenged:\n                score[color] += 1.0 if p.piece_type == chess.KNIGHT else 0.7\n        return float(score[chess.WHITE] - score[chess.BLACK])\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Castled pawn-shield integrity for castled kings (white - black), penalizes missing shield pawns and attacks on shield squares'\n    try:\n        pm = board.piece_map()\n        def shield_score(color):\n            # find king\n            king_sq = next((sq for sq,p in pm.items() if p and p.piece_type == chess.KING and p.color == color), None)\n            if king_sq is None:\n                return 0.0\n            f = chess.square_file(king_sq); r = chess.square_rank(king_sq)\n            # identify typical castled squares for white/black\n            if color == chess.WHITE and (king_sq == chess.parse_square('g1') or king_sq == chess.parse_square('c1')):\n                if king_sq == chess.parse_square('g1'):\n                    shield_squares = [chess.parse_square(n) for n in ('f2','g2','h2')]\n                else:\n                    shield_squares = [chess.parse_square(n) for n in ('b2','c2','d2')]\n            elif color == chess.BLACK and (king_sq == chess.parse_square('g8') or king_sq == chess.parse_square('c8')):\n                if king_sq == chess.parse_square('g8'):\n                    shield_squares = [chess.parse_square(n) for n in ('f7','g7','h7')]\n                else:\n                    shield_squares = [chess.parse_square(n) for n in ('b7','c7','d7')]\n            else:\n                # not castled in a standard way; measure local pawns in 3x2 area in front of king\n                shield_squares = []\n                if color == chess.WHITE:\n                    dirs = [(df,1) for df in (-1,0,1)]\n                    for df,dr in dirs:\n                        ff = f + df; rr = r + dr\n                        if 0 <= ff <= 7 and 0 <= rr <= 7:\n                            shield_squares.append(chess.square(ff,rr))\n                else:\n                    dirs = [(df,-1) for df in (-1,0,1)]\n                    for df,dr in dirs:\n                        ff = f + df; rr = r + dr\n                        if 0 <= ff <= 7 and 0 <= rr <= 7:\n                            shield_squares.append(chess.square(ff,rr))\n            score = 0.0\n            opp = chess.BLACK if color == chess.WHITE else chess.WHITE\n            for sq in shield_squares:\n                p = pm.get(sq)\n                if p and p.piece_type == chess.PAWN and p.color == color:\n                    score += 1.0\n                # penalize if opponent attacks shield square\n                attackers = len(list(board.attackers(opp, sq)))\n                if attackers > 0:\n                    score -= 0.35 * attackers\n            return score\n        return float(shield_score(chess.WHITE) - shield_score(chess.BLACK))\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Mobility-to-material ratio: (white_mobility/(1+white_nonpawn_mat) - black_mobility/(1+black_nonpawn_mat))'\n    try:\n        vals = {chess.KNIGHT:3.0, chess.BISHOP:3.0, chess.ROOK:5.0, chess.QUEEN:9.0}\n        pm = board.piece_map()\n        mat = {chess.WHITE:0.0, chess.BLACK:0.0}\n        for p in pm.values():\n            if not p: continue\n            if p.piece_type in vals:\n                mat[p.color] += vals[p.piece_type]\n        orig = board.turn\n        try:\n            mob = {chess.WHITE:0.0, chess.BLACK:0.0}\n            for color in (chess.WHITE, chess.BLACK):\n                board.turn = color\n                mob[color] = sum(1 for _ in board.legal_moves)\n        finally:\n            board.turn = orig\n        w_ratio = mob[chess.WHITE] / (1.0 + mat[chess.WHITE])\n        b_ratio = mob[chess.BLACK] / (1.0 + mat[chess.BLACK])\n        return float(w_ratio - b_ratio)\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Tempo-adjusted mobility: mobility difference weighted by which side to move (positive favors White)'\n    try:\n        orig = board.turn\n        try:\n            board.turn = chess.WHITE\n            w_moves = sum(1 for _ in board.legal_moves)\n            board.turn = chess.BLACK\n            b_moves = sum(1 for _ in board.legal_moves)\n        finally:\n            board.turn = orig\n        total = max(1.0, w_moves + b_moves)\n        diff = (w_moves - b_moves) / total\n        # if White to move, tempo helps White (positive), if Black to move, it helps Black (negative for White)\n        sign = 1.0 if board.turn == chess.WHITE else -1.0\n        return float(diff * sign)\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Pinned material imbalance: sum of pinned-piece values (black_pinned - white_pinned), positive favors White'\n    try:\n        vals = {chess.PAWN:1.0, chess.KNIGHT:3.0, chess.BISHOP:3.0, chess.ROOK:5.0, chess.QUEEN:9.0, chess.KING:0.0}\n        pm = board.piece_map()\n        # find kings\n        kings = {chess.WHITE: None, chess.BLACK: None}\n        for sq,p in pm.items():\n            if p and p.piece_type == chess.KING:\n                kings[p.color] = sq\n        if kings[chess.WHITE] is None or kings[chess.BLACK] is None:\n            return 0.0\n        def on_same_line(a, b):\n            fa, ra = chess.square_file(a), chess.square_rank(a)\n            fb, rb = chess.square_file(b), chess.square_rank(b)\n            if fa == fb:\n                return (0, 1 if rb > ra else -1)\n            if ra == rb:\n                return (1 if fb > fa else -1, 0)\n            if abs(fa - fb) == abs(ra - rb):\n                df = 1 if fb > fa else -1\n                dr = 1 if rb > ra else -1\n                return (df, dr)\n            return None\n        pinned_value = {chess.WHITE:0.0, chess.BLACK:0.0}\n        for sq, p in pm.items():\n            if not p or p.piece_type == chess.KING:\n                continue\n            color = p.color\n            opp = chess.BLACK if color == chess.WHITE else chess.WHITE\n            king_sq = kings[color]\n            # look for sliding enemy attackers that share a line with king\n            pinned = False\n            for sq2, pe in pm.items():\n                if not pe or pe.color != opp or pe.piece_type not in (chess.ROOK, chess.BISHOP, chess.QUEEN):\n                    continue\n                step = on_same_line(sq2, king_sq)\n                if step is None:\n                    continue\n                # is the potential attacker aligned with king?\n                # check squares between attacker and king: count blockers\n                df, dr = step\n                # start from attacker moving towards king_sq\n                cur_f = chess.square_file(sq2)\n                cur_r = chess.square_rank(sq2)\n                blockers = []\n                while True:\n                    cur_f += df; cur_r += dr\n                    if not (0 <= cur_f <= 7 and 0 <= cur_r <= 7):\n                        break\n                    cur_sq = chess.square(cur_f, cur_r)\n                    if cur_sq == king_sq:\n                        break\n                    if pm.get(cur_sq):\n                        blockers.append(cur_sq)\n                        if len(blockers) > 1:\n                            break\n                if len(blockers) == 1 and blockers[0] == sq:\n                    # ensure attacker type can move along this vector (rook on orthogonal, bishop on diagonal, queen both)\n                    if pe.piece_type == chess.ROOK and (df == 0 or dr == 0):\n                        pinned = True; break\n                    if pe.piece_type == chess.BISHOP and (abs(df) == 1 and abs(dr) == 1):\n                        pinned = True; break\n                    if pe.piece_type == chess.QUEEN:\n                        pinned = True; break\n            if pinned:\n                pinned_value[color] += vals.get(p.piece_type, 0.0)\n        # black_pinned is good for white -> positive\n        return float(pinned_value[chess.BLACK] - pinned_value[chess.WHITE])\n    except Exception:\n        return 0.0\n",
    "def feature(board: chess.Board) -> float:\n    'Passed pawn potential: weighted sum of passed pawns by advancement (white - black)'\n    try:\n        pm = board.piece_map()\n        white_score = 0.0\n        black_score = 0.0\n        for sq, p in pm.items():\n            if not p or p.piece_type != chess.PAWN:\n                continue\n            f = chess.square_file(sq)\n            r = chess.square_rank(sq)\n            # check adjacent files for opposing pawns ahead (for white) or behind (for black)\n            files = [ff for ff in (f-1, f, f+1) if 0 <= ff < 8]\n            if p.color == chess.WHITE:\n                blocked = False\n                for ff in files:\n                    # any black pawn with rank > r on these files blocks passed status\n                    for rr in range(r+1, 8):\n                        sq2 = chess.square(ff, rr)\n                        pp = pm.get(sq2)\n                        if pp and pp.piece_type == chess.PAWN and pp.color == chess.BLACK:\n                            blocked = True\n                            break\n                    if blocked:\n                        break\n                if not blocked:\n                    # weight by advancement (more advanced pawns are more valuable)\n                    weight = float(r) / 7.0\n                    white_score += (0.8 + 1.2 * weight)\n            else:\n                blocked = False\n                for ff in files:\n                    # any white pawn with rank < r blocks black pawn\n                    for rr in range(0, r):\n                        sq2 = chess.square(ff, rr)\n                        pp = pm.get(sq2)\n                        if pp and pp.piece_type == chess.PAWN and pp.color == chess.WHITE:\n                            blocked = True\n                            break\n                    if blocked:\n                        break\n                if not blocked:\n                    weight = float(7 - r) / 7.0\n                    black_score += (0.8 + 1.2 * weight)\n        return float(white_score - black_score)\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Pawn-structure weaknesses: doubled and isolated pawn penalties (positive if opponent has more weaknesses)'\n    try:\n        pm = board.piece_map()\n        # count pawns per file\n        wp_file = [0]*8\n        bp_file = [0]*8\n        for sq,p in pm.items():\n            if not p or p.piece_type != chess.PAWN:\n                continue\n            f = chess.square_file(sq)\n            if p.color == chess.WHITE:\n                wp_file[f] += 1\n            else:\n                bp_file[f] += 1\n        def penalties(file_counts):\n            doubled = 0.0\n            isolated = 0.0\n            for f in range(8):\n                cnt = file_counts[f]\n                if cnt > 1:\n                    doubled += (cnt - 1) * 1.0  # penalty per extra pawn\n                if cnt > 0:\n                    left = file_counts[f-1] if f-1 >= 0 else 0\n                    right = file_counts[f+1] if f+1 <=7 else 0\n                    if left == 0 and right == 0:\n                        isolated += cnt * 1.2  # isolated pawns heavier penalty\n            return doubled + isolated\n        w_pen = penalties(wp_file)\n        b_pen = penalties(bp_file)\n        # return positive when Black is structurally worse (so White advantage)\n        return float(b_pen - w_pen)\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Control of central squares (d4,e4,d5,e5) weighted by attacker piece value (white - black)'\n    try:\n        center_names = ('d4','e4','d5','e5')\n        weights = {chess.PAWN:0.5, chess.KNIGHT:1.0, chess.BISHOP:1.0, chess.ROOK:1.5, chess.QUEEN:2.0, chess.KING:0.0}\n        pm = board.piece_map()\n        w = 0.0; b = 0.0\n        for name in center_names:\n            sq = chess.parse_square(name)\n            attackers_w = board.attackers(chess.WHITE, sq)\n            attackers_b = board.attackers(chess.BLACK, sq)\n            for a in attackers_w:\n                pa = pm.get(a)\n                if pa:\n                    w += weights.get(pa.piece_type, 0.0)\n            for a in attackers_b:\n                pa = pm.get(a)\n                if pa:\n                    b += weights.get(pa.piece_type, 0.0)\n        return float(w - b)\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Rook activity on open or semi-open files and on opponent half (white - black)'\n    try:\n        pm = board.piece_map()\n        # pawns present per file\n        pawns_on_file = [0]*8\n        white_pawns_on_file = [0]*8\n        black_pawns_on_file = [0]*8\n        for sq,p in pm.items():\n            if p and p.piece_type == chess.PAWN:\n                f = chess.square_file(sq)\n                pawns_on_file[f] += 1\n                if p.color == chess.WHITE:\n                    white_pawns_on_file[f] += 1\n                else:\n                    black_pawns_on_file[f] += 1\n        score_w = 0.0; score_b = 0.0\n        for sq,p in pm.items():\n            if not p or p.piece_type != chess.ROOK:\n                continue\n            f = chess.square_file(sq)\n            r = chess.square_rank(sq)\n            # open file (no pawns), semi-open (no friendly pawns)\n            if pawns_on_file[f] == 0:\n                base = 1.6\n            elif (p.color == chess.WHITE and white_pawns_on_file[f] == 0) or (p.color == chess.BLACK and black_pawns_on_file[f] == 0):\n                base = 1.1\n            else:\n                base = 0.0\n            # bonus for being deep in opponent half\n            bonus = 0.5 if (p.color == chess.WHITE and r >= 4) or (p.color == chess.BLACK and r <= 3) else 0.0\n            if p.color == chess.WHITE:\n                score_w += base + bonus\n            else:\n                score_b += base + bonus\n        return float(score_w - score_b)\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Queen safety vs mobility: mobility reward minus attacker penalty summed per queen (white - black)'\n    try:\n        pm = board.piece_map()\n        orig = board.turn\n        try:\n            mobility = {chess.WHITE: {}, chess.BLACK: {}}\n            for color in (chess.WHITE, chess.BLACK):\n                board.turn = color\n                # build mobility counts for pieces of that color\n                for mv in board.legal_moves:\n                    from_sq = mv.from_square\n                    mobility[color][from_sq] = mobility[color].get(from_sq, 0) + 1\n        finally:\n            board.turn = orig\n        score_w = 0.0; score_b = 0.0\n        for sq,p in pm.items():\n            if not p or p.piece_type != chess.QUEEN:\n                continue\n            opp = chess.BLACK if p.color == chess.WHITE else chess.WHITE\n            move_count = mobility.get(p.color, {}).get(sq, 0)\n            attackers = len(board.attackers(opp, sq))\n            # mobility helps, being attacked is costly\n            val = 0.18 * move_count - 1.15 * attackers\n            if p.color == chess.WHITE:\n                score_w += val\n            else:\n                score_b += val\n        return float(score_w - score_b)\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Knight outpost measure: knights in opponent half defended by a pawn and not attacked by enemy pawns (white - black)'\n    try:\n        pm = board.piece_map()\n        out_w = 0.0; out_b = 0.0\n        for sq,p in pm.items():\n            if not p or p.piece_type != chess.KNIGHT:\n                continue\n            f = chess.square_file(sq)\n            r = chess.square_rank(sq)\n            opp = chess.BLACK if p.color == chess.WHITE else chess.WHITE\n            attackers_of_color = board.attackers(p.color, sq)\n            attackers_of_opp = board.attackers(opp, sq)\n            # defended by a pawn?\n            defended_by_pawn = any((pm.get(a) and pm.get(a).piece_type == chess.PAWN) for a in attackers_of_color)\n            attacked_by_opp_pawn = any((pm.get(a) and pm.get(a).piece_type == chess.PAWN) for a in attackers_of_opp)\n            if p.color == chess.WHITE and r >= 4 and defended_by_pawn and not attacked_by_opp_pawn:\n                # more advanced outposts worth more\n                out_w += 0.8 + 0.3 * ((r - 4) / 3.0 if r > 4 else 0.0)\n            if p.color == chess.BLACK and r <= 3 and defended_by_pawn and not attacked_by_opp_pawn:\n                out_b += 0.8 + 0.3 * ((3 - r) / 3.0 if r < 3 else 0.0)\n        return float(out_w - out_b)\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'King pressure by heavy attackers on surrounding squares: (black king pressure - white king pressure) positive favors White'\n    try:\n        pm = board.piece_map()\n        def king_pressure(color):\n            king_sq = next((sq for sq,p in pm.items() if p and p.piece_type == chess.KING and p.color == color), None)\n            if king_sq is None:\n                return 0.0\n            f = chess.square_file(king_sq)\n            r = chess.square_rank(king_sq)\n            opp = chess.BLACK if color == chess.WHITE else chess.WHITE\n            pressure = 0.0\n            # examine 3x3 around king\n            for ff in range(max(0, f-1), min(7, f+1)+1):\n                for rr in range(max(0, r-1), min(7, r+1)+1):\n                    sq = chess.square(ff, rr)\n                    attackers = board.attackers(opp, sq)\n                    for a in attackers:\n                        pa = pm.get(a)\n                        if not pa:\n                            continue\n                        if pa.piece_type == chess.ROOK:\n                            pressure += 1.0\n                        elif pa.piece_type == chess.QUEEN:\n                            pressure += 1.6\n                        elif pa.piece_type == chess.BISHOP:\n                            pressure += 0.6\n                        elif pa.piece_type == chess.KNIGHT:\n                            pressure += 0.6\n                        elif pa.piece_type == chess.PAWN:\n                            pressure += 0.25\n            return pressure\n        kp_w = king_pressure(chess.WHITE)\n        kp_b = king_pressure(chess.BLACK)\n        # positive when Black king is under more pressure (good for White)\n        return float(kp_b - kp_w)\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Bishop-pair and open-diagonal control: favors color with bishop pair and more unobstructed diagonal reach (white - black)'\n    try:\n        pm = board.piece_map()\n        def diagonal_control_for_bishop(sq):\n            # count empty squares reachable along four diagonals before first blocker\n            total = 0\n            f0 = chess.square_file(sq)\n            r0 = chess.square_rank(sq)\n            for df, dr in ((1,1),(1,-1),(-1,1),(-1,-1)):\n                ff = f0 + df; rr = r0 + dr\n                while 0 <= ff < 8 and 0 <= rr < 8:\n                    s2 = chess.square(ff, rr)\n                    p2 = pm.get(s2)\n                    if p2:\n                        # blocked - do not count the square if it is occupied (we measure unobstructed reach)\n                        break\n                    total += 1\n                    ff += df; rr += dr\n            return total\n        score_w = 0.0; score_b = 0.0\n        # count bishops and open control\n        for sq,p in pm.items():\n            if not p or p.piece_type != chess.BISHOP:\n                continue\n            ctrl = diagonal_control_for_bishop(sq)\n            # normalize by maximum possible diagonal reach (~13)\n            normalized = float(ctrl) / 13.0\n            if p.color == chess.WHITE:\n                score_w += normalized\n            else:\n                score_b += normalized\n        # bishop pair bonus\n        w_bishops = sum(1 for p in pm.values() if p and p.piece_type==chess.BISHOP and p.color==chess.WHITE)\n        b_bishops = sum(1 for p in pm.values() if p and p.piece_type==chess.BISHOP and p.color==chess.BLACK)\n        pair_bonus = 1.0\n        score_w += pair_bonus if w_bishops >= 2 else 0.0\n        score_b += pair_bonus if b_bishops >= 2 else 0.0\n        return float(score_w - score_b)\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Activity to material ratio for non-pawn pieces: (white_ratio - black_ratio)'\n    try:\n        vals = {chess.KNIGHT:3.0, chess.BISHOP:3.0, chess.ROOK:5.0, chess.QUEEN:9.0}\n        pm = board.piece_map()\n        mat = {chess.WHITE:0.0, chess.BLACK:0.0}\n        # non-pawn material\n        for p in pm.values():\n            if not p: continue\n            if p.piece_type in vals:\n                mat[p.color] += vals[p.piece_type]\n        # mobility: count moves from non-pawn non-king pieces by toggling turn\n        orig = board.turn\n        try:\n            mobi = {chess.WHITE:0, chess.BLACK:0}\n            for color in (chess.WHITE, chess.BLACK):\n                board.turn = color\n                for mv in board.legal_moves:\n                    p = board.piece_at(mv.from_square)\n                    if p and p.piece_type not in (chess.PAWN, chess.KING) and p.color == color:\n                        mobi[color] += 1\n        finally:\n            board.turn = orig\n        ratio_w = mobi[chess.WHITE] / (mat[chess.WHITE] + 0.1)\n        ratio_b = mobi[chess.BLACK] / (mat[chess.BLACK] + 0.1)\n        return float(ratio_w - ratio_b)\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Drawishness heuristic combining halfmove clock, insufficient material, low mobility and low material (higher = more drawish)'\n    try:\n        pm = board.piece_map()\n        # material total (pawns count 1)\n        vals = {chess.PAWN:1.0, chess.KNIGHT:3.0, chess.BISHOP:3.0, chess.ROOK:5.0, chess.QUEEN:9.0, chess.KING:0.0}\n        total_mat = 0.0\n        for p in pm.values():\n            if p:\n                total_mat += vals.get(p.piece_type, 0.0)\n        # mobility total\n        orig = board.turn\n        try:\n            w_moves = 0; b_moves = 0\n            board.turn = chess.WHITE\n            w_moves = sum(1 for _ in board.legal_moves)\n            board.turn = chess.BLACK\n            b_moves = sum(1 for _ in board.legal_moves)\n        finally:\n            board.turn = orig\n        mobility = float(w_moves + b_moves)\n        # halfmove clock normalized (50-move rule threshold)\n        hm = float(board.halfmove_clock)\n        halfmove_factor = min(1.0, hm / 50.0)\n        # insufficient material check\n        insuff = 1.0 if board.is_insufficient_material() else 0.0\n        # low material factor (more drawish when materially low)\n        low_mat = max(0.0, (12.0 - total_mat) / 12.0)  # scaled 0..1\n        # low mobility factor\n        low_mob = max(0.0, (60.0 - mobility) / 60.0)\n        # combine: weight draw-promoting signals\n        draw_score = 0.45 * halfmove_factor + 0.35 * low_mat + 0.15 * low_mob + 0.5 * insuff\n        # clamp 0..1 and return\n        draw_score = max(0.0, min(1.0, draw_score))\n        return float(draw_score)\n    except Exception:\n        return 0.0\n",
    "def feature(board: chess.Board) -> float:\n    'Pawn-structure fragility: weighted count of isolated, doubled and backward pawns (white - black)'\n    try:\n        pm = board.piece_map()\n        vals = {'isolated': 0.9, 'doubled': 0.6, 'backward': 1.2}\n        files_pawns = {f: {chess.WHITE: [], chess.BLACK: []} for f in range(8)}\n        for sq, p in pm.items():\n            if not p or p.piece_type != chess.PAWN:\n                continue\n            f = chess.square_file(sq)\n            files_pawns[f][p.color].append(sq)\n        def pawn_fragility(color):\n            opp = chess.BLACK if color == chess.WHITE else chess.WHITE\n            score = 0.0\n            # isolated: no friendly pawns on adjacent files\n            for f in range(8):\n                for sq in files_pawns[f][color]:\n                    left = f - 1\n                    right = f + 1\n                    isolated = True\n                    for ff in (left, right):\n                        if 0 <= ff < 8 and len(files_pawns[ff][color]) > 0:\n                            isolated = False\n                            break\n                    if isolated:\n                        score += vals['isolated']\n            # doubled: more than one pawn on same file\n            for f in range(8):\n                cnt = len(files_pawns[f][color])\n                if cnt > 1:\n                    score += (cnt - 1) * vals['doubled']\n            # backward: heuristic - pawn whose forward square is attacked by opponent and has no friendly pawn on adjacent files behind\n            for sq, p in pm.items():\n                if not p or p.piece_type != chess.PAWN or p.color != color:\n                    continue\n                f = chess.square_file(sq); r = chess.square_rank(sq)\n                if color == chess.WHITE:\n                    forward_r = r + 1\n                    behind_r = r - 1\n                    if forward_r >= 8:\n                        continue\n                    forward_sq = chess.square(f, forward_r)\n                    # forward occupied or attacked by opponent\n                    forward_blocked = (pm.get(forward_sq) is not None)\n                    attacked = bool(board.attackers(opp, forward_sq))\n                    support_behind = False\n                    for ff in (f-1, f, f+1):\n                        if 0 <= ff < 8 and behind_r >= 0:\n                            sqb = chess.square(ff, behind_r)\n                            p2 = pm.get(sqb)\n                            if p2 and p2.piece_type == chess.PAWN and p2.color == color:\n                                support_behind = True\n                                break\n                    if (forward_blocked or attacked) and not support_behind:\n                        score += vals['backward']\n                else:\n                    forward_r = r - 1\n                    behind_r = r + 1\n                    if forward_r < 0:\n                        continue\n                    forward_sq = chess.square(f, forward_r)\n                    forward_blocked = (pm.get(forward_sq) is not None)\n                    attacked = bool(board.attackers(opp, forward_sq))\n                    support_behind = False\n                    for ff in (f-1, f, f+1):\n                        if 0 <= ff < 8 and behind_r < 8:\n                            sqb = chess.square(ff, behind_r)\n                            p2 = pm.get(sqb)\n                            if p2 and p2.piece_type == chess.PAWN and p2.color == color:\n                                support_behind = True\n                                break\n                    if (forward_blocked or attacked) and not support_behind:\n                        score += vals['backward']\n            return score\n        return float(pawn_fragility(chess.WHITE) - pawn_fragility(chess.BLACK))\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Hanging high-value pieces: sum of attacked-but-underdefended non-pawn piece values (white - black)'\n    try:\n        pm = board.piece_map()\n        vals = {chess.KNIGHT:3.0, chess.BISHOP:3.0, chess.ROOK:5.0, chess.QUEEN:9.0, chess.KING:0.0}\n        def hanging_sum(color):\n            opp = chess.BLACK if color == chess.WHITE else chess.WHITE\n            s = 0.0\n            for sq, p in pm.items():\n                if not p or p.color != color or p.piece_type == chess.PAWN:\n                    continue\n                attackers = board.attackers(opp, sq)\n                if not attackers:\n                    continue\n                defenders = board.attackers(color, sq)\n                # approximate underdefended if attackers > defenders (defenders may include the piece itself attacking?)\n                if len(attackers) > len(defenders):\n                    s += vals.get(p.piece_type, 0.0)\n            return s\n        return float(hanging_sum(chess.WHITE) - hanging_sum(chess.BLACK))\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Passed-pawn progress: sum of normalized advancement for passed pawns (white - black)'\n    try:\n        pm = board.piece_map()\n        def is_passed(sq, color):\n            f = chess.square_file(sq); r = chess.square_rank(sq)\n            opp = chess.BLACK if color == chess.WHITE else chess.WHITE\n            if color == chess.WHITE:\n                for f2 in (f-1,f,f+1):\n                    if 0 <= f2 < 8:\n                        for rr in range(r+1,8):\n                            p = pm.get(chess.square(f2,rr))\n                            if p and p.piece_type == chess.PAWN and p.color == opp:\n                                return False\n                return True\n            else:\n                for f2 in (f-1,f,f+1):\n                    if 0 <= f2 < 8:\n                        for rr in range(0,r):\n                            p = pm.get(chess.square(f2,rr))\n                            if p and p.piece_type == chess.PAWN and p.color == opp:\n                                return False\n                return True\n        score_w = 0.0; score_b = 0.0\n        for sq, p in pm.items():\n            if not p or p.piece_type != chess.PAWN:\n                continue\n            if not is_passed(sq, p.color):\n                continue\n            r = chess.square_rank(sq)\n            if p.color == chess.WHITE:\n                progress = r / 7.0\n                score_w += progress\n            else:\n                progress = (7 - r) / 7.0\n                score_b += progress\n        return float(score_w - score_b)\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'King centralization in low-material positions: normalized closeness to center when total non-king material low (white - black)'\n    try:\n        pm = board.piece_map()\n        vals = {chess.PAWN:1.0, chess.KNIGHT:3.0, chess.BISHOP:3.0, chess.ROOK:5.0, chess.QUEEN:9.0}\n        total_mat = 0.0\n        for p in pm.values():\n            if p:\n                total_mat += vals.get(p.piece_type, 0.0)\n        # only meaningful in endgameish situations\n        if total_mat > 14.0:\n            # return small value diminishing effect outside endgames\n            scale = 0.5\n        else:\n            scale = 1.0\n        # center defined as square (3.5,3.5) max manhattan distance to center is 7? We'll use max 7\n        def center_closeness(color):\n            ksq = next((sq for sq,p in pm.items() if p and p.piece_type == chess.KING and p.color == color), None)\n            if ksq is None:\n                return 0.0\n            # compute manhattan distance to central point (3.5,3.5) approximated by min distance to 4 central squares\n            center_sqs = [chess.parse_square(s) if isinstance(s,str) else None for s in []]  # placeholder avoid lint\n            # use distance to nearest of d4,e4,d5,e5\n            centers = [chess.parse_square('d4'), chess.parse_square('e4'), chess.parse_square('d5'), chess.parse_square('e5')]\n            dmin = min(chess.square_distance(ksq, c) for c in centers)\n            closeness = (14.0 - float(dmin)) / 14.0  # normalize similar to king distance scale\n            return closeness\n        return float(scale * (center_closeness(chess.WHITE) - center_closeness(chess.BLACK)))\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Bishop-pair mobility and scope: mobility (legal moves) for bishops and open-diagonal presence (white - black)'\n    try:\n        pm = board.piece_map()\n        orig = board.turn\n        try:\n            def bishop_score(color):\n                score = 0.0\n                board.turn = color\n                # mobility: count legal moves by bishops\n                mobility = 0\n                bishops = 0\n                for mv in board.legal_moves:\n                    p = board.piece_at(mv.from_square)\n                    if p and p.piece_type == chess.BISHOP and p.color == color:\n                        mobility += 1\n                for sq,p in pm.items():\n                    if p and p.piece_type == chess.BISHOP and p.color == color:\n                        bishops += 1\n                        # check if bishop is unobstructed to long diagonal (heuristic: adjacent diagonal ray has empty squares)\n                        f = chess.square_file(sq); r = chess.square_rank(sq)\n                        unobstructed = 0\n                        for df, dr in ((1,1),(1,-1),(-1,1),(-1,-1)):\n                            steps = 0\n                            ff, rr = f+df, r+dr\n                            while 0 <= ff < 8 and 0 <= rr < 8 and steps < 7:\n                                if pm.get(chess.square(ff,rr)):\n                                    break\n                                steps += 1\n                                ff += df; rr += dr\n                            unobstructed += steps\n                        score += 0.1 * unobstructed\n                # mobility normalized by number of bishops (avoid division by zero)\n                score += (mobility / max(1.0, max(1, bishops))) * 0.45\n                # bishop pair bonus\n                if bishops >= 2:\n                    score += 0.6\n                return score\n            return float(bishop_score(chess.WHITE) - bishop_score(chess.BLACK))\n        finally:\n            board.turn = orig\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Rooks behind passed pawns: count of rooks supporting passed pawns on same file (white - black)'\n    try:\n        pm = board.piece_map()\n        def is_passed(sq, color):\n            f = chess.square_file(sq); r = chess.square_rank(sq)\n            opp = chess.BLACK if color == chess.WHITE else chess.WHITE\n            if color == chess.WHITE:\n                for f2 in (f-1,f,f+1):\n                    if 0 <= f2 < 8:\n                        for rr in range(r+1,8):\n                            p = pm.get(chess.square(f2,rr))\n                            if p and p.piece_type == chess.PAWN and p.color == opp:\n                                return False\n                return True\n            else:\n                for f2 in (f-1,f,f+1):\n                    if 0 <= f2 < 8:\n                        for rr in range(0,r):\n                            p = pm.get(chess.square(f2,rr))\n                            if p and p.piece_type == chess.PAWN and p.color == opp:\n                                return False\n                return True\n        def score(color):\n            s = 0.0\n            for sq, p in pm.items():\n                if not p or p.piece_type != chess.PAWN or p.color != color:\n                    continue\n                if not is_passed(sq, color):\n                    continue\n                f = chess.square_file(sq); r = chess.square_rank(sq)\n                for sq2, p2 in pm.items():\n                    if not p2 or p2.color != color or p2.piece_type != chess.ROOK:\n                        continue\n                    rf = chess.square_file(sq2); rr = chess.square_rank(sq2)\n                    if rf != f:\n                        continue\n                    # rook behind pawn: for white rook rank < pawn rank\n                    if color == chess.WHITE and rr < r:\n                        s += 1.0\n                    if color == chess.BLACK and rr > r:\n                        s += 1.0\n            return s\n        return float(score(chess.WHITE) - score(chess.BLACK))\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Central-square control: weighted attackers of d4,e4,d5,e5 by piece value (white - black)'\n    try:\n        centers = [chess.parse_square('d4'), chess.parse_square('e4'), chess.parse_square('d5'), chess.parse_square('e5')]\n        pm = board.piece_map()\n        vals = {chess.PAWN:1.0, chess.KNIGHT:3.0, chess.BISHOP:3.0, chess.ROOK:5.0, chess.QUEEN:9.0, chess.KING:0.0}\n        control = {chess.WHITE:0.0, chess.BLACK:0.0}\n        for c in centers:\n            for color in (chess.WHITE, chess.BLACK):\n                attackers = board.attackers(color, c)\n                for a in attackers:\n                    pa = pm.get(a)\n                    if pa:\n                        # weight central control by piece value and give pawns smaller influence\n                        control[color] += vals.get(pa.piece_type, 0.0) * 0.28\n        return float(control[chess.WHITE] - control[chess.BLACK])\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Pressure on opponent 7th/2nd rank: rooks/queens attacking or occupying the opponent pawn rank (white - black)'\n    try:\n        pm = board.piece_map()\n        score = {chess.WHITE:0.0, chess.BLACK:0.0}\n        # for white, opponent 7th rank is rank 6; for black it's rank 1\n        targets = {chess.WHITE:6, chess.BLACK:1}\n        for color in (chess.WHITE, chess.BLACK):\n            tr = targets[color]\n            for f in range(8):\n                sq = chess.square(f, tr)\n                # occupied by our heavy piece (rook/queen) on enemy rank\n                p = pm.get(sq)\n                if p and p.color == color and p.piece_type in (chess.ROOK, chess.QUEEN):\n                    score[color] += 1.2\n                # attacked by our rooks/queens\n                attackers = board.attackers(color, sq)\n                for a in attackers:\n                    pa = pm.get(a)\n                    if pa and pa.piece_type in (chess.ROOK, chess.QUEEN) and pa.color == color:\n                        score[color] += 0.6\n        return float(score[chess.WHITE] - score[chess.BLACK])\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Trapped minor pieces: fraction of knights/bishops with very low mobility and attacked (white - black)'\n    try:\n        pm = board.piece_map()\n        orig = board.turn\n        try:\n            trapped = {chess.WHITE:0.0, chess.BLACK:0.0}\n            counts = {chess.WHITE:0.0, chess.BLACK:0.0}\n            for color in (chess.WHITE, chess.BLACK):\n                board.turn = color\n                mobility_by_sq = {}\n                for mv in board.legal_moves:\n                    p = board.piece_at(mv.from_square)\n                    if p and p.piece_type in (chess.KNIGHT, chess.BISHOP) and p.color == color:\n                        mobility_by_sq[mv.from_square] = mobility_by_sq.get(mv.from_square, 0) + 1\n                for sq, p in pm.items():\n                    if not p or p.color != color or p.piece_type not in (chess.KNIGHT, chess.BISHOP):\n                        continue\n                    counts[color] += 1.0\n                    moves = mobility_by_sq.get(sq, 0)\n                    attacked = bool(board.attackers(chess.BLACK if color == chess.WHITE else chess.WHITE, sq))\n                    if moves <= 2 and attacked:\n                        trapped[color] += 1.0\n            # return fraction difference (white - black)\n            frac_w = trapped[chess.WHITE] / max(1.0, counts[chess.WHITE])\n            frac_b = trapped[chess.BLACK] / max(1.0, counts[chess.BLACK])\n            return float(frac_w - frac_b)\n        finally:\n            board.turn = orig\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Tactical-initiative proxy: difference in number of immediate forcing moves (captures/promotions) available (white - black)'\n    try:\n        pm = board.piece_map()\n        orig = board.turn\n        try:\n            force = {chess.WHITE:0.0, chess.BLACK:0.0}\n            for color in (chess.WHITE, chess.BLACK):\n                board.turn = color\n                for mv in board.legal_moves:\n                    # treat as forcing if it captures a piece (simple) or promotes\n                    capture = (pm.get(mv.to_square) is not None)\n                    # promotion detection: move has promotion attribute; avoid relying on API not listed - approximate by landing on last rank with pawn from penultimate rank\n                    promo = False\n                    p = pm.get(mv.from_square)\n                    if p and p.piece_type == chess.PAWN:\n                        tr = chess.square_rank(mv.to_square)\n                        if (color == chess.WHITE and tr == 7) or (color == chess.BLACK and tr == 0):\n                            promo = True\n                    if capture or promo:\n                        weight = 1.0 if capture else 1.4\n                        force[color] += weight\n            return float(force[chess.WHITE] - force[chess.BLACK])\n        finally:\n            board.turn = orig\n    except Exception:\n        return 0.0\n",
    "def feature(board: chess.Board) -> float:\n    'Passed pawn pressure: counts passed pawns weighted by advancement and pawn support (white - black)'\n    try:\n        pm = board.piece_map()\n        def is_passed(sq, color):\n            f = chess.square_file(sq)\n            r = chess.square_rank(sq)\n            opp = chess.BLACK if color == chess.WHITE else chess.WHITE\n            # For each enemy pawn, if it's on the same file or adjacent files and is ahead (toward promotion)\n            for ff in (f-1, f, f+1):\n                if 0 <= ff < 8:\n                    # check enemy pawns on all ranks that would block/provide opposition\n                    if color == chess.WHITE:\n                        # enemy pawns on ranks > r (ahead of the pawn) block passage\n                        for rr in range(r+1, 8):\n                            sq2 = chess.square(ff, rr)\n                            p2 = pm.get(sq2)\n                            if p2 and p2.piece_type == chess.PAWN and p2.color == opp:\n                                return False\n                    else:\n                        for rr in range(0, r):\n                            sq2 = chess.square(ff, rr)\n                            p2 = pm.get(sq2)\n                            if p2 and p2.piece_type == chess.PAWN and p2.color == opp:\n                                return False\n            return True\n        score = {chess.WHITE:0.0, chess.BLACK:0.0}\n        for sq, p in pm.items():\n            if not p or p.piece_type != chess.PAWN:\n                continue\n            color = p.color\n            r = chess.square_rank(sq)\n            # advancement factor: more advanced pawns are more valuable\n            adv = (r / 7.0) if color == chess.WHITE else ((7 - r) / 7.0)\n            # support: count friendly pawns that attack or defend this pawn\n            sup = 0.0\n            for a in board.attackers(color, sq):\n                pa = pm.get(a)\n                if pa and pa.piece_type == chess.PAWN:\n                    sup += 0.5\n            if is_passed(sq, color):\n                score[color] += 1.8 * adv + 0.6 * sup\n            else:\n                # protected advanced pawn still has modest value\n                score[color] += 0.35 * adv + 0.2 * sup\n        return float(score[chess.WHITE] - score[chess.BLACK])\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Pawn structure weakness: combined penalty for doubled, isolated and pawn-island count (positive favors White when Black is worse)'\n    try:\n        pm = board.piece_map()\n        pawns_on_file = {f: {chess.WHITE:0, chess.BLACK:0} for f in range(8)}\n        files_with_pawn = {chess.WHITE:set(), chess.BLACK:set()}\n        for sq, p in pm.items():\n            if p and p.piece_type == chess.PAWN:\n                f = chess.square_file(sq)\n                pawns_on_file[f][p.color] += 1\n                files_with_pawn[p.color].add(f)\n        def structure_penalty(color):\n            doubled = sum(1 for f in range(8) if pawns_on_file[f][color] > 1)\n            # isolated: pawn on file with no friendly pawns adjacent\n            isolated = 0\n            for f in files_with_pawn[color]:\n                if (f-1 not in files_with_pawn[color]) and (f+1 not in files_with_pawn[color]):\n                    isolated += 1\n            # pawn islands: contiguous groups of pawn files\n            files = sorted(list(files_with_pawn[color]))\n            islands = 0\n            i = 0\n            while i < len(files):\n                islands += 1\n                j = i+1\n                while j < len(files) and files[j] == files[j-1] + 1:\n                    j += 1\n                i = j\n            # weighted penalty\n            return 0.85 * doubled + 0.9 * isolated + 0.6 * islands\n        pen_w = structure_penalty(chess.WHITE)\n        pen_b = structure_penalty(chess.BLACK)\n        # positive when Black has worse structure (pen_b > pen_w)\n        return float(pen_b - pen_w)\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Rook seventh-rank and open-file pressure (white - black): rooks on opponent seventh and rooks on open/semi-open files'\n    try:\n        pm = board.piece_map()\n        pawns_on_file = [0]*8\n        pawns_color_on_file = [{chess.WHITE:0, chess.BLACK:0} for _ in range(8)]\n        for sq, p in pm.items():\n            if p and p.piece_type == chess.PAWN:\n                f = chess.square_file(sq)\n                pawns_on_file[f] += 1\n                pawns_color_on_file[f][p.color] += 1\n        score = {chess.WHITE:0.0, chess.BLACK:0.0}\n        for sq, p in pm.items():\n            if not p or p.piece_type != chess.ROOK:\n                continue\n            f = chess.square_file(sq)\n            r = chess.square_rank(sq)\n            # seventh rank: for white, seventh is rank 6; for black seventh is rank 1\n            if p.color == chess.WHITE:\n                if r == 6:\n                    score[chess.WHITE] += 1.6\n            else:\n                if r == 1:\n                    score[chess.BLACK] += 1.6\n            # open / semi-open file bonus\n            if pawns_on_file[f] == 0:\n                score[p.color] += 0.9\n            elif pawns_color_on_file[f][p.color] == 0:\n                score[p.color] += 0.45\n        return float(score[chess.WHITE] - score[chess.BLACK])\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Tactical potential: difference in available capture and checking moves (white - black), normalized'\n    try:\n        orig = board.turn\n        try:\n            stats = {chess.WHITE:{'caps':0,'checks':0,'tot':0}, chess.BLACK:{'caps':0,'checks':0,'tot':0}}\n            for color in (chess.WHITE, chess.BLACK):\n                board.turn = color\n                for mv in board.legal_moves:\n                    stats[color]['tot'] += 1\n                    if mv.drop is None and mv.capture:\n                        stats[color]['caps'] += 1\n                    # determine if move gives check by pushing and testing\n                    try:\n                        board.push(mv)\n                        if board.is_check():\n                            stats[color]['checks'] += 1\n                        board.pop()\n                    except Exception:\n                        # if move push/pop fails, ignore this move's check detection\n                        try:\n                            # attempt to restore if partially modified\n                            board.pop()\n                        except Exception:\n                            pass\n            # combine captures and checks giving more weight to checks\n            w_val = stats[chess.WHITE]['caps'] * 0.9 + stats[chess.WHITE]['checks'] * 1.6\n            b_val = stats[chess.BLACK]['caps'] * 0.9 + stats[chess.BLACK]['checks'] * 1.6\n            denom = max(1.0, w_val + b_val)\n            return float((w_val - b_val) / denom)\n        finally:\n            board.turn = orig\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Queen activity and exposure: mobility minus being attacked (white - black)'\n    try:\n        pm = board.piece_map()\n        orig = board.turn\n        try:\n            scores = {chess.WHITE:0.0, chess.BLACK:0.0}\n            for color in (chess.WHITE, chess.BLACK):\n                mobility = 0\n                attacked = 0\n                board.turn = color\n                for mv in board.legal_moves:\n                    p = board.piece_at(mv.from_square)\n                    if p and p.piece_type == chess.QUEEN and p.color == color:\n                        mobility += 1\n                # queen attacked count\n                for sq, p in pm.items():\n                    if p and p.piece_type == chess.QUEEN and p.color == color:\n                        attackers = len(board.attackers(chess.BLACK if color == chess.WHITE else chess.WHITE, sq))\n                        attacked += attackers\n                        # bonus if on open file\n                        f = chess.square_file(sq)\n                        # open file if no pawns\n                        pawns_here = any((pp and pp.piece_type == chess.PAWN) for s2, pp in pm.items() if chess.square_file(s2) == f)\n                        if not pawns_here:\n                            mobility += 0.9\n                        # advanced centralization bonus\n                        r = chess.square_rank(sq)\n                        central_files = (3,4)\n                        if f in central_files and (2 <= r <= 5):\n                            mobility += 0.6\n                scores[color] = 0.12 * mobility - 0.25 * attacked\n        finally:\n            board.turn = orig\n        return float(scores[chess.WHITE] - scores[chess.BLACK])\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Outpost knights: count of knights on outpost squares (supported by pawns and not attacked by enemy pawns) (white - black)'\n    try:\n        pm = board.piece_map()\n        def outpost_count(color):\n            opp = chess.BLACK if color == chess.WHITE else chess.WHITE\n            cnt = 0.0\n            for sq, p in pm.items():\n                if not p or p.piece_type != chess.KNIGHT or p.color != color:\n                    continue\n                r = chess.square_rank(sq)\n                # require reasonably advanced ranks for outpost\n                if color == chess.WHITE and r < 3:\n                    continue\n                if color == chess.BLACK and r > 4:\n                    continue\n                # not attacked by enemy pawns\n                pawn_attackers = 0\n                for a in board.attackers(opp, sq):\n                    pa = pm.get(a)\n                    if pa and pa.piece_type == chess.PAWN:\n                        pawn_attackers += 1\n                if pawn_attackers > 0:\n                    continue\n                # supported by a friendly pawn (pawn defender)\n                pawn_support = 0\n                for a in board.attackers(color, sq):\n                    pa = pm.get(a)\n                    if pa and pa.piece_type == chess.PAWN:\n                        pawn_support += 1\n                if pawn_support > 0:\n                    cnt += 1.0 + 0.5 * pawn_support\n            return cnt\n        return float(outpost_count(chess.WHITE) - outpost_count(chess.BLACK))\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Trapped/immobile major pieces: counts of non-king pieces that are attacked more than defended and have <=1 legal moves (black - white), positive favors White'\n    try:\n        pm = board.piece_map()\n        orig = board.turn\n        try:\n            trapped = {chess.WHITE:0.0, chess.BLACK:0.0}\n            for color in (chess.WHITE, chess.BLACK):\n                board.turn = color\n                # precompute defenders/attackers\n                for sq, p in pm.items():\n                    if not p or p.piece_type == chess.KING or p.color != color:\n                        continue\n                    attackers = len(board.attackers(chess.BLACK if color == chess.WHITE else chess.WHITE, sq))\n                    defenders = len(board.attackers(color, sq))\n                    # count legal moves for this piece\n                    moves_for_piece = 0\n                    for mv in board.legal_moves:\n                        if mv.from_square == sq:\n                            moves_for_piece += 1\n                            if moves_for_piece > 1:\n                                break\n                    if attackers > defenders and moves_for_piece <= 1:\n                        # weight by piece value\n                        val = 0.0\n                        if p.piece_type == chess.QUEEN:\n                            val = 1.6\n                        elif p.piece_type == chess.ROOK:\n                            val = 1.1\n                        else:\n                            val = 0.6\n                        trapped[color] += val\n            # return trapped_black - trapped_white so positive when Black is worse\n            return float(trapped[chess.BLACK] - trapped[chess.WHITE])\n        finally:\n            board.turn = orig\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Minor vs major piece tilt: (white minor - white major) - (black minor - black major); positive favors White minor advantage'\n    try:\n        pm = board.piece_map()\n        vals = {chess.KNIGHT:1.0, chess.BISHOP:1.0, chess.ROOK:1.0, chess.QUEEN:2.0}\n        minor = {chess.WHITE:0.0, chess.BLACK:0.0}\n        major = {chess.WHITE:0.0, chess.BLACK:0.0}\n        for sq, p in pm.items():\n            if not p:\n                continue\n            if p.piece_type in (chess.KNIGHT, chess.BISHOP):\n                minor[p.color] += 1.0\n            if p.piece_type in (chess.ROOK, chess.QUEEN):\n                major[p.color] += 1.0\n        tilt_w = minor[chess.WHITE] - major[chess.WHITE]\n        tilt_b = minor[chess.BLACK] - major[chess.BLACK]\n        return float(tilt_w - tilt_b)\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'King pressure: weighted sum of attacking piece values within distance 2 of opponent king (pressure_on_black - pressure_on_white); positive favors White'\n    try:\n        pm = board.piece_map()\n        # find kings\n        wk = next((sq for sq,p in pm.items() if p and p.piece_type == chess.KING and p.color == chess.WHITE), None)\n        bk = next((sq for sq,p in pm.items() if p and p.piece_type == chess.KING and p.color == chess.BLACK), None)\n        if wk is None or bk is None:\n            return 0.0\n        vals = {chess.PAWN:1.0, chess.KNIGHT:3.0, chess.BISHOP:3.0, chess.ROOK:5.0, chess.QUEEN:9.0, chess.KING:0.0}\n        def pressure_on(square, by_color):\n            total = 0.0\n            for sq2, p in pm.items():\n                if not p or p.color != by_color:\n                    continue\n                d = chess.square_distance(sq2, square)\n                if d <= 2:\n                    # closer pieces count more\n                    weight = max(0.2, (3.0 - float(d)) / 3.0)\n                    total += vals.get(p.piece_type, 0.0) * weight\n            return total\n        p_on_b = pressure_on(bk, chess.WHITE)\n        p_on_w = pressure_on(wk, chess.BLACK)\n        return float(p_on_b - p_on_w)\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Clear promotion paths: count of pawns with clear file path to promotion weighted by advancement (white - black)'\n    try:\n        pm = board.piece_map()\n        def clear_pawn_potential(color):\n            total = 0.0\n            for sq, p in pm.items():\n                if not p or p.piece_type != chess.PAWN or p.color != color:\n                    continue\n                f = chess.square_file(sq)\n                r = chess.square_rank(sq)\n                clear = True\n                if color == chess.WHITE:\n                    for rr in range(r+1, 8):\n                        sq2 = chess.square(f, rr)\n                        p2 = pm.get(sq2)\n                        if p2:\n                            clear = False\n                            break\n                    if clear:\n                        total += (r / 7.0) + 0.2  # advanced clear pawns slightly boosted\n                else:\n                    for rr in range(0, r):\n                        sq2 = chess.square(f, rr)\n                        p2 = pm.get(sq2)\n                        if p2:\n                            clear = False\n                            break\n                    if clear:\n                        total += ((7 - r) / 7.0) + 0.2\n            return total\n        return float(clear_pawn_potential(chess.WHITE) - clear_pawn_potential(chess.BLACK))\n    except Exception:\n        return 0.0\n",
    "def feature(board: chess.Board) -> float:\n    'Passed pawn pressure: weighted sum of passed pawns (advancement-weighted) (white - black)'\n    try:\n        pm = board.piece_map()\n        def is_passed(sq, color):\n            p = pm.get(sq)\n            if not p or p.piece_type != chess.PAWN or p.color != color:\n                return False\n            f = chess.square_file(sq)\n            r = chess.square_rank(sq)\n            opp = chess.BLACK if color == chess.WHITE else chess.WHITE\n            files = [f]\n            if f - 1 >= 0: files.append(f-1)\n            if f + 1 <= 7: files.append(f+1)\n            if color == chess.WHITE:\n                for rr in range(r+1, 8):\n                    for ff in files:\n                        p2 = pm.get(chess.square(ff, rr))\n                        if p2 and p2.piece_type == chess.PAWN and p2.color == opp:\n                            return False\n            else:\n                for rr in range(0, r):\n                    for ff in files:\n                        p2 = pm.get(chess.square(ff, rr))\n                        if p2 and p2.piece_type == chess.PAWN and p2.color == opp:\n                            return False\n            return True\n        score_w = 0.0; score_b = 0.0\n        for sq, p in pm.items():\n            if not p or p.piece_type != chess.PAWN: continue\n            r = chess.square_rank(sq)\n            adv = (r / 7.0) if p.color == chess.WHITE else ((7 - r) / 7.0)\n            if is_passed(sq, p.color):\n                if p.color == chess.WHITE:\n                    score_w += 1.0 * adv + 0.2\n                else:\n                    score_b += 1.0 * adv + 0.2\n        return float(score_w - score_b)\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Pawn island fragmentation: number of isolated pawn islands (white - black), higher is worse'\n    try:\n        pm = board.piece_map()\n        def pawn_islands(color):\n            files_with_pawn = set()\n            for sq,p in pm.items():\n                if p and p.piece_type == chess.PAWN and p.color == color:\n                    files_with_pawn.add(chess.square_file(sq))\n            if not files_with_pawn:\n                return 0.0\n            files = sorted(files_with_pawn)\n            islands = 1\n            for i in range(1, len(files)):\n                if files[i] != files[i-1] + 1:\n                    islands += 1\n            return float(islands)\n        return float(pawn_islands(chess.WHITE) - pawn_islands(chess.BLACK))\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Doubled pawns penalty difference: count of doubled pawn files (white - black)'\n    try:\n        pm = board.piece_map()\n        files_count = {chess.WHITE: [0]*8, chess.BLACK: [0]*8}\n        for sq,p in pm.items():\n            if p and p.piece_type == chess.PAWN:\n                files_count[p.color][chess.square_file(sq)] += 1\n        doubled = {chess.WHITE:0.0, chess.BLACK:0.0}\n        for color in (chess.WHITE, chess.BLACK):\n            for c in files_count[color]:\n                if c > 1:\n                    doubled[color] += (c - 1)  # penalize each extra pawn on a file\n        return float(doubled[chess.WHITE] - doubled[chess.BLACK])\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Rook file quality: count of rooks on open (1.0) or semi-open (0.5) files (white - black)'\n    try:\n        pm = board.piece_map()\n        pawn_on_file = [False]*8\n        pawn_color_on_file = [set() for _ in range(8)]\n        for sq,p in pm.items():\n            if p and p.piece_type == chess.PAWN:\n                f = chess.square_file(sq)\n                pawn_on_file[f] = True\n                pawn_color_on_file[f].add(p.color)\n        score = {chess.WHITE:0.0, chess.BLACK:0.0}\n        for sq,p in pm.items():\n            if not p or p.piece_type != chess.ROOK:\n                continue\n            f = chess.square_file(sq)\n            if not pawn_on_file[f]:\n                score[p.color] += 1.0\n            else:\n                # semi-open if no friendly pawn on file\n                if p.color not in pawn_color_on_file[f]:\n                    score[p.color] += 0.5\n        return float(score[chess.WHITE] - score[chess.BLACK])\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Direct sliding threats to king: number of unobstructed sliding attackers (rook/queen/bishop) targeting king lines (white - black)'\n    try:\n        pm = board.piece_map()\n        def sliding_threats_against(color):\n            # threats against king of color by opponent sliding pieces\n            king_sq = next((sq for sq,p in pm.items() if p and p.piece_type == chess.KING and p.color == color), None)\n            if king_sq is None:\n                return 0.0\n            opp = chess.BLACK if color == chess.WHITE else chess.WHITE\n            threats = 0.0\n            # examine opponent queens and rooks/bishops\n            for sq,p in pm.items():\n                if not p or p.color != opp:\n                    continue\n                if p.piece_type not in (chess.QUEEN, chess.ROOK, chess.BISHOP):\n                    continue\n                # check if on same line/diagonal\n                try:\n                    f1,r1 = chess.square_file(sq), chess.square_rank(sq)\n                    f2,r2 = chess.square_file(king_sq), chess.square_rank(king_sq)\n                except Exception:\n                    continue\n                df = f2 - f1; dr = r2 - r1\n                step_f = 0 if df == 0 else (1 if df > 0 else -1)\n                step_r = 0 if dr == 0 else (1 if dr > 0 else -1)\n                # valid sliding only if aligned\n                if not (step_f == 0 or step_r == 0 or abs(df) == abs(dr)):\n                    continue\n                # check path clear (exclude source and target)\n                f = f1 + step_f; r = r1 + step_r\n                blocked = False\n                while f != f2 or r != r2:\n                    sq_mid = chess.square(f, r)\n                    if pm.get(sq_mid):\n                        blocked = True\n                        break\n                    f += step_f; r += step_r\n                if blocked:\n                    continue\n                # piece type suitability: rook same file/rank; bishop diagonal; queen both\n                if p.piece_type == chess.ROOK and (step_f == 0 or step_r == 0):\n                    threats += 1.0\n                elif p.piece_type == chess.BISHOP and abs(df) == abs(dr):\n                    threats += 1.0\n                elif p.piece_type == chess.QUEEN and (step_f == 0 or step_r == 0 or abs(df) == abs(dr)):\n                    threats += 1.25  # queen threat slightly more dangerous\n            return threats\n        return float(sliding_threats_against(chess.WHITE) - sliding_threats_against(chess.BLACK))\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Piece protection balance: total defending value minus attacking value around all pieces (positive favors White)'\n    try:\n        pm = board.piece_map()\n        vals = {chess.PAWN:1.0, chess.KNIGHT:3.0, chess.BISHOP:3.0, chess.ROOK:5.0, chess.QUEEN:9.0, chess.KING:0.0}\n        total = {chess.WHITE:0.0, chess.BLACK:0.0}\n        for sq,p in pm.items():\n            if not p:\n                continue\n            color = p.color\n            opp = chess.BLACK if color == chess.WHITE else chess.WHITE\n            defenders = board.attackers(color, sq)\n            attackers = board.attackers(opp, sq)\n            # sum values of defender pieces (exclude the piece itself if counted)\n            def_val = 0.0\n            for d in defenders:\n                pd = pm.get(d)\n                if pd:\n                    def_val += vals.get(pd.piece_type, 0.0)\n            att_val = 0.0\n            for a in attackers:\n                pa = pm.get(a)\n                if pa:\n                    att_val += vals.get(pa.piece_type, 0.0)\n            # contribution: piece importance times (def - att) normalized\n            contrib = (def_val - att_val) * (vals.get(p.piece_type, 0.0) / 10.0)\n            total[color] += contrib\n        return float(total[chess.WHITE] - total[chess.BLACK])\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Rooks on opponent seventh rank (penetration): count weighted (white - black)'\n    try:\n        pm = board.piece_map()\n        score = {chess.WHITE:0.0, chess.BLACK:0.0}\n        for sq,p in pm.items():\n            if not p or p.piece_type != chess.ROOK:\n                continue\n            r = chess.square_rank(sq)\n            if p.color == chess.WHITE and r == 6:\n                score[chess.WHITE] += 1.0\n            if p.color == chess.BLACK and r == 1:\n                score[chess.BLACK] += 1.0\n        return float(score[chess.WHITE] - score[chess.BLACK])\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Knight outpost score: number of knights on outposts (supported and not attacked by opponent pawns) (white - black)'\n    try:\n        pm = board.piece_map()\n        score = {chess.WHITE:0.0, chess.BLACK:0.0}\n        for sq,p in pm.items():\n            if not p or p.piece_type != chess.KNIGHT:\n                continue\n            color = p.color\n            opp = chess.BLACK if color == chess.WHITE else chess.WHITE\n            r = chess.square_rank(sq)\n            # require to be in opponent half\n            in_enemy_half = (color == chess.WHITE and r >= 4) or (color == chess.BLACK and r <= 3)\n            if not in_enemy_half:\n                continue\n            attackers_by_opp = board.attackers(opp, sq)\n            # check for pawn attackers among opponent attackers\n            pawn_attacked = False\n            for a in attackers_by_opp:\n                pa = pm.get(a)\n                if pa and pa.piece_type == chess.PAWN:\n                    pawn_attacked = True\n                    break\n            if pawn_attacked:\n                continue\n            # check supported by a friendly piece (excluding the knight itself)\n            defenders = board.attackers(color, sq)\n            supported = any((pm.get(d) and d != sq) for d in defenders)\n            if supported:\n                score[color] += 1.0\n        return float(score[chess.WHITE] - score[chess.BLACK])\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Hanging pieces differential: (black hanging pieces - white hanging pieces), positive favors White'\n    try:\n        pm = board.piece_map()\n        hanging = {chess.WHITE:0.0, chess.BLACK:0.0}\n        for sq,p in pm.items():\n            if not p:\n                continue\n            color = p.color\n            opp = chess.BLACK if color == chess.WHITE else chess.WHITE\n            attackers = len(board.attackers(opp, sq))\n            defenders = len(board.attackers(color, sq))\n            # a piece is hanging if attackers > defenders\n            if attackers > defenders:\n                hanging[color] += 1.0\n        # feature positive when black has more hanging pieces (i.e., good for White)\n        return float(hanging[chess.BLACK] - hanging[chess.WHITE])\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'King centralization benefit in endgame: favor kings closer to center when few pieces remain (white - black)'\n    try:\n        pm = board.piece_map()\n        vals = {chess.PAWN:0.0, chess.KNIGHT:1.0, chess.BISHOP:1.0, chess.ROOK:2.5, chess.QUEEN:4.5, chess.KING:0.0}\n        nonpawn_material = 0.0\n        for p in pm.values():\n            if p:\n                nonpawn_material += vals.get(p.piece_type, 0.0)\n        # endgame factor: more weight when less non-pawn material remains\n        factor = 1.0 if nonpawn_material <= 6.0 else max(0.0, (12.0 - nonpawn_material) / 12.0)\n        centers = [chess.parse_square(s) for s in ('d4','e4','d5','e5')]\n        def central_score(color):\n            king_sq = next((sq for sq,p in pm.items() if p and p.piece_type == chess.KING and p.color == color), None)\n            if king_sq is None:\n                return 0.0\n            # distance = min Manhattan distance to center squares\n            dists = [chess.square_distance(king_sq, c) for c in centers]\n            d = min(dists) if dists else 8\n            # normalize: max meaningful distance ~6; central_score in [0,1]\n            sc = max(0.0, (6.0 - float(d)) / 6.0)\n            return sc\n        return float(factor * (central_score(chess.WHITE) - central_score(chess.BLACK)))\n    except Exception:\n        return 0.0\n",
    "def feature(board: chess.Board) -> float:\n    'Passed-pawn potential differential: sum of distances-to-promotion of passed pawns (white - black)'\n    try:\n        pm = board.piece_map()\n        def is_passed(p_sq, p):\n            f = chess.square_file(p_sq); r = chess.square_rank(p_sq)\n            if p.piece_type != chess.PAWN:\n                return False\n            if p.color == chess.WHITE:\n                for sq2, p2 in pm.items():\n                    if p2 and p2.piece_type == chess.PAWN and p2.color == chess.BLACK:\n                        of = chess.square_file(sq2); orank = chess.square_rank(sq2)\n                        if abs(of - f) <= 1 and orank > r:\n                            return False\n                return True\n            else:\n                for sq2, p2 in pm.items():\n                    if p2 and p2.piece_type == chess.PAWN and p2.color == chess.WHITE:\n                        of = chess.square_file(sq2); orank = chess.square_rank(sq2)\n                        if abs(of - f) <= 1 and orank < r:\n                            return False\n                return True\n        w_score = 0.0; b_score = 0.0\n        for sq, p in pm.items():\n            if not p or p.piece_type != chess.PAWN:\n                continue\n            r = chess.square_rank(sq)\n            if is_passed(sq, p):\n                if p.color == chess.WHITE:\n                    # closer to promotion -> higher weight\n                    w_score += float(7 - r) / 7.0\n                else:\n                    b_score += float(r) / 7.0\n        return float(w_score - b_score)\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Rook file quality differential: open (no pawns) =1.5, semi-open (no friendly pawns)=1.0 (white - black)'\n    try:\n        pm = board.piece_map()\n        # precompute pawn counts per file per color\n        pawns_on_file = {f: {chess.WHITE:0, chess.BLACK:0} for f in range(8)}\n        for sq, p in pm.items():\n            if p and p.piece_type == chess.PAWN:\n                pawns_on_file[chess.square_file(sq)][p.color] += 1\n        score = {chess.WHITE:0.0, chess.BLACK:0.0}\n        for sq, p in pm.items():\n            if not p or p.piece_type != chess.ROOK:\n                continue\n            f = chess.square_file(sq)\n            total_on_file = pawns_on_file[f][chess.WHITE] + pawns_on_file[f][chess.BLACK]\n            if total_on_file == 0:\n                score[p.color] += 1.5\n            else:\n                # semi-open for color means no friendly pawns on file\n                if pawns_on_file[f][p.color] == 0:\n                    score[p.color] += 1.0\n        return float(score[chess.WHITE] - score[chess.BLACK])\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'King centrality bonus in endgame: closeness to center weighted by endgame phase (positive if White king more central)'\n    try:\n        pm = board.piece_map()\n        wk = next((sq for sq,p in pm.items() if p and p.piece_type==chess.KING and p.color==chess.WHITE), None)\n        bk = next((sq for sq,p in pm.items() if p and p.piece_type==chess.KING and p.color==chess.BLACK), None)\n        if wk is None or bk is None:\n            return 0.0\n        # phase estimate based on number of non-pawn non-king pieces\n        nonpawns = sum(1 for p in pm.values() if p and p.piece_type not in (chess.PAWN, chess.KING))\n        # phase factor: more weight when fewer pieces remain\n        phase = max(0.0, min(1.0, (6.0 - nonpawns) / 6.0))\n        centers = [chess.parse_square('d4'), chess.parse_square('e4'), chess.parse_square('d5'), chess.parse_square('e5')]\n        def closeness(sq):\n            md = min(chess.square_distance(sq, c) for c in centers)\n            # normalize by max distance to center (7)\n            return (7.0 - float(md)) / 7.0\n        wc = closeness(wk); bc = closeness(bk)\n        return float(phase * (wc - bc))\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Hanging-piece penalty differential: sum of values of pieces attacked more times than defended (white - black)'\n    try:\n        pm = board.piece_map()\n        vals = {chess.PAWN:1.0, chess.KNIGHT:3.0, chess.BISHOP:3.0, chess.ROOK:5.0, chess.QUEEN:9.0, chess.KING:0.0}\n        pen = {chess.WHITE:0.0, chess.BLACK:0.0}\n        for sq, p in pm.items():\n            if not p or p.piece_type == chess.KING:\n                continue\n            color = p.color\n            opp = chess.BLACK if color == chess.WHITE else chess.WHITE\n            attackers = len(board.attackers(opp, sq))\n            defenders = len(board.attackers(color, sq))\n            if attackers > defenders:\n                # penalize proportionally to how much more attackers there are\n                diff = float(attackers - defenders)\n                pen[color] += vals.get(p.piece_type, 0.0) * (0.5 * min(diff, 3.0) / 3.0)\n        return float(pen[chess.BLACK] - pen[chess.WHITE]) * -1.0 if False else float(pen[chess.WHITE] - pen[chess.BLACK])\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Rooks on the seventh rank differential: count of rooks on opponent seventh (white - black)'\n    try:\n        pm = board.piece_map()\n        wcnt = 0.0; bcnt = 0.0\n        for sq, p in pm.items():\n            if not p or p.piece_type != chess.ROOK:\n                continue\n            r = chess.square_rank(sq)\n            if p.color == chess.WHITE and r == 6:\n                wcnt += 1.0\n            if p.color == chess.BLACK and r == 1:\n                bcnt += 1.0\n        return float(wcnt - bcnt)\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Bishop-pair and bishop mobility differential: pair bonus + ray mobility (white - black)'\n    try:\n        pm = board.piece_map()\n        dirs = [(1,1),(1,-1),(-1,1),(-1,-1)]\n        def bishop_stats(color):\n            count = 0\n            mobility = 0.0\n            for sq, p in pm.items():\n                if p and p.color == color and p.piece_type == chess.BISHOP:\n                    count += 1\n                    f = chess.square_file(sq); r = chess.square_rank(sq)\n                    for df, dr in dirs:\n                        ff, rr = f + df, r + dr\n                        while 0 <= ff < 8 and 0 <= rr < 8:\n                            mobility += 1.0\n                            sq2 = chess.square(ff, rr)\n                            if pm.get(sq2) is not None:\n                                break\n                            ff += df; rr += dr\n            pair_bonus = 1.0 if count >= 2 else 0.0\n            return pair_bonus + 0.05 * mobility\n        return float(bishop_stats(chess.WHITE) - bishop_stats(chess.BLACK))\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Central pawn control: number of central squares (d4/e4/d5/e5) controlled by pawns (white - black)'\n    try:\n        centers = [chess.parse_square(s) for s in ('d4','e4','d5','e5')]\n        pm = board.piece_map()\n        def pawn_controls(color):\n            cnt = 0.0\n            for c in centers:\n                attackers = board.attackers(color, c)\n                for a in attackers:\n                    p = pm.get(a)\n                    if p and p.piece_type == chess.PAWN and p.color == color:\n                        cnt += 1.0\n                        break\n            return cnt\n        return float(pawn_controls(chess.WHITE) - pawn_controls(chess.BLACK))\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Material adjusted by immediate safety: pieces attacked more than defended lose part of their value (white - black)'\n    try:\n        pm = board.piece_map()\n        vals = {chess.PAWN:1.0, chess.KNIGHT:3.0, chess.BISHOP:3.0, chess.ROOK:5.0, chess.QUEEN:9.0, chess.KING:0.0}\n        adj = {chess.WHITE:0.0, chess.BLACK:0.0}\n        for sq, p in pm.items():\n            if not p:\n                continue\n            v = vals.get(p.piece_type, 0.0)\n            color = p.color\n            opp = chess.BLACK if color == chess.WHITE else chess.WHITE\n            attackers = len(board.attackers(opp, sq))\n            defenders = len(board.attackers(color, sq))\n            penalty = 0.0\n            if attackers > defenders:\n                # larger penalty if many attackers relative to defenders\n                penalty = v * 0.4 * min(1.0, float(attackers - defenders) / 3.0)\n            adj[color] += max(0.0, v - penalty)\n        return float(adj[chess.WHITE] - adj[chess.BLACK])\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'King-vicinity invasion moves: legal moves that land in 3x3 around opponent king (white - black)'\n    try:\n        pm = board.piece_map()\n        wk = next((sq for sq,p in pm.items() if p and p.piece_type==chess.KING and p.color==chess.WHITE), None)\n        bk = next((sq for sq,p in pm.items() if p and p.piece_type==chess.KING and p.color==chess.BLACK), None)\n        if wk is None or bk is None:\n            return 0.0\n        def vicinity(sq):\n            f = chess.square_file(sq); r = chess.square_rank(sq)\n            sset = set()\n            for ff in range(max(0, f-1), min(7, f+1)+1):\n                for rr in range(max(0, r-1), min(7, r+1)+1):\n                    sset.add(chess.square(ff, rr))\n            return sset\n        vic_w = vicinity(bk)  # squares around black king threatened by White moves\n        vic_b = vicinity(wk)\n        orig = board.turn\n        try:\n            counts = {chess.WHITE:0.0, chess.BLACK:0.0}\n            for color, vic in ((chess.WHITE, vic_w), (chess.BLACK, vic_b)):\n                board.turn = color\n                for mv in board.legal_moves:\n                    if mv.to_square in vic:\n                        counts[color] += 1.0\n        finally:\n            board.turn = orig\n        return float(counts[chess.WHITE] - counts[chess.BLACK])\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Pawn-flank majority differential: kingside minus queenside pawn majority (white - black)'\n    try:\n        pm = board.piece_map()\n        def flank_counts(color):\n            kside = 0; qside = 0\n            for sq, p in pm.items():\n                if p and p.color == color and p.piece_type == chess.PAWN:\n                    f = chess.square_file(sq)\n                    if f <= 3:\n                        qside += 1\n                    else:\n                        kside += 1\n            return kside - qside\n        return float(flank_counts(chess.WHITE) - flank_counts(chess.BLACK))\n    except Exception:\n        return 0.0\n",
    "def feature(board: chess.Board) -> float:\n    'Passed pawn pressure: sum of passed-pawn advancement weighted by support (white - black)'\n    try:\n        vals = {chess.PAWN:1.0, chess.KNIGHT:3.0, chess.BISHOP:3.0, chess.ROOK:5.0, chess.QUEEN:9.0, chess.KING:0.0}\n        pm = board.piece_map()\n        def is_passed(sq, color):\n            f = chess.square_file(sq); r = chess.square_rank(sq)\n            opp = chess.BLACK if color == chess.WHITE else chess.WHITE\n            if pm.get(sq) is None or pm.get(sq).piece_type != chess.PAWN or pm.get(sq).color != color:\n                return False\n            if color == chess.WHITE:\n                for rr in range(r+1, 8):\n                    for ff in (f-1, f, f+1):\n                        if 0 <= ff < 8:\n                            p = pm.get(chess.square(ff, rr))\n                            if p and p.piece_type == chess.PAWN and p.color == opp:\n                                return False\n            else:\n                for rr in range(r-1, -1, -1):\n                    for ff in (f-1, f, f+1):\n                        if 0 <= ff < 8:\n                            p = pm.get(chess.square(ff, rr))\n                            if p and p.piece_type == chess.PAWN and p.color == opp:\n                                return False\n            return True\n        def support_count(sq, color):\n            # pawns behind that support or friendly pieces attacking square\n            f = chess.square_file(sq); r = chess.square_rank(sq)\n            cnt = 0\n            if color == chess.WHITE:\n                behind = r - 1\n                if 0 <= behind < 8:\n                    for df in (-1, 0, 1):\n                        ff = f + df\n                        if 0 <= ff < 8:\n                            p = pm.get(chess.square(ff, behind))\n                            if p and p.piece_type == chess.PAWN and p.color == color:\n                                cnt += 1\n            else:\n                behind = r + 1\n                if 0 <= behind < 8:\n                    for df in (-1, 0, 1):\n                        ff = f + df\n                        if 0 <= ff < 8:\n                            p = pm.get(chess.square(ff, behind))\n                            if p and p.piece_type == chess.PAWN and p.color == color:\n                                cnt += 1\n            # also count friendly attackers (defenders)\n            try:\n                cnt += len(board.attackers(color, sq))\n            except Exception:\n                pass\n            return float(cnt)\n        score = {chess.WHITE:0.0, chess.BLACK:0.0}\n        for sq, p in list(pm.items()):\n            if not p or p.piece_type != chess.PAWN:\n                continue\n            color = p.color\n            if is_passed(sq, color):\n                r = chess.square_rank(sq)\n                if color == chess.WHITE:\n                    adv = float(r) / 6.0  # 0..~1, more advanced gives higher\n                else:\n                    adv = float(7 - r) / 6.0\n                sup = support_count(sq, color)\n                score[color] += adv * (1.0 + 0.25 * min(sup, 4.0))\n        return float(score[chess.WHITE] - score[chess.BLACK])\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Pinned material imbalance: total value of pieces pinned to their king by sliding pieces (black pinned - white pinned)'\n    try:\n        pm = board.piece_map()\n        vals = {chess.PAWN:1.0, chess.KNIGHT:3.0, chess.BISHOP:3.25, chess.ROOK:5.0, chess.QUEEN:9.0, chess.KING:0.0}\n        def on_same_line(a, b):\n            af, ar = chess.square_file(a), chess.square_rank(a)\n            bf, br = chess.square_file(b), chess.square_rank(b)\n            return af == bf or ar == br or abs(af - bf) == abs(ar - br)\n        # Directions as (df, dr) increments\n        directions = [(1,0),(-1,0),(0,1),(0,-1),(1,1),(1,-1),(-1,1),(-1,-1)]\n        pinned_value = {chess.WHITE:0.0, chess.BLACK:0.0}\n        # find kings\n        kings = {chess.WHITE:None, chess.BLACK:None}\n        for sq, p in pm.items():\n            if p and p.piece_type == chess.KING:\n                kings[p.color] = sq\n        for sq, p in list(pm.items()):\n            if not p or p.piece_type == chess.KING:\n                continue\n            color = p.color\n            ksq = kings.get(color)\n            if ksq is None:\n                continue\n            if not on_same_line(sq, ksq):\n                continue\n            # Determine direction from king to piece\n            kf, kr = chess.square_file(ksq), chess.square_rank(ksq)\n            pf, pr = chess.square_file(sq), chess.square_rank(sq)\n            df = pf - kf; dr = pr - kr\n            step_df = 0 if df == 0 else (1 if df > 0 else -1)\n            step_dr = 0 if dr == 0 else (1 if dr > 0 else -1)\n            if step_df == 0 and step_dr == 0:\n                continue\n            # Walk beyond piece away from king to find first attacker\n            ff = pf + step_df; rr = pr + step_dr\n            blocker_found = False\n            attacker_sq = None\n            while 0 <= ff < 8 and 0 <= rr < 8:\n                s = chess.square(ff, rr)\n                q = pm.get(s)\n                if q:\n                    blocker_found = True\n                    attacker_sq = s\n                    break\n                ff += step_df; rr += step_dr\n            if not blocker_found or attacker_sq is None:\n                continue\n            attacker = pm.get(attacker_sq)\n            if not attacker or attacker.color == color:\n                continue\n            # check if attacker is sliding and matches line type\n            is_diag = abs(step_df) == 1 and abs(step_dr) == 1\n            is_ortho = (step_df == 0) ^ (step_dr == 0)\n            if attacker.piece_type == chess.QUEEN or (attacker.piece_type == chess.BISHOP and is_diag) or (attacker.piece_type == chess.ROOK and is_ortho):\n                # Ensure there is exactly one intervening piece (the candidate) between king and attacker\n                # verify there are no other pieces between king and candidate and between candidate and attacker we already scanned\n                # Check between king and piece\n                ff = kf + step_df; rr = kr + step_dr\n                intervening = 0\n                ok = True\n                while (ff, rr) != (pf, pr):\n                    s = chess.square(ff, rr)\n                    if pm.get(s):\n                        intervening += 1\n                    ff += step_df; rr += step_dr\n                # intervening should be 0 (direct neighbor chain)\n                if intervening == 0:\n                    pinned_value[color] += vals.get(p.piece_type, 0.0)\n        # positive means Black has more pinned material (good for White)\n        return float(pinned_value[chess.BLACK] - pinned_value[chess.WHITE])\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Rook on enemy seventh rank count (white - black)'\n    try:\n        pm = board.piece_map()\n        w = 0.0; b = 0.0\n        for sq, p in pm.items():\n            if not p or p.piece_type != chess.ROOK:\n                continue\n            r = chess.square_rank(sq)\n            if p.color == chess.WHITE and r == 6:\n                w += 1.0\n            if p.color == chess.BLACK and r == 1:\n                b += 1.0\n        return float(w - b)\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Bishop long-diagonal mobility: sum of unobstructed diagonal ray lengths (white - black)'\n    try:\n        pm = board.piece_map()\n        score = {chess.WHITE:0.0, chess.BLACK:0.0}\n        for sq, p in list(pm.items()):\n            if not p or p.piece_type != chess.BISHOP:\n                continue\n            f = chess.square_file(sq); r = chess.square_rank(sq)\n            # four diagonal directions\n            for df, dr in ((1,1),(1,-1),(-1,1),(-1,-1)):\n                ff = f + df; rr = r + dr\n                length = 0\n                while 0 <= ff < 8 and 0 <= rr < 8:\n                    s = chess.square(ff, rr)\n                    if pm.get(s):\n                        break\n                    length += 1\n                    ff += df; rr += dr\n                score[p.color] += float(length) * 0.25  # weight modestly\n        return float(score[chess.WHITE] - score[chess.BLACK])\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'King exposure: enemy attacks minus friendly pawn/defender coverage around the king (black - white)'\n    try:\n        pm = board.piece_map()\n        def exposure(color):\n            ksq = next((sq for sq,p in pm.items() if p and p.piece_type == chess.KING and p.color == color), None)\n            if ksq is None:\n                return 0.0\n            kf = chess.square_file(ksq); kr = chess.square_rank(ksq)\n            opp = chess.BLACK if color == chess.WHITE else chess.WHITE\n            attacked = 0.0\n            defended = 0.0\n            pawn_shield = 0.0\n            for df in (-1,0,1):\n                for dr in (-1,0,1):\n                    if df == 0 and dr == 0:\n                        continue\n                    ff = kf + df; rr = kr + dr\n                    if 0 <= ff < 8 and 0 <= rr < 8:\n                        sq = chess.square(ff, rr)\n                        if board.is_attacked_by(opp, sq):\n                            attacked += 1.0\n                        if board.is_attacked_by(color, sq):\n                            defended += 1.0\n                        p = pm.get(sq)\n                        if p and p.piece_type == chess.PAWN and p.color == color:\n                            pawn_shield += 1.0\n            # exposure increases with attacks, reduced by defenders and pawn shield\n            return attacked - 0.6 * defended - 0.9 * pawn_shield\n        exp_w = exposure(chess.WHITE)\n        exp_b = exposure(chess.BLACK)\n        # positive means Black more exposed than White => favors White\n        return float(exp_b - exp_w)\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Piece coordination: aggregate count of friendly defenders on non-pawn pieces (white - black)'\n    try:\n        pm = board.piece_map()\n        score = {chess.WHITE:0.0, chess.BLACK:0.0}\n        for sq, p in list(pm.items()):\n            if not p or p.piece_type in (chess.PAWN, chess.KING):\n                continue\n            defenders = 0\n            try:\n                defenders = len(board.attackers(p.color, sq))\n            except Exception:\n                defenders = 0\n            # weight by piece importance but reward multi-defended pieces more\n            weight = {chess.KNIGHT:1.0, chess.BISHOP:1.1, chess.ROOK:1.2, chess.QUEEN:1.5}.get(p.piece_type, 1.0)\n            score[p.color] += weight * float(defenders)\n        return float(score[chess.WHITE] - score[chess.BLACK])\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Pawn island imbalance: (black pawn islands - white pawn islands) positive favors White'\n    try:\n        pm = board.piece_map()\n        def pawn_islands(color):\n            files_has = [False]*8\n            for sq, p in pm.items():\n                if p and p.piece_type == chess.PAWN and p.color == color:\n                    files_has[chess.square_file(sq)] = True\n            islands = 0\n            i = 0\n            while i < 8:\n                if files_has[i]:\n                    islands += 1\n                    while i < 8 and files_has[i]:\n                        i += 1\n                else:\n                    i += 1\n            return islands\n        w = pawn_islands(chess.WHITE)\n        b = pawn_islands(chess.BLACK)\n        return float(b - w)\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Hanging pieces total value: sum of values of pieces attacked but undefended (black - white)'\n    try:\n        pm = board.piece_map()\n        vals = {chess.PAWN:1.0, chess.KNIGHT:3.0, chess.BISHOP:3.0, chess.ROOK:5.0, chess.QUEEN:9.0, chess.KING:0.0}\n        hanging = {chess.WHITE:0.0, chess.BLACK:0.0}\n        for sq, p in list(pm.items()):\n            if not p:\n                continue\n            attackers = len(board.attackers(not p.color, sq))\n            defenders = len(board.attackers(p.color, sq))\n            if attackers > 0 and defenders == 0:\n                hanging[p.color] += vals.get(p.piece_type, 0.0)\n        # positive if Black has more hanging material (good for White)\n        return float(hanging[chess.BLACK] - hanging[chess.WHITE])\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Passed pawn promotion race metric: measures closeness of passed pawns to promotion adjusted by enemy king proximity (white - black)'\n    try:\n        pm = board.piece_map()\n        # find kings\n        kings = {chess.WHITE:None, chess.BLACK:None}\n        for sq, p in pm.items():\n            if p and p.piece_type == chess.KING:\n                kings[p.color] = sq\n        def pawn_race_score(color):\n            s = 0.0\n            for sq, p in pm.items():\n                if not p or p.piece_type != chess.PAWN or p.color != color:\n                    continue\n                f = chess.square_file(sq); r = chess.square_rank(sq)\n                # check passed\n                opp = chess.BLACK if color == chess.WHITE else chess.WHITE\n                passed = True\n                if color == chess.WHITE:\n                    for rr in range(r+1, 8):\n                        for ff in (f-1, f, f+1):\n                            if 0 <= ff < 8:\n                                q = pm.get(chess.square(ff, rr))\n                                if q and q.piece_type == chess.PAWN and q.color == opp:\n                                    passed = False\n                                    break\n                        if not passed:\n                            break\n                else:\n                    for rr in range(r-1, -1, -1):\n                        for ff in (f-1, f, f+1):\n                            if 0 <= ff < 8:\n                                q = pm.get(chess.square(ff, rr))\n                                if q and q.piece_type == chess.PAWN and q.color == opp:\n                                    passed = False\n                                    break\n                        if not passed:\n                            break\n                if not passed:\n                    continue\n                # moves to promote\n                moves = (7 - r) if color == chess.WHITE else r\n                moves = max(0, moves)\n                prom_factor = 1.0 / (1.0 + moves)  # nearer -> larger\n                # enemy king proximity to promotion square\n                promote_sq = chess.square(f, 7) if color == chess.WHITE else chess.square(f, 0)\n                enemy_king_sq = kings.get(opp)\n                king_dist = chess.square_distance(promote_sq, enemy_king_sq) if enemy_king_sq is not None else 8.0\n                # if king is far relative to moves, stronger\n                safety = max(-1.0, (king_dist - moves) / 8.0)\n                s += prom_factor * (1.0 + 0.8 * safety)\n            return s\n        return float(pawn_race_score(chess.WHITE) - pawn_race_score(chess.BLACK))\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Bishop-pair effectiveness on open diagonals: bishop-pair open-diagonal score (white - black)'\n    try:\n        pm = board.piece_map()\n        # build pawn occupancy per diagonal id (each diagonal defined by file-rank or file+rank)\n        # main diag id = file - rank ranges -7..7 -> shift by +7 to index 0..14\n        pawn_diag_occupied = [False]*15\n        pawn_adiag_occupied = [False]*15\n        for sq, p in pm.items():\n            if p and p.piece_type == chess.PAWN:\n                f = chess.square_file(sq); r = chess.square_rank(sq)\n                pawn_diag_occupied[f - r + 7] = True\n                pawn_adiag_occupied[f + r] = True\n        score = {chess.WHITE:0.0, chess.BLACK:0.0}\n        for color in (chess.WHITE, chess.BLACK):\n            bishops = [sq for sq,p in pm.items() if p and p.piece_type == chess.BISHOP and p.color == color]\n            if len(bishops) < 2:\n                continue\n            open_diags = 0\n            for sq in bishops:\n                f = chess.square_file(sq); r = chess.square_rank(sq)\n                d1 = f - r + 7\n                d2 = f + r\n                if 0 <= d1 < 15 and not pawn_diag_occupied[d1]:\n                    open_diags += 1\n                if 0 <= d2 < 15 and not pawn_adiag_occupied[d2]:\n                    open_diags += 1\n            # normalize by number of bishops (max 4 checks), reward pairs more\n            score[color] = float(open_diags) * 0.5\n        return float(score[chess.WHITE] - score[chess.BLACK])\n    except Exception:\n        return 0.0\n",
    "def feature(board: chess.Board) -> float:\n    'Pawn-structure weakness: weighted (doubled + isolated + backward) pawn penalty (white - black)'\n    try:\n        pm = board.piece_map()\n        def pawn_structure_penalty(color):\n            files = {f: [] for f in range(8)}\n            for sq, p in pm.items():\n                if p and p.piece_type == chess.PAWN and p.color == color:\n                    files[chess.square_file(sq)].append(sq)\n            doubled = 0.0\n            isolated = 0.0\n            backward = 0.0\n            opp = chess.BLACK if color == chess.WHITE else chess.WHITE\n            for f, sqs in files.items():\n                if len(sqs) > 1:\n                    doubled += 0.8 * (len(sqs) - 1)  # penalty per extra pawn on file\n                for sq in sqs:\n                    # isolated: no pawns on adjacent files\n                    if (len(files.get(f-1, [])) == 0) and (len(files.get(f+1, [])) == 0):\n                        isolated += 1.0\n                    # backward: pawn has no friendly pawn attacking it (support) and an enemy pawn on adjacent file is advanced\n                    supported = any((pm.get(a) and pm.get(a).piece_type == chess.PAWN and pm.get(a).color == color) for a in board.attackers(color, sq))\n                    if not supported:\n                        r = chess.square_rank(sq)\n                        # check adjacent files for an enemy pawn that is more advanced (blocks advance)\n                        adj_block = False\n                        for af in (f-1, f+1):\n                            if 0 <= af < 8:\n                                for rsq in files.get(af, []):\n                                    ep = pm.get(rsq)\n                                    if ep and ep.color == opp:\n                                        rr = chess.square_rank(rsq)\n                                        if (color == chess.WHITE and rr > r) or (color == chess.BLACK and rr < r):\n                                            adj_block = True\n                                            break\n                                if adj_block:\n                                    break\n                        if adj_block:\n                            backward += 1.5\n            return doubled + isolated + backward\n        return float(pawn_structure_penalty(chess.WHITE) - pawn_structure_penalty(chess.BLACK))\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Passed pawns advancement and potential: sum of progressed passed-pawn scores (white - black)'\n    try:\n        pm = board.piece_map()\n        def passed_sum(color):\n            total = 0.0\n            opp = chess.BLACK if color == chess.WHITE else chess.WHITE\n            for sq, p in pm.items():\n                if not p or p.piece_type != chess.PAWN or p.color != color:\n                    continue\n                f = chess.square_file(sq); r = chess.square_rank(sq)\n                is_passed = True\n                # check enemy pawns on same or adjacent files ahead of pawn\n                for af in (f-1, f, f+1):\n                    if 0 <= af < 8:\n                        for rank_check in range(r+1, 8) if color == chess.WHITE else range(0, r):\n                            check_sq = chess.square(af, rank_check)\n                            q = pm.get(check_sq)\n                            if q and q.piece_type == chess.PAWN and q.color == opp:\n                                is_passed = False\n                                break\n                        if not is_passed:\n                            break\n                if is_passed:\n                    # value increases with rank advancement (closer to promotion)\n                    progress = (r / 7.0) if color == chess.WHITE else ((7 - r) / 7.0)\n                    # base passed pawn value plus progress bonus\n                    total += 4.0 + 5.0 * progress\n            return total\n        return float(passed_sum(chess.WHITE) - passed_sum(chess.BLACK))\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Rook activity on open or semi-open files and proximity to opponent rank (white - black)'\n    try:\n        pm = board.piece_map()\n        def rook_activity(color):\n            score = 0.0\n            for sq, p in pm.items():\n                if not p or p.piece_type != chess.ROOK or p.color != color:\n                    continue\n                f = chess.square_file(sq); r = chess.square_rank(sq)\n                # check file pawns\n                file_has_white = any((pm.get(chess.square(f, rr)) and pm.get(chess.square(f, rr)).piece_type == chess.PAWN and pm.get(chess.square(f, rr)).color == chess.WHITE) for rr in range(8))\n                file_has_black = any((pm.get(chess.square(f, rr)) and pm.get(chess.square(f, rr)).piece_type == chess.PAWN and pm.get(chess.square(f, rr)).color == chess.BLACK) for rr in range(8))\n                open_file = not file_has_white and not file_has_black\n                semi_open = not (file_has_white if color == chess.WHITE else file_has_black)\n                base = 0.0\n                if open_file:\n                    base += 2.0\n                elif semi_open:\n                    base += 1.0\n                # proximity bonus: rooks on 7th for white (rank 6) and black on rank 1\n                if color == chess.WHITE:\n                    base += max(0.0, (r - 4) * 0.4)  # more weight when on enemy half\n                    if r == 6:\n                        base += 1.5\n                else:\n                    base += max(0.0, (3 - r) * 0.4)\n                    if r == 1:\n                        base += 1.5\n                score += base\n            return score\n        return float(rook_activity(chess.WHITE) - rook_activity(chess.BLACK))\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'King-file exposure: count of open/semi-open files adjacent to king lacking pawn shield (positive favors White being safer)'\n    try:\n        pm = board.piece_map()\n        def exposure(color):\n            king_sq = next((sq for sq, p in pm.items() if p and p.piece_type == chess.KING and p.color == color), None)\n            if king_sq is None:\n                return 0.0\n            kf = chess.square_file(king_sq); kr = chess.square_rank(king_sq)\n            exp = 0.0\n            for af in (kf-1, kf, kf+1):\n                if not (0 <= af < 8):\n                    continue\n                # check for friendly pawn shield in front of king (one or two ranks forward)\n                shield_found = False\n                if color == chess.WHITE:\n                    for rr in (kr+1, kr+2):\n                        if 0 <= rr < 8:\n                            p = pm.get(chess.square(af, rr))\n                            if p and p.piece_type == chess.PAWN and p.color == color:\n                                shield_found = True\n                                break\n                else:\n                    for rr in (kr-1, kr-2):\n                        if 0 <= rr < 8:\n                            p = pm.get(chess.square(af, rr))\n                            if p and p.piece_type == chess.PAWN and p.color == color:\n                                shield_found = True\n                                break\n                # check if file is open or semi-open\n                file_has_friendly = any((pm.get(chess.square(af, rr)) and pm.get(chess.square(af, rr)).piece_type == chess.PAWN and pm.get(chess.square(af, rr)).color == color) for rr in range(8))\n                file_has_enemy = any((pm.get(chess.square(af, rr)) and pm.get(chess.square(af, rr)).piece_type == chess.PAWN and pm.get(chess.square(af, rr)).color != color) for rr in range(8))\n                open_file = not file_has_friendly and not file_has_enemy\n                semi_open = not file_has_friendly and file_has_enemy\n                if open_file:\n                    exp += 1.5 if not shield_found else 0.6\n                elif semi_open and not shield_found:\n                    exp += 0.9\n            return exp\n        # return safety advantage: lower exposure is better, so compute (exposure_black - exposure_white)\n        return float(exposure(chess.BLACK) - exposure(chess.WHITE))\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Bishop pair and mobility score: bishop count + diagonal reach adjusted by pawn-color-block (white - black)'\n    try:\n        pm = board.piece_map()\n        vals = {chess.BISHOP:3.0}\n        def bishop_score(color):\n            score = 0.0\n            bishops = [sq for sq, p in pm.items() if p and p.piece_type == chess.BISHOP and p.color == color]\n            score += 0.75 * (len(bishops) // 2)  # small pair bonus\n            # diagonal reach\n            for sq in bishops:\n                f = chess.square_file(sq); r = chess.square_rank(sq)\n                reach = 0\n                for dx, dy in ((1,1),(1,-1),(-1,1),(-1,-1)):\n                    ff, rr = f + dx, r + dy\n                    while 0 <= ff < 8 and 0 <= rr < 8:\n                        reach += 1\n                        if pm.get(chess.square(ff, rr)):\n                            break\n                        ff += dx; rr += dy\n                # penalty if many own pawns on same-colored squares (bad-bishop)\n                # detect bishop square color (0 = light, 1 = dark)\n                square_color = (f + r) & 1\n                own_pawns_on_color = sum(1 for s, p in pm.items() if p and p.piece_type == chess.PAWN and p.color == color and (((chess.square_file(s) + chess.square_rank(s)) & 1) == square_color))\n                badness = 0.15 * own_pawns_on_color\n                score += 0.15 * reach - badness\n            return score\n        return float(bishop_score(chess.WHITE) - bishop_score(chess.BLACK))\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Direct sliding-piece pressure on king: count of rooks/bishops/queens with unobstructed line to opponent king (white - black)'\n    try:\n        pm = board.piece_map()\n        def line_pressure(color):\n            opp = chess.BLACK if color == chess.WHITE else chess.WHITE\n            king_sq = next((sq for sq, p in pm.items() if p and p.piece_type == chess.KING and p.color == opp), None)\n            if king_sq is None:\n                return 0.0\n            kf = chess.square_file(king_sq); kr = chess.square_rank(king_sq)\n            pressure = 0.0\n            for sq, p in pm.items():\n                if not p or p.color != color:\n                    continue\n                if p.piece_type not in (chess.ROOK, chess.BISHOP, chess.QUEEN):\n                    continue\n                pf = chess.square_file(sq); pr = chess.square_rank(sq)\n                dx = pf - kf; dy = pr - kr\n                sdx = 0 if dx == 0 else (1 if dx > 0 else -1)\n                sdy = 0 if dy == 0 else (1 if dy > 0 else -1)\n                # aligned?\n                if not (dx == 0 or dy == 0 or abs(dx) == abs(dy)):\n                    continue\n                # scan between piece and king for blockers\n                blocked = False\n                ff, rr = kf + sdx, kr + sdy\n                while (ff, rr) != (pf, pr):\n                    if not (0 <= ff < 8 and 0 <= rr < 8):\n                        blocked = True\n                        break\n                    inter_sq = chess.square(ff, rr)\n                    if pm.get(inter_sq) is not None:\n                        blocked = True\n                        break\n                    ff += sdx; rr += sdy\n                if blocked:\n                    continue\n                # now ensure piece is of appropriate type for direction\n                if sdx == 0 or sdy == 0:\n                    if p.piece_type in (chess.ROOK, chess.QUEEN):\n                        pressure += 1.8 if p.piece_type == chess.QUEEN else 1.0\n                else:\n                    if p.piece_type in (chess.BISHOP, chess.QUEEN):\n                        pressure += 1.8 if p.piece_type == chess.QUEEN else 1.0\n            return pressure\n        return float(line_pressure(chess.WHITE) - line_pressure(chess.BLACK))\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Weighted pinned pieces count (more valuable pieces count more) (white - black)'\n    try:\n        pm = board.piece_map()\n        vals = {chess.PAWN:1.0, chess.KNIGHT:3.0, chess.BISHOP:3.0, chess.ROOK:5.0, chess.QUEEN:9.0}\n        def pinned_weight(color):\n            total = 0.0\n            king_sq = next((sq for sq, p in pm.items() if p and p.piece_type == chess.KING and p.color == color), None)\n            if king_sq is None:\n                return 0.0\n            opp = chess.BLACK if color == chess.WHITE else chess.WHITE\n            kf = chess.square_file(king_sq); kr = chess.square_rank(king_sq)\n            for sq, p in pm.items():\n                if not p or p.color != color or p.piece_type == chess.KING:\n                    continue\n                pf = chess.square_file(sq); pr = chess.square_rank(sq)\n                dx = pf - kf; dy = pr - kr\n                sdx = 0 if dx == 0 else (1 if dx > 0 else -1)\n                sdy = 0 if dy == 0 else (1 if dy > 0 else -1)\n                if not (dx == 0 or dy == 0 or abs(dx) == abs(dy)):\n                    continue\n                # traverse from king towards piece, ensure piece is first blocker\n                ff, rr = kf + sdx, kr + sdy\n                hit_piece = None\n                blocked_before = False\n                while 0 <= ff < 8 and 0 <= rr < 8:\n                    cur = pm.get(chess.square(ff, rr))\n                    if cur:\n                        if (ff, rr) == (pf, pr):\n                            hit_piece = cur\n                            break\n                        else:\n                            blocked_before = True\n                            break\n                    ff += sdx; rr += sdy\n                if blocked_before or hit_piece is None:\n                    continue\n                # now beyond the piece, find first non-empty square\n                ff += sdx; rr += sdy\n                while 0 <= ff < 8 and 0 <= rr < 8:\n                    cur = pm.get(chess.square(ff, rr))\n                    if cur:\n                        # is it an enemy sliding piece that can pin?\n                        if cur.color == opp and cur.piece_type in (chess.QUEEN, chess.ROOK, chess.BISHOP):\n                            # check compatibility\n                            if (sdx == 0 or sdy == 0) and cur.piece_type in (chess.ROOK, chess.QUEEN):\n                                total += vals.get(hit_piece.piece_type, 1.0) * 0.9\n                            elif abs(sdx) == abs(sdy) and cur.piece_type in (chess.BISHOP, chess.QUEEN):\n                                total += vals.get(hit_piece.piece_type, 1.0) * 0.9\n                        break\n                    ff += sdx; rr += sdy\n            return total\n        return float(pinned_weight(chess.WHITE) - pinned_weight(chess.BLACK))\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Drawishness indicator: higher when material is low or halfmove clock is high (positive = drawish)'\n    try:\n        pm = board.piece_map()\n        vals = {chess.PAWN:1.0, chess.KNIGHT:3.0, chess.BISHOP:3.0, chess.ROOK:5.0, chess.QUEEN:9.0}\n        total_nonking = 0.0\n        for p in pm.values():\n            if p and p.piece_type != chess.KING:\n                total_nonking += vals.get(p.piece_type, 0.0)\n        # base drawiness inversely proportional to material, plus halfmove clock factor\n        mat_factor = max(0.0, (20.0 - total_nonking) / 20.0)  # more when less material\n        hm = float(board.halfmove_clock)\n        hm_factor = min(1.0, hm / 50.0)\n        insuff = 1.0 if board.is_insufficient_material() else 0.0\n        # if material very imbalanced but low total, less drawish (winning side advantage) -> reduce drawiness by imbalance\n        white_mat = 0.0; black_mat = 0.0\n        for p in pm.values():\n            if p and p.piece_type != chess.KING:\n                if p.color == chess.WHITE:\n                    white_mat += vals.get(p.piece_type, 0.0)\n                else:\n                    black_mat += vals.get(p.piece_type, 0.0)\n        imbalance = abs(white_mat - black_mat)\n        imbalance_factor = max(0.0, 1.0 - imbalance / 20.0)\n        drawiness = max(insuff, 0.6 * mat_factor * imbalance_factor + 0.4 * hm_factor)\n        return float(drawiness)\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Queen activity ratio: normalized queen legal moves / total legal moves difference (white - black)'\n    try:\n        orig = board.turn\n        try:\n            ratios = {chess.WHITE:0.0, chess.BLACK:0.0}\n            for color in (chess.WHITE, chess.BLACK):\n                board.turn = color\n                total = 0\n                qmoves = 0\n                for mv in board.legal_moves:\n                    total += 1\n                    p = board.piece_at(mv.from_square)\n                    if p and p.piece_type == chess.QUEEN and p.color == color:\n                        qmoves += 1\n                ratios[color] = (qmoves / total) if total > 0 else 0.0\n        finally:\n            board.turn = orig\n        return float(ratios[chess.WHITE] - ratios[chess.BLACK])\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Immobile/trapped high-value piece penalty: sum of values of non-pawn/king pieces with zero legal moves (white - black)'\n    try:\n        pm = board.piece_map()\n        vals = {chess.KNIGHT:3.0, chess.BISHOP:3.0, chess.ROOK:5.0, chess.QUEEN:9.0}\n        orig = board.turn\n        try:\n            immobile = {chess.WHITE:0.0, chess.BLACK:0.0}\n            for color in (chess.WHITE, chess.BLACK):\n                board.turn = color\n                # precompute moves from squares\n                moves_from = {}\n                for mv in board.legal_moves:\n                    moves_from.setdefault(mv.from_square, 0)\n                    moves_from[mv.from_square] += 1\n                for sq, p in pm.items():\n                    if not p or p.color != color or p.piece_type not in vals:\n                        continue\n                    movecnt = moves_from.get(sq, 0)\n                    if movecnt == 0:\n                        # penalize more if few defenders as well\n                        defenders = len(board.attackers(color, sq))\n                        penalty = vals[p.piece_type] * (1.0 + max(0.0, 2.0 - defenders) * 0.35)\n                        immobile[color] += penalty\n        finally:\n            board.turn = orig\n        return float(immobile[chess.WHITE] - immobile[chess.BLACK])\n    except Exception:\n        return 0.0\n",
    "def feature(board: chess.Board) -> float:\n    'Centralization of non-pawn, non-king pieces weighted by piece value (white - black)'\n    try:\n        import math\n        vals = {chess.PAWN:1.0, chess.KNIGHT:3.0, chess.BISHOP:3.0, chess.ROOK:5.0, chess.QUEEN:9.0, chess.KING:0.0}\n        pm = board.piece_map()\n        center_f = 3.5; center_r = 3.5\n        def central_score(color):\n            s = 0.0\n            for sq,p in pm.items():\n                if not p or p.color != color:\n                    continue\n                if p.piece_type in (chess.PAWN, chess.KING):\n                    continue\n                f = chess.square_file(sq); r = chess.square_rank(sq)\n                dist = math.hypot(f - center_f, r - center_r)\n                # normalized centrality in [0,1], with 1 at center, >0 when within radius ~4\n                cent = max(0.0, (4.0 - dist) / 4.0)\n                s += cent * vals.get(p.piece_type, 0.0)\n            return s\n        return float(central_score(chess.WHITE) - central_score(chess.BLACK))\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Passed pawn potential: weighted count of passed pawns by advancement (white - black)'\n    try:\n        pm = board.piece_map()\n        def is_passed(sq, color):\n            f = chess.square_file(sq); r = chess.square_rank(sq)\n            if color == chess.WHITE:\n                # any black pawn on same/adjacent files on ranks ahead (r+1..7) blocks\n                for af in (f-1, f, f+1):\n                    if af < 0 or af > 7: continue\n                    for rr in range(r+1, 8):\n                        p = pm.get(chess.square(af, rr))\n                        if p and p.piece_type == chess.PAWN and p.color == chess.BLACK:\n                            return False\n                return True\n            else:\n                for af in (f-1, f, f+1):\n                    if af < 0 or af > 7: continue\n                    for rr in range(0, r):\n                        p = pm.get(chess.square(af, rr))\n                        if p and p.piece_type == chess.PAWN and p.color == chess.WHITE:\n                            return False\n                return True\n        score = {chess.WHITE:0.0, chess.BLACK:0.0}\n        for sq,p in pm.items():\n            if not p or p.piece_type != chess.PAWN:\n                continue\n            r = chess.square_rank(sq)\n            adv = (r / 7.0) if p.color == chess.WHITE else ((7 - r) / 7.0)\n            if is_passed(sq, p.color):\n                score[p.color] += 1.0 * (0.6 + 0.8 * adv)  # passed pawn base + advancement bonus\n        return float(score[chess.WHITE] - score[chess.BLACK])\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Rooks on opponent seventh rank (pressure on enemy pawns/king) (white - black)'\n    try:\n        pm = board.piece_map()\n        w = 0.0; b = 0.0\n        for sq,p in pm.items():\n            if not p or p.piece_type != chess.ROOK:\n                continue\n            r = chess.square_rank(sq)\n            if p.color == chess.WHITE and r == 6:\n                # white rook on black seventh\n                w += 1.6\n            if p.color == chess.BLACK and r == 1:\n                b += 1.6\n            # also reward rooks on open/semi-open seventh even if no pawn: smaller bonus\n            if p.color == chess.WHITE and r == 6:\n                f = chess.square_file(sq)\n                # check if target rank has any friendly pawn that rook can harass\n                for ff in range(8):\n                    p2 = pm.get(chess.square(ff, 6))\n                    if p2 and p2.piece_type == chess.PAWN and p2.color == chess.BLACK:\n                        w += 0.4\n                        break\n            if p.color == chess.BLACK and r == 1:\n                f = chess.square_file(sq)\n                for ff in range(8):\n                    p2 = pm.get(chess.square(ff, 1))\n                    if p2 and p2.piece_type == chess.PAWN and p2.color == chess.WHITE:\n                        b += 0.4\n                        break\n        return float(w - b)\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'King mobility in simplified positions: (white_moveable_squares - black_moveable_squares) when low material'\n    try:\n        vals = {chess.PAWN:1.0, chess.KNIGHT:3.0, chess.BISHOP:3.0, chess.ROOK:5.0, chess.QUEEN:9.0, chess.KING:0.0}\n        pm = board.piece_map()\n        material = 0.0\n        for p in pm.values():\n            if p:\n                material += vals.get(p.piece_type, 0.0)\n        # only meaningful in endgame-ish positions\n        if material > 18.0:  # many pieces -> return small signal\n            return 0.0\n        wk = next((sq for sq,p in pm.items() if p and p.piece_type == chess.KING and p.color == chess.WHITE), None)\n        bk = next((sq for sq,p in pm.items() if p and p.piece_type == chess.KING and p.color == chess.BLACK), None)\n        def king_moves(king_sq, color):\n            if king_sq is None:\n                return 0.0\n            count = 0\n            for df in (-1,0,1):\n                for dr in (-1,0,1):\n                    if df == 0 and dr == 0: continue\n                    f = chess.square_file(king_sq) + df\n                    r = chess.square_rank(king_sq) + dr\n                    if 0 <= f <= 7 and 0 <= r <= 7:\n                        sq = chess.square(f, r)\n                        # legal move to that square? Use attackers and occupancy approx: only count if not occupied by friendly or square not attacked heavily?\n                        occ = board.piece_at(sq)\n                        if occ and occ.color == color:\n                            continue\n                        # count if square not attacked by many enemies (safer)\n                        attackers = len(board.attackers(not color, sq))\n                        if attackers <= 2:\n                            count += 1\n            return float(count)\n        km_w = king_moves(wk, chess.WHITE)\n        km_b = king_moves(bk, chess.BLACK)\n        return float(km_w - km_b)\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Bishop-pair bonus minus bad-bishop penalties: favors side with pair and few pawns on same color squares (white - black)'\n    try:\n        pm = board.piece_map()\n        def bishop_metric(color):\n            bishops = [sq for sq,p in pm.items() if p and p.color==color and p.piece_type==chess.BISHOP]\n            pawn_color_counts = {0:0, 1:0}  # light/dark pawn counts\n            for sq,p in pm.items():\n                if p and p.piece_type==chess.PAWN and p.color==color:\n                    sqc = (chess.square_file(sq) + chess.square_rank(sq)) & 1\n                    pawn_color_counts[sqc] += 1\n            score = 0.0\n            if len(bishops) >= 2:\n                score += 0.9\n            for b in bishops:\n                sc = (chess.square_file(b) + chess.square_rank(b)) & 1\n                # if many pawns on same color, bishop is likely \"bad\"\n                if pawn_color_counts.get(sc,0) >= 3:\n                    score -= 0.6\n                elif pawn_color_counts.get(sc,0) >= 2:\n                    score -= 0.3\n            return score\n        return float(bishop_metric(chess.WHITE) - bishop_metric(chess.BLACK))\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Count of tactically trapped pieces (low mobility and outnumbered attackers) (black_trapped - white_trapped)'\n    try:\n        pm = board.piece_map()\n        trapped = {chess.WHITE:0.0, chess.BLACK:0.0}\n        orig = board.turn\n        try:\n            for color in (chess.WHITE, chess.BLACK):\n                board.turn = color\n                # map from from_square to number of legal moves for that piece\n                move_counts = {}\n                for mv in board.legal_moves:\n                    move_counts[mv.from_square] = move_counts.get(mv.from_square, 0) + 1\n                for sq,p in pm.items():\n                    if not p or p.color != color or p.piece_type in (chess.PAWN, chess.KING):\n                        continue\n                    moves = move_counts.get(sq, 0)\n                    attackers = len(board.attackers(not color, sq))\n                    defenders = len(board.attackers(color, sq))\n                    # trapped heuristic: almost no moves and outnumbered by attackers\n                    if moves <= 1 and attackers >= 2 and defenders <= 1:\n                        # weight by piece importance\n                        weight = 1.0\n                        if p.piece_type == chess.QUEEN:\n                            weight = 3.0\n                        elif p.piece_type == chess.ROOK:\n                            weight = 1.6\n                        elif p.piece_type in (chess.BISHOP, chess.KNIGHT):\n                            weight = 1.0\n                        trapped[color] += weight\n        finally:\n            board.turn = orig\n        # more trapped pieces on Black is good for White\n        return float(trapped[chess.BLACK] - trapped[chess.WHITE])\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Knight outposts: knights on advanced stable outposts (white - black)'\n    try:\n        pm = board.piece_map()\n        def is_enemy_pawn_attacking(sq, enemy_color):\n            for a in board.attackers(enemy_color, sq):\n                p = pm.get(a)\n                if p and p.piece_type == chess.PAWN:\n                    return True\n            return False\n        def outpost_score(color):\n            s = 0.0\n            enemy = not color\n            for sq,p in pm.items():\n                if not p or p.color != color or p.piece_type != chess.KNIGHT:\n                    continue\n                r = chess.square_rank(sq)\n                # require the knight to be on advanced ranks (4th-6th from its perspective)\n                if color == chess.WHITE:\n                    if r < 3 or r > 5: continue\n                else:\n                    if r > 4 or r < 2: continue\n                # prefer if no enemy pawn attacks the square\n                if is_enemy_pawn_attacking(sq, enemy):\n                    continue\n                # require some support (own pawn or own minor piece attacks)\n                own_attackers = list(board.attackers(color, sq))\n                supported = any(pm.get(a) and (pm.get(a).piece_type in (chess.PAWN, chess.BISHOP, chess.KNIGHT)) for a in own_attackers)\n                if supported:\n                    s += 1.1\n            return s\n        return float(outpost_score(chess.WHITE) - outpost_score(chess.BLACK))\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Space advantage measured by occupied squares in opponent half weighted by piece type (white - black)'\n    try:\n        pm = board.piece_map()\n        score = {chess.WHITE:0.0, chess.BLACK:0.0}\n        for sq,p in pm.items():\n            if not p or p.piece_type == chess.KING:\n                continue\n            r = chess.square_rank(sq)\n            if p.color == chess.WHITE and r >= 4:\n                # white piece in black half\n                weight = 0.9 if p.piece_type == chess.PAWN else 1.2\n                score[chess.WHITE] += weight\n            if p.color == chess.BLACK and r <= 3:\n                weight = 0.9 if p.piece_type == chess.PAWN else 1.2\n                score[chess.BLACK] += weight\n        return float(score[chess.WHITE] - score[chess.BLACK])\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Hanging/undefended high-value pieces: weighted attackers-without-defenders (black_hangs - white_hangs), positive favors White'\n    try:\n        vals = {chess.PAWN:1.0, chess.KNIGHT:3.0, chess.BISHOP:3.0, chess.ROOK:5.0, chess.QUEEN:9.0, chess.KING:0.0}\n        pm = board.piece_map()\n        hangs = {chess.WHITE:0.0, chess.BLACK:0.0}\n        for sq,p in pm.items():\n            if not p:\n                continue\n            attackers = len(board.attackers(not p.color, sq))\n            defenders = len(board.attackers(p.color, sq))\n            if attackers > 0 and defenders == 0:\n                hangs[p.color] += vals.get(p.piece_type, 0.0)\n        # more hangs on Black is good for White\n        return float(hangs[chess.BLACK] - hangs[chess.WHITE])\n    except Exception:\n        return 0.0\n",
    "def feature(board: chess.Board) -> float:\n    'Bishop pair bonus scaled by board openness (more valuable when pawns are fewer)'\n    try:\n        pm = board.piece_map()\n        # Count bishops per color\n        bishops = {chess.WHITE:0, chess.BLACK:0}\n        pawn_count = 0\n        for sq,p in pm.items():\n            if not p: continue\n            if p.piece_type == chess.BISHOP:\n                bishops[p.color] += 1\n            if p.piece_type == chess.PAWN:\n                pawn_count += 1\n        # openness: fewer pawns -> more open\n        max_pawns = 16.0\n        openness = 1.0 - min(float(pawn_count) / max_pawns, 1.0)\n        # bishop pair bonus scaled by openness\n        bonus_per_pair = 1.5\n        score_w = bonus_per_pair * max(0, bishops[chess.WHITE] - 1) * openness\n        score_b = bonus_per_pair * max(0, bishops[chess.BLACK] - 1) * openness\n        return float(score_w - score_b)\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Passed pawn potential: counts passed pawns weighted by advancement and defenders (white - black)'\n    try:\n        pm = board.piece_map()\n        def is_passed(square, color):\n            f = chess.square_file(square); r = chess.square_rank(square)\n            if color == chess.WHITE:\n                # no black pawns on same file or adjacent files in front of or on same rank\n                for ff in range(max(0,f-1), min(7,f+1)+1):\n                    for rr in range(r+1, 8):\n                        p = pm.get(chess.square(ff, rr))\n                        if p and p.piece_type == chess.PAWN and p.color == chess.BLACK:\n                            return False\n                return True\n            else:\n                for ff in range(max(0,f-1), min(7,f+1)+1):\n                    for rr in range(0, r):\n                        p = pm.get(chess.square(ff, rr))\n                        if p and p.piece_type == chess.PAWN and p.color == chess.WHITE:\n                            return False\n                return True\n        vals = {chess.PAWN:1.0, chess.KNIGHT:3.0, chess.BISHOP:3.0, chess.ROOK:5.0, chess.QUEEN:9.0}\n        score = {chess.WHITE:0.0, chess.BLACK:0.0}\n        for sq,p in pm.items():\n            if not p or p.piece_type != chess.PAWN: continue\n            color = p.color\n            if is_passed(sq, color):\n                r = chess.square_rank(sq)\n                # advancement fraction: 0..1\n                adv = (r / 7.0) if color == chess.WHITE else ((7 - r) / 7.0)\n                # defenders on pawn\n                defenders = len(board.attackers(color, sq))\n                # weight defenders modestly\n                weight = 1.0 + 0.25 * min(defenders, 3)\n                score[color] += weight * (0.8 + 1.2 * adv)  # base + reward for advancement\n        return float(score[chess.WHITE] - score[chess.BLACK])\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Knight outposts: counts knights on advanced protected outpost squares (white - black)'\n    try:\n        pm = board.piece_map()\n        def knight_outposts(color):\n            cnt = 0.0\n            for sq,p in pm.items():\n                if not p or p.piece_type != chess.KNIGHT or p.color != color:\n                    continue\n                f = chess.square_file(sq); r = chess.square_rank(sq)\n                # outpost ranks: advanced ranks where knights are strong\n                if color == chess.WHITE and r < 3:  # too passive\n                    continue\n                if color == chess.BLACK and r > 4:\n                    continue\n                # check no opposing pawn can attack this square (opponent pawns that could capture to it)\n                opp = chess.BLACK if color == chess.WHITE else chess.WHITE\n                pawn_attackable = False\n                # squares from which opponent pawn would attack this square\n                if opp == chess.WHITE:\n                    # white pawn attacks from below-left/right: from r-1\n                    for df in (-1,1):\n                        sf = f + df; sr = r - 1\n                        if 0 <= sf < 8 and 0 <= sr < 8:\n                            pp = pm.get(chess.square(sf, sr))\n                            if pp and pp.piece_type == chess.PAWN and pp.color == opp:\n                                pawn_attackable = True; break\n                else:\n                    for df in (-1,1):\n                        sf = f + df; sr = r + 1\n                        if 0 <= sf < 8 and 0 <= sr < 8:\n                            pp = pm.get(chess.square(sf, sr))\n                            if pp and pp.piece_type == chess.PAWN and pp.color == opp:\n                                pawn_attackable = True; break\n                if pawn_attackable:\n                    continue\n                # check defended by a pawn or stable minor piece\n                defended_by_pawn = any((pm.get(sq2) and pm.get(sq2).piece_type == chess.PAWN and pm.get(sq2).color == color)\n                                       for sq2 in [chess.square(f-1, r-1), chess.square(f+1, r-1)] if 0 <= chess.square_file(sq2) < 8 and 0 <= chess.square_rank(sq2) < 8) if color==chess.WHITE else False\n                # simpler: check any friendly pawn attacks the knight square\n                pawn_attacks = False\n                for ff in range(8):\n                    for rr in range(8):\n                        s = chess.square(ff, rr)\n                        p2 = pm.get(s)\n                        if p2 and p2.piece_type == chess.PAWN and p2.color == color:\n                            if sq in board.attackers(color, sq) and sq in board.attackers(color, sq):\n                                pawn_attacks = True\n                # more reliable: check if any pawn of color attacks sq (using attackers)\n                pawn_defenders = [a for a in board.attackers(color, sq) if pm.get(a) and pm.get(a).piece_type == chess.PAWN]\n                if pawn_defenders:\n                    cnt += 1.0\n                else:\n                    # half credit if defended by other minor piece\n                    other_def = [a for a in board.attackers(color, sq) if pm.get(a) and pm.get(a).piece_type in (chess.BISHOP, chess.KNIGHT)]\n                    if other_def:\n                        cnt += 0.5\n            return cnt\n        out_w = knight_outposts(chess.WHITE)\n        out_b = knight_outposts(chess.BLACK)\n        return float(out_w - out_b)\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'King mobility (number of safe adjacent squares) scaled by endgame stage (white - black)'\n    try:\n        pm = board.piece_map()\n        vals = {chess.PAWN:1.0, chess.KNIGHT:3.0, chess.BISHOP:3.0, chess.ROOK:5.0, chess.QUEEN:9.0}\n        total_mat = 0.0\n        for p in pm.values():\n            if not p: continue\n            total_mat += vals.get(p.piece_type, 0.0)\n        # endgame factor: more weight to king mobility when less material\n        endgame_factor = 1.0 - min(total_mat / 40.0, 1.0)\n        def king_safe_squares(color):\n            ksq = next((sq for sq,p in pm.items() if p and p.piece_type == chess.KING and p.color == color), None)\n            if ksq is None:\n                return 0.0\n            safe = 0\n            kf = chess.square_file(ksq); kr = chess.square_rank(ksq)\n            opp = chess.BLACK if color == chess.WHITE else chess.WHITE\n            for df in (-1,0,1):\n                for dr in (-1,0,1):\n                    if df == 0 and dr == 0:\n                        continue\n                    ff = kf + df; rr = kr + dr\n                    if 0 <= ff < 8 and 0 <= rr < 8:\n                        s = chess.square(ff, rr)\n                        occ = pm.get(s)\n                        # King cannot move to a square occupied by friendly piece\n                        if occ and occ.color == color:\n                            continue\n                        # cannot move into square attacked by opponent\n                        if board.is_attacked_by(opp, s):\n                            continue\n                        safe += 1\n            return safe * endgame_factor\n        ks_w = king_safe_squares(chess.WHITE)\n        ks_b = king_safe_squares(chess.BLACK)\n        return float(ks_w - ks_b)\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Pawn control of central 4 squares (d4,e4,d5,e5): (white - black) count normalized'\n    try:\n        center_sqs = [chess.parse_square(s) for s in ('d4','e4','d5','e5')]\n        pm = board.piece_map()\n        def pawn_controls(color):\n            cnt = 0.0\n            for s in center_sqs:\n                # check if any pawn of color attacks this square\n                attackers = board.attackers(color, s)\n                for a in attackers:\n                    p = pm.get(a)\n                    if p and p.piece_type == chess.PAWN and p.color == color:\n                        cnt += 1.0\n                        break\n            return cnt / float(len(center_sqs))\n        return float(pawn_controls(chess.WHITE) - pawn_controls(chess.BLACK))\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Rook vs minor-piece imbalance: more rooks relative to minor pieces is valued (white - black)'\n    try:\n        pm = board.piece_map()\n        counts = {chess.WHITE:{'rook':0,'minor':0}, chess.BLACK:{'rook':0,'minor':0}}\n        for sq,p in pm.items():\n            if not p: continue\n            if p.piece_type == chess.ROOK:\n                counts[p.color]['rook'] += 1\n            if p.piece_type in (chess.BISHOP, chess.KNIGHT):\n                counts[p.color]['minor'] += 1\n        score_w = counts[chess.WHITE]['rook'] * 5.0 - counts[chess.WHITE]['minor'] * 3.0\n        score_b = counts[chess.BLACK]['rook'] * 5.0 - counts[chess.BLACK]['minor'] * 3.0\n        return float(score_w - score_b)\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Tactical initiative: sum of opponent piece values under net attack (attackers > defenders) (white - black)'\n    try:\n        pm = board.piece_map()\n        vals = {chess.PAWN:1.0, chess.KNIGHT:3.0, chess.BISHOP:3.0, chess.ROOK:5.0, chess.QUEEN:9.0, chess.KING:0.0}\n        pressure = {chess.WHITE:0.0, chess.BLACK:0.0}\n        for sq,p in pm.items():\n            if not p: continue\n            color = p.color\n            opp = chess.BLACK if color == chess.WHITE else chess.WHITE\n            attackers = len(board.attackers(opp, sq))\n            defenders = len(board.attackers(color, sq))\n            if attackers > defenders:\n                # reward proportional to value and net attackers\n                net = float(attackers - defenders)\n                contribution = vals.get(p.piece_type, 0.0) * min(1.0, net / 3.0) * 0.6\n                pressure[opp] += contribution\n        return float(pressure[chess.WHITE] - pressure[chess.BLACK])\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Pawn advancement pressure: sum of pawn advancement weighted by defenders (white - black)'\n    try:\n        pm = board.piece_map()\n        score = {chess.WHITE:0.0, chess.BLACK:0.0}\n        for sq,p in pm.items():\n            if not p or p.piece_type != chess.PAWN: continue\n            color = p.color\n            r = chess.square_rank(sq)\n            adv = (r / 7.0) if color == chess.WHITE else ((7 - r) / 7.0)\n            defenders = len(board.attackers(color, sq))\n            score[color] += (0.5 + adv) * (1.0 + 0.2 * min(defenders, 4))\n        return float(score[chess.WHITE] - score[chess.BLACK])\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Trapped piece penalty: counts poorly mobile non-pawn pieces with attackers (black - white gives advantage to White if Black has more trapped pieces)'\n    try:\n        pm = board.piece_map()\n        trapped = {chess.WHITE:0.0, chess.BLACK:0.0}\n        orig = board.turn\n        try:\n            for color in (chess.WHITE, chess.BLACK):\n                board.turn = color\n                for sq,p in list(pm.items()):\n                    if not p or p.color != color or p.piece_type in (chess.PAWN, chess.KING):\n                        continue\n                    # count legal moves for this piece\n                    moves = 0\n                    for mv in board.legal_moves:\n                        if mv.from_square == sq:\n                            moves += 1\n                            if moves > 2:\n                                break\n                    attackers = len(board.attackers(chess.BLACK if color == chess.WHITE else chess.WHITE, sq))\n                    if moves <= 1 and attackers > 0:\n                        # more trapped if less moves and attacked\n                        trapped[color] += 1.0 + 0.5 * attackers\n        finally:\n            board.turn = orig\n        # positive means White advantage if Black has more trapped pieces\n        return float(trapped[chess.BLACK] - trapped[chess.WHITE])\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Heavy-piece alignment to enemy king (rooks/queens/bishops on same ray with clear path) (white - black)'\n    try:\n        pm = board.piece_map()\n        def align_score(color):\n            score = 0.0\n            opp = chess.BLACK if color == chess.WHITE else chess.WHITE\n            ksq = next((sq for sq,p in pm.items() if p and p.piece_type == chess.KING and p.color == opp), None)\n            if ksq is None:\n                return 0.0\n            kf = chess.square_file(ksq); kr = chess.square_rank(ksq)\n            for sq,p in pm.items():\n                if not p or p.color != color: continue\n                if p.piece_type not in (chess.ROOK, chess.QUEEN, chess.BISHOP):\n                    continue\n                f = chess.square_file(sq); r = chess.square_rank(sq)\n                df = kf - f; dr = kr - r\n                # rook/queen file or rank alignment\n                if f == kf or r == kr:\n                    # check clear path\n                    clear = True\n                    if f == kf:\n                        step = 1 if kr > r else -1\n                        for rr in range(r+step, kr, step):\n                            if pm.get(chess.square(f, rr)):\n                                clear = False; break\n                    else:\n                        step = 1 if kf > f else -1\n                        for ff in range(f+step, kf, step):\n                            if pm.get(chess.square(ff, r)):\n                                clear = False; break\n                    if clear:\n                        score += 1.2 if p.piece_type == chess.ROOK else 1.8\n                # bishop/queen diagonal alignment\n                if abs(df) == abs(dr) and df != 0:\n                    stepf = 1 if df > 0 else -1\n                    stepr = 1 if dr > 0 else -1\n                    clear = True\n                    steps = abs(df)\n                    for i in range(1, steps):\n                        if pm.get(chess.square(f + i*stepf, r + i*stepr)):\n                            clear = False; break\n                    if clear:\n                        score += 1.1 if p.piece_type == chess.BISHOP else 1.8\n            return score\n        return float(align_score(chess.WHITE) - align_score(chess.BLACK))\n    except Exception:\n        return 0.0\n",
    "def feature(board: chess.Board) -> float:\n    'Control of central squares (d4,e4,d5,e5) weighted by attacker piece value (white - black)'\n    try:\n        center_names = ['d4', 'e4', 'd5', 'e5']\n        centers = [chess.parse_square(n) for n in center_names]\n        vals = {chess.PAWN:0.5, chess.KNIGHT:1.0, chess.BISHOP:1.0, chess.ROOK:1.5, chess.QUEEN:2.0, chess.KING:0.0}\n        pm = board.piece_map()\n        score = {chess.WHITE:0.0, chess.BLACK:0.0}\n        for sq in centers:\n            for color in (chess.WHITE, chess.BLACK):\n                attackers = board.attackers(color, sq)\n                for a in attackers:\n                    p = pm.get(a)\n                    if p:\n                        score[color] += vals.get(p.piece_type, 0.0)\n        return float(score[chess.WHITE] - score[chess.BLACK])\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Rooks on open or semi-open files: (open*1.0 + semi-open*0.5) difference (white - black)'\n    try:\n        pm = board.piece_map()\n        open_score = {chess.WHITE:0.0, chess.BLACK:0.0}\n        for sq, p in pm.items():\n            if not p or p.piece_type != chess.ROOK:\n                continue\n            f = chess.square_file(sq)\n            # count pawns on file\n            pawns_on_file = 0\n            friendly_pawns = 0\n            for r in range(8):\n                s = chess.square(f, r)\n                q = pm.get(s)\n                if q and q.piece_type == chess.PAWN:\n                    pawns_on_file += 1\n                    if q.color == p.color:\n                        friendly_pawns += 1\n            val = 0.0\n            if pawns_on_file == 0:\n                val = 1.0\n            elif friendly_pawns == 0:\n                val = 0.5\n            open_score[p.color] += val\n        return float(open_score[chess.WHITE] - open_score[chess.BLACK])\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Knight outposts: knights supported by friendly pawn and not attacked by enemy pawns on advanced central squares (white - black)'\n    try:\n        pm = board.piece_map()\n        outpost = {chess.WHITE:0.0, chess.BLACK:0.0}\n        for sq, p in pm.items():\n            if not p or p.piece_type != chess.KNIGHT:\n                continue\n            f = chess.square_file(sq)\n            r = chess.square_rank(sq)\n            color = p.color\n            # require somewhat advanced and somewhat central-ish: files 2..5 and ranks >=3 for white, <=4 for black\n            central_file = 2 <= f <= 5\n            advanced = (color == chess.WHITE and r >= 3) or (color == chess.BLACK and r <= 4)\n            if not (central_file and advanced):\n                continue\n            # supported by a friendly pawn\n            friendly_attackers = board.attackers(color, sq)\n            supported_by_pawn = any((pm.get(a) and pm.get(a).piece_type == chess.PAWN and pm.get(a).color == color) for a in friendly_attackers)\n            # attacked by enemy pawns?\n            enemy = chess.BLACK if color == chess.WHITE else chess.WHITE\n            enemy_pawn_attackers = any((pm.get(a) and pm.get(a).piece_type == chess.PAWN and pm.get(a).color == enemy) for a in board.attackers(enemy, sq))\n            if supported_by_pawn and not enemy_pawn_attackers:\n                outpost[color] += 1.0\n        return float(outpost[chess.WHITE] - outpost[chess.BLACK])\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Bishop mobility: total number of reachable squares along diagonals (including single capture squares) difference (white - black)'\n    try:\n        pm = board.piece_map()\n        mobility = {chess.WHITE:0.0, chess.BLACK:0.0}\n        dirs = [(1,1),(1,-1),(-1,1),(-1,-1)]\n        for sq,p in pm.items():\n            if not p or p.piece_type != chess.BISHOP:\n                continue\n            f = chess.square_file(sq); r = chess.square_rank(sq)\n            count = 0\n            for df, dr in dirs:\n                ff, rr = f + df, r + dr\n                while 0 <= ff < 8 and 0 <= rr < 8:\n                    s = chess.square(ff, rr)\n                    q = pm.get(s)\n                    if q is None:\n                        count += 1\n                        ff += df; rr += dr\n                        continue\n                    else:\n                        # can capture opponent once then blocked\n                        if q.color != p.color:\n                            count += 1\n                        break\n            mobility[p.color] += float(count)\n        return float(mobility[chess.WHITE] - mobility[chess.BLACK])\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Rooks on the seventh rank (opponent second rank) count difference (white - black)'\n    try:\n        pm = board.piece_map()\n        score = {chess.WHITE:0.0, chess.BLACK:0.0}\n        for sq,p in pm.items():\n            if not p or p.piece_type != chess.ROOK:\n                continue\n            r = chess.square_rank(sq)\n            if p.color == chess.WHITE and r == 6:\n                score[chess.WHITE] += 1.0\n            if p.color == chess.BLACK and r == 1:\n                score[chess.BLACK] += 1.0\n        return float(score[chess.WHITE] - score[chess.BLACK])\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Castled status proxy: +1 if white appears castled (king on g1 or c1, g2/c2 variants), -1 if black appears castled (white - black)'\n    try:\n        pm = board.piece_map()\n        white_castled = 0.0\n        black_castled = 0.0\n        # consider castled if king on typical castled squares\n        wk_sq = next((sq for sq,p in pm.items() if p and p.piece_type == chess.KING and p.color == chess.WHITE), None)\n        bk_sq = next((sq for sq,p in pm.items() if p and p.piece_type == chess.KING and p.color == chess.BLACK), None)\n        if wk_sq is not None:\n            # common castled squares for white: g1 (file 6 rank 0) or c1 (file 2 rank 0)\n            if (chess.square_file(wk_sq), chess.square_rank(wk_sq)) in ((6,0),(2,0)):\n                white_castled = 1.0\n        if bk_sq is not None:\n            if (chess.square_file(bk_sq), chess.square_rank(bk_sq)) in ((6,7),(2,7)):\n                black_castled = 1.0\n        return float(white_castled - black_castled)\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Queen central mobility: number of squares reachable by queen(s) (sliding + captures) difference (white - black)'\n    try:\n        pm = board.piece_map()\n        mobility = {chess.WHITE:0.0, chess.BLACK:0.0}\n        directions = [(1,0),(-1,0),(0,1),(0,-1),(1,1),(1,-1),(-1,1),(-1,-1)]\n        for sq,p in pm.items():\n            if not p or p.piece_type != chess.QUEEN:\n                continue\n            f = chess.square_file(sq); r = chess.square_rank(sq)\n            count = 0\n            for df, dr in directions:\n                ff, rr = f + df, r + dr\n                while 0 <= ff < 8 and 0 <= rr < 8:\n                    s = chess.square(ff, rr)\n                    q = pm.get(s)\n                    if q is None:\n                        count += 1\n                        ff += df; rr += dr\n                        continue\n                    else:\n                        if q.color != p.color:\n                            count += 1\n                        break\n            mobility[p.color] += float(count)\n        return float(mobility[chess.WHITE] - mobility[chess.BLACK])\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Weak squares around kings: count of adjacent squares with more enemy attackers than defenders (black_weak - white_weak), positive favors White'\n    try:\n        pm = board.piece_map()\n        def weak_around(color):\n            king_sq = next((sq for sq,p in pm.items() if p and p.piece_type == chess.KING and p.color == color), None)\n            if king_sq is None:\n                return 0.0\n            f = chess.square_file(king_sq); r = chess.square_rank(king_sq)\n            weak = 0.0\n            enemy = chess.BLACK if color == chess.WHITE else chess.WHITE\n            for ff in range(max(0, f-1), min(7, f+1)+1):\n                for rr in range(max(0, r-1), min(7, r+1)+1):\n                    if ff == f and rr == r:\n                        continue\n                    sq = chess.square(ff, rr)\n                    attackers = len(board.attackers(enemy, sq))\n                    defenders = len(board.attackers(color, sq))\n                    if attackers > defenders:\n                        weak += 1.0\n            return weak\n        w = weak_around(chess.WHITE)\n        b = weak_around(chess.BLACK)\n        return float(b - w)\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Piece coordination: fraction of non-pawn non-king pieces that are defended by a friendly piece difference (white - black)'\n    try:\n        pm = board.piece_map()\n        coord = {chess.WHITE:[0,0], chess.BLACK:[0,0]}  # [protected_count, total_count]\n        for sq,p in pm.items():\n            if not p or p.piece_type in (chess.PAWN, chess.KING):\n                continue\n            color = p.color\n            total, prot = coord[color]\n            total += 1\n            defenders = board.attackers(color, sq)\n            # ignore self (shouldn't be in attackers) but ensure at least one defender that is not the piece itself\n            has_def = any((pm.get(a) and a != sq) for a in defenders)\n            if has_def:\n                prot += 1\n            coord[color] = [prot, total]\n        def frac(color):\n            prot, total = coord[color]\n            return (float(prot) / float(total)) if total > 0 else 0.0\n        return float(frac(chess.WHITE) - frac(chess.BLACK))\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Endgame king centrality emphasis: king closeness to center weighted by low non-king material (white - black)'\n    try:\n        pm = board.piece_map()\n        vals = {chess.PAWN:1.0, chess.KNIGHT:3.0, chess.BISHOP:3.0, chess.ROOK:5.0, chess.QUEEN:9.0}\n        nonking_total = 0.0\n        for p in pm.values():\n            if not p:\n                continue\n            if p.piece_type != chess.KING:\n                nonking_total += vals.get(p.piece_type, 0.0)\n        # scale encourages king activity when material is low\n        scale = max(0.0, (14.0 - nonking_total) / 14.0)\n        centers = [chess.parse_square(n) for n in ('d4','e4','d5','e5')]\n        def king_centrality(color):\n            ksq = next((sq for sq,p in pm.items() if p and p.piece_type == chess.KING and p.color == color), None)\n            if ksq is None:\n                return 0.0\n            # closeness measured as inverse of min distance to central squares\n            min_d = min(chess.square_distance(ksq, c) for c in centers)\n            closeness = (7.0 - float(min_d)) / 7.0\n            return closeness * scale\n        return float(king_centrality(chess.WHITE) - king_centrality(chess.BLACK))\n    except Exception:\n        return 0.0\n",
    "def feature(board: chess.Board) -> float:\n    'Control of opponent half: difference in number of unique squares in the opponent half attacked by White vs Black (positive favors White)'\n    try:\n        total_w = 0\n        total_b = 0\n        # For White, opponent half is ranks 4..7 (0-based ranks 4-7). For Black, opponent half ranks 0..3.\n        for sq in range(64):\n            r = chess.square_rank(sq)\n            if r >= 4:\n                if board.is_attacked_by(chess.WHITE, sq):\n                    total_w += 1\n            if r <= 3:\n                if board.is_attacked_by(chess.BLACK, sq):\n                    total_b += 1\n        # Normalize by half-board squares (32)\n        return float((total_w - total_b) / 32.0)\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Weighted proximity of pieces to the enemy king: sum of inverse distances of major/minor pieces to opposing king (white - black)'\n    try:\n        pm = board.piece_map()\n        # locate kings\n        wk = next((sq for sq,p in pm.items() if p and p.piece_type == chess.KING and p.color == chess.WHITE), None)\n        bk = next((sq for sq,p in pm.items() if p and p.piece_type == chess.KING and p.color == chess.BLACK), None)\n        if wk is None or bk is None:\n            return 0.0\n        vals = {chess.QUEEN:9.0, chess.ROOK:5.0, chess.BISHOP:3.0, chess.KNIGHT:3.0, chess.PAWN:1.0, chess.KING:0.0}\n        score_w = 0.0\n        score_b = 0.0\n        for sq,p in pm.items():\n            if not p or p.piece_type == chess.KING:\n                continue\n            if p.color == chess.WHITE:\n                d = chess.square_distance(sq, bk)\n                inv = 1.0 / (1.0 + float(d))\n                score_w += vals.get(p.piece_type, 0.0) * inv\n            else:\n                d = chess.square_distance(sq, wk)\n                inv = 1.0 / (1.0 + float(d))\n                score_b += vals.get(p.piece_type, 0.0) * inv\n        # scale down to keep values modest\n        return float((score_w - score_b) / 10.0)\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Passed pawn potential: sum of advancement of passed pawns weighted by pass status and support (white - black)'\n    try:\n        pm = board.piece_map()\n        pawns = {chess.WHITE: [], chess.BLACK: []}\n        for sq,p in pm.items():\n            if p and p.piece_type == chess.PAWN:\n                pawns[p.color].append(sq)\n        def is_passed(sq, color):\n            f = chess.square_file(sq); r = chess.square_rank(sq)\n            opp = chess.BLACK if color == chess.WHITE else chess.WHITE\n            for sq2 in pawns[opp]:\n                ff = chess.square_file(sq2); rr = chess.square_rank(sq2)\n                if abs(ff - f) <= 1:\n                    if color == chess.WHITE and rr > r:\n                        return False\n                    if color == chess.BLACK and rr < r:\n                        return False\n            return True\n        score_w = 0.0; score_b = 0.0\n        for color in (chess.WHITE, chess.BLACK):\n            for sq in pawns[color]:\n                r = chess.square_rank(sq)\n                adv = (float(r) / 7.0) if color == chess.WHITE else (float(7 - r) / 7.0)\n                passed = 1.0 if is_passed(sq, color) else 0.0\n                # supported if own piece/pawn attacks the pawn square\n                support = 1.0 if any((pm.get(a) and pm.get(a).color == color and pm.get(a).piece_type == chess.PAWN) for a in board.attackers(color, sq)) else 0.0\n                val = adv * (1.0 + 0.8 * passed + 0.5 * support)\n                if color == chess.WHITE:\n                    score_w += val\n                else:\n                    score_b += val\n        return float(score_w - score_b)\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Knights on outposts: count of knights on outpost squares (supported by pawn and not attackable by opponent pawn) (white - black)'\n    try:\n        pm = board.piece_map()\n        out_w = 0.0; out_b = 0.0\n        for sq,p in pm.items():\n            if not p or p.piece_type != chess.KNIGHT:\n                continue\n            color = p.color\n            opp = chess.BLACK if color == chess.WHITE else chess.WHITE\n            # check if any opponent pawn attacks this square\n            opp_pawn_attackers = [a for a in board.attackers(opp, sq) if pm.get(a) and pm.get(a).piece_type == chess.PAWN]\n            friendly_pawn_support = [a for a in board.attackers(color, sq) if pm.get(a) and pm.get(a).piece_type == chess.PAWN]\n            r = chess.square_rank(sq)\n            # outpost if supported by pawn or on advanced rank (5th/6th for white, 3rd/4th for black), and opponent pawns do not attack\n            advanced = (color == chess.WHITE and r >= 4) or (color == chess.BLACK and r <= 3)\n            if (friendly_pawn_support or advanced) and (not opp_pawn_attackers):\n                if color == chess.WHITE:\n                    out_w += 1.0\n                else:\n                    out_b += 1.0\n        return float(out_w - out_b)\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Rook file openness: difference in number of rooks on open or semi-open files and their potential to access enemy ranks (white - black)'\n    try:\n        pm = board.piece_map()\n        def rook_score_for(color):\n            score = 0.0\n            for sq,p in pm.items():\n                if not p or p.piece_type != chess.ROOK or p.color != color:\n                    continue\n                f = chess.square_file(sq)\n                # count pawns on file\n                friendly_pawns = 0; any_pawns = 0\n                for r in range(8):\n                    p2 = pm.get(chess.square(f, r))\n                    if p2 and p2.piece_type == chess.PAWN:\n                        any_pawns += 1\n                        if p2.color == color:\n                            friendly_pawns += 1\n                # open file = no pawns; semi-open = no friendly pawns but some opponent pawns\n                if any_pawns == 0:\n                    score += 1.5\n                elif friendly_pawns == 0:\n                    score += 0.9\n                # extra if rook has direct line toward enemy king file (same logic as earlier but simplified)\n                opp_king_sq = next((sqk for sqk, pk in pm.items() if pk and pk.piece_type == chess.KING and pk.color != color), None)\n                if opp_king_sq is not None and chess.square_file(opp_king_sq) == f:\n                    # reward if path unobstructed\n                    rf = chess.square_rank(sq); rk = chess.square_rank(opp_king_sq)\n                    step = 1 if rk > rf else -1\n                    rr = rf + step\n                    blocked = False\n                    while rr != rk:\n                        if board.piece_at(chess.square(f, rr)) is not None:\n                            blocked = True\n                            break\n                        rr += step\n                    if not blocked:\n                        score += 0.8\n            return score\n        return float(rook_score_for(chess.WHITE) - rook_score_for(chess.BLACK))\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Threatened material balance: difference between opponent material currently attacked by White and material attacked by Black (positive favors White)'\n    try:\n        vals = {chess.PAWN:1.0, chess.KNIGHT:3.0, chess.BISHOP:3.0, chess.ROOK:5.0, chess.QUEEN:9.0, chess.KING:0.0}\n        pm = board.piece_map()\n        threatened_by_white = 0.0\n        threatened_by_black = 0.0\n        for sq,p in pm.items():\n            if not p:\n                continue\n            # is this piece attacked by the opponent?\n            attackers_from_white = board.attackers(chess.WHITE, sq)\n            attackers_from_black = board.attackers(chess.BLACK, sq)\n            if p.color == chess.WHITE:\n                if attackers_from_black:\n                    threatened_by_black += vals.get(p.piece_type, 0.0)\n            else:\n                if attackers_from_white:\n                    threatened_by_white += vals.get(p.piece_type, 0.0)\n        # positive means White is threatening more opponent material than Black threatens White\n        return float(threatened_by_white - threatened_by_black)\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Bishop blockage index: difference in mobility potential for bishops (fraction of reachable diagonal squares) (white - black)'\n    try:\n        pm = board.piece_map()\n        def bishop_mobility(color):\n            total = 0.0\n            max_possible = 0.0\n            for sq,p in pm.items():\n                if not p or p.piece_type != chess.BISHOP or p.color != color:\n                    continue\n                # iterate four diagonals\n                f = chess.square_file(sq); r = chess.square_rank(sq)\n                for df, dr in ((1,1),(1,-1),(-1,1),(-1,-1)):\n                    steps = 0\n                    ff = f + df; rr = r + dr\n                    while 0 <= ff < 8 and 0 <= rr < 8:\n                        max_possible += 1.0\n                        occupant = board.piece_at(chess.square(ff, rr))\n                        # if empty square, it's reachable and we can continue\n                        if occupant is None:\n                            total += 1.0\n                        else:\n                            # occupied square is reachable as a capture only if occupant is opponent\n                            if occupant.color != color:\n                                total += 1.0\n                            break\n                        ff += df; rr += dr\n            # avoid divide by zero\n            return (total / max(1.0, max_possible)) if max_possible > 0 else 0.0\n        return float(bishop_mobility(chess.WHITE) - bishop_mobility(chess.BLACK))\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'King centralization scaled by game phase: endgame favors central kings, opening favors tucked kings (positive favors White)'\n    try:\n        pm = board.piece_map()\n        # compute non-king material sum\n        vals = {chess.PAWN:1.0, chess.KNIGHT:3.0, chess.BISHOP:3.0, chess.ROOK:5.0, chess.QUEEN:9.0}\n        mat_sum = 0.0\n        for p in pm.values():\n            if p and p.piece_type in vals:\n                mat_sum += vals[p.piece_type]\n        # phase weight: 1.0 is endgame strongly, 0.0 is opening\n        phase = max(0.0, min(1.0, (30.0 - mat_sum) / 20.0))  # roughly scales to 0..1\n        # center squares: d4,d5,e4,e5 -> files 3-4, ranks 3-4\n        centers = [chess.parse_square(s) for s in ('d4','d5','e4','e5')]\n        def centralization(color):\n            ksq = next((sq for sq,p in pm.items() if p and p.piece_type == chess.KING and p.color == color), None)\n            if ksq is None:\n                return 0.0\n            # minimal Manhattan distance to center squares (max possible ~7)\n            md = min(chess.square_distance(ksq, c) for c in centers)\n            # normalize: closer -> higher\n            return (7.0 - float(md)) / 7.0\n        cent_w = centralization(chess.WHITE)\n        cent_b = centralization(chess.BLACK)\n        # In endgame centralization is good (positive), in opening it's negative (penalize central kings)\n        # combine: weight positive by phase, negative by (1-phase)\n        score = (phase * (cent_w - cent_b)) - ((1.0 - phase) * (cent_w - cent_b) * 0.6)\n        return float(score)\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Zugzwang risk in low-material positions: favors the side not to move if the side to move has few legal moves and not in check (positive favors White)'\n    try:\n        # compute simplified material count (exclude kings)\n        vals = {chess.PAWN:1.0, chess.KNIGHT:3.0, chess.BISHOP:3.0, chess.ROOK:5.0, chess.QUEEN:9.0}\n        pm = board.piece_map()\n        mat_sum = 0.0\n        for p in pm.values():\n            if p and p.piece_type in vals:\n                mat_sum += vals[p.piece_type]\n        # only meaningful in light-material situations\n        if mat_sum > 12.0:\n            return 0.0\n        try:\n            orig = board.turn\n            moves = sum(1 for _ in board.legal_moves)\n        finally:\n            board.turn = orig\n        if board.is_check():\n            return 0.0\n        # if few legal moves, side-to-move is at risk\n        if moves >= 12:\n            return 0.0\n        # compute intensity (0..1)\n        intensity = (12.0 - float(moves)) / 12.0\n        # positive if Black to move (good for White), negative if White to move (bad for White)\n        sign = 1.0 if board.turn == chess.BLACK else -1.0\n        # scale by endgame-ness\n        endgame_weight = max(0.0, (12.0 - mat_sum) / 12.0)\n        return float(sign * intensity * endgame_weight)\n    except Exception:\n        return 0.0\n",
    "def feature(board: chess.Board) -> float:\n    'Piece-square centralization: weighted sum of piece values on central/extended-center squares (white - black)'\n    try:\n        vals = {chess.PAWN:1.0, chess.KNIGHT:3.2, chess.BISHOP:3.3, chess.ROOK:5.0, chess.QUEEN:9.0, chess.KING:0.0}\n        # weights: central 4 squares get highest, next ring medium, outer ring small\n        central4 = {chess.parse_square(s) for s in ('d4','d5','e4','e5')}\n        medium = set()\n        outer = set()\n        for f in range(8):\n            for r in range(8):\n                sq = chess.square(f, r)\n                if sq in central4:\n                    continue\n                # distance to nearest central square (Manhattan)\n                d = min(chess.square_distance(sq, c) for c in central4)\n                if d == 1:\n                    medium.add(sq)\n                else:\n                    outer.add(sq)\n        score = {chess.WHITE:0.0, chess.BLACK:0.0}\n        for sq, p in board.piece_map().items():\n            if not p:\n                continue\n            w = 0.4\n            if sq in central4:\n                w = 1.0\n            elif sq in medium:\n                w = 0.7\n            else:\n                w = 0.2\n            score[p.color] += vals.get(p.piece_type, 0.0) * w\n        return float(score[chess.WHITE] - score[chess.BLACK])\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Rook file control: rooks on open files (no pawns) and semi-open files (no friendly pawns) weighted (white - black)'\n    try:\n        pm = board.piece_map()\n        rook_score = {chess.WHITE:0.0, chess.BLACK:0.0}\n        # count pawns per file by color and total\n        pawns_on_file = {f: {chess.WHITE:0, chess.BLACK:0, 'total':0} for f in range(8)}\n        for sq, p in pm.items():\n            if p and p.piece_type == chess.PAWN:\n                f = chess.square_file(sq)\n                pawns_on_file[f][p.color] += 1\n                pawns_on_file[f]['total'] += 1\n        for sq, p in pm.items():\n            if not p or p.piece_type != chess.ROOK:\n                continue\n            f = chess.square_file(sq)\n            if pawns_on_file[f]['total'] == 0:\n                rook_score[p.color] += 1.2  # open file bonus\n            elif pawns_on_file[f][p.color] == 0:\n                rook_score[p.color] += 0.7  # semi-open\n            else:\n                rook_score[p.color] += 0.1  # little value otherwise\n        return float(rook_score[chess.WHITE] - rook_score[chess.BLACK])\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Bishop pair and reach: bonus for bishop pair plus aggregated unobstructed diagonal reach (white - black)'\n    try:\n        pm = board.piece_map()\n        vals = {chess.BISHOP:0.9}  # pair bonus\n        reach = {chess.WHITE:0.0, chess.BLACK:0.0}\n        pair_bonus = {chess.WHITE:0.0, chess.BLACK:0.0}\n        for sq, p in pm.items():\n            if not p:\n                continue\n            if p.piece_type == chess.BISHOP:\n                f = chess.square_file(sq); r = chess.square_rank(sq)\n                # for each diagonal direction count squares until blocked\n                dirs = [(-1,-1),(-1,1),(1,-1),(1,1)]\n                for df, dr in dirs:\n                    ff = f + df; rr = r + dr\n                    dist = 0\n                    while 0 <= ff <= 7 and 0 <= rr <= 7:\n                        cur = chess.square(ff, rr)\n                        if pm.get(cur):\n                            break\n                        dist += 1\n                        ff += df; rr += dr\n                    reach[p.color] += float(dist)\n        # bishop pair detection\n        counts = {chess.WHITE:0, chess.BLACK:0}\n        for p in pm.values():\n            if p and p.piece_type == chess.BISHOP:\n                counts[p.color] += 1\n        for color in (chess.WHITE, chess.BLACK):\n            if counts[color] >= 2:\n                pair_bonus[color] = 1.5\n        # combine\n        score = (pair_bonus[chess.WHITE] + 0.14 * reach[chess.WHITE]) - (pair_bonus[chess.BLACK] + 0.14 * reach[chess.BLACK])\n        return float(score)\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'King centralization in endgames: favors the side whose king is closer to center when material is low (positive if White better)'\n    try:\n        pm = board.piece_map()\n        # determine endgame factor by remaining major+minor material (excluding pawns and kings)\n        material_count = 0\n        for p in pm.values():\n            if p and p.piece_type not in (chess.PAWN, chess.KING):\n                material_count += 1\n        # if many pieces, this should be small; if few, this should be large\n        endgame_factor = 1.0 if material_count <= 4 else max(0.0, 1.0 - (material_count - 4) * 0.2)\n        # find kings\n        wk = next((sq for sq,p in pm.items() if p and p.piece_type == chess.KING and p.color == chess.WHITE), None)\n        bk = next((sq for sq,p in pm.items() if p and p.piece_type == chess.KING and p.color == chess.BLACK), None)\n        if wk is None or bk is None:\n            return 0.0\n        centers = [chess.parse_square(s) for s in ('d4','d5','e4','e5')]\n        def min_center_dist(sq):\n            return min(chess.square_distance(sq, c) for c in centers)\n        wd = float(min_center_dist(wk))\n        bd = float(min_center_dist(bk))\n        # smaller distance is better; return positive if White king better (closer)\n        return float((bd - wd) * endgame_factor)\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Knight outpost presence: counts knights on advanced outpost squares that are hard to dislodge (white - black)'\n    try:\n        pm = board.piece_map()\n        outpost = {chess.WHITE:0.0, chess.BLACK:0.0}\n        for sq, p in pm.items():\n            if not p or p.piece_type != chess.KNIGHT:\n                continue\n            f = chess.square_file(sq); r = chess.square_rank(sq)\n            color = p.color\n            opp = chess.BLACK if color == chess.WHITE else chess.WHITE\n            # candidate outpost: not on file edge and advanced (rank >= 3 for white, <=4 for black)\n            if f in (0,7):\n                continue\n            if color == chess.WHITE and r < 3:\n                continue\n            if color == chess.BLACK and r > 4:\n                continue\n            # check for enemy pawn presence on adjacent files in front of knight that could challenge it\n            blocked_by_enemy_pawn = False\n            for af in (f-1, f+1):\n                if 0 <= af < 8:\n                    # for white knight, enemy pawns ahead are on ranks > r\n                    for ar in range(8):\n                        if color == chess.WHITE:\n                            if ar > r:\n                                pp = board.piece_at(chess.square(af, ar))\n                                if pp and pp.piece_type == chess.PAWN and pp.color == opp:\n                                    blocked_by_enemy_pawn = True\n                                    break\n                        else:\n                            if ar < r:\n                                pp = board.piece_at(chess.square(af, ar))\n                                if pp and pp.piece_type == chess.PAWN and pp.color == opp:\n                                    blocked_by_enemy_pawn = True\n                                    break\n                    if blocked_by_enemy_pawn:\n                        break\n            if blocked_by_enemy_pawn:\n                continue\n            # reward if supported by a friendly pawn (strong outpost)\n            supported = False\n            for af in (f-1, f+1):\n                if 0 <= af < 8:\n                    if color == chess.WHITE:\n                        # pawn behind (lower rank)\n                        for ar in range(0, r):\n                            pp = board.piece_at(chess.square(af, ar))\n                            if pp and pp.piece_type == chess.PAWN and pp.color == color:\n                                supported = True; break\n                    else:\n                        for ar in range(r+1, 8):\n                            pp = board.piece_at(chess.square(af, ar))\n                            if pp and pp.piece_type == chess.PAWN and pp.color == color:\n                                supported = True; break\n                if supported:\n                    break\n            outpost[color] += 1.3 if supported else 0.7\n        return float(outpost[chess.WHITE] - outpost[chess.BLACK])\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Pawn structure weakness: combined score of doubled and backward pawns (black_weakness - white_weakness); positive favors White'\n    try:\n        pm = board.piece_map()\n        vals = {chess.WHITE:0.0, chess.BLACK:0.0}\n        # doubled pawns per file\n        pawns_by_file = {f: {chess.WHITE:[], chess.BLACK:[]} for f in range(8)}\n        for sq, p in pm.items():\n            if p and p.piece_type == chess.PAWN:\n                pawns_by_file[chess.square_file(sq)][p.color].append(sq)\n        for f in range(8):\n            for color in (chess.WHITE, chess.BLACK):\n                n = len(pawns_by_file[f][color])\n                if n > 1:\n                    vals[color] += 0.8 * (n - 1)  # penalty per doubled pawn beyond first\n        # backward pawn heuristic: pawn with no friendly pawn on adjacent files behind it\n        for sq, p in pm.items():\n            if not p or p.piece_type != chess.PAWN:\n                continue\n            color = p.color\n            f = chess.square_file(sq); r = chess.square_rank(sq)\n            has_support_behind = False\n            for af in (f-1, f+1):\n                if 0 <= af < 8:\n                    if color == chess.WHITE:\n                        for ar in range(0, r):\n                            pp = board.piece_at(chess.square(af, ar))\n                            if pp and pp.piece_type == chess.PAWN and pp.color == color:\n                                has_support_behind = True; break\n                    else:\n                        for ar in range(r+1, 8):\n                            pp = board.piece_at(chess.square(af, ar))\n                            if pp and pp.piece_type == chess.PAWN and pp.color == color:\n                                has_support_behind = True; break\n                if has_support_behind:\n                    break\n            if not has_support_behind:\n                # small backward penalty, larger if there is an enemy pawn in front blocking progress\n                blocked = False\n                if color == chess.WHITE:\n                    for ar in range(r+1, 8):\n                        pp = board.piece_at(chess.square(f, ar))\n                        if pp and pp.piece_type == chess.PAWN and pp.color != color:\n                            blocked = True; break\n                else:\n                    for ar in range(r-1, -1, -1):\n                        pp = board.piece_at(chess.square(f, ar))\n                        if pp and pp.piece_type == chess.PAWN and pp.color != color:\n                            blocked = True; break\n                vals[color] += 0.9 if blocked else 0.45\n        # black_weakness is favorable to white -> return black - white\n        return float(vals[chess.BLACK] - vals[chess.WHITE])\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Attacked but undefended piece value sum: net value of opponent pieces that are attacked and not defended (black_unprotected - white_unprotected)'\n    try:\n        pm = board.piece_map()\n        vals = {chess.PAWN:1.0, chess.KNIGHT:3.0, chess.BISHOP:3.0, chess.ROOK:5.0, chess.QUEEN:9.0, chess.KING:0.0}\n        unprotected = {chess.WHITE:0.0, chess.BLACK:0.0}\n        for sq, p in pm.items():\n            if not p:\n                continue\n            color = p.color\n            opp = chess.BLACK if color == chess.WHITE else chess.WHITE\n            # is the piece attacked by any opponent piece?\n            attackers = board.attackers(opp, sq)\n            if not attackers:\n                continue\n            # is it defended by any friendly attacker?\n            defenders = board.attackers(color, sq)\n            if defenders:\n                continue\n            unprotected[color] += vals.get(p.piece_type, 0.0)\n        # black_unprotected being larger is good for White -> return black - white\n        return float(unprotected[chess.BLACK] - unprotected[chess.WHITE])\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Queen-to-king pressure: closeness and direct attack of queens on enemy king squares (white - black)'\n    try:\n        pm = board.piece_map()\n        wk = next((sq for sq,p in pm.items() if p and p.piece_type == chess.KING and p.color == chess.WHITE), None)\n        bk = next((sq for sq,p in pm.items() if p and p.piece_type == chess.KING and p.color == chess.BLACK), None)\n        if wk is None or bk is None:\n            return 0.0\n        pressure = {chess.WHITE:0.0, chess.BLACK:0.0}\n        for sq, p in pm.items():\n            if not p or p.piece_type != chess.QUEEN:\n                continue\n            color = p.color\n            target_sq = bk if color == chess.WHITE else wk\n            # Manhattan (square_distance) smaller is stronger\n            d = chess.square_distance(sq, target_sq)\n            # base closeness: stronger when closer (max meaningful dist 14)\n            closeness = max(0.0, (14.0 - float(d)) / 14.0)\n            pressure[color] += closeness * 3.0\n            # extra if queen directly attacks king square\n            if board.is_attacked_by(color, target_sq):\n                pressure[color] += 4.5\n            # extra if queen is on same line (rank/file/diag) as king and unobstructed: approximate by attackers check\n            # attackers check already covers direct attack; keep it simple\n        return float(pressure[chess.WHITE] - pressure[chess.BLACK])\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Central square control: normalized difference in attackers of central four squares (d4,d5,e4,e5) (white - black)'\n    try:\n        centers = [chess.parse_square(s) for s in ('d4','d5','e4','e5')]\n        ctrl = {chess.WHITE:0.0, chess.BLACK:0.0}\n        for c in centers:\n            w_atk = len(board.attackers(chess.WHITE, c))\n            b_atk = len(board.attackers(chess.BLACK, c))\n            # weight central squares more if currently occupied by a pawn (control contested)\n            occ = board.piece_at(c)\n            occ_bonus = 0.5 if occ and occ.piece_type == chess.PAWN else 0.0\n            ctrl[chess.WHITE] += w_atk + occ_bonus\n            ctrl[chess.BLACK] += b_atk + occ_bonus\n        denom = max(1.0, ctrl[chess.WHITE] + ctrl[chess.BLACK])\n        return float((ctrl[chess.WHITE] - ctrl[chess.BLACK]) / denom)\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Trapped-piece metric: difference in count-weighted trapped/non-mobile non-pawn pieces (black_trapped - white_trapped)'\n    try:\n        pm = board.piece_map()\n        trapped = {chess.WHITE:0.0, chess.BLACK:0.0}\n        orig = getattr(board, 'turn', None)\n        try:\n            for color in (chess.WHITE, chess.BLACK):\n                # temporarily set turn to color to measure legal moves for that color\n                try:\n                    board.turn = color\n                except Exception:\n                    pass\n                piece_move_counts = {}\n                for mv in board.legal_moves:\n                    p = board.piece_at(mv.from_square)\n                    if p and p.piece_type not in (chess.PAWN, chess.KING) and p.color == color:\n                        piece_move_counts.setdefault(mv.from_square, 0)\n                        piece_move_counts[mv.from_square] += 1\n                # evaluate pieces with low legal moves and attacked by opponent\n                opp = chess.BLACK if color == chess.WHITE else chess.WHITE\n                for sq, p in pm.items():\n                    if not p or p.piece_type in (chess.PAWN, chess.KING) or p.color != color:\n                        continue\n                    moves = piece_move_counts.get(sq, 0)\n                    if moves <= 1:\n                        # attacked by opponent?\n                        if len(board.attackers(opp, sq)) > 0:\n                            # heavier pieces more significant\n                            weight = 0.9 if p.piece_type == chess.QUEEN else 0.6 if p.piece_type == chess.ROOK else 0.5\n                            trapped[color] += weight * (2.0 - float(moves))  # fewer moves => bigger penalty\n                # also penalize pieces completely immobile (0 moves) even if not attacked\n                for sq, p in pm.items():\n                    if not p or p.piece_type in (chess.PAWN, chess.KING) or p.color != color:\n                        continue\n                    moves = piece_move_counts.get(sq, 0)\n                    if moves == 0:\n                        trapped[color] += 0.4\n        finally:\n            try:\n                if orig is not None:\n                    board.turn = orig\n            except Exception:\n                pass\n        # black_trapped being larger is good for White -> return black - white\n        return float(trapped[chess.BLACK] - trapped[chess.WHITE])\n    except Exception:\n        return 0.0\n",
    "def feature(board: chess.Board) -> float:\n    'Pawn structure weaknesses: weighted count of isolated, doubled and backward pawns (white - black)'\n    try:\n        pm = board.piece_map()\n        vals = {chess.WHITE:0.0, chess.BLACK:0.0}\n        # collect pawn files\n        pawns_by_file = {f:{chess.WHITE:[], chess.BLACK:[]} for f in range(8)}\n        for sq, p in pm.items():\n            if p and p.piece_type == chess.PAWN:\n                f = chess.square_file(sq)\n                r = chess.square_rank(sq)\n                pawns_by_file[f][p.color].append((sq, r))\n        # isolated: no friendly pawn on adjacent files\n        # doubled: multiple pawns on same file (each extra counts)\n        # backward: simplistic test: pawn that has no friendly pawn on adjacent files on ranks behind it (for white: lower ranks; for black: higher ranks)\n        for color in (chess.WHITE, chess.BLACK):\n            score = 0.0\n            for f in range(8):\n                plist = pawns_by_file[f][color]\n                if not plist:\n                    continue\n                # doubled\n                if len(plist) > 1:\n                    # count extras\n                    score += 0.45 * (len(plist) - 1)\n                for (sq, r) in plist:\n                    # isolated?\n                    adj_has = False\n                    for af in (f-1, f+1):\n                        if 0 <= af < 8 and pawns_by_file[af][color]:\n                            adj_has = True\n                            break\n                    if not adj_has:\n                        score += 0.9\n                    # backward: no friendly pawn on adjacent files behind (approx)\n                    behind_blocked = True\n                    if color == chess.WHITE:\n                        for af in (f-1, f+1):\n                            if 0 <= af < 8:\n                                for (_, rr) in pawns_by_file[af][color]:\n                                    if rr < r:\n                                        behind_blocked = False\n                                        break\n                                if not behind_blocked:\n                                    break\n                    else:\n                        for af in (f-1, f+1):\n                            if 0 <= af < 8:\n                                for (_, rr) in pawns_by_file[af][color]:\n                                    if rr > r:\n                                        behind_blocked = False\n                                        break\n                                if not behind_blocked:\n                                    break\n                    if behind_blocked:\n                        score += 0.6\n            vals[color] = score\n        return float(vals[chess.WHITE] - vals[chess.BLACK])\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Passed-pawn potential: sum of passed pawn strengths weighted by advancement and protection (white - black)'\n    try:\n        pm = board.piece_map()\n        def is_passed(sq, color):\n            f = chess.square_file(sq); r = chess.square_rank(sq)\n            if color == chess.WHITE:\n                ahead_ranks = range(r+1, 8)\n                enemy = chess.BLACK\n            else:\n                ahead_ranks = range(0, r)\n                enemy = chess.WHITE\n            for af in (f-1, f, f+1):\n                if 0 <= af < 8:\n                    for ar in ahead_ranks:\n                        esq = chess.square(af, ar)\n                        p = pm.get(esq)\n                        if p and p.piece_type == chess.PAWN and p.color == enemy:\n                            return False\n            return True\n        vals = {chess.WHITE:0.0, chess.BLACK:0.0}\n        for sq, p in pm.items():\n            if not p or p.piece_type != chess.PAWN:\n                continue\n            color = p.color\n            if not is_passed(sq, color):\n                continue\n            r = chess.square_rank(sq)\n            # advancement factor 0..1\n            adv = (r / 7.0) if color == chess.WHITE else ((7 - r) / 7.0)\n            base = 1.0 + 2.0 * adv  # advanced passed pawns matter more\n            # defended by pawn?\n            defended = False\n            for df in (-1, 1):\n                ff = chess.square_file(sq) + df\n                if 0 <= ff < 8:\n                    if color == chess.WHITE:\n                        rf = r - 1\n                    else:\n                        rf = r + 1\n                    if 0 <= rf < 8:\n                        dsq = chess.square(ff, rf)\n                        dp = pm.get(dsq)\n                        if dp and dp.piece_type == chess.PAWN and dp.color == color:\n                            defended = True\n                            break\n            if defended:\n                base += 0.7\n            # penalize if enemy king close to stopping\n            king_sq = next((s for s,pc in pm.items() if pc and pc.piece_type==chess.KING and pc.color != color), None)\n            if king_sq is not None:\n                d = chess.square_distance(sq, king_sq)\n                if d <= 3:\n                    base *= 0.6\n            vals[color] += base\n        return float(vals[chess.WHITE] - vals[chess.BLACK])\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Knight outposts and advanced central knights presence (white - black)'\n    try:\n        pm = board.piece_map()\n        outpost_squares = set()\n        # define candidate outpost squares (advanced central-ish)\n        for name in ('c4','d4','e4','f4','c5','d5','e5','f5','b4','g4','b5','g5'):\n            try:\n                outpost_squares.add(chess.parse_square(name))\n            except Exception:\n                pass\n        def is_blocked_by_enemy_pawn(sq, color):\n            # return True if enemy pawn can attack this square (i.e., pawn on adjacent file behind it)\n            enemy = chess.BLACK if color == chess.WHITE else chess.WHITE\n            f = chess.square_file(sq); r = chess.square_rank(sq)\n            if enemy == chess.WHITE:\n                # white pawn attacks up: must be at rank r-1 on adjacent file\n                for af in (f-1, f+1):\n                    rf = r-1\n                    if 0 <= af < 8 and 0 <= rf < 8:\n                        p = pm.get(chess.square(af, rf))\n                        if p and p.piece_type==chess.PAWN and p.color==enemy:\n                            return True\n            else:\n                for af in (f-1, f+1):\n                    rf = r+1\n                    if 0 <= af < 8 and 0 <= rf < 8:\n                        p = pm.get(chess.square(af, rf))\n                        if p and p.piece_type==chess.PAWN and p.color==enemy:\n                            return True\n            return False\n        score = {chess.WHITE:0.0, chess.BLACK:0.0}\n        for sq, p in pm.items():\n            if not p or p.piece_type != chess.KNIGHT:\n                continue\n            color = p.color\n            bonus = 0.0\n            if sq in outpost_squares:\n                # must not be attackable by enemy pawn and should be on 4th rank or higher for white\n                if not is_blocked_by_enemy_pawn(sq, color):\n                    r = chess.square_rank(sq)\n                    if (color == chess.WHITE and r >= 3) or (color == chess.BLACK and r <= 4):\n                        bonus += 1.6\n            # additional centralization bonus\n            f = chess.square_file(sq)\n            r = chess.square_rank(sq)\n            center_dist = abs(f-3.5) + abs(r-3.5)\n            bonus += max(0.0, 1.2 - 0.25*center_dist)\n            score[color] += bonus\n        return float(score[chess.WHITE] - score[chess.BLACK])\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Battery potential: aligned major/minor/heavy pieces (rook/queen/bishop) without friendly blockers (white - black)'\n    try:\n        pm = board.piece_map()\n        def align_score(color):\n            s = 0.0\n            pieces = [(sq,p) for sq,p in pm.items() if p and p.color==color and p.piece_type in (chess.ROOK, chess.QUEEN, chess.BISHOP)]\n            n = len(pieces)\n            for i in range(n):\n                sq1, p1 = pieces[i]\n                f1, r1 = chess.square_file(sq1), chess.square_rank(sq1)\n                for j in range(i+1, n):\n                    sq2, p2 = pieces[j]\n                    f2, r2 = chess.square_file(sq2), chess.square_rank(sq2)\n                    dx = f2 - f1; dy = r2 - r1\n                    if not (dx == 0 or dy == 0 or abs(dx) == abs(dy)):\n                        continue\n                    sdx = 0 if dx==0 else (1 if dx>0 else -1)\n                    sdy = 0 if dy==0 else (1 if dy>0 else -1)\n                    ff, rr = f1 + sdx, r1 + sdy\n                    blocked = False\n                    while (ff, rr) != (f2, r2):\n                        if not (0 <= ff < 8 and 0 <= rr < 8):\n                            blocked = True\n                            break\n                        sqi = chess.square(ff, rr)\n                        if pm.get(sqi) is not None:\n                            blocked = True\n                            break\n                        ff += sdx; rr += sdy\n                    if not blocked:\n                        # reward complementary types more (rook+queen strong)\n                        weight = 1.0\n                        if p1.piece_type == chess.QUEEN or p2.piece_type == chess.QUEEN:\n                            weight += 0.6\n                        if p1.piece_type != p2.piece_type:\n                            weight += 0.3\n                        s += weight\n            return s\n        return float(align_score(chess.WHITE) - align_score(chess.BLACK))\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Queen activity and high-value threats: central queen presence plus number of attacked opponent heavy/minor pieces (white - black)'\n    try:\n        pm = board.piece_map()\n        vals = {chess.PAWN:1.0, chess.KNIGHT:3.0, chess.BISHOP:3.0, chess.ROOK:5.0, chess.QUEEN:9.0, chess.KING:0.0}\n        def queen_score(color):\n            score = 0.0\n            for sq, p in pm.items():\n                if not p or p.color != color or p.piece_type != chess.QUEEN:\n                    continue\n                f = chess.square_file(sq); r = chess.square_rank(sq)\n                # centrality: closer to center gets more\n                center_dist = abs(f-3.5) + abs(r-3.5)\n                score += max(0.0, 2.0 - 0.25*center_dist)\n                # count attacked opponent non-pawns (value weighted)\n                opp = chess.BLACK if color == chess.WHITE else chess.WHITE\n                for osq, op in pm.items():\n                    if not op or op.color != opp or op.piece_type == chess.PAWN:\n                        continue\n                    if board.is_attacked_by(color, osq):\n                        score += 0.35 * vals.get(op.piece_type, 0.0)\n            return score\n        return float(queen_score(chess.WHITE) - queen_score(chess.BLACK))\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Hanging piece vulnerability: sum of values of pieces attacked more times than defended (black - white to produce positive when White better)'\n    try:\n        pm = board.piece_map()\n        vals = {chess.PAWN:1.0, chess.KNIGHT:3.0, chess.BISHOP:3.0, chess.ROOK:5.0, chess.QUEEN:9.0, chess.KING:0.0}\n        vuln = {chess.WHITE:0.0, chess.BLACK:0.0}\n        for sq, p in pm.items():\n            if not p:\n                continue\n            color = p.color\n            attackers = len(board.attackers(not color, sq))\n            defenders = len(board.attackers(color, sq))\n            if attackers > defenders:\n                vuln[color] += vals.get(p.piece_type, 0.0) * (attackers - defenders)\n        # We want positive value when White is better (i.e., Black has more vulnerabilities)\n        return float(vuln[chess.BLACK] - vuln[chess.WHITE])\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Pawn majority on wings: normalized queenside and kingside pawn-majority difference (white - black)'\n    try:\n        pm = board.piece_map()\n        def pawns_on_files(color, files):\n            c = 0\n            for f in files:\n                for r in range(8):\n                    p = pm.get(chess.square(f, r))\n                    if p and p.piece_type == chess.PAWN and p.color == color:\n                        c += 1\n            return c\n        # queenside files a-d -> 0..3 ; kingside e-h -> 4..7\n        w_qs = pawns_on_files(chess.WHITE, range(0,4))\n        b_qs = pawns_on_files(chess.BLACK, range(0,4))\n        w_ks = pawns_on_files(chess.WHITE, range(4,8))\n        b_ks = pawns_on_files(chess.BLACK, range(4,8))\n        # normalized majority in each wing (-1..1)\n        qmaj = (w_qs - b_qs) / max(1.0, w_qs + b_qs)\n        kmaj = (w_ks - b_ks) / max(1.0, w_ks + b_ks)\n        # weight queenside slightly higher typical for majority play\n        return float(0.6 * qmaj + 0.4 * kmaj)\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Piece coordination: normalized inverse average pairwise distance among non-pawn non-king pieces (white - black)'\n    try:\n        pm = board.piece_map()\n        def coord(color):\n            sqs = [sq for sq,p in pm.items() if p and p.color==color and p.piece_type not in (chess.PAWN, chess.KING)]\n            m = len(sqs)\n            if m <= 1:\n                return 0.0\n            total = 0.0\n            pairs = 0\n            for i in range(m):\n                for j in range(i+1, m):\n                    total += chess.square_distance(sqs[i], sqs[j])\n                    pairs += 1\n            avg = total / pairs if pairs > 0 else 14.0\n            # convert to coordination score where smaller avg distance -> higher score, normalize by max 14\n            return (14.0 - avg) / 14.0\n        return float(coord(chess.WHITE) - coord(chess.BLACK))\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Bishop mobility penalty: sum of bishops with low reachable squares due to pawn blockades (black - white to be positive when White better)'\n    try:\n        pm = board.piece_map()\n        def bishop_reach_count(sq):\n            # count empty or enemy-occupied squares bishop can legally move to ignoring pins (approx by ray scanning)\n            f = chess.square_file(sq); r = chess.square_rank(sq)\n            count = 0\n            for sdx, sdy in ((1,1),(1,-1),(-1,1),(-1,-1)):\n                ff, rr = f + sdx, r + sdy\n                while 0 <= ff < 8 and 0 <= rr < 8:\n                    tsq = chess.square(ff, rr)\n                    p = pm.get(tsq)\n                    count += 1\n                    if p is not None:\n                        break\n                    ff += sdx; rr += sdy\n            return count\n        pen = {chess.WHITE:0.0, chess.BLACK:0.0}\n        for sq, p in pm.items():\n            if not p or p.piece_type != chess.BISHOP:\n                continue\n            reach = bishop_reach_count(sq)\n            # penalty if very restricted\n            if reach <= 4:\n                pen[p.color] += (5.0 - reach) * 0.6\n        # return value positive when white advantage (i.e., black more penalized)\n        return float(pen[chess.BLACK] - pen[chess.WHITE])\n    except Exception:\n        return 0.0\n",
    "def feature(board: chess.Board) -> float:\n    'Hanging pieces imbalance: sum of values of opponent pieces attacked and undefended minus same for own side (positive favors White)'\n    try:\n        vals = {chess.PAWN:1.0, chess.KNIGHT:3.0, chess.BISHOP:3.0, chess.ROOK:5.0, chess.QUEEN:9.0, chess.KING:0.0}\n        pm = board.piece_map()\n        hang = {chess.WHITE:0.0, chess.BLACK:0.0}\n        for sq, p in pm.items():\n            if not p:\n                continue\n            color = p.color\n            opp = chess.BLACK if color == chess.WHITE else chess.WHITE\n            attackers = len(board.attackers(opp, sq))\n            defenders = len(board.attackers(color, sq))\n            # hanging: attacked and effectively undefended (no defenders)\n            if attackers > 0 and defenders == 0:\n                hang[color] += vals.get(p.piece_type, 0.0)\n        return float(hang[chess.WHITE] - hang[chess.BLACK])\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Passed pawn potential: sum of passed-pawn scores weighted by advancement and pawn support (white - black)'\n    try:\n        pm = board.piece_map()\n        def is_passed(sq, color):\n            f = chess.square_file(sq); r = chess.square_rank(sq)\n            opp = chess.BLACK if color == chess.WHITE else chess.WHITE\n            if color == chess.WHITE:\n                rng = range(r+1, 8)\n            else:\n                rng = range(r-1, -1, -1)\n            for of in (f-1, f, f+1):\n                if 0 <= of < 8:\n                    for orr in rng:\n                        sq2 = chess.square(of, orr)\n                        p2 = pm.get(sq2)\n                        if p2 and p2.piece_type == chess.PAWN and p2.color == opp:\n                            return False\n            return True\n        score = {chess.WHITE:0.0, chess.BLACK:0.0}\n        for sq, p in pm.items():\n            if not p or p.piece_type != chess.PAWN:\n                continue\n            color = p.color\n            if not is_passed(sq, color):\n                continue\n            r = chess.square_rank(sq)\n            # advancement fraction (0..1)\n            adv = (r / 7.0) if color == chess.WHITE else ((7 - r) / 7.0)\n            # count pawn supports (friendly pawns attacking/defending this pawn)\n            supports = 0\n            for a in board.attackers(color, sq):\n                pa = pm.get(a)\n                if pa and pa.piece_type == chess.PAWN:\n                    supports += 1\n            score[color] += 1.0 * (0.7 + 0.6 * adv) + 0.5 * supports\n        return float(score[chess.WHITE] - score[chess.BLACK])\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Bishop mobility and pair bonus: mobility (empty diagonal squares reachable) plus bishop-pair reward (white - black)'\n    try:\n        pm = board.piece_map()\n        vals = {chess.BISHOP:0.2}  # small pair bonus per side used below\n        def bishop_mobility(color):\n            mobility = 0.0\n            bishops = 0\n            for sq, p in pm.items():\n                if not p or p.piece_type != chess.BISHOP or p.color != color:\n                    continue\n                bishops += 1\n                f = chess.square_file(sq); r = chess.square_rank(sq)\n                # four diagonal directions\n                for df, dr in ((1,1),(1,-1),(-1,1),(-1,-1)):\n                    cf = f + df; cr = r + dr\n                    while 0 <= cf < 8 and 0 <= cr < 8:\n                        s2 = chess.square(cf, cr)\n                        if board.piece_at(s2) is None:\n                            mobility += 1.0\n                        else:\n                            break\n                        cf += df; cr += dr\n            # bishop pair bonus\n            if bishops >= 2:\n                mobility += 1.2\n            return mobility\n        return float(bishop_mobility(chess.WHITE) - bishop_mobility(chess.BLACK))\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Rook behind passed pawn: count rooks sitting on file behind own passed pawn weighted by pawn advancement (white - black)'\n    try:\n        pm = board.piece_map()\n        pawn_files = {chess.WHITE: {f:[] for f in range(8)}, chess.BLACK: {f:[] for f in range(8)}}\n        for sq, p in pm.items():\n            if p and p.piece_type == chess.PAWN:\n                pawn_files[p.color][chess.square_file(sq)].append(chess.square_rank(sq))\n        # helper to check passed pawn at square\n        def pawn_is_passed(sq, color):\n            f = chess.square_file(sq); r = chess.square_rank(sq)\n            opp = chess.BLACK if color == chess.WHITE else chess.WHITE\n            if color == chess.WHITE:\n                ranges = range(r+1, 8)\n            else:\n                ranges = range(r-1, -1, -1)\n            for of in (f-1, f, f+1):\n                if 0 <= of < 8:\n                    for rr in ranges:\n                        s2 = chess.square(of, rr)\n                        p2 = pm.get(s2)\n                        if p2 and p2.piece_type == chess.PAWN and p2.color == opp:\n                            return False\n            return True\n        score = {chess.WHITE:0.0, chess.BLACK:0.0}\n        for sq, p in pm.items():\n            if not p or p.piece_type != chess.ROOK:\n                continue\n            color = p.color\n            f = chess.square_file(sq); r = chess.square_rank(sq)\n            # check if there exists a passed pawn of same color on same file ahead of rook\n            for rr in pawn_files[color].get(f, []):\n                pawn_sq = chess.square(f, rr)\n                if not pawn_is_passed(pawn_sq, color):\n                    continue\n                if color == chess.WHITE and rr > r:\n                    # rook behind passed pawn\n                    adv = rr / 7.0\n                    score[color] += 1.0 + 1.2 * adv\n                if color == chess.BLACK and rr < r:\n                    adv = (7 - rr) / 7.0\n                    score[color] += 1.0 + 1.2 * adv\n        return float(score[chess.WHITE] - score[chess.BLACK])\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Attack-to-defend imbalance on high-value pieces: sum((attackers/ (1+defenders)) * piece_value) (white - black)'\n    try:\n        pm = board.piece_map()\n        vals = {chess.PAWN:1.0, chess.KNIGHT:3.0, chess.BISHOP:3.0, chess.ROOK:5.0, chess.QUEEN:9.0, chess.KING:0.0}\n        score = {chess.WHITE:0.0, chess.BLACK:0.0}\n        for sq, p in pm.items():\n            if not p or p.piece_type == chess.PAWN:\n                continue\n            color = p.color\n            opp = chess.BLACK if color == chess.WHITE else chess.WHITE\n            attackers = len(board.attackers(opp, sq))\n            defenders = len(board.attackers(color, sq))\n            if attackers == 0:\n                continue\n            # attackers weighted relative to defenders; more dangerous if attackers > defenders\n            ratio = float(attackers) / (1.0 + float(defenders))\n            score[color] += ratio * vals.get(p.piece_type, 0.0)\n        # higher score indicates that side's pieces are under attack relative to defenders; we invert to make positive favor White\n        return float(score[chess.BLACK] - score[chess.WHITE])\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Loose piece pressure: sum of values of pieces for which attackers > defenders (white - black)'\n    try:\n        pm = board.piece_map()\n        vals = {chess.PAWN:0.5, chess.KNIGHT:2.5, chess.BISHOP:2.5, chess.ROOK:4.5, chess.QUEEN:8.0, chess.KING:0.0}\n        loose = {chess.WHITE:0.0, chess.BLACK:0.0}\n        for sq, p in pm.items():\n            if not p:\n                continue\n            color = p.color\n            opp = chess.BLACK if color == chess.WHITE else chess.WHITE\n            attackers = len(board.attackers(opp, sq))\n            defenders = len(board.attackers(color, sq))\n            if attackers > defenders:\n                loose[color] += vals.get(p.piece_type, 0.0) * (attackers - defenders)\n        # return white - black loose burden inverted (less loose is better): positive favors White\n        return float(loose[chess.BLACK] - loose[chess.WHITE])\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Pawn island difference (fewer islands is usually better): (black_islands - white_islands) positive favors White'\n    try:\n        pm = board.piece_map()\n        def pawn_islands(color):\n            files_has = [False]*8\n            for sq, p in pm.items():\n                if p and p.piece_type == chess.PAWN and p.color == color:\n                    files_has[chess.square_file(sq)] = True\n            islands = 0\n            prev = False\n            for f in range(8):\n                if files_has[f] and not prev:\n                    islands += 1\n                prev = files_has[f]\n            return islands\n        iw = pawn_islands(chess.WHITE)\n        ib = pawn_islands(chess.BLACK)\n        return float(ib - iw)\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Central control: weighted control of central 4x4 squares (c3-f6 region) by piece values (white - black)'\n    try:\n        pm = board.piece_map()\n        center_files = range(2, 6)  # c,d,e,f\n        center_ranks = range(2, 6)  # 3,4,5,6 (0-based)\n        vals = {chess.PAWN:0.5, chess.KNIGHT:1.0, chess.BISHOP:1.0, chess.ROOK:1.5, chess.QUEEN:2.0, chess.KING:0.0}\n        ctrl = {chess.WHITE:0.0, chess.BLACK:0.0}\n        for f in center_files:\n            for r in center_ranks:\n                sq = chess.square(f, r)\n                for color in (chess.WHITE, chess.BLACK):\n                    for a in board.attackers(color, sq):\n                        pa = pm.get(a)\n                        if pa:\n                            ctrl[color] += vals.get(pa.piece_type, 0.0)\n        # small normalization by number of central squares\n        norm = 1.0 / max(1.0, float(len(list(center_files)) * len(list(center_ranks))))\n        return float((ctrl[chess.WHITE] - ctrl[chess.BLACK]) * norm)\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Piece coordination: summed bonus where two or more friendly pieces attack the same enemy square, weighted by target piece value (white - black)'\n    try:\n        pm = board.piece_map()\n        vals = {chess.PAWN:0.5, chess.KNIGHT:1.5, chess.BISHOP:1.5, chess.ROOK:2.5, chess.QUEEN:4.0, chess.KING:0.0}\n        coord = {chess.WHITE:0.0, chess.BLACK:0.0}\n        # consider squares occupied by opponent pieces as targets, and count friendly attackers\n        for sq, p in pm.items():\n            if not p:\n                continue\n            target_color = p.color\n            attackers = len(board.attackers(not target_color, sq))\n            if attackers >= 2:\n                # reward coordination against this target\n                coord[not target_color] += (attackers - 1) * vals.get(p.piece_type, 0.0)\n        return float(coord[chess.WHITE] - coord[chess.BLACK])\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Material amplified by mobility: (material_diff) * (1 + 0.5 * normalized_mobility_advantage) where positive favors White'\n    try:\n        vals = {chess.PAWN:1.0, chess.KNIGHT:3.0, chess.BISHOP:3.0, chess.ROOK:5.0, chess.QUEEN:9.0, chess.KING:0.0}\n        pm = board.piece_map()\n        mat = {chess.WHITE:0.0, chess.BLACK:0.0}\n        for p in pm.values():\n            if not p: continue\n            mat[p.color] += vals.get(p.piece_type, 0.0)\n        orig = board.turn\n        try:\n            board.turn = chess.WHITE\n            w_moves = sum(1 for _ in board.legal_moves)\n            board.turn = chess.BLACK\n            b_moves = sum(1 for _ in board.legal_moves)\n        finally:\n            board.turn = orig\n        total_moves = max(1.0, float(w_moves + b_moves))\n        mob_adv = (float(w_moves - b_moves) / total_moves)  # in [-1,1]\n        mat_diff = mat[chess.WHITE] - mat[chess.BLACK]\n        result = mat_diff * (1.0 + 0.5 * mob_adv)\n        return float(result)\n    except Exception:\n        return 0.0\n",
    "def feature(board: chess.Board) -> float:\n    'Material weighted by piece centralization: pieces closer to center contribute more (white - black)'\n    try:\n        vals = {chess.PAWN:1.0, chess.KNIGHT:3.0, chess.BISHOP:3.0, chess.ROOK:5.0, chess.QUEEN:9.0, chess.KING:0.0}\n        center_x = 3.5; center_y = 3.5\n        score = {chess.WHITE:0.0, chess.BLACK:0.0}\n        for sq, p in board.piece_map().items():\n            if p is None:\n                continue\n            f = float(chess.square_file(sq)); r = float(chess.square_rank(sq))\n            # centralization factor: 1.0 at center, declines to 0.0 at corners (use inverse distance)\n            dist = ((f - center_x) ** 2 + (r - center_y) ** 2) ** 0.5\n            max_dist = ((0 - center_x) ** 2 + (0 - center_y) ** 2) ** 0.5\n            cent = max(0.0, 1.0 - dist / max_dist)\n            score[p.color] += vals.get(p.piece_type, 0.0) * (0.5 + 0.9 * cent)  # base weight + central bonus\n        return float(score[chess.WHITE] - score[chess.BLACK])\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Bishop-pair and bishop mobility minus knight mobility (positive favors White)'\n    try:\n        pm = board.piece_map()\n        bp = {chess.WHITE:0, chess.BLACK:0}\n        mob = {chess.WHITE:0.0, chess.BLACK:0.0}\n        counts = {chess.WHITE:0, chess.BLACK:0}\n        orig = board.turn\n        try:\n            for color in (chess.WHITE, chess.BLACK):\n                # bishop pair\n                for p in pm.values():\n                    if p and p.piece_type == chess.BISHOP and p.color == color:\n                        bp[color] += 1\n                # mobility: count legal moves by bishops minus knights\n                board.turn = color\n                for mv in board.legal_moves:\n                    p = board.piece_at(mv.from_square)\n                    if not p or p.color != color:\n                        continue\n                    if p.piece_type == chess.BISHOP:\n                        mob[color] += 1.0\n                    if p.piece_type == chess.KNIGHT:\n                        mob[color] += 0.6  # knights less mobile typically\n                # counts useful for normalization\n                counts[color] = sum(1 for p in pm.values() if p and p.color == color and p.piece_type in (chess.BISHOP, chess.KNIGHT))\n        finally:\n            board.turn = orig\n        # bishop-pair bonus and mobility difference\n        bp_bonus = 0.75 * ( (1 if bp[chess.WHITE] >= 2 else 0) - (1 if bp[chess.BLACK] >= 2 else 0) )\n        mob_norm = 0.0\n        denom = 1.0 + (mob[chess.WHITE] + mob[chess.BLACK])\n        mob_norm = (mob[chess.WHITE] - mob[chess.BLACK]) / denom\n        return float(bp_bonus + 0.9 * mob_norm)\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Rook penetration: rooks on opponent 7th/2nd rank and open/semi-open file presence (white - black)'\n    try:\n        pm = board.piece_map()\n        score = {chess.WHITE:0.0, chess.BLACK:0.0}\n        def pawns_on_file(f):\n            return [sq for sq,p in pm.items() if p and p.piece_type == chess.PAWN and chess.square_file(sq) == f]\n        for sq,p in pm.items():\n            if not p or p.piece_type != chess.ROOK:\n                continue\n            f = chess.square_file(sq); r = chess.square_rank(sq)\n            # rank bonus if rook penetrates to opponent's 7th/2nd\n            if p.color == chess.WHITE and r == 6:\n                score[chess.WHITE] += 1.2\n            if p.color == chess.BLACK and r == 1:\n                score[chess.BLACK] += 1.2\n            # file openness\n            pawns = pawns_on_file(f)\n            if len(pawns) == 0:\n                score[p.color] += 0.9\n            else:\n                # semi-open if only opponent pawns\n                colors = set(pm.get(sq).color for sq in pawns if pm.get(sq) is not None)\n                if len(colors) == 1 and (p.color not in colors):\n                    score[p.color] += 0.6\n        return float(score[chess.WHITE] - score[chess.BLACK])\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Undefended high-value pieces attacked: sum of values of attacked and undefended pieces (black - white) so positive favors White'\n    try:\n        vals = {chess.PAWN:1.0, chess.KNIGHT:3.0, chess.BISHOP:3.0, chess.ROOK:5.0, chess.QUEEN:9.0, chess.KING:0.0}\n        pm = board.piece_map()\n        vuln = {chess.WHITE:0.0, chess.BLACK:0.0}\n        for sq,p in pm.items():\n            if not p:\n                continue\n            opp = chess.BLACK if p.color == chess.WHITE else chess.WHITE\n            # is attacked by opponent?\n            if board.is_attacked_by(opp, sq):\n                # is defended by friendly pieces?\n                defended = board.is_attacked_by(p.color, sq)\n                if not defended:\n                    vuln[p.color] += vals.get(p.piece_type, 0.0)\n        # we return black - white so positive favors white (i.e., white sees black more vulnerable)\n        return float(vuln[chess.BLACK] - vuln[chess.WHITE])\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Pawn majority on each flank (queen-side a-d vs king-side e-h): advantage (white - black)'\n    try:\n        pm = board.piece_map()\n        qs_files = set([0,1,2,3])\n        ks_files = set([4,5,6,7])\n        pawns = {chess.WHITE:{'qs':0,'ks':0}, chess.BLACK:{'qs':0,'ks':0}}\n        for sq,p in pm.items():\n            if not p or p.piece_type != chess.PAWN:\n                continue\n            f = chess.square_file(sq)\n            side = 'qs' if f in qs_files else 'ks'\n            pawns[p.color][side] += 1\n        # majority measure: (my - opp) on each flank, favoring centralization of majority (scale)\n        white_score = float((pawns[chess.WHITE]['qs'] - pawns[chess.BLACK]['qs']) * 0.8 + (pawns[chess.WHITE]['ks'] - pawns[chess.BLACK]['ks']) * 0.8)\n        black_score = 0.0  # not used\n        return float(white_score)\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'King centrality bonus in endgame: if low non-pawn material, central king is good (positive favors White)'\n    try:\n        pm = board.piece_map()\n        nonpawn = 0\n        king_sq = {chess.WHITE:None, chess.BLACK:None}\n        for sq,p in pm.items():\n            if not p:\n                continue\n            if p.piece_type != chess.PAWN and p.piece_type != chess.KING:\n                nonpawn += 1\n            if p.piece_type == chess.KING:\n                king_sq[p.color] = sq\n        # endgame threshold\n        endgame_factor = 1.0 if nonpawn <= 6 else 0.0\n        if endgame_factor == 0.0:\n            return 0.0\n        def central_dist_bonus(sq):\n            if sq is None:\n                return 0.0\n            f = float(chess.square_file(sq)); r = float(chess.square_rank(sq))\n            # Manhattan to center\n            d = abs(f - 3.5) + abs(r - 3.5)\n            # normalize 0..7; invert so smaller distance => bigger bonus\n            return max(0.0, (7.0 - d) / 7.0)\n        bw = central_dist_bonus(king_sq[chess.WHITE])\n        bb = central_dist_bonus(king_sq[chess.BLACK])\n        return float(endgame_factor * (bw - bb))\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Squares controlled in opponent half by non-pawn pieces (white - black), proxy for space and pressure'\n    try:\n        pm = board.piece_map()\n        controlled = {chess.WHITE:set(), chess.BLACK:set()}\n        for sq,p in pm.items():\n            if not p or p.piece_type == chess.PAWN or p.piece_type == chess.KING:\n                continue\n            col = p.color\n            # squares this piece attacks: use board.attackers in reverse is not available; enumerate all squares to check attacks\n            for target in range(64):\n                try:\n                    if board.is_attacked_by(col, target):\n                        # include only opponent half\n                        if col == chess.WHITE and chess.square_rank(target) >= 4:\n                            controlled[col].add(target)\n                        if col == chess.BLACK and chess.square_rank(target) <= 3:\n                            controlled[col].add(target)\n                except Exception:\n                    continue\n        # normalize by max possible (~32)\n        w = float(len(controlled[chess.WHITE])) / 32.0\n        b = float(len(controlled[chess.BLACK])) / 32.0\n        return float(w - b)\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Trapped/unactive piece penalty: counts non-pawn pieces with <=1 legal moves and attacked > defended (black - white)'\n    try:\n        pm = board.piece_map()\n        trapped = {chess.WHITE:0.0, chess.BLACK:0.0}\n        orig = board.turn\n        try:\n            # for each side, set turn and compute defenders/attackers for piece squares\n            for color in (chess.WHITE, chess.BLACK):\n                board.turn = color\n                for sq,p in pm.items():\n                    if not p or p.piece_type in (chess.PAWN, chess.KING) or p.color != color:\n                        continue\n                    # count legal moves for this piece\n                    moves_for_piece = 0\n                    for mv in board.legal_moves:\n                        if mv.from_square == sq:\n                            moves_for_piece += 1\n                            if moves_for_piece > 1:\n                                break\n                    opp = chess.BLACK if color == chess.WHITE else chess.WHITE\n                    attacked_by_opp = len(board.attackers(opp, sq))\n                    defended_by_self = len(board.attackers(color, sq))\n                    if moves_for_piece <= 1 and attacked_by_opp > defended_by_self:\n                        val = 0.0\n                        if p.piece_type == chess.KNIGHT or p.piece_type == chess.BISHOP:\n                            val = 1.2\n                        elif p.piece_type == chess.ROOK:\n                            val = 1.5\n                        elif p.piece_type == chess.QUEEN:\n                            val = 2.2\n                        trapped[color] += val\n        finally:\n            board.turn = orig\n        # return black - white so positive means white advantage (black more trapped)\n        return float(trapped[chess.BLACK] - trapped[chess.WHITE])\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Exchange imbalance weighted by phase: (white major piece advantage - black) scaled by endgame importance'\n    try:\n        pm = board.piece_map()\n        majors = {chess.WHITE:{'rook':0,'queen':0}, chess.BLACK:{'rook':0,'queen':0}}\n        minor = {chess.WHITE:0, chess.BLACK:0}\n        for sq,p in pm.items():\n            if not p:\n                continue\n            if p.piece_type == chess.ROOK:\n                majors[p.color]['rook'] += 1\n            if p.piece_type == chess.QUEEN:\n                majors[p.color]['queen'] += 1\n            if p.piece_type in (chess.BISHOP, chess.KNIGHT):\n                minor[p.color] += 1\n        # phase: fewer minor pieces -> more endgame (0..1)\n        total_minor = minor[chess.WHITE] + minor[chess.BLACK]\n        phase = 1.0 - min(1.0, total_minor / 8.0)  # near 1 in endgame\n        white_major_value = majors[chess.WHITE]['rook'] * 5.0 + majors[chess.WHITE]['queen'] * 9.0\n        black_major_value = majors[chess.BLACK]['rook'] * 5.0 + majors[chess.BLACK]['queen'] * 9.0\n        # weighted by phase so majors matter more later\n        raw = (white_major_value - black_major_value)\n        return float(phase * raw / 10.0)  # scaled down\n    except Exception:\n        return 0.0\n",
    "def feature(board: chess.Board) -> float:\n    'Passed pawn potential: weighted count of passed pawns (white - black), weight increases as pawn approaches promotion'\n    try:\n        pm = board.piece_map()\n        passed = {chess.WHITE:0.0, chess.BLACK:0.0}\n        for sq,p in pm.items():\n            if not p or p.piece_type != chess.PAWN:\n                continue\n            f = chess.square_file(sq); r = chess.square_rank(sq)\n            color = p.color\n            opp = chess.BLACK if color == chess.WHITE else chess.WHITE\n            is_passed = True\n            if color == chess.WHITE:\n                for ff in (f-1, f, f+1):\n                    if 0 <= ff < 8:\n                        for rr in range(r+1, 8):\n                            op_sq = chess.square(ff, rr)\n                            op_p = pm.get(op_sq)\n                            if op_p and op_p.piece_type == chess.PAWN and op_p.color == opp:\n                                is_passed = False\n                                break\n                        if not is_passed:\n                            break\n                if is_passed:\n                    weight = 1.0 + (r / 7.0)  # more weight as pawn advances\n                    passed[chess.WHITE] += weight\n            else:\n                for ff in (f-1, f, f+1):\n                    if 0 <= ff < 8:\n                        for rr in range(r-1, -1, -1):\n                            op_sq = chess.square(ff, rr)\n                            op_p = pm.get(op_sq)\n                            if op_p and op_p.piece_type == chess.PAWN and op_p.color == opp:\n                                is_passed = False\n                                break\n                        if not is_passed:\n                            break\n                if is_passed:\n                    weight = 1.0 + ((7 - r) / 7.0)\n                    passed[chess.BLACK] += weight\n        return float(passed[chess.WHITE] - passed[chess.BLACK])\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Pawn island imbalance: (black pawn island count - white pawn island count) (fewer islands is better)'\n    try:\n        pm = board.piece_map()\n        islands = {chess.WHITE:0, chess.BLACK:0}\n        for color in (chess.WHITE, chess.BLACK):\n            files_with_pawn = [any(pm.get(chess.square(f, r)) and pm.get(chess.square(f, r)).piece_type == chess.PAWN and pm.get(chess.square(f, r)).color == color for r in range(8)) for f in range(8)]\n            cur = 0\n            i_count = 0\n            for f in range(8):\n                if files_with_pawn[f]:\n                    if cur == 0:\n                        i_count += 1\n                        cur = 1\n                else:\n                    cur = 0\n            islands[color] = i_count\n        return float(islands[chess.BLACK] - islands[chess.WHITE])\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Rook file activity: open/semi-open file presence for rooks (white - black); open files weighted higher'\n    try:\n        pm = board.piece_map()\n        def rook_score_for(color):\n            score = 0.0\n            for sq,p in pm.items():\n                if not p or p.color != color or p.piece_type != chess.ROOK:\n                    continue\n                f = chess.square_file(sq)\n                any_pawns_on_file = any(pm.get(chess.square(f, r)) and pm.get(chess.square(f, r)).piece_type == chess.PAWN for r in range(8))\n                friendly_pawns_on_file = any(pm.get(chess.square(f, r)) and pm.get(chess.square(f, r)).piece_type == chess.PAWN and pm.get(chess.square(f, r)).color == color for r in range(8))\n                if not any_pawns_on_file:\n                    score += 1.0  # fully open\n                elif not friendly_pawns_on_file:\n                    score += 0.6  # semi-open\n            return score\n        return float(rook_score_for(chess.WHITE) - rook_score_for(chess.BLACK))\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Outpost quality: sum of outpost bonuses for knights (and minor pieces) on advanced safe squares (white - black)'\n    try:\n        pm = board.piece_map()\n        outpost = {chess.WHITE:0.0, chess.BLACK:0.0}\n        for sq,p in pm.items():\n            if not p or p.piece_type not in (chess.KNIGHT, chess.BISHOP):\n                continue\n            f = chess.square_file(sq); r = chess.square_rank(sq)\n            color = p.color\n            opp = chess.BLACK if color == chess.WHITE else chess.WHITE\n            # require being on opponent half to be considered an outpost\n            if color == chess.WHITE and r < 4:\n                continue\n            if color == chess.BLACK and r > 3:\n                continue\n            # check if enemy pawn can attack this square (simple pawn-attack test)\n            attacked_by_enemy_pawn = False\n            if opp == chess.BLACK:\n                # black pawns attack from rank r+1 on adjacent files\n                for ff in (f-1, f+1):\n                    rr = r+1\n                    if 0 <= ff < 8 and 0 <= rr < 8:\n                        q = chess.square(ff, rr)\n                        op = pm.get(q)\n                        if op and op.piece_type == chess.PAWN and op.color == opp:\n                            attacked_by_enemy_pawn = True\n                            break\n            else:\n                for ff in (f-1, f+1):\n                    rr = r-1\n                    if 0 <= ff < 8 and 0 <= rr < 8:\n                        q = chess.square(ff, rr)\n                        op = pm.get(q)\n                        if op and op.piece_type == chess.PAWN and op.color == opp:\n                            attacked_by_enemy_pawn = True\n                            break\n            if attacked_by_enemy_pawn:\n                continue\n            # support by friendly pawn behind gives extra bonus\n            supported = False\n            if color == chess.WHITE:\n                for ff in (f-1, f+1):\n                    rr = r-1\n                    if 0 <= ff < 8 and 0 <= rr < 8:\n                        q = chess.square(ff, rr)\n                        sp = pm.get(q)\n                        if sp and sp.piece_type == chess.PAWN and sp.color == color:\n                            supported = True\n                            break\n            else:\n                for ff in (f-1, f+1):\n                    rr = r+1\n                    if 0 <= ff < 8 and 0 <= rr < 8:\n                        q = chess.square(ff, rr)\n                        sp = pm.get(q)\n                        if sp and sp.piece_type == chess.PAWN and sp.color == color:\n                            supported = True\n                            break\n            base = 1.5 if p.piece_type == chess.KNIGHT else 0.9\n            bonus = 0.6 if supported else 0.0\n            outpost[color] += base + bonus\n        return float(outpost[chess.WHITE] - outpost[chess.BLACK])\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Bishop diagonal reach: total reachable diagonal squares for bishops (white - black) as proxy for bishop activity'\n    try:\n        pm = board.piece_map()\n        def bishop_reach_for(color):\n            total = 0.0\n            for sq,p in pm.items():\n                if not p or p.color != color or p.piece_type != chess.BISHOP:\n                    continue\n                f = chess.square_file(sq); r = chess.square_rank(sq)\n                # four diagonal directions\n                for df,dr in ((1,1),(1,-1),(-1,1),(-1,-1)):\n                    ff, rr = f+df, r+dr\n                    while 0 <= ff < 8 and 0 <= rr < 8:\n                        q = chess.square(ff, rr)\n                        total += 1.0\n                        if pm.get(q) is not None:\n                            break\n                        ff += df; rr += dr\n            return total\n        w = bishop_reach_for(chess.WHITE); b = bishop_reach_for(chess.BLACK)\n        denom = max(1.0, w + b)\n        return float((w - b) / denom)\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Bishop-pair synergy: bonus for two bishops with reasonable mobility (white - black)'\n    try:\n        pm = board.piece_map()\n        def pair_bonus(color):\n            bishops = [sq for sq,p in pm.items() if p and p.piece_type == chess.BISHOP and p.color == color]\n            if len(bishops) < 2:\n                return 0.0\n            # compute average mobility (using reachable diagonals similar to bishop_reach)\n            mobi = 0.0\n            for sq in bishops:\n                f = chess.square_file(sq); r = chess.square_rank(sq)\n                for df,dr in ((1,1),(1,-1),(-1,1),(-1,-1)):\n                    ff, rr = f+df, r+dr\n                    while 0 <= ff < 8 and 0 <= rr < 8:\n                        q = chess.square(ff, rr)\n                        mobi += 1.0\n                        if pm.get(q) is not None:\n                            break\n                        ff += df; rr += dr\n            avg = mobi / len(bishops)\n            # stronger bonus if average mobility is decent\n            return 0.9 if avg >= 4.0 else 0.45\n        return float(pair_bonus(chess.WHITE) - pair_bonus(chess.BLACK))\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Hanging pieces imbalance: count of pieces attacked and undefended (black - white)'\n    try:\n        pm = board.piece_map()\n        hanging = {chess.WHITE:0.0, chess.BLACK:0.0}\n        for sq,p in pm.items():\n            if not p or p.piece_type == chess.KING:\n                continue\n            attackers = len(board.attackers(not p.color, sq))\n            defenders = len(board.attackers(p.color, sq))\n            if attackers > 0 and defenders == 0:\n                # weight by relative piece importance\n                w = 1.0\n                if p.piece_type == chess.QUEEN:\n                    w = 3.0\n                elif p.piece_type == chess.ROOK:\n                    w = 1.6\n                elif p.piece_type in (chess.BISHOP, chess.KNIGHT):\n                    w = 1.0\n                elif p.piece_type == chess.PAWN:\n                    w = 0.6\n                hanging[p.color] += w\n        return float(hanging[chess.BLACK] - hanging[chess.WHITE])\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'King pawn-storm vulnerability: counts advanced enemy pawns on files adjacent to the king (positive if Black more vulnerable)'\n    try:\n        pm = board.piece_map()\n        def vuln_for(color):\n            ksq = next((sq for sq,p in pm.items() if p and p.piece_type == chess.KING and p.color == color), None)\n            if ksq is None:\n                return 0.0\n            f = chess.square_file(ksq); r = chess.square_rank(ksq)\n            opp = chess.BLACK if color == chess.WHITE else chess.WHITE\n            vuln = 0.0\n            for ff in (f-1, f, f+1):\n                if not (0 <= ff < 8):\n                    continue\n                for rr in range(8):\n                    sq = chess.square(ff, rr)\n                    p = pm.get(sq)\n                    if not p or p.piece_type != chess.PAWN or p.color != opp:\n                        continue\n                    # consider pawn \"advanced\" relative to king: for white king, black pawns with rank <= king_rank are advanced\n                    advanced = False\n                    if color == chess.WHITE and rr <= r:\n                        advanced = True\n                    if color == chess.BLACK and rr >= r:\n                        advanced = True\n                    if advanced:\n                        # closer pawns weigh more\n                        dist = abs(rr - r)\n                        weight = 1.0 + max(0.0, 3.0 - dist) * 0.25\n                        vuln += weight\n            return vuln\n        vuln_w = vuln_for(chess.WHITE)\n        vuln_b = vuln_for(chess.BLACK)\n        # positive means Black is more vulnerable (good for White)\n        return float(vuln_b - vuln_w)\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Capture richness: normalized difference in number of legal captures available (white - black)'\n    try:\n        orig = board.turn\n        try:\n            caps = {chess.WHITE:0.0, chess.BLACK:0.0}\n            moves_total = {chess.WHITE:1.0, chess.BLACK:1.0}\n            pm = board.piece_map()\n            for color in (chess.WHITE, chess.BLACK):\n                board.turn = color\n                cnt = 0\n                tot = 0\n                for mv in board.legal_moves:\n                    tot += 1\n                    to = mv.to_square\n                    target = pm.get(to)\n                    if target and target.color != color:\n                        cnt += 1\n                caps[color] = float(cnt)\n                moves_total[color] = float(max(1, tot))\n        finally:\n            board.turn = orig\n        # normalize by legal move counts to avoid bias from move count\n        w_norm = caps[chess.WHITE] / moves_total[chess.WHITE]\n        b_norm = caps[chess.BLACK] / moves_total[chess.BLACK]\n        return float(w_norm - b_norm)\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Central control: weighted attackers of the four central squares d4,d5,e4,e5 (white - black)'\n    try:\n        vals = {chess.PAWN:0.8, chess.KNIGHT:2.7, chess.BISHOP:2.8, chess.ROOK:4.5, chess.QUEEN:7.5, chess.KING:0.0}\n        centers = [chess.square(3,3), chess.square(3,4), chess.square(4,3), chess.square(4,4)]\n        pm = board.piece_map()\n        control = {chess.WHITE:0.0, chess.BLACK:0.0}\n        for sq in centers:\n            for color in (chess.WHITE, chess.BLACK):\n                atks = board.attackers(color, sq)\n                for a in atks:\n                    p = pm.get(a)\n                    if p:\n                        control[color] += vals.get(p.piece_type, 0.0)\n        return float(control[chess.WHITE] - control[chess.BLACK])\n    except Exception:\n        return 0.0\n",
    "def feature(board: chess.Board) -> float:\n    'Passed pawn potential: sum of passed pawn strengths weighted by proximity to promotion (white - black)'\n    try:\n        pm = board.piece_map()\n        vals = {chess.PAWN:1.0}\n        score_w = 0.0\n        score_b = 0.0\n        for sq, p in pm.items():\n            if not p or p.piece_type != chess.PAWN:\n                continue\n            f = chess.square_file(sq)\n            r = chess.square_rank(sq)\n            color = p.color\n            # Determine if there is any enemy pawn on same file or adjacent files ahead of this pawn\n            is_passed = True\n            if color == chess.WHITE:\n                for ff in range(max(0, f-1), min(7, f+1)+1):\n                    for rr in range(r+1, 8):\n                        q = pm.get(chess.square(ff, rr))\n                        if q and q.piece_type == chess.PAWN and q.color == chess.BLACK:\n                            is_passed = False\n                            break\n                    if not is_passed:\n                        break\n                if is_passed:\n                    dist = float(7 - r) / 7.0\n                    # bonus if supported by a pawn (defender pawn attacks this square)\n                    defenders = board.attackers(chess.WHITE, sq)\n                    pawn_def = any(pm.get(sq2) and pm[sq2].piece_type == chess.PAWN for sq2 in defenders)\n                    score_w += (1.0 + (0.35 if pawn_def else 0.0)) * dist\n            else:\n                for ff in range(max(0, f-1), min(7, f+1)+1):\n                    for rr in range(0, r):\n                        q = pm.get(chess.square(ff, rr))\n                        if q and q.piece_type == chess.PAWN and q.color == chess.WHITE:\n                            is_passed = False\n                            break\n                    if not is_passed:\n                        break\n                if is_passed:\n                    dist = float(r) / 7.0\n                    defenders = board.attackers(chess.BLACK, sq)\n                    pawn_def = any(pm.get(sq2) and pm[sq2].piece_type == chess.PAWN for sq2 in defenders)\n                    score_b += (1.0 + (0.35 if pawn_def else 0.0)) * dist\n        return float(score_w - score_b)\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Central control: difference in number of attacks on the 16 central squares (files c-f, ranks 3-6) normalized (white - black)'\n    try:\n        central_sqs = [chess.square(f, r) for f in range(2, 6) for r in range(2, 6)]\n        w_att = 0\n        b_att = 0\n        for sq in central_sqs:\n            w_att += len(board.attackers(chess.WHITE, sq))\n            b_att += len(board.attackers(chess.BLACK, sq))\n        total = max(1.0, len(central_sqs) * 2.0)  # normalization baseline\n        return float((w_att - b_att) / total)\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Pawn structure weakness: difference in isolated + doubled pawn penalties (black_penalty - white_penalty) (positive favors White)'\n    try:\n        pm = board.piece_map()\n        files_pawns = {i: {chess.WHITE:0, chess.BLACK:0} for i in range(8)}\n        for sq, p in pm.items():\n            if p and p.piece_type == chess.PAWN:\n                files_pawns[chess.square_file(sq)][p.color] += 1\n        penalty_w = 0.0\n        penalty_b = 0.0\n        # Doubled pawn penalty\n        for f in range(8):\n            if files_pawns[f][chess.WHITE] > 1:\n                penalty_w += 0.55 * (files_pawns[f][chess.WHITE] - 1)\n            if files_pawns[f][chess.BLACK] > 1:\n                penalty_b += 0.55 * (files_pawns[f][chess.BLACK] - 1)\n        # Isolated pawn penalty\n        for sq, p in pm.items():\n            if not p or p.piece_type != chess.PAWN:\n                continue\n            f = chess.square_file(sq)\n            color = p.color\n            has_friendly_adjacent = False\n            for af in (f-1, f+1):\n                if 0 <= af <= 7 and files_pawns[af][color] > 0:\n                    has_friendly_adjacent = True\n                    break\n            if not has_friendly_adjacent:\n                if color == chess.WHITE:\n                    penalty_w += 0.6\n                else:\n                    penalty_b += 0.6\n        # return black_pen - white_pen so that positive favors White (black worse)\n        return float(penalty_b - penalty_w)\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Knight outposts: advanced, pawn-supported knights not easily chased by enemy pawns (white - black)'\n    try:\n        pm = board.piece_map()\n        out_w = 0.0\n        out_b = 0.0\n        for sq, p in pm.items():\n            if not p or p.piece_type != chess.KNIGHT:\n                continue\n            f = chess.square_file(sq)\n            r = chess.square_rank(sq)\n            color = p.color\n            opp = chess.BLACK if color == chess.WHITE else chess.WHITE\n            # Must be on opponent half to be considered \"outpost\"\n            if color == chess.WHITE and r < 4:\n                continue\n            if color == chess.BLACK and r > 3:\n                continue\n            # Is there an enemy pawn that attacks this square? If so, not a secure outpost\n            opp_attackers = board.attackers(opp, sq)\n            opp_pawn_attacks = any(pm.get(a) and pm[a].piece_type == chess.PAWN for a in opp_attackers)\n            if opp_pawn_attacks:\n                continue\n            # Is the knight defended (preferably by pawn)? Prefer pawn defender but accept any defender\n            defenders = board.attackers(color, sq)\n            has_pawn_def = any(pm.get(d) and pm[d].piece_type == chess.PAWN for d in defenders)\n            has_any_def = len(defenders) > 0\n            if color == chess.WHITE:\n                if has_pawn_def:\n                    out_w += 1.0\n                elif has_any_def:\n                    out_w += 0.45\n            else:\n                if has_pawn_def:\n                    out_b += 1.0\n                elif has_any_def:\n                    out_b += 0.45\n        return float(out_w - out_b)\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Bishop pair and mobility: (white bishops mobility + pair bonus) - (black bishops mobility + pair bonus)'\n    try:\n        pm = board.piece_map()\n        def bishop_mobility(sq):\n            if sq is None:\n                return 0\n            mobility = 0\n            f0 = chess.square_file(sq); r0 = chess.square_rank(sq)\n            dirs = [(1,1),(1,-1),(-1,1),(-1,-1)]\n            for df, dr in dirs:\n                f = f0 + df; r = r0 + dr\n                while 0 <= f <= 7 and 0 <= r <= 7:\n                    s = chess.square(f, r)\n                    occ = pm.get(s)\n                    if occ is None:\n                        mobility += 1\n                    else:\n                        # can capture opponent piece but blocked thereafter\n                        mobility += 1\n                        break\n                    f += df; r += dr\n            return mobility\n        w_mob = 0.0; b_mob = 0.0\n        w_count = 0; b_count = 0\n        for sq, p in pm.items():\n            if not p or p.piece_type != chess.BISHOP:\n                continue\n            if p.color == chess.WHITE:\n                w_count += 1\n                w_mob += bishop_mobility(sq)\n            else:\n                b_count += 1\n                b_mob += bishop_mobility(sq)\n        pair_bonus_w = 0.9 if w_count >= 2 else 0.0\n        pair_bonus_b = 0.9 if b_count >= 2 else 0.0\n        # normalize mobility by typical scale\n        norm = 12.0\n        return float((w_mob / max(1.0, norm) + pair_bonus_w) - (b_mob / max(1.0, norm) + pair_bonus_b))\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Pinned material value: difference in total value of pinned pieces (black_pinned_value - white_pinned_value) (positive favors White)'\n    try:\n        pm = board.piece_map()\n        vals = {chess.PAWN:1.0, chess.KNIGHT:3.0, chess.BISHOP:3.0, chess.ROOK:5.0, chess.QUEEN:9.0, chess.KING:0.0}\n        def is_pinned(piece_sq, color):\n            # find own king\n            king_sq = next((sq for sq,p in pm.items() if p and p.piece_type==chess.KING and p.color==color), None)\n            if king_sq is None:\n                return False\n            if piece_sq == king_sq:\n                return False\n            fx = chess.square_file(king_sq); rx = chess.square_rank(king_sq)\n            fy = chess.square_file(piece_sq); ry = chess.square_rank(piece_sq)\n            dx = fy - fx; dy = ry - rx\n            # Not aligned -> cannot be pin along sliding line to king\n            if dx != 0 and dy != 0 and abs(dx) != abs(dy):\n                return False\n            # Direction from king to piece\n            step_f = 0 if dx == 0 else (1 if dx > 0 else -1)\n            step_r = 0 if dy == 0 else (1 if dy > 0 else -1)\n            # ensure squares between king and piece are empty\n            cx = fx + step_f; cy = rx + step_r\n            while (cx, cy) != (fy, ry):\n                if pm.get(chess.square(cx, cy)) is not None:\n                    return False\n                cx += step_f; cy += step_r\n            # Now look beyond the piece in same direction for an opponent sliding attacker\n            cx = fy + step_f; cy = ry + step_r\n            opp = chess.BLACK if color == chess.WHITE else chess.WHITE\n            while 0 <= cx <= 7 and 0 <= cy <= 7:\n                occ = pm.get(chess.square(cx, cy))\n                if occ is not None:\n                    # Check if this piece is an opponent sliding piece that can attack along this line\n                    if occ.color == opp:\n                        if step_f == 0 or step_r == 0:\n                            # straight line -> rook or queen pins\n                            if occ.piece_type in (chess.ROOK, chess.QUEEN):\n                                return True\n                        elif abs(step_f) == abs(step_r):\n                            # diagonal -> bishop or queen pins\n                            if occ.piece_type in (chess.BISHOP, chess.QUEEN):\n                                return True\n                    break\n                cx += step_f; cy += step_r\n            return False\n        pinned_w = 0.0; pinned_b = 0.0\n        for sq, p in pm.items():\n            if not p or p.piece_type == chess.KING:\n                continue\n            if is_pinned(sq, p.color):\n                val = vals.get(p.piece_type, 0.0)\n                if p.color == chess.WHITE:\n                    pinned_w += val\n                else:\n                    pinned_b += val\n        # If black has more pinned value, that's good for white => positive\n        return float(pinned_b - pinned_w)\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Rooks on opponent seventh rank advantage: count of rooks on the opponent seventh rank weighted by enemy pawn presence (white - black)'\n    try:\n        pm = board.piece_map()\n        w_score = 0.0\n        b_score = 0.0\n        # White rooks on rank 6 (seventh rank from White's perspective)\n        for sq, p in pm.items():\n            if not p or p.piece_type != chess.ROOK:\n                continue\n            r = chess.square_rank(sq)\n            f = chess.square_file(sq)\n            if p.color == chess.WHITE and r == 6:\n                # bonus greater if there are enemy pawns on that rank (targets)\n                targets = sum(1 for ff in range(8) if pm.get(chess.square(ff, 6)) and pm[chess.square(ff, 6)].color == chess.BLACK)\n                w_score += 1.0 + 0.25 * targets\n            if p.color == chess.BLACK and r == 1:\n                targets = sum(1 for ff in range(8) if pm.get(chess.square(ff, 1)) and pm[chess.square(ff, 1)].color == chess.WHITE)\n                b_score += 1.0 + 0.25 * targets\n        return float(w_score - b_score)\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Immediate tactical capture opportunity net value: sum of capture gains available now (white - black)'\n    try:\n        vals = {chess.PAWN:1.0, chess.KNIGHT:3.0, chess.BISHOP:3.0, chess.ROOK:5.0, chess.QUEEN:9.0, chess.KING:0.0}\n        orig = board.turn\n        try:\n            totals = {chess.WHITE:0.0, chess.BLACK:0.0}\n            for color in (chess.WHITE, chess.BLACK):\n                board.turn = color\n                for mv in board.legal_moves:\n                    try:\n                        target = board.piece_at(mv.to_square)\n                    except Exception:\n                        target = None\n                    if target is None:\n                        # try to detect en passant capture: if moving pawn and target square empty but move captures\n                        # best-effort: check if moving piece is pawn and the move file changed and destination empty\n                        mover = board.piece_at(mv.from_square)\n                        if mover and mover.piece_type == chess.PAWN:\n                            # approximate en-passant by checking if a pawn sits behind the to_square (relative)\n                            # For white EP capture, captured pawn sits at to_square - 8; for black, +8\n                            if mover.color == chess.WHITE:\n                                cap_sq = mv.to_square - 8\n                            else:\n                                cap_sq = mv.to_square + 8\n                            if 0 <= cap_sq < 64:\n                                cp = board.piece_at(cap_sq)\n                                if cp and cp.piece_type == chess.PAWN and cp.color != mover.color:\n                                    target = cp\n                    if target is None:\n                        continue\n                    mover = board.piece_at(mv.from_square)\n                    if mover is None:\n                        continue\n                    captured_value = vals.get(target.piece_type, 0.0)\n                    mover_value = vals.get(mover.piece_type, 0.0)\n                    # approximate net tactical gain: captured value minus small cost proportional to mover value\n                    gain = captured_value - 0.25 * mover_value\n                    totals[color] += max(0.0, gain)\n            return float(totals[chess.WHITE] - totals[chess.BLACK])\n        finally:\n            board.turn = orig\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Space index from pawn advancement: difference in average pawn rank (white_avg - black_avg) normalized (positive favors White)'\n    try:\n        pm = board.piece_map()\n        sum_w = 0.0; cnt_w = 0\n        sum_b = 0.0; cnt_b = 0\n        for sq, p in pm.items():\n            if not p or p.piece_type != chess.PAWN:\n                continue\n            r = chess.square_rank(sq)\n            if p.color == chess.WHITE:\n                sum_w += r\n                cnt_w += 1\n            else:\n                sum_b += (7 - r)  # invert for black so larger means more advanced toward white side\n                cnt_b += 1\n        avg_w = (sum_w / cnt_w) if cnt_w > 0 else 3.5\n        avg_b = (sum_b / cnt_b) if cnt_b > 0 else 3.5\n        # normalize by 7\n        return float((avg_w - avg_b) / 7.0)\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Queen pressure near enemy king: number of squares within 2 of opponent king attacked by queens (white - black)'\n    try:\n        pm = board.piece_map()\n        def queen_pressure(king_sq, attacker_color):\n            if king_sq is None:\n                return 0.0\n            count = 0\n            for f in range(max(0, chess.square_file(king_sq)-2), min(7, chess.square_file(king_sq)+2)+1):\n                for r in range(max(0, chess.square_rank(king_sq)-2), min(7, chess.square_rank(king_sq)+2)+1):\n                    sq = chess.square(f, r)\n                    # check if any attacker square is a queen\n                    attackers = board.attackers(attacker_color, sq)\n                    for a in attackers:\n                        pa = pm.get(a)\n                        if pa and pa.piece_type == chess.QUEEN:\n                            count += 1\n                            break\n            return float(count)\n        wk = next((sq for sq,p in board.piece_map().items() if p and p.piece_type==chess.KING and p.color==chess.WHITE), None)\n        bk = next((sq for sq,p in board.piece_map().items() if p and p.piece_type==chess.KING and p.color==chess.BLACK), None)\n        # Queen pressure by White on squares near Black king minus vice versa\n        p_w_on_b = queen_pressure(bk, chess.WHITE)\n        p_b_on_w = queen_pressure(wk, chess.BLACK)\n        # normalize by number of nearby squares (~25)\n        return float((p_w_on_b - p_b_on_w) / 25.0)\n    except Exception:\n        return 0.0\n",
    "def feature(board: chess.Board) -> float:\n    'Central control: weighted sum of attacks and occupations on the central four squares (white - black)'\n    try:\n        vals = {chess.PAWN:1.0, chess.KNIGHT:3.0, chess.BISHOP:3.0, chess.ROOK:5.0, chess.QUEEN:9.0, chess.KING:0.0}\n        center_files = (3, 4)\n        center_ranks = (3, 4)\n        pm = board.piece_map()\n        score = {chess.WHITE:0.0, chess.BLACK:0.0}\n        for f in center_files:\n            for r in center_ranks:\n                sq = chess.square(f, r)\n                # occupation contributes partially\n                p = pm.get(sq)\n                if p:\n                    score[p.color] += 0.7 * vals.get(p.piece_type, 0.0)\n                # attackers: sum attacker piece values with a reduced weight since multiple attackers overlap\n                for color in (chess.WHITE, chess.BLACK):\n                    attackers = board.attackers(color, sq)\n                    for a in attackers:\n                        pa = pm.get(a)\n                        if pa:\n                            score[color] += 0.55 * vals.get(pa.piece_type, 0.0)\n        return float(score[chess.WHITE] - score[chess.BLACK])\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Passed pawn potential: sum of passed pawn closeness-to-promotion (white - black)'\n    try:\n        pm = board.piece_map()\n        def is_passed(sq, color):\n            f = chess.square_file(sq); r = chess.square_rank(sq)\n            if color == chess.WHITE:\n                for af in (f-1, f, f+1):\n                    if 0 <= af < 8:\n                        for br in range(r+1, 8):\n                            pp = pm.get(chess.square(af, br))\n                            if pp and pp.piece_type == chess.PAWN and pp.color == chess.BLACK:\n                                return False\n                return True\n            else:\n                for af in (f-1, f, f+1):\n                    if 0 <= af < 8:\n                        for br in range(0, r):\n                            pp = pm.get(chess.square(af, br))\n                            if pp and pp.piece_type == chess.PAWN and pp.color == chess.WHITE:\n                                return False\n                return True\n        score = {chess.WHITE:0.0, chess.BLACK:0.0}\n        for sq, p in pm.items():\n            if p and p.piece_type == chess.PAWN:\n                if is_passed(sq, p.color):\n                    r = chess.square_rank(sq)\n                    # closeness to promotion: for white r/7, for black (7-r)/7\n                    if p.color == chess.WHITE:\n                        closeness = (r / 7.0)\n                    else:\n                        closeness = ((7 - r) / 7.0)\n                    # non-linear emphasize advanced passers\n                    val = 1.0 + (closeness ** 2) * 3.0\n                    score[p.color] += val\n        return float(score[chess.WHITE] - score[chess.BLACK])\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Piece coordination: difference in fraction of pieces that are defended by a friendly unit (white - black)'\n    try:\n        pm = board.piece_map()\n        counts = {chess.WHITE:0, chess.BLACK:0}\n        defended = {chess.WHITE:0, chess.BLACK:0}\n        for sq, p in pm.items():\n            if not p:\n                continue\n            counts[p.color] += 1\n            # a piece is \"defended\" if any friendly unit attacks its square (excluding itself)\n            defenders = board.attackers(p.color, sq)\n            # attackers returns squares; a piece sitting on the square won't be in attackers, so no need to exclude self\n            if len(defenders) > 0:\n                defended[p.color] += 1\n        frac_w = defended[chess.WHITE] / max(1.0, counts[chess.WHITE])\n        frac_b = defended[chess.BLACK] / max(1.0, counts[chess.BLACK])\n        return float(frac_w - frac_b)\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Queen exposure: penalty for queens attacked more times than defended (black_penalty - white_penalty) so positive favors White'\n    try:\n        vals = {chess.PAWN:1.0, chess.KNIGHT:3.0, chess.BISHOP:3.0, chess.ROOK:5.0, chess.QUEEN:9.0, chess.KING:0.0}\n        pm = board.piece_map()\n        q_pen = {chess.WHITE:0.0, chess.BLACK:0.0}\n        for sq, p in pm.items():\n            if p and p.piece_type == chess.QUEEN:\n                enemy = chess.BLACK if p.color == chess.WHITE else chess.WHITE\n                attackers = len(board.attackers(enemy, sq))\n                defenders = len(board.attackers(p.color, sq))\n                if attackers > defenders:\n                    q_pen[p.color] += vals[chess.QUEEN] * float(attackers - defenders)\n        # want positive when White is better (black penalty > white penalty)\n        return float(q_pen[chess.BLACK] - q_pen[chess.WHITE])\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Connected passed pawns: bonus for passed pawns that have a friendly pawn on an adjacent file (white - black)'\n    try:\n        pm = board.piece_map()\n        def is_passed_and_connected(sq, color):\n            f = chess.square_file(sq); r = chess.square_rank(sq)\n            # passed check\n            if color == chess.WHITE:\n                for af in (f-1, f, f+1):\n                    if 0 <= af < 8:\n                        for br in range(r+1, 8):\n                            pp = pm.get(chess.square(af, br))\n                            if pp and pp.piece_type == chess.PAWN and pp.color == chess.BLACK:\n                                return False, False\n            else:\n                for af in (f-1, f, f+1):\n                    if 0 <= af < 8:\n                        for br in range(0, r):\n                            pp = pm.get(chess.square(af, br))\n                            if pp and pp.piece_type == chess.PAWN and pp.color == chess.WHITE:\n                                return False, False\n            # connected check: friendly pawn on adjacent file (any rank)\n            connected = False\n            for af in (f-1, f+1):\n                if 0 <= af < 8:\n                    for br in range(8):\n                        pp = pm.get(chess.square(af, br))\n                        if pp and pp.piece_type == chess.PAWN and pp.color == color:\n                            connected = True\n                            break\n                    if connected:\n                        break\n            return True, connected\n        score = {chess.WHITE:0.0, chess.BLACK:0.0}\n        for sq, p in pm.items():\n            if p and p.piece_type == chess.PAWN:\n                passed, conn = is_passed_and_connected(sq, p.color)\n                if passed:\n                    r = chess.square_rank(sq)\n                    closeness = (r / 7.0) if p.color == chess.WHITE else ((7 - r) / 7.0)\n                    base = 1.0 + closeness * 2.0\n                    if conn:\n                        base *= 1.6\n                    score[p.color] += base\n        return float(score[chess.WHITE] - score[chess.BLACK])\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Outpost knights: number of knights on squares not attackable by enemy pawns and supported by a friendly unit (white - black)'\n    try:\n        pm = board.piece_map()\n        outpost_count = {chess.WHITE:0.0, chess.BLACK:0.0}\n        for sq, p in pm.items():\n            if not p or p.piece_type != chess.KNIGHT:\n                continue\n            f = chess.square_file(sq); r = chess.square_rank(sq)\n            color = p.color\n            enemy = chess.BLACK if color == chess.WHITE else chess.WHITE\n            # consider outpost ranks roughly in the opponent half and center-ish\n            if color == chess.WHITE and r < 2:\n                continue\n            if color == chess.BLACK and r > 5:\n                continue\n            # check enemy pawn attacks on this square\n            pawn_attackable = False\n            # pawns attack differently by color\n            if enemy == chess.WHITE:\n                for df in (-1, 1):\n                    ff = f + df; rr = r + 1\n                    if 0 <= ff < 8 and 0 <= rr < 8:\n                        pp = pm.get(chess.square(ff, rr))\n                        if pp and pp.piece_type == chess.PAWN and pp.color == chess.WHITE:\n                            pawn_attackable = True; break\n            else:\n                for df in (-1, 1):\n                    ff = f + df; rr = r - 1\n                    if 0 <= ff < 8 and 0 <= rr < 8:\n                        pp = pm.get(chess.square(ff, rr))\n                        if pp and pp.piece_type == chess.PAWN and pp.color == chess.BLACK:\n                            pawn_attackable = True; break\n            if pawn_attackable:\n                continue\n            # check defended by any friendly attacker\n            defenders = board.attackers(color, sq)\n            if len(defenders) > 0:\n                outpost_count[color] += 1.0\n        return float(outpost_count[chess.WHITE] - outpost_count[chess.BLACK])\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Heavy-piece mobility: average legal moves per rook/queen for each side (white - black), normalized'\n    try:\n        orig = board.turn\n        try:\n            mobility = {chess.WHITE:0.0, chess.BLACK:0.0}\n            counts = {chess.WHITE:0, chess.BLACK:0}\n            for color in (chess.WHITE, chess.BLACK):\n                board.turn = color\n                moves = 0\n                heavy_moves = 0\n                heavy_pieces = set()\n                for mv in board.legal_moves:\n                    moves += 1\n                    p = board.piece_at(mv.from_square)\n                    if p and p.piece_type in (chess.ROOK, chess.QUEEN) and p.color == color:\n                        heavy_moves += 1\n                        heavy_pieces.add(mv.from_square)\n                counts[color] = max(1, len(heavy_pieces))\n                mobility[color] = heavy_moves / float(counts[color])\n        finally:\n            board.turn = orig\n        # normalize by a modest factor to keep values small\n        return float((mobility[chess.WHITE] - mobility[chess.BLACK]) / 5.0)\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'King centrality weighted by endgame phase: positive when White king is more central in endgames'\n    try:\n        vals = {chess.PAWN:1.0, chess.KNIGHT:3.0, chess.BISHOP:3.0, chess.ROOK:5.0, chess.QUEEN:9.0, chess.KING:0.0}\n        pm = board.piece_map()\n        material = 0.0\n        for p in pm.values():\n            if p:\n                material += vals.get(p.piece_type, 0.0)\n        # define endgame factor: stronger weight when low material\n        endgame_factor = 1.0 if material <= 14.0 else 0.25\n        wk = next((sq for sq, p in pm.items() if p and p.piece_type == chess.KING and p.color == chess.WHITE), None)\n        bk = next((sq for sq, p in pm.items() if p and p.piece_type == chess.KING and p.color == chess.BLACK), None)\n        if wk is None or bk is None:\n            return 0.0\n        def center_dist(sq):\n            f = float(chess.square_file(sq))\n            r = float(chess.square_rank(sq))\n            cx = 3.5; cy = 3.5\n            return ((f - cx) ** 2 + (r - cy) ** 2) ** 0.5\n        wd = center_dist(wk)\n        bd = center_dist(bk)\n        # positive when white king is closer to center than black king (good in endgame)\n        return float((bd - wd) * endgame_factor)\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Tactical target score: weighted sum of high-value pieces (>=3) that are attacked more times than defended (black - white)'\n    try:\n        vals = {chess.PAWN:1.0, chess.KNIGHT:3.0, chess.BISHOP:3.0, chess.ROOK:5.0, chess.QUEEN:9.0, chess.KING:0.0}\n        pm = board.piece_map()\n        vuln = {chess.WHITE:0.0, chess.BLACK:0.0}\n        for sq, p in pm.items():\n            if not p:\n                continue\n            v = vals.get(p.piece_type, 0.0)\n            if v < 3.0:\n                continue\n            enemy = chess.BLACK if p.color == chess.WHITE else chess.WHITE\n            attackers = len(board.attackers(enemy, sq))\n            defenders = len(board.attackers(p.color, sq))\n            if attackers > defenders:\n                # emphasize high-value pieces and multiple attackers\n                vuln[p.color] += v * float(attackers - defenders) * 0.9\n        # black vulnerability minus white vulnerability so positive favors White\n        return float(vuln[chess.BLACK] - vuln[chess.WHITE])\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Pawn island penalty adjusted by average pawn advancement: (black_penalty - white_penalty) so positive favors White'\n    try:\n        pm = board.piece_map()\n        def pawn_island_and_advance(color):\n            files_with_pawns = [False] * 8\n            ranks_sum = 0\n            cnt = 0\n            for sq, p in pm.items():\n                if p and p.piece_type == chess.PAWN and p.color == color:\n                    f = chess.square_file(sq)\n                    files_with_pawns[f] = True\n                    ranks_sum += chess.square_rank(sq)\n                    cnt += 1\n            # count islands: contiguous groups of True in files_with_pawns\n            islands = 0\n            f = 0\n            while f < 8:\n                if files_with_pawns[f]:\n                    islands += 1\n                    while f < 8 and files_with_pawns[f]:\n                        f += 1\n                else:\n                    f += 1\n            avg_rank = (ranks_sum / cnt) if cnt > 0 else (3.5)\n            # for White higher rank is more advanced; for Black lower rank is more advanced -> convert to 0..1\n            if color == chess.WHITE:\n                advance = avg_rank / 7.0\n            else:\n                advance = (7.0 - avg_rank) / 7.0\n            # penalty: islands cost, advancement reduces the penalty\n            penalty = islands * 1.1 - advance * 0.6\n            return penalty\n        pen_w = pawn_island_and_advance(chess.WHITE)\n        pen_b = pawn_island_and_advance(chess.BLACK)\n        return float(pen_b - pen_w)\n    except Exception:\n        return 0.0\n",
    "def feature(board: chess.Board) -> float:\n    'Pawn-structure weakness differential: (black_weakness - white_weakness) where higher positive favors White'\n    try:\n        pm = board.piece_map()\n        def pawn_weakness(color):\n            files = {f:0 for f in range(8)}\n            pawns = []\n            for sq,p in pm.items():\n                if p and p.piece_type == chess.PAWN and p.color == color:\n                    f = chess.square_file(sq); r = chess.square_rank(sq)\n                    files[f] += 1\n                    pawns.append((sq,f,r))\n            isolated = 0\n            doubled = 0\n            blocked = 0\n            for sq,f,r in pawns:\n                # isolated: no friendly pawn on adjacent files\n                if (f-1 < 0 or files.get(f-1,0) == 0) and (f+1 > 7 or files.get(f+1,0) == 0):\n                    isolated += 1\n                # doubled: counted as extra pawns on same file\n                if files.get(f,0) > 1:\n                    # count each pawn beyond the first as a doubled contribution\n                    doubled += 1\n                # blocked: forward square occupied\n                if color == chess.WHITE:\n                    if r < 7:\n                        ahead = chess.square(f, r+1)\n                        if board.piece_at(ahead) is not None:\n                            blocked += 1\n                else:\n                    if r > 0:\n                        ahead = chess.square(f, r-1)\n                        if board.piece_at(ahead) is not None:\n                            blocked += 1\n            # scale factors: doubled and isolated are typically worse\n            return isolated + 0.9 * max(0, (doubled - 1)) + 0.6 * blocked\n        w_weak = pawn_weakness(chess.WHITE)\n        b_weak = pawn_weakness(chess.BLACK)\n        return float(b_weak - w_weak)\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Rook file quality: (white_open+0.5*white_halfopen) - (black_open+0.5*black_halfopen)'\n    try:\n        pm = board.piece_map()\n        # precompute pawn presence per file\n        file_any = {f:False for f in range(8)}\n        file_own = {chess.WHITE:{f:False for f in range(8)}, chess.BLACK:{f:False for f in range(8)}}\n        for sq,p in pm.items():\n            if p and p.piece_type == chess.PAWN:\n                f = chess.square_file(sq)\n                file_any[f] = True\n                file_own[p.color][f] = True\n        score = {chess.WHITE:0.0, chess.BLACK:0.0}\n        for sq,p in pm.items():\n            if not p or p.piece_type != chess.ROOK:\n                continue\n            f = chess.square_file(sq)\n            any_p = file_any.get(f, False)\n            own_p = file_own[p.color].get(f, False)\n            opp = chess.BLACK if p.color == chess.WHITE else chess.WHITE\n            opp_p = file_own[opp].get(f, False)\n            if not any_p:\n                # open file\n                score[p.color] += 1.0\n            elif not own_p and opp_p:\n                # half-open (opponent pawns but no own pawns)\n                score[p.color] += 0.5\n        return float(score[chess.WHITE] - score[chess.BLACK])\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Knight outpost centrality: (white_outpost_score - black_outpost_score) for central/stable knights'\n    try:\n        pm = board.piece_map()\n        def knight_score(color):\n            s = 0.0\n            for sq,p in pm.items():\n                if not p or p.piece_type != chess.KNIGHT or p.color != color:\n                    continue\n                f = chess.square_file(sq); r = chess.square_rank(sq)\n                # central region preference (files c-f = 2..5, ranks 3..5 = 2..4)\n                if 2 <= f <= 5 and 2 <= r <= 5:\n                    # check for opponent pawns on adjacent files ahead (approx dislodging pawns)\n                    opp = chess.BLACK if color == chess.WHITE else chess.WHITE\n                    vulnerable = False\n                    for af in (f-1, f+1):\n                        if 0 <= af < 8:\n                            for rr in range(0,8):\n                                p2 = board.piece_at(chess.square(af, rr))\n                                if p2 and p2.piece_type == chess.PAWN and p2.color == opp:\n                                    # if opponent pawn is in front half relative to the knight, consider it a threat\n                                    if (color == chess.WHITE and rr > r) or (color == chess.BLACK and rr < r):\n                                        vulnerable = True\n                                        break\n                            if vulnerable:\n                                break\n                    if not vulnerable:\n                        s += 1.0\n                        # bonus if supported by own pawn or defended by a minor piece\n                        attackers = board.attackers(color, sq)\n                        for a in attackers:\n                            pa = pm.get(a)\n                            if pa and (pa.piece_type == chess.PAWN or pa.piece_type in (chess.KNIGHT, chess.BISHOP)):\n                                s += 0.5\n                                break\n            return s\n        return float(knight_score(chess.WHITE) - knight_score(chess.BLACK))\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'King centralization in endgames: (white_centered - black_centered) if low non-pawn material, else 0'\n    try:\n        pm = board.piece_map()\n        nonpawn_pieces = 0\n        for p in pm.values():\n            if p and p.piece_type not in (chess.PAWN, chess.KING):\n                nonpawn_pieces += 1\n        # consider endgame when few non-pawn pieces remain\n        if nonpawn_pieces > 4:\n            return 0.0\n        centers = [chess.parse_square(s) for s in ('d4','e4','d5','e5')]\n        def center_score(color):\n            ksq = next((sq for sq,p in pm.items() if p and p.piece_type == chess.KING and p.color == color), None)\n            if ksq is None:\n                return 0.0\n            d = min(chess.square_distance(ksq, c) for c in centers)\n            # normalized closeness (14 max Manhattan); closer -> higher score\n            return (14.0 - float(d)) / 14.0\n        return float(center_score(chess.WHITE) - center_score(chess.BLACK))\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Bishop long-range control: (white_long_diag_reach - black_long_diag_reach) counting reachable squares >=3 steps away'\n    try:\n        pm = board.piece_map()\n        def long_reach(color):\n            total = 0.0\n            for sq,p in pm.items():\n                if not p or p.piece_type != chess.BISHOP or p.color != color:\n                    continue\n                f = chess.square_file(sq); r = chess.square_rank(sq)\n                # four diagonal directions\n                for df,dr in ((1,1),(1,-1),(-1,1),(-1,-1)):\n                    step = 0\n                    ff, rr = f, r\n                    while True:\n                        ff += df; rr += dr; step += 1\n                        if not (0 <= ff < 8 and 0 <= rr < 8):\n                            break\n                        # count squares at distance >=3 (i.e., step >=3) as long-range influence\n                        if step >= 3:\n                            total += 1.0\n                        sq2 = chess.square(ff, rr)\n                        if board.piece_at(sq2) is not None:\n                            break\n            return total\n        return float(long_reach(chess.WHITE) - long_reach(chess.BLACK))\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Rook presence on opponent seventh rank: (white_rooks_on_7th - black_rooks_on_7th)'\n    try:\n        pm = board.piece_map()\n        w = 0; b = 0\n        for sq,p in pm.items():\n            if not p or p.piece_type != chess.ROOK:\n                continue\n            r = chess.square_rank(sq)\n            if p.color == chess.WHITE and r == 6:\n                w += 1\n            if p.color == chess.BLACK and r == 1:\n                b += 1\n        return float(w - b)\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Pawn island and open-file blend: combined measure; returns positive if position structurally favors White'\n    try:\n        pm = board.piece_map()\n        def pawn_islands_and_open(color):\n            file_has = [False]*8\n            for sq,p in pm.items():\n                if p and p.piece_type == chess.PAWN and p.color == color:\n                    file_has[chess.square_file(sq)] = True\n            # count islands\n            islands = 0\n            i = 0\n            while i < 8:\n                if file_has[i]:\n                    islands += 1\n                    while i < 8 and file_has[i]:\n                        i += 1\n                else:\n                    i += 1\n            # open files where neither side has pawns\n            open_files = 0\n            for f in range(8):\n                if not any((pm.get(chess.square(f,r)) and pm.get(chess.square(f,r)).piece_type == chess.PAWN) for r in range(8)):\n                    open_files += 1\n            return islands, open_files\n        w_islands, open_files = pawn_islands_and_open(chess.WHITE)\n        b_islands, _ = pawn_islands_and_open(chess.BLACK)\n        # fewer islands better; more open files slightly helps rooks (neutral when both)\n        return float((b_islands - w_islands) + 0.25 * ( (open_files if True else 0) * 0))  # open_files included as placeholder 0.25*0 (keeps signature)\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Safe king escape squares differential: (white_safe_squares - black_safe_squares)'\n    try:\n        pm = board.piece_map()\n        def safe_squares(color):\n            ksq = next((sq for sq,p in pm.items() if p and p.piece_type == chess.KING and p.color == color), None)\n            if ksq is None:\n                return 0.0\n            f = chess.square_file(ksq); r = chess.square_rank(ksq)\n            safe = 0\n            for df in (-1,0,1):\n                for dr in (-1,0,1):\n                    if df == 0 and dr == 0:\n                        continue\n                    ff = f + df; rr = r + dr\n                    if 0 <= ff < 8 and 0 <= rr < 8:\n                        sq2 = chess.square(ff, rr)\n                        occ = board.piece_at(sq2)\n                        # cannot move to own-occupied square\n                        if occ and occ.color == color:\n                            continue\n                        # square must not be attacked by opponent\n                        opp = chess.BLACK if color == chess.WHITE else chess.WHITE\n                        if not board.is_attacked_by(opp, sq2):\n                            safe += 1\n            return float(safe)\n        return float(safe_squares(chess.WHITE) - safe_squares(chess.BLACK))\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Queen activity differential: legal queen moves for White - Black (approx by setting turn and counting queen-origin moves)'\n    try:\n        pm = board.piece_map()\n        orig = board.turn\n        try:\n            qmoves = {chess.WHITE:0, chess.BLACK:0}\n            for color in (chess.WHITE, chess.BLACK):\n                board.turn = color\n                for mv in board.legal_moves:\n                    p = board.piece_at(mv.from_square)\n                    if p and p.piece_type == chess.QUEEN and p.color == color:\n                        qmoves[color] += 1\n            return float(qmoves[chess.WHITE] - qmoves[chess.BLACK])\n        finally:\n            board.turn = orig\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Tempo-adjusted material advantage: (positive favors side-to-move with material edge)'\n    try:\n        vals = {chess.PAWN:1.0, chess.KNIGHT:3.0, chess.BISHOP:3.0, chess.ROOK:5.0, chess.QUEEN:9.0, chess.KING:0.0}\n        mat_w = 0.0; mat_b = 0.0\n        for p in board.piece_map().values():\n            if not p: continue\n            if p.color == chess.WHITE:\n                mat_w += vals.get(p.piece_type, 0.0)\n            else:\n                mat_b += vals.get(p.piece_type, 0.0)\n        orig = board.turn\n        try:\n            board.turn = chess.WHITE\n            w_moves = sum(1 for _ in board.legal_moves)\n            board.turn = chess.BLACK\n            b_moves = sum(1 for _ in board.legal_moves)\n        finally:\n            board.turn = orig\n        mat_diff = mat_w - mat_b\n        mob_diff = float(w_moves - b_moves)\n        # tempo favors the side to move: amplify sign if side-to-move has the material advantage\n        if board.turn == chess.WHITE:\n            sign = 1.0\n        else:\n            sign = -1.0\n        # combine: base = mat_diff scaled, amplified by mobility; sign applied so positive is good for side-to-move\n        score = sign * (mat_diff * (1.0 + 0.12 * mob_diff))\n        # we want positive when White is favored overall, so convert side-to-move-centric score back to White-centric:\n        return float(score if board.turn == chess.WHITE else -score)\n    except Exception:\n        return 0.0\n",
    "def feature(board: chess.Board) -> float:\n    'Passed pawn strength: advanced and supported passed pawns (white - black)'\n    try:\n        pm = board.piece_map()\n        vals = {chess.PAWN:1.0}\n        score = {chess.WHITE:0.0, chess.BLACK:0.0}\n        for sq, p in pm.items():\n            if not p or p.piece_type != chess.PAWN:\n                continue\n            f = chess.square_file(sq)\n            r = chess.square_rank(sq)\n            color = p.color\n            enemy = not color\n            # check for opposing pawns on same or adjacent files ahead of pawn => if none => passed pawn\n            is_passed = True\n            if color == chess.WHITE:\n                for ef in (f-1, f, f+1):\n                    if 0 <= ef <= 7:\n                        for er in range(r+1, 8):\n                            esq = chess.square(ef, er)\n                            ep = pm.get(esq)\n                            if ep and ep.piece_type == chess.PAWN and ep.color == chess.BLACK:\n                                is_passed = False\n                                break\n                        if not is_passed:\n                            break\n            else:\n                for ef in (f-1, f, f+1):\n                    if 0 <= ef <= 7:\n                        for er in range(0, r):\n                            esq = chess.square(ef, er)\n                            ep = pm.get(esq)\n                            if ep and ep.piece_type == chess.PAWN and ep.color == chess.WHITE:\n                                is_passed = False\n                                break\n                        if not is_passed:\n                            break\n            if not is_passed:\n                continue\n            # base weight increases with advancement\n            advancement = (r / 7.0) if color == chess.WHITE else ((7 - r) / 7.0)\n            base = 1.0 + 1.5 * advancement\n            # support by pawns or other pieces\n            defenders = board.attackers(color, sq)\n            support_bonus = 0.0\n            for d in defenders:\n                dp = pm.get(d)\n                if dp:\n                    if dp.piece_type == chess.PAWN:\n                        support_bonus += 0.6\n                        break\n                    else:\n                        support_bonus += 0.25\n                        break\n            score[color] += base + support_bonus\n        return float(score[chess.WHITE] - score[chess.BLACK])\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Pawn structure defects: doubled and isolated pawn penalty difference (black - white) so positive favors White'\n    try:\n        pm = board.piece_map()\n        files = {i: {chess.WHITE:0, chess.BLACK:0} for i in range(8)}\n        pawns_by_color = {chess.WHITE:[], chess.BLACK:[]}\n        for sq, p in pm.items():\n            if p and p.piece_type == chess.PAWN:\n                f = chess.square_file(sq)\n                files[f][p.color] += 1\n                pawns_by_color[p.color].append(sq)\n        penalty = {chess.WHITE:0.0, chess.BLACK:0.0}\n        for color in (chess.WHITE, chess.BLACK):\n            for sq in pawns_by_color[color]:\n                f = chess.square_file(sq)\n                # doubled if more than one pawn of same color on file (each pawn counted)\n                if files[f][color] > 1:\n                    penalty[color] += 0.9\n                # isolated if no friendly pawns on adjacent files\n                isolated = True\n                for af in (f-1, f+1):\n                    if 0 <= af <= 7 and files[af][color] > 0:\n                        isolated = False\n                        break\n                if isolated:\n                    penalty[color] += 0.7\n                # backward pawn heuristic: no friendly pawn behind on adjacent files and enemy pawn can stop advance\n                r = chess.square_rank(sq)\n                behind_exists = False\n                if color == chess.WHITE:\n                    for af in (f-1, f+1):\n                        if 0 <= af <= 7:\n                            for rr in range(0, r):\n                                psq = chess.square(af, rr)\n                                pp = pm.get(psq)\n                                if pp and pp.piece_type == chess.PAWN and pp.color == color:\n                                    behind_exists = True\n                                    break\n                            if behind_exists:\n                                break\n                    if not behind_exists:\n                        penalty[color] += 0.15\n                else:\n                    for af in (f-1, f+1):\n                        if 0 <= af <= 7:\n                            for rr in range(r+1, 8):\n                                psq = chess.square(af, rr)\n                                pp = pm.get(psq)\n                                if pp and pp.piece_type == chess.PAWN and pp.color == color:\n                                    behind_exists = True\n                                    break\n                            if behind_exists:\n                                break\n                    if not behind_exists:\n                        penalty[color] += 0.15\n        # positive favors White: black_bad - white_bad\n        return float(penalty[chess.BLACK] - penalty[chess.WHITE])\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Rook effectiveness: rooks on open/semi-open files and on the 7th rank (white - black)'\n    try:\n        pm = board.piece_map()\n        # precompute pawns on files\n        pawns_on_file = {i: {'any':0, chess.WHITE:0, chess.BLACK:0} for i in range(8)}\n        for sq, p in pm.items():\n            if p and p.piece_type == chess.PAWN:\n                f = chess.square_file(sq)\n                pawns_on_file[f]['any'] += 1\n                pawns_on_file[f][p.color] += 1\n        score = {chess.WHITE:0.0, chess.BLACK:0.0}\n        for sq, p in pm.items():\n            if not p or p.piece_type != chess.ROOK:\n                continue\n            f = chess.square_file(sq)\n            r = chess.square_rank(sq)\n            color = p.color\n            # open file\n            if pawns_on_file[f]['any'] == 0:\n                score[color] += 1.8\n            # semi-open (no own pawn on file)\n            elif pawns_on_file[f][color] == 0:\n                score[color] += 0.9\n            # rooks on 7th rank (very valuable)\n            if (color == chess.WHITE and r == 6) or (color == chess.BLACK and r == 1):\n                score[color] += 2.4\n            # doubled rooks on same file bonus for the side\n            # detect another rook on same file\n            for sq2, p2 in pm.items():\n                if p2 and p2.piece_type == chess.ROOK and p2.color == color and sq2 != sq:\n                    if chess.square_file(sq2) == f:\n                        score[color] += 0.8\n                        break\n        return float(score[chess.WHITE] - score[chess.BLACK])\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Bishop quality: bishop pair bonus minus bad-bishop and low-mobility penalties (white - black)'\n    try:\n        pm = board.piece_map()\n        vals = {chess.BISHOP:3.0, chess.PAWN:1.0}\n        score = {chess.WHITE:0.0, chess.BLACK:0.0}\n        pawn_counts = {chess.WHITE:0, chess.BLACK:0}\n        for p in pm.values():\n            if p and p.piece_type == chess.PAWN:\n                pawn_counts[p.color] += 1\n        # compute mobility per bishop by counting legal moves from that square when it's that side's turn\n        orig = board.turn\n        try:\n            for color in (chess.WHITE, chess.BLACK):\n                # count bishops and store bishop squares\n                bishop_sqs = [sq for sq, p in pm.items() if p and p.piece_type == chess.BISHOP and p.color == color]\n                if len(bishop_sqs) >= 2:\n                    score[color] += 1.0  # bishop pair bonus\n                # mobility and bad-bishop detection\n                board.turn = color\n                for bsq in bishop_sqs:\n                    move_count = 0\n                    for mv in board.legal_moves:\n                        if mv.from_square == bsq:\n                            move_count += 1\n                    # low mobility penalty\n                    if move_count <= 2:\n                        score[color] -= 0.6\n                    # bad bishop: count own pawns on same square color\n                    f = chess.square_file(bsq); r = chess.square_rank(bsq)\n                    my_pawns_same_color = 0\n                    total_my_pawns = pawn_counts[color] if pawn_counts[color] > 0 else 1\n                    for sq2, pp in pm.items():\n                        if pp and pp.piece_type == chess.PAWN and pp.color == color:\n                            sf = chess.square_file(sq2); sr = chess.square_rank(sq2)\n                            if ((sf + sr) % 2) == ((f + r) % 2):\n                                my_pawns_same_color += 1\n                    frac = my_pawns_same_color / total_my_pawns\n                    # if many own pawns are on same color as bishop, penalize proportionally\n                    score[color] -= 0.8 * frac\n        finally:\n            board.turn = orig\n        return float(score[chess.WHITE] - score[chess.BLACK])\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Direct king assault potential: weighted attackers near enemy king and adjacent squares (white - black)'\n    try:\n        pm = board.piece_map()\n        vals = {chess.PAWN:0.6, chess.KNIGHT:2.8, chess.BISHOP:3.0, chess.ROOK:4.5, chess.QUEEN:7.0, chess.KING:0.0}\n        def attack_zone_score(attacker_color):\n            # compute target = enemy king\n            defender = not attacker_color\n            king_sq = next((sq for sq, p in pm.items() if p and p.piece_type == chess.KING and p.color == defender), None)\n            if king_sq is None:\n                return 0.0\n            kf = chess.square_file(king_sq); kr = chess.square_rank(king_sq)\n            score_local = 0.0\n            # squares to consider: king square and adjacent 8 squares and one-ring further (2)\n            for ff in range(max(0, kf-2), min(7, kf+2)+1):\n                for rr in range(max(0, kr-2), min(7, kr+2)+1):\n                    sq = chess.square(ff, rr)\n                    attackers = board.attackers(attacker_color, sq)\n                    for a in attackers:\n                        pa = pm.get(a)\n                        if pa:\n                            # weight closer squares heavier\n                            dist = abs(ff - kf) + abs(rr - kr)\n                            closeness = max(0.0, (3.0 - dist) / 3.0)\n                            score_local += vals.get(pa.piece_type, 0.0) * (0.9 + 1.1 * closeness)\n            return score_local\n        w_score = attack_zone_score(chess.WHITE)\n        b_score = attack_zone_score(chess.BLACK)\n        return float(w_score - b_score)\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Material efficiency: legal moves per unit material (white - black) indicating how active material is'\n    try:\n        vals = {chess.PAWN:1.0, chess.KNIGHT:3.0, chess.BISHOP:3.0, chess.ROOK:5.0, chess.QUEEN:9.0, chess.KING:0.0}\n        pm = board.piece_map()\n        mat = {chess.WHITE:0.0, chess.BLACK:0.0}\n        for p in pm.values():\n            if p:\n                mat[p.color] += vals.get(p.piece_type, 0.0)\n        orig = board.turn\n        moves = {chess.WHITE:1, chess.BLACK:1}\n        try:\n            for color in (chess.WHITE, chess.BLACK):\n                board.turn = color\n                cnt = 0\n                for mv in board.legal_moves:\n                    cnt += 1\n                moves[color] = max(1, cnt)\n        finally:\n            board.turn = orig\n        eff = {c: moves[c] / max(1.0, mat[c]) for c in (chess.WHITE, chess.BLACK)}\n        return float(eff[chess.WHITE] - eff[chess.BLACK])\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Favorable exchange potential: sum of positive exchange prospects (white - black)'\n    try:\n        pm = board.piece_map()\n        vals = {chess.PAWN:1.0, chess.KNIGHT:3.0, chess.BISHOP:3.0, chess.ROOK:5.0, chess.QUEEN:9.0, chess.KING:0.0}\n        def side_exchange_score(attacker_color):\n            score_local = 0.0\n            for sq, target in pm.items():\n                if not target or target.color == attacker_color:\n                    continue\n                # target is enemy piece\n                attackers = board.attackers(attacker_color, sq)\n                if not attackers:\n                    continue\n                min_attacker_val = min((vals.get(pm.get(a).piece_type, 0.0) for a in attackers if pm.get(a)), default=100.0)\n                target_val = vals.get(target.piece_type, 0.0)\n                # positive if attacker is \"cheap\" relative to target; more positive the better\n                diff = target_val - min_attacker_val\n                if diff > 0.01:\n                    # scale by how many attackers and closeness of attacker values\n                    score_local += diff * (0.6 + 0.2 * len(attackers))\n            return score_local\n        w = side_exchange_score(chess.WHITE)\n        b = side_exchange_score(chess.BLACK)\n        return float(w - b)\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Pawn cohesion: pawn-islands penalty and pawn-chain support bonus (white - black)'\n    try:\n        pm = board.piece_map()\n        def pawn_cohesion(color):\n            files_with_pawn = sorted({chess.square_file(sq) for sq, p in pm.items() if p and p.piece_type == chess.PAWN and p.color == color})\n            if not files_with_pawn:\n                return 0.0\n            # pawn islands = contiguous groups in files\n            islands = 1\n            for i in range(1, len(files_with_pawn)):\n                if files_with_pawn[i] != files_with_pawn[i-1] + 1:\n                    islands += 1\n            island_penalty = islands * 0.9\n            # chain support: count pawns defended by another pawn behind (white behind means lower rank)\n            support = 0\n            for sq, p in pm.items():\n                if not p or p.piece_type != chess.PAWN or p.color != color:\n                    continue\n                f = chess.square_file(sq); r = chess.square_rank(sq)\n                if color == chess.WHITE:\n                    for df in (-1, 1):\n                        bf = f + df; br = r - 1\n                        if 0 <= bf <= 7 and 0 <= br <= 7:\n                            bp_sq = chess.square(bf, br)\n                            bp = pm.get(bp_sq)\n                            if bp and bp.piece_type == chess.PAWN and bp.color == color:\n                                support += 1\n                                break\n                else:\n                    for df in (-1, 1):\n                        bf = f + df; br = r + 1\n                        if 0 <= bf <= 7 and 0 <= br <= 7:\n                            bp_sq = chess.square(bf, br)\n                            bp = pm.get(bp_sq)\n                            if bp and bp.piece_type == chess.PAWN and bp.color == color:\n                                support += 1\n                                break\n            # cohesion = support bonus minus islands penalty\n            return float(support * 0.7 - island_penalty)\n        return float(pawn_cohesion(chess.WHITE) - pawn_cohesion(chess.BLACK))\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Queen menace: queen mobility plus proximity to enemy king weighted (white - black)'\n    try:\n        pm = board.piece_map()\n        vals = {chess.QUEEN:9.0}\n        def queen_score(color):\n            # locate my queen(s)\n            q_sqs = [sq for sq, p in pm.items() if p and p.piece_type == chess.QUEEN and p.color == color]\n            if not q_sqs:\n                return 0.0\n            # enemy king\n            enemy = not color\n            king_sq = next((sq for sq, p in pm.items() if p and p.piece_type == chess.KING and p.color == enemy), None)\n            orig = board.turn\n            try:\n                board.turn = color\n                mobility = 0\n                for mv in board.legal_moves:\n                    if pm.get(mv.from_square) and pm.get(mv.from_square).piece_type == chess.QUEEN and pm.get(mv.from_square).color == color:\n                        mobility += 1\n                proximity = 0.0\n                if king_sq is not None:\n                    kf = chess.square_file(king_sq); kr = chess.square_rank(king_sq)\n                    for qs in q_sqs:\n                        qf = chess.square_file(qs); qr = chess.square_rank(qs)\n                        d = chess.square_distance(qs, king_sq)\n                        # smaller distance -> higher proximity\n                        proximity += (14.0 - d) / 14.0\n                return float(0.6 * mobility + 1.8 * proximity)\n            finally:\n                board.turn = orig\n        return float(queen_score(chess.WHITE) - queen_score(chess.BLACK))\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Trapped-piece penalty: pieces with very low mobility and more attackers than defenders (white - black)'\n    try:\n        pm = board.piece_map()\n        vals = {chess.PAWN:1.0, chess.KNIGHT:3.0, chess.BISHOP:3.0, chess.ROOK:5.0, chess.QUEEN:9.0, chess.KING:0.0}\n        score = {chess.WHITE:0.0, chess.BLACK:0.0}\n        orig = board.turn\n        try:\n            for color in (chess.WHITE, chess.BLACK):\n                board.turn = color\n                # compute mobility per piece by scanning legal moves\n                mobility_map = {}\n                for mv in board.legal_moves:\n                    from_sq = mv.from_square\n                    mobility_map[from_sq] = mobility_map.get(from_sq, 0) + 1\n                for sq, p in pm.items():\n                    if not p or p.color != color or p.piece_type in (chess.PAWN, chess.KING):\n                        continue\n                    moves_for_piece = mobility_map.get(sq, 0)\n                    attackers = board.attackers(not color, sq)\n                    defenders = board.attackers(color, sq)\n                    if moves_for_piece <= 1 and len(attackers) > len(defenders):\n                        # penalize proportionally to piece value and attacker-defender imbalance\n                        imbalance = len(attackers) - len(defenders)\n                        penalty = vals.get(p.piece_type, 0.0) * (0.6 + 0.4 * imbalance)\n                        score[color] -= penalty\n        finally:\n            board.turn = orig\n        return float(score[chess.WHITE] - score[chess.BLACK])\n    except Exception:\n        return 0.0\n",
    "def feature(board: chess.Board) -> float:\n    'Space control in opponent half: (squares attacked by White in Black half - squares attacked by Black in White half) normalized'\n    try:\n        pm = board.piece_map()\n        def attacked_in_opponent_half(color):\n            count = 0\n            # for White the opponent half is ranks 4..7 (indexes 4..7); for Black it's ranks 0..3\n            if color == chess.WHITE:\n                ranks = range(4, 8)\n            else:\n                ranks = range(0, 4)\n            for r in ranks:\n                for f in range(0, 8):\n                    sq = chess.square(f, r)\n                    if board.is_attacked_by(color, sq):\n                        count += 1\n            return float(count)\n        w = attacked_in_opponent_half(chess.WHITE)\n        b = attacked_in_opponent_half(chess.BLACK)\n        # normalize by half-board size (32)\n        return float((w - b) / 32.0)\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Rook file control: open/semi-open file score for rooks (white - black); open file = no pawns, semi-open = only opponent pawns'\n    try:\n        pm = board.piece_map()\n        def rook_file_score(color):\n            score = 0.0\n            for sq, p in pm.items():\n                if not p or p.color != color or p.piece_type != chess.ROOK:\n                    continue\n                f = chess.square_file(sq)\n                pawn_counts = {color: 0, (not color): 0}\n                for r in range(0, 8):\n                    s = chess.square(f, r)\n                    pp = pm.get(s)\n                    if pp and pp.piece_type == chess.PAWN:\n                        pawn_counts[pp.color] = pawn_counts.get(pp.color, 0) + 1\n                total_pawns = pawn_counts.get(color, 0) + pawn_counts.get(not color, 0)\n                if total_pawns == 0:\n                    score += 1.0  # open file bonus\n                elif pawn_counts.get(color, 0) == 0 and pawn_counts.get(not color, 0) > 0:\n                    score += 0.45  # semi-open for rooks\n            return score\n        return float(rook_file_score(chess.WHITE) - rook_file_score(chess.BLACK))\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Knight outpost count weighted: knights on forward/central squares protected by a pawn and not attacked by enemy pawns (white - black)'\n    try:\n        pm = board.piece_map()\n        def outpost_count(color):\n            cnt = 0.0\n            opp = not color\n            for sq, p in pm.items():\n                if not p or p.color != color or p.piece_type != chess.KNIGHT:\n                    continue\n                f = chess.square_file(sq); r = chess.square_rank(sq)\n                # prefer central-ish ranks for outposts\n                if not (2 <= r <= 5):\n                    continue\n                # protected by at least one friendly pawn\n                defenders = board.attackers(color, sq)\n                has_friendly_pawn_defender = any((pm.get(sq2) and pm.get(sq2).piece_type == chess.PAWN and pm.get(sq2).color == color) for sq2 in defenders)\n                # no enemy pawn attack\n                enemy_pawn_attacks = any((pm.get(sq2) and pm.get(sq2).piece_type == chess.PAWN and pm.get(sq2).color == opp) for sq2 in board.attackers(opp, sq))\n                if has_friendly_pawn_defender and not enemy_pawn_attacks:\n                    cnt += 1.2\n            return cnt\n        return float(outpost_count(chess.WHITE) - outpost_count(chess.BLACK))\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Rooks on seventh rank pressure: weighted count of rooks sitting on the opponent seventh rank (white - black)'\n    try:\n        pm = board.piece_map()\n        def seventh_pressure(color):\n            pressure = 0.0\n            # white seventh rank index = 6, black seventh rank index = 1\n            target_rank = 6 if color == chess.WHITE else 1\n            opp = not color\n            for sq, p in pm.items():\n                if not p or p.color != color or p.piece_type != chess.ROOK:\n                    continue\n                if chess.square_rank(sq) == target_rank:\n                    # base bonus\n                    bonus = 1.0\n                    # count enemy pawns on that rank (makes rook more powerful)\n                    enemy_pawns_on_rank = sum(1 for f in range(0, 8) if (pm.get(chess.square(f, target_rank)) and pm.get(chess.square(f, target_rank)).piece_type == chess.PAWN and pm.get(chess.square(f, target_rank)).color == opp))\n                    bonus += 0.25 * enemy_pawns_on_rank\n                    pressure += bonus\n            return pressure\n        return float(seventh_pressure(chess.WHITE) - seventh_pressure(chess.BLACK))\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Hanging pieces imbalance: sum of values of pieces that are attacked and undefended (white - black)'\n    try:\n        vals = {chess.PAWN:1.0, chess.KNIGHT:3.0, chess.BISHOP:3.0, chess.ROOK:5.0, chess.QUEEN:9.0, chess.KING:0.0}\n        pm = board.piece_map()\n        def hanging_value(color):\n            opp = not color\n            tot = 0.0\n            for sq, p in pm.items():\n                if not p or p.color != color:\n                    continue\n                attackers = board.attackers(opp, sq)\n                defenders = board.attackers(color, sq)\n                if len(attackers) > 0 and len(defenders) == 0:\n                    tot += vals.get(p.piece_type, 0.0)\n            return tot\n        return float(hanging_value(chess.WHITE) - hanging_value(chess.BLACK))\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Piece coordination: fraction of non-pawn non-king pieces defended by a friendly piece (white - black)'\n    try:\n        pm = board.piece_map()\n        def coordination(color):\n            total = 0\n            defended = 0\n            for sq, p in pm.items():\n                if not p or p.color != color or p.piece_type in (chess.PAWN, chess.KING):\n                    continue\n                total += 1\n                defenders = board.attackers(color, sq)\n                # if any defender exists (could include pawn), count as defended\n                if len(defenders) > 0:\n                    defended += 1\n            return (defended / total) if total > 0 else 0.0\n        return float(coordination(chess.WHITE) - coordination(chess.BLACK))\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Queen centralization minus exposure: centralization bonus minus penalty for being attacked (white - black)'\n    try:\n        pm = board.piece_map()\n        centers = [chess.square(3, 3), chess.square(4, 3), chess.square(3, 4), chess.square(4, 4)]\n        def queen_score(color):\n            qsq = next((sq for sq, p in pm.items() if p and p.piece_type == chess.QUEEN and p.color == color), None)\n            if qsq is None:\n                return 0.0\n            # distance to nearest central square (Manhattan as square_distance)\n            min_dist = min(chess.square_distance(qsq, c) for c in centers)\n            centrality = (6.0 - float(min_dist)) / 6.0  # roughly normalized (min_dist 0..6)\n            # attackers count\n            opp = not color\n            attackers = len(board.attackers(opp, qsq))\n            # combine: centrality positive, attackers penalize\n            return centrality - 0.18 * float(attackers)\n        return float(queen_score(chess.WHITE) - queen_score(chess.BLACK))\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'King centralization in simplified positions: endgame king centralization (white - black), only active in endgames'\n    try:\n        vals = {chess.PAWN:1.0, chess.KNIGHT:3.0, chess.BISHOP:3.0, chess.ROOK:5.0, chess.QUEEN:9.0, chess.KING:0.0}\n        pm = board.piece_map()\n        # compute non-pawn non-king material sum\n        nonpawn_mat = 0.0\n        for p in pm.values():\n            if p and p.piece_type not in (chess.PAWN, chess.KING):\n                nonpawn_mat += vals.get(p.piece_type, 0.0)\n        # consider it an endgame when light material remains (threshold chosen moderately)\n        if nonpawn_mat > 8.0:\n            return 0.0\n        centers = [chess.square(3, 3), chess.square(4, 3), chess.square(3, 4), chess.square(4, 4)]\n        def king_centralization(color):\n            ksq = next((sq for sq, p in pm.items() if p and p.piece_type == chess.KING and p.color == color), None)\n            if ksq is None:\n                return 0.0\n            min_dist = float(min(chess.square_distance(ksq, c) for c in centers))\n            # max possible manhattan on board is 14, but for king to center use 6 as rough span\n            score = (6.0 - min_dist) / 6.0\n            return max(-1.0, min(1.0, score))\n        return float(king_centralization(chess.WHITE) - king_centralization(chess.BLACK))\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Pawn structure deficits: combined penalty for isolated, doubled and backward pawns (fewer deficits is higher) (white - black)'\n    try:\n        pm = board.piece_map()\n        def pawn_structure_score(color):\n            isolated = 0\n            doubled = 0\n            backward = 0\n            # map file->list of ranks with pawns\n            files = {f: [] for f in range(8)}\n            for sq, p in pm.items():\n                if p and p.piece_type == chess.PAWN and p.color == color:\n                    f = chess.square_file(sq); r = chess.square_rank(sq)\n                    files[f].append(r)\n            # doubled pawns: more than one pawn on same file\n            for f, ranks in files.items():\n                if len(ranks) > 1:\n                    doubled += (len(ranks) - 1)\n            # isolated pawns: no friendly pawns on adjacent files\n            for f, ranks in files.items():\n                if len(ranks) == 0:\n                    continue\n                adj = False\n                for af in (f-1, f+1):\n                    if 0 <= af < 8 and len(files.get(af, [])) > 0:\n                        adj = True\n                        break\n                if not adj:\n                    isolated += len(ranks)\n            # backward pawns (approx): a pawn with no friendly pawn ahead on same file and whose forward square is attacked by enemy pawn(s)\n            opp = not color\n            for f, ranks in files.items():\n                for r in ranks:\n                    # check if friendly pawn ahead on same file\n                    if color == chess.WHITE:\n                        has_front_friendly = any(rr > r for rr in ranks)\n                        forward_rank = r + 1\n                        enemy_pawn_attack = False\n                        # check enemy pawns on adjacent files that could attack forward square\n                        if 0 <= forward_rank < 8:\n                            for af in (f-1, f+1):\n                                if 0 <= af < 8:\n                                    s = chess.square(af, forward_rank)\n                                    pp = pm.get(s)\n                                    if pp and pp.piece_type == chess.PAWN and pp.color == opp:\n                                        enemy_pawn_attack = True\n                        if not has_front_friendly and enemy_pawn_attack:\n                            backward += 1\n                    else:\n                        has_front_friendly = any(rr < r for rr in ranks)\n                        forward_rank = r - 1\n                        enemy_pawn_attack = False\n                        if 0 <= forward_rank < 8:\n                            for af in (f-1, f+1):\n                                if 0 <= af < 8:\n                                    s = chess.square(af, forward_rank)\n                                    pp = pm.get(s)\n                                    if pp and pp.piece_type == chess.PAWN and pp.color == opp:\n                                        enemy_pawn_attack = True\n                        if not has_front_friendly and enemy_pawn_attack:\n                            backward += 1\n            # combine penalties: higher is worse. We convert to a \"goodness\" by negating\n            penalty = 0.6 * isolated + 0.5 * doubled + 0.8 * backward\n            # return inverted (higher is better): fewer penalties -> higher score\n            # normalize roughly by 6 to keep magnitude modest\n            return float(-penalty / 6.0)\n        return float(pawn_structure_score(chess.WHITE) - pawn_structure_score(chess.BLACK))\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Exchange imbalance proxy: rooks versus minor pieces (positive means White prefers rook-heavy material, negative means Black)'\n    try:\n        pm = board.piece_map()\n        def exchange_score(color):\n            rooks = sum(1 for p in pm.values() if p and p.color == color and p.piece_type == chess.ROOK)\n            minors = sum(1 for p in pm.values() if p and p.color == color and p.piece_type in (chess.BISHOP, chess.KNIGHT))\n            # score favors rooks over minors; normalize by small constant\n            return float((rooks * 5.0 - minors * 3.0) / 10.0)\n        return float(exchange_score(chess.WHITE) - exchange_score(chess.BLACK))\n    except Exception:\n        return 0.0\n",
    "def feature(board: chess.Board) -> float:\n    'Bishop-pair effectiveness: rewards having a bishop pair on a relatively open board (white - black)'\n    try:\n        pm = board.piece_map()\n        # count bishops per color\n        bishops = {chess.WHITE:0, chess.BLACK:0}\n        pawn_count = 0\n        for p in pm.values():\n            if not p: continue\n            if p.piece_type == chess.BISHOP:\n                bishops[p.color] += 1\n            if p.piece_type == chess.PAWN:\n                pawn_count += 1\n        # openness: fewer pawns -> more open board (0..1)\n        openness = 1.0 - min(1.0, pawn_count / 16.0)\n        # bishop pair value: give extra only when at least 2 bishops\n        val_pair = {chess.WHITE: (1.25 if bishops[chess.WHITE] >= 2 else 0.0),\n                    chess.BLACK: (1.25 if bishops[chess.BLACK] >= 2 else 0.0)}\n        result = (val_pair[chess.WHITE] - val_pair[chess.BLACK]) * (0.6 + 0.8 * openness)\n        return float(result)\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Pawn-structure weakness score: difference in weighted pawn weaknesses (black_penalty - white_penalty); positive favors White'\n    try:\n        pm = board.piece_map()\n        # initialize files list of pawn squares per color\n        pawns_by_file = {chess.WHITE:[[] for _ in range(8)], chess.BLACK:[[] for _ in range(8)]}\n        for sq,p in pm.items():\n            if not p or p.piece_type != chess.PAWN: continue\n            f = chess.square_file(sq)\n            pawns_by_file[p.color][f].append(sq)\n        def penalties(color):\n            opp = chess.BLACK if color == chess.WHITE else chess.WHITE\n            pen = 0.0\n            # doubled pawns: >1 pawn on same file\n            for f in range(8):\n                n = len(pawns_by_file[color][f])\n                if n > 1:\n                    pen += 0.6 * (n - 1)\n            # isolated pawns: no friendly pawn on adjacent files\n            for f in range(8):\n                if len(pawns_by_file[color][f]) == 0: continue\n                left = (f-1 >=0 and len(pawns_by_file[color][f-1])>0)\n                right = (f+1<=7 and len(pawns_by_file[color][f+1])>0)\n                if not left and not right:\n                    pen += 0.9\n            # backward pawns (simplified): pawn that cannot be advanced because opponent pawn controls forward square and no friendly support\n            for f in range(8):\n                for sq in pawns_by_file[color][f]:\n                    r = chess.square_rank(sq)\n                    forward_r = r+1 if color==chess.WHITE else r-1\n                    if not (0 <= forward_r <= 7):\n                        continue\n                    forward_sq = chess.square(f, forward_r)\n                    occ = pm.get(forward_sq)\n                    # if forward occupied by any pawn -> candidate backward/doubled; check if any friendly defends forward_sq\n                    if occ and occ.piece_type == chess.PAWN and occ.color == opp:\n                        # check if any friendly pawn attacks forward_sq (support)\n                        supported = False\n                        for df in (f-1, f+1):\n                            if 0 <= df <= 7:\n                                s2 = chess.square(df, r)\n                                p2 = pm.get(s2)\n                                if p2 and p2.piece_type==chess.PAWN and p2.color==color:\n                                    supported = True\n                                    break\n                        if not supported:\n                            pen += 0.8\n            return pen\n        white_pen = penalties(chess.WHITE)\n        black_pen = penalties(chess.BLACK)\n        return float(black_pen - white_pen)\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Rook open/semi-open file control: weighted count of rooks on open and semi-open files (white - black)'\n    try:\n        pm = board.piece_map()\n        def file_status(f):\n            # 0 = open (no pawns), 1 = semi-open for white (no white pawns), 2 = semi-open for black (no black pawns), 3 = closed (both)\n            has_white = False; has_black = False\n            for r in range(8):\n                p = pm.get(chess.square(f, r))\n                if p and p.piece_type == chess.PAWN:\n                    if p.color == chess.WHITE: has_white = True\n                    else: has_black = True\n            if not has_white and not has_black: return 0\n            if not has_white: return 1\n            if not has_black: return 2\n            return 3\n        score = {chess.WHITE:0.0, chess.BLACK:0.0}\n        for sq,p in pm.items():\n            if not p or p.piece_type != chess.ROOK: continue\n            f = chess.square_file(sq)\n            st = file_status(f)\n            if p.color == chess.WHITE:\n                if st == 0: score[chess.WHITE] += 1.4\n                elif st == 1: score[chess.WHITE] += 0.9\n                elif st == 2: score[chess.WHITE] += 0.2\n            else:\n                if st == 0: score[chess.BLACK] += 1.4\n                elif st == 2: score[chess.BLACK] += 0.9\n                elif st == 1: score[chess.BLACK] += 0.2\n        return float(score[chess.WHITE] - score[chess.BLACK])\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Queen centralization & safety: central queen presence minus vulnerability (white - black)'\n    try:\n        pm = board.piece_map()\n        center_squares = [chess.parse_square(n) for n in ('d4','e4','d5','e5')]\n        def queen_score(color):\n            qs = [sq for sq,p in pm.items() if p and p.piece_type==chess.QUEEN and p.color==color]\n            if not qs: return 0.0\n            score = 0.0\n            for qsq in qs:\n                # centralization: inverse distance to center (0..1)\n                dists = [chess.square_distance(qsq, c) for c in center_squares]\n                dist = min(dists) if dists else 10\n                cent = max(0.0, (7.0 - dist) / 7.0)\n                # mobility: number of legal moves by queen when side to move (approximate)\n                orig = board.turn\n                try:\n                    board.turn = color\n                    moves = 0\n                    for mv in board.legal_moves:\n                        if mv.from_square == qsq:\n                            moves += 1\n                finally:\n                    board.turn = orig\n                mobility = min(8.0, moves) / 8.0\n                # vulnerability: fraction of attackers to queen square\n                attackers = board.attackers(not color, qsq)\n                vuln = min(4.0, len(attackers)) / 4.0\n                score += (0.9 * cent + 0.6 * mobility) - 0.9 * vuln\n            return score\n        return float(queen_score(chess.WHITE) - queen_score(chess.BLACK))\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Piece coordination index: count of mutual defensive links among non-pawn pieces normalized (white - black)'\n    try:\n        pm = board.piece_map()\n        def coord(color):\n            pieces = [sq for sq,p in pm.items() if p and p.color==color and p.piece_type != chess.PAWN]\n            if not pieces:\n                return 0.0\n            links = 0\n            for a in pieces:\n                for b in pieces:\n                    if a == b: continue\n                    # a defends b?\n                    if a in board.attackers(color, b):\n                        links += 1\n            # normalize by number of ordered pairs\n            max_pairs = max(1, len(pieces) * (len(pieces)-1))\n            return links / max_pairs\n        return float(coord(chess.WHITE) - coord(chess.BLACK))\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Pawn-storm momentum near kings: advanced friendly pawns on files adjacent to enemy king (white - black)'\n    try:\n        pm = board.piece_map()\n        def storm(color):\n            # measure advanced pawns on files adjacent to opponent king\n            enemy = not color\n            king_sq = next((sq for sq,p in pm.items() if p and p.piece_type==chess.KING and p.color==enemy), None)\n            if king_sq is None: return 0.0\n            kf = chess.square_file(king_sq)\n            total = 0.0\n            for df in (kf-1, kf, kf+1):\n                if not (0 <= df <= 7): continue\n                for r in range(8):\n                    s = chess.square(df, r)\n                    p = pm.get(s)\n                    if p and p.piece_type==chess.PAWN and p.color==color:\n                        # advancement relative to pawn's starting rank\n                        if color == chess.WHITE:\n                            adv = r - 1  # 0..6\n                        else:\n                            adv = 6 - r\n                        adv = max(0, adv)\n                        total += 0.2 + 0.8 * (adv / 6.0)\n            return total\n        return float(storm(chess.WHITE) - storm(chess.BLACK))\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Passed-pawn promotion race heuristic: advantage if passed pawns closer to promotion than opponent can stop (white - black)'\n    try:\n        pm = board.piece_map()\n        def pawn_race_score(color):\n            opp = not color\n            score = 0.0\n            for sq,p in pm.items():\n                if not p or p.piece_type != chess.PAWN or p.color != color: continue\n                # detect passed pawn\n                f = chess.square_file(sq); r = chess.square_rank(sq)\n                passed = True\n                if color == chess.WHITE:\n                    for ff in (f-1, f, f+1):\n                        if 0 <= ff < 8:\n                            for rr in range(r+1, 8):\n                                op = pm.get(chess.square(ff, rr))\n                                if op and op.piece_type==chess.PAWN and op.color==opp:\n                                    passed = False; break\n                            if not passed: break\n                    if not passed: continue\n                    dist_prom = 7 - r\n                else:\n                    for ff in (f-1, f, f+1):\n                        if 0 <= ff < 8:\n                            for rr in range(r-1, -1, -1):\n                                op = pm.get(chess.square(ff, rr))\n                                if op and op.piece_type==chess.PAWN and op.color==opp:\n                                    passed = False; break\n                            if not passed: break\n                    if not passed: continue\n                    dist_prom = r\n                # approximate defender distance: nearest opponent king or rook/queen distance in Manhattan\n                min_def = 100\n                for sq2,p2 in pm.items():\n                    if not p2 or p2.color != opp: continue\n                    if p2.piece_type in (chess.KING, chess.ROOK, chess.QUEEN):\n                        d = chess.square_distance(sq, sq2)\n                        if d < min_def: min_def = d\n                # score bigger when pawn closer and defenders far\n                score += max(0.0, (6.0 - dist_prom) / 6.0) * (1.0 + (min_def / 8.0))\n            return score\n        return float(pawn_race_score(chess.WHITE) - pawn_race_score(chess.BLACK))\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Trapped minor-piece penalty: difference in number of knights/bishops with <=1 safe retreat squares (black_penalty - white_penalty); positive favors White'\n    try:\n        pm = board.piece_map()\n        def trapped_pen(color):\n            pen = 0.0\n            for sq,p in pm.items():\n                if not p or p.color != color or p.piece_type not in (chess.KNIGHT, chess.BISHOP): continue\n                # count moves that are not landing on square attacked by opponent (naive safe check)\n                orig = board.turn\n                safe_moves = 0\n                try:\n                    board.turn = color\n                    for mv in board.legal_moves:\n                        if mv.from_square != sq: continue\n                        to = mv.to_square\n                        # if destination attacked by opponent, consider unsafe\n                        if not board.is_attacked_by(not color, to):\n                            safe_moves += 1\n                            if safe_moves > 1:\n                                break\n                finally:\n                    board.turn = orig\n                if safe_moves <= 1:\n                    pen += 1.0\n            return pen\n        white_pen = trapped_pen(chess.WHITE)\n        black_pen = trapped_pen(chess.BLACK)\n        return float(black_pen - white_pen)\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Material skew toward majors vs minors scaled by openness: (white_major_minus_minor - black_major_minus_minor)'\n    try:\n        pm = board.piece_map()\n        def maj_min_diff(color):\n            majors = 0.0; minors = 0.0; pawns = 0\n            for p in pm.values():\n                if not p: continue\n                if p.piece_type == chess.QUEEN or p.piece_type == chess.ROOK:\n                    if p.color == color: majors += 1.0\n                if p.piece_type == chess.BISHOP or p.piece_type == chess.KNIGHT:\n                    if p.color == color: minors += 1.0\n                if p.piece_type == chess.PAWN and p.color == color:\n                    pawns += 1\n            # openness factor based on total pawns on board (less pawns => more open)\n            total_pawns = sum(1 for p in pm.values() if p and p.piece_type==chess.PAWN)\n            openness = 1.0 - min(1.0, total_pawns / 16.0)\n            return (majors - minors) * (0.5 + 1.5 * openness)\n        return float(maj_min_diff(chess.WHITE) - maj_min_diff(chess.BLACK))\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Immediate forcing potential: difference in number of capture or checking moves available to side-to-move vs opponent (white - black when measured from each side)'\n    try:\n        pm = board.piece_map()\n        orig = board.turn\n        try:\n            # compute for white\n            board.turn = chess.WHITE\n            w_forcing = 0\n            for mv in board.legal_moves:\n                if board.is_capture(mv) or board.gives_check(mv):\n                    w_forcing += 1\n            # compute for black\n            board.turn = chess.BLACK\n            b_forcing = 0\n            for mv in board.legal_moves:\n                if board.is_capture(mv) or board.gives_check(mv):\n                    b_forcing += 1\n        finally:\n            board.turn = orig\n        total = max(1.0, w_forcing + b_forcing)\n        return float((w_forcing - b_forcing) / total)\n    except Exception:\n        return 0.0\n",
    "def feature(board: chess.Board) -> float:\n    'Central control balance: weighted sum of attacks on central 4x4 (c3..f6) squares (white - black)'\n    try:\n        pm = board.piece_map()\n        # central 4x4 squares c3..f6 (files 2..5, ranks 2..5)\n        center_sqs = [chess.square(f, r) for f in range(2, 6) for r in range(2, 6)]\n        vals = {chess.PAWN:0.8, chess.KNIGHT:1.6, chess.BISHOP:1.6, chess.ROOK:2.2, chess.QUEEN:3.2, chess.KING:0.0}\n        score = {chess.WHITE:0.0, chess.BLACK:0.0}\n        for sq in center_sqs:\n            for color in (chess.WHITE, chess.BLACK):\n                attackers = board.attackers(color, sq)\n                for a in attackers:\n                    p = pm.get(a)\n                    if p:\n                        score[color] += vals.get(p.piece_type, 0.0)\n        # normalize by number of central squares to keep ranges bounded\n        norm = max(1.0, len(center_sqs))\n        return float((score[chess.WHITE] - score[chess.BLACK]) / norm)\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Passed pawn promotion proximity: sum of proximity-to-promotion for passed pawns (white - black)'\n    try:\n        pm = board.piece_map()\n        def is_passed(sq, color):\n            f = chess.square_file(sq); r = chess.square_rank(sq)\n            if color == chess.WHITE:\n                for af in (f-1, f, f+1):\n                    if 0 <= af <= 7:\n                        for rr in range(r+1, 8):\n                            p = board.piece_at(chess.square(af, rr))\n                            if p and p.piece_type == chess.PAWN and p.color == chess.BLACK:\n                                return False\n                return True\n            else:\n                for af in (f-1, f, f+1):\n                    if 0 <= af <= 7:\n                        for rr in range(0, r):\n                            p = board.piece_at(chess.square(af, rr))\n                            if p and p.piece_type == chess.PAWN and p.color == chess.WHITE:\n                                return False\n                return True\n        score_w = 0.0; score_b = 0.0\n        for sq,p in pm.items():\n            if not p or p.piece_type != chess.PAWN:\n                continue\n            if not is_passed(sq, p.color):\n                continue\n            r = chess.square_rank(sq)\n            if p.color == chess.WHITE:\n                dist = 7 - r\n                # closeness: advanced pawns get high score; promotion imminent gets strongest\n                contrib = (8 - dist)  # ranges 1..8 with more advanced larger\n                score_w += contrib\n            else:\n                dist = r - 0\n                contrib = (8 - dist)\n                score_b += contrib\n        return float(score_w - score_b)\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Rooks on open or semi-open files: (#rooks on open files) + 0.5*(#rooks on semi-open) difference (white - black)'\n    try:\n        pm = board.piece_map()\n        files = {i: {'w':0, 'b':0, 'any':0} for i in range(8)}\n        for sq,p in pm.items():\n            if not p:\n                continue\n            f = chess.square_file(sq)\n            if p.piece_type == chess.PAWN:\n                files[f]['any'] += 1\n                if p.color == chess.WHITE:\n                    files[f]['w'] += 1\n                else:\n                    files[f]['b'] += 1\n        rooks_open = {chess.WHITE:0.0, chess.BLACK:0.0}\n        for sq,p in pm.items():\n            if not p or p.piece_type != chess.ROOK:\n                continue\n            f = chess.square_file(sq)\n            file_info = files[f]\n            # open: no pawns of either side on file\n            if file_info['any'] == 0:\n                rooks_open[p.color] += 1.0\n            # semi-open: no own pawns\n            elif (p.color == chess.WHITE and file_info['w'] == 0) or (p.color == chess.BLACK and file_info['b'] == 0):\n                rooks_open[p.color] += 0.5\n        return float(rooks_open[chess.WHITE] - rooks_open[chess.BLACK])\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Pinned material value: total value of own pieces that are pinned to their king (white - black)'\n    try:\n        pm = board.piece_map()\n        vals = {chess.PAWN:1.0, chess.KNIGHT:3.0, chess.BISHOP:3.0, chess.ROOK:5.0, chess.QUEEN:9.0, chess.KING:0.0}\n        directions = [(1,0),(-1,0),(0,1),(0,-1),(1,1),(1,-1),(-1,1),(-1,-1)]\n        def pinned_value(color):\n            total = 0.0\n            king_sq = next((sq for sq,p in pm.items() if p and p.piece_type==chess.KING and p.color==color), None)\n            if king_sq is None:\n                return 0.0\n            kf = chess.square_file(king_sq); kr = chess.square_rank(king_sq)\n            for dx,dy in directions:\n                pieces_seen = []\n                for step in range(1,8):\n                    ff = kf + dx*step; rr = kr + dy*step\n                    if not (0 <= ff < 8 and 0 <= rr < 8):\n                        break\n                    s = chess.square(ff, rr)\n                    p = pm.get(s)\n                    if p:\n                        pieces_seen.append((s,p))\n                        break\n                # if first piece is own and there's an opposing sliding attacker further along same ray -> pinned\n                if len(pieces_seen) == 1:\n                    s0, p0 = pieces_seen[0]\n                    if p0.color == color:\n                        # look further for attacker\n                        for step2 in range(2,8):\n                            ff2 = kf + dx*step2; rr2 = kr + dy*step2\n                            if not (0 <= ff2 < 8 and 0 <= rr2 < 8):\n                                break\n                            s2 = chess.square(ff2, rr2)\n                            p2 = pm.get(s2)\n                            if p2:\n                                if p2.color != color:\n                                    # check sliding compatibility\n                                    if dx == 0 or dy == 0:\n                                        if p2.piece_type in (chess.ROOK, chess.QUEEN):\n                                            total += vals.get(p0.piece_type, 0.0)\n                                    else:\n                                        if p2.piece_type in (chess.BISHOP, chess.QUEEN):\n                                            total += vals.get(p0.piece_type, 0.0)\n                                break\n            return total\n        return float(pinned_value(chess.WHITE) - pinned_value(chess.BLACK))\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Knight outpost count: knights on advanced stable squares defended by pawn and not attackable by enemy pawns (white - black)'\n    try:\n        pm = board.piece_map()\n        def is_defended_by_pawn(color, sq):\n            attackers = board.attackers(color, sq)\n            for a in attackers:\n                p = pm.get(a)\n                if p and p.piece_type == chess.PAWN:\n                    return True\n            return False\n        def attacked_by_enemy_pawn(enemy_color, sq):\n            attackers = board.attackers(enemy_color, sq)\n            for a in attackers:\n                p = pm.get(a)\n                if p and p.piece_type == chess.PAWN:\n                    return True\n            return False\n        w_count = 0; b_count = 0\n        for sq,p in pm.items():\n            if not p or p.piece_type != chess.KNIGHT:\n                continue\n            r = chess.square_rank(sq)\n            if p.color == chess.WHITE:\n                if r >= 4 and is_defended_by_pawn(chess.WHITE, sq) and not attacked_by_enemy_pawn(chess.BLACK, sq):\n                    w_count += 1\n            else:\n                if r <= 3 and is_defended_by_pawn(chess.BLACK, sq) and not attacked_by_enemy_pawn(chess.WHITE, sq):\n                    b_count += 1\n        return float(w_count - b_count)\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Bishop mobility: sum of reachable squares along diagonals for bishops (white - black)'\n    try:\n        pm = board.piece_map()\n        dirs = [(1,1),(1,-1),(-1,1),(-1,-1)]\n        def mobility_for(color):\n            mob = 0.0\n            for sq,p in pm.items():\n                if not p or p.piece_type != chess.BISHOP or p.color != color:\n                    continue\n                f = chess.square_file(sq); r = chess.square_rank(sq)\n                for dx,dy in dirs:\n                    for step in range(1,8):\n                        ff = f + dx*step; rr = r + dy*step\n                        if not (0 <= ff < 8 and 0 <= rr < 8):\n                            break\n                        s2 = chess.square(ff, rr)\n                        p2 = pm.get(s2)\n                        if p2 is None:\n                            mob += 1.0\n                        else:\n                            # can capture opponent but stops\n                            if p2.color != color:\n                                mob += 1.0\n                            break\n            return mob\n        return float(mobility_for(chess.WHITE) - mobility_for(chess.BLACK))\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'King centralization in endgame: favors more central king when non-pawn material is low (white - black)'\n    try:\n        pm = board.piece_map()\n        vals = {chess.PAWN:0.0, chess.KNIGHT:3.0, chess.BISHOP:3.0, chess.ROOK:5.0, chess.QUEEN:9.0, chess.KING:0.0}\n        nonpawn_material = 0.0\n        for p in pm.values():\n            if p and p.piece_type != chess.PAWN:\n                nonpawn_material += vals.get(p.piece_type, 0.0)\n        # endgame factor: when non-pawn material is small, kings matter more\n        endgame_factor = max(0.0, 1.0 - (nonpawn_material / 14.0))  # 14 approximates heavy material presence\n        def centralization(color):\n            ksq = next((sq for sq,p in pm.items() if p and p.piece_type==chess.KING and p.color==color), None)\n            if ksq is None:\n                return 0.0\n            f = chess.square_file(ksq); r = chess.square_rank(ksq)\n            # Manhattan distance to center point (3.5,3.5)\n            d = abs(f - 3.5) + abs(r - 3.5)\n            # normalize (max possible 7)\n            cent = (7.0 - d) / 7.0\n            return cent * endgame_factor\n        return float(centralization(chess.WHITE) - centralization(chess.BLACK))\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Rooks on opponent seventh rank: count of rooks on 7th rank (white - black)'\n    try:\n        pm = board.piece_map()\n        w = 0.0; b = 0.0\n        for sq,p in pm.items():\n            if not p or p.piece_type != chess.ROOK:\n                continue\n            r = chess.square_rank(sq)\n            if p.color == chess.WHITE and r == 6:  # white rook on rank 7 (0-based 6)\n                w += 1.0\n            if p.color == chess.BLACK and r == 1:  # black rook on rank 2 (0-based 1)\n                b += 1.0\n        return float(w - b)\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Queen proximity to enemy king: higher when queen is close to opponent king (white - black)'\n    try:\n        pm = board.piece_map()\n        def proximity(color):\n            # color is the queen owner; measure distance from their queens to enemy king\n            enemy = chess.BLACK if color == chess.WHITE else chess.WHITE\n            king_sq = next((sq for sq,p in pm.items() if p and p.piece_type==chess.KING and p.color==enemy), None)\n            if king_sq is None:\n                return 0.0\n            total = 0.0\n            for sq,p in pm.items():\n                if p and p.piece_type==chess.QUEEN and p.color==color:\n                    d = chess.square_distance(sq, king_sq)  # 0..14\n                    closeness = (14.0 - float(d)) / 14.0\n                    total += closeness * 9.0  # weight by queen value\n            return total\n        return float(proximity(chess.WHITE) - proximity(chess.BLACK))\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Bishop-pair advantage scaled by board openness: favors extra bishop(s) in open positions (white - black)'\n    try:\n        pm = board.piece_map()\n        def bishop_pairs(color):\n            cnt = sum(1 for p in pm.values() if p and p.piece_type==chess.BISHOP and p.color==color)\n            return 1.0 if cnt >= 2 else 0.0\n        total_pawns = sum(1 for p in pm.values() if p and p.piece_type==chess.PAWN)\n        # openness: fewer pawns -> more open\n        openness = 1.0 - (total_pawns / 16.0)  # ~0..1\n        bp_diff = bishop_pairs(chess.WHITE) - bishop_pairs(chess.BLACK)\n        return float(bp_diff * openness * 0.9)\n    except Exception:\n        return 0.0\n",
    "def feature(board: chess.Board) -> float:\n    'King-file openness: counts opponent heavy-piece threats along the king file and adjacent files when the king lacks pawn shield (positive favors White)'\n    try:\n        pm = board.piece_map()\n        def king_open_score(color):\n            king_sq = next((sq for sq,p in pm.items() if p and p.piece_type == chess.KING and p.color == color), None)\n            if king_sq is None:\n                return 0.0\n            opp = chess.BLACK if color == chess.WHITE else chess.WHITE\n            kf = chess.square_file(king_sq)\n            score = 0.0\n            for ff in (kf-1, kf, kf+1):\n                if ff < 0 or ff > 7:\n                    continue\n                # check for any friendly pawn on this file\n                friendly_pawn_on_file = any(p.piece_type == chess.PAWN and p.color == color and chess.square_file(sq) == ff for sq,p in pm.items() if p)\n                if friendly_pawn_on_file:\n                    continue\n                # vulnerability exists; now check for opponent heavy presence or influence on that file\n                threat = 0.0\n                # direct presence of rook/queen on file\n                for sq,p in pm.items():\n                    if p and p.color == opp and p.piece_type in (chess.ROOK, chess.QUEEN) and chess.square_file(sq) == ff:\n                        threat += 1.0\n                # attacks by opponent to any square on that file\n                for rr in range(8):\n                    sq_test = chess.square(ff, rr)\n                    if board.is_attacked_by(opp, sq_test):\n                        threat += 0.25\n                score += min(threat, 2.0)  # cap per file\n            return score\n        return float(king_open_score(chess.WHITE) - king_open_score(chess.BLACK))\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Mutual defence pairs: number of distinct pairs of friendly pieces that directly defend each other (white - black)'\n    try:\n        pm = board.piece_map()\n        mutual = {chess.WHITE:0.0, chess.BLACK:0.0}\n        for color in (chess.WHITE, chess.BLACK):\n            squares = [sq for sq,p in pm.items() if p and p.color == color]\n            counted = 0\n            n = len(squares)\n            for i in range(n):\n                for j in range(i+1, n):\n                    a = squares[i]; b = squares[j]\n                    # a defends b and b defends a\n                    try:\n                        if a in board.attackers(color, b) and b in board.attackers(color, a):\n                            counted += 1\n                    except Exception:\n                        continue\n            mutual[color] = float(counted)\n        return float(mutual[chess.WHITE] - mutual[chess.BLACK])\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Hanging pieces penalty: sum of values of pieces that are attacked by more opponents than defenders (black hanging - white hanging) so positive favors White'\n    try:\n        vals = {chess.PAWN:1.0, chess.KNIGHT:3.0, chess.BISHOP:3.0, chess.ROOK:5.0, chess.QUEEN:9.0, chess.KING:0.0}\n        pm = board.piece_map()\n        hang = {chess.WHITE:0.0, chess.BLACK:0.0}\n        for sq,p in pm.items():\n            if not p:\n                continue\n            color = p.color\n            opp = chess.BLACK if color == chess.WHITE else chess.WHITE\n            try:\n                defenders = len(board.attackers(color, sq))\n                attackers = len(board.attackers(opp, sq))\n            except Exception:\n                defenders = 0; attackers = 0\n            if attackers > defenders:\n                hang[color] += vals.get(p.piece_type, 0.0) * float(attackers - defenders)\n        # feature positive when Black is more hung (good for White)\n        return float(hang[chess.BLACK] - hang[chess.WHITE])\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Outpost knights: counts knights on outposts (no enemy pawn can challenge) weighted by advancement (white - black)'\n    try:\n        pm = board.piece_map()\n        def is_outpost_knight(sq, color):\n            p = pm.get(sq)\n            if not p or p.piece_type != chess.KNIGHT or p.color != color:\n                return False\n            f = chess.square_file(sq); r = chess.square_rank(sq)\n            # For White: enemy pawns on files f-1..f+1 with rank > r can challenge\n            if color == chess.WHITE:\n                for sq2, p2 in pm.items():\n                    if p2 and p2.piece_type == chess.PAWN and p2.color == chess.BLACK:\n                        ff = chess.square_file(sq2); rr = chess.square_rank(sq2)\n                        if abs(ff - f) <= 1 and rr > r:\n                            return False\n                return True\n            else:\n                for sq2, p2 in pm.items():\n                    if p2 and p2.piece_type == chess.PAWN and p2.color == chess.WHITE:\n                        ff = chess.square_file(sq2); rr = chess.square_rank(sq2)\n                        if abs(ff - f) <= 1 and rr < r:\n                            return False\n                return True\n        score = {chess.WHITE:0.0, chess.BLACK:0.0}\n        for sq,p in pm.items():\n            if not p or p.piece_type != chess.KNIGHT:\n                continue\n            color = p.color\n            if is_outpost_knight(sq, color):\n                r = chess.square_rank(sq)\n                adv = (r / 7.0) if color == chess.WHITE else ((7 - r) / 7.0)\n                score[color] += 0.8 + 1.2 * adv\n        return float(score[chess.WHITE] - score[chess.BLACK])\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Rook pressure on opponent base: rooks on the 7th/2nd rank and on open/semi-open files (white - black)'\n    try:\n        pm = board.piece_map()\n        def rook_score_for(color):\n            s = 0.0\n            for sq,p in pm.items():\n                if not p or p.piece_type != chess.ROOK or p.color != color:\n                    continue\n                f = chess.square_file(sq); r = chess.square_rank(sq)\n                # open/semi-open detection\n                pawns_on_file = [pp for ss,pp in pm.items() if pp and pp.piece_type == chess.PAWN and chess.square_file(ss) == f]\n                if not pawns_on_file:\n                    open_bonus = 0.9\n                    semi = False\n                else:\n                    # semi-open if no friendly pawn\n                    friendly_pawn_present = any(pp.color == color for pp in pawns_on_file)\n                    open_bonus = 0.45 if not friendly_pawn_present else 0.0\n                    semi = not friendly_pawn_present and bool(pawns_on_file)\n                # 7th/2nd rank bonus\n                on_7th = (color == chess.WHITE and r == 6)\n                on_2nd = (color == chess.BLACK and r == 1)\n                rank_bonus = 1.2 if on_7th or on_2nd else 0.15\n                s += rank_bonus + open_bonus\n            return s\n        return float(rook_score_for(chess.WHITE) - rook_score_for(chess.BLACK))\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Pawn islands: difference in number of pawn islands (black islands - white islands) so positive favors White when Black has more fragmented pawns'\n    try:\n        pm = board.piece_map()\n        def pawn_islands(color):\n            files_with_pawn = sorted({chess.square_file(sq) for sq,p in pm.items() if p and p.piece_type == chess.PAWN and p.color == color})\n            if not files_with_pawn:\n                return 0.0\n            islands = 1\n            for i in range(1, len(files_with_pawn)):\n                if files_with_pawn[i] != files_with_pawn[i-1] + 1:\n                    islands += 1\n            return float(islands)\n        return float(pawn_islands(chess.BLACK) - pawn_islands(chess.WHITE))\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Minor vs major piece activity: difference of minor-piece move counts minus scaled major-piece move counts (positive favors White)'\n    try:\n        orig = board.turn\n        minor_moves = {chess.WHITE:0.0, chess.BLACK:0.0}\n        major_moves = {chess.WHITE:0.0, chess.BLACK:0.0}\n        try:\n            for color in (chess.WHITE, chess.BLACK):\n                board.turn = color\n                for mv in board.legal_moves:\n                    p = board.piece_at(mv.from_square)\n                    if not p or p.color != color:\n                        continue\n                    if p.piece_type in (chess.KNIGHT, chess.BISHOP):\n                        minor_moves[color] += 1.0\n                    elif p.piece_type in (chess.ROOK, chess.QUEEN):\n                        major_moves[color] += 1.0\n        finally:\n            board.turn = orig\n        # compute normalized difference\n        return float((minor_moves[chess.WHITE] - minor_moves[chess.BLACK]) - 0.55 * (major_moves[chess.WHITE] - major_moves[chess.BLACK]))\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Connected passed pawns potential: sum of advancement-weighted connected passed pawns (white - black)'\n    try:\n        pm = board.piece_map()\n        def is_passed(sq, color):\n            f = chess.square_file(sq); r = chess.square_rank(sq)\n            if color == chess.WHITE:\n                for sq2,p2 in pm.items():\n                    if p2 and p2.piece_type == chess.PAWN and p2.color == chess.BLACK:\n                        ff = chess.square_file(sq2); rr = chess.square_rank(sq2)\n                        if abs(ff - f) <= 1 and rr > r:\n                            return False\n                return True\n            else:\n                for sq2,p2 in pm.items():\n                    if p2 and p2.piece_type == chess.PAWN and p2.color == chess.WHITE:\n                        ff = chess.square_file(sq2); rr = chess.square_rank(sq2)\n                        if abs(ff - f) <= 1 and rr < r:\n                            return False\n                return True\n        score = {chess.WHITE:0.0, chess.BLACK:0.0}\n        passed_positions = {chess.WHITE: set(), chess.BLACK: set()}\n        for sq,p in pm.items():\n            if p and p.piece_type == chess.PAWN:\n                if is_passed(sq, p.color):\n                    passed_positions[p.color].add(sq)\n        for color in (chess.WHITE, chess.BLACK):\n            used = set()\n            for sq in passed_positions[color]:\n                if sq in used:\n                    continue\n                f = chess.square_file(sq); r = chess.square_rank(sq)\n                # search for connected passed pawns on adjacent files\n                chain = {sq}\n                for sq2 in list(passed_positions[color]):\n                    if sq2 == sq:\n                        continue\n                    ff = chess.square_file(sq2); rr = chess.square_rank(sq2)\n                    if abs(ff - f) == 1 and abs(rr - r) <= 2:\n                        chain.add(sq2)\n                for sqq in chain:\n                    used.add(sqq)\n                    rr = chess.square_rank(sqq)\n                    adv = (rr / 7.0) if color == chess.WHITE else ((7 - rr) / 7.0)\n                    score[color] += 0.7 + 1.0 * adv\n        return float(score[chess.WHITE] - score[chess.BLACK])\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Checking-move potential: normalized number of legal moves that give check for each side (white - black); positive favors White'\n    try:\n        orig = board.turn\n        checks = {chess.WHITE:0.0, chess.BLACK:0.0}\n        moves = {chess.WHITE:0.0, chess.BLACK:0.0}\n        try:\n            for color in (chess.WHITE, chess.BLACK):\n                board.turn = color\n                for mv in list(board.legal_moves):\n                    moves[color] += 1.0\n                    try:\n                        board.push(mv)\n                        if board.is_check():\n                            checks[color] += 1.0\n                        board.pop()\n                    except Exception:\n                        # if illegal to push/pop due to weird state, skip that move\n                        try:\n                            if board.move_stack:\n                                board.pop()\n                        except Exception:\n                            pass\n                        continue\n        finally:\n            board.turn = orig\n        # normalized check potential per move\n        w_rate = checks[chess.WHITE] / (1.0 + moves[chess.WHITE])\n        b_rate = checks[chess.BLACK] / (1.0 + moves[chess.BLACK])\n        return float(w_rate - b_rate)\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Queen centralization vs exposure: centrality score of queens penalized by being attacked (white - black)'\n    try:\n        pm = board.piece_map()\n        centers = [chess.parse_square(s) for s in ('d4','e4','d5','e5')]\n        def queen_net(color):\n            qs = [sq for sq,p in pm.items() if p and p.piece_type == chess.QUEEN and p.color == color]\n            if not qs:\n                return 0.0\n            tot = 0.0\n            for sq in qs:\n                min_dist = min(chess.square_distance(sq, c) for c in centers)\n                centrality = max(0.0, (6.0 - float(min_dist)) / 6.0)\n                opp = chess.BLACK if color == chess.WHITE else chess.WHITE\n                attackers = len(board.attackers(opp, sq))\n                defenders = len(board.attackers(color, sq))\n                exposure = float(max(0, attackers - defenders))\n                tot += centrality - 0.12 * exposure\n            return tot / float(len(qs))\n        return float(queen_net(chess.WHITE) - queen_net(chess.BLACK))\n    except Exception:\n        return 0.0\n",
    "def feature(board: chess.Board) -> float:\n    'Passed-pawn advancement score: sums strength of passed pawns weighted by rank and connectedness (white - black)'\n    try:\n        pm = board.piece_map()\n        def is_passed(sq, color):\n            f = chess.square_file(sq); r = chess.square_rank(sq)\n            opp = chess.BLACK if color == chess.WHITE else chess.WHITE\n            files = [ff for ff in (f-1, f, f+1) if 0 <= ff < 8]\n            if color == chess.WHITE:\n                for ff in files:\n                    for rr in range(r+1, 8):\n                        p = pm.get(chess.square(ff, rr))\n                        if p and p.piece_type == chess.PAWN and p.color == opp:\n                            return False\n                return True\n            else:\n                for ff in files:\n                    for rr in range(0, r):\n                        p = pm.get(chess.square(ff, rr))\n                        if p and p.piece_type == chess.PAWN and p.color == opp:\n                            return False\n                return True\n        score = {chess.WHITE:0.0, chess.BLACK:0.0}\n        for sq, p in pm.items():\n            if not p or p.piece_type != chess.PAWN:\n                continue\n            color = p.color\n            r = chess.square_rank(sq)\n            if is_passed(sq, color):\n                # advancement factor: more advanced -> stronger\n                adv = (r / 7.0) if color == chess.WHITE else ((7 - r) / 7.0)\n                # connected passed pawn bonus if adjacent file has friendly pawn ahead/behind\n                conn = 0.0\n                for ff in (chess.square_file(sq)-1, chess.square_file(sq)+1):\n                    if 0 <= ff < 8:\n                        for rr in range(0,8):\n                            p2 = pm.get(chess.square(ff, rr))\n                            if p2 and p2.piece_type == chess.PAWN and p2.color == color:\n                                # prefer nearby files and forward direction\n                                if color == chess.WHITE and rr >= r-1:\n                                    conn += 0.6\n                                if color == chess.BLACK and rr <= r+1:\n                                    conn += 0.6\n                score[color] += 2.1 * adv + conn\n        return float(score[chess.WHITE] - score[chess.BLACK])\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Rook file control and seventh-rank pressure: open/semi-open file bonuses and 7th-rank occupancy (white - black)'\n    try:\n        pm = board.piece_map()\n        def rook_score(color):\n            s = 0.0\n            for sq, p in pm.items():\n                if not p or p.piece_type != chess.ROOK or p.color != color:\n                    continue\n                f = chess.square_file(sq)\n                r = chess.square_rank(sq)\n                pawns_on_file = 0\n                friendly_pawns = 0\n                for rr in range(8):\n                    p2 = pm.get(chess.square(f, rr))\n                    if p2 and p2.piece_type == chess.PAWN:\n                        pawns_on_file += 1\n                        if p2.color == color:\n                            friendly_pawns += 1\n                # open file: no pawns; semi-open: no friendly pawns\n                if pawns_on_file == 0:\n                    s += 1.3\n                elif friendly_pawns == 0:\n                    s += 0.8\n                # seventh rank bonus (pressure on opponent back rank)\n                if color == chess.WHITE and r == 6:\n                    s += 1.6\n                if color == chess.BLACK and r == 1:\n                    s += 1.6\n                # doubled rooks bonus if another rook on same file\n                for rr in range(8):\n                    if rr == r: continue\n                    p3 = pm.get(chess.square(f, rr))\n                    if p3 and p3.piece_type == chess.ROOK and p3.color == color:\n                        s += 0.9\n                        break\n            return s\n        return float(rook_score(chess.WHITE) - rook_score(chess.BLACK))\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Bishop-pair and diagonal mobility adjusted by board openness (white - black)'\n    try:\n        pm = board.piece_map()\n        vals = {chess.BISHOP:3.0}\n        pawn_count = sum(1 for p in pm.values() if p and p.piece_type == chess.PAWN)\n        openness = max(0.0, 1.0 - (pawn_count / 16.0))  # more pawns -> less open\n        def bishop_mobility(sq):\n            # count unobstructed diagonal squares for a bishop\n            cnt = 0\n            f0 = chess.square_file(sq); r0 = chess.square_rank(sq)\n            for df, dr in ((1,1),(1,-1),(-1,1),(-1,-1)):\n                f = f0 + df; r = r0 + dr\n                while 0 <= f < 8 and 0 <= r < 8:\n                    p = pm.get(chess.square(f, r))\n                    cnt += 1\n                    if p:\n                        break\n                    f += df; r += dr\n            return cnt\n        score = {chess.WHITE:0.0, chess.BLACK:0.0}\n        for color in (chess.WHITE, chess.BLACK):\n            bishops = [sq for sq,p in pm.items() if p and p.piece_type == chess.BISHOP and p.color == color]\n            if len(bishops) >= 2:\n                # bishop pair baseline\n                score[color] += 1.1 * openness\n            # add mobility of bishops\n            mob = 0.0\n            for b in bishops:\n                mob += 0.08 * bishop_mobility(b)\n            score[color] += mob\n            # penalty if both bishops on same color squares (reduces pair value)\n            if len(bishops) >= 2:\n                colorsq = [(chess.square_file(b) + chess.square_rank(b)) & 1 for b in bishops]\n                if all(x == colorsq[0] for x in colorsq):\n                    score[color] -= 0.4 * openness\n        return float(score[chess.WHITE] - score[chess.BLACK])\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Knight outpost presence: counts advanced knights on outposts not attackable by enemy pawns (white - black)'\n    try:\n        pm = board.piece_map()\n        def is_attacked_by_pawn(sq, by_color):\n            # check if any pawn of by_color attacks sq\n            attackers = board.attackers(by_color, sq)\n            for a in attackers:\n                pa = pm.get(a)\n                if pa and pa.piece_type == chess.PAWN:\n                    return True\n            return False\n        def outpost_score(color):\n            s = 0.0\n            for sq,p in pm.items():\n                if not p or p.piece_type != chess.KNIGHT or p.color != color:\n                    continue\n                r = chess.square_rank(sq)\n                # require somewhat advanced placement\n                if color == chess.WHITE and r < 3:\n                    continue\n                if color == chess.BLACK and r > 4:\n                    continue\n                opp = chess.BLACK if color == chess.WHITE else chess.WHITE\n                # true outpost: not attacked by opponent pawn and defended by something of own side\n                if not is_attacked_by_pawn(sq, opp):\n                    defenders = board.attackers(color, sq)\n                    if len(defenders) >= 1:\n                        s += 1.7\n                    else:\n                        s += 0.4\n            return s\n        return float(outpost_score(chess.WHITE) - outpost_score(chess.BLACK))\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Hanging / underdefended pieces penalty: net penalty for pieces attacked more times than defended (positive favors White)'\n    try:\n        pm = board.piece_map()\n        vals = {chess.PAWN:1.0, chess.KNIGHT:3.0, chess.BISHOP:3.0, chess.ROOK:5.0, chess.QUEEN:9.0, chess.KING:0.0}\n        pen = {chess.WHITE:0.0, chess.BLACK:0.0}\n        for sq,p in pm.items():\n            if not p:\n                continue\n            color = p.color\n            opp = chess.BLACK if color == chess.WHITE else chess.WHITE\n            attackers = board.attackers(opp, sq)\n            defenders = board.attackers(color, sq)\n            a_cnt = len(attackers)\n            d_cnt = len(defenders)\n            if a_cnt > d_cnt:\n                # penalty grows with how underdefended and piece value\n                pen[color] += vals.get(p.piece_type, 0.0) * float(a_cnt - d_cnt) * 0.65\n        # side with more hanging pieces is worse; return black_pen - white_pen (positive favors White)\n        return float(pen[chess.BLACK] - pen[chess.WHITE])\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Weighted central control: sum of piece-weighted attacks on the 4 central squares plus occupancy (white - black)'\n    try:\n        centers = [chess.parse_square(s) if isinstance(s,str) else None for s in []]  # harmless placeholder\n        central_squares = [chess.square(f,r) for f in (3,4) for r in (3,4)]\n        pm = board.piece_map()\n        vals = {chess.PAWN:0.9, chess.KNIGHT:3.1, chess.BISHOP:3.0, chess.ROOK:4.8, chess.QUEEN:8.8, chess.KING:0.0}\n        score = {chess.WHITE:0.0, chess.BLACK:0.0}\n        for csq in central_squares:\n            for color in (chess.WHITE, chess.BLACK):\n                attackers = board.attackers(color, csq)\n                for a in attackers:\n                    p = pm.get(a)\n                    if p:\n                        score[color] += vals.get(p.piece_type, 0.0) * 0.22\n            occ = pm.get(csq)\n            if occ:\n                score[occ.color] += 0.6  # occupying center matters\n        # slight bonus to side to move controlling center\n        mover = chess.WHITE if board.turn else chess.BLACK\n        score[mover] += 0.18\n        return float(score[chess.WHITE] - score[chess.BLACK])\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Pawn storm proximity to king: counts opponent pawns near king (within manhattan<=3) indicating attacking pawn mass (black - white favors White when black storm worse)'\n    try:\n        pm = board.piece_map()\n        def storm_for_king(color):\n            # return number of opponent pawns near the king of color\n            king_sq = next((sq for sq,p in pm.items() if p and p.piece_type == chess.KING and p.color == color), None)\n            if king_sq is None:\n                return 0.0\n            opp = chess.BLACK if color == chess.WHITE else chess.WHITE\n            kf = chess.square_file(king_sq); kr = chess.square_rank(king_sq)\n            cnt = 0.0\n            for sq,p in pm.items():\n                if not p or p.piece_type != chess.PAWN or p.color != opp:\n                    continue\n                df = abs(chess.square_file(sq) - kf)\n                dr = abs(chess.square_rank(sq) - kr)\n                if df + dr <= 3:\n                    # weight more for pawns on adjacent files and forward direction roughly\n                    w = 1.0\n                    if df == 0:\n                        w += 0.3\n                    if dr <= 1:\n                        w += 0.4\n                    cnt += w\n            return cnt\n        # higher value means Black's king more stormed -> negative for Black; we return (black_storm - white_storm)\n        b_storm = storm_for_king(chess.BLACK)\n        w_storm = storm_for_king(chess.WHITE)\n        return float(b_storm - w_storm)\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Piece coordination: inverted average Manhattan distance among non-pawn non-king pieces (white - black), higher is better coordination'\n    try:\n        pm = board.piece_map()\n        def coord(color):\n            sqs = [sq for sq,p in pm.items() if p and p.color == color and p.piece_type not in (chess.PAWN, chess.KING)]\n            n = len(sqs)\n            if n < 2:\n                return 0.0\n            total = 0.0; pairs = 0\n            for i in range(n):\n                for j in range(i+1, n):\n                    total += chess.square_distance(sqs[i], sqs[j])\n                    pairs += 1\n            avg = total / pairs if pairs > 0 else 14.0\n            # convert to coordination score (higher when avg distance smaller)\n            return float(max(0.0, (14.0 - avg) / 14.0))\n        return float(coord(chess.WHITE) - coord(chess.BLACK))\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Rook mobility potential: sum of unobstructed ray squares (including capture squares) for rooks (white - black)'\n    try:\n        pm = board.piece_map()\n        def rook_mobility(color):\n            s = 0.0\n            for sq,p in pm.items():\n                if not p or p.piece_type != chess.ROOK or p.color != color:\n                    continue\n                f0 = chess.square_file(sq); r0 = chess.square_rank(sq)\n                for df, dr in ((1,0),(-1,0),(0,1),(0,-1)):\n                    f = f0 + df; r = r0 + dr\n                    steps = 0\n                    while 0 <= f < 8 and 0 <= r < 8:\n                        target = pm.get(chess.square(f, r))\n                        steps += 1\n                        # if occupied by friend, cannot move/capture further\n                        if target:\n                            if target.color != color:\n                                s += 0.9  # capture possibility counts\n                            break\n                        s += 0.5\n                        f += df; r += dr\n                        if steps > 14:\n                            break\n                # extra for doubling on open file handled elsewhere but reward being active on rank\n                if (color == chess.WHITE and r0 == 6) or (color == chess.BLACK and r0 == 1):\n                    s += 0.6\n            return s\n        return float(rook_mobility(chess.WHITE) - rook_mobility(chess.BLACK))\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Direct unobstructed sliding attackers to king: counts rooks/queens/bishops with clear lines to enemy king weighted by piece value (white - black)'\n    try:\n        pm = board.piece_map()\n        vals = {chess.BISHOP:3.0, chess.ROOK:5.0, chess.QUEEN:9.0}\n        def sliding_threats_on_king(attacker_color):\n            defender = chess.BLACK if attacker_color == chess.WHITE else chess.WHITE\n            king_sq = next((sq for sq,p in pm.items() if p and p.piece_type == chess.KING and p.color == defender), None)\n            if king_sq is None:\n                return 0.0\n            kf = chess.square_file(king_sq); kr = chess.square_rank(king_sq)\n            total = 0.0\n            for sq,p in pm.items():\n                if not p or p.color != attacker_color or p.piece_type not in (chess.BISHOP, chess.ROOK, chess.QUEEN):\n                    continue\n                f = chess.square_file(sq); r = chess.square_rank(sq)\n                df = kf - f; dr = kr - r\n                step_f = 0; step_r = 0\n                if df == 0:\n                    step_f = 0; step_r = 1 if dr > 0 else -1\n                elif dr == 0:\n                    step_f = 1 if df > 0 else -1; step_r = 0\n                elif abs(df) == abs(dr):\n                    step_f = 1 if df > 0 else -1; step_r = 1 if dr > 0 else -1\n                else:\n                    continue\n                # check path clear between sq and king (exclusive)\n                f2 = f + step_f; r2 = r + step_r\n                blocked = False\n                while (f2, r2) != (kf, kr):\n                    if pm.get(chess.square(f2, r2)):\n                        blocked = True\n                        break\n                    f2 += step_f; r2 += step_r\n                if not blocked:\n                    total += vals.get(p.piece_type, 0.0)\n            return total\n        w = sliding_threats_on_king(chess.WHITE)\n        b = sliding_threats_on_king(chess.BLACK)\n        return float(w - b)\n    except Exception:\n        return 0.0\n",
    "def feature(board: chess.Board) -> float:\n    'Passed-pawn potential: counts passed pawns weighted by advancement (white - black)'\n    try:\n        pm = board.piece_map()\n        def passed_weight(sq, p):\n            rank = chess.square_rank(sq)\n            if p.color == chess.WHITE:\n                # advancement fraction 0 (on rank0) .. 1 (on rank6); clamp if on rank7\n                adv = min(max(rank, 0), 6) / 6.0\n            else:\n                adv = min(max(7 - rank, 0), 6) / 6.0\n            return adv ** 1.4\n        def is_passed(sq, p):\n            f = chess.square_file(sq); r = chess.square_rank(sq)\n            opp = chess.BLACK if p.color == chess.WHITE else chess.WHITE\n            if p.color == chess.WHITE:\n                for ff in (f-1, f, f+1):\n                    if 0 <= ff < 8:\n                        for rr in range(r+1, 8):\n                            sq2 = chess.square(ff, rr)\n                            q = pm.get(sq2)\n                            if q and q.piece_type == chess.PAWN and q.color == opp:\n                                return False\n                return True\n            else:\n                for ff in (f-1, f, f+1):\n                    if 0 <= ff < 8:\n                        for rr in range(0, r):\n                            sq2 = chess.square(ff, rr)\n                            q = pm.get(sq2)\n                            if q and q.piece_type == chess.PAWN and q.color == opp:\n                                return False\n                return True\n        w = 0.0; b = 0.0\n        for sq, p in pm.items():\n            if not p or p.piece_type != chess.PAWN:\n                continue\n            if is_passed(sq, p):\n                if p.color == chess.WHITE:\n                    w += passed_weight(sq, p)\n                else:\n                    b += passed_weight(sq, p)\n        return float(w - b)\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Rook file quality: rooks on open files (no pawns) and semi-open files (only opponent pawns) (white - black)'\n    try:\n        pm = board.piece_map()\n        pawn_count_on_file = [0]*8\n        pawn_color_on_file = [set() for _ in range(8)]\n        for sq, p in pm.items():\n            if p and p.piece_type == chess.PAWN:\n                f = chess.square_file(sq)\n                pawn_count_on_file[f] += 1\n                pawn_color_on_file[f].add(p.color)\n        def rook_score_for_color(color):\n            score = 0.0\n            for sq, p in pm.items():\n                if p and p.piece_type == chess.ROOK and p.color == color:\n                    f = chess.square_file(sq)\n                    if pawn_count_on_file[f] == 0:\n                        score += 1.0\n                    elif pawn_color_on_file[f] == { (chess.BLACK if color==chess.WHITE else chess.WHITE) }:\n                        score += 0.5\n            return score\n        return float(rook_score_for_color(chess.WHITE) - rook_score_for_color(chess.BLACK))\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Net hanging material: weighted sum of opponent hanging pieces minus own hanging pieces (positive favors White)'\n    try:\n        vals = {chess.PAWN:1.0, chess.KNIGHT:3.0, chess.BISHOP:3.0, chess.ROOK:5.0, chess.QUEEN:9.0, chess.KING:0.0}\n        pm = board.piece_map()\n        hang = {chess.WHITE:0.0, chess.BLACK:0.0}\n        for sq, p in pm.items():\n            if not p or p.piece_type == chess.KING:\n                continue\n            opp = chess.BLACK if p.color == chess.WHITE else chess.WHITE\n            attackers_by_opp = board.attackers(opp, sq)\n            defenders = board.attackers(p.color, sq)\n            # if attacked by opponent and has no defenders -> hanging\n            if attackers_by_opp and len(defenders) == 0:\n                hang[p.color] += vals.get(p.piece_type, 0.0)\n        # positive means White advantage if Black has more hanging material\n        return float(hang[chess.BLACK] - hang[chess.WHITE])\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Rooks on seventh rank pressure: rooks on opponent seventh rank weighted by opposing pawn structure (white - black)'\n    try:\n        pm = board.piece_map()\n        def seventh_score(color):\n            score = 0.0\n            if color == chess.WHITE:\n                target_rank = 6\n                enemy_pawn_rank = 6\n                enemy = chess.BLACK\n            else:\n                target_rank = 1\n                enemy_pawn_rank = 1\n                enemy = chess.WHITE\n            for sq, p in pm.items():\n                if p and p.piece_type == chess.ROOK and p.color == color:\n                    if chess.square_rank(sq) == target_rank:\n                        # count enemy pawns on that rank to know pressure/leverage\n                        pawn_count = sum(1 for s,q in pm.items() if q and q.piece_type==chess.PAWN and q.color==enemy and chess.square_rank(s)==enemy_pawn_rank)\n                        score += 1.0 + 0.25 * pawn_count\n            return score\n        return float(seventh_score(chess.WHITE) - seventh_score(chess.BLACK))\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Outpost knights: knights on squares immune to enemy pawn attacks and supported by own pawns, weighted by centrality (white - black)'\n    try:\n        pm = board.piece_map()\n        def outposts(color):\n            opp = chess.BLACK if color==chess.WHITE else chess.WHITE\n            cnt = 0.0\n            for sq, p in pm.items():\n                if not p or p.piece_type != chess.KNIGHT or p.color != color:\n                    continue\n                # check if any enemy pawn attacks this square\n                pawn_attackers = [a for a in board.attackers(opp, sq) if pm.get(a) and pm.get(a).piece_type==chess.PAWN]\n                if pawn_attackers:\n                    continue\n                # check defended by own pawn\n                pawn_defenders = [a for a in board.attackers(color, sq) if pm.get(a) and pm.get(a).piece_type==chess.PAWN]\n                if not pawn_defenders:\n                    continue\n                # centrality boost: files 2..5 and ranks 2..5 more valuable\n                f = chess.square_file(sq); r = chess.square_rank(sq)\n                central = 1.2 if 2 <= f <= 5 and 2 <= r <= 5 else 0.8\n                cnt += central\n            return cnt\n        return float(outposts(chess.WHITE) - outposts(chess.BLACK))\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'King centralization in endgames: advantage for the side whose king is closer to the board center when material is low'\n    try:\n        import math\n        pm = board.piece_map()\n        vals = {chess.PAWN:1.0, chess.KNIGHT:3.0, chess.BISHOP:3.0, chess.ROOK:5.0, chess.QUEEN:9.0}\n        total_material = 0.0\n        wk = bk = None\n        for sq, p in pm.items():\n            if not p:\n                continue\n            if p.piece_type != chess.KING:\n                total_material += vals.get(p.piece_type, 0.0)\n            if p.piece_type == chess.KING:\n                if p.color == chess.WHITE:\n                    wk = sq\n                else:\n                    bk = sq\n        # endgame factor: stronger when less material remains\n        factor = 1.0 if total_material <= 8.0 else max(0.0, (24.0 - total_material) / 24.0)\n        def king_center_dist(sq):\n            if sq is None:\n                return 0.0\n            f = chess.square_file(sq); r = chess.square_rank(sq)\n            dx = f - 3.5; dy = r - 3.5\n            return math.hypot(dx, dy)  # smaller is better\n        dw = king_center_dist(wk)\n        db = king_center_dist(bk)\n        # positive if White's king is comparatively better centralized\n        return float((db - dw) * factor)\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Heavy-piece mobility: normalized legal move count for rooks+queens difference (white - black)'\n    try:\n        pm = board.piece_map()\n        heavy_counts = {chess.WHITE:0, chess.BLACK:0}\n        for p in pm.values():\n            if p and p.piece_type in (chess.ROOK, chess.QUEEN):\n                heavy_counts[p.color] += 1\n        orig = board.turn\n        try:\n            mobility = {chess.WHITE:0.0, chess.BLACK:0.0}\n            for color in (chess.WHITE, chess.BLACK):\n                board.turn = color\n                cnt = 0\n                for mv in board.legal_moves:\n                    p = board.piece_at(mv.from_square)\n                    if p and p.color == color and p.piece_type in (chess.ROOK, chess.QUEEN):\n                        cnt += 1\n                denom = heavy_counts[color] if heavy_counts[color] > 0 else 1\n                mobility[color] = cnt / float(denom)\n        finally:\n            board.turn = orig\n        # normalize by sum to keep scale small\n        total = max(1.0, mobility[chess.WHITE] + mobility[chess.BLACK])\n        return float((mobility[chess.WHITE] - mobility[chess.BLACK]) / total)\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'King escape squares: number of safe adjacent squares for each king (white - black), normalized to [-1,1]'\n    try:\n        pm = board.piece_map()\n        def king_safe_squares(color):\n            king_sq = next((sq for sq, p in pm.items() if p and p.piece_type == chess.KING and p.color == color), None)\n            if king_sq is None:\n                return 0.0\n            f = chess.square_file(king_sq); r = chess.square_rank(king_sq)\n            opp = chess.BLACK if color == chess.WHITE else chess.WHITE\n            safe = 0\n            for ff in range(f-1, f+2):\n                for rr in range(r-1, r+2):\n                    if ff == f and rr == r:\n                        continue\n                    if 0 <= ff < 8 and 0 <= rr < 8:\n                        sq = chess.square(ff, rr)\n                        piece = pm.get(sq)\n                        # cannot move onto own piece's square\n                        if piece and piece.color == color:\n                            continue\n                        # square is safe if not attacked by opponent\n                        if not board.is_attacked_by(opp, sq):\n                            safe += 1\n            return safe / 8.0\n        return float(king_safe_squares(chess.WHITE) - king_safe_squares(chess.BLACK))\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Pawn majority on flank of enemy king: measures attacking-side pawn count advantage on the flank where the opponent king stands (white - black)'\n    try:\n        pm = board.piece_map()\n        def flank_majority(attacker_color):\n            defender = chess.BLACK if attacker_color == chess.WHITE else chess.WHITE\n            king_sq = next((sq for sq, p in pm.items() if p and p.piece_type == chess.KING and p.color == defender), None)\n            if king_sq is None:\n                return 0.0\n            kf = chess.square_file(king_sq)\n            # define flank: queenside files 0..3, kingside 4..7\n            if kf <= 3:\n                files = range(0, 4)\n            else:\n                files = range(4, 8)\n            atk_cnt = 0; def_cnt = 0\n            for sq, p in pm.items():\n                if not p or p.piece_type != chess.PAWN:\n                    continue\n                f = chess.square_file(sq)\n                if f in files:\n                    if p.color == attacker_color:\n                        atk_cnt += 1\n                    elif p.color == defender:\n                        def_cnt += 1\n            # return normalized majority\n            return (atk_cnt - def_cnt) / 8.0\n        return float(flank_majority(chess.WHITE) - flank_majority(chess.BLACK))\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Bishop diagonal reach and pair bonus: sum of unobstructed diagonal lengths for bishops plus bishop-pair boost (white - black)'\n    try:\n        pm = board.piece_map()\n        def bishop_score(color):\n            score = 0.0\n            bishops = [sq for sq, p in pm.items() if p and p.piece_type == chess.BISHOP and p.color == color]\n            for sq in bishops:\n                f = chess.square_file(sq); r = chess.square_rank(sq)\n                # four diagonal directions\n                for df, dr in ((1,1),(1,-1),(-1,1),(-1,-1)):\n                    steps = 0\n                    ff, rr = f+df, r+dr\n                    while 0 <= ff < 8 and 0 <= rr < 8:\n                        sq2 = chess.square(ff, rr)\n                        if pm.get(sq2):\n                            break\n                        steps += 1\n                        ff += df; rr += dr\n                    score += steps\n            # bishop-pair bonus\n            if len(bishops) >= 2:\n                score += 1.2\n            # normalize roughly by board size\n            return score / 10.0\n        return float(bishop_score(chess.WHITE) - bishop_score(chess.BLACK))\n    except Exception:\n        return 0.0\n",
    "def feature(board: chess.Board) -> float:\n    'Pawn islands difference (fewer islands is better): (black_islands - white_islands) positive favors White'\n    try:\n        pm = board.piece_map()\n        def pawn_islands(color):\n            files_has = [False] * 8\n            for sq, p in pm.items():\n                if not p or p.piece_type != chess.PAWN or p.color != color:\n                    continue\n                f = chess.square_file(sq)\n                files_has[f] = True\n            islands = 0\n            i = 0\n            while i < 8:\n                if files_has[i]:\n                    islands += 1\n                    while i < 8 and files_has[i]:\n                        i += 1\n                else:\n                    i += 1\n            return float(islands)\n        w_is = pawn_islands(chess.WHITE)\n        b_is = pawn_islands(chess.BLACK)\n        return float(b_is - w_is)\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Passed pawn potential: weighted count of passed pawns by advancement (white - black)'\n    try:\n        pm = board.piece_map()\n        def is_passed(sq, color):\n            f = chess.square_file(sq); r = chess.square_rank(sq)\n            opp = chess.BLACK if color == chess.WHITE else chess.WHITE\n            if color == chess.WHITE:\n                # any opposing pawn on same or adjacent file with rank > r blocks passed\n                for ff in range(max(0, f-1), min(7, f+1)+1):\n                    for rr in range(r+1, 8):\n                        s = chess.square(ff, rr)\n                        p = pm.get(s)\n                        if p and p.piece_type == chess.PAWN and p.color == opp:\n                            return False\n                return True\n            else:\n                for ff in range(max(0, f-1), min(7, f+1)+1):\n                    for rr in range(0, r):\n                        s = chess.square(ff, rr)\n                        p = pm.get(s)\n                        if p and p.piece_type == chess.PAWN and p.color == opp:\n                            return False\n                return True\n        def score_for(color):\n            total = 0.0\n            for sq, p in pm.items():\n                if not p or p.piece_type != chess.PAWN or p.color != color:\n                    continue\n                if not is_passed(sq, color):\n                    continue\n                r = chess.square_rank(sq)\n                # advancement weight: for white higher rank better; for black lower rank better\n                if color == chess.WHITE:\n                    adv = float(r) / 7.0\n                else:\n                    adv = float(7 - r) / 7.0\n                # promote strong passed pawns more\n                total += 1.0 + 2.5 * adv\n            return total\n        return float(score_for(chess.WHITE) - score_for(chess.BLACK))\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Doubled and isolated pawn penalty difference: (black_penalty - white_penalty) positive favors White'\n    try:\n        pm = board.piece_map()\n        pawn_files = {chess.WHITE: [0]*8, chess.BLACK: [0]*8}\n        for sq, p in pm.items():\n            if not p or p.piece_type != chess.PAWN:\n                continue\n            f = chess.square_file(sq)\n            pawn_files[p.color][f] += 1\n        penalties = {chess.WHITE:0.0, chess.BLACK:0.0}\n        for color in (chess.WHITE, chess.BLACK):\n            files = pawn_files[color]\n            for f in range(8):\n                # doubled or more\n                if files[f] > 1:\n                    penalties[color] += 0.5 * (files[f] - 1)\n                # isolated\n                left = files[f-1] if f-1 >= 0 else 0\n                right = files[f+1] if f+1 <= 7 else 0\n                if files[f] > 0 and left == 0 and right == 0:\n                    penalties[color] += 0.7 * files[f]\n        return float(penalties[chess.BLACK] - penalties[chess.WHITE])\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Rook control of open/semi-open files (weighted) (white - black)'\n    try:\n        pm = board.piece_map()\n        # classify files\n        file_pawns = [0]*8  # 0 none, 1 white, -1 black, 2 both\n        for f in range(8):\n            w = any(p and p.piece_type==chess.PAWN and p.color==chess.WHITE for sq,p in pm.items() if chess.square_file(sq)==f)\n            b = any(p and p.piece_type==chess.PAWN and p.color==chess.BLACK for sq,p in pm.items() if chess.square_file(sq)==f)\n            if w and b:\n                file_pawns[f] = 2\n            elif w:\n                file_pawns[f] = 1\n            elif b:\n                file_pawns[f] = -1\n            else:\n                file_pawns[f] = 0\n        w_score = 0.0; b_score = 0.0\n        for sq, p in pm.items():\n            if not p or p.piece_type != chess.ROOK:\n                continue\n            f = chess.square_file(sq); r = chess.square_rank(sq)\n            fp = file_pawns[f]\n            if fp == 0:\n                weight = 1.0\n            elif (fp == 1 and p.color == chess.WHITE) or (fp == -1 and p.color == chess.BLACK):\n                # friendly pawn present -> less effective\n                weight = 0.15\n            else:\n                # semi-open for this rook (no friendly pawn)\n                weight = 0.6\n            # bonus if on opponent's seventh or more advanced\n            bonus = 0.0\n            if p.color == chess.WHITE and r >= 6:\n                bonus = 0.5\n            if p.color == chess.BLACK and r <= 1:\n                bonus = 0.5\n            if p.color == chess.WHITE:\n                w_score += weight + bonus\n            else:\n                b_score += weight + bonus\n        return float(w_score - b_score)\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Pinned pieces difference (how many pieces pinned to king) (black_pinned - white_pinned) positive favors White'\n    try:\n        pm = board.piece_map()\n        # find kings\n        kings = {chess.WHITE: None, chess.BLACK: None}\n        for sq, p in pm.items():\n            if p and p.piece_type == chess.KING:\n                kings[p.color] = sq\n        def pinned_count(color):\n            opp = chess.BLACK if color == chess.WHITE else chess.WHITE\n            king_sq = kings[color]\n            if king_sq is None:\n                return 0.0\n            count = 0\n            # look for opponent sliding pieces that are aligned with king\n            for sq, p in pm.items():\n                if not p or p.color != opp or p.piece_type not in (chess.QUEEN, chess.ROOK, chess.BISHOP):\n                    continue\n                f1 = chess.square_file(king_sq); r1 = chess.square_rank(king_sq)\n                f2 = chess.square_file(sq); r2 = chess.square_rank(sq)\n                df = f2 - f1; dr = r2 - r1\n                step_f = 0; step_r = 0\n                if df == 0 and dr != 0:\n                    step_f = 0; step_r = 1 if dr>0 else -1\n                elif dr == 0 and df != 0:\n                    step_r = 0; step_f = 1 if df>0 else -1\n                elif abs(df) == abs(dr) and df != 0:\n                    step_f = 1 if df>0 else -1\n                    step_r = 1 if dr>0 else -1\n                else:\n                    continue\n                # ensure sliding piece type fits direction\n                if p.piece_type == chess.ROOK and (step_f != 0 and step_r != 0):\n                    continue\n                if p.piece_type == chess.BISHOP and (step_f == 0 or step_r == 0):\n                    continue\n                # count intervening pieces\n                cur_f = f1 + step_f; cur_r = r1 + step_r\n                intervening = []\n                while (cur_f, cur_r) != (f2, r2):\n                    if not (0 <= cur_f < 8 and 0 <= cur_r < 8):\n                        break\n                    cur_sq = chess.square(cur_f, cur_r)\n                    if pm.get(cur_sq):\n                        intervening.append((cur_sq, pm.get(cur_sq)))\n                    cur_f += step_f; cur_r += step_r\n                # pinned if exactly one intervening piece and it is of 'color'\n                if len(intervening) == 1 and intervening[0][1].color == color:\n                    count += 1\n            return float(count)\n        w_pin = pinned_count(chess.WHITE)\n        b_pin = pinned_count(chess.BLACK)\n        return float(b_pin - w_pin)\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'King centrality advantage scaled by endgame factor: (black_dist - white_dist) * endgame_factor (positive favors White)'\n    try:\n        pm = board.piece_map()\n        # find kings\n        wk = next((sq for sq,p in pm.items() if p and p.piece_type==chess.KING and p.color==chess.WHITE), None)\n        bk = next((sq for sq,p in pm.items() if p and p.piece_type==chess.KING and p.color==chess.BLACK), None)\n        if wk is None or bk is None:\n            return 0.0\n        def center_dist(sq):\n            f = chess.square_file(sq); r = chess.square_rank(sq)\n            # center at (3.5,3.5), use Euclidean-like metric\n            return ((float(f)-3.5)**2 + (float(r)-3.5)**2) ** 0.5\n        # compute remaining non-king material\n        material = 0\n        vals = {chess.PAWN:1, chess.KNIGHT:3, chess.BISHOP:3, chess.ROOK:5, chess.QUEEN:9}\n        for p in pm.values():\n            if not p or p.piece_type == chess.KING:\n                continue\n            material += vals.get(p.piece_type, 0)\n        endgame_factor = 1.0 if material <= 10 else 0.28\n        wd = center_dist(wk); bd = center_dist(bk)\n        # smaller distance is better in endgame\n        return float((bd - wd) * endgame_factor)\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Loose piece vulnerability sum difference: sum of values of pieces that are attacked and undefended (black - white) positive favors White'\n    try:\n        pm = board.piece_map()\n        vals = {chess.PAWN:1.0, chess.KNIGHT:3.0, chess.BISHOP:3.0, chess.ROOK:5.0, chess.QUEEN:9.0, chess.KING:0.0}\n        vuln = {chess.WHITE:0.0, chess.BLACK:0.0}\n        for sq, p in pm.items():\n            if not p:\n                continue\n            attackers = board.attackers(not p.color, sq)\n            if not attackers:\n                continue\n            defenders = board.attackers(p.color, sq)\n            if len(defenders) == 0:\n                vuln[p.color] += vals.get(p.piece_type, 0.0)\n        return float(vuln[chess.BLACK] - vuln[chess.WHITE])\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'King-side minor piece mobility imbalance (white_ks_moves - black_ks_moves) positive favors White'\n    try:\n        pm = board.piece_map()\n        orig = board.turn\n        try:\n            ks_moves = {chess.WHITE:0.0, chess.BLACK:0.0}\n            qs_moves = {chess.WHITE:0.0, chess.BLACK:0.0}\n            for color in (chess.WHITE, chess.BLACK):\n                board.turn = color\n                for mv in board.legal_moves:\n                    p = board.piece_at(mv.from_square)\n                    if p and p.color == color and p.piece_type in (chess.KNIGHT, chess.BISHOP):\n                        f = chess.square_file(mv.from_square)\n                        # king-side defined as files 4-7 inclusive\n                        if f >= 4:\n                            ks_moves[color] += 1.0\n                        else:\n                            qs_moves[color] += 1.0\n            # normalized difference of king-side mobility advantage between sides\n            w_ks = ks_moves[chess.WHITE]; b_ks = ks_moves[chess.BLACK]\n            w_qs = qs_moves[chess.WHITE]; b_qs = qs_moves[chess.BLACK]\n            # emphasize king-side mobility relative to queen-side to capture attacking potential\n            white_metric = w_ks - 0.5 * w_qs\n            black_metric = b_ks - 0.5 * b_qs\n            return float(white_metric - black_metric)\n        finally:\n            board.turn = orig\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Queen centralization vs pressure: sum over queens of centrality*(defenders - attackers) (white - black)'\n    try:\n        pm = board.piece_map()\n        def queen_score(color):\n            s = 0.0\n            for sq, p in pm.items():\n                if not p or p.piece_type != chess.QUEEN or p.color != color:\n                    continue\n                f = chess.square_file(sq); r = chess.square_rank(sq)\n                # centrality: inverse distance to center\n                dist = ((float(f)-3.5)**2 + (float(r)-3.5)**2) ** 0.5\n                centrality = max(0.0, (5.0 - dist) / 5.0)\n                attackers = len(board.attackers(not color, sq))\n                defenders = len(board.attackers(color, sq))\n                s += centrality * float(defenders - attackers)\n            return s\n        return float(queen_score(chess.WHITE) - queen_score(chess.BLACK))\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Pawn majority on one flank: (white_best_majority - black_best_majority) positive favors White'\n    try:\n        pm = board.piece_map()\n        def pawns_by_side(color):\n            files = [0]*8\n            for sq, p in pm.items():\n                if p and p.piece_type == chess.PAWN and p.color == color:\n                    files[chess.square_file(sq)] += 1\n            qs = sum(files[0:4])  # a-d\n            ks = sum(files[4:8])  # e-h\n            return qs, ks\n        w_qs, w_ks = pawns_by_side(chess.WHITE)\n        b_qs, b_ks = pawns_by_side(chess.BLACK)\n        # majority is difference per flank (positive means majority)\n        w_majority = max(0, w_qs - b_qs, w_ks - b_ks)\n        b_majority = max(0, b_qs - w_qs, b_ks - w_ks)\n        return float(w_majority - b_majority)\n    except Exception:\n        return 0.0\n",
    "def feature(board: chess.Board) -> float:\n    'Pawn island imbalance: (black pawn islands - white pawn islands); positive favors White when fewer white islands'\n    try:\n        pm = board.piece_map()\n        def pawn_islands(color):\n            files_with = [False]*8\n            for sq,p in pm.items():\n                if p and p.piece_type == chess.PAWN and p.color == color:\n                    files_with[chess.square_file(sq)] = True\n            islands = 0\n            i = 0\n            while i < 8:\n                if files_with[i]:\n                    islands += 1\n                    while i < 8 and files_with[i]:\n                        i += 1\n                else:\n                    i += 1\n            return islands\n        w = pawn_islands(chess.WHITE)\n        b = pawn_islands(chess.BLACK)\n        # return positive when White structurally better (fewer islands)\n        return float((b - w))\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Doubled and isolated pawn penalty: (black_penalty - white_penalty) where penalty >=0; positive favors White when black has worse pawns'\n    try:\n        pm = board.piece_map()\n        def pawn_penalty(color):\n            # doubled pawns: each extra pawn on same file counts 0.5\n            file_counts = [0]*8\n            pawns = []\n            for sq,p in pm.items():\n                if p and p.piece_type == chess.PAWN and p.color == color:\n                    f = chess.square_file(sq)\n                    file_counts[f] += 1\n                    pawns.append(sq)\n            doubled = sum(max(0, c-1) for c in file_counts) * 0.5\n            # isolated pawns: pawn with no friendly pawn on adjacent files\n            isolated = 0.0\n            for sq in pawns:\n                f = chess.square_file(sq)\n                if (f==0 or file_counts[f-1]==0) and (f==7 or file_counts[f+1]==0):\n                    isolated += 0.8\n            return doubled + isolated\n        pen_w = pawn_penalty(chess.WHITE)\n        pen_b = pawn_penalty(chess.BLACK)\n        return float(pen_b - pen_w)\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Bishop-pair and bad-bishop metric: (white_score - black_score); good for bishops on opposite colors and penalizes blocked bishops'\n    try:\n        pm = board.piece_map()\n        def side_score(color):\n            bishops = [sq for sq,p in pm.items() if p and p.piece_type==chess.BISHOP and p.color==color]\n            pawns = [sq for sq,p in pm.items() if p and p.piece_type==chess.PAWN and p.color==color]\n            score = 0.0\n            if len(bishops) >= 2:\n                score += 0.6  # bishop pair bonus\n                # extra if bishops on opposite colors\n                colorset = set(((chess.square_file(sq)+chess.square_rank(sq)) & 1) for sq in bishops)\n                if len(colorset) == 2:\n                    score += 0.25\n            # bad-bishop penalty: many own pawns on same color squares as bishop reduce mobility\n            for sq in bishops:\n                sqcolor = (chess.square_file(sq) + chess.square_rank(sq)) & 1\n                same_color_pawns = sum(1 for pp in pawns if ((chess.square_file(pp)+chess.square_rank(pp)) & 1) == sqcolor)\n                if len(pawns) > 0 and same_color_pawns >= max(3, len(pawns)//2):\n                    score -= 0.45\n            return score\n        return float(side_score(chess.WHITE) - side_score(chess.BLACK))\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Rook effectiveness on open/semi-open files: (white_score - black_score); open file = no pawns, semi-open = no friendly pawns'\n    try:\n        pm = board.piece_map()\n        def file_pawn_presence(file_index):\n            own = False; opp = False\n            for r in range(8):\n                p = pm.get(chess.square(file_index, r))\n                if p and p.piece_type == chess.PAWN:\n                    if p.color == chess.WHITE:\n                        own = True\n                    else:\n                        opp = True\n            return own, opp\n        def side_score(color):\n            score = 0.0\n            for sq,p in pm.items():\n                if p and p.piece_type == chess.ROOK and p.color == color:\n                    f = chess.square_file(sq)\n                    own, opp = file_pawn_presence(f)\n                    if not own and not opp:\n                        score += 0.9\n                    elif not own and opp:\n                        # semi-open but opponent pawns present (rook can attack)\n                        score += 0.6\n                    elif own and not opp:\n                        # semi-open with only friendly pawns (rare) - smaller bonus\n                        score += 0.2\n                    # extra small bonus if rook on 7th rank (rank 6 for white, 1 for black)\n                    r = chess.square_rank(sq)\n                    if (color == chess.WHITE and r == 6) or (color == chess.BLACK and r == 1):\n                        score += 0.4\n            return score\n        return float(side_score(chess.WHITE) - side_score(chess.BLACK))\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Knight outpost score: (# of stable outposts white - black). Outpost = knight on opponent half, protected by pawn and not attackable by enemy pawn'\n    try:\n        pm = board.piece_map()\n        def is_enemy_pawn_attackable(sq, enemy):\n            # check whether any enemy pawn attacks this square\n            return any((pm.get(a) and pm.get(a).piece_type == chess.PAWN and pm.get(a).color == enemy) for a in board.attackers(enemy, sq))\n        def side_outposts(color):\n            score = 0.0\n            enemy = chess.BLACK if color == chess.WHITE else chess.WHITE\n            for sq,p in pm.items():\n                if p and p.piece_type == chess.KNIGHT and p.color == color:\n                    r = chess.square_rank(sq)\n                    # opponent half: for white ranks 4..7, for black ranks 0..3\n                    if (color == chess.WHITE and r >= 4) or (color == chess.BLACK and r <= 3):\n                        # protected by pawn\n                        pawn_protectors = sum(1 for a in board.attackers(color, sq) if pm.get(a) and pm.get(a).piece_type == chess.PAWN)\n                        if pawn_protectors >= 1 and not is_enemy_pawn_attackable(sq, enemy):\n                            score += 1.0\n            return score\n        return float(side_outposts(chess.WHITE) - side_outposts(chess.BLACK))\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Queen centrality and mobility: (white_score - black_score) where score = central presence + normalized queen legal moves'\n    try:\n        pm = board.piece_map()\n        central_squares = set(chess.parse_square(s) for s in ('c3','c4','c5','c6','d3','d4','d5','d6','e3','e4','e5','e6','f3','f4','f5','f6'))\n        def side_score(color):\n            score = 0.0\n            # central presence\n            for sq,p in pm.items():\n                if p and p.piece_type == chess.QUEEN and p.color == color:\n                    if sq in central_squares:\n                        score += 0.8\n                    # distance to center\n                    cf = 3.5; cr = 3.5\n                    f = chess.square_file(sq); r = chess.square_rank(sq)\n                    dist = abs(f - cf) + abs(r - cr)\n                    score += max(0.0, 0.6 - 0.06*dist)\n            # mobility: temporarily set turn to color and count queen legal moves\n            orig = board.turn\n            try:\n                board.turn = color\n                q_moves = 0\n                for mv in board.legal_moves:\n                    pfrom = board.piece_at(mv.from_square)\n                    if pfrom and pfrom.piece_type == chess.QUEEN and pfrom.color == color:\n                        q_moves += 1\n                # normalize: divide by 10 (reasonable cap)\n                score += float(min(q_moves, 12)) * 0.07\n            finally:\n                board.turn = orig\n            return score\n        return float(side_score(chess.WHITE) - side_score(chess.BLACK))\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'King file weakness: (black_weakness - white_weakness) positive favors White when Black king files are weaker'\n    try:\n        pm = board.piece_map()\n        vals = {chess.ROOK:1.0, chess.QUEEN:1.2}\n        def king_weakness(color):\n            king_sq = next((sq for sq,p in pm.items() if p and p.piece_type==chess.KING and p.color==color), None)\n            if king_sq is None:\n                return 0.0\n            f = chess.square_file(king_sq)\n            weak_files = []\n            for ff in (f-1, f, f+1):\n                if 0 <= ff < 8:\n                    # if no friendly pawn on this file -> weaker\n                    friendly_pawn_on_file = any(pm.get(chess.square(ff, rr)) and pm.get(chess.square(ff, rr)).piece_type==chess.PAWN and pm.get(chess.square(ff, rr)).color==color for rr in range(8))\n                    if not friendly_pawn_on_file:\n                        weak_files.append(ff)\n            # compute enemy heavy attackers on those files (any square on file)\n            enemy = chess.BLACK if color == chess.WHITE else chess.WHITE\n            pressure = 0.0\n            for ff in weak_files:\n                for rr in range(8):\n                    sq = chess.square(ff, rr)\n                    for a in board.attackers(enemy, sq):\n                        pa = pm.get(a)\n                        if pa and pa.piece_type in vals:\n                            # weight by proximity to king rank\n                            dist = abs(chess.square_rank(sq) - chess.square_rank(king_sq))\n                            pressure += vals[pa.piece_type] * max(0.1, 1.2 - 0.12*dist)\n            return pressure\n        return float(king_weakness(chess.BLACK) - king_weakness(chess.WHITE))\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Piece coordination: average pairwise Manhattan distance among non-pawn/non-king pieces (black - white); lower distance = better coordination'\n    try:\n        pm = board.piece_map()\n        def avg_pair_dist(color):\n            pts = [sq for sq,p in pm.items() if p and p.color==color and p.piece_type not in (chess.PAWN, chess.KING)]\n            if len(pts) <= 1:\n                return 14.0  # max-ish distance when few pieces (discourage)\n            total = 0.0; cnt = 0\n            for i in range(len(pts)):\n                for j in range(i+1, len(pts)):\n                    total += chess.square_distance(pts[i], pts[j])\n                    cnt += 1\n            return float(total / max(1, cnt))\n        return float(avg_pair_dist(chess.BLACK) - avg_pair_dist(chess.WHITE))\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Passed-pawn support by rook: counts passed pawns that have a friendly rook behind on same file weighted by advancement (white - black)'\n    try:\n        pm = board.piece_map()\n        def is_passed(sq, color):\n            f = chess.square_file(sq); r = chess.square_rank(sq)\n            for ff in (f-1, f, f+1):\n                if 0 <= ff <= 7:\n                    if color == chess.WHITE:\n                        for rr in range(r+1, 8):\n                            p = pm.get(chess.square(ff, rr))\n                            if p and p.piece_type == chess.PAWN and p.color != color:\n                                return False\n                    else:\n                        for rr in range(0, r):\n                            p = pm.get(chess.square(ff, rr))\n                            if p and p.piece_type == chess.PAWN and p.color != color:\n                                return False\n            return True\n        def side_score(color):\n            score = 0.0\n            rooks = [sq for sq,p in pm.items() if p and p.piece_type==chess.ROOK and p.color==color]\n            for sq,p in pm.items():\n                if p and p.piece_type==chess.PAWN and p.color==color:\n                    if is_passed(sq, color):\n                        r = chess.square_rank(sq)\n                        adv = (r/7.0) if color==chess.WHITE else ((7-r)/7.0)\n                        # check rook behind on same file\n                        f = chess.square_file(sq)\n                        behind_ok = False\n                        for rr in range(0, chess.square_rank(sq)):\n                            if color==chess.BLACK:\n                                # for black, \"behind\" means higher rank\n                                pass\n                        for rook_sq in rooks:\n                            rf = chess.square_file(rook_sq); rr = chess.square_rank(rook_sq)\n                            if rf == f:\n                                if color == chess.WHITE and rr < chess.square_rank(sq):\n                                    behind_ok = True\n                                if color == chess.BLACK and rr > chess.square_rank(sq):\n                                    behind_ok = True\n                        if behind_ok:\n                            score += 0.9 * (0.5 + adv)\n                        else:\n                            score += 0.2 * (0.5 + adv)\n            return score\n        return float(side_score(chess.WHITE) - side_score(chess.BLACK))\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Space/control advantage in opponent half: (white_control - black_control) normalized by 32; counts distinct squares attacked in opponent half'\n    try:\n        pm = board.piece_map()\n        def controlled_squares(color):\n            attacked = set()\n            # opponent half: for white ranks 4..7, for black ranks 0..3\n            ranks = range(4,8) if color==chess.WHITE else range(0,4)\n            for r in ranks:\n                for f in range(8):\n                    sq = chess.square(f, r)\n                    if any(pm.get(a) for a in board.attackers(color, sq)):\n                        attacked.add(sq)\n            return len(attacked)\n        w = controlled_squares(chess.WHITE)\n        b = controlled_squares(chess.BLACK)\n        # normalize by maximum half squares (32)\n        return float((w - b) / 32.0)\n    except Exception:\n        return 0.0\n",
    "def feature(board: chess.Board) -> float:\n    'Pawn-structure weakness imbalance: (isolated + doubled*0.8 + backward*1.2) (white - black)'\n    try:\n        pm = board.piece_map()\n        pawn_files = {chess.WHITE: {f: 0 for f in range(8)}, chess.BLACK: {f: 0 for f in range(8)}}\n        pawns_by_color = {chess.WHITE: [], chess.BLACK: []}\n        for sq, p in pm.items():\n            if p and p.piece_type == chess.PAWN:\n                f = chess.square_file(sq)\n                pawn_files[p.color][f] += 1\n                pawns_by_color[p.color].append(sq)\n        def pawn_weakness(color):\n            iso = 0.0; doubled = 0.0; back = 0.0\n            for sq in pawns_by_color[color]:\n                f = chess.square_file(sq); r = chess.square_rank(sq)\n                # isolated: no friendly pawn on adjacent files\n                if pawn_files[color].get(f-1,0) == 0 and pawn_files[color].get(f+1,0) == 0:\n                    iso += 1.0\n                # doubled: if more than one pawn on file, count extras\n                if pawn_files[color].get(f,0) > 1:\n                    # each pawn on a doubled file contributes fractional doubled count (avoid overcounting by counting extras once)\n                    # approximate contribution per pawn = (count-1)/count\n                    cnt = pawn_files[color][f]\n                    doubled += float(cnt - 1) / float(cnt)\n                # backward pawn heuristic: no friendly pawn on adjacent files that is more advanced (for white higher rank, for black lower rank),\n                # and there is a blocking enemy pawn directly in front (approx)\n                adv_exists = False\n                for af in (f-1, f+1):\n                    if 0 <= af <= 7:\n                        for sq2, p2 in pm.items():\n                            if p2 and p2.piece_type == chess.PAWN and p2.color == color and chess.square_file(sq2) == af:\n                                if (color == chess.WHITE and chess.square_rank(sq2) > r) or (color == chess.BLACK and chess.square_rank(sq2) < r):\n                                    adv_exists = True\n                                    break\n                        if adv_exists:\n                            break\n                front_sq = None\n                if color == chess.WHITE and r < 7:\n                    front_sq = chess.square(f, r+1)\n                if color == chess.BLACK and r > 0:\n                    front_sq = chess.square(f, r-1)\n                blocked = False\n                if front_sq is not None:\n                    pfront = pm.get(front_sq)\n                    if pfront and pfront.color != color:\n                        blocked = True\n                if not adv_exists and blocked:\n                    back += 1.0\n            # weights\n            return iso * 0.9 + doubled * 0.6 + back * 1.2\n        return float(pawn_weakness(chess.WHITE) - pawn_weakness(chess.BLACK))\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Undefended high-value targets: sum of values of pieces attacked and undefended (white - black)'\n    try:\n        vals = {chess.PAWN:1.0, chess.KNIGHT:3.0, chess.BISHOP:3.0, chess.ROOK:5.0, chess.QUEEN:9.0, chess.KING:0.0}\n        pm = board.piece_map()\n        def undefended_attacked_value(color):\n            total = 0.0\n            opp = chess.WHITE if color == chess.BLACK else chess.BLACK\n            for sq, p in pm.items():\n                if not p or p.color != color:\n                    continue\n                attackers = board.attackers(opp, sq)\n                if not attackers:\n                    continue\n                defenders = board.attackers(color, sq)\n                # undefended if no defenders (or king only defending? treat king as defender as well)\n                if len(defenders) == 0:\n                    total += vals.get(p.piece_type, 0.0)\n            return total\n        return float(undefended_attacked_value(chess.WHITE) - undefended_attacked_value(chess.BLACK))\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Rook file control: weighted count of rooks on open files (1.0) or semi-open files (0.6) (white - black)'\n    try:\n        pm = board.piece_map()\n        def rook_file_score(color):\n            score = 0.0\n            for sq, p in pm.items():\n                if not p or p.piece_type != chess.ROOK or p.color != color:\n                    continue\n                f = chess.square_file(sq)\n                pawns_on_file = 0\n                friendly_pawns = 0\n                for sq2, p2 in pm.items():\n                    if p2 and p2.piece_type == chess.PAWN and chess.square_file(sq2) == f:\n                        pawns_on_file += 1\n                        if p2.color == color:\n                            friendly_pawns += 1\n                if pawns_on_file == 0:\n                    score += 1.0\n                elif friendly_pawns == 0 and pawns_on_file > 0:\n                    score += 0.6\n            return score\n        return float(rook_file_score(chess.WHITE) - rook_file_score(chess.BLACK))\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Knight outpost score: number of knights on supported squares not attackable by enemy pawns (weighted) (white - black)'\n    try:\n        pm = board.piece_map()\n        def pawn_attacks_square(sq, pawn_color):\n            # check if any pawn of pawn_color attacks sq\n            attackers = board.attackers(pawn_color, sq)\n            for a in attackers:\n                pa = pm.get(a)\n                if pa and pa.piece_type == chess.PAWN:\n                    return True\n            return False\n        def outpost_score(color):\n            score = 0.0\n            opp = chess.WHITE if color == chess.BLACK else chess.BLACK\n            for sq, p in pm.items():\n                if not p or p.piece_type != chess.KNIGHT or p.color != color:\n                    continue\n                r = chess.square_rank(sq)\n                # outpost rank threshold: white knights on 5th rank or further (rank >=4), black knights on 4th or less (rank <=3)\n                if (color == chess.WHITE and r < 4) or (color == chess.BLACK and r > 3):\n                    continue\n                # not attackable by enemy pawns\n                if pawn_attacks_square(sq, opp):\n                    continue\n                # supported by any friendly unit (pawn or piece)\n                defenders = board.attackers(color, sq)\n                if len(defenders) == 0:\n                    continue\n                score += 2.5\n            return score\n        return float(outpost_score(chess.WHITE) - outpost_score(chess.BLACK))\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Space control imbalance: difference in count of squares attacked in opponent half (normalized)'\n    try:\n        w_attacks = 0; b_attacks = 0\n        # white controls ranks 4..7 (r >= 4), black controls ranks 0..3 (r <= 3)\n        for sq in chess.SQUARES:\n            r = chess.square_rank(sq)\n            if r >= 4:\n                if board.is_attacked_by(chess.WHITE, sq):\n                    w_attacks += 1\n            if r <= 3:\n                if board.is_attacked_by(chess.BLACK, sq):\n                    b_attacks += 1\n        denom = max(1.0, 32.0)\n        return float((w_attacks - b_attacks) / denom)\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Pawn-storm proximity to enemy king: sum of advanced nearby pawns (white - black) (weights advanced pawns more)'\n    try:\n        pm = board.piece_map()\n        def storm_score(attacker_color):\n            defender = chess.WHITE if attacker_color == chess.BLACK else chess.BLACK\n            king_sq = next((sq for sq, p in pm.items() if p and p.piece_type == chess.KING and p.color == defender), None)\n            if king_sq is None:\n                return 0.0\n            score = 0.0\n            for sq, p in pm.items():\n                if not p or p.piece_type != chess.PAWN or p.color != attacker_color:\n                    continue\n                d = chess.square_distance(sq, king_sq)\n                if d <= 3:\n                    r = chess.square_rank(sq)\n                    adv = (r / 7.0) if attacker_color == chess.WHITE else ((7 - r) / 7.0)\n                    score += (0.6 + 1.4 * adv) * (1.0 / (1.0 + d))  # closer and more advanced weigh more\n            return score\n        return float(storm_score(chess.WHITE) - storm_score(chess.BLACK))\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Queen centralization and mobility: prefers queens near center with many reachable squares (white - black)'\n    try:\n        pm = board.piece_map()\n        center = [chess.parse_square(s) for s in ('d4','e4','d5','e5')]\n        directions = [(-1,0),(1,0),(0,-1),(0,1),(-1,-1),(-1,1),(1,-1),(1,1)]\n        def queen_attack_count(sq):\n            # count squares queen can move to (ray-based, stop on piece)\n            cnt = 0\n            f0 = chess.square_file(sq); r0 = chess.square_rank(sq)\n            for df, dr in directions:\n                f = f0 + df; r = r0 + dr\n                while 0 <= f <= 7 and 0 <= r <= 7:\n                    ss = chess.square(f, r)\n                    cnt += 1\n                    if board.piece_at(ss) is not None:\n                        break\n                    f += df; r += dr\n            return cnt\n        def best_queen_score(color):\n            best = 0.0\n            for sq, p in pm.items():\n                if p and p.piece_type == chess.QUEEN and p.color == color:\n                    d = min(chess.square_distance(sq, c) for c in center)\n                    attacks = queen_attack_count(sq)\n                    central_factor = 1.0 - (float(d) / 7.0)\n                    mobility_factor = 1.0 + (float(attacks) / 28.0)\n                    score = central_factor * mobility_factor\n                    if score > best:\n                        best = score\n            return best\n        return float(best_queen_score(chess.WHITE) - best_queen_score(chess.BLACK))\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Bad-bishop measure: counts bishops with very limited mobility (likely trapped by pawns) (white - black)'\n    try:\n        pm = board.piece_map()\n        directions = [(-1,-1),(-1,1),(1,-1),(1,1)]\n        def bishop_mobility(sq):\n            cnt = 0\n            f0 = chess.square_file(sq); r0 = chess.square_rank(sq)\n            for df, dr in directions:\n                f = f0 + df; r = r0 + dr\n                while 0 <= f <= 7 and 0 <= r <= 7:\n                    ss = chess.square(f, r)\n                    cnt += 1\n                    if board.piece_at(ss) is not None:\n                        break\n                    f += df; r += dr\n            return cnt\n        def bad_bishops_score(color):\n            score = 0.0\n            for sq, p in pm.items():\n                if p and p.piece_type == chess.BISHOP and p.color == color:\n                    mob = bishop_mobility(sq)\n                    if mob <= 6:\n                        score += 3.0  # penalize low-mobility bishops\n            return score\n        return float(bad_bishops_score(chess.WHITE) - bad_bishops_score(chess.BLACK))\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Rooks on the seventh: pressure on opponent pawns and seventh rank control (white - black)'\n    try:\n        pm = board.piece_map()\n        def seventh_score(color):\n            score = 0.0\n            opp = chess.WHITE if color == chess.BLACK else chess.BLACK\n            target_rank = 6 if color == chess.WHITE else 1\n            # count rooks on target_rank\n            for sq, p in pm.items():\n                if not p or p.piece_type != chess.ROOK or p.color != color:\n                    continue\n                if chess.square_rank(sq) == target_rank:\n                    score += 1.2\n                    # count opponent pawns on that rank attacked by this rook\n                    for f in range(8):\n                        sqp = chess.square(f, target_rank)\n                        p2 = pm.get(sqp)\n                        if p2 and p2.piece_type == chess.PAWN and p2.color == opp:\n                            attackers = board.attackers(color, sqp)\n                            if sq in attackers:\n                                score += 0.5\n            return score\n        return float(seventh_score(chess.WHITE) - seventh_score(chess.BLACK))\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Drawish endgame tendency: higher when position is likely drawish (no queens, few pieces/pawns) (white - black)'\n    try:\n        pm = board.piece_map()\n        def drawish_score(color):\n            npieces = 0\n            pawns = 0\n            queens = 0\n            for p in pm.values():\n                if not p: continue\n                if p.color != color: continue\n                if p.piece_type == chess.PAWN:\n                    pawns += 1\n                elif p.piece_type == chess.QUEEN:\n                    queens += 1\n                elif p.piece_type not in (chess.KING, chess.PAWN):\n                    npieces += 1\n            if queens == 0 and (npieces <= 1) and pawns <= 3:\n                return 1.0\n            # smooth scale: more pieces+pawns -> less drawish\n            rem = max(0.0, 5.0 - (npieces + pawns))\n            return rem / 5.0\n        return float(drawish_score(chess.WHITE) - drawish_score(chess.BLACK))\n    except Exception:\n        return 0.0\n",
    "def feature(board: chess.Board) -> float:\n    'Central-control imbalance: weighted control of the central nine squares (positive favors White)'\n    try:\n        pm = board.piece_map()\n        vals = {chess.PAWN:0.5, chess.KNIGHT:2.8, chess.BISHOP:3.0, chess.ROOK:4.5, chess.QUEEN:7.0, chess.KING:0.0}\n        center_sq_names = ['d4','e4','d5','e5','c4','f4','c5','f5','e4']  # central 3x3 (e4 duplicated harmless)\n        center_sqs = [chess.parse_square(n) for n in set(center_sq_names)]\n        score = {chess.WHITE:0.0, chess.BLACK:0.0}\n        for sq in center_sqs:\n            for color in (chess.WHITE, chess.BLACK):\n                attackers = board.attackers(color, sq)\n                # weight multiple attackers less than linear, but sum piece values\n                s = 0.0\n                for a in attackers:\n                    p = pm.get(a)\n                    if p:\n                        s += vals.get(p.piece_type, 0.0)\n                score[color] += s\n        return float(score[chess.WHITE] - score[chess.BLACK])\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Hanging-piece imbalance: value-weighted pieces that are attacked more than defended (positive = Black more hanging -> favors White)'\n    try:\n        pm = board.piece_map()\n        vals = {chess.PAWN:1.0, chess.KNIGHT:3.0, chess.BISHOP:3.0, chess.ROOK:5.0, chess.QUEEN:9.0, chess.KING:0.0}\n        hang = {chess.WHITE:0.0, chess.BLACK:0.0}\n        for sq, p in pm.items():\n            if not p: continue\n            attackers = board.attackers(not p.color, sq)\n            defenders = board.attackers(p.color, sq)\n            # count attackers and defenders (multiple attackers increase tactical risk)\n            a_cnt = len(attackers)\n            d_cnt = len(defenders)\n            if a_cnt > d_cnt:\n                # penalize proportionally to the surplus attackers and piece value\n                hang[p.color] += vals.get(p.piece_type, 0.0) * float(a_cnt - d_cnt)\n        # if Black pieces are more hanging, White is favored -> return (black_hang - white_hang)\n        return float(hang[chess.BLACK] - hang[chess.WHITE])\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Pawn-structure fragility: counts isolated, doubled and backward pawns weighted by severity (positive favors White)'\n    try:\n        pm = board.piece_map()\n        pawns_by_file = {f: {chess.WHITE:[], chess.BLACK:[]} for f in range(8)}\n        for sq,p in pm.items():\n            if p and p.piece_type == chess.PAWN:\n                pawns_by_file[chess.square_file(sq)][p.color].append(sq)\n        def frag_score(color):\n            sc = 0.0\n            for f in range(8):\n                files_adj = [f-1, f+1]\n                for sq in pawns_by_file[f][color]:\n                    r = chess.square_rank(sq)\n                    # isolated: no friendly pawns on adjacent files\n                    isolated = all(len(pawns_by_file[af][color])==0 for af in files_adj if 0<=af<8)\n                    if isolated:\n                        sc += 1.2\n                    # doubled: more than one pawn on this file (penalize per extra pawn)\n                    if len(pawns_by_file[f][color]) > 1:\n                        sc += 0.8 * (len(pawns_by_file[f][color]) - 1)\n                    # backward: no friendly pawn on adjacent files ahead (approx)\n                    ahead_exists = False\n                    if color == chess.WHITE:\n                        for af in files_adj:\n                            if 0<=af<8:\n                                for psq in pawns_by_file[af][color]:\n                                    if chess.square_rank(psq) > r:\n                                        ahead_exists = True; break\n                                if ahead_exists: break\n                    else:\n                        for af in files_adj:\n                            if 0<=af<8:\n                                for psq in pawns_by_file[af][color]:\n                                    if chess.square_rank(psq) < r:\n                                        ahead_exists = True; break\n                                if ahead_exists: break\n                    if not ahead_exists:\n                        # treat backward as milder than isolated but still relevant\n                        sc += 0.6\n            return sc\n        return float(frag_score(chess.WHITE) - frag_score(chess.BLACK))\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Rook penetration and 7th-rank pressure: counts rooks on opponent 7th rank, connected rooks and open-file occupation (white - black)'\n    try:\n        pm = board.piece_map()\n        score = {chess.WHITE:0.0, chess.BLACK:0.0}\n        for sq,p in pm.items():\n            if not p or p.piece_type != chess.ROOK: continue\n            f = chess.square_file(sq); r = chess.square_rank(sq)\n            # rook on opponent 7th rank\n            if p.color == chess.WHITE and r == 6:\n                score[p.color] += 2.2\n            if p.color == chess.BLACK and r == 1:\n                score[p.color] += 2.2\n            # connected rooks: another rook on same rank or file with no pieces between\n            for sq2, p2 in pm.items():\n                if sq2 == sq or not p2 or p2.piece_type != chess.ROOK or p2.color != p.color:\n                    continue\n                f2 = chess.square_file(sq2); r2 = chess.square_rank(sq2)\n                if f == f2:\n                    step = 8 if r2>r else -8\n                    clear = True\n                    for inter in range(sq+step, sq2, step):\n                        if pm.get(inter):\n                            clear = False; break\n                    if clear:\n                        score[p.color] += 1.5\n                if r == r2:\n                    step = 1 if f2>f else -1\n                    clear = True\n                    for interf in range(f+step, f2, step):\n                        intersq = chess.square(interf, r)\n                        if pm.get(intersq):\n                            clear = False; break\n                    if clear:\n                        score[p.color] += 1.5\n            # rooks on open file (no pawns any color on file) get extra\n            file_pawns = any((pp and pp.piece_type==chess.PAWN) for sqq,pp in pm.items() if chess.square_file(sqq)==f)\n            if not file_pawns:\n                score[p.color] += 0.9\n        return float(score[chess.WHITE] - score[chess.BLACK])\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Outpost knight advantage: knights on advanced outpost squares protected by pawns or unassailable by enemy pawns (white - black)'\n    try:\n        pm = board.piece_map()\n        def knight_outpost_score(color):\n            sc = 0.0\n            for sq,p in pm.items():\n                if not p or p.piece_type != chess.KNIGHT or p.color != color: continue\n                f = chess.square_file(sq); r = chess.square_rank(sq)\n                # advanced threshold\n                advanced = (r >= 4) if color==chess.WHITE else (r <= 3)\n                if not advanced: continue\n                # check if enemy pawns can attack this square (from behind)\n                enemy = not color\n                pawn_threat = False\n                if color == chess.WHITE:\n                    for af in (f-1, f+1):\n                        if 0<=af<8:\n                            attacker_sq = chess.square(af, r-1)\n                            p2 = pm.get(attacker_sq)\n                            if p2 and p2.piece_type==chess.PAWN and p2.color==enemy:\n                                pawn_threat = True; break\n                else:\n                    for af in (f-1, f+1):\n                        if 0<=af<8:\n                            attacker_sq = chess.square(af, r+1)\n                            p2 = pm.get(attacker_sq)\n                            if p2 and p2.piece_type==chess.PAWN and p2.color==enemy:\n                                pawn_threat = True; break\n                # check if pawn defends the knight\n                pawn_defended = False\n                if color == chess.WHITE:\n                    for af in (f-1, f+1):\n                        if 0<=af<8:\n                            defender_sq = chess.square(af, r-1)\n                            p2 = pm.get(defender_sq)\n                            if p2 and p2.piece_type==chess.PAWN and p2.color==color:\n                                pawn_defended = True; break\n                else:\n                    for af in (f-1, f+1):\n                        if 0<=af<8:\n                            defender_sq = chess.square(af, r+1)\n                            p2 = pm.get(defender_sq)\n                            if p2 and p2.piece_type==chess.PAWN and p2.color==color:\n                                pawn_defended = True; break\n                if pawn_defended and not pawn_threat:\n                    sc += 2.0\n                elif not pawn_threat:\n                    sc += 1.0\n                elif pawn_defended and pawn_threat:\n                    sc += 0.6\n            return sc\n        return float(knight_outpost_score(chess.WHITE) - knight_outpost_score(chess.BLACK))\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Bishop mobility index: sum of squares reachable along diagonals until blocked (positive favors White)'\n    try:\n        pm = board.piece_map()\n        def bishop_mob(color):\n            total = 0.0\n            for sq,p in pm.items():\n                if not p or p.piece_type != chess.BISHOP or p.color != color: continue\n                f = chess.square_file(sq); r = chess.square_rank(sq)\n                # four diagonal directions\n                dirs = [(1,1),(1,-1),(-1,1),(-1,-1)]\n                for df, dr in dirs:\n                    ff = f + df; rr = r + dr\n                    steps = 0\n                    while 0<=ff<8 and 0<=rr<8:\n                        steps += 1\n                        sq2 = chess.square(ff, rr)\n                        if pm.get(sq2) is not None:\n                            # if occupied by own piece, mobility stops; if opponent, it can capture but not go further\n                            total += 0.8  # capture potential counts but less than empty squares\n                            break\n                        else:\n                            total += 1.0\n                        ff += df; rr += dr\n            return total\n        return float(bishop_mob(chess.WHITE) - bishop_mob(chess.BLACK))\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Space advantage in opponent half: number of squares in opponent half attacked by each side (normalized, white - black)'\n    try:\n        pm = board.piece_map()\n        # define halves: for White, opponent half is ranks 4..7 (indices 4-7); for Black, ranks 0..3\n        def control_half(color):\n            target_ranks = range(4,8) if color==chess.WHITE else range(0,4)\n            cnt = 0\n            seen = set()\n            for r in target_ranks:\n                for f in range(8):\n                    sq = chess.square(f, r)\n                    if sq in seen:\n                        continue\n                    if board.is_attacked_by(color, sq):\n                        cnt += 1\n                        seen.add(sq)\n            # normalize by half size (32)\n            return float(cnt) / 32.0\n        return float(control_half(chess.WHITE) - control_half(chess.BLACK))\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'King centrality in reduced-material endgames: prefers more central king when material is low (positive favors White)'\n    try:\n        pm = board.piece_map()\n        vals = {chess.PAWN:1.0, chess.KNIGHT:3.0, chess.BISHOP:3.0, chess.ROOK:5.0, chess.QUEEN:9.0}\n        material = 0.0\n        for p in pm.values():\n            if p and p.piece_type in vals:\n                material += vals[p.piece_type]\n        # apply only when material is low-ish (endgame threshold)\n        endgame_factor = 1.0 if material <= 14.0 else 0.0\n        if endgame_factor == 0.0:\n            return 0.0\n        wk = next((sq for sq,p in pm.items() if p and p.piece_type==chess.KING and p.color==chess.WHITE), None)\n        bk = next((sq for sq,p in pm.items() if p and p.piece_type==chess.KING and p.color==chess.BLACK), None)\n        if wk is None or bk is None:\n            return 0.0\n        # center is between d4,e4,d5,e5 roughly (files 3-4, ranks 3-4)\n        def centrality(sq):\n            f = chess.square_file(sq); r = chess.square_rank(sq)\n            # Manhattan distance to center squares averaged\n            center_dists = [abs(f-3.5) + abs(r-3.5)]\n            d = center_dists[0]\n            # convert to centrality [0..1], closer = larger\n            return max(0.0, (7.0 - d) / 7.0)\n        wc = centrality(wk); bc = centrality(bk)\n        return float(endgame_factor * (wc - bc))\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Piece connectivity / protection score: sum of own pieces that are defended weighted by piece value (white - black)'\n    try:\n        pm = board.piece_map()\n        vals = {chess.PAWN:1.0, chess.KNIGHT:3.0, chess.BISHOP:3.0, chess.ROOK:5.0, chess.QUEEN:9.0, chess.KING:0.0}\n        protect = {chess.WHITE:0.0, chess.BLACK:0.0}\n        for sq,p in pm.items():\n            if not p: continue\n            defenders = board.attackers(p.color, sq)\n            if len(defenders) > 0:\n                # weight more if multiple defenders (stability)\n                protect[p.color] += vals.get(p.piece_type,0.0) * min(1.5, 0.7 + 0.3*len(defenders))\n        return float(protect[chess.WHITE] - protect[chess.BLACK])\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Safe pawn-advance potential: count of pawns that can push one square (or capture) into a square not attacked by opponent (white - black)'\n    try:\n        pm = board.piece_map()\n        def pawn_potential(color):\n            sc = 0.0\n            enemy = not color\n            for sq,p in pm.items():\n                if not p or p.piece_type != chess.PAWN or p.color != color: continue\n                f = chess.square_file(sq); r = chess.square_rank(sq)\n                # forward push\n                if color == chess.WHITE:\n                    if r < 7:\n                        forward = chess.square(f, r+1)\n                        if pm.get(forward) is None and not board.is_attacked_by(enemy, forward):\n                            sc += 1.0\n                    # captures\n                    for af in (f-1, f+1):\n                        if 0<=af<8 and r<7:\n                            target = chess.square(af, r+1)\n                            if pm.get(target) and pm.get(target).color==enemy and not board.is_attacked_by(enemy, target):\n                                sc += 0.9\n                else:\n                    if r > 0:\n                        forward = chess.square(f, r-1)\n                        if pm.get(forward) is None and not board.is_attacked_by(enemy, forward):\n                            sc += 1.0\n                    for af in (f-1, f+1):\n                        if 0<=af<8 and r>0:\n                            target = chess.square(af, r-1)\n                            if pm.get(target) and pm.get(target).color==enemy and not board.is_attacked_by(enemy, target):\n                                sc += 0.9\n            return sc\n        return float(pawn_potential(chess.WHITE) - pawn_potential(chess.BLACK))\n    except Exception:\n        return 0.0\n",
    "def feature(board: chess.Board) -> float:\n    'Passed pawn potential weighted by advancement (positive favors White)'\n    try:\n        pm = board.piece_map()\n        def is_passed(sq, color):\n            f = chess.square_file(sq); r = chess.square_rank(sq)\n            if color == chess.WHITE:\n                # no enemy pawn on same file or adjacent files ahead (higher rank)\n                for ff in range(max(0, f-1), min(7, f+1)+1):\n                    for rr in range(r+1, 8):\n                        sq2 = chess.square(ff, rr)\n                        p = pm.get(sq2)\n                        if p and p.piece_type == chess.PAWN and p.color == chess.BLACK:\n                            return False\n                return True\n            else:\n                for ff in range(max(0, f-1), min(7, f+1)+1):\n                    for rr in range(0, r):\n                        sq2 = chess.square(ff, rr)\n                        p = pm.get(sq2)\n                        if p and p.piece_type == chess.PAWN and p.color == chess.WHITE:\n                            return False\n                return True\n        score = {chess.WHITE:0.0, chess.BLACK:0.0}\n        for sq,p in pm.items():\n            if not p or p.piece_type != chess.PAWN: continue\n            if is_passed(sq, p.color):\n                r = chess.square_rank(sq)\n                # advancement progress [0..1]\n                progress = (r / 7.0) if p.color == chess.WHITE else ((7 - r) / 7.0)\n                # weight: base + progress emphasis\n                weight = 1.0 + 3.0 * progress\n                score[p.color] += weight\n        return float(score[chess.WHITE] - score[chess.BLACK])\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Pawn structure weakness: weighted count of doubled, isolated and backward pawns (positive favors White)'\n    try:\n        pm = board.piece_map()\n        files_count = {chess.WHITE:[0]*8, chess.BLACK:[0]*8, 'total':[0]*8}\n        for sq,p in pm.items():\n            if not p or p.piece_type != chess.PAWN: continue\n            f = chess.square_file(sq)\n            files_count[p.color][f] += 1\n            files_count['total'][f] += 1\n        weakness = {chess.WHITE:0.0, chess.BLACK:0.0}\n        for sq,p in pm.items():\n            if not p or p.piece_type != chess.PAWN: continue\n            f = chess.square_file(sq); r = chess.square_rank(sq)\n            col = p.color\n            # doubled\n            if files_count[col][f] > 1:\n                weakness[col] += 1.0\n            # isolated: no friendly pawns on adjacent files\n            left = files_count[col][f-1] if f-1 >= 0 else 0\n            right = files_count[col][f+1] if f+1 <= 7 else 0\n            if left + right == 0:\n                weakness[col] += 1.2\n            # approximate backward: no friendly pawn on adjacent files behind it AND opponent pawn ahead blocks potential advance\n            adj_behind = False\n            if col == chess.WHITE:\n                for ff in (f-1, f+1):\n                    if 0 <= ff <= 7:\n                        for rr in range(0, r):\n                            sq2 = chess.square(ff, rr)\n                            p2 = pm.get(sq2)\n                            if p2 and p2.piece_type == chess.PAWN and p2.color == col:\n                                adj_behind = True; break\n                        if adj_behind: break\n                # opponent pawn ahead on same or adj file\n                opp_block = False\n                for ff in range(max(0,f-1), min(7,f+1)+1):\n                    for rr in range(r+1, 8):\n                        p2 = pm.get(chess.square(ff, rr))\n                        if p2 and p2.piece_type == chess.PAWN and p2.color != col:\n                            opp_block = True; break\n                    if opp_block: break\n                if not adj_behind and opp_block:\n                    weakness[col] += 1.5\n            else:\n                for ff in (f-1, f+1):\n                    if 0 <= ff <= 7:\n                        for rr in range(r+1, 8):\n                            sq2 = chess.square(ff, rr)\n                            p2 = pm.get(sq2)\n                            if p2 and p2.piece_type == chess.PAWN and p2.color == col:\n                                adj_behind = True; break\n                        if adj_behind: break\n                opp_block = False\n                for ff in range(max(0,f-1), min(7,f+1)+1):\n                    for rr in range(0, r):\n                        p2 = pm.get(chess.square(ff, rr))\n                        if p2 and p2.piece_type == chess.PAWN and p2.color != col:\n                            opp_block = True; break\n                    if opp_block: break\n                if not adj_behind and opp_block:\n                    weakness[col] += 1.5\n        # return black weakness minus white weakness so positive favors White (less black weaknesses)\n        return float(weakness[chess.BLACK] - weakness[chess.WHITE])\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Space/control in opponent half: normalized count of squares controlled in enemy territory (white - black)'\n    try:\n        controlled = {chess.WHITE:0, chess.BLACK:0}\n        # Define halves: White controls Black half ranks 4..7 (ranks indexed 4-7), Black controls White half 0..3\n        for sq in range(64):\n            r = chess.square_rank(sq)\n            if r >= 4:\n                if board.is_attacked_by(chess.WHITE, sq):\n                    controlled[chess.WHITE] += 1\n            if r <= 3:\n                if board.is_attacked_by(chess.BLACK, sq):\n                    controlled[chess.BLACK] += 1\n        # normalize by halfboard (32)\n        return float((controlled[chess.WHITE] - controlled[chess.BLACK]) / 32.0)\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Piece coordination: joint-attack and mutual-defense score (positive favors White coordination)'\n    try:\n        pm = board.piece_map()\n        def coordination(color):\n            coord = 0.0\n            # joint attacks: for each square count combinations of same-color attackers\n            for sq in range(64):\n                attackers = board.attackers(color, sq)\n                n = len([a for a in attackers if pm.get(a) and pm[a].color == color])\n                if n >= 2:\n                    coord += 0.6 * (n * (n-1) / 2.0)\n            # mutual defense: for each piece if it defends another friendly piece\n            for sq_a, pa in pm.items():\n                if not pa or pa.color != color: continue\n                for sq_b, pb in pm.items():\n                    if not pb or pb.color != color or sq_a == sq_b: continue\n                    # if a attacks b then it's a defender\n                    if sq_a in board.attackers(color, sq_b):\n                        coord += 0.25\n            return coord\n        return float(coordination(chess.WHITE) - coordination(chess.BLACK))\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Trapped immobile pieces: favor positions where opponent has more stuck non-pawn pieces (positive favors White)'\n    try:\n        pm = board.piece_map()\n        orig = board.turn\n        try:\n            movable = {chess.WHITE:set(), chess.BLACK:set()}\n            for color in (chess.WHITE, chess.BLACK):\n                board.turn = color\n                for mv in board.legal_moves:\n                    movable[color].add(mv.from_square)\n        finally:\n            board.turn = orig\n        trapped = {chess.WHITE:0.0, chess.BLACK:0.0}\n        for sq,p in pm.items():\n            if not p or p.piece_type in (chess.PAWN, chess.KING): continue\n            if sq not in movable[p.color]:\n                # piece has no legal moves (or pinned/stuck)\n                trapped[p.color] += 1.0\n        # more trapped white pieces is bad for White, so return black_trapped - white_trapped\n        return float(trapped[chess.BLACK] - trapped[chess.WHITE])\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'King exposure via adjacent-file openness and enemy heavy presence (positive favors White)'\n    try:\n        pm = board.piece_map()\n        # pawn file occupancy\n        files_total = [0]*8\n        files_white = [0]*8\n        files_black = [0]*8\n        for sq,p in pm.items():\n            if not p: continue\n            f = chess.square_file(sq)\n            if p.piece_type == chess.PAWN:\n                files_total[f] += 1\n                if p.color == chess.WHITE: files_white[f] += 1\n                else: files_black[f] += 1\n        def exposure(color):\n            # exposure of this color's king (how vulnerable it is)\n            king_sq = next((s for s,p in pm.items() if p and p.piece_type == chess.KING and p.color == color), None)\n            if king_sq is None:\n                return 0.0\n            kf = chess.square_file(king_sq)\n            exp = 0.0\n            opp = chess.BLACK if color == chess.WHITE else chess.WHITE\n            for ff in range(max(0, kf-1), min(7, kf+1)+1):\n                # open file amplifies exposure\n                if files_total[ff] == 0:\n                    exp += 1.2\n                else:\n                    # semi-open when no friendly pawns but opponent pawns exist\n                    if color == chess.WHITE and files_white[ff] == 0 and files_black[ff] > 0:\n                        exp += 0.8\n                    if color == chess.BLACK and files_black[ff] == 0 and files_white[ff] > 0:\n                        exp += 0.8\n                # heavy enemy piece on that file increases exposure\n                for sq2,p2 in pm.items():\n                    if not p2 or p2.color != opp: continue\n                    if p2.piece_type in (chess.ROOK, chess.QUEEN):\n                        if chess.square_file(sq2) == ff:\n                            exp += 1.1\n            return exp\n        exp_w = exposure(chess.WHITE); exp_b = exposure(chess.BLACK)\n        # less exposure for White is good: return black_exp - white_exp\n        return float(exp_b - exp_w)\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Bishop pair and diagonal mobility: bonus for two bishops and open diagonal reach (white - black)'\n    try:\n        pm = board.piece_map()\n        def bishop_mobility(sq):\n            # approximate by counting unobstructed diagonal squares\n            mob = 0\n            f = chess.square_file(sq); r = chess.square_rank(sq)\n            for df, dr in ((1,1),(1,-1),(-1,1),(-1,-1)):\n                ff, rr = f+df, r+dr\n                while 0 <= ff < 8 and 0 <= rr < 8:\n                    mob += 1\n                    if pm.get(chess.square(ff, rr)) is not None:\n                        break\n                    ff += df; rr += dr\n            return mob\n        score = {chess.WHITE:0.0, chess.BLACK:0.0}\n        for sq,p in pm.items():\n            if not p or p.piece_type != chess.BISHOP: continue\n            score[p.color] += 0.25 * bishop_mobility(sq)\n        # bishop pair bonus\n        for color in (chess.WHITE, chess.BLACK):\n            cnt = sum(1 for p in pm.values() if p and p.piece_type == chess.BISHOP and p.color == color)\n            if cnt >= 2:\n                score[color] += 1.6\n        return float(score[chess.WHITE] - score[chess.BLACK])\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Undefended high-value targets: sum of attacked but undefended pieces (queen/rook/knight/bishop), (positive favors White)'\n    try:\n        pm = board.piece_map()\n        vals = {chess.KNIGHT:3.0, chess.BISHOP:3.0, chess.ROOK:5.0, chess.QUEEN:9.0}\n        undef = {chess.WHITE:0.0, chess.BLACK:0.0}\n        for sq,p in pm.items():\n            if not p or p.piece_type not in vals: continue\n            attackers = board.attackers(not p.color, sq)\n            defenders = board.attackers(p.color, sq)\n            if len(attackers) > 0 and len(defenders) == 0:\n                undef[p.color] += vals[p.piece_type]\n        # if Black has more undefended value, White benefits -> return black_undef - white_undef\n        return float(undef[chess.BLACK] - undef[chess.WHITE])\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Tactical opportunities: difference in number of capture-or-check legal moves (white - black) normalized'\n    try:\n        orig = board.turn\n        try:\n            c_or_check = {chess.WHITE:0.0, chess.BLACK:0.0}\n            for color in (chess.WHITE, chess.BLACK):\n                board.turn = color\n                for mv in board.legal_moves:\n                    # capture\n                    if board.is_capture(mv):\n                        c_or_check[color] += 1.0\n                    else:\n                        # detect if move gives check: make move on a copy to test\n                        # avoid modifying original board: use push/pop\n                        board.push(mv)\n                        if board.is_check():\n                            c_or_check[color] += 1.0\n                        board.pop()\n            total = max(1.0, c_or_check[chess.WHITE] + c_or_check[chess.BLACK])\n            return float((c_or_check[chess.WHITE] - c_or_check[chess.BLACK]) / total)\n        finally:\n            board.turn = orig\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Passed-pawn king-race metric: sum over passed pawns of (enemy king distance - pawn steps) (positive favors White)'\n    try:\n        pm = board.piece_map()\n        # find kings\n        wk = next((sq for sq,p in pm.items() if p and p.piece_type == chess.KING and p.color == chess.WHITE), None)\n        bk = next((sq for sq,p in pm.items() if p and p.piece_type == chess.KING and p.color == chess.BLACK), None)\n        if wk is None or bk is None:\n            return 0.0\n        def is_passed(sq, color):\n            f = chess.square_file(sq); r = chess.square_rank(sq)\n            if color == chess.WHITE:\n                for ff in range(max(0,f-1), min(7,f+1)+1):\n                    for rr in range(r+1, 8):\n                        p = pm.get(chess.square(ff, rr))\n                        if p and p.piece_type == chess.PAWN and p.color == chess.BLACK:\n                            return False\n                return True\n            else:\n                for ff in range(max(0,f-1), min(7,f+1)+1):\n                    for rr in range(0, r):\n                        p = pm.get(chess.square(ff, rr))\n                        if p and p.piece_type == chess.PAWN and p.color == chess.WHITE:\n                            return False\n                return True\n        score = {chess.WHITE:0.0, chess.BLACK:0.0}\n        for sq,p in pm.items():\n            if not p or p.piece_type != chess.PAWN: continue\n            if not is_passed(sq, p.color): continue\n            f = chess.square_file(sq); r = chess.square_rank(sq)\n            if p.color == chess.WHITE:\n                steps = 7 - r\n                promotion_sq = chess.square(f, 7)\n                enemy_king_dist = chess.square_distance(bk, promotion_sq)\n                own_king_dist = chess.square_distance(wk, promotion_sq)\n                # positive if enemy king is farther relative to pawn steps (pawn likely to promote)\n                score[p.color] += max(0.0, (enemy_king_dist - steps) * 0.6) + max(0.0, (own_king_dist - steps) * 0.2)\n            else:\n                steps = r\n                promotion_sq = chess.square(f, 0)\n                enemy_king_dist = chess.square_distance(wk, promotion_sq)\n                own_king_dist = chess.square_distance(bk, promotion_sq)\n                score[p.color] += max(0.0, (enemy_king_dist - steps) * 0.6) + max(0.0, (own_king_dist - steps) * 0.2)\n        return float(score[chess.WHITE] - score[chess.BLACK])\n    except Exception:\n        return 0.0\n",
    "def feature(board: chess.Board) -> float:\n    'Passed pawn potential differential: advanced passed pawns weighted by closeness to promotion (positive favors White)'\n    try:\n        pm = board.piece_map()\n        def is_passed(sq, color):\n            f = chess.square_file(sq); r = chess.square_rank(sq)\n            opp = chess.BLACK if color == chess.WHITE else chess.WHITE\n            # for white, passed if no opposing pawns on same or adjacent files with rank > r\n            for df in (-1, 0, 1):\n                ff = f + df\n                if not (0 <= ff < 8):\n                    continue\n                for rr in range(r + (1 if color == chess.WHITE else -1), 8 if color == chess.WHITE else -1, 1 if color == chess.WHITE else -1):\n                    sq2 = chess.square(ff, rr)\n                    p2 = pm.get(sq2)\n                    if p2 and p2.piece_type == chess.PAWN and p2.color == opp:\n                        return False\n            return True\n        def passed_score(color):\n            s = 0.0\n            for sq,p in pm.items():\n                if not p or p.piece_type != chess.PAWN or p.color != color:\n                    continue\n                if is_passed(sq, color):\n                    r = chess.square_rank(sq)\n                    adv = r if color == chess.WHITE else (7 - r)\n                    # weight: more advanced pawns matter more; quadratic emphasis\n                    s += (1.0 + (adv / 7.0) ** 2 * 7.0)\n            return s\n        return float(passed_score(chess.WHITE) - passed_score(chess.BLACK))\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Bishop mobility and diagonal openness: sum of reachable diagonal squares and bishop-pair bonus (white - black)'\n    try:\n        pm = board.piece_map()\n        def bishop_score(color):\n            score = 0.0\n            for sq,p in pm.items():\n                if not p or p.color != color or p.piece_type != chess.BISHOP:\n                    continue\n                f = chess.square_file(sq); r = chess.square_rank(sq)\n                # explore four diagonal directions\n                for df, dr in ((1,1),(1,-1),(-1,1),(-1,-1)):\n                    ff, rr = f + df, r + dr\n                    steps = 0\n                    while 0 <= ff < 8 and 0 <= rr < 8:\n                        steps += 1\n                        sq2 = chess.square(ff, rr)\n                        if pm.get(sq2) is not None:\n                            break\n                        ff += df; rr += dr\n                    score += 0.25 * steps\n            # bishop-pair bonus\n            bishops = sum(1 for p in pm.values() if p and p.color == color and p.piece_type == chess.BISHOP)\n            if bishops >= 2:\n                score += 1.5\n            return score\n        return float(bishop_score(chess.WHITE) - bishop_score(chess.BLACK))\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Pawn-structure weakness index: counts isolated, doubled, and backward pawns (positive = Black worse -> good for White)'\n    try:\n        pm = board.piece_map()\n        def weaknesses(color):\n            weak = 0.0\n            # file map of pawn counts and pawn ranks\n            pawns_on_file = {f: [] for f in range(8)}\n            for sq,p in pm.items():\n                if p and p.piece_type == chess.PAWN and p.color == color:\n                    pawns_on_file[chess.square_file(sq)].append(chess.square_rank(sq))\n            for f, ranks in pawns_on_file.items():\n                if not ranks:\n                    continue\n                # doubled pawns penalty for extra pawns on file\n                if len(ranks) > 1:\n                    weak += 0.6 * (len(ranks) - 1)\n                for r in ranks:\n                    # isolated if no friendly pawns on adjacent files\n                    has_adj = False\n                    for af in (f-1, f+1):\n                        if 0 <= af < 8 and pawns_on_file.get(af):\n                            has_adj = True; break\n                    if not has_adj:\n                        weak += 0.9\n                    # backward pawn: no friendly pawn behind on adjacent files and cannot advance safely (approx)\n                    behind_exists = False\n                    for af in (f-1, f+1):\n                        if 0 <= af < 8:\n                            for br in pawns_on_file.get(af, []):\n                                if (color == chess.WHITE and br < r) or (color == chess.BLACK and br > r):\n                                    behind_exists = True\n                                    break\n                            if behind_exists: break\n                    if not behind_exists:\n                        weak += 0.45\n            return weak\n        w_weak = weaknesses(chess.WHITE)\n        b_weak = weaknesses(chess.BLACK)\n        # positive when Black has more weaknesses (good for White)\n        return float(b_weak - w_weak)\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Central control index: control and occupation of d4,e4,d5,e5 weighted by attacks and occupation (white - black)'\n    try:\n        centers = [chess.parse_square(s) for s in ('d4','e4','d5','e5')]\n        pm = board.piece_map()\n        def ctrl(color):\n            s = 0.0\n            for sq in centers:\n                # occupancy bonus\n                p = pm.get(sq)\n                if p and p.color == color:\n                    s += 1.3\n                # attack bonus\n                attackers = len(board.attackers(color, sq))\n                s += 0.5 * attackers\n            return s\n        return float(ctrl(chess.WHITE) - ctrl(chess.BLACK))\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Space advantage: number of squares in opponent half attacked or occupied (normalized, positive favors White)'\n    try:\n        pm = board.piece_map()\n        def space_score(color):\n            score = 0.0\n            # opponent half: for White ranks 4-7 (r >= 4), for Black ranks 0-3 (r <= 3)\n            ranks = range(4,8) if color == chess.WHITE else range(0,4)\n            for r in ranks:\n                for f in range(8):\n                    sq = chess.square(f, r)\n                    # occupancy by own piece counts strongly\n                    p = pm.get(sq)\n                    if p and p.color == color:\n                        score += 1.0\n                        continue\n                    # attacked by color\n                    if board.is_attacked_by(color, sq):\n                        score += 0.45\n            # normalize by half-board squares (32)\n            return score / 32.0\n        return float(space_score(chess.WHITE) - space_score(chess.BLACK))\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Pinned pieces imbalance: counts pieces pinned to the king by sliding enemy pieces (positive when Black more pinned -> good for White)'\n    try:\n        pm = board.piece_map()\n        # helper to find king square for color\n        kings = {chess.WHITE: None, chess.BLACK: None}\n        for sq,p in pm.items():\n            if p and p.piece_type == chess.KING:\n                kings[p.color] = sq\n        def pinned_count(color):\n            cnt = 0\n            king_sq = kings.get(color)\n            if king_sq is None:\n                return 0\n            opp = chess.BLACK if color == chess.WHITE else chess.WHITE\n            # sliding attackers types\n            for sq,p in pm.items():\n                if not p or p.color != opp or p.piece_type not in (chess.ROOK, chess.BISHOP, chess.QUEEN):\n                    continue\n                af = chess.square_file(sq); ar = chess.square_rank(sq)\n                kf = chess.square_file(king_sq); kr = chess.square_rank(king_sq)\n                df = kf - af; dr = kr - ar\n                step_f = 0 if df == 0 else (1 if df > 0 else -1)\n                step_r = 0 if dr == 0 else (1 if dr > 0 else -1)\n                # must be aligned on rank/file/diag\n                if not (af == kf or ar == kr or abs(df) == abs(dr)):\n                    continue\n                # traverse squares between attacker and king, count blocking pieces\n                ff, rr = af + step_f, ar + step_r\n                blockers = []\n                while (ff, rr) != (kf, kr):\n                    sq2 = chess.square(ff, rr)\n                    if pm.get(sq2) is not None:\n                        blockers.append((sq2, pm.get(sq2)))\n                    ff += step_f; rr += step_r\n                if len(blockers) == 1:\n                    blocker_sq, blocker_piece = blockers[0]\n                    # pinned only if the blocker is enemy of attacker and friendly to king (i.e., the side we check)\n                    if blocker_piece and blocker_piece.color == color:\n                        cnt += 1\n            return cnt\n        w = pinned_count(chess.WHITE)\n        b = pinned_count(chess.BLACK)\n        # positive when Black more pinned (good for White)\n        return float(b - w)\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Rook-file control and connectivity: open/semi-open files and doubled/connected rooks (white - black)'\n    try:\n        pm = board.piece_map()\n        def rook_feat(color):\n            open_rooks = 0.0\n            semi_open_rooks = 0.0\n            connected_bonus = 0.0\n            rooks = [sq for sq,p in pm.items() if p and p.color == color and p.piece_type == chess.ROOK]\n            # precompute pawn presence per file\n            pawn_on_file = {f: False for f in range(8)}\n            friendly_pawn_on_file = {f: False for f in range(8)}\n            for sq,p in pm.items():\n                if p and p.piece_type == chess.PAWN:\n                    pawn_on_file[chess.square_file(sq)] = True\n                    if p.color == color:\n                        friendly_pawn_on_file[chess.square_file(sq)] = True\n            for r_sq in rooks:\n                f = chess.square_file(r_sq)\n                if not pawn_on_file[f]:\n                    open_rooks += 1.0\n                elif not friendly_pawn_on_file[f]:\n                    semi_open_rooks += 0.9\n            # connected/doubled rooks: on same rank or file with no intervening pieces\n            for i in range(len(rooks)):\n                for j in range(i+1, len(rooks)):\n                    a = rooks[i]; b = rooks[j]\n                    af, ar = chess.square_file(a), chess.square_rank(a)\n                    bf, br = chess.square_file(b), chess.square_rank(b)\n                    if af == bf or ar == br:\n                        # check path clear between them\n                        step_f = 0 if af == bf else (1 if bf > af else -1)\n                        step_r = 0 if ar == br else (1 if br > ar else -1)\n                        ff, rr = af + step_f, ar + step_r\n                        clear = True\n                        while (ff, rr) != (bf, br):\n                            if pm.get(chess.square(ff, rr)) is not None:\n                                clear = False; break\n                            ff += step_f; rr += step_r\n                        if clear:\n                            connected_bonus += 1.2\n            return open_rooks + 0.7 * semi_open_rooks + 0.6 * connected_bonus\n        return float(rook_feat(chess.WHITE) - rook_feat(chess.BLACK))\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Stable outpost count (knights/bishops) backed by pawns and not attackable by enemy pawns (white - black)'\n    try:\n        pm = board.piece_map()\n        def stable_outposts(color):\n            score = 0.0\n            opp = chess.BLACK if color == chess.WHITE else chess.WHITE\n            for sq,p in pm.items():\n                if not p or p.color != color or p.piece_type not in (chess.KNIGHT, chess.BISHOP):\n                    continue\n                f = chess.square_file(sq); r = chess.square_rank(sq)\n                # candidate ranks for outpost: for white ranks 3..5, for black 2..4 (0-indexed)\n                if color == chess.WHITE and not (3 <= r <= 5):\n                    continue\n                if color == chess.BLACK and not (2 <= r <= 4):\n                    continue\n                # backed by friendly pawn behind (relative to color)\n                behind_r = r - 1 if color == chess.WHITE else r + 1\n                if not (0 <= behind_r < 8):\n                    continue\n                if not (pm.get(chess.square(f, behind_r)) and pm.get(chess.square(f, behind_r)).piece_type == chess.PAWN and pm.get(chess.square(f, behind_r)).color == color):\n                    continue\n                # ensure no enemy pawn can attack this square (i.e., it's stable)\n                pawn_attackers = [a for a in board.attackers(opp, sq) if pm.get(a) and pm.get(a).piece_type == chess.PAWN]\n                if pawn_attackers:\n                    continue\n                # score knights slightly higher for outposts\n                score += 1.2 if p.piece_type == chess.KNIGHT else 0.9\n            return score\n        return float(stable_outposts(chess.WHITE) - stable_outposts(chess.BLACK))\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Endgame king centralization: reward central kings when material is low (positive favors White centralization)'\n    try:\n        pm = board.piece_map()\n        vals = {chess.PAWN:1.0, chess.KNIGHT:3.0, chess.BISHOP:3.0, chess.ROOK:5.0, chess.QUEEN:9.0}\n        material = 0.0\n        for p in pm.values():\n            if p and p.piece_type in vals:\n                material += vals[p.piece_type]\n        # apply only in reduced-material positions\n        if material > 14.0:\n            return 0.0\n        # compute king closeness to board center (3.5,3.5) using Manhattan distance scaled\n        def king_central(color):\n            ks = next((sq for sq,p in pm.items() if p and p.piece_type == chess.KING and p.color == color), None)\n            if ks is None:\n                return 0.0\n            f = chess.square_file(ks); r = chess.square_rank(ks)\n            dist = abs(f - 3.5) + abs(r - 3.5)  # in range 0..7\n            # convert to closeness score 0..1\n            closeness = max(0.0, (7.0 - dist) / 7.0)\n            return closeness\n        return float(king_central(chess.WHITE) - king_central(chess.BLACK))\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Promotion race metric: for each passed pawn measure advancement vs enemy king proximity (white - black)'\n    try:\n        pm = board.piece_map()\n        def passed_pawn_list(color):\n            pawns = []\n            opp = chess.BLACK if color == chess.WHITE else chess.WHITE\n            for sq,p in pm.items():\n                if not p or p.piece_type != chess.PAWN or p.color != color:\n                    continue\n                f = chess.square_file(sq); r = chess.square_rank(sq)\n                # simple passed test\n                passed = True\n                for df in (-1,0,1):\n                    ff = f + df\n                    if not (0 <= ff < 8):\n                        continue\n                    if color == chess.WHITE:\n                        for rr in range(r+1,8):\n                            p2 = pm.get(chess.square(ff, rr))\n                            if p2 and p2.piece_type == chess.PAWN and p2.color == opp:\n                                passed = False; break\n                        if not passed: break\n                    else:\n                        for rr in range(r-1,-1,-1):\n                            p2 = pm.get(chess.square(ff, rr))\n                            if p2 and p2.piece_type == chess.PAWN and p2.color == opp:\n                                passed = False; break\n                        if not passed: break\n                if passed:\n                    pawns.append(sq)\n            return pawns\n        # find kings\n        wk = next((sq for sq,p in pm.items() if p and p.piece_type == chess.KING and p.color == chess.WHITE), None)\n        bk = next((sq for sq,p in pm.items() if p and p.piece_type == chess.KING and p.color == chess.BLACK), None)\n        def pawn_promotion_potential(color):\n            total = 0.0\n            pawns = passed_pawn_list(color)\n            king_sq = bk if color == chess.WHITE else wk  # enemy king\n            if king_sq is None:\n                return 0.0\n            for sq in pawns:\n                r = chess.square_rank(sq)\n                dist_to_promo = (7 - r) if color == chess.WHITE else r\n                # distance in king moves from enemy king to pawn square\n                king_dist = chess.square_distance(king_sq, sq)\n                # potential score: more advanced and enemy king far is better\n                advance_score = (1.0 + ( (7 - dist_to_promo) / 7.0 )**2 * 3.0)\n                intercept_risk = max(0.1, 1.0 - (king_dist / 8.0))  # closer king increases risk\n                total += advance_score * (1.0 - intercept_risk)\n            return total\n        return float(pawn_promotion_potential(chess.WHITE) - pawn_promotion_potential(chess.BLACK))\n    except Exception:\n        return 0.0\n",
    "def feature(board: chess.Board) -> float:\n    'Passed-pawn promotion potential: sum of progress-to-promotion for passed pawns (white - black)'\n    try:\n        pm = board.piece_map()\n        def is_passed(sq, color):\n            f = chess.square_file(sq); r = chess.square_rank(sq)\n            opp = chess.BLACK if color == chess.WHITE else chess.WHITE\n            files = [ff for ff in (f-1, f, f+1) if 0 <= ff < 8]\n            if color == chess.WHITE:\n                for ff in files:\n                    for rr in range(r+1, 8):\n                        sqx = chess.square(ff, rr)\n                        p2 = pm.get(sqx)\n                        if p2 and p2.piece_type == chess.PAWN and p2.color == opp:\n                            return False\n                return True\n            else:\n                for ff in files:\n                    for rr in range(0, r):\n                        sqx = chess.square(ff, rr)\n                        p2 = pm.get(sqx)\n                        if p2 and p2.piece_type == chess.PAWN and p2.color == opp:\n                            return False\n                return True\n        score_w = 0.0; score_b = 0.0\n        for sq,p in pm.items():\n            if not p or p.piece_type != chess.PAWN:\n                continue\n            r = chess.square_rank(sq)\n            if is_passed(sq, p.color):\n                # progress normalized 0..1 (0 on starting rank, 1 on promotion rank)\n                if p.color == chess.WHITE:\n                    prog = float(r) / 7.0\n                    score_w += 1.0 + 5.0 * prog  # base plus progress-weight\n                else:\n                    prog = float(7 - r) / 7.0\n                    score_b += 1.0 + 5.0 * prog\n        return float(score_w - score_b)\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Rook activity: count rooks on open/semi-open files and rooks on opponent seventh rank (white - black)'\n    try:\n        pm = board.piece_map()\n        # collect pawns by file\n        pawns_on_file = {f: {'w':0, 'b':0} for f in range(8)}\n        for sq,p in pm.items():\n            if p and p.piece_type == chess.PAWN:\n                pawns_on_file[chess.square_file(sq)][ 'w' if p.color==chess.WHITE else 'b'] += 1\n        score_w = 0.0; score_b = 0.0\n        for sq,p in pm.items():\n            if not p or p.piece_type != chess.ROOK:\n                continue\n            f = chess.square_file(sq); r = chess.square_rank(sq)\n            # open file: no pawns of either color\n            if pawns_on_file[f]['w'] + pawns_on_file[f]['b'] == 0:\n                bonus = 1.6\n            # semi-open: no friendly pawn on file (but opponent pawn exists)\n            elif pawns_on_file[f]['w' if p.color==chess.WHITE else 'b'] == 0:\n                bonus = 0.9\n            else:\n                bonus = 0.0\n            # seventh rank occupancy: white rooks on rank 6, black rooks on rank 1\n            if p.color == chess.WHITE and r == 6:\n                bonus += 1.8\n            if p.color == chess.BLACK and r == 1:\n                bonus += 1.8\n            if p.color == chess.WHITE:\n                score_w += bonus\n            else:\n                score_b += bonus\n        return float(score_w - score_b)\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Bishop mobility constrained by own pawns: normalized mobility deficit (white - black)'\n    try:\n        pm = board.piece_map()\n        vals = {chess.WHITE:0.0, chess.BLACK:0.0}\n        orig = board.turn\n        try:\n            for color in (chess.WHITE, chess.BLACK):\n                board.turn = color\n                moves_from_bishops = 0\n                bishop_count = 0\n                for mv in board.legal_moves:\n                    p = board.piece_at(mv.from_square)\n                    if p and p.piece_type == chess.BISHOP and p.color == color:\n                        moves_from_bishops += 1\n                for sq,p in pm.items():\n                    if p and p.piece_type == chess.BISHOP and p.color == color:\n                        bishop_count += 1\n                # maximum practical bishop moves ~13 (corner-to-corner)\n                if bishop_count > 0:\n                    mobility = moves_from_bishops / (13.0 * bishop_count)\n                else:\n                    mobility = 0.0\n                vals[color] = mobility\n        finally:\n            board.turn = orig\n        # lower mobility is bad: invert and scale\n        return float((vals[chess.WHITE] - vals[chess.BLACK]) * 2.0)\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Knight outpost strength: knights on opponent half not easily attacked by enemy pawns and supported by friendly pawns (white - black)'\n    try:\n        pm = board.piece_map()\n        def kn_outpost(color):\n            total = 0.0\n            opp = chess.BLACK if color == chess.WHITE else chess.WHITE\n            for sq,p in pm.items():\n                if not p or p.piece_type != chess.KNIGHT or p.color != color:\n                    continue\n                f = chess.square_file(sq); r = chess.square_rank(sq)\n                # must be on opponent half (for white rank >=4, for black rank <=3)\n                if color == chess.WHITE and r < 4:\n                    continue\n                if color == chess.BLACK and r > 3:\n                    continue\n                # attacked by enemy pawn?\n                pawn_attackers = 0\n                if color == chess.WHITE:\n                    # black pawn would be at (f-1,r+1) or (f+1,r+1)\n                    for ff in (f-1, f+1):\n                        rr = r+1\n                        if 0 <= ff < 8 and 0 <= rr < 8:\n                            p2 = pm.get(chess.square(ff, rr))\n                            if p2 and p2.piece_type == chess.PAWN and p2.color == opp:\n                                pawn_attackers += 1\n                else:\n                    for ff in (f-1, f+1):\n                        rr = r-1\n                        if 0 <= ff < 8 and 0 <= rr < 8:\n                            p2 = pm.get(chess.square(ff, rr))\n                            if p2 and p2.piece_type == chess.PAWN and p2.color == opp:\n                                pawn_attackers += 1\n                if pawn_attackers > 0:\n                    continue\n                # supported by friendly pawn on adjacent files behind (outpost support)\n                supported = 0\n                if color == chess.WHITE:\n                    for ff in (f-1, f+1):\n                        rr = r-1\n                        if 0 <= ff < 8 and 0 <= rr < 8:\n                            p2 = pm.get(chess.square(ff, rr))\n                            if p2 and p2.piece_type == chess.PAWN and p2.color == color:\n                                supported += 1\n                else:\n                    for ff in (f-1, f+1):\n                        rr = r+1\n                        if 0 <= ff < 8 and 0 <= rr < 8:\n                            p2 = pm.get(chess.square(ff, rr))\n                            if p2 and p2.piece_type == chess.PAWN and p2.color == color:\n                                supported += 1\n                bonus = 0.9 + 0.6 * supported\n                total += bonus\n            return total\n        return float(kn_outpost(chess.WHITE) - kn_outpost(chess.BLACK))\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Pawn-structure fragility: weighted count of doubled, isolated, and backward pawns (negative = worse); returns (black_fragility - white_fragility)'\n    try:\n        pm = board.piece_map()\n        # gather pawn files and squares\n        pawns_by_file = {f: [] for f in range(8)}\n        pawns = []\n        for sq,p in pm.items():\n            if p and p.piece_type == chess.PAWN:\n                f = chess.square_file(sq); r = chess.square_rank(sq)\n                pawns_by_file[f].append((sq, p.color, r))\n                pawns.append((sq, p.color, r))\n        frag = {chess.WHITE:0.0, chess.BLACK:0.0}\n        for f in range(8):\n            file_pawns = pawns_by_file[f]\n            if not file_pawns:\n                continue\n            # doubled: more than one pawn on a file\n            if len(file_pawns) > 1:\n                for sq,color,r in file_pawns:\n                    frag[color] += 1.0 * (len(file_pawns) - 1)  # penalize each doubled pawn\n        # isolated and backward approx\n        for sq,color,r in pawns:\n            f = chess.square_file(sq)\n            # isolated: no friendly pawns on adjacent files\n            adj_has = False\n            for ff in (f-1, f+1):\n                if 0 <= ff < 8:\n                    for s2,c2,r2 in pawns_by_file[ff]:\n                        if c2 == color:\n                            adj_has = True; break\n                    if adj_has: break\n            if not adj_has:\n                frag[color] += 1.2\n            # backward (approx): no friendly pawn on adjacent files with rank >= this pawn rank (can't be supported forward)\n            support_forward = False\n            for ff in (f-1, f+1):\n                if 0 <= ff < 8:\n                    for s2,c2,r2 in pawns_by_file[ff]:\n                        if c2 == color:\n                            if color == chess.WHITE and r2 >= r:\n                                support_forward = True; break\n                            if color == chess.BLACK and r2 <= r:\n                                support_forward = True; break\n                    if support_forward: break\n            # also check if the square ahead is controlled by opponent (approx)\n            ahead_controlled = False\n            if color == chess.WHITE:\n                if r < 7:\n                    ahead_sq = chess.square(f, r+1)\n                    if board.is_attacked_by(chess.BLACK, ahead_sq):\n                        ahead_controlled = True\n            else:\n                if r > 0:\n                    ahead_sq = chess.square(f, r-1)\n                    if board.is_attacked_by(chess.WHITE, ahead_sq):\n                        ahead_controlled = True\n            if not support_forward and ahead_controlled:\n                frag[color] += 1.5\n        # return black fragility minus white fragility (positive means black is more fragile -> good for white)\n        return float(frag[chess.BLACK] - frag[chess.WHITE])\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'King activity bonus in endgames: kings closer to the central squares in low-material positions (white - black)'\n    try:\n        pm = board.piece_map()\n        vals = {chess.PAWN:1.0, chess.KNIGHT:3.0, chess.BISHOP:3.0, chess.ROOK:5.0, chess.QUEEN:9.0}\n        nonpawn_material = 0.0\n        for p in pm.values():\n            if p and p.piece_type != chess.PAWN and p.piece_type != chess.KING:\n                nonpawn_material += vals.get(p.piece_type, 0.0)\n        # consider endgame when non-pawn material is low\n        if nonpawn_material > 10.0:\n            return 0.0\n        # find kings\n        wk = next((sq for sq,p in pm.items() if p and p.piece_type == chess.KING and p.color == chess.WHITE), None)\n        bk = next((sq for sq,p in pm.items() if p and p.piece_type == chess.KING and p.color == chess.BLACK), None)\n        if wk is None or bk is None:\n            return 0.0\n        centers = [chess.parse_square(s) for s in ('d4','e4','d5','e5')]\n        def centrality(king_sq):\n            dmin = min(chess.square_distance(king_sq, c) for c in centers)\n            # max manhattan distance to center ~6, invert so closer -> larger\n            return (6.0 - float(dmin)) / 6.0\n        return float(centrality(wk) - centrality(bk))\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Hanging-piece vulnerability: weighted sum of opponent pieces attacked more times than defended (positive when black is more vulnerable)'\n    try:\n        pm = board.piece_map()\n        vals = {chess.PAWN:1.0, chess.KNIGHT:3.0, chess.BISHOP:3.0, chess.ROOK:5.0, chess.QUEEN:9.0, chess.KING:0.0}\n        vuln = {chess.WHITE:0.0, chess.BLACK:0.0}\n        for sq,p in pm.items():\n            if not p:\n                continue\n            color = p.color\n            opp = chess.BLACK if color == chess.WHITE else chess.WHITE\n            attackers = board.attackers(opp, sq)\n            defenders = board.attackers(color, sq)\n            a = len(attackers); d = len(defenders)\n            if a > d:\n                vuln[color] += vals.get(p.piece_type, 0.0) * (a - d)\n        # feature positive if black is more vulnerable than white\n        return float(vuln[chess.BLACK] - vuln[chess.WHITE])\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Space advantage by pawn advancement: sum of pawn-advancement into opponent half (white - black)'\n    try:\n        pm = board.piece_map()\n        score_w = 0.0; score_b = 0.0\n        for sq,p in pm.items():\n            if not p or p.piece_type != chess.PAWN:\n                continue\n            r = chess.square_rank(sq); f = chess.square_file(sq)\n            if p.color == chess.WHITE:\n                if r >= 4:\n                    score_w += float(r - 3)  # 1..4 weighting\n            else:\n                if r <= 3:\n                    score_b += float(3 - r)\n        # normalize by typical max (sum of pawn advances) to keep numbers moderate\n        denom = max(1.0, score_w + score_b)\n        return float((score_w - score_b) / denom * (score_w + score_b))\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Piece coordination pressure: sum over squares of squared attacker-value (emphasizes multiple attackers) (white - black)'\n    try:\n        pm = board.piece_map()\n        vals = {chess.PAWN:1.0, chess.KNIGHT:3.0, chess.BISHOP:3.0, chess.ROOK:5.0, chess.QUEEN:9.0, chess.KING:0.0}\n        coord = {chess.WHITE:0.0, chess.BLACK:0.0}\n        for sq in range(64):\n            # white attackers\n            wa = board.attackers(chess.WHITE, sq)\n            wb_sum = 0.0\n            for a in wa:\n                p = pm.get(a)\n                if p:\n                    wb_sum += vals.get(p.piece_type, 0.0)\n            coord[chess.WHITE] += wb_sum * wb_sum\n            # black attackers\n            ba = board.attackers(chess.BLACK, sq)\n            bb_sum = 0.0\n            for a in ba:\n                p = pm.get(a)\n                if p:\n                    bb_sum += vals.get(p.piece_type, 0.0)\n            coord[chess.BLACK] += bb_sum * bb_sum\n        # scale down\n        return float((coord[chess.WHITE] - coord[chess.BLACK]) * 0.02)\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Initiative proxy: legal captures plus pressure on enemy king (white - black), slight bonus for side to move'\n    try:\n        pm = board.piece_map()\n        score = {chess.WHITE:0.0, chess.BLACK:0.0}\n        orig = board.turn\n        try:\n            for color in (chess.WHITE, chess.BLACK):\n                board.turn = color\n                captures = 0\n                for mv in board.legal_moves:\n                    # approximate capture (ignore en-passant rare case)\n                    if board.piece_at(mv.to_square) is not None:\n                        captures += 1\n                # attackers to opponent king (current pressure)\n                opp_king_sq = next((sq for sq,p in pm.items() if p and p.piece_type == chess.KING and p.color != color), None)\n                king_attackers = 0\n                if opp_king_sq is not None:\n                    king_attackers = len(board.attackers(color, opp_king_sq))\n                score[color] = captures + 0.8 * king_attackers\n                # small tempo bonus if side to move equals this color\n                if orig == color:\n                    score[color] += 0.3\n        finally:\n            board.turn = orig\n        return float(score[chess.WHITE] - score[chess.BLACK])\n    except Exception:\n        return 0.0\n",
    "def feature(board: chess.Board) -> float:\n    'Passed pawn potential difference (white - black): counts passed pawns weighted by advancement'\n    try:\n        pm = board.piece_map()\n        def passed_pawn_score(color):\n            score = 0.0\n            opp = chess.BLACK if color == chess.WHITE else chess.WHITE\n            for sq, p in pm.items():\n                if not p or p.piece_type != chess.PAWN or p.color != color:\n                    continue\n                f = chess.square_file(sq); r = chess.square_rank(sq)\n                blocked = False\n                for af in (f-1, f, f+1):\n                    if not (0 <= af < 8):\n                        continue\n                    # for white, opponent pawns ahead have rank > r; for black, rank < r\n                    if color == chess.WHITE:\n                        for ar in range(r+1, 8):\n                            s = chess.square(af, ar)\n                            pp = pm.get(s)\n                            if pp and pp.piece_type == chess.PAWN and pp.color == opp:\n                                blocked = True; break\n                        if blocked: break\n                    else:\n                        for ar in range(0, r):\n                            s = chess.square(af, ar)\n                            pp = pm.get(s)\n                            if pp and pp.piece_type == chess.PAWN and pp.color == opp:\n                                blocked = True; break\n                        if blocked: break\n                if not blocked:\n                    # advancement weight: more advanced passed pawns are more valuable\n                    adv = (r / 7.0) if color == chess.WHITE else ((7 - r) / 7.0)\n                    score += 1.0 * (0.2 + 0.8 * adv)\n            return score\n        return float(passed_pawn_score(chess.WHITE) - passed_pawn_score(chess.BLACK))\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Rook file and 7th/2nd rank control: counts rooks on open/semi-open files and rooks on opponent 7th/2nd ranks (white - black)'\n    try:\n        pm = board.piece_map()\n        def rook_score(color):\n            score = 0.0\n            for sq, p in pm.items():\n                if not p or p.piece_type != chess.ROOK or p.color != color:\n                    continue\n                f = chess.square_file(sq); r = chess.square_rank(sq)\n                # open file: no pawns; semi-open: only opponent pawns\n                pawns_on_file = [pm.get(chess.square(f, rr)) for rr in range(8)]\n                pawn_colors = set(pp.color for pp in pawns_on_file if pp and pp.piece_type == chess.PAWN)\n                if len([pp for pp in pawns_on_file if pp and pp.piece_type == chess.PAWN]) == 0:\n                    score += 1.0  # open file bonus\n                elif pawn_colors == { (chess.BLACK if color == chess.WHITE else chess.WHITE) }:\n                    score += 0.6  # semi-open\n                # 7th/2nd rank pressure: white rooks on rank 6 (7th rank) or black rooks on rank 1 (2nd rank)\n                if color == chess.WHITE and r == 6:\n                    score += 1.2\n                if color == chess.BLACK and r == 1:\n                    score += 1.2\n            return score\n        return float(rook_score(chess.WHITE) - rook_score(chess.BLACK))\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Minor-piece outpost advantage: knights/bishops on outpost squares (protected by pawn, not attackable by enemy pawns) (white - black)'\n    try:\n        pm = board.piece_map()\n        def outpost_score(color):\n            score = 0.0\n            opp = chess.BLACK if color == chess.WHITE else chess.WHITE\n            for sq, p in pm.items():\n                if not p or p.piece_type not in (chess.KNIGHT, chess.BISHOP) or p.color != color:\n                    continue\n                # must be on opponent half to be a meaningful outpost\n                rank = chess.square_rank(sq)\n                if color == chess.WHITE and rank < 4:\n                    continue\n                if color == chess.BLACK and rank > 3:\n                    continue\n                # protected by friendly pawn?\n                protected_by_pawn = False\n                for a in board.attackers(color, sq):\n                    pa = pm.get(a)\n                    if pa and pa.piece_type == chess.PAWN and pa.color == color:\n                        protected_by_pawn = True\n                        break\n                if not protected_by_pawn:\n                    continue\n                # not attackable by enemy pawns\n                pawn_attackers = [a for a in board.attackers(opp, sq) if pm.get(a) and pm.get(a).piece_type == chess.PAWN]\n                if pawn_attackers:\n                    continue\n                # weight knights slightly higher as outposts are particularly strong for knights\n                weight = 1.0 if p.piece_type == chess.BISHOP else 1.3\n                score += weight\n            return score\n        return float(outpost_score(chess.WHITE) - outpost_score(chess.BLACK))\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'King centrality adjusted for endgame: rewards more central king when few pieces remain (positive favors White)'\n    try:\n        pm = board.piece_map()\n        # locate kings\n        wk = next((sq for sq,p in pm.items() if p and p.piece_type == chess.KING and p.color == chess.WHITE), None)\n        bk = next((sq for sq,p in pm.items() if p and p.piece_type == chess.KING and p.color == chess.BLACK), None)\n        if wk is None or bk is None:\n            return 0.0\n        # compute phase: number of non-king non-pawn pieces\n        non_pawn_pieces = sum(1 for p in pm.values() if p and p.piece_type not in (chess.PAWN, chess.KING))\n        # phase factor: more centralization value when non_pawn_pieces small\n        phase_factor = 1.0 if non_pawn_pieces <= 4 else max(0.0, 1.0 - (non_pawn_pieces - 4) / 10.0)\n        # center coords (3.5, 3.5)\n        def centrality(sq):\n            f = chess.square_file(sq); r = chess.square_rank(sq)\n            dx = f - 3.5; dy = r - 3.5\n            dist = (dx*dx + dy*dy) ** 0.5\n            maxd = (3.5*3.5 + 3.5*3.5) ** 0.5\n            return (maxd - dist) / maxd\n        return float((centrality(wk) - centrality(bk)) * phase_factor)\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Hanging piece vulnerability: net value of pieces attacked more than defended (positive if Black has more vulnerable material -> good for White)'\n    try:\n        pm = board.piece_map()\n        vals = {chess.PAWN:1.0, chess.KNIGHT:3.0, chess.BISHOP:3.0, chess.ROOK:5.0, chess.QUEEN:9.0, chess.KING:0.0}\n        white_vulnerable = 0.0\n        black_vulnerable = 0.0\n        for sq, p in pm.items():\n            if not p:\n                continue\n            # count attacker total value vs defender total value\n            opp = chess.BLACK if p.color == chess.WHITE else chess.WHITE\n            atk_vals = sum(vals.get(pm.get(a).piece_type, 0.0) for a in board.attackers(opp, sq) if pm.get(a))\n            def_vals = sum(vals.get(pm.get(a).piece_type, 0.0) for a in board.attackers(p.color, sq) if pm.get(a))\n            # if attackers' total value notably exceeds defenders' total value, piece is effectively hanging\n            if atk_vals > def_vals + 0.5:\n                if p.color == chess.WHITE:\n                    white_vulnerable += vals.get(p.piece_type, 0.0)\n                else:\n                    black_vulnerable += vals.get(p.piece_type, 0.0)\n        # positive if Black has more vulnerable material (good for White)\n        return float(black_vulnerable - white_vulnerable)\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Space control in opponent half by minors/majors: fraction of opponent-half squares attacked by non-pawn pieces (white - black)'\n    try:\n        pm = board.piece_map()\n        def control_in_enemy_half(color):\n            count = 0\n            total = 0\n            # opponent half ranks: for white target ranks 4..7, for black target ranks 0..3\n            target_ranks = range(4,8) if color == chess.WHITE else range(0,4)\n            for f in range(8):\n                for r in target_ranks:\n                    sq = chess.square(f, r)\n                    # consider control by non-pawn pieces only\n                    attackers = board.attackers(color, sq)\n                    has_non_pawn = any(pm.get(a) and pm.get(a).piece_type != chess.PAWN for a in attackers)\n                    total += 1\n                    if has_non_pawn:\n                        count += 1\n            return (count / total) if total > 0 else 0.0\n        return float(control_in_enemy_half(chess.WHITE) - control_in_enemy_half(chess.BLACK))\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Bishop vs Knight suitability given board openness: rewards side whose piece mix matches openness (positive favors White)'\n    try:\n        pm = board.piece_map()\n        pawn_count = sum(1 for p in pm.values() if p and p.piece_type == chess.PAWN)\n        openness = 1.0 - min(1.0, pawn_count / 16.0)  # 0..1, larger => more open\n        def mix_score(color):\n            knights = sum(1 for p in pm.values() if p and p.piece_type == chess.KNIGHT and p.color == color)\n            bishops = sum(1 for p in pm.values() if p and p.piece_type == chess.BISHOP and p.color == color)\n            # if open, bishops preferred; if closed, knights preferred\n            return (bishops - knights) * (2.0 * openness - 1.0)\n        return float(mix_score(chess.WHITE) - mix_score(chess.BLACK))\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Rook-behind-passed-pawn synergy: rewards rooks aligned behind own passed pawns (white - black)'\n    try:\n        pm = board.piece_map()\n        def passed_pawns(color):\n            opp = chess.BLACK if color == chess.WHITE else chess.WHITE\n            res = []\n            for sq, p in pm.items():\n                if not p or p.piece_type != chess.PAWN or p.color != color:\n                    continue\n                f = chess.square_file(sq); r = chess.square_rank(sq)\n                blocked = False\n                for af in (f-1, f, f+1):\n                    if not (0 <= af < 8):\n                        continue\n                    if color == chess.WHITE:\n                        for ar in range(r+1, 8):\n                            s = chess.square(af, ar)\n                            pp = pm.get(s)\n                            if pp and pp.piece_type == chess.PAWN and pp.color == opp:\n                                blocked = True; break\n                        if blocked: break\n                    else:\n                        for ar in range(0, r):\n                            s = chess.square(af, ar)\n                            pp = pm.get(s)\n                            if pp and pp.piece_type == chess.PAWN and pp.color == opp:\n                                blocked = True; break\n                        if blocked: break\n                if not blocked:\n                    res.append((f, r, sq))\n            return res\n        def rook_synergy(color):\n            score = 0.0\n            rooks = [(chess.square_file(sq), chess.square_rank(sq), sq) for sq, p in pm.items() if p and p.piece_type == chess.ROOK and p.color == color]\n            for f, r, sqp in passed_pawns(color):\n                for rf, rr, r_sq in rooks:\n                    if rf != f:\n                        continue\n                    # rook behind pawn: for white rook rank < pawn rank; for black rook rank > pawn rank\n                    if color == chess.WHITE and rr < r:\n                        # closer is better\n                        dist = r - rr\n                        score += 0.8 * (1.0 / (0.5 + dist))\n                    if color == chess.BLACK and rr > r:\n                        dist = rr - r\n                        score += 0.8 * (1.0 / (0.5 + dist))\n            return score\n        return float(rook_synergy(chess.WHITE) - rook_synergy(chess.BLACK))\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Heavy-piece (rooks+queen) mobility imbalance normalized (white - black)'\n    try:\n        orig = board.turn\n        try:\n            heavy_moves = {chess.WHITE:0, chess.BLACK:0}\n            for color in (chess.WHITE, chess.BLACK):\n                board.turn = color\n                for mv in board.legal_moves:\n                    p = board.piece_at(mv.from_square)\n                    if p and p.piece_type in (chess.ROOK, chess.QUEEN) and p.color == color:\n                        heavy_moves[color] += 1\n            total = max(1.0, heavy_moves[chess.WHITE] + heavy_moves[chess.BLACK])\n            return float((heavy_moves[chess.WHITE] - heavy_moves[chess.BLACK]) / total)\n        finally:\n            board.turn = orig\n    except Exception:\n        return 0.0\n",
    "def feature(board: chess.Board) -> float:\n    'Passed pawn potential: advancement-weighted passed pawn score (white - black)'\n    try:\n        pm = board.piece_map()\n        def is_passed(sq, color):\n            if sq is None: return False\n            f = chess.square_file(sq); r = chess.square_rank(sq)\n            opp = chess.BLACK if color == chess.WHITE else chess.WHITE\n            # ranks ahead depending on color\n            if color == chess.WHITE:\n                for af in (f-1, f, f+1):\n                    if 0 <= af <= 7:\n                        for ar in range(r+1, 8):\n                            s2 = chess.square(af, ar)\n                            p = pm.get(s2)\n                            if p and p.piece_type == chess.PAWN and p.color == opp:\n                                return False\n                return True\n            else:\n                for af in (f-1, f, f+1):\n                    if 0 <= af <= 7:\n                        for ar in range(0, r):\n                            s2 = chess.square(af, ar)\n                            p = pm.get(s2)\n                            if p and p.piece_type == chess.PAWN and p.color == opp:\n                                return False\n                return True\n        white = 0.0; black = 0.0\n        for sq, p in pm.items():\n            if not p or p.piece_type != chess.PAWN:\n                continue\n            f = chess.square_file(sq); r = chess.square_rank(sq)\n            if p.color == chess.WHITE:\n                adv = r / 7.0\n                passed = is_passed(sq, chess.WHITE)\n                blocked = 1.0 if pm.get(chess.square(f, r+1)) else 0.0\n                white += (0.9 * adv + (0.9 if passed else 0.0) - 0.45 * blocked)\n            else:\n                adv = (7 - r) / 7.0\n                passed = is_passed(sq, chess.BLACK)\n                blocked = 1.0 if pm.get(chess.square(f, r-1)) else 0.0\n                black += (0.9 * adv + (0.9 if passed else 0.0) - 0.45 * blocked)\n        return float(white - black)\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Rook 7th-rank pressure and doubling: counts rooks on opponent seventh and doubled rooks (white - black)'\n    try:\n        pm = board.piece_map()\n        score = {chess.WHITE:0.0, chess.BLACK:0.0}\n        rooks_by_file = {chess.WHITE: {}, chess.BLACK: {}}\n        for sq, p in pm.items():\n            if not p or p.piece_type != chess.ROOK:\n                continue\n            rnk = chess.square_rank(sq)\n            color = p.color\n            # opponent seventh rank: for white rooks attacking black, rank 6; for black rooks attacking white, rank 1\n            target_rank = 6 if color == chess.WHITE else 1\n            if rnk == target_rank:\n                score[color] += 1.0\n            elif rnk == target_rank - 1 or rnk == target_rank + 1:\n                score[color] += 0.25\n            f = chess.square_file(sq)\n            rooks_by_file[color].setdefault(f, 0)\n            rooks_by_file[color][f] += 1\n        # doubled rooks bonus\n        for color in (chess.WHITE, chess.BLACK):\n            for cnt in rooks_by_file[color].values():\n                if cnt >= 2:\n                    score[color] += 0.6 * (cnt - 1)\n        return float(score[chess.WHITE] - score[chess.BLACK])\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Knight outpost strength: supported, pawn-protected central knights not easily attacked (white - black)'\n    try:\n        pm = board.piece_map()\n        def outpost_value(sq, color):\n            if sq is None: return 0.0\n            f = chess.square_file(sq); r = chess.square_rank(sq)\n            opp = chess.BLACK if color == chess.WHITE else chess.WHITE\n            # supported by friendly pawn behind\n            supported = False\n            if color == chess.WHITE:\n                for df in (f-1, f+1):\n                    fr = r-1\n                    if 0 <= df <= 7 and 0 <= fr <= 7:\n                        p = pm.get(chess.square(df, fr))\n                        if p and p.piece_type == chess.PAWN and p.color == color:\n                            supported = True; break\n            else:\n                for df in (f-1, f+1):\n                    fr = r+1\n                    if 0 <= df <= 7 and 0 <= fr <= 7:\n                        p = pm.get(chess.square(df, fr))\n                        if p and p.piece_type == chess.PAWN and p.color == color:\n                            supported = True; break\n            # attacked by enemy pawns?\n            attacked_by_pawn = False\n            if color == chess.WHITE:\n                for df in (f-1, f+1):\n                    fr = r+1\n                    if 0 <= df <= 7 and 0 <= fr <= 7:\n                        p = pm.get(chess.square(df, fr))\n                        if p and p.piece_type == chess.PAWN and p.color == opp:\n                            attacked_by_pawn = True; break\n            else:\n                for df in (f-1, f+1):\n                    fr = r-1\n                    if 0 <= df <= 7 and 0 <= fr <= 7:\n                        p = pm.get(chess.square(df, fr))\n                        if p and p.piece_type == chess.PAWN and p.color == opp:\n                            attacked_by_pawn = True; break\n            # enemy attackers count\n            attackers = len(board.attackers(opp, sq))\n            # centrality: prefer d4,e4,d5,e5 (files/ranks 3 or 4)\n            dist_file = abs(f - 3.5); dist_rank = abs(r - 3.5)\n            cent = max(0.0, 1.0 - (dist_file + dist_rank) / 7.0)\n            val = 0.0\n            if supported and not attacked_by_pawn:\n                val += 1.1 * cent\n            # penalize if many attackers\n            val -= 0.25 * max(0, attackers - 1)\n            return max(0.0, val)\n        total = {chess.WHITE:0.0, chess.BLACK:0.0}\n        for sq, p in pm.items():\n            if not p or p.piece_type != chess.KNIGHT:\n                continue\n            total[p.color] += outpost_value(sq, p.color)\n        return float(total[chess.WHITE] - total[chess.BLACK])\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Queen proximity pressure: how close queens are to the opposing king and whether they attack king vicinity (positive favors White)'\n    try:\n        pm = board.piece_map()\n        # find kings and queens\n        wk = next((sq for sq,p in pm.items() if p and p.piece_type==chess.KING and p.color==chess.WHITE), None)\n        bk = next((sq for sq,p in pm.items() if p and p.piece_type==chess.KING and p.color==chess.BLACK), None)\n        wq = next((sq for sq,p in pm.items() if p and p.piece_type==chess.QUEEN and p.color==chess.WHITE), None)\n        bq = next((sq for sq,p in pm.items() if p and p.piece_type==chess.QUEEN and p.color==chess.BLACK), None)\n        maxd = 14.0\n        def qscore(qsq, target_king_sq, color):\n            if qsq is None or target_king_sq is None:\n                return 0.0\n            d = chess.square_distance(qsq, target_king_sq)\n            closeness = (maxd - float(d)) / maxd\n            # additional weight if queen attacks near king\n            kf = chess.square_file(target_king_sq); kr = chess.square_rank(target_king_sq)\n            near_attacks = 0\n            for ff in range(max(0, kf-1), min(7, kf+1)+1):\n                for rr in range(max(0, kr-1), min(7, kr+1)+1):\n                    sq = chess.square(ff, rr)\n                    attackers = board.attackers(color, sq)\n                    for a in attackers:\n                        if a == qsq:\n                            near_attacks += 1\n            return closeness + 0.25 * near_attacks\n        wscore = qscore(wq, bk, chess.WHITE)\n        bscore = qscore(bq, wk, chess.BLACK)\n        return float(wscore - bscore)\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Hanging pieces differential: sum of values of undefended pieces attacked by opponent (black_hangs - white_hangs); positive favors White'\n    try:\n        pm = board.piece_map()\n        vals = {chess.PAWN:1.0, chess.KNIGHT:3.0, chess.BISHOP:3.0, chess.ROOK:5.0, chess.QUEEN:9.0, chess.KING:0.0}\n        hang = {chess.WHITE:0.0, chess.BLACK:0.0}\n        for sq, p in pm.items():\n            if not p or p.piece_type == chess.KING:\n                continue\n            color = p.color\n            opp = chess.BLACK if color == chess.WHITE else chess.WHITE\n            attacked = len(board.attackers(opp, sq)) > 0\n            defended = len(board.attackers(color, sq)) > 0\n            if attacked and not defended:\n                hang[color] += vals.get(p.piece_type, 0.0)\n        # positive when black has more hanging material (good for white)\n        return float(hang[chess.BLACK] - hang[chess.WHITE])\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Pawn-majority imbalance by side and connectivity: favors side with connected majority on a wing (positive favors White)'\n    try:\n        pm = board.piece_map()\n        wk = sum(1 for sq,p in pm.items() if p and p.piece_type==chess.PAWN and p.color==chess.WHITE and chess.square_file(sq) >= 4)\n        wq = sum(1 for sq,p in pm.items() if p and p.piece_type==chess.PAWN and p.color==chess.WHITE and chess.square_file(sq) <= 3)\n        bk = sum(1 for sq,p in pm.items() if p and p.piece_type==chess.PAWN and p.color==chess.BLACK and chess.square_file(sq) >= 4)\n        bq = sum(1 for sq,p in pm.items() if p and p.piece_type==chess.PAWN and p.color==chess.BLACK and chess.square_file(sq) <= 3)\n        # connectivity: count pawns that have a friendly pawn on adjacent file within one rank\n        def connected_count(color):\n            cnt = 0\n            for sq,p in pm.items():\n                if not p or p.piece_type != chess.PAWN or p.color != color: continue\n                f = chess.square_file(sq); r = chess.square_rank(sq)\n                for df in (f-1, f+1):\n                    for dr in (-1, 0, 1):\n                        if 0 <= df <=7 and 0 <= r+dr <=7:\n                            p2 = pm.get(chess.square(df, r+dr))\n                            if p2 and p2.piece_type == chess.PAWN and p2.color == color:\n                                cnt += 1\n                                df = None; break\n                    if df is None: break\n            return cnt\n        wconn = connected_count(chess.WHITE)\n        bconn = connected_count(chess.BLACK)\n        # majority difference weighted by connectivity\n        wing_majority = ( (wk - bk) - (wq - bq) )\n        conn_bonus = 0.25 * (wconn - bconn)\n        return float(wing_majority + conn_bonus)\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Bad-bishop measure: counts bishops hampered by same-color pawns and limited mobility (white - black)'\n    try:\n        pm = board.piece_map()\n        bad = {chess.WHITE:0.0, chess.BLACK:0.0}\n        orig = board.turn\n        try:\n            for sq, p in pm.items():\n                if not p or p.piece_type != chess.BISHOP:\n                    continue\n                color = p.color\n                f = chess.square_file(sq); r = chess.square_rank(sq)\n                # count friendly pawns on same-colored squares (worse if central)\n                same_color_pawn_count = 0\n                for sq2, p2 in pm.items():\n                    if p2 and p2.piece_type == chess.PAWN and p2.color == color:\n                        cf = chess.square_file(sq2); cr = chess.square_rank(sq2)\n                        if ((cf + cr) % 2) == ((f + r) % 2):\n                            # central pawns count more\n                            center_bonus = 1.0 if 2 <= cf <= 5 and 2 <= cr <= 5 else 0.6\n                            same_color_pawn_count += center_bonus\n                # mobility: count legal moves from this bishop square\n                board.turn = color\n                mob = 0\n                for mv in board.legal_moves:\n                    if mv.from_square == sq:\n                        mob += 1\n                mob_norm = min(1.0, mob / 13.0)\n                # badness increases with same-color pawns, decreases with mobility\n                badness = 0.45 * same_color_pawn_count - 0.9 * mob_norm\n                bad[color] += badness\n        finally:\n            board.turn = orig\n        return float(max(-5.0, min(5.0, bad[chess.WHITE] - bad[chess.BLACK])))\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Heavy-piece file control: rooks/queens on open or semi-open files weighted by enemy material on the file (white - black)'\n    try:\n        pm = board.piece_map()\n        pawn_on_file = [False]*8\n        pawn_color_on_file = [set() for _ in range(8)]\n        for sq,p in pm.items():\n            if p and p.piece_type == chess.PAWN:\n                f = chess.square_file(sq)\n                pawn_on_file[f] = True\n                pawn_color_on_file[f].add(p.color)\n        score = {chess.WHITE:0.0, chess.BLACK:0.0}\n        for sq,p in pm.items():\n            if not p or p.piece_type not in (chess.ROOK, chess.QUEEN):\n                continue\n            f = chess.square_file(sq)\n            color = p.color\n            enemy_pieces_on_file = 0\n            for r in range(8):\n                s2 = chess.square(f, r)\n                p2 = pm.get(s2)\n                if p2 and p2.color != color:\n                    enemy_pieces_on_file += 1\n            if not pawn_on_file[f]:\n                base = 1.0\n            elif color not in pawn_color_on_file[f]:\n                base = 0.6\n            else:\n                base = 0.0\n            score[color] += base * (1.0 + 0.3 * enemy_pieces_on_file)\n        return float(score[chess.WHITE] - score[chess.BLACK])\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Initiative metric: legal-move tactical pressure (checks, captures of high value, promotions) for each side (white - black)'\n    try:\n        vals = {chess.PAWN:1.0, chess.KNIGHT:3.0, chess.BISHOP:3.0, chess.ROOK:5.0, chess.QUEEN:9.0, chess.KING:0.0}\n        orig_turn = board.turn\n        try:\n            def side_pressure(color):\n                board.turn = color\n                cap_val = 0.0\n                checks = 0.0\n                promos = 0.0\n                for mv in board.legal_moves:\n                    # capture value (piece on to_square before move)\n                    tgt = board.piece_at(mv.to_square)\n                    if tgt:\n                        cap_val += vals.get(tgt.piece_type, 0.0)\n                    # promotion detection (some move objects define promotion)\n                    if getattr(mv, 'promotion', None):\n                        promos += 3.0\n                    # simulate move briefly to detect checks\n                    try:\n                        board.push(mv)\n                        if board.is_check():\n                            checks += 1.0\n                        board.pop()\n                    except Exception:\n                        # make sure board remains consistent\n                        try:\n                            board.pop()\n                        except Exception:\n                            pass\n                # combine: weight checks quite a bit\n                return cap_val + 1.4 * checks + promos\n            w = side_pressure(chess.WHITE)\n            b = side_pressure(chess.BLACK)\n        finally:\n            board.turn = orig_turn\n        return float(w - b)\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'King shelter safety: fraction of king-adjacent squares not attacked by opponent and not occupied by enemy (white - black)'\n    try:\n        pm = board.piece_map()\n        def safe_squares_for(color):\n            king_sq = next((sq for sq,p in pm.items() if p and p.piece_type==chess.KING and p.color==color), None)\n            if king_sq is None:\n                return 0.0\n            opp = chess.BLACK if color == chess.WHITE else chess.WHITE\n            kf = chess.square_file(king_sq); kr = chess.square_rank(king_sq)\n            safe = 0\n            total = 0\n            for ff in range(max(0, kf-1), min(7, kf+1)+1):\n                for rr in range(max(0, kr-1), min(7, kr+1)+1):\n                    sq = chess.square(ff, rr)\n                    total += 1\n                    occ = pm.get(sq)\n                    # dangerous if attacked by opponent or occupied by opponent piece\n                    if board.is_attacked_by(opp, sq):\n                        continue\n                    if occ and occ.color == opp:\n                        continue\n                    safe += 1\n            return safe / max(1.0, total)\n        sw = safe_squares_for(chess.WHITE)\n        sb = safe_squares_for(chess.BLACK)\n        return float(sw - sb)\n    except Exception:\n        return 0.0\n",
    "def feature(board: chess.Board) -> float:\n    'Central control weighted by attacker piece value on d4,e4,d5,e5 (white - black)'\n    try:\n        vals = {chess.PAWN:1.0, chess.KNIGHT:3.0, chess.BISHOP:3.0, chess.ROOK:5.0, chess.QUEEN:9.0, chess.KING:0.0}\n        centers = [chess.parse_square(s) for s in ('d4','e4','d5','e5')]\n        pm = board.piece_map()\n        def control_score(color):\n            score = 0.0\n            for sq in centers:\n                attackers = board.attackers(color, sq)\n                for a in attackers:\n                    p = pm.get(a)\n                    if p:\n                        score += vals.get(p.piece_type, 0.0)\n            return score\n        return float(control_score(chess.WHITE) - control_score(chess.BLACK))\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Bishop-pair and bishop mobility advantage: (white - black)'\n    try:\n        pm = board.piece_map()\n        def bishop_stats(color):\n            count = 0\n            mobility = 0\n            for sq, p in pm.items():\n                if not p or p.piece_type != chess.BISHOP or p.color != color:\n                    continue\n                count += 1\n                f = chess.square_file(sq); r = chess.square_rank(sq)\n                # four diagonal directions\n                for df, dr in ((1,1),(1,-1),(-1,1),(-1,-1)):\n                    ff, rr = f + df, r + dr\n                    while 0 <= ff < 8 and 0 <= rr < 8:\n                        qs = chess.square(ff, rr)\n                        if pm.get(qs) is None:\n                            mobility += 1.0\n                        else:\n                            # can capture enemy piece, counts as mobility step\n                            if pm[qs].color != color:\n                                mobility += 1.0\n                            break\n                        ff += df; rr += dr\n            # bishop-pair bonus\n            pair_bonus = 0.8 if count >= 2 else 0.0\n            return pair_bonus + mobility * 0.06\n        return float(bishop_stats(chess.WHITE) - bishop_stats(chess.BLACK))\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'King escape/safety squares: number of adjacent safe squares for king (white - black)'\n    try:\n        pm = board.piece_map()\n        def safe_king_squares(color):\n            king_sq = next((sq for sq,p in pm.items() if p and p.piece_type == chess.KING and p.color == color), None)\n            if king_sq is None:\n                return 0.0\n            kf = chess.square_file(king_sq); kr = chess.square_rank(king_sq)\n            opp = chess.BLACK if color == chess.WHITE else chess.WHITE\n            safe = 0\n            for df in (-1,0,1):\n                for dr in (-1,0,1):\n                    if df == 0 and dr == 0:\n                        continue\n                    ff = kf + df; rr = kr + dr\n                    if not (0 <= ff < 8 and 0 <= rr < 8):\n                        continue\n                    sq = chess.square(ff, rr)\n                    occ = pm.get(sq)\n                    # can't move on friendly-occupied square\n                    if occ and occ.color == color:\n                        continue\n                    # square must not be attacked by opponent\n                    try:\n                        if not board.is_attacked_by(opp, sq):\n                            safe += 1\n                    except Exception:\n                        # fallback to attackers()\n                        attackers = board.attackers(opp, sq)\n                        if not attackers:\n                            safe += 1\n            return float(safe)\n        return float(safe_king_squares(chess.WHITE) - safe_king_squares(chess.BLACK))\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Total material value of pinned pieces (positive = white pinned pieces value higher -> bad for White), returned as (black - white) so positive favors White when lower pinned value for White'\n    try:\n        vals = {chess.PAWN:1.0, chess.KNIGHT:3.0, chess.BISHOP:3.0, chess.ROOK:5.0, chess.QUEEN:9.0, chess.KING:0.0}\n        pm = board.piece_map()\n        def pinned_value(color):\n            total = 0.0\n            king_sq = next((sq for sq,p in pm.items() if p and p.piece_type == chess.KING and p.color == color), None)\n            if king_sq is None:\n                return 0.0\n            kf = chess.square_file(king_sq); kr = chess.square_rank(king_sq)\n            opp = chess.BLACK if color == chess.WHITE else chess.WHITE\n            for sq, p in pm.items():\n                if not p or p.color != opp:\n                    continue\n                if p.piece_type not in (chess.ROOK, chess.BISHOP, chess.QUEEN):\n                    continue\n                pf = chess.square_file(sq); pr = chess.square_rank(sq)\n                df = kf - pf; dr = kr - pr\n                # aligned?\n                if df == 0:\n                    step = (0, 1 if dr > 0 else -1)\n                elif dr == 0:\n                    step = (1 if df > 0 else -1, 0)\n                elif abs(df) == abs(dr):\n                    step = (1 if df > 0 else -1, 1 if dr > 0 else -1)\n                else:\n                    continue\n                # walk from opponent piece towards king, count pieces in-between\n                ff, rr = pf + step[0], pr + step[1]\n                between = []\n                blocked = False\n                while (ff, rr) != (kf, kr):\n                    if not (0 <= ff < 8 and 0 <= rr < 8):\n                        blocked = True\n                        break\n                    sqb = chess.square(ff, rr)\n                    if pm.get(sqb):\n                        between.append((sqb, pm[sqb]))\n                    ff += step[0]; rr += step[1]\n                if blocked:\n                    continue\n                # exactly one piece of our color between => pinned\n                if len(between) == 1 and between[0][1].color == color:\n                    pinned_piece = between[0][1]\n                    total += vals.get(pinned_piece.piece_type, 0.0)\n            return total\n        # pinned_value returns how much of color is pinned (bad for that color)\n        # Compute result so that positive is good for White: black_pinned - white_pinned\n        return float(pinned_value(chess.BLACK) - pinned_value(chess.WHITE))\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Pawn majority imbalance on kingside vs queenside: positive favors White kingside majority'\n    try:\n        pm = board.piece_map()\n        def flank_counts(color):\n            ks = 0; qs = 0\n            for sq, p in pm.items():\n                if p and p.piece_type == chess.PAWN and p.color == color:\n                    f = chess.square_file(sq)\n                    if f >= 4:\n                        ks += 1\n                    else:\n                        qs += 1\n            return ks, qs\n        wks, wqs = flank_counts(chess.WHITE)\n        bks, bqs = flank_counts(chess.BLACK)\n        # white kingside majority minus black kingside majority\n        return float((wks - wqs) - (bks - bqs))\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Tactical capture pressure: sum of opponent pieces attacked more times than defended weighted by their value (white - black)'\n    try:\n        vals = {chess.PAWN:1.0, chess.KNIGHT:3.0, chess.BISHOP:3.0, chess.ROOK:5.0, chess.QUEEN:9.0, chess.KING:0.0}\n        pm = board.piece_map()\n        def tactical_score(attacker_color):\n            score = 0.0\n            for sq, p in pm.items():\n                if not p or p.color == attacker_color:\n                    continue\n                # p is a potential target for attacker_color\n                attackers = board.attackers(attacker_color, sq)\n                defenders = board.attackers(p.color, sq)\n                atk = len(attackers)\n                defc = len(defenders)\n                if atk > defc and atk > 0:\n                    score += vals.get(p.piece_type, 0.0) * (atk - defc)\n            return score\n        # positive value indicates White has better capture pressure\n        return float(tactical_score(chess.WHITE) - tactical_score(chess.BLACK))\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Stable outposts for minor pieces (knights/bishops) that are immune to enemy pawn attacks and supported (white - black)'\n    try:\n        pm = board.piece_map()\n        def outpost_score(color):\n            score = 0.0\n            opp = chess.BLACK if color == chess.WHITE else chess.WHITE\n            for sq, p in pm.items():\n                if not p or p.color != color or p.piece_type not in (chess.KNIGHT, chess.BISHOP):\n                    continue\n                f = chess.square_file(sq); r = chess.square_rank(sq)\n                # require reasonably advanced for each color: white on rank >= 3, black on rank <= 4\n                if color == chess.WHITE and r < 3:\n                    continue\n                if color == chess.BLACK and r > 4:\n                    continue\n                # check enemy pawns that could attack this square\n                enemy_pawn_attacks = False\n                if color == chess.WHITE:\n                    # black pawns attack downwards from one rank above\n                    for af in (f-1, f+1):\n                        rr = r + 1\n                        if 0 <= af < 8 and 0 <= rr < 8:\n                            sqp = chess.square(af, rr)\n                            pp = pm.get(sqp)\n                            if pp and pp.piece_type == chess.PAWN and pp.color == opp:\n                                enemy_pawn_attacks = True\n                                break\n                else:\n                    for af in (f-1, f+1):\n                        rr = r - 1\n                        if 0 <= af < 8 and 0 <= rr < 8:\n                            sqp = chess.square(af, rr)\n                            pp = pm.get(sqp)\n                            if pp and pp.piece_type == chess.PAWN and pp.color == opp:\n                                enemy_pawn_attacks = True\n                                break\n                if enemy_pawn_attacks:\n                    continue\n                # require at least one defender (piece or pawn)\n                defenders = board.attackers(color, sq)\n                if defenders:\n                    score += 1.0 if p.piece_type == chess.KNIGHT else 0.7\n            return score\n        return float(outpost_score(chess.WHITE) - outpost_score(chess.BLACK))\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Minor vs major composition imbalance: (white - black) where positives favor having more minor-piece presence relative to majors'\n    try:\n        pm = board.piece_map()\n        def comp(color):\n            minors = 0\n            majors = 0\n            for p in pm.values():\n                if not p or p.color != color:\n                    continue\n                if p.piece_type in (chess.KNIGHT, chess.BISHOP):\n                    minors += 1\n                if p.piece_type in (chess.ROOK, chess.QUEEN):\n                    majors += 1\n            return minors, majors\n        wm, wM = comp(chess.WHITE)\n        bm, bM = comp(chess.BLACK)\n        # weight minors positively and majors negatively (since majors often decide but minors indicate rich middlegame)\n        return float((wm - bm) * 2.5 - (wM - bM) * 1.8)\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Queen centralization and vulnerability: centralization bonus minus penalty if attacked more than defended (white - black)'\n    try:\n        pm = board.piece_map()\n        centers = [chess.parse_square(s) for s in ('d4','e4','d5','e5')]\n        max_cent_dist = 6.0\n        def queen_score(color):\n            score = 0.0\n            for sq, p in pm.items():\n                if not p or p.color != color or p.piece_type != chess.QUEEN:\n                    continue\n                # distance to nearest center square (min Manhattan)\n                dmin = min(chess.square_distance(sq, c) for c in centers)\n                centerness = max(0.0, (max_cent_dist - float(dmin)) / max_cent_dist)\n                # safety: attacked vs defended\n                attackers = board.attackers(not color, sq)\n                defenders = board.attackers(color, sq)\n                vuln = max(0, len(attackers) - len(defenders))\n                score += 1.8 * centerness - 0.9 * vuln\n            return score\n        return float(queen_score(chess.WHITE) - queen_score(chess.BLACK))\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Immediate tactical initiative: difference in number of capture-or-check legal moves available to side to move (white - black) normalized'\n    try:\n        pm = board.piece_map()\n        orig_turn = board.turn\n        try:\n            def tactical_moves_for(color):\n                cnt = 0\n                board.turn = color\n                # iterate legal moves; count captures or checks\n                for mv in list(board.legal_moves):\n                    try:\n                        if board.is_capture(mv):\n                            cnt += 1\n                            continue\n                    except Exception:\n                        # fallback: destination occupied by opponent\n                        dst = pm.get(mv.to_square)\n                        if dst and dst.color != color:\n                            cnt += 1\n                            continue\n                    # check for checks by making move\n                    try:\n                        board.push(mv)\n                        if board.is_check():\n                            cnt += 1\n                        board.pop()\n                    except Exception:\n                        # if push/pop fails skip\n                        try:\n                            board.pop()\n                        except Exception:\n                            pass\n                return cnt\n            w_moves = tactical_moves_for(chess.WHITE)\n            b_moves = tactical_moves_for(chess.BLACK)\n        finally:\n            board.turn = orig_turn\n        total = max(1.0, float(w_moves + b_moves))\n        return float((w_moves - b_moves) / total)\n    except Exception:\n        return 0.0\n",
    "def feature(board: chess.Board) -> float:\n    'Pawn structure: isolated pawn count difference (white - black)'\n    try:\n        pm = board.piece_map()\n        pawns_by_file = {f: {chess.WHITE:0, chess.BLACK:0} for f in range(8)}\n        for sq, p in pm.items():\n            if p and p.piece_type == chess.PAWN:\n                pawns_by_file[chess.square_file(sq)][p.color] += 1\n        def isolated_count(color):\n            cnt = 0\n            for sq, p in pm.items():\n                if not p or p.piece_type != chess.PAWN or p.color != color:\n                    continue\n                f = chess.square_file(sq)\n                left = pawns_by_file[f-1][color] if f-1 >= 0 else 0\n                right = pawns_by_file[f+1][color] if f+1 <= 7 else 0\n                if left == 0 and right == 0:\n                    cnt += 1\n            return cnt\n        return float(isolated_count(chess.WHITE) - isolated_count(chess.BLACK))\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Passed pawns weighted by proximity to promotion (white - black)'\n    try:\n        pm = board.piece_map()\n        def is_passed(sq, color):\n            f = chess.square_file(sq); r = chess.square_rank(sq)\n            if color == chess.WHITE:\n                for bf_sq, p in pm.items():\n                    if p and p.piece_type == chess.PAWN and p.color == chess.BLACK:\n                        bf = chess.square_file(bf_sq); br = chess.square_rank(bf_sq)\n                        if abs(bf - f) <= 1 and br > r:\n                            return False\n                return True\n            else:\n                for wf_sq, p in pm.items():\n                    if p and p.piece_type == chess.PAWN and p.color == chess.WHITE:\n                        wf = chess.square_file(wf_sq); wr = chess.square_rank(wf_sq)\n                        if abs(wf - f) <= 1 and wr < r:\n                            return False\n                return True\n        score_w = 0.0; score_b = 0.0\n        for sq, p in pm.items():\n            if not p or p.piece_type != chess.PAWN:\n                continue\n            if is_passed(sq, p.color):\n                r = chess.square_rank(sq)\n                if p.color == chess.WHITE:\n                    dist = 7 - r\n                    progress = (7 - dist) / 7.0\n                    score_w += 1.0 + 0.9 * progress\n                else:\n                    dist = r\n                    progress = (7 - dist) / 7.0\n                    score_b += 1.0 + 0.9 * progress\n        return float(score_w - score_b)\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Bishop pair and mobility: bishop pair bonus plus attacked squares by bishops (white - black)'\n    try:\n        pm = board.piece_map()\n        def bishop_attack_count(sq):\n            # ray march along 4 diagonals until blocked\n            cnt = 0\n            f0 = chess.square_file(sq); r0 = chess.square_rank(sq)\n            for df, dr in ((1,1),(1,-1),(-1,1),(-1,-1)):\n                f = f0 + df; r = r0 + dr\n                while 0 <= f <= 7 and 0 <= r <= 7:\n                    cnt += 1\n                    if board.piece_at(chess.square(f, r)) is not None:\n                        break\n                    f += df; r += dr\n            return cnt\n        bw = 0; bb = 0\n        att_w = 0; att_b = 0\n        for sq, p in pm.items():\n            if not p or p.piece_type != chess.BISHOP:\n                continue\n            if p.color == chess.WHITE:\n                bw += 1\n                att_w += bishop_attack_count(sq)\n            else:\n                bb += 1\n                att_b += bishop_attack_count(sq)\n        pair_bonus_w = 0.75 if bw >= 2 else 0.0\n        pair_bonus_b = 0.75 if bb >= 2 else 0.0\n        return float((pair_bonus_w + 0.06 * att_w) - (pair_bonus_b + 0.06 * att_b))\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Knight outpost score: knights on forward protected squares not attackable by enemy pawns (white - black), weighted by centrality'\n    try:\n        pm = board.piece_map()\n        def centrality(sq):\n            f = chess.square_file(sq); r = chess.square_rank(sq)\n            df = abs(f - 3.5); dr = abs(r - 3.5)\n            d = df + dr\n            return max(0.0, (7.0 - d) / 7.0)\n        def score_for_color(color):\n            opp = chess.BLACK if color == chess.WHITE else chess.WHITE\n            s = 0.0\n            for sq, p in pm.items():\n                if not p or p.piece_type != chess.KNIGHT or p.color != color:\n                    continue\n                r = chess.square_rank(sq)\n                # require some forward presence (outpost on ranks >=3 for white, <=4 for black)\n                if color == chess.WHITE and r < 2:\n                    continue\n                if color == chess.BLACK and r > 5:\n                    continue\n                # check if square attacked by enemy pawn\n                attacked_by_opp = False\n                attackers = board.attackers(opp, sq)\n                for a in attackers:\n                    pa = pm.get(a)\n                    if pa and pa.piece_type == chess.PAWN:\n                        attacked_by_opp = True; break\n                # check defended by friendly pawn or piece\n                defended = any(True for a in board.attackers(color, sq))\n                if not attacked_by_opp and defended:\n                    s += 1.0 * centrality(sq)\n            return s\n        return float(score_for_color(chess.WHITE) - score_for_color(chess.BLACK))\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Pinned pieces count difference (white - black) where piece is linearly pinned to king by sliding enemy'\n    try:\n        pm = board.piece_map()\n        def sign(x): return (x > 0) - (x < 0)\n        def pinned_count(color):\n            cnt = 0\n            king_sq = next((sq for sq,p in pm.items() if p and p.piece_type==chess.KING and p.color==color), None)\n            if king_sq is None:\n                return 0\n            kf = chess.square_file(king_sq); kr = chess.square_rank(king_sq)\n            for sq, p in pm.items():\n                if not p or p.color != color or p.piece_type == chess.KING:\n                    continue\n                f = chess.square_file(sq); r = chess.square_rank(sq)\n                df = f - kf; dr = r - kr\n                # must be collinear\n                if df == 0:\n                    dirf, dirr = 0, sign(dr)\n                elif dr == 0:\n                    dirf, dirr = sign(df), 0\n                elif abs(df) == abs(dr):\n                    dirf, dirr = sign(df), sign(dr)\n                else:\n                    continue\n                # check no other pieces between piece and king\n                between_clear = True\n                tf, tr = f - dirf, r - dirr\n                while (tf, tr) != (kf, kr):\n                    if board.piece_at(chess.square(tf, tr)) is not None:\n                        between_clear = False; break\n                    tf -= dirf; tr -= dirr\n                if not between_clear:\n                    continue\n                # beyond the piece on the same line, check for enemy sliding attacker as first piece\n                tf, tr = f + dirf, r + dirr\n                while 0 <= tf <= 7 and 0 <= tr <= 7:\n                    occ = board.piece_at(chess.square(tf, tr))\n                    if occ:\n                        if occ.color != color:\n                            # is occ sliding and matches direction?\n                            if (dirf == 0 or dirr == 0) and occ.piece_type in (chess.ROOK, chess.QUEEN):\n                                cnt += 1\n                            elif (dirf != 0 and dirr != 0) and occ.piece_type in (chess.BISHOP, chess.QUEEN):\n                                cnt += 1\n                        break\n                    tf += dirf; tr += dirr\n            return cnt\n        return float(pinned_count(chess.WHITE) - pinned_count(chess.BLACK))\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Open and semi-open file control: rooks/queens on open files count +0.9, on semi-open files +0.45 (white - black)'\n    try:\n        pm = board.piece_map()\n        pawns_on_file = [ {chess.WHITE:0, chess.BLACK:0} for _ in range(8) ]\n        for sq, p in pm.items():\n            if p and p.piece_type == chess.PAWN:\n                pawns_on_file[chess.square_file(sq)][p.color] += 1\n        score_w = 0.0; score_b = 0.0\n        for sq, p in pm.items():\n            if not p or p.piece_type not in (chess.ROOK, chess.QUEEN):\n                continue\n            f = chess.square_file(sq)\n            pw = pawns_on_file[f][chess.WHITE]; pb = pawns_on_file[f][chess.BLACK]\n            if pw == 0 and pb == 0:\n                bonus = 0.9\n            elif (p.color == chess.WHITE and pw == 0 and pb > 0) or (p.color == chess.BLACK and pb == 0 and pw > 0):\n                bonus = 0.45\n            else:\n                bonus = 0.0\n            if p.color == chess.WHITE:\n                score_w += bonus\n            else:\n                score_b += bonus\n        return float(score_w - score_b)\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'King x-ray vulnerability: sliding enemy pieces aligned with king with exactly one intervening blocker (white - black)'\n    try:\n        pm = board.piece_map()\n        def sign(x): return (x > 0) - (x < 0)\n        def xray_score(color):\n            score = 0.0\n            king_sq = next((sq for sq,p in pm.items() if p and p.piece_type==chess.KING and p.color==color), None)\n            if king_sq is None:\n                return 0.0\n            kf = chess.square_file(king_sq); kr = chess.square_rank(king_sq)\n            opp = chess.BLACK if color == chess.WHITE else chess.WHITE\n            # for every sliding enemy piece, check alignment\n            for sq, p in pm.items():\n                if not p or p.color != opp or p.piece_type not in (chess.ROOK, chess.BISHOP, chess.QUEEN):\n                    continue\n                f = chess.square_file(sq); r = chess.square_rank(sq)\n                df = kf - f; dr = kr - r\n                if df == 0:\n                    dirf, dirr = 0, sign(dr)\n                elif dr == 0:\n                    dirf, dirr = sign(df), 0\n                elif abs(df) == abs(dr):\n                    dirf, dirr = sign(df), sign(dr)\n                else:\n                    continue\n                # count pieces between attacker and king\n                tf, tr = f + dirf, r + dirr\n                between = 0\n                while (tf, tr) != (kf, kr):\n                    if board.piece_at(chess.square(tf, tr)) is not None:\n                        between += 1\n                        if between > 1:\n                            break\n                    tf += dirf; tr += dirr\n                if between == 1:\n                    # one blocker between => potential x-ray/discovered attack\n                    score += 1.0\n                elif between == 0:\n                    # direct attack (countable too but less indicative of latent tactics)\n                    score += 0.4\n            return score\n        return float(xray_score(chess.WHITE) - xray_score(chess.BLACK))\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Closed-position factor * (knight_count - bishop_count): favors knights in blocked pawn structures (positive favors White)'\n    try:\n        pm = board.piece_map()\n        # compute closure metric: number of pawn pairs on adjacent files facing each other or blocking center\n        closure = 0\n        for f in range(7):\n            for r in range(8):\n                sq = chess.square(f, r); sqr = chess.square(f+1, r)\n                p1 = pm.get(sq); p2 = pm.get(sqr)\n                if p1 and p2 and p1.piece_type == chess.PAWN and p2.piece_type == chess.PAWN and p1.color != p2.color:\n                    closure += 1\n        # normalize closure roughly to [0..8]\n        closure_factor = min(1.0, closure / 6.0)\n        # count knights and bishops\n        counts = {chess.WHITE:{'N':0,'B':0}, chess.BLACK:{'N':0,'B':0}}\n        for p in pm.values():\n            if not p: continue\n            if p.piece_type == chess.KNIGHT:\n                counts[p.color]['N'] += 1\n            elif p.piece_type == chess.BISHOP:\n                counts[p.color]['B'] += 1\n        val_w = (counts[chess.WHITE]['N'] - counts[chess.WHITE]['B'])\n        val_b = (counts[chess.BLACK]['N'] - counts[chess.BLACK]['B'])\n        # if more closed, knights gain importance; otherwise neutralize\n        return float(closure_factor * (val_w - val_b))\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Undefended attacked material: sum of piece values where attackers > defenders (white - black)'\n    try:\n        pm = board.piece_map()\n        vals = {chess.PAWN:1.0, chess.KNIGHT:3.0, chess.BISHOP:3.0, chess.ROOK:5.0, chess.QUEEN:9.0, chess.KING:0.0}\n        score_w = 0.0; score_b = 0.0\n        for sq, p in pm.items():\n            if not p:\n                continue\n            color = p.color\n            opp = chess.BLACK if color == chess.WHITE else chess.WHITE\n            attackers = board.attackers(opp, sq)\n            defenders = board.attackers(color, sq)\n            num_attackers = sum(1 for a in attackers)\n            num_defenders = sum(1 for d in defenders)\n            if num_attackers > num_defenders:\n                penalty = vals.get(p.piece_type, 0.0) * (num_attackers - num_defenders)\n                if color == chess.WHITE:\n                    score_w -= penalty\n                else:\n                    score_b -= penalty\n        # return white minus black (more negative means white pieces more undefended)\n        return float(score_w - score_b)\n    except Exception:\n        return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Central control index: weighted attacks on central and extended-central squares (white - black)'\n    try:\n        pm = board.piece_map()\n        centers = [(3,3),(4,3),(3,4),(4,4)]  # d4,e4,d5,e5\n        extended = [(2,3),(5,3),(2,4),(5,4),(3,2),(4,2),(3,5),(4,5)]\n        score_w = 0.0; score_b = 0.0\n        for f,r in centers:\n            sq = chess.square(f,r)\n            aw = sum(1 for a in board.attackers(chess.WHITE, sq))\n            ab = sum(1 for a in board.attackers(chess.BLACK, sq))\n            score_w += 1.2 * aw\n            score_b += 1.2 * ab\n        for f,r in extended:\n            sq = chess.square(f,r)\n            aw = sum(1 for a in board.attackers(chess.WHITE, sq))\n            ab = sum(1 for a in board.attackers(chess.BLACK, sq))\n            score_w += 0.6 * aw\n            score_b += 0.6 * ab\n        # scale down to reasonable magnitude\n        return float((score_w - score_b) * 0.08)\n    except Exception:\n        return 0.0\n"
  ]
}