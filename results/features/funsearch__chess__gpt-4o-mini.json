{
  "used_features": [
    "def feature(board: chess.Board) -> float:\n    \"Calculates the material value difference between white and black.\"\n    material_values = {\n        chess.PAWN: 1,\n        chess.KNIGHT: 3,\n        chess.BISHOP: 3,\n        chess.ROOK: 5,\n        chess.QUEEN: 9,\n        chess.KING: 0  # King has no material value\n    }\n    white_material = sum(material_values[piece.piece_type] for piece in board.piece_map().values() if piece.color == chess.WHITE)\n    black_material = sum(material_values[piece.piece_type] for piece in board.piece_map().values() if piece.color == chess.BLACK)\n    return float(white_material - black_material)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Evaluates the number of pieces in play for each side.\"\n    white_piece_count = len([piece for piece in board.piece_map().values() if piece.color == chess.WHITE])\n    black_piece_count = len([piece for piece in board.piece_map().values() if piece.color == chess.BLACK])\n    return float(white_piece_count - black_piece_count)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of pawns each side has.\"\n    white_pawns = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE and piece.piece_type == chess.PAWN)\n    black_pawns = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK and piece.piece_type == chess.PAWN)\n    return float(white_pawns - black_pawns)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the control of the center squares (d4, d5, e4, e5) by each side.\"\n    center_squares = [chess.parse_square(sq) for sq in ['d4', 'd5', 'e4', 'e5']]\n    white_control = sum(1 for square in center_squares if board.is_attacked_by(chess.WHITE, square))\n    black_control = sum(1 for square in center_squares if board.is_attacked_by(chess.BLACK, square))\n    return float(white_control - black_control)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Checks if either side is in check and assigns values accordingly.\"\n    if board.is_check():\n        return -1.0\n    return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the number of legal moves available for the current player.\"\n    return float(len(list(board.legal_moves)))\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces attacking the opponent's king.\"\n    white_king_square = next(square for square, piece in board.piece_map().items() if piece.color == chess.WHITE and piece.piece_type == chess.KING)\n    black_king_square = next(square for square, piece in board.piece_map().items() if piece.color == chess.BLACK and piece.piece_type == chess.KING)\n    white_attackers = len(board.attackers(chess.WHITE, black_king_square))\n    black_attackers = len(board.attackers(chess.BLACK, white_king_square))\n    return float(white_attackers - black_attackers)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the advancement of pawns for each side.\"\n    white_advanced_pawns = sum(1 for square in board.piece_map() if board.piece_map()[square].color == chess.WHITE and chess.square_rank(square) > 4)\n    black_advanced_pawns = sum(1 for square in board.piece_map() if board.piece_map()[square].color == chess.BLACK and chess.square_rank(square) < 3)\n    return float(white_advanced_pawns - black_advanced_pawns)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Assess if the position is potentially a draw due to insufficient material.\"\n    return float(1.0 if board.is_insufficient_material() else 0.0)\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the number of pieces that are pinned by the opponent's pieces.\"\n    pinned_pieces = sum(1 for square, piece in board.piece_map().items() if piece.color == board.turn and any(board.is_attacked_by(not board.turn, square) for target_square in board.piece_map() if board.piece_map()[target_square].piece_type == chess.KING))\n    return float(pinned_pieces)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the potential passed pawns each side has.\"\n    def is_passed_pawn(square, color):\n        if color == chess.WHITE:\n            return all(board.piece_at(chess.square_file(square) + i) is None for i in range(1, 8) if chess.square_file(square) + i < 8)\n        else:\n            return all(board.piece_at(chess.square_file(square) - i) is None for i in range(1, 8) if chess.square_file(square) - i >= 0)\n    \n    white_passed = sum(1 for square in board.piece_map() if board.piece_map()[square].color == chess.WHITE and board.piece_map()[square].piece_type == chess.PAWN and is_passed_pawn(square, chess.WHITE))\n    black_passed = sum(1 for square in board.piece_map() if board.piece_map()[square].color == chess.BLACK and board.piece_map()[square].piece_type == chess.PAWN and is_passed_pawn(square, chess.BLACK))\n    \n    return float(white_passed - black_passed)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the mobility of knights for each player.\"\n    white_knight_mobility = sum(len(list(board.legal_moves)) for square in board.piece_map() if board.piece_map()[square].color == chess.WHITE and board.piece_map()[square].piece_type == chess.KNIGHT)\n    black_knight_mobility = sum(len(list(board.legal_moves)) for square in board.piece_map() if board.piece_map()[square].color == chess.BLACK and board.piece_map()[square].piece_type == chess.KNIGHT)\n    return float(white_knight_mobility - black_knight_mobility)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Evaluates the control of major files by rooks for both sides.\"\n    def rook_control(file, color):\n        return any(board.piece_at(square) and board.piece_at(square).color == color and board.piece_at(square).piece_type == chess.ROOK for square in range(file, 64, 8))\n    \n    white_control = sum(1 for file in range(8) if rook_control(file, chess.WHITE))\n    black_control = sum(1 for file in range(8) if rook_control(file, chess.BLACK))\n    return float(white_control - black_control)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Checks if there are threats to the opponent's major pieces.\"\n    threats = 0\n    for square, piece in board.piece_map().items():\n        if piece.color != board.turn and piece.piece_type in [chess.QUEEN, chess.ROOK, chess.BISHOP]:\n            if board.is_attacked_by(board.turn, square):\n                threats += 1\n    return float(threats)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in space control within the opponent's territory.\"\n    white_space_control = sum(1 for square in range(32, 64) if board.is_attacked_by(chess.WHITE, square))\n    black_space_control = sum(1 for square in range(0, 32) if board.is_attacked_by(chess.BLACK, square))\n    return float(white_space_control - black_space_control)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the development of pieces, determining which side has developed more pieces.\"\n    developed_pieces = {\n        chess.WHITE: sum(1 for square, piece in board.piece_map().items() if piece.color == chess.WHITE and (piece.piece_type in [chess.KNIGHT, chess.BISHOP] and chess.square_rank(square) > 1)),\n        chess.BLACK: sum(1 for square, piece in board.piece_map().items() if piece.color == chess.BLACK and (piece.piece_type in [chess.KNIGHT, chess.BISHOP] and chess.square_rank(square) < 6)),\n    }\n    return float(developed_pieces[chess.WHITE] - developed_pieces[chess.BLACK])\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the number of control squares for pieces in the back rank.\"\n    control_squares = sum(1 for square, piece in board.piece_map().items() if piece.color == board.turn and chess.square_rank(square) == (0 if piece.color == chess.BLACK else 7) and len(board.attackers(not board.turn, square)))\n    return float(control_squares)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the number of pieces on open files for both players.\"\n    open_files = [file for file in range(8) if all(board.piece_at(chess.square(file, rank)) is None for rank in range(8))]\n    white_open_file_pieces = sum(1 for square in board.piece_map() if square in [chess.square(file, rank) for file in open_files for rank in range(8)] and board.piece_map()[square].color == chess.WHITE)\n    black_open_file_pieces = sum(1 for square in board.piece_map() if square in [chess.square(file, rank) for file in open_files for rank in range(8)] and board.piece_map()[square].color == chess.BLACK)\n    return float(white_open_file_pieces - black_open_file_pieces)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the number of double pawns each side has.\"\n    white_double_pawns = sum(1 for file in range(8) if sum(1 for square in board.piece_map() if chess.square_file(square) == file and board.piece_map()[square].color == chess.WHITE and board.piece_map()[square].piece_type == chess.PAWN) > 1)\n    black_double_pawns = sum(1 for file in range(8) if sum(1 for square in board.piece_map() if chess.square_file(square) == file and board.piece_map()[square].color == chess.BLACK and board.piece_map()[square].piece_type == chess.PAWN) > 1)\n    return float(white_double_pawns - black_double_pawns)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Evaluates king safety by counting the number of squares around it that are safe.\"\n    king_square = next((square for square, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color == board.turn), None)\n    if king_square is None:\n        return 0.0\n    safe_squares = sum(1 for dx in (-1, 0, 1) for dy in (-1, 0, 1) if (dx != 0 or dy != 0) and 0 <= chess.square_file(king_square) + dx < 8 and 0 <= chess.square_rank(king_square) + dy < 8 and not board.is_attacked_by(not board.turn, chess.square(chess.square_file(king_square) + dx, chess.square_rank(king_square) + dy)))\n    return float(safe_squares)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of isolated pawns for each side.\"\n    isolated_pawns_white = sum(1 for square in board.piece_map() if board.piece_map()[square].color == chess.WHITE and board.piece_map()[square].piece_type == chess.PAWN and (board.piece_at(chess.square_file(square) - 1) is None and board.piece_at(chess.square_file(square) + 1) is None))\n    isolated_pawns_black = sum(1 for square in board.piece_map() if board.piece_map()[square].color == chess.BLACK and board.piece_map()[square].piece_type == chess.PAWN and (board.piece_at(chess.square_file(square) - 1) is None and board.piece_at(chess.square_file(square) + 1) is None))\n    return float(isolated_pawns_white - isolated_pawns_black)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the amount of control of key central squares.\"\n    central_squares = [chess.E4, chess.E5, chess.D4, chess.D5]\n    white_control = sum(1 for square in central_squares if board.is_attacked_by(chess.WHITE, square))\n    black_control = sum(1 for square in central_squares if board.is_attacked_by(chess.BLACK, square))\n    return float(white_control - black_control)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the potential threats against opponent's king based on proximity.\"\n    king_square = next(square for square, piece in board.piece_map().items() if piece.color != board.turn and piece.piece_type == chess.KING)\n    threats = sum(1 for square, piece in board.piece_map().items() if piece.color == board.turn and chess.square_distance(square, king_square) == 1)\n    return float(threats)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of opponent's pieces that can be easily captured without retaliation.\"\n    unprotected_threats = sum(1 for square, piece in board.piece_map().items() if piece.color != board.turn and not any(board.is_attacked_by(not board.turn, target_square) for target_square in board.attackers(board.turn, square)))\n    return float(unprotected_threats)\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the number of pieces each side has on the back rank.\"\n    white_back_rank_pieces = sum(1 for square in range(56, 64) if board.piece_at(square) and board.piece_at(square).color == chess.WHITE)\n    black_back_rank_pieces = sum(1 for square in range(0, 8) if board.piece_at(square) and board.piece_at(square).color == chess.BLACK)\n    return float(white_back_rank_pieces - black_back_rank_pieces)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the difference in the average distance of pieces from their respective back ranks.\"\n    white_distances = [7 - chess.square_rank(square) for square in board.piece_map() if board.piece_map()[square].color == chess.WHITE]\n    black_distances = [chess.square_rank(square) for square in board.piece_map() if board.piece_map()[square].color == chess.BLACK]\n    avg_white_distance = (sum(white_distances) / len(white_distances)) if white_distances else 0\n    avg_black_distance = (sum(black_distances) / len(black_distances)) if black_distances else 0\n    return float(avg_white_distance - avg_black_distance)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces on the board that are unprotected.\"\n    unprotected_pieces = sum(1 for square, piece in board.piece_map().items() if piece.color == board.turn and not any(board.is_attacked_by(not board.turn, target_square) for target_square in board.attackers(not board.turn, square)))\n    return float(unprotected_pieces)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the total number of squares controlled by each side.\"\n    white_controlled_squares = sum(1 for square in range(64) if board.is_attacked_by(chess.WHITE, square))\n    black_controlled_squares = sum(1 for square in range(64) if board.is_attacked_by(chess.BLACK, square))\n    return float(white_controlled_squares - black_controlled_squares)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the number of minor pieces (knights and bishops) each side has.\"\n    white_minor_pieces = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE and piece.piece_type in [chess.KNIGHT, chess.BISHOP])\n    black_minor_pieces = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK and piece.piece_type in [chess.KNIGHT, chess.BISHOP])\n    return float(white_minor_pieces - black_minor_pieces)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in pawns that have reached the opponent's 7th rank.\"\n    white_pawns_on_7th = sum(1 for square in board.piece_map() if board.piece_map()[square].color == chess.WHITE and chess.square_rank(square) == 6)\n    black_pawns_on_7th = sum(1 for square in board.piece_map() if board.piece_map()[square].color == chess.BLACK and chess.square_rank(square) == 1)\n    return float(white_pawns_on_7th - black_pawns_on_7th)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of squares that are attacked by both sides.\"\n    attacked_squares = len(set(square for square in range(64) if board.is_attacked_by(chess.WHITE, square) or board.is_attacked_by(chess.BLACK, square)))\n    return float(attacked_squares)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Detects if there is a potential of a back rank checkmate.\"\n    if board.is_checkmate():\n        return 0.0\n    white_back_rank_checkmate = any(board.is_attacked_by(chess.BLACK, square) for square in range(56, 64) if board.piece_at(square) and board.piece_at(square).color == chess.WHITE)\n    black_back_rank_checkmate = any(board.is_attacked_by(chess.WHITE, square) for square in range(0, 8) if board.piece_at(square) and board.piece_at(square).color == chess.BLACK)\n    return float(white_back_rank_checkmate - black_back_rank_checkmate)\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the number of pieces pinned against the king for both sides.\"\n    pinned_pieces = 0\n    for square, piece in board.piece_map().items():\n        if piece.piece_type != chess.KING and board.is_attacked_by(not piece.color, square):\n            # Check if the piece is pinned against their king\n            if board.is_attacked_by(piece.color, next(sq for sq, p in board.piece_map().items() if p.piece_type == chess.KING and p.color == piece.color)):\n                pinned_pieces += 1\n    return float(pinned_pieces)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of central squares controlled by each side.\"\n    central_squares = [chess.D4, chess.D5, chess.E4, chess.E5]\n    white_control = sum(1 for sq in central_squares if board.is_attacked_by(chess.WHITE, sq))\n    black_control = sum(1 for sq in central_squares if board.is_attacked_by(chess.BLACK, sq))\n    return float(white_control - black_control)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in mobility of the pieces for both players.\"\n    white_mobility = sum(len(list(board.legal_moves)) for square in board.piece_map() if board.piece_map()[square].color == chess.WHITE)\n    black_mobility = sum(len(list(board.legal_moves)) for square in board.piece_map() if board.piece_map()[square].color == chess.BLACK)\n    return float(white_mobility - black_mobility)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the presence of double pawns for both sides.\"\n    white_double_pawns = sum(1 for square in board.piece_map() if board.piece_map()[square].color == chess.WHITE and board.piece_map()[square].piece_type == chess.PAWN and len([s for s in range(8) if board.piece_at(s) and board.piece_at(s).color == chess.WHITE and chess.square_file(square) == chess.square_file(s)]) > 1)\n    black_double_pawns = sum(1 for square in board.piece_map() if board.piece_map()[square].color == chess.BLACK and board.piece_map()[square].piece_type == chess.PAWN and len([s for s in range(8) if board.piece_at(s) and board.piece_at(s).color == chess.BLACK and chess.square_file(square) == chess.square_file(s)]) > 1)\n    return float(white_double_pawns - black_double_pawns)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Evaluates the coordination of pieces attacking the same target.\"\n    attacking_pairs = 0\n    for square in range(64):\n        if board.is_attacked_by(chess.WHITE, square) and board.is_attacked_by(chess.BLACK, square):\n            attacking_pairs += len(board.attackers(chess.WHITE, square)) + len(board.attackers(chess.BLACK, square))\n    return float(attacking_pairs)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the number of discovered attacks for both colors.\"\n    discovered_attacks = 0\n    for square in board.piece_map():\n        piece = board.piece_map()[square]\n        for move in board.legal_moves:\n            if move.from_square == square:\n                target_piece = board.piece_at(move.to_square)\n                if target_piece and target_piece.color != piece.color and board.is_attacked_by(piece.color, move.to_square):\n                    discovered_attacks += 1\n    return float(discovered_attacks)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Evaluates the number of squares that are defended by multiple pieces.\"\n    defended_squares = sum(1 for square in range(64) if sum(1 for piece in board.piece_map().values() if board.is_attacked_by(piece.color, square)) > 1)\n    return float(defended_squares)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces on the back rank for each side.\"\n    back_rank_white = sum(1 for square in range(56, 64) if board.piece_at(square) and board.piece_at(square).color == chess.WHITE)\n    back_rank_black = sum(1 for square in range(0, 8) if board.piece_at(square) and board.piece_at(square).color == chess.BLACK)\n    return float(back_rank_white - back_rank_black)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the presence of pawns on the 7th rank for each side.\"\n    pawns_on_seventh_white = sum(1 for square in range(56, 64) if board.piece_at(square) and board.piece_at(square).color == chess.WHITE and board.piece_at(square).piece_type == chess.PAWN)\n    pawns_on_seventh_black = sum(1 for square in range(0, 8) if board.piece_at(square) and board.piece_at(square).color == chess.BLACK and board.piece_at(square).piece_type == chess.PAWN)\n    return float(pawns_on_seventh_white - pawns_on_seventh_black)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces attacking the opponent's king.\"\n    opponent_king_square = next((square for square, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color != board.turn), None)\n    if opponent_king_square is None:\n        return 0.0\n    attack_count = sum(1 for square in board.piece_map() if board.piece_map()[square].color == board.turn and board.is_attacked_by(board.turn, opponent_king_square))\n    return float(attack_count)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the presence of doubled pawns for each side.\"\n    doubled_pawns_white = sum(1 for square in board.piece_map() if board.piece_map()[square].color == chess.WHITE and \n                               board.piece_map()[square].piece_type == chess.PAWN and \n                               (board.piece_at(chess.square_file(square) + 8) is not None or board.piece_at(chess.square_file(square) - 8) is not None))\n    doubled_pawns_black = sum(1 for square in board.piece_map() if board.piece_map()[square].color == chess.BLACK and \n                               board.piece_map()[square].piece_type == chess.PAWN and \n                               (board.piece_at(chess.square_file(square) + 8) is not None or board.piece_at(chess.square_file(square) - 8) is not None))\n    return float(doubled_pawns_white - doubled_pawns_black)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the total material value for each side, normalized by the number of pieces.\"\n    material_values = {\n        chess.PAWN: 1,\n        chess.KNIGHT: 3,\n        chess.BISHOP: 3,\n        chess.ROOK: 5,\n        chess.QUEEN: 9,\n        chess.KING: 0\n    }\n    white_material = sum(material_values[piece.piece_type] for piece in board.piece_map().values() if piece.color == chess.WHITE)\n    black_material = sum(material_values[piece.piece_type] for piece in board.piece_map().values() if piece.color == chess.BLACK)\n    white_pieces_count = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE)\n    black_pieces_count = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK)\n    white_average = white_material / white_pieces_count if white_pieces_count > 0 else 0\n    black_average = black_material / black_pieces_count if black_pieces_count > 0 else 0\n    return float(white_average - black_average)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the amount of space controlled by pawns for both sides.\"\n    white_space_control = sum(1 for square in board.piece_map() if board.piece_map()[square].color == chess.WHITE and board.piece_map()[square].piece_type == chess.PAWN and \n                               (board.piece_at(square + 8) is None or board.piece_at(square + 8) is None))\n    black_space_control = sum(1 for square in board.piece_map() if board.piece_map()[square].color == chess.BLACK and board.piece_map()[square].piece_type == chess.PAWN and \n                               (board.piece_at(square - 8) is None or board.piece_at(square - 8) is None))\n    return float(white_space_control - black_space_control)\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the mobility advantage between the two sides.\"\n    white_mobility = len(list(board.legal_moves)) if board.turn == chess.WHITE else len(list(board.legal_moves))\n    black_mobility = len(list(board.legal_moves)) if board.turn == chess.BLACK else len(list(board.legal_moves))\n    return float(white_mobility - black_mobility)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the control of key central squares (d4, e4, d5, e5) for both sides.\"\n    center_squares = [chess.D4, chess.E4, chess.D5, chess.E5]\n    white_control = sum(1 for square in center_squares if board.is_attacked_by(chess.WHITE, square))\n    black_control = sum(1 for square in center_squares if board.is_attacked_by(chess.BLACK, square))\n    return float(white_control - black_control)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of undefended pieces on the board.\"\n    undefended_count = sum(1 for square, piece in board.piece_map().items() if piece.color == board.turn and not any(board.is_attacked_by(not piece.color, square) for attacked_square in board.attackers(not piece.color, square)))\n    return float(undefended_count)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the difference in bishop pair advantage.\"\n    white_bishops = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE and piece.piece_type == chess.BISHOP)\n    black_bishops = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK and piece.piece_type == chess.BISHOP)\n    return float(white_bishops - black_bishops)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in the number of rooks on open files.\"\n    open_files_white = sum(1 for square in range(56, 64) if board.piece_at(square) and board.piece_at(square).color == chess.WHITE and chess.square_file(square) != 0 and not any(board.piece_at(chess.square_file(square) + i) for i in range(1, 8)))\n    open_files_black = sum(1 for square in range(0, 8) if board.piece_at(square) and board.piece_at(square).color == chess.BLACK and chess.square_file(square) != 0 and not any(board.piece_at(chess.square_file(square) - i) for i in range(1, 8)))\n    return float(open_files_white - open_files_black)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the total number of threats posed by pieces on the board.\"\n    total_threats = sum(len(board.attackers(not piece.color, square)) for square, piece in board.piece_map().items())\n    return float(total_threats)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in piece activity by assessing piece positions relative to the center.\"\n    central_squares = [chess.D4, chess.E4, chess.D5, chess.E5]\n    white_active = sum(1 for square in board.piece_map() if board.piece_map()[square].color == chess.WHITE and square in central_squares)\n    black_active = sum(1 for square in board.piece_map() if board.piece_map()[square].color == chess.BLACK and square in central_squares)\n    return float(white_active - black_active)\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the difference in number of developed pieces for both players.\"\n    white_developed = sum(1 for square in board.piece_map() if board.piece_map()[square].color == chess.WHITE and chess.square_rank(square) > 1)\n    black_developed = sum(1 for square in board.piece_map() if board.piece_map()[square].color == chess.BLACK and chess.square_rank(square) < 6)\n    return float(white_developed - black_developed)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of rooks on open files for each side.\"\n    white_open_files = sum(1 for file in range(8) if all(board.piece_at(chess.square(file, rank)) is None for rank in range(8) if board.piece_at(chess.square(file, rank)) and board.piece_at(chess.square(file, rank)).color == chess.WHITE))\n    black_open_files = sum(1 for file in range(8) if all(board.piece_at(chess.square(file, rank)) is None for rank in range(8) if board.piece_at(chess.square(file, rank)) and board.piece_at(chess.square(file, rank)).color == chess.BLACK))\n    return float(white_open_files - black_open_files)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the total number of pieces attacking the opposing king.\"\n    white_attackers = sum(1 for square in board.piece_map() if board.piece_map()[square].color == chess.WHITE and board.is_attacked_by(chess.BLACK, square))\n    black_attackers = sum(1 for square in board.piece_map() if board.piece_map()[square].color == chess.BLACK and board.is_attacked_by(chess.WHITE, square))\n    return float(white_attackers - black_attackers)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces that are participating in threats to the opponent's pieces.\"\n    threats = sum(1 for square in board.piece_map() if board.is_attacked_by(not board.turn, square))\n    return float(threats)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in kings' safety based on the number of pawn shields.\"\n    white_shields = sum(1 for square in range(8) if board.piece_at(chess.square(square, 1)) and board.piece_at(chess.square(square, 1)).color == chess.WHITE)\n    black_shields = sum(1 for square in range(8) if board.piece_at(chess.square(square, 6)) and board.piece_at(chess.square(square, 6)).color == chess.BLACK)\n    return float(white_shields - black_shields)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the efficiency of piece placements near the opponent's king.\"\n    efficiency = sum(1 for square in board.piece_map() if board.piece_map()[square].color == board.turn and board.is_attacked_by(not board.turn, square))\n    return float(efficiency)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of advanced pawns for each side.\"\n    advanced_white = sum(1 for square in board.piece_map() if board.piece_map()[square].color == chess.WHITE and board.piece_map()[square].piece_type == chess.PAWN and chess.square_rank(square) > 4)\n    advanced_black = sum(1 for square in board.piece_map() if board.piece_map()[square].color == chess.BLACK and board.piece_map()[square].piece_type == chess.PAWN and chess.square_rank(square) < 3)\n    return float(advanced_white - advanced_black)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the difference in activity of rooks on open files.\"\n    white_rook_files = {chess.square_file(square) for square in board.piece_map() if board.piece_map()[square].color == chess.WHITE and board.piece_map()[square].piece_type == chess.ROOK}\n    black_rook_files = {chess.square_file(square) for square in board.piece_map() if board.piece_map()[square].color == chess.BLACK and board.piece_map()[square].piece_type == chess.ROOK}\n    return float(len(white_rook_files) - len(black_rook_files))\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the difference in king safety based on the number of attacking squares around each king.\"\n    white_king_square = next(square for square in board.piece_map() if board.piece_map()[square].color == chess.WHITE and board.piece_map()[square].piece_type == chess.KING)\n    black_king_square = next(square for square in board.piece_map() if board.piece_map()[square].color == chess.BLACK and board.piece_map()[square].piece_type == chess.KING)\n\n    white_attack_count = sum(1 for square in chess.SQUARES_180 if board.is_attacked_by(chess.BLACK, square) and board.is_attacked_by(chess.BLACK, white_king_square))\n    black_attack_count = sum(1 for square in chess.SQUARES_180 if board.is_attacked_by(chess.WHITE, square) and board.is_attacked_by(chess.WHITE, black_king_square))\n\n    return float(white_attack_count - black_attack_count)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in the number of pieces near the corners for each side.\"\n    def pieces_in_corners(color):\n        corner_squares = [chess.A1, chess.A8, chess.H1, chess.H8]\n        return sum(1 for square in corner_squares if board.piece_at(square) and board.piece_at(square).color == color)\n\n    white_corners = pieces_in_corners(chess.WHITE)\n    black_corners = pieces_in_corners(chess.BLACK)\n    return float(white_corners - black_corners)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of isolated pawns for both sides.\"\n    def is_isolated(square, color):\n        pawn_file = chess.square_file(square)\n        return (board.piece_at(square).piece_type == chess.PAWN and \n                not (board.piece_at(chess.parse_square(chess.square_name(square).replace(str(chess.square_rank(square)), str(chess.square_rank(square) + 1))) or None) or\n                     board.piece_at(chess.parse_square(chess.square_name(square).replace(str(chess.square_rank(square)), str(chess.square_rank(square) - 1))) or None)))\n\n    isolated_white = sum(1 for square in board.piece_map() if board.piece_map()[square].color == chess.WHITE and is_isolated(square, chess.WHITE))\n    isolated_black = sum(1 for square in board.piece_map() if board.piece_map()[square].color == chess.BLACK and is_isolated(square, chess.BLACK))\n    return float(isolated_white - isolated_black)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in mobility of knights for each side.\"\n    def knight_mobility(color):\n        return sum(len([move for move in board.legal_moves if move.from_square == square]) for square in board.piece_map() if board.piece_map()[square].color == color and board.piece_map()[square].piece_type == chess.KNIGHT)\n\n    white_mobility = knight_mobility(chess.WHITE)\n    black_mobility = knight_mobility(chess.BLACK)\n    return float(white_mobility - black_mobility)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the king's safety by counting the number of pawns that protect it.\"\n    king_square = next(square for square, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color == board.turn)\n    protecting_pawns = sum(1 for square in range(64) if board.piece_at(square) and board.piece_at(square).piece_type == chess.PAWN and \n                           abs(chess.square_file(square) - chess.square_file(king_square)) <= 1 and \n                           abs(chess.square_rank(square) - chess.square_rank(king_square)) <= 1)\n    return float(protecting_pawns)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the potential mobility of rooks based on the number of open files.\"\n    open_files = sum(1 for file in range(8) if all(board.piece_at(file + rank * 8) is None for rank in range(8)))\n    return float(open_files)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Evaluates the center control by counting pieces in central squares.\"\n    central_squares = [chess.D4, chess.E4, chess.D5, chess.E5]\n    white_control = sum(1 for square in central_squares if board.piece_at(square) and board.piece_at(square).color == chess.WHITE)\n    black_control = sum(1 for square in central_squares if board.piece_at(square) and board.piece_at(square).color == chess.BLACK)\n    return float(white_control - black_control)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Assesses the difference in the number of pieces on the seventh rank.\"\n    white_seventh_rank_pieces = sum(1 for square in range(56, 64) if board.piece_at(square) and board.piece_at(square).color == chess.WHITE)\n    black_seventh_rank_pieces = sum(1 for square in range(0, 8) if board.piece_at(square) and board.piece_at(square).color == chess.BLACK)\n    return float(white_seventh_rank_pieces - black_seventh_rank_pieces)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of hanging pieces for each side.\"\n    hanging_white = sum(1 for square in board.piece_map() if board.piece_map()[square].color == chess.WHITE and \n                         not any(board.is_attacked_by(chess.BLACK, square) for move in board.legal_moves if move.from_square == square))\n    hanging_black = sum(1 for square in board.piece_map() if board.piece_map()[square].color == chess.BLACK and \n                         not any(board.is_attacked_by(chess.WHITE, square) for move in board.legal_moves if move.from_square == square))\n    return float(hanging_white - hanging_black)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Evaluates the balance of minor pieces by comparing the number of knights and bishops for each side.\"\n    white_knights = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE and piece.piece_type == chess.KNIGHT)\n    white_bishops = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE and piece.piece_type == chess.BISHOP)\n    black_knights = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK and piece.piece_type == chess.KNIGHT)\n    black_bishops = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK and piece.piece_type == chess.BISHOP)\n    return float((white_knights + white_bishops) - (black_knights + black_bishops))\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the total number of legal moves available to both sides.\"\n    white_moves = len(list(board.legal_moves))\n    black_moves = len(list(board.legal_moves))\n    return float(white_moves - black_moves)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the total number of pieces in the center 4 squares for each side.\"\n    center_squares = [chess.D4, chess.D5, chess.E4, chess.E5]\n    white_center_count = sum(1 for square in center_squares if board.piece_at(square) and board.piece_at(square).color == chess.WHITE)\n    black_center_count = sum(1 for square in center_squares if board.piece_at(square) and board.piece_at(square).color == chess.BLACK)\n    return float(white_center_count - black_center_count)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the number of back rank threats for each side.\"\n    white_back_rank_threats = sum(1 for square in chess.SQUARES_180 if board.is_attacked_by(chess.BLACK, square) and (chess.square_rank(square) == 0))\n    black_back_rank_threats = sum(1 for square in chess.SQUARES_180 if board.is_attacked_by(chess.WHITE, square) and (chess.square_rank(square) == 7))\n    return float(white_back_rank_threats - black_back_rank_threats)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the number of pawns in the opponent's half of the board for each side.\"\n    white_pawn_authority = sum(1 for square in board.piece_map() if board.piece_map()[square].color == chess.WHITE and board.piece_map()[square].piece_type == chess.PAWN and chess.square_rank(square) > 4)\n    black_pawn_authority = sum(1 for square in board.piece_map() if board.piece_map()[square].color == chess.BLACK and board.piece_map()[square].piece_type == chess.PAWN and chess.square_rank(square) < 3)\n    return float(white_pawn_authority - black_pawn_authority)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the number of pieces on the last rank for each side.\"\n    white_last_rank_pieces = sum(1 for square in board.piece_map() if board.piece_map()[square].color == chess.WHITE and chess.square_rank(square) == 7)\n    black_last_rank_pieces = sum(1 for square in board.piece_map() if board.piece_map()[square].color == chess.BLACK and chess.square_rank(square) == 0)\n    return float(white_last_rank_pieces - black_last_rank_pieces)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the material advantage controlled by rooks on open files for each side.\"\n    open_files = [file for file in range(8) if all(board.piece_at(chess.square(file, rank)) is None for rank in range(8))]\n    white_rooks_on_open_files = sum(1 for square in board.piece_map() if square in [chess.square(file, rank) for file in open_files for rank in range(8)] and board.piece_map()[square].color == chess.WHITE and board.piece_map()[square].piece_type == chess.ROOK)\n    black_rooks_on_open_files = sum(1 for square in board.piece_map() if square in [chess.square(file, rank) for file in open_files for rank in range(8)] and board.piece_map()[square].color == chess.BLACK and board.piece_map()[square].piece_type == chess.ROOK)\n    return float(white_rooks_on_open_files - black_rooks_on_open_files)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the edge piece mobility by counting pieces on the a and h files.\"\n    white_edge_pieces = sum(1 for square in board.piece_map() if board.piece_map()[square].color == chess.WHITE and chess.square_file(square) in (0, 7))\n    black_edge_pieces = sum(1 for square in board.piece_map() if board.piece_map()[square].color == chess.BLACK and chess.square_file(square) in (0, 7))\n    return float(white_edge_pieces - black_edge_pieces)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the activity score based on the number of pieces that can immediately attack the opponent's king.\"\n    white_king_square = next(square for square in board.piece_map() if board.piece_map()[square].color == chess.WHITE and board.piece_map()[square].piece_type == chess.KING)\n    black_king_square = next(square for square in board.piece_map() if board.piece_map()[square].color == chess.BLACK and board.piece_map()[square].piece_type == chess.KING)\n    \n    white_attacking_pieces = sum(1 for square in board.piece_map() if board.piece_map()[square].color == chess.WHITE and (board.is_attacked_by(chess.BLACK, square) and board.is_attacked_by(chess.BLACK, white_king_square)))\n    black_attacking_pieces = sum(1 for square in board.piece_map() if board.piece_map()[square].color == chess.BLACK and (board.is_attacked_by(chess.WHITE, square) and board.is_attacked_by(chess.WHITE, black_king_square)))\n    \n    return float(white_attacking_pieces - black_attacking_pieces)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of connected pieces for each side, contributing to control and structure.\"\n    connected_white = sum(1 for square in board.piece_map() if board.piece_map()[square].color == chess.WHITE and (chess.square_file(square) > 0 and chess.square_file(square) < 7))\n    connected_black = sum(1 for square in board.piece_map() if board.piece_map()[square].color == chess.BLACK and (chess.square_file(square) > 0 and chess.square_file(square) < 7))\n    return float(connected_white - connected_black)\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces on the 7th and 2nd ranks.\"\n    white_on_7th = sum(1 for square in board.piece_map() if board.piece_map()[square].color == chess.WHITE and chess.square_rank(square) == 6)\n    black_on_2nd = sum(1 for square in board.piece_map() if board.piece_map()[square].color == chess.BLACK and chess.square_rank(square) == 1)\n    \n    return float(white_on_7th - black_on_2nd)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in king safety based on the number of squares around the king that are controlled by the opponent.\"\n    white_king_pos = next(square for square in board.piece_map() if board.piece_map()[square].color == chess.WHITE and board.piece_map()[square].piece_type == chess.KING)\n    black_king_pos = next(square for square in board.piece_map() if board.piece_map()[square].color == chess.BLACK and board.piece_map()[square].piece_type == chess.KING)\n    \n    white_threats = sum(board.is_attacked_by(chess.BLACK, square) for square in chess.SQUARES)\n    black_threats = sum(board.is_attacked_by(chess.WHITE, square) for square in chess.SQUARES)\n    \n    return float(black_threats - white_threats)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the number of pieces that are pinning the opponent's pieces.\"\n    white_pins = sum(1 for square in board.piece_map() if board.piece_map()[square].color == chess.WHITE and \n                     any(board.is_attacked_by(chess.BLACK, square) for _ in board.legal_moves if board.is_check() and board.piece_at(square).piece_type != chess.KING))\n    \n    black_pins = sum(1 for square in board.piece_map() if board.piece_map()[square].color == chess.BLACK and \n                     any(board.is_attacked_by(chess.WHITE, square) for _ in board.legal_moves if board.is_check() and board.piece_at(square).piece_type != chess.KING))\n    \n    return float(white_pins - black_pins)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the total piece activity by measuring the number of legal moves available for each side.\"\n    white_legal_moves = len(list(board.legal_moves)) \n    black_legal_moves = len(list(board.legal_moves))\n    \n    return float(white_legal_moves - black_legal_moves)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the mobility of pieces based on central control.\"\n    central_sq_white = sum(1 for square in board.piece_map() if board.piece_map()[square].color == chess.WHITE and \n                            chess.square_file(square) in (3, 4) and chess.square_rank(square) in (3, 4))\n    \n    central_sq_black = sum(1 for square in board.piece_map() if board.piece_map()[square].color == chess.BLACK and \n                            chess.square_file(square) in (3, 4) and chess.square_rank(square) in (3, 4))\n    \n    return float(central_sq_white - central_sq_black)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in development between both sides' pieces.\"\n    white_developed = sum(1 for square in board.piece_map() if board.piece_map()[square].color == chess.WHITE and \n                          (chess.square_rank(square) > 1 or chess.square_file(square) > 1))\n    \n    black_developed = sum(1 for square in board.piece_map() if board.piece_map()[square].color == chess.BLACK and \n                          (chess.square_rank(square) < 6 or chess.square_file(square) < 6))\n    \n    return float(white_developed - black_developed)\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of minor pieces (knights and bishops) each side has.\"\n    white_minors = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE and piece.piece_type in [chess.KNIGHT, chess.BISHOP])\n    black_minors = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK and piece.piece_type in [chess.KNIGHT, chess.BISHOP])\n    return float(white_minors - black_minors)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the number of tempo moves available for each player.\"\n    white_tempo_moves = sum(1 for move in board.legal_moves if board.turn is True)\n    black_tempo_moves = sum(1 for move in board.legal_moves if board.turn is False)\n    return float(white_tempo_moves - black_tempo_moves)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the total number of pieces attacking the opponent's pieces.\"\n    white_attack_count = sum(1 for square in board.piece_map() if board.piece_map()[square].color == chess.WHITE for attack_square in board.attackers(chess.BLACK, square) if attack_square)\n    black_attack_count = sum(1 for square in board.piece_map() if board.piece_map()[square].color == chess.BLACK for attack_square in board.attackers(chess.WHITE, square) if attack_square)\n    return float(white_attack_count - black_attack_count)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the distance of pawns to promotion for each player.\"\n    white_pawn_distance = sum(7 - chess.square_rank(square) for square in board.piece_map() if board.piece_map()[square].color == chess.WHITE and board.piece_map()[square].piece_type == chess.PAWN)\n    black_pawn_distance = sum(chess.square_rank(square) for square in board.piece_map() if board.piece_map()[square].color == chess.BLACK and board.piece_map()[square].piece_type == chess.PAWN)\n    return float(white_pawn_distance - black_pawn_distance)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces attacking the center squares.\"\n    center_squares = [chess.D4, chess.D5, chess.E4, chess.E5]\n    white_center_attack = sum(1 for square in center_squares if board.is_attacked_by(chess.WHITE, square))\n    black_center_attack = sum(1 for square in center_squares if board.is_attacked_by(chess.BLACK, square))\n    return float(white_center_attack - black_center_attack)\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the number of active pieces for each side, defined as pieces that can move without being blocked.\"\n    active_white_pieces = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE and len(list(board.legal_moves)) > 0)\n    active_black_pieces = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK and len(list(board.legal_moves)) > 0)\n    return float(active_white_pieces - active_black_pieces)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces that are pinned by the opponent.\"\n    pinned_white = sum(1 for square, piece in board.piece_map().items() if piece.color == chess.WHITE and any(board.is_attacked_by(chess.BLACK, square) for square in board.attackers(chess.BLACK, square)))\n    pinned_black = sum(1 for square, piece in board.piece_map().items() if piece.color == chess.BLACK and any(board.is_attacked_by(chess.WHITE, square) for square in board.attackers(chess.WHITE, square)))\n    return float(pinned_white - pinned_black)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Evaluates the king's safety based on the number of pieces defending it.\"\n    white_king_square = next((square for square in board.piece_map() if board.piece_map()[square].color == chess.WHITE and board.piece_map()[square].piece_type == chess.KING), None)\n    black_king_square = next((square for square in board.piece_map() if board.piece_map()[square].color == chess.BLACK and board.piece_map()[square].piece_type == chess.KING), None)\n    white_defenders = len(board.attackers(chess.WHITE, white_king_square)) if white_king_square else 0\n    black_defenders = len(board.attackers(chess.BLACK, black_king_square)) if black_king_square else 0\n    return float(white_defenders - black_defenders)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of squares available for the pieces of each side (mobility).\"\n    white_mobility = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE and len(list(board.legal_moves)) > 0)\n    black_mobility = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK and len(list(board.legal_moves)) > 0)\n    return float(white_mobility - black_mobility)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the concentration of pieces in the center (d4, d5, e4, e5) for each side.\"\n    center_squares = [chess.parse_square('d4'), chess.parse_square('d5'), chess.parse_square('e4'), chess.parse_square('e5')]\n    white_center_control = sum(1 for square in center_squares if board.piece_at(square) and board.piece_at(square).color == chess.WHITE)\n    black_center_control = sum(1 for square in center_squares if board.piece_at(square) and board.piece_at(square).color == chess.BLACK)\n    return float(white_center_control - black_center_control)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the number of outposts for knights for each side.\"\n    white_outposts = sum(1 for square in board.piece_map() if board.piece_map()[square].color == chess.WHITE and board.piece_map()[square].piece_type == chess.KNIGHT and chess.square_rank(square) in [5, 6])\n    black_outposts = sum(1 for square in board.piece_map() if board.piece_map()[square].color == chess.BLACK and board.piece_map()[square].piece_type == chess.KNIGHT and chess.square_rank(square) in [2, 3])\n    return float(white_outposts - black_outposts)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of rooks on the same file for each side.\"\n    rooks_per_file_white = [0] * 8\n    rooks_per_file_black = [0] * 8\n    for square in board.piece_map():\n        piece = board.piece_map()[square]\n        if piece.color == chess.WHITE and piece.piece_type == chess.ROOK:\n            rooks_per_file_white[chess.square_file(square)] += 1\n        elif piece.color == chess.BLACK and piece.piece_type == chess.ROOK:\n            rooks_per_file_black[chess.square_file(square)] += 1\n    return float(max(rooks_per_file_white) - max(rooks_per_file_black))\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the position of pawns in relation to the opponent's back rank.\"\n    white_advanced_pawns = sum(1 for square in board.piece_map() if board.piece_map()[square].color == chess.WHITE and board.piece_map()[square].piece_type == chess.PAWN and chess.square_rank(square) >= 4)\n    black_advanced_pawns = sum(1 for square in board.piece_map() if board.piece_map()[square].color == chess.BLACK and board.piece_map()[square].piece_type == chess.PAWN and chess.square_rank(square) <= 3)\n    return float(white_advanced_pawns - black_advanced_pawns)\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the balance of remaining pieces compared to the maximum possible.\"\n    total_pieces = len(board.piece_map())\n    total_possible = 32  # 16 per side at the start\n    return float((total_possible - total_pieces) / total_possible)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces on the back rank for each color.\"\n    white_back_rank = sum(1 for square in range(0, 8) if board.piece_at(chess.square(square, 0)) and board.piece_at(chess.square(square, 0)).color == chess.WHITE)\n    black_back_rank = sum(1 for square in range(0, 8) if board.piece_at(chess.square(square, 7)) and board.piece_at(chess.square(square, 7)).color == chess.BLACK)\n    return float(white_back_rank - black_back_rank)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the number of pieces in opponent's territory for each side.\"\n    white_in_opponent_territory = sum(1 for square in board.piece_map() if board.piece_map()[square].color == chess.WHITE and chess.square_rank(square) >= 4)\n    black_in_opponent_territory = sum(1 for square in board.piece_map() if board.piece_map()[square].color == chess.BLACK and chess.square_rank(square) <= 3)\n    return float(white_in_opponent_territory - black_in_opponent_territory)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the number of pieces that are pinned by each side.\"\n    def is_pinned(color):\n        pinned_count = 0\n        for square in board.piece_map():\n            piece = board.piece_map()[square]\n            if piece.color == color:\n                if board.is_attacked_by(not color, square):\n                    pinned_count += 1\n        return pinned_count\n\n    white_pinned = is_pinned(chess.WHITE)\n    black_pinned = is_pinned(chess.BLACK)\n    return float(white_pinned - black_pinned)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the mobility of major pieces (rooks and queens) for each side.\"\n    white_major_mobility = sum(len([move for move in board.legal_moves if move.from_square == square]) \n                                for square in board.piece_map() if board.piece_map()[square].color == chess.WHITE and \n                                board.piece_map()[square].piece_type in {chess.ROOK, chess.QUEEN})\n    black_major_mobility = sum(len([move for move in board.legal_moves if move.from_square == square]) \n                                for square in board.piece_map() if board.piece_map()[square].color == chess.BLACK and \n                                board.piece_map()[square].piece_type in {chess.ROOK, chess.QUEEN})\n    return float(white_major_mobility - black_major_mobility)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of squares available to knights for each side.\"\n    def knight_moves(square):\n        knight_moves = [\n            (2, 1), (2, -1), (-2, 1), (-2, -1),\n            (1, 2), (1, -2), (-1, 2), (-1, -2)\n        ]\n        return sum(1 for dx, dy in knight_moves if 0 <= chess.square_file(square) + dx < 8 and \n                   0 <= chess.square_rank(square) + dy < 8)\n\n    white_knight_squares = sum(knight_moves(square) for square in board.piece_map() if board.piece_map()[square].color == chess.WHITE and board.piece_map()[square].piece_type == chess.KNIGHT)\n    black_knight_squares = sum(knight_moves(square) for square in board.piece_map() if board.piece_map()[square].color == chess.BLACK and board.piece_map()[square].piece_type == chess.KNIGHT)\n    return float(white_knight_squares - black_knight_squares)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Evaluates the presence of isolated pawns for each side.\"\n    def isolated_pawn_count(color):\n        count = 0\n        for square in chess.SQUARES:\n            piece = board.piece_at(square)\n            if piece and piece.color == color and piece.piece_type == chess.PAWN:\n                file = chess.square_file(square)\n                if (file > 0 and board.piece_at(chess.square(file - 1, chess.square_rank(square))) is None) and \\\n                   (file < 7 and board.piece_at(chess.square(file + 1, chess.square_rank(square))) is None):\n                    count += 1\n        return count\n\n    white_isolated = isolated_pawn_count(chess.WHITE)\n    black_isolated = isolated_pawn_count(chess.BLACK)\n    return float(white_isolated - black_isolated)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the average distance of pieces from the center of the board for each side.\"\n    def average_piece_distance(color):\n        total_distance = 0\n        piece_count = 0\n        for square in board.piece_map():\n            piece = board.piece_map()[square]\n            if piece.color == color:\n                total_distance += chess.square_distance(square, chess.square(4, 4))\n                piece_count += 1\n        return total_distance / piece_count if piece_count > 0 else 0\n\n    white_avg_distance = average_piece_distance(chess.WHITE)\n    black_avg_distance = average_piece_distance(chess.BLACK)\n    return float(white_avg_distance - black_avg_distance)\n",
    "def feature(board: chess.Board) -> float:\n    'Calculates the difference in active pieces (pieces that can move) for each side.'\n    white_active_pieces = sum(1 for move in board.legal_moves if board.piece_at(move.from_square).color == chess.WHITE)\n    black_active_pieces = sum(1 for move in board.legal_moves if board.piece_at(move.from_square).color == chess.BLACK)\n    return float(white_active_pieces - black_active_pieces)\n\n",
    "def feature(board: chess.Board) -> float:\n    'Measures the number of doubled pawns for each side.'\n    white_doubled_pawns = sum(1 for file in range(8) if sum(1 for rank in range(8) if board.piece_at(chess.square(file, rank)) == chess.PAWN and piece.color == chess.WHITE) > 1)\n    black_doubled_pawns = sum(1 for file in range(8) if sum(1 for rank in range(8) if board.piece_at(chess.square(file, rank)) == chess.PAWN and piece.color == chess.BLACK) > 1)\n    return float(white_doubled_pawns - black_doubled_pawns)\n\n",
    "def feature(board: chess.Board) -> float:\n    'Calculates the difference in central control between both sides.'\n    central_control_white = sum(1 for square in [chess.D4, chess.D5, chess.E4, chess.E5] if board.is_attacked_by(chess.WHITE, square))\n    central_control_black = sum(1 for square in [chess.D4, chess.D5, chess.E4, chess.E5] if board.is_attacked_by(chess.BLACK, square))\n    return float(central_control_white - central_control_black)\n\n",
    "def feature(board: chess.Board) -> float:\n    'Measures the number of pieces pinned by each side.'\n    def count_pins(color):\n        return sum(1 for square in board.piece_map() if board.piece_map()[square].color == color and any(board.is_attacked_by(not color, pin_square) for pin_square in board.attackers(color, square)))\n    white_pins = count_pins(chess.WHITE)\n    black_pins = count_pins(chess.BLACK)\n    return float(white_pins - black_pins)\n\n",
    "def feature(board: chess.Board) -> float:\n    'Calculates the effect of pawn structure; number of isolated pawns for each side.'\n    def count_isolated_pawns(color):\n        return sum(1 for file in range(8) if board.piece_at(chess.square(file, 1 if color == chess.WHITE else 6)) == chess.PAWN and (file == 0 or not board.piece_at(chess.square(file - 1, 1 if color == chess.WHITE else 6)) == chess.PAWN) and (file == 7 or not board.piece_at(chess.square(file + 1, 1 if color == chess.WHITE else 6)) == chess.PAWN))\n    white_isolated_pawns = count_isolated_pawns(chess.WHITE)\n    black_isolated_pawns = count_isolated_pawns(chess.BLACK)\n    return float(white_isolated_pawns - black_isolated_pawns)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in material value of pieces beyond the 7th rank.\"\n    material_values = {\n        chess.PAWN: 1,\n        chess.KNIGHT: 3,\n        chess.BISHOP: 3,\n        chess.ROOK: 5,\n        chess.QUEEN: 9,\n        chess.KING: 0\n    }\n    white_material = sum(material_values[piece.piece_type] for square, piece in board.piece_map().items() if piece.color == chess.WHITE and chess.square_rank(square) >= 7)\n    black_material = sum(material_values[piece.piece_type] for square, piece in board.piece_map().items() if piece.color == chess.BLACK and chess.square_rank(square) <= 1)\n    return float(white_material - black_material)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the number of advanced pawns for both sides.\"\n    white_advanced_pawns = sum(1 for square, piece in board.piece_map().items() if piece.color == chess.WHITE and piece.piece_type == chess.PAWN and chess.square_rank(square) >= 5)\n    black_advanced_pawns = sum(1 for square, piece in board.piece_map().items() if piece.color == chess.BLACK and piece.piece_type == chess.PAWN and chess.square_rank(square) <= 3)\n    return float(white_advanced_pawns - black_advanced_pawns)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the disparity in the number of pieces each side has on the 7th and 8th ranks.\"\n    white_pieces_on_ranks = sum(1 for square, piece in board.piece_map().items() if piece.color == chess.WHITE and chess.square_rank(square) >= 6)\n    black_pieces_on_ranks = sum(1 for square, piece in board.piece_map().items() if piece.color == chess.BLACK and chess.square_rank(square) <= 1)\n    return float(white_pieces_on_ranks - black_pieces_on_ranks)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the number of critical squares attacked by each side.\"\n    critical_squares = [chess.D4, chess.E4, chess.D5, chess.E5, chess.C5, chess.C4, chess.F4, chess.F5]\n    white_control = sum(1 for square in critical_squares if board.is_attacked_by(chess.WHITE, square))\n    black_control = sum(1 for square in critical_squares if board.is_attacked_by(chess.BLACK, square))\n    return float(white_control - black_control)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of major pieces (rooks and queens) each side controls.\"\n    white_major = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE and piece.piece_type in {chess.ROOK, chess.QUEEN})\n    black_major = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK and piece.piece_type in {chess.ROOK, chess.QUEEN})\n    return float(white_major - black_major)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the safety of kings by assessing available escape squares.\"\n    def king_safety(color):\n        king_square = next(square for square, piece in board.piece_map().items() if piece.color == color and piece.piece_type == chess.KING)\n        return sum(1 for move in board.legal_moves if chess.square_distance(king_square, move.to_square) == 1)\n    white_safety = king_safety(chess.WHITE)\n    black_safety = king_safety(chess.BLACK)\n    return float(white_safety - black_safety)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the number of doubled pawns for both sides.\"\n    def count_doubled_pawns(color):\n        pawn_files = {}\n        for square, piece in board.piece_map().items():\n            if piece.color == color and piece.piece_type == chess.PAWN:\n                file = chess.square_file(square)\n                pawn_files[file] = pawn_files.get(file, 0) + 1\n        return sum(count - 1 for count in pawn_files.values() if count > 1)\n    white_doubled = count_doubled_pawns(chess.WHITE)\n    black_doubled = count_doubled_pawns(chess.BLACK)\n    return float(white_doubled - black_doubled)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in the number of pieces that are pinned against the opponent's king.\"\n    white_pinned = sum(1 for square in board.piece_map() if board.piece_map()[square].color == chess.WHITE and board.is_attacked_by(chess.BLACK, square))\n    black_pinned = sum(1 for square in board.piece_map() if board.piece_map()[square].color == chess.BLACK and board.is_attacked_by(chess.WHITE, square))\n    return float(white_pinned - black_pinned)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the mobility of pieces by counting the number of squares each piece can move to.\"\n    def count_mobility(color):\n        return sum(len(list(board.legal_moves)) for key, piece in board.piece_map().items() if piece.color == color)\n    \n    white_mobility = count_mobility(chess.WHITE)\n    black_mobility = count_mobility(chess.BLACK)\n    return float(white_mobility - black_mobility)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces that can attack the opponent's king.\"\n    white_attacks = sum(1 for square in chess.SQUARES if board.is_attacked_by(chess.WHITE, square) and board.piece_at(square) and board.piece_at(square).color == chess.BLACK)\n    black_attacks = sum(1 for square in chess.SQUARES if board.is_attacked_by(chess.BLACK, square) and board.piece_at(square) and board.piece_at(square).color == chess.WHITE)\n    return float(white_attacks - black_attacks)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in the number of pieces each side has on the promotion rank.\"\n    white_on_promotion = sum(1 for square in board.piece_map() if board.piece_map()[square].color == chess.WHITE and chess.square_rank(square) == 7)\n    black_on_promotion = sum(1 for square in board.piece_map() if board.piece_map()[square].color == chess.BLACK and chess.square_rank(square) == 0)\n    return float(white_on_promotion - black_on_promotion)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in the number of major pieces (rooks and queens) each side has.\"\n    def count_major_pieces(color):\n        return sum(1 for piece in board.piece_map().values() if piece.color == color and piece.piece_type in {chess.ROOK, chess.QUEEN})\n    \n    white_major = count_major_pieces(chess.WHITE)\n    black_major = count_major_pieces(chess.BLACK)\n    return float(white_major - black_major)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the bishops' control of diagonals in terms of the number of open squares on those diagonals.\"\n    def bishop_control(color):\n        total_control = 0\n        for square in board.piece_map():\n            piece = board.piece_map()[square]\n            if piece.color == color and piece.piece_type == chess.BISHOP:\n                total_control += sum(1 for sq in chess.SQUARES if board.is_attacked_by(color, sq) and chess.square_file(square) != chess.square_file(sq))\n        return total_control\n\n    white_control = bishop_control(chess.WHITE)\n    black_control = bishop_control(chess.BLACK)\n    return float(white_control - black_control)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in the number of knights on advanced squares (ranks 5 and higher for white, rank 4 and lower for black).\"\n    advanced_knights_white = sum(1 for square in board.piece_map() if board.piece_map()[square].color == chess.WHITE and chess.square_rank(square) >= 4)\n    advanced_knights_black = sum(1 for square in board.piece_map() if board.piece_map()[square].color == chess.BLACK and chess.square_rank(square) <= 3)\n    return float(advanced_knights_white - advanced_knights_black)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces that are currently unprotected, i.e., not defended by any other piece.\"\n    def unprotected(color):\n        total_unprotected = 0\n        for square in board.piece_map():\n            piece = board.piece_map()[square]\n            if piece.color == color and all(not board.is_attacked_by(board.turn, square) for attacker in board.attackers(color, square)):\n                total_unprotected += 1\n        return total_unprotected\n\n    unprotected_white = unprotected(chess.WHITE)\n    unprotected_black = unprotected(chess.BLACK)\n    return float(unprotected_white - unprotected_black)\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of squares controlled by each player's pieces.\"\n    white_control = sum(1 for square in chess.SQUARES if board.is_attacked_by(chess.WHITE, square))\n    black_control = sum(1 for square in chess.SQUARES if board.is_attacked_by(chess.BLACK, square))\n    return float(white_control - black_control)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the number of available checks for both players.\"\n    white_checks = sum(1 for move in board.legal_moves if board.is_check())\n    board.turn = chess.BLACK  # Switch turn to count black checks\n    black_checks = sum(1 for move in board.legal_moves if board.is_check())\n    board.turn = chess.WHITE  # Reset turn\n    return float(white_checks - black_checks)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of potential forks available for each side.\"\n    white_forks = 0\n    black_forks = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == chess.WHITE:\n            if len(board.attackers(chess.BLACK, square)) > 1:\n                white_forks += 1\n        elif piece.color == chess.BLACK:\n            if len(board.attackers(chess.WHITE, square)) > 1:\n                black_forks += 1\n    return float(white_forks - black_forks)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the number of pieces each side has on the 7th rank.\"\n    white_7th_rank = sum(1 for square in range(0, 8) if board.piece_at(chess.square(square, 6)) and board.piece_at(chess.square(square, 6)).color == chess.WHITE)\n    black_7th_rank = sum(1 for square in range(0, 8) if board.piece_at(chess.square(square, 1)) and board.piece_at(chess.square(square, 1)).color == chess.BLACK)\n    return float(white_7th_rank - black_7th_rank)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the central control of pieces (e4, e5, d4, d5 squares).\"\n    center_squares = [chess.E4, chess.E5, chess.D4, chess.D5]\n    white_center_control = sum(1 for square in center_squares if board.is_attacked_by(chess.WHITE, square))\n    black_center_control = sum(1 for square in center_squares if board.is_attacked_by(chess.BLACK, square))\n    return float(white_center_control - black_center_control)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the coordination of major pieces (rooks and queens).\"\n    white_major = [piece for piece in board.piece_map().values() if piece.color == chess.WHITE and piece.piece_type in [chess.ROOK, chess.QUEEN]]\n    black_major = [piece for piece in board.piece_map().values() if piece.color == chess.BLACK and piece.piece_type in [chess.ROOK, chess.QUEEN]]\n    return float(len(white_major) - len(black_major))\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the total number of pieces that are pinned or unprotected for each color.\"\n    def count_pinned(color):\n        pinned_count = 0\n        for square in board.piece_map():\n            piece = board.piece_map()[square]\n            if piece.color == color:\n                attackers = board.attackers(not color, square)\n                if attackers:  # If there are attackers\n                    for attacker_square in attackers:\n                        if board.piece_at(attacker_square).piece_type in [chess.ROOK, chess.QUEEN]: \n                            pinned_count += 1\n        return pinned_count\n\n    white_pinned = count_pinned(chess.WHITE)\n    black_pinned = count_pinned(chess.BLACK)\n    return float(white_pinned - black_pinned)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the opponent's material lead, considering only pieces worth more than a pawn.\"\n    material_values = {\n        chess.PAWN: 1,\n        chess.KNIGHT: 3,\n        chess.BISHOP: 3,\n        chess.ROOK: 5,\n        chess.QUEEN: 9,\n        chess.KING: 0\n    }\n    opponent_material = sum(material_values[piece.piece_type] for piece in board.piece_map().values() if piece.color != board.turn)\n    return float(opponent_material)\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the total number of pawn islands for each side.\"\n    def count_pawn_islands(color):\n        rank_groups = [[] for _ in range(8)]\n        for square, piece in board.piece_map().items():\n            if piece.color == color and piece.piece_type == chess.PAWN:\n                file = chess.square_file(square)\n                rank_groups[file].append(square)\n        return sum(1 for group in rank_groups if group)\n    \n    white_islands = count_pawn_islands(chess.WHITE)\n    black_islands = count_pawn_islands(chess.BLACK)\n    return float(white_islands - black_islands)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the total number of pieces placed on the back rank for each side.\"\n    white_back_rank_pieces = sum(1 for square in range(64) if chess.square_rank(square) == 0 and board.piece_at(square) and board.piece_at(square).color == chess.WHITE)\n    black_back_rank_pieces = sum(1 for square in range(64) if chess.square_rank(square) == 7 and board.piece_at(square) and board.piece_at(square).color == chess.BLACK)\n    return float(white_back_rank_pieces - black_back_rank_pieces)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the average distance of each side's pieces from their back rank.\"\n    def average_distance(color):\n        distances = []\n        for square, piece in board.piece_map().items():\n            if piece.color == color:\n                distances.append(chess.square_rank(square) if color == chess.WHITE else 7 - chess.square_rank(square))\n        return sum(distances) / len(distances) if distances else 0\n\n    white_average_distance = average_distance(chess.WHITE)\n    black_average_distance = average_distance(chess.BLACK)\n    return float(white_average_distance - black_average_distance)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the number of pieces attacking the opponent's king for both sides.\"\n    white_king_attackers = len(board.attackers(chess.BLACK, chess.parse_square('e8')))\n    black_king_attackers = len(board.attackers(chess.WHITE, chess.parse_square('e1')))\n    return float(white_king_attackers - black_king_attackers)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the total number of squares that are available for promotion for each side.\"\n    white_promotion_squares = sum(1 for square in range(0, 8) if board.is_attacked_by(chess.WHITE, square))\n    black_promotion_squares = sum(1 for square in range(56, 64) if board.is_attacked_by(chess.BLACK, square))\n    return float(white_promotion_squares - black_promotion_squares)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the number of unopposed pieces by color within the opponent's zone.\"\n    def unopposed_count(color):\n        count = 0\n        for square in chess.SQUARES_180:\n            if board.piece_at(square) and board.piece_at(square).color == color and not any(board.is_attacked_by(not color, square) for attacked_square in board.attackers(not color, square)):\n                count += 1\n        return count\n    \n    white_unopposed = unopposed_count(chess.WHITE)\n    black_unopposed = unopposed_count(chess.BLACK)\n    return float(white_unopposed - black_unopposed)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in the number of pawns past the opponent's 4th rank.\"\n    white_pawns_advanced = sum(1 for square in board.piece_map() if board.piece_map()[square].color == chess.WHITE and chess.square_rank(square) >= 4)\n    black_pawns_advanced = sum(1 for square in board.piece_map() if board.piece_map()[square].color == chess.BLACK and chess.square_rank(square) <= 3)\n    return float(white_pawns_advanced - black_pawns_advanced)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the central control by counting pieces occupying or attacking the central squares.\"\n    central_squares = [chess.E4, chess.E5, chess.D4, chess.D5]\n    white_control = sum(1 for square in central_squares if board.is_attacked_by(chess.WHITE, square) or board.piece_at(square) and board.piece_at(square).color == chess.WHITE)\n    black_control = sum(1 for square in central_squares if board.is_attacked_by(chess.BLACK, square) or board.piece_at(square) and board.piece_at(square).color == chess.BLACK)\n    return float(white_control - black_control)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the overall piece activity by counting active pieces (not blocked by pawns).\"\n    active_white = sum(1 for square in board.piece_map() if board.piece_map()[square].color == chess.WHITE and chess.square_rank(square) < 6)\n    active_black = sum(1 for square in board.piece_map() if board.piece_map()[square].color == chess.BLACK and chess.square_rank(square) > 1)\n    return float(active_white - active_black)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the average distance of all pieces from the opponent's back rank.\"\n    white_distance = sum(chess.square_rank(square) for square in board.piece_map() if board.piece_map()[square].color == chess.WHITE) / max(1, len(board.piece_map()))\n    black_distance = sum(7 - chess.square_rank(square) for square in board.piece_map() if board.piece_map()[square].color == chess.BLACK) / max(1, len(board.piece_map()))\n    return float(white_distance - black_distance)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the pawn structure's integrity through doubled pawns.\"\n    white_doubled_pawns = sum(1 for file in range(8) if sum(1 for rank in range(8) if board.piece_at(chess.parse_square(f'{chr(97 + file)}{rank + 1}') ) and board.piece_at(chess.parse_square(f'{chr(97 + file)}{rank + 1}') ).color == chess.WHITE) > 1)\n    black_doubled_pawns = sum(1 for file in range(8) if sum(1 for rank in range(8) if board.piece_at(chess.parse_square(f'{chr(97 + file)}{rank + 1}') ) and board.piece_at(chess.parse_square(f'{chr(97 + file)}{rank + 1}') ).color == chess.BLACK) > 1)\n    return float(black_doubled_pawns - white_doubled_pawns)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the number of pawns that are on the 3rd and 6th ranks for each side.\"\n    white_pawns = sum(1 for square in board.piece_map() if board.piece_map()[square].color == chess.WHITE and chess.square_rank(square) == 5)\n    black_pawns = sum(1 for square in board.piece_map() if board.piece_map()[square].color == chess.BLACK and chess.square_rank(square) == 2)\n    return float(white_pawns - black_pawns)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces in the center (d4, d5, e4, e5) for both sides.\"\n    center_squares = [chess.D4, chess.D5, chess.E4, chess.E5]\n    white_center_count = sum(1 for square in center_squares if board.piece_at(square) and board.piece_at(square).color == chess.WHITE)\n    black_center_count = sum(1 for square in center_squares if board.piece_at(square) and board.piece_at(square).color == chess.BLACK)\n    return float(white_center_count - black_center_count)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Evaluates the presence of hanging pieces susceptible to capture.\"\n    hanging_pieces = sum(1 for square, piece in board.piece_map().items() if piece.color == board.turn and not board.attackers(not piece.color, square))\n    return float(hanging_pieces)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the piece activity by counting the number of pieces that can move.\"\n    active_pieces = sum(1 for piece in board.piece_map().values() if piece.color == board.turn and len(list(board.legal_moves)) > 0)\n    return float(active_pieces)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the knight activity based on control of the central squares.\"\n    knight_control = sum(1 for square in board.piece_map() if board.piece_map()[square].piece_type == chess.KNIGHT and board.piece_map()[square].color == board.turn)\n    central_squares = [chess.D4, chess.D5, chess.E4, chess.E5]\n    return float(sum(1 for square in central_squares if square in board.attackers(board.turn, square))) * knight_control\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Quantifies the number of undeveloped minor pieces (knights and bishops) for both sides.\"\n    white_undeveloped = sum(1 for square in board.piece_map() if board.piece_map()[square].color == chess.WHITE and board.piece_map()[square].piece_type in (chess.KNIGHT, chess.BISHOP) and (chess.square_rank(square) == 0 or chess.square_rank(square) == 1))\n    black_undeveloped = sum(1 for square in board.piece_map() if board.piece_map()[square].color == chess.BLACK and board.piece_map()[square].piece_type in (chess.KNIGHT, chess.BISHOP) and (chess.square_rank(square) == 6 or chess.square_rank(square) == 7))\n    return float(white_undeveloped - black_undeveloped)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Assesses the potential for pawn promotion based on pawn positions.\"\n    white_pawn_promotions = sum(1 for square in board.piece_map() if board.piece_map()[square].color == chess.WHITE and chess.square_rank(square) >= 5)\n    black_pawn_promotions = sum(1 for square in board.piece_map() if board.piece_map()[square].color == chess.BLACK and chess.square_rank(square) <= 2)\n    return float(white_pawn_promotions - black_pawn_promotions)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of potentially forkable pieces by knights for both sides.\"\n    knight_forks = sum(1 for square in board.piece_map() if board.piece_map()[square].piece_type == chess.KNIGHT and board.piece_map()[square].color == board.turn)\n    return float(knight_forks) * 0.5  # Weight slightly for contribution to the evaluation\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the number of squares under attack by each side.\"\n    white_attacks = sum(1 for square in range(64) if board.is_attacked_by(chess.WHITE, square))\n    black_attacks = sum(1 for square in range(64) if board.is_attacked_by(chess.BLACK, square))\n    return float(white_attacks - black_attacks)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the number of times each side can check the opponent's king in one move.\"\n    white_checks = sum(1 for move in board.legal_moves if board.is_check() and move.to_square in [square for square in board.piece_map() if board.piece_map()[square].color == chess.BLACK and board.is_attacked_by(chess.WHITE, square)])\n    black_checks = sum(1 for move in board.legal_moves if board.is_check() and move.to_square in [square for square in board.piece_map() if board.piece_map()[square].color == chess.WHITE and board.is_attacked_by(chess.BLACK, square)])\n    return float(white_checks - black_checks)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the pawn structure by counting isolated, doubled, and passed pawns.\"\n    def pawn_structure(color):\n        pawns = [square for square in board.piece_map() if board.piece_map()[square].color == color and board.piece_map()[square].piece_type == chess.PAWN]\n        isolated = sum(1 for sq in pawns if not (board.piece_at(sq - 8) and board.piece_at(sq + 8)))\n        doubled = sum(1 for file in range(8) if sum(1 for rank in range(8) if board.piece_at(chess.square(file, rank)) == chess.PAWN and piece.color == color) > 1)\n        return isolated + doubled\n    \n    white_structure = pawn_structure(chess.WHITE)\n    black_structure = pawn_structure(chess.BLACK)\n    return float(white_structure - black_structure)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of open files for both sides, with a preference for connected rooks.\"\n    def open_files(color):\n        files = [file for file in range(8) if not any(board.piece_at(chess.square(file, rank)) for rank in range(8))]\n        connected_rooks = sum(1 for file in files if any(board.piece_at(chess.square(file, rank)) and board.piece_at(chess.square(file, rank)).piece_type == chess.ROOK and board.piece_at(chess.square(file, rank)).color == color for rank in range(8)))\n        return len(files) + connected_rooks\n    \n    white_files = open_files(chess.WHITE)\n    black_files = open_files(chess.BLACK)\n    return float(white_files - black_files)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the ratio of pieces defending each king for both sides.\"\n    def defending_pieces(color):\n        king_square = next(square for square in board.piece_map() if board.piece_map()[square].color == color and board.piece_map()[square].piece_type == chess.KING)\n        return sum(1 for square in board.piece_map() if board.piece_map()[square].color == color and board.is_attacked_by(color, king_square))\n\n    white_defenders = defending_pieces(chess.WHITE)\n    black_defenders = defending_pieces(chess.BLACK)\n    return float(white_defenders - black_defenders)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the balance of minor pieces by evaluating knights and bishops.\"\n    material_values = {\n        chess.KNIGHT: 3,\n        chess.BISHOP: 3\n    }\n    white_minor_material = sum(material_values[piece.piece_type] for piece in board.piece_map().values() if piece.color == chess.WHITE and piece.piece_type in material_values)\n    black_minor_material = sum(material_values[piece.piece_type] for piece in board.piece_map().values() if piece.color == chess.BLACK and piece.piece_type in material_values)\n    return float(white_minor_material - black_minor_material)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of moves each side has in the current position.\"\n    white_moves = len(list(board.legal_moves)) if board.turn == chess.WHITE else 0\n    black_moves = len(list(board.legal_moves)) if board.turn == chess.BLACK else 0\n    return float(white_moves - black_moves)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Evaluates the king's safety based on the number of pieces surrounding it.\"\n    def king_safety(color):\n        king_square = next(square for square in board.piece_map() if board.piece_map()[square].color == color and board.piece_map()[square].piece_type == chess.KING)\n        surrounding_pieces = sum(1 for square in range(64) if chess.square_distance(king_square, square) == 1 and board.piece_at(square) and board.piece_at(square).color == color)\n        return surrounding_pieces\n\n    white_safety = king_safety(chess.WHITE)\n    black_safety = king_safety(chess.BLACK)\n    return float(white_safety - black_safety)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the risk of losing pieces based on the number of attackers surrounding the opponent's pieces.\"\n    def piece_risk(color):\n        risk = 0\n        for square in board.piece_map():\n            if board.piece_map()[square].color == color:\n                attackers = sum(1 for att in board.attackers(chess.BLACK if color == chess.WHITE else chess.WHITE, square))\n                risk += attackers\n        return risk\n\n    white_risk = piece_risk(chess.WHITE)\n    black_risk = piece_risk(chess.BLACK)\n    return float(white_risk - black_risk)\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the number of exits available to each side's king.\"\n    white_king_square = next(square for square, piece in board.piece_map().items() if piece.color == chess.WHITE and piece.piece_type == chess.KING)\n    black_king_square = next(square for square, piece in board.piece_map().items() if piece.color == chess.BLACK and piece.piece_type == chess.KING)\n    \n    white_king_exits = sum(1 for move in board.legal_moves if move.from_square == white_king_square)\n    black_king_exits = sum(1 for move in board.legal_moves if move.from_square == black_king_square)\n    \n    return float(white_king_exits - black_king_exits)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the control over the center squares (d4, d5, e4, e5) by rooks and queens.\"\n    center_squares = [chess.parse_square('d4'), chess.parse_square('d5'), chess.parse_square('e4'), chess.parse_square('e5')]\n    white_control = sum(1 for square in center_squares if board.piece_at(square) and board.piece_at(square).color == chess.WHITE and board.piece_at(square).piece_type in [chess.ROOK, chess.QUEEN])\n    black_control = sum(1 for square in center_squares if board.piece_at(square) and board.piece_at(square).color == chess.BLACK and board.piece_at(square).piece_type in [chess.ROOK, chess.QUEEN])\n    return float(white_control - black_control)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Evaluates the number of development moves available for each side's minor pieces.\"\n    white_development_moves = sum(1 for square in board.piece_map().keys() if board.piece_map()[square].color == chess.WHITE and board.piece_map()[square].piece_type in [chess.KNIGHT, chess.BISHOP] and chess.square_rank(square) < 6)\n    black_development_moves = sum(1 for square in board.piece_map().keys() if board.piece_map()[square].color == chess.BLACK and board.piece_map()[square].piece_type in [chess.KNIGHT, chess.BISHOP] and chess.square_rank(square) > 1)\n    return float(white_development_moves - black_development_moves)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the number of potential pinning threats against both kings.\"\n    white_pinning_threats = sum(1 for square in board.piece_map().keys() if board.piece_map()[square].color == chess.WHITE and any(board.is_attacked_by(chess.BLACK, square) for square in board.attackers(chess.BLACK, square)))\n    black_pinning_threats = sum(1 for square in board.piece_map().keys() if board.piece_map()[square].color == chess.BLACK and any(board.is_attacked_by(chess.WHITE, square) for square in board.attackers(chess.WHITE, square)))\n    return float(white_pinning_threats - black_pinning_threats)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the number of squares controlled by bishops of each side.\"\n    white_bishop_control = sum(1 for square in range(64) if board.is_attacked_by(chess.WHITE, square) and any(piece.piece_type == chess.BISHOP for piece in board.piece_map().values() if piece.color == chess.WHITE))\n    black_bishop_control = sum(1 for square in range(64) if board.is_attacked_by(chess.BLACK, square) and any(piece.piece_type == chess.BISHOP for piece in board.piece_map().values() if piece.color == chess.BLACK))\n    return float(white_bishop_control - black_bishop_control)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in pawn structure, checking for doubled, isolated, or backward pawns.\"\n    white_pawns = [square for square in board.piece_map() if board.piece_map()[square].color == chess.WHITE and board.piece_map()[square].piece_type == chess.PAWN]\n    black_pawns = [square for square in board.piece_map() if board.piece_map()[square].color == chess.BLACK and board.piece_map()[square].piece_type == chess.PAWN]\n    white_structure = sum(1 for sq in white_pawns if (chess.square_file(sq), chess.square_rank(sq)) in [(file, rank) for file in range(8) for rank in range(8) if rank < 7])  # Example counting logic for structure\n    black_structure = sum(1 for sq in black_pawns if (chess.square_file(sq), chess.square_rank(sq)) in [(file, rank) for file in range(8) for rank in range(8) if rank > 0])  \n    return float(white_structure - black_structure)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the distance of pieces from the center of the board.\"\n    center_squares = [chess.parse_square('d4'), chess.parse_square('d5'), chess.parse_square('e4'), chess.parse_square('e5')]\n    white_distance = sum(chess.square_distance(square, center) for center in center_squares for square in board.piece_map() if board.piece_map()[square].color == chess.WHITE)\n    black_distance = sum(chess.square_distance(square, center) for center in center_squares for square in board.piece_map() if board.piece_map()[square].color == chess.BLACK)\n    return float(black_distance - white_distance)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the material advantage considering the piece positioning.\"\n    material_values = {\n        chess.PAWN: 1,\n        chess.KNIGHT: 3,\n        chess.BISHOP: 3,\n        chess.ROOK: 5,\n        chess.QUEEN: 9,\n        chess.KING: 0\n    }\n    positional_advantage = sum(material_values[piece.piece_type] for square, piece in board.piece_map().items() if piece.color == board.turn) - sum(material_values[piece.piece_type] for square, piece in board.piece_map().items() if piece.color != board.turn)\n    \n    return float(positional_advantage)\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the number of connected pawns for each side.\"\n    def connected_pawns(color):\n        count = 0\n        for square in board.piece_map():\n            if board.piece_map()[square].color == color and board.piece_map()[square].piece_type == chess.PAWN:\n                file = chess.square_file(square)\n                if (board.piece_at(chess.square(file - 1, chess.square_rank(square))) and \n                    board.piece_at(chess.square(file - 1, chess.square_rank(square))).color == color):\n                    count += 1\n                if (board.piece_at(chess.square(file + 1, chess.square_rank(square))) and \n                    board.piece_at(chess.square(file + 1, chess.square_rank(square))).color == color):\n                    count += 1\n        return count\n\n    white_connected = connected_pawns(chess.WHITE)\n    black_connected = connected_pawns(chess.BLACK)\n    return float(white_connected - black_connected)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the number of pieces on the 7th rank for each side.\"\n    white_pieces_on_seventh = sum(1 for square in board.piece_map() if board.piece_map()[square].color == chess.WHITE and chess.square_rank(square) == 6)\n    black_pieces_on_seventh = sum(1 for square in board.piece_map() if board.piece_map()[square].color == chess.BLACK and chess.square_rank(square) == 1)\n    return float(white_pieces_on_seventh - black_pieces_on_seventh)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of squares controlled by pieces on the 2nd and 7th ranks for each side.\"\n    def controlled_squares_count(color, rank):\n        return sum(1 for square in chess.SQUARES if board.is_attacked_by(color, square) and chess.square_rank(square) != rank)\n\n    white_control = controlled_squares_count(chess.WHITE, 1)\n    black_control = controlled_squares_count(chess.BLACK, 6)\n    return float(white_control - black_control)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the mobility for each side based on legal moves.\"\n    white_mobility = len(list(board.legal_moves)) if board.turn == chess.WHITE else 0\n    black_mobility = len(list(board.legal_moves)) if board.turn == chess.BLACK else 0\n    return float(white_mobility - black_mobility)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the difference in pawn structure between both sides.\"\n    def pawn_structure_score(color):\n        score = 0\n        for file in range(8):\n            if board.piece_at(chess.square(file, 1 if color == chess.BLACK else 6)) and board.piece_at(chess.square(file, 1 if color == chess.BLACK else 6)).piece_type == chess.PAWN:\n                score += 1\n        return score\n\n    white_structure_score = pawn_structure_score(chess.WHITE)\n    black_structure_score = pawn_structure_score(chess.BLACK)\n    return float(white_structure_score - black_structure_score)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in piece activity based on their attack potential.\"\n    def piece_activity(color):\n        activity = 0\n        for square in board.piece_map():\n            piece = board.piece_map()[square]\n            if piece.color == color:\n                activity += len(board.attackers(not color, square))\n        return activity\n    \n    white_activity = piece_activity(chess.WHITE)\n    black_activity = piece_activity(chess.BLACK)\n    return float(white_activity - black_activity)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the number of isolated pawns for each side.\"\n    def isolated_pawn_count(color):\n        count = 0\n        for square in board.piece_map():\n            piece = board.piece_map()[square]\n            if piece.color == color and piece.piece_type == chess.PAWN:\n                file = chess.square_file(square)\n                if not (board.piece_at(chess.square(file - 1, chess.square_rank(square))) and board.piece_at(chess.square(file - 1, chess.square_rank(square))).color == color) and \\\n                        not (board.piece_at(chess.square(file + 1, chess.square_rank(square))) and board.piece_at(chess.square(file + 1, chess.square_rank(square))).color == color):\n                    count += 1\n        return count\n\n    white_isolated = isolated_pawn_count(chess.WHITE)\n    black_isolated = isolated_pawn_count(chess.BLACK)\n    return float(white_isolated - black_isolated)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the influence on the center based on pawns and pieces attacking central squares.\"\n    central_squares = [chess.D4, chess.D5, chess.E4, chess.E5]\n    def center_influence(color):\n        return sum(1 for square in central_squares if board.is_attacked_by(color, square))\n    \n    white_influence = center_influence(chess.WHITE)\n    black_influence = center_influence(chess.BLACK)\n    return float(white_influence - black_influence)\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in mobility for both sides based on legal moves.\"\n    white_mobility = len(list(board.legal_moves)) if board.turn else 0\n    black_mobility = len(list(board.legal_moves)) if not board.turn else 0\n    return float(white_mobility - black_mobility)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the total piece activity based on how many squares each piece controls.\"\n    piece_control = {chess.WHITE: 0, chess.BLACK: 0}\n    for square in board.piece_map():\n        piece_color = board.piece_map()[square].color\n        piece_control[piece_color] += len(list(board.legal_moves))\n    return float(piece_control[chess.WHITE] - piece_control[chess.BLACK])\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of development moves made by each side (pieces moved from their original positions).\"\n    def count_development(color):\n        return sum(1 for square in board.piece_map() if board.piece_map()[square].color == color and \n                   chess.square_rank(square) < 6)\n    white_development = count_development(chess.WHITE)\n    black_development = count_development(chess.BLACK)\n    return float(white_development - black_development)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the number of pieces each player has on the opponent's half of the board.\"\n    white_advanced = sum(1 for square in board.piece_map() if board.piece_map()[square].color == chess.WHITE and chess.square_rank(square) > 3)\n    black_advanced = sum(1 for square in board.piece_map() if board.piece_map()[square].color == chess.BLACK and chess.square_rank(square) < 4)\n    return float(white_advanced - black_advanced)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the presence of active pieces near the opponent's king.\"\n    white_threats = sum(1 for square in board.piece_map() if board.piece_map()[square].color == chess.WHITE and \n                        board.is_attacked_by(chess.BLACK, square))\n    black_threats = sum(1 for square in board.piece_map() if board.piece_map()[square].color == chess.BLACK and \n                        board.is_attacked_by(chess.WHITE, square))\n    return float(white_threats - black_threats)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in the number of pieces on the back ranks of both sides.\"\n    white_back_rank = sum(1 for square in chess.SQUARES_180 if board.piece_at(square) and board.piece_at(square).color == chess.WHITE and chess.square_rank(square) == 0)\n    black_back_rank = sum(1 for square in chess.SQUARES_180 if board.piece_at(square) and board.piece_at(square).color == chess.BLACK and chess.square_rank(square) == 7)\n    return float(white_back_rank - black_back_rank)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the influence of bishops based on their diagonal control.\"\n    def bishop_control(color):\n        return sum(1 for square in board.piece_map() if board.piece_map()[square].color == color and \n                   board.piece_map()[square].piece_type == chess.BISHOP)\n    white_control = bishop_control(chess.WHITE)\n    black_control = bishop_control(chess.BLACK)\n    return float(white_control - black_control)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Evaluates the risk of losing pieces based on how many are attacked.\"\n    white_attacked = sum(1 for square in board.piece_map() if board.piece_map()[square].color == chess.WHITE and \n                          board.is_attacked_by(chess.BLACK, square))\n    black_attacked = sum(1 for square in board.piece_map() if board.piece_map()[square].color == chess.BLACK and \n                          board.is_attacked_by(chess.WHITE, square))\n    return float(white_attacked - black_attacked)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the coordination of knights based on their proximity to each other.\"\n    knight_positions = [square for square in board.piece_map() if board.piece_map()[square].piece_type == chess.KNIGHT]\n    knight_distance = sum(chess.square_distance(knight_positions[i], knight_positions[j]) for i in range(len(knight_positions)) for j in range(i + 1, len(knight_positions)))\n    return float(knight_distance)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the imbalance of pawn structure based on doubled pawns.\"\n    def count_doubled_pawns(color):\n        pawn_files = [file for file in range(8) if board.piece_at(chess.square(file, 1 if color == chess.WHITE else 6)) == chess.PAWN]\n        return sum(1 for file in pawn_files if pawn_files.count(file) > 1)\n    white_doubled = count_doubled_pawns(chess.WHITE)\n    black_doubled = count_doubled_pawns(chess.BLACK)\n    return float(white_doubled - black_doubled)\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the number of pieces attacking the opponent's king.\"\n    opponent_king_square = next(square for square in board.piece_map() if board.piece_map()[square].piece_type == chess.KING and board.piece_map()[square].color != board.turn)\n    attacking_pieces = sum(1 for piece_square in board.piece_map() if board.is_attacked_by(board.turn, piece_square) and board.piece_map()[piece_square].color == board.turn)\n    return float(attacking_pieces)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the number of piece pairs (connected pieces) each side has.\"\n    connected_pairs = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == board.turn:\n            for move in board.legal_moves:\n                if move.from_square == square and board.piece_at(move.to_square) is not None:\n                    connected_pairs += 1\n    return float(connected_pairs)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the piece activity based on the number of pieces that can move to squares under attack.\"\n    activity_score = sum(1 for piece_square in board.piece_map() if any(board.is_attacked_by(board.turn, move.to_square) for move in board.legal_moves if move.from_square == piece_square))\n    return float(activity_score)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the number of pieces that are pinned (unable to move without exposing the king).\"\n    pinned_count = 0\n    for square in board.piece_map():\n        piece = board.piece_map()[square]\n        if piece.color == board.turn:\n            for move in board.legal_moves:\n                if move.from_square == square and board.is_check():\n                    pinned_count += 1\n    return float(pinned_count)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of pawn-promoting squares each side has access to.\"\n    def promotion_squares(color):\n        return sum(1 for square in range(0, 8) if board.piece_at(square) == chess.PAWN and board.piece_map()[square].color == color)\n\n    white_promotions = promotion_squares(chess.WHITE)\n    black_promotions = promotion_squares(chess.BLACK)\n    return float(white_promotions - black_promotions)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the king's safety based on the number of escape squares.\"\n    king_square = next(square for square in board.piece_map() if board.piece_map()[square].piece_type == chess.KING and board.piece_map()[square].color == board.turn)\n    escape_squares = sum(1 for move in board.legal_moves if move.from_square == king_square)\n    return float(escape_squares)\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in the number of pawns on the third and sixth ranks.\"\n    white_third_rank_pawns = sum(1 for square in range(24, 32) if board.piece_at(square) and board.piece_at(square).color == chess.WHITE and board.piece_at(square).piece_type == chess.PAWN)\n    black_sixth_rank_pawns = sum(1 for square in range(48, 56) if board.piece_at(square) and board.piece_at(square).color == chess.BLACK and board.piece_at(square).piece_type == chess.PAWN)\n    return float(white_third_rank_pawns - black_sixth_rank_pawns)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces that are pinned for both sides.\"\n    def is_pinned(color):\n        pinned_count = 0\n        for square in board.piece_map():\n            piece = board.piece_map()[square]\n            if piece.color == color:\n                for attacker in board.attackers(not color, square):\n                    if board.piece_at(attacker).piece_type == chess.QUEEN or board.piece_at(attacker).piece_type == chess.ROOK or (board.piece_at(attacker).piece_type == chess.BISHOP and abs(chess.square_file(attacker) - chess.square_file(square)) == abs(chess.square_rank(attacker) - chess.square_rank(square))):\n                        pinned_count += 1\n                        break\n        return pinned_count\n\n    white_pinned = is_pinned(chess.WHITE)\n    black_pinned = is_pinned(chess.BLACK)\n    return float(white_pinned - black_pinned)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the number of open files for both sides.\"\n    def count_open_files(color):\n        open_files = 0\n        for file in range(8):\n            if all(board.piece_at(chess.square(file, rank)) is None for rank in range(8) if (color == chess.WHITE and rank > 0) or (color == chess.BLACK and rank < 7)):\n                open_files += 1\n        return open_files\n\n    white_open_files = count_open_files(chess.WHITE)\n    black_open_files = count_open_files(chess.BLACK)\n    return float(white_open_files - black_open_files)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Evaluates the total number of pieces attacking enemy pieces, counting only non-king pieces.\"\n    def attacking_piece_count(color):\n        count = 0\n        for square in board.piece_map():\n            if board.piece_map()[square].color == color:\n                for target in board.piece_map():\n                    if board.piece_map()[target].color != color and target != chess.square_file(board.piece_map()[square].piece_type):\n                        if square in board.attackers(color, target):\n                            count += 1\n        return count\n    white_attacks = attacking_piece_count(chess.WHITE)\n    black_attacks = attacking_piece_count(chess.BLACK)\n    return float(white_attacks - black_attacks)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in the number of pieces on the 2nd and 7th ranks.\"\n    white_second_rank_pieces = sum(1 for square in range(8, 16) if board.piece_at(square) and board.piece_at(square).color == chess.WHITE)\n    black_seventh_rank_pieces = sum(1 for square in range(56, 64) if board.piece_at(square) and board.piece_at(square).color == chess.BLACK)\n    return float(white_second_rank_pieces - black_seventh_rank_pieces)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of pinned pieces around both kings.\"\n    def count_pinned_around_king(color):\n        king_square = next(square for square in board.piece_map() if board.piece_map()[square].piece_type == chess.KING and board.piece_map()[square].color == color)\n        pinned_count = 0\n        for square in board.piece_map():\n            if board.piece_map()[square].color == color and board.is_attacked_by(not color, square):\n                pinned_count += 1\n        return pinned_count\n\n    white_pinned_around_king = count_pinned_around_king(chess.WHITE)\n    black_pinned_around_king = count_pinned_around_king(chess.BLACK)\n    return float(white_pinned_around_king - black_pinned_around_king)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the mobility of bishops by counting the number of diagonally accessible squares.\"\n    def bishop_mobility(color):\n        mobility = 0\n        for square in board.piece_map():\n            if board.piece_map()[square].color == color and board.piece_map()[square].piece_type == chess.BISHOP:\n                rank, file = chess.square_rank(square), chess.square_file(square)\n                for dx in range(-7, 8):\n                    for dy in range(-7, 8):\n                        if abs(dx) == abs(dy) and dx != 0:\n                            target_square = chess.square(file + dx, rank + dy)\n                            if 0 <= file + dx < 8 and 0 <= rank + dy < 8 and board.piece_at(target_square) is None:\n                                mobility += 1\n        return mobility\n\n    white_mobility = bishop_mobility(chess.WHITE)\n    black_mobility = bishop_mobility(chess.BLACK)\n    return float(white_mobility - black_mobility)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in the number of knights controlling the center squares.\"\n    center_squares = {chess.D4, chess.D5, chess.E4, chess.E5}\n    def knight_control(color):\n        control_count = sum(1 for square in board.piece_map() if board.piece_map()[square].color == color and \n                            board.piece_map()[square].piece_type == chess.KNIGHT and \n                            any(chess.square_distance(square, center) == 1 for center in center_squares))\n        return control_count\n\n    white_knights = knight_control(chess.WHITE)\n    black_knights = knight_control(chess.BLACK)\n    return float(white_knights - black_knights)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the difference in the number of squares available in the opponent's territory.\"\n    def available_squares(color):\n        count = 0\n        start_rank = 0 if color == chess.WHITE else 5\n        end_rank = 3 if color == chess.WHITE else 8\n        for square in range(start_rank * 8, end_rank * 8):\n            if board.is_attacked_by(color, square):\n                count += 1\n        return count\n\n    white_available = available_squares(chess.WHITE)\n    black_available = available_squares(chess.BLACK)\n    return float(white_available - black_available)\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the total number of pawns each player has advanced past the fourth rank.\"\n    white_advanced_pawns = sum(1 for square in board.piece_map() if board.piece_map()[square].color == chess.WHITE and chess.square_rank(square) > 3 and board.piece_map()[square].piece_type == chess.PAWN)\n    black_advanced_pawns = sum(1 for square in board.piece_map() if board.piece_map()[square].color == chess.BLACK and chess.square_rank(square) < 4 and board.piece_map()[square].piece_type == chess.PAWN)\n    return float(white_advanced_pawns - black_advanced_pawns)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Evaluates the presence of control over the center squares (d4, d5, e4, e5).\"\n    center_squares = [chess.D4, chess.D5, chess.E4, chess.E5]\n    white_center_control = sum(1 for square in center_squares if board.is_attacked_by(chess.WHITE, square))\n    black_center_control = sum(1 for square in center_squares if board.is_attacked_by(chess.BLACK, square))\n    return float(white_center_control - black_center_control)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the pawn structure by counting isolated pawns.\"\n    def is_isolated(square, color):\n        file = chess.square_file(square)\n        return (not board.piece_at(chess.parse_square(chess.square_name(square)[0] + str(i))) and \n                not board.piece_at(chess.parse_square(chess.square_name(square)[1] + str(i))) \n                for i in range(1, 9) if chess.square_rank(square) == i)\n\n    white_isolated = sum(1 for square in board.piece_map() if board.piece_map()[square].color == chess.WHITE and board.piece_map()[square].piece_type == chess.PAWN and is_isolated(square, chess.WHITE))\n    black_isolated = sum(1 for square in board.piece_map() if board.piece_map()[square].color == chess.BLACK and board.piece_map()[square].piece_type == chess.PAWN and is_isolated(square, chess.BLACK))\n    return float(white_isolated - black_isolated)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the potential for double attacks by counting attacking pieces.\"\n    white_double_attack = sum(1 for square in board.piece_map() if board.piece_map()[square].color == chess.WHITE and len(board.attackers(chess.BLACK, square)) > 1)\n    black_double_attack = sum(1 for square in board.piece_map() if board.piece_map()[square].color == chess.BLACK and len(board.attackers(chess.WHITE, square)) > 1)\n    return float(white_double_attack - black_double_attack)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the presence of pieces on strategic squares (c3, c6, f3, f6).\"\n    strategic_squares = [chess.C3, chess.C6, chess.F3, chess.F6]\n    white_strategic_count = sum(1 for square in strategic_squares if board.piece_at(square) and board.piece_at(square).color == chess.WHITE)\n    black_strategic_count = sum(1 for square in strategic_squares if board.piece_at(square) and board.piece_at(square).color == chess.BLACK)\n    return float(white_strategic_count - black_strategic_count)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in the number of moves available between both players.\"\n    white_moves = len(list(board.legal_moves)) if board.turn == chess.WHITE else 0\n    black_moves = len(list(board.legal_moves)) if board.turn == chess.BLACK else 0\n    return float(white_moves - black_moves)\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the value of pieces that have potential to promote.\"\n    promotion_squares = [chess.A7, chess.B7, chess.C7, chess.D7, chess.E7, chess.F7, chess.G7, chess.H7]\n    white_promoting = sum(1 for square in promotion_squares if board.piece_at(square) and board.piece_at(square).color == chess.WHITE)\n    black_promoting = sum(1 for square in promotion_squares if board.piece_at(square) and board.piece_at(square).color == chess.BLACK)\n    return float(white_promoting - black_promoting)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts pieces trapped with no legal moves left to escape.\"\n    trapped_pieces = sum(1 for square, piece in board.piece_map().items() if piece.color == board.turn and not list(board.legal_moves) and all(board.is_attacked_by(not board.turn, square)))\n    return float(trapped_pieces)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the number of pieces in the opponent's back rank.\"\n    white_back_rank_count = sum(1 for square in range(56, 64) if board.piece_at(square) and board.piece_at(square).color == chess.WHITE)\n    black_back_rank_count = sum(1 for square in range(0, 8) if board.piece_at(square) and board.piece_at(square).color == chess.BLACK)\n    return float(black_back_rank_count - white_back_rank_count)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the initiative based on the number of available checks.\"\n    white_checks = sum(1 for move in board.legal_moves if board.gives_check(move))\n    black_checks = sum(1 for move in board.legal_moves if not board.gives_check(move))\n    return float(white_checks - black_checks)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Evaluates the difference in mobility based on the number of legal moves.\"\n    white_mobility = len(list(board.legal_moves)) if board.turn == chess.WHITE else 0\n    black_mobility = len(list(board.legal_moves)) if board.turn == chess.BLACK else 0\n    return float(white_mobility - black_mobility)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of doubled pawns for each side.\"\n    white_doubled_pawns = sum(1 for rank in range(8) for file in range(8) if board.piece_at(chess.square(file, rank)) == chess.PAWN and \n                                 len([sq for sq in board.piece_map() if chess.square_file(sq) == file and board.piece_at(sq).color == chess.WHITE]) > 1)\n    black_doubled_pawns = sum(1 for rank in range(8) for file in range(8) if board.piece_at(chess.square(file, rank)) == chess.PAWN and \n                                 len([sq for sq in board.piece_map() if chess.square_file(sq) == file and board.piece_at(sq).color == chess.BLACK]) > 1)\n    return float(white_doubled_pawns - black_doubled_pawns)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the influence of pieces on key squares (center and back rank).\"\n    key_squares = [chess.D4, chess.D5, chess.E4, chess.E5, chess.A8, chess.H8]\n    white_influence = sum(1 for square in key_squares if board.is_attacked_by(chess.WHITE, square))\n    black_influence = sum(1 for square in key_squares if board.is_attacked_by(chess.BLACK, square))\n    return float(white_influence - black_influence)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the number of open files available for each side's rooks.\"\n    open_files_white = sum(1 for file in range(8) if all(board.piece_at(chess.square(file, rank)) is None for rank in range(8) if board.turn == chess.WHITE))\n    open_files_black = sum(1 for file in range(8) if all(board.piece_at(chess.square(file, rank)) is None for rank in range(8) if board.turn == chess.BLACK))\n    return float(open_files_white - open_files_black)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Evaluates the vulnerability of the king based on nearby attacks.\"\n    white_king_square = next(square for square, piece in board.piece_map().items() if piece.color == chess.WHITE and piece.piece_type == chess.KING)\n    black_king_square = next(square for square, piece in board.piece_map().items() if piece.color == chess.BLACK and piece.piece_type == chess.KING)\n    white_king_vulnerability = sum(1 for square in chess.SQUARES if board.is_attacked_by(chess.BLACK, square) and chess.square_distance(white_king_square, square) <= 1)\n    black_king_vulnerability = sum(1 for square in chess.SQUARES if board.is_attacked_by(chess.WHITE, square) and chess.square_distance(black_king_square, square) <= 1)\n    return float(white_king_vulnerability - black_king_vulnerability)\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in pawn structure between the two sides.\"\n    def count_connected_pawns(color):\n        connected = 0\n        for file in range(8):\n            if board.piece_at(chess.square(file, 1 if color == chess.WHITE else 6)) == chess.PAWN:\n                if (file > 0 and board.piece_at(chess.square(file - 1, 1 if color == chess.WHITE else 6)) == chess.PAWN) or \\\n                   (file < 7 and board.piece_at(chess.square(file + 1, 1 if color == chess.WHITE else 6)) == chess.PAWN):\n                    connected += 1\n        return connected\n    white_connected = count_connected_pawns(chess.WHITE)\n    black_connected = count_connected_pawns(chess.BLACK)\n    return float(white_connected - black_connected)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the safety of the king based on the number of available escape squares.\"\n    king_square = next(square for square, piece in board.piece_map().items() if piece.color == board.turn and piece.piece_type == chess.KING)\n    escape_squares = sum(1 for move in board.legal_moves if move.to_square == king_square)\n    return float(escape_squares)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces on the 7th rank for both sides.\"\n    white_seventh = sum(1 for square in range(56, 64) if board.piece_at(square) and board.piece_at(square).color == chess.WHITE)\n    black_seventh = sum(1 for square in range(0, 8) if board.piece_at(square) and board.piece_at(square).color == chess.BLACK)\n    return float(white_seventh - black_seventh)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Evaluates the control of the center squares (d4, e4, d5, e5).\"\n    center_squares = [chess.D4, chess.E4, chess.D5, chess.E5]\n    white_control = sum(1 for square in center_squares if board.is_attacked_by(chess.WHITE, square))\n    black_control = sum(1 for square in center_squares if board.is_attacked_by(chess.BLACK, square))\n    return float(white_control - black_control)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of pinned pieces for each color.\"\n    def count_pinned_pieces(color):\n        pinned = 0\n        for square, piece in board.piece_map().items():\n            if piece.color == color:\n                if board.attackers(not color, square):\n                    pinned += 1\n        return pinned\n    white_pinned = count_pinned_pieces(chess.WHITE)\n    black_pinned = count_pinned_pieces(chess.BLACK)\n    return float(white_pinned - black_pinned)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the distribution of pieces across ranks for both sides.\"\n    def piece_distribution(color):\n        distribution = [0] * 8\n        for square, piece in board.piece_map().items():\n            if piece.color == color:\n                distribution[chess.square_rank(square)] += 1\n        return distribution\n    white_distribution = piece_distribution(chess.WHITE)\n    black_distribution = piece_distribution(chess.BLACK)\n    return float(sum(white_distribution) - sum(black_distribution))\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the potential to create passed pawns.\"\n    def has_passed_pawn(color):\n        for file in range(8):\n            pawn_square = chess.square(file, 1 if color == chess.WHITE else 6)\n            if board.piece_at(pawn_square) == chess.PAWN:\n                for attacked_square in (chess.square(file-1, 1 if color == chess.WHITE else 6), chess.square(file+1, 1 if color == chess.WHITE else 6)):\n                    if 0 <= file < 8 and board.is_attacked_by(not color, attacked_square):\n                        return 0\n                return 1\n        return 0\n    white_passed = has_passed_pawn(chess.WHITE)\n    black_passed = has_passed_pawn(chess.BLACK)\n    return float(white_passed - black_passed)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Evaluates the average piece activity based on the number of squares controlled.\"\n    piece_activity = 0\n    for square, piece in board.piece_map().items():\n        piece_activity += len(board.attackers(not piece.color, square))\n    return float(piece_activity)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the presence of active vs inactive pieces (non-king) for each player.\"\n    def active_piece_score(color):\n        score = 0\n        for square, piece in board.piece_map().items():\n            if piece.color == color and piece.piece_type != chess.KING:\n                score += len(list(board.legal_moves))\n        return score\n    white_activity = active_piece_score(chess.WHITE)\n    black_activity = active_piece_score(chess.BLACK)\n    return float(white_activity - black_activity)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in piece value locations based on piece placement.\"\n    piece_values = {chess.PAWN: 1, chess.KNIGHT: 3, chess.BISHOP: 3, chess.ROOK: 5, chess.QUEEN: 9, chess.KING: 0}\n    def value_position(color):\n        total_value = 0\n        for square, piece in board.piece_map().items():\n            if piece.color == color:\n                total_value += piece_values[piece.piece_type] * (8 - chess.square_rank(square) if color == chess.WHITE else chess.square_rank(square))\n        return total_value\n    white_position_value = value_position(chess.WHITE)\n    black_position_value = value_position(chess.BLACK)\n    return float(white_position_value - black_position_value)\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the number of pawns on the 5th rank for both sides, which can indicate advanced position.\"\n    white_pawns_on_5th = sum(1 for square in range(24, 32) if board.piece_at(square) and board.piece_at(square).color == chess.WHITE and board.piece_at(square).piece_type == chess.PAWN)\n    black_pawns_on_5th = sum(1 for square in range(16, 24) if board.piece_at(square) and board.piece_at(square).color == chess.BLACK and board.piece_at(square).piece_type == chess.PAWN)\n    return float(white_pawns_on_5th - black_pawns_on_5th)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Evaluates the potential threats by counting attacking squares of pieces for both sides.\"\n    white_threats = sum(1 for square in board.piece_map() if board.piece_map()[square].color == chess.WHITE for target in board.attackers(chess.BLACK, square))\n    black_threats = sum(1 for square in board.piece_map() if board.piece_map()[square].color == chess.BLACK for target in board.attackers(chess.WHITE, square))\n    return float(white_threats - black_threats)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the imbalance in piece distribution across different ranks for each side.\"\n    white_rank_distribution = [0] * 8\n    black_rank_distribution = [0] * 8\n    for square, piece in board.piece_map().items():\n        if piece.color == chess.WHITE:\n            white_rank_distribution[chess.square_rank(square)] += 1\n        else:\n            black_rank_distribution[chess.square_rank(square)] += 1\n    return float(sum(white_rank_distribution) - sum(black_rank_distribution))\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces unable to move due to being blocked or pinned for each side.\"\n    blocked_pieces_white = sum(1 for square in board.piece_map() if board.piece_map()[square].color == chess.WHITE and not any(board.piece_at(move.to_square) for move in board.legal_moves))\n    blocked_pieces_black = sum(1 for square in board.piece_map() if board.piece_map()[square].color == chess.BLACK and not any(board.piece_at(move.to_square) for move in board.legal_moves))\n    return float(blocked_pieces_white - blocked_pieces_black)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in material considering only high-value pieces remaining on the board.\"\n    high_value_material = {\n        chess.KNIGHT: 3,\n        chess.BISHOP: 3,\n        chess.ROOK: 5,\n        chess.QUEEN: 9,\n        chess.KING: 0\n    }\n    white_high_value = sum(high_value_material[piece.piece_type] for piece in board.piece_map().values() if piece.color == chess.WHITE and piece.piece_type in high_value_material)\n    black_high_value = sum(high_value_material[piece.piece_type] for piece in board.piece_map().values() if piece.color == chess.BLACK and piece.piece_type in high_value_material)\n    return float(white_high_value - black_high_value)\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in number of pieces attacking critical squares (central and back rank).\"\n    critical_squares = [chess.D4, chess.E4, chess.D5, chess.E5, chess.D1, chess.E1, chess.D8, chess.E8]\n    white_attacks = sum(board.is_attacked_by(chess.WHITE, square) for square in critical_squares)\n    black_attacks = sum(board.is_attacked_by(chess.BLACK, square) for square in critical_squares)\n    return float(white_attacks - black_attacks)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Assesses the balance of bishops on the board.\"\n    white_bishops = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE and piece.piece_type == chess.BISHOP)\n    black_bishops = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK and piece.piece_type == chess.BISHOP)\n    return float(white_bishops - black_bishops)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the count of pieces on the opponent's side of the board.\"\n    white_pieces = sum(1 for square in range(32, 64) if board.piece_at(square) and board.piece_map()[square].color == chess.WHITE)\n    black_pieces = sum(1 for square in range(0, 32) if board.piece_at(square) and board.piece_map()[square].color == chess.BLACK)\n    return float(white_pieces - black_pieces)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the number of pieces that can be developed in the next move.\"\n    white_developables = sum(1 for move in board.legal_moves if board.piece_map()[move.from_square].color == chess.WHITE and move.to_square in [chess.C3, chess.F3, chess.C6, chess.F6])\n    black_developables = sum(1 for move in board.legal_moves if board.piece_map()[move.from_square].color == chess.BLACK and move.to_square in [chess.C3, chess.F3, chess.C6, chess.F6])\n    return float(white_developables - black_developables)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Assesses the level of king safety based on the presence of attacking pieces.\"\n    white_king_square = next(square for square in board.piece_map() if board.piece_map()[square].color == chess.WHITE and board.piece_map()[square].piece_type == chess.KING)\n    black_king_square = next(square for square in board.piece_map() if board.piece_map()[square].color == chess.BLACK and board.piece_map()[square].piece_type == chess.KING)\n    white_threats = len(board.attackers(chess.BLACK, white_king_square))\n    black_threats = len(board.attackers(chess.WHITE, black_king_square))\n    return float(black_threats - white_threats)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the potential pawn mobility for both players.\"\n    white_pawn_mobility = sum(1 for square in board.piece_map() if board.piece_map()[square].color == chess.WHITE and board.piece_map()[square].piece_type == chess.PAWN and board.is_attacked_by(chess.BLACK, square + 8))\n    black_pawn_mobility = sum(1 for square in board.piece_map() if board.piece_map()[square].color == chess.BLACK and board.piece_map()[square].piece_type == chess.PAWN and board.is_attacked_by(chess.WHITE, square - 8))\n    return float(white_pawn_mobility - black_pawn_mobility)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Evaluates the presence of open files for rooks.\"\n    open_files = sum(1 for file in range(8) if not any(board.piece_at(chess.square(file, rank)) for rank in range(8)))\n    return float(open_files)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in the average rank of pawns for both sides.\"\n    def average_pawn_rank(color):\n        pawns = [chess.square_rank(square) for square in board.piece_map() if board.piece_map()[square].color == color and board.piece_map()[square].piece_type == chess.PAWN]\n        return sum(pawns) / len(pawns) if pawns else 0\n    \n    white_pawn_avg = average_pawn_rank(chess.WHITE)\n    black_pawn_avg = average_pawn_rank(chess.BLACK)\n    return float(white_pawn_avg - black_pawn_avg)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Assesses the positional advantage based on control of key central squares.\"\n    central_squares = [chess.D4, chess.E4, chess.D5, chess.E5]\n    white_control = sum(board.is_attacked_by(chess.WHITE, square) for square in central_squares)\n    black_control = sum(board.is_attacked_by(chess.BLACK, square) for square in central_squares)\n    return float(white_control - black_control)\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the number of pieces each side has on the back rank.\"\n    white_back_rank = sum(1 for square in range(0, 8) if board.piece_at(chess.square(square, 0)) and board.piece_at(chess.square(square, 0)).color == chess.WHITE)\n    black_back_rank = sum(1 for square in range(0, 8) if board.piece_at(chess.square(square, 7)) and board.piece_at(chess.square(square, 7)).color == chess.BLACK)\n    return float(white_back_rank - black_back_rank)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the number of potential threats considering piece safety.\"\n    threats = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == board.turn:\n            threats += len(list(board.attackers(not board.turn, square)))\n    return float(threats)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of doubled pawns for each side.\"\n    pawn_positions = {chess.WHITE: set(), chess.BLACK: set()}\n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.PAWN:\n            pawn_positions[piece.color].add(chess.square_file(square))\n    double_pawns = {color: len(pawns) - len(set(pawns)) for color, pawns in pawn_positions.items()}\n    return float(double_pawns[chess.WHITE] - double_pawns[chess.BLACK])\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the mobility advantage based on the number of legal moves.\"\n    white_moves = len(list(board.legal_moves)) if board.turn == chess.WHITE else len(list(board.legal_moves))\n    black_moves = len(list(board.legal_moves)) if board.turn == chess.BLACK else len(list(board.legal_moves))\n    return float(white_moves - black_moves)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Evaluates the number of pieces each side has on the second rank, indicating development.\"\n    white_second_rank = sum(1 for square in range(0, 8) if board.piece_at(chess.square(square, 1)) and board.piece_at(chess.square(square, 1)).color == chess.WHITE)\n    black_second_rank = sum(1 for square in range(0, 8) if board.piece_at(chess.square(square, 6)) and board.piece_at(chess.square(square, 6)).color == chess.BLACK)\n    return float(white_second_rank - black_second_rank)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the number of isolated pawns for each side.\"\n    def is_isolated_pawn(square, color):\n        file = chess.square_file(square)\n        if color == chess.WHITE:\n            return (file == 0 or board.piece_at(chess.square(file - 1, 1)) is None) and (file == 7 or board.piece_at(chess.square(file + 1, 1)) is None)\n        else:\n            return (file == 0 or board.piece_at(chess.square(file - 1, 6)) is None) and (file == 7 or board.piece_at(chess.square(file + 1, 6)) is None)\n\n    white_isolated = sum(1 for square in board.piece_map() if board.piece_map()[square].color == chess.WHITE and board.piece_map()[square].piece_type == chess.PAWN and is_isolated_pawn(square, chess.WHITE))\n    black_isolated = sum(1 for square in board.piece_map() if board.piece_map()[square].color == chess.BLACK and board.piece_map()[square].piece_type == chess.PAWN and is_isolated_pawn(square, chess.BLACK))\n\n    return float(white_isolated - black_isolated)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the number of rooks each side has on open files.\"\n    def is_open_file(file, color):\n        for rank in range(8):\n            square = chess.square(file, rank)\n            if board.piece_at(square) is not None and board.piece_at(square).color == color:\n                return all(board.piece_at(chess.square(file, r)) is None for r in range(8) if r != rank)\n        return False\n\n    white_open_files = sum(1 for file in range(8) if is_open_file(file, chess.WHITE))\n    black_open_files = sum(1 for file in range(8) if is_open_file(file, chess.BLACK))\n    return float(white_open_files - black_open_files)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of pinned pieces each side has.\"\n    def is_pinned(square, color):\n        piece = board.piece_at(square)\n        if piece is None or piece.color != color:\n            return False\n        for attacker in board.attackers(not color, square):\n            for square_to_check in board.attackers(color, attacker):\n                if board.piece_at(square_to_check) and board.piece_at(square_to_check).piece_type == chess.KING:\n                    continue\n                return True\n        return False\n\n    white_pins = sum(1 for square in board.piece_map() if is_pinned(square, chess.WHITE))\n    black_pins = sum(1 for square in board.piece_map() if is_pinned(square, chess.BLACK))\n    return float(white_pins - black_pins)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the difference in control of key squares (center and opponent's back rank).\"\n    key_squares = [chess.D4, chess.D5, chess.E4, chess.E5] + [chess.square(file, 0) for file in range(8)]\n    control = {chess.WHITE: 0, chess.BLACK: 0}\n    for square in key_squares:\n        if board.is_attacked_by(chess.WHITE, square):\n            control[chess.WHITE] += 1\n        if board.is_attacked_by(chess.BLACK, square):\n            control[chess.BLACK] += 1\n    return float(control[chess.WHITE] - control[chess.BLACK])\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in the number of protected pawns for each side.\"\n    white_protected_pawns = sum(1 for square in board.piece_map() if board.piece_map()[square].color == chess.WHITE and \n                                 board.piece_map()[square].piece_type == chess.PAWN and \n                                 any(board.is_attacked_by(chess.BLACK, attack_square) for attack_square in board.attackers(chess.WHITE, square)))\n    black_protected_pawns = sum(1 for square in board.piece_map() if board.piece_map()[square].color == chess.BLACK and \n                                 board.piece_map()[square].piece_type == chess.PAWN and \n                                 any(board.is_attacked_by(chess.WHITE, attack_square) for attack_square in board.attackers(chess.BLACK, square)))\n    return float(white_protected_pawns - black_protected_pawns)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces each side has on the opponent's second rank.\"\n    white_on_second_rank = sum(1 for square in range(16, 24) if board.piece_at(square) and board.piece_at(square).color == chess.WHITE)\n    black_on_second_rank = sum(1 for square in range(48, 56) if board.piece_at(square) and board.piece_at(square).color == chess.BLACK)\n    return float(white_on_second_rank - black_on_second_rank)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the mobility difference based on the number of legal moves available to each side.\"\n    white_mobility = len(list(board.legal_moves)) if board.turn == chess.WHITE else len(list(board.legal_moves))  # Current turn\n    black_mobility = len(list(board.legal_moves)) if board.turn == chess.BLACK else len(list(board.legal_moves))  # Current turn\n    return float(white_mobility - black_mobility)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Evaluates the number of pieces pinned by each side.\"\n    def count_pinned_pieces(color):\n        return sum(1 for square in board.piece_map() if board.piece_map()[square].color == color and \n                   any(board.is_attacked_by(color, target_square) and \n                       board.is_attacked_by(chess.BLACK if color == chess.WHITE else chess.WHITE, square) \n                       for target_square in board.attackers(color, square))\n              )\n    \n    white_pinned = count_pinned_pieces(chess.WHITE)\n    black_pinned = count_pinned_pieces(chess.BLACK)\n    return float(white_pinned - black_pinned)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the overall piece development by counting pieces on the 2nd and 7th ranks.\"\n    white_development = sum(1 for square in range(8, 16) if board.piece_at(square) and board.piece_at(square).color == chess.WHITE)\n    black_development = sum(1 for square in range(48, 56) if board.piece_at(square) and board.piece_at(square).color == chess.BLACK)\n    return float(white_development - black_development)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the number of squares controlled by each side's pawns.\"\n    def controlled_squares(color):\n        return sum(1 for square in range(64) if any(board.is_attacked_by(color, square) for pawn_square in board.piece_map() if board.piece_map()[pawn_square].color == color and \n                                                       board.piece_map()[pawn_square].piece_type == chess.PAWN))\n    \n    white_control = controlled_squares(chess.WHITE)\n    black_control = controlled_squares(chess.BLACK)\n    return float(white_control - black_control)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the balance of central pawn structure for each side.\"\n    central_pawns_white = sum(1 for square in [chess.E4, chess.E5, chess.D4, chess.D5] \n                               if board.piece_at(square) and board.piece_at(square).color == chess.WHITE)\n    central_pawns_black = sum(1 for square in [chess.E4, chess.E5, chess.D4, chess.D5] \n                               if board.piece_at(square) and board.piece_at(square).color == chess.BLACK)\n    return float(central_pawns_white - central_pawns_black)\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the total number of pieces in the opponent's territory for each side.\"\n    white_in_enemy_territory = sum(1 for square, piece in board.piece_map().items() if piece.color == chess.WHITE and chess.square_rank(square) > 4)\n    black_in_enemy_territory = sum(1 for square, piece in board.piece_map().items() if piece.color == chess.BLACK and chess.square_rank(square) < 3)\n    return float(white_in_enemy_territory - black_in_enemy_territory)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the number of pinned pieces for both sides.\"\n    pinned_pieces = 0\n    for square, piece in board.piece_map().items():\n        for move in board.legal_moves:\n            if move.from_square == square:\n                target_piece = board.piece_at(move.to_square)\n                if target_piece and target_piece.color != piece.color and board.is_attacked_by(piece.color, move.to_square):\n                    pinned_pieces += 1\n                    break\n    return float(pinned_pieces)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the mobility of both sides based on the number of legal moves.\"\n    white_mobility = len(list(board.legal_moves)) if board.turn == chess.WHITE else 0\n    black_mobility = len(list(board.legal_moves)) if board.turn == chess.BLACK else 0\n    return float(white_mobility - black_mobility)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Assesses whether both kings are safe, returning 1.0 for both safe, -1.0 for both unsafe, or 0.0 otherwise.\"\n    white_safe = not board.is_check() and not any(board.is_attacked_by(chess.BLACK, square) for square in board.piece_map() if board.piece_map()[square].color == chess.WHITE and board.piece_map()[square].piece_type == chess.KING)\n    black_safe = not board.is_check() and not any(board.is_attacked_by(chess.WHITE, square) for square in board.piece_map() if board.piece_map()[square].color == chess.BLACK and board.piece_map()[square].piece_type == chess.KING)\n    return float(1.0 if white_safe and black_safe else (-1.0 if not white_safe and not black_safe else 0.0))\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the central control, counting pieces in the center squares (d4, d5, e4, e5).\"\n    center_squares = [chess.parse_square('d4'), chess.parse_square('d5'), chess.parse_square('e4'), chess.parse_square('e5')]\n    white_control = sum(1 for square in center_squares if board.piece_at(square) and board.piece_at(square).color == chess.WHITE)\n    black_control = sum(1 for square in center_squares if board.piece_at(square) and board.piece_at(square).color == chess.BLACK)\n    return float(white_control - black_control)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the number of double attacks for both sides.\"\n    double_attacks = 0\n    for square, piece in board.piece_map().items():\n        current_attacks = board.attackers(not piece.color, square)\n        if len(current_attacks) >= 2:\n            double_attacks += 1\n    return float(double_attacks)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the material disparity of minor pieces (knights and bishops) for both sides.\"\n    material_values = {chess.KNIGHT: 3, chess.BISHOP: 3}\n    white_minor_material = sum(material_values[piece.piece_type] for piece in board.piece_map().values() if piece.color == chess.WHITE and piece.piece_type in [chess.KNIGHT, chess.BISHOP])\n    black_minor_material = sum(material_values[piece.piece_type] for piece in board.piece_map().values() if piece.color == chess.BLACK and piece.piece_type in [chess.KNIGHT, chess.BISHOP])\n    return float(white_minor_material - black_minor_material)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the ratio of pawns' positions to their potential strength.\"\n    pawn_position_values = {chess.PAWN: 1}\n    white_pawn_strength = sum(pawn_position_values[piece.piece_type] * chess.square_rank(square) for square, piece in board.piece_map().items() if piece.color == chess.WHITE and piece.piece_type == chess.PAWN)\n    black_pawn_strength = sum(pawn_position_values[piece.piece_type] * (7 - chess.square_rank(square)) for square, piece in board.piece_map().items() if piece.color == chess.BLACK and piece.piece_type == chess.PAWN)\n    total_strength = white_pawn_strength + black_pawn_strength\n    return float((white_pawn_strength / total_strength) - (black_pawn_strength / total_strength) if total_strength > 0 else 0.0)\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the material difference considering the positions of pieces in the opponent's back rank.\"\n    material_values = {\n        chess.PAWN: 1,\n        chess.KNIGHT: 3,\n        chess.BISHOP: 3,\n        chess.ROOK: 5,\n        chess.QUEEN: 9,\n        chess.KING: 0\n    }\n    white_back_rank_material = sum(material_values[piece.piece_type] for square, piece in board.piece_map().items() \n                                    if piece.color == chess.WHITE and chess.square_rank(square) == 0)\n    black_back_rank_material = sum(material_values[piece.piece_type] for square, piece in board.piece_map().items() \n                                    if piece.color == chess.BLACK and chess.square_rank(square) == 7)\n    return float(white_back_rank_material - black_back_rank_material)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces that can move to a square attacking the enemy king.\"\n    white_attack_moves = sum(1 for move in board.legal_moves if board.piece_at(move.to_square) and \n                              board.is_attacked_by(chess.BLACK, move.to_square) and \n                              board.piece_at(move.to_square).color == chess.WHITE)\n    black_attack_moves = sum(1 for move in board.legal_moves if board.piece_at(move.to_square) and \n                              board.is_attacked_by(chess.WHITE, move.to_square) and \n                              board.piece_at(move.to_square).color == chess.BLACK)\n    return float(white_attack_moves - black_attack_moves)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the density of pieces in the center of the board.\"\n    center_squares = [chess.D4, chess.D5, chess.E4, chess.E5]\n    white_center_density = sum(1 for square in center_squares if board.piece_at(square) and board.piece_at(square).color == chess.WHITE)\n    black_center_density = sum(1 for square in center_squares if board.piece_at(square) and board.piece_at(square).color == chess.BLACK)\n    return float(white_center_density - black_center_density)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Evaluates the number of pieces controlled by each side in the opponent's territory.\"\n    white_controlled_in_black_territory = sum(1 for square in range(0, 32) if board.is_attacked_by(chess.WHITE, square))\n    black_controlled_in_white_territory = sum(1 for square in range(32, 64) if board.is_attacked_by(chess.BLACK, square))\n    return float(white_controlled_in_black_territory - black_controlled_in_white_territory)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the potential mobility of each side based on the number of legal moves.\"\n    white_legal_moves = len(list(board.legal_moves)) if board.turn == chess.WHITE else 0\n    black_legal_moves = len(list(board.legal_moves)) if board.turn == chess.BLACK else 0\n    return float(white_legal_moves - black_legal_moves)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the imbalance in rooks' activity based on their control of open files.\"\n    white_rook_control = sum(1 for square in board.piece_map() if board.piece_map()[square].color == chess.WHITE and \n                              (chess.square_file(square) == 0 or chess.square_file(square) == 7))\n    black_rook_control = sum(1 for square in board.piece_map() if board.piece_map()[square].color == chess.BLACK and \n                              (chess.square_file(square) == 0 or chess.square_file(square) == 7))\n    return float(white_rook_control - black_rook_control)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the number of pieces attacking the enemy's most advanced pawn.\"\n    white_advanced_pawns = [square for square in range(24, 32) if board.piece_at(square) and \n                            board.piece_at(square).piece_type == chess.PAWN and \n                            board.piece_at(square).color == chess.WHITE]\n    black_advanced_pawns = [square for square in range(8) if board.piece_at(square) and \n                            board.piece_at(square).piece_type == chess.PAWN and \n                            board.piece_at(square).color == chess.BLACK]\n    \n    white_attacks = sum(len(board.attackers(chess.BLACK, pawn_square)) for pawn_square in white_advanced_pawns)\n    black_attacks = sum(len(board.attackers(chess.WHITE, pawn_square)) for pawn_square in black_advanced_pawns)\n    return float(white_attacks - black_attacks)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Evaluates the imbalance in material due to missing high-value pieces.\"\n    material_values = {\n        chess.PAWN: 1,\n        chess.KNIGHT: 3,\n        chess.BISHOP: 3,\n        chess.ROOK: 5,\n        chess.QUEEN: 9,\n        chess.KING: 0\n    }\n    white_high_value = sum(material_values[piece.piece_type] for piece in board.piece_map().values() if piece.color == chess.WHITE and piece.piece_type in [chess.ROOK, chess.QUEEN])\n    black_high_value = sum(material_values[piece.piece_type] for piece in board.piece_map().values() if piece.color == chess.BLACK and piece.piece_type in [chess.ROOK, chess.QUEEN])\n    return float(white_high_value - black_high_value)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of pawns that are safely advanced into the opponent's territory.\"\n    safe_advanced_pawns = sum(1 for square in chess.SQUARES if board.piece_at(square) and board.piece_at(square).color == chess.WHITE and chess.square_rank(square) >= 4)\n    return float(safe_advanced_pawns)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures control of the center squares (d4, d5, e4, e5).\"\n    center_squares = [chess.D4, chess.D5, chess.E4, chess.E5]\n    white_control = sum(1 for square in center_squares if board.is_attacked_by(chess.WHITE, square))\n    black_control = sum(1 for square in center_squares if board.is_attacked_by(chess.BLACK, square))\n    return float(white_control - black_control)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the number of pieces attacking the opponent's king.\"\n    white_king_square = next(square for square, piece in board.piece_map().items() if piece.color == chess.WHITE and piece.piece_type == chess.KING)\n    black_king_square = next(square for square, piece in board.piece_map().items() if piece.color == chess.BLACK and piece.piece_type == chess.KING)\n    white_attackers = sum(1 for square in board.legal_moves if board.is_attacked_by(chess.BLACK, white_king_square))\n    black_attackers = sum(1 for square in board.legal_moves if board.is_attacked_by(chess.WHITE, black_king_square))\n    return float(white_attackers - black_attackers)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of doubled pawns on both sides.\"\n    def count_doubled_pawns(color):\n        files = {}\n        for square in board.piece_map():\n            piece = board.piece_at(square)\n            if piece and piece.color == color and piece.piece_type == chess.PAWN:\n                file = chess.square_file(square)\n                if file in files:\n                    files[file] += 1\n                else:\n                    files[file] = 1\n        return sum(1 for count in files.values() if count > 1)\n      \n    white_doubled = count_doubled_pawns(chess.WHITE)\n    black_doubled = count_doubled_pawns(chess.BLACK)\n    return float(white_doubled - black_doubled)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Evaluates the number of pieces on the board versus total pawn structure.\"\n    total_pieces = len(board.piece_map())\n    total_pawns = sum(1 for piece in board.piece_map().values() if piece.piece_type == chess.PAWN)\n    return float(total_pieces - total_pawns)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Evaluates the pawn structure's overall strengths, including the number of protected pawns.\"\n    def count_protected_pawns(color):\n        protected_count = 0\n        for square in chess.SQUARES:\n            piece = board.piece_at(square)\n            if piece and piece.color == color and piece.piece_type == chess.PAWN:\n                file = chess.square_file(square)\n                rank = chess.square_rank(square)\n                if (file > 0 and board.is_attacked_by(not color, chess.square(file - 1, rank))) or \\\n                   (file < 7 and board.is_attacked_by(not color, chess.square(file + 1, rank))):\n                    protected_count += 1\n        return protected_count\n\n    white_protected = count_protected_pawns(chess.WHITE)\n    black_protected = count_protected_pawns(chess.BLACK)\n    return float(white_protected - black_protected)\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in number of advanced pawns for both sides.\"\n    white_advanced_pawns = sum(1 for square in board.piece_map() if board.piece_map()[square].color == chess.WHITE and chess.square_rank(square) >= 4)\n    black_advanced_pawns = sum(1 for square in board.piece_map() if board.piece_map()[square].color == chess.BLACK and chess.square_rank(square) <= 3)\n    return float(white_advanced_pawns - black_advanced_pawns)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the number of double pawns for each side.\"\n    white_double_pawns = sum(1 for square in board.piece_map() if board.piece_map()[square].color == chess.WHITE and\n                              len([1 for s in range(8) if board.piece_at(chess.square(s, chess.square_rank(square))) and \n                              board.piece_at(chess.square(s, chess.square_rank(square))).color == chess.WHITE]) > 1)\n    black_double_pawns = sum(1 for square in board.piece_map() if board.piece_map()[square].color == chess.BLACK and\n                              len([1 for s in range(8) if board.piece_at(chess.square(s, chess.square_rank(square))) and \n                              board.piece_at(chess.square(s, chess.square_rank(square))).color == chess.BLACK]) > 1)\n    return float(white_double_pawns - black_double_pawns)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces attacking each king for both sides.\"\n    white_king_square = next(square for square in board.piece_map() if board.piece_map()[square].color == chess.WHITE and \n                              board.piece_map()[square].piece_type == chess.KING)\n    black_king_square = next(square for square in board.piece_map() if board.piece_map()[square].color == chess.BLACK and \n                              board.piece_map()[square].piece_type == chess.KING)\n    white_attackers = len(board.attackers(chess.BLACK, white_king_square))\n    black_attackers = len(board.attackers(chess.WHITE, black_king_square))\n    return float(white_attackers - black_attackers)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the material advantage of the pieces on the board.\"\n    material_values = {\n        chess.PAWN: 1,\n        chess.KNIGHT: 3,\n        chess.BISHOP: 3,\n        chess.ROOK: 5,\n        chess.QUEEN: 9,\n        chess.KING: 0\n    }\n    white_material = sum(material_values[piece.piece_type] for piece in board.piece_map().values() if piece.color == chess.WHITE)\n    black_material = sum(material_values[piece.piece_type] for piece in board.piece_map().values() if piece.color == chess.BLACK)\n    return float(white_material - black_material)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the central control for both sides.\"\n    central_squares = [chess.E4, chess.D4, chess.E5, chess.D5]\n    white_control = sum(1 for square in central_squares if board.is_attacked_by(chess.WHITE, square))\n    black_control = sum(1 for square in central_squares if board.is_attacked_by(chess.BLACK, square))\n    return float(white_control - black_control)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the safety of major pieces (rooks and queens) considering their position.\"\n    piece_safety_values = {chess.ROOK: 0, chess.QUEEN: 1}\n    \n    def safety_score(color):\n        score = 0\n        for square, piece in board.piece_map().items():\n            if piece.color == color and piece.piece_type in piece_safety_values:\n                score += piece_safety_values[piece.piece_type]\n                if board.is_attacked_by(not color, square):\n                    score -= 1  # Penalize if the piece is attacked\n        return score\n    \n    white_safety = safety_score(chess.WHITE)\n    black_safety = safety_score(chess.BLACK)\n    return float(white_safety - black_safety)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates mobility advantage by examining legal moves.\"\n    white_mobility = len(list(board.legal_moves)) if board.turn == chess.WHITE else 0\n    black_mobility = len(list(board.legal_moves)) if board.turn == chess.BLACK else 0\n    return float(white_mobility - black_mobility)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Evaluates the number of potential pawn promotions for both sides.\"\n    white_promotion_pawns = sum(1 for square in board.piece_map() if board.piece_map()[square].color == chess.WHITE and \n                                 chess.square_rank(square) == 6)\n    black_promotion_pawns = sum(1 for square in board.piece_map() if board.piece_map()[square].color == chess.BLACK and \n                                 chess.square_rank(square) == 1)\n    return float(white_promotion_pawns - black_promotion_pawns)\n",
    "def feature(board: chess.Board) -> float:\n    'Calculates the mobility of each side based on the number of legal moves available.'\n    white_mobility = len(list(board.legal_moves)) if board.turn == chess.WHITE else 0\n    black_mobility = len(list(board.legal_moves)) if board.turn == chess.BLACK else 0\n    return float(white_mobility - black_mobility)\n\n",
    "def feature(board: chess.Board) -> float:\n    'Measures the number of pieces under attack by the opponent.'\n    under_attack_count = sum(1 for square in board.piece_map() if board.piece_map()[square].color == board.turn and board.is_attacked_by(not board.turn, square))\n    return float(under_attack_count)\n\n",
    "def feature(board: chess.Board) -> float:\n    'Counts the total number of undefended pieces for each side.'\n    undefended_count = sum(1 for square, piece in board.piece_map().items() if piece.color == board.turn and len(board.attackers(not piece.color, square)) == 0)\n    return float(undefended_count)\n\n",
    "def feature(board: chess.Board) -> float:\n    'Calculates the total mobility of knight pieces on the board.'\n    knight_mobility = sum(len(list(board.legal_moves)) for square in board.piece_map() if board.piece_map()[square].piece_type == chess.KNIGHT)\n    return float(knight_mobility)\n\n",
    "def feature(board: chess.Board) -> float:\n    'Evaluates the presence of pieces on the opponent\u2019s 7th and 2nd ranks which can indicate a strong position.'\n    white_threats = sum(1 for square in board.piece_map() if board.piece_map()[square].color == chess.WHITE and chess.square_rank(square) == 6)\n    black_threats = sum(1 for square in board.piece_map() if board.piece_map()[square].color == chess.BLACK and chess.square_rank(square) == 1)\n    return float(white_threats - black_threats)\n\n",
    "def feature(board: chess.Board) -> float:\n    'Computes the control of central squares (d4, d5, e4, e5) by each side.'\n    central_squares = [chess.D4, chess.D5, chess.E4, chess.E5]\n    white_control = sum(1 for square in central_squares if board.is_attacked_by(chess.WHITE, square))\n    black_control = sum(1 for square in central_squares if board.is_attacked_by(chess.BLACK, square))\n    return float(white_control - black_control)\n\n",
    "def feature(board: chess.Board) -> float:\n    'Measures the activity of rooks by counting their control over open files.'\n    open_files = sum(1 for file in range(8) if not any(board.piece_at(chess.square(file, rank)) for rank in range(8)))\n    return float(open_files)\n\n",
    "def feature(board: chess.Board) -> float:\n    'Calculates the number of piece pairs (two pieces of the same color on adjacent squares) for each side.'\n    piece_pairs = 0\n    for square1 in board.piece_map():\n        for square2 in board.piece_map():\n            if square1 != square2 and board.piece_map()[square1].color == board.piece_map()[square2].color:\n                if chess.square_distance(square1, square2) == 1:  # Adjacent squares\n                    piece_pairs += 1\n    return float(piece_pairs)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the number of connected pawns for each side.\"\n    def connected_pawns(color):\n        count = 0\n        for file in range(8):\n            if board.piece_at(chess.square(file, 1 if color == chess.WHITE else 6)) == chess.PAWN:\n                if (file > 0 and board.piece_at(chess.square(file-1, 1 if color == chess.WHITE else 6)) == chess.PAWN) or \\\n                   (file < 7 and board.piece_at(chess.square(file+1, 1 if color == chess.WHITE else 6)) == chess.PAWN):\n                    count += 1\n        return count\n    white_connected = connected_pawns(chess.WHITE)\n    black_connected = connected_pawns(chess.BLACK)\n    return float(white_connected - black_connected)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces on the seventh rank for each color.\"\n    white_seventh_rank = sum(1 for file in range(8) if board.piece_at(chess.square(file, 6)) and board.piece_at(chess.square(file, 6)).color == chess.WHITE)\n    black_seventh_rank = sum(1 for file in range(8) if board.piece_at(chess.square(file, 1)) and board.piece_at(chess.square(file, 1)).color == chess.BLACK)\n    return float(white_seventh_rank - black_seventh_rank)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the king's safety based on the number of pieces defending it.\"\n    white_king_square = next(square for square in board.piece_map() if board.piece_map()[square].color == chess.WHITE and board.piece_map()[square].piece_type == chess.KING)\n    black_king_square = next(square for square in board.piece_map() if board.piece_map()[square].color == chess.BLACK and board.piece_map()[square].piece_type == chess.KING)\n    white_defenders = sum(1 for square in board.piece_map() if board.piece_map()[square].color == chess.WHITE and board.is_attacked_by(chess.BLACK, white_king_square))\n    black_defenders = sum(1 for square in board.piece_map() if board.piece_map()[square].color == chess.BLACK and board.is_attacked_by(chess.WHITE, black_king_square))\n    return float(white_defenders - black_defenders)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the number of isolated pawns for each side.\"\n    def isolated_pawns(color):\n        count = 0\n        for file in range(8):\n            if board.piece_at(chess.square(file, 1 if color == chess.WHITE else 6)) == chess.PAWN:\n                if (file > 0 and board.piece_at(chess.square(file-1, 1 if color == chess.WHITE else 6)) != chess.PAWN) and \\\n                   (file < 7 and board.piece_at(chess.square(file+1, 1 if color == chess.WHITE else 6)) != chess.PAWN):\n                    count += 1\n        return count\n    white_isolated = isolated_pawns(chess.WHITE)\n    black_isolated = isolated_pawns(chess.BLACK)\n    return float(white_isolated - black_isolated)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the central control based on pieces in central squares.\"\n    central_squares = [chess.E4, chess.E5, chess.D4, chess.D5]\n    white_control = sum(1 for square in central_squares if board.is_attacked_by(chess.WHITE, square))\n    black_control = sum(1 for square in central_squares if board.is_attacked_by(chess.BLACK, square))\n    return float(white_control - black_control)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the activity of the queen based on its potential to attack.\"\n    white_queen = next((square for square in board.piece_map() if board.piece_map()[square].color == chess.WHITE and board.piece_map()[square].piece_type == chess.QUEEN), None)\n    black_queen = next((square for square in board.piece_map() if board.piece_map()[square].color == chess.BLACK and board.piece_map()[square].piece_type == chess.QUEEN), None)\n    white_queen_activity = len([move for move in board.legal_moves if move.from_square == white_queen]) if white_queen else 0\n    black_queen_activity = len([move for move in board.legal_moves if move.from_square == black_queen]) if black_queen else 0\n    return float(white_queen_activity - black_queen_activity)\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the number of pieces that are currently defended by other pieces.\"\n    defended_count = sum(1 for square, piece in board.piece_map().items() if piece.color == board.turn and len(board.attackers(piece.color, square)) > 0)\n    return float(defended_count)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the difference in number of pawns each side has in the opponent's territory.\"\n    white_pawns_in_opponent_territory = sum(1 for square, piece in board.piece_map().items() if piece.color == chess.WHITE and chess.square_rank(square) > 4)\n    black_pawns_in_opponent_territory = sum(1 for square, piece in board.piece_map().items() if piece.color == chess.BLACK and chess.square_rank(square) < 4)\n    return float(white_pawns_in_opponent_territory - black_pawns_in_opponent_territory)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the number of available captures for the current turn.\"\n    current_turn = board.turn\n    available_captures = sum(1 for move in board.legal_moves if board.piece_at(move.to_square) is not None and board.piece_at(move.to_square).color != current_turn)\n    return float(available_captures)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of moves that put the opponent's king in check.\"\n    opponent_color = chess.BLACK if board.turn else chess.WHITE\n    check_count = sum(1 for move in board.legal_moves if board.is_check())\n    return float(check_count)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in central control by pieces for both sides.\"\n    central_squares = [chess.D4, chess.E4, chess.D5, chess.E5]\n    white_control = sum(1 for square in central_squares if board.is_attacked_by(chess.WHITE, square))\n    black_control = sum(1 for square in central_squares if board.is_attacked_by(chess.BLACK, square))\n    return float(white_control - black_control)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the total number of pieces on the board.\"\n    total_piece_count = len(board.piece_map())\n    return float(total_piece_count)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the number of squares attacked by all pieces of each color.\"\n    def count_attacked_squares(color):\n        attacked_squares = set()\n        for move in board.legal_moves:\n            if board.piece_at(move.from_square).color == color:\n                attacked_squares.add(move.to_square)\n        return len(attacked_squares)\n    white_attacked = count_attacked_squares(chess.WHITE)\n    black_attacked = count_attacked_squares(chess.BLACK)\n    return float(white_attacked - black_attacked)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the number of connected pawns for each color.\"\n    def count_connected_pawns(color):\n        connected_pawn_count = 0\n        for square, piece in board.piece_map().items():\n            if piece.color == color and piece.piece_type == chess.PAWN:\n                file = chess.square_file(square)\n                if (board.piece_at(chess.parse_square(chess.square_name(square + 1))) and \n                    board.piece_at(chess.parse_square(chess.square_name(square - 1))) \n                    and board.piece_at(chess.parse_square(chess.square_name(square + 1))).color == color):\n                    connected_pawn_count += 1\n        return connected_pawn_count\n    white_connected = count_connected_pawns(chess.WHITE)\n    black_connected = count_connected_pawns(chess.BLACK)\n    return float(white_connected - black_connected)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the threat level of the most powerful piece opposing the current turn.\"\n    opponent_color = chess.BLACK if board.turn else chess.WHITE\n    threat_value = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == opponent_color and piece.piece_type in {chess.QUEEN, chess.ROOK, chess.KNIGHT, chess.BISHOP}:\n            threat_value = max(threat_value, {chess.QUEEN: 9, chess.ROOK: 5, chess.KNIGHT: 3, chess.BISHOP: 3}[piece.piece_type])\n    return float(threat_value)\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in piece mobility for both sides based on legal moves.\"\n    white_mobility = len(list(board.legal_moves)) if board.turn else 0\n    black_mobility = len(list(board.legal_moves)) if not board.turn else 0\n    return float(white_mobility - black_mobility)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of doubled pawns for each side.\"\n    white_doubled_pawns = sum(1 for file in range(8) if sum(1 for rank in range(8) if board.piece_at(chess.square(file, rank)) == chess.PAWN and board.piece_at(chess.square(file, rank)).color == chess.WHITE) > 1)\n    black_doubled_pawns = sum(1 for file in range(8) if sum(1 for rank in range(8) if board.piece_at(chess.square(file, rank)) == chess.PAWN and board.piece_at(chess.square(file, rank)).color == chess.BLACK) > 1)\n    return float(white_doubled_pawns - black_doubled_pawns)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the number of unprotected pieces each side has.\"\n    unprotected_white = sum(1 for square, piece in board.piece_map().items() if piece.color == chess.WHITE and all(not board.is_attacked_by(chess.BLACK, square) for square in board.attackers(chess.BLACK, square)))\n    unprotected_black = sum(1 for square, piece in board.piece_map().items() if piece.color == chess.BLACK and all(not board.is_attacked_by(chess.WHITE, square) for square in board.attackers(chess.WHITE, square)))\n    return float(unprotected_white - unprotected_black)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in the number of minor pieces each side has.\"\n    white_minor_pieces = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE and piece.piece_type in {chess.KNIGHT, chess.BISHOP})\n    black_minor_pieces = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK and piece.piece_type in {chess.KNIGHT, chess.BISHOP})\n    return float(white_minor_pieces - black_minor_pieces)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Evaluates the pawn structure by counting isolated pawns for each side.\"\n    white_isolated_pawns = sum(1 for file in range(8) if board.piece_at(chess.square(file, 1)) == chess.PAWN and (file == 0 or file == 7 or (board.piece_at(chess.square(file - 1, 1)) is None and board.piece_at(chess.square(file + 1, 1)) is None)))\n    black_isolated_pawns = sum(1 for file in range(8) if board.piece_at(chess.square(file, 6)) == chess.PAWN and (file == 0 or file == 7 or (board.piece_at(chess.square(file - 1, 6)) is None and board.piece_at(chess.square(file + 1, 6)) is None)))\n    return float(white_isolated_pawns - black_isolated_pawns)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the number of moves left in the game according to the halfmove clock.\"\n    halfmove_limit = 50 \n    return float(halfmove_limit - board.halfmove_clock)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the overall piece count for both players.\"\n    white_piece_count = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE)\n    black_piece_count = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK)\n    return float(white_piece_count - black_piece_count)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces attacked by each side.\"\n    white_attacked = sum(1 for square in board.piece_map() if board.is_attacked_by(chess.WHITE, square))\n    black_attacked = sum(1 for square in board.piece_map() if board.is_attacked_by(chess.BLACK, square))\n    return float(white_attacked - black_attacked)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the potential pawn promotion advantage for each side.\"\n    white_promotion_pawns = sum(1 for square in range(56, 64) if board.piece_at(square) == chess.PAWN and board.piece_at(square).color == chess.WHITE)\n    black_promotion_pawns = sum(1 for square in range(0, 8) if board.piece_at(square) == chess.PAWN and board.piece_at(square).color == chess.BLACK)\n    return float(white_promotion_pawns - black_promotion_pawns)\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the control of the center squares by measuring pieces and pawn presence.\"\n    central_squares = [chess.D4, chess.D5, chess.E4, chess.E5]\n    white_control = sum(1 for square in central_squares if board.piece_at(square) and board.piece_at(square).color == chess.WHITE)\n    black_control = sum(1 for square in central_squares if board.piece_at(square) and board.piece_at(square).color == chess.BLACK)\n    return float(white_control - black_control)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the mobility of pieces based on the number of legal moves available.\"\n    white_mobility = sum(1 for move in board.legal_moves if board.piece_at(move.from_square) and board.piece_at(move.from_square).color == chess.WHITE)\n    black_mobility = sum(1 for move in board.legal_moves if board.piece_at(move.from_square) and board.piece_at(move.from_square).color == chess.BLACK)\n    return float(white_mobility - black_mobility)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Evaluates king safety by counting the number of available escape squares around the kings.\"\n    def escape_squares_count(color):\n        king_square = next(square for square in board.piece_map() if board.piece_map()[square].color == color and board.piece_map()[square].piece_type == chess.KING)\n        return sum(1 for square in range(64) if chess.square_distance(king_square, square) == 1 and board.piece_at(square) is None)\n    white_escape = escape_squares_count(chess.WHITE)\n    black_escape = escape_squares_count(chess.BLACK)\n    return float(white_escape - black_escape)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the number of extra squares controlled by pawns in the opponent's half.\"\n    controlled_by_white = sum(1 for square in range(0, 32) if board.is_attacked_by(chess.WHITE, square))\n    controlled_by_black = sum(1 for square in range(32, 64) if board.is_attacked_by(chess.BLACK, square))\n    return float(controlled_by_white - controlled_by_black)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in the number of pieces in the endgame stage for both sides.\"\n    endgame_threshold = 5 \n    white_pieces = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE)\n    black_pieces = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK)\n    return float((white_pieces < endgame_threshold) - (black_pieces < endgame_threshold))\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Evaluates the potential for creating passed pawns depending on pawn structure.\"\n    white_passed = sum(1 for square in board.piece_map() if board.piece_map()[square].color == chess.WHITE and board.piece_map()[square].piece_type == chess.PAWN and not any(board.piece_at(file) for file in range(chess.square_file(square)) if board.piece_at(chess.parse_square(chess.square_name(file + chess.square_rank(square)))) is not None))\n    black_passed = sum(1 for square in board.piece_map() if board.piece_map()[square].color == chess.BLACK and board.piece_map()[square].piece_type == chess.PAWN and not any(board.piece_at(file) for file in range(chess.square_file(square)) if board.piece_at(chess.parse_square(chess.square_name(file + chess.square_rank(square)))) is not None))\n    return float(white_passed - black_passed)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the presence of pieces of both sides on the 7th rank, contributing to endgame dynamics.\"\n    seventh_rank_white = sum(1 for square in range(chess.A7, chess.H7) if board.piece_at(square) and board.piece_at(square).color == chess.WHITE)\n    seventh_rank_black = sum(1 for square in range(chess.A7, chess.H7) if board.piece_at(square) and board.piece_at(square).color == chess.BLACK)\n    return float(seventh_rank_white - seventh_rank_black)\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the number of pieces each player has on their opponent's 6th rank.\"\n    white_on_6th_rank = sum(1 for square in range(0, 8) if board.piece_at(chess.square(square, 5)) and board.piece_at(chess.square(square, 5)).color == chess.WHITE)\n    black_on_6th_rank = sum(1 for square in range(0, 8) if board.piece_at(chess.square(square, 2)) and board.piece_at(chess.square(square, 2)).color == chess.BLACK)\n    return float(white_on_6th_rank - black_on_6th_rank)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the total number of open files available for rooks.\"\n    white_open_files = sum(1 for file in range(8) if all(board.piece_at(chess.square(file, rank)) is None for rank in range(8) if board.piece_at(chess.square(file, rank)) and board.piece_at(chess.square(file, rank)).color == chess.WHITE))\n    black_open_files = sum(1 for file in range(8) if all(board.piece_at(chess.square(file, rank)) is None for rank in range(8) if board.piece_at(chess.square(file, rank)) and board.piece_at(chess.square(file, rank)).color == chess.BLACK))\n    return float(white_open_files - black_open_files)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in piece activity by considering the number of legal moves each side has.\"\n    white_moves = len(list(board.legal_moves))\n    black_moves = len(list(board.legal_moves))\n    return float(white_moves - black_moves)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the disparity in the number of minor pieces (knights and bishops) each side has.\"\n    white_minor_count = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE and piece.piece_type in {chess.KNIGHT, chess.BISHOP})\n    black_minor_count = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK and piece.piece_type in {chess.KNIGHT, chess.BISHOP})\n    return float(white_minor_count - black_minor_count)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Evaluates the king safety based on the number of pieces around each king.\"\n    def king_safety(color):\n        king_square = next(square for square in board.piece_map() if board.piece_map()[square].piece_type == chess.KING and board.piece_map()[square].color == color)\n        surrounding_pieces_count = sum(1 for square in board.piece_map() if chess.square_distance(square, king_square) <= 1 and board.piece_map()[square].color == color)\n        return surrounding_pieces_count\n    \n    white_safety = king_safety(chess.WHITE)\n    black_safety = king_safety(chess.BLACK)\n    return float(white_safety - black_safety)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the average value of pieces for each side relative to their total.\"\n    material_values = {\n        chess.PAWN: 1,\n        chess.KNIGHT: 3,\n        chess.BISHOP: 3,\n        chess.ROOK: 5,\n        chess.QUEEN: 9,\n        chess.KING: 0\n    }\n    def average_piece_value(color):\n        pieces = [material_values[piece.piece_type] for piece in board.piece_map().values() if piece.color == color]\n        return sum(pieces) / len(pieces) if pieces else 0\n    \n    white_average = average_piece_value(chess.WHITE)\n    black_average = average_piece_value(chess.BLACK)\n    return float(white_average - black_average)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the sum of the values of pieces that are currently pinned.\"\n    material_values = {\n        chess.PAWN: 1,\n        chess.KNIGHT: 3,\n        chess.BISHOP: 3,\n        chess.ROOK: 5,\n        chess.QUEEN: 9,\n        chess.KING: 0\n    }\n    pinned_value = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == board.turn and board.is_attacked_by(not board.turn, square):\n            pinned_value += material_values.get(piece.piece_type, 0)\n    return float(pinned_value)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the difference in active pieces (pieces not blocked by pawns) for both sides.\"\n    def active_pieces(color):\n        return sum(1 for square, piece in board.piece_map().items() \n                   if piece.color == color and piece.piece_type != chess.PAWN and \n                   square not in board.attackers(not color, square))\n    \n    white_active = active_pieces(chess.WHITE)\n    black_active = active_pieces(chess.BLACK)\n    return float(white_active - black_active)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of potential threats (opponent pieces that can be threatened next move).\"\n    threats = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == board.turn:\n            for move in board.legal_moves:\n                if move.from_square == square and (board.piece_at(move.to_square) is None or board.piece_at(move.to_square).color != board.turn):\n                    threats += 1\n    return float(threats)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the control of key squares: f7, e7, f2, and e2.\"\n    key_squares = [chess.F7, chess.E7, chess.F2, chess.E2]\n    white_control = sum(1 for square in key_squares if board.is_attacked_by(chess.WHITE, square))\n    black_control = sum(1 for square in key_squares if board.is_attacked_by(chess.BLACK, square))\n    return float(white_control - black_control)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the number of doubled pawns for each side.\"\n    def doubled_pawns(color):\n        pawns = [square for square, piece in board.piece_map().items() if piece.color == color and piece.piece_type == chess.PAWN]\n        files = [chess.square_file(pawn) for pawn in pawns]\n        return len(files) - len(set(files))\n\n    white_doubled = doubled_pawns(chess.WHITE)\n    black_doubled = doubled_pawns(chess.BLACK)\n    return float(white_doubled - black_doubled)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the number of open files controlled by rooks for both players.\"\n    def open_files(color):\n        controlled_files = set()\n        for square, piece in board.piece_map().items():\n            if piece.color == color and piece.piece_type == chess.ROOK:\n                controlled_files.add(chess.square_file(square))\n        return len(controlled_files)\n    \n    white_open = open_files(chess.WHITE)\n    black_open = open_files(chess.BLACK)\n    return float(white_open - black_open)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the total number of pieces (excluding pawns) that have no legal moves.\"\n    immobile_count = sum(1 for square, piece in board.piece_map().items() if piece.piece_type != chess.PAWN and len(list(board.legal_moves)) == 0)\n    return float(immobile_count)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures how many checks the opponent can make in the next move.\"\n    opponent_checks = 0\n    for move in board.legal_moves:\n        opponent_board = board.copy()\n        opponent_board.push(move)\n        if opponent_board.is_check():\n            opponent_checks += 1\n    return float(opponent_checks)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the ratio of bishops to knights for both sides and returns their difference.\"\n    white_bishops = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE and piece.piece_type == chess.BISHOP)\n    white_knights = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE and piece.piece_type == chess.KNIGHT)\n    black_bishops = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK and piece.piece_type == chess.BISHOP)\n    black_knights = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK and piece.piece_type == chess.KNIGHT)\n\n    white_ratio = white_bishops / (white_knights + 1)  # Avoid division by zero\n    black_ratio = black_bishops / (black_knights + 1)  # Avoid division by zero\n    \n    return float(white_ratio - black_ratio)\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the mobility advantage by calculating total legal moves for each side.\"\n    white_mobility = len(list(board.legal_moves))\n    black_mobility = len(list(board.legal_moves))\n    return float(white_mobility - black_mobility)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the value of knights in the opponent's territory.\"\n    knight_value = 3\n    opponent_knight_value = sum(knight_value for square in board.piece_map() if board.piece_map()[square].color != board.turn and board.piece_map()[square].piece_type == chess.KNIGHT and chess.square_rank(square) > 4)\n    return float(opponent_knight_value)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Assesses the number of pieces on open files for each side.\"\n    def open_file_count(color):\n        return sum(1 for file in range(8) if all(board.piece_at(chess.parse_square(chr(file + 97) + str(rank + 1))) is None or board.piece_at(chess.parse_square(chr(file + 97) + str(rank + 1))).color == color for rank in range(8)))\n\n    white_open_files = open_file_count(chess.WHITE)\n    black_open_files = open_file_count(chess.BLACK)\n    return float(white_open_files - black_open_files)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the total piece placement value based on position strength.\"\n    piece_values = {\n        chess.PAWN: 1,\n        chess.KNIGHT: 3,\n        chess.BISHOP: 3,\n        chess.ROOK: 5,\n        chess.QUEEN: 9\n    }\n    positioning_value = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == board.turn:\n            positioning_value += piece_values.get(piece.piece_type, 0) * (8 - chess.square_rank(square))\n\n    return float(positioning_value)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the number of pieces controlling center squares for each side.\"\n    center_squares = [chess.E4, chess.E5, chess.D4, chess.D5]\n    white_control = sum(1 for square in center_squares if board.is_attacked_by(chess.WHITE, square))\n    black_control = sum(1 for square in center_squares if board.is_attacked_by(chess.BLACK, square))\n    return float(white_control - black_control)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the difference in pawn structure between players.\"\n    def pawn_structure(color):\n        pawn_structure_value = 0\n        for square in chess.SQUARES:\n            piece = board.piece_at(square)\n            if piece and piece.color == color and piece.piece_type == chess.PAWN:\n                if chess.square_rank(square) == 6:  # 7th rank for white\n                    pawn_structure_value += 1\n                elif chess.square_rank(square) == 1:  # 2nd rank for black\n                    pawn_structure_value += 1\n        return pawn_structure_value\n\n    white_structure = pawn_structure(chess.WHITE)\n    black_structure = pawn_structure(chess.BLACK)\n    return float(white_structure - black_structure)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Evaluates the number of pieces that can potentially be sacrificed.\"\n    sacrificing_potential = sum(1 for piece in board.piece_map().values() if piece.color == board.turn and piece.piece_type in {chess.ROOK, chess.QUEEN, chess.BISHOP})\n    return float(sacrificing_potential)\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the number of pawns on the 7th rank versus the 2nd rank.\"\n    white_pawns_on_7th = sum(1 for square in chess.SQUARES if board.piece_at(square) and board.piece_at(square).color == chess.WHITE and chess.square_rank(square) == 6)\n    black_pawns_on_2nd = sum(1 for square in chess.SQUARES if board.piece_at(square) and board.piece_at(square).color == chess.BLACK and chess.square_rank(square) == 1)\n    return float(white_pawns_on_7th - black_pawns_on_2nd)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the piece activity by counting the number of legal moves available for each side.\"\n    white_legal_moves = len(list(board.legal_moves)) if board.turn else 0\n    black_legal_moves = len(list(board.legal_moves)) if not board.turn else 0\n    return float(white_legal_moves - black_legal_moves)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the number of pieces under attack by opponents.\"\n    white_under_attack = sum(1 for square in chess.SQUARES if board.piece_at(square) and board.piece_at(square).color == chess.WHITE and board.is_attacked_by(chess.BLACK, square))\n    black_under_attack = sum(1 for square in chess.SQUARES if board.piece_at(square) and board.piece_at(square).color == chess.BLACK and board.is_attacked_by(chess.WHITE, square))\n    return float(black_under_attack - white_under_attack)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of developed pieces for each side (not on the back rank).\"\n    developed_white = sum(1 for square in chess.SQUARES if board.piece_at(square) and board.piece_at(square).color == chess.WHITE and chess.square_rank(square) > 1)\n    developed_black = sum(1 for square in chess.SQUARES if board.piece_at(square) and board.piece_at(square).color == chess.BLACK and chess.square_rank(square) < 6)\n    return float(developed_white - developed_black)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Evaluates the rook activity by counting the number of open files they control.\"\n    def open_files(color):\n        controlled_files = set()\n        for square in chess.SQUARES:\n            piece = board.piece_at(square)\n            if piece and piece.color == color and piece.piece_type == chess.ROOK:\n                controlled_files.add(chess.square_file(square))\n        open_file_count = sum(1 for f in range(8) if not any(board.piece_at(chess.square(f, r)) for r in range(8)))\n        return open_file_count\n    \n    return float(open_files(chess.WHITE) - open_files(chess.BLACK))\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of kingside and queenside castling rights.\"\n    white_castle_rights = int(board.has_castling_rights(chess.WHITE))\n    black_castle_rights = int(board.has_castling_rights(chess.BLACK))\n    return float(white_castle_rights - black_castle_rights)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in control over the f7 and f2 squares for tactical threats.\"\n    white_f2_control = 1 if board.is_attacked_by(chess.WHITE, chess.F2) else 0\n    black_f7_control = 1 if board.is_attacked_by(chess.BLACK, chess.F7) else 0\n    return float(white_f2_control - black_f7_control)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the total number of minor pieces (knights and bishops) remaining for both sides.\"\n    white_minor = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE and piece.piece_type in [chess.KNIGHT, chess.BISHOP])\n    black_minor = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK and piece.piece_type in [chess.KNIGHT, chess.BISHOP])\n    return float(white_minor - black_minor)\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces pinned by the opponent's pieces.\"\n    pinned_count = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == board.turn:\n            for target in board.attackers(board.turn, square):\n                if board.piece_at(target) and board.piece_at(target).color != board.turn:\n                    pinned_count += 1\n                    break\n    return float(pinned_count)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the advancement of pieces towards the opponent's back rank.\"\n    white_advanced = sum(1 for square, piece in board.piece_map().items() if piece.color == chess.WHITE and chess.square_rank(square) > 4)\n    black_advanced = sum(1 for square, piece in board.piece_map().items() if piece.color == chess.BLACK and chess.square_rank(square) < 3)\n    return float(white_advanced - black_advanced)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the mobility of pieces based on the number of legal moves available.\"\n    white_mobility = sum(1 for move in board.legal_moves if board.piece_map()[move.from_square].color == chess.WHITE)\n    black_mobility = sum(1 for move in board.legal_moves if board.piece_map()[move.from_square].color == chess.BLACK)\n    return float(white_mobility - black_mobility)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the threats posed by minor pieces to the opponent's major pieces.\"\n    threat_score = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == board.turn and piece.piece_type in {chess.KNIGHT, chess.BISHOP}:\n            for target in board.legal_moves:\n                if target.to_square in board.piece_map() and board.piece_map()[target.to_square].piece_type in {chess.QUEEN, chess.ROOK}:\n                    threat_score += 1\n    return float(threat_score)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the disparity in control over center squares (d4, e4 for White; d5, e5 for Black).\"\n    center_squares = [chess.square(3, 3), chess.square(4, 3), chess.square(3, 4), chess.square(4, 4)]\n    white_control = sum(1 for square in center_squares if board.is_attacked_by(chess.WHITE, square))\n    black_control = sum(1 for square in center_squares if board.is_attacked_by(chess.BLACK, square))\n    return float(white_control - black_control)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Evaluates the piece coordination by counting the number of pieces supporting each other.\"\n    support_count = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == board.turn:\n            for target in board.attackers(piece.color, square):\n                if board.piece_at(target) and board.piece_at(target).color == piece.color:\n                    support_count += 1\n    return float(support_count)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the number of squares that are attacked but not defended.\"\n    attacked_not_defended = sum(1 for square in range(64) if board.is_attacked_by(board.turn, square) and not any(board.is_attacked_by(board.turn, target) for target in board.attackers(not board.turn, square)))\n    return float(attacked_not_defended)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Tracks the number of pieces on each player's back rank.\"\n    white_back_rank_pieces = sum(1 for square in range(56, 64) if board.piece_at(square) and board.piece_at(square).color == chess.WHITE)\n    black_back_rank_pieces = sum(1 for square in range(0, 8) if board.piece_at(square) and board.piece_at(square).color == chess.BLACK)\n    return float(white_back_rank_pieces - black_back_rank_pieces)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the number of available captures for each player in the current position.\"\n    white_captures = sum(1 for move in board.legal_moves if move.to_square in board.piece_map() and board.piece_map()[move.to_square].color == chess.BLACK)\n    black_captures = sum(1 for move in board.legal_moves if move.to_square in board.piece_map() and board.piece_map()[move.to_square].color == chess.WHITE)\n    return float(white_captures - black_captures)\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the number of pieces on the board for each side.\"\n    white_piece_count = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE)\n    black_piece_count = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK)\n    return float(white_piece_count - black_piece_count)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Evaluates the threefold repetition rule possibility for each side.\"\n    white_repetition = board.is_repetition(chess.WHITE)\n    black_repetition = board.is_repetition(chess.BLACK)\n    return float(white_repetition - black_repetition)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the number of squares controlled by both sides' pieces.\"\n    controlled_squares_white = sum(1 for square in range(64) if board.is_attacked_by(chess.WHITE, square))\n    controlled_squares_black = sum(1 for square in range(64) if board.is_attacked_by(chess.BLACK, square))\n    return float(controlled_squares_white - controlled_squares_black)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures king safety based on the distribution of pawns around each king.\"\n    def king_safety(color):\n        king_square = next(square for square, piece in board.piece_map().items() if piece.color == color and piece.piece_type == chess.KING)\n        safety_value = 0\n        for square in range(64):\n            if board.piece_at(square) and board.piece_at(square).color == color and board.piece_at(square).piece_type == chess.PAWN:\n                distance = chess.square_distance(king_square, square)\n                safety_value += max(0, (3 - distance))\n        return safety_value\n\n    white_safety = king_safety(chess.WHITE)\n    black_safety = king_safety(chess.BLACK)\n    return float(white_safety - black_safety)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the number of squares vacated by opponent's pieces.\"\n    vacated_squares_white = sum(1 for square in range(64) if board.piece_at(square) and board.piece_at(square).color == chess.BLACK and not board.is_attacked_by(chess.WHITE, square))\n    vacated_squares_black = sum(1 for square in range(64) if board.piece_at(square) and board.piece_at(square).color == chess.WHITE and not board.is_attacked_by(chess.BLACK, square))\n    return float(vacated_squares_white - vacated_squares_black)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the tempo advantage based on the move order and unique moves played.\"\n    unique_moves = len(set(str(move) for move in board.legal_moves))\n    return float(unique_moves)\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the imbalance in piece value by comparing knights and bishops for both sides.\"\n    material_values = {chess.PAWN: 1, chess.KNIGHT: 3, chess.BISHOP: 3}\n    white_knights = sum(material_values[chess.KNIGHT] for piece in board.piece_map().values() if piece.color == chess.WHITE and piece.piece_type == chess.KNIGHT)\n    white_bishops = sum(material_values[chess.BISHOP] for piece in board.piece_map().values() if piece.color == chess.WHITE and piece.piece_type == chess.BISHOP)\n    black_knights = sum(material_values[chess.KNIGHT] for piece in board.piece_map().values() if piece.color == chess.BLACK and piece.piece_type == chess.KNIGHT)\n    black_bishops = sum(material_values[chess.BISHOP] for piece in board.piece_map().values() if piece.color == chess.BLACK and piece.piece_type == chess.BISHOP)\n    return float((white_knights - black_knights) + (white_bishops - black_bishops))\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Evaluates control over the sixth and third ranks for both sides.\"\n    white_control = sum(1 for square in range(48, 56) if board.is_attacked_by(chess.WHITE, square))\n    black_control = sum(1 for square in range(8, 16) if board.is_attacked_by(chess.BLACK, square))\n    return float(white_control - black_control)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of doubled pawns for both sides.\"\n    def doubled_pawns(color):\n        return sum(1 for file in range(8) if board.piece_at(chess.parse_square(f'{chr(file + 97)}2')) and color == chess.WHITE and board.piece_at(chess.parse_square(f'{chr(file + 97)}7')) and color == chess.BLACK)\n\n    white_doubled = doubled_pawns(chess.WHITE)\n    black_doubled = doubled_pawns(chess.BLACK)\n    return float(white_doubled - black_doubled)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the number of pawns advanced beyond their starting rank.\"\n    white_advanced = sum(1 for square in board.piece_map() if square in range(8, 16) and board.piece_map()[square].color == chess.WHITE)\n    black_advanced = sum(1 for square in board.piece_map() if square in range(48, 56) and board.piece_map()[square].color == chess.BLACK)\n    return float(white_advanced - black_advanced)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the number of major pieces for both sides.\"\n    white_major_count = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE and piece.piece_type in {chess.ROOK, chess.QUEEN})\n    black_major_count = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK and piece.piece_type in {chess.ROOK, chess.QUEEN})\n    return float(white_major_count - black_major_count)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the mobility of each side by counting legal moves.\"\n    white_moves = len(list(board.legal_moves)) if board.turn else 0\n    black_moves = len(list(board.legal_moves)) if not board.turn else 0\n    return float(white_moves - black_moves)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Evaluates the coordination between queen and rook for both sides.\"\n    def has_rook_and_queen(color):\n        return any(piece.piece_type == chess.ROOK for piece in board.piece_map().values() if piece.color == color) and any(piece.piece_type == chess.QUEEN for piece in board.piece_map().values() if piece.color == color)\n\n    white_coordination = 1.0 if has_rook_and_queen(chess.WHITE) else 0.0\n    black_coordination = 1.0 if has_rook_and_queen(chess.BLACK) else 0.0\n    return float(white_coordination - black_coordination)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in the number of pieces in the opponent's home rank.\"\n    white_pieces_in_rank_8 = sum(1 for square in range(56, 64) if board.piece_at(square) and board.piece_at(square).color == chess.WHITE)\n    black_pieces_in_rank_1 = sum(1 for square in range(0, 8) if board.piece_at(square) and board.piece_at(square).color == chess.BLACK)\n    return float(white_pieces_in_rank_8 - black_pieces_in_rank_1)\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the number of pieces attacking the opponent's king.\"\n    opponent_color = chess.BLACK if board.turn else chess.WHITE\n    king_square = next(square for square, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color == opponent_color)\n    attackers_count = len(board.attackers(board.turn, king_square))\n    return float(attackers_count)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Determines the presence of dangerous passed pawns for the current player.\"\n    passed_pawn_count = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == board.turn and piece.piece_type == chess.PAWN:\n            if all(board.piece_at(chess.square(file, square_rank)) is None for file in range(chess.square_file(square) + 1, 8) for square_rank in range(chess.square_rank(square) + 1, 8)):\n                passed_pawn_count += 1\n    return float(passed_pawn_count)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the number of minor pieces (knights and bishops) each side has relative to the opponent.\"\n    white_minor = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE and piece.piece_type in {chess.KNIGHT, chess.BISHOP})\n    black_minor = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK and piece.piece_type in {chess.KNIGHT, chess.BISHOP})\n    return float(white_minor - black_minor)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the difference in central control by counting pieces in the center squares.\"\n    center_squares = [chess.E4, chess.E5, chess.D4, chess.D5]\n    white_center_control = sum(1 for square in center_squares if board.piece_at(square) and board.piece_at(square).color == chess.WHITE)\n    black_center_control = sum(1 for square in center_squares if board.piece_at(square) and board.piece_at(square).color == chess.BLACK)\n    return float(white_center_control - black_center_control)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Evaluates the number of threats posed by the current player's pieces.\"\n    threats_count = sum(1 for square in board.piece_map() if board.piece_map()[square].color == board.turn and len(list(board.attackers(not board.turn, square))) > 0)\n    return float(threats_count)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the distance of pieces from the opponent's back rank.\"\n    piece_distances = []\n    for square, piece in board.piece_map().items():\n        if piece.color == board.turn:\n            distance = 7 - chess.square_rank(square) if board.turn == chess.WHITE else chess.square_rank(square)\n            piece_distances.append(distance)\n    return float(sum(piece_distances) / len(piece_distances)) if piece_distances else 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the tempo by counting the number of moves to check or checkmate.\"\n    tempo = 0\n    if board.is_check():\n        tempo = 1\n    elif board.is_checkmate():\n        tempo = -1\n    return float(tempo)\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the difference between the number of pieces on the board.\"\n    white_piece_count = len([piece for piece in board.piece_map().values() if piece.color == chess.WHITE])\n    black_piece_count = len([piece for piece in board.piece_map().values() if piece.color == chess.BLACK])\n    return float(white_piece_count - black_piece_count)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Evaluates the difference in rooks and queens for both sides.\"\n    material_values = {\n        chess.ROOK: 5,\n        chess.QUEEN: 9\n    }\n    white_material = sum(material_values.get(piece.piece_type, 0) for piece in board.piece_map().values() if piece.color == chess.WHITE)\n    black_material = sum(material_values.get(piece.piece_type, 0) for piece in board.piece_map().values() if piece.color == chess.BLACK)\n    return float(white_material - black_material)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of grid squares occupied by pieces of each color.\"\n    white_controlled_squares = len([1 for square in board.piece_map() if board.piece_map()[square].color == chess.WHITE])\n    black_controlled_squares = len([1 for square in board.piece_map() if board.piece_map()[square].color == chess.BLACK])\n    return float(white_controlled_squares - black_controlled_squares)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the number of pieces of each color that are pinned.\"\n    def is_pinned(color):\n        pinned_count = 0\n        for square, piece in board.piece_map().items():\n            if piece.color == color:\n                if any(board.attackers(color, square)):\n                    pinned_count += 1\n        return pinned_count\n    \n    white_pinned = is_pinned(chess.WHITE)\n    black_pinned = is_pinned(chess.BLACK)\n    return float(white_pinned - black_pinned)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Evaluates the distance of the kings from the center of the board.\"\n    white_king_square = next((square for square, piece in board.piece_map().items() if piece.color == chess.WHITE and piece.piece_type == chess.KING), None)\n    black_king_square = next((square for square, piece in board.piece_map().items() if piece.color == chess.BLACK and piece.piece_type == chess.KING), None)\n    white_distance = chess.square_distance(28, white_king_square) if white_king_square is not None else 0\n    black_distance = chess.square_distance(28, black_king_square) if black_king_square is not None else 0\n    return float(black_distance - white_distance)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the positional advantage based on the number of pieces on the 7th and 2nd ranks.\"\n    white_seventh_rank = sum(1 for square in range(56, 64) if board.piece_at(square) is not None and board.piece_at(square).color == chess.WHITE)\n    black_second_rank = sum(1 for square in range(8, 16) if board.piece_at(square) is not None and board.piece_at(square).color == chess.BLACK)\n    return float(white_seventh_rank - black_second_rank)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the pieces under threat for each side.\"\n    white_threatened = sum(1 for square in board.piece_map() if board.is_attacked_by(chess.BLACK, square))\n    black_threatened = sum(1 for square in board.piece_map() if board.is_attacked_by(chess.WHITE, square))\n    return float(white_threatened - black_threatened)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the mobility of knights for both sides.\"\n    white_knight_mobility = sum(len(list(board.legal_moves)) for square in board.piece_map() if board.piece_map()[square].color == chess.WHITE and board.piece_map()[square].piece_type == chess.KNIGHT)\n    black_knight_mobility = sum(len(list(board.legal_moves)) for square in board.piece_map() if board.piece_map()[square].color == chess.BLACK and board.piece_map()[square].piece_type == chess.KNIGHT)\n    return float(white_knight_mobility - black_knight_mobility)\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the number of pieces that have influence on central squares (d4, d5, e4, e5).\"\n    central_squares = [chess.D4, chess.D5, chess.E4, chess.E5]\n    control = sum(1 for square in central_squares if board.is_attacked_by(chess.WHITE, square)) \\\n              - sum(1 for square in central_squares if board.is_attacked_by(chess.BLACK, square))\n    return float(control)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the total number of pieces each side can capture next move.\"\n    white_captures = sum(1 for move in board.legal_moves \n                         if board.piece_at(move.to_square) and \n                         board.piece_at(move.to_square).color == chess.BLACK)\n    black_captures = sum(1 for move in board.legal_moves \n                         if board.piece_at(move.to_square) and \n                         board.piece_at(move.to_square).color == chess.WHITE)\n    return float(white_captures - black_captures)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the mobility advantage between both sides.\"\n    white_mobility = len(list(board.legal_moves)) if board.turn == chess.WHITE else 0\n    black_mobility = len(list(board.legal_moves)) if board.turn == chess.BLACK else 0\n    return float(white_mobility - black_mobility)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of pinned pieces each side has.\"\n    def count_pinned(color):\n        pinned_count = 0\n        for square, piece in board.piece_map().items():\n            if piece.color == color:\n                for attacker in board.attackers(not color, square):\n                    if board.piece_at(attacker).piece_type in {chess.ROOK, chess.QUEEN}:\n                        pinned_count += 1\n                        break\n        return pinned_count\n    \n    white_pinned = count_pinned(chess.WHITE)\n    black_pinned = count_pinned(chess.BLACK)\n    return float(white_pinned - black_pinned)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the piece activity based on the number of legal moves for each side.\"\n    white_activity = len(list(board.legal_moves)) if board.turn == chess.WHITE else 0\n    black_activity = len(list(board.legal_moves)) if board.turn == chess.BLACK else 0\n    return float(white_activity - black_activity)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Determines the material balance considering remaining pieces types.\"\n    material_values = {\n        chess.PAWN: 1,\n        chess.KNIGHT: 3,\n        chess.BISHOP: 3,\n        chess.ROOK: 5,\n        chess.QUEEN: 9,\n        chess.KING: 0\n    }\n    white_material = sum(material_values[piece.piece_type] for piece in board.piece_map().values() if piece.color == chess.WHITE)\n    black_material = sum(material_values[piece.piece_type] for piece in board.piece_map().values() if piece.color == chess.BLACK)\n    return float(white_material - black_material)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the number of pieces that are currently pinned by an opponent's piece.\"\n    pinned_pieces = sum(1 for square, piece in board.piece_map().items() if piece.color == board.turn and board.is_attacked_by(not board.turn, square))\n    return float(pinned_pieces)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of open files available for rooks and queens for both sides.\"\n    open_files = sum(1 for file in range(8) if not any(board.piece_at(chess.square(file, rank)) for rank in range(8)))\n    return float(open_files)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the number of possible checks the current player can execute in their next move.\"\n    checks = sum(1 for move in board.legal_moves if board.gives_check(move))\n    return float(checks)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the number of backward pawns for both sides.\"\n    backward_pawns = sum(1 for square, piece in board.piece_map().items() if piece.piece_type == chess.PAWN and (piece.color == chess.WHITE and chess.square_rank(square) == 3 or piece.color == chess.BLACK and chess.square_rank(square) == 4))\n    return float(backward_pawns)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces in optimal attacking formation (e.g., pieces supporting each other).\"\n    formation_count = sum(1 for square, piece in board.piece_map().items() if piece.color == board.turn and (chess.square_rank(square) == 1 or chess.square_rank(square) == 6) and any(board.is_attacked_by(board.turn, attacking_square) for attacking_square in board.attackers(board.turn, square)))\n    return float(formation_count)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Evaluates the total number of squares controlled by pieces on the back rank.\"\n    back_rank_squares = [chess.A8, chess.B8, chess.C8, chess.D8, chess.E8, chess.F8, chess.G8, chess.H8] if board.turn == chess.BLACK else [chess.A1, chess.B1, chess.C1, chess.D1, chess.E1, chess.F1, chess.G1, chess.H1]\n    controlled_squares = sum(1 for square in back_rank_squares if board.is_attacked_by(board.turn, square))\n    return float(controlled_squares)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of unprotected pieces for the current player.\"\n    unprotected_pieces = sum(1 for square, piece in board.piece_map().items() if piece.color == board.turn and not any(board.is_attacked_by(not board.turn, square) for attacker_square in board.attackers(not board.turn, square)))\n    return float(unprotected_pieces)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the number of squares adjacent to the opposing king that are attacked by the current player's pieces.\"\n    opponent_king_square = next(square for square, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color != board.turn)\n    adjacent_squares = [chess.square_file(opponent_king_square) + 1, chess.square_file(opponent_king_square) - 1]\n    controlled_squares = sum(1 for square in adjacent_squares if board.is_attacked_by(board.turn, square))\n    return float(controlled_squares)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the proportion of pieces that can move to control more central squares.\"\n    central_squares = [chess.E4, chess.E5, chess.D4, chess.D5]\n    control = sum(1 for square in board.piece_map() if board.piece_map()[square].color == board.turn and square in central_squares)\n    total_pieces = sum(1 for piece in board.piece_map().values() if piece.color == board.turn)\n    return float(control / total_pieces) if total_pieces > 0 else 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in active pieces (pieces able to move) for both sides.\"\n    white_active = sum(1 for move in board.legal_moves if board.piece_map()[move.from_square].color == chess.WHITE)\n    black_active = sum(1 for move in board.legal_moves if board.piece_map()[move.from_square].color == chess.BLACK)\n    return float(white_active - black_active)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces attacking the opponent's major pieces (queen and rooks).\"\n    major_pieces = {chess.QUEEN, chess.ROOK}\n    attacks_count = sum(1 for square in board.piece_map() if board.piece_map()[square].color != board.turn and \n                        board.piece_map()[square].piece_type in major_pieces and \n                        any(board.is_attacked_by(board.turn, square) for attacker in board.attackers(board.turn, square)))\n    return float(attacks_count)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the number of potential discovered attacks that can be made.\"\n    discovered_attacks = 0\n    for square in board.piece_map():\n        piece = board.piece_map()[square]\n        if piece.color == board.turn:\n            for move in board.legal_moves:\n                if move.from_square == square:\n                    # Assuming the move may uncover an attack\n                    potential_target = move.to_square\n                    for target in board.attackers(not piece.color, potential_target):\n                        if board.piece_map()[target].color != piece.color:\n                            discovered_attacks += 1\n    return float(discovered_attacks)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the pawn structure quality by counting doubled and isolated pawns.\"\n    def pawn_structure(color):\n        pawns = [square for square in board.piece_map() if board.piece_map()[square].color == color and board.piece_map()[square].piece_type == chess.PAWN]\n        doubles = sum(1 for square in pawns if board.piece_at(square + 8) and \n                      board.piece_at(square + 8).color == color)  # Check for doubled pawns\n        isolated = sum(1 for square in pawns if not (board.piece_at(square - 1) and board.piece_at(square - 1).color == color) and \n                                        not (board.piece_at(square + 1) and board.piece_at(square + 1).color == color))  # Check for isolated\n        return doubles + isolated\n\n    white_structure = pawn_structure(chess.WHITE)\n    black_structure = pawn_structure(chess.BLACK)\n    return float(white_structure - black_structure)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures material imbalance by evaluating the safety of the king in relation to major threats.\"\n    opponent_color = chess.BLACK if board.turn else chess.WHITE\n    king_square = next(square for square in board.piece_map() if board.piece_map()[square].color == board.turn and \n                       board.piece_map()[square].piece_type == chess.KING)\n    threats_count = sum(1 for square in board.piece_map() if board.piece_map()[square].color == opponent_color and \n                        board.is_attacked_by(board.turn, square))\n    return float(threats_count - board.is_check())\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the amount of space each side controls by measuring their pawn formation.\"\n    space_control = 0\n    for square in board.piece_map():\n        piece = board.piece_map()[square]\n        if piece.color == board.turn and piece.piece_type == chess.PAWN:\n            file_control = chess.square_file(square)\n            if (piece.color == chess.WHITE and file_control > 2) or (piece.color == chess.BLACK and file_control < 5):\n                space_control += 1\n    return float(space_control)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Checks for the existence of unprotected pieces for both sides and evaluates their count.\"\n    unprotected_count = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == board.turn:\n            if not any(board.is_attacked_by(not piece.color, square) for square in board.attackers(piece.color, square)):\n                unprotected_count += 1\n    return float(unprotected_count)\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in the number of opponent's pieces on the back rank.\"\n    white_back_rank_pieces = sum(1 for square in range(56, 64) if board.piece_at(square) and board.piece_at(square).color == chess.WHITE)\n    black_back_rank_pieces = sum(1 for square in range(0, 8) if board.piece_at(square) and board.piece_at(square).color == chess.BLACK)\n    return float(black_back_rank_pieces - white_back_rank_pieces)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the difference in the number of pawn structures (connected pawns) for both players.\"\n    def connected_pawns_count(color):\n        count = 0\n        for file in range(8):\n            if board.piece_at(chess.square(file, 1 if color == chess.WHITE else 6)) and board.piece_at(chess.square(file, 1 if color == chess.WHITE else 6)).color == color:\n                if (file > 0 and board.piece_at(chess.square(file - 1, 1 if color == chess.WHITE else 6)) and board.piece_at(chess.square(file - 1, 1 if color == chess.WHITE else 6)).color == color) or \\\n                   (file < 7 and board.piece_at(chess.square(file + 1, 1 if color == chess.WHITE else 6)) and board.piece_at(chess.square(file + 1, 1 if color == chess.WHITE else 6)).color == color):\n                    count += 1\n        return count\n\n    white_connected = connected_pawns_count(chess.WHITE)\n    black_connected = connected_pawns_count(chess.BLACK)\n    return float(white_connected - black_connected)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the mobility advantage by comparing the number of legal moves.\"\n    white_moves = len(list(board.legal_moves)) if board.turn == chess.WHITE else 0\n    black_moves = len(list(board.legal_moves)) if board.turn == chess.BLACK else 0\n    return float(white_moves - black_moves)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the king safety by counting pawns shielding each king.\"\n    def pawn_shields_king(color):\n        count = 0\n        king_square = next(square for square, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color == color)\n        king_file = chess.square_file(king_square)\n        for file_shift in [-1, 0, 1]:\n            pawn_square = chess.square(king_file + file_shift, chess.square_rank(king_square) - 1)\n            if board.piece_at(pawn_square) and board.piece_at(pawn_square).color == color and chess.square_rank(king_square) > 0:\n                count += 1\n        return count\n\n    white_shields = pawn_shields_king(chess.WHITE)\n    black_shields = pawn_shields_king(chess.BLACK)\n    return float(white_shields - black_shields)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in central control by counting pieces in the center squares.\"\n    center_squares = [chess.E4, chess.E5, chess.D4, chess.D5]\n    white_control = sum(1 for square in center_squares if board.piece_at(square) and board.piece_at(square).color == chess.WHITE)\n    black_control = sum(1 for square in center_squares if board.piece_at(square) and board.piece_at(square).color == chess.BLACK)\n    return float(white_control - black_control)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the number of weak squares controlled by each player.\"\n    def count_weak_squares(color):\n        weak_squares = 0\n        enemy_color = chess.BLACK if color == chess.WHITE else chess.WHITE\n        for square in chess.SQUARES:\n            if board.is_attacked_by(enemy_color, square):\n                # Check if the square is unprotected\n                if not board.attackers(color, square):\n                    weak_squares += 1\n        return weak_squares\n\n    white_weak = count_weak_squares(chess.WHITE)\n    black_weak = count_weak_squares(chess.BLACK)\n    return float(white_weak - black_weak)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the total number of open files available for rooks.\"\n    def open_file_count(color):\n        count = 0\n        for file in range(8):\n            if all(not board.piece_at(chess.square(file, rank)) or board.piece_at(chess.square(file, rank)).color != color for rank in range(8)):\n                count += 1\n        return count\n\n    white_open_files = open_file_count(chess.WHITE)\n    black_open_files = open_file_count(chess.BLACK)\n    return float(white_open_files - black_open_files)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the piece activity by evaluating pieces not on their starting positions.\"\n    def piece_activity(color):\n        count = 0\n        for square, piece in board.piece_map().items():\n            if piece.color == color:\n                starting_rank = 1 if color == chess.WHITE else 6\n                if chess.square_rank(square) != starting_rank:\n                    count += 1\n        return count\n\n    white_activity = piece_activity(chess.WHITE)\n    black_activity = piece_activity(chess.BLACK)\n    return float(white_activity - black_activity)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Checks the status of key pieces to determine relative strength of each player's setup.\"\n    key_piece_status = {\n        chess.QUEEN: 0,\n        chess.ROOK: 1,\n        chess.BISHOP: 2,\n        chess.KNIGHT: 3\n    }\n    \n    def calculate_key_piece_strength(color):\n        strength = 0\n        for piece in board.piece_map().values():\n            if piece.color == color and piece.piece_type in key_piece_status:\n                strength += 1\n        return strength\n\n    white_strength = calculate_key_piece_strength(chess.WHITE)\n    black_strength = calculate_key_piece_strength(chess.BLACK)\n    return float(white_strength - black_strength)\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the phases of the game based on piece count and positioning.\"\n    piece_count = len(board.piece_map())\n    if piece_count > 30:\n        return 1.0  # Early game\n    elif piece_count > 15:\n        return 0.5  # Middle game\n    else:\n        return 0.0  # Endgame\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the control of central squares (d4, e4, d5, e5) based on piece position.\"\n    central_squares = [chess.D4, chess.E4, chess.D5, chess.E5]\n    control_score = sum(1 for square in central_squares if board.is_attacked_by(chess.WHITE, square)) - \\\n                    sum(1 for square in central_squares if board.is_attacked_by(chess.BLACK, square))\n    return float(control_score)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the number of isolated pawns for each color.\"\n    def isolated_pawns(color):\n        pawns = [square for square in board.piece_map() if board.piece_map()[square].color == color and \n                  board.piece_map()[square].piece_type == chess.PAWN]\n        isolated = 0\n        for pawn in pawns:\n            file = chess.square_file(pawn)\n            if not (board.piece_at(chess.parse_square(f'{chr(file + 97)}{chess.square_rank(pawn) + 1}')) or \n                                   board.piece_at(chess.parse_square(f'{chr(file + 97)}{chess.square_rank(pawn) - 1}'))):\n                isolated += 1\n        return isolated\n\n    white_isolated = isolated_pawns(chess.WHITE)\n    black_isolated = isolated_pawns(chess.BLACK)\n    return float(white_isolated - black_isolated)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the safety of the king based on available escape squares.\"\n    white_king_square = next((square for square in board.piece_map() if board.piece_map()[square].color == chess.WHITE and board.piece_map()[square].piece_type == chess.KING), None)\n    black_king_square = next((square for square in board.piece_map() if board.piece_map()[square].color == chess.BLACK and board.piece_map()[square].piece_type == chess.KING), None)\n    \n    def escape_squares(king_square):\n        escape_moves = 0\n        for move in board.legal_moves:\n            if move.from_square == king_square:\n                escape_moves += 1\n        return escape_moves\n\n    score = escape_squares(white_king_square) - escape_squares(black_king_square)\n    return float(score)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces that are pinned against their own king.\"\n    pinned_pieces = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == board.turn and board.is_attacked_by(not piece.color, square):\n            attackers = board.attackers(not piece.color, square)\n            if any(board.piece_at(attacker).piece_type == chess.KING for attacker in attackers):\n                pinned_pieces += 1\n    return float(pinned_pieces)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the total influence of the rooks on open files.\"\n    influence_score = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == board.turn and piece.piece_type == chess.ROOK:\n            file_controlled = chess.square_file(square)\n            if not any(board.piece_at(s) for s in range(file_controlled * 8, (file_controlled + 1) * 8)):\n                influence_score += 1\n    return float(influence_score)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the number of times pieces attack the opponent's pieces.\"\n    attack_score = sum(len(board.attackers(not piece.color, square)) for square, piece in board.piece_map().items() if piece.color == board.turn)\n    return float(attack_score)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Evaluates the piece development by counting pieces that are out of their starting rank.\"\n    developed_pieces = sum(1 for square, piece in board.piece_map().items() if piece.color == board.turn and\n                            ((piece.piece_type == chess.PAWN and chess.square_rank(square) > 1) or\n                             (piece.piece_type in {chess.KNIGHT, chess.BISHOP, chess.ROOK, chess.QUEEN} and chess.square_rank(square) > 0))) \n    return float(developed_pieces)\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the amount of potential pawn promotion for each side.\"\n    white_pawn_promotions = sum(1 for square in board.piece_map() if board.piece_map()[square].color == chess.WHITE and chess.square_rank(square) == 6)\n    black_pawn_promotions = sum(1 for square in board.piece_map() if board.piece_map()[square].color == chess.BLACK and chess.square_rank(square) == 1)\n    return float(white_pawn_promotions - black_pawn_promotions)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of back rank threats each side has against the opponent.\"\n    white_back_rank_threats = sum(1 for square in range(0, 8) if board.is_attacked_by(chess.BLACK, square) and chess.square_rank(square) == 0)\n    black_back_rank_threats = sum(1 for square in range(56, 64) if board.is_attacked_by(chess.WHITE, square) and chess.square_rank(square) == 7)\n    return float(white_back_rank_threats - black_back_rank_threats)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the number of possible forks available to each side from knights.\"\n    white_knight_forks = sum(1 for move in board.legal_moves if board.piece_map()[move.from_square].piece_type == chess.KNIGHT and len(board.attackers(board.piece_map()[move.from_square].color, move.to_square)) > 1)\n    black_knight_forks = sum(1 for move in board.legal_moves if board.piece_map()[move.from_square].piece_type == chess.KNIGHT and len(board.attackers(board.piece_map()[move.from_square].color, move.to_square)) > 1)\n    return float(white_knight_forks - black_knight_forks)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the distance of the kings from the center of the board.\"\n    white_king_square = next(square for square, piece in board.piece_map().items() if piece.color == chess.WHITE and piece.piece_type == chess.KING)\n    black_king_square = next(square for square, piece in board.piece_map().items() if piece.color == chess.BLACK and piece.piece_type == chess.KING)\n    white_king_distance = chess.square_distance(white_king_square, chess.parse_square('e4'))\n    black_king_distance = chess.square_distance(black_king_square, chess.parse_square('e4'))\n    return float(black_king_distance - white_king_distance)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the number of squares attacked by each side's rooks.\"\n    white_rook_control = sum(1 for square in board.piece_map() if board.piece_map()[square].color == chess.WHITE and board.is_attacked_by(chess.WHITE, square))\n    black_rook_control = sum(1 for square in board.piece_map() if board.piece_map()[square].color == chess.BLACK and board.is_attacked_by(chess.BLACK, square))\n    return float(white_rook_control - black_rook_control)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the total piece count disadvantage for each side.\"\n    white_piece_count = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE)\n    black_piece_count = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK)\n    return float(black_piece_count - white_piece_count)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of squares that are double attacked by pieces of both sides.\"\n    double_attacked_squares = set(square for square in range(64) if len(board.attackers(chess.WHITE, square)) > 0 and len(board.attackers(chess.BLACK, square)) > 0)\n    return float(len(double_attacked_squares))\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in development based on minor pieces' positions.\"\n    white_knights = sum(1 for square in board.piece_map() if board.piece_map()[square].color == chess.WHITE and board.piece_map()[square].piece_type == chess.KNIGHT and chess.square_rank(square) > 1)\n    black_knights = sum(1 for square in board.piece_map() if board.piece_map()[square].color == chess.BLACK and board.piece_map()[square].piece_type == chess.KNIGHT and chess.square_rank(square) < 6)\n    white_bishops = sum(1 for square in board.piece_map() if board.piece_map()[square].color == chess.WHITE and board.piece_map()[square].piece_type == chess.BISHOP and chess.square_rank(square) > 1)\n    black_bishops = sum(1 for square in board.piece_map() if board.piece_map()[square].color == chess.BLACK and board.piece_map()[square].piece_type == chess.BISHOP and chess.square_rank(square) < 6)\n    return float((white_knights + white_bishops) - (black_knights + black_bishops))\n\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the potential for attacking the opponent's king by counting direct attacks.\"\n    opponent_color = chess.BLACK if board.turn else chess.WHITE\n    king_square = next((square for square in board.piece_map() if board.piece_map()[square].color == opponent_color and board.piece_map()[square].piece_type == chess.KING), None)\n    if king_square is None:\n        return 0.0\n    attack_count = sum(1 for square in board.piece_map() if board.piece_map()[square].color == board.turn and board.is_attacked_by(opponent_color, square))\n    return float(attack_count)\n\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in pawn advancement through the ranks.\"\n    white_pawn_advance = sum(1 for square in board.piece_map() if board.piece_map()[square].color == chess.WHITE and chess.square_rank(square) > 4)\n    black_pawn_advance = sum(1 for square in board.piece_map() if board.piece_map()[square].color == chess.BLACK and chess.square_rank(square) < 3)\n    return float(white_pawn_advance - black_pawn_advance)\n\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Evaluates the number of pieces that are controlling the center squares.\"\n    center_squares = [chess.D4, chess.D5, chess.E4, chess.E5]\n    white_control = sum(1 for sq in center_squares if board.is_attacked_by(chess.WHITE, sq))\n    black_control = sum(1 for sq in center_squares if board.is_attacked_by(chess.BLACK, sq))\n    return float(white_control - black_control)\n\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the total number of pieces pinned by the opposing side.\"\n    pinned_count = 0\n    for square in board.piece_map():\n        piece = board.piece_map()[square]\n        if board.is_attacked_by(not piece.color, square) and (piece.piece_type == chess.QUEEN or piece.piece_type == chess.ROOK):\n            pinned_count += 1\n    return float(pinned_count)\n\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the number of pieces on the 7th (for White) or 2nd (for Black) ranks as indicators of pressure.\"\n    white_pressure = sum(1 for square in range(48, 56) if board.piece_at(square) and board.piece_at(square).color == chess.WHITE)\n    black_pressure = sum(1 for square in range(8, 16) if board.piece_at(square) and board.piece_at(square).color == chess.BLACK)\n    return float(white_pressure - black_pressure)\n\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the number of loose pieces that can be easily captured without retaliation.\"\n    loose_piece_count = 0\n    for square, piece in board.piece_map().items():\n        if any(board.is_attacked_by(piece.color, sq) for sq in board.attackers(not piece.color, square)):\n            loose_piece_count += 1\n    return float(loose_piece_count)\n\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Evaluates material imbalance by calculating the difference in the remaining pieces of both players.\"\n    material_values = {chess.PAWN: 1, chess.KNIGHT: 3, chess.BISHOP: 3, chess.ROOK: 5, chess.QUEEN: 9, chess.KING: 0}\n    white_material = sum(material_values[piece.piece_type] for piece in board.piece_map().values() if piece.color == chess.WHITE)\n    black_material = sum(material_values[piece.piece_type] for piece in board.piece_map().values() if piece.color == chess.BLACK)\n    return float(white_material - black_material)\n\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the average distance of pieces from their starting position.\"\n    initial_positions = {\n        chess.WHITE: {chess.A2: 0, chess.B2: 0, chess.C2: 0, chess.D2: 0, chess.E2: 0, chess.F2: 0, chess.G2: 0, chess.H2: 0,\n                      chess.A1: 0, chess.B1: 0, chess.C1: 0, chess.D1: 0, chess.E1: 0, chess.F1: 0, chess.G1: 0, chess.H1: 0},\n        chess.BLACK: {chess.A7: 0, chess.B7: 0, chess.C7: 0, chess.D7: 0, chess.E7: 0, chess.F7: 0, chess.G7: 0, chess.H7: 0,\n                      chess.A8: 0, chess.B8: 0, chess.C8: 0, chess.D8: 0, chess.E8: 0, chess.F8: 0, chess.G8: 0, chess.H8: 0}\n    }\n    distance = 0\n    total_pieces = 0\n    for square, piece in board.piece_map().items():\n        if piece.color in initial_positions:\n            distance += chess.square_distance(square, next(iter(initial_positions[piece.color].keys())))\n            total_pieces += 1\n    return float(distance / total_pieces) if total_pieces > 0 else 0.0\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the mobility of pieces by counting legal moves available for each side.\"\n    white_mobility = len(list(board.legal_moves)) if board.turn else 0\n    black_mobility = len(list(board.legal_moves)) if not board.turn else 0\n    return float(white_mobility - black_mobility)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Evaluates the number of open files for rooks and queens.\"\n    open_files = sum(1 for file in range(8) if not any(board.piece_at(chess.square(file, rank)) for rank in range(8)))\n    return float(open_files * (1 if board.turn else -1))\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the total number of pieces being attacked by each side.\"\n    white_attacked = sum(1 for square in board.piece_map() if board.piece_map()[square].color == chess.WHITE and board.is_attacked_by(chess.BLACK, square))\n    black_attacked = sum(1 for square in board.piece_map() if board.piece_map()[square].color == chess.BLACK and board.is_attacked_by(chess.WHITE, square))\n    return float(white_attacked - black_attacked)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the exposed position of the kings' by counting the squares attacking each king.\"\n    white_king_square = next(square for square in board.piece_map() if board.piece_map()[square].color == chess.WHITE and board.piece_map()[square].piece_type == chess.KING)\n    black_king_square = next(square for square in board.piece_map() if board.piece_map()[square].color == chess.BLACK and board.piece_map()[square].piece_type == chess.KING)\n    white_exposure = sum(1 for square in chess.SQUARES_180 if board.is_attacked_by(chess.BLACK, square) and square in chess.SQUARES_180)\n    black_exposure = sum(1 for square in chess.SQUARES_180 if board.is_attacked_by(chess.WHITE, square) and square in chess.SQUARES_180)\n    return float(white_exposure - black_exposure)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Evaluates the pawn structure by counting doubled pawns for each side.\"\n    def doubled_pawns(color):\n        pawn_files = [0] * 8\n        for square in board.piece_map():\n            piece = board.piece_map()[square]\n            if piece.color == color and piece.piece_type == chess.PAWN:\n                pawn_files[chess.square_file(square)] += 1\n        return sum(1 for count in pawn_files if count > 1)\n    \n    white_doubled = doubled_pawns(chess.WHITE)\n    black_doubled = doubled_pawns(chess.BLACK)\n    return float(white_doubled - black_doubled)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in potential future threats by counting pieces that can attack on the next move.\"\n    white_threats = sum(1 for square in board.piece_map() if board.piece_map()[square].color == chess.WHITE and board.is_attacked_by(chess.BLACK, square))\n    black_threats = sum(1 for square in board.piece_map() if board.piece_map()[square].color == chess.BLACK and board.is_attacked_by(chess.WHITE, square))\n    return float(white_threats - black_threats)\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the number of doubled pawns for each side.\"\n    def count_doubled_pawns(color):\n        pawn_files = [0] * 8\n        for square, piece in board.piece_map().items():\n            if piece.color == color and piece.piece_type == chess.PAWN:\n                file = chess.square_file(square)\n                pawn_files[file] += 1\n        return sum(1 for count in pawn_files if count > 1)\n\n    white_doubled = count_doubled_pawns(chess.WHITE)\n    black_doubled = count_doubled_pawns(chess.BLACK)\n    return float(white_doubled - black_doubled)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the number of pinned pieces for each side.\"\n    def count_pinned_pieces(color):\n        pinned_count = 0\n        for square, piece in board.piece_map().items():\n            if piece.color == color:\n                for attacker_square in board.attackers(not color, square):\n                    if board.is_check():\n                        pinned_count += 1\n                        break\n        return pinned_count\n\n    white_pinned = count_pinned_pieces(chess.WHITE)\n    black_pinned = count_pinned_pieces(chess.BLACK)\n    return float(white_pinned - black_pinned)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the king safety score based on nearby pieces.\"\n    def king_safety(color):\n        king_square = next(square for square, piece in board.piece_map().items() if piece.color == color and piece.piece_type == chess.KING)\n        safety_score = 0\n        for square in board.piece_map():\n            piece = board.piece_at(square)\n            if piece and piece.color != color:\n                if chess.square_distance(king_square, square) <= 2:\n                    safety_score -= {chess.QUEEN: 3, chess.ROOK: 2, chess.BISHOP: 1, chess.KNIGHT: 1}.get(piece.piece_type, 0)\n        return safety_score\n\n    white_safety = king_safety(chess.WHITE)\n    black_safety = king_safety(chess.BLACK)\n    return float(white_safety - black_safety)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the number of passed pawns for each side.\"\n    def count_passed_pawns(color):\n        passed_count = 0\n        for square, piece in board.piece_map().items():\n            if piece.color == color and piece.piece_type == chess.PAWN:\n                file = chess.square_file(square)\n                is_passed = True\n                for enemy_square in range(0, 8):\n                    if (color == chess.WHITE and enemy_square < chess.square_rank(square)) or (color == chess.BLACK and enemy_square > chess.square_rank(square)):\n                        if board.piece_at(chess.square(file, enemy_square)) and board.piece_at(chess.square(file, enemy_square)).color != color:\n                            is_passed = False\n                            break\n                if is_passed:\n                    passed_count += 1\n        return passed_count\n\n    white_passed = count_passed_pawns(chess.WHITE)\n    black_passed = count_passed_pawns(chess.BLACK)\n    return float(white_passed - black_passed)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Evaluates the activity of the rooks on the board.\"\n    def rook_activity(color):\n        activity_score = 0\n        for square, piece in board.piece_map().items():\n            if piece.color == color and piece.piece_type == chess.ROOK:\n                file_control = sum(1 for rank in range(8) if board.piece_at(chess.square(chess.square_file(square), rank)) is None)\n                activity_score += file_control\n        return activity_score\n\n    white_activity = rook_activity(chess.WHITE)\n    black_activity = rook_activity(chess.BLACK)\n    return float(white_activity - black_activity)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the control of center squares (d4, e4 for White; d5, e5 for Black).\"\n    def center_control(color):\n        center_squares = [chess.D4, chess.E4] if color == chess.WHITE else [chess.D5, chess.E5]\n        control_count = sum(1 for square in center_squares if board.is_attacked_by(color, square))\n        return control_count\n\n    white_control = center_control(chess.WHITE)\n    black_control = center_control(chess.BLACK)\n    return float(white_control - black_control)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the total number of forks available for each side.\"\n    def count_forks(color):\n        fork_count = 0\n        for square in board.legal_moves:\n            if board.piece_at(square.from_square).color == color:\n                # Check potential captures\n                for target in board.attackers(not color, square.to_square):\n                    if board.piece_at(target).color != color:\n                        fork_count += 1\n        return fork_count\n\n    white_forks = count_forks(chess.WHITE)\n    black_forks = count_forks(chess.BLACK)\n    return float(white_forks - black_forks)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Evaluates the activity of both queens on the board.\"\n    def queen_activity(color):\n        activity_score = 0\n        for square, piece in board.piece_map().items():\n            if piece.color == color and piece.piece_type == chess.QUEEN:\n                activity_score += 1 if chess.square_file(square) in {3, 4} else 0\n        return activity_score\n\n    white_activity = queen_activity(chess.WHITE)\n    black_activity = queen_activity(chess.BLACK)\n    return float(white_activity - black_activity)\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of protected pawns for the current player.\"\n    protected_pawns = sum(1 for square, piece in board.piece_map().items() if piece.color == board.turn and piece.piece_type == chess.PAWN and any(board.is_attacked_by(board.turn, attacker) for attacker in board.attackers(board.turn, square)))\n    return float(protected_pawns)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the mobility of pieces by counting the number of legal moves.\"\n    mobility = len(list(board.legal_moves))\n    return float(mobility)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the number of open files for rooks.\"\n    open_files = sum(1 for file in range(8) if not any(board.piece_at(chess.square(file, rank)) for rank in range(8)))\n    return float(open_files)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Evaluates the king's safety by counting the number of squares around it that are attacked.\"\n    king_square = next((square for square, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color == board.turn), None)\n    if king_square is None:\n        return 0.0\n    threatened_squares = sum(1 for square in chess.SQUARES_180 if board.is_attacked_by(not board.turn, square))\n    return float(threatened_squares)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of hanging pieces for the current player.\"\n    hanging_pieces = sum(1 for square, piece in board.piece_map().items() if piece.color == board.turn and board.is_attacked_by(not board.turn, square))\n    return float(hanging_pieces)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in pawn structure between players based on isolated and doubled pawns.\"\n    def pawn_structure_score(color):\n        return -sum(1 for square in board.piece_map() if board.piece_map()[square].color == color and (board.is_attacked_by(not color, square) or (board.piece_map()[square].piece_type == chess.PAWN and (board.piece_at(square + 1) == board.piece_at(square - 1) == None))))\n    \n    white_score = pawn_structure_score(chess.WHITE)\n    black_score = pawn_structure_score(chess.BLACK)\n    return float(white_score - black_score)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of potential forks available for each side's knights.\"\n    def knight_forks(color):\n        knight_positions = [square for square, piece in board.piece_map().items() if piece.color == color and piece.piece_type == chess.KNIGHT]\n        forks = 0\n        for knight in knight_positions:\n            for target in board.attackers(not color, knight):\n                if board.piece_at(target) and board.piece_at(target).color != color:\n                    forks += 1\n        return forks\n    \n    return float(knight_forks(chess.WHITE) - knight_forks(chess.BLACK))\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the control of the back rank.\"\n    back_rank_control = sum(1 for square in range(0, 8) if board.is_attacked_by(board.turn, chess.square(square, 0 if board.turn else 7)))\n    return float(back_rank_control)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of threats against pieces in the opponent's territory.\"\n    threats = sum(1 for square in range(32, 64) if board.piece_at(square) and board.is_attacked_by(not board.turn, square))\n    return float(threats)\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the difference in king safety by counting nearby enemy pieces.\"\n    def count_threats(color):\n        threat_count = 0\n        king_square = next(square for square, piece in board.piece_map().items() if piece.color == color and piece.piece_type == chess.KING)\n        for attacker in board.attackers(not color, king_square):\n            threat_count += 1\n        return threat_count\n    \n    white_threats = count_threats(chess.WHITE)\n    black_threats = count_threats(chess.BLACK)\n    return float(black_threats - white_threats)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of squares attacked by each side's pieces.\"\n    def attacked_squares_count(color):\n        attacked_count = sum(1 for square in board.piece_map() if board.is_attacked_by(color, square))\n        return attacked_count\n    \n    white_attacked = attacked_squares_count(chess.WHITE)\n    black_attacked = attacked_squares_count(chess.BLACK)\n    return float(white_attacked - black_attacked)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the difference in total piece value lost due to attacks.\"\n    material_values = {\n        chess.PAWN: 1,\n        chess.KNIGHT: 3,\n        chess.BISHOP: 3,\n        chess.ROOK: 5,\n        chess.QUEEN: 9,\n        chess.KING: 0\n    }\n    \n    def lost_material(color):\n        loss_value = 0\n        for square, piece in board.piece_map().items():\n            if piece.color == color and board.is_attacked_by(not color, square):\n                loss_value += material_values[piece.piece_type]\n        return loss_value\n    \n    white_loss = lost_material(chess.WHITE)\n    black_loss = lost_material(chess.BLACK)\n    return float(black_loss - white_loss)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Evaluates the pawn structure by counting weaknesses for both sides.\"\n    def pawn_structure_weaknesses(color):\n        weaknesses = 0\n        for square in range(64):\n            if board.piece_at(square) and board.piece_at(square).color == color and board.piece_at(square).piece_type == chess.PAWN:\n                if (square > 7 and not board.piece_at(square - 8)) or (square < 56 and not board.piece_at(square + 8)):\n                    weaknesses += 1\n        return weaknesses\n    \n    white_weaknesses = pawn_structure_weaknesses(chess.WHITE)\n    black_weaknesses = pawn_structure_weaknesses(chess.BLACK)\n    return float(black_weaknesses - white_weaknesses)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the piece activity of rooks on open files for both sides.\"\n    def rook_activity(color):\n        activity = 0\n        for square, piece in board.piece_map().items():\n            if piece.color == color and piece.piece_type == chess.ROOK:\n                if all(board.piece_at(sq) is None for sq in range(8) if chess.square_file(sq) == chess.square_file(square)):\n                    activity += 1\n        return activity\n    \n    white_activity = rook_activity(chess.WHITE)\n    black_activity = rook_activity(chess.BLACK)\n    return float(white_activity - black_activity)\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in the number of pawns for each side.\"\n    white_pawns = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE and piece.piece_type == chess.PAWN)\n    black_pawns = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK and piece.piece_type == chess.PAWN)\n    return float(white_pawns - black_pawns)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the total number of pieces that have mobility, evaluating their safety.\"\n    mobile_pieces = sum(1 for piece in board.piece_map().values() if len(list(board.legal_moves)) > 0)\n    return float(mobile_pieces)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces out of the back rank for each side.\"\n    white_ranked = sum(1 for square in range(0, 8) if board.piece_at(chess.square(square, 0)) and board.piece_at(chess.square(square, 0)).color == chess.WHITE)\n    black_ranked = sum(1 for square in range(0, 8) if board.piece_at(chess.square(square, 7)) and board.piece_at(chess.square(square, 7)).color == chess.BLACK)\n    return float(white_ranked - black_ranked)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the number of squares controlled by each side on the opponent's side of the board.\"\n    white_control = sum(1 for square in range(32, 64) if board.is_attacked_by(chess.WHITE, square))\n    black_control = sum(1 for square in range(0, 32) if board.is_attacked_by(chess.BLACK, square))\n    return float(white_control - black_control)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in king safety based on the number of attacking pieces near each king.\"\n    white_attacks = sum(1 for square in chess.SQUARES if board.is_attacked_by(chess.WHITE, square) and board.piece_at(square) and board.piece_at(square).piece_type == chess.KING)\n    black_attacks = sum(1 for square in chess.SQUARES if board.is_attacked_by(chess.BLACK, square) and board.piece_at(square) and board.piece_at(square).piece_type == chess.KING)\n    return float(white_attacks - black_attacks)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the number of potential discovered checks from each side's pieces.\"\n    white_discovered_checks = sum(1 for square in chess.SQUARES if board.piece_at(square) and board.piece_at(square).color == chess.WHITE and len(list(board.legal_moves)) > 1)\n    black_discovered_checks = sum(1 for square in chess.SQUARES if board.piece_at(square) and board.piece_at(square).color == chess.BLACK and len(list(board.legal_moves)) > 1)\n    return float(white_discovered_checks - black_discovered_checks)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts how many pieces each player has attacking their opponent's pieces.\"\n    white_attacks = sum(1 for square in chess.SQUARES for move in board.legal_moves if board.is_attacked_by(chess.WHITE, move.to_square) and board.piece_at(move.to_square) and board.piece_at(move.to_square).color != chess.WHITE)\n    black_attacks = sum(1 for square in chess.SQUARES for move in board.legal_moves if board.is_attacked_by(chess.BLACK, move.to_square) and board.piece_at(move.to_square) and board.piece_at(move.to_square).color != chess.BLACK)\n    return float(white_attacks - black_attacks)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the difference between the number of doubled pawns for each side.\"\n    white_doubled = sum(1 for square in range(8) if board.piece_at(chess.square(square, 1)) and board.piece_at(chess.square(square, 1)).color == chess.WHITE and board.piece_at(chess.square(square, 0)) is not None)\n    black_doubled = sum(1 for square in range(8) if board.piece_at(chess.square(square, 6)) and board.piece_at(chess.square(square, 6)).color == chess.BLACK and board.piece_at(chess.square(square, 7)) is not None)\n    return float(white_doubled - black_doubled)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in piece value between each side, considering only the major pieces.\"\n    major_piece_values = {\n        chess.ROOK: 5,\n        chess.QUEEN: 9\n    }\n    white_major_value = sum(major_piece_values.get(piece.piece_type, 0) for piece in board.piece_map().values() if piece.color == chess.WHITE)\n    black_major_value = sum(major_piece_values.get(piece.piece_type, 0) for piece in board.piece_map().values() if piece.color == chess.BLACK)\n    return float(white_major_value - black_major_value)\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in the number of pieces that are pinned by opponent pieces.\"\n    pinned_white = sum(1 for square in board.piece_map() if board.piece_map()[square].color == chess.WHITE and board.is_attacked_by(chess.BLACK, square))\n    pinned_black = sum(1 for square in board.piece_map() if board.piece_map()[square].color == chess.BLACK and board.is_attacked_by(chess.WHITE, square))\n    return float(pinned_white - pinned_black)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in the number of potential forks by knights for both sides.\"\n    knight_forks = {chess.WHITE: 0, chess.BLACK: 0}\n    knight_squares = [s for s in board.piece_map() if board.piece_map()[s].piece_type == chess.KNIGHT]\n    for square in knight_squares:\n        for attacker in board.attackers(board.piece_map()[square].color, square):\n            if board.piece_map()[attacker].color != board.piece_map()[square].color:\n                knight_forks[board.piece_map()[square].color] += 1\n    return float(knight_forks[chess.WHITE] - knight_forks[chess.BLACK])\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the development advantage by counting pieces developed for each player.\"\n    developed_white = sum(1 for square in board.piece_map() if board.piece_map()[square].color == chess.WHITE and chess.square_rank(square) != 0)\n    developed_black = sum(1 for square in board.piece_map() if board.piece_map()[square].color == chess.BLACK and chess.square_rank(square) != 7)\n    return float(developed_white - developed_black)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the king safety by checking the number of pieces around the kings for both sides.\"\n    def king_safety(color):\n        king_square = next(square for square, piece in board.piece_map().items() if piece.color == color and piece.piece_type == chess.KING)\n        return sum(1 for square in board.attackers(color, king_square)) + sum(1 for square in range(64) if board.is_attacked_by(color, square) and board.piece_at(square))\n    white_safety = king_safety(chess.WHITE)\n    black_safety = king_safety(chess.BLACK)\n    return float(white_safety - black_safety)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in the number of pawns on the 7th rank for both sides.\"\n    white_7th_rank = sum(1 for square in board.piece_map() if board.piece_map()[square].color == chess.WHITE and chess.square_rank(square) == 6)\n    black_7th_rank = sum(1 for square in board.piece_map() if board.piece_map()[square].color == chess.BLACK and chess.square_rank(square) == 1)\n    return float(white_7th_rank - black_7th_rank)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the number of pieces that are pinned against the king.\"\n    pinned_count = 0\n    king_square = None\n    \n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.KING and piece.color == board.turn:\n            king_square = square\n    \n    if king_square is not None:\n        for square, piece in board.piece_map().items():\n            if piece.color != board.turn:\n                if board.is_attacked_by(board.turn, square):\n                    if any(board.piece_at(s) and board.piece_at(s).color == board.turn for s in board.attackers(piece.color, square)):\n                        pinned_count += 1\n                        \n    return float(pinned_count)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the total number of squares controlled by each player's pieces.\"\n    control_count = {chess.WHITE: 0, chess.BLACK: 0}\n    \n    for square in chess.SQUARES:\n        if board.is_attacked_by(chess.WHITE, square):\n            control_count[chess.WHITE] += 1\n        if board.is_attacked_by(chess.BLACK, square):\n            control_count[chess.BLACK] += 1\n    \n    return float(control_count[chess.WHITE] - control_count[chess.BLACK])\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the material difference weighted by piece centrality (squares e4, d4, e5, d5).\"\n    central_squares = [chess.parse_square('e4'), chess.parse_square('d4'), chess.parse_square('e5'), chess.parse_square('d5')]\n    material_values = {chess.PAWN: 1, chess.KNIGHT: 3, chess.BISHOP: 3, chess.ROOK: 5, chess.QUEEN: 9, chess.KING: 0}\n    \n    def central_material(color):\n        return sum(material_values[piece.piece_type] for square, piece in board.piece_map().items() if piece.color == color and square in central_squares)\n    \n    white_central = central_material(chess.WHITE)\n    black_central = central_material(chess.BLACK)\n    \n    return float(white_central - black_central)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of connected pawns for each player.\"\n    connected_pawns = {chess.WHITE: 0, chess.BLACK: 0}\n    \n    def count_connected(color):\n        pawns = [square for square in board.piece_map() if board.piece_map()[square].color == color and board.piece_map()[square].piece_type == chess.PAWN]\n        for square in pawns:\n            if board.piece_at(square + 1) and board.piece_at(square + 1).color == color:\n                connected_pawns[color] += 1\n            if board.piece_at(square - 1) and board.piece_at(square - 1).color == color:\n                connected_pawns[color] += 1\n    \n    count_connected(chess.WHITE)\n    count_connected(chess.BLACK)\n    \n    return float(connected_pawns[chess.WHITE] - connected_pawns[chess.BLACK])\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the number of squares the opponent's king can escape to when in check.\"\n    if board.is_check():\n        king_square = next(square for square, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color == (chess.WHITE if board.turn else chess.BLACK))\n        escape_squares = sum(1 for move in board.legal_moves if board.piece_at(move.to_square) is None and move.to_square != king_square)\n        return float(escape_squares)\n    return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the mobility of the pieces for the current player.\"\n    mobility_score = len(list(board.legal_moves))\n    return float(mobility_score)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the total number of potential captures per player.\"\n    capture_count = {chess.WHITE: 0, chess.BLACK: 0}\n    \n    for move in board.legal_moves:\n        if board.piece_at(move.to_square) is not None:\n            capture_count[board.piece_at(move.to_square).color] += 1\n    \n    return float(capture_count[chess.WHITE] - capture_count[chess.BLACK])\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the number of pieces of each color that are currently under attack.\"\n    under_attack_count = {chess.WHITE: 0, chess.BLACK: 0}\n    \n    for square, piece in board.piece_map().items():\n        if board.is_attacked_by(chess.WHITE, square):\n            under_attack_count[chess.WHITE] += 1\n        if board.is_attacked_by(chess.BLACK, square):\n            under_attack_count[chess.BLACK] += 1\n\n    return float(under_attack_count[chess.WHITE] - under_attack_count[chess.BLACK])\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the potential mobility difference by counting total legal moves available for each side.\"\n    white_moves = len(list(board.legal_moves)) if board.turn else 0\n    black_moves = len(list(board.legal_moves)) if not board.turn else 0\n    return float(white_moves - black_moves)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the number of controlling pieces versus defending pieces on critical squares.\"\n    critical_squares = [chess.E4, chess.D4, chess.E5, chess.D5]\n    white_control = sum(1 for square in critical_squares if board.is_attacked_by(chess.WHITE, square))\n    black_control = sum(1 for square in critical_squares if board.is_attacked_by(chess.BLACK, square))\n    return float(white_control - black_control)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Evaluates the balance of the center pawns for each side.\"\n    center_pawns = [chess.D4, chess.D5, chess.E4, chess.E5]\n    white_center_pawns = sum(1 for square in center_pawns if board.piece_at(square) and board.piece_at(square).color == chess.WHITE)\n    black_center_pawns = sum(1 for square in center_pawns if board.piece_at(square) and board.piece_at(square).color == chess.BLACK)\n    return float(white_center_pawns - black_center_pawns)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in king safety based on the distance of kings from the center.\"\n    white_king_square = next(square for square in board.piece_map() if board.piece_map()[square].color == chess.WHITE and board.piece_map()[square].piece_type == chess.KING)\n    black_king_square = next(square for square in board.piece_map() if board.piece_map()[square].color == chess.BLACK and board.piece_map()[square].piece_type == chess.KING)\n    white_distance = chess.square_distance(white_king_square, chess.E4) + chess.square_distance(white_king_square, chess.D4)\n    black_distance = chess.square_distance(black_king_square, chess.E4) + chess.square_distance(black_king_square, chess.D4)\n    return float(black_distance - white_distance)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Scores the number of threats to the opponent's pieces relative to the number of defended pieces.\"\n    threats = sum(1 for square in board.piece_map() if board.is_attacked_by(chess.WHITE, square) and board.piece_map()[square].color == chess.BLACK)\n    defenses = sum(1 for square in board.piece_map() if board.is_attacked_by(chess.BLACK, square) and board.piece_map()[square].color == chess.WHITE)\n    return float(threats - defenses)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the potential for piece development by counting undeveloped pieces.\"\n    undeveloped_white = sum(1 for square, piece in board.piece_map().items() if piece.color == chess.WHITE and piece.piece_type in {chess.KNIGHT, chess.BISHOP} and chess.square_rank(square) < 2)\n    undeveloped_black = sum(1 for square, piece in board.piece_map().items() if piece.color == chess.BLACK and piece.piece_type in {chess.KNIGHT, chess.BISHOP} and chess.square_rank(square) > 5)\n    return float(undeveloped_black - undeveloped_white)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the difference in active pieces (pieces moving towards the opponent's territory).\"\n    active_white = sum(1 for square, piece in board.piece_map().items() if piece.color == chess.WHITE and chess.square_rank(square) > 4)\n    active_black = sum(1 for square, piece in board.piece_map().items() if piece.color == chess.BLACK and chess.square_rank(square) < 3)\n    return float(active_white - active_black)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the total number of squares controlled by each side.\"\n    white_control = sum(1 for square in range(64) if board.is_attacked_by(chess.WHITE, square))\n    black_control = sum(1 for square in range(64) if board.is_attacked_by(chess.BLACK, square))\n    return float(white_control - black_control)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the activity of the pieces by counting the number of legal moves available to each side.\"\n    white_legal_moves = len(list(board.legal_moves)) if board.turn else 0\n    board.push(chess.Move.null())  # Push a null move to simulate other side's turn\n    black_legal_moves = len(list(board.legal_moves)) if not board.turn else 0\n    board.pop()  # Undo the null move\n    return float(white_legal_moves - black_legal_moves)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of hanging pieces on the board for both sides.\"\n    hanging_count = sum(1 for square, piece in board.piece_map().items() \n                        if piece.color == board.turn and len(board.attackers(not board.turn, square)) > 0)\n    return float(hanging_count)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the potential for checkmating the opponent by counting how many pieces can deliver check.\"\n    check_potential = sum(1 for square, piece in board.piece_map().items() \n                           if piece.color == board.turn and piece.piece_type != chess.KING and \n                           square in [m.to_square for m in board.legal_moves if m.to_square in board.attackers(not board.turn, square)])\n    return float(check_potential)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures king safety by counting the number of squares available to move away from an attack.\"\n    king_square = next(square for square, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color == board.turn)\n    safe_moves = sum(1 for square in board.legal_moves if square.to_square == king_square and not board.is_attacked_by(not board.turn, square.to_square))\n    return float(safe_moves)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Evaluates pawn advancement by calculating the average rank of pawns for each side.\"\n    def average_pawn_rank(color):\n        pawns = [chess.square_rank(square) for square in board.piece_map() \n                  if board.piece_map()[square].color == color and board.piece_map()[square].piece_type == chess.PAWN]\n        return sum(pawns) / len(pawns) if pawns else 0\n    \n    white_avg_rank = average_pawn_rank(chess.WHITE)\n    black_avg_rank = average_pawn_rank(chess.BLACK)\n    return float(white_avg_rank - black_avg_rank)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces attacking the opponent's king.\"\n    opponent_king_square = next(square for square, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color != board.turn)\n    attacking_pieces = sum(1 for square, piece in board.piece_map().items() \n                           if piece.color == board.turn and square in board.attackers(not board.turn, opponent_king_square))\n    return float(attacking_pieces)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the imbalance of material by counting excess pieces beyond the basic pawns.\"\n    material_values = {\n        chess.PAWN: 1,\n        chess.KNIGHT: 3,\n        chess.BISHOP: 3,\n        chess.ROOK: 5,\n        chess.QUEEN: 9,\n        chess.KING: 0\n    }\n    excess_white_material = sum(material_values[piece.piece_type] for piece in board.piece_map().values() \n                                  if piece.color == chess.WHITE and material_values[piece.piece_type] > 1) - \\\n                            sum(material_values[piece.piece_type] for piece in board.piece_map().values() \n                                  if piece.color == chess.BLACK and material_values[piece.piece_type] > 1)\n    return float(excess_white_material)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Evaluates the development of pieces by counting the number of pieces developed from their starting positions.\"\n    initial_positions = {\n        chess.ROOK: [0, 1, 56, 57],\n        chess.KNIGHT: [2, 5, 58, 61],\n        chess.BISHOP: [3, 4, 59, 60],\n        chess.QUEEN: [3, 4],\n        chess.KING: [60, 4]\n    }\n    developed_count = 0\n    for piece_type, squares in initial_positions.items():\n        developed_count += sum(1 for square in board.piece_map() \n                               if board.piece_map()[square].piece_type == piece_type and \n                               square not in squares and \n                               board.piece_map()[square].color == board.turn)\n    return float(developed_count)\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of squares controlled by each side's pieces.\"\n    white_controlled_squares = sum(1 for square in chess.SQUARES if board.is_attacked_by(chess.WHITE, square))\n    black_controlled_squares = sum(1 for square in chess.SQUARES if board.is_attacked_by(chess.BLACK, square))\n    return float(white_controlled_squares - black_controlled_squares)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Evaluates the king safety by counting squares around the king that are attacked.\"\n    king_square = next((square for square, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color == board.turn), None)\n    if king_square is None:\n        return 0.0\n    unsafe_squares = sum(1 for square in chess.SQUARES if board.is_attacked_by(not board.turn, square) and chess.square_distance(square, king_square) <= 1)\n    return float(unsafe_squares)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures how many pieces each side has in the opponent's territory.\"\n    white_in_enemy_territory = sum(1 for square in board.piece_map() if board.piece_map()[square].color == chess.WHITE and chess.square_rank(square) > 4)\n    black_in_enemy_territory = sum(1 for square in board.piece_map() if board.piece_map()[square].color == chess.BLACK and chess.square_rank(square) < 3)\n    return float(white_in_enemy_territory - black_in_enemy_territory)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in doubled pawns between both sides.\"\n    def count_doubled_pawns(color):\n        return sum(1 for file in range(8) if sum(1 for square in chess.SQUARES if board.piece_at(square) and board.piece_at(square).piece_type == chess.PAWN and board.piece_at(square).color == color and chess.square_file(square) == file) > 1)\n    white_doubled = count_doubled_pawns(chess.WHITE)\n    black_doubled = count_doubled_pawns(chess.BLACK)\n    return float(black_doubled - white_doubled)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the number of unprotected pieces for both sides.\"\n    def count_unprotected(color):\n        unprotected = 0\n        for square, piece in board.piece_map().items():\n            if piece.color == color:\n                if not any(board.is_attacked_by(not color, attacker) for attacker in board.attackers(not color, square)):\n                    unprotected += 1\n        return unprotected\n    white_unprotected = count_unprotected(chess.WHITE)\n    black_unprotected = count_unprotected(chess.BLACK)\n    return float(white_unprotected - black_unprotected)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in the number of major pieces (rook and queen) each side has on the board.\"\n    def count_major_pieces(color):\n        return sum(1 for square, piece in board.piece_map().items() if piece.color == color and piece.piece_type in {chess.ROOK, chess.QUEEN})\n    white_major = count_major_pieces(chess.WHITE)\n    black_major = count_major_pieces(chess.BLACK)\n    return float(white_major - black_major)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts how many squares each side's knights can reach within one move.\"\n    def knight_reach(color):\n        knight_moves = 0\n        for square, piece in board.piece_map().items():\n            if piece.color == color and piece.piece_type == chess.KNIGHT:\n                knight_moves += len(list(board.legal_moves))\n        return knight_moves\n    white_knight_moves = knight_reach(chess.WHITE)\n    black_knight_moves = knight_reach(chess.BLACK)\n    return float(white_knight_moves - black_knight_moves)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in the number of controlling bishops on diagonals.\"\n    def count_bishops(color):\n        return sum(1 for square, piece in board.piece_map().items() if piece.color == color and piece.piece_type == chess.BISHOP)\n    return float(count_bishops(chess.WHITE) - count_bishops(chess.BLACK))\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the number of doubled pawns for each color.\"\n    def doubled_pawns(color):\n        pawns = [square for square in board.piece_map() if board.piece_map()[square].color == color and \n                  board.piece_map()[square].piece_type == chess.PAWN]\n        files = {}\n        for pawn in pawns:\n            file = chess.square_file(pawn)\n            if file not in files:\n                files[file] = []\n            files[file].append(pawn)\n        return sum(len(squares) - 1 for squares in files.values() if len(squares) > 1)\n\n    white_doubled = doubled_pawns(chess.WHITE)\n    black_doubled = doubled_pawns(chess.BLACK)\n    return float(white_doubled - black_doubled)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the number of pieces coordinated to control the same square.\"\n    coordinated_threats = {}\n    for square in board.piece_map():\n        if square not in coordinated_threats:\n            coordinated_threats[square] = {'white': 0, 'black': 0}\n        for attacker in board.attackers(chess.WHITE, square):\n            coordinated_threats[square]['white'] += 1\n        for attacker in board.attackers(chess.BLACK, square):\n            coordinated_threats[square]['black'] += 1\n    total_coords = sum(abs(coords['white'] - coords['black']) for coords in coordinated_threats.values())\n    return float(total_coords)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Assesses the number of hanging pieces for each side.\"\n    hanging_pieces = sum(1 for square, piece in board.piece_map().items() \n                         if piece.color == board.turn and not any(board.is_attacked_by(not piece.color, target_square) \n                         for target_square in board.attackers(piece.color, square)))\n    return float(hanging_pieces)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in the number of pawns on the 7th rank for each color.\"\n    pawns_rank_7 = {\n        chess.WHITE: sum(1 for square in board.piece_map() if (board.piece_map()[square].color == chess.WHITE and \n                                                                chess.square_rank(square) == 6)),\n        chess.BLACK: sum(1 for square in board.piece_map() if (board.piece_map()[square].color == chess.BLACK and \n                                                                chess.square_rank(square) == 1))\n    }\n    return float(pawns_rank_7[chess.WHITE] - pawns_rank_7[chess.BLACK])\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the number of pieces pinned by the opponent's major pieces.\"\n    pinned_pieces = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == board.turn and (piece.piece_type in {chess.KING, chess.QUEEN, chess.ROOK}):\n            if any(board.is_attacked_by(not piece.color, target_square) for target_square in board.attackers(piece.color, square)):\n                pinned_pieces += 1\n    return float(pinned_pieces)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of pawn breaks available for each side.\"\n    def pawn_breaks(color):\n        count = 0\n        for square, piece in board.piece_map().items():\n            if piece.color == color and piece.piece_type == chess.PAWN:\n                if (color == chess.WHITE and board.piece_at(square + 8) is None and \n                    (board.piece_at(square + 7) is not None and board.piece_at(square + 7).color != color)):\n                    count += 1\n                if (color == chess.BLACK and board.piece_at(square - 8) is None and \n                    (board.piece_at(square - 7) is not None and board.piece_at(square - 7).color != color)):\n                    count += 1\n        return count\n\n    white_breaks = pawn_breaks(chess.WHITE)\n    black_breaks = pawn_breaks(chess.BLACK)\n    return float(white_breaks - black_breaks)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the number of pieces that are currently being developed towards the center.\"\n    development_count = 0\n    center_squares = [chess.D4, chess.E4, chess.D5, chess.E5]\n    for square, piece in board.piece_map().items():\n        if piece.color == board.turn and (piece.piece_type in {chess.KNIGHT, chess.BISHOP, chess.QUEEN}):\n            if square in center_squares:\n                development_count += 1\n    return float(development_count)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the mobility of rooks by counting open files.\"\n    rook_mobility = 0\n    open_files = [f for f in range(8) if all(board.piece_at(chess.square(f, r)) is None for r in range(8))]\n    for square, piece in board.piece_map().items():\n        if piece.color == board.turn and piece.piece_type == chess.ROOK:\n            file = chess.square_file(square)\n            if file in open_files:\n                rook_mobility += 1\n    return float(rook_mobility)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Assesses the balance of material across the board compared to the number of pieces.\"\n    material_values = {\n        chess.PAWN: 1,\n        chess.KNIGHT: 3,\n        chess.BISHOP: 3,\n        chess.ROOK: 5,\n        chess.QUEEN: 9,\n        chess.KING: 0\n    }\n    total_material = sum(material_values[piece.piece_type] for piece in board.piece_map().values())\n    total_pieces = len(board.piece_map())\n    average_material = total_material / total_pieces if total_pieces > 0 else 0\n    return float(average_material)\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the number of vulnerable pieces for the current player's turn, assessing potential threats.\"\n    vulnerable_count = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == board.turn:\n            if not board.is_attacked_by(not board.turn, square):\n                vulnerable_count += 1\n    return float(vulnerable_count)\n\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Evaluates the pawn structure by counting doubled pawns for each side.\"\n    def doubled_pawn_count(color):\n        count = 0\n        files = set()\n        for square, piece in board.piece_map().items():\n            if piece.color == color and piece.piece_type == chess.PAWN:\n                file = chess.square_file(square)\n                if file in files:\n                    count += 1\n                files.add(file)\n        return count\n\n    white_doubled = doubled_pawn_count(chess.WHITE)\n    black_doubled = doubled_pawn_count(chess.BLACK)\n    return float(black_doubled - white_doubled)\n\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the number of active pieces on the board, representing overall strength.\"\n    active_pieces = sum(1 for piece in board.piece_map().values() if piece.color == board.turn)\n    return float(active_pieces)\n\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the control of the center by counting pieces occupying central squares for both sides.\"\n    central_squares = [chess.D4, chess.D5, chess.E4, chess.E5]\n    white_control = sum(1 for square in central_squares if board.piece_at(square) and board.piece_at(square).color == chess.WHITE)\n    black_control = sum(1 for square in central_squares if board.piece_at(square) and board.piece_at(square).color == chess.BLACK)\n    return float(white_control - black_control)\n\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the total number of threats against the opponent's king.\"\n    opponent_color = chess.BLACK if board.turn else chess.WHITE\n    threats = sum(1 for square in board.piece_map() if board.piece_map()[square].color == opponent_color and board.is_attacked_by(board.turn, square))\n    return float(threats)\n\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the potential for pawn promotion by counting pawns on the 7th rank for both sides.\"\n    white_pawns_on_7th = sum(1 for square in range(56, 64) if board.piece_at(square) and board.piece_at(square).color == chess.WHITE and board.piece_at(square).piece_type == chess.PAWN)\n    black_pawns_on_7th = sum(1 for square in range(8, 16) if board.piece_at(square) and board.piece_at(square).color == chess.BLACK and board.piece_at(square).piece_type == chess.PAWN)\n    return float(white_pawns_on_7th - black_pawns_on_7th)\n\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Evaluates the number of unprotected pieces on the board for both sides.\"\n    unprotected_count = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == board.turn and not board.is_attacked_by(not board.turn, square):\n            unprotected_count += 1\n    return float(unprotected_count)\n\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the potential of the rooks by counting their ranks and files control.\"\n    rook_value = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == board.turn and piece.piece_type == chess.ROOK:\n            rook_value += (chess.square_rank(square) + chess.square_file(square))\n    return float(rook_value)\n\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the balance of piece types by comparing the total number of minor and major pieces of both sides.\"\n    piece_count = {\n        chess.WHITE: {'minor': 0, 'major': 0},\n        chess.BLACK: {'minor': 0, 'major': 0}\n    }\n    \n    for piece in board.piece_map().values():\n        if piece.piece_type in {chess.KNIGHT, chess.BISHOP}:\n            piece_count[piece.color]['minor'] += 1\n        elif piece.piece_type in {chess.ROOK, chess.QUEEN}:\n            piece_count[piece.color]['major'] += 1\n\n    return float(piece_count[chess.WHITE]['minor'] + piece_count[chess.WHITE]['major'] - (piece_count[chess.BLACK]['minor'] + piece_count[chess.BLACK]['major']))\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the control of the center squares (d4, d5, e4, e5) for both sides.\"\n    center_squares = [chess.D4, chess.D5, chess.E4, chess.E5]\n    white_control = sum(1 for square in center_squares if board.is_attacked_by(chess.WHITE, square))\n    black_control = sum(1 for square in center_squares if board.is_attacked_by(chess.BLACK, square))\n    return float(white_control - black_control)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces on each side that are pinned.\"\n    pinned_white = sum(1 for square in board.piece_map() if board.piece_map()[square].color == chess.WHITE and board.is_attacked_by(chess.BLACK, square) and board.is_attacked_by(chess.WHITE, square))\n    pinned_black = sum(1 for square in board.piece_map() if board.piece_map()[square].color == chess.BLACK and board.is_attacked_by(chess.WHITE, square) and board.is_attacked_by(chess.BLACK, square))\n    return float(pinned_white - pinned_black)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the number of pawn promotions that could be achieved in future moves.\"\n    white_promotions = sum(1 for square in range(8, 16) if board.piece_at(square) and board.piece_at(square).color == chess.WHITE)\n    black_promotions = sum(1 for square in range(48, 56) if board.piece_at(square) and board.piece_at(square).color == chess.BLACK)\n    return float(white_promotions - black_promotions)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Evaluates the material imbalance, counting the total value of pieces for each side.\"\n    material_values = {\n        chess.PAWN: 1,\n        chess.KNIGHT: 3,\n        chess.BISHOP: 3,\n        chess.ROOK: 5,\n        chess.QUEEN: 9,\n        chess.KING: 0\n    }\n    white_material = sum(material_values[piece.piece_type] for piece in board.piece_map().values() if piece.color == chess.WHITE)\n    black_material = sum(material_values[piece.piece_type] for piece in board.piece_map().values() if piece.color == chess.BLACK)\n    return float(white_material - black_material)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Determines if any player has a complete piece integration (e.g. pieces connected).\"\n    def has_connected_pieces(color):\n        connected = set()\n        for square in range(64):\n            piece = board.piece_at(square)\n            if piece and piece.color == color:\n                connected.add(square)\n        return len(connected) >= 3  # arbitrary threshold for connected pieces\n    \n    white_connected = has_connected_pieces(chess.WHITE)\n    black_connected = has_connected_pieces(chess.BLACK)\n    return float(white_connected - black_connected)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the total number of developed pieces for each side.\"\n    def developed_pieces(color):\n        return sum(1 for square in board.piece_map() if board.piece_map()[square].color == color and chess.square_rank(square) > 1)\n    \n    white_development = developed_pieces(chess.WHITE)\n    black_development = developed_pieces(chess.BLACK)\n    return float(white_development - black_development)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the kings' safety scores based on surrounding piece protection.\"\n    def king_safety(color):\n        king_square = next(square for square, piece in board.piece_map().items() if piece.color == color and piece.piece_type == chess.KING)\n        return sum(1 for square in board.attackers(color, king_square))\n    \n    white_safety = king_safety(chess.WHITE)\n    black_safety = king_safety(chess.BLACK)\n    return float(white_safety - black_safety)\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the difference in piece development by counting pieces on the 2nd and 7th ranks.\"\n    white_development = sum(1 for square in range(8) if board.piece_at(chess.square(square, 1)))\n    black_development = sum(1 for square in range(8) if board.piece_at(chess.square(square, 6)))\n    return float(white_development - black_development)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of pawn structures on each side that are doubled, isolated, or blocked.\"\n    def pawn_structure_weakness(color):\n        count = 0\n        for file in range(8):\n            pawn_count = sum(1 for rank in range(8) if board.piece_at(chess.square(file, rank)) == chess.PAWN and (piece := board.piece_at(chess.square(file, rank))).color == color)\n            if pawn_count > 1:\n                count += 1  # Count doubled pawns\n            if pawn_count == 1:\n                count += 0 if (file > 0 and board.piece_at(chess.square(file-1, rank)) != chess.PAWN) and (file < 7 and board.piece_at(chess.square(file+1, rank)) != chess.PAWN) else 1  # Isolated pawn\n        return count\n\n    white_weakness = pawn_structure_weakness(chess.WHITE)\n    black_weakness = pawn_structure_weakness(chess.BLACK)\n    return float(white_weakness - black_weakness)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures king safety based on the number of squares around the king that are attacked.\"\n    king_square = next(square for square, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color == board.turn)\n    attacked_squares = sum(1 for square in chess.SQUARES if board.is_attacked_by(not board.turn, square) and chess.square_distance(square, king_square) <= 1)\n    return float(attacked_squares)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the number of pieces attacked and defended for each side to assess position strength.\"\n    piece_map = board.piece_map()\n    white_attacked = sum(1 for square, piece in piece_map.items() if piece.color == chess.WHITE and board.is_attacked_by(chess.BLACK, square))\n    white_defended = sum(1 for square, piece in piece_map.items() if piece.color == chess.WHITE and len(list(board.attackers(chess.WHITE, square))) > 0)\n    \n    black_attacked = sum(1 for square, piece in piece_map.items() if piece.color == chess.BLACK and board.is_attacked_by(chess.WHITE, square))\n    black_defended = sum(1 for square, piece in piece_map.items() if piece.color == chess.BLACK and len(list(board.attackers(chess.BLACK, square))) > 0)\n\n    return float((white_defended - white_attacked) - (black_defended - black_attacked))\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures material balance, excluding pawns, in relation to the total number of pieces.\"\n    material_values = {\n        chess.KNIGHT: 3,\n        chess.BISHOP: 3,\n        chess.ROOK: 5,\n        chess.QUEEN: 9\n    }\n    def calculate_material(color):\n        return sum(material_values.get(piece.piece_type, 0) for piece in board.piece_map().values() if piece.color == color)\n\n    white_material = calculate_material(chess.WHITE)\n    black_material = calculate_material(chess.BLACK)\n    total_pieces = sum(1 for piece in board.piece_map().values())\n    \n    return float((white_material / (total_pieces if total_pieces else 1)) - (black_material / (total_pieces if total_pieces else 1)))\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the difference in the number of pieces that can move to the opponent's back rank.\"\n    def back_rank_threats(color):\n        return sum(1 for square in range(8) if board.is_attacked_by(color, chess.square(square, 0 if color == chess.WHITE else 7)))\n\n    white_threats = back_rank_threats(chess.WHITE)\n    black_threats = back_rank_threats(chess.BLACK)\n    return float(white_threats - black_threats)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the pressure on the center squares based on piece positioning.\"\n    center_squares = [chess.D4, chess.D5, chess.E4, chess.E5]\n    white_pressure = sum(1 for square in center_squares if board.is_attacked_by(chess.WHITE, square))\n    black_pressure = sum(1 for square in center_squares if board.is_attacked_by(chess.BLACK, square))\n    return float(white_pressure - black_pressure)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the number of pieces in the opponent's half of the board.\"\n    opponent_half = range(0, 32) if board.turn else range(32, 64)\n    piece_count = sum(1 for square, piece in board.piece_map().items() if piece.color == board.turn and square in opponent_half)\n    return float(piece_count)\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the distance of kings from their respective front lines.\"\n    white_king_square = next(square for square, piece in board.piece_map().items() if piece.color == chess.WHITE and piece.piece_type == chess.KING)\n    black_king_square = next(square for square, piece in board.piece_map().items() if piece.color == chess.BLACK and piece.piece_type == chess.KING)\n    white_distance = 7 - chess.square_rank(white_king_square)\n    black_distance = chess.square_rank(black_king_square)\n    return float(white_distance - black_distance)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the number of unprotected pieces for each side.\"\n    unprotected_pieces = {chess.WHITE: 0, chess.BLACK: 0}\n    for square, piece in board.piece_map().items():\n        if piece.color == chess.WHITE:\n            if not any(board.is_attacked_by(chess.BLACK, target_square) for target_square in board.attackers(piece.color, square)):\n                unprotected_pieces[chess.WHITE] += 1\n        else:\n            if not any(board.is_attacked_by(chess.WHITE, target_square) for target_square in board.attackers(piece.color, square)):\n                unprotected_pieces[chess.BLACK] += 1\n    return float(unprotected_pieces[chess.WHITE] - unprotected_pieces[chess.BLACK])\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the number of squares attacked by each side's pieces.\"\n    white_attacks = sum(len(board.attackers(chess.WHITE, square)) for square in board.piece_map() if board.piece_map()[square].color == chess.WHITE)\n    black_attacks = sum(len(board.attackers(chess.BLACK, square)) for square in board.piece_map() if board.piece_map()[square].color == chess.BLACK)\n    return float(white_attacks - black_attacks)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of active pieces (that can move) for both sides.\"\n    movable_white = sum(1 for square, piece in board.piece_map().items() if piece.color == chess.WHITE and len(list(board.legal_moves)) > 0)\n    movable_black = sum(1 for square, piece in board.piece_map().items() if piece.color == chess.BLACK and len(list(board.legal_moves)) > 0)\n    return float(movable_white - movable_black)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the number of forks possible with knights for each side.\"\n    def count_knight_forks(color):\n        knight_squares = [square for square in board.piece_map() if board.piece_map()[square].color == color and board.piece_map()[square].piece_type == chess.KNIGHT]\n        forks = 0\n        for knight_square in knight_squares:\n            potential_targets = [square for square in board.piece_map() if board.piece_map()[square].color != color and square not in knight_squares]\n            if len(potential_targets) >= 2:\n                forks += 1\n        return forks\n\n    white_forks = count_knight_forks(chess.WHITE)\n    black_forks = count_knight_forks(chess.BLACK)\n    return float(white_forks - black_forks)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the number of pieces in the opponent's half of the board.\"\n    opponent_color = chess.BLACK if board.turn else chess.WHITE\n    opponent_pieces_in_half = sum(1 for square, piece in board.piece_map().items() if piece.color == opponent_color and chess.square_rank(square) >= 4)\n    return float(opponent_pieces_in_half)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the score based on the number of pieces that control the opponent's pieces.\"\n    score = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == board.turn:\n            score += len(board.attackers(not piece.color, square))\n    return float(score)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the control of the 7th rank by both sides.\"\n    white_seventh_control = sum(1 for square in range(chess.A7, chess.H7 + 1) if board.is_attacked_by(chess.WHITE, square))\n    black_seventh_control = sum(1 for square in range(chess.A7, chess.H7 + 1) if board.is_attacked_by(chess.BLACK, square))\n    return float(white_seventh_control - black_seventh_control)\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the control of open files by rooks for both sides.\"\n    white_rook_control = sum(1 for square in board.piece_map() if board.piece_map()[square].color == chess.WHITE and board.piece_map()[square].piece_type == chess.ROOK and not any(board.is_attacked_by(chess.BLACK, sq) for sq in board.piece_map() if chess.square_file(square) == chess.square_file(sq)))\n    black_rook_control = sum(1 for square in board.piece_map() if board.piece_map()[square].color == chess.BLACK and board.piece_map()[square].piece_type == chess.ROOK and not any(board.is_attacked_by(chess.WHITE, sq) for sq in board.piece_map() if chess.square_file(square) == chess.square_file(sq)))\n    return float(white_rook_control - black_rook_control)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the number of pieces in the opponent's attacking range.\"\n    attacking_pieces_count = sum(1 for square in board.piece_map() if board.is_attacked_by(board.turn, square))\n    return float(attacking_pieces_count)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the number of threats each player can make.\"\n    white_threats = sum(1 for square in board.piece_map() if board.piece_map()[square].color == chess.WHITE and board.legal_moves.count() > 0)\n    black_threats = sum(1 for square in board.piece_map() if board.piece_map()[square].color == chess.BLACK and board.legal_moves.count() > 0)\n    return float(white_threats - black_threats)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the potential square control across the board.\"\n    control_squares = sum(1 for square in board.piece_map() if board.legal_moves.count() > 0)\n    return float(control_squares)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures kingside activity, evaluating the development of pieces around the king.\"\n    kingside_pieces = sum(1 for square in range(60, 64) if board.piece_at(square) and board.piece_at(square).color == board.turn)\n    return float(kingside_pieces)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the difference in mobility between both sides.\"\n    white_mobility = len(list(board.legal_moves)) if board.turn else 0\n    board.push(chess.Move.null())  # Simulate opponent's turn\n    black_mobility = len(list(board.legal_moves)) if not board.turn else 0\n    board.pop()  # Undo the null move\n    return float(white_mobility - black_mobility)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the number of pins affecting pieces for both sides.\"\n    white_pins = sum(1 for square in board.piece_map() if board.is_attacked_by(chess.BLACK, square) and board.piece_map()[square].color == chess.WHITE)\n    black_pins = sum(1 for square in board.piece_map() if board.is_attacked_by(chess.WHITE, square) and board.piece_map()[square].color == chess.BLACK)\n    return float(white_pins - black_pins)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the score for potential configurations on the board.\"\n    potential_configs = sum(1 for square in board.piece_map() if board.piece_map()[square].color == board.turn)\n    return float(potential_configs)\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the number of open files for rooks of each color.\"\n    open_files = sum(1 for file in range(8) \n                     if all(board.piece_at(chess.square(file, rank)) is None for rank in range(8)))\n    white_rooks = sum(1 for square in board.piece_map() \n                      if board.piece_map()[square].color == chess.WHITE and \n                      board.piece_map()[square].piece_type == chess.ROOK and \n                      chess.square_file(square) in range(open_files))\n    black_rooks = sum(1 for square in board.piece_map() \n                      if board.piece_map()[square].color == chess.BLACK and \n                      board.piece_map()[square].piece_type == chess.ROOK and \n                      chess.square_file(square) in range(open_files))\n    return float(white_rooks - black_rooks)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Evaluates the number of pieces on the back rank for each side.\"\n    white_back_rank = sum(1 for square in board.piece_map() \n                          if board.piece_map()[square].color == chess.WHITE and \n                          chess.square_rank(square) == 0)\n    black_back_rank = sum(1 for square in board.piece_map() \n                          if board.piece_map()[square].color == chess.BLACK and \n                          chess.square_rank(square) == 7)\n    return float(white_back_rank - black_back_rank)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the total value of each player's pieces expressed in terms of material.\"\n    material_values = {\n        chess.PAWN: 1,\n        chess.KNIGHT: 3,\n        chess.BISHOP: 3,\n        chess.ROOK: 5,\n        chess.QUEEN: 9\n    }\n    total_value = sum(material_values.get(piece.piece_type, 0) for piece in board.piece_map().values())\n    return float(total_value)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the average distance of pieces from their opponent's back rank.\"\n    material_values = {\n        chess.PAWN: 1,\n        chess.KNIGHT: 3,\n        chess.BISHOP: 3,\n        chess.ROOK: 5,\n        chess.QUEEN: 9,\n        chess.KING: 0\n    }\n    distance_sum = 0\n    total_pieces = 0\n    for square in board.piece_map():\n        piece = board.piece_map()[square]\n        if piece.color == board.turn:\n            opponent_back_rank = 0 if piece.color == chess.WHITE else 7\n            distance_sum += chess.square_distance(square, chess.square(chess.square_file(square), opponent_back_rank))\n            total_pieces += 1\n    return float(distance_sum / total_pieces) if total_pieces > 0 else 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the number of minor pieces on the board for each player.\"\n    white_minor = sum(1 for piece in board.piece_map().values() \n                      if piece.color == chess.WHITE and piece.piece_type in {chess.KNIGHT, chess.BISHOP})\n    black_minor = sum(1 for piece in board.piece_map().values() \n                      if piece.color == chess.BLACK and piece.piece_type in {chess.KNIGHT, chess.BISHOP})\n    return float(white_minor - black_minor)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the ratio of force to the number of pieces on the board.\"\n    material_values = {\n        chess.PAWN: 1,\n        chess.KNIGHT: 3,\n        chess.BISHOP: 3,\n        chess.ROOK: 5,\n        chess.QUEEN: 9,\n    }\n    total_material = sum(material_values.get(piece.piece_type, 0) for piece in board.piece_map().values())\n    total_pieces = len(board.piece_map())\n    return float(total_material / (total_pieces if total_pieces > 0 else 1))\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the number of squares controlled by each player's pawns.\"\n    controlled_squares = sum(1 for square in board.piece_map() \n                              if board.piece_map()[square].piece_type == chess.PAWN and \n                              board.piece_map()[square].color == board.turn and \n                              any(board.is_attacked_by(chess.BLACK if board.turn else chess.WHITE, target_square) \n                                  for target_square in board.attackers(board.turn, square)))\n    return float(controlled_squares)\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the control of central squares (d4, d5, e4, e5) by each side.\"\n    central_squares = [chess.D4, chess.E4, chess.D5, chess.E5]\n    white_control = sum(1 for square in central_squares if board.is_attacked_by(chess.WHITE, square))\n    black_control = sum(1 for square in central_squares if board.is_attacked_by(chess.BLACK, square))\n    return float(white_control - black_control)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the number of doubled pawns for each player.\"\n    def count_doubled_pawns(color):\n        pawn_files = [0] * 8\n        for square, piece in board.piece_map().items():\n            if piece.color == color and piece.piece_type == chess.PAWN:\n                pawn_files[chess.square_file(square)] += 1\n        return sum(1 for count in pawn_files if count > 1)\n\n    white_doubled = count_doubled_pawns(chess.WHITE)\n    black_doubled = count_doubled_pawns(chess.BLACK)\n    return float(white_doubled - black_doubled)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the number of potential discovered attacks from each side.\"\n    discovered_attacks = 0\n    for move in board.legal_moves:\n        board.push(move)\n        for target_square in board.legal_moves:\n            if board.is_attacked_by(not board.turn, target_square.to_square):\n                discovered_attacks += 1\n                break\n        board.pop()\n    return float(discovered_attacks)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the number of squares controlled by each player's pawns.\"\n    def pawn_control(color):\n        controlled_squares = set()\n        for square in board.piece_map():\n            piece = board.piece_at(square)\n            if piece and piece.color == color and piece.piece_type == chess.PAWN:\n                if chess.square_rank(square) < 7:\n                    controlled_squares.add(square + 7)  # Moves forward\n                controlled_squares.add(square + 8 - 2 * (color == chess.WHITE))  # Attacks diagonally\n                \n        return len(controlled_squares)\n\n    white_controlled = pawn_control(chess.WHITE)\n    black_controlled = pawn_control(chess.BLACK)\n    return float(white_controlled - black_controlled)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the number of pieces supported by pawns for each color.\"\n    def supported_pieces_count(color):\n        count = 0\n        for square, piece in board.piece_map().items():\n            if piece.color == color:\n                if piece.piece_type != chess.PAWN:\n                    file = chess.square_file(square)\n                    rank = chess.square_rank(square)\n                    if (board.piece_at(chess.square(file, rank - 1)) and board.piece_at(chess.square(file, rank - 1)).color == color) or \\\n                       (board.piece_at(chess.square(file - 1, rank - 1)) and board.piece_at(chess.square(file - 1, rank - 1)).color == color) or \\\n                       (board.piece_at(chess.square(file + 1, rank - 1)) and board.piece_at(chess.square(file + 1, rank - 1)).color == color):\n                        count += 1\n        return count\n\n    white_supported = supported_pieces_count(chess.WHITE)\n    black_supported = supported_pieces_count(chess.BLACK)\n    return float(white_supported - black_supported)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the total number of minor pieces (knights and bishops) for each player.\"\n    def count_minor_pieces(color):\n        return sum(1 for piece in board.piece_map().values() if piece.color == color and piece.piece_type in {chess.KNIGHT, chess.BISHOP})\n\n    white_minors = count_minor_pieces(chess.WHITE)\n    black_minors = count_minor_pieces(chess.BLACK)\n    return float(white_minors - black_minors)\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the number of pieces trapped or with limited movement opportunities.\"\n    trapped_pieces_count = sum(1 for square, piece in board.piece_map().items() if piece.color == board.turn and len(list(board.legal_moves)) == 0)\n    return float(trapped_pieces_count)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Evaluates space control by measuring the number of unoccupied squares in the central area.\"\n    central_squares = [chess.E4, chess.E5, chess.D4, chess.D5]\n    central_control = sum(1 for square in central_squares if board.piece_at(square) is None)\n    return float(central_control)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the potential for pawn promotion based on pawn positions.\"\n    promotion_pawns = sum(1 for square, piece in board.piece_map().items() if piece.color == board.turn and piece.piece_type == chess.PAWN and (chess.square_rank(square) == (7 if piece.color == chess.WHITE else 0)))\n    return float(promotion_pawns)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the number of pieces on the opponent's side of the board.\"\n    opponent_half = range(0, 4) if board.turn else range(4, 8)\n    pieces_on_opponent_side = sum(1 for square, piece in board.piece_map().items() if piece.color == board.turn and chess.square_file(square) in opponent_half)\n    return float(pieces_on_opponent_side)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Assesses the effectiveness of pawns as blockers or protectors of pieces.\"\n    protected_pawns = sum(1 for square, piece in board.piece_map().items() if piece.color == board.turn and piece.piece_type == chess.PAWN and any(board.is_attacked_by(not board.turn, square) for attack_square in board.attackers(board.turn, square)))\n    return float(protected_pawns)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the distance of the pieces from their home squares.\"\n    total_distance = sum(chess.square_rank(square) if piece.color == chess.WHITE else (7 - chess.square_rank(square)) for square, piece in board.piece_map().items())\n    return float(total_distance)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Evaluates the number of pieces attacking the back rank of the opponent.\"\n    back_rank_attacks = sum(1 for square in range(0, 8) if board.is_attacked_by(board.turn, chess.square(square, 0 if board.turn else 7)))\n    return float(back_rank_attacks)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the number of pieces aligned with the opponent's king, simulating a potential check.\"\n    opponent_king_square = next(square for square in board.piece_map() if board.piece_map()[square].color != board.turn and board.piece_map()[square].piece_type == chess.KING)\n    alignments = sum(1 for square, piece in board.piece_map().items() if piece.color == board.turn and (chess.square_file(square) == chess.square_file(opponent_king_square) or chess.square_rank(square) == chess.square_rank(opponent_king_square)))\n    return float(alignments)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Assesses the king's activity based on the number of available escape routes.\"\n    king_square = next(square for square in board.piece_map() if board.piece_map()[square].color == board.turn and board.piece_map()[square].piece_type == chess.KING)\n    escape_routes = sum(1 for move in board.legal_moves if chess.square_distance(move.from_square, king_square) == 1)\n    return float(escape_routes)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the material balance of minor pieces (knights and bishops) only.\"\n    minor_material_values = {chess.KNIGHT: 3, chess.BISHOP: 3}\n    def calculate_minor_material(color):\n        return sum(minor_material_values.get(piece.piece_type, 0) for piece in board.piece_map().values() if piece.color == color)\n\n    white_minor_material = calculate_minor_material(chess.WHITE)\n    black_minor_material = calculate_minor_material(chess.BLACK)\n    return float(white_minor_material - black_minor_material)\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the number of doubled pawns for each side.\"\n    doubled_pawns_white = sum(1 for square in board.piece_map() if board.piece_map()[square].color == chess.WHITE and board.piece_map()[square].piece_type == chess.PAWN and (board.piece_at(chess.square_file(square) + 8) is not None or board.piece_at(chess.square_file(square) - 8) is not None))\n    doubled_pawns_black = sum(1 for square in board.piece_map() if board.piece_map()[square].color == chess.BLACK and board.piece_map()[square].piece_type == chess.PAWN and (board.piece_at(chess.square_file(square) + 8) is not None or board.piece_at(chess.square_file(square) - 8) is not None))\n    return float(doubled_pawns_white - doubled_pawns_black)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the pawn structure's strength by evaluating connected pawns.\"\n    def connected_pawns(color):\n        count = 0\n        for square in board.piece_map():\n            if board.piece_map()[square].color == color and board.piece_map()[square].piece_type == chess.PAWN:\n                if (board.piece_at(chess.square_file(square) - 1) and board.piece_at(chess.square_file(square) - 1).color == color) or (board.piece_at(chess.square_file(square) + 1) and board.piece_at(chess.square_file(square) + 1).color == color):\n                    count += 1\n        return count\n    \n    white_connected = connected_pawns(chess.WHITE)\n    black_connected = connected_pawns(chess.BLACK)\n    return float(white_connected - black_connected)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Assesses the imbalance of minor pieces on the board (knights versus bishops).\"\n    white_knights = sum(1 for square in board.piece_map() if board.piece_map()[square].color == chess.WHITE and board.piece_map()[square].piece_type == chess.KNIGHT)\n    black_knights = sum(1 for square in board.piece_map() if board.piece_map()[square].color == chess.BLACK and board.piece_map()[square].piece_type == chess.KNIGHT)\n    white_bishops = sum(1 for square in board.piece_map() if board.piece_map()[square].color == chess.WHITE and board.piece_map()[square].piece_type == chess.BISHOP)\n    black_bishops = sum(1 for square in board.piece_map() if board.piece_map()[square].color == chess.BLACK and board.piece_map()[square].piece_type == chess.BISHOP)\n    return float((white_knights - black_knights) + (white_bishops - black_bishops))\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates central pawn control by checking pawns in the center squares.\"\n    center_squares = {chess.E4, chess.E5, chess.D4, chess.D5}\n    white_center_control = sum(1 for square in center_squares if board.piece_at(square) and board.piece_at(square).color == chess.WHITE)\n    black_center_control = sum(1 for square in center_squares if board.piece_at(square) and board.piece_at(square).color == chess.BLACK)\n    return float(white_center_control - black_center_control)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Evaluates the number of potential back-rank weaknesses for each side.\"\n    def back_rank_weakness(color):\n        piece_rows = {chess.WHITE: 0, chess.BLACK: 7}\n        return sum(1 for square in range(8) if board.is_attacked_by(not color, chess.square(square, piece_rows[color])))\n\n    white_weakness = back_rank_weakness(chess.WHITE)\n    black_weakness = back_rank_weakness(chess.BLACK)\n    return float(black_weakness - white_weakness)\n",
    "def feature(board: chess.Board) -> float:\n    'Measures the number of major pieces (rook and queen) remaining for each side.'\n    major_pieces_white = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE and piece.piece_type in {chess.ROOK, chess.QUEEN})\n    major_pieces_black = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK and piece.piece_type in {chess.ROOK, chess.QUEEN})\n    return float(major_pieces_white - major_pieces_black)\n\n",
    "def feature(board: chess.Board) -> float:\n    'Measures the difference in king safety, based on the number of defenders around each king.'\n    def king_safety(color):\n        king_square = next(square for square, piece in board.piece_map().items() if piece.color == color and piece.piece_type == chess.KING)\n        return len(board.attackers(color, king_square))\n\n    white_defenders = king_safety(chess.WHITE)\n    black_defenders = king_safety(chess.BLACK)\n    return float(black_defenders - white_defenders)\n\n",
    "def feature(board: chess.Board) -> float:\n    'Measures the control of the center squares (d4, d5, e4, e5) for both players.'\n    center_squares = [chess.D4, chess.D5, chess.E4, chess.E5]\n    white_control = sum(1 for square in center_squares if board.is_attacked_by(chess.WHITE, square))\n    black_control = sum(1 for square in center_squares if board.is_attacked_by(chess.BLACK, square))\n    return float(white_control - black_control)\n\n",
    "def feature(board: chess.Board) -> float:\n    'Calculates the number of pieces attacking the same square for the current player.'\n    attacks = sum(len(board.attackers(board.turn, square)) for square in board.piece_map() if board.piece_map()[square].color == board.turn)\n    return float(attacks)\n\n",
    "def feature(board: chess.Board) -> float:\n    'Measures the potential to create a passed pawn by counting pawns that have no opposing pawns in front of them.'\n    def passed_pawns(color):\n        return sum(1 for square in board.piece_map() if (board.piece_map()[square].color == color and \n            (color == chess.WHITE and square in range(chess.A5, chess.H8)) or \n            (color == chess.BLACK and square in range(chess.A2, chess.H5)) and \n            not (board.piece_at(square + 8) if color == chess.WHITE else board.piece_at(square - 8) if square >= 8 else None)))\n\n    white_passed = passed_pawns(chess.WHITE)\n    black_passed = passed_pawns(chess.BLACK)\n    return float(white_passed - black_passed)\n\n",
    "def feature(board: chess.Board) -> float:\n    'Evaluates piece mobility based on the number of legal moves each piece can make.'\n    def mobility(color):\n        return sum(len(list(board.legal_moves)) for square in board.piece_map() if board.piece_map()[square].color == color)\n\n    white_mobility = mobility(chess.WHITE)\n    black_mobility = mobility(chess.BLACK)\n    return float(white_mobility - black_mobility)\n\n",
    "def feature(board: chess.Board) -> float:\n    'Measures the number of pins against each king by either side.'\n    def pins(color):\n        king_square = next(square for square, piece in board.piece_map().items() if piece.color == color and piece.piece_type == chess.KING)\n        return sum(1 for square in board.piece_map() if (board.piece_map()[square].color != color and \n            board.attackers(color, square) and board.is_attacked_by(color, king_square)))\n\n    white_pins = pins(chess.WHITE)\n    black_pins = pins(chess.BLACK)\n    return float(white_pins - black_pins)\n\n",
    "def feature(board: chess.Board) -> float:\n    'Calculates the number of undefended pieces for both sides.'\n    def undefended_pieces(color):\n        return sum(1 for square in board.piece_map() if (board.piece_map()[square].color == color and \n            len(board.attackers(not color, square)) == 0))\n\n    white_undefended = undefended_pieces(chess.WHITE)\n    black_undefended = undefended_pieces(chess.BLACK)\n    return float(white_undefended - black_undefended)\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of developed pieces for each side, excluding the pawns.\"\n    developed_pieces_count = sum(1 for square, piece in board.piece_map().items() \n                                  if piece.color == board.turn and piece.piece_type in \n                                  {chess.KNIGHT, chess.BISHOP, chess.ROOK, chess.QUEEN} and \n                                  (chess.square_rank(square) > 0 if piece.color == chess.WHITE else chess.square_rank(square) < 7))\n    return float(developed_pieces_count)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the number of isolated pawns for both sides.\"\n    isolated_pawn_count = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == board.turn and piece.piece_type == chess.PAWN:\n            file = chess.square_file(square)\n            if not (board.piece_at(chess.square(file - 1, chess.square_rank(square))) and \n                    board.piece_at(chess.square(file + 1, chess.square_rank(square)))):\n                isolated_pawn_count += 1\n    return float(isolated_pawn_count)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces that are on the opponent's half of the board.\"\n    opponent_half_control = sum(1 for square, piece in board.piece_map().items() \n                                  if piece.color == board.turn and \n                                  (piece.color == chess.WHITE and chess.square_rank(square) > 3 or \n                                   piece.color == chess.BLACK and chess.square_rank(square) < 4))\n    return float(opponent_half_control)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the king's safety based on the number of adjacent attacking squares.\"\n    king_square = next((square for square, piece in board.piece_map().items() \n                        if piece.piece_type == chess.KING and piece.color == board.turn), None)\n    return float(len(board.attackers(not board.turn, king_square)))\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Evaluates the mobility of the rooks based on their openness and control of files.\"\n    rook_mobility = sum(1 for square, piece in board.piece_map().items() \n                        if piece.color == board.turn and piece.piece_type == chess.ROOK and\n                        all(board.piece_at(chess.square(file, rank)) is None for file in range(8) \n                            for rank in range(8) if chess.square_file(square) == file))\n    return float(rook_mobility)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the total value of pawns considering positions for both sides.\"\n    pawn_value = {chess.PAWN: 1}\n    total_pawn_value = sum(pawn_value[piece.piece_type] for piece in board.piece_map().values() \n                            if piece.piece_type == chess.PAWN and piece.color == board.turn)\n    return float(total_pawn_value)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of backward pawns for both sides.\"\n    backward_pawn_count = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == board.turn and piece.piece_type == chess.PAWN:\n            rank = chess.square_rank(square)\n            if rank < 7 and not (board.piece_at(chess.square(chess.square_file(square), rank + 1)) is None or \n                                 board.piece_at(chess.square(chess.square_file(square) - 1, rank + 1)) is None or \n                                 board.piece_at(chess.square(chess.square_file(square) + 1, rank + 1)) is None):\n                backward_pawn_count += 1\n    return float(backward_pawn_count)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the presence of pieces that can create threats to the opponent's king.\"\n    threat_multiplier = {chess.QUEEN: 9, chess.ROOK: 5, chess.KNIGHT: 3, chess.BISHOP: 3}\n    threats = sum(threat_multiplier[piece.piece_type] for square, piece in board.piece_map().items() \n                   if piece.color == board.turn and piece.piece_type in threat_multiplier)\n    return float(threats)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the total control over the board based on the pieces controlling squares.\"\n    controlled_squares = sum(1 for square in chess.SQUARES \n                             if any(board.is_attacked_by(piece.color, square) for piece in board.piece_map().values()))\n    return float(controlled_squares)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the number of piece exchanges available for the current turn.\"\n    exchange_moves_count = sum(1 for move in board.legal_moves if \n                                board.is_attacked_by(not board.turn, move.to_square))\n    return float(exchange_moves_count)\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the material advantage considering only minor pieces (knights and bishops).\"\n    material_values = {\n        chess.KNIGHT: 3,\n        chess.BISHOP: 3,\n    }\n    def calculate_minor_material(color):\n        return sum(material_values.get(piece.piece_type, 0) for piece in board.piece_map().values() if piece.color == color)\n    \n    white_minor_material = calculate_minor_material(chess.WHITE)\n    black_minor_material = calculate_minor_material(chess.BLACK)\n    \n    return float(white_minor_material - black_minor_material)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces attacked but not defended by either side.\"\n    attacked_and_hanging = sum(1 for square, piece in board.piece_map().items() \n                                if board.is_attacked_by(chess.WHITE, square) and \n                                not any(board.is_attacked_by(chess.BLACK, attack_square) for attack_square in board.attackers(chess.BLACK, square)) or\n                                board.is_attacked_by(chess.BLACK, square) and \n                                not any(board.is_attacked_by(chess.WHITE, attack_square) for attack_square in board.attackers(chess.WHITE, square)))\n    \n    return float(attacked_and_hanging)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the total number of squares occupied by each side.\"\n    white_occupied = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE)\n    black_occupied = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK)\n    return float(white_occupied - black_occupied)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the number of pieces on the back rank for each side.\"\n    back_rank_white = sum(1 for square in range(56, 64) if board.piece_at(square) and board.piece_at(square).color == chess.WHITE)\n    back_rank_black = sum(1 for square in range(0, 8) if board.piece_at(square) and board.piece_at(square).color == chess.BLACK)\n    return float(back_rank_white - back_rank_black)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the distance of the king from the center for each side.\"\n    white_king_square = next(square for square, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color == chess.WHITE)\n    black_king_square = next(square for square, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color == chess.BLACK)\n\n    white_king_distance = abs(chess.square_file(white_king_square) - 3.5) + abs(chess.square_rank(white_king_square) - 3.5)\n    black_king_distance = abs(chess.square_file(black_king_square) - 3.5) + abs(chess.square_rank(black_king_square) - 3.5)\n    \n    return float(black_king_distance - white_king_distance)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the number of exposed kings for each side.\"\n    white_exposed = int(board.is_check() and not board.is_checkmate())\n    black_exposed = int(board.is_check() and not board.is_checkmate())\n    return float(white_exposed - black_exposed)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces in front of the pawns for each side.\"\n    def count_pieces_in_front(color):\n        return sum(1 for square in board.piece_map().keys() if board.piece_map()[square].color == color and chess.square_rank(square) < 7)\n\n    white_pieces_in_front = count_pieces_in_front(chess.WHITE)\n    black_pieces_in_front = count_pieces_in_front(chess.BLACK)\n    \n    return float(white_pieces_in_front - black_pieces_in_front)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the number of doubled pawns for each side.\"\n    def count_doubled_pawns(color):\n        pawn_squares = [square for square in board.piece_map() if board.piece_map()[square].piece_type == chess.PAWN and board.piece_map()[square].color == color]\n        return sum(1 for file in range(8) if sum(1 for square in pawn_squares if chess.square_file(square) == file) > 1)\n    \n    white_doubled = count_doubled_pawns(chess.WHITE)\n    black_doubled = count_doubled_pawns(chess.BLACK)\n    return float(white_doubled - black_doubled)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Assesses the king's safety by counting pieces within one square of the opponent's king.\"\n    opponent_king_square = next((square for square, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color != board.turn), None)\n    if opponent_king_square is None:\n        return 0.0\n    safe_zone = sum(1 for square in range(64) if chess.square_distance(square, opponent_king_square) <= 1 and board.piece_at(square) is not None)\n    return float(safe_zone)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces that are unprotected by other pieces on each side.\"\n    def unprotected_pieces(color):\n        count = 0\n        for square, piece in board.piece_map().items():\n            if piece.color == color and not any(board.is_attacked_by(not color, square) for attacker_square in board.attackers(not color, square)):\n                count += 1\n        return count\n    \n    white_unprotected = unprotected_pieces(chess.WHITE)\n    black_unprotected = unprotected_pieces(chess.BLACK)\n    return float(white_unprotected - black_unprotected)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in central pawn control for both sides.\"\n    def central_pawn_control(color):\n        pawns = [square for square in board.piece_map() if board.piece_map()[square].piece_type == chess.PAWN and board.piece_map()[square].color == color]\n        return sum(1 for square in pawns if chess.square_file(square) in {3, 4})\n    \n    white_control = central_pawn_control(chess.WHITE)\n    black_control = central_pawn_control(chess.BLACK)\n    return float(white_control - black_control)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures development imbalance by assessing the number of developed pieces relative to the total pieces.\"\n    developed_white = sum(1 for square in board.piece_map() if board.piece_map()[square].color == chess.WHITE and \n                           chess.square_rank(square) > 1)\n    developed_black = sum(1 for square in board.piece_map() if board.piece_map()[square].color == chess.BLACK and \n                           chess.square_rank(square) > 6)\n    \n    total_white = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE)\n    total_black = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK)\n    \n    return float((developed_white / max(1, total_white)) - (developed_black / max(1, total_black))) \n\n",
    "def feature(board: chess.Board) -> float:\n    \"Evaluates the distance from the center for pieces on the board.\"\n    center_squares = {chess.D4, chess.D5, chess.E4, chess.E5}\n    def piece_distance(color):\n        distance = sum(chess.square_distance(square, center_square) \n                       for square in board.piece_map() \n                       if board.piece_map()[square].color == color \n                       for center_square in center_squares)\n        return distance\n\n    white_distance = piece_distance(chess.WHITE)\n    black_distance = piece_distance(chess.BLACK)\n    return float(black_distance - white_distance)\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in material value of major pieces (rooks and queens) for each side.\"\n    material_values = {\n        chess.ROOK: 5,\n        chess.QUEEN: 9\n    }\n    def calculate_major_material(color):\n        return sum(material_values.get(piece.piece_type, 0) for piece in board.piece_map().values() if piece.color == color)\n    \n    white_major_material = calculate_major_material(chess.WHITE)\n    black_major_material = calculate_major_material(chess.BLACK)\n    return float(white_major_material - black_major_material)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the amount of control over the center (e4, d4, e5, d5 squares) by each side.\"\n    center_squares = [chess.parse_square('e4'), chess.parse_square('d4'), chess.parse_square('e5'), chess.parse_square('d5')]\n    white_control = sum(1 for square in center_squares if board.is_attacked_by(chess.WHITE, square))\n    black_control = sum(1 for square in center_squares if board.is_attacked_by(chess.BLACK, square))\n    return float(white_control - black_control)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts how many pieces each side has that are unprotected (attacked but not defended).\"\n    def count_unprotected(color):\n        count = 0\n        for square, piece in board.piece_map().items():\n            if piece.color == color and board.is_attacked_by(not color, square) and not any(board.is_attacked_by(color, attacker) for attacker in board.attackers(not color, square)):\n                count += 1\n        return count\n    \n    white_unprotected = count_unprotected(chess.WHITE)\n    black_unprotected = count_unprotected(chess.BLACK)\n    return float(black_unprotected - white_unprotected)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the number of squares controlled by knights for each side.\"\n    def knight_control(color):\n        return sum(len([move for move in board.legal_moves if move.from_square == square]) for square in board.piece_map() if board.piece_map()[square].color == color and board.piece_map()[square].piece_type == chess.KNIGHT)\n    \n    white_knight_control = knight_control(chess.WHITE)\n    black_knight_control = knight_control(chess.BLACK)\n    return float(white_knight_control - black_knight_control)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the king safety by counting the number of pieces around the king's position.\"\n    def king_safety(color):\n        king_square = next(square for square, piece in board.piece_map().items() if piece.color == color and piece.piece_type == chess.KING)\n        return sum(1 for square in board.piece_map() if square in board.attackers(color, king_square))\n    \n    white_king_safety = king_safety(chess.WHITE)\n    black_king_safety = king_safety(chess.BLACK)\n    return float(black_king_safety - white_king_safety)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the number of doubled pawns for each side, as a disadvantage.\"\n    def count_doubled_pawns(color):\n        pawn_files = [0] * 8\n        for square, piece in board.piece_map().items():\n            if piece.color == color and piece.piece_type == chess.PAWN:\n                pawn_files[chess.square_file(square)] += 1\n        return sum(1 for count in pawn_files if count > 1)\n    \n    white_doubled = count_doubled_pawns(chess.WHITE)\n    black_doubled = count_doubled_pawns(chess.BLACK)\n    return float(black_doubled - white_doubled)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of hanging pieces (pieces that can be captured without retaliation) for each side.\"\n    def count_hanging_pieces(color):\n        count = 0\n        for square, piece in board.piece_map().items():\n            if piece.color == color and board.is_attacked_by(not color, square) and not any(board.is_attacked_by(color, attacker) for attacker in board.attackers(not color, square)):\n                count += 1\n        return count\n    \n    white_hanging = count_hanging_pieces(chess.WHITE)\n    black_hanging = count_hanging_pieces(chess.BLACK)\n    return float(black_hanging - white_hanging)\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the total material advantage of the current player over the opponent.\"\n    material_values = {\n        chess.PAWN: 1,\n        chess.KNIGHT: 3,\n        chess.BISHOP: 3,\n        chess.ROOK: 5,\n        chess.QUEEN: 9,\n        chess.KING: 0\n    }\n    player_material = sum(material_values[piece.piece_type] for piece in board.piece_map().values() if piece.color == board.turn)\n    opponent_material = sum(material_values[piece.piece_type] for piece in board.piece_map().values() if piece.color != board.turn)\n    return float(player_material - opponent_material)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the number of open files for rooks for both sides.\"\n    def open_files(color):\n        return sum(1 for file in range(8) if all(board.piece_at(chess.square(file, rank)) is None for rank in range(8) \n                                                   if board.piece_at(chess.square(file, rank)) and board.piece_at(chess.square(file, rank)).color != color))\n    \n    white_open_files = open_files(chess.WHITE)\n    black_open_files = open_files(chess.BLACK)\n    return float(white_open_files - black_open_files)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the piece activity of bishops based on their control over diagonals.\"\n    def bishop_activity(color):\n        return sum(1 for square in board.piece_map() if board.piece_map()[square].color == color \n                   and board.piece_map()[square].piece_type == chess.BISHOP \n                   and (chess.square_distance(square, chess.A1) < 7 or chess.square_distance(square, chess.H8) < 7))\n    \n    white_activity = bishop_activity(chess.WHITE)\n    black_activity = bishop_activity(chess.BLACK)\n    return float(white_activity - black_activity)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the total control of the edges of the board (1st and 8th ranks, 1st and 8th files).\"\n    edge_squares = [square for square in range(64) if chess.square_rank(square) in {0, 7} or chess.square_file(square) in {0, 7}]\n    white_control = sum(1 for square in edge_squares if board.is_attacked_by(chess.WHITE, square))\n    black_control = sum(1 for square in edge_squares if board.is_attacked_by(chess.BLACK, square))\n    return float(white_control - black_control)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of doubled pawns for each side.\"\n    def count_doubled_pawns(color):\n        pawn_files = [0] * 8\n        for square in board.piece_map():\n            if board.piece_map()[square].color == color and board.piece_map()[square].piece_type == chess.PAWN:\n                pawn_files[chess.square_file(square)] += 1\n        return sum(1 for count in pawn_files if count > 1)\n    \n    white_doubled = count_doubled_pawns(chess.WHITE)\n    black_doubled = count_doubled_pawns(chess.BLACK)\n    return float(white_doubled - black_doubled)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the king's safety based on the number of pieces defending it.\"\n    king_square = next(square for square, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color == board.turn)\n    defending_pieces = sum(1 for square in board.piece_map() if board.piece_map()[square].color == board.turn \n                           and square in board.attackers(not board.turn, king_square))\n    return float(defending_pieces)\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the number of pieces beyond the 4th rank for both sides.\"\n    white_advanced = sum(1 for square in board.piece_map() if board.piece_map()[square].color == chess.WHITE and chess.square_rank(square) > 3)\n    black_advanced = sum(1 for square in board.piece_map() if board.piece_map()[square].color == chess.BLACK and chess.square_rank(square) < 4)\n    return float(white_advanced - black_advanced)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the number of squares attacked by the current player's pieces.\"\n    attacker_count = sum(len(board.attackers(board.turn, square)) for square in board.piece_map() if board.piece_map()[square].color == board.turn)\n    return float(attacker_count)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures how many pawns are on the 7th rank (for white) or 2nd rank (for black).\"\n    white_pawns_on_7th = sum(1 for square in range(56, 64) if board.piece_at(square) and board.piece_at(square).piece_type == chess.PAWN)\n    black_pawns_on_2nd = sum(1 for square in range(8) if board.piece_at(square) and board.piece_at(square).piece_type == chess.PAWN)\n    return float(white_pawns_on_7th - black_pawns_on_2nd)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the difference in the number of pieces in each player's possession that can promote.\"\n    white_promising = sum(1 for square in board.piece_map() if board.piece_map()[square].color == chess.WHITE and chess.square_rank(square) == 6)\n    black_promising = sum(1 for square in board.piece_map() if board.piece_map()[square].color == chess.BLACK and chess.square_rank(square) == 1)\n    return float(white_promising - black_promising)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the number of potential checks each side can deliver on the next turn.\"\n    potential_checks = 0\n    for move in board.legal_moves:\n        board.push(move)\n        if board.is_check():\n            potential_checks += 1\n        board.pop()\n    return float(potential_checks)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the clustering of pieces in relation to each color's respective half of the board.\"\n    white_cluster_radius = sum(chess.square_file(square) < 4 for square in board.piece_map() if board.piece_map()[square].color == chess.WHITE)\n    black_cluster_radius = sum(chess.square_file(square) > 3 for square in board.piece_map() if board.piece_map()[square].color == chess.BLACK)\n    return float(white_cluster_radius - black_cluster_radius)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the distance of the closest opposing piece to the player's king.\"\n    king_square = next(square for square in board.piece_map() if board.piece_map()[square].piece_type == chess.KING and board.piece_map()[square].color == board.turn)\n    closest_piece_distance = float('inf')\n    \n    for square, piece in board.piece_map().items():\n        if piece.color != board.turn:\n            distance = chess.square_distance(king_square, square)\n            closest_piece_distance = min(closest_piece_distance, distance)\n\n    return 1 / (closest_piece_distance + 1)  # Return a value that increases as distance decreases\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the pawn structure stability by assessing double pawns.\"\n    double_pawn_count = sum(1 for square in range(8) for color in (chess.WHITE, chess.BLACK) if \n                             sum(1 for sq in range(8) if (board.piece_at(sq) and board.piece_at(sq).color == color)) > 1)\n    return float(-double_pawn_count)  # Negative value since double pawns are a weakness\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in central control by counting pieces on central squares.\"\n    central_squares = [chess.E4, chess.E5, chess.D4, chess.D5]\n    white_control = sum(1 for square in central_squares if board.piece_at(square) and board.piece_at(square).color == chess.WHITE)\n    black_control = sum(1 for square in central_squares if board.piece_at(square) and board.piece_at(square).color == chess.BLACK)\n    return float(white_control - black_control)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the overall material imbalance based on the pieces captured.\"\n    material_values = {\n        chess.PAWN: 1,\n        chess.KNIGHT: 3,\n        chess.BISHOP: 3,\n        chess.ROOK: 5,\n        chess.QUEEN: 9,\n        chess.KING: 0\n    }\n    white_material = sum(material_values[piece.piece_type] for piece in board.piece_map().values() if piece.color == chess.WHITE)\n    black_material = sum(material_values[piece.piece_type] for piece in board.piece_map().values() if piece.color == chess.BLACK)\n    return float(white_material - black_material)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Evaluates the number of pieces that are actively contributing to the attack for both sides.\"\n    attacking_pieces = 0\n    for square, piece in board.piece_map().items():\n        attack_moves = sum(1 for move in board.legal_moves if move.from_square == square)\n        if attack_moves > 0:\n            attacking_pieces += 1 if piece.color == chess.WHITE else -1\n    return float(attacking_pieces)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of pawn moves made by each side, indicating pawn structure development.\"\n    white_pawn_moves = sum(1 for square in board.piece_map() if board.piece_map()[square].color == chess.WHITE and board.fullmove_number > 1)\n    black_pawn_moves = sum(1 for square in board.piece_map() if board.piece_map()[square].color == chess.BLACK and board.fullmove_number > 1)\n    return float(white_pawn_moves - black_pawn_moves)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the presence of unprotected pieces on the board for both sides.\"\n    unprotected_pieces = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == board.turn:\n            if not board.attackers(chess.BLACK if piece.color == chess.WHITE else chess.WHITE, square):\n                unprotected_pieces += 1 if piece.color == chess.WHITE else -1\n    return float(unprotected_pieces)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the total number of piece exchanges that could lead to a stronger position.\"\n    potential_exchanges = 0\n    for move in board.legal_moves:\n        target_piece = board.piece_at(move.to_square)\n        if target_piece and target_piece.color != board.piece_at(move.from_square).color:\n            potential_exchanges += 1\n    return float(potential_exchanges)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates pawn structure by counting the number of isolated pawns.\"\n    isolated_pawns = 0\n    for file in range(8):\n        white_pawn = board.piece_at(chess.square(file, 1))\n        black_pawn = board.piece_at(chess.square(file, 6))\n        if white_pawn and white_pawn.color == chess.WHITE and ((file > 0 and not board.piece_at(chess.square(file - 1, 1))) and (file < 7 and not board.piece_at(chess.square(file + 1, 1)))):\n            isolated_pawns += 1\n        if black_pawn and black_pawn.color == chess.BLACK and ((file > 0 and not board.piece_at(chess.square(file - 1, 6))) and (file < 7 and not board.piece_at(chess.square(file + 1, 6)))):\n            isolated_pawns -= 1\n    return float(isolated_pawns)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the presence of dangerous passed pawns that may promote.\"\n    passed_pawns_count = 0\n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.PAWN and piece.color == board.turn:\n            if (piece.color == chess.WHITE and square >= chess.A5) or (piece.color == chess.BLACK and square <= chess.H4):\n                passed = True\n                for file in range(chess.square_file(square) - 1, chess.square_file(square) + 2):\n                    if (file >= 0 and file < 8) and board.piece_at(chess.square(file, chess.square_rank(square) - (1 if piece.color == chess.WHITE else -1))):\n                        passed = False\n                        break\n                if passed:\n                    passed_pawns_count += 1 if piece.color == chess.WHITE else -1\n    return float(passed_pawns_count)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Evaluates the number of available checks for both sides.\"\n    available_checks = 0\n    for move in board.legal_moves:\n        if board.piece_at(move.from_square).piece_type == chess.KING:\n            continue\n        if board.gives_check(move):\n            available_checks += 1 if board.piece_at(move.from_square).color == chess.WHITE else -1\n    return float(available_checks)\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the total number of attacking pieces of each side.\"\n    white_attackers = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE)\n    black_attackers = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK)\n    return float(white_attackers - black_attackers)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the total value of pieces each side has while considering the positions of their kings.\"\n    material_values = {\n        chess.PAWN: 1,\n        chess.KNIGHT: 3,\n        chess.BISHOP: 3,\n        chess.ROOK: 5,\n        chess.QUEEN: 9,\n        chess.KING: 0\n    }\n    white_value = sum(material_values[piece.piece_type] for piece in board.piece_map().values() if piece.color == chess.WHITE)\n    black_value = sum(material_values[piece.piece_type] for piece in board.piece_map().values() if piece.color == chess.BLACK)\n    \n    white_king_pos = sum(chess.square_rank(square) for square in board.piece_map() if board.piece_map()[square].piece_type == chess.KING and board.piece_map()[square].color == chess.WHITE)\n    black_king_pos = sum(chess.square_rank(square) for square in board.piece_map() if board.piece_map()[square].piece_type == chess.KING and board.piece_map()[square].color == chess.BLACK)\n    \n    adjusted_white_value = white_value - (white_king_pos / 10)\n    adjusted_black_value = black_value - ((7 - black_king_pos) / 10)\n    \n    return float(adjusted_white_value - adjusted_black_value)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the number of pawns on the 2nd rank for White and the 7th rank for Black.\"\n    white_pawns_on_rank = sum(1 for square in range(8, 16) if board.piece_at(square) and board.piece_at(square).color == chess.WHITE)\n    black_pawns_on_rank = sum(1 for square in range(48, 56) if board.piece_at(square) and board.piece_at(square).color == chess.BLACK)\n    return float(white_pawns_on_rank - black_pawns_on_rank)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the number of pieces that are currently pinned by the opponent's pieces.\"\n    def count_pinned_pieces(color):\n        pinned_count = 0\n        for square, piece in board.piece_map().items():\n            if piece.color == color:\n                for target_square in board.attackers(not color, square):\n                    if board.piece_at(target_square):\n                        pinned_count += 1\n                        break\n        return pinned_count\n    \n    white_pinned = count_pinned_pieces(chess.WHITE)\n    black_pinned = count_pinned_pieces(chess.BLACK)\n    return float(white_pinned - black_pinned)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the number of available checks the current player can deliver.\"\n    checks = sum(1 for move in board.legal_moves if board.is_check())\n    return float(checks)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the difference in the number of doubled pawns each side has.\"\n    def count_doubled_pawns(color):\n        pawn_files = [0] * 8\n        for square in board.piece_map():\n            piece = board.piece_map()[square]\n            if piece.color == color and piece.piece_type == chess.PAWN:\n                pawn_files[chess.square_file(square)] += 1\n        return sum(max(0, count - 1) for count in pawn_files)\n\n    white_doubled = count_doubled_pawns(chess.WHITE)\n    black_doubled = count_doubled_pawns(chess.BLACK)\n    return float(white_doubled - black_doubled)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in the number of reserves available for promotion.\"\n    def count_pawns(color):\n        return sum(1 for square in board.piece_map() if board.piece_map()[square].color == color and board.piece_map()[square].piece_type == chess.PAWN)\n\n    white_pawns = count_pawns(chess.WHITE)\n    black_pawns = count_pawns(chess.BLACK)\n    return float(white_pawns - black_pawns)\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the number of pieces controlled by each side, including pawns, on critical central squares.\"\n    central_squares = [chess.E4, chess.E5, chess.D4, chess.D5]\n    white_control = sum(1 for square in central_squares if board.is_attacked_by(chess.WHITE, square))\n    black_control = sum(1 for square in central_squares if board.is_attacked_by(chess.BLACK, square))\n    return float(white_control - black_control)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of major pieces (rooks and queens) on the board, giving an idea of endgame readiness.\"\n    major_pieces_count = {\n        chess.WHITE: 0,\n        chess.BLACK: 0\n    }\n    for piece in board.piece_map().values():\n        if piece.piece_type in {chess.ROOK, chess.QUEEN}:\n            major_pieces_count[piece.color] += 1\n    return float(major_pieces_count[chess.WHITE] - major_pieces_count[chess.BLACK])\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the number of doubled pawns for each side, indicating structural weaknesses.\"\n    pawn_structure = {chess.WHITE: [], chess.BLACK: []}\n    for square in board.piece_map():\n        piece = board.piece_at(square)\n        if piece and piece.piece_type == chess.PAWN:\n            pawn_structure[piece.color].append(chess.square_file(square))\n    \n    white_doubled = sum(pawn_structure[chess.WHITE].count(file) > 1 for file in set(pawn_structure[chess.WHITE]))\n    black_doubled = sum(pawn_structure[chess.BLACK].count(file) > 1 for file in set(pawn_structure[chess.BLACK]))\n    return float(black_doubled - white_doubled)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in numbers of light-squared and dark-squared pieces for positional assessment.\"\n    color_count = {chess.WHITE: {'light': 0, 'dark': 0}, chess.BLACK: {'light': 0, 'dark': 0}}\n    for square, piece in board.piece_map().items():\n        if piece.piece_type != chess.PAWN:  # Exclude pawns from this count\n            color_type = 'light' if (chess.square_file(square) + chess.square_rank(square)) % 2 == 0 else 'dark'\n            color_count[piece.color][color_type] += 1\n    return float(color_count[chess.WHITE]['light'] - color_count[chess.BLACK]['light']) - float(color_count[chess.WHITE]['dark'] - color_count[chess.BLACK]['dark'])\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Checks for potential discovered attacks by counting pieces that can move away from the line of attack.\"\n    discovered_counts = {chess.WHITE: 0, chess.BLACK: 0}\n    for square in chess.SQUARES:\n        if board.piece_at(square) and board.piece_at(square).piece_type in {chess.ROOK, chess.QUEEN}:\n            for move in board.legal_moves:\n                if move.from_square == square:\n                    piece_on_target = board.piece_at(move.to_square)\n                    if piece_on_target and piece_on_target.color != board.piece_at(square).color:\n                        discovered_counts[board.piece_at(square).color] += 1\n    return float(discovered_counts[chess.WHITE]) - float(discovered_counts[chess.BLACK])\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Gauges king safety by counting the number of pieces defending each king.\"\n    white_king_square = board.king(chess.WHITE)\n    black_king_square = board.king(chess.BLACK)\n    white_defenders = len(board.attackers(chess.WHITE, white_king_square))\n    black_defenders = len(board.attackers(chess.BLACK, black_king_square))\n    return float(white_defenders - black_defenders)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Examines the pawn majority on each side to assess endgame potential.\"\n    white_pawn_files = [chess.square_file(square) for square in range(8) if board.piece_at(chess.parse_square(chess.square_name(square))) and board.piece_at(chess.parse_square(chess.square_name(square))).color == chess.WHITE]\n    black_pawn_files = [chess.square_file(square) for square in range(56, 64) if board.piece_at(chess.parse_square(chess.square_name(square))) and board.piece_at(chess.parse_square(chess.square_name(square))).color == chess.BLACK]\n    return float(len(white_pawn_files) - len(black_pawn_files))\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the center control by evaluating the number of pieces on d4, d5, e4, and e5.\"\n    center_squares = [chess.D4, chess.D5, chess.E4, chess.E5]\n    white_center_control = sum(1 for square in center_squares if board.piece_at(square) and board.piece_at(square).color == chess.WHITE)\n    black_center_control = sum(1 for square in center_squares if board.piece_at(square) and board.piece_at(square).color == chess.BLACK)\n    return float(white_center_control - black_center_control)\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the number of pieces on the board to assess material density.\"\n    piece_count = len(board.piece_map())\n    return float(piece_count)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Evaluates piece activity by counting the number of pieces that can move.\"\n    active_pieces = sum(1 for piece in board.piece_map().values() if len(list(board.legal_moves)) > 0)\n    return float(active_pieces)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Assesses the central control by counting pieces in the central squares.\"\n    central_squares = [chess.D4, chess.D5, chess.E4, chess.E5]\n    central_control = sum(1 for square in central_squares if board.piece_at(square) and board.piece_at(square).color == board.turn)\n    return float(central_control)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the number of pieces pinned against the king.\"\n    pinned_count = sum(1 for square in board.piece_map() if board.is_attacked_by(chess.WHITE, square) and board.piece_at(square).color == chess.BLACK)\n    return float(pinned_count)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Assesses the pawn structure by counting isolated pawns.\"\n    isolated_pawns = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == board.turn and piece.piece_type == chess.PAWN:\n            file = chess.square_file(square)\n            if (board.piece_at(chess.square(file - 1, chess.square_rank(square))) is None and\n                board.piece_at(chess.square(file + 1, chess.square_rank(square))) is None):\n                isolated_pawns += 1\n    return float(isolated_pawns)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the total number of double pawns for both sides.\"\n    double_pawns = {'white': 0, 'black': 0}\n    pawn_files = [0] * 8\n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.PAWN:\n            pawn_files[chess.square_file(square)] += 1\n\n    for count in pawn_files:\n        if count > 1:\n            double_pawns['white' if board.turn else 'black'] += count - 1\n  \n    return float(double_pawns['white'] - double_pawns['black'])\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Assesses the mobility of the king by counting legal squares it can move to.\"\n    king_square = next((square for square, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color == board.turn), None)\n    if king_square is None:\n        return 0.0\n    legal_moves_count = sum(1 for move in board.legal_moves if move.from_square == king_square)\n    return float(legal_moves_count)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the distance of pieces from the opponent's pawns, assessing pressure.\"\n    opponent_pawns = [square for square, piece in board.piece_map().items() if piece.piece_type == chess.PAWN and piece.color != board.turn]\n    distance_sum = sum(chess.square_distance(square, pawn) for square in board.piece_map() if board.piece_map()[square].color == board.turn for pawn in opponent_pawns)\n    return float(distance_sum)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the number of pieces aligned with the opponent's king.\"\n    opponent_king_square = next((square for square, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color != board.turn), None)\n    aligned_count = 0\n    if opponent_king_square is not None:\n        for square in board.piece_map():\n            if board.piece_map()[square].color == board.turn and (chess.square_file(square) == chess.square_file(opponent_king_square) or chess.square_rank(square) == chess.square_rank(opponent_king_square)):\n                aligned_count += 1\n    return float(aligned_count)\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the number of pieces attacked by the opponent for each side.\"\n    attacks_white = sum(1 for square in board.piece_map() if board.piece_map()[square].color == chess.WHITE and board.is_attacked_by(chess.BLACK, square))\n    attacks_black = sum(1 for square in board.piece_map() if board.piece_map()[square].color == chess.BLACK and board.is_attacked_by(chess.WHITE, square))\n    return float(attacks_white - attacks_black)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces each side has that are currently pinned.\"\n    def count_pinned(color):\n        pinned_count = 0\n        for square in board.piece_map():\n            piece = board.piece_map()[square]\n            if piece.color == color:\n                for attacker in board.attackers(not color, square):\n                    if board.piece_at(attacker) and board.piece_at(attacker).piece_type == chess.QUEEN:\n                        pinned_count += 1\n        return pinned_count\n\n    white_pinned = count_pinned(chess.WHITE)\n    black_pinned = count_pinned(chess.BLACK)\n    return float(white_pinned - black_pinned)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Evaluates the number of central control squares occupied by each side.\"\n    central_squares = [chess.D4, chess.D5, chess.E4, chess.E5]\n    white_control = sum(1 for square in central_squares if board.piece_at(square) and board.piece_at(square).color == chess.WHITE)\n    black_control = sum(1 for square in central_squares if board.piece_at(square) and board.piece_at(square).color == chess.BLACK)\n    return float(white_control - black_control)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts potential checkmating threats by considering movable pieces towards the opponent's back rank.\"\n    threats = 0\n    for square in board.piece_map():\n        piece = board.piece_map()[square]\n        if piece.color == board.turn:\n            # Count legitimate moves that can threaten check\n            for move in board.legal_moves:\n                if move.to_square in (chess.A8, chess.B8, chess.C8, chess.D8, chess.E8, chess.F8, chess.G8, chess.H8) and board.is_checkmate():\n                    threats += 1\n    return float(threats)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in values of pieces on each side that are on the board's edge.\"\n    edge_squares = {chess.A1, chess.B1, chess.C1, chess.D1, chess.E1, chess.F1, chess.G1, chess.H1,\n                    chess.A8, chess.B8, chess.C8, chess.D8, chess.E8, chess.F8, chess.G8, chess.H8}\n    \n    material_values = {\n        chess.PAWN: 1,\n        chess.KNIGHT: 3,\n        chess.BISHOP: 3,\n        chess.ROOK: 5,\n        chess.QUEEN: 9,\n        chess.KING: 0\n    }\n    \n    edge_value_white = sum(material_values[piece.piece_type] for square, piece in board.piece_map().items() if piece.color == chess.WHITE and square in edge_squares)\n    edge_value_black = sum(material_values[piece.piece_type] for square, piece in board.piece_map().items() if piece.color == chess.BLACK and square in edge_squares)\n\n    return float(edge_value_white - edge_value_black)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the proposed sacrifice material value of knights for each side.\"\n    knight_value = 0\n    for square in board.piece_map():\n        piece = board.piece_map()[square]\n        if piece.color == chess.WHITE and piece.piece_type == chess.KNIGHT:\n            knight_value += 3\n        elif piece.color == chess.BLACK and piece.piece_type == chess.KNIGHT:\n            knight_value -= 3\n    return float(knight_value) \n\n",
    "def feature(board: chess.Board) -> float:\n    \"Assesses the number of safe squares for each side's king considering current threats.\"\n    def safe_squares(color):\n        king_square = None\n        for square in board.piece_map():\n            piece = board.piece_map()[square]\n            if piece.color == color and piece.piece_type == chess.KING:\n                king_square = square\n                break\n        if king_square is None:\n            return 0\n        return sum(1 for sq in chess.SQUARES if board.is_attacked_by(not color, sq) is False and chess.square_distance(sq, king_square) <= 1)\n\n    white_safe = safe_squares(chess.WHITE)\n    black_safe = safe_squares(chess.BLACK)\n    return float(white_safe - black_safe)\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in the number of pieces on the board for both sides.\"\n    white_piece_count = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE)\n    black_piece_count = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK)\n    return float(white_piece_count - black_piece_count)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Evaluates the king's safety by counting the number of attacking pieces near the king.\"\n    king_square = next(square for square, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color == board.turn)\n    attackers_count = len(board.attackers(not board.turn, king_square))\n    return float(attackers_count)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the average distance of pieces to the opponent's king for both sides.\"\n    def average_distance(color):\n        king_square = next(square for square, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color == (color))\n        distances = [chess.square_distance(square, king_square) for square, piece in board.piece_map().items() if piece.color == color]\n        return sum(distances) / len(distances) if distances else 0\n    \n    white_avg_distance = average_distance(chess.WHITE)\n    black_avg_distance = average_distance(chess.BLACK)\n    return float(black_avg_distance - white_avg_distance)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the control of the center squares (d4, d5, e4, e5) for both sides.\"\n    center_squares = [chess.parse_square('d4'), chess.parse_square('d5'), chess.parse_square('e4'), chess.parse_square('e5')]\n    white_center_control = sum(1 for sq in center_squares if board.is_attacked_by(chess.WHITE, sq))\n    black_center_control = sum(1 for sq in center_squares if board.is_attacked_by(chess.BLACK, sq))\n    return float(white_center_control - black_center_control)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of pins affecting pieces of both sides.\"\n    pin_count = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == board.turn:\n            for attacker in board.attackers(not board.turn, square):\n                if board.piece_at(attacker).piece_type == chess.ROOK or board.piece_at(attacker).piece_type == chess.QUEEN:\n                    for target in board.attackers(board.turn, square):\n                        if board.piece_at(target) is not None and board.piece_at(target).piece_type == chess.KING:\n                            pin_count += 1\n    return float(pin_count)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the difference in the number of active pieces (pieces with legal moves) for both sides.\"\n    def active_piece_count(color):\n        return sum(1 for square in board.piece_map().keys() if board.piece_map()[square].color == color and len(list(board.legal_moves)) > 0)\n\n    white_active = active_piece_count(chess.WHITE)\n    black_active = active_piece_count(chess.BLACK)\n    return float(white_active - black_active)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the number of pieces attacking the opponent's king.\"\n    opponent_king_square = next(square for square, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color != board.turn)\n    attacking_count = len(board.attackers(board.turn, opponent_king_square))\n    return float(attacking_count)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Evaluates the presence of rooks on open files for both players.\"\n    open_file_count = 0\n    for file in range(8):\n        if all(board.piece_at(chess.square(file, rank)) is None for rank in range(8)):\n            if any(board.piece_at(chess.square(file, rank)).piece_type == chess.ROOK for rank in range(8) if board.piece_at(chess.square(file, rank)) is not None):\n                open_file_count += 1\n    return float(open_file_count)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the historical pawn structure by counting doubled pawns for each side.\"\n    def doubled_pawn_count(color):\n        pawns = [square for square in board.piece_map() if board.piece_map()[square].piece_type == chess.PAWN and board.piece_map()[square].color == color]\n        return sum(1 for rank in range(8) if len([sq for sq in pawns if chess.square_rank(sq) == rank]) > 1)\n\n    white_doubled = doubled_pawn_count(chess.WHITE)\n    black_doubled = doubled_pawn_count(chess.BLACK)\n    return float(black_doubled - white_doubled)\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the number of advanced pawns (pawns on the 4th rank or beyond) for both sides.\"\n    advanced_pawns = sum(1 for square, piece in board.piece_map().items() if piece.piece_type == chess.PAWN and piece.color == board.turn and chess.square_rank(square) >= 4)\n    return float(advanced_pawns)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in total piece value between both sides, including pawns.\"\n    material_values = {\n        chess.PAWN: 1,\n        chess.KNIGHT: 3,\n        chess.BISHOP: 3,\n        chess.ROOK: 5,\n        chess.QUEEN: 9,\n        chess.KING: 0\n    }\n    white_material = sum(material_values[piece.piece_type] for piece in board.piece_map().values() if piece.color == chess.WHITE)\n    black_material = sum(material_values[piece.piece_type] for piece in board.piece_map().values() if piece.color == chess.BLACK)\n    return float(white_material - black_material)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the number of pieces developed (knights and bishops on their respective advanced ranks).\"\n    developed_pieces = sum(1 for square, piece in board.piece_map().items() if piece.color == board.turn and (piece.piece_type in {chess.KNIGHT, chess.BISHOP} and chess.square_rank(square) >= 2))\n    return float(developed_pieces)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Evaluates the symmetry of the board by counting similar pieces in mirrored positions.\"\n    mirrored_positions = [(chess.A1, chess.H1), (chess.B1, chess.G1), (chess.C1, chess.F1), (chess.D1, chess.E1)]\n    symmetry_count = sum(1 for a, b in mirrored_positions if board.piece_at(a) and board.piece_at(b) and board.piece_at(a).color == board.piece_at(b).color)\n    return float(symmetry_count)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the distance of the closest enemy piece to the current player's king.\"\n    king_square = next(square for square, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color == board.turn)\n    closest_distance = min(chess.square_distance(king_square, square) for square, piece in board.piece_map().items() if piece.color != board.turn) if any(piece.color != board.turn for piece in board.piece_map().values()) else 8\n    return float(closest_distance)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the total number of squares attacked by each player's pieces.\"\n    white_attacks = sum(1 for square in board.piece_map() if board.piece_map()[square].color == chess.WHITE and board.is_attacked_by(chess.WHITE, square))\n    black_attacks = sum(1 for square in board.piece_map() if board.piece_map()[square].color == chess.BLACK and board.is_attacked_by(chess.BLACK, square))\n    return float(white_attacks - black_attacks)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces on the back rank (first and eighth ranks) for both sides.\"\n    back_rank_count = sum(1 for square in range(0, 8) if board.piece_at(square) and board.piece_at(square).color == board.turn) + \\\n                     sum(1 for square in range(56, 64) if board.piece_at(square) and board.piece_at(square).color != board.turn)\n    return float(back_rank_count)\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the total material advantage for each side, factoring in piece types and counts.\"\n    material_values = {\n        chess.PAWN: 1,\n        chess.KNIGHT: 3,\n        chess.BISHOP: 3,\n        chess.ROOK: 5,\n        chess.QUEEN: 9,\n        chess.KING: 0\n    }\n    def calculate_material(color):\n        return sum(material_values[piece.piece_type] for piece in board.piece_map().values() if piece.color == color)\n\n    white_material = calculate_material(chess.WHITE)\n    black_material = calculate_material(chess.BLACK)\n    return float(white_material - black_material)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Evaluates the number of pieces that are currently pinned.\"\n    pinned_pieces = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == board.turn:\n            for target in board.attackers(not piece.color, square):\n                if board.piece_at(target) and board.piece_at(target).piece_type == chess.KING:\n                    pinned_pieces += 1\n                    break\n    return float(pinned_pieces)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the control of the center squares by both sides.\"\n    center_squares = [chess.E4, chess.E5, chess.D4, chess.D5]\n    white_control = sum(1 for square in center_squares if board.is_attacked_by(chess.WHITE, square))\n    black_control = sum(1 for square in center_squares if board.is_attacked_by(chess.BLACK, square))\n    return float(white_control - black_control)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the total number of connected pieces of each side.\"\n    def count_connected_pieces(color):\n        connected_count = 0\n        visited = set()\n        for square in board.piece_map():\n            if board.piece_map()[square].color == color and square not in visited:\n                connected_count += 1\n                visited.add(square)\n                for offset in [-1, 1, -8, 8, -7, -9, 7, 9]:  # Check adjacent squares\n                    adjacent_square = square + offset\n                    if 0 <= adjacent_square < 64 and (adjacent_square in board.piece_map() and board.piece_map()[adjacent_square].color == color):\n                        visited.add(adjacent_square)\n        return connected_count\n\n    white_connected = count_connected_pieces(chess.WHITE)\n    black_connected = count_connected_pieces(chess.BLACK)\n    return float(white_connected - black_connected)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Evaluates the mobility of the knights on the board.\"\n    def knight_mobility(color):\n        mobility = 0\n        for square, piece in board.piece_map().items():\n            if piece.color == color and piece.piece_type == chess.KNIGHT:\n                mobility += len(list(board.legal_moves))\n        return mobility\n\n    return float(knight_mobility(chess.WHITE) - knight_mobility(chess.BLACK))\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the number of threats against the opponent's pieces.\"\n    threats = 0\n    for square, piece in board.piece_map().items():\n        if piece.color != board.turn:\n            threats += len(list(board.attackers(board.turn, square)))\n    return float(threats)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Evaluates the potential pawn advancement for each side.\"\n    def pawn_advancement(color):\n        advancement = 0\n        for square, piece in board.piece_map().items():\n            if piece.color == color and piece.piece_type == chess.PAWN:\n                advancement += chess.square_rank(square)  # Higher rank means more advanced\n        return advancement\n\n    return float(pawn_advancement(chess.WHITE) - pawn_advancement(chess.BLACK))\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the king safety by checking the number of attacks on the king.\"\n    king_square = next(square for square, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color == board.turn)\n    return float(len(board.attackers(not board.turn, king_square)))\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the value of unprotected pieces for both sides.\"\n    def unprotected_value(color):\n        value = 0\n        for square, piece in board.piece_map().items():\n            if piece.color == color:\n                if not any(board.is_attacked_by(not color, square) for square in board.attackers(color, square)):\n                    value += {\n                        chess.PAWN: 1,\n                        chess.KNIGHT: 3,\n                        chess.BISHOP: 3,\n                        chess.ROOK: 5,\n                        chess.QUEEN: 9\n                    }.get(piece.piece_type, 0)\n        return value\n\n    return float(unprotected_value(chess.WHITE) - unprotected_value(chess.BLACK) )\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the mobility of the current player's pieces by counting reevaluated legal move scores.\"\n    mobility_score = 0\n    for move in board.legal_moves:\n        board.push(move)\n        mobility_score += len(list(board.legal_moves))\n        board.pop()\n    return float(mobility_score)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures pawn structure strength by counting connected pawns.\"\n    def connected_pawns(color):\n        pawns = [square for square in board.piece_map() if board.piece_map()[square].piece_type == chess.PAWN and board.piece_map()[square].color == color]\n        connections = 0\n        for square in pawns:\n            if abs(chess.square_file(square) - chess.square_file(square + 1)) <= 1:  # Check for horizontal connection\n                connections += 1\n        return connections\n\n    white_connections = connected_pawns(chess.WHITE)\n    black_connections = connected_pawns(chess.BLACK)\n    return float(white_connections - black_connections)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Evaluates control of key squares, specifically those around the opponent's king.\"\n    key_squares = {chess.parse_square('e4'), chess.parse_square('e5'), chess.parse_square('d4'), chess.parse_square('d5')}\n    def key_square_control(color):\n        return sum(1 for square in key_squares if board.is_attacked_by(color, square))\n    \n    white_control = key_square_control(chess.WHITE)\n    black_control = key_square_control(chess.BLACK)\n    return float(white_control - black_control)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the difference in development of knights versus bishops in the current position.\"\n    def piece_development(color):\n        knights = sum(1 for piece in board.piece_map().values() if piece.color == color and piece.piece_type == chess.KNIGHT)\n        bishops = sum(1 for piece in board.piece_map().values() if piece.color == color and piece.piece_type == chess.BISHOP)\n        return knights - bishops\n\n    white_development = piece_development(chess.WHITE)\n    black_development = piece_development(chess.BLACK)\n    return float(white_development)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Evaluates the impact of open files for rooks on a chessboard.\"\n    def open_files(color):\n        return sum(1 for file in range(8) if all(board.piece_at(chess.square(file, rank)) is None for rank in range(8) if chess.square(file, rank) in board.piece_map() and board.piece_map()[chess.square(file, rank)].color != color))\n    \n    white_open_files = open_files(chess.WHITE)\n    black_open_files = open_files(chess.BLACK)\n    return float(white_open_files - black_open_files)\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the activity level of pieces by counting how many legal moves each side has.\"\n    white_moves = len(list(board.legal_moves))\n    # Simulate opponent's turn to check for black's moves\n    board.push(chess.Move.null())\n    black_moves = len(list(board.legal_moves))\n    board.pop()\n    return float(white_moves - black_moves)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the ratio of material values of pieces currently on board.\"\n    material_values = {\n        chess.PAWN: 1,\n        chess.KNIGHT: 3,\n        chess.BISHOP: 3,\n        chess.ROOK: 5,\n        chess.QUEEN: 9,\n        chess.KING: 0\n    }\n    total_white_value = sum(material_values[piece.piece_type] for piece in board.piece_map().values() if piece.color == chess.WHITE)\n    total_black_value = sum(material_values[piece.piece_type] for piece in board.piece_map().values() if piece.color == chess.BLACK)\n    return float(total_white_value / (total_black_value if total_black_value > 0 else 1))\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of central control squares occupied by each side.\"\n    central_squares = [chess.D4, chess.D5, chess.E4, chess.E5]\n    white_control = sum(1 for square in central_squares if board.piece_at(square) and board.piece_at(square).color == chess.WHITE)\n    black_control = sum(1 for square in central_squares if board.piece_at(square) and board.piece_at(square).color == chess.BLACK)\n    return float(white_control - black_control)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the number of pinned pieces each side has.\"\n    def count_pinned(color):\n        pinned_count = 0\n        for square, piece in board.piece_map().items():\n            if piece.color == color:\n                for attacker in board.attackers(not color, square):\n                    if board.piece_at(attacker).piece_type == chess.QUEEN or (board.piece_at(attacker).piece_type == chess.ROOK and (attacker // 8 == square // 8)) or (board.piece_at(attacker).piece_type == chess.BISHOP and (attacker % 8 == square % 8)):\n                        pinned_count += 1\n                        break\n        return pinned_count\n    white_pinned = count_pinned(chess.WHITE)\n    black_pinned = count_pinned(chess.BLACK)\n    return float(white_pinned - black_pinned)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the number of safe squares for each side's pieces.\"\n    def safe_squares(color):\n        return sum(1 for square in board.piece_map() if board.piece_map()[square].color == color and not board.is_attacked_by(not color, square))\n    white_safe = safe_squares(chess.WHITE)\n    black_safe = safe_squares(chess.BLACK)\n    return float(white_safe - black_safe)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the mobility advantage by counting total pieces versus their squares.\"\n    total_pieces = sum(1 for piece in board.piece_map().values())\n    total_squares = len(board.piece_map())\n    return float(total_squares / (total_pieces if total_pieces > 0 else 1))\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Evaluates the king's safety by counting defending pieces around each side's king.\"\n    def king_safety(color):\n        king_square = next(square for square, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color == color)\n        return sum(1 for square in board.attackers(not color, king_square) if board.is_attacked_by(color, square))\n    white_safety = king_safety(chess.WHITE)\n    black_safety = king_safety(chess.BLACK)\n    return float(black_safety - white_safety)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures how many squares each side's pieces control.\"\n    def controlled_squares(color):\n        controlled = set()\n        for move in board.legal_moves:\n            controlled.add(move.to_square)\n        return len(controlled)\n\n    white_controlled = controlled_squares(chess.WHITE)\n    black_controlled = controlled_squares(chess.BLACK)\n    return float(white_controlled - black_controlled)\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the number of pieces that have no legal moves (blocked pieces).\"\n    blocked_count = sum(1 for square, piece in board.piece_map().items() if piece.color == board.turn and not list(board.legal_moves) and piece.color == board.turn)\n    return float(blocked_count)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the potential for pawn promotion by counting advanced pawns near the 7th rank.\"\n    advanced_promotions = sum(1 for square in chess.SQUARES if board.piece_at(square) and board.piece_at(square).color == board.turn and chess.square_rank(square) == 6)\n    return float(advanced_promotions)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in number of attacking pieces each side has.\"\n    white_attackers = sum(1 for square in chess.SQUARES if board.is_attacked_by(chess.WHITE, square))\n    black_attackers = sum(1 for square in chess.SQUARES if board.is_attacked_by(chess.BLACK, square))\n    return float(white_attackers - black_attackers)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the number of squares controlled by current player's pawns.\"\n    controlled_squares = sum(1 for square in chess.SQUARES if board.piece_at(square) and board.piece_at(square).color == board.turn and chess.square_rank(square) == 5)\n    return float(controlled_squares)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the number of pieces that are pinned against the king.\"\n    pinned_pieces = sum(1 for square, piece in board.piece_map().items() if piece.color == board.turn and any(board.is_attacked_by(board.turn, square) for target in board.piece_map().values() if target.piece_type == chess.KING))\n    return float(pinned_pieces)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the number of doubled pawns each side has on the board.\"\n    white_doubled_pawns = len([square for square in chess.SQUARES if board.piece_at(square) and board.piece_at(square).color == chess.WHITE and sum(1 for sq in chess.SQUARES if board.piece_at(sq) and chess.square_file(sq) == chess.square_file(square) and board.piece_at(sq).color == chess.WHITE) > 1])\n    black_doubled_pawns = len([square for square in chess.SQUARES if board.piece_at(square) and board.piece_at(square).color == chess.BLACK and sum(1 for sq in chess.SQUARES if board.piece_at(sq) and chess.square_file(sq) == chess.square_file(square) and board.piece_at(sq).color == chess.BLACK) > 1])\n    return float(white_doubled_pawns - black_doubled_pawns)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the total material advantage with a focus on minor pieces.\"\n    material_values = {\n        chess.PAWN: 1,\n        chess.KNIGHT: 3,\n        chess.BISHOP: 3,\n        chess.ROOK: 5,\n        chess.QUEEN: 9,\n        chess.KING: 0\n    }\n    minor_piece_value = sum(material_values[piece.piece_type] for piece in board.piece_map().values() if piece.color == chess.WHITE and piece.piece_type in [chess.KNIGHT, chess.BISHOP])\n    opponent_minor_piece_value = sum(material_values[piece.piece_type] for piece in board.piece_map().values() if piece.color == chess.BLACK and piece.piece_type in [chess.KNIGHT, chess.BISHOP])\n    return float(minor_piece_value - opponent_minor_piece_value)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Evaluates control over the center 4 squares of the board.\"\n    central_squares = [chess.E4, chess.E5, chess.D4, chess.D5]\n    center_control = 0\n    for square in central_squares:\n        if board.is_attacked_by(chess.WHITE, square):\n            center_control += 1\n        elif board.is_attacked_by(chess.BLACK, square):\n            center_control -= 1\n    return float(center_control)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the number of discovered attacks available for each side.\"\n    def discovered_attacks(color):\n        count = 0\n        for square, piece in board.piece_map().items():\n            if piece.color == color:\n                for move in board.legal_moves:\n                    if board.is_check() and move.from_square == square:\n                        continue\n                    board.push(move)\n                    if board.is_check():\n                        count += 1\n                    board.pop()\n        return count\n    \n    return float(discovered_attacks(chess.WHITE) - discovered_attacks(chess.BLACK))\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the balance of bishops with respect to their positioning (active vs passive).\"\n    def bishop_activity(color):\n        activity = 0\n        for square, piece in board.piece_map().items():\n            if piece.color == color and piece.piece_type == chess.BISHOP:\n                if chess.square_file(square) in [2, 5] and chess.square_rank(square) in [2, 5]:  # Active centers\n                    activity += 2\n                if chess.square_file(square) in [1, 6] and chess.square_rank(square) in [1, 6]:  # Passive positions\n                    activity -= 1\n        return activity\n\n    return float(bishop_activity(chess.WHITE) - bishop_activity(chess.BLACK))\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the strength of open files for rooks.\"\n    def open_files(color):\n        occupy_count = 0\n        for file in range(8):\n            is_open = True\n            for rank in range(8):\n                piece = board.piece_at(chess.square(file, rank))\n                if piece and piece.color == color:\n                    occupy_count += 1\n                    is_open = False\n                elif piece and piece.color != color:\n                    is_open = False\n            if is_open:\n                occupy_count += 1\n        return occupy_count\n\n    return float(open_files(chess.WHITE) - open_files(chess.BLACK))\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the degree of king safety based on pawn structure.\"\n    def king_safety(color):\n        king_square = next(square for square, piece in board.piece_map().items() if piece.color == color and piece.piece_type == chess.KING)\n        safety = 0\n        for square in range(64):\n            piece = board.piece_at(square)\n            if piece and piece.color == color:\n                if chess.square_distance(king_square, square) <= 1:\n                    safety += 1\n        return safety\n\n    return float(king_safety(chess.WHITE) - king_safety(chess.BLACK))\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the pressure on the opponent's pieces (attacks and potential captures).\"\n    def piece_pressure(color):\n        pressure = 0\n        for square, piece in board.piece_map().items():\n            if piece.color == color:\n                for target in board.legal_moves:\n                    if target.to_square == square:\n                        pressure += 1\n        return pressure\n\n    return float(piece_pressure(chess.WHITE) - piece_pressure(chess.BLACK))\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the number of pieces currently in danger of capture.\"\n    threatened_count = sum(1 for square, piece in board.piece_map().items() if piece.color == board.turn and board.is_attacked_by(not piece.color, square))\n    return float(threatened_count)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in pawn structure by counting isolated pawns for each side.\"\n    def isolated_pawns(color):\n        pawns = [square for square, piece in board.piece_map().items() if piece.color == color and piece.piece_type == chess.PAWN]\n        isolated = 0\n        for pawn in pawns:\n            file = chess.square_file(pawn)\n            if (file > 0 and not board.piece_at(chess.parse_square(chess.square_name(pawn)[0] + str(chess.square_rank(pawn) + 1))) and \n                board.piece_at(chess.parse_square(chess.square_name(pawn)[0] + str(chess.square_rank(pawn) - 1))) is None):\n                isolated += 1\n        return isolated\n    \n    white_isolated = isolated_pawns(chess.WHITE)\n    black_isolated = isolated_pawns(chess.BLACK)\n    return float(white_isolated - black_isolated)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Evaluates the potential for promotion based on the distance of pawns from promotion.\"\n    def promotion_potential(color):\n        return sum(8 - chess.square_rank(square) if color == chess.WHITE else chess.square_rank(square) for square, piece in board.piece_map().items() if piece.color == color and piece.piece_type == chess.PAWN)\n    \n    return float(promotion_potential(chess.WHITE) - promotion_potential(chess.BLACK))\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the tempo by counting the turn of side that leads to more capturing moves.\"\n    def capturing_moves(color):\n        return sum(1 for move in board.legal_moves if board.is_attacked_by(not color, move.to_square))\n    \n    white_captures = capturing_moves(chess.WHITE)\n    black_captures = capturing_moves(chess.BLACK)\n    return float(white_captures - black_captures)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates control of the center (squares d4, d5, e4, e5) by counting controlled squares.\"\n    center_squares = [chess.D4, chess.D5, chess.E4, chess.E5]\n    white_control = sum(1 for square in center_squares if board.is_attacked_by(chess.WHITE, square))\n    black_control = sum(1 for square in center_squares if board.is_attacked_by(chess.BLACK, square))\n    return float(white_control - black_control)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the activity of rooks on open files.\"\n    def rook_activity(color):\n        return sum(1 for square, piece in board.piece_map().items() if piece.color == color and piece.piece_type == chess.ROOK and (not board.piece_at(chess.parse_square(chess.square_name(square)[0] + '1')) or \n                not board.piece_at(chess.parse_square(chess.square_name(square)[0] + '8'))))\n    \n    return float(rook_activity(chess.WHITE) - rook_activity(chess.BLACK))\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Evaluates the presence of pinned pieces on the opponent's side.\"\n    pin_count = sum(1 for square, piece in board.piece_map().items() if piece.color == board.turn and any(board.is_attacked_by(not piece.color, square) for attacker in board.attackers(not piece.color, square)))\n    return float(pin_count)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of squares under attack by each side.\"\n    def attack_control(color):\n        return sum(1 for square in board.piece_map() if board.is_attacked_by(color, square))\n    \n    white_attack = attack_control(chess.WHITE)\n    black_attack = attack_control(chess.BLACK)\n    return float(white_attack - black_attack)\n"
  ]
}