{
  "used_features": [
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of pixels in top half versus bottom half of image\"\n    h, w = image.shape\n    if h == 0:\n        return 0.0\n    top_half = np.sum(image[:h//2, :])\n    bottom_half = np.sum(image[h//2:, :])\n    if bottom_half == 0:\n        return float('inf') if top_half > 0 else 0.0\n    return float(top_half / bottom_half)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Density of non-zero pixels in the bottom third of the image\"\n    h, w = image.shape\n    bottom_third = image[2*h//3:, :]\n    total_pixels = bottom_third.size\n    if total_pixels == 0:\n        return 0.0\n    return float(np.count_nonzero(bottom_third) / total_pixels)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Number of horizontal line segments in the middle region\"\n    h, w = image.shape\n    middle_region = image[h//3:2*h//3, :]\n    threshold = np.mean(middle_region) if np.mean(middle_region) > 0 else 0.1\n    binary = (middle_region > threshold).astype(int)\n    horizontal_lines = 0\n    for row in binary:\n        in_segment = False\n        for pixel in row:\n            if pixel > 0 and not in_segment:\n                horizontal_lines += 1\n                in_segment = True\n            elif pixel == 0:\n                in_segment = False\n    return float(horizontal_lines)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of pixel intensity in the upper third versus middle third of image\"\n    h, w = image.shape\n    upper_third = image[:h//3, :]\n    middle_third = image[h//3:2*h//3, :]\n    upper_mean = np.mean(upper_third)\n    middle_mean = np.mean(middle_third)\n    if middle_mean == 0:\n        return 0.0\n    return float(upper_mean / middle_mean)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of pixel intensity in the upper third versus middle third of image\"\n    h, w = image.shape\n    upper_third = image[:h//3, :]\n    middle_third = image[h//3:2*h//3, :]\n    upper_mean = np.mean(upper_third)\n    middle_mean = np.mean(middle_third)\n    if middle_mean == 0:\n        return 0.0\n    return float(upper_mean / middle_mean)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Maximum width of continuous horizontal strokes in the image\"\n    max_width = 0\n    for row in image:\n        current_width = 0\n        local_max = 0\n        for pixel in row:\n            if pixel > 0:\n                current_width += 1\n                local_max = max(local_max, current_width)\n            else:\n                current_width = 0\n        max_width = max(max_width, local_max)\n    return float(max_width)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Density of non-zero pixels in the bottom third of the image\"\n    h, w = image.shape\n    bottom_third = image[2*h//3:, :]\n    total_pixels = bottom_third.size\n    if total_pixels == 0:\n        return 0.0\n    return float(np.count_nonzero(bottom_third) / total_pixels)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Number of horizontal transitions from zero to non-zero pixels\"\n    transitions = 0\n    h, w = image.shape\n    for row in range(h):\n        for col in range(1, w):\n            if image[row, col-1] == 0 and image[row, col] > 0:\n                transitions += 1\n    return float(transitions)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Intensity ratio between upper-middle and lower-middle regions\"\n    h, w = image.shape\n    upper_mid = image[h//4:h//2, w//4:3*w//4]\n    lower_mid = image[h//2:3*h//4, w//4:3*w//4]\n    upper_sum = np.sum(upper_mid)\n    lower_sum = np.sum(lower_mid)\n    if lower_sum == 0:\n        return 1.0 if upper_sum > 0 else 0.0\n    return float(upper_sum / (upper_sum + lower_sum))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Standard deviation of pixel intensities in the top quarter\"\n    h, w = image.shape\n    top_quarter = image[:h//4, :]\n    if top_quarter.size == 0:\n        return 0.0\n    return float(np.std(top_quarter))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Intensity ratio between upper-middle and lower-middle regions\"\n    h, w = image.shape\n    upper_mid = image[h//4:h//2, w//4:3*w//4]\n    lower_mid = image[h//2:3*h//4, w//4:3*w//4]\n    upper_sum = np.sum(upper_mid)\n    lower_sum = np.sum(lower_mid)\n    if lower_sum == 0:\n        return 1.0 if upper_sum > 0 else 0.0\n    return float(upper_sum / (upper_sum + lower_sum))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Number of vertical transitions from background to foreground in center column\"\n    h, w = image.shape\n    center_col = image[:, w//2]\n    threshold = np.mean(image) * 0.5\n    binary = (center_col > threshold).astype(int)\n    transitions = np.sum(np.diff(binary) > 0)\n    return float(transitions)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Standard deviation of pixel intensities in the top quarter\"\n    h, w = image.shape\n    top_quarter = image[:h//4, :]\n    if top_quarter.size == 0:\n        return 0.0\n    return float(np.std(top_quarter))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Presence of enclosed regions using simple flood fill detection\"\n    h, w = image.shape\n    binary = (image > 0).astype(int)\n    visited = np.zeros_like(binary)\n    enclosed_regions = 0\n    \n    def flood_fill(r, c):\n        if r < 0 or r >= h or c < 0 or c >= w or visited[r, c] or binary[r, c]:\n            return False\n        visited[r, c] = 1\n        touches_border = (r == 0 or r == h-1 or c == 0 or c == w-1)\n        for dr, dc in [(0,1), (0,-1), (1,0), (-1,0)]:\n            if flood_fill(r + dr, c + dc):\n                touches_border = True\n        return touches_border\n    \n    for r in range(h):\n        for c in range(w):\n            if not visited[r, c] and binary[r, c] == 0:\n                if not flood_fill(r, c):\n                    enclosed_regions += 1\n    \n    return float(enclosed_regions)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Number of horizontal line segments in the middle region\"\n    h, w = image.shape\n    middle_region = image[h//3:2*h//3, :]\n    threshold = np.mean(middle_region) if np.mean(middle_region) > 0 else 0.1\n    binary = (middle_region > threshold).astype(int)\n    horizontal_lines = 0\n    for row in binary:\n        in_segment = False\n        for pixel in row:\n            if pixel > 0 and not in_segment:\n                horizontal_lines += 1\n                in_segment = True\n            elif pixel == 0:\n                in_segment = False\n    return float(horizontal_lines)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Maximum pixel intensity in the bottom quarter of the image\"\n    h, w = image.shape\n    bottom_quarter = image[3*h//4:, :]\n    if bottom_quarter.size == 0:\n        return 0.0\n    return float(np.max(bottom_quarter))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Count of high intensity pixels (above 75th percentile) in bottom quarter\"\n    h, w = image.shape\n    if h == 0:\n        return 0.0\n    bottom_quarter = image[3*h//4:, :]\n    if bottom_quarter.size == 0:\n        return 0.0\n    threshold = np.percentile(image, 75)\n    high_intensity_count = np.sum(bottom_quarter > threshold)\n    return float(high_intensity_count)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Number of connected components in the right half of the image\"\n    h, w = image.shape\n    right_half = image[:, w//2:]\n    binary = (right_half > np.mean(right_half)).astype(int)\n    components = 0\n    visited = np.zeros_like(binary)\n    \n    def flood_fill(y, x):\n        if y < 0 or y >= h or x < 0 or x >= w//2 or visited[y, x] or binary[y, x] == 0:\n            return\n        visited[y, x] = 1\n        for dy, dx in [(0,1), (1,0), (0,-1), (-1,0)]:\n            flood_fill(y + dy, x + dx)\n    \n    for i in range(h):\n        for j in range(w//2):\n            if binary[i, j] and not visited[i, j]:\n                flood_fill(i, j)\n                components += 1\n    return float(components)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Maximum width of continuous horizontal strokes in the image\"\n    max_width = 0\n    for row in image:\n        current_width = 0\n        local_max = 0\n        for pixel in row:\n            if pixel > 0:\n                current_width += 1\n                local_max = max(local_max, current_width)\n            else:\n                current_width = 0\n        max_width = max(max_width, local_max)\n    return float(max_width)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of vertical edge strength to horizontal edge strength\"\n    if image.size == 0:\n        return 0.0\n    grad_y, grad_x = np.gradient(image)\n    vertical_strength = np.sum(np.abs(grad_x))\n    horizontal_strength = np.sum(np.abs(grad_y))\n    if horizontal_strength == 0:\n        return 1.0 if vertical_strength > 0 else 0.0\n    return float(vertical_strength / horizontal_strength)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Number of connected components in the right half of the image\"\n    h, w = image.shape\n    right_half = image[:, w//2:]\n    binary = (right_half > np.mean(right_half)).astype(int)\n    components = 0\n    visited = np.zeros_like(binary)\n    \n    def flood_fill(y, x):\n        if y < 0 or y >= h or x < 0 or x >= w//2 or visited[y, x] or binary[y, x] == 0:\n            return\n        visited[y, x] = 1\n        for dy, dx in [(0,1), (1,0), (0,-1), (-1,0)]:\n            flood_fill(y + dy, x + dx)\n    \n    for i in range(h):\n        for j in range(w//2):\n            if binary[i, j] and not visited[i, j]:\n                flood_fill(i, j)\n                components += 1\n    return float(components)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Number of connected components in the right half of the image\"\n    h, w = image.shape\n    right_half = image[:, w//2:]\n    binary = (right_half > np.mean(right_half)).astype(int)\n    components = 0\n    visited = np.zeros_like(binary)\n    \n    def flood_fill(y, x):\n        if y < 0 or y >= h or x < 0 or x >= w//2 or visited[y, x] or binary[y, x] == 0:\n            return\n        visited[y, x] = 1\n        for dy, dx in [(0,1), (1,0), (0,-1), (-1,0)]:\n            flood_fill(y + dy, x + dx)\n    \n    for i in range(h):\n        for j in range(w//2):\n            if binary[i, j] and not visited[i, j]:\n                flood_fill(i, j)\n                components += 1\n    return float(components)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Maximum consecutive horizontal pixels above threshold in center row\"\n    h, w = image.shape\n    if h == 0:\n        return 0.0\n    center_row = image[h//2, :]\n    threshold = np.mean(image) if np.std(image) > 0 else 0.5\n    binary_row = center_row > threshold\n    max_consecutive = 0\n    current_consecutive = 0\n    for pixel in binary_row:\n        if pixel:\n            current_consecutive += 1\n            max_consecutive = max(max_consecutive, current_consecutive)\n        else:\n            current_consecutive = 0\n    return float(max_consecutive)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Presence of enclosed circular or oval regions\"\n    h, w = image.shape\n    threshold = np.mean(image) if np.mean(image) > 0 else 0.1\n    binary = (image > threshold).astype(int)\n    enclosed_regions = 0\n    center_h, center_w = h//2, w//2\n    for i in range(h//4, 3*h//4):\n        for j in range(w//4, 3*w//4):\n            if binary[i, j] == 0:\n                neighbors = binary[max(0,i-1):min(h,i+2), max(0,j-1):min(w,j+2)]\n                if np.sum(neighbors) >= 6:\n                    enclosed_regions += 1\n    return float(min(enclosed_regions / 10.0, 1.0))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Number of vertical line segments in the center column\"\n    h, w = image.shape\n    if w == 0:\n        return 0.0\n    center_col = image[:, w//2]\n    threshold = np.mean(center_col) + np.std(center_col) if np.std(center_col) > 0 else np.mean(center_col)\n    binary_col = (center_col > threshold).astype(int)\n    segments = 0\n    in_segment = False\n    for pixel in binary_col:\n        if pixel == 1 and not in_segment:\n            segments += 1\n            in_segment = True\n        elif pixel == 0:\n            in_segment = False\n    return float(segments)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Number of connected components in the right half of the image\"\n    h, w = image.shape\n    right_half = image[:, w//2:]\n    binary = (right_half > np.mean(right_half)).astype(int)\n    components = 0\n    visited = np.zeros_like(binary)\n    \n    def flood_fill(y, x):\n        if y < 0 or y >= h or x < 0 or x >= w//2 or visited[y, x] or binary[y, x] == 0:\n            return\n        visited[y, x] = 1\n        for dy, dx in [(0,1), (1,0), (0,-1), (-1,0)]:\n            flood_fill(y + dy, x + dx)\n    \n    for i in range(h):\n        for j in range(w//2):\n            if binary[i, j] and not visited[i, j]:\n                flood_fill(i, j)\n                components += 1\n    return float(components)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Number of connected components in the right half of the image\"\n    h, w = image.shape\n    right_half = image[:, w//2:]\n    binary = (right_half > np.mean(right_half)).astype(int)\n    components = 0\n    visited = np.zeros_like(binary)\n    \n    def flood_fill(y, x):\n        if y < 0 or y >= h or x < 0 or x >= w//2 or visited[y, x] or binary[y, x] == 0:\n            return\n        visited[y, x] = 1\n        for dy, dx in [(0,1), (1,0), (0,-1), (-1,0)]:\n            flood_fill(y + dy, x + dx)\n    \n    for i in range(h):\n        for j in range(w//2):\n            if binary[i, j] and not visited[i, j]:\n                flood_fill(i, j)\n                components += 1\n    return float(components)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Intensity ratio between upper-middle and lower-middle regions\"\n    h, w = image.shape\n    upper_mid = image[h//4:h//2, w//4:3*w//4]\n    lower_mid = image[h//2:3*h//4, w//4:3*w//4]\n    upper_sum = np.sum(upper_mid)\n    lower_sum = np.sum(lower_mid)\n    if lower_sum == 0:\n        return 1.0 if upper_sum > 0 else 0.0\n    return float(upper_sum / (upper_sum + lower_sum))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of pixel intensity in bottom third to middle third\"\n    h, w = image.shape\n    if h < 3:\n        return 0.0\n    middle_third = image[h//3:2*h//3, :]\n    bottom_third = image[2*h//3:, :]\n    middle_sum = np.sum(middle_third)\n    bottom_sum = np.sum(bottom_third)\n    if middle_sum == 0:\n        return 0.0\n    return float(bottom_sum / middle_sum)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Presence of enclosed regions using simple flood fill detection\"\n    h, w = image.shape\n    binary = (image > 0).astype(int)\n    visited = np.zeros_like(binary)\n    enclosed_regions = 0\n    \n    def flood_fill(r, c):\n        if r < 0 or r >= h or c < 0 or c >= w or visited[r, c] or binary[r, c]:\n            return False\n        visited[r, c] = 1\n        touches_border = (r == 0 or r == h-1 or c == 0 or c == w-1)\n        for dr, dc in [(0,1), (0,-1), (1,0), (-1,0)]:\n            if flood_fill(r + dr, c + dc):\n                touches_border = True\n        return touches_border\n    \n    for r in range(h):\n        for c in range(w):\n            if not visited[r, c] and binary[r, c] == 0:\n                if not flood_fill(r, c):\n                    enclosed_regions += 1\n    \n    return float(enclosed_regions)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Number of enclosed circular regions or loops in the image\"\n    h, w = image.shape\n    if h == 0 or w == 0:\n        return 0.0\n    \n    # Create binary image\n    binary = (image > np.mean(image)).astype(int)\n    \n    # Count enclosed regions by looking for transitions\n    loops = 0\n    center_h, center_w = h // 2, w // 2\n    \n    # Check multiple radial scans from center\n    for angle in np.linspace(0, 2*np.pi, 16):\n        transitions = 0\n        prev_val = 0\n        for r in range(1, min(center_h, center_w)):\n            y = int(center_h + r * np.sin(angle))\n            x = int(center_w + r * np.cos(angle))\n            if 0 <= y < h and 0 <= x < w:\n                if binary[y, x] != prev_val:\n                    transitions += 1\n                prev_val = binary[y, x]\n        if transitions >= 4:  # Likely indicates a loop\n            loops += 1\n    \n    return float(loops)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Width of the widest row with non-zero pixels\"\n    h, w = image.shape\n    max_width = 0\n    for row in range(h):\n        non_zero_cols = np.where(image[row, :] > 0)[0]\n        if len(non_zero_cols) > 0:\n            width = non_zero_cols[-1] - non_zero_cols[0] + 1\n            max_width = max(max_width, width)\n    return float(max_width)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of maximum pixel value in top quarter to maximum in bottom quarter\"\n    h, w = image.shape\n    top_quarter = image[:h//4, :]\n    bottom_quarter = image[3*h//4:, :]\n    top_max = np.max(top_quarter) if top_quarter.size > 0 else 0\n    bottom_max = np.max(bottom_quarter) if bottom_quarter.size > 0 else 0\n    if bottom_max == 0:\n        return 1.0 if top_max > 0 else 0.0\n    return float(top_max / bottom_max)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of pixel intensity in bottom third to middle third\"\n    h, w = image.shape\n    if h < 3:\n        return 0.0\n    middle_third = image[h//3:2*h//3, :]\n    bottom_third = image[2*h//3:, :]\n    middle_sum = np.sum(middle_third)\n    bottom_sum = np.sum(bottom_third)\n    if middle_sum == 0:\n        return 0.0\n    return float(bottom_sum / middle_sum)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of maximum pixel value in top quarter to maximum in bottom quarter\"\n    h, w = image.shape\n    top_quarter = image[:h//4, :]\n    bottom_quarter = image[3*h//4:, :]\n    top_max = np.max(top_quarter) if top_quarter.size > 0 else 0\n    bottom_max = np.max(bottom_quarter) if bottom_quarter.size > 0 else 0\n    if bottom_max == 0:\n        return 1.0 if top_max > 0 else 0.0\n    return float(top_max / bottom_max)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of pixel density in upper third versus lower third of image\"\n    h, w = image.shape\n    upper_third = image[:h//3, :]\n    lower_third = image[2*h//3:, :]\n    upper_density = np.mean(upper_third) if upper_third.size > 0 else 0\n    lower_density = np.mean(lower_third) if lower_third.size > 0 else 0\n    return float(upper_density / (lower_density + 1e-8))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of vertical edge strength to horizontal edge strength\"\n    if image.size == 0:\n        return 0.0\n    grad_y, grad_x = np.gradient(image)\n    vertical_strength = np.sum(np.abs(grad_x))\n    horizontal_strength = np.sum(np.abs(grad_y))\n    if horizontal_strength == 0:\n        return 1.0 if vertical_strength > 0 else 0.0\n    return float(vertical_strength / horizontal_strength)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Number of vertical transitions from background to foreground in center column\"\n    h, w = image.shape\n    center_col = image[:, w//2]\n    threshold = np.mean(image) * 0.5\n    binary = (center_col > threshold).astype(int)\n    transitions = np.sum(np.diff(binary) > 0)\n    return float(transitions)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Number of enclosed regions detected by counting transitions\"\n    h, w = image.shape\n    threshold = image.max() * 0.3\n    binary = (image > threshold).astype(int)\n    \n    enclosed_count = 0\n    middle_rows = binary[h//3:2*h//3, :]\n    \n    for row in middle_rows:\n        transitions = 0\n        for i in range(1, len(row)):\n            if row[i] != row[i-1]:\n                transitions += 1\n        if transitions >= 4:\n            enclosed_count += 1\n    \n    return float(enclosed_count)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Horizontal gradient strength in the middle third of image\"\n    h, w = image.shape\n    middle_third = image[h//3:2*h//3, :]\n    grad_y, grad_x = np.gradient(middle_third)\n    return float(np.mean(np.abs(grad_x)))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Presence of enclosed regions using simple flood fill detection\"\n    h, w = image.shape\n    binary = (image > 0).astype(int)\n    visited = np.zeros_like(binary)\n    enclosed_regions = 0\n    \n    def flood_fill(r, c):\n        if r < 0 or r >= h or c < 0 or c >= w or visited[r, c] or binary[r, c]:\n            return False\n        visited[r, c] = 1\n        touches_border = (r == 0 or r == h-1 or c == 0 or c == w-1)\n        for dr, dc in [(0,1), (0,-1), (1,0), (-1,0)]:\n            if flood_fill(r + dr, c + dc):\n                touches_border = True\n        return touches_border\n    \n    for r in range(h):\n        for c in range(w):\n            if not visited[r, c] and binary[r, c] == 0:\n                if not flood_fill(r, c):\n                    enclosed_regions += 1\n    \n    return float(enclosed_regions)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Maximum vertical gap between non-zero pixels in center column\"\n    h, w = image.shape\n    if w == 0:\n        return 0.0\n    center_col = image[:, w//2]\n    nonzero_rows = np.where(center_col > np.mean(center_col))[0]\n    if len(nonzero_rows) < 2:\n        return float(h)\n    max_gap = 0\n    for i in range(1, len(nonzero_rows)):\n        gap = nonzero_rows[i] - nonzero_rows[i-1] - 1\n        max_gap = max(max_gap, gap)\n    return float(max_gap)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Count of high intensity pixels (above 75th percentile) in bottom quarter\"\n    h, w = image.shape\n    if h == 0:\n        return 0.0\n    bottom_quarter = image[3*h//4:, :]\n    if bottom_quarter.size == 0:\n        return 0.0\n    threshold = np.percentile(image, 75)\n    high_intensity_count = np.sum(bottom_quarter > threshold)\n    return float(high_intensity_count)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Intensity ratio between upper-middle and lower-middle regions\"\n    h, w = image.shape\n    upper_mid = image[h//4:h//2, w//4:3*w//4]\n    lower_mid = image[h//2:3*h//4, w//4:3*w//4]\n    upper_sum = np.sum(upper_mid)\n    lower_sum = np.sum(lower_mid)\n    if lower_sum == 0:\n        return 1.0 if upper_sum > 0 else 0.0\n    return float(upper_sum / (upper_sum + lower_sum))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of pixel intensity variance in top third versus middle third\"\n    h, w = image.shape\n    top_third = image[:h//3, :]\n    middle_third = image[h//3:2*h//3, :]\n    top_var = np.var(top_third)\n    middle_var = np.var(middle_third)\n    if middle_var == 0:\n        return float(top_var)\n    return float(top_var / middle_var)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Number of enclosed regions detected by counting transitions\"\n    h, w = image.shape\n    threshold = image.max() * 0.3\n    binary = (image > threshold).astype(int)\n    \n    enclosed_count = 0\n    middle_rows = binary[h//3:2*h//3, :]\n    \n    for row in middle_rows:\n        transitions = 0\n        for i in range(1, len(row)):\n            if row[i] != row[i-1]:\n                transitions += 1\n        if transitions >= 4:\n            enclosed_count += 1\n    \n    return float(enclosed_count)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Number of connected components in the right half of the image\"\n    h, w = image.shape\n    right_half = image[:, w//2:]\n    binary = (right_half > np.mean(right_half)).astype(int)\n    components = 0\n    visited = np.zeros_like(binary)\n    \n    def flood_fill(y, x):\n        if y < 0 or y >= h or x < 0 or x >= w//2 or visited[y, x] or binary[y, x] == 0:\n            return\n        visited[y, x] = 1\n        for dy, dx in [(0,1), (1,0), (0,-1), (-1,0)]:\n            flood_fill(y + dy, x + dx)\n    \n    for i in range(h):\n        for j in range(w//2):\n            if binary[i, j] and not visited[i, j]:\n                flood_fill(i, j)\n                components += 1\n    return float(components)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Intensity difference between center pixel and image mean\"\n    h, w = image.shape\n    if h == 0 or w == 0:\n        return 0.0\n    center_pixel = image[h//2, w//2]\n    image_mean = np.mean(image)\n    return float(abs(center_pixel - image_mean))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Average gradient magnitude in the horizontal direction\"\n    if image.shape[1] < 2:\n        return 0.0\n    grad_y, grad_x = np.gradient(image)\n    return float(np.mean(np.abs(grad_x)))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of filled pixels in top-left quadrant to total quadrant size\"\n    h, w = image.shape\n    if h < 2 or w < 2:\n        return float(np.mean(image > 0))\n    top_left = image[:h//2, :w//2]\n    total_pixels = top_left.size\n    filled_pixels = np.count_nonzero(top_left)\n    return float(filled_pixels / total_pixels)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Count of horizontal line segments in the middle third of the image\"\n    h, w = image.shape\n    middle_third = image[h//3:2*h//3, :]\n    threshold = np.mean(middle_third) + np.std(middle_third)\n    line_count = 0\n    for row in middle_third:\n        segments = 0\n        in_segment = False\n        for pixel in row:\n            if pixel > threshold and not in_segment:\n                segments += 1\n                in_segment = True\n            elif pixel <= threshold:\n                in_segment = False\n        line_count += segments\n    return float(line_count)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Number of enclosed circular regions or loops in the image\"\n    h, w = image.shape\n    if h == 0 or w == 0:\n        return 0.0\n    \n    # Create binary image\n    binary = (image > np.mean(image)).astype(int)\n    \n    # Count enclosed regions by looking for transitions\n    loops = 0\n    center_h, center_w = h // 2, w // 2\n    \n    # Check multiple radial scans from center\n    for angle in np.linspace(0, 2*np.pi, 16):\n        transitions = 0\n        prev_val = 0\n        for r in range(1, min(center_h, center_w)):\n            y = int(center_h + r * np.sin(angle))\n            x = int(center_w + r * np.cos(angle))\n            if 0 <= y < h and 0 <= x < w:\n                if binary[y, x] != prev_val:\n                    transitions += 1\n                prev_val = binary[y, x]\n        if transitions >= 4:  # Likely indicates a loop\n            loops += 1\n    \n    return float(loops)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Number of connected vertical segments in the rightmost quarter\"\n    h, w = image.shape\n    if w < 4:\n        return 0.0\n    right_quarter = image[:, 3*w//4:]\n    segments = 0\n    for col in range(right_quarter.shape[1]):\n        in_segment = False\n        for row in range(h):\n            if right_quarter[row, col] > 0:\n                if not in_segment:\n                    segments += 1\n                    in_segment = True\n            else:\n                in_segment = False\n    return float(segments)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Number of enclosed regions or loops in the image\"\n    from scipy import ndimage\n    if image.size == 0:\n        return 0.0\n    binary = image > np.mean(image)\n    filled = ndimage.binary_fill_holes(binary)\n    loops = np.sum(filled) - np.sum(binary)\n    return float(loops)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of pixel intensity in bottom third to middle third\"\n    h, w = image.shape\n    if h < 3:\n        return 0.0\n    middle_third = image[h//3:2*h//3, :]\n    bottom_third = image[2*h//3:, :]\n    middle_sum = np.sum(middle_third)\n    bottom_sum = np.sum(bottom_third)\n    if middle_sum == 0:\n        return 0.0\n    return float(bottom_sum / middle_sum)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of pixel intensity in bottom third to middle third\"\n    h, w = image.shape\n    if h < 3:\n        return 0.0\n    middle_third = image[h//3:2*h//3, :]\n    bottom_third = image[2*h//3:, :]\n    middle_sum = np.sum(middle_third)\n    bottom_sum = np.sum(bottom_third)\n    if middle_sum == 0:\n        return 0.0\n    return float(bottom_sum / middle_sum)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Number of enclosed circular regions or loops in the image\"\n    h, w = image.shape\n    if h == 0 or w == 0:\n        return 0.0\n    \n    # Create binary image\n    binary = (image > np.mean(image)).astype(int)\n    \n    # Count enclosed regions by looking for transitions\n    loops = 0\n    center_h, center_w = h // 2, w // 2\n    \n    # Check multiple radial scans from center\n    for angle in np.linspace(0, 2*np.pi, 16):\n        transitions = 0\n        prev_val = 0\n        for r in range(1, min(center_h, center_w)):\n            y = int(center_h + r * np.sin(angle))\n            x = int(center_w + r * np.cos(angle))\n            if 0 <= y < h and 0 <= x < w:\n                if binary[y, x] != prev_val:\n                    transitions += 1\n                prev_val = binary[y, x]\n        if transitions >= 4:  # Likely indicates a loop\n            loops += 1\n    \n    return float(loops)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Vertical extent of the topmost significant pixel cluster\"\n    h, w = image.shape\n    top_quarter = image[:h//4, :]\n    if top_quarter.size == 0:\n        return 0.0\n    nonzero_rows = np.where(np.sum(top_quarter, axis=1) > 0)[0]\n    if len(nonzero_rows) == 0:\n        return 0.0\n    vertical_extent = len(nonzero_rows)\n    return float(vertical_extent / max(h//4, 1))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Vertical extent of the topmost significant pixel cluster\"\n    h, w = image.shape\n    top_quarter = image[:h//4, :]\n    if top_quarter.size == 0:\n        return 0.0\n    nonzero_rows = np.where(np.sum(top_quarter, axis=1) > 0)[0]\n    if len(nonzero_rows) == 0:\n        return 0.0\n    vertical_extent = len(nonzero_rows)\n    return float(vertical_extent / max(h//4, 1))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Number of enclosed regions or loops in the image\"\n    from scipy import ndimage\n    if image.size == 0:\n        return 0.0\n    binary = image > np.mean(image)\n    filled = ndimage.binary_fill_holes(binary)\n    loops = np.sum(filled) - np.sum(binary)\n    return float(loops)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Fraction of image width covered by non-zero pixels in the middle row\"\n    h, w = image.shape\n    if h == 0:\n        return 0.0\n    middle_row = image[h//2, :]\n    non_zero_positions = np.where(middle_row > 0)[0]\n    if len(non_zero_positions) == 0:\n        return 0.0\n    span = non_zero_positions[-1] - non_zero_positions[0] + 1\n    return float(span / w)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Density of high-intensity pixels in the outer border region\"\n    h, w = image.shape\n    border_width = min(h, w) // 8\n    if border_width == 0:\n        border_width = 1\n    border_mask = np.zeros((h, w), dtype=bool)\n    border_mask[:border_width, :] = True\n    border_mask[-border_width:, :] = True\n    border_mask[:, :border_width] = True\n    border_mask[:, -border_width:] = True\n    border_pixels = image[border_mask]\n    threshold = np.mean(image) + np.std(image)\n    return float(np.sum(border_pixels > threshold) / len(border_pixels) if len(border_pixels) > 0 else 0.0)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Vertical extent of the topmost significant pixel cluster\"\n    h, w = image.shape\n    top_quarter = image[:h//4, :]\n    if top_quarter.size == 0:\n        return 0.0\n    nonzero_rows = np.where(np.sum(top_quarter, axis=1) > 0)[0]\n    if len(nonzero_rows) == 0:\n        return 0.0\n    vertical_extent = len(nonzero_rows)\n    return float(vertical_extent / max(h//4, 1))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of vertical edge strength to horizontal edge strength\"\n    if image.size == 0:\n        return 0.0\n    grad_y, grad_x = np.gradient(image)\n    vertical_strength = np.sum(np.abs(grad_x))\n    horizontal_strength = np.sum(np.abs(grad_y))\n    if horizontal_strength == 0:\n        return 1.0 if vertical_strength > 0 else 0.0\n    return float(vertical_strength / horizontal_strength)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Horizontal gradient strength in the middle third of image\"\n    h, w = image.shape\n    middle_third = image[h//3:2*h//3, :]\n    grad_y, grad_x = np.gradient(middle_third)\n    return float(np.mean(np.abs(grad_x)))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Presence of curved bottom region characteristic of digit 9\"\n    h, w = image.shape\n    bottom_third = image[2*h//3:, :]\n    if bottom_third.size == 0:\n        return 0.0\n    curve_score = 0.0\n    for row_idx in range(bottom_third.shape[0]):\n        row = bottom_third[row_idx, :]\n        nonzero_cols = np.where(row > 0)[0]\n        if len(nonzero_cols) > 2:\n            left_most, right_most = nonzero_cols[0], nonzero_cols[-1]\n            width_span = right_most - left_most\n            curve_score += width_span / max(w, 1)\n    return float(curve_score / max(bottom_third.shape[0], 1))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of pixel intensity in the upper third versus middle third of image\"\n    h, w = image.shape\n    upper_third = image[:h//3, :]\n    middle_third = image[h//3:2*h//3, :]\n    upper_mean = np.mean(upper_third)\n    middle_mean = np.mean(middle_third)\n    if middle_mean == 0:\n        return 0.0\n    return float(upper_mean / middle_mean)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of non-zero pixels in the bottom quarter versus top quarter\"\n    h, w = image.shape\n    top_quarter = image[:h//4, :]\n    bottom_quarter = image[3*h//4:, :]\n    top_count = np.count_nonzero(top_quarter)\n    bottom_count = np.count_nonzero(bottom_quarter)\n    if top_count == 0:\n        return float(bottom_count)\n    return float(bottom_count / top_count)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Number of enclosed regions or loops in the image\"\n    from scipy import ndimage\n    if image.size == 0:\n        return 0.0\n    binary = image > np.mean(image)\n    filled = ndimage.binary_fill_holes(binary)\n    loops = np.sum(filled) - np.sum(binary)\n    return float(loops)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Vertical stroke continuity in the upper two-thirds of the image\"\n    h, w = image.shape\n    upper_region = image[:2*h//3, :]\n    if upper_region.size == 0:\n        return 0.0\n    vertical_continuity = 0.0\n    for col in range(w):\n        column_pixels = upper_region[:, col]\n        nonzero_positions = np.where(column_pixels > 0)[0]\n        if len(nonzero_positions) > 1:\n            gaps = np.diff(nonzero_positions)\n            continuity_score = np.sum(gaps == 1) / max(len(gaps), 1)\n            vertical_continuity += continuity_score\n    return float(vertical_continuity / max(w, 1))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of pixel intensity in bottom third to middle third\"\n    h, w = image.shape\n    if h < 3:\n        return 0.0\n    middle_third = image[h//3:2*h//3, :]\n    bottom_third = image[2*h//3:, :]\n    middle_sum = np.sum(middle_third)\n    bottom_sum = np.sum(bottom_third)\n    if middle_sum == 0:\n        return 0.0\n    return float(bottom_sum / middle_sum)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Count of vertical runs of consecutive non-zero pixels in the left half\"\n    h, w = image.shape\n    left_half = image[:, :w//2]\n    vertical_runs = 0\n    for col in range(left_half.shape[1]):\n        in_run = False\n        for row in range(left_half.shape[0]):\n            if left_half[row, col] > 0:\n                if not in_run:\n                    vertical_runs += 1\n                    in_run = True\n            else:\n                in_run = False\n    return float(vertical_runs)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of non-zero pixels in the bottom quarter versus top quarter\"\n    h, w = image.shape\n    top_quarter = image[:h//4, :]\n    bottom_quarter = image[3*h//4:, :]\n    top_count = np.count_nonzero(top_quarter)\n    bottom_count = np.count_nonzero(bottom_quarter)\n    if top_count == 0:\n        return float(bottom_count)\n    return float(bottom_count / top_count)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Width of the widest row with non-zero pixels\"\n    h, w = image.shape\n    max_width = 0\n    for row in range(h):\n        non_zero_cols = np.where(image[row, :] > 0)[0]\n        if len(non_zero_cols) > 0:\n            width = non_zero_cols[-1] - non_zero_cols[0] + 1\n            max_width = max(max_width, width)\n    return float(max_width)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Vertical extent of the topmost significant pixel cluster\"\n    h, w = image.shape\n    top_quarter = image[:h//4, :]\n    if top_quarter.size == 0:\n        return 0.0\n    nonzero_rows = np.where(np.sum(top_quarter, axis=1) > 0)[0]\n    if len(nonzero_rows) == 0:\n        return 0.0\n    vertical_extent = len(nonzero_rows)\n    return float(vertical_extent / max(h//4, 1))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Presence of closed loops by counting enclosed regions\"\n    if image.size == 0:\n        return 0.0\n    binary = image > np.mean(image)\n    h, w = binary.shape\n    enclosed_count = 0\n    for i in range(1, h-1):\n        for j in range(1, w-1):\n            if not binary[i, j]:\n                surrounding = binary[i-1:i+2, j-1:j+2]\n                if np.sum(surrounding) >= 6:\n                    enclosed_count += 1\n    return float(enclosed_count / max(1, h * w / 100))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Presence of enclosed regions using simple flood fill detection\"\n    h, w = image.shape\n    binary = (image > 0).astype(int)\n    visited = np.zeros_like(binary)\n    enclosed_regions = 0\n    \n    def flood_fill(r, c):\n        if r < 0 or r >= h or c < 0 or c >= w or visited[r, c] or binary[r, c]:\n            return False\n        visited[r, c] = 1\n        touches_border = (r == 0 or r == h-1 or c == 0 or c == w-1)\n        for dr, dc in [(0,1), (0,-1), (1,0), (-1,0)]:\n            if flood_fill(r + dr, c + dc):\n                touches_border = True\n        return touches_border\n    \n    for r in range(h):\n        for c in range(w):\n            if not visited[r, c] and binary[r, c] == 0:\n                if not flood_fill(r, c):\n                    enclosed_regions += 1\n    \n    return float(enclosed_regions)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of non-zero pixels in the bottom quarter versus top quarter\"\n    h, w = image.shape\n    top_quarter = image[:h//4, :]\n    bottom_quarter = image[3*h//4:, :]\n    top_count = np.count_nonzero(top_quarter)\n    bottom_count = np.count_nonzero(bottom_quarter)\n    if top_count == 0:\n        return float(bottom_count)\n    return float(bottom_count / top_count)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of non-zero pixels in the bottom quarter versus top quarter\"\n    h, w = image.shape\n    top_quarter = image[:h//4, :]\n    bottom_quarter = image[3*h//4:, :]\n    top_count = np.count_nonzero(top_quarter)\n    bottom_count = np.count_nonzero(bottom_quarter)\n    if top_count == 0:\n        return float(bottom_count)\n    return float(bottom_count / top_count)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of non-zero pixels in the bottom quarter versus top quarter\"\n    h, w = image.shape\n    top_quarter = image[:h//4, :]\n    bottom_quarter = image[3*h//4:, :]\n    top_count = np.count_nonzero(top_quarter)\n    bottom_count = np.count_nonzero(bottom_quarter)\n    if top_count == 0:\n        return float(bottom_count)\n    return float(bottom_count / top_count)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Average distance of non-zero pixels from the vertical center line\"\n    h, w = image.shape\n    center_col = w // 2\n    distances = []\n    for row in range(h):\n        for col in range(w):\n            if image[row, col] > 0:\n                distances.append(abs(col - center_col))\n    return float(np.mean(distances) if distances else 0)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Count of horizontal line segments in the middle third of the image\"\n    h, w = image.shape\n    middle_third = image[h//3:2*h//3, :]\n    threshold = np.mean(middle_third) + np.std(middle_third)\n    line_count = 0\n    for row in middle_third:\n        segments = 0\n        in_segment = False\n        for pixel in row:\n            if pixel > threshold and not in_segment:\n                segments += 1\n                in_segment = True\n            elif pixel <= threshold:\n                in_segment = False\n        line_count += segments\n    return float(line_count)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Vertical extent of the topmost significant pixel cluster\"\n    h, w = image.shape\n    top_quarter = image[:h//4, :]\n    if top_quarter.size == 0:\n        return 0.0\n    nonzero_rows = np.where(np.sum(top_quarter, axis=1) > 0)[0]\n    if len(nonzero_rows) == 0:\n        return 0.0\n    vertical_extent = len(nonzero_rows)\n    return float(vertical_extent / max(h//4, 1))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Vertical extent of the topmost significant pixel cluster\"\n    h, w = image.shape\n    top_quarter = image[:h//4, :]\n    if top_quarter.size == 0:\n        return 0.0\n    nonzero_rows = np.where(np.sum(top_quarter, axis=1) > 0)[0]\n    if len(nonzero_rows) == 0:\n        return 0.0\n    vertical_extent = len(nonzero_rows)\n    return float(vertical_extent / max(h//4, 1))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of non-zero pixels in the bottom quarter versus top quarter\"\n    h, w = image.shape\n    top_quarter = image[:h//4, :]\n    bottom_quarter = image[3*h//4:, :]\n    top_count = np.count_nonzero(top_quarter)\n    bottom_count = np.count_nonzero(bottom_quarter)\n    if top_count == 0:\n        return float(bottom_count)\n    return float(bottom_count / top_count)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Vertical extent of the topmost significant pixel cluster\"\n    h, w = image.shape\n    top_quarter = image[:h//4, :]\n    if top_quarter.size == 0:\n        return 0.0\n    nonzero_rows = np.where(np.sum(top_quarter, axis=1) > 0)[0]\n    if len(nonzero_rows) == 0:\n        return 0.0\n    vertical_extent = len(nonzero_rows)\n    return float(vertical_extent / max(h//4, 1))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Vertical extent of the topmost significant pixel cluster\"\n    h, w = image.shape\n    top_quarter = image[:h//4, :]\n    if top_quarter.size == 0:\n        return 0.0\n    nonzero_rows = np.where(np.sum(top_quarter, axis=1) > 0)[0]\n    if len(nonzero_rows) == 0:\n        return 0.0\n    vertical_extent = len(nonzero_rows)\n    return float(vertical_extent / max(h//4, 1))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Standard deviation of column sums in the middle third of image width\"\n    h, w = image.shape\n    if w == 0:\n        return 0.0\n    start_col = w // 3\n    end_col = 2 * w // 3\n    middle_section = image[:, start_col:end_col]\n    if middle_section.size == 0:\n        return 0.0\n    column_sums = np.sum(middle_section, axis=0)\n    return float(np.std(column_sums))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Number of vertical transitions from background to foreground in center column\"\n    h, w = image.shape\n    center_col = image[:, w//2]\n    threshold = np.mean(image) * 0.5\n    binary = (center_col > threshold).astype(int)\n    transitions = np.sum(np.diff(binary) > 0)\n    return float(transitions)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Count of vertical runs of consecutive non-zero pixels in the left half\"\n    h, w = image.shape\n    left_half = image[:, :w//2]\n    vertical_runs = 0\n    for col in range(left_half.shape[1]):\n        in_run = False\n        for row in range(left_half.shape[0]):\n            if left_half[row, col] > 0:\n                if not in_run:\n                    vertical_runs += 1\n                    in_run = True\n            else:\n                in_run = False\n    return float(vertical_runs)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Width of the widest row with non-zero pixels\"\n    h, w = image.shape\n    max_width = 0\n    for row in range(h):\n        non_zero_cols = np.where(image[row, :] > 0)[0]\n        if len(non_zero_cols) > 0:\n            width = non_zero_cols[-1] - non_zero_cols[0] + 1\n            max_width = max(max_width, width)\n    return float(max_width)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Standard deviation of row sums in the bottom half of image\"\n    h, w = image.shape\n    bottom_half = image[h//2:, :]\n    row_sums = np.sum(bottom_half, axis=1)\n    return float(np.std(row_sums))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of pixel sum in bottom-right quadrant to total pixel sum\"\n    h, w = image.shape\n    if h < 2 or w < 2:\n        return 0.0\n    bottom_right = image[h//2:, w//2:]\n    total_sum = np.sum(image)\n    if total_sum == 0:\n        return 0.0\n    return float(np.sum(bottom_right) / total_sum)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Count of horizontal line segments in the middle third of the image\"\n    h, w = image.shape\n    middle_third = image[h//3:2*h//3, :]\n    threshold = np.mean(middle_third) + np.std(middle_third)\n    line_count = 0\n    for row in middle_third:\n        segments = 0\n        in_segment = False\n        for pixel in row:\n            if pixel > threshold and not in_segment:\n                segments += 1\n                in_segment = True\n            elif pixel <= threshold:\n                in_segment = False\n        line_count += segments\n    return float(line_count)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Number of vertical line segments in the center column\"\n    h, w = image.shape\n    if w == 0:\n        return 0.0\n    \n    center_col = image[:, w//2]\n    threshold = np.mean(center_col) if np.mean(center_col) > 0 else np.max(center_col) * 0.5\n    \n    binary_col = (center_col > threshold).astype(int)\n    \n    # Count continuous segments\n    segments = 0\n    in_segment = False\n    \n    for val in binary_col:\n        if val == 1 and not in_segment:\n            segments += 1\n            in_segment = True\n        elif val == 0:\n            in_segment = False\n    \n    return float(segments)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Count of vertical runs of consecutive non-zero pixels in the left half\"\n    h, w = image.shape\n    left_half = image[:, :w//2]\n    vertical_runs = 0\n    for col in range(left_half.shape[1]):\n        in_run = False\n        for row in range(left_half.shape[0]):\n            if left_half[row, col] > 0:\n                if not in_run:\n                    vertical_runs += 1\n                    in_run = True\n            else:\n                in_run = False\n    return float(vertical_runs)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of horizontal edges to vertical edges in the image\"\n    grad_y, grad_x = np.gradient(image.astype(float))\n    horizontal_edges = np.sum(np.abs(grad_y) > np.abs(grad_x))\n    vertical_edges = np.sum(np.abs(grad_x) > np.abs(grad_y))\n    if vertical_edges == 0:\n        return float(horizontal_edges)\n    return float(horizontal_edges / vertical_edges)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Standard deviation of pixel intensities in the top quarter\"\n    h, w = image.shape\n    top_quarter = image[:h//4, :]\n    if top_quarter.size == 0:\n        return 0.0\n    return float(np.std(top_quarter))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Skewness of horizontal distribution of non-zero pixels\"\n    h, w = image.shape\n    if w == 0:\n        return 0.0\n    col_sums = np.sum(image, axis=0)\n    non_zero_cols = np.nonzero(col_sums)[0]\n    if len(non_zero_cols) < 3:\n        return 0.0\n    weights = col_sums[non_zero_cols]\n    positions = non_zero_cols\n    mean_pos = np.average(positions, weights=weights)\n    variance = np.average((positions - mean_pos)**2, weights=weights)\n    if variance == 0:\n        return 0.0\n    skewness = np.average((positions - mean_pos)**3, weights=weights) / (variance**1.5)\n    return float(skewness)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of horizontal edges to vertical edges in the image\"\n    grad_y, grad_x = np.gradient(image.astype(float))\n    horizontal_edges = np.sum(np.abs(grad_y) > np.abs(grad_x))\n    vertical_edges = np.sum(np.abs(grad_x) > np.abs(grad_y))\n    if vertical_edges == 0:\n        return float(horizontal_edges)\n    return float(horizontal_edges / vertical_edges)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Count of vertical runs of consecutive non-zero pixels in the left half\"\n    h, w = image.shape\n    left_half = image[:, :w//2]\n    vertical_runs = 0\n    for col in range(left_half.shape[1]):\n        in_run = False\n        for row in range(left_half.shape[0]):\n            if left_half[row, col] > 0:\n                if not in_run:\n                    vertical_runs += 1\n                    in_run = True\n            else:\n                in_run = False\n    return float(vertical_runs)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Intensity concentration in the center-right quadrant\"\n    h, w = image.shape\n    center_right = image[h//4:3*h//4, w//2:3*w//4]\n    if center_right.size == 0:\n        return 0.0\n    total_intensity = np.sum(image)\n    center_right_intensity = np.sum(center_right)\n    return float(center_right_intensity) / (total_intensity + 1e-10)\n",
    "def feature(image: np.ndarray) -> float:\n    \"Average width of non-zero regions per row in bottom half\"\n    h, w = image.shape\n    bottom_half = image[h//2:, :]\n    total_width = 0\n    valid_rows = 0\n    for row in bottom_half:\n        nonzero_indices = np.where(row > 0)[0]\n        if len(nonzero_indices) > 0:\n            width = nonzero_indices[-1] - nonzero_indices[0] + 1\n            total_width += width\n            valid_rows += 1\n    return float(total_width / valid_rows if valid_rows > 0 else 0)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Density of pixels in a small central circular region\"\n    h, w = image.shape\n    center_y, center_x = h // 2, w // 2\n    radius = min(h, w) // 6\n    y, x = np.ogrid[:h, :w]\n    mask = (y - center_y)**2 + (x - center_x)**2 <= radius**2\n    if np.sum(mask) == 0:\n        return 0.0\n    return float(np.sum(image[mask] > 0) / np.sum(mask))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Number of enclosed regions or loops in the image\"\n    from scipy import ndimage\n    if image.size == 0:\n        return 0.0\n    binary = image > np.mean(image)\n    filled = ndimage.binary_fill_holes(binary)\n    loops = np.sum(filled) - np.sum(binary)\n    return float(loops)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of horizontal edges to vertical edges in the image\"\n    grad_y, grad_x = np.gradient(image.astype(float))\n    horizontal_edges = np.sum(np.abs(grad_y) > np.abs(grad_x))\n    vertical_edges = np.sum(np.abs(grad_x) > np.abs(grad_y))\n    if vertical_edges == 0:\n        return float(horizontal_edges)\n    return float(horizontal_edges / vertical_edges)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Number of diagonal transitions from top-left to bottom-right\"\n    h, w = image.shape\n    if h < 2 or w < 2:\n        return 0.0\n    transitions = 0\n    min_dim = min(h, w)\n    for i in range(min_dim - 1):\n        if (image[i, i] > 0) != (image[i+1, i+1] > 0):\n            transitions += 1\n    return float(transitions)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Number of vertical transitions from background to foreground in center column\"\n    h, w = image.shape\n    center_col = image[:, w//2]\n    threshold = np.mean(image) * 0.5\n    binary = (center_col > threshold).astype(int)\n    transitions = np.sum(np.diff(binary) > 0)\n    return float(transitions)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Diagonal edge strength from top-left to bottom-right\"\n    h, w = image.shape\n    diagonal_sum = 0.0\n    count = 0\n    for i in range(min(h-1, w-1)):\n        if i+1 < h and i+1 < w:\n            diagonal_sum += abs(float(image[i+1, i+1]) - float(image[i, i]))\n            count += 1\n    return float(diagonal_sum / count) if count > 0 else 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Number of enclosed regions or loops in the image\"\n    from scipy import ndimage\n    if image.size == 0:\n        return 0.0\n    binary = image > np.mean(image)\n    filled = ndimage.binary_fill_holes(binary)\n    loops = np.sum(filled) - np.sum(binary)\n    return float(loops)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Count of pixels above median in the upper-right eighth of image\"\n    h, w = image.shape\n    upper_right_eighth = image[:h//4, 3*w//4:]\n    median_val = np.median(image)\n    return float(np.sum(upper_right_eighth > median_val))\n",
    "def feature(image: np.ndarray) -> float:\n    \"Density of high-intensity pixels in the top quarter\"\n    h, w = image.shape\n    if h == 0 or w == 0:\n        return 0.0\n    top_quarter = image[:h//4, :]\n    high_intensity = np.sum(top_quarter > np.mean(image))\n    total_pixels = top_quarter.size\n    return float(high_intensity / total_pixels if total_pixels > 0 else 0.0)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of horizontal edges to vertical edges in the image\"\n    grad_y, grad_x = np.gradient(image.astype(float))\n    horizontal_edges = np.sum(np.abs(grad_y) > np.abs(grad_x))\n    vertical_edges = np.sum(np.abs(grad_x) > np.abs(grad_y))\n    if vertical_edges == 0:\n        return float(horizontal_edges)\n    return float(horizontal_edges / vertical_edges)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Standard deviation of pixel intensities in the outer border region\"\n    h, w = image.shape\n    border_width = min(h, w) // 8\n    if border_width == 0:\n        return 0.0\n    border_mask = np.zeros((h, w), dtype=bool)\n    border_mask[:border_width, :] = True\n    border_mask[-border_width:, :] = True\n    border_mask[:, :border_width] = True\n    border_mask[:, -border_width:] = True\n    return float(np.std(image[border_mask]))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Number of vertical line segments in the center column\"\n    h, w = image.shape\n    if w == 0:\n        return 0.0\n    center_col = image[:, w//2]\n    threshold = np.mean(center_col) + np.std(center_col) if np.std(center_col) > 0 else np.mean(center_col)\n    binary_col = (center_col > threshold).astype(int)\n    segments = 0\n    in_segment = False\n    for pixel in binary_col:\n        if pixel == 1 and not in_segment:\n            segments += 1\n            in_segment = True\n        elif pixel == 0:\n            in_segment = False\n    return float(segments)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Vertical extent of non-zero pixels as fraction of image height\"\n    if image.size == 0:\n        return 0.0\n    nonzero_rows = np.any(image > np.mean(image), axis=1)\n    if not np.any(nonzero_rows):\n        return 0.0\n    first_row = np.argmax(nonzero_rows)\n    last_row = len(nonzero_rows) - 1 - np.argmax(nonzero_rows[::-1])\n    return float((last_row - first_row + 1) / image.shape[0])\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Vertical extent of the topmost significant pixel cluster\"\n    h, w = image.shape\n    top_quarter = image[:h//4, :]\n    if top_quarter.size == 0:\n        return 0.0\n    nonzero_rows = np.where(np.sum(top_quarter, axis=1) > 0)[0]\n    if len(nonzero_rows) == 0:\n        return 0.0\n    vertical_extent = len(nonzero_rows)\n    return float(vertical_extent / max(h//4, 1))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Number of enclosed regions or loops in the image\"\n    h, w = image.shape\n    if h == 0 or w == 0:\n        return 0.0\n    # Simple loop detection by counting transitions in middle rows\n    loops = 0\n    for row in range(h//3, 2*h//3):\n        transitions = 0\n        prev = 0\n        for col in range(w):\n            curr = 1 if image[row, col] > 0 else 0\n            if curr != prev:\n                transitions += 1\n            prev = curr\n        if transitions >= 4:  # Likely indicates a loop\n            loops += 1\n    return float(loops)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Maximum width of continuous horizontal pixel runs in middle third\"\n    h, w = image.shape\n    middle_third = image[h//3:2*h//3, :]\n    threshold = np.mean(middle_third) + 0.5 * np.std(middle_third)\n    binary = middle_third > threshold\n    max_width = 0\n    for row in binary:\n        current_width = 0\n        for pixel in row:\n            if pixel:\n                current_width += 1\n                max_width = max(max_width, current_width)\n            else:\n                current_width = 0\n    return float(max_width)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Number of vertical line segments in the center column\"\n    h, w = image.shape\n    if w == 0:\n        return 0.0\n    center_col = image[:, w//2]\n    threshold = np.mean(center_col) + np.std(center_col) if np.std(center_col) > 0 else np.mean(center_col)\n    binary_col = (center_col > threshold).astype(int)\n    segments = 0\n    in_segment = False\n    for pixel in binary_col:\n        if pixel == 1 and not in_segment:\n            segments += 1\n            in_segment = True\n        elif pixel == 0:\n            in_segment = False\n    return float(segments)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Average width of non-zero regions per row in bottom half\"\n    h, w = image.shape\n    bottom_half = image[h//2:, :]\n    total_width = 0\n    valid_rows = 0\n    for row in bottom_half:\n        nonzero_indices = np.where(row > 0)[0]\n        if len(nonzero_indices) > 0:\n            width = nonzero_indices[-1] - nonzero_indices[0] + 1\n            total_width += width\n            valid_rows += 1\n    return float(total_width / valid_rows if valid_rows > 0 else 0)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Number of enclosed regions or loops in the image\"\n    from scipy import ndimage\n    if image.size == 0:\n        return 0.0\n    binary = image > np.mean(image)\n    filled = ndimage.binary_fill_holes(binary)\n    loops = np.sum(filled) - np.sum(binary)\n    return float(loops)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Number of distinct enclosed loops or holes in the image\"\n    h, w = image.shape\n    if h == 0 or w == 0:\n        return 0.0\n    \n    # Create binary image\n    binary = (image > np.mean(image)).astype(int)\n    visited = np.zeros_like(binary)\n    holes = 0\n    \n    for i in range(1, h-1):\n        for j in range(1, w-1):\n            if binary[i, j] == 0 and visited[i, j] == 0:\n                # Check if this zero region is completely surrounded\n                stack = [(i, j)]\n                region = []\n                is_hole = True\n                \n                while stack and len(region) < 100:  # Limit to avoid infinite loops\n                    y, x = stack.pop()\n                    if y < 0 or y >= h or x < 0 or x >= w or visited[y, x]:\n                        continue\n                    if binary[y, x] == 1:\n                        continue\n                    if y == 0 or y == h-1 or x == 0 or x == w-1:\n                        is_hole = False\n                    \n                    visited[y, x] = 1\n                    region.append((y, x))\n                    stack.extend([(y+1, x), (y-1, x), (y, x+1), (y, x-1)])\n                \n                if is_hole and len(region) > 3:\n                    holes += 1\n    \n    return float(holes)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of pixel intensity in bottom quarter to middle half\"\n    h, w = image.shape\n    bottom_quarter = image[3*h//4:, :]\n    middle_half = image[h//4:3*h//4, :]\n    bottom_mean = np.mean(bottom_quarter) if bottom_quarter.size > 0 else 0\n    middle_mean = np.mean(middle_half) if middle_half.size > 0 else 1\n    return float(bottom_mean / middle_mean if middle_mean > 0 else 0.0)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Average width of non-zero regions per row in bottom half\"\n    h, w = image.shape\n    bottom_half = image[h//2:, :]\n    total_width = 0\n    valid_rows = 0\n    for row in bottom_half:\n        nonzero_indices = np.where(row > 0)[0]\n        if len(nonzero_indices) > 0:\n            width = nonzero_indices[-1] - nonzero_indices[0] + 1\n            total_width += width\n            valid_rows += 1\n    return float(total_width / valid_rows if valid_rows > 0 else 0)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Horizontal gradient variance in the middle third of image height\"\n    h, w = image.shape\n    middle_section = image[h//3:2*h//3, :]\n    grad_x = np.gradient(middle_section, axis=1)\n    return float(np.var(grad_x))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Sum of pixel intensities in the bottom-left corner region\"\n    h, w = image.shape\n    corner_size = min(h//3, w//3)\n    bottom_left_corner = image[h-corner_size:, :corner_size]\n    return float(np.sum(bottom_left_corner))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Density of non-zero pixels in the top-right quarter of the image\"\n    h, w = image.shape\n    top_right = image[:h//2, w//2:]\n    total_pixels = top_right.size\n    if total_pixels == 0:\n        return 0.0\n    return float(np.count_nonzero(top_right) / total_pixels)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Average vertical position of non-zero pixels weighted by intensity\"\n    h, w = image.shape\n    if np.sum(image) == 0:\n        return 0.0\n    y_coords, x_coords = np.where(image > 0)\n    weights = image[y_coords, x_coords]\n    weighted_y = np.sum(y_coords * weights) / np.sum(weights)\n    return float(weighted_y / h)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Maximum vertical span of non-zero pixels in any single column\"\n    h, w = image.shape\n    max_span = 0\n    for col in range(w):\n        column = image[:, col]\n        nonzero_rows = np.where(column > 0)[0]\n        if len(nonzero_rows) > 0:\n            span = nonzero_rows.max() - nonzero_rows.min() + 1\n            max_span = max(max_span, span)\n    return float(max_span / h if h > 0 else 0)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Number of enclosed circular regions or loops in the image\"\n    h, w = image.shape\n    if h == 0 or w == 0:\n        return 0.0\n    \n    # Create binary image\n    binary = (image > np.mean(image)).astype(int)\n    \n    # Count enclosed regions by looking for transitions\n    loops = 0\n    center_h, center_w = h // 2, w // 2\n    \n    # Check multiple radial scans from center\n    for angle in np.linspace(0, 2*np.pi, 16):\n        transitions = 0\n        prev_val = 0\n        for r in range(1, min(center_h, center_w)):\n            y = int(center_h + r * np.sin(angle))\n            x = int(center_w + r * np.cos(angle))\n            if 0 <= y < h and 0 <= x < w:\n                if binary[y, x] != prev_val:\n                    transitions += 1\n                prev_val = binary[y, x]\n        if transitions >= 4:  # Likely indicates a loop\n            loops += 1\n    \n    return float(loops)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Horizontal gradient strength in the middle third of image\"\n    h, w = image.shape\n    middle_third = image[h//3:2*h//3, :]\n    grad_y, grad_x = np.gradient(middle_third)\n    return float(np.mean(np.abs(grad_x)))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Average pixel intensity in the bottom-right quadrant\"\n    h, w = image.shape\n    if h < 2 or w < 2:\n        return float(np.mean(image))\n    bottom_right = image[h//2:, w//2:]\n    return float(np.mean(bottom_right))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Number of distinct connected regions in the right half of the image\"\n    h, w = image.shape\n    if w < 2:\n        return 0.0\n    right_half = image[:, w//2:]\n    regions = 0\n    visited = np.zeros_like(right_half, dtype=bool)\n    \n    def flood_fill(r, c):\n        if r < 0 or r >= right_half.shape[0] or c < 0 or c >= right_half.shape[1]:\n            return\n        if visited[r, c] or right_half[r, c] == 0:\n            return\n        visited[r, c] = True\n        flood_fill(r+1, c)\n        flood_fill(r-1, c)\n        flood_fill(r, c+1)\n        flood_fill(r, c-1)\n    \n    for r in range(right_half.shape[0]):\n        for c in range(right_half.shape[1]):\n            if right_half[r, c] > 0 and not visited[r, c]:\n                flood_fill(r, c)\n                regions += 1\n    \n    return float(regions)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Average width of non-zero regions per row in bottom half\"\n    h, w = image.shape\n    bottom_half = image[h//2:, :]\n    total_width = 0\n    valid_rows = 0\n    for row in bottom_half:\n        nonzero_indices = np.where(row > 0)[0]\n        if len(nonzero_indices) > 0:\n            width = nonzero_indices[-1] - nonzero_indices[0] + 1\n            total_width += width\n            valid_rows += 1\n    return float(total_width / valid_rows if valid_rows > 0 else 0)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Number of enclosed regions or loops in the image\"\n    h, w = image.shape\n    binary = (image > np.mean(image)).astype(int)\n    enclosed_count = 0\n    center_h, center_w = h//2, w//2\n    search_radius = min(h, w) // 4\n    for r in range(max(0, center_h - search_radius), min(h, center_h + search_radius)):\n        row = binary[r, :]\n        transitions = np.sum(np.abs(np.diff(row)))\n        if transitions >= 4:\n            enclosed_count += 1\n    return float(enclosed_count)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Count of horizontal line segments in the middle third of the image\"\n    h, w = image.shape\n    middle_third = image[h//3:2*h//3, :]\n    horizontal_lines = 0\n    threshold = np.mean(middle_third) * 0.5 if np.mean(middle_third) > 0 else 0.1\n    for row in middle_third:\n        consecutive = 0\n        for pixel in row:\n            if pixel > threshold:\n                consecutive += 1\n            else:\n                if consecutive >= w // 4:\n                    horizontal_lines += 1\n                consecutive = 0\n        if consecutive >= w // 4:\n            horizontal_lines += 1\n    return float(horizontal_lines)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Compactness of the main shape measured by perimeter squared over area\"\n    binary = image > np.mean(image)\n    area = np.sum(binary)\n    if area == 0:\n        return 0.0\n    grad_y, grad_x = np.gradient(binary.astype(float))\n    perimeter = np.sum(np.sqrt(grad_x**2 + grad_y**2) > 0)\n    return float(perimeter**2 / max(1, area))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of connected components in top-right quadrant to total non-zero pixels\"\n    h, w = image.shape\n    top_right = image[:h//2, w//2:]\n    if np.sum(top_right) == 0:\n        return 0.0\n    components = 0\n    visited = np.zeros_like(top_right, dtype=bool)\n    for i in range(top_right.shape[0]):\n        for j in range(top_right.shape[1]):\n            if top_right[i, j] > 0 and not visited[i, j]:\n                components += 1\n                stack = [(i, j)]\n                while stack:\n                    x, y = stack.pop()\n                    if x >= 0 and x < top_right.shape[0] and y >= 0 and y < top_right.shape[1] and not visited[x, y] and top_right[x, y] > 0:\n                        visited[x, y] = True\n                        stack.extend([(x+1, y), (x-1, y), (x, y+1), (x, y-1)])\n    return float(components / np.count_nonzero(top_right))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Horizontal extent of the topmost non-zero pixels\"\n    h, w = image.shape\n    for row in range(h):\n        if np.any(image[row, :] > 0):\n            nonzero_cols = np.where(image[row, :] > 0)[0]\n            return float(nonzero_cols[-1] - nonzero_cols[0] + 1) / w\n    return 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Average pixel intensity in the rightmost quarter of the image\"\n    h, w = image.shape\n    if w == 0:\n        return 0.0\n    right_quarter = image[:, 3*w//4:]\n    return float(np.mean(right_quarter))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Number of vertical runs of consecutive non-zero pixels in middle columns\"\n    h, w = image.shape\n    middle_cols = image[:, w//4:3*w//4]\n    if middle_cols.size == 0:\n        return 0.0\n    runs = 0\n    for col in range(middle_cols.shape[1]):\n        in_run = False\n        for row in range(middle_cols.shape[0]):\n            if middle_cols[row, col] > 0:\n                if not in_run:\n                    runs += 1\n                    in_run = True\n            else:\n                in_run = False\n    return float(runs)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Number of enclosed regions or loops in the image\"\n    from scipy import ndimage\n    if image.size == 0:\n        return 0.0\n    binary = image > np.mean(image)\n    filled = ndimage.binary_fill_holes(binary)\n    loops = np.sum(filled) - np.sum(binary)\n    return float(loops)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Maximum pixel intensity in the upper-left quadrant\"\n    h, w = image.shape\n    upper_left = image[:h//2, :w//2]\n    return float(np.max(upper_left))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Diagonal edge strength from top-left to bottom-right\"\n    h, w = image.shape\n    diagonal_sum = 0.0\n    count = 0\n    for i in range(min(h-1, w-1)):\n        if i+1 < h and i+1 < w:\n            diagonal_sum += abs(float(image[i+1, i+1]) - float(image[i, i]))\n            count += 1\n    return float(diagonal_sum / count) if count > 0 else 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Number of horizontal transitions from zero to non-zero pixels\"\n    transitions = 0\n    h, w = image.shape\n    for row in range(h):\n        for col in range(1, w):\n            if image[row, col-1] == 0 and image[row, col] > 0:\n                transitions += 1\n    return float(transitions)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of pixels in center vertical strip versus total non-zero pixels\"\n    h, w = image.shape\n    if w == 0:\n        return 0.0\n    center_strip_width = max(1, w // 8)\n    center_start = w // 2 - center_strip_width // 2\n    center_end = center_start + center_strip_width\n    center_strip = image[:, center_start:center_end]\n    center_pixels = np.count_nonzero(center_strip)\n    total_pixels = np.count_nonzero(image)\n    if total_pixels == 0:\n        return 0.0\n    return float(center_pixels / total_pixels)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Average vertical gradient magnitude in center column\"\n    h, w = image.shape\n    center_col = image[:, w//2] if w > 0 else np.array([0])\n    grad = np.abs(np.gradient(center_col))\n    return float(np.mean(grad))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Maximum consecutive horizontal zeros in the middle row\"\n    h, w = image.shape\n    middle_row = image[h//2, :]\n    max_zeros = 0\n    current_zeros = 0\n    for pixel in middle_row:\n        if pixel == 0:\n            current_zeros += 1\n            max_zeros = max(max_zeros, current_zeros)\n        else:\n            current_zeros = 0\n    return float(max_zeros / w if w > 0 else 0.0)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Standard deviation of pixel intensities in the leftmost third\"\n    h, w = image.shape\n    left_third = image[:, :w//3]\n    return float(np.std(left_third)) if left_third.size > 0 else 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of pixel intensity in the center circle versus outer ring\"\n    h, w = image.shape\n    center_y, center_x = h // 2, w // 2\n    radius = min(h, w) // 4\n    y_coords, x_coords = np.ogrid[:h, :w]\n    distances = np.sqrt((y_coords - center_y)**2 + (x_coords - center_x)**2)\n    center_mask = distances <= radius\n    outer_mask = (distances > radius) & (distances <= radius * 2)\n    center_sum = np.sum(image[center_mask]) if np.any(center_mask) else 0\n    outer_sum = np.sum(image[outer_mask]) if np.any(outer_mask) else 1\n    return float(center_sum / max(outer_sum, 1))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of pixels in top half versus bottom half of image\"\n    h, w = image.shape\n    if h == 0:\n        return 0.0\n    top_half = np.sum(image[:h//2, :])\n    bottom_half = np.sum(image[h//2:, :])\n    if bottom_half == 0:\n        return float('inf') if top_half > 0 else 0.0\n    return float(top_half / bottom_half)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Count of vertical runs of consecutive non-zero pixels in the left half\"\n    h, w = image.shape\n    left_half = image[:, :w//2]\n    vertical_runs = 0\n    for col in range(left_half.shape[1]):\n        in_run = False\n        for row in range(left_half.shape[0]):\n            if left_half[row, col] > 0:\n                if not in_run:\n                    vertical_runs += 1\n                    in_run = True\n            else:\n                in_run = False\n    return float(vertical_runs)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Intensity ratio between upper-middle and lower-middle regions\"\n    h, w = image.shape\n    upper_mid = image[h//4:h//2, w//4:3*w//4]\n    lower_mid = image[h//2:3*h//4, w//4:3*w//4]\n    upper_sum = np.sum(upper_mid)\n    lower_sum = np.sum(lower_mid)\n    if lower_sum == 0:\n        return 1.0 if upper_sum > 0 else 0.0\n    return float(upper_sum / (upper_sum + lower_sum))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Maximum width of connected pixels in any single row\"\n    h, w = image.shape\n    max_width = 0\n    threshold = np.mean(image) * 0.3 if np.mean(image) > 0 else 0.1\n    for row in image:\n        current_width = 0\n        row_max = 0\n        for pixel in row:\n            if pixel > threshold:\n                current_width += 1\n            else:\n                row_max = max(row_max, current_width)\n                current_width = 0\n        row_max = max(row_max, current_width)\n        max_width = max(max_width, row_max)\n    return float(max_width)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Number of distinct connected regions in the right half of the image\"\n    h, w = image.shape\n    if w < 2:\n        return 0.0\n    right_half = image[:, w//2:]\n    regions = 0\n    visited = np.zeros_like(right_half, dtype=bool)\n    \n    def flood_fill(r, c):\n        if r < 0 or r >= right_half.shape[0] or c < 0 or c >= right_half.shape[1]:\n            return\n        if visited[r, c] or right_half[r, c] == 0:\n            return\n        visited[r, c] = True\n        flood_fill(r+1, c)\n        flood_fill(r-1, c)\n        flood_fill(r, c+1)\n        flood_fill(r, c-1)\n    \n    for r in range(right_half.shape[0]):\n        for c in range(right_half.shape[1]):\n            if right_half[r, c] > 0 and not visited[r, c]:\n                flood_fill(r, c)\n                regions += 1\n    \n    return float(regions)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Vertical extent of the topmost significant pixel cluster\"\n    h, w = image.shape\n    top_quarter = image[:h//4, :]\n    if top_quarter.size == 0:\n        return 0.0\n    nonzero_rows = np.where(np.sum(top_quarter, axis=1) > 0)[0]\n    if len(nonzero_rows) == 0:\n        return 0.0\n    vertical_extent = len(nonzero_rows)\n    return float(vertical_extent / max(h//4, 1))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Maximum vertical gap between non-zero pixels in center column\"\n    h, w = image.shape\n    if w == 0:\n        return 0.0\n    center_col = image[:, w//2]\n    nonzero_rows = np.where(center_col > np.mean(center_col))[0]\n    if len(nonzero_rows) < 2:\n        return float(h)\n    max_gap = 0\n    for i in range(1, len(nonzero_rows)):\n        gap = nonzero_rows[i] - nonzero_rows[i-1] - 1\n        max_gap = max(max_gap, gap)\n    return float(max_gap)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Horizontal concentration of non-zero pixels in middle rows\"\n    h, w = image.shape\n    middle_rows = image[h//3:2*h//3, :]\n    if middle_rows.size == 0:\n        return 0.0\n    row_sums = np.sum(middle_rows > 0, axis=1)\n    return float(np.std(row_sums) / (np.mean(row_sums) + 1e-8))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Horizontal position of the rightmost significant pixel cluster\"\n    h, w = image.shape\n    threshold = np.percentile(image, 50) if np.max(image) > 0 else 0\n    significant_pixels = image > threshold\n    if not np.any(significant_pixels):\n        return 0.0\n    rightmost_cols = np.where(np.any(significant_pixels, axis=0))[0]\n    if len(rightmost_cols) == 0:\n        return 0.0\n    return float(np.max(rightmost_cols) / w)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Density of pixels in the bottom quarter of the image\"\n    h, w = image.shape\n    bottom_quarter = image[3*h//4:, :]\n    if bottom_quarter.size == 0:\n        return 0.0\n    return float(np.count_nonzero(bottom_quarter) / bottom_quarter.size)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Diagonal edge strength from top-left to bottom-right\"\n    h, w = image.shape\n    diagonal_sum = 0.0\n    count = 0\n    for i in range(min(h-1, w-1)):\n        if i+1 < h and i+1 < w:\n            diagonal_sum += abs(float(image[i+1, i+1]) - float(image[i, i]))\n            count += 1\n    return float(diagonal_sum / count) if count > 0 else 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of pixel density in upper third versus lower third of image\"\n    h, w = image.shape\n    upper_third = image[:h//3, :]\n    lower_third = image[2*h//3:, :]\n    upper_density = np.mean(upper_third) if upper_third.size > 0 else 0\n    lower_density = np.mean(lower_third) if lower_third.size > 0 else 0\n    return float(upper_density / (lower_density + 1e-8))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Count of horizontal runs of consecutive non-zero pixels in the upper half\"\n    h, w = image.shape\n    if h < 2:\n        return 0.0\n    upper_half = image[:h//2, :]\n    run_count = 0\n    for row in upper_half:\n        in_run = False\n        for pixel in row:\n            if pixel > 0 and not in_run:\n                run_count += 1\n                in_run = True\n            elif pixel == 0:\n                in_run = False\n    return float(run_count)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Vertical stroke continuity in the upper two-thirds of the image\"\n    h, w = image.shape\n    upper_region = image[:2*h//3, :]\n    if upper_region.size == 0:\n        return 0.0\n    vertical_continuity = 0.0\n    for col in range(w):\n        column_pixels = upper_region[:, col]\n        nonzero_positions = np.where(column_pixels > 0)[0]\n        if len(nonzero_positions) > 1:\n            gaps = np.diff(nonzero_positions)\n            continuity_score = np.sum(gaps == 1) / max(len(gaps), 1)\n            vertical_continuity += continuity_score\n    return float(vertical_continuity / max(w, 1))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Vertical extent of the topmost significant pixel cluster\"\n    h, w = image.shape\n    top_quarter = image[:h//4, :]\n    if top_quarter.size == 0:\n        return 0.0\n    nonzero_rows = np.where(np.sum(top_quarter, axis=1) > 0)[0]\n    if len(nonzero_rows) == 0:\n        return 0.0\n    vertical_extent = len(nonzero_rows)\n    return float(vertical_extent / max(h//4, 1))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of horizontal edges to vertical edges in the image\"\n    grad_y, grad_x = np.gradient(image.astype(float))\n    horizontal_edges = np.sum(np.abs(grad_y) > np.abs(grad_x))\n    vertical_edges = np.sum(np.abs(grad_x) > np.abs(grad_y))\n    if vertical_edges == 0:\n        return float(horizontal_edges)\n    return float(horizontal_edges / vertical_edges)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Skewness of horizontal distribution of non-zero pixels\"\n    h, w = image.shape\n    if w == 0:\n        return 0.0\n    col_sums = np.sum(image, axis=0)\n    non_zero_cols = np.nonzero(col_sums)[0]\n    if len(non_zero_cols) < 3:\n        return 0.0\n    weights = col_sums[non_zero_cols]\n    positions = non_zero_cols\n    mean_pos = np.average(positions, weights=weights)\n    variance = np.average((positions - mean_pos)**2, weights=weights)\n    if variance == 0:\n        return 0.0\n    skewness = np.average((positions - mean_pos)**3, weights=weights) / (variance**1.5)\n    return float(skewness)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Horizontal concentration of non-zero pixels in middle rows\"\n    h, w = image.shape\n    middle_rows = image[h//3:2*h//3, :]\n    if middle_rows.size == 0:\n        return 0.0\n    row_sums = np.sum(middle_rows > 0, axis=1)\n    return float(np.std(row_sums) / (np.mean(row_sums) + 1e-8))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Horizontal gradient magnitude in the middle row\"\n    h, w = image.shape\n    if h == 0 or w < 2:\n        return 0.0\n    middle_row = image[h//2, :]\n    gradient = np.gradient(middle_row)\n    return float(np.mean(np.abs(gradient)))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Count of horizontal runs of consecutive non-zero pixels in the upper half\"\n    h, w = image.shape\n    if h < 2:\n        return 0.0\n    upper_half = image[:h//2, :]\n    run_count = 0\n    for row in upper_half:\n        in_run = False\n        for pixel in row:\n            if pixel > 0 and not in_run:\n                run_count += 1\n                in_run = True\n            elif pixel == 0:\n                in_run = False\n    return float(run_count)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Number of enclosed regions or loops in the image\"\n    h, w = image.shape\n    binary = (image > np.mean(image)).astype(int)\n    enclosed_count = 0\n    center_h, center_w = h//2, w//2\n    search_radius = min(h, w) // 4\n    for r in range(max(0, center_h - search_radius), min(h, center_h + search_radius)):\n        row = binary[r, :]\n        transitions = np.sum(np.abs(np.diff(row)))\n        if transitions >= 4:\n            enclosed_count += 1\n    return float(enclosed_count)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Count of horizontal runs of consecutive non-zero pixels in the upper half\"\n    h, w = image.shape\n    if h < 2:\n        return 0.0\n    upper_half = image[:h//2, :]\n    run_count = 0\n    for row in upper_half:\n        in_run = False\n        for pixel in row:\n            if pixel > 0 and not in_run:\n                run_count += 1\n                in_run = True\n            elif pixel == 0:\n                in_run = False\n    return float(run_count)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of pixels above threshold in upper-left versus lower-right quadrants\"\n    h, w = image.shape\n    if h < 2 or w < 2:\n        return 0.0\n    threshold = np.mean(image)\n    upper_left = image[:h//2, :w//2]\n    lower_right = image[h//2:, w//2:]\n    ul_count = np.count_nonzero(upper_left > threshold)\n    lr_count = np.count_nonzero(lower_right > threshold)\n    if lr_count == 0:\n        return float(ul_count > 0)\n    return float(ul_count / lr_count)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Horizontal gradient variance in the middle third of image height\"\n    h, w = image.shape\n    middle_section = image[h//3:2*h//3, :]\n    grad_x = np.gradient(middle_section, axis=1)\n    return float(np.var(grad_x))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Coefficient of variation of row-wise pixel intensities\"\n    h, w = image.shape\n    if h == 0:\n        return 0.0\n    row_means = np.array([np.mean(image[i, :]) for i in range(h)])\n    mean_of_means = np.mean(row_means)\n    if mean_of_means == 0:\n        return 0.0\n    std_of_means = np.std(row_means)\n    return float(std_of_means / mean_of_means)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Coefficient of variation of row-wise pixel intensities\"\n    h, w = image.shape\n    if h == 0:\n        return 0.0\n    row_means = np.array([np.mean(image[i, :]) for i in range(h)])\n    mean_of_means = np.mean(row_means)\n    if mean_of_means == 0:\n        return 0.0\n    std_of_means = np.std(row_means)\n    return float(std_of_means / mean_of_means)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Number of enclosed regions or loops in the image\"\n    from scipy import ndimage\n    if image.size == 0:\n        return 0.0\n    binary = image > np.mean(image)\n    filled = ndimage.binary_fill_holes(binary)\n    loops = np.sum(filled) - np.sum(binary)\n    return float(loops)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Variance of pixel intensities in diagonal regions versus anti-diagonal regions\"\n    h, w = image.shape\n    if h == 0 or w == 0:\n        return 0.0\n    diag_pixels = []\n    anti_diag_pixels = []\n    for i in range(min(h, w)):\n        diag_pixels.append(image[i, i])\n        anti_diag_pixels.append(image[i, w-1-i])\n    diag_var = np.var(diag_pixels) if diag_pixels else 0.0\n    anti_diag_var = np.var(anti_diag_pixels) if anti_diag_pixels else 0.0\n    return float(diag_var - anti_diag_var)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of pixel intensity in bottom quarter to middle half\"\n    h, w = image.shape\n    bottom_quarter = image[3*h//4:, :]\n    middle_half = image[h//4:3*h//4, :]\n    bottom_mean = np.mean(bottom_quarter) if bottom_quarter.size > 0 else 0\n    middle_mean = np.mean(middle_half) if middle_half.size > 0 else 1\n    return float(bottom_mean / middle_mean if middle_mean > 0 else 0.0)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Intensity concentration in the center 3x3 region relative to total\"\n    h, w = image.shape\n    if h < 3 or w < 3:\n        return 0.0\n    center_h, center_w = h//2, w//2\n    center_3x3 = image[center_h-1:center_h+2, center_w-1:center_w+2]\n    center_sum = np.sum(center_3x3)\n    total_sum = np.sum(image)\n    if total_sum == 0:\n        return 0.0\n    return float(center_sum / total_sum)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Count of pixels above median in the upper-right eighth of image\"\n    h, w = image.shape\n    upper_right_eighth = image[:h//4, 3*w//4:]\n    median_val = np.median(image)\n    return float(np.sum(upper_right_eighth > median_val))\n",
    "def feature(image: np.ndarray) -> float:\n    \"Coefficient of variation of row-wise pixel intensities\"\n    h, w = image.shape\n    if h == 0:\n        return 0.0\n    row_means = np.array([np.mean(image[i, :]) for i in range(h)])\n    mean_of_means = np.mean(row_means)\n    if mean_of_means == 0:\n        return 0.0\n    std_of_means = np.std(row_means)\n    return float(std_of_means / mean_of_means)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Standard deviation of pixel intensities in the bottom-right corner\"\n    h, w = image.shape\n    bottom_right = image[2*h//3:, 2*w//3:]\n    return float(np.std(bottom_right))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Maximum vertical run length of connected foreground pixels\"\n    h, w = image.shape\n    threshold = np.mean(image) * 0.3\n    binary = image > threshold\n    max_run = 0\n    for j in range(w):\n        current_run = 0\n        for i in range(h):\n            if binary[i, j]:\n                current_run += 1\n                max_run = max(max_run, current_run)\n            else:\n                current_run = 0\n    return float(max_run)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Compactness measure using perimeter-to-area ratio of non-zero pixels\"\n    binary = (image > 0).astype(np.uint8)\n    area = np.count_nonzero(binary)\n    if area == 0:\n        return 0.0\n    gradients = np.gradient(binary.astype(float))\n    edge_magnitude = np.sqrt(gradients[0]**2 + gradients[1]**2)\n    perimeter = np.count_nonzero(edge_magnitude > 0.1)\n    return perimeter / (area + 1e-8)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Number of distinct enclosed regions or holes in the image\"\n    from scipy import ndimage\n    if image.size == 0:\n        return 0.0\n    binary = image > np.mean(image)\n    inverted = ~binary\n    labeled, num_holes = ndimage.label(inverted)\n    return float(num_holes - 1) if num_holes > 0 else 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Intensity variance in diagonal stripe from top-right to bottom-left\"\n    h, w = image.shape\n    diagonal_pixels = []\n    for i in range(min(h, w)):\n        if i < h and w-1-i >= 0:\n            diagonal_pixels.append(image[i, w-1-i])\n    return float(np.var(diagonal_pixels) if diagonal_pixels else 0.0)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Average intensity in the middle horizontal strip of the image\"\n    h, w = image.shape\n    middle_strip = image[h//3:2*h//3, :]\n    return float(np.mean(middle_strip))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Skewness of horizontal distribution of non-zero pixels\"\n    h, w = image.shape\n    if w == 0:\n        return 0.0\n    col_sums = np.sum(image, axis=0)\n    non_zero_cols = np.nonzero(col_sums)[0]\n    if len(non_zero_cols) < 3:\n        return 0.0\n    weights = col_sums[non_zero_cols]\n    positions = non_zero_cols\n    mean_pos = np.average(positions, weights=weights)\n    variance = np.average((positions - mean_pos)**2, weights=weights)\n    if variance == 0:\n        return 0.0\n    skewness = np.average((positions - mean_pos)**3, weights=weights) / (variance**1.5)\n    return float(skewness)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of pixels in top half versus bottom half of image\"\n    h, w = image.shape\n    if h == 0:\n        return 0.0\n    top_half = np.sum(image[:h//2, :])\n    bottom_half = np.sum(image[h//2:, :])\n    if bottom_half == 0:\n        return float('inf') if top_half > 0 else 0.0\n    return float(top_half / bottom_half)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Average vertical gradient magnitude in the middle vertical strip\"\n    h, w = image.shape\n    if h < 2 or w < 3:\n        return 0.0\n    middle_strip = image[:, w//3:2*w//3]\n    grad_y = np.gradient(middle_strip, axis=0)\n    return float(np.mean(np.abs(grad_y)))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Standard deviation of row-wise pixel intensities in middle third\"\n    h, w = image.shape\n    if h < 3:\n        return 0.0\n    middle_third = image[h//3:2*h//3, :]\n    row_means = np.mean(middle_third, axis=1)\n    return float(np.std(row_means))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Average vertical gradient magnitude in the middle vertical strip\"\n    h, w = image.shape\n    if h < 2 or w < 3:\n        return 0.0\n    middle_strip = image[:, w//3:2*w//3]\n    grad_y = np.gradient(middle_strip, axis=0)\n    return float(np.mean(np.abs(grad_y)))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Number of distinct enclosed loops or holes in the image\"\n    h, w = image.shape\n    if h == 0 or w == 0:\n        return 0.0\n    \n    # Create binary image\n    binary = (image > np.mean(image)).astype(int)\n    visited = np.zeros_like(binary)\n    holes = 0\n    \n    for i in range(1, h-1):\n        for j in range(1, w-1):\n            if binary[i, j] == 0 and visited[i, j] == 0:\n                # Check if this zero region is completely surrounded\n                stack = [(i, j)]\n                region = []\n                is_hole = True\n                \n                while stack and len(region) < 100:  # Limit to avoid infinite loops\n                    y, x = stack.pop()\n                    if y < 0 or y >= h or x < 0 or x >= w or visited[y, x]:\n                        continue\n                    if binary[y, x] == 1:\n                        continue\n                    if y == 0 or y == h-1 or x == 0 or x == w-1:\n                        is_hole = False\n                    \n                    visited[y, x] = 1\n                    region.append((y, x))\n                    stack.extend([(y+1, x), (y-1, x), (y, x+1), (y, x-1)])\n                \n                if is_hole and len(region) > 3:\n                    holes += 1\n    \n    return float(holes)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of pixels in top half versus bottom half of image\"\n    h, w = image.shape\n    if h == 0:\n        return 0.0\n    top_half = np.sum(image[:h//2, :])\n    bottom_half = np.sum(image[h//2:, :])\n    if bottom_half == 0:\n        return float('inf') if top_half > 0 else 0.0\n    return float(top_half / bottom_half)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of maximum width in top half versus bottom half\"\n    h, w = image.shape\n    if h == 0:\n        return 1.0\n    top_half = image[:h//2, :]\n    bottom_half = image[h//2:, :]\n    \n    top_widths = [np.sum(row > 0) for row in top_half]\n    bottom_widths = [np.sum(row > 0) for row in bottom_half]\n    \n    max_top = max(top_widths) if top_widths else 0\n    max_bottom = max(bottom_widths) if bottom_widths else 0\n    \n    if max_bottom == 0:\n        return float(max_top > 0)\n    return float(max_top / max_bottom)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Thickness variation of the stroke measured at multiple vertical positions\"\n    h, w = image.shape\n    thicknesses = []\n    for row_idx in range(h//4, 3*h//4):\n        row = image[row_idx, :]\n        nonzero_indices = np.where(row > 0)[0]\n        if len(nonzero_indices) > 0:\n            thickness = nonzero_indices[-1] - nonzero_indices[0] + 1\n            thicknesses.append(thickness)\n    if len(thicknesses) < 2:\n        return 0.0\n    return float(np.std(thicknesses))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of pixels in curved regions versus straight regions\"\n    grad_y, grad_x = np.gradient(image)\n    gradient_magnitude = np.sqrt(grad_x**2 + grad_y**2)\n    high_gradient = gradient_magnitude > np.percentile(gradient_magnitude, 75)\n    if np.sum(high_gradient) == 0:\n        return 0.0\n    return float(np.sum(gradient_magnitude > np.percentile(gradient_magnitude, 85)) / max(1, np.sum(high_gradient)))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Intensity concentration in bottom-left quadrant\"\n    h, w = image.shape\n    bottom_left = image[h//2:, :w//2]\n    total_intensity = np.sum(image)\n    if total_intensity == 0:\n        return 0.0\n    bottom_left_intensity = np.sum(bottom_left)\n    return float(bottom_left_intensity / total_intensity)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of vertical edge strength to horizontal edge strength\"\n    if image.size == 0:\n        return 0.0\n    grad_y, grad_x = np.gradient(image)\n    vertical_strength = np.sum(np.abs(grad_x))\n    horizontal_strength = np.sum(np.abs(grad_y))\n    if horizontal_strength == 0:\n        return 1.0 if vertical_strength > 0 else 0.0\n    return float(vertical_strength / horizontal_strength)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Compactness of non-zero pixels measured by their spread from centroid\"\n    nonzero_coords = np.where(image > 0)\n    if len(nonzero_coords[0]) == 0:\n        return 0.0\n    centroid_y = np.mean(nonzero_coords[0])\n    centroid_x = np.mean(nonzero_coords[1])\n    distances = np.sqrt((nonzero_coords[0] - centroid_y)**2 + (nonzero_coords[1] - centroid_x)**2)\n    return float(np.std(distances))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Number of rows that contain non-zero pixels in both left and right halves\"\n    h, w = image.shape\n    if w < 2:\n        return 0.0\n    mid_col = w // 2\n    connected_rows = 0\n    for row in range(h):\n        left_has_pixels = np.any(image[row, :mid_col] > 0)\n        right_has_pixels = np.any(image[row, mid_col:] > 0)\n        if left_has_pixels and right_has_pixels:\n            connected_rows += 1\n    return float(connected_rows)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Maximum vertical position of any foreground pixel as ratio of image height\"\n    h, w = image.shape\n    if h == 0:\n        return 0.0\n    foreground_rows = np.where(np.any(image > 0, axis=1))[0]\n    if len(foreground_rows) == 0:\n        return 0.0\n    return float(np.max(foreground_rows) / h)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Count of vertical line segments in the left half of the image\"\n    h, w = image.shape\n    left_half = image[:, :w//2]\n    transitions = 0\n    for col in range(left_half.shape[1]):\n        column = left_half[:, col]\n        in_segment = False\n        segment_length = 0\n        for pixel in column:\n            if pixel > 0:\n                if not in_segment:\n                    in_segment = True\n                    segment_length = 1\n                else:\n                    segment_length += 1\n            else:\n                if in_segment and segment_length >= 3:\n                    transitions += 1\n                in_segment = False\n                segment_length = 0\n        if in_segment and segment_length >= 3:\n            transitions += 1\n    return float(transitions)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Number of distinct vertical segments with high pixel intensity in the rightmost quarter\"\n    h, w = image.shape\n    right_quarter = image[:, 3*w//4:]\n    if right_quarter.size == 0:\n        return 0.0\n    threshold = np.mean(image) + np.std(image)\n    high_intensity_mask = right_quarter > threshold\n    segments = 0\n    for col in range(right_quarter.shape[1]):\n        col_data = high_intensity_mask[:, col]\n        if np.any(col_data):\n            segments += 1\n    return float(segments)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Maximum row intensity in the bottom third of image\"\n    h, w = image.shape\n    if h == 0:\n        return 0.0\n    bottom_third = image[2*h//3:, :]\n    if bottom_third.size == 0:\n        return 0.0\n    row_sums = np.sum(bottom_third, axis=1)\n    return float(np.max(row_sums) if len(row_sums) > 0 else 0.0)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Average vertical distance of brightest pixels from image center\"\n    h, w = image.shape\n    center_y = h // 2\n    threshold = np.percentile(image, 85)\n    bright_pixels = np.where(image > threshold)\n    if len(bright_pixels[0]) == 0:\n        return float(0)\n    distances = np.abs(bright_pixels[0] - center_y)\n    return float(np.mean(distances))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of maximum width in top half versus bottom half\"\n    h, w = image.shape\n    if h == 0:\n        return 1.0\n    top_half = image[:h//2, :]\n    bottom_half = image[h//2:, :]\n    \n    top_widths = [np.sum(row > 0) for row in top_half]\n    bottom_widths = [np.sum(row > 0) for row in bottom_half]\n    \n    max_top = max(top_widths) if top_widths else 0\n    max_bottom = max(bottom_widths) if bottom_widths else 0\n    \n    if max_bottom == 0:\n        return float(max_top > 0)\n    return float(max_top / max_bottom)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Horizontal gradient strength in the middle third of image\"\n    h, w = image.shape\n    middle_third = image[h//3:2*h//3, :]\n    grad_y, grad_x = np.gradient(middle_third)\n    return float(np.mean(np.abs(grad_x)))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Fraction of image width occupied by non-zero pixels in the middle row\"\n    h, w = image.shape\n    if h == 0 or w == 0:\n        return 0.0\n    middle_row = image[h//2, :]\n    nonzero_cols = np.count_nonzero(middle_row)\n    return float(nonzero_cols / w)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Number of connected components in the middle vertical strip\"\n    h, w = image.shape\n    middle_strip = image[:, w//3:2*w//3]\n    binary = (middle_strip > middle_strip.mean()).astype(int)\n    transitions = 0\n    for col in range(binary.shape[1]):\n        column = binary[:, col]\n        transitions += np.sum(np.abs(np.diff(column)))\n    return float(transitions)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Average vertical gradient magnitude in the middle vertical strip\"\n    h, w = image.shape\n    if h < 2 or w < 3:\n        return 0.0\n    middle_strip = image[:, w//3:2*w//3]\n    grad_y = np.gradient(middle_strip, axis=0)\n    return float(np.mean(np.abs(grad_y)))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Coefficient of variation of row-wise pixel intensities\"\n    h, w = image.shape\n    if h == 0:\n        return 0.0\n    row_means = np.array([np.mean(image[i, :]) for i in range(h)])\n    mean_of_means = np.mean(row_means)\n    if mean_of_means == 0:\n        return 0.0\n    std_of_means = np.std(row_means)\n    return float(std_of_means / mean_of_means)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Count of vertical runs of consecutive non-zero pixels in the left half\"\n    h, w = image.shape\n    left_half = image[:, :w//2]\n    vertical_runs = 0\n    for col in range(left_half.shape[1]):\n        in_run = False\n        for row in range(left_half.shape[0]):\n            if left_half[row, col] > 0:\n                if not in_run:\n                    vertical_runs += 1\n                    in_run = True\n            else:\n                in_run = False\n    return float(vertical_runs)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Average vertical gradient magnitude in the center column\"\n    h, w = image.shape\n    if w == 0:\n        return 0.0\n    center_col = image[:, w//2]\n    if len(center_col) < 2:\n        return 0.0\n    gradients = np.abs(np.diff(center_col.astype(float)))\n    return float(np.mean(gradients))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Number of diagonal transitions from top-left to bottom-right\"\n    h, w = image.shape\n    if h < 2 or w < 2:\n        return 0.0\n    transitions = 0\n    min_dim = min(h, w)\n    for i in range(min_dim - 1):\n        if (image[i, i] > 0) != (image[i+1, i+1] > 0):\n            transitions += 1\n    return float(transitions)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of connected components in top-right quadrant to total non-zero pixels\"\n    h, w = image.shape\n    top_right = image[:h//2, w//2:]\n    if np.sum(top_right) == 0:\n        return 0.0\n    components = 0\n    visited = np.zeros_like(top_right, dtype=bool)\n    for i in range(top_right.shape[0]):\n        for j in range(top_right.shape[1]):\n            if top_right[i, j] > 0 and not visited[i, j]:\n                components += 1\n                stack = [(i, j)]\n                while stack:\n                    x, y = stack.pop()\n                    if x >= 0 and x < top_right.shape[0] and y >= 0 and y < top_right.shape[1] and not visited[x, y] and top_right[x, y] > 0:\n                        visited[x, y] = True\n                        stack.extend([(x+1, y), (x-1, y), (x, y+1), (x, y-1)])\n    return float(components / np.count_nonzero(top_right))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of connected components in top-right quadrant to total non-zero pixels\"\n    h, w = image.shape\n    top_right = image[:h//2, w//2:]\n    if np.sum(top_right) == 0:\n        return 0.0\n    components = 0\n    visited = np.zeros_like(top_right, dtype=bool)\n    for i in range(top_right.shape[0]):\n        for j in range(top_right.shape[1]):\n            if top_right[i, j] > 0 and not visited[i, j]:\n                components += 1\n                stack = [(i, j)]\n                while stack:\n                    x, y = stack.pop()\n                    if x >= 0 and x < top_right.shape[0] and y >= 0 and y < top_right.shape[1] and not visited[x, y] and top_right[x, y] > 0:\n                        visited[x, y] = True\n                        stack.extend([(x+1, y), (x-1, y), (x, y+1), (x, y-1)])\n    return float(components / np.count_nonzero(top_right))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Percentage of image rows that contain at least one non-zero pixel\"\n    if image.shape[0] == 0:\n        return 0.0\n    non_empty_rows = np.sum(np.any(image > 0, axis=1))\n    return float(non_empty_rows / image.shape[0])\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Number of distinct horizontal segments with intensity above median in upper third\"\n    h, w = image.shape\n    upper_third = image[:h//3, :]\n    if upper_third.size == 0:\n        return 0.0\n    median_val = np.median(upper_third)\n    segments = 0\n    for row in upper_third:\n        in_segment = False\n        for pixel in row:\n            if pixel > median_val and not in_segment:\n                segments += 1\n                in_segment = True\n            elif pixel <= median_val:\n                in_segment = False\n    return float(segments)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Maximum consecutive foreground pixels in any diagonal direction\"\n    h, w = image.shape\n    if h == 0 or w == 0:\n        return 0.0\n    \n    threshold = np.mean(image)\n    max_diagonal = 0\n    \n    # Check main diagonals\n    for start_row in range(h):\n        # Down-right diagonal\n        count = 0\n        max_count = 0\n        r, c = start_row, 0\n        while r < h and c < w:\n            if image[r, c] > threshold:\n                count += 1\n                max_count = max(max_count, count)\n            else:\n                count = 0\n            r += 1\n            c += 1\n        max_diagonal = max(max_diagonal, max_count)\n    \n    return float(max_diagonal)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Maximum vertical position of any foreground pixel as ratio of image height\"\n    h, w = image.shape\n    if h == 0:\n        return 0.0\n    foreground_rows = np.where(np.any(image > 0, axis=1))[0]\n    if len(foreground_rows) == 0:\n        return 0.0\n    return float(np.max(foreground_rows) / h)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Vertical gradient magnitude in the middle-right region\"\n    h, w = image.shape\n    middle_right = image[h//4:3*h//4, w//2:]\n    if middle_right.size == 0:\n        return 0.0\n    grad_y = np.gradient(middle_right, axis=0)\n    return float(np.mean(np.abs(grad_y)))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Average distance of bright pixels from the center of mass\"\n    h, w = image.shape\n    threshold = np.mean(image) * 0.8\n    bright_pixels = np.where(image > threshold)\n    if len(bright_pixels[0]) == 0:\n        return 0.0\n    \n    center_y = np.mean(bright_pixels[0])\n    center_x = np.mean(bright_pixels[1])\n    \n    distances = np.sqrt((bright_pixels[0] - center_y) ** 2 + (bright_pixels[1] - center_x) ** 2)\n    return float(np.mean(distances))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of maximum width in top half versus bottom half\"\n    h, w = image.shape\n    if h == 0:\n        return 1.0\n    top_half = image[:h//2, :]\n    bottom_half = image[h//2:, :]\n    \n    top_widths = [np.sum(row > 0) for row in top_half]\n    bottom_widths = [np.sum(row > 0) for row in bottom_half]\n    \n    max_top = max(top_widths) if top_widths else 0\n    max_bottom = max(bottom_widths) if bottom_widths else 0\n    \n    if max_bottom == 0:\n        return float(max_top > 0)\n    return float(max_top / max_bottom)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Maximum row intensity in the bottom third of image\"\n    h, w = image.shape\n    if h == 0:\n        return 0.0\n    bottom_third = image[2*h//3:, :]\n    if bottom_third.size == 0:\n        return 0.0\n    row_sums = np.sum(bottom_third, axis=1)\n    return float(np.max(row_sums) if len(row_sums) > 0 else 0.0)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Average width of non-zero regions per row in bottom half\"\n    h, w = image.shape\n    bottom_half = image[h//2:, :]\n    total_width = 0\n    valid_rows = 0\n    for row in bottom_half:\n        nonzero_indices = np.where(row > 0)[0]\n        if len(nonzero_indices) > 0:\n            width = nonzero_indices[-1] - nonzero_indices[0] + 1\n            total_width += width\n            valid_rows += 1\n    return float(total_width / valid_rows if valid_rows > 0 else 0)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Number of enclosed regions or loops in the image\"\n    from scipy import ndimage\n    if image.size == 0:\n        return 0.0\n    binary = image > np.mean(image)\n    filled = ndimage.binary_fill_holes(binary)\n    loops = np.sum(filled) - np.sum(binary)\n    return float(loops)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of pixel intensity in the upper third versus middle third of image\"\n    h, w = image.shape\n    upper_third = image[:h//3, :]\n    middle_third = image[h//3:2*h//3, :]\n    upper_mean = np.mean(upper_third)\n    middle_mean = np.mean(middle_third)\n    if middle_mean == 0:\n        return 0.0\n    return float(upper_mean / middle_mean)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of pixel intensity variance in top quarter to bottom quarter\"\n    h, w = image.shape\n    top_quarter = image[:h//4, :]\n    bottom_quarter = image[3*h//4:, :]\n    top_var = np.var(top_quarter) if top_quarter.size > 0 else 0.0\n    bottom_var = np.var(bottom_quarter) if bottom_quarter.size > 0 else 0.0\n    if bottom_var == 0:\n        return float(top_var)\n    return float(top_var / bottom_var)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of maximum to minimum row intensity in the middle third of image\"\n    h, w = image.shape\n    middle_third = image[h//3:2*h//3, :]\n    if middle_third.size == 0:\n        return 1.0\n    row_sums = np.sum(middle_third, axis=1)\n    if len(row_sums) == 0:\n        return 1.0\n    max_row = np.max(row_sums)\n    min_row = np.min(row_sums)\n    if min_row == 0:\n        return float(max_row) if max_row > 0 else 1.0\n    return float(max_row / min_row)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of pixel sum in bottom-right quadrant to total pixel sum\"\n    h, w = image.shape\n    if h < 2 or w < 2:\n        return 0.0\n    bottom_right = image[h//2:, w//2:]\n    total_sum = np.sum(image)\n    if total_sum == 0:\n        return 0.0\n    return float(np.sum(bottom_right) / total_sum)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Number of horizontal line segments in the middle region\"\n    h, w = image.shape\n    middle_region = image[h//3:2*h//3, :]\n    threshold = np.mean(middle_region) if np.mean(middle_region) > 0 else 0.1\n    binary = (middle_region > threshold).astype(int)\n    horizontal_lines = 0\n    for row in binary:\n        in_segment = False\n        for pixel in row:\n            if pixel > 0 and not in_segment:\n                horizontal_lines += 1\n                in_segment = True\n            elif pixel == 0:\n                in_segment = False\n    return float(horizontal_lines)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Average vertical distance of non-zero pixels from image center\"\n    h, w = image.shape\n    if h == 0:\n        return 0.0\n    center_y = h // 2\n    total_distance = 0.0\n    pixel_count = 0\n    for y in range(h):\n        for x in range(w):\n            if image[y, x] > 0:\n                total_distance += abs(y - center_y)\n                pixel_count += 1\n    if pixel_count == 0:\n        return 0.0\n    return total_distance / pixel_count\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Maximum vertical position of any foreground pixel as ratio of image height\"\n    h, w = image.shape\n    if h == 0:\n        return 0.0\n    foreground_rows = np.where(np.any(image > 0, axis=1))[0]\n    if len(foreground_rows) == 0:\n        return 0.0\n    return float(np.max(foreground_rows) / h)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Number of connected components in the right half of the image\"\n    h, w = image.shape\n    right_half = image[:, w//2:]\n    binary = (right_half > np.mean(right_half)).astype(int)\n    components = 0\n    visited = np.zeros_like(binary)\n    \n    def flood_fill(y, x):\n        if y < 0 or y >= h or x < 0 or x >= w//2 or visited[y, x] or binary[y, x] == 0:\n            return\n        visited[y, x] = 1\n        for dy, dx in [(0,1), (1,0), (0,-1), (-1,0)]:\n            flood_fill(y + dy, x + dx)\n    \n    for i in range(h):\n        for j in range(w//2):\n            if binary[i, j] and not visited[i, j]:\n                flood_fill(i, j)\n                components += 1\n    return float(components)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Coefficient of variation of row-wise pixel intensities\"\n    h, w = image.shape\n    if h == 0:\n        return 0.0\n    row_means = np.array([np.mean(image[i, :]) for i in range(h)])\n    mean_of_means = np.mean(row_means)\n    if mean_of_means == 0:\n        return 0.0\n    std_of_means = np.std(row_means)\n    return float(std_of_means / mean_of_means)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Intensity concentration in the center 3x3 region relative to total\"\n    h, w = image.shape\n    if h < 3 or w < 3:\n        return 0.0\n    center_h, center_w = h//2, w//2\n    center_3x3 = image[center_h-1:center_h+2, center_w-1:center_w+2]\n    center_sum = np.sum(center_3x3)\n    total_sum = np.sum(image)\n    if total_sum == 0:\n        return 0.0\n    return float(center_sum / total_sum)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Skewness of horizontal distribution of non-zero pixels\"\n    h, w = image.shape\n    if w == 0:\n        return 0.0\n    col_sums = np.sum(image, axis=0)\n    non_zero_cols = np.nonzero(col_sums)[0]\n    if len(non_zero_cols) < 3:\n        return 0.0\n    weights = col_sums[non_zero_cols]\n    positions = non_zero_cols\n    mean_pos = np.average(positions, weights=weights)\n    variance = np.average((positions - mean_pos)**2, weights=weights)\n    if variance == 0:\n        return 0.0\n    skewness = np.average((positions - mean_pos)**3, weights=weights) / (variance**1.5)\n    return float(skewness)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of maximum to minimum row intensity in the middle third of image\"\n    h, w = image.shape\n    middle_third = image[h//3:2*h//3, :]\n    if middle_third.size == 0:\n        return 1.0\n    row_sums = np.sum(middle_third, axis=1)\n    if len(row_sums) == 0:\n        return 1.0\n    max_row = np.max(row_sums)\n    min_row = np.min(row_sums)\n    if min_row == 0:\n        return float(max_row) if max_row > 0 else 1.0\n    return float(max_row / min_row)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Average width of non-zero regions per row in bottom half\"\n    h, w = image.shape\n    bottom_half = image[h//2:, :]\n    total_width = 0\n    valid_rows = 0\n    for row in bottom_half:\n        nonzero_indices = np.where(row > 0)[0]\n        if len(nonzero_indices) > 0:\n            width = nonzero_indices[-1] - nonzero_indices[0] + 1\n            total_width += width\n            valid_rows += 1\n    return float(total_width / valid_rows if valid_rows > 0 else 0)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of horizontal edge strength in middle rows to edge strength in outer rows\"\n    h, w = image.shape\n    if h < 6:\n        return 0.0\n    gradients = np.abs(np.gradient(image, axis=1))\n    middle_third = gradients[h//3:2*h//3, :]\n    outer_thirds = np.concatenate([gradients[:h//3, :], gradients[2*h//3:, :]])\n    middle_strength = np.mean(middle_third) if middle_third.size > 0 else 0.0\n    outer_strength = np.mean(outer_thirds) if outer_thirds.size > 0 else 0.0\n    return middle_strength / (outer_strength + 1e-6)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Maximum vertical position of any foreground pixel as ratio of image height\"\n    h, w = image.shape\n    if h == 0:\n        return 0.0\n    foreground_rows = np.where(np.any(image > 0, axis=1))[0]\n    if len(foreground_rows) == 0:\n        return 0.0\n    return float(np.max(foreground_rows) / h)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Width of the narrowest horizontal cross-section in the middle vertical region\"\n    h, w = image.shape\n    if h == 0:\n        return 0.0\n    middle_start, middle_end = h // 3, 2 * h // 3\n    min_width = w\n    for row in range(middle_start, middle_end):\n        non_zero_cols = np.where(image[row, :] > 0)[0]\n        if len(non_zero_cols) > 0:\n            width = non_zero_cols[-1] - non_zero_cols[0] + 1\n            min_width = min(min_width, width)\n    return float(min_width / w if w > 0 else 0.0)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Vertical density gradient from center to bottom of image\"\n    h, w = image.shape\n    if h < 4:\n        return 0.0\n    center_strip = image[h//2:3*h//4, :]\n    bottom_strip = image[3*h//4:, :]\n    center_density = np.mean(center_strip) if center_strip.size > 0 else 0.0\n    bottom_density = np.mean(bottom_strip) if bottom_strip.size > 0 else 0.0\n    return float(bottom_density - center_density)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Average intensity in the bottom quarter of the image\"\n    h, w = image.shape\n    bottom_quarter = image[3*h//4:, :]\n    return float(np.mean(bottom_quarter))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Average vertical gradient magnitude in the middle vertical strip\"\n    h, w = image.shape\n    if h < 2 or w < 3:\n        return 0.0\n    middle_strip = image[:, w//3:2*w//3]\n    grad_y = np.gradient(middle_strip, axis=0)\n    return float(np.mean(np.abs(grad_y)))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of non-zero pixels in diagonal strips versus anti-diagonal strips\"\n    h, w = image.shape\n    diag_count = 0\n    anti_diag_count = 0\n    total_pixels = 0\n    \n    for i in range(h):\n        for j in range(w):\n            if abs(i - j) <= min(h, w) // 4:  # Main diagonal strip\n                if image[i, j] > 0:\n                    diag_count += 1\n                total_pixels += 1\n            elif abs(i + j - (h-1)) <= min(h, w) // 4:  # Anti-diagonal strip\n                if image[i, j] > 0:\n                    anti_diag_count += 1\n                total_pixels += 1\n    \n    if anti_diag_count == 0:\n        return float(diag_count)\n    return float(diag_count / anti_diag_count)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Density of pixels in the upper-middle region relative to total foreground\"\n    h, w = image.shape\n    if h == 0 or w == 0:\n        return 0.0\n    \n    total_foreground = np.count_nonzero(image > np.mean(image))\n    if total_foreground == 0:\n        return 0.0\n    \n    # Upper-middle region\n    upper_mid = image[h//6:h//2, w//4:3*w//4]\n    upper_mid_pixels = np.count_nonzero(upper_mid > np.mean(image))\n    \n    return float(upper_mid_pixels / total_foreground)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Thickness variation of the stroke measured at multiple vertical positions\"\n    h, w = image.shape\n    thicknesses = []\n    for row_idx in range(h//4, 3*h//4):\n        row = image[row_idx, :]\n        nonzero_indices = np.where(row > 0)[0]\n        if len(nonzero_indices) > 0:\n            thickness = nonzero_indices[-1] - nonzero_indices[0] + 1\n            thicknesses.append(thickness)\n    if len(thicknesses) < 2:\n        return 0.0\n    return float(np.std(thicknesses))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of non-zero pixels in left half versus right half of image\"\n    h, w = image.shape\n    if w == 0:\n        return 0.0\n    left_half = image[:, :w//2]\n    right_half = image[:, w//2:]\n    left_count = np.count_nonzero(left_half)\n    right_count = np.count_nonzero(right_half)\n    if right_count == 0:\n        return 1.0 if left_count > 0 else 0.0\n    return float(left_count / right_count)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Standard deviation of row sums in the bottom half of image\"\n    h, w = image.shape\n    bottom_half = image[h//2:, :]\n    row_sums = np.sum(bottom_half, axis=1)\n    return float(np.std(row_sums))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of pixels in top-left quadrant versus bottom-right quadrant\"\n    h, w = image.shape\n    top_left = image[:h//2, :w//2]\n    bottom_right = image[h//2:, w//2:]\n    top_left_count = np.count_nonzero(top_left)\n    bottom_right_count = np.count_nonzero(bottom_right)\n    if bottom_right_count == 0:\n        return float(top_left_count)\n    return float(top_left_count / bottom_right_count)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Thickness variation of the stroke measured at multiple vertical positions\"\n    h, w = image.shape\n    thicknesses = []\n    for row_idx in range(h//4, 3*h//4):\n        row = image[row_idx, :]\n        nonzero_indices = np.where(row > 0)[0]\n        if len(nonzero_indices) > 0:\n            thickness = nonzero_indices[-1] - nonzero_indices[0] + 1\n            thicknesses.append(thickness)\n    if len(thicknesses) < 2:\n        return 0.0\n    return float(np.std(thicknesses))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of pixels in top half versus bottom half of image\"\n    h, w = image.shape\n    if h == 0:\n        return 0.0\n    top_half = np.sum(image[:h//2, :])\n    bottom_half = np.sum(image[h//2:, :])\n    if bottom_half == 0:\n        return float('inf') if top_half > 0 else 0.0\n    return float(top_half / bottom_half)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of pixel intensity in bottom third to middle third\"\n    h, w = image.shape\n    if h < 3:\n        return 0.0\n    middle_third = image[h//3:2*h//3, :]\n    bottom_third = image[2*h//3:, :]\n    middle_sum = np.sum(middle_third)\n    bottom_sum = np.sum(bottom_third)\n    if middle_sum == 0:\n        return 0.0\n    return float(bottom_sum / middle_sum)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Average intensity in the middle horizontal strip of the image\"\n    h, w = image.shape\n    middle_strip = image[h//3:2*h//3, :]\n    return float(np.mean(middle_strip))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Number of vertical runs of consecutive non-zero pixels in middle columns\"\n    h, w = image.shape\n    if w < 3:\n        return 0.0\n    middle_cols = image[:, w//3:2*w//3]\n    runs = 0\n    for col in range(middle_cols.shape[1]):\n        column = middle_cols[:, col]\n        in_run = False\n        for pixel in column:\n            if pixel > 0 and not in_run:\n                runs += 1\n                in_run = True\n            elif pixel == 0:\n                in_run = False\n    return float(runs)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Average pixel intensity in diagonal stripe from top-left to bottom-right\"\n    h, w = image.shape\n    if h == 0 or w == 0:\n        return 0.0\n    diagonal_pixels = []\n    for i in range(min(h, w)):\n        diagonal_pixels.append(image[i, i])\n    return float(np.mean(diagonal_pixels))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of non-zero pixels in top quarter versus center half vertically\"\n    h, w = image.shape\n    if h < 4:\n        return 0.0\n    top_quarter = image[:h//4, :]\n    center_half = image[h//4:3*h//4, :]\n    top_nonzero = np.count_nonzero(top_quarter)\n    center_nonzero = np.count_nonzero(center_half)\n    if center_nonzero == 0:\n        return float(top_nonzero)\n    return float(top_nonzero / center_nonzero)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Diagonal edge strength from top-left to bottom-right\"\n    h, w = image.shape\n    diagonal_sum = 0.0\n    count = 0\n    for i in range(min(h-1, w-1)):\n        if i+1 < h and i+1 < w:\n            diagonal_sum += abs(float(image[i+1, i+1]) - float(image[i, i]))\n            count += 1\n    return float(diagonal_sum / count) if count > 0 else 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Number of vertical runs of consecutive non-zero pixels\"\n    h, w = image.shape\n    runs = 0\n    for col in range(w):\n        in_run = False\n        for row in range(h):\n            if image[row, col] > 0:\n                if not in_run:\n                    runs += 1\n                    in_run = True\n            else:\n                in_run = False\n    return float(runs)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of pixels in top-left quadrant versus bottom-right quadrant\"\n    h, w = image.shape\n    top_left = image[:h//2, :w//2]\n    bottom_right = image[h//2:, w//2:]\n    top_left_count = np.count_nonzero(top_left)\n    bottom_right_count = np.count_nonzero(bottom_right)\n    if bottom_right_count == 0:\n        return float(top_left_count)\n    return float(top_left_count / bottom_right_count)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Horizontal symmetry score of the middle third region\"\n    h, w = image.shape\n    if h == 0 or w == 0:\n        return 0.0\n    \n    middle_start, middle_end = h // 3, 2 * h // 3\n    middle_region = image[middle_start:middle_end, :]\n    \n    if middle_region.shape[1] <= 1:\n        return 1.0\n    \n    left_half = middle_region[:, :w//2]\n    right_half = middle_region[:, w//2:]\n    right_flipped = np.fliplr(right_half)\n    \n    min_width = min(left_half.shape[1], right_flipped.shape[1])\n    if min_width == 0:\n        return 0.0\n    \n    left_crop = left_half[:, -min_width:]\n    right_crop = right_flipped[:, :min_width]\n    \n    diff = np.abs(left_crop - right_crop)\n    max_possible_diff = np.abs(left_crop).max() + np.abs(right_crop).max()\n    \n    if max_possible_diff == 0:\n        return 1.0\n    \n    return float(1.0 - np.mean(diff) / max_possible_diff)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Vertical extent of non-zero pixels as fraction of image height\"\n    if image.size == 0:\n        return 0.0\n    nonzero_rows = np.any(image > np.mean(image), axis=1)\n    if not np.any(nonzero_rows):\n        return 0.0\n    first_row = np.argmax(nonzero_rows)\n    last_row = len(nonzero_rows) - 1 - np.argmax(nonzero_rows[::-1])\n    return float((last_row - first_row + 1) / image.shape[0])\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Average vertical gradient magnitude in the middle vertical strip\"\n    h, w = image.shape\n    if h < 2 or w < 3:\n        return 0.0\n    middle_strip = image[:, w//3:2*w//3]\n    grad_y = np.gradient(middle_strip, axis=0)\n    return float(np.mean(np.abs(grad_y)))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Count of diagonal transitions from zero to non-zero pixels (top-left to bottom-right)\"\n    h, w = image.shape\n    transitions = 0\n    for i in range(min(h-1, w-1)):\n        for offset in range(max(0, -i), min(h-i, w)):\n            row, col = i + offset, offset\n            if row < h-1 and col < w-1:\n                if image[row, col] == 0 and image[row+1, col+1] > 0:\n                    transitions += 1\n    return float(transitions)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Number of enclosed circular regions or loops in the image\"\n    h, w = image.shape\n    if h == 0 or w == 0:\n        return 0.0\n    \n    # Create binary image\n    binary = (image > np.mean(image)).astype(int)\n    \n    # Count enclosed regions by looking for transitions\n    loops = 0\n    center_h, center_w = h // 2, w // 2\n    \n    # Check multiple radial scans from center\n    for angle in np.linspace(0, 2*np.pi, 16):\n        transitions = 0\n        prev_val = 0\n        for r in range(1, min(center_h, center_w)):\n            y = int(center_h + r * np.sin(angle))\n            x = int(center_w + r * np.cos(angle))\n            if 0 <= y < h and 0 <= x < w:\n                if binary[y, x] != prev_val:\n                    transitions += 1\n                prev_val = binary[y, x]\n        if transitions >= 4:  # Likely indicates a loop\n            loops += 1\n    \n    return float(loops)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Vertical symmetry score - correlation between left and right halves\"\n    h, w = image.shape\n    if w < 2:\n        return 0.0\n    left_half = image[:, :w//2]\n    right_half = np.fliplr(image[:, w//2:])\n    min_width = min(left_half.shape[1], right_half.shape[1])\n    left_resized = left_half[:, :min_width].flatten()\n    right_resized = right_half[:, :min_width].flatten()\n    if len(left_resized) == 0 or np.std(left_resized) == 0 or np.std(right_resized) == 0:\n        return 0.0\n    correlation = np.corrcoef(left_resized, right_resized)[0, 1]\n    return float(correlation if not np.isnan(correlation) else 0.0)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Count of horizontal runs of consecutive non-zero pixels in the upper half\"\n    h, w = image.shape\n    if h < 2:\n        return 0.0\n    upper_half = image[:h//2, :]\n    run_count = 0\n    for row in upper_half:\n        in_run = False\n        for pixel in row:\n            if pixel > 0 and not in_run:\n                run_count += 1\n                in_run = True\n            elif pixel == 0:\n                in_run = False\n    return float(run_count)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Width of the narrowest horizontal cross-section in the middle vertical region\"\n    h, w = image.shape\n    if h == 0:\n        return 0.0\n    middle_start, middle_end = h // 3, 2 * h // 3\n    min_width = w\n    for row in range(middle_start, middle_end):\n        non_zero_cols = np.where(image[row, :] > 0)[0]\n        if len(non_zero_cols) > 0:\n            width = non_zero_cols[-1] - non_zero_cols[0] + 1\n            min_width = min(min_width, width)\n    return float(min_width / w if w > 0 else 0.0)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Number of vertical runs of consecutive non-zero pixels in middle columns\"\n    h, w = image.shape\n    if w < 3:\n        return 0.0\n    middle_cols = image[:, w//3:2*w//3]\n    runs = 0\n    for col in range(middle_cols.shape[1]):\n        column = middle_cols[:, col]\n        in_run = False\n        for pixel in column:\n            if pixel > 0 and not in_run:\n                runs += 1\n                in_run = True\n            elif pixel == 0:\n                in_run = False\n    return float(runs)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Vertical extent of the topmost significant pixel cluster\"\n    h, w = image.shape\n    top_quarter = image[:h//4, :]\n    if top_quarter.size == 0:\n        return 0.0\n    nonzero_rows = np.where(np.sum(top_quarter, axis=1) > 0)[0]\n    if len(nonzero_rows) == 0:\n        return 0.0\n    vertical_extent = len(nonzero_rows)\n    return float(vertical_extent / max(h//4, 1))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Standard deviation of pixel intensities in the center column\"\n    h, w = image.shape\n    center_col = image[:, w//2]\n    if center_col.size == 0:\n        return 0.0\n    return float(np.std(center_col))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of vertical edge strength to horizontal edge strength\"\n    if image.size == 0:\n        return 0.0\n    grad_y, grad_x = np.gradient(image)\n    vertical_strength = np.sum(np.abs(grad_x))\n    horizontal_strength = np.sum(np.abs(grad_y))\n    if horizontal_strength == 0:\n        return 1.0 if vertical_strength > 0 else 0.0\n    return float(vertical_strength / horizontal_strength)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Intensity variance in the upper middle region\"\n    h, w = image.shape\n    upper_middle = image[:h//3, w//4:3*w//4]\n    if upper_middle.size == 0:\n        return 0.0\n    return float(np.var(upper_middle))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Fraction of image width occupied by non-zero pixels in the middle row\"\n    h, w = image.shape\n    if h == 0 or w == 0:\n        return 0.0\n    middle_row = image[h//2, :]\n    nonzero_cols = np.count_nonzero(middle_row)\n    return float(nonzero_cols / w)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Maximum row intensity in the bottom third of image\"\n    h, w = image.shape\n    if h == 0:\n        return 0.0\n    bottom_third = image[2*h//3:, :]\n    if bottom_third.size == 0:\n        return 0.0\n    row_sums = np.sum(bottom_third, axis=1)\n    return float(np.max(row_sums) if len(row_sums) > 0 else 0.0)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Presence of thick vertical stroke in center region\"\n    h, w = image.shape\n    center = image[h//4:3*h//4, w//3:2*w//3]\n    if center.size == 0:\n        return 0.0\n    threshold = center.mean() + center.std()\n    thick_pixels = np.sum(center > threshold)\n    return float(thick_pixels / center.size)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of curved versus straight edge pixels using gradient direction changes\"\n    grad_y, grad_x = np.gradient(image)\n    magnitude = np.sqrt(grad_x**2 + grad_y**2)\n    edge_threshold = np.percentile(magnitude, 75)\n    edge_mask = magnitude > edge_threshold\n    if np.sum(edge_mask) == 0:\n        return 0.0\n    angles = np.arctan2(grad_y, grad_x)\n    angle_changes = np.abs(np.diff(angles[edge_mask]))\n    curved_pixels = np.sum(angle_changes > np.pi/4)\n    total_edge_pixels = np.sum(edge_mask)\n    return float(curved_pixels / max(total_edge_pixels, 1))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of pixels in top half versus bottom half of image\"\n    h, w = image.shape\n    if h == 0:\n        return 0.0\n    top_half = np.sum(image[:h//2, :])\n    bottom_half = np.sum(image[h//2:, :])\n    if bottom_half == 0:\n        return float('inf') if top_half > 0 else 0.0\n    return float(top_half / bottom_half)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Intensity concentration in the upper-left quadrant\"\n    h, w = image.shape\n    upper_left = image[:h//2, :w//2]\n    total_intensity = np.sum(image)\n    if total_intensity == 0:\n        return 0.0\n    upper_left_intensity = np.sum(upper_left)\n    return float(upper_left_intensity / total_intensity)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Vertical asymmetry score between left and right halves\"\n    h, w = image.shape\n    left_half = image[:, :w//2]\n    right_half = image[:, w//2:]\n    min_width = min(left_half.shape[1], right_half.shape[1])\n    left_profile = np.sum(left_half[:, :min_width], axis=1)\n    right_profile = np.sum(right_half[:, :min_width], axis=1)\n    if np.sum(left_profile) + np.sum(right_profile) == 0:\n        return 0.0\n    return float(np.sum(np.abs(left_profile - right_profile)) / (np.sum(left_profile) + np.sum(right_profile)))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of top-left quadrant intensity to top-right quadrant intensity\"\n    h, w = image.shape\n    top_left = image[:h//2, :w//2]\n    top_right = image[:h//2, w//2:]\n    tl_mean = np.mean(top_left) if top_left.size > 0 else 0.0\n    tr_mean = np.mean(top_right) if top_right.size > 0 else 0.0\n    if tr_mean == 0:\n        return float(10.0 if tl_mean > 0 else 1.0)\n    return float(tl_mean / tr_mean)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Compactness measure: ratio of filled area to bounding box area\"\n    h, w = image.shape\n    if h == 0 or w == 0:\n        return 0.0\n    \n    # Find bounding box of non-zero pixels\n    nonzero_rows, nonzero_cols = np.where(image > np.mean(image))\n    \n    if len(nonzero_rows) == 0:\n        return 0.0\n    \n    min_row, max_row = np.min(nonzero_rows), np.max(nonzero_rows)\n    min_col, max_col = np.min(nonzero_cols), np.max(nonzero_cols)\n    \n    bounding_area = (max_row - min_row + 1) * (max_col - min_col + 1)\n    filled_area = len(nonzero_rows)\n    \n    return float(filled_area / bounding_area) if bounding_area > 0 else 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of pixels in top half versus bottom half of image\"\n    h, w = image.shape\n    if h == 0:\n        return 0.0\n    top_half = np.sum(image[:h//2, :])\n    bottom_half = np.sum(image[h//2:, :])\n    if bottom_half == 0:\n        return float('inf') if top_half > 0 else 0.0\n    return float(top_half / bottom_half)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Concentration of pixels in diagonal directions from center\"\n    h, w = image.shape\n    center_y, center_x = h // 2, w // 2\n    diagonal_sum = 0\n    count = 0\n    for i in range(h):\n        for j in range(w):\n            if abs(i - center_y) == abs(j - center_x):\n                diagonal_sum += image[i, j]\n                count += 1\n    return float(diagonal_sum / count if count > 0 else 0)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of pixels in top half versus bottom half of image\"\n    h, w = image.shape\n    if h == 0:\n        return 0.0\n    top_half = np.sum(image[:h//2, :])\n    bottom_half = np.sum(image[h//2:, :])\n    if bottom_half == 0:\n        return float('inf') if top_half > 0 else 0.0\n    return float(top_half / bottom_half)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Average gradient magnitude in the horizontal direction\"\n    if image.shape[1] < 2:\n        return 0.0\n    grad_y, grad_x = np.gradient(image)\n    return float(np.mean(np.abs(grad_x)))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Intensity concentration in the middle-right region of the image\"\n    h, w = image.shape\n    if h == 0 or w == 0:\n        return 0.0\n    mid_right = image[h//4:3*h//4, 2*w//3:]\n    if mid_right.size == 0:\n        return 0.0\n    return float(np.mean(mid_right) / (np.mean(image) + 1e-8))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of pixel density in bottom quarter versus middle quarter of image\"\n    h, w = image.shape\n    if h < 4:\n        return 0.0\n    bottom_quarter = image[3*h//4:, :]\n    middle_quarter = image[h//4:h//2, :]\n    bottom_density = np.count_nonzero(bottom_quarter) / (bottom_quarter.size + 1e-8)\n    middle_density = np.count_nonzero(middle_quarter) / (middle_quarter.size + 1e-8)\n    return float(bottom_density / (middle_density + 1e-8))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of non-zero pixels in middle third versus outer thirds vertically\"\n    h, w = image.shape\n    third = h // 3\n    middle_third = image[third:2*third, :]\n    outer_thirds = np.concatenate([image[:third, :].flatten(), image[2*third:, :].flatten()])\n    middle_nonzero = np.count_nonzero(middle_third)\n    outer_nonzero = np.count_nonzero(outer_thirds)\n    if outer_nonzero == 0:\n        return 0.0\n    return float(middle_nonzero / outer_nonzero)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of curved versus straight edge pixels using gradient direction changes\"\n    grad_y, grad_x = np.gradient(image)\n    magnitude = np.sqrt(grad_x**2 + grad_y**2)\n    edge_threshold = np.percentile(magnitude, 75)\n    edge_mask = magnitude > edge_threshold\n    if np.sum(edge_mask) == 0:\n        return 0.0\n    angles = np.arctan2(grad_y, grad_x)\n    angle_changes = np.abs(np.diff(angles[edge_mask]))\n    curved_pixels = np.sum(angle_changes > np.pi/4)\n    total_edge_pixels = np.sum(edge_mask)\n    return float(curved_pixels / max(total_edge_pixels, 1))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Maximum horizontal gap between non-zero pixels in center row\"\n    h, w = image.shape\n    center_row = image[h//2, :]\n    nonzero_indices = np.where(center_row > 0)[0]\n    if len(nonzero_indices) <= 1:\n        return 0.0\n    max_gap = 0\n    for i in range(1, len(nonzero_indices)):\n        gap = nonzero_indices[i] - nonzero_indices[i-1] - 1\n        max_gap = max(max_gap, gap)\n    return float(max_gap)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Coefficient of variation of row-wise pixel intensities\"\n    h, w = image.shape\n    if h == 0:\n        return 0.0\n    row_means = np.array([np.mean(image[i, :]) for i in range(h)])\n    mean_of_means = np.mean(row_means)\n    if mean_of_means == 0:\n        return 0.0\n    std_of_means = np.std(row_means)\n    return float(std_of_means / mean_of_means)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Number of distinct vertical segments in the left third\"\n    h, w = image.shape\n    left_third = image[:, :w//3]\n    vertical_segments = 0\n    for col in range(left_third.shape[1]):\n        column = left_third[:, col]\n        in_segment = False\n        for pixel in column:\n            if pixel > 0:\n                if not in_segment:\n                    vertical_segments += 1\n                    in_segment = True\n            else:\n                in_segment = False\n    return float(vertical_segments)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Standard deviation of pixel intensities in the outer border region\"\n    h, w = image.shape\n    border_width = min(h, w) // 8\n    if border_width == 0:\n        return 0.0\n    border_mask = np.zeros((h, w), dtype=bool)\n    border_mask[:border_width, :] = True\n    border_mask[-border_width:, :] = True\n    border_mask[:, :border_width] = True\n    border_mask[:, -border_width:] = True\n    return float(np.std(image[border_mask]))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Average vertical position of the rightmost non-zero pixels\"\n    h, w = image.shape\n    if h == 0 or w == 0:\n        return 0.0\n    rightmost_positions = []\n    for col_idx in range(w-1, -1, -1):\n        col = image[:, col_idx]\n        nonzero_rows = np.where(col > 0)[0]\n        if len(nonzero_rows) > 0:\n            rightmost_positions.extend(nonzero_rows)\n            break\n    if len(rightmost_positions) == 0:\n        return 0.0\n    return float(np.mean(rightmost_positions) / h)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Maximum consecutive vertical pixels in the rightmost quarter\"\n    h, w = image.shape\n    if h == 0 or w == 0:\n        return 0.0\n    right_region = image[:, 3*w//4:]\n    if right_region.shape[1] == 0:\n        return 0.0\n    max_consecutive = 0\n    for col in range(right_region.shape[1]):\n        current_streak = 0\n        for row in range(h):\n            if right_region[row, col] > 0:\n                current_streak += 1\n                max_consecutive = max(max_consecutive, current_streak)\n            else:\n                current_streak = 0\n    return float(max_consecutive)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Presence of curved bottom region characteristic of digit 9\"\n    h, w = image.shape\n    bottom_third = image[2*h//3:, :]\n    if bottom_third.size == 0:\n        return 0.0\n    curve_score = 0.0\n    for row_idx in range(bottom_third.shape[0]):\n        row = bottom_third[row_idx, :]\n        nonzero_cols = np.where(row > 0)[0]\n        if len(nonzero_cols) > 2:\n            left_most, right_most = nonzero_cols[0], nonzero_cols[-1]\n            width_span = right_most - left_most\n            curve_score += width_span / max(w, 1)\n    return float(curve_score / max(bottom_third.shape[0], 1))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of pixels in top half versus bottom half of image\"\n    h, w = image.shape\n    if h == 0:\n        return 0.0\n    top_half = np.sum(image[:h//2, :])\n    bottom_half = np.sum(image[h//2:, :])\n    if bottom_half == 0:\n        return float('inf') if top_half > 0 else 0.0\n    return float(top_half / bottom_half)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Density of non-zero pixels in the left half of the image\"\n    h, w = image.shape\n    left_half = image[:, :w//2]\n    total_pixels = left_half.size\n    if total_pixels == 0:\n        return 0.0\n    return float(np.count_nonzero(left_half) / total_pixels)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Number of horizontal transitions from zero to non-zero pixels\"\n    transitions = 0\n    h, w = image.shape\n    for row in range(h):\n        for col in range(1, w):\n            if image[row, col-1] == 0 and image[row, col] > 0:\n                transitions += 1\n    return float(transitions)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Maximum consecutive vertical pixels above threshold in center column\"\n    h, w = image.shape\n    center_col = image[:, w//2]\n    threshold = np.mean(center_col)\n    max_consecutive = 0\n    current_consecutive = 0\n    for pixel in center_col:\n        if pixel > threshold:\n            current_consecutive += 1\n            max_consecutive = max(max_consecutive, current_consecutive)\n        else:\n            current_consecutive = 0\n    return float(max_consecutive)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Number of gaps in the bottom quarter when scanning horizontally\"\n    h, w = image.shape\n    bottom_quarter = image[3*h//4:, :]\n    gaps = 0\n    for row in bottom_quarter:\n        in_stroke = False\n        for pixel in row:\n            if pixel > 0:\n                in_stroke = True\n            elif in_stroke and pixel == 0:\n                gaps += 1\n                in_stroke = False\n    return float(gaps)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of non-zero pixels in bottom quarter versus middle half\"\n    h, w = image.shape\n    if h < 4:\n        return 0.0\n    bottom_quarter = image[3*h//4:, :]\n    middle_half = image[h//4:3*h//4, :]\n    bottom_count = np.count_nonzero(bottom_quarter)\n    middle_count = np.count_nonzero(middle_half)\n    if middle_count == 0:\n        return float('inf') if bottom_count > 0 else 0.0\n    return float(bottom_count / middle_count)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Number of diagonal transitions from bottom-left to top-right direction\"\n    h, w = image.shape\n    if h < 2 or w < 2:\n        return 0.0\n    transitions = 0\n    for i in range(h - 1):\n        for j in range(w - 1):\n            if (image[i+1, j] > 0) != (image[i, j+1] > 0):\n                transitions += 1\n    return float(transitions)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of pixel intensity in bottom quarter to middle half\"\n    h, w = image.shape\n    bottom_quarter = image[3*h//4:, :]\n    middle_half = image[h//4:3*h//4, :]\n    bottom_mean = np.mean(bottom_quarter) if bottom_quarter.size > 0 else 0\n    middle_mean = np.mean(middle_half) if middle_half.size > 0 else 1\n    return float(bottom_mean / middle_mean if middle_mean > 0 else 0.0)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Diagonal edge strength from top-left to bottom-right\"\n    h, w = image.shape\n    diagonal_sum = 0.0\n    count = 0\n    for i in range(min(h-1, w-1)):\n        if i+1 < h and i+1 < w:\n            diagonal_sum += abs(float(image[i+1, i+1]) - float(image[i, i]))\n            count += 1\n    return float(diagonal_sum / count) if count > 0 else 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of non-zero pixels in bottom quarter versus middle half\"\n    h, w = image.shape\n    if h < 4:\n        return 0.0\n    bottom_quarter = image[3*h//4:, :]\n    middle_half = image[h//4:3*h//4, :]\n    bottom_count = np.count_nonzero(bottom_quarter)\n    middle_count = np.count_nonzero(middle_half)\n    if middle_count == 0:\n        return float('inf') if bottom_count > 0 else 0.0\n    return float(bottom_count / middle_count)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Thickness variation of the stroke measured at multiple vertical positions\"\n    h, w = image.shape\n    thicknesses = []\n    for row_idx in range(h//4, 3*h//4):\n        row = image[row_idx, :]\n        nonzero_indices = np.where(row > 0)[0]\n        if len(nonzero_indices) > 0:\n            thickness = nonzero_indices[-1] - nonzero_indices[0] + 1\n            thicknesses.append(thickness)\n    if len(thicknesses) < 2:\n        return 0.0\n    return float(np.std(thicknesses))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Diagonal edge strength from top-left to bottom-right\"\n    h, w = image.shape\n    diagonal_sum = 0.0\n    count = 0\n    for i in range(min(h-1, w-1)):\n        if i+1 < h and i+1 < w:\n            diagonal_sum += abs(float(image[i+1, i+1]) - float(image[i, i]))\n            count += 1\n    return float(diagonal_sum / count) if count > 0 else 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Presence of horizontal line in upper third of image\"\n    h, w = image.shape\n    upper_third = image[:h//3, :]\n    horizontal_intensity = 0\n    for row in range(upper_third.shape[0]):\n        row_sum = np.sum(upper_third[row, :])\n        if row_sum > horizontal_intensity:\n            horizontal_intensity = row_sum\n    return float(horizontal_intensity / (w * 255) if w > 0 else 0.0)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of pixel variance in left quarter versus right quarter\"\n    h, w = image.shape\n    left_quarter = image[:, :w//4]\n    right_quarter = image[:, 3*w//4:]\n    left_var = np.var(left_quarter) if left_quarter.size > 0 else 0.0\n    right_var = np.var(right_quarter) if right_quarter.size > 0 else 0.0\n    if right_var == 0:\n        return 1.0 if left_var > 0 else 0.0\n    return float(left_var / right_var)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of non-zero pixels in the center circle versus outer ring\"\n    h, w = image.shape\n    center_y, center_x = h // 2, w // 2\n    radius = min(h, w) // 4\n    \n    center_count = 0\n    outer_count = 0\n    total_center = 0\n    total_outer = 0\n    \n    for y in range(h):\n        for x in range(w):\n            dist = ((y - center_y) ** 2 + (x - center_x) ** 2) ** 0.5\n            if dist <= radius:\n                total_center += 1\n                if image[y, x] > 0:\n                    center_count += 1\n            elif dist <= radius * 2:\n                total_outer += 1\n                if image[y, x] > 0:\n                    outer_count += 1\n    \n    center_ratio = center_count / max(total_center, 1)\n    outer_ratio = outer_count / max(total_outer, 1)\n    return float(center_ratio / max(outer_ratio, 0.01))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Number of enclosed regions or loops in the image\"\n    from scipy import ndimage\n    if image.size == 0:\n        return 0.0\n    binary = image > np.mean(image)\n    filled = ndimage.binary_fill_holes(binary)\n    loops = np.sum(filled) - np.sum(binary)\n    return float(loops)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Horizontal concentration of non-zero pixels in middle rows\"\n    h, w = image.shape\n    middle_rows = image[h//3:2*h//3, :]\n    if middle_rows.size == 0:\n        return 0.0\n    row_sums = np.sum(middle_rows > 0, axis=1)\n    return float(np.std(row_sums) / (np.mean(row_sums) + 1e-8))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Variance of pixel intensities in diagonal regions versus anti-diagonal regions\"\n    h, w = image.shape\n    if h == 0 or w == 0:\n        return 0.0\n    diag_pixels = []\n    anti_diag_pixels = []\n    for i in range(min(h, w)):\n        diag_pixels.append(image[i, i])\n        anti_diag_pixels.append(image[i, w-1-i])\n    diag_var = np.var(diag_pixels) if diag_pixels else 0.0\n    anti_diag_var = np.var(anti_diag_pixels) if anti_diag_pixels else 0.0\n    return float(diag_var - anti_diag_var)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Average intensity in the bottom quarter of the image\"\n    h, w = image.shape\n    bottom_quarter = image[3*h//4:, :]\n    return float(np.mean(bottom_quarter))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Variance of pixel intensities in diagonal regions versus anti-diagonal regions\"\n    h, w = image.shape\n    if h == 0 or w == 0:\n        return 0.0\n    diag_pixels = []\n    anti_diag_pixels = []\n    for i in range(min(h, w)):\n        diag_pixels.append(image[i, i])\n        anti_diag_pixels.append(image[i, w-1-i])\n    diag_var = np.var(diag_pixels) if diag_pixels else 0.0\n    anti_diag_var = np.var(anti_diag_pixels) if anti_diag_pixels else 0.0\n    return float(diag_var - anti_diag_var)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Intensity concentration in the center 3x3 region relative to total\"\n    h, w = image.shape\n    if h < 3 or w < 3:\n        return 0.0\n    center_h, center_w = h//2, w//2\n    center_3x3 = image[center_h-1:center_h+2, center_w-1:center_w+2]\n    center_sum = np.sum(center_3x3)\n    total_sum = np.sum(image)\n    if total_sum == 0:\n        return 0.0\n    return float(center_sum / total_sum)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Average horizontal gradient magnitude in the center region\"\n    h, w = image.shape\n    center_region = image[h//4:3*h//4, w//4:3*w//4]\n    if center_region.shape[1] < 2:\n        return 0.0\n    grad_x = np.gradient(center_region, axis=1)\n    return float(np.mean(np.abs(grad_x)))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Number of horizontal line segments in the middle third of the image\"\n    h, w = image.shape\n    middle_third = image[h//3:2*h//3, :]\n    line_count = 0\n    threshold = np.mean(middle_third) + 0.5 * np.std(middle_third)\n    for row in middle_third:\n        segments = 0\n        in_segment = False\n        for pixel in row:\n            if pixel > threshold and not in_segment:\n                segments += 1\n                in_segment = True\n            elif pixel <= threshold:\n                in_segment = False\n        line_count += segments\n    return float(line_count)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Average width of non-zero regions per row in bottom half\"\n    h, w = image.shape\n    bottom_half = image[h//2:, :]\n    total_width = 0\n    valid_rows = 0\n    for row in bottom_half:\n        nonzero_indices = np.where(row > 0)[0]\n        if len(nonzero_indices) > 0:\n            width = nonzero_indices[-1] - nonzero_indices[0] + 1\n            total_width += width\n            valid_rows += 1\n    return float(total_width / valid_rows if valid_rows > 0 else 0)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Intensity concentration in the center quarter of the image\"\n    h, w = image.shape\n    center_quarter = image[3*h//8:5*h//8, 3*w//8:5*w//8]\n    if center_quarter.size == 0 or image.size == 0:\n        return 0.0\n    center_sum = np.sum(center_quarter)\n    total_sum = np.sum(image)\n    if total_sum == 0:\n        return 0.0\n    return float(center_sum / total_sum)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Width of the horizontal gap or opening in the middle vertical section\"\n    h, w = image.shape\n    middle_third = image[h//3:2*h//3, :]\n    gaps = []\n    for row in middle_third:\n        nonzero_indices = np.where(row > 0)[0]\n        if len(nonzero_indices) > 1:\n            max_gap = 0\n            for i in range(len(nonzero_indices) - 1):\n                gap = nonzero_indices[i+1] - nonzero_indices[i] - 1\n                max_gap = max(max_gap, gap)\n            gaps.append(max_gap)\n    return float(np.mean(gaps) if gaps else 0.0)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Average vertical position of the rightmost non-zero pixels\"\n    h, w = image.shape\n    if h == 0 or w == 0:\n        return 0.0\n    rightmost_positions = []\n    for col_idx in range(w-1, -1, -1):\n        col = image[:, col_idx]\n        nonzero_rows = np.where(col > 0)[0]\n        if len(nonzero_rows) > 0:\n            rightmost_positions.extend(nonzero_rows)\n            break\n    if len(rightmost_positions) == 0:\n        return 0.0\n    return float(np.mean(rightmost_positions) / h)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Horizontal gradient magnitude in the middle row\"\n    h, w = image.shape\n    if h == 0 or w < 2:\n        return 0.0\n    middle_row = image[h//2, :]\n    gradient = np.gradient(middle_row)\n    return float(np.mean(np.abs(gradient)))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Number of horizontal transitions from background to foreground in middle rows\"\n    h, w = image.shape\n    if h < 3:\n        return 0.0\n    middle_rows = image[h//3:2*h//3, :]\n    threshold = np.mean(image) * 0.5\n    binary = middle_rows > threshold\n    transitions = 0\n    for row in binary:\n        for i in range(1, len(row)):\n            if not row[i-1] and row[i]:\n                transitions += 1\n    return float(transitions)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Standard deviation of column sums in the middle third of image width\"\n    h, w = image.shape\n    if w == 0:\n        return 0.0\n    start_col = w // 3\n    end_col = 2 * w // 3\n    middle_section = image[:, start_col:end_col]\n    if middle_section.size == 0:\n        return 0.0\n    column_sums = np.sum(middle_section, axis=0)\n    return float(np.std(column_sums))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Number of horizontal transitions from zero to non-zero pixels\"\n    transitions = 0\n    h, w = image.shape\n    for row in range(h):\n        for col in range(1, w):\n            if image[row, col-1] == 0 and image[row, col] > 0:\n                transitions += 1\n    return float(transitions)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of maximum to minimum row-wise pixel counts for non-empty rows\"\n    h, w = image.shape\n    row_counts = []\n    for row in range(h):\n        count = np.count_nonzero(image[row, :])\n        if count > 0:\n            row_counts.append(count)\n    if len(row_counts) == 0:\n        return 1.0\n    min_count = min(row_counts)\n    max_count = max(row_counts)\n    if min_count == 0:\n        return float(max_count)\n    return float(max_count) / min_count\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Average pixel intensity in corners versus center cross pattern\"\n    h, w = image.shape\n    corner_size = min(h//4, w//4)\n    corners = np.concatenate([\n        image[:corner_size, :corner_size].flatten(),\n        image[:corner_size, -corner_size:].flatten(),\n        image[-corner_size:, :corner_size].flatten(),\n        image[-corner_size:, -corner_size:].flatten()\n    ])\n    cross = np.concatenate([\n        image[h//2-corner_size:h//2+corner_size, :].flatten(),\n        image[:, w//2-corner_size:w//2+corner_size].flatten()\n    ])\n    corner_avg = np.mean(corners) if corners.size > 0 else 0\n    cross_avg = np.mean(cross) if cross.size > 0 else 0\n    if cross_avg == 0:\n        return 1.0 if corner_avg > 0 else 0.0\n    return float(corner_avg / cross_avg)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Vertical extent of the topmost significant pixel cluster\"\n    h, w = image.shape\n    top_quarter = image[:h//4, :]\n    if top_quarter.size == 0:\n        return 0.0\n    nonzero_rows = np.where(np.sum(top_quarter, axis=1) > 0)[0]\n    if len(nonzero_rows) == 0:\n        return 0.0\n    vertical_extent = len(nonzero_rows)\n    return float(vertical_extent / max(h//4, 1))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Intensity variance in diagonal stripe from top-right to bottom-left\"\n    h, w = image.shape\n    diagonal_pixels = []\n    for i in range(min(h, w)):\n        if i < h and w-1-i >= 0:\n            diagonal_pixels.append(image[i, w-1-i])\n    return float(np.var(diagonal_pixels) if diagonal_pixels else 0.0)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Average gradient magnitude in the horizontal direction\"\n    if image.shape[1] < 2:\n        return 0.0\n    grad_y, grad_x = np.gradient(image)\n    return float(np.mean(np.abs(grad_x)))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Count of vertical edges detected in the center region\"\n    h, w = image.shape\n    if h < 4 or w < 4:\n        return 0.0\n    center = image[h//4:3*h//4, w//4:3*w//4]\n    if center.size == 0:\n        return 0.0\n    grad_y, grad_x = np.gradient(center.astype(float))\n    vertical_edges = np.abs(grad_x) > np.abs(grad_y)\n    return float(np.sum(vertical_edges))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Maximum consecutive horizontal pixels above threshold in center row\"\n    h, w = image.shape\n    if h == 0:\n        return 0.0\n    center_row = image[h//2, :]\n    threshold = np.mean(image) if np.std(image) > 0 else 0.5\n    binary_row = center_row > threshold\n    max_consecutive = 0\n    current_consecutive = 0\n    for pixel in binary_row:\n        if pixel:\n            current_consecutive += 1\n            max_consecutive = max(max_consecutive, current_consecutive)\n        else:\n            current_consecutive = 0\n    return float(max_consecutive)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of pixel sum in bottom-right quadrant to total pixel sum\"\n    h, w = image.shape\n    if h < 2 or w < 2:\n        return 0.0\n    bottom_right = image[h//2:, w//2:]\n    total_sum = np.sum(image)\n    if total_sum == 0:\n        return 0.0\n    return float(np.sum(bottom_right) / total_sum)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Maximum distance from center to any foreground pixel\"\n    if image.size == 0:\n        return 0.0\n    h, w = image.shape\n    center_y, center_x = h // 2, w // 2\n    threshold = np.mean(image) + np.std(image)\n    foreground = np.where(image > threshold)\n    if len(foreground[0]) == 0:\n        return 0.0\n    distances = np.sqrt((foreground[0] - center_y)**2 + (foreground[1] - center_x)**2)\n    return float(np.max(distances))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Intensity gradient magnitude in the central vertical strip\"\n    h, w = image.shape\n    strip_width = w // 4\n    start_col = w // 2 - strip_width // 2\n    end_col = w // 2 + strip_width // 2\n    central_strip = image[:, start_col:end_col]\n    if central_strip.size == 0:\n        return 0.0\n    grad_y, grad_x = np.gradient(central_strip.astype(float))\n    gradient_magnitude = np.sqrt(grad_y**2 + grad_x**2)\n    return float(np.mean(gradient_magnitude))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Average vertical position of the rightmost non-zero pixels\"\n    h, w = image.shape\n    if h == 0 or w == 0:\n        return 0.0\n    rightmost_positions = []\n    for col_idx in range(w-1, -1, -1):\n        col = image[:, col_idx]\n        nonzero_rows = np.where(col > 0)[0]\n        if len(nonzero_rows) > 0:\n            rightmost_positions.extend(nonzero_rows)\n            break\n    if len(rightmost_positions) == 0:\n        return 0.0\n    return float(np.mean(rightmost_positions) / h)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Variance of row sums in the bottom quarter of the image\"\n    h, w = image.shape\n    if h < 4:\n        return 0.0\n    bottom_quarter = image[3*h//4:, :]\n    row_sums = np.sum(bottom_quarter, axis=1)\n    return float(np.var(row_sums))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Horizontal symmetry score of the middle third region\"\n    h, w = image.shape\n    if h == 0 or w == 0:\n        return 0.0\n    \n    middle_start, middle_end = h // 3, 2 * h // 3\n    middle_region = image[middle_start:middle_end, :]\n    \n    if middle_region.shape[1] <= 1:\n        return 1.0\n    \n    left_half = middle_region[:, :w//2]\n    right_half = middle_region[:, w//2:]\n    right_flipped = np.fliplr(right_half)\n    \n    min_width = min(left_half.shape[1], right_flipped.shape[1])\n    if min_width == 0:\n        return 0.0\n    \n    left_crop = left_half[:, -min_width:]\n    right_crop = right_flipped[:, :min_width]\n    \n    diff = np.abs(left_crop - right_crop)\n    max_possible_diff = np.abs(left_crop).max() + np.abs(right_crop).max()\n    \n    if max_possible_diff == 0:\n        return 1.0\n    \n    return float(1.0 - np.mean(diff) / max_possible_diff)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of pixels in top half versus bottom half of image\"\n    h, w = image.shape\n    if h == 0:\n        return 0.0\n    top_half = np.sum(image[:h//2, :])\n    bottom_half = np.sum(image[h//2:, :])\n    if bottom_half == 0:\n        return float('inf') if top_half > 0 else 0.0\n    return float(top_half / bottom_half)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Standard deviation of pixel intensities in vertical middle strip\"\n    h, w = image.shape\n    if h < 3:\n        return 0.0\n    middle_strip = image[h//3:2*h//3, :]\n    return float(np.std(middle_strip))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Presence of a curved bottom section connecting left and right sides\"\n    h, w = image.shape\n    bottom_quarter = image[3*h//4:, :]\n    curve_score = 0\n    for i, row in enumerate(bottom_quarter):\n        nonzero_indices = np.where(row > 0)[0]\n        if len(nonzero_indices) > w//4:  # Substantial horizontal presence\n            # Weight rows closer to bottom more heavily\n            weight = (i + 1) / len(bottom_quarter)\n            curve_score += weight * len(nonzero_indices) / w\n    return float(curve_score)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Vertical density gradient from center to bottom of image\"\n    h, w = image.shape\n    if h < 4:\n        return 0.0\n    center_strip = image[h//2:3*h//4, :]\n    bottom_strip = image[3*h//4:, :]\n    center_density = np.mean(center_strip) if center_strip.size > 0 else 0.0\n    bottom_density = np.mean(bottom_strip) if bottom_strip.size > 0 else 0.0\n    return float(bottom_density - center_density)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Width of the widest row with non-zero pixels\"\n    h, w = image.shape\n    max_width = 0\n    for row in range(h):\n        non_zero_cols = np.where(image[row, :] > 0)[0]\n        if len(non_zero_cols) > 0:\n            width = non_zero_cols[-1] - non_zero_cols[0] + 1\n            max_width = max(max_width, width)\n    return float(max_width)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Number of horizontal runs of consecutive non-zero pixels in the right half\"\n    h, w = image.shape\n    right_half = image[:, w//2:]\n    horizontal_runs = 0\n    for row in right_half:\n        in_run = False\n        for pixel in row:\n            if pixel > 0 and not in_run:\n                horizontal_runs += 1\n                in_run = True\n            elif pixel == 0:\n                in_run = False\n    return float(horizontal_runs)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of connected components in top-right quadrant to total non-zero pixels\"\n    h, w = image.shape\n    top_right = image[:h//2, w//2:]\n    if np.sum(top_right) == 0:\n        return 0.0\n    components = 0\n    visited = np.zeros_like(top_right, dtype=bool)\n    for i in range(top_right.shape[0]):\n        for j in range(top_right.shape[1]):\n            if top_right[i, j] > 0 and not visited[i, j]:\n                components += 1\n                stack = [(i, j)]\n                while stack:\n                    x, y = stack.pop()\n                    if x >= 0 and x < top_right.shape[0] and y >= 0 and y < top_right.shape[1] and not visited[x, y] and top_right[x, y] > 0:\n                        visited[x, y] = True\n                        stack.extend([(x+1, y), (x-1, y), (x, y+1), (x, y-1)])\n    return float(components / np.count_nonzero(top_right))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of pixels in top half versus bottom half of image\"\n    h, w = image.shape\n    if h == 0:\n        return 0.0\n    top_half = np.sum(image[:h//2, :])\n    bottom_half = np.sum(image[h//2:, :])\n    if bottom_half == 0:\n        return float('inf') if top_half > 0 else 0.0\n    return float(top_half / bottom_half)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Maximum consecutive horizontal pixels above threshold in center row\"\n    h, w = image.shape\n    if h == 0:\n        return 0.0\n    center_row = image[h//2, :]\n    threshold = np.mean(image) if np.std(image) > 0 else 0.5\n    binary_row = center_row > threshold\n    max_consecutive = 0\n    current_consecutive = 0\n    for pixel in binary_row:\n        if pixel:\n            current_consecutive += 1\n            max_consecutive = max(max_consecutive, current_consecutive)\n        else:\n            current_consecutive = 0\n    return float(max_consecutive)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of pixels in top half versus bottom half of image\"\n    h, w = image.shape\n    if h == 0:\n        return 0.0\n    top_half = np.sum(image[:h//2, :])\n    bottom_half = np.sum(image[h//2:, :])\n    if bottom_half == 0:\n        return float('inf') if top_half > 0 else 0.0\n    return float(top_half / bottom_half)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of pixels in top half versus bottom half of image\"\n    h, w = image.shape\n    if h == 0:\n        return 0.0\n    top_half = np.sum(image[:h//2, :])\n    bottom_half = np.sum(image[h//2:, :])\n    if bottom_half == 0:\n        return float('inf') if top_half > 0 else 0.0\n    return float(top_half / bottom_half)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Presence of circular or curved patterns in center region\"\n    h, w = image.shape\n    center = image[h//4:3*h//4, w//4:3*w//4]\n    if center.size == 0:\n        return 0.0\n    gradients = np.gradient(center)\n    grad_mag = np.sqrt(gradients[0]**2 + gradients[1]**2)\n    return float(np.std(grad_mag))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Average intensity of pixels in the center column\"\n    h, w = image.shape\n    if w == 0:\n        return 0.0\n    center_col = w // 2\n    center_column = image[:, center_col]\n    non_zero_pixels = center_column[center_column > 0]\n    if len(non_zero_pixels) == 0:\n        return 0.0\n    return float(np.mean(non_zero_pixels))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of non-zero pixels in middle row to middle column\"\n    h, w = image.shape\n    if h == 0 or w == 0:\n        return 1.0\n    middle_row = image[h//2, :]\n    middle_col = image[:, w//2]\n    row_nonzero = np.count_nonzero(middle_row)\n    col_nonzero = np.count_nonzero(middle_col)\n    return row_nonzero / (col_nonzero + 1.0)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of pixels in top half versus bottom half of image\"\n    h, w = image.shape\n    if h == 0:\n        return 0.0\n    top_half = np.sum(image[:h//2, :])\n    bottom_half = np.sum(image[h//2:, :])\n    if bottom_half == 0:\n        return float('inf') if top_half > 0 else 0.0\n    return float(top_half / bottom_half)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of pixels in top half versus bottom half of image\"\n    h, w = image.shape\n    if h == 0:\n        return 0.0\n    top_half = np.sum(image[:h//2, :])\n    bottom_half = np.sum(image[h//2:, :])\n    if bottom_half == 0:\n        return float('inf') if top_half > 0 else 0.0\n    return float(top_half / bottom_half)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of pixels in top half versus bottom half of image\"\n    h, w = image.shape\n    if h == 0:\n        return 0.0\n    top_half = np.sum(image[:h//2, :])\n    bottom_half = np.sum(image[h//2:, :])\n    if bottom_half == 0:\n        return float('inf') if top_half > 0 else 0.0\n    return float(top_half / bottom_half)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Average vertical gradient magnitude in the middle vertical strip\"\n    h, w = image.shape\n    if h < 2 or w < 3:\n        return 0.0\n    middle_strip = image[:, w//3:2*w//3]\n    grad_y = np.gradient(middle_strip, axis=0)\n    return float(np.mean(np.abs(grad_y)))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Minimum row index of non-zero pixels in center column\"\n    h, w = image.shape\n    if w == 0:\n        return float(h)\n    center_col = image[:, w//2]\n    non_zero_rows = np.where(center_col > 0)[0]\n    if len(non_zero_rows) == 0:\n        return float(h)\n    return float(non_zero_rows[0])\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of pixels in top half versus bottom half of image\"\n    h, w = image.shape\n    if h == 0:\n        return 0.0\n    top_half = np.sum(image[:h//2, :])\n    bottom_half = np.sum(image[h//2:, :])\n    if bottom_half == 0:\n        return float('inf') if top_half > 0 else 0.0\n    return float(top_half / bottom_half)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of vertical gradients in upper half versus lower half\"\n    h, w = image.shape\n    grad_y = np.gradient(image, axis=0)\n    upper_grad = np.sum(np.abs(grad_y[:h//2, :]))\n    lower_grad = np.sum(np.abs(grad_y[h//2:, :]))\n    if lower_grad == 0:\n        return float(upper_grad > 0)\n    return float(upper_grad / lower_grad)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Skewness of horizontal distribution of non-zero pixels\"\n    h, w = image.shape\n    if w == 0:\n        return 0.0\n    col_sums = np.sum(image, axis=0)\n    non_zero_cols = np.nonzero(col_sums)[0]\n    if len(non_zero_cols) < 3:\n        return 0.0\n    weights = col_sums[non_zero_cols]\n    positions = non_zero_cols\n    mean_pos = np.average(positions, weights=weights)\n    variance = np.average((positions - mean_pos)**2, weights=weights)\n    if variance == 0:\n        return 0.0\n    skewness = np.average((positions - mean_pos)**3, weights=weights) / (variance**1.5)\n    return float(skewness)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Average vertical gradient magnitude in the center column\"\n    h, w = image.shape\n    if w == 0:\n        return 0.0\n    center_col = image[:, w//2]\n    if len(center_col) < 2:\n        return 0.0\n    gradients = np.abs(np.diff(center_col.astype(float)))\n    return float(np.mean(gradients))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Maximum consecutive vertical pixels above threshold in the center column\"\n    h, w = image.shape\n    if w == 0 or h == 0:\n        return 0.0\n    center_col = image[:, w // 2]\n    threshold = np.mean(image) + 0.5 * np.std(image)\n    above_threshold = center_col > threshold\n    max_consecutive = 0\n    current_consecutive = 0\n    for pixel in above_threshold:\n        if pixel:\n            current_consecutive += 1\n            max_consecutive = max(max_consecutive, current_consecutive)\n        else:\n            current_consecutive = 0\n    return float(max_consecutive)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Density of high-intensity pixels (above 75th percentile) in bottom half\"\n    h, w = image.shape\n    bottom_half = image[h//2:, :]\n    threshold = np.percentile(image, 75)\n    high_intensity_count = np.sum(bottom_half > threshold)\n    total_pixels = bottom_half.size\n    return float(high_intensity_count / total_pixels)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of maximum row sum to maximum column sum of pixel intensities\"\n    row_sums = np.sum(image, axis=1)\n    col_sums = np.sum(image, axis=0)\n    max_row = np.max(row_sums) if row_sums.size > 0 else 1e-8\n    max_col = np.max(col_sums) if col_sums.size > 0 else 1e-8\n    return max_row / max_col\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of pixel intensity in the upper third versus middle third of image\"\n    h, w = image.shape\n    upper_third = image[:h//3, :]\n    middle_third = image[h//3:2*h//3, :]\n    upper_mean = np.mean(upper_third)\n    middle_mean = np.mean(middle_third)\n    if middle_mean == 0:\n        return 0.0\n    return float(upper_mean / middle_mean)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of pixel density in upper third versus lower third of image\"\n    h, w = image.shape\n    upper_third = image[:h//3, :]\n    lower_third = image[2*h//3:, :]\n    upper_density = np.mean(upper_third) if upper_third.size > 0 else 0\n    lower_density = np.mean(lower_third) if lower_third.size > 0 else 0\n    return float(upper_density / (lower_density + 1e-8))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Intensity ratio between upper-middle and lower-middle regions\"\n    h, w = image.shape\n    upper_mid = image[h//4:h//2, w//4:3*w//4]\n    lower_mid = image[h//2:3*h//4, w//4:3*w//4]\n    upper_sum = np.sum(upper_mid)\n    lower_sum = np.sum(lower_mid)\n    if lower_sum == 0:\n        return 1.0 if upper_sum > 0 else 0.0\n    return float(upper_sum / (upper_sum + lower_sum))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Variance of pixel intensities in diagonal regions versus anti-diagonal regions\"\n    h, w = image.shape\n    if h == 0 or w == 0:\n        return 0.0\n    diag_pixels = []\n    anti_diag_pixels = []\n    for i in range(min(h, w)):\n        diag_pixels.append(image[i, i])\n        anti_diag_pixels.append(image[i, w-1-i])\n    diag_var = np.var(diag_pixels) if diag_pixels else 0.0\n    anti_diag_var = np.var(anti_diag_pixels) if anti_diag_pixels else 0.0\n    return float(diag_var - anti_diag_var)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Intensity concentration in the center quarter of the image\"\n    h, w = image.shape\n    center_quarter = image[3*h//8:5*h//8, 3*w//8:5*w//8]\n    if center_quarter.size == 0 or image.size == 0:\n        return 0.0\n    center_sum = np.sum(center_quarter)\n    total_sum = np.sum(image)\n    if total_sum == 0:\n        return 0.0\n    return float(center_sum / total_sum)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Number of distinct horizontal segments with intensity above median in upper third\"\n    h, w = image.shape\n    upper_third = image[:h//3, :]\n    if upper_third.size == 0:\n        return 0.0\n    median_val = np.median(upper_third)\n    segments = 0\n    for row in upper_third:\n        in_segment = False\n        for pixel in row:\n            if pixel > median_val and not in_segment:\n                segments += 1\n                in_segment = True\n            elif pixel <= median_val:\n                in_segment = False\n    return float(segments)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Maximum row intensity in the bottom third of image\"\n    h, w = image.shape\n    if h == 0:\n        return 0.0\n    bottom_third = image[2*h//3:, :]\n    if bottom_third.size == 0:\n        return 0.0\n    row_sums = np.sum(bottom_third, axis=1)\n    return float(np.max(row_sums) if len(row_sums) > 0 else 0.0)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Presence of a curved bottom section connecting left and right sides\"\n    h, w = image.shape\n    bottom_quarter = image[3*h//4:, :]\n    curve_score = 0\n    for i, row in enumerate(bottom_quarter):\n        nonzero_indices = np.where(row > 0)[0]\n        if len(nonzero_indices) > w//4:  # Substantial horizontal presence\n            # Weight rows closer to bottom more heavily\n            weight = (i + 1) / len(bottom_quarter)\n            curve_score += weight * len(nonzero_indices) / w\n    return float(curve_score)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Average vertical position of the rightmost non-zero pixels\"\n    h, w = image.shape\n    if h == 0 or w == 0:\n        return 0.0\n    rightmost_positions = []\n    for col_idx in range(w-1, -1, -1):\n        col = image[:, col_idx]\n        nonzero_rows = np.where(col > 0)[0]\n        if len(nonzero_rows) > 0:\n            rightmost_positions.extend(nonzero_rows)\n            break\n    if len(rightmost_positions) == 0:\n        return 0.0\n    return float(np.mean(rightmost_positions) / h)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Concentration of pixels in the upper-middle region\"\n    h, w = image.shape\n    if h < 4 or w < 4:\n        return float(np.mean(image))\n    upper_middle = image[h//4:h//2, w//4:3*w//4]\n    total_intensity = np.sum(image)\n    if total_intensity == 0:\n        return 0.0\n    upper_middle_intensity = np.sum(upper_middle)\n    return float(upper_middle_intensity / total_intensity)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of vertical edge strength to horizontal edge strength\"\n    if image.size == 0:\n        return 0.0\n    grad_y, grad_x = np.gradient(image)\n    vertical_strength = np.sum(np.abs(grad_x))\n    horizontal_strength = np.sum(np.abs(grad_y))\n    if horizontal_strength == 0:\n        return 1.0 if vertical_strength > 0 else 0.0\n    return float(vertical_strength / horizontal_strength)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of pixel intensity variance in top third versus middle third\"\n    h, w = image.shape\n    top_third = image[:h//3, :]\n    middle_third = image[h//3:2*h//3, :]\n    top_var = np.var(top_third)\n    middle_var = np.var(middle_third)\n    if middle_var == 0:\n        return float(top_var)\n    return float(top_var / middle_var)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of filled pixels in middle-right region to middle-left region\"\n    h, w = image.shape\n    mid_top, mid_bottom = h//3, 2*h//3\n    left_region = image[mid_top:mid_bottom, :w//2]\n    right_region = image[mid_top:mid_bottom, w//2:]\n    left_count = np.count_nonzero(left_region) if left_region.size > 0 else 1\n    right_count = np.count_nonzero(right_region) if right_region.size > 0 else 0\n    return float(right_count / max(left_count, 1))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Curvature measure in the middle-right region\"\n    h, w = image.shape\n    if h < 6 or w < 4:\n        return 0.0\n    middle_right = image[h//3:2*h//3, w//2:]\n    \n    # Find contour-like transitions\n    grad_y, grad_x = np.gradient(middle_right.astype(float))\n    curvature = np.abs(grad_x[1:-1, :] * grad_y[:-2, :] - grad_x[:-2, :] * grad_y[1:-1, :])\n    return float(np.mean(curvature))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Maximum consecutive foreground pixels in any diagonal direction\"\n    h, w = image.shape\n    if h == 0 or w == 0:\n        return 0.0\n    \n    threshold = np.mean(image)\n    max_diagonal = 0\n    \n    # Check main diagonals\n    for start_row in range(h):\n        # Down-right diagonal\n        count = 0\n        max_count = 0\n        r, c = start_row, 0\n        while r < h and c < w:\n            if image[r, c] > threshold:\n                count += 1\n                max_count = max(max_count, count)\n            else:\n                count = 0\n            r += 1\n            c += 1\n        max_diagonal = max(max_diagonal, max_count)\n    \n    return float(max_diagonal)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of curved regions to straight regions based on gradient changes\"\n    grad_y, grad_x = np.gradient(image.astype(float))\n    grad_magnitude = np.sqrt(grad_x**2 + grad_y**2)\n    grad_direction = np.arctan2(grad_y, grad_x)\n    \n    direction_changes = np.sum(np.abs(np.diff(grad_direction.flatten())) > np.pi/4)\n    straight_regions = np.sum(grad_magnitude > np.mean(grad_magnitude))\n    \n    return float(direction_changes / (straight_regions + 1e-8))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Maximum consecutive vertical pixels with values above threshold in any column\"\n    if image.size == 0:\n        return 0.0\n    h, w = image.shape\n    threshold = np.mean(image) + 0.1\n    max_consecutive = 0\n    for col in range(w):\n        current_consecutive = 0\n        for row in range(h):\n            if image[row, col] > threshold:\n                current_consecutive += 1\n                max_consecutive = max(max_consecutive, current_consecutive)\n            else:\n                current_consecutive = 0\n    return float(max_consecutive)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of maximum width in top half versus bottom half\"\n    h, w = image.shape\n    if h == 0:\n        return 1.0\n    top_half = image[:h//2, :]\n    bottom_half = image[h//2:, :]\n    \n    top_widths = [np.sum(row > 0) for row in top_half]\n    bottom_widths = [np.sum(row > 0) for row in bottom_half]\n    \n    max_top = max(top_widths) if top_widths else 0\n    max_bottom = max(bottom_widths) if bottom_widths else 0\n    \n    if max_bottom == 0:\n        return float(max_top > 0)\n    return float(max_top / max_bottom)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Density of non-zero pixels in the top-right quarter of the image\"\n    h, w = image.shape\n    top_right = image[:h//2, w//2:]\n    total_pixels = top_right.size\n    if total_pixels == 0:\n        return 0.0\n    return float(np.count_nonzero(top_right) / total_pixels)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Intensity concentration in the center quarter of the image\"\n    h, w = image.shape\n    center_quarter = image[3*h//8:5*h//8, 3*w//8:5*w//8]\n    if center_quarter.size == 0 or image.size == 0:\n        return 0.0\n    center_sum = np.sum(center_quarter)\n    total_sum = np.sum(image)\n    if total_sum == 0:\n        return 0.0\n    return float(center_sum / total_sum)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of vertical gradient magnitude in left half versus right half\"\n    h, w = image.shape\n    grad_y = np.gradient(image, axis=0)\n    left_grad = np.abs(grad_y[:, :w//2])\n    right_grad = np.abs(grad_y[:, w//2:])\n    left_mag = np.mean(left_grad) if left_grad.size > 0 else 0\n    right_mag = np.mean(right_grad) if right_grad.size > 0 else 0\n    return float(left_mag / (right_mag + 0.001))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Average vertical position of the rightmost non-zero pixels\"\n    h, w = image.shape\n    if h == 0 or w == 0:\n        return 0.0\n    rightmost_positions = []\n    for col_idx in range(w-1, -1, -1):\n        col = image[:, col_idx]\n        nonzero_rows = np.where(col > 0)[0]\n        if len(nonzero_rows) > 0:\n            rightmost_positions.extend(nonzero_rows)\n            break\n    if len(rightmost_positions) == 0:\n        return 0.0\n    return float(np.mean(rightmost_positions) / h)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Intensity concentration in the center 3x3 region relative to total\"\n    h, w = image.shape\n    if h < 3 or w < 3:\n        return 0.0\n    center_h, center_w = h//2, w//2\n    center_3x3 = image[center_h-1:center_h+2, center_w-1:center_w+2]\n    center_sum = np.sum(center_3x3)\n    total_sum = np.sum(image)\n    if total_sum == 0:\n        return 0.0\n    return float(center_sum / total_sum)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Count of connected high-intensity regions in middle vertical strip\"\n    h, w = image.shape\n    middle_strip = image[:, w//3:2*w//3]\n    threshold = np.percentile(middle_strip, 60)\n    binary_strip = (middle_strip > threshold).astype(int)\n    transitions = np.sum(np.diff(binary_strip, axis=1) != 0)\n    return float(transitions)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Intensity concentration in the center quarter of the image\"\n    h, w = image.shape\n    center_quarter = image[3*h//8:5*h//8, 3*w//8:5*w//8]\n    if center_quarter.size == 0 or image.size == 0:\n        return 0.0\n    center_sum = np.sum(center_quarter)\n    total_sum = np.sum(image)\n    if total_sum == 0:\n        return 0.0\n    return float(center_sum / total_sum)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Concentration of pixels in the upper-middle region\"\n    h, w = image.shape\n    if h < 4 or w < 4:\n        return float(np.mean(image))\n    upper_middle = image[h//4:h//2, w//4:3*w//4]\n    total_intensity = np.sum(image)\n    if total_intensity == 0:\n        return 0.0\n    upper_middle_intensity = np.sum(upper_middle)\n    return float(upper_middle_intensity / total_intensity)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Horizontal gradient strength in the middle third of image\"\n    h, w = image.shape\n    middle_third = image[h//3:2*h//3, :]\n    grad_y, grad_x = np.gradient(middle_third)\n    return float(np.mean(np.abs(grad_x)))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of connected components in top-right quadrant to total non-zero pixels\"\n    h, w = image.shape\n    top_right = image[:h//2, w//2:]\n    if np.sum(top_right) == 0:\n        return 0.0\n    components = 0\n    visited = np.zeros_like(top_right, dtype=bool)\n    for i in range(top_right.shape[0]):\n        for j in range(top_right.shape[1]):\n            if top_right[i, j] > 0 and not visited[i, j]:\n                components += 1\n                stack = [(i, j)]\n                while stack:\n                    x, y = stack.pop()\n                    if x >= 0 and x < top_right.shape[0] and y >= 0 and y < top_right.shape[1] and not visited[x, y] and top_right[x, y] > 0:\n                        visited[x, y] = True\n                        stack.extend([(x+1, y), (x-1, y), (x, y+1), (x, y-1)])\n    return float(components / np.count_nonzero(top_right))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of pixels in the leftmost quarter versus rightmost quarter\"\n    h, w = image.shape\n    if w < 4:\n        return 0.5\n    left_quarter = image[:, :w//4]\n    right_quarter = image[:, -w//4:]\n    left_sum = np.sum(left_quarter)\n    right_sum = np.sum(right_quarter)\n    if left_sum + right_sum == 0:\n        return 0.5\n    return float(left_sum / (left_sum + right_sum))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Curvature measure in the middle-right region\"\n    h, w = image.shape\n    if h < 6 or w < 4:\n        return 0.0\n    middle_right = image[h//3:2*h//3, w//2:]\n    \n    # Find contour-like transitions\n    grad_y, grad_x = np.gradient(middle_right.astype(float))\n    curvature = np.abs(grad_x[1:-1, :] * grad_y[:-2, :] - grad_x[:-2, :] * grad_y[1:-1, :])\n    return float(np.mean(curvature))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Presence of horizontal line in upper third of image\"\n    h, w = image.shape\n    upper_third = image[:h//3, :]\n    horizontal_intensity = 0\n    for row in range(upper_third.shape[0]):\n        row_sum = np.sum(upper_third[row, :])\n        if row_sum > horizontal_intensity:\n            horizontal_intensity = row_sum\n    return float(horizontal_intensity / (w * 255) if w > 0 else 0.0)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Number of diagonal transitions from bottom-left to top-right direction\"\n    h, w = image.shape\n    if h < 2 or w < 2:\n        return 0.0\n    transitions = 0\n    for i in range(h - 1):\n        for j in range(w - 1):\n            if (image[i+1, j] > 0) != (image[i, j+1] > 0):\n                transitions += 1\n    return float(transitions)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of non-zero pixels in diagonal strips versus anti-diagonal strips\"\n    h, w = image.shape\n    diag_count = 0\n    anti_diag_count = 0\n    total_pixels = 0\n    \n    for i in range(h):\n        for j in range(w):\n            if abs(i - j) <= min(h, w) // 4:  # Main diagonal strip\n                if image[i, j] > 0:\n                    diag_count += 1\n                total_pixels += 1\n            elif abs(i + j - (h-1)) <= min(h, w) // 4:  # Anti-diagonal strip\n                if image[i, j] > 0:\n                    anti_diag_count += 1\n                total_pixels += 1\n    \n    if anti_diag_count == 0:\n        return float(diag_count)\n    return float(diag_count / anti_diag_count)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of pixel density in center column versus side columns\"\n    h, w = image.shape\n    center_col = w // 2\n    center_pixels = np.count_nonzero(image[:, center_col])\n    \n    left_col = w // 4\n    right_col = 3 * w // 4\n    side_pixels = np.count_nonzero(image[:, left_col]) + np.count_nonzero(image[:, right_col])\n    \n    if side_pixels == 0:\n        return float(center_pixels)\n    return float(center_pixels / side_pixels)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of pixel intensity variance in top-left quadrant versus bottom-right quadrant\"\n    h, w = image.shape\n    top_left = image[:h//2, :w//2]\n    bottom_right = image[h//2:, w//2:]\n    tl_var = np.var(top_left)\n    br_var = np.var(bottom_right)\n    if br_var == 0:\n        return float(tl_var > 0)\n    return float(tl_var) / float(br_var)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of intensity in bottom-right quadrant to top-right quadrant\"\n    h, w = image.shape\n    if h == 0 or w == 0:\n        return 0.0\n    top_right = image[:h//2, w//2:]\n    bottom_right = image[h//2:, w//2:]\n    top_sum = np.sum(top_right)\n    bottom_sum = np.sum(bottom_right)\n    return float(bottom_sum / (top_sum + 1e-8))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Vertical position of the row with maximum pixel intensity sum\"\n    h, w = image.shape\n    row_sums = np.sum(image, axis=1)\n    max_row = np.argmax(row_sums)\n    return float(max_row / h)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Horizontal extent of the topmost non-zero pixels\"\n    h, w = image.shape\n    for row in range(h):\n        if np.any(image[row, :] > 0):\n            nonzero_cols = np.where(image[row, :] > 0)[0]\n            return float(nonzero_cols[-1] - nonzero_cols[0] + 1) / w\n    return 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of pixel intensity variance in top quarter to bottom quarter\"\n    h, w = image.shape\n    top_quarter = image[:h//4, :]\n    bottom_quarter = image[3*h//4:, :]\n    top_var = np.var(top_quarter) if top_quarter.size > 0 else 0.0\n    bottom_var = np.var(bottom_quarter) if bottom_quarter.size > 0 else 0.0\n    if bottom_var == 0:\n        return float(top_var)\n    return float(top_var / bottom_var)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Number of connected components in the middle vertical strip\"\n    h, w = image.shape\n    middle_strip = image[:, w//3:2*w//3]\n    binary = (middle_strip > middle_strip.mean()).astype(int)\n    transitions = 0\n    for col in range(binary.shape[1]):\n        column = binary[:, col]\n        transitions += np.sum(np.abs(np.diff(column)))\n    return float(transitions)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of non-zero pixels in the bottom third to middle third of the image\"\n    h, w = image.shape\n    bottom_third = image[2*h//3:h, :]\n    middle_third = image[h//3:2*h//3, :]\n    bottom_count = np.count_nonzero(bottom_third)\n    middle_count = np.count_nonzero(middle_third)\n    if middle_count == 0:\n        return 0.0\n    return float(bottom_count / middle_count)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Count of horizontal runs of consecutive non-zero pixels in the upper half\"\n    h, w = image.shape\n    if h < 2:\n        return 0.0\n    upper_half = image[:h//2, :]\n    run_count = 0\n    for row in upper_half:\n        in_run = False\n        for pixel in row:\n            if pixel > 0 and not in_run:\n                run_count += 1\n                in_run = True\n            elif pixel == 0:\n                in_run = False\n    return float(run_count)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Number of distinct connected regions in the right half of the image\"\n    h, w = image.shape\n    if w < 2:\n        return 0.0\n    right_half = image[:, w//2:]\n    regions = 0\n    visited = np.zeros_like(right_half, dtype=bool)\n    \n    def flood_fill(r, c):\n        if r < 0 or r >= right_half.shape[0] or c < 0 or c >= right_half.shape[1]:\n            return\n        if visited[r, c] or right_half[r, c] == 0:\n            return\n        visited[r, c] = True\n        flood_fill(r+1, c)\n        flood_fill(r-1, c)\n        flood_fill(r, c+1)\n        flood_fill(r, c-1)\n    \n    for r in range(right_half.shape[0]):\n        for c in range(right_half.shape[1]):\n            if right_half[r, c] > 0 and not visited[r, c]:\n                flood_fill(r, c)\n                regions += 1\n    \n    return float(regions)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Number of non-zero pixels in a small central square region\"\n    h, w = image.shape\n    center_size = min(h, w) // 6\n    start_row = h//2 - center_size//2\n    end_row = h//2 + center_size//2\n    start_col = w//2 - center_size//2\n    end_col = w//2 + center_size//2\n    central_square = image[start_row:end_row, start_col:end_col]\n    return float(np.count_nonzero(central_square))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Number of pixels forming curved patterns in the bottom half\"\n    h, w = image.shape\n    bottom_half = image[h//2:, :]\n    threshold = np.mean(bottom_half) + 0.5 * np.std(bottom_half)\n    binary = (bottom_half > threshold).astype(int)\n    curved_pixels = 0\n    for i in range(1, binary.shape[0]-1):\n        for j in range(1, binary.shape[1]-1):\n            if binary[i, j] > 0:\n                neighbors = binary[i-1:i+2, j-1:j+2]\n                if np.sum(neighbors) >= 4 and np.sum(neighbors) <= 6:\n                    curved_pixels += 1\n    return float(curved_pixels)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Count of vertical segments where pixel intensity increases then decreases\"\n    h, w = image.shape\n    segment_count = 0\n    \n    for col in range(w):\n        column = image[:, col]\n        state = 'start'\n        for i in range(1, len(column)):\n            if state == 'start' and column[i] > column[i-1] and column[i] > 0:\n                state = 'increasing'\n            elif state == 'increasing' and column[i] < column[i-1]:\n                segment_count += 1\n                state = 'start'\n    \n    return float(segment_count)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Average pixel intensity in diagonal stripe from top-left to bottom-right\"\n    h, w = image.shape\n    if h == 0 or w == 0:\n        return 0.0\n    diagonal_pixels = []\n    for i in range(min(h, w)):\n        diagonal_pixels.append(image[i, i])\n    return float(np.mean(diagonal_pixels))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Number of distinct horizontal segments with intensity above median in upper third\"\n    h, w = image.shape\n    upper_third = image[:h//3, :]\n    if upper_third.size == 0:\n        return 0.0\n    median_val = np.median(upper_third)\n    segments = 0\n    for row in upper_third:\n        in_segment = False\n        for pixel in row:\n            if pixel > median_val and not in_segment:\n                segments += 1\n                in_segment = True\n            elif pixel <= median_val:\n                in_segment = False\n    return float(segments)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Number of sharp angle turns in the bottom half\"\n    h, w = image.shape\n    bottom_half = image[h//2:, :]\n    if bottom_half.size == 0:\n        return 0.0\n    grad_y, grad_x = np.gradient(bottom_half.astype(float))\n    angle_changes = np.abs(np.gradient(np.arctan2(grad_y, grad_x + 0.001)))\n    sharp_turns = np.sum(angle_changes > np.pi/3)\n    return float(sharp_turns)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of mean pixel intensity in center versus top-left quadrant\"\n    h, w = image.shape\n    center_region = image[h//4:3*h//4, w//4:3*w//4]\n    top_left = image[:h//2, :w//2]\n    center_mean = np.mean(center_region) if center_region.size > 0 else 0.0\n    top_left_mean = np.mean(top_left) if top_left.size > 0 else 0.0\n    if top_left_mean == 0:\n        return float(center_mean)\n    return float(center_mean / top_left_mean)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of mean intensity in top-left quadrant versus bottom-right quadrant\"\n    h, w = image.shape\n    top_left = image[:h//2, :w//2]\n    bottom_right = image[h//2:, w//2:]\n    tl_mean = np.mean(top_left)\n    br_mean = np.mean(bottom_right)\n    if br_mean == 0:\n        return 1.0 if tl_mean > 0 else 0.0\n    return float(tl_mean / br_mean)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of maximum width in top half versus bottom half\"\n    h, w = image.shape\n    if h == 0:\n        return 1.0\n    top_half = image[:h//2, :]\n    bottom_half = image[h//2:, :]\n    \n    top_widths = [np.sum(row > 0) for row in top_half]\n    bottom_widths = [np.sum(row > 0) for row in bottom_half]\n    \n    max_top = max(top_widths) if top_widths else 0\n    max_bottom = max(bottom_widths) if bottom_widths else 0\n    \n    if max_bottom == 0:\n        return float(max_top > 0)\n    return float(max_top / max_bottom)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Maximum vertical gap between non-zero pixels in center column\"\n    h, w = image.shape\n    if w == 0:\n        return 0.0\n    center_col = image[:, w//2]\n    nonzero_rows = np.where(center_col > np.mean(center_col))[0]\n    if len(nonzero_rows) < 2:\n        return float(h)\n    max_gap = 0\n    for i in range(1, len(nonzero_rows)):\n        gap = nonzero_rows[i] - nonzero_rows[i-1] - 1\n        max_gap = max(max_gap, gap)\n    return float(max_gap)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Vertical position of the row with maximum pixel intensity sum\"\n    h, w = image.shape\n    row_sums = np.sum(image, axis=1)\n    max_row = np.argmax(row_sums)\n    return float(max_row / h)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Horizontal extent of the topmost non-zero pixels\"\n    h, w = image.shape\n    for row in range(h):\n        if np.any(image[row, :] > 0):\n            nonzero_cols = np.where(image[row, :] > 0)[0]\n            return float(nonzero_cols[-1] - nonzero_cols[0] + 1) / w\n    return 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Number of rows that contain pixels above the 90th percentile\"\n    if np.max(image) == 0:\n        return 0.0\n    threshold = np.percentile(image, 90)\n    rows_with_high_pixels = 0\n    for row in image:\n        if np.any(row >= threshold):\n            rows_with_high_pixels += 1\n    return float(rows_with_high_pixels)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Maximum width of continuous horizontal segments in the upper quarter\"\n    h, w = image.shape\n    upper_quarter = image[:h//4, :]\n    threshold = np.mean(upper_quarter) * 0.5\n    binary = upper_quarter > threshold\n    max_width = 0\n    for row in binary:\n        current_width = 0\n        for pixel in row:\n            if pixel:\n                current_width += 1\n                max_width = max(max_width, current_width)\n            else:\n                current_width = 0\n    return float(max_width / w)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of pixel density in upper third versus lower third of image\"\n    h, w = image.shape\n    upper_third = image[:h//3, :]\n    lower_third = image[2*h//3:, :]\n    upper_density = np.mean(upper_third) if upper_third.size > 0 else 0\n    lower_density = np.mean(lower_third) if lower_third.size > 0 else 0\n    return float(upper_density / (lower_density + 1e-8))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Intensity concentration in the center-right quadrant\"\n    h, w = image.shape\n    center_right = image[h//4:3*h//4, w//2:3*w//4]\n    if center_right.size == 0:\n        return 0.0\n    total_intensity = np.sum(image)\n    center_right_intensity = np.sum(center_right)\n    return float(center_right_intensity) / (total_intensity + 1e-10)\n",
    "def feature(image: np.ndarray) -> float:\n    \"Average width of non-zero regions per row in bottom half\"\n    h, w = image.shape\n    bottom_half = image[h//2:, :]\n    total_width = 0\n    valid_rows = 0\n    for row in bottom_half:\n        nonzero_indices = np.where(row > 0)[0]\n        if len(nonzero_indices) > 0:\n            width = nonzero_indices[-1] - nonzero_indices[0] + 1\n            total_width += width\n            valid_rows += 1\n    return float(total_width / valid_rows if valid_rows > 0 else 0)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Number of enclosed regions or loops in the image\"\n    h, w = image.shape\n    binary = (image > np.mean(image)).astype(int)\n    enclosed_count = 0\n    center_h, center_w = h//2, w//2\n    search_radius = min(h, w) // 4\n    for r in range(max(0, center_h - search_radius), min(h, center_h + search_radius)):\n        row = binary[r, :]\n        transitions = np.sum(np.abs(np.diff(row)))\n        if transitions >= 4:\n            enclosed_count += 1\n    return float(enclosed_count)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Number of columns with peak intensity in the top third\"\n    h, w = image.shape\n    if h < 3:\n        return 0.0\n    top_third = h // 3\n    count = 0\n    for col in range(w):\n        column = image[:, col]\n        if len(column) > 0:\n            max_pos = np.argmax(column)\n            if max_pos < top_third:\n                count += 1\n    return float(count)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of pixels in top half versus bottom half of image\"\n    h, w = image.shape\n    if h == 0:\n        return 0.0\n    top_half = np.sum(image[:h//2, :])\n    bottom_half = np.sum(image[h//2:, :])\n    if bottom_half == 0:\n        return float('inf') if top_half > 0 else 0.0\n    return float(top_half / bottom_half)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of non-zero pixels in top-right quadrant versus bottom-right quadrant\"\n    h, w = image.shape\n    top_right = image[:h//2, w//2:]\n    bottom_right = image[h//2:, w//2:]\n    top_count = np.count_nonzero(top_right)\n    bottom_count = np.count_nonzero(bottom_right)\n    if top_count + bottom_count == 0:\n        return 0.5\n    return float(top_count / (top_count + bottom_count))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Intensity difference between center pixel and image mean\"\n    h, w = image.shape\n    if h == 0 or w == 0:\n        return 0.0\n    center_pixel = image[h//2, w//2]\n    image_mean = np.mean(image)\n    return float(abs(center_pixel - image_mean))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Count of vertical line segments in the left half of the image\"\n    h, w = image.shape\n    left_half = image[:, :w//2]\n    transitions = 0\n    for col in range(left_half.shape[1]):\n        column = left_half[:, col]\n        in_segment = False\n        segment_length = 0\n        for pixel in column:\n            if pixel > 0:\n                if not in_segment:\n                    in_segment = True\n                    segment_length = 1\n                else:\n                    segment_length += 1\n            else:\n                if in_segment and segment_length >= 3:\n                    transitions += 1\n                in_segment = False\n                segment_length = 0\n        if in_segment and segment_length >= 3:\n            transitions += 1\n    return float(transitions)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Maximum consecutive foreground pixels in any diagonal direction\"\n    h, w = image.shape\n    if h == 0 or w == 0:\n        return 0.0\n    \n    threshold = np.mean(image)\n    max_diagonal = 0\n    \n    # Check main diagonals\n    for start_row in range(h):\n        # Down-right diagonal\n        count = 0\n        max_count = 0\n        r, c = start_row, 0\n        while r < h and c < w:\n            if image[r, c] > threshold:\n                count += 1\n                max_count = max(max_count, count)\n            else:\n                count = 0\n            r += 1\n            c += 1\n        max_diagonal = max(max_diagonal, max_count)\n    \n    return float(max_diagonal)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Number of distinct vertical runs of foreground pixels in the middle column\"\n    h, w = image.shape\n    middle_col = image[:, w//2]\n    threshold = np.mean(image)\n    binary_col = (middle_col > threshold).astype(int)\n    transitions = np.diff(binary_col)\n    runs = np.sum(transitions == 1)\n    return float(runs)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Number of diagonal transitions from bottom-left to top-right direction\"\n    h, w = image.shape\n    if h < 2 or w < 2:\n        return 0.0\n    transitions = 0\n    for i in range(h - 1):\n        for j in range(w - 1):\n            if (image[i+1, j] > 0) != (image[i, j+1] > 0):\n                transitions += 1\n    return float(transitions)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of vertical gradients in upper half versus lower half\"\n    h, w = image.shape\n    grad_y = np.gradient(image, axis=0)\n    upper_grad = np.sum(np.abs(grad_y[:h//2, :]))\n    lower_grad = np.sum(np.abs(grad_y[h//2:, :]))\n    if lower_grad == 0:\n        return float(upper_grad > 0)\n    return float(upper_grad / lower_grad)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Intensity concentration in the center-right quadrant\"\n    h, w = image.shape\n    center_right = image[h//4:3*h//4, w//2:3*w//4]\n    if center_right.size == 0:\n        return 0.0\n    total_intensity = np.sum(image)\n    center_right_intensity = np.sum(center_right)\n    return float(center_right_intensity) / (total_intensity + 1e-10)\n",
    "def feature(image: np.ndarray) -> float:\n    \"Width of the narrowest horizontal cross-section in the middle vertical region\"\n    h, w = image.shape\n    if h == 0:\n        return 0.0\n    middle_start, middle_end = h // 3, 2 * h // 3\n    min_width = w\n    for row in range(middle_start, middle_end):\n        non_zero_cols = np.where(image[row, :] > 0)[0]\n        if len(non_zero_cols) > 0:\n            width = non_zero_cols[-1] - non_zero_cols[0] + 1\n            min_width = min(min_width, width)\n    return float(min_width / w if w > 0 else 0.0)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Vertical extent of the topmost significant pixel cluster\"\n    h, w = image.shape\n    top_quarter = image[:h//4, :]\n    if top_quarter.size == 0:\n        return 0.0\n    nonzero_rows = np.where(np.sum(top_quarter, axis=1) > 0)[0]\n    if len(nonzero_rows) == 0:\n        return 0.0\n    vertical_extent = len(nonzero_rows)\n    return float(vertical_extent / max(h//4, 1))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Gradient magnitude concentration in the lower half of the image\"\n    h, w = image.shape\n    grad_y, grad_x = np.gradient(image.astype(float))\n    gradient_magnitude = np.sqrt(grad_x**2 + grad_y**2)\n    lower_half = gradient_magnitude[h//2:, :]\n    total_gradient = np.sum(gradient_magnitude)\n    return float(np.sum(lower_half) / max(total_gradient, 1e-6))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Average vertical position of the rightmost non-zero pixels\"\n    h, w = image.shape\n    if h == 0 or w == 0:\n        return 0.0\n    rightmost_positions = []\n    for col_idx in range(w-1, -1, -1):\n        col = image[:, col_idx]\n        nonzero_rows = np.where(col > 0)[0]\n        if len(nonzero_rows) > 0:\n            rightmost_positions.extend(nonzero_rows)\n            break\n    if len(rightmost_positions) == 0:\n        return 0.0\n    return float(np.mean(rightmost_positions) / h)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of non-zero pixels in bottom quarter versus middle half\"\n    h, w = image.shape\n    if h < 4:\n        return 0.0\n    bottom_quarter = image[3*h//4:, :]\n    middle_half = image[h//4:3*h//4, :]\n    bottom_count = np.count_nonzero(bottom_quarter)\n    middle_count = np.count_nonzero(middle_half)\n    if middle_count == 0:\n        return float('inf') if bottom_count > 0 else 0.0\n    return float(bottom_count / middle_count)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Vertical density gradient from center to bottom of image\"\n    h, w = image.shape\n    if h < 4:\n        return 0.0\n    center_strip = image[h//2:3*h//4, :]\n    bottom_strip = image[3*h//4:, :]\n    center_density = np.mean(center_strip) if center_strip.size > 0 else 0.0\n    bottom_density = np.mean(bottom_strip) if bottom_strip.size > 0 else 0.0\n    return float(bottom_density - center_density)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of pixel intensity in bottom third to middle third\"\n    h, w = image.shape\n    if h < 3:\n        return 0.0\n    middle_third = image[h//3:2*h//3, :]\n    bottom_third = image[2*h//3:, :]\n    middle_sum = np.sum(middle_third)\n    bottom_sum = np.sum(bottom_third)\n    if middle_sum == 0:\n        return 0.0\n    return float(bottom_sum / middle_sum)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Presence of horizontal line in upper third of image\"\n    h, w = image.shape\n    upper_third = image[:h//3, :]\n    horizontal_intensity = 0\n    for row in range(upper_third.shape[0]):\n        row_sum = np.sum(upper_third[row, :])\n        if row_sum > horizontal_intensity:\n            horizontal_intensity = row_sum\n    return float(horizontal_intensity / (w * 255) if w > 0 else 0.0)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of maximum to minimum row intensity in the middle third of image\"\n    h, w = image.shape\n    middle_third = image[h//3:2*h//3, :]\n    if middle_third.size == 0:\n        return 1.0\n    row_sums = np.sum(middle_third, axis=1)\n    if len(row_sums) == 0:\n        return 1.0\n    max_row = np.max(row_sums)\n    min_row = np.min(row_sums)\n    if min_row == 0:\n        return float(max_row) if max_row > 0 else 1.0\n    return float(max_row / min_row)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Average width of non-zero regions per row in bottom half\"\n    h, w = image.shape\n    bottom_half = image[h//2:, :]\n    total_width = 0\n    valid_rows = 0\n    for row in bottom_half:\n        nonzero_indices = np.where(row > 0)[0]\n        if len(nonzero_indices) > 0:\n            width = nonzero_indices[-1] - nonzero_indices[0] + 1\n            total_width += width\n            valid_rows += 1\n    return float(total_width / valid_rows if valid_rows > 0 else 0)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Standard deviation of column sums in the middle third of image width\"\n    h, w = image.shape\n    if w == 0:\n        return 0.0\n    start_col = w // 3\n    end_col = 2 * w // 3\n    middle_section = image[:, start_col:end_col]\n    if middle_section.size == 0:\n        return 0.0\n    column_sums = np.sum(middle_section, axis=0)\n    return float(np.std(column_sums))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Number of enclosed regions or loops in the image\"\n    from scipy import ndimage\n    if image.size == 0:\n        return 0.0\n    binary = image > np.mean(image)\n    filled = ndimage.binary_fill_holes(binary)\n    loops = np.sum(filled) - np.sum(binary)\n    return float(loops)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Count of vertical transitions from non-zero to zero pixels in the middle third\"\n    h, w = image.shape\n    middle_third = image[h//3:2*h//3, :]\n    transitions = 0\n    for col in range(w):\n        column = middle_third[:, col]\n        for i in range(len(column) - 1):\n            if column[i] > 0 and column[i+1] == 0:\n                transitions += 1\n    return float(transitions)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Thickness variation of the stroke measured at multiple vertical positions\"\n    h, w = image.shape\n    thicknesses = []\n    for row_idx in range(h//4, 3*h//4):\n        row = image[row_idx, :]\n        nonzero_indices = np.where(row > 0)[0]\n        if len(nonzero_indices) > 0:\n            thickness = nonzero_indices[-1] - nonzero_indices[0] + 1\n            thicknesses.append(thickness)\n    if len(thicknesses) < 2:\n        return 0.0\n    return float(np.std(thicknesses))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Count of pixels above median in the upper-right eighth of image\"\n    h, w = image.shape\n    upper_right_eighth = image[:h//4, 3*w//4:]\n    median_val = np.median(image)\n    return float(np.sum(upper_right_eighth > median_val))\n",
    "def feature(image: np.ndarray) -> float:\n    \"Number of distinct connected components in the bottom half\"\n    h, w = image.shape\n    bottom_half = image[h//2:, :] > 0\n    if bottom_half.size == 0:\n        return 0.0\n    components = 0\n    visited = np.zeros_like(bottom_half)\n    for i in range(bottom_half.shape[0]):\n        for j in range(bottom_half.shape[1]):\n            if bottom_half[i, j] and not visited[i, j]:\n                components += 1\n                stack = [(i, j)]\n                while stack:\n                    ci, cj = stack.pop()\n                    if ci < 0 or ci >= bottom_half.shape[0] or cj < 0 or cj >= bottom_half.shape[1]:\n                        continue\n                    if visited[ci, cj] or not bottom_half[ci, cj]:\n                        continue\n                    visited[ci, cj] = True\n                    stack.extend([(ci+1, cj), (ci-1, cj), (ci, cj+1), (ci, cj-1)])\n    return float(components)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of pixels in top-left quadrant versus bottom-right quadrant\"\n    h, w = image.shape\n    top_left = image[:h//2, :w//2]\n    bottom_right = image[h//2:, w//2:]\n    top_left_count = np.count_nonzero(top_left)\n    bottom_right_count = np.count_nonzero(bottom_right)\n    if bottom_right_count == 0:\n        return float(top_left_count)\n    return float(top_left_count / bottom_right_count)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Concentration of mass in the rightmost third of the image\"\n    h, w = image.shape\n    right_third = image[:, 2*w//3:]\n    total_mass = np.sum(image)\n    right_mass = np.sum(right_third)\n    if total_mass == 0:\n        return 0.0\n    return float(right_mass / total_mass)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Intensity concentration in the center 3x3 region relative to total\"\n    h, w = image.shape\n    if h < 3 or w < 3:\n        return 0.0\n    center_h, center_w = h//2, w//2\n    center_3x3 = image[center_h-1:center_h+2, center_w-1:center_w+2]\n    center_sum = np.sum(center_3x3)\n    total_sum = np.sum(image)\n    if total_sum == 0:\n        return 0.0\n    return float(center_sum / total_sum)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Number of enclosed regions detected by checking connectivity\"\n    h, w = image.shape\n    binary = (image > 0).astype(int)\n    enclosed_count = 0\n    visited = np.zeros_like(binary)\n    \n    for i in range(1, h-1):\n        for j in range(1, w-1):\n            if binary[i, j] == 0 and visited[i, j] == 0:\n                stack = [(i, j)]\n                region_pixels = []\n                touches_border = False\n                \n                while stack:\n                    y, x = stack.pop()\n                    if visited[y, x] == 1:\n                        continue\n                    visited[y, x] = 1\n                    region_pixels.append((y, x))\n                    \n                    if y == 0 or y == h-1 or x == 0 or x == w-1:\n                        touches_border = True\n                    \n                    for dy, dx in [(-1,0), (1,0), (0,-1), (0,1)]:\n                        ny, nx = y + dy, x + dx\n                        if 0 <= ny < h and 0 <= nx < w and binary[ny, nx] == 0 and visited[ny, nx] == 0:\n                            stack.append((ny, nx))\n                \n                if not touches_border and len(region_pixels) > 2:\n                    enclosed_count += 1\n    \n    return float(enclosed_count)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Average vertical gradient magnitude in the middle columns\"\n    h, w = image.shape\n    middle_cols = image[:, w//4:3*w//4]\n    if middle_cols.size == 0:\n        return 0.0\n    grad_y = np.gradient(middle_cols, axis=0)\n    return float(np.mean(np.abs(grad_y)))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Maximum vertical position of any foreground pixel as ratio of image height\"\n    h, w = image.shape\n    if h == 0:\n        return 0.0\n    foreground_rows = np.where(np.any(image > 0, axis=1))[0]\n    if len(foreground_rows) == 0:\n        return 0.0\n    return float(np.max(foreground_rows) / h)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of pixels in top half versus bottom half of image\"\n    h, w = image.shape\n    if h == 0:\n        return 0.0\n    top_half = np.sum(image[:h//2, :])\n    bottom_half = np.sum(image[h//2:, :])\n    if bottom_half == 0:\n        return float('inf') if top_half > 0 else 0.0\n    return float(top_half / bottom_half)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of pixels in top half versus bottom half of image\"\n    h, w = image.shape\n    if h == 0:\n        return 0.0\n    top_half = np.sum(image[:h//2, :])\n    bottom_half = np.sum(image[h//2:, :])\n    if bottom_half == 0:\n        return float('inf') if top_half > 0 else 0.0\n    return float(top_half / bottom_half)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of pixel intensity in the upper third versus middle third of image\"\n    h, w = image.shape\n    upper_third = image[:h//3, :]\n    middle_third = image[h//3:2*h//3, :]\n    upper_mean = np.mean(upper_third)\n    middle_mean = np.mean(middle_third)\n    if middle_mean == 0:\n        return 0.0\n    return float(upper_mean / middle_mean)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of pixels in top half versus bottom half of image\"\n    h, w = image.shape\n    if h == 0:\n        return 0.0\n    top_half = np.sum(image[:h//2, :])\n    bottom_half = np.sum(image[h//2:, :])\n    if bottom_half == 0:\n        return float('inf') if top_half > 0 else 0.0\n    return float(top_half / bottom_half)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Intensity-weighted centroid distance from image center (y-coordinate)\"\n    h, w = image.shape\n    total_intensity = np.sum(image)\n    if total_intensity == 0:\n        return 0.0\n    \n    weighted_y = 0\n    for row in range(h):\n        for col in range(w):\n            weighted_y += row * image[row, col]\n    \n    centroid_y = weighted_y / total_intensity\n    center_y = h / 2\n    return float(abs(centroid_y - center_y))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Maximum pixel intensity in the bottom quarter of the image\"\n    h, w = image.shape\n    bottom_quarter = image[3*h//4:, :]\n    if bottom_quarter.size == 0:\n        return 0.0\n    return float(np.max(bottom_quarter))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Number of distinct vertical segments with high pixel density\"\n    h, w = image.shape\n    threshold = np.mean(image) * 0.4 if np.mean(image) > 0 else 0.1\n    segments = 0\n    for col in range(w):\n        column = image[:, col]\n        in_segment = False\n        for pixel in column:\n            if pixel > threshold and not in_segment:\n                segments += 1\n                in_segment = True\n            elif pixel <= threshold:\n                in_segment = False\n    return float(segments)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of pixels in top half versus bottom half of image\"\n    h, w = image.shape\n    if h == 0:\n        return 0.0\n    top_half = np.sum(image[:h//2, :])\n    bottom_half = np.sum(image[h//2:, :])\n    if bottom_half == 0:\n        return float('inf') if top_half > 0 else 0.0\n    return float(top_half / bottom_half)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of pixels in top half versus bottom half of image\"\n    h, w = image.shape\n    if h == 0:\n        return 0.0\n    top_half = np.sum(image[:h//2, :])\n    bottom_half = np.sum(image[h//2:, :])\n    if bottom_half == 0:\n        return float('inf') if top_half > 0 else 0.0\n    return float(top_half / bottom_half)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of pixels in top half versus bottom half of image\"\n    h, w = image.shape\n    if h == 0:\n        return 0.0\n    top_half = np.sum(image[:h//2, :])\n    bottom_half = np.sum(image[h//2:, :])\n    if bottom_half == 0:\n        return float('inf') if top_half > 0 else 0.0\n    return float(top_half / bottom_half)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of pixels in top half versus bottom half of image\"\n    h, w = image.shape\n    if h == 0:\n        return 0.0\n    top_half = np.sum(image[:h//2, :])\n    bottom_half = np.sum(image[h//2:, :])\n    if bottom_half == 0:\n        return float('inf') if top_half > 0 else 0.0\n    return float(top_half / bottom_half)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of pixels in top half versus bottom half of image\"\n    h, w = image.shape\n    if h == 0:\n        return 0.0\n    top_half = np.sum(image[:h//2, :])\n    bottom_half = np.sum(image[h//2:, :])\n    if bottom_half == 0:\n        return float('inf') if top_half > 0 else 0.0\n    return float(top_half / bottom_half)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of pixels in top half versus bottom half of image\"\n    h, w = image.shape\n    if h == 0:\n        return 0.0\n    top_half = np.sum(image[:h//2, :])\n    bottom_half = np.sum(image[h//2:, :])\n    if bottom_half == 0:\n        return float('inf') if top_half > 0 else 0.0\n    return float(top_half / bottom_half)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of pixels in top half versus bottom half of image\"\n    h, w = image.shape\n    if h == 0:\n        return 0.0\n    top_half = np.sum(image[:h//2, :])\n    bottom_half = np.sum(image[h//2:, :])\n    if bottom_half == 0:\n        return float('inf') if top_half > 0 else 0.0\n    return float(top_half / bottom_half)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of pixels in top half versus bottom half of image\"\n    h, w = image.shape\n    if h == 0:\n        return 0.0\n    top_half = np.sum(image[:h//2, :])\n    bottom_half = np.sum(image[h//2:, :])\n    if bottom_half == 0:\n        return float('inf') if top_half > 0 else 0.0\n    return float(top_half / bottom_half)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of pixels in top half versus bottom half of image\"\n    h, w = image.shape\n    if h == 0:\n        return 0.0\n    top_half = np.sum(image[:h//2, :])\n    bottom_half = np.sum(image[h//2:, :])\n    if bottom_half == 0:\n        return float('inf') if top_half > 0 else 0.0\n    return float(top_half / bottom_half)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Compactness measure: ratio of filled area to bounding box area\"\n    non_zero_coords = np.where(image > 0)\n    if len(non_zero_coords[0]) == 0:\n        return 0.0\n    min_row, max_row = np.min(non_zero_coords[0]), np.max(non_zero_coords[0])\n    min_col, max_col = np.min(non_zero_coords[1]), np.max(non_zero_coords[1])\n    bounding_area = (max_row - min_row + 1) * (max_col - min_col + 1)\n    filled_area = len(non_zero_coords[0])\n    return float(filled_area / bounding_area)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Density of high-intensity pixels in the outer border region\"\n    h, w = image.shape\n    border_width = min(h, w) // 8\n    if border_width == 0:\n        border_width = 1\n    border_mask = np.zeros((h, w), dtype=bool)\n    border_mask[:border_width, :] = True\n    border_mask[-border_width:, :] = True\n    border_mask[:, :border_width] = True\n    border_mask[:, -border_width:] = True\n    border_pixels = image[border_mask]\n    threshold = np.mean(image) + np.std(image)\n    return float(np.sum(border_pixels > threshold) / len(border_pixels) if len(border_pixels) > 0 else 0.0)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of pixels in top half versus bottom half of image\"\n    h, w = image.shape\n    if h == 0:\n        return 0.0\n    top_half = np.sum(image[:h//2, :])\n    bottom_half = np.sum(image[h//2:, :])\n    if bottom_half == 0:\n        return float('inf') if top_half > 0 else 0.0\n    return float(top_half / bottom_half)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Number of connected components in the upper half of the image\"\n    h, w = image.shape\n    if h < 2:\n        return 0.0\n    upper_half = image[:h//2, :] > 0\n    components = 0\n    visited = np.zeros_like(upper_half)\n    \n    for i in range(upper_half.shape[0]):\n        for j in range(upper_half.shape[1]):\n            if upper_half[i, j] and not visited[i, j]:\n                components += 1\n                stack = [(i, j)]\n                while stack:\n                    x, y = stack.pop()\n                    if x < 0 or x >= upper_half.shape[0] or y < 0 or y >= upper_half.shape[1]:\n                        continue\n                    if visited[x, y] or not upper_half[x, y]:\n                        continue\n                    visited[x, y] = True\n                    stack.extend([(x+1, y), (x-1, y), (x, y+1), (x, y-1)])\n    \n    return float(components)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of pixels in top half versus bottom half of image\"\n    h, w = image.shape\n    if h == 0:\n        return 0.0\n    top_half = np.sum(image[:h//2, :])\n    bottom_half = np.sum(image[h//2:, :])\n    if bottom_half == 0:\n        return float('inf') if top_half > 0 else 0.0\n    return float(top_half / bottom_half)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Coefficient of variation of row-wise pixel intensities\"\n    h, w = image.shape\n    if h == 0:\n        return 0.0\n    row_means = np.array([np.mean(image[i, :]) for i in range(h)])\n    mean_of_means = np.mean(row_means)\n    if mean_of_means == 0:\n        return 0.0\n    std_of_means = np.std(row_means)\n    return float(std_of_means / mean_of_means)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Density of pixels in the middle horizontal band relative to top and bottom thirds\"\n    h, w = image.shape\n    top_third = np.count_nonzero(image[:h//3, :])\n    middle_third = np.count_nonzero(image[h//3:2*h//3, :])\n    bottom_third = np.count_nonzero(image[2*h//3:, :])\n    total_edges = top_third + bottom_third\n    return float(middle_third / (total_edges + 1))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Intensity concentration in bottom-left quadrant\"\n    h, w = image.shape\n    bottom_left = image[h//2:, :w//2]\n    total_intensity = np.sum(image)\n    if total_intensity == 0:\n        return 0.0\n    bottom_left_intensity = np.sum(bottom_left)\n    return float(bottom_left_intensity / total_intensity)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of vertical gradients in upper half versus lower half\"\n    h, w = image.shape\n    grad_y = np.gradient(image, axis=0)\n    upper_grad = np.sum(np.abs(grad_y[:h//2, :]))\n    lower_grad = np.sum(np.abs(grad_y[h//2:, :]))\n    if lower_grad == 0:\n        return float(upper_grad > 0)\n    return float(upper_grad / lower_grad)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Intensity ratio between upper-middle and lower-middle regions\"\n    h, w = image.shape\n    upper_mid = image[h//4:h//2, w//4:3*w//4]\n    lower_mid = image[h//2:3*h//4, w//4:3*w//4]\n    upper_sum = np.sum(upper_mid)\n    lower_sum = np.sum(lower_mid)\n    if lower_sum == 0:\n        return 1.0 if upper_sum > 0 else 0.0\n    return float(upper_sum / (upper_sum + lower_sum))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of pixels in outer ring versus inner core of image\"\n    h, w = image.shape\n    margin = min(h, w) // 6\n    outer_ring = np.copy(image)\n    if margin > 0:\n        outer_ring[margin:-margin, margin:-margin] = 0\n    inner_core = image[margin:-margin, margin:-margin] if margin > 0 else image\n    outer_count = np.count_nonzero(outer_ring)\n    inner_count = np.count_nonzero(inner_core)\n    if inner_count == 0:\n        return float(outer_count)\n    return float(outer_count / inner_count)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of vertical gradient magnitude in left half versus right half\"\n    h, w = image.shape\n    grad_y = np.gradient(image, axis=0)\n    left_grad = np.abs(grad_y[:, :w//2])\n    right_grad = np.abs(grad_y[:, w//2:])\n    left_mag = np.mean(left_grad) if left_grad.size > 0 else 0\n    right_mag = np.mean(right_grad) if right_grad.size > 0 else 0\n    return float(left_mag / (right_mag + 0.001))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of filled pixels in middle-right region to middle-left region\"\n    h, w = image.shape\n    mid_top, mid_bottom = h//3, 2*h//3\n    left_region = image[mid_top:mid_bottom, :w//2]\n    right_region = image[mid_top:mid_bottom, w//2:]\n    left_count = np.count_nonzero(left_region) if left_region.size > 0 else 1\n    right_count = np.count_nonzero(right_region) if right_region.size > 0 else 0\n    return float(right_count / max(left_count, 1))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Density of non-zero pixels in the center square region\"\n    h, w = image.shape\n    center_size = min(h, w) // 3\n    start_h, start_w = (h - center_size) // 2, (w - center_size) // 2\n    center_region = image[start_h:start_h + center_size, start_w:start_w + center_size]\n    total_pixels = center_region.size\n    if total_pixels == 0:\n        return 0.0\n    return float(np.count_nonzero(center_region) / total_pixels)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Symmetry score of the central circular region\"\n    h, w = image.shape\n    center_h, center_w = h // 2, w // 2\n    radius = min(h, w) // 4\n    if radius == 0:\n        return 0.0\n    symmetry_sum = 0.0\n    count = 0\n    for angle in np.linspace(0, np.pi, 16):\n        for r in range(1, radius):\n            x1 = int(center_w + r * np.cos(angle))\n            y1 = int(center_h + r * np.sin(angle))\n            x2 = int(center_w - r * np.cos(angle))\n            y2 = int(center_h - r * np.sin(angle))\n            if 0 <= x1 < w and 0 <= y1 < h and 0 <= x2 < w and 0 <= y2 < h:\n                symmetry_sum += abs(image[y1, x1] - image[y2, x2])\n                count += 1\n    return float(symmetry_sum / count if count > 0 else 0.0)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Compactness measure: ratio of filled area to bounding box area\"\n    h, w = image.shape\n    if h == 0 or w == 0:\n        return 0.0\n    \n    # Find bounding box of non-zero pixels\n    nonzero_rows, nonzero_cols = np.where(image > np.mean(image))\n    \n    if len(nonzero_rows) == 0:\n        return 0.0\n    \n    min_row, max_row = np.min(nonzero_rows), np.max(nonzero_rows)\n    min_col, max_col = np.min(nonzero_cols), np.max(nonzero_cols)\n    \n    bounding_area = (max_row - min_row + 1) * (max_col - min_col + 1)\n    filled_area = len(nonzero_rows)\n    \n    return float(filled_area / bounding_area) if bounding_area > 0 else 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of pixels in top half versus bottom half of image\"\n    h, w = image.shape\n    if h == 0:\n        return 0.0\n    top_half = np.sum(image[:h//2, :])\n    bottom_half = np.sum(image[h//2:, :])\n    if bottom_half == 0:\n        return float('inf') if top_half > 0 else 0.0\n    return float(top_half / bottom_half)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of left half intensity to right half intensity\"\n    h, w = image.shape\n    left_half = image[:, :w//2]\n    right_half = image[:, w//2:]\n    left_sum = np.sum(left_half)\n    right_sum = np.sum(right_half)\n    if right_sum == 0:\n        return 1.0 if left_sum > 0 else 0.0\n    return float(left_sum / right_sum)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of pixels in top half versus bottom half of image\"\n    h, w = image.shape\n    if h == 0:\n        return 0.0\n    top_half = np.sum(image[:h//2, :])\n    bottom_half = np.sum(image[h//2:, :])\n    if bottom_half == 0:\n        return float('inf') if top_half > 0 else 0.0\n    return float(top_half / bottom_half)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of pixels in top half versus bottom half of image\"\n    h, w = image.shape\n    if h == 0:\n        return 0.0\n    top_half = np.sum(image[:h//2, :])\n    bottom_half = np.sum(image[h//2:, :])\n    if bottom_half == 0:\n        return float('inf') if top_half > 0 else 0.0\n    return float(top_half / bottom_half)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of pixels in top half versus bottom half of image\"\n    h, w = image.shape\n    if h == 0:\n        return 0.0\n    top_half = np.sum(image[:h//2, :])\n    bottom_half = np.sum(image[h//2:, :])\n    if bottom_half == 0:\n        return float('inf') if top_half > 0 else 0.0\n    return float(top_half / bottom_half)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Number of rows that contain non-zero pixels in both left and right halves\"\n    h, w = image.shape\n    if w < 2:\n        return 0.0\n    mid_col = w // 2\n    connected_rows = 0\n    for row in range(h):\n        left_has_pixels = np.any(image[row, :mid_col] > 0)\n        right_has_pixels = np.any(image[row, mid_col:] > 0)\n        if left_has_pixels and right_has_pixels:\n            connected_rows += 1\n    return float(connected_rows)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of vertical edge strength to horizontal edge strength\"\n    if image.size == 0:\n        return 0.0\n    grad_y, grad_x = np.gradient(image)\n    vertical_strength = np.sum(np.abs(grad_x))\n    horizontal_strength = np.sum(np.abs(grad_y))\n    if horizontal_strength == 0:\n        return 1.0 if vertical_strength > 0 else 0.0\n    return float(vertical_strength / horizontal_strength)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Average intensity difference between adjacent horizontal pixels\"\n    h, w = image.shape\n    if h == 0 or w < 2:\n        return 0.0\n    diff_sum = 0.0\n    count = 0\n    for i in range(h):\n        for j in range(w-1):\n            diff_sum += abs(float(image[i, j]) - float(image[i, j+1]))\n            count += 1\n    return diff_sum / count if count > 0 else 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Maximum number of consecutive white pixels in any row\"\n    h, w = image.shape\n    if h == 0 or w == 0:\n        return 0.0\n    threshold = np.mean(image)\n    max_consecutive = 0\n    for i in range(h):\n        current_consecutive = 0\n        for j in range(w):\n            if image[i, j] > threshold:\n                current_consecutive += 1\n                max_consecutive = max(max_consecutive, current_consecutive)\n            else:\n                current_consecutive = 0\n    return float(max_consecutive)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of vertical edge strength to horizontal edge strength\"\n    if image.size == 0:\n        return 0.0\n    grad_y, grad_x = np.gradient(image)\n    vertical_strength = np.sum(np.abs(grad_x))\n    horizontal_strength = np.sum(np.abs(grad_y))\n    if horizontal_strength == 0:\n        return 1.0 if vertical_strength > 0 else 0.0\n    return float(vertical_strength / horizontal_strength)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of pixels in top half versus bottom half of image\"\n    h, w = image.shape\n    if h == 0:\n        return 0.0\n    top_half = np.sum(image[:h//2, :])\n    bottom_half = np.sum(image[h//2:, :])\n    if bottom_half == 0:\n        return float('inf') if top_half > 0 else 0.0\n    return float(top_half / bottom_half)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of pixels in top half versus bottom half of image\"\n    h, w = image.shape\n    if h == 0:\n        return 0.0\n    top_half = np.sum(image[:h//2, :])\n    bottom_half = np.sum(image[h//2:, :])\n    if bottom_half == 0:\n        return float('inf') if top_half > 0 else 0.0\n    return float(top_half / bottom_half)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of pixels in top-left quadrant versus bottom-right quadrant\"\n    h, w = image.shape\n    top_left = image[:h//2, :w//2]\n    bottom_right = image[h//2:, w//2:]\n    top_left_count = np.count_nonzero(top_left)\n    bottom_right_count = np.count_nonzero(bottom_right)\n    if bottom_right_count == 0:\n        return float(top_left_count)\n    return float(top_left_count / bottom_right_count)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of pixels in top-left quadrant versus bottom-right quadrant\"\n    h, w = image.shape\n    top_left = image[:h//2, :w//2]\n    bottom_right = image[h//2:, w//2:]\n    top_left_count = np.count_nonzero(top_left)\n    bottom_right_count = np.count_nonzero(bottom_right)\n    if bottom_right_count == 0:\n        return float(top_left_count)\n    return float(top_left_count / bottom_right_count)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Maximum vertical position of any foreground pixel as ratio of image height\"\n    h, w = image.shape\n    if h == 0:\n        return 0.0\n    foreground_rows = np.where(np.any(image > 0, axis=1))[0]\n    if len(foreground_rows) == 0:\n        return 0.0\n    return float(np.max(foreground_rows) / h)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Average distance from center to non-zero pixels in the outer ring\"\n    h, w = image.shape\n    center_h, center_w = h // 2, w // 2\n    distances = []\n    # Define outer ring as pixels not in the middle third\n    for i in range(h):\n        for j in range(w):\n            if image[i, j] > 0 and (i < h//3 or i >= 2*h//3 or j < w//3 or j >= 2*w//3):\n                dist = np.sqrt((i - center_h)**2 + (j - center_w)**2)\n                distances.append(dist)\n    return float(np.mean(distances) if distances else 0.0)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Count of connected high-intensity regions in middle vertical strip\"\n    h, w = image.shape\n    middle_strip = image[:, w//3:2*w//3]\n    threshold = np.percentile(middle_strip, 60)\n    binary_strip = (middle_strip > threshold).astype(int)\n    transitions = np.sum(np.diff(binary_strip, axis=1) != 0)\n    return float(transitions)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Coefficient of variation of row-wise pixel intensities\"\n    h, w = image.shape\n    if h == 0:\n        return 0.0\n    row_means = np.array([np.mean(image[i, :]) for i in range(h)])\n    mean_of_means = np.mean(row_means)\n    if mean_of_means == 0:\n        return 0.0\n    std_of_means = np.std(row_means)\n    return float(std_of_means / mean_of_means)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Vertical extent of non-zero pixels as fraction of image height\"\n    if image.size == 0:\n        return 0.0\n    nonzero_rows = np.any(image > np.mean(image), axis=1)\n    if not np.any(nonzero_rows):\n        return 0.0\n    first_row = np.argmax(nonzero_rows)\n    last_row = len(nonzero_rows) - 1 - np.argmax(nonzero_rows[::-1])\n    return float((last_row - first_row + 1) / image.shape[0])\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of pixel intensity in the upper third versus middle third of image\"\n    h, w = image.shape\n    upper_third = image[:h//3, :]\n    middle_third = image[h//3:2*h//3, :]\n    upper_mean = np.mean(upper_third)\n    middle_mean = np.mean(middle_third)\n    if middle_mean == 0:\n        return 0.0\n    return float(upper_mean / middle_mean)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of pixels in top half versus bottom half of image\"\n    h, w = image.shape\n    if h == 0:\n        return 0.0\n    top_half = np.sum(image[:h//2, :])\n    bottom_half = np.sum(image[h//2:, :])\n    if bottom_half == 0:\n        return float('inf') if top_half > 0 else 0.0\n    return float(top_half / bottom_half)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Horizontal symmetry score comparing left and right halves\"\n    h, w = image.shape\n    if w == 0:\n        return 0.0\n    left_half = image[:, :w//2]\n    right_half = image[:, w//2:]\n    right_flipped = np.fliplr(right_half)\n    min_width = min(left_half.shape[1], right_flipped.shape[1])\n    if min_width == 0:\n        return 0.0\n    left_crop = left_half[:, :min_width]\n    right_crop = right_flipped[:, :min_width]\n    diff = np.mean(np.abs(left_crop - right_crop))\n    max_val = max(np.mean(left_crop), np.mean(right_crop))\n    if max_val == 0:\n        return 1.0\n    return float(1.0 - diff / max_val)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of vertical gradient magnitude in left half versus right half\"\n    h, w = image.shape\n    grad_y = np.gradient(image, axis=0)\n    left_grad = np.abs(grad_y[:, :w//2])\n    right_grad = np.abs(grad_y[:, w//2:])\n    left_mag = np.mean(left_grad) if left_grad.size > 0 else 0\n    right_mag = np.mean(right_grad) if right_grad.size > 0 else 0\n    return float(left_mag / (right_mag + 0.001))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of pixels in top half versus bottom half of image\"\n    h, w = image.shape\n    if h == 0:\n        return 0.0\n    top_half = np.sum(image[:h//2, :])\n    bottom_half = np.sum(image[h//2:, :])\n    if bottom_half == 0:\n        return float('inf') if top_half > 0 else 0.0\n    return float(top_half / bottom_half)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Average vertical gradient magnitude in the center column\"\n    h, w = image.shape\n    if w == 0:\n        return 0.0\n    center_col = image[:, w//2]\n    if len(center_col) < 2:\n        return 0.0\n    gradients = np.abs(np.diff(center_col.astype(float)))\n    return float(np.mean(gradients))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Presence of a curved bottom section connecting left and right sides\"\n    h, w = image.shape\n    bottom_quarter = image[3*h//4:, :]\n    curve_score = 0\n    for i, row in enumerate(bottom_quarter):\n        nonzero_indices = np.where(row > 0)[0]\n        if len(nonzero_indices) > w//4:  # Substantial horizontal presence\n            # Weight rows closer to bottom more heavily\n            weight = (i + 1) / len(bottom_quarter)\n            curve_score += weight * len(nonzero_indices) / w\n    return float(curve_score)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Density of pixels in the upper-middle region relative to total foreground\"\n    h, w = image.shape\n    if h == 0 or w == 0:\n        return 0.0\n    \n    total_foreground = np.count_nonzero(image > np.mean(image))\n    if total_foreground == 0:\n        return 0.0\n    \n    # Upper-middle region\n    upper_mid = image[h//6:h//2, w//4:3*w//4]\n    upper_mid_pixels = np.count_nonzero(upper_mid > np.mean(image))\n    \n    return float(upper_mid_pixels / total_foreground)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Intensity concentration in the center-right quadrant\"\n    h, w = image.shape\n    center_right = image[h//4:3*h//4, w//2:3*w//4]\n    if center_right.size == 0:\n        return 0.0\n    total_intensity = np.sum(image)\n    center_right_intensity = np.sum(center_right)\n    return float(center_right_intensity) / (total_intensity + 1e-10)\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of non-zero pixels in the leftmost quarter versus rightmost quarter\"\n    h, w = image.shape\n    left_quarter = image[:, :w//4]\n    right_quarter = image[:, 3*w//4:]\n    left_pixels = np.count_nonzero(left_quarter)\n    right_pixels = np.count_nonzero(right_quarter)\n    if right_pixels == 0:\n        return float(left_pixels)\n    return float(left_pixels / right_pixels)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of pixels in top half versus bottom half of image\"\n    h, w = image.shape\n    if h == 0:\n        return 0.0\n    top_half = np.sum(image[:h//2, :])\n    bottom_half = np.sum(image[h//2:, :])\n    if bottom_half == 0:\n        return float('inf') if top_half > 0 else 0.0\n    return float(top_half / bottom_half)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of pixel sum in bottom-right quadrant to total pixel sum\"\n    h, w = image.shape\n    if h < 2 or w < 2:\n        return 0.0\n    bottom_right = image[h//2:, w//2:]\n    total_sum = np.sum(image)\n    if total_sum == 0:\n        return 0.0\n    return float(np.sum(bottom_right) / total_sum)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Average horizontal gradient magnitude in the bottom half\"\n    h, w = image.shape\n    bottom_half = image[h//2:, :]\n    if bottom_half.size == 0:\n        return 0.0\n    grad_x = np.gradient(bottom_half, axis=1)\n    return float(np.mean(np.abs(grad_x)))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Standard deviation of pixel intensities along the main diagonal\"\n    h, w = image.shape\n    min_dim = min(h, w)\n    diagonal_pixels = np.array([image[i, i] for i in range(min_dim)])\n    return float(np.std(diagonal_pixels))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Density of non-zero pixels in the bottom third of the image\"\n    h, w = image.shape\n    bottom_third = image[2*h//3:, :]\n    total_pixels = bottom_third.size\n    if total_pixels == 0:\n        return 0.0\n    return float(np.count_nonzero(bottom_third) / total_pixels)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of horizontal edge strength in middle rows to edge strength in outer rows\"\n    h, w = image.shape\n    if h < 6:\n        return 0.0\n    gradients = np.abs(np.gradient(image, axis=1))\n    middle_third = gradients[h//3:2*h//3, :]\n    outer_thirds = np.concatenate([gradients[:h//3, :], gradients[2*h//3:, :]])\n    middle_strength = np.mean(middle_third) if middle_third.size > 0 else 0.0\n    outer_strength = np.mean(outer_thirds) if outer_thirds.size > 0 else 0.0\n    return middle_strength / (outer_strength + 1e-6)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Horizontal gradient magnitude in the middle row\"\n    h, w = image.shape\n    if h == 0 or w < 2:\n        return 0.0\n    middle_row = image[h//2, :]\n    gradient = np.gradient(middle_row)\n    return float(np.mean(np.abs(gradient)))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Maximum vertical run length in the right half of the image\"\n    h, w = image.shape\n    right_half = image[:, w//2:]\n    max_run = 0\n    for col in range(right_half.shape[1]):\n        column = right_half[:, col]\n        current_run = 0\n        local_max = 0\n        for pixel in column:\n            if pixel > 0:\n                current_run += 1\n                local_max = max(local_max, current_run)\n            else:\n                current_run = 0\n        max_run = max(max_run, local_max)\n    return float(max_run / h if h > 0 else 0.0)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of pixel intensity variance in top third versus middle third\"\n    h, w = image.shape\n    top_third = image[:h//3, :]\n    middle_third = image[h//3:2*h//3, :]\n    top_var = np.var(top_third)\n    middle_var = np.var(middle_third)\n    if middle_var == 0:\n        return float(top_var)\n    return float(top_var / middle_var)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Number of enclosed regions or loops in the image\"\n    from scipy import ndimage\n    if image.size == 0:\n        return 0.0\n    binary = image > np.mean(image)\n    filled = ndimage.binary_fill_holes(binary)\n    loops = np.sum(filled) - np.sum(binary)\n    return float(loops)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Horizontal gradient variance in the middle third of image height\"\n    h, w = image.shape\n    middle_section = image[h//3:2*h//3, :]\n    grad_x = np.gradient(middle_section, axis=1)\n    return float(np.var(grad_x))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of maximum width in top half versus bottom half\"\n    h, w = image.shape\n    if h == 0:\n        return 1.0\n    top_half = image[:h//2, :]\n    bottom_half = image[h//2:, :]\n    \n    top_widths = [np.sum(row > 0) for row in top_half]\n    bottom_widths = [np.sum(row > 0) for row in bottom_half]\n    \n    max_top = max(top_widths) if top_widths else 0\n    max_bottom = max(bottom_widths) if bottom_widths else 0\n    \n    if max_bottom == 0:\n        return float(max_top > 0)\n    return float(max_top / max_bottom)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Average distance of high-intensity pixels from image center\"\n    h, w = image.shape\n    center_y, center_x = h // 2, w // 2\n    threshold = np.percentile(image, 75)\n    high_pixels = np.where(image > threshold)\n    if len(high_pixels[0]) == 0:\n        return 0.0\n    distances = np.sqrt((high_pixels[0] - center_y)**2 + (high_pixels[1] - center_x)**2)\n    return float(np.mean(distances))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Number of horizontal line segments in the middle region\"\n    h, w = image.shape\n    middle_region = image[h//3:2*h//3, :]\n    threshold = np.mean(middle_region) if np.mean(middle_region) > 0 else 0.1\n    binary = (middle_region > threshold).astype(int)\n    horizontal_lines = 0\n    for row in binary:\n        in_segment = False\n        for pixel in row:\n            if pixel > 0 and not in_segment:\n                horizontal_lines += 1\n                in_segment = True\n            elif pixel == 0:\n                in_segment = False\n    return float(horizontal_lines)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Number of distinct connected regions in the bottom quarter of image\"\n    h, w = image.shape\n    bottom_quarter = image[3*h//4:, :]\n    threshold = np.mean(bottom_quarter) + np.std(bottom_quarter)\n    binary = (bottom_quarter > threshold).astype(int)\n    regions = 0\n    visited = np.zeros_like(binary)\n    for i in range(binary.shape[0]):\n        for j in range(binary.shape[1]):\n            if binary[i, j] and not visited[i, j]:\n                regions += 1\n                stack = [(i, j)]\n                while stack:\n                    ci, cj = stack.pop()\n                    if 0 <= ci < binary.shape[0] and 0 <= cj < binary.shape[1] and binary[ci, cj] and not visited[ci, cj]:\n                        visited[ci, cj] = 1\n                        stack.extend([(ci+1, cj), (ci-1, cj), (ci, cj+1), (ci, cj-1)])\n    return float(regions)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of vertical gradients in upper half versus lower half\"\n    h, w = image.shape\n    grad_y = np.gradient(image, axis=0)\n    upper_grad = np.sum(np.abs(grad_y[:h//2, :]))\n    lower_grad = np.sum(np.abs(grad_y[h//2:, :]))\n    if lower_grad == 0:\n        return float(upper_grad > 0)\n    return float(upper_grad / lower_grad)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Intensity concentration in the center-right quadrant\"\n    h, w = image.shape\n    center_right = image[h//4:3*h//4, w//2:3*w//4]\n    if center_right.size == 0:\n        return 0.0\n    total_intensity = np.sum(image)\n    center_right_intensity = np.sum(center_right)\n    return float(center_right_intensity) / (total_intensity + 1e-10)\n",
    "def feature(image: np.ndarray) -> float:\n    \"Intensity concentration in the center 3x3 region relative to total\"\n    h, w = image.shape\n    if h < 3 or w < 3:\n        return 0.0\n    center_h, center_w = h//2, w//2\n    center_3x3 = image[center_h-1:center_h+2, center_w-1:center_w+2]\n    center_sum = np.sum(center_3x3)\n    total_sum = np.sum(image)\n    if total_sum == 0:\n        return 0.0\n    return float(center_sum / total_sum)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Number of vertical runs of consecutive non-zero pixels\"\n    h, w = image.shape\n    runs = 0\n    for col in range(w):\n        in_run = False\n        for row in range(h):\n            if image[row, col] > 0:\n                if not in_run:\n                    runs += 1\n                    in_run = True\n            else:\n                in_run = False\n    return float(runs)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of diagonal line segments to horizontal line segments\"\n    h, w = image.shape\n    threshold = np.mean(image) * 0.5\n    binary = (image > threshold).astype(int)\n    horizontal_lines = 0\n    diagonal_lines = 0\n    for i in range(h):\n        for j in range(w-2):\n            if np.all(binary[i, j:j+3] > 0):\n                horizontal_lines += 1\n    for i in range(h-2):\n        for j in range(w-2):\n            if binary[i,j] > 0 and binary[i+1,j+1] > 0 and binary[i+2,j+2] > 0:\n                diagonal_lines += 1\n    return float(diagonal_lines / (horizontal_lines + 1e-6))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of non-zero pixels in bottom quarter versus middle half\"\n    h, w = image.shape\n    if h < 4:\n        return 0.0\n    bottom_quarter = image[3*h//4:, :]\n    middle_half = image[h//4:3*h//4, :]\n    bottom_count = np.count_nonzero(bottom_quarter)\n    middle_count = np.count_nonzero(middle_half)\n    if middle_count == 0:\n        return float('inf') if bottom_count > 0 else 0.0\n    return float(bottom_count / middle_count)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Thickness variation of the stroke measured at multiple vertical positions\"\n    h, w = image.shape\n    thicknesses = []\n    for row_idx in range(h//4, 3*h//4):\n        row = image[row_idx, :]\n        nonzero_indices = np.where(row > 0)[0]\n        if len(nonzero_indices) > 0:\n            thickness = nonzero_indices[-1] - nonzero_indices[0] + 1\n            thicknesses.append(thickness)\n    if len(thicknesses) < 2:\n        return 0.0\n    return float(np.std(thicknesses))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Number of vertical line segments in the center column\"\n    h, w = image.shape\n    if w == 0:\n        return 0.0\n    center_col = image[:, w//2]\n    threshold = np.mean(center_col) + np.std(center_col) if np.std(center_col) > 0 else np.mean(center_col)\n    binary_col = (center_col > threshold).astype(int)\n    segments = 0\n    in_segment = False\n    for pixel in binary_col:\n        if pixel == 1 and not in_segment:\n            segments += 1\n            in_segment = True\n        elif pixel == 0:\n            in_segment = False\n    return float(segments)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Concentration of high intensity pixels in the center-right region\"\n    h, w = image.shape\n    center_right = image[h//4:3*h//4, w//2:3*w//4]\n    threshold = np.percentile(image, 75)\n    high_intensity_count = np.sum(center_right > threshold)\n    total_pixels = center_right.size\n    if total_pixels == 0:\n        return 0.0\n    return float(high_intensity_count / total_pixels)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Number of intensity peaks in the middle horizontal slice\"\n    h, w = image.shape\n    if h == 0:\n        return 0.0\n    middle_row = image[h//2, :]\n    peaks = 0\n    for i in range(1, len(middle_row) - 1):\n        if middle_row[i] > middle_row[i-1] and middle_row[i] > middle_row[i+1] and middle_row[i] > 0:\n            peaks += 1\n    return float(peaks)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Number of rows where the rightmost non-zero pixel is in the right third\"\n    h, w = image.shape\n    count = 0\n    right_boundary = 2 * w // 3\n    for row in range(h):\n        nonzero_cols = np.where(image[row, :] > 0)[0]\n        if len(nonzero_cols) > 0 and nonzero_cols[-1] >= right_boundary:\n            count += 1\n    return float(count)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of pixels in top half versus bottom half of image\"\n    h, w = image.shape\n    if h == 0:\n        return 0.0\n    top_half = np.sum(image[:h//2, :])\n    bottom_half = np.sum(image[h//2:, :])\n    if bottom_half == 0:\n        return float('inf') if top_half > 0 else 0.0\n    return float(top_half / bottom_half)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Number of enclosed regions by counting background-to-foreground transitions in middle rows\"\n    h, w = image.shape\n    if h < 4:\n        return 0.0\n    middle_rows = image[h//4:3*h//4, :]\n    transitions = 0\n    threshold = np.mean(image) if np.std(image) > 0 else 0.5\n    for row in middle_rows:\n        binary_row = (row > threshold).astype(int)\n        transitions += np.sum(np.diff(binary_row) > 0)\n    return float(transitions)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Number of distinct vertical segments with high pixel intensity in the rightmost quarter\"\n    h, w = image.shape\n    right_quarter = image[:, 3*w//4:]\n    if right_quarter.size == 0:\n        return 0.0\n    threshold = np.mean(image) + np.std(image)\n    high_intensity_mask = right_quarter > threshold\n    segments = 0\n    for col in range(right_quarter.shape[1]):\n        col_data = high_intensity_mask[:, col]\n        if np.any(col_data):\n            segments += 1\n    return float(segments)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of pixels in top half versus bottom half of image\"\n    h, w = image.shape\n    if h == 0:\n        return 0.0\n    top_half = np.sum(image[:h//2, :])\n    bottom_half = np.sum(image[h//2:, :])\n    if bottom_half == 0:\n        return float('inf') if top_half > 0 else 0.0\n    return float(top_half / bottom_half)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Average pixel intensity in the bottom third of the image\"\n    h, w = image.shape\n    bottom_third = image[2*h//3:, :]\n    return float(np.mean(bottom_third))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of pixels in top half versus bottom half of image\"\n    h, w = image.shape\n    if h == 0:\n        return 0.0\n    top_half = np.sum(image[:h//2, :])\n    bottom_half = np.sum(image[h//2:, :])\n    if bottom_half == 0:\n        return float('inf') if top_half > 0 else 0.0\n    return float(top_half / bottom_half)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of vertical gradients in upper half versus lower half\"\n    h, w = image.shape\n    grad_y = np.gradient(image, axis=0)\n    upper_grad = np.sum(np.abs(grad_y[:h//2, :]))\n    lower_grad = np.sum(np.abs(grad_y[h//2:, :]))\n    if lower_grad == 0:\n        return float(upper_grad > 0)\n    return float(upper_grad / lower_grad)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Horizontal symmetry score comparing left and right halves\"\n    h, w = image.shape\n    if w == 0:\n        return 0.0\n    left_half = image[:, :w//2]\n    right_half = image[:, w//2:]\n    right_flipped = np.fliplr(right_half)\n    min_width = min(left_half.shape[1], right_flipped.shape[1])\n    if min_width == 0:\n        return 0.0\n    left_crop = left_half[:, :min_width]\n    right_crop = right_flipped[:, :min_width]\n    diff = np.mean(np.abs(left_crop - right_crop))\n    max_val = max(np.mean(left_crop), np.mean(right_crop))\n    if max_val == 0:\n        return 1.0\n    return float(1.0 - diff / max_val)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of pixels in top half versus bottom half of image\"\n    h, w = image.shape\n    if h == 0:\n        return 0.0\n    top_half = np.sum(image[:h//2, :])\n    bottom_half = np.sum(image[h//2:, :])\n    if bottom_half == 0:\n        return float('inf') if top_half > 0 else 0.0\n    return float(top_half / bottom_half)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of pixels in top half versus bottom half of image\"\n    h, w = image.shape\n    if h == 0:\n        return 0.0\n    top_half = np.sum(image[:h//2, :])\n    bottom_half = np.sum(image[h//2:, :])\n    if bottom_half == 0:\n        return float('inf') if top_half > 0 else 0.0\n    return float(top_half / bottom_half)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Number of connected components in the middle vertical strip\"\n    h, w = image.shape\n    middle_strip = image[:, w//3:2*w//3]\n    binary = (middle_strip > middle_strip.mean()).astype(int)\n    transitions = 0\n    for col in range(binary.shape[1]):\n        column = binary[:, col]\n        transitions += np.sum(np.abs(np.diff(column)))\n    return float(transitions)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Asymmetry measure between left and right halves of the image\"\n    h, w = image.shape\n    left_half = image[:, :w//2]\n    right_half = image[:, w//2:]\n    right_flipped = np.fliplr(right_half)\n    min_width = min(left_half.shape[1], right_flipped.shape[1])\n    left_crop = left_half[:, :min_width]\n    right_crop = right_flipped[:, :min_width]\n    return float(np.mean(np.abs(left_crop - right_crop)))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of vertical gradient magnitude in left half versus right half\"\n    h, w = image.shape\n    grad_y = np.gradient(image, axis=0)\n    left_grad = np.abs(grad_y[:, :w//2])\n    right_grad = np.abs(grad_y[:, w//2:])\n    left_mag = np.mean(left_grad) if left_grad.size > 0 else 0\n    right_mag = np.mean(right_grad) if right_grad.size > 0 else 0\n    return float(left_mag / (right_mag + 0.001))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Average vertical position of the rightmost non-zero pixels\"\n    h, w = image.shape\n    if h == 0 or w == 0:\n        return 0.0\n    rightmost_positions = []\n    for col_idx in range(w-1, -1, -1):\n        col = image[:, col_idx]\n        nonzero_rows = np.where(col > 0)[0]\n        if len(nonzero_rows) > 0:\n            rightmost_positions.extend(nonzero_rows)\n            break\n    if len(rightmost_positions) == 0:\n        return 0.0\n    return float(np.mean(rightmost_positions) / h)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of pixels in top-left quadrant versus bottom-right quadrant\"\n    h, w = image.shape\n    top_left = image[:h//2, :w//2]\n    bottom_right = image[h//2:, w//2:]\n    top_left_count = np.count_nonzero(top_left)\n    bottom_right_count = np.count_nonzero(bottom_right)\n    if bottom_right_count == 0:\n        return float(top_left_count)\n    return float(top_left_count / bottom_right_count)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of non-zero pixels in top-right to bottom-left corners\"\n    h, w = image.shape\n    corner_size = min(h//4, w//4)\n    if corner_size == 0:\n        return 1.0\n    top_right = image[0:corner_size, -corner_size:]\n    bottom_left = image[-corner_size:, 0:corner_size]\n    tr_count = np.count_nonzero(top_right)\n    bl_count = np.count_nonzero(bottom_left)\n    if bl_count == 0:\n        return float(tr_count)\n    return float(tr_count / bl_count)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Average intensity in the bottom quarter of the image\"\n    h, w = image.shape\n    bottom_quarter = image[3*h//4:, :]\n    return float(np.mean(bottom_quarter))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of pixels in top half versus bottom half of image\"\n    h, w = image.shape\n    if h == 0:\n        return 0.0\n    top_half = np.sum(image[:h//2, :])\n    bottom_half = np.sum(image[h//2:, :])\n    if bottom_half == 0:\n        return float('inf') if top_half > 0 else 0.0\n    return float(top_half / bottom_half)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Concentration of pixels in the upper right quadrant\"\n    h, w = image.shape\n    upper_right = image[:h//2, w//2:]\n    total_pixels = np.sum(image)\n    if total_pixels == 0:\n        return 0.0\n    upper_right_pixels = np.sum(upper_right)\n    return float(upper_right_pixels / total_pixels)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of pixels in top half versus bottom half of image\"\n    h, w = image.shape\n    if h == 0:\n        return 0.0\n    top_half = np.sum(image[:h//2, :])\n    bottom_half = np.sum(image[h//2:, :])\n    if bottom_half == 0:\n        return float('inf') if top_half > 0 else 0.0\n    return float(top_half / bottom_half)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of filled pixels in middle-right region to middle-left region\"\n    h, w = image.shape\n    mid_top, mid_bottom = h//3, 2*h//3\n    left_region = image[mid_top:mid_bottom, :w//2]\n    right_region = image[mid_top:mid_bottom, w//2:]\n    left_count = np.count_nonzero(left_region) if left_region.size > 0 else 1\n    right_count = np.count_nonzero(right_region) if right_region.size > 0 else 0\n    return float(right_count / max(left_count, 1))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of non-zero pixels in middle third versus outer thirds vertically\"\n    h, w = image.shape\n    third = h // 3\n    middle_third = image[third:2*third, :]\n    outer_thirds = np.concatenate([image[:third, :].flatten(), image[2*third:, :].flatten()])\n    middle_nonzero = np.count_nonzero(middle_third)\n    outer_nonzero = np.count_nonzero(outer_thirds)\n    if outer_nonzero == 0:\n        return 0.0\n    return float(middle_nonzero / outer_nonzero)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of pixels above median intensity in top half versus bottom half\"\n    h, w = image.shape\n    median_val = np.median(image)\n    top_half = image[:h//2, :]\n    bottom_half = image[h//2:, :]\n    top_above_median = np.count_nonzero(top_half > median_val)\n    bottom_above_median = np.count_nonzero(bottom_half > median_val)\n    return float(top_above_median / max(bottom_above_median, 1))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of non-zero pixels in top-right to bottom-left corners\"\n    h, w = image.shape\n    corner_size = min(h//4, w//4)\n    if corner_size == 0:\n        return 1.0\n    top_right = image[0:corner_size, -corner_size:]\n    bottom_left = image[-corner_size:, 0:corner_size]\n    tr_count = np.count_nonzero(top_right)\n    bl_count = np.count_nonzero(bottom_left)\n    if bl_count == 0:\n        return float(tr_count)\n    return float(tr_count / bl_count)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Average distance from image center to non-zero pixels in right half\"\n    h, w = image.shape\n    center_y, center_x = h // 2, w // 2\n    right_half = image[:, w//2:]\n    distances = []\n    \n    for i in range(h):\n        for j in range(w//2, w):\n            if image[i, j] > 0:\n                dist = np.sqrt((i - center_y)**2 + (j - center_x)**2)\n                distances.append(dist)\n    \n    if len(distances) == 0:\n        return 0.0\n    return float(np.mean(distances))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of pixels in top half versus bottom half of image\"\n    h, w = image.shape\n    if h == 0:\n        return 0.0\n    top_half = np.sum(image[:h//2, :])\n    bottom_half = np.sum(image[h//2:, :])\n    if bottom_half == 0:\n        return float('inf') if top_half > 0 else 0.0\n    return float(top_half / bottom_half)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of non-zero pixels in middle-left region to middle-right region\"\n    h, w = image.shape\n    middle_left = image[h//4:3*h//4, :w//2]\n    middle_right = image[h//4:3*h//4, w//2:]\n    left_nonzero = np.count_nonzero(middle_left)\n    right_nonzero = np.count_nonzero(middle_right)\n    return float(left_nonzero / (right_nonzero + 1e-6))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of pixels in top half versus bottom half of image\"\n    h, w = image.shape\n    if h == 0:\n        return 0.0\n    top_half = np.sum(image[:h//2, :])\n    bottom_half = np.sum(image[h//2:, :])\n    if bottom_half == 0:\n        return float('inf') if top_half > 0 else 0.0\n    return float(top_half / bottom_half)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Intensity concentration in the center quarter of the image\"\n    h, w = image.shape\n    center_quarter = image[3*h//8:5*h//8, 3*w//8:5*w//8]\n    if center_quarter.size == 0 or image.size == 0:\n        return 0.0\n    center_sum = np.sum(center_quarter)\n    total_sum = np.sum(image)\n    if total_sum == 0:\n        return 0.0\n    return float(center_sum / total_sum)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of filled pixels in middle-right region to middle-left region\"\n    h, w = image.shape\n    mid_top, mid_bottom = h//3, 2*h//3\n    left_region = image[mid_top:mid_bottom, :w//2]\n    right_region = image[mid_top:mid_bottom, w//2:]\n    left_count = np.count_nonzero(left_region) if left_region.size > 0 else 1\n    right_count = np.count_nonzero(right_region) if right_region.size > 0 else 0\n    return float(right_count / max(left_count, 1))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of pixels in top half versus bottom half of image\"\n    h, w = image.shape\n    if h == 0:\n        return 0.0\n    top_half = np.sum(image[:h//2, :])\n    bottom_half = np.sum(image[h//2:, :])\n    if bottom_half == 0:\n        return float('inf') if top_half > 0 else 0.0\n    return float(top_half / bottom_half)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Average intensity of pixels forming enclosed regions or loops\"\n    h, w = image.shape\n    if h < 5 or w < 5:\n        return 0.0\n    center_region = image[h//4:3*h//4, w//4:3*w//4]\n    interior_pixels = center_region[1:-1, 1:-1]\n    boundary_pixels = np.concatenate([\n        center_region[0, :], center_region[-1, :],\n        center_region[1:-1, 0], center_region[1:-1, -1]\n    ])\n    interior_mean = np.mean(interior_pixels) if interior_pixels.size > 0 else 0.0\n    boundary_mean = np.mean(boundary_pixels) if boundary_pixels.size > 0 else 0.0\n    return float(interior_mean - boundary_mean)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Number of pixels with intensity greater than mean in the center region\"\n    h, w = image.shape\n    if h == 0 or w == 0:\n        return 0.0\n    center_region = image[h//4:3*h//4, w//4:3*w//4]\n    mean_intensity = np.mean(image)\n    above_mean_count = np.sum(center_region > mean_intensity)\n    return float(above_mean_count)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Curvature measure based on direction changes in the upper portion\"\n    h, w = image.shape\n    if h < 4 or w < 4:\n        return 0.0\n    upper_half = image[:h//2, :]\n    grad_y, grad_x = np.gradient(upper_half)\n    angles = np.arctan2(grad_y, grad_x)\n    angle_changes = np.abs(np.diff(angles.flatten()))\n    angle_changes = angle_changes[angle_changes > 0.1]\n    return float(np.sum(angle_changes))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Intensity concentration in the center quarter of the image\"\n    h, w = image.shape\n    center_quarter = image[3*h//8:5*h//8, 3*w//8:5*w//8]\n    if center_quarter.size == 0 or image.size == 0:\n        return 0.0\n    center_sum = np.sum(center_quarter)\n    total_sum = np.sum(image)\n    if total_sum == 0:\n        return 0.0\n    return float(center_sum / total_sum)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Number of horizontal transitions from zero to non-zero pixels\"\n    transitions = 0\n    h, w = image.shape\n    for row in range(h):\n        for col in range(1, w):\n            if image[row, col-1] == 0 and image[row, col] > 0:\n                transitions += 1\n    return float(transitions)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Maximum vertical distance between consecutive high-intensity pixels in center column\"\n    h, w = image.shape\n    center_col = image[:, w//2]\n    threshold = np.mean(center_col) + 0.5 * np.std(center_col)\n    high_pixels = np.where(center_col > threshold)[0]\n    if len(high_pixels) < 2:\n        return 0.0\n    max_gap = 0\n    for i in range(1, len(high_pixels)):\n        gap = high_pixels[i] - high_pixels[i-1]\n        max_gap = max(max_gap, gap)\n    return float(max_gap)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of pixel intensity variance in top-right versus bottom-left quadrants\"\n    h, w = image.shape\n    top_right = image[:h//2, w//2:]\n    bottom_left = image[h//2:, :w//2]\n    tr_var = np.var(top_right) if top_right.size > 0 else 0\n    bl_var = np.var(bottom_left) if bottom_left.size > 0 else 0\n    return float(tr_var / (bl_var + 1e-8))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of pixels in top half versus bottom half of image\"\n    h, w = image.shape\n    if h == 0:\n        return 0.0\n    top_half = np.sum(image[:h//2, :])\n    bottom_half = np.sum(image[h//2:, :])\n    if bottom_half == 0:\n        return float('inf') if top_half > 0 else 0.0\n    return float(top_half / bottom_half)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of pixels in top half versus bottom half of image\"\n    h, w = image.shape\n    if h == 0:\n        return 0.0\n    top_half = np.sum(image[:h//2, :])\n    bottom_half = np.sum(image[h//2:, :])\n    if bottom_half == 0:\n        return float('inf') if top_half > 0 else 0.0\n    return float(top_half / bottom_half)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Average gradient magnitude in the central horizontal stripe\"\n    h, w = image.shape\n    center_stripe = image[2*h//5:3*h//5, :]\n    grad_y, grad_x = np.gradient(center_stripe)\n    gradient_magnitude = np.sqrt(grad_x**2 + grad_y**2)\n    return float(np.mean(gradient_magnitude))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of left half intensity to right half intensity\"\n    h, w = image.shape\n    left_half = image[:, :w//2]\n    right_half = image[:, w//2:]\n    left_sum = np.sum(left_half)\n    right_sum = np.sum(right_half)\n    if right_sum == 0:\n        return 1.0 if left_sum > 0 else 0.0\n    return float(left_sum / right_sum)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Presence of strong vertical lines in the center column region\"\n    h, w = image.shape\n    if w < 3 or h < 3:\n        return 0.0\n    center_cols = image[:, w//3:2*w//3]\n    vertical_strength = 0\n    threshold = np.mean(image) * 0.5\n    for col_idx in range(center_cols.shape[1]):\n        col = center_cols[:, col_idx]\n        consecutive = 0\n        max_consecutive = 0\n        for pixel in col:\n            if pixel > threshold:\n                consecutive += 1\n                max_consecutive = max(max_consecutive, consecutive)\n            else:\n                consecutive = 0\n        if max_consecutive > h * 0.4:\n            vertical_strength += 1\n    return float(vertical_strength > 0)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of pixels in top half versus bottom half of image\"\n    h, w = image.shape\n    if h == 0:\n        return 0.0\n    top_half = np.sum(image[:h//2, :])\n    bottom_half = np.sum(image[h//2:, :])\n    if bottom_half == 0:\n        return float('inf') if top_half > 0 else 0.0\n    return float(top_half / bottom_half)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Average vertical position of non-zero pixels weighted by intensity\"\n    h, w = image.shape\n    if np.sum(image) == 0:\n        return 0.0\n    y_coords, x_coords = np.where(image > 0)\n    weights = image[y_coords, x_coords]\n    weighted_y = np.sum(y_coords * weights) / np.sum(weights)\n    return float(weighted_y / h)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Number of enclosed regions or loops in the image\"\n    from scipy import ndimage\n    if image.size == 0:\n        return 0.0\n    binary = image > np.mean(image)\n    filled = ndimage.binary_fill_holes(binary)\n    loops = np.sum(filled) - np.sum(binary)\n    return float(loops)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of pixels in top half versus bottom half of image\"\n    h, w = image.shape\n    if h == 0:\n        return 0.0\n    top_half = np.sum(image[:h//2, :])\n    bottom_half = np.sum(image[h//2:, :])\n    if bottom_half == 0:\n        return float('inf') if top_half > 0 else 0.0\n    return float(top_half / bottom_half)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of pixels in top half versus bottom half of image\"\n    h, w = image.shape\n    if h == 0:\n        return 0.0\n    top_half = np.sum(image[:h//2, :])\n    bottom_half = np.sum(image[h//2:, :])\n    if bottom_half == 0:\n        return float('inf') if top_half > 0 else 0.0\n    return float(top_half / bottom_half)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of pixels in top half versus bottom half of image\"\n    h, w = image.shape\n    if h == 0:\n        return 0.0\n    top_half = np.sum(image[:h//2, :])\n    bottom_half = np.sum(image[h//2:, :])\n    if bottom_half == 0:\n        return float('inf') if top_half > 0 else 0.0\n    return float(top_half / bottom_half)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of pixels in top half versus bottom half of image\"\n    h, w = image.shape\n    if h == 0:\n        return 0.0\n    top_half = np.sum(image[:h//2, :])\n    bottom_half = np.sum(image[h//2:, :])\n    if bottom_half == 0:\n        return float('inf') if top_half > 0 else 0.0\n    return float(top_half / bottom_half)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of pixels in top half versus bottom half of image\"\n    h, w = image.shape\n    if h == 0:\n        return 0.0\n    top_half = np.sum(image[:h//2, :])\n    bottom_half = np.sum(image[h//2:, :])\n    if bottom_half == 0:\n        return float('inf') if top_half > 0 else 0.0\n    return float(top_half / bottom_half)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of pixels in top half versus bottom half of image\"\n    h, w = image.shape\n    if h == 0:\n        return 0.0\n    top_half = np.sum(image[:h//2, :])\n    bottom_half = np.sum(image[h//2:, :])\n    if bottom_half == 0:\n        return float('inf') if top_half > 0 else 0.0\n    return float(top_half / bottom_half)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of pixels in top half versus bottom half of image\"\n    h, w = image.shape\n    if h == 0:\n        return 0.0\n    top_half = np.sum(image[:h//2, :])\n    bottom_half = np.sum(image[h//2:, :])\n    if bottom_half == 0:\n        return float('inf') if top_half > 0 else 0.0\n    return float(top_half / bottom_half)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of pixels in top half versus bottom half of image\"\n    h, w = image.shape\n    if h == 0:\n        return 0.0\n    top_half = np.sum(image[:h//2, :])\n    bottom_half = np.sum(image[h//2:, :])\n    if bottom_half == 0:\n        return float('inf') if top_half > 0 else 0.0\n    return float(top_half / bottom_half)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Average vertical gradient magnitude in the center column\"\n    h, w = image.shape\n    if h <= 1 or w == 0:\n        return 0.0\n    center_col = w // 2\n    center_column = image[:, center_col]\n    vertical_grad = np.abs(np.diff(center_column))\n    return float(np.mean(vertical_grad))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of pixels in top half versus bottom half of image\"\n    h, w = image.shape\n    if h == 0:\n        return 0.0\n    top_half = np.sum(image[:h//2, :])\n    bottom_half = np.sum(image[h//2:, :])\n    if bottom_half == 0:\n        return float('inf') if top_half > 0 else 0.0\n    return float(top_half / bottom_half)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of pixels in top half versus bottom half of image\"\n    h, w = image.shape\n    if h == 0:\n        return 0.0\n    top_half = np.sum(image[:h//2, :])\n    bottom_half = np.sum(image[h//2:, :])\n    if bottom_half == 0:\n        return float('inf') if top_half > 0 else 0.0\n    return float(top_half / bottom_half)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of pixels in top half versus bottom half of image\"\n    h, w = image.shape\n    if h == 0:\n        return 0.0\n    top_half = np.sum(image[:h//2, :])\n    bottom_half = np.sum(image[h//2:, :])\n    if bottom_half == 0:\n        return float('inf') if top_half > 0 else 0.0\n    return float(top_half / bottom_half)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Standard deviation of pixel intensities in the center column\"\n    h, w = image.shape\n    center_col = image[:, w//2]\n    if center_col.size == 0:\n        return 0.0\n    return float(np.std(center_col))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of pixels in top half versus bottom half of image\"\n    h, w = image.shape\n    if h == 0:\n        return 0.0\n    top_half = np.sum(image[:h//2, :])\n    bottom_half = np.sum(image[h//2:, :])\n    if bottom_half == 0:\n        return float('inf') if top_half > 0 else 0.0\n    return float(top_half / bottom_half)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of pixels in top half versus bottom half of image\"\n    h, w = image.shape\n    if h == 0:\n        return 0.0\n    top_half = np.sum(image[:h//2, :])\n    bottom_half = np.sum(image[h//2:, :])\n    if bottom_half == 0:\n        return float('inf') if top_half > 0 else 0.0\n    return float(top_half / bottom_half)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Intensity ratio between upper-middle and lower-middle regions\"\n    h, w = image.shape\n    upper_mid = image[h//4:h//2, w//4:3*w//4]\n    lower_mid = image[h//2:3*h//4, w//4:3*w//4]\n    upper_sum = np.sum(upper_mid)\n    lower_sum = np.sum(lower_mid)\n    if lower_sum == 0:\n        return 1.0 if upper_sum > 0 else 0.0\n    return float(upper_sum / (upper_sum + lower_sum))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Average intensity difference between adjacent horizontal pixels\"\n    h, w = image.shape\n    if h == 0 or w < 2:\n        return 0.0\n    diff_sum = 0.0\n    count = 0\n    for i in range(h):\n        for j in range(w-1):\n            diff_sum += abs(float(image[i, j]) - float(image[i, j+1]))\n            count += 1\n    return diff_sum / count if count > 0 else 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of left half intensity to right half intensity\"\n    h, w = image.shape\n    left_half = image[:, :w//2]\n    right_half = image[:, w//2:]\n    left_sum = np.sum(left_half)\n    right_sum = np.sum(right_half)\n    if right_sum == 0:\n        return 1.0 if left_sum > 0 else 0.0\n    return float(left_sum / right_sum)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Vertical symmetry score - correlation between left and right halves\"\n    h, w = image.shape\n    if w < 2:\n        return 0.0\n    left_half = image[:, :w//2]\n    right_half = np.fliplr(image[:, w//2:])\n    min_width = min(left_half.shape[1], right_half.shape[1])\n    left_resized = left_half[:, :min_width].flatten()\n    right_resized = right_half[:, :min_width].flatten()\n    if len(left_resized) == 0 or np.std(left_resized) == 0 or np.std(right_resized) == 0:\n        return 0.0\n    correlation = np.corrcoef(left_resized, right_resized)[0, 1]\n    return float(correlation if not np.isnan(correlation) else 0.0)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of pixels in top half versus bottom half of image\"\n    h, w = image.shape\n    if h == 0:\n        return 0.0\n    top_half = np.sum(image[:h//2, :])\n    bottom_half = np.sum(image[h//2:, :])\n    if bottom_half == 0:\n        return float('inf') if top_half > 0 else 0.0\n    return float(top_half / bottom_half)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Maximum vertical gap between non-zero pixels in the right third\"\n    h, w = image.shape\n    right_third = image[:, 2*w//3:]\n    if right_third.size == 0:\n        return 0.0\n    max_gap = 0\n    for col in range(right_third.shape[1]):\n        nonzero_rows = np.where(right_third[:, col] > 0)[0]\n        if len(nonzero_rows) < 2:\n            continue\n        gaps = np.diff(nonzero_rows) - 1\n        if len(gaps) > 0:\n            max_gap = max(max_gap, np.max(gaps))\n    return float(max_gap)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of pixels in top half versus bottom half of image\"\n    h, w = image.shape\n    if h == 0:\n        return 0.0\n    top_half = np.sum(image[:h//2, :])\n    bottom_half = np.sum(image[h//2:, :])\n    if bottom_half == 0:\n        return float('inf') if top_half > 0 else 0.0\n    return float(top_half / bottom_half)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of pixels in top half versus bottom half of image\"\n    h, w = image.shape\n    if h == 0:\n        return 0.0\n    top_half = np.sum(image[:h//2, :])\n    bottom_half = np.sum(image[h//2:, :])\n    if bottom_half == 0:\n        return float('inf') if top_half > 0 else 0.0\n    return float(top_half / bottom_half)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Number of distinct vertical segments with high pixel intensity in the rightmost quarter\"\n    h, w = image.shape\n    right_quarter = image[:, 3*w//4:]\n    if right_quarter.size == 0:\n        return 0.0\n    threshold = np.mean(image) + np.std(image)\n    high_intensity_mask = right_quarter > threshold\n    segments = 0\n    for col in range(right_quarter.shape[1]):\n        col_data = high_intensity_mask[:, col]\n        if np.any(col_data):\n            segments += 1\n    return float(segments)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Vertical position of the rightmost non-zero pixel as fraction of height\"\n    h, w = image.shape\n    if h == 0 or np.count_nonzero(image) == 0:\n        return 0.0\n    rightmost_positions = []\n    for i in range(h):\n        row_indices = np.where(image[i, :] > 0)[0]\n        if len(row_indices) > 0:\n            rightmost_positions.append(i / h)\n    return float(np.mean(rightmost_positions) if rightmost_positions else 0.0)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of maximum width in top half versus bottom half\"\n    h, w = image.shape\n    if h == 0:\n        return 1.0\n    top_half = image[:h//2, :]\n    bottom_half = image[h//2:, :]\n    \n    top_widths = [np.sum(row > 0) for row in top_half]\n    bottom_widths = [np.sum(row > 0) for row in bottom_half]\n    \n    max_top = max(top_widths) if top_widths else 0\n    max_bottom = max(bottom_widths) if bottom_widths else 0\n    \n    if max_bottom == 0:\n        return float(max_top > 0)\n    return float(max_top / max_bottom)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Number of enclosed regions detected by counting local minima surrounded by higher values\"\n    h, w = image.shape\n    enclosed_count = 0\n    for i in range(1, h-1):\n        for j in range(1, w-1):\n            center = image[i, j]\n            neighbors = image[i-1:i+2, j-1:j+2]\n            if center < np.percentile(neighbors, 75) and np.sum(neighbors > center) >= 6:\n                enclosed_count += 1\n    return float(enclosed_count)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of pixel density in the middle vertical strip versus outer edges\"\n    h, w = image.shape\n    middle_strip = image[:, w//3:2*w//3]\n    left_edge = image[:, :w//6]\n    right_edge = image[:, 5*w//6:]\n    middle_density = np.count_nonzero(middle_strip) / middle_strip.size\n    edge_density = (np.count_nonzero(left_edge) + np.count_nonzero(right_edge)) / (left_edge.size + right_edge.size)\n    if edge_density == 0:\n        return float(middle_density * 10)\n    return float(middle_density / edge_density)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of maximum row intensity to average row intensity\"\n    h, w = image.shape\n    row_sums = np.sum(image, axis=1)\n    if len(row_sums) == 0:\n        return 0.0\n    max_row = np.max(row_sums)\n    avg_row = np.mean(row_sums)\n    if avg_row == 0:\n        return 0.0\n    return float(max_row / avg_row)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Standard deviation of row-wise pixel counts in the middle third\"\n    h, w = image.shape\n    middle_third = image[h//3:2*h//3, :]\n    row_counts = [np.count_nonzero(row) for row in middle_third]\n    if len(row_counts) == 0:\n        return 0.0\n    return float(np.std(row_counts))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Average intensity in the middle horizontal strip of the image\"\n    h, w = image.shape\n    middle_strip = image[h//3:2*h//3, :]\n    return float(np.mean(middle_strip))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Maximum consecutive non-zero pixels in any diagonal direction\"\n    h, w = image.shape\n    max_length = 0\n    # Check main diagonal\n    current_length = 0\n    for i in range(min(h, w)):\n        if image[i, i] > 0:\n            current_length += 1\n            max_length = max(max_length, current_length)\n        else:\n            current_length = 0\n    return float(max_length)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Number of connected vertical segments in the center 20 percent width\"\n    h, w = image.shape\n    if w < 5:\n        return 0.0\n    center_start = int(0.4 * w)\n    center_end = int(0.6 * w)\n    center_strip = image[:, center_start:center_end]\n    segments = 0\n    for col in range(center_strip.shape[1]):\n        column = center_strip[:, col]\n        in_segment = False\n        for pixel in column:\n            if pixel > 0 and not in_segment:\n                segments += 1\n                in_segment = True\n            elif pixel == 0:\n                in_segment = False\n    return float(segments)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Maximum consecutive non-zero pixels in any diagonal direction\"\n    h, w = image.shape\n    if h == 0 or w == 0:\n        return 0.0\n    max_diagonal = 0\n    # Main diagonal top-left to bottom-right\n    for start_row in range(h):\n        consecutive = 0\n        for offset in range(min(h - start_row, w)):\n            if image[start_row + offset, offset] > 0:\n                consecutive += 1\n                max_diagonal = max(max_diagonal, consecutive)\n            else:\n                consecutive = 0\n    # Anti-diagonal top-right to bottom-left\n    for start_row in range(h):\n        consecutive = 0\n        for offset in range(min(h - start_row, w)):\n            if image[start_row + offset, w - 1 - offset] > 0:\n                consecutive += 1\n                max_diagonal = max(max_diagonal, consecutive)\n            else:\n                consecutive = 0\n    return float(max_diagonal)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Maximum vertical position of any foreground pixel as ratio of image height\"\n    h, w = image.shape\n    if h == 0:\n        return 0.0\n    foreground_rows = np.where(np.any(image > 0, axis=1))[0]\n    if len(foreground_rows) == 0:\n        return 0.0\n    return float(np.max(foreground_rows) / h)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Presence of horizontal line in upper third of image\"\n    h, w = image.shape\n    upper_third = image[:h//3, :]\n    horizontal_intensity = 0\n    for row in range(upper_third.shape[0]):\n        row_sum = np.sum(upper_third[row, :])\n        if row_sum > horizontal_intensity:\n            horizontal_intensity = row_sum\n    return float(horizontal_intensity / (w * 255) if w > 0 else 0.0)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Horizontal extent of the topmost non-zero pixels\"\n    h, w = image.shape\n    for row in range(h):\n        if np.any(image[row, :] > 0):\n            nonzero_cols = np.where(image[row, :] > 0)[0]\n            return float(nonzero_cols[-1] - nonzero_cols[0] + 1) / w\n    return 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Horizontal extent ratio of rightmost to leftmost significant pixels\"\n    h, w = image.shape\n    nonzero_positions = np.where(image > 0)\n    if len(nonzero_positions[1]) == 0:\n        return 1.0\n    leftmost = np.min(nonzero_positions[1])\n    rightmost = np.max(nonzero_positions[1])\n    left_extent = leftmost + 1\n    right_extent = w - rightmost\n    if left_extent == 0:\n        return float('inf') if right_extent > 0 else 1.0\n    return float(right_extent / left_extent)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Maximum consecutive vertical pixels in the rightmost third\"\n    h, w = image.shape\n    if w < 3:\n        return 0.0\n    right_third = image[:, 2*w//3:]\n    max_consecutive = 0\n    threshold = np.mean(image) * 0.5\n    for col in range(right_third.shape[1]):\n        consecutive = 0\n        current_max = 0\n        for row in range(h):\n            if right_third[row, col] > threshold:\n                consecutive += 1\n                current_max = max(current_max, consecutive)\n            else:\n                consecutive = 0\n        max_consecutive = max(max_consecutive, current_max)\n    return float(max_consecutive)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Average horizontal gradient magnitude in the upper half\"\n    h, w = image.shape\n    upper_half = image[:h//2, :]\n    if upper_half.shape[1] < 2:\n        return 0.0\n    grad_x = np.gradient(upper_half, axis=1)\n    return float(np.mean(np.abs(grad_x)))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Average pixel intensity in corners versus center cross pattern\"\n    h, w = image.shape\n    corner_size = min(h//4, w//4)\n    corners = np.concatenate([\n        image[:corner_size, :corner_size].flatten(),\n        image[:corner_size, -corner_size:].flatten(),\n        image[-corner_size:, :corner_size].flatten(),\n        image[-corner_size:, -corner_size:].flatten()\n    ])\n    cross = np.concatenate([\n        image[h//2-corner_size:h//2+corner_size, :].flatten(),\n        image[:, w//2-corner_size:w//2+corner_size].flatten()\n    ])\n    corner_avg = np.mean(corners) if corners.size > 0 else 0\n    cross_avg = np.mean(cross) if cross.size > 0 else 0\n    if cross_avg == 0:\n        return 1.0 if corner_avg > 0 else 0.0\n    return float(corner_avg / cross_avg)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Vertical symmetry score - correlation between left and right halves\"\n    h, w = image.shape\n    if w < 2:\n        return 0.0\n    left_half = image[:, :w//2]\n    right_half = np.fliplr(image[:, w//2:])\n    min_width = min(left_half.shape[1], right_half.shape[1])\n    left_resized = left_half[:, :min_width].flatten()\n    right_resized = right_half[:, :min_width].flatten()\n    if len(left_resized) == 0 or np.std(left_resized) == 0 or np.std(right_resized) == 0:\n        return 0.0\n    correlation = np.corrcoef(left_resized, right_resized)[0, 1]\n    return float(correlation if not np.isnan(correlation) else 0.0)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Coefficient of variation of row-wise pixel intensities\"\n    h, w = image.shape\n    if h == 0:\n        return 0.0\n    row_means = np.array([np.mean(image[i, :]) for i in range(h)])\n    mean_of_means = np.mean(row_means)\n    if mean_of_means == 0:\n        return 0.0\n    std_of_means = np.std(row_means)\n    return float(std_of_means / mean_of_means)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of non-zero pixels in diagonal strips versus anti-diagonal strips\"\n    h, w = image.shape\n    diag_count = 0\n    anti_diag_count = 0\n    total_pixels = 0\n    \n    for i in range(h):\n        for j in range(w):\n            if abs(i - j) <= min(h, w) // 4:  # Main diagonal strip\n                if image[i, j] > 0:\n                    diag_count += 1\n                total_pixels += 1\n            elif abs(i + j - (h-1)) <= min(h, w) // 4:  # Anti-diagonal strip\n                if image[i, j] > 0:\n                    anti_diag_count += 1\n                total_pixels += 1\n    \n    if anti_diag_count == 0:\n        return float(diag_count)\n    return float(diag_count / anti_diag_count)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Maximum row intensity in the bottom third of image\"\n    h, w = image.shape\n    if h == 0:\n        return 0.0\n    bottom_third = image[2*h//3:, :]\n    if bottom_third.size == 0:\n        return 0.0\n    row_sums = np.sum(bottom_third, axis=1)\n    return float(np.max(row_sums) if len(row_sums) > 0 else 0.0)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Presence of enclosed circular or oval regions\"\n    h, w = image.shape\n    threshold = np.mean(image) if np.mean(image) > 0 else 0.1\n    binary = (image > threshold).astype(int)\n    enclosed_regions = 0\n    center_h, center_w = h//2, w//2\n    for i in range(h//4, 3*h//4):\n        for j in range(w//4, 3*w//4):\n            if binary[i, j] == 0:\n                neighbors = binary[max(0,i-1):min(h,i+2), max(0,j-1):min(w,j+2)]\n                if np.sum(neighbors) >= 6:\n                    enclosed_regions += 1\n    return float(min(enclosed_regions / 10.0, 1.0))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Count of vertical edges detected in the center region\"\n    h, w = image.shape\n    if h < 4 or w < 4:\n        return 0.0\n    center = image[h//4:3*h//4, w//4:3*w//4]\n    if center.size == 0:\n        return 0.0\n    grad_y, grad_x = np.gradient(center.astype(float))\n    vertical_edges = np.abs(grad_x) > np.abs(grad_y)\n    return float(np.sum(vertical_edges))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Maximum intensity difference between adjacent rows in bottom half\"\n    h, w = image.shape\n    bottom_half = image[h//2:, :]\n    if bottom_half.shape[0] < 2:\n        return 0.0\n    max_diff = 0.0\n    for i in range(bottom_half.shape[0] - 1):\n        row_diff = np.abs(np.mean(bottom_half[i+1]) - np.mean(bottom_half[i]))\n        max_diff = max(max_diff, row_diff)\n    return float(max_diff)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Maximum horizontal width of non-zero pixels in the bottom third of image\"\n    h, w = image.shape\n    bottom_third = image[2*h//3:, :]\n    max_width = 0\n    for row in bottom_third:\n        nonzero_indices = np.where(row > 0)[0]\n        if len(nonzero_indices) > 0:\n            width = nonzero_indices[-1] - nonzero_indices[0] + 1\n            max_width = max(max_width, width)\n    return float(max_width)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Vertical symmetry score - correlation between left and right halves\"\n    h, w = image.shape\n    if w < 2:\n        return 0.0\n    left_half = image[:, :w//2]\n    right_half = np.fliplr(image[:, w//2:])\n    min_width = min(left_half.shape[1], right_half.shape[1])\n    left_resized = left_half[:, :min_width].flatten()\n    right_resized = right_half[:, :min_width].flatten()\n    if len(left_resized) == 0 or np.std(left_resized) == 0 or np.std(right_resized) == 0:\n        return 0.0\n    correlation = np.corrcoef(left_resized, right_resized)[0, 1]\n    return float(correlation if not np.isnan(correlation) else 0.0)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of pixels in top half versus bottom half of image\"\n    h, w = image.shape\n    if h == 0:\n        return 0.0\n    top_half = np.sum(image[:h//2, :])\n    bottom_half = np.sum(image[h//2:, :])\n    if bottom_half == 0:\n        return float('inf') if top_half > 0 else 0.0\n    return float(top_half / bottom_half)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of pixels in top half versus bottom half of image\"\n    h, w = image.shape\n    if h == 0:\n        return 0.0\n    top_half = np.sum(image[:h//2, :])\n    bottom_half = np.sum(image[h//2:, :])\n    if bottom_half == 0:\n        return float('inf') if top_half > 0 else 0.0\n    return float(top_half / bottom_half)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of maximum width in top half versus bottom half\"\n    h, w = image.shape\n    if h == 0:\n        return 1.0\n    top_half = image[:h//2, :]\n    bottom_half = image[h//2:, :]\n    \n    top_widths = [np.sum(row > 0) for row in top_half]\n    bottom_widths = [np.sum(row > 0) for row in bottom_half]\n    \n    max_top = max(top_widths) if top_widths else 0\n    max_bottom = max(bottom_widths) if bottom_widths else 0\n    \n    if max_bottom == 0:\n        return float(max_top > 0)\n    return float(max_top / max_bottom)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Vertical gradient variance in the middle columns\"\n    h, w = image.shape\n    if h < 2 or w < 3:\n        return 0.0\n    middle_cols = image[:, w//3:2*w//3]\n    grad_y = np.gradient(middle_cols, axis=0)\n    return float(np.var(grad_y))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Asymmetry between upper-left and lower-right diagonal regions\"\n    h, w = image.shape\n    upper_left = np.sum([image[i, j] for i in range(h) for j in range(w) if i + j < min(h, w)])\n    lower_right = np.sum([image[i, j] for i in range(h) for j in range(w) if i + j >= max(h, w)])\n    total = upper_left + lower_right\n    if total == 0:\n        return 0.5\n    return float(upper_left / total)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Intensity concentration in the center quarter of the image\"\n    h, w = image.shape\n    center_quarter = image[3*h//8:5*h//8, 3*w//8:5*w//8]\n    if center_quarter.size == 0 or image.size == 0:\n        return 0.0\n    center_sum = np.sum(center_quarter)\n    total_sum = np.sum(image)\n    if total_sum == 0:\n        return 0.0\n    return float(center_sum / total_sum)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of horizontal pixel transitions to vertical pixel transitions\"\n    h, w = image.shape\n    if h < 2 or w < 2:\n        return 0.0\n    horizontal_transitions = np.sum(np.abs(np.diff(image, axis=1)) > 0)\n    vertical_transitions = np.sum(np.abs(np.diff(image, axis=0)) > 0)\n    if vertical_transitions == 0:\n        return float(horizontal_transitions)\n    return float(horizontal_transitions / vertical_transitions)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of pixel density in upper third versus lower third of image\"\n    h, w = image.shape\n    upper_third = image[:h//3, :]\n    lower_third = image[2*h//3:, :]\n    upper_density = np.mean(upper_third) if upper_third.size > 0 else 0\n    lower_density = np.mean(lower_third) if lower_third.size > 0 else 0\n    return float(upper_density / (lower_density + 1e-8))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Average intensity of pixels forming enclosed regions or loops\"\n    h, w = image.shape\n    if h < 5 or w < 5:\n        return 0.0\n    center_region = image[h//4:3*h//4, w//4:3*w//4]\n    interior_pixels = center_region[1:-1, 1:-1]\n    boundary_pixels = np.concatenate([\n        center_region[0, :], center_region[-1, :],\n        center_region[1:-1, 0], center_region[1:-1, -1]\n    ])\n    interior_mean = np.mean(interior_pixels) if interior_pixels.size > 0 else 0.0\n    boundary_mean = np.mean(boundary_pixels) if boundary_pixels.size > 0 else 0.0\n    return float(interior_mean - boundary_mean)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Skewness of horizontal distribution of non-zero pixels\"\n    h, w = image.shape\n    if w == 0:\n        return 0.0\n    col_sums = np.sum(image, axis=0)\n    non_zero_cols = np.nonzero(col_sums)[0]\n    if len(non_zero_cols) < 3:\n        return 0.0\n    weights = col_sums[non_zero_cols]\n    positions = non_zero_cols\n    mean_pos = np.average(positions, weights=weights)\n    variance = np.average((positions - mean_pos)**2, weights=weights)\n    if variance == 0:\n        return 0.0\n    skewness = np.average((positions - mean_pos)**3, weights=weights) / (variance**1.5)\n    return float(skewness)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of maximum to minimum row intensity in the middle third of image\"\n    h, w = image.shape\n    middle_third = image[h//3:2*h//3, :]\n    if middle_third.size == 0:\n        return 1.0\n    row_sums = np.sum(middle_third, axis=1)\n    if len(row_sums) == 0:\n        return 1.0\n    max_row = np.max(row_sums)\n    min_row = np.min(row_sums)\n    if min_row == 0:\n        return float(max_row) if max_row > 0 else 1.0\n    return float(max_row / min_row)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of curved regions to straight regions based on gradient changes\"\n    grad_y, grad_x = np.gradient(image.astype(float))\n    grad_magnitude = np.sqrt(grad_x**2 + grad_y**2)\n    grad_direction = np.arctan2(grad_y, grad_x)\n    \n    direction_changes = np.sum(np.abs(np.diff(grad_direction.flatten())) > np.pi/4)\n    straight_regions = np.sum(grad_magnitude > np.mean(grad_magnitude))\n    \n    return float(direction_changes / (straight_regions + 1e-8))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Number of rows in bottom half with significant pixel activity\"\n    h, w = image.shape\n    bottom_half = image[h//2:, :]\n    threshold = np.mean(image) if np.mean(image) > 0 else 0.1\n    active_rows = 0\n    for row in bottom_half:\n        if np.sum(row) > threshold * w:\n            active_rows += 1\n    return float(active_rows)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of vertical gradient magnitude in left half versus right half\"\n    h, w = image.shape\n    grad_y = np.gradient(image, axis=0)\n    left_grad = np.abs(grad_y[:, :w//2])\n    right_grad = np.abs(grad_y[:, w//2:])\n    left_mag = np.mean(left_grad) if left_grad.size > 0 else 0\n    right_mag = np.mean(right_grad) if right_grad.size > 0 else 0\n    return float(left_mag / (right_mag + 0.001))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Number of rows in bottom half with significant pixel activity\"\n    h, w = image.shape\n    bottom_half = image[h//2:, :]\n    threshold = np.mean(image) if np.mean(image) > 0 else 0.1\n    active_rows = 0\n    for row in bottom_half:\n        if np.sum(row) > threshold * w:\n            active_rows += 1\n    return float(active_rows)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Intensity concentration in the center quarter of the image\"\n    h, w = image.shape\n    center_quarter = image[3*h//8:5*h//8, 3*w//8:5*w//8]\n    if center_quarter.size == 0 or image.size == 0:\n        return 0.0\n    center_sum = np.sum(center_quarter)\n    total_sum = np.sum(image)\n    if total_sum == 0:\n        return 0.0\n    return float(center_sum / total_sum)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of maximum to minimum row intensity in the middle third of image\"\n    h, w = image.shape\n    middle_third = image[h//3:2*h//3, :]\n    if middle_third.size == 0:\n        return 1.0\n    row_sums = np.sum(middle_third, axis=1)\n    if len(row_sums) == 0:\n        return 1.0\n    max_row = np.max(row_sums)\n    min_row = np.min(row_sums)\n    if min_row == 0:\n        return float(max_row) if max_row > 0 else 1.0\n    return float(max_row / min_row)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Average vertical position of the rightmost non-zero pixels\"\n    h, w = image.shape\n    if h == 0 or w == 0:\n        return 0.0\n    rightmost_positions = []\n    for col_idx in range(w-1, -1, -1):\n        col = image[:, col_idx]\n        nonzero_rows = np.where(col > 0)[0]\n        if len(nonzero_rows) > 0:\n            rightmost_positions.extend(nonzero_rows)\n            break\n    if len(rightmost_positions) == 0:\n        return 0.0\n    return float(np.mean(rightmost_positions) / h)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of pixel density in top-right corner versus bottom-left corner\"\n    h, w = image.shape\n    top_right = image[:h//3, 2*w//3:]\n    bottom_left = image[2*h//3:, :w//3]\n    tr_density = np.mean(top_right) if top_right.size > 0 else 0\n    bl_density = np.mean(bottom_left) if bottom_left.size > 0 else 0\n    return float(tr_density / (bl_density + 0.001))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Intensity concentration in the middle-left region of the image\"\n    h, w = image.shape\n    middle_left = image[h//4:3*h//4, :w//2]\n    total_intensity = np.sum(image)\n    if total_intensity == 0:\n        return 0.0\n    return float(np.sum(middle_left) / total_intensity)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of horizontal edges to vertical edges in the image\"\n    grad_y, grad_x = np.gradient(image.astype(float))\n    horizontal_edges = np.sum(np.abs(grad_y) > np.abs(grad_x))\n    vertical_edges = np.sum(np.abs(grad_x) > np.abs(grad_y))\n    if vertical_edges == 0:\n        return float(horizontal_edges)\n    return float(horizontal_edges / vertical_edges)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of curved regions to straight regions based on gradient changes\"\n    grad_y, grad_x = np.gradient(image.astype(float))\n    grad_magnitude = np.sqrt(grad_x**2 + grad_y**2)\n    grad_direction = np.arctan2(grad_y, grad_x)\n    \n    direction_changes = np.sum(np.abs(np.diff(grad_direction.flatten())) > np.pi/4)\n    straight_regions = np.sum(grad_magnitude > np.mean(grad_magnitude))\n    \n    return float(direction_changes / (straight_regions + 1e-8))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Average horizontal gradient magnitude in the bottom third\"\n    h, w = image.shape\n    bottom_third = image[2*h//3:, :]\n    if bottom_third.size == 0:\n        return 0.0\n    horiz_grad = np.gradient(bottom_third, axis=1)\n    return float(np.mean(np.abs(horiz_grad)))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Density of pixels in the middle horizontal band relative to top and bottom thirds\"\n    h, w = image.shape\n    top_third = np.count_nonzero(image[:h//3, :])\n    middle_third = np.count_nonzero(image[h//3:2*h//3, :])\n    bottom_third = np.count_nonzero(image[2*h//3:, :])\n    total_edges = top_third + bottom_third\n    return float(middle_third / (total_edges + 1))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Percentage of total image area occupied by pixels above 75th percentile intensity\"\n    threshold = np.percentile(image, 75)\n    high_intensity_pixels = np.sum(image > threshold)\n    total_pixels = image.size\n    return float(high_intensity_pixels / total_pixels)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Average vertical position of the rightmost non-zero pixels\"\n    h, w = image.shape\n    if h == 0 or w == 0:\n        return 0.0\n    rightmost_positions = []\n    for col_idx in range(w-1, -1, -1):\n        col = image[:, col_idx]\n        nonzero_rows = np.where(col > 0)[0]\n        if len(nonzero_rows) > 0:\n            rightmost_positions.extend(nonzero_rows)\n            break\n    if len(rightmost_positions) == 0:\n        return 0.0\n    return float(np.mean(rightmost_positions) / h)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Maximum consecutive non-zero pixels in any diagonal direction\"\n    h, w = image.shape\n    if h == 0 or w == 0:\n        return 0.0\n    max_diagonal = 0\n    # Main diagonal top-left to bottom-right\n    for start_row in range(h):\n        consecutive = 0\n        for offset in range(min(h - start_row, w)):\n            if image[start_row + offset, offset] > 0:\n                consecutive += 1\n                max_diagonal = max(max_diagonal, consecutive)\n            else:\n                consecutive = 0\n    # Anti-diagonal top-right to bottom-left\n    for start_row in range(h):\n        consecutive = 0\n        for offset in range(min(h - start_row, w)):\n            if image[start_row + offset, w - 1 - offset] > 0:\n                consecutive += 1\n                max_diagonal = max(max_diagonal, consecutive)\n            else:\n                consecutive = 0\n    return float(max_diagonal)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Density of pixels in the bottom-right quadrant\"\n    h, w = image.shape\n    bottom_right = image[h//2:, w//2:]\n    total_pixels = bottom_right.size\n    if total_pixels == 0:\n        return 0.0\n    return float(np.count_nonzero(bottom_right) / total_pixels)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Average pixel intensity difference between adjacent columns in middle section\"\n    h, w = image.shape\n    if w < 3:\n        return 0.0\n    middle_cols = image[:, w//4:3*w//4]\n    if middle_cols.shape[1] < 2:\n        return 0.0\n    diffs = []\n    for i in range(middle_cols.shape[1] - 1):\n        col_diff = np.mean(np.abs(middle_cols[:, i+1] - middle_cols[:, i]))\n        diffs.append(col_diff)\n    return float(np.mean(diffs)) if diffs else 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of pixels in top half versus bottom half of image\"\n    h, w = image.shape\n    if h == 0:\n        return 0.0\n    top_half = np.sum(image[:h//2, :])\n    bottom_half = np.sum(image[h//2:, :])\n    if bottom_half == 0:\n        return float('inf') if top_half > 0 else 0.0\n    return float(top_half / bottom_half)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of non-zero pixels in center region to total non-zero pixels\"\n    h, w = image.shape\n    total_nonzero = np.count_nonzero(image)\n    if total_nonzero == 0:\n        return 0.0\n    center_region = image[h//4:3*h//4, w//4:3*w//4]\n    center_nonzero = np.count_nonzero(center_region)\n    return float(center_nonzero / total_nonzero)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Number of horizontal line segments in the middle third of the image\"\n    h, w = image.shape\n    middle_third = image[h//3:2*h//3, :]\n    line_count = 0\n    threshold = np.mean(middle_third) + 0.5 * np.std(middle_third)\n    for row in middle_third:\n        segments = 0\n        in_segment = False\n        for pixel in row:\n            if pixel > threshold and not in_segment:\n                segments += 1\n                in_segment = True\n            elif pixel <= threshold:\n                in_segment = False\n        line_count += segments\n    return float(line_count)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of pixels in top half versus bottom half of image\"\n    h, w = image.shape\n    if h == 0:\n        return 0.0\n    top_half = np.sum(image[:h//2, :])\n    bottom_half = np.sum(image[h//2:, :])\n    if bottom_half == 0:\n        return float('inf') if top_half > 0 else 0.0\n    return float(top_half / bottom_half)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of horizontal edge strength in middle rows to edge strength in outer rows\"\n    h, w = image.shape\n    if h < 6:\n        return 0.0\n    gradients = np.abs(np.gradient(image, axis=1))\n    middle_third = gradients[h//3:2*h//3, :]\n    outer_thirds = np.concatenate([gradients[:h//3, :], gradients[2*h//3:, :]])\n    middle_strength = np.mean(middle_third) if middle_third.size > 0 else 0.0\n    outer_strength = np.mean(outer_thirds) if outer_thirds.size > 0 else 0.0\n    return middle_strength / (outer_strength + 1e-6)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Number of connected components in the top third of the image\"\n    h, w = image.shape\n    top_third = image[:h//3, :] > 0\n    if top_third.size == 0:\n        return 0.0\n    visited = np.zeros_like(top_third)\n    components = 0\n    for i in range(top_third.shape[0]):\n        for j in range(top_third.shape[1]):\n            if top_third[i, j] and not visited[i, j]:\n                components += 1\n                stack = [(i, j)]\n                while stack:\n                    x, y = stack.pop()\n                    if x < 0 or x >= top_third.shape[0] or y < 0 or y >= top_third.shape[1]:\n                        continue\n                    if visited[x, y] or not top_third[x, y]:\n                        continue\n                    visited[x, y] = True\n                    stack.extend([(x+1, y), (x-1, y), (x, y+1), (x, y-1)])\n    return float(components)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Width of the brightest vertical stroke in the upper third of the image\"\n    h, w = image.shape\n    upper_third = image[:h//3, :]\n    if upper_third.size == 0:\n        return 0.0\n    max_width = 0\n    for row in range(upper_third.shape[0]):\n        current_width = 0\n        for col in range(upper_third.shape[1]):\n            if upper_third[row, col] > np.mean(upper_third):\n                current_width += 1\n            else:\n                max_width = max(max_width, current_width)\n                current_width = 0\n        max_width = max(max_width, current_width)\n    return float(max_width)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Number of connected components in the right half of the image\"\n    h, w = image.shape\n    right_half = image[:, w//2:]\n    binary = (right_half > np.mean(right_half)).astype(int)\n    components = 0\n    visited = np.zeros_like(binary)\n    \n    def flood_fill(y, x):\n        if y < 0 or y >= h or x < 0 or x >= w//2 or visited[y, x] or binary[y, x] == 0:\n            return\n        visited[y, x] = 1\n        for dy, dx in [(0,1), (1,0), (0,-1), (-1,0)]:\n            flood_fill(y + dy, x + dx)\n    \n    for i in range(h):\n        for j in range(w//2):\n            if binary[i, j] and not visited[i, j]:\n                flood_fill(i, j)\n                components += 1\n    return float(components)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Width of the brightest vertical stroke in the upper third of the image\"\n    h, w = image.shape\n    upper_third = image[:h//3, :]\n    if upper_third.size == 0:\n        return 0.0\n    max_width = 0\n    for row in range(upper_third.shape[0]):\n        current_width = 0\n        for col in range(upper_third.shape[1]):\n            if upper_third[row, col] > np.mean(upper_third):\n                current_width += 1\n            else:\n                max_width = max(max_width, current_width)\n                current_width = 0\n        max_width = max(max_width, current_width)\n    return float(max_width)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Average pixel intensity in the center vertical strip of the image\"\n    h, w = image.shape\n    center_strip = image[:, w//3:2*w//3]\n    return float(np.mean(center_strip))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of pixels in top half versus bottom half of image\"\n    h, w = image.shape\n    if h == 0:\n        return 0.0\n    top_half = np.sum(image[:h//2, :])\n    bottom_half = np.sum(image[h//2:, :])\n    if bottom_half == 0:\n        return float('inf') if top_half > 0 else 0.0\n    return float(top_half / bottom_half)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Width of the brightest vertical stroke in the upper third of the image\"\n    h, w = image.shape\n    upper_third = image[:h//3, :]\n    if upper_third.size == 0:\n        return 0.0\n    max_width = 0\n    for row in range(upper_third.shape[0]):\n        current_width = 0\n        for col in range(upper_third.shape[1]):\n            if upper_third[row, col] > np.mean(upper_third):\n                current_width += 1\n            else:\n                max_width = max(max_width, current_width)\n                current_width = 0\n        max_width = max(max_width, current_width)\n    return float(max_width)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Number of connected components in the top third of the image\"\n    h, w = image.shape\n    top_third = image[:h//3, :] > 0\n    if top_third.size == 0:\n        return 0.0\n    visited = np.zeros_like(top_third)\n    components = 0\n    for i in range(top_third.shape[0]):\n        for j in range(top_third.shape[1]):\n            if top_third[i, j] and not visited[i, j]:\n                components += 1\n                stack = [(i, j)]\n                while stack:\n                    x, y = stack.pop()\n                    if x < 0 or x >= top_third.shape[0] or y < 0 or y >= top_third.shape[1]:\n                        continue\n                    if visited[x, y] or not top_third[x, y]:\n                        continue\n                    visited[x, y] = True\n                    stack.extend([(x+1, y), (x-1, y), (x, y+1), (x, y-1)])\n    return float(components)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Maximum consecutive zero pixels in the center vertical line\"\n    h, w = image.shape\n    center_col = image[:, w//2]\n    \n    max_zeros = 0\n    current_zeros = 0\n    \n    for pixel in center_col:\n        if pixel == 0:\n            current_zeros += 1\n            max_zeros = max(max_zeros, current_zeros)\n        else:\n            current_zeros = 0\n    \n    return float(max_zeros)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of vertical connectivity in left third versus right third of image\"\n    h, w = image.shape\n    left_third = image[:, :w//3]\n    right_third = image[:, 2*w//3:]\n    left_vertical = np.sum(np.diff(left_third > 0, axis=0) == False)\n    right_vertical = np.sum(np.diff(right_third > 0, axis=0) == False)\n    if right_vertical == 0:\n        return float(left_vertical)\n    return float(left_vertical / right_vertical)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Maximum consecutive vertical pixels in the rightmost third\"\n    h, w = image.shape\n    if w < 3:\n        return 0.0\n    right_third = image[:, 2*w//3:]\n    max_consecutive = 0\n    threshold = np.mean(image) * 0.5\n    for col in range(right_third.shape[1]):\n        consecutive = 0\n        current_max = 0\n        for row in range(h):\n            if right_third[row, col] > threshold:\n                consecutive += 1\n                current_max = max(current_max, consecutive)\n            else:\n                consecutive = 0\n        max_consecutive = max(max_consecutive, current_max)\n    return float(max_consecutive)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Concentration of mass in diagonal regions\"\n    h, w = image.shape\n    if h == 0 or w == 0:\n        return 0.0\n    main_diag = np.sum([image[i, min(int(i*w/h), w-1)] for i in range(h)])\n    anti_diag = np.sum([image[i, max(0, w-1-int(i*w/h))] for i in range(h)])\n    total_mass = np.sum(image)\n    return float((main_diag + anti_diag) / max(total_mass, 1))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Average vertical distance of brightest pixels from image center\"\n    h, w = image.shape\n    center_y = h // 2\n    threshold = np.percentile(image, 85)\n    bright_pixels = np.where(image > threshold)\n    if len(bright_pixels[0]) == 0:\n        return float(0)\n    distances = np.abs(bright_pixels[0] - center_y)\n    return float(np.mean(distances))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of pixel intensity in the upper third versus middle third of image\"\n    h, w = image.shape\n    upper_third = image[:h//3, :]\n    middle_third = image[h//3:2*h//3, :]\n    upper_mean = np.mean(upper_third)\n    middle_mean = np.mean(middle_third)\n    if middle_mean == 0:\n        return 0.0\n    return float(upper_mean / middle_mean)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of non-zero pixels in top-right quadrant to total non-zero pixels\"\n    h, w = image.shape\n    top_right = image[:h//2, w//2:]\n    total_nonzero = np.count_nonzero(image)\n    tr_nonzero = np.count_nonzero(top_right)\n    if total_nonzero == 0:\n        return 0.0\n    return float(tr_nonzero / total_nonzero)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of pixels in top-left quadrant versus bottom-right quadrant\"\n    h, w = image.shape\n    top_left = image[:h//2, :w//2]\n    bottom_right = image[h//2:, w//2:]\n    top_left_count = np.count_nonzero(top_left)\n    bottom_right_count = np.count_nonzero(bottom_right)\n    if bottom_right_count == 0:\n        return float(top_left_count)\n    return float(top_left_count / bottom_right_count)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of non-zero pixels in the leftmost quarter versus rightmost quarter\"\n    h, w = image.shape\n    if w < 4:\n        return 0.5\n    left_quarter = image[:, :w//4]\n    right_quarter = image[:, 3*w//4:]\n    left_pixels = np.count_nonzero(left_quarter)\n    right_pixels = np.count_nonzero(right_quarter)\n    if right_pixels == 0:\n        return 1.0 if left_pixels > 0 else 0.5\n    return float(left_pixels / right_pixels)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of maximum row sum in bottom half to maximum row sum in top half\"\n    h, w = image.shape\n    if h <= 1:\n        return 0.0\n    top_half = image[:h//2, :]\n    bottom_half = image[h//2:, :]\n    if top_half.size == 0 or bottom_half.size == 0:\n        return 0.0\n    top_max = np.max(np.sum(top_half, axis=1)) if top_half.size > 0 else 0\n    bottom_max = np.max(np.sum(bottom_half, axis=1)) if bottom_half.size > 0 else 0\n    if top_max == 0:\n        return float(bottom_max > 0)\n    return float(bottom_max / top_max)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of vertical gradients in upper half versus lower half\"\n    h, w = image.shape\n    grad_y = np.gradient(image, axis=0)\n    upper_grad = np.sum(np.abs(grad_y[:h//2, :]))\n    lower_grad = np.sum(np.abs(grad_y[h//2:, :]))\n    if lower_grad == 0:\n        return float(upper_grad > 0)\n    return float(upper_grad / lower_grad)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Number of pixels forming curved patterns in the bottom half\"\n    h, w = image.shape\n    bottom_half = image[h//2:, :]\n    threshold = np.mean(bottom_half) + 0.5 * np.std(bottom_half)\n    binary = (bottom_half > threshold).astype(int)\n    curved_pixels = 0\n    for i in range(1, binary.shape[0]-1):\n        for j in range(1, binary.shape[1]-1):\n            if binary[i, j] > 0:\n                neighbors = binary[i-1:i+2, j-1:j+2]\n                if np.sum(neighbors) >= 4 and np.sum(neighbors) <= 6:\n                    curved_pixels += 1\n    return float(curved_pixels)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Maximum horizontal gap between non-zero pixels in center row\"\n    h, w = image.shape\n    center_row = image[h//2, :]\n    nonzero_indices = np.where(center_row > 0)[0]\n    if len(nonzero_indices) <= 1:\n        return 0.0\n    max_gap = 0\n    for i in range(1, len(nonzero_indices)):\n        gap = nonzero_indices[i] - nonzero_indices[i-1] - 1\n        max_gap = max(max_gap, gap)\n    return float(max_gap)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of pixels in top half versus bottom half of image\"\n    h, w = image.shape\n    if h == 0:\n        return 0.0\n    top_half = np.sum(image[:h//2, :])\n    bottom_half = np.sum(image[h//2:, :])\n    if bottom_half == 0:\n        return float('inf') if top_half > 0 else 0.0\n    return float(top_half / bottom_half)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Average intensity of pixels forming enclosed regions or loops\"\n    h, w = image.shape\n    if h < 5 or w < 5:\n        return 0.0\n    center_region = image[h//4:3*h//4, w//4:3*w//4]\n    interior_pixels = center_region[1:-1, 1:-1]\n    boundary_pixels = np.concatenate([\n        center_region[0, :], center_region[-1, :],\n        center_region[1:-1, 0], center_region[1:-1, -1]\n    ])\n    interior_mean = np.mean(interior_pixels) if interior_pixels.size > 0 else 0.0\n    boundary_mean = np.mean(boundary_pixels) if boundary_pixels.size > 0 else 0.0\n    return float(interior_mean - boundary_mean)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of pixels in top half versus bottom half of image\"\n    h, w = image.shape\n    if h == 0:\n        return 0.0\n    top_half = np.sum(image[:h//2, :])\n    bottom_half = np.sum(image[h//2:, :])\n    if bottom_half == 0:\n        return float('inf') if top_half > 0 else 0.0\n    return float(top_half / bottom_half)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of pixels in top half versus bottom half of image\"\n    h, w = image.shape\n    if h == 0:\n        return 0.0\n    top_half = np.sum(image[:h//2, :])\n    bottom_half = np.sum(image[h//2:, :])\n    if bottom_half == 0:\n        return float('inf') if top_half > 0 else 0.0\n    return float(top_half / bottom_half)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Intensity gradient strength in the bottom-right quadrant\"\n    h, w = image.shape\n    if h < 2 or w < 2:\n        return 0.0\n    bottom_right = image[h//2:, w//2:]\n    if bottom_right.size == 0:\n        return 0.0\n    grad_y, grad_x = np.gradient(bottom_right.astype(float))\n    gradient_magnitude = np.sqrt(grad_x**2 + grad_y**2)\n    return float(np.mean(gradient_magnitude))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Number of peaks in horizontal projection profile\"\n    h, w = image.shape\n    horizontal_projection = np.sum(image, axis=1)\n    mean_proj = np.mean(horizontal_projection)\n    peaks = 0\n    for i in range(1, len(horizontal_projection) - 1):\n        if horizontal_projection[i] > horizontal_projection[i-1] and horizontal_projection[i] > horizontal_projection[i+1] and horizontal_projection[i] > mean_proj:\n            peaks += 1\n    return float(peaks)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Intensity concentration in the center-right quadrant\"\n    h, w = image.shape\n    center_right = image[h//4:3*h//4, w//2:3*w//4]\n    if center_right.size == 0:\n        return 0.0\n    total_intensity = np.sum(image)\n    center_right_intensity = np.sum(center_right)\n    return float(center_right_intensity) / (total_intensity + 1e-10)\n",
    "def feature(image: np.ndarray) -> float:\n    \"Maximum horizontal span of connected non-zero pixels in bottom half\"\n    h, w = image.shape\n    bottom_half = image[h//2:, :]\n    max_span = 0\n    for row in bottom_half:\n        current_span = 0\n        for pixel in row:\n            if pixel > 0:\n                current_span += 1\n            else:\n                max_span = max(max_span, current_span)\n                current_span = 0\n        max_span = max(max_span, current_span)\n    return float(max_span)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Width of the brightest vertical stroke in the upper third of the image\"\n    h, w = image.shape\n    upper_third = image[:h//3, :]\n    if upper_third.size == 0:\n        return 0.0\n    max_width = 0\n    for row in range(upper_third.shape[0]):\n        current_width = 0\n        for col in range(upper_third.shape[1]):\n            if upper_third[row, col] > np.mean(upper_third):\n                current_width += 1\n            else:\n                max_width = max(max_width, current_width)\n                current_width = 0\n        max_width = max(max_width, current_width)\n    return float(max_width)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of maximum row intensity to average row intensity\"\n    h, w = image.shape\n    row_sums = np.sum(image, axis=1)\n    if len(row_sums) == 0:\n        return 0.0\n    max_row = np.max(row_sums)\n    avg_row = np.mean(row_sums)\n    if avg_row == 0:\n        return 0.0\n    return float(max_row / avg_row)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Number of connected vertical segments in the rightmost quarter\"\n    h, w = image.shape\n    if w < 4:\n        return 0.0\n    right_quarter = image[:, 3*w//4:]\n    segments = 0\n    for col in range(right_quarter.shape[1]):\n        in_segment = False\n        for row in range(h):\n            if right_quarter[row, col] > 0:\n                if not in_segment:\n                    segments += 1\n                    in_segment = True\n            else:\n                in_segment = False\n    return float(segments)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of pixel sum in bottom-right quadrant to total pixel sum\"\n    h, w = image.shape\n    if h < 2 or w < 2:\n        return 0.0\n    bottom_right = image[h//2:, w//2:]\n    total_sum = np.sum(image)\n    if total_sum == 0:\n        return 0.0\n    return float(np.sum(bottom_right) / total_sum)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of maximum width in top half versus bottom half\"\n    h, w = image.shape\n    if h == 0:\n        return 1.0\n    top_half = image[:h//2, :]\n    bottom_half = image[h//2:, :]\n    \n    top_widths = [np.sum(row > 0) for row in top_half]\n    bottom_widths = [np.sum(row > 0) for row in bottom_half]\n    \n    max_top = max(top_widths) if top_widths else 0\n    max_bottom = max(bottom_widths) if bottom_widths else 0\n    \n    if max_bottom == 0:\n        return float(max_top > 0)\n    return float(max_top / max_bottom)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Maximum horizontal span of non-zero pixels in the bottom quarter\"\n    h, w = image.shape\n    bottom_quarter = image[3*h//4:h, :]\n    max_span = 0.0\n    for row in bottom_quarter:\n        non_zero_cols = np.where(row > 0)[0]\n        if len(non_zero_cols) > 0:\n            span = non_zero_cols[-1] - non_zero_cols[0] + 1\n            max_span = max(max_span, span)\n    return float(max_span)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Intensity concentration in the center-right quadrant\"\n    h, w = image.shape\n    center_right = image[h//4:3*h//4, w//2:3*w//4]\n    if center_right.size == 0:\n        return 0.0\n    total_intensity = np.sum(image)\n    center_right_intensity = np.sum(center_right)\n    return float(center_right_intensity) / (total_intensity + 1e-10)\n",
    "def feature(image: np.ndarray) -> float:\n    \"Average pixel intensity in diagonal stripe from top-left to bottom-right\"\n    h, w = image.shape\n    if h == 0 or w == 0:\n        return 0.0\n    diagonal_pixels = []\n    for i in range(min(h, w)):\n        diagonal_pixels.append(image[i, i])\n    return float(np.mean(diagonal_pixels))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Curvature measure based on direction changes in the brightest path\"\n    h, w = image.shape\n    if h < 3 or w < 3:\n        return 0.0\n    grad_y, grad_x = np.gradient(image)\n    angles = np.arctan2(grad_y, grad_x)\n    diff = np.diff(angles.flatten())\n    diff = np.abs(np.arctan2(np.sin(diff), np.cos(diff)))\n    return float(np.sum(diff > np.pi/4) / len(diff))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of pixels in outer ring versus inner core of image\"\n    h, w = image.shape\n    margin = min(h, w) // 6\n    outer_ring = np.copy(image)\n    if margin > 0:\n        outer_ring[margin:-margin, margin:-margin] = 0\n    inner_core = image[margin:-margin, margin:-margin] if margin > 0 else image\n    outer_count = np.count_nonzero(outer_ring)\n    inner_count = np.count_nonzero(inner_core)\n    if inner_count == 0:\n        return float(outer_count)\n    return float(outer_count / inner_count)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Number of closed loops detected by counting enclosed background regions\"\n    h, w = image.shape\n    threshold = np.mean(image) * 0.4\n    binary = (image > threshold).astype(int)\n    background = 1 - binary\n    visited = np.zeros_like(background)\n    loop_count = 0\n    \n    def flood_fill(start_i, start_j):\n        if start_i < 0 or start_i >= h or start_j < 0 or start_j >= w:\n            return False, 0\n        if visited[start_i, start_j] or background[start_i, start_j] == 0:\n            return False, 0\n        \n        stack = [(start_i, start_j)]\n        size = 0\n        touches_border = False\n        \n        while stack:\n            i, j = stack.pop()\n            if i < 0 or i >= h or j < 0 or j >= w or visited[i, j] or background[i, j] == 0:\n                continue\n            if i == 0 or i == h-1 or j == 0 or j == w-1:\n                touches_border = True\n            \n            visited[i, j] = 1\n            size += 1\n            stack.extend([(i-1,j), (i+1,j), (i,j-1), (i,j+1)])\n        \n        return not touches_border, size\n    \n    for i in range(h):\n        for j in range(w):\n            if background[i, j] and not visited[i, j]:\n                is_enclosed, size = flood_fill(i, j)\n                if is_enclosed and size > 3:\n                    loop_count += 1\n    \n    return float(loop_count)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Average intensity difference between adjacent horizontal pixels\"\n    h, w = image.shape\n    if h == 0 or w < 2:\n        return 0.0\n    diff_sum = 0.0\n    count = 0\n    for i in range(h):\n        for j in range(w-1):\n            diff_sum += abs(float(image[i, j]) - float(image[i, j+1]))\n            count += 1\n    return diff_sum / count if count > 0 else 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Average pixel intensity in a thin horizontal strip at 3/4 height\"\n    h, w = image.shape\n    strip_row = int(3 * h / 4)\n    if strip_row >= h:\n        strip_row = h - 1\n    strip = image[strip_row, :]\n    return float(np.mean(strip))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of pixels in top half versus bottom half of image\"\n    h, w = image.shape\n    if h == 0:\n        return 0.0\n    top_half = np.sum(image[:h//2, :])\n    bottom_half = np.sum(image[h//2:, :])\n    if bottom_half == 0:\n        return float('inf') if top_half > 0 else 0.0\n    return float(top_half / bottom_half)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Vertical symmetry score - correlation between left and right halves\"\n    h, w = image.shape\n    if w < 2:\n        return 0.0\n    left_half = image[:, :w//2]\n    right_half = np.fliplr(image[:, w//2:])\n    min_width = min(left_half.shape[1], right_half.shape[1])\n    left_resized = left_half[:, :min_width].flatten()\n    right_resized = right_half[:, :min_width].flatten()\n    if len(left_resized) == 0 or np.std(left_resized) == 0 or np.std(right_resized) == 0:\n        return 0.0\n    correlation = np.corrcoef(left_resized, right_resized)[0, 1]\n    return float(correlation if not np.isnan(correlation) else 0.0)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of pixels in top half versus bottom half of image\"\n    h, w = image.shape\n    if h == 0:\n        return 0.0\n    top_half = np.sum(image[:h//2, :])\n    bottom_half = np.sum(image[h//2:, :])\n    if bottom_half == 0:\n        return float('inf') if top_half > 0 else 0.0\n    return float(top_half / bottom_half)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Standard deviation of pixel intensities in the top quarter\"\n    h, w = image.shape\n    top_quarter = image[:h//4, :]\n    if top_quarter.size == 0:\n        return 0.0\n    return float(np.std(top_quarter))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of non-zero pixels in outer ring versus inner circle\"\n    h, w = image.shape\n    center_y, center_x = h // 2, w // 2\n    inner_radius = min(h, w) // 6\n    outer_radius = min(h, w) // 3\n    inner_count, outer_count = 0, 0\n    for y in range(h):\n        for x in range(w):\n            dist_sq = (y - center_y) ** 2 + (x - center_x) ** 2\n            if dist_sq <= inner_radius ** 2 and image[y, x] > 0:\n                inner_count += 1\n            elif inner_radius ** 2 < dist_sq <= outer_radius ** 2 and image[y, x] > 0:\n                outer_count += 1\n    return outer_count / (inner_count + 1) if inner_count > 0 else float(outer_count)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of pixels in top half versus bottom half of image\"\n    h, w = image.shape\n    if h == 0:\n        return 0.0\n    top_half = np.sum(image[:h//2, :])\n    bottom_half = np.sum(image[h//2:, :])\n    if bottom_half == 0:\n        return float('inf') if top_half > 0 else 0.0\n    return float(top_half / bottom_half)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of non-zero pixels in the bottom third to total non-zero pixels\"\n    h, w = image.shape\n    bottom_third = image[2*h//3:, :]\n    total_nonzero = np.count_nonzero(image)\n    bottom_nonzero = np.count_nonzero(bottom_third)\n    if total_nonzero == 0:\n        return 0.0\n    return float(bottom_nonzero) / float(total_nonzero)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Maximum consecutive non-zero pixels in any diagonal direction\"\n    h, w = image.shape\n    if h == 0 or w == 0:\n        return 0.0\n    max_diagonal = 0\n    # Main diagonal top-left to bottom-right\n    for start_row in range(h):\n        consecutive = 0\n        for offset in range(min(h - start_row, w)):\n            if image[start_row + offset, offset] > 0:\n                consecutive += 1\n                max_diagonal = max(max_diagonal, consecutive)\n            else:\n                consecutive = 0\n    # Anti-diagonal top-right to bottom-left\n    for start_row in range(h):\n        consecutive = 0\n        for offset in range(min(h - start_row, w)):\n            if image[start_row + offset, w - 1 - offset] > 0:\n                consecutive += 1\n                max_diagonal = max(max_diagonal, consecutive)\n            else:\n                consecutive = 0\n    return float(max_diagonal)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Presence of a curved bottom section connecting left and right sides\"\n    h, w = image.shape\n    bottom_quarter = image[3*h//4:, :]\n    curve_score = 0\n    for i, row in enumerate(bottom_quarter):\n        nonzero_indices = np.where(row > 0)[0]\n        if len(nonzero_indices) > w//4:  # Substantial horizontal presence\n            # Weight rows closer to bottom more heavily\n            weight = (i + 1) / len(bottom_quarter)\n            curve_score += weight * len(nonzero_indices) / w\n    return float(curve_score)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Number of disconnected components in the top third of the image\"\n    h, w = image.shape\n    if h == 0 or w == 0:\n        return 0.0\n    top_third = image[:h//3, :]\n    binary = (top_third > np.mean(top_third)).astype(int)\n    components = 0\n    visited = np.zeros_like(binary)\n    for i in range(binary.shape[0]):\n        for j in range(binary.shape[1]):\n            if binary[i,j] == 1 and visited[i,j] == 0:\n                components += 1\n                stack = [(i,j)]\n                while stack:\n                    ci, cj = stack.pop()\n                    if 0 <= ci < binary.shape[0] and 0 <= cj < binary.shape[1] and visited[ci,cj] == 0 and binary[ci,cj] == 1:\n                        visited[ci,cj] = 1\n                        stack.extend([(ci+1,cj), (ci-1,cj), (ci,cj+1), (ci,cj-1)])\n    return float(components)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Maximum horizontal span of non-zero pixels in the bottom quarter\"\n    h, w = image.shape\n    bottom_quarter = image[3*h//4:h, :]\n    max_span = 0.0\n    for row in bottom_quarter:\n        non_zero_cols = np.where(row > 0)[0]\n        if len(non_zero_cols) > 0:\n            span = non_zero_cols[-1] - non_zero_cols[0] + 1\n            max_span = max(max_span, span)\n    return float(max_span)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Number of vertical runs of consecutive non-zero pixels in middle columns\"\n    h, w = image.shape\n    if w < 3:\n        return 0.0\n    middle_cols = image[:, w//3:2*w//3]\n    runs = 0\n    for col in range(middle_cols.shape[1]):\n        column = middle_cols[:, col]\n        in_run = False\n        for pixel in column:\n            if pixel > 0 and not in_run:\n                runs += 1\n                in_run = True\n            elif pixel == 0:\n                in_run = False\n    return float(runs)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Width of the digit at the vertical midpoint\"\n    h, w = image.shape\n    mid_row = h // 2\n    if mid_row >= h:\n        return 0.0\n    row_pixels = image[mid_row, :]\n    threshold = np.mean(image) + 0.3 * np.std(image)\n    active_pixels = row_pixels > threshold\n    if not np.any(active_pixels):\n        return 0.0\n    first_active = np.argmax(active_pixels)\n    last_active = len(active_pixels) - 1 - np.argmax(active_pixels[::-1])\n    return float((last_active - first_active + 1) / w)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Asymmetry between upper-left and lower-right diagonal regions\"\n    h, w = image.shape\n    upper_left = np.sum([image[i, j] for i in range(h) for j in range(w) if i + j < min(h, w)])\n    lower_right = np.sum([image[i, j] for i in range(h) for j in range(w) if i + j >= max(h, w)])\n    total = upper_left + lower_right\n    if total == 0:\n        return 0.5\n    return float(upper_left / total)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Number of rows in bottom half with significant pixel activity\"\n    h, w = image.shape\n    bottom_half = image[h//2:, :]\n    threshold = np.mean(image) if np.mean(image) > 0 else 0.1\n    active_rows = 0\n    for row in bottom_half:\n        if np.sum(row) > threshold * w:\n            active_rows += 1\n    return float(active_rows)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Average intensity difference between adjacent vertical pixels in center region\"\n    h, w = image.shape\n    if h < 3 or w < 3:\n        return 0.0\n    center_region = image[h//4:3*h//4, w//4:3*w//4]\n    if center_region.shape[0] < 2:\n        return 0.0\n    vertical_diffs = np.abs(np.diff(center_region, axis=0))\n    return float(np.mean(vertical_diffs))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Number of rows in bottom half with significant pixel activity\"\n    h, w = image.shape\n    bottom_half = image[h//2:, :]\n    threshold = np.mean(image) if np.mean(image) > 0 else 0.1\n    active_rows = 0\n    for row in bottom_half:\n        if np.sum(row) > threshold * w:\n            active_rows += 1\n    return float(active_rows)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Number of rows in bottom half with significant pixel activity\"\n    h, w = image.shape\n    bottom_half = image[h//2:, :]\n    threshold = np.mean(image) if np.mean(image) > 0 else 0.1\n    active_rows = 0\n    for row in bottom_half:\n        if np.sum(row) > threshold * w:\n            active_rows += 1\n    return float(active_rows)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Difference in mean intensity between middle row and edges\"\n    h, w = image.shape\n    middle_row = image[h//2, :]\n    top_row = image[0, :]\n    bottom_row = image[-1, :]\n    edge_mean = (np.mean(top_row) + np.mean(bottom_row)) / 2\n    return float(np.mean(middle_row) - edge_mean)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Diagonal edge strength from top-left to bottom-right\"\n    h, w = image.shape\n    diagonal_sum = 0.0\n    count = 0\n    for i in range(min(h-1, w-1)):\n        if i+1 < h and i+1 < w:\n            diagonal_sum += abs(float(image[i+1, i+1]) - float(image[i, i]))\n            count += 1\n    return float(diagonal_sum / count) if count > 0 else 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of maximum to minimum row sums in middle half of image\"\n    h, w = image.shape\n    middle_rows = image[h//4:3*h//4, :]\n    if middle_rows.size == 0:\n        return 1.0\n    row_sums = np.sum(middle_rows, axis=1)\n    max_sum = np.max(row_sums)\n    min_sum = np.min(row_sums)\n    if min_sum == 0:\n        return float(max_sum)\n    return float(max_sum / min_sum)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of vertical gradient magnitude in left half versus right half\"\n    h, w = image.shape\n    grad_y = np.gradient(image, axis=0)\n    left_grad = np.abs(grad_y[:, :w//2])\n    right_grad = np.abs(grad_y[:, w//2:])\n    left_mag = np.mean(left_grad) if left_grad.size > 0 else 0\n    right_mag = np.mean(right_grad) if right_grad.size > 0 else 0\n    return float(left_mag / (right_mag + 0.001))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Count of pixels above median intensity in the center cross pattern\"\n    h, w = image.shape\n    median_val = np.median(image)\n    center_row = image[h//2-h//8:h//2+h//8, :]\n    center_col = image[:, w//2-w//8:w//2+w//8]\n    cross_pixels = np.concatenate([center_row.flatten(), center_col.flatten()])\n    return float(np.sum(cross_pixels > median_val))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Presence of vertical intensity gradient in center column\"\n    h, w = image.shape\n    if w == 0 or h < 2:\n        return 0.0\n    center_col = image[:, w // 2]\n    gradient = np.gradient(center_col)\n    return float(np.std(gradient))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Curvature measure based on direction changes in the upper portion\"\n    h, w = image.shape\n    if h < 4 or w < 4:\n        return 0.0\n    upper_half = image[:h//2, :]\n    grad_y, grad_x = np.gradient(upper_half)\n    angles = np.arctan2(grad_y, grad_x)\n    angle_changes = np.abs(np.diff(angles.flatten()))\n    angle_changes = angle_changes[angle_changes > 0.1]\n    return float(np.sum(angle_changes))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Density of non-zero pixels in the top-right quarter of the image\"\n    h, w = image.shape\n    top_right = image[:h//2, w//2:]\n    total_pixels = top_right.size\n    if total_pixels == 0:\n        return 0.0\n    return float(np.count_nonzero(top_right) / total_pixels)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Horizontal gradient variance in the middle third of image height\"\n    h, w = image.shape\n    middle_section = image[h//3:2*h//3, :]\n    grad_x = np.gradient(middle_section, axis=1)\n    return float(np.var(grad_x))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Number of connected components in the middle third vertically\"\n    h, w = image.shape\n    if h == 0:\n        return 0.0\n    middle_third = image[h//3:2*h//3, :]\n    components = 0\n    visited = np.zeros_like(middle_third, dtype=bool)\n    \n    for i in range(middle_third.shape[0]):\n        for j in range(middle_third.shape[1]):\n            if middle_third[i, j] > 0 and not visited[i, j]:\n                components += 1\n                stack = [(i, j)]\n                while stack:\n                    ci, cj = stack.pop()\n                    if ci >= 0 and ci < middle_third.shape[0] and cj >= 0 and cj < middle_third.shape[1]:\n                        if not visited[ci, cj] and middle_third[ci, cj] > 0:\n                            visited[ci, cj] = True\n                            stack.extend([(ci+1, cj), (ci-1, cj), (ci, cj+1), (ci, cj-1)])\n    return float(components)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of vertical connectivity in left third versus right third of image\"\n    h, w = image.shape\n    left_third = image[:, :w//3]\n    right_third = image[:, 2*w//3:]\n    left_vertical = np.sum(np.diff(left_third > 0, axis=0) == False)\n    right_vertical = np.sum(np.diff(right_third > 0, axis=0) == False)\n    if right_vertical == 0:\n        return float(left_vertical)\n    return float(left_vertical / right_vertical)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Average horizontal gradient magnitude in the bottom half\"\n    h, w = image.shape\n    bottom_half = image[h//2:, :]\n    if bottom_half.size == 0:\n        return 0.0\n    grad_x = np.gradient(bottom_half, axis=1)\n    return float(np.mean(np.abs(grad_x)))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Maximum pixel intensity difference between adjacent rows\"\n    h, w = image.shape\n    if h < 2:\n        return 0.0\n    max_diff = 0.0\n    for i in range(h - 1):\n        row_diff = np.abs(np.mean(image[i]) - np.mean(image[i + 1]))\n        max_diff = max(max_diff, row_diff)\n    return float(max_diff)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Intensity ratio between upper-middle and lower-middle regions\"\n    h, w = image.shape\n    upper_mid = image[h//4:h//2, w//4:3*w//4]\n    lower_mid = image[h//2:3*h//4, w//4:3*w//4]\n    upper_sum = np.sum(upper_mid)\n    lower_sum = np.sum(lower_mid)\n    if lower_sum == 0:\n        return 1.0 if upper_sum > 0 else 0.0\n    return float(upper_sum / (upper_sum + lower_sum))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of pixels in middle third versus left third vertically\"\n    h, w = image.shape\n    left_third = image[:, :w//3]\n    middle_third = image[:, w//3:2*w//3]\n    left_sum = np.sum(left_third)\n    middle_sum = np.sum(middle_third)\n    if left_sum == 0:\n        return 0.0\n    return float(middle_sum / left_sum)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Intensity concentration in the center 3x3 region relative to total\"\n    h, w = image.shape\n    if h < 3 or w < 3:\n        return 0.0\n    center_h, center_w = h//2, w//2\n    center_3x3 = image[center_h-1:center_h+2, center_w-1:center_w+2]\n    center_sum = np.sum(center_3x3)\n    total_sum = np.sum(image)\n    if total_sum == 0:\n        return 0.0\n    return float(center_sum / total_sum)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Gradient magnitude concentration in the lower half of the image\"\n    h, w = image.shape\n    grad_y, grad_x = np.gradient(image.astype(float))\n    gradient_magnitude = np.sqrt(grad_x**2 + grad_y**2)\n    lower_half = gradient_magnitude[h//2:, :]\n    total_gradient = np.sum(gradient_magnitude)\n    return float(np.sum(lower_half) / max(total_gradient, 1e-6))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Number of closed loops detected by counting enclosed background regions\"\n    h, w = image.shape\n    threshold = np.mean(image) * 0.4\n    binary = (image > threshold).astype(int)\n    background = 1 - binary\n    visited = np.zeros_like(background)\n    loop_count = 0\n    \n    def flood_fill(start_i, start_j):\n        if start_i < 0 or start_i >= h or start_j < 0 or start_j >= w:\n            return False, 0\n        if visited[start_i, start_j] or background[start_i, start_j] == 0:\n            return False, 0\n        \n        stack = [(start_i, start_j)]\n        size = 0\n        touches_border = False\n        \n        while stack:\n            i, j = stack.pop()\n            if i < 0 or i >= h or j < 0 or j >= w or visited[i, j] or background[i, j] == 0:\n                continue\n            if i == 0 or i == h-1 or j == 0 or j == w-1:\n                touches_border = True\n            \n            visited[i, j] = 1\n            size += 1\n            stack.extend([(i-1,j), (i+1,j), (i,j-1), (i,j+1)])\n        \n        return not touches_border, size\n    \n    for i in range(h):\n        for j in range(w):\n            if background[i, j] and not visited[i, j]:\n                is_enclosed, size = flood_fill(i, j)\n                if is_enclosed and size > 3:\n                    loop_count += 1\n    \n    return float(loop_count)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of pixels in top half versus bottom half of image\"\n    h, w = image.shape\n    if h == 0:\n        return 0.0\n    top_half = np.sum(image[:h//2, :])\n    bottom_half = np.sum(image[h//2:, :])\n    if bottom_half == 0:\n        return float('inf') if top_half > 0 else 0.0\n    return float(top_half / bottom_half)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of maximum pixel value in top quarter to maximum in bottom quarter\"\n    h, w = image.shape\n    top_quarter = image[:h//4, :]\n    bottom_quarter = image[3*h//4:, :]\n    top_max = np.max(top_quarter) if top_quarter.size > 0 else 0\n    bottom_max = np.max(bottom_quarter) if bottom_quarter.size > 0 else 0\n    if bottom_max == 0:\n        return 1.0 if top_max > 0 else 0.0\n    return float(top_max / bottom_max)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Intensity concentration in the center 3x3 region relative to total\"\n    h, w = image.shape\n    if h < 3 or w < 3:\n        return 0.0\n    center_h, center_w = h//2, w//2\n    center_3x3 = image[center_h-1:center_h+2, center_w-1:center_w+2]\n    center_sum = np.sum(center_3x3)\n    total_sum = np.sum(image)\n    if total_sum == 0:\n        return 0.0\n    return float(center_sum / total_sum)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Width of the widest continuous horizontal line in bottom quarter\"\n    h, w = image.shape\n    bottom_quarter = image[3*h//4:, :]\n    max_width = 0\n    for row in bottom_quarter:\n        current_width = 0\n        for pixel in row:\n            if pixel > 0:\n                current_width += 1\n                max_width = max(max_width, current_width)\n            else:\n                current_width = 0\n    return float(max_width)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Count of diagonal transitions from zero to non-zero pixels (top-left to bottom-right)\"\n    h, w = image.shape\n    transitions = 0\n    for i in range(min(h-1, w-1)):\n        for offset in range(max(0, -i), min(h-i, w)):\n            row, col = i + offset, offset\n            if row < h-1 and col < w-1:\n                if image[row, col] == 0 and image[row+1, col+1] > 0:\n                    transitions += 1\n    return float(transitions)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of vertical gradient magnitude in left half versus right half\"\n    h, w = image.shape\n    grad_y = np.gradient(image, axis=0)\n    left_grad = np.abs(grad_y[:, :w//2])\n    right_grad = np.abs(grad_y[:, w//2:])\n    left_mag = np.mean(left_grad) if left_grad.size > 0 else 0\n    right_mag = np.mean(right_grad) if right_grad.size > 0 else 0\n    return float(left_mag / (right_mag + 0.001))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of pixels in top half versus bottom half of image\"\n    h, w = image.shape\n    if h == 0:\n        return 0.0\n    top_half = np.sum(image[:h//2, :])\n    bottom_half = np.sum(image[h//2:, :])\n    if bottom_half == 0:\n        return float('inf') if top_half > 0 else 0.0\n    return float(top_half / bottom_half)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of pixels in top half versus bottom half of image\"\n    h, w = image.shape\n    if h == 0:\n        return 0.0\n    top_half = np.sum(image[:h//2, :])\n    bottom_half = np.sum(image[h//2:, :])\n    if bottom_half == 0:\n        return float('inf') if top_half > 0 else 0.0\n    return float(top_half / bottom_half)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of pixel density in bottom-right quadrant to bottom-left quadrant\"\n    h, w = image.shape\n    bottom_right = image[h//2:, w//2:]\n    bottom_left = image[h//2:, :w//2]\n    density_br = np.count_nonzero(bottom_right) / (bottom_right.size + 1e-6)\n    density_bl = np.count_nonzero(bottom_left) / (bottom_left.size + 1e-6)\n    return float(density_br / (density_bl + 1e-6))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Average width of non-zero regions per row in bottom half\"\n    h, w = image.shape\n    bottom_half = image[h//2:, :]\n    total_width = 0\n    valid_rows = 0\n    for row in bottom_half:\n        nonzero_indices = np.where(row > 0)[0]\n        if len(nonzero_indices) > 0:\n            width = nonzero_indices[-1] - nonzero_indices[0] + 1\n            total_width += width\n            valid_rows += 1\n    return float(total_width / valid_rows if valid_rows > 0 else 0)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Variance of row sums in the bottom quarter of the image\"\n    h, w = image.shape\n    if h < 4:\n        return 0.0\n    bottom_quarter = image[3*h//4:, :]\n    row_sums = np.sum(bottom_quarter, axis=1)\n    return float(np.var(row_sums))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of vertical edge strength to horizontal edge strength\"\n    if image.size == 0:\n        return 0.0\n    grad_y, grad_x = np.gradient(image)\n    vertical_strength = np.sum(np.abs(grad_x))\n    horizontal_strength = np.sum(np.abs(grad_y))\n    if horizontal_strength == 0:\n        return 1.0 if vertical_strength > 0 else 0.0\n    return float(vertical_strength / horizontal_strength)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Average pixel intensity in the center-left vertical strip\"\n    h, w = image.shape\n    center_left = image[h//4:3*h//4, w//6:w//3]\n    if center_left.size == 0:\n        return 0.0\n    return float(np.mean(center_left))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of pixels in top half versus bottom half of image\"\n    h, w = image.shape\n    if h == 0:\n        return 0.0\n    top_half = np.sum(image[:h//2, :])\n    bottom_half = np.sum(image[h//2:, :])\n    if bottom_half == 0:\n        return float('inf') if top_half > 0 else 0.0\n    return float(top_half / bottom_half)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of pixels in top half versus bottom half of image\"\n    h, w = image.shape\n    if h == 0:\n        return 0.0\n    top_half = np.sum(image[:h//2, :])\n    bottom_half = np.sum(image[h//2:, :])\n    if bottom_half == 0:\n        return float('inf') if top_half > 0 else 0.0\n    return float(top_half / bottom_half)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Width of the widest continuous horizontal line in bottom quarter\"\n    h, w = image.shape\n    bottom_quarter = image[3*h//4:, :]\n    max_width = 0\n    for row in bottom_quarter:\n        current_width = 0\n        for pixel in row:\n            if pixel > 0:\n                current_width += 1\n                max_width = max(max_width, current_width)\n            else:\n                current_width = 0\n    return float(max_width)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Average intensity difference between adjacent horizontal pixels\"\n    h, w = image.shape\n    if h == 0 or w < 2:\n        return 0.0\n    diff_sum = 0.0\n    count = 0\n    for i in range(h):\n        for j in range(w-1):\n            diff_sum += abs(float(image[i, j]) - float(image[i, j+1]))\n            count += 1\n    return diff_sum / count if count > 0 else 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Intensity concentration in the upper-left quadrant\"\n    h, w = image.shape\n    upper_left = image[:h//2, :w//2]\n    total_intensity = np.sum(image)\n    if total_intensity == 0:\n        return 0.0\n    upper_left_intensity = np.sum(upper_left)\n    return float(upper_left_intensity / total_intensity)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of pixels in the middle ring versus center circle\"\n    h, w = image.shape\n    center_y, center_x = h // 2, w // 2\n    y, x = np.ogrid[:h, :w]\n    distances = np.sqrt((y - center_y)**2 + (x - center_x)**2)\n    inner_radius = min(h, w) // 6\n    outer_radius = min(h, w) // 3\n    center_pixels = np.sum(image[distances <= inner_radius])\n    ring_pixels = np.sum(image[(distances > inner_radius) & (distances <= outer_radius)])\n    return float(ring_pixels / max(center_pixels, 1))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Intensity ratio between upper-middle and lower-middle regions\"\n    h, w = image.shape\n    upper_mid = image[h//4:h//2, w//4:3*w//4]\n    lower_mid = image[h//2:3*h//4, w//4:3*w//4]\n    upper_sum = np.sum(upper_mid)\n    lower_sum = np.sum(lower_mid)\n    if lower_sum == 0:\n        return 1.0 if upper_sum > 0 else 0.0\n    return float(upper_sum / (upper_sum + lower_sum))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of maximum to minimum row sums in middle half of image\"\n    h, w = image.shape\n    middle_rows = image[h//4:3*h//4, :]\n    if middle_rows.size == 0:\n        return 1.0\n    row_sums = np.sum(middle_rows, axis=1)\n    max_sum = np.max(row_sums)\n    min_sum = np.min(row_sums)\n    if min_sum == 0:\n        return float(max_sum)\n    return float(max_sum / min_sum)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Compactness of non-zero pixels measured by their spread from centroid\"\n    nonzero_coords = np.where(image > 0)\n    if len(nonzero_coords[0]) == 0:\n        return 0.0\n    centroid_y = np.mean(nonzero_coords[0])\n    centroid_x = np.mean(nonzero_coords[1])\n    distances = np.sqrt((nonzero_coords[0] - centroid_y)**2 + (nonzero_coords[1] - centroid_x)**2)\n    return float(np.std(distances))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Average intensity in the middle horizontal strip of the image\"\n    h, w = image.shape\n    middle_strip = image[h//3:2*h//3, :]\n    return float(np.mean(middle_strip))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of pixels in top half versus bottom half of image\"\n    h, w = image.shape\n    if h == 0:\n        return 0.0\n    top_half = np.sum(image[:h//2, :])\n    bottom_half = np.sum(image[h//2:, :])\n    if bottom_half == 0:\n        return float('inf') if top_half > 0 else 0.0\n    return float(top_half / bottom_half)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of pixels in top half versus bottom half of image\"\n    h, w = image.shape\n    if h == 0:\n        return 0.0\n    top_half = np.sum(image[:h//2, :])\n    bottom_half = np.sum(image[h//2:, :])\n    if bottom_half == 0:\n        return float('inf') if top_half > 0 else 0.0\n    return float(top_half / bottom_half)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Number of horizontal transitions from zero to non-zero pixels\"\n    transitions = 0\n    h, w = image.shape\n    for row in range(h):\n        for col in range(1, w):\n            if image[row, col-1] == 0 and image[row, col] > 0:\n                transitions += 1\n    return float(transitions)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of pixels in top half versus bottom half of image\"\n    h, w = image.shape\n    if h == 0:\n        return 0.0\n    top_half = np.sum(image[:h//2, :])\n    bottom_half = np.sum(image[h//2:, :])\n    if bottom_half == 0:\n        return float('inf') if top_half > 0 else 0.0\n    return float(top_half / bottom_half)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of pixels in top half versus bottom half of image\"\n    h, w = image.shape\n    if h == 0:\n        return 0.0\n    top_half = np.sum(image[:h//2, :])\n    bottom_half = np.sum(image[h//2:, :])\n    if bottom_half == 0:\n        return float('inf') if top_half > 0 else 0.0\n    return float(top_half / bottom_half)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of pixels in top half versus bottom half of image\"\n    h, w = image.shape\n    if h == 0:\n        return 0.0\n    top_half = np.sum(image[:h//2, :])\n    bottom_half = np.sum(image[h//2:, :])\n    if bottom_half == 0:\n        return float('inf') if top_half > 0 else 0.0\n    return float(top_half / bottom_half)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of pixels in top half versus bottom half of image\"\n    h, w = image.shape\n    if h == 0:\n        return 0.0\n    top_half = np.sum(image[:h//2, :])\n    bottom_half = np.sum(image[h//2:, :])\n    if bottom_half == 0:\n        return float('inf') if top_half > 0 else 0.0\n    return float(top_half / bottom_half)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of pixels in top half versus bottom half of image\"\n    h, w = image.shape\n    if h == 0:\n        return 0.0\n    top_half = np.sum(image[:h//2, :])\n    bottom_half = np.sum(image[h//2:, :])\n    if bottom_half == 0:\n        return float('inf') if top_half > 0 else 0.0\n    return float(top_half / bottom_half)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of pixels in top half versus bottom half of image\"\n    h, w = image.shape\n    if h == 0:\n        return 0.0\n    top_half = np.sum(image[:h//2, :])\n    bottom_half = np.sum(image[h//2:, :])\n    if bottom_half == 0:\n        return float('inf') if top_half > 0 else 0.0\n    return float(top_half / bottom_half)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of pixels in top half versus bottom half of image\"\n    h, w = image.shape\n    if h == 0:\n        return 0.0\n    top_half = np.sum(image[:h//2, :])\n    bottom_half = np.sum(image[h//2:, :])\n    if bottom_half == 0:\n        return float('inf') if top_half > 0 else 0.0\n    return float(top_half / bottom_half)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of pixels in top half versus bottom half of image\"\n    h, w = image.shape\n    if h == 0:\n        return 0.0\n    top_half = np.sum(image[:h//2, :])\n    bottom_half = np.sum(image[h//2:, :])\n    if bottom_half == 0:\n        return float('inf') if top_half > 0 else 0.0\n    return float(top_half / bottom_half)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of pixels in top half versus bottom half of image\"\n    h, w = image.shape\n    if h == 0:\n        return 0.0\n    top_half = np.sum(image[:h//2, :])\n    bottom_half = np.sum(image[h//2:, :])\n    if bottom_half == 0:\n        return float('inf') if top_half > 0 else 0.0\n    return float(top_half / bottom_half)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of pixels in top half versus bottom half of image\"\n    h, w = image.shape\n    if h == 0:\n        return 0.0\n    top_half = np.sum(image[:h//2, :])\n    bottom_half = np.sum(image[h//2:, :])\n    if bottom_half == 0:\n        return float('inf') if top_half > 0 else 0.0\n    return float(top_half / bottom_half)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of pixels in top half versus bottom half of image\"\n    h, w = image.shape\n    if h == 0:\n        return 0.0\n    top_half = np.sum(image[:h//2, :])\n    bottom_half = np.sum(image[h//2:, :])\n    if bottom_half == 0:\n        return float('inf') if top_half > 0 else 0.0\n    return float(top_half / bottom_half)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of pixels in top half versus bottom half of image\"\n    h, w = image.shape\n    if h == 0:\n        return 0.0\n    top_half = np.sum(image[:h//2, :])\n    bottom_half = np.sum(image[h//2:, :])\n    if bottom_half == 0:\n        return float('inf') if top_half > 0 else 0.0\n    return float(top_half / bottom_half)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of pixels in top half versus bottom half of image\"\n    h, w = image.shape\n    if h == 0:\n        return 0.0\n    top_half = np.sum(image[:h//2, :])\n    bottom_half = np.sum(image[h//2:, :])\n    if bottom_half == 0:\n        return float('inf') if top_half > 0 else 0.0\n    return float(top_half / bottom_half)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Standard deviation of column-wise pixel intensity sums\"\n    h, w = image.shape\n    if w == 0:\n        return 0.0\n    col_sums = np.sum(image, axis=0)\n    return float(np.std(col_sums))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of pixels in top half versus bottom half of image\"\n    h, w = image.shape\n    if h == 0:\n        return 0.0\n    top_half = np.sum(image[:h//2, :])\n    bottom_half = np.sum(image[h//2:, :])\n    if bottom_half == 0:\n        return float('inf') if top_half > 0 else 0.0\n    return float(top_half / bottom_half)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Vertical gradient variance in the middle columns\"\n    h, w = image.shape\n    if h < 2 or w < 3:\n        return 0.0\n    middle_cols = image[:, w//3:2*w//3]\n    grad_y = np.gradient(middle_cols, axis=0)\n    return float(np.var(grad_y))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of pixels in the bottom quarter versus top quarter of the image\"\n    h, w = image.shape\n    if h < 4:\n        return 0.0\n    top_quarter = np.sum(image[:h//4, :])\n    bottom_quarter = np.sum(image[-h//4:, :])\n    if top_quarter == 0:\n        return float(bottom_quarter > 0)\n    return float(bottom_quarter / top_quarter)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Maximum width of continuous horizontal pixel runs in middle third\"\n    h, w = image.shape\n    middle_third = image[h//3:2*h//3, :]\n    threshold = np.mean(middle_third) + 0.5 * np.std(middle_third)\n    binary = middle_third > threshold\n    max_width = 0\n    for row in binary:\n        current_width = 0\n        for pixel in row:\n            if pixel:\n                current_width += 1\n                max_width = max(max_width, current_width)\n            else:\n                current_width = 0\n    return float(max_width)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of pixels in top half versus bottom half of image\"\n    h, w = image.shape\n    if h == 0:\n        return 0.0\n    top_half = np.sum(image[:h//2, :])\n    bottom_half = np.sum(image[h//2:, :])\n    if bottom_half == 0:\n        return float('inf') if top_half > 0 else 0.0\n    return float(top_half / bottom_half)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of pixels in top half versus bottom half of image\"\n    h, w = image.shape\n    if h == 0:\n        return 0.0\n    top_half = np.sum(image[:h//2, :])\n    bottom_half = np.sum(image[h//2:, :])\n    if bottom_half == 0:\n        return float('inf') if top_half > 0 else 0.0\n    return float(top_half / bottom_half)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of maximum row intensity to average row intensity\"\n    h, w = image.shape\n    row_sums = np.sum(image, axis=1)\n    if len(row_sums) == 0:\n        return 0.0\n    max_row = np.max(row_sums)\n    avg_row = np.mean(row_sums)\n    if avg_row == 0:\n        return 0.0\n    return float(max_row / avg_row)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Maximum vertical extent of continuous foreground pixels in the rightmost third\"\n    h, w = image.shape\n    right_third = image[:, 2*w//3:]\n    if right_third.size == 0:\n        return 0.0\n    max_extent = 0\n    for col in range(right_third.shape[1]):\n        column = right_third[:, col]\n        nonzero_indices = np.where(column > 0)[0]\n        if len(nonzero_indices) > 0:\n            extent = nonzero_indices[-1] - nonzero_indices[0] + 1\n            max_extent = max(max_extent, extent)\n    return float(max_extent)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of pixels in top half versus bottom half of image\"\n    h, w = image.shape\n    if h == 0:\n        return 0.0\n    top_half = np.sum(image[:h//2, :])\n    bottom_half = np.sum(image[h//2:, :])\n    if bottom_half == 0:\n        return float('inf') if top_half > 0 else 0.0\n    return float(top_half / bottom_half)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of pixels in top half versus bottom half of image\"\n    h, w = image.shape\n    if h == 0:\n        return 0.0\n    top_half = np.sum(image[:h//2, :])\n    bottom_half = np.sum(image[h//2:, :])\n    if bottom_half == 0:\n        return float('inf') if top_half > 0 else 0.0\n    return float(top_half / bottom_half)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Average vertical thickness of non-zero regions in the center columns\"\n    h, w = image.shape\n    if w == 0:\n        return 0.0\n    center_cols = image[:, w//4:3*w//4]\n    if center_cols.size == 0:\n        return 0.0\n    thicknesses = []\n    for col in range(center_cols.shape[1]):\n        column = center_cols[:, col]\n        nonzero_indices = np.where(column > 0)[0]\n        if len(nonzero_indices) > 0:\n            thickness = np.max(nonzero_indices) - np.min(nonzero_indices) + 1\n            thicknesses.append(thickness)\n    return float(np.mean(thicknesses) if thicknesses else 0.0)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Number of rows in bottom half where pixel intensity changes more than 3 times\"\n    h, w = image.shape\n    bottom_half = image[h//2:, :]\n    if bottom_half.shape[0] == 0:\n        return 0.0\n    count = 0\n    threshold = np.std(image) * 0.5\n    for row in bottom_half:\n        if len(row) < 2:\n            continue\n        changes = np.sum(np.abs(np.diff(row)) > threshold)\n        if changes > 3:\n            count += 1\n    return float(count)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of non-zero pixels in the bottom quarter versus top quarter\"\n    h, w = image.shape\n    top_quarter = image[:h//4, :]\n    bottom_quarter = image[3*h//4:, :]\n    top_count = np.count_nonzero(top_quarter)\n    bottom_count = np.count_nonzero(bottom_quarter)\n    if top_count == 0:\n        return float(bottom_count)\n    return float(bottom_count / top_count)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Count of high intensity pixels (above 75th percentile) in bottom quarter\"\n    h, w = image.shape\n    if h == 0:\n        return 0.0\n    bottom_quarter = image[3*h//4:, :]\n    if bottom_quarter.size == 0:\n        return 0.0\n    threshold = np.percentile(image, 75)\n    high_intensity_count = np.sum(bottom_quarter > threshold)\n    return float(high_intensity_count)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Standard deviation of pixel intensities in the rightmost third\"\n    h, w = image.shape\n    right_third = image[:, 2*w//3:]\n    return float(np.std(right_third))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of pixels in top half versus bottom half of image\"\n    h, w = image.shape\n    if h == 0:\n        return 0.0\n    top_half = np.sum(image[:h//2, :])\n    bottom_half = np.sum(image[h//2:, :])\n    if bottom_half == 0:\n        return float('inf') if top_half > 0 else 0.0\n    return float(top_half / bottom_half)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of pixels in top half versus bottom half of image\"\n    h, w = image.shape\n    if h == 0:\n        return 0.0\n    top_half = np.sum(image[:h//2, :])\n    bottom_half = np.sum(image[h//2:, :])\n    if bottom_half == 0:\n        return float('inf') if top_half > 0 else 0.0\n    return float(top_half / bottom_half)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of pixels in top half versus bottom half of image\"\n    h, w = image.shape\n    if h == 0:\n        return 0.0\n    top_half = np.sum(image[:h//2, :])\n    bottom_half = np.sum(image[h//2:, :])\n    if bottom_half == 0:\n        return float('inf') if top_half > 0 else 0.0\n    return float(top_half / bottom_half)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of pixels in top half versus bottom half of image\"\n    h, w = image.shape\n    if h == 0:\n        return 0.0\n    top_half = np.sum(image[:h//2, :])\n    bottom_half = np.sum(image[h//2:, :])\n    if bottom_half == 0:\n        return float('inf') if top_half > 0 else 0.0\n    return float(top_half / bottom_half)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Intensity ratio between upper-middle and lower-middle regions\"\n    h, w = image.shape\n    upper_mid = image[h//4:h//2, w//4:3*w//4]\n    lower_mid = image[h//2:3*h//4, w//4:3*w//4]\n    upper_sum = np.sum(upper_mid)\n    lower_sum = np.sum(lower_mid)\n    if lower_sum == 0:\n        return 1.0 if upper_sum > 0 else 0.0\n    return float(upper_sum / (upper_sum + lower_sum))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of pixels in top half versus bottom half of image\"\n    h, w = image.shape\n    if h == 0:\n        return 0.0\n    top_half = np.sum(image[:h//2, :])\n    bottom_half = np.sum(image[h//2:, :])\n    if bottom_half == 0:\n        return float('inf') if top_half > 0 else 0.0\n    return float(top_half / bottom_half)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Average pixel intensity in the top-left to bottom-right diagonal region\"\n    h, w = image.shape\n    diagonal_sum = 0\n    diagonal_count = 0\n    for i in range(min(h, w)):\n        for j in range(max(0, i-2), min(w, i+3)):\n            if i < h and j < w:\n                diagonal_sum += image[i, j]\n                diagonal_count += 1\n    if diagonal_count == 0:\n        return 0.0\n    return float(diagonal_sum / diagonal_count)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of pixel density in upper third versus lower third of image\"\n    h, w = image.shape\n    upper_third = image[:h//3, :]\n    lower_third = image[2*h//3:, :]\n    upper_density = np.mean(upper_third) if upper_third.size > 0 else 0\n    lower_density = np.mean(lower_third) if lower_third.size > 0 else 0\n    return float(upper_density / (lower_density + 1e-8))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Average pixel intensity in the innermost central quarter region\"\n    h, w = image.shape\n    center_h, center_w = h // 8, w // 8\n    inner_region = image[3*center_h:5*center_h, 3*center_w:5*center_w]\n    if inner_region.size == 0:\n        return 0.0\n    return float(np.mean(inner_region))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of pixels in top half versus bottom half of image\"\n    h, w = image.shape\n    if h == 0:\n        return 0.0\n    top_half = np.sum(image[:h//2, :])\n    bottom_half = np.sum(image[h//2:, :])\n    if bottom_half == 0:\n        return float('inf') if top_half > 0 else 0.0\n    return float(top_half / bottom_half)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Average pixel intensity in the center vertical strip of the image\"\n    h, w = image.shape\n    center_strip = image[:, w//3:2*w//3]\n    return float(np.mean(center_strip))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of pixels in top half versus bottom half of image\"\n    h, w = image.shape\n    if h == 0:\n        return 0.0\n    top_half = np.sum(image[:h//2, :])\n    bottom_half = np.sum(image[h//2:, :])\n    if bottom_half == 0:\n        return float('inf') if top_half > 0 else 0.0\n    return float(top_half / bottom_half)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of pixels in top half versus bottom half of image\"\n    h, w = image.shape\n    if h == 0:\n        return 0.0\n    top_half = np.sum(image[:h//2, :])\n    bottom_half = np.sum(image[h//2:, :])\n    if bottom_half == 0:\n        return float('inf') if top_half > 0 else 0.0\n    return float(top_half / bottom_half)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of pixels in top half versus bottom half of image\"\n    h, w = image.shape\n    if h == 0:\n        return 0.0\n    top_half = np.sum(image[:h//2, :])\n    bottom_half = np.sum(image[h//2:, :])\n    if bottom_half == 0:\n        return float('inf') if top_half > 0 else 0.0\n    return float(top_half / bottom_half)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of pixels in top half versus bottom half of image\"\n    h, w = image.shape\n    if h == 0:\n        return 0.0\n    top_half = np.sum(image[:h//2, :])\n    bottom_half = np.sum(image[h//2:, :])\n    if bottom_half == 0:\n        return float('inf') if top_half > 0 else 0.0\n    return float(top_half / bottom_half)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of pixels in top half versus bottom half of image\"\n    h, w = image.shape\n    if h == 0:\n        return 0.0\n    top_half = np.sum(image[:h//2, :])\n    bottom_half = np.sum(image[h//2:, :])\n    if bottom_half == 0:\n        return float('inf') if top_half > 0 else 0.0\n    return float(top_half / bottom_half)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of filled pixels in middle-right region to middle-left region\"\n    h, w = image.shape\n    mid_top, mid_bottom = h//3, 2*h//3\n    left_region = image[mid_top:mid_bottom, :w//2]\n    right_region = image[mid_top:mid_bottom, w//2:]\n    left_count = np.count_nonzero(left_region) if left_region.size > 0 else 1\n    right_count = np.count_nonzero(right_region) if right_region.size > 0 else 0\n    return float(right_count / max(left_count, 1))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Maximum pixel intensity difference between adjacent rows\"\n    h, w = image.shape\n    if h < 2:\n        return 0.0\n    max_diff = 0.0\n    for i in range(h - 1):\n        row_diff = np.abs(np.mean(image[i]) - np.mean(image[i + 1]))\n        max_diff = max(max_diff, row_diff)\n    return float(max_diff)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Skewness of horizontal distribution of non-zero pixels\"\n    h, w = image.shape\n    if w == 0:\n        return 0.0\n    col_sums = np.sum(image, axis=0)\n    non_zero_cols = np.nonzero(col_sums)[0]\n    if len(non_zero_cols) < 3:\n        return 0.0\n    weights = col_sums[non_zero_cols]\n    positions = non_zero_cols\n    mean_pos = np.average(positions, weights=weights)\n    variance = np.average((positions - mean_pos)**2, weights=weights)\n    if variance == 0:\n        return 0.0\n    skewness = np.average((positions - mean_pos)**3, weights=weights) / (variance**1.5)\n    return float(skewness)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of vertical connectivity in left third versus right third of image\"\n    h, w = image.shape\n    left_third = image[:, :w//3]\n    right_third = image[:, 2*w//3:]\n    left_vertical = np.sum(np.diff(left_third > 0, axis=0) == False)\n    right_vertical = np.sum(np.diff(right_third > 0, axis=0) == False)\n    if right_vertical == 0:\n        return float(left_vertical)\n    return float(left_vertical / right_vertical)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Variance of row sums in the bottom quarter of the image\"\n    h, w = image.shape\n    if h < 4:\n        return 0.0\n    bottom_quarter = image[3*h//4:, :]\n    row_sums = np.sum(bottom_quarter, axis=1)\n    return float(np.var(row_sums))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of pixels in top half versus bottom half of image\"\n    h, w = image.shape\n    if h == 0:\n        return 0.0\n    top_half = np.sum(image[:h//2, :])\n    bottom_half = np.sum(image[h//2:, :])\n    if bottom_half == 0:\n        return float('inf') if top_half > 0 else 0.0\n    return float(top_half / bottom_half)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of pixels in top half versus bottom half of image\"\n    h, w = image.shape\n    if h == 0:\n        return 0.0\n    top_half = np.sum(image[:h//2, :])\n    bottom_half = np.sum(image[h//2:, :])\n    if bottom_half == 0:\n        return float('inf') if top_half > 0 else 0.0\n    return float(top_half / bottom_half)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Average vertical distance from center of mass to image center\"\n    h, w = image.shape\n    if np.sum(image) == 0:\n        return 0.0\n    y_coords, x_coords = np.where(image > 0)\n    if len(y_coords) == 0:\n        return 0.0\n    center_y = np.average(y_coords, weights=image[y_coords, x_coords])\n    return float(abs(center_y - h/2))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of pixels in top half versus bottom half of image\"\n    h, w = image.shape\n    if h == 0:\n        return 0.0\n    top_half = np.sum(image[:h//2, :])\n    bottom_half = np.sum(image[h//2:, :])\n    if bottom_half == 0:\n        return float('inf') if top_half > 0 else 0.0\n    return float(top_half / bottom_half)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Number of vertical gaps in the middle third of the image\"\n    h, w = image.shape\n    middle_region = image[h//3:2*h//3, :]\n    gaps = 0\n    for col in range(w):\n        column_pixels = middle_region[:, col]\n        in_gap = True\n        for pixel in column_pixels:\n            if pixel > 0:\n                if in_gap:\n                    gaps += 1\n                    in_gap = False\n            else:\n                in_gap = True\n    return float(gaps)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Maximum vertical stroke thickness in the leftmost third of image\"\n    h, w = image.shape\n    if w < 3:\n        return 0.0\n    left_region = image[:, :w//3]\n    threshold = np.mean(left_region) if left_region.size > 0 else 0\n    binary = (left_region > threshold).astype(int)\n    max_thickness = 0\n    for j in range(binary.shape[1]):\n        current_thickness = 0\n        for i in range(binary.shape[0]):\n            if binary[i, j] > 0:\n                current_thickness += 1\n            else:\n                max_thickness = max(max_thickness, current_thickness)\n                current_thickness = 0\n        max_thickness = max(max_thickness, current_thickness)\n    return float(max_thickness)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Average horizontal gradient magnitude in the middle-left region\"\n    h, w = image.shape\n    if h == 0 or w == 0:\n        return 0.0\n    middle_left = image[h//3:2*h//3, :w//2]\n    if middle_left.size == 0:\n        return 0.0\n    grad_x = np.gradient(middle_left, axis=1)\n    return float(np.mean(np.abs(grad_x)))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of pixel sum in bottom-right quadrant to total pixel sum\"\n    h, w = image.shape\n    if h < 2 or w < 2:\n        return 0.0\n    bottom_right = image[h//2:, w//2:]\n    total_sum = np.sum(image)\n    if total_sum == 0:\n        return 0.0\n    return float(np.sum(bottom_right) / total_sum)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of pixels in top half versus bottom half of image\"\n    h, w = image.shape\n    if h == 0:\n        return 0.0\n    top_half = np.sum(image[:h//2, :])\n    bottom_half = np.sum(image[h//2:, :])\n    if bottom_half == 0:\n        return float('inf') if top_half > 0 else 0.0\n    return float(top_half / bottom_half)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Number of vertical runs of consecutive non-zero pixels\"\n    h, w = image.shape\n    runs = 0\n    for col in range(w):\n        in_run = False\n        for row in range(h):\n            if image[row, col] > 0:\n                if not in_run:\n                    runs += 1\n                    in_run = True\n            else:\n                in_run = False\n    return float(runs)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Number of rows that contain only one connected component of non-zero pixels\"\n    h, w = image.shape\n    single_component_rows = 0\n    for row in image:\n        components = 0\n        in_component = False\n        for pixel in row:\n            if pixel > 0 and not in_component:\n                components += 1\n                in_component = True\n            elif pixel == 0:\n                in_component = False\n        if components == 1:\n            single_component_rows += 1\n    return float(single_component_rows)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of pixels in top half versus bottom half of image\"\n    h, w = image.shape\n    if h == 0:\n        return 0.0\n    top_half = np.sum(image[:h//2, :])\n    bottom_half = np.sum(image[h//2:, :])\n    if bottom_half == 0:\n        return float('inf') if top_half > 0 else 0.0\n    return float(top_half / bottom_half)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of pixels in top half versus bottom half of image\"\n    h, w = image.shape\n    if h == 0:\n        return 0.0\n    top_half = np.sum(image[:h//2, :])\n    bottom_half = np.sum(image[h//2:, :])\n    if bottom_half == 0:\n        return float('inf') if top_half > 0 else 0.0\n    return float(top_half / bottom_half)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of pixels in top half versus bottom half of image\"\n    h, w = image.shape\n    if h == 0:\n        return 0.0\n    top_half = np.sum(image[:h//2, :])\n    bottom_half = np.sum(image[h//2:, :])\n    if bottom_half == 0:\n        return float('inf') if top_half > 0 else 0.0\n    return float(top_half / bottom_half)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of maximum pixel intensity in top-right quadrant to overall maximum\"\n    h, w = image.shape\n    top_right = image[:h//2, w//2:] if h > 1 and w > 1 else image\n    tr_max = np.max(top_right) if top_right.size > 0 else 0\n    overall_max = np.max(image)\n    if overall_max == 0:\n        return 0.0\n    return float(tr_max / overall_max)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of pixels in top half versus bottom half of image\"\n    h, w = image.shape\n    if h == 0:\n        return 0.0\n    top_half = np.sum(image[:h//2, :])\n    bottom_half = np.sum(image[h//2:, :])\n    if bottom_half == 0:\n        return float('inf') if top_half > 0 else 0.0\n    return float(top_half / bottom_half)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of pixels in top half versus bottom half of image\"\n    h, w = image.shape\n    if h == 0:\n        return 0.0\n    top_half = np.sum(image[:h//2, :])\n    bottom_half = np.sum(image[h//2:, :])\n    if bottom_half == 0:\n        return float('inf') if top_half > 0 else 0.0\n    return float(top_half / bottom_half)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of vertical edge strength to horizontal edge strength\"\n    if image.size == 0:\n        return 0.0\n    grad_y, grad_x = np.gradient(image)\n    vertical_strength = np.sum(np.abs(grad_x))\n    horizontal_strength = np.sum(np.abs(grad_y))\n    if horizontal_strength == 0:\n        return 1.0 if vertical_strength > 0 else 0.0\n    return float(vertical_strength / horizontal_strength)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Curvature measure based on direction changes in the brightest path\"\n    h, w = image.shape\n    if h < 3 or w < 3:\n        return 0.0\n    grad_y, grad_x = np.gradient(image)\n    angles = np.arctan2(grad_y, grad_x)\n    diff = np.diff(angles.flatten())\n    diff = np.abs(np.arctan2(np.sin(diff), np.cos(diff)))\n    return float(np.sum(diff > np.pi/4) / len(diff))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of non-zero pixels in the bottom third to middle third of the image\"\n    h, w = image.shape\n    bottom_third = image[2*h//3:h, :]\n    middle_third = image[h//3:2*h//3, :]\n    bottom_count = np.count_nonzero(bottom_third)\n    middle_count = np.count_nonzero(middle_third)\n    if middle_count == 0:\n        return 0.0\n    return float(bottom_count / middle_count)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of pixels in top half versus bottom half of image\"\n    h, w = image.shape\n    if h == 0:\n        return 0.0\n    top_half = np.sum(image[:h//2, :])\n    bottom_half = np.sum(image[h//2:, :])\n    if bottom_half == 0:\n        return float('inf') if top_half > 0 else 0.0\n    return float(top_half / bottom_half)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of pixels in top half versus bottom half of image\"\n    h, w = image.shape\n    if h == 0:\n        return 0.0\n    top_half = np.sum(image[:h//2, :])\n    bottom_half = np.sum(image[h//2:, :])\n    if bottom_half == 0:\n        return float('inf') if top_half > 0 else 0.0\n    return float(top_half / bottom_half)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of maximum to minimum row-wise pixel counts for non-empty rows\"\n    h, w = image.shape\n    row_counts = []\n    for row in range(h):\n        count = np.count_nonzero(image[row, :])\n        if count > 0:\n            row_counts.append(count)\n    if len(row_counts) == 0:\n        return 1.0\n    min_count = min(row_counts)\n    max_count = max(row_counts)\n    if min_count == 0:\n        return float(max_count)\n    return float(max_count) / min_count\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of pixel intensity in center region versus outer border region\"\n    h, w = image.shape\n    center = image[h//4:3*h//4, w//4:3*w//4]\n    border = np.concatenate([\n        image[:h//4, :].flatten(),\n        image[3*h//4:, :].flatten(),\n        image[h//4:3*h//4, :w//4].flatten(),\n        image[h//4:3*h//4, 3*w//4:].flatten()\n    ])\n    center_mean = np.mean(center)\n    border_mean = np.mean(border)\n    if border_mean == 0:\n        return 1.0 if center_mean > 0 else 0.0\n    return float(center_mean / border_mean)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Average pixel intensity difference between adjacent rows in the middle third\"\n    h, w = image.shape\n    if h < 3:\n        return 0.0\n    middle_third = image[h//3:2*h//3, :]\n    if middle_third.shape[0] < 2:\n        return 0.0\n    row_means = np.mean(middle_third, axis=1)\n    diffs = np.abs(np.diff(row_means))\n    return float(np.mean(diffs)) if len(diffs) > 0 else 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Horizontal gradient magnitude in the middle row\"\n    h, w = image.shape\n    if h == 0 or w < 2:\n        return 0.0\n    middle_row = image[h//2, :]\n    gradient = np.gradient(middle_row)\n    return float(np.mean(np.abs(gradient)))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of pixels in top half versus bottom half of image\"\n    h, w = image.shape\n    if h == 0:\n        return 0.0\n    top_half = np.sum(image[:h//2, :])\n    bottom_half = np.sum(image[h//2:, :])\n    if bottom_half == 0:\n        return float('inf') if top_half > 0 else 0.0\n    return float(top_half / bottom_half)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of pixels in top half versus bottom half of image\"\n    h, w = image.shape\n    if h == 0:\n        return 0.0\n    top_half = np.sum(image[:h//2, :])\n    bottom_half = np.sum(image[h//2:, :])\n    if bottom_half == 0:\n        return float('inf') if top_half > 0 else 0.0\n    return float(top_half / bottom_half)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Horizontal gradient strength in the middle third of image\"\n    h, w = image.shape\n    middle_third = image[h//3:2*h//3, :]\n    grad_y, grad_x = np.gradient(middle_third)\n    return float(np.mean(np.abs(grad_x)))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Average distance of non-zero pixels from the vertical center line\"\n    h, w = image.shape\n    center_col = w // 2\n    distances = []\n    for row in range(h):\n        for col in range(w):\n            if image[row, col] > 0:\n                distances.append(abs(col - center_col))\n    return float(np.mean(distances) if distances else 0)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of pixel intensity variance in top third versus middle third\"\n    h, w = image.shape\n    top_third = image[:h//3, :]\n    middle_third = image[h//3:2*h//3, :]\n    top_var = np.var(top_third)\n    middle_var = np.var(middle_third)\n    if middle_var == 0:\n        return float(top_var)\n    return float(top_var / middle_var)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of pixels in top half versus bottom half of image\"\n    h, w = image.shape\n    if h == 0:\n        return 0.0\n    top_half = np.sum(image[:h//2, :])\n    bottom_half = np.sum(image[h//2:, :])\n    if bottom_half == 0:\n        return float('inf') if top_half > 0 else 0.0\n    return float(top_half / bottom_half)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Number of horizontal line segments in the middle region\"\n    h, w = image.shape\n    middle_region = image[h//3:2*h//3, :]\n    threshold = np.mean(middle_region) if np.mean(middle_region) > 0 else 0.1\n    binary = (middle_region > threshold).astype(int)\n    horizontal_lines = 0\n    for row in binary:\n        in_segment = False\n        for pixel in row:\n            if pixel > 0 and not in_segment:\n                horizontal_lines += 1\n                in_segment = True\n            elif pixel == 0:\n                in_segment = False\n    return float(horizontal_lines)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Curvature measure based on direction changes along the outer contour\"\n    h, w = image.shape\n    binary = (image > 0).astype(int)\n    direction_changes = 0\n    for i in range(1, h-1):\n        for j in range(1, w-1):\n            if binary[i, j] > 0:\n                neighbors = binary[i-1:i+2, j-1:j+2]\n                if np.sum(neighbors) < 6:  # On edge/contour\n                    gradient_x = np.sum(neighbors * np.array([[-1, 0, 1], [-1, 0, 1], [-1, 0, 1]]))\n                    gradient_y = np.sum(neighbors * np.array([[-1, -1, -1], [0, 0, 0], [1, 1, 1]]))\n                    if abs(gradient_x) + abs(gradient_y) > 2:\n                        direction_changes += 1\n    return float(direction_changes)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of pixels in top half versus bottom half of image\"\n    h, w = image.shape\n    if h == 0:\n        return 0.0\n    top_half = np.sum(image[:h//2, :])\n    bottom_half = np.sum(image[h//2:, :])\n    if bottom_half == 0:\n        return float('inf') if top_half > 0 else 0.0\n    return float(top_half / bottom_half)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of pixels in top half versus bottom half of image\"\n    h, w = image.shape\n    if h == 0:\n        return 0.0\n    top_half = np.sum(image[:h//2, :])\n    bottom_half = np.sum(image[h//2:, :])\n    if bottom_half == 0:\n        return float('inf') if top_half > 0 else 0.0\n    return float(top_half / bottom_half)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Maximum horizontal gap within active pixel rows in the upper half\"\n    h, w = image.shape\n    max_gap = 0\n    for row in range(h // 2):\n        row_pixels = image[row, :]\n        nonzero_cols = np.where(row_pixels > 0)[0]\n        if len(nonzero_cols) > 1:\n            gaps = np.diff(nonzero_cols)\n            if len(gaps) > 0:\n                max_gap = max(max_gap, np.max(gaps))\n    return float(max_gap)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Density of non-zero pixels in the middle horizontal band\"\n    h, w = image.shape\n    middle_band = image[h//3:2*h//3, :]\n    total_pixels = middle_band.size\n    if total_pixels == 0:\n        return 0.0\n    return float(np.count_nonzero(middle_band) / total_pixels)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Intensity concentration in the center 3x3 region relative to total\"\n    h, w = image.shape\n    if h < 3 or w < 3:\n        return 0.0\n    center_h, center_w = h//2, w//2\n    center_3x3 = image[center_h-1:center_h+2, center_w-1:center_w+2]\n    center_sum = np.sum(center_3x3)\n    total_sum = np.sum(image)\n    if total_sum == 0:\n        return 0.0\n    return float(center_sum / total_sum)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Average row position of pixels in the leftmost quarter weighted by intensity\"\n    h, w = image.shape\n    left_quarter = image[:, :w//4]\n    total_weight = 0\n    weighted_sum = 0\n    for row in range(h):\n        for col in range(min(w//4, w)):\n            if left_quarter[row, col] > 0:\n                total_weight += left_quarter[row, col]\n                weighted_sum += row * left_quarter[row, col]\n    if total_weight == 0:\n        return float(h / 2)\n    return float(weighted_sum / total_weight / h)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of pixel intensity variance in left third versus right third\"\n    h, w = image.shape\n    left_third = image[:, :w//3]\n    right_third = image[:, 2*w//3:]\n    left_var = np.var(left_third)\n    right_var = np.var(right_third)\n    if right_var == 0:\n        return 1.0 if left_var > 0 else 0.0\n    return float(left_var / right_var)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Curvature measure based on direction changes in the upper portion\"\n    h, w = image.shape\n    if h < 4 or w < 4:\n        return 0.0\n    upper_half = image[:h//2, :]\n    grad_y, grad_x = np.gradient(upper_half)\n    angles = np.arctan2(grad_y, grad_x)\n    angle_changes = np.abs(np.diff(angles.flatten()))\n    angle_changes = angle_changes[angle_changes > 0.1]\n    return float(np.sum(angle_changes))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of pixels in top half versus bottom half of image\"\n    h, w = image.shape\n    if h == 0:\n        return 0.0\n    top_half = np.sum(image[:h//2, :])\n    bottom_half = np.sum(image[h//2:, :])\n    if bottom_half == 0:\n        return float('inf') if top_half > 0 else 0.0\n    return float(top_half / bottom_half)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of pixels in top half versus bottom half of image\"\n    h, w = image.shape\n    if h == 0:\n        return 0.0\n    top_half = np.sum(image[:h//2, :])\n    bottom_half = np.sum(image[h//2:, :])\n    if bottom_half == 0:\n        return float('inf') if top_half > 0 else 0.0\n    return float(top_half / bottom_half)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Maximum consecutive vertical pixels in the rightmost third\"\n    h, w = image.shape\n    if w < 3:\n        return 0.0\n    right_third = image[:, 2*w//3:]\n    max_consecutive = 0\n    threshold = np.mean(image) * 0.5\n    for col in range(right_third.shape[1]):\n        consecutive = 0\n        current_max = 0\n        for row in range(h):\n            if right_third[row, col] > threshold:\n                consecutive += 1\n                current_max = max(current_max, consecutive)\n            else:\n                consecutive = 0\n        max_consecutive = max(max_consecutive, current_max)\n    return float(max_consecutive)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Maximum vertical stroke thickness in the leftmost third of image\"\n    h, w = image.shape\n    if w < 3:\n        return 0.0\n    left_region = image[:, :w//3]\n    threshold = np.mean(left_region) if left_region.size > 0 else 0\n    binary = (left_region > threshold).astype(int)\n    max_thickness = 0\n    for j in range(binary.shape[1]):\n        current_thickness = 0\n        for i in range(binary.shape[0]):\n            if binary[i, j] > 0:\n                current_thickness += 1\n            else:\n                max_thickness = max(max_thickness, current_thickness)\n                current_thickness = 0\n        max_thickness = max(max_thickness, current_thickness)\n    return float(max_thickness)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of pixels in top half versus bottom half of image\"\n    h, w = image.shape\n    if h == 0:\n        return 0.0\n    top_half = np.sum(image[:h//2, :])\n    bottom_half = np.sum(image[h//2:, :])\n    if bottom_half == 0:\n        return float('inf') if top_half > 0 else 0.0\n    return float(top_half / bottom_half)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Diagonal edge strength from top-left to bottom-right\"\n    h, w = image.shape\n    diagonal_sum = 0.0\n    count = 0\n    for i in range(min(h-1, w-1)):\n        if i+1 < h and i+1 < w:\n            diagonal_sum += abs(float(image[i+1, i+1]) - float(image[i, i]))\n            count += 1\n    return float(diagonal_sum / count) if count > 0 else 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of pixels in top half versus bottom half of image\"\n    h, w = image.shape\n    if h == 0:\n        return 0.0\n    top_half = np.sum(image[:h//2, :])\n    bottom_half = np.sum(image[h//2:, :])\n    if bottom_half == 0:\n        return float('inf') if top_half > 0 else 0.0\n    return float(top_half / bottom_half)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Vertical position where maximum horizontal width occurs\"\n    h, w = image.shape\n    if h == 0:\n        return 0.5\n    \n    max_width = 0\n    max_width_row = h // 2\n    \n    for i in range(h):\n        row = image[i, :]\n        nonzero_cols = np.where(row > 0)[0]\n        if len(nonzero_cols) > 1:\n            width = nonzero_cols[-1] - nonzero_cols[0] + 1\n            if width > max_width:\n                max_width = width\n                max_width_row = i\n    \n    return float(max_width_row / h)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Intensity difference between center pixel and image mean\"\n    h, w = image.shape\n    if h == 0 or w == 0:\n        return 0.0\n    center_pixel = image[h//2, w//2]\n    image_mean = np.mean(image)\n    return float(abs(center_pixel - image_mean))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of pixels in top half versus bottom half of image\"\n    h, w = image.shape\n    if h == 0:\n        return 0.0\n    top_half = np.sum(image[:h//2, :])\n    bottom_half = np.sum(image[h//2:, :])\n    if bottom_half == 0:\n        return float('inf') if top_half > 0 else 0.0\n    return float(top_half / bottom_half)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of pixels in top half versus bottom half of image\"\n    h, w = image.shape\n    if h == 0:\n        return 0.0\n    top_half = np.sum(image[:h//2, :])\n    bottom_half = np.sum(image[h//2:, :])\n    if bottom_half == 0:\n        return float('inf') if top_half > 0 else 0.0\n    return float(top_half / bottom_half)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of pixels in top half versus bottom half of image\"\n    h, w = image.shape\n    if h == 0:\n        return 0.0\n    top_half = np.sum(image[:h//2, :])\n    bottom_half = np.sum(image[h//2:, :])\n    if bottom_half == 0:\n        return float('inf') if top_half > 0 else 0.0\n    return float(top_half / bottom_half)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of non-zero pixels in top-right to bottom-left corners\"\n    h, w = image.shape\n    corner_size = min(h//4, w//4)\n    if corner_size == 0:\n        return 1.0\n    top_right = image[0:corner_size, -corner_size:]\n    bottom_left = image[-corner_size:, 0:corner_size]\n    tr_count = np.count_nonzero(top_right)\n    bl_count = np.count_nonzero(bottom_left)\n    if bl_count == 0:\n        return float(tr_count)\n    return float(tr_count / bl_count)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Presence of a curved bottom section connecting left and right sides\"\n    h, w = image.shape\n    bottom_quarter = image[3*h//4:, :]\n    curve_score = 0\n    for i, row in enumerate(bottom_quarter):\n        nonzero_indices = np.where(row > 0)[0]\n        if len(nonzero_indices) > w//4:  # Substantial horizontal presence\n            # Weight rows closer to bottom more heavily\n            weight = (i + 1) / len(bottom_quarter)\n            curve_score += weight * len(nonzero_indices) / w\n    return float(curve_score)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of pixels in top half versus bottom half of image\"\n    h, w = image.shape\n    if h == 0:\n        return 0.0\n    top_half = np.sum(image[:h//2, :])\n    bottom_half = np.sum(image[h//2:, :])\n    if bottom_half == 0:\n        return float('inf') if top_half > 0 else 0.0\n    return float(top_half / bottom_half)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of vertical line segments in the left half versus right half of the image\"\n    h, w = image.shape\n    left_half = image[:, :w//2]\n    right_half = image[:, w//2:]\n    \n    left_vertical = 0\n    right_vertical = 0\n    \n    for col in range(left_half.shape[1]):\n        for row in range(1, left_half.shape[0] - 1):\n            if left_half[row, col] > 0 and left_half[row-1, col] > 0 and left_half[row+1, col] > 0:\n                left_vertical += 1\n                \n    for col in range(right_half.shape[1]):\n        for row in range(1, right_half.shape[0] - 1):\n            if right_half[row, col] > 0 and right_half[row-1, col] > 0 and right_half[row+1, col] > 0:\n                right_vertical += 1\n    \n    if right_vertical == 0:\n        return 0.0\n    return float(left_vertical / (right_vertical + 1e-10))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of pixels above mean intensity in top half versus bottom half\"\n    h, w = image.shape\n    if h < 2:\n        return 1.0\n    mean_intensity = np.mean(image)\n    top_half = image[:h//2, :]\n    bottom_half = image[h//2:, :]\n    top_above_mean = np.count_nonzero(top_half > mean_intensity)\n    bottom_above_mean = np.count_nonzero(bottom_half > mean_intensity)\n    if bottom_above_mean == 0:\n        return float('inf') if top_above_mean > 0 else 1.0\n    return float(top_above_mean) / float(bottom_above_mean)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Vertical symmetry score - correlation between left and right halves\"\n    h, w = image.shape\n    if w < 2:\n        return 0.0\n    left_half = image[:, :w//2]\n    right_half = np.fliplr(image[:, w//2:])\n    min_width = min(left_half.shape[1], right_half.shape[1])\n    left_resized = left_half[:, :min_width].flatten()\n    right_resized = right_half[:, :min_width].flatten()\n    if len(left_resized) == 0 or np.std(left_resized) == 0 or np.std(right_resized) == 0:\n        return 0.0\n    correlation = np.corrcoef(left_resized, right_resized)[0, 1]\n    return float(correlation if not np.isnan(correlation) else 0.0)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of pixels in top half versus bottom half of image\"\n    h, w = image.shape\n    if h == 0:\n        return 0.0\n    top_half = np.sum(image[:h//2, :])\n    bottom_half = np.sum(image[h//2:, :])\n    if bottom_half == 0:\n        return float('inf') if top_half > 0 else 0.0\n    return float(top_half / bottom_half)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Presence of closed loop structure based on center region hollowness\"\n    h, w = image.shape\n    center_h, center_w = h//3, w//3\n    center_region = image[center_h:2*center_h, center_w:2*center_w]\n    if center_region.size == 0:\n        return 0.0\n    center_mean = np.mean(center_region)\n    border_pixels = np.concatenate([\n        center_region[0, :], center_region[-1, :],\n        center_region[:, 0], center_region[:, -1]\n    ])\n    border_mean = np.mean(border_pixels) if border_pixels.size > 0 else 0.0\n    return float(border_mean - center_mean)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Average intensity difference between adjacent vertical pixels in center region\"\n    h, w = image.shape\n    if h < 3 or w < 3:\n        return 0.0\n    center_region = image[h//4:3*h//4, w//4:3*w//4]\n    if center_region.shape[0] < 2:\n        return 0.0\n    vertical_diffs = np.abs(np.diff(center_region, axis=0))\n    return float(np.mean(vertical_diffs))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Standard deviation of pixel intensities in the center column\"\n    h, w = image.shape\n    center_col = image[:, w//2]\n    if center_col.size == 0:\n        return 0.0\n    return float(np.std(center_col))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of pixels in top half versus bottom half of image\"\n    h, w = image.shape\n    if h == 0:\n        return 0.0\n    top_half = np.sum(image[:h//2, :])\n    bottom_half = np.sum(image[h//2:, :])\n    if bottom_half == 0:\n        return float('inf') if top_half > 0 else 0.0\n    return float(top_half / bottom_half)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Density of pixels in a small central circular region\"\n    h, w = image.shape\n    center_y, center_x = h // 2, w // 2\n    radius = min(h, w) // 6\n    y, x = np.ogrid[:h, :w]\n    mask = (y - center_y)**2 + (x - center_x)**2 <= radius**2\n    if np.sum(mask) == 0:\n        return 0.0\n    return float(np.sum(image[mask] > 0) / np.sum(mask))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of pixels in top half versus bottom half of image\"\n    h, w = image.shape\n    if h == 0:\n        return 0.0\n    top_half = np.sum(image[:h//2, :])\n    bottom_half = np.sum(image[h//2:, :])\n    if bottom_half == 0:\n        return float('inf') if top_half > 0 else 0.0\n    return float(top_half / bottom_half)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Average horizontal gradient magnitude in the center region\"\n    h, w = image.shape\n    center_region = image[h//4:3*h//4, w//4:3*w//4]\n    if center_region.shape[1] < 2:\n        return 0.0\n    grad_x = np.gradient(center_region, axis=1)\n    return float(np.mean(np.abs(grad_x)))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Standard deviation of pixel intensities in the leftmost third\"\n    h, w = image.shape\n    left_third = image[:, :w//3]\n    return float(np.std(left_third)) if left_third.size > 0 else 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Standard deviation of row-wise pixel counts in the top half\"\n    h, w = image.shape\n    top_half = image[:h//2, :]\n    if top_half.size == 0:\n        return 0.0\n    row_counts = [np.count_nonzero(row) for row in top_half]\n    return float(np.std(row_counts))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of diagonal stroke intensity to horizontal/vertical strokes\"\n    if image.size == 0:\n        return 0.0\n    grad_y, grad_x = np.gradient(image)\n    diag_strength = np.mean(np.abs(grad_x - grad_y)) + np.mean(np.abs(grad_x + grad_y))\n    ortho_strength = np.mean(np.abs(grad_x)) + np.mean(np.abs(grad_y))\n    return float(diag_strength / (ortho_strength + 1e-6))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of non-zero pixels in the leftmost quarter versus rightmost quarter\"\n    h, w = image.shape\n    left_quarter = image[:, :w//4]\n    right_quarter = image[:, 3*w//4:]\n    left_pixels = np.count_nonzero(left_quarter)\n    right_pixels = np.count_nonzero(right_quarter)\n    if right_pixels == 0:\n        return float(left_pixels)\n    return float(left_pixels / right_pixels)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Width of the central horizontal opening or gap in the image\"\n    h, w = image.shape\n    middle_row = h // 2\n    row_slice = image[middle_row, :]\n    zero_regions = np.diff(np.concatenate(([1], (row_slice == 0).astype(int), [1])))\n    starts = np.where(zero_regions == 1)[0]\n    ends = np.where(zero_regions == -1)[0]\n    if len(starts) > 0 and len(ends) > 0:\n        return float(np.max(ends - starts))\n    return 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of non-zero pixels in top-right quadrant to total non-zero pixels\"\n    h, w = image.shape\n    top_right = image[:h//2, w//2:]\n    total_nonzero = np.count_nonzero(image)\n    tr_nonzero = np.count_nonzero(top_right)\n    if total_nonzero == 0:\n        return 0.0\n    return float(tr_nonzero / total_nonzero)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Horizontal center of mass of non-zero pixels\"\n    h, w = image.shape\n    y_coords, x_coords = np.where(image > 0)\n    if len(x_coords) == 0:\n        return 0.0\n    weights = image[y_coords, x_coords]\n    center_of_mass = np.sum(x_coords * weights) / np.sum(weights)\n    return float(center_of_mass / w)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of maximum width in top half versus bottom half\"\n    h, w = image.shape\n    if h == 0:\n        return 1.0\n    top_half = image[:h//2, :]\n    bottom_half = image[h//2:, :]\n    \n    top_widths = [np.sum(row > 0) for row in top_half]\n    bottom_widths = [np.sum(row > 0) for row in bottom_half]\n    \n    max_top = max(top_widths) if top_widths else 0\n    max_bottom = max(bottom_widths) if bottom_widths else 0\n    \n    if max_bottom == 0:\n        return float(max_top > 0)\n    return float(max_top / max_bottom)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of maximum width in top half versus bottom half\"\n    h, w = image.shape\n    if h == 0:\n        return 1.0\n    top_half = image[:h//2, :]\n    bottom_half = image[h//2:, :]\n    \n    top_widths = [np.sum(row > 0) for row in top_half]\n    bottom_widths = [np.sum(row > 0) for row in bottom_half]\n    \n    max_top = max(top_widths) if top_widths else 0\n    max_bottom = max(bottom_widths) if bottom_widths else 0\n    \n    if max_bottom == 0:\n        return float(max_top > 0)\n    return float(max_top / max_bottom)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of pixels in top half versus bottom half of image\"\n    h, w = image.shape\n    if h == 0:\n        return 0.0\n    top_half = np.sum(image[:h//2, :])\n    bottom_half = np.sum(image[h//2:, :])\n    if bottom_half == 0:\n        return float('inf') if top_half > 0 else 0.0\n    return float(top_half / bottom_half)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of pixels above median intensity in top half versus bottom half\"\n    h, w = image.shape\n    median_val = np.median(image)\n    top_half = image[:h//2, :]\n    bottom_half = image[h//2:, :]\n    top_above_median = np.count_nonzero(top_half > median_val)\n    bottom_above_median = np.count_nonzero(bottom_half > median_val)\n    return float(top_above_median / max(bottom_above_median, 1))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of pixels in top half versus bottom half of image\"\n    h, w = image.shape\n    if h == 0:\n        return 0.0\n    top_half = np.sum(image[:h//2, :])\n    bottom_half = np.sum(image[h//2:, :])\n    if bottom_half == 0:\n        return float('inf') if top_half > 0 else 0.0\n    return float(top_half / bottom_half)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of pixels in top half versus bottom half of image\"\n    h, w = image.shape\n    if h == 0:\n        return 0.0\n    top_half = np.sum(image[:h//2, :])\n    bottom_half = np.sum(image[h//2:, :])\n    if bottom_half == 0:\n        return float('inf') if top_half > 0 else 0.0\n    return float(top_half / bottom_half)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Number of vertical transitions from background to foreground in center column\"\n    h, w = image.shape\n    center_col = image[:, w//2]\n    threshold = np.mean(image) * 0.5\n    binary = (center_col > threshold).astype(int)\n    transitions = np.sum(np.diff(binary) > 0)\n    return float(transitions)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of pixels in top half versus bottom half of image\"\n    h, w = image.shape\n    if h == 0:\n        return 0.0\n    top_half = np.sum(image[:h//2, :])\n    bottom_half = np.sum(image[h//2:, :])\n    if bottom_half == 0:\n        return float('inf') if top_half > 0 else 0.0\n    return float(top_half / bottom_half)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of pixel intensity in center region versus outer border region\"\n    h, w = image.shape\n    center = image[h//4:3*h//4, w//4:3*w//4]\n    border = np.concatenate([\n        image[:h//4, :].flatten(),\n        image[3*h//4:, :].flatten(),\n        image[h//4:3*h//4, :w//4].flatten(),\n        image[h//4:3*h//4, 3*w//4:].flatten()\n    ])\n    center_mean = np.mean(center)\n    border_mean = np.mean(border)\n    if border_mean == 0:\n        return 1.0 if center_mean > 0 else 0.0\n    return float(center_mean / border_mean)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Maximum consecutive vertical pixels in the bottom quarter\"\n    h, w = image.shape\n    bottom_quarter = image[3*h//4:, :]\n    if bottom_quarter.size == 0:\n        return 0.0\n    max_consecutive = 0\n    for col in range(w):\n        consecutive = 0\n        current_max = 0\n        for row in range(bottom_quarter.shape[0]):\n            if bottom_quarter[row, col] > 0:\n                consecutive += 1\n                current_max = max(current_max, consecutive)\n            else:\n                consecutive = 0\n        max_consecutive = max(max_consecutive, current_max)\n    return float(max_consecutive)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Horizontal extent ratio of rightmost to leftmost significant pixels\"\n    h, w = image.shape\n    nonzero_positions = np.where(image > 0)\n    if len(nonzero_positions[1]) == 0:\n        return 1.0\n    leftmost = np.min(nonzero_positions[1])\n    rightmost = np.max(nonzero_positions[1])\n    left_extent = leftmost + 1\n    right_extent = w - rightmost\n    if left_extent == 0:\n        return float('inf') if right_extent > 0 else 1.0\n    return float(right_extent / left_extent)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of pixels in top half versus bottom half of image\"\n    h, w = image.shape\n    if h == 0:\n        return 0.0\n    top_half = np.sum(image[:h//2, :])\n    bottom_half = np.sum(image[h//2:, :])\n    if bottom_half == 0:\n        return float('inf') if top_half > 0 else 0.0\n    return float(top_half / bottom_half)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Average intensity in the bottom quarter of the image\"\n    h, w = image.shape\n    bottom_quarter = image[3*h//4:, :]\n    return float(np.mean(bottom_quarter))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of pixels in top half versus bottom half of image\"\n    h, w = image.shape\n    if h == 0:\n        return 0.0\n    top_half = np.sum(image[:h//2, :])\n    bottom_half = np.sum(image[h//2:, :])\n    if bottom_half == 0:\n        return float('inf') if top_half > 0 else 0.0\n    return float(top_half / bottom_half)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of mean intensity in center column versus center row\"\n    h, w = image.shape\n    center_col = image[:, w//2]\n    center_row = image[h//2, :]\n    col_mean = np.mean(center_col)\n    row_mean = np.mean(center_row)\n    if row_mean == 0:\n        return float(col_mean)\n    return float(col_mean / row_mean)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Average intensity difference between consecutive rows in the middle columns\"\n    h, w = image.shape\n    if h < 2 or w < 3:\n        return 0.0\n    middle_cols = image[:, w//3:2*w//3]\n    row_means = np.mean(middle_cols, axis=1)\n    if len(row_means) < 2:\n        return 0.0\n    differences = np.abs(np.diff(row_means))\n    return float(np.mean(differences))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of pixels in top half versus bottom half of image\"\n    h, w = image.shape\n    if h == 0:\n        return 0.0\n    top_half = np.sum(image[:h//2, :])\n    bottom_half = np.sum(image[h//2:, :])\n    if bottom_half == 0:\n        return float('inf') if top_half > 0 else 0.0\n    return float(top_half / bottom_half)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of pixels in top half versus bottom half of image\"\n    h, w = image.shape\n    if h == 0:\n        return 0.0\n    top_half = np.sum(image[:h//2, :])\n    bottom_half = np.sum(image[h//2:, :])\n    if bottom_half == 0:\n        return float('inf') if top_half > 0 else 0.0\n    return float(top_half / bottom_half)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Standard deviation of pixel intensities in the rightmost quarter\"\n    h, w = image.shape\n    right_quarter = image[:, 3*w//4:]\n    if right_quarter.size == 0:\n        return 0.0\n    return float(np.std(right_quarter))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of pixels in top half versus bottom half of image\"\n    h, w = image.shape\n    if h == 0:\n        return 0.0\n    top_half = np.sum(image[:h//2, :])\n    bottom_half = np.sum(image[h//2:, :])\n    if bottom_half == 0:\n        return float('inf') if top_half > 0 else 0.0\n    return float(top_half / bottom_half)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of pixels in top half versus bottom half of image\"\n    h, w = image.shape\n    if h == 0:\n        return 0.0\n    top_half = np.sum(image[:h//2, :])\n    bottom_half = np.sum(image[h//2:, :])\n    if bottom_half == 0:\n        return float('inf') if top_half > 0 else 0.0\n    return float(top_half / bottom_half)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of pixels in top half versus bottom half of image\"\n    h, w = image.shape\n    if h == 0:\n        return 0.0\n    top_half = np.sum(image[:h//2, :])\n    bottom_half = np.sum(image[h//2:, :])\n    if bottom_half == 0:\n        return float('inf') if top_half > 0 else 0.0\n    return float(top_half / bottom_half)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of pixels in top half versus bottom half of image\"\n    h, w = image.shape\n    if h == 0:\n        return 0.0\n    top_half = np.sum(image[:h//2, :])\n    bottom_half = np.sum(image[h//2:, :])\n    if bottom_half == 0:\n        return float('inf') if top_half > 0 else 0.0\n    return float(top_half / bottom_half)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of non-zero pixels in bottom-right quadrant to total non-zero pixels\"\n    h, w = image.shape\n    bottom_right = image[h//2:, w//2:]\n    total_nonzero = np.count_nonzero(image)\n    if total_nonzero == 0:\n        return 0.0\n    br_nonzero = np.count_nonzero(bottom_right)\n    return float(br_nonzero / total_nonzero)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Asymmetry between upper-left and lower-right diagonal regions\"\n    h, w = image.shape\n    upper_left = np.sum([image[i, j] for i in range(h) for j in range(w) if i + j < min(h, w)])\n    lower_right = np.sum([image[i, j] for i in range(h) for j in range(w) if i + j >= max(h, w)])\n    total = upper_left + lower_right\n    if total == 0:\n        return 0.5\n    return float(upper_left / total)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of pixels in top half versus bottom half of image\"\n    h, w = image.shape\n    if h == 0:\n        return 0.0\n    top_half = np.sum(image[:h//2, :])\n    bottom_half = np.sum(image[h//2:, :])\n    if bottom_half == 0:\n        return float('inf') if top_half > 0 else 0.0\n    return float(top_half / bottom_half)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of pixels in top half versus bottom half of image\"\n    h, w = image.shape\n    if h == 0:\n        return 0.0\n    top_half = np.sum(image[:h//2, :])\n    bottom_half = np.sum(image[h//2:, :])\n    if bottom_half == 0:\n        return float('inf') if top_half > 0 else 0.0\n    return float(top_half / bottom_half)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of pixels in top half versus bottom half of image\"\n    h, w = image.shape\n    if h == 0:\n        return 0.0\n    top_half = np.sum(image[:h//2, :])\n    bottom_half = np.sum(image[h//2:, :])\n    if bottom_half == 0:\n        return float('inf') if top_half > 0 else 0.0\n    return float(top_half / bottom_half)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of pixels in top half versus bottom half of image\"\n    h, w = image.shape\n    if h == 0:\n        return 0.0\n    top_half = np.sum(image[:h//2, :])\n    bottom_half = np.sum(image[h//2:, :])\n    if bottom_half == 0:\n        return float('inf') if top_half > 0 else 0.0\n    return float(top_half / bottom_half)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of pixels in top half versus bottom half of image\"\n    h, w = image.shape\n    if h == 0:\n        return 0.0\n    top_half = np.sum(image[:h//2, :])\n    bottom_half = np.sum(image[h//2:, :])\n    if bottom_half == 0:\n        return float('inf') if top_half > 0 else 0.0\n    return float(top_half / bottom_half)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of pixels in top half versus bottom half of image\"\n    h, w = image.shape\n    if h == 0:\n        return 0.0\n    top_half = np.sum(image[:h//2, :])\n    bottom_half = np.sum(image[h//2:, :])\n    if bottom_half == 0:\n        return float('inf') if top_half > 0 else 0.0\n    return float(top_half / bottom_half)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of pixels in top half versus bottom half of image\"\n    h, w = image.shape\n    if h == 0:\n        return 0.0\n    top_half = np.sum(image[:h//2, :])\n    bottom_half = np.sum(image[h//2:, :])\n    if bottom_half == 0:\n        return float('inf') if top_half > 0 else 0.0\n    return float(top_half / bottom_half)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of pixels in top half versus bottom half of image\"\n    h, w = image.shape\n    if h == 0:\n        return 0.0\n    top_half = np.sum(image[:h//2, :])\n    bottom_half = np.sum(image[h//2:, :])\n    if bottom_half == 0:\n        return float('inf') if top_half > 0 else 0.0\n    return float(top_half / bottom_half)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of pixels in top half versus bottom half of image\"\n    h, w = image.shape\n    if h == 0:\n        return 0.0\n    top_half = np.sum(image[:h//2, :])\n    bottom_half = np.sum(image[h//2:, :])\n    if bottom_half == 0:\n        return float('inf') if top_half > 0 else 0.0\n    return float(top_half / bottom_half)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of pixels in top half versus bottom half of image\"\n    h, w = image.shape\n    if h == 0:\n        return 0.0\n    top_half = np.sum(image[:h//2, :])\n    bottom_half = np.sum(image[h//2:, :])\n    if bottom_half == 0:\n        return float('inf') if top_half > 0 else 0.0\n    return float(top_half / bottom_half)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of pixels in top half versus bottom half of image\"\n    h, w = image.shape\n    if h == 0:\n        return 0.0\n    top_half = np.sum(image[:h//2, :])\n    bottom_half = np.sum(image[h//2:, :])\n    if bottom_half == 0:\n        return float('inf') if top_half > 0 else 0.0\n    return float(top_half / bottom_half)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of pixels in top half versus bottom half of image\"\n    h, w = image.shape\n    if h == 0:\n        return 0.0\n    top_half = np.sum(image[:h//2, :])\n    bottom_half = np.sum(image[h//2:, :])\n    if bottom_half == 0:\n        return float('inf') if top_half > 0 else 0.0\n    return float(top_half / bottom_half)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of pixels in top half versus bottom half of image\"\n    h, w = image.shape\n    if h == 0:\n        return 0.0\n    top_half = np.sum(image[:h//2, :])\n    bottom_half = np.sum(image[h//2:, :])\n    if bottom_half == 0:\n        return float('inf') if top_half > 0 else 0.0\n    return float(top_half / bottom_half)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of pixels in top half versus bottom half of image\"\n    h, w = image.shape\n    if h == 0:\n        return 0.0\n    top_half = np.sum(image[:h//2, :])\n    bottom_half = np.sum(image[h//2:, :])\n    if bottom_half == 0:\n        return float('inf') if top_half > 0 else 0.0\n    return float(top_half / bottom_half)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of pixels in top half versus bottom half of image\"\n    h, w = image.shape\n    if h == 0:\n        return 0.0\n    top_half = np.sum(image[:h//2, :])\n    bottom_half = np.sum(image[h//2:, :])\n    if bottom_half == 0:\n        return float('inf') if top_half > 0 else 0.0\n    return float(top_half / bottom_half)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of pixels in top-left quadrant versus bottom-right quadrant\"\n    h, w = image.shape\n    top_left = image[:h//2, :w//2]\n    bottom_right = image[h//2:, w//2:]\n    top_left_count = np.count_nonzero(top_left)\n    bottom_right_count = np.count_nonzero(bottom_right)\n    if bottom_right_count == 0:\n        return float(top_left_count)\n    return float(top_left_count / bottom_right_count)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Standard deviation of pixel intensities in the top-right quadrant\"\n    h, w = image.shape\n    if h == 0 or w == 0:\n        return 0.0\n    top_right = image[:h//2, w//2:]\n    return float(np.std(top_right))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Number of enclosed regions or loops in the image\"\n    from scipy import ndimage\n    if image.size == 0:\n        return 0.0\n    binary = image > np.mean(image)\n    filled = ndimage.binary_fill_holes(binary)\n    loops = np.sum(filled) - np.sum(binary)\n    return float(loops)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of pixels in top half versus bottom half of image\"\n    h, w = image.shape\n    if h == 0:\n        return 0.0\n    top_half = np.sum(image[:h//2, :])\n    bottom_half = np.sum(image[h//2:, :])\n    if bottom_half == 0:\n        return float('inf') if top_half > 0 else 0.0\n    return float(top_half / bottom_half)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of pixels in top-left quadrant versus bottom-right quadrant\"\n    h, w = image.shape\n    top_left = image[:h//2, :w//2]\n    bottom_right = image[h//2:, w//2:]\n    top_left_count = np.count_nonzero(top_left)\n    bottom_right_count = np.count_nonzero(bottom_right)\n    if bottom_right_count == 0:\n        return float(top_left_count)\n    return float(top_left_count / bottom_right_count)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of pixels in top half versus bottom half of image\"\n    h, w = image.shape\n    if h == 0:\n        return 0.0\n    top_half = np.sum(image[:h//2, :])\n    bottom_half = np.sum(image[h//2:, :])\n    if bottom_half == 0:\n        return float('inf') if top_half > 0 else 0.0\n    return float(top_half / bottom_half)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of pixels in top half versus bottom half of image\"\n    h, w = image.shape\n    if h == 0:\n        return 0.0\n    top_half = np.sum(image[:h//2, :])\n    bottom_half = np.sum(image[h//2:, :])\n    if bottom_half == 0:\n        return float('inf') if top_half > 0 else 0.0\n    return float(top_half / bottom_half)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Number of pixels forming curved patterns in the bottom half\"\n    h, w = image.shape\n    bottom_half = image[h//2:, :]\n    threshold = np.mean(bottom_half) + 0.5 * np.std(bottom_half)\n    binary = (bottom_half > threshold).astype(int)\n    curved_pixels = 0\n    for i in range(1, binary.shape[0]-1):\n        for j in range(1, binary.shape[1]-1):\n            if binary[i, j] > 0:\n                neighbors = binary[i-1:i+2, j-1:j+2]\n                if np.sum(neighbors) >= 4 and np.sum(neighbors) <= 6:\n                    curved_pixels += 1\n    return float(curved_pixels)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Number of columns where the bottom half has higher mean intensity than top half\"\n    h, w = image.shape\n    if h < 2:\n        return 0.0\n    count = 0\n    for col in range(w):\n        top_half_mean = np.mean(image[:h//2, col])\n        bottom_half_mean = np.mean(image[h//2:, col])\n        if bottom_half_mean > top_half_mean:\n            count += 1\n    return float(count)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Vertical symmetry score comparing top and bottom halves pixel by pixel\"\n    h, w = image.shape\n    if h < 2:\n        return 1.0\n    top_half = image[:h//2, :]\n    bottom_half = image[h//2:, :]\n    min_h = min(top_half.shape[0], bottom_half.shape[0])\n    top_crop = top_half[:min_h, :]\n    bottom_crop = np.flipud(bottom_half[:min_h, :])\n    diff = np.abs(top_crop - bottom_crop)\n    total_intensity = np.sum(image)\n    if total_intensity == 0:\n        return 1.0\n    return float(1.0 - np.sum(diff) / total_intensity)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Standard deviation of column-wise foreground pixel counts in upper half\"\n    h, w = image.shape\n    upper_half = image[:h//2, :]\n    column_counts = []\n    for col in range(w):\n        count = np.count_nonzero(upper_half[:, col])\n        column_counts.append(count)\n    return float(np.std(column_counts))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of non-zero pixels in bottom quarter to total non-zero pixels\"\n    h, w = image.shape\n    if h == 0 or w == 0:\n        return 0.0\n    bottom_quarter = image[3*h//4:, :]\n    total_nonzero = np.count_nonzero(image)\n    bottom_nonzero = np.count_nonzero(bottom_quarter)\n    if total_nonzero == 0:\n        return 0.0\n    return float(bottom_nonzero / total_nonzero)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Number of horizontal segments in the middle vertical strip\"\n    h, w = image.shape\n    if w < 3:\n        return 0.0\n    middle_col = w // 2\n    strip = image[:, middle_col-1:middle_col+2]\n    mean_strip = np.mean(strip, axis=1)\n    threshold = np.mean(mean_strip) * 0.5\n    binary = (mean_strip > threshold).astype(int)\n    segments = 0\n    in_segment = False\n    for val in binary:\n        if val > 0 and not in_segment:\n            segments += 1\n            in_segment = True\n        elif val == 0:\n            in_segment = False\n    return float(segments)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Skewness measure of horizontal pixel distribution weighted by intensity\"\n    h, w = image.shape\n    total_intensity = np.sum(image)\n    if total_intensity == 0:\n        return 0.0\n    weighted_positions = np.sum(image * np.arange(w).reshape(1, -1))\n    center_of_mass = weighted_positions / total_intensity\n    third_moment = np.sum(image * ((np.arange(w).reshape(1, -1) - center_of_mass) ** 3))\n    return float(third_moment / total_intensity)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of enclosed area to total non-zero pixels\"\n    h, w = image.shape\n    if np.count_nonzero(image) == 0:\n        return 0.0\n    threshold = np.mean(image[image > 0]) * 0.5 if np.count_nonzero(image) > 0 else 1.0\n    binary = (image > threshold).astype(int)\n    enclosed_count = 0\n    for i in range(1, h-1):\n        for j in range(1, w-1):\n            if binary[i, j] == 0 and np.sum(binary[i-1:i+2, j-1:j+2]) >= 6:\n                enclosed_count += 1\n    return float(enclosed_count) / np.count_nonzero(image)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Number of connected vertical segments longer than quarter image height\"\n    h, w = image.shape\n    min_length = h // 4\n    count = 0\n    for col in range(w):\n        column = image[:, col] > 0\n        current_length = 0\n        for pixel in column:\n            if pixel:\n                current_length += 1\n            else:\n                if current_length >= min_length:\n                    count += 1\n                current_length = 0\n        if current_length >= min_length:\n            count += 1\n    return float(count)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Maximum pixel intensity difference between adjacent columns in center region\"\n    h, w = image.shape\n    center_region = image[h//4:3*h//4, w//4:3*w//4]\n    if center_region.shape[1] <= 1:\n        return 0.0\n    col_means = np.mean(center_region, axis=0)\n    if len(col_means) <= 1:\n        return 0.0\n    diffs = np.abs(np.diff(col_means))\n    return float(np.max(diffs))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Curvature measure in the upper portion of the image\"\n    h, w = image.shape\n    upper_region = image[:h//2, :]\n    if upper_region.size == 0:\n        return 0.0\n    grad_y, grad_x = np.gradient(upper_region)\n    curvature = np.abs(grad_x) + np.abs(grad_y)\n    curved_pixels = np.sum(curvature > np.percentile(curvature, 75))\n    return float(curved_pixels) / upper_region.size\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of pixels in top half versus bottom half of image\"\n    h, w = image.shape\n    if h == 0:\n        return 0.0\n    top_half = np.sum(image[:h//2, :])\n    bottom_half = np.sum(image[h//2:, :])\n    if bottom_half == 0:\n        return float('inf') if top_half > 0 else 0.0\n    return float(top_half / bottom_half)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of non-zero pixels in the leftmost quarter versus rightmost quarter\"\n    h, w = image.shape\n    left_quarter = image[:, :w//4]\n    right_quarter = image[:, 3*w//4:]\n    left_pixels = np.count_nonzero(left_quarter)\n    right_pixels = np.count_nonzero(right_quarter)\n    if right_pixels == 0:\n        return float(left_pixels)\n    return float(left_pixels / right_pixels)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Number of rows in bottom half with significant pixel activity\"\n    h, w = image.shape\n    bottom_half = image[h//2:, :]\n    threshold = np.mean(image) if np.mean(image) > 0 else 0.1\n    active_rows = 0\n    for row in bottom_half:\n        if np.sum(row) > threshold * w:\n            active_rows += 1\n    return float(active_rows)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of non-zero pixels in the leftmost quarter versus rightmost quarter\"\n    h, w = image.shape\n    left_quarter = image[:, :w//4]\n    right_quarter = image[:, 3*w//4:]\n    left_pixels = np.count_nonzero(left_quarter)\n    right_pixels = np.count_nonzero(right_quarter)\n    if right_pixels == 0:\n        return float(left_pixels)\n    return float(left_pixels / right_pixels)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Average vertical gradient magnitude in the center column\"\n    h, w = image.shape\n    if w == 0:\n        return 0.0\n    center_col = image[:, w//2]\n    if len(center_col) < 2:\n        return 0.0\n    gradients = np.abs(np.diff(center_col.astype(float)))\n    return float(np.mean(gradients))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Width of the brightest vertical stroke in the upper third of the image\"\n    h, w = image.shape\n    upper_third = image[:h//3, :]\n    if upper_third.size == 0:\n        return 0.0\n    max_width = 0\n    for row in range(upper_third.shape[0]):\n        current_width = 0\n        for col in range(upper_third.shape[1]):\n            if upper_third[row, col] > np.mean(upper_third):\n                current_width += 1\n            else:\n                max_width = max(max_width, current_width)\n                current_width = 0\n        max_width = max(max_width, current_width)\n    return float(max_width)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Intensity gradient magnitude in the upper-left quadrant\"\n    h, w = image.shape\n    quadrant = image[0:h//2, 0:w//2]\n    if quadrant.size == 0:\n        return 0.0\n    grad_y, grad_x = np.gradient(quadrant.astype(float))\n    gradient_magnitude = np.sqrt(grad_y**2 + grad_x**2)\n    return float(np.mean(gradient_magnitude))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Skewness of non-zero pixel distribution in horizontal direction\"\n    h, w = image.shape\n    y_coords, x_coords = np.where(image > 0)\n    if len(x_coords) < 3:\n        return 0.0\n    mean_x = np.mean(x_coords)\n    std_x = np.std(x_coords)\n    if std_x == 0:\n        return 0.0\n    skewness = np.mean(((x_coords - mean_x) / std_x)**3)\n    return float(skewness)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Number of horizontal line segments in middle third of image\"\n    h, w = image.shape\n    if h < 3:\n        return 0.0\n    middle_third = image[h//3:2*h//3, :]\n    horizontal_lines = 0\n    threshold = np.mean(image) * 0.5\n    for row in middle_third:\n        line_pixels = np.sum(row > threshold)\n        if line_pixels > w * 0.6:\n            horizontal_lines += 1\n    return float(horizontal_lines)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of pixels in top half versus bottom half of image\"\n    h, w = image.shape\n    if h == 0:\n        return 0.0\n    top_half = np.sum(image[:h//2, :])\n    bottom_half = np.sum(image[h//2:, :])\n    if bottom_half == 0:\n        return float('inf') if top_half > 0 else 0.0\n    return float(top_half / bottom_half)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of pixel sum in bottom-right quadrant to total pixel sum\"\n    h, w = image.shape\n    if h < 2 or w < 2:\n        return 0.0\n    bottom_right = image[h//2:, w//2:]\n    total_sum = np.sum(image)\n    if total_sum == 0:\n        return 0.0\n    return float(np.sum(bottom_right) / total_sum)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of pixels in top half versus bottom half of image\"\n    h, w = image.shape\n    if h == 0:\n        return 0.0\n    top_half = np.sum(image[:h//2, :])\n    bottom_half = np.sum(image[h//2:, :])\n    if bottom_half == 0:\n        return float('inf') if top_half > 0 else 0.0\n    return float(top_half / bottom_half)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Concentration of mass in the rightmost third of the image\"\n    h, w = image.shape\n    right_third = image[:, 2*w//3:]\n    total_mass = np.sum(image)\n    right_mass = np.sum(right_third)\n    if total_mass == 0:\n        return 0.0\n    return float(right_mass / total_mass)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Horizontal gradient magnitude sum in the middle third\"\n    h, w = image.shape\n    middle_third = image[:, w//3:2*w//3]\n    if middle_third.size == 0:\n        return 0.0\n    grad_x = np.gradient(middle_third, axis=1)\n    return float(np.sum(np.abs(grad_x)))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Compactness of the main connected component measured by perimeter squared over area\"\n    binary = (image > 0).astype(np.uint8)\n    if np.sum(binary) == 0:\n        return 0.0\n    area = np.sum(binary)\n    perimeter = 0\n    h, w = binary.shape\n    for i in range(h):\n        for j in range(w):\n            if binary[i, j]:\n                neighbors = 0\n                for di, dj in [(-1,0), (1,0), (0,-1), (0,1)]:\n                    ni, nj = i + di, j + dj\n                    if 0 <= ni < h and 0 <= nj < w and binary[ni, nj]:\n                        neighbors += 1\n                if neighbors < 4:\n                    perimeter += 1\n    return float(perimeter * perimeter / (area + 1e-8))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of foreground pixels in middle rows to total foreground\"\n    h, w = image.shape\n    threshold = np.mean(image) + 0.5 * np.std(image)\n    total_foreground = np.sum(image > threshold)\n    if total_foreground == 0:\n        return 0.0\n    middle_start = h // 3\n    middle_end = 2 * h // 3\n    middle_foreground = np.sum(image[middle_start:middle_end, :] > threshold)\n    return float(middle_foreground / total_foreground)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Pixel intensity variance in the center 3x3 region\"\n    h, w = image.shape\n    if h < 3 or w < 3:\n        return 0.0\n    center_h, center_w = h // 2, w // 2\n    center_region = image[center_h-1:center_h+2, center_w-1:center_w+2]\n    return float(np.var(center_region))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of left half intensity to right half intensity\"\n    h, w = image.shape\n    left_half = image[:, :w//2]\n    right_half = image[:, w//2:]\n    left_sum = np.sum(left_half)\n    right_sum = np.sum(right_half)\n    if right_sum == 0:\n        return 1.0 if left_sum > 0 else 0.0\n    return float(left_sum / right_sum)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Density of non-zero pixels in the top-right quarter of the image\"\n    h, w = image.shape\n    top_right = image[:h//2, w//2:]\n    total_pixels = top_right.size\n    if total_pixels == 0:\n        return 0.0\n    return float(np.count_nonzero(top_right) / total_pixels)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of curved versus straight edge pixels using gradient direction changes\"\n    grad_y, grad_x = np.gradient(image)\n    magnitude = np.sqrt(grad_x**2 + grad_y**2)\n    edge_threshold = np.percentile(magnitude, 75)\n    edge_mask = magnitude > edge_threshold\n    if np.sum(edge_mask) == 0:\n        return 0.0\n    angles = np.arctan2(grad_y, grad_x)\n    angle_changes = np.abs(np.diff(angles[edge_mask]))\n    curved_pixels = np.sum(angle_changes > np.pi/4)\n    total_edge_pixels = np.sum(edge_mask)\n    return float(curved_pixels / max(total_edge_pixels, 1))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Presence of strong diagonal intensity gradient from top-left to bottom-right\"\n    h, w = image.shape\n    if h < 2 or w < 2:\n        return 0.0\n    diagonal_sum = 0.0\n    count = 0\n    min_dim = min(h, w)\n    for i in range(min_dim):\n        diagonal_sum += image[i, i]\n        count += 1\n    if count == 0:\n        return 0.0\n    diagonal_mean = diagonal_sum / count\n    overall_mean = np.mean(image)\n    if overall_mean == 0:\n        return 0.0\n    return float(diagonal_mean / overall_mean)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Average width of non-zero regions per row in bottom half\"\n    h, w = image.shape\n    bottom_half = image[h//2:, :]\n    total_width = 0\n    valid_rows = 0\n    for row in bottom_half:\n        nonzero_indices = np.where(row > 0)[0]\n        if len(nonzero_indices) > 0:\n            width = nonzero_indices[-1] - nonzero_indices[0] + 1\n            total_width += width\n            valid_rows += 1\n    return float(total_width / valid_rows if valid_rows > 0 else 0)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of pixels in top half versus bottom half of image\"\n    h, w = image.shape\n    if h == 0:\n        return 0.0\n    top_half = np.sum(image[:h//2, :])\n    bottom_half = np.sum(image[h//2:, :])\n    if bottom_half == 0:\n        return float('inf') if top_half > 0 else 0.0\n    return float(top_half / bottom_half)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Presence of closed loops by counting enclosed regions\"\n    if image.size == 0:\n        return 0.0\n    binary = image > np.mean(image)\n    h, w = binary.shape\n    enclosed_count = 0\n    for i in range(1, h-1):\n        for j in range(1, w-1):\n            if not binary[i, j]:\n                surrounding = binary[i-1:i+2, j-1:j+2]\n                if np.sum(surrounding) >= 6:\n                    enclosed_count += 1\n    return float(enclosed_count / max(1, h * w / 100))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Number of vertical line segments in the center column\"\n    h, w = image.shape\n    if w == 0:\n        return 0.0\n    center_col = image[:, w//2]\n    threshold = np.mean(center_col) + np.std(center_col) if np.std(center_col) > 0 else np.mean(center_col)\n    binary_col = (center_col > threshold).astype(int)\n    segments = 0\n    in_segment = False\n    for pixel in binary_col:\n        if pixel == 1 and not in_segment:\n            segments += 1\n            in_segment = True\n        elif pixel == 0:\n            in_segment = False\n    return float(segments)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Maximum consecutive vertical pixels in the center column\"\n    h, w = image.shape\n    if w == 0 or h == 0:\n        return 0.0\n    center_col = image[:, w//2]\n    max_consecutive = 0\n    current_consecutive = 0\n    for pixel in center_col:\n        if pixel > 0:\n            current_consecutive += 1\n            max_consecutive = max(max_consecutive, current_consecutive)\n        else:\n            current_consecutive = 0\n    return float(max_consecutive)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Number of distinct horizontal transitions from background to foreground in middle rows\"\n    h, w = image.shape\n    if h == 0 or w == 0:\n        return 0.0\n    middle_start, middle_end = h // 3, 2 * h // 3\n    middle_region = image[middle_start:middle_end, :]\n    transitions = 0\n    threshold = np.mean(image) if np.std(image) > 0 else 0.5\n    for row in middle_region:\n        for i in range(1, len(row)):\n            if (row[i-1] <= threshold) and (row[i] > threshold):\n                transitions += 1\n    return float(transitions)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Presence of closed loop structure based on center region hollowness\"\n    h, w = image.shape\n    center_h, center_w = h//3, w//3\n    center_region = image[center_h:2*center_h, center_w:2*center_w]\n    if center_region.size == 0:\n        return 0.0\n    center_mean = np.mean(center_region)\n    border_pixels = np.concatenate([\n        center_region[0, :], center_region[-1, :],\n        center_region[:, 0], center_region[:, -1]\n    ])\n    border_mean = np.mean(border_pixels) if border_pixels.size > 0 else 0.0\n    return float(border_mean - center_mean)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of pixels in top half versus bottom half of image\"\n    h, w = image.shape\n    if h == 0:\n        return 0.0\n    top_half = np.sum(image[:h//2, :])\n    bottom_half = np.sum(image[h//2:, :])\n    if bottom_half == 0:\n        return float('inf') if top_half > 0 else 0.0\n    return float(top_half / bottom_half)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Presence of enclosed circular or oval regions\"\n    h, w = image.shape\n    threshold = np.mean(image) if np.mean(image) > 0 else 0.1\n    binary = (image > threshold).astype(int)\n    enclosed_regions = 0\n    center_h, center_w = h//2, w//2\n    for i in range(h//4, 3*h//4):\n        for j in range(w//4, 3*w//4):\n            if binary[i, j] == 0:\n                neighbors = binary[max(0,i-1):min(h,i+2), max(0,j-1):min(w,j+2)]\n                if np.sum(neighbors) >= 6:\n                    enclosed_regions += 1\n    return float(min(enclosed_regions / 10.0, 1.0))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Number of enclosed regions or holes in the digit\"\n    h, w = image.shape\n    binary = (image > image.mean()).astype(int)\n    holes = 0\n    visited = np.zeros_like(binary)\n    \n    def flood_fill(start_r, start_c, target_val):\n        if start_r < 0 or start_r >= h or start_c < 0 or start_c >= w:\n            return 0\n        if visited[start_r, start_c] or binary[start_r, start_c] != target_val:\n            return 0\n        visited[start_r, start_c] = 1\n        size = 1\n        for dr, dc in [(-1,0), (1,0), (0,-1), (0,1)]:\n            size += flood_fill(start_r + dr, start_c + dc, target_val)\n        return size\n    \n    for r in range(1, h-1):\n        for c in range(1, w-1):\n            if binary[r, c] == 0 and not visited[r, c]:\n                size = flood_fill(r, c, 0)\n                if size > 0 and size < h * w * 0.8:\n                    holes += 1\n    \n    return float(holes)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of pixel intensity in middle third versus outer thirds combined\"\n    h, w = image.shape\n    if w < 3:\n        return 0.0\n    middle_third = image[:, w//3:2*w//3]\n    outer_thirds = np.concatenate([image[:, :w//3], image[:, 2*w//3:]], axis=1)\n    middle_sum = float(np.sum(middle_third))\n    outer_sum = float(np.sum(outer_thirds))\n    if outer_sum == 0:\n        return 1.0 if middle_sum > 0 else 0.0\n    return middle_sum / outer_sum\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of pixels in top half versus bottom half of image\"\n    h, w = image.shape\n    if h == 0:\n        return 0.0\n    top_half = np.sum(image[:h//2, :])\n    bottom_half = np.sum(image[h//2:, :])\n    if bottom_half == 0:\n        return float('inf') if top_half > 0 else 0.0\n    return float(top_half / bottom_half)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of pixels in top half versus bottom half of image\"\n    h, w = image.shape\n    if h == 0:\n        return 0.0\n    top_half = np.sum(image[:h//2, :])\n    bottom_half = np.sum(image[h//2:, :])\n    if bottom_half == 0:\n        return float('inf') if top_half > 0 else 0.0\n    return float(top_half / bottom_half)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of pixels in top half versus bottom half of image\"\n    h, w = image.shape\n    if h == 0:\n        return 0.0\n    top_half = np.sum(image[:h//2, :])\n    bottom_half = np.sum(image[h//2:, :])\n    if bottom_half == 0:\n        return float('inf') if top_half > 0 else 0.0\n    return float(top_half / bottom_half)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Average vertical position of the rightmost non-zero pixels\"\n    h, w = image.shape\n    if h == 0 or w == 0:\n        return 0.0\n    rightmost_positions = []\n    for col_idx in range(w-1, -1, -1):\n        col = image[:, col_idx]\n        nonzero_rows = np.where(col > 0)[0]\n        if len(nonzero_rows) > 0:\n            rightmost_positions.extend(nonzero_rows)\n            break\n    if len(rightmost_positions) == 0:\n        return 0.0\n    return float(np.mean(rightmost_positions) / h)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Standard deviation of pixel intensities in the bottom-right corner\"\n    h, w = image.shape\n    bottom_right = image[2*h//3:, 2*w//3:]\n    return float(np.std(bottom_right))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Maximum consecutive horizontal pixels in the top quarter of image\"\n    h, w = image.shape\n    top_quarter = image[:h//4, :]\n    max_consecutive = 0\n    for row in top_quarter:\n        current_consecutive = 0\n        for pixel in row:\n            if pixel > 0:\n                current_consecutive += 1\n                max_consecutive = max(max_consecutive, current_consecutive)\n            else:\n                current_consecutive = 0\n    return float(max_consecutive)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of pixel intensity at top-right corner region versus bottom-left corner region\"\n    h, w = image.shape\n    corner_size = min(h//4, w//4)\n    if corner_size == 0:\n        return 0.0\n    top_right = image[:corner_size, -corner_size:]\n    bottom_left = image[-corner_size:, :corner_size]\n    tr_intensity = np.mean(top_right)\n    bl_intensity = np.mean(bottom_left)\n    if bl_intensity == 0:\n        return float(tr_intensity)\n    return float(tr_intensity / bl_intensity)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Average pixel intensity in the innermost central quarter region\"\n    h, w = image.shape\n    center_h, center_w = h // 8, w // 8\n    inner_region = image[3*center_h:5*center_h, 3*center_w:5*center_w]\n    if inner_region.size == 0:\n        return 0.0\n    return float(np.mean(inner_region))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Average pixel intensity in the top-right corner region\"\n    h, w = image.shape\n    corner_h, corner_w = h // 3, w // 3\n    if corner_h == 0 or corner_w == 0:\n        return 0.0\n    top_right = image[:corner_h, -corner_w:]\n    return float(np.mean(top_right))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Average pixel intensity in the innermost central quarter region\"\n    h, w = image.shape\n    center_h, center_w = h // 8, w // 8\n    inner_region = image[3*center_h:5*center_h, 3*center_w:5*center_w]\n    if inner_region.size == 0:\n        return 0.0\n    return float(np.mean(inner_region))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of vertical gradient magnitude in left half versus right half\"\n    h, w = image.shape\n    grad_y = np.gradient(image, axis=0)\n    left_grad = np.abs(grad_y[:, :w//2])\n    right_grad = np.abs(grad_y[:, w//2:])\n    left_mag = np.mean(left_grad) if left_grad.size > 0 else 0\n    right_mag = np.mean(right_grad) if right_grad.size > 0 else 0\n    return float(left_mag / (right_mag + 0.001))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Horizontal gradient magnitude in the middle row\"\n    h, w = image.shape\n    if h == 0 or w < 2:\n        return 0.0\n    middle_row = image[h//2, :]\n    gradient = np.gradient(middle_row)\n    return float(np.mean(np.abs(gradient)))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Count of connected horizontal runs of non-zero pixels in middle row\"\n    h, w = image.shape\n    if h == 0:\n        return 0.0\n    middle_row = image[h//2, :]\n    runs = 0\n    in_run = False\n    for pixel in middle_row:\n        if pixel > 0 and not in_run:\n            runs += 1\n            in_run = True\n        elif pixel == 0:\n            in_run = False\n    return float(runs)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of pixels in top half versus bottom half of image\"\n    h, w = image.shape\n    if h == 0:\n        return 0.0\n    top_half = np.sum(image[:h//2, :])\n    bottom_half = np.sum(image[h//2:, :])\n    if bottom_half == 0:\n        return float('inf') if top_half > 0 else 0.0\n    return float(top_half / bottom_half)\n\n"
  ]
}