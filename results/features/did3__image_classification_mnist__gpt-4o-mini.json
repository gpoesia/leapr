{
  "used_features": [
    "def feature(image: np.ndarray) -> float:\n    \"Mean pixel intensity of the image edges\"\n    edges = np.gradient(image)\n    edge_magnitude = np.sqrt(edges[0]**2 + edges[1]**2)\n    return float(np.mean(edge_magnitude))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Mean pixel intensity of the image edges\"\n    edges = np.gradient(image)\n    edge_magnitude = np.sqrt(edges[0]**2 + edges[1]**2)\n    return float(np.mean(edge_magnitude))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Count of horizontal edges (variation in pixel intensity) in the image\"\n    gradient_x, gradient_y = np.gradient(image)\n    horizontal_edges = np.sum(np.abs(gradient_y))\n    return float(horizontal_edges)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Count of horizontal edges (variation in pixel intensity) in the image\"\n    gradient_x, gradient_y = np.gradient(image)\n    horizontal_edges = np.sum(np.abs(gradient_y))\n    return float(horizontal_edges)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Proportion of white pixels (intensity > threshold) to total pixels'\n    threshold = 200\n    white_pixels = np.sum(image > threshold)\n    return float(white_pixels) / image.size\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Calculate the ratio of non-zero pixels in the lower half of the image to the total non-zero pixels.\"\n    h, w = image.shape\n    lower_half = image[h//2:, :]\n    total_non_zero = np.count_nonzero(image)\n    lower_non_zero = np.count_nonzero(lower_half)\n    return float(lower_non_zero / total_non_zero) if total_non_zero > 0 else 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Calculate the ratio of non-zero pixels in the lower half of the image to the total non-zero pixels.\"\n    h, w = image.shape\n    lower_half = image[h//2:, :]\n    total_non_zero = np.count_nonzero(image)\n    lower_non_zero = np.count_nonzero(lower_half)\n    return float(lower_non_zero / total_non_zero) if total_non_zero > 0 else 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of non-zero pixels to total pixels in the image\"\n    total_pixels = image.size\n    non_zero_pixels = np.count_nonzero(image)\n    return float(non_zero_pixels) / total_pixels if total_pixels > 0 else 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Count the number of vertical edges (maximum differences between adjacent columns).\"\n    vertical_edges = np.sum(np.abs(np.diff(image, axis=1)) > 20)\n    return float(vertical_edges)\n",
    "def feature(image: np.ndarray) -> float:\n    \"Count of vertical lines in the image based on intensity gradient\"\n    gradient = np.gradient(image, axis=1)\n    vertical_lines = np.sum(np.abs(gradient) > 10)\n    return float(vertical_lines)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Determine the mean pixel intensity in the top-right quarter of the image.\"\n    h, w = image.shape\n    top_right_quarter = image[:h//2, w//2:]\n    return float(np.mean(top_right_quarter))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Mean pixel intensity of the image edges\"\n    edges = np.gradient(image)\n    edge_magnitude = np.sqrt(edges[0]**2 + edges[1]**2)\n    return float(np.mean(edge_magnitude))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Count of non-zero columns in the image\"\n    non_zero_columns = np.count_nonzero(np.sum(image, axis=0))\n    return float(non_zero_columns)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Count of horizontal edges (variation in pixel intensity) in the image\"\n    gradient_x, gradient_y = np.gradient(image)\n    horizontal_edges = np.sum(np.abs(gradient_y))\n    return float(horizontal_edges)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of the number of vertical edges to the total number of edges.\"\n    gradient = np.gradient(image)\n    vertical_edges = np.count_nonzero(gradient[1])  # Vertical gradient count\n    total_edges = np.count_nonzero(gradient)\n    return float(vertical_edges) / float(total_edges) if total_edges > 0 else 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Proportion of edge pixels to total pixels using gradient magnitude\"\n    gradient = np.gradient(image)\n    edges = np.sqrt(gradient[0]**2 + gradient[1]**2)\n    edge_count = np.count_nonzero(edges)\n    total_count = image.size\n    return float(edge_count) / total_count if total_count > 0 else 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Sum of pixel values in the top-left quarter of the image\"\n    h, w = image.shape\n    top_left_quarter = image[:h // 2, :w // 2]\n    return float(np.sum(top_left_quarter))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Count of non-zero pixels in the top and bottom halves of the image'\n    h, w = image.shape\n    top_half = np.count_nonzero(image[:h//2])\n    bottom_half = np.count_nonzero(image[h//2:])\n    return float(top_half - bottom_half)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Proportion of white pixels (intensity > threshold) to total pixels'\n    threshold = 200\n    white_pixels = np.sum(image > threshold)\n    return float(white_pixels) / image.size\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Count of non-zero pixels in the image's lower left quadrant\"\n    h, w = image.shape\n    lower_left = image[h//2:, 0:w//2]\n    return float(np.count_nonzero(lower_left))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Calculate the ratio of non-zero pixels in the lower half of the image to the total non-zero pixels.\"\n    h, w = image.shape\n    lower_half = image[h//2:, :]\n    total_non_zero = np.count_nonzero(image)\n    lower_non_zero = np.count_nonzero(lower_half)\n    return float(lower_non_zero / total_non_zero) if total_non_zero > 0 else 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Count of non-zero pixels in the top and bottom halves of the image'\n    h, w = image.shape\n    top_half = np.count_nonzero(image[:h//2])\n    bottom_half = np.count_nonzero(image[h//2:])\n    return float(top_half - bottom_half)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Standard deviation of pixel intensities in the corner regions\"\n    h, w = image.shape\n    top_left = image[0:h//2, 0:w//2]\n    top_right = image[0:h//2, w//2:w]\n    bottom_left = image[h//2:h, 0:w//2]\n    bottom_right = image[h//2:h, w//2:w]\n    corner_std = np.std([np.std(top_left), np.std(top_right), np.std(bottom_left), np.std(bottom_right)])\n    return float(corner_std)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Count of horizontal edges (variation in pixel intensity) in the image\"\n    gradient_x, gradient_y = np.gradient(image)\n    horizontal_edges = np.sum(np.abs(gradient_y))\n    return float(horizontal_edges)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Calculate the symmetry of the image by comparing halves.'\n    h, w = image.shape\n    left_half = image[:, :w//2]\n    right_half = image[:, w//2:]\n    return float(np.mean(left_half) / (np.mean(right_half) or 1))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of the number of vertical edges to the total number of edges.\"\n    gradient = np.gradient(image)\n    vertical_edges = np.count_nonzero(gradient[1])  # Vertical gradient count\n    total_edges = np.count_nonzero(gradient)\n    return float(vertical_edges) / float(total_edges) if total_edges > 0 else 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of the number of vertical edges to the total number of edges.\"\n    gradient = np.gradient(image)\n    vertical_edges = np.count_nonzero(gradient[1])  # Vertical gradient count\n    total_edges = np.count_nonzero(gradient)\n    return float(vertical_edges) / float(total_edges) if total_edges > 0 else 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Mean pixel intensity of the image edges\"\n    edges = np.gradient(image)\n    edge_magnitude = np.sqrt(edges[0]**2 + edges[1]**2)\n    return float(np.mean(edge_magnitude))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Mean pixel intensity of the diagonal from top-left to bottom-right'\n    diagonal = np.diagonal(image)\n    return float(np.mean(diagonal))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Average pixel intensity of the image corners\"\n    h, w = image.shape\n    corners = np.concatenate((image[:h//4, :w//4], image[:h//4, 3*w//4:], \n                               image[3*h//4:, :w//4], image[3*h//4:, 3*w//4:]))\n    return float(np.mean(corners))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Calculate the ratio of the sum of upper half pixel intensities to the sum of the lower half pixel intensities.\"\n    h, w = image.shape\n    upper_half = image[:h//2]\n    lower_half = image[h//2:]\n    upper_sum = np.sum(upper_half)\n    lower_sum = np.sum(lower_half)\n    return upper_sum / (lower_sum + 1e-5)  # Avoid division by zero\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of the number of vertical edges to the total number of edges.\"\n    gradient = np.gradient(image)\n    vertical_edges = np.count_nonzero(gradient[1])  # Vertical gradient count\n    total_edges = np.count_nonzero(gradient)\n    return float(vertical_edges) / float(total_edges) if total_edges > 0 else 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Detection of horizontal edges using the Prewitt filter'\n    prewitt_y = np.array([[1, 1, 1], [0, 0, 0], [-1, -1, -1]])\n    edges = np.abs(np.convolve(image.flatten(), prewitt_y.flatten(), 'same'))\n    return float(np.count_nonzero(edges))\n",
    "def feature(image: np.ndarray) -> float:\n    \"Count of distinct pixel values in the image\"\n    unique_values = np.unique(image)\n    return float(len(unique_values))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of the number of vertical edges to the total number of edges.\"\n    gradient = np.gradient(image)\n    vertical_edges = np.count_nonzero(gradient[1])  # Vertical gradient count\n    total_edges = np.count_nonzero(gradient)\n    return float(vertical_edges) / float(total_edges) if total_edges > 0 else 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Standard deviation of pixel intensities in the corner regions\"\n    h, w = image.shape\n    top_left = image[0:h//2, 0:w//2]\n    top_right = image[0:h//2, w//2:w]\n    bottom_left = image[h//2:h, 0:w//2]\n    bottom_right = image[h//2:h, w//2:w]\n    corner_std = np.std([np.std(top_left), np.std(top_right), np.std(bottom_left), np.std(bottom_right)])\n    return float(corner_std)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Number of vertical lines detected using simple column intensity variation\"\n    vertical_lines = np.sum(np.abs(np.diff(image, axis=1)) > 10)\n    return float(vertical_lines)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Average width of white contours in the image'\n    thresholded = np.where(image > 150, 1, 0)\n    contours = np.sum(thresholded, axis=0)\n    return float(np.mean(contours[contours > 0])) if np.any(contours > 0) else 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Sum of the pixel intensities in the upper half of the image'\n    upper_half = image[:image.shape[0] // 2, :]\n    return float(np.sum(upper_half))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Difference between the mean intensity of the upper and lower halves of the image'\n    h, w = image.shape\n    upper_half_mean = np.mean(image[0:h//2, :])\n    lower_half_mean = np.mean(image[h//2:, :])\n    return float(upper_half_mean - lower_half_mean)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Count of horizontal lines detected using the intensity threshold\"\n    threshold = 128\n    horizontal_projection = np.sum(image > threshold, axis=1)\n    horizontal_lines = np.count_nonzero(horizontal_projection)\n    return float(horizontal_lines)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Total count of pixels located in the middle third of the image\"\n    h, w = image.shape\n    mid_start_h = h // 3\n    mid_end_h = 2 * h // 3\n    mid_region = image[mid_start_h:mid_end_h]\n    return float(np.count_nonzero(mid_region))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of non-zero pixels in the top quarter to the bottom quarter of the image\"\n    h, w = image.shape\n    top_quarter = image[:h // 4, :]\n    bottom_quarter = image[h * 3 // 4:, :]\n    top_nonzero = np.count_nonzero(top_quarter)\n    bottom_nonzero = np.count_nonzero(bottom_quarter)\n    return float(top_nonzero / (bottom_nonzero + 1e-5))  # Avoid division by zero\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of non-zero pixels in the top quarter to the bottom quarter of the image\"\n    h, w = image.shape\n    top_quarter = image[:h // 4, :]\n    bottom_quarter = image[h * 3 // 4:, :]\n    top_nonzero = np.count_nonzero(top_quarter)\n    bottom_nonzero = np.count_nonzero(bottom_quarter)\n    return float(top_nonzero / (bottom_nonzero + 1e-5))  # Avoid division by zero\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of non-zero pixels in the top quarter to the bottom quarter of the image\"\n    h, w = image.shape\n    top_quarter = image[:h // 4, :]\n    bottom_quarter = image[h * 3 // 4:, :]\n    top_nonzero = np.count_nonzero(top_quarter)\n    bottom_nonzero = np.count_nonzero(bottom_quarter)\n    return float(top_nonzero / (bottom_nonzero + 1e-5))  # Avoid division by zero\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of non-zero pixels in the top quarter to the bottom quarter of the image\"\n    h, w = image.shape\n    top_quarter = image[:h // 4, :]\n    bottom_quarter = image[h * 3 // 4:, :]\n    top_nonzero = np.count_nonzero(top_quarter)\n    bottom_nonzero = np.count_nonzero(bottom_quarter)\n    return float(top_nonzero / (bottom_nonzero + 1e-5))  # Avoid division by zero\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Sum of pixel intensities in the right half of the image\"\n    h, w = image.shape\n    right_half = image[:, w//2:]\n    return float(np.sum(right_half))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of non-zero pixels in the top quarter to the bottom quarter of the image\"\n    h, w = image.shape\n    top_quarter = image[:h // 4, :]\n    bottom_quarter = image[h * 3 // 4:, :]\n    top_nonzero = np.count_nonzero(top_quarter)\n    bottom_nonzero = np.count_nonzero(bottom_quarter)\n    return float(top_nonzero / (bottom_nonzero + 1e-5))  # Avoid division by zero\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of non-zero pixels in the top quarter to the bottom quarter of the image\"\n    h, w = image.shape\n    top_quarter = image[:h // 4, :]\n    bottom_quarter = image[h * 3 // 4:, :]\n    top_nonzero = np.count_nonzero(top_quarter)\n    bottom_nonzero = np.count_nonzero(bottom_quarter)\n    return float(top_nonzero / (bottom_nonzero + 1e-5))  # Avoid division by zero\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of non-zero pixels in the top quarter to the bottom quarter of the image\"\n    h, w = image.shape\n    top_quarter = image[:h // 4, :]\n    bottom_quarter = image[h * 3 // 4:, :]\n    top_nonzero = np.count_nonzero(top_quarter)\n    bottom_nonzero = np.count_nonzero(bottom_quarter)\n    return float(top_nonzero / (bottom_nonzero + 1e-5))  # Avoid division by zero\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Sum of pixel values in the bottom quarter of the image\"\n    h = image.shape[0]\n    bottom_quarter = image[3*h//4:h, :]\n    return float(np.sum(bottom_quarter))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of non-zero pixels in the top quarter to the bottom quarter of the image\"\n    h, w = image.shape\n    top_quarter = image[:h // 4, :]\n    bottom_quarter = image[h * 3 // 4:, :]\n    top_nonzero = np.count_nonzero(top_quarter)\n    bottom_nonzero = np.count_nonzero(bottom_quarter)\n    return float(top_nonzero / (bottom_nonzero + 1e-5))  # Avoid division by zero\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of non-zero pixels in the top quarter to the bottom quarter of the image\"\n    h, w = image.shape\n    top_quarter = image[:h // 4, :]\n    bottom_quarter = image[h * 3 // 4:, :]\n    top_nonzero = np.count_nonzero(top_quarter)\n    bottom_nonzero = np.count_nonzero(bottom_quarter)\n    return float(top_nonzero / (bottom_nonzero + 1e-5))  # Avoid division by zero\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of non-zero pixels in the top quarter to the bottom quarter of the image\"\n    h, w = image.shape\n    top_quarter = image[:h // 4, :]\n    bottom_quarter = image[h * 3 // 4:, :]\n    top_nonzero = np.count_nonzero(top_quarter)\n    bottom_nonzero = np.count_nonzero(bottom_quarter)\n    return float(top_nonzero / (bottom_nonzero + 1e-5))  # Avoid division by zero\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Average pixel intensity in the top third of the image\"\n    h, w = image.shape\n    top_third = image[:h//3, :]\n    return float(np.mean(top_third))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Horizontal gradient magnitude at the middle row of the image\"\n    grad_x = np.gradient(image, axis=1)\n    return float(np.mean(np.abs(grad_x[image.shape[0] // 2])))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Horizontal gradient magnitude at the middle row of the image\"\n    grad_x = np.gradient(image, axis=1)\n    return float(np.mean(np.abs(grad_x[image.shape[0] // 2])))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Sum of pixel values in the bottom quarter of the image\"\n    h = image.shape[0]\n    bottom_quarter = image[3*h//4:h, :]\n    return float(np.sum(bottom_quarter))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Horizontal gradient magnitude at the middle row of the image\"\n    grad_x = np.gradient(image, axis=1)\n    return float(np.mean(np.abs(grad_x[image.shape[0] // 2])))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of non-zero pixels in the top quarter to the bottom quarter of the image\"\n    h, w = image.shape\n    top_quarter = image[:h // 4, :]\n    bottom_quarter = image[h * 3 // 4:, :]\n    top_nonzero = np.count_nonzero(top_quarter)\n    bottom_nonzero = np.count_nonzero(bottom_quarter)\n    return float(top_nonzero / (bottom_nonzero + 1e-5))  # Avoid division by zero\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Horizontal gradient magnitude at the middle row of the image\"\n    grad_x = np.gradient(image, axis=1)\n    return float(np.mean(np.abs(grad_x[image.shape[0] // 2])))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of non-zero pixels in the top quarter to the bottom quarter of the image\"\n    h, w = image.shape\n    top_quarter = image[:h // 4, :]\n    bottom_quarter = image[h * 3 // 4:, :]\n    top_nonzero = np.count_nonzero(top_quarter)\n    bottom_nonzero = np.count_nonzero(bottom_quarter)\n    return float(top_nonzero / (bottom_nonzero + 1e-5))  # Avoid division by zero\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Sum of pixel values in the bottom quarter of the image\"\n    h = image.shape[0]\n    bottom_quarter = image[3*h//4:h, :]\n    return float(np.sum(bottom_quarter))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Standard deviation of pixel intensities in the corner regions\"\n    h, w = image.shape\n    top_left = image[0:h//2, 0:w//2]\n    top_right = image[0:h//2, w//2:w]\n    bottom_left = image[h//2:h, 0:w//2]\n    bottom_right = image[h//2:h, w//2:w]\n    corner_std = np.std([np.std(top_left), np.std(top_right), np.std(bottom_left), np.std(bottom_right)])\n    return float(corner_std)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Sum of the pixel intensities in the upper half of the image'\n    upper_half = image[:image.shape[0] // 2, :]\n    return float(np.sum(upper_half))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Mean pixel intensity of the image margins (top and bottom)\"\n    top_margin = image[:image.shape[0]//10, :]\n    bottom_margin = image[-image.shape[0]//10:, :]\n    return float((np.mean(top_margin) + np.mean(bottom_margin)) / 2)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Proportion of pixels in the center region compared to the entire image\"\n    h, w = image.shape\n    center_region = image[h//4:3*h//4, w//4:3*w//4]\n    pixel_count = np.count_nonzero(image)\n    center_pixel_count = np.count_nonzero(center_region)\n    return float(center_pixel_count / pixel_count) if pixel_count > 0 else 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of non-zero pixels to total pixels in the image\"\n    total_pixels = image.size\n    non_zero_pixels = np.count_nonzero(image)\n    return float(non_zero_pixels) / total_pixels if total_pixels > 0 else 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of non-zero pixels in the upper half of the image to total non-zero pixels.\"\n    h, w = image.shape\n    upper_half = image[:h//2]\n    upper_nonzero_count = np.count_nonzero(upper_half)\n    total_nonzero_count = np.count_nonzero(image)\n    return float(upper_nonzero_count) / float(total_nonzero_count) if total_nonzero_count > 0 else 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Total count of pixels located in the middle third of the image\"\n    h, w = image.shape\n    mid_start_h = h // 3\n    mid_end_h = 2 * h // 3\n    mid_region = image[mid_start_h:mid_end_h]\n    return float(np.count_nonzero(mid_region))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Sum of pixel intensities in the center column of the image\"\n    h, w = image.shape\n    center_col = image[:, w // 2]\n    return float(np.sum(center_col))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Difference between the mean intensity of the upper and lower halves of the image'\n    h, w = image.shape\n    upper_half_mean = np.mean(image[0:h//2, :])\n    lower_half_mean = np.mean(image[h//2:, :])\n    return float(upper_half_mean - lower_half_mean)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Mean pixel intensity of the image margins (top and bottom)\"\n    top_margin = image[:image.shape[0]//10, :]\n    bottom_margin = image[-image.shape[0]//10:, :]\n    return float((np.mean(top_margin) + np.mean(bottom_margin)) / 2)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Average width of white contours in the image'\n    thresholded = np.where(image > 150, 1, 0)\n    contours = np.sum(thresholded, axis=0)\n    return float(np.mean(contours[contours > 0])) if np.any(contours > 0) else 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Sum of pixel values in the bottom quarter of the image\"\n    h = image.shape[0]\n    bottom_quarter = image[3*h//4:h, :]\n    return float(np.sum(bottom_quarter))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Calculate the ratio of the sum of pixel intensities in the top quarter to the bottom quarter\"\n    top_quarter_sum = np.sum(image[:image.shape[0]//4])\n    bottom_quarter_sum = np.sum(image[3*image.shape[0]//4:])\n    return float(top_quarter_sum / (bottom_quarter_sum + 1e-6))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of non-zero pixels to total pixels in the image\"\n    total_pixels = image.size\n    non_zero_pixels = np.count_nonzero(image)\n    return float(non_zero_pixels) / total_pixels if total_pixels > 0 else 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of the number of vertical edges to the total number of edges.\"\n    gradient = np.gradient(image)\n    vertical_edges = np.count_nonzero(gradient[1])  # Vertical gradient count\n    total_edges = np.count_nonzero(gradient)\n    return float(vertical_edges) / float(total_edges) if total_edges > 0 else 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Count of corners detected in the image using Harris corner detection\"\n    import cv2\n    corners = cv2.cornerHarris(image.astype(np.float32), blockSize=2, ksize=3, k=0.04)\n    return float(np.sum(corners > 0.01 * corners.max()))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Ratio of maximum pixel intensity in the left half to the right half of the image'\n    h, w = image.shape\n    left_half_max = np.max(image[:, :w//2])\n    right_half_max = np.max(image[:, w//2:])\n    return float(left_half_max / (right_half_max + 1e-6))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Standard deviation of pixel intensities in the corner regions\"\n    h, w = image.shape\n    top_left = image[0:h//2, 0:w//2]\n    top_right = image[0:h//2, w//2:w]\n    bottom_left = image[h//2:h, 0:w//2]\n    bottom_right = image[h//2:h, w//2:w]\n    corner_std = np.std([np.std(top_left), np.std(top_right), np.std(bottom_left), np.std(bottom_right)])\n    return float(corner_std)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Mean pixel intensity of the image margins (top and bottom)\"\n    top_margin = image[:image.shape[0]//10, :]\n    bottom_margin = image[-image.shape[0]//10:, :]\n    return float((np.mean(top_margin) + np.mean(bottom_margin)) / 2)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Mean pixel intensity of the image margins (top and bottom)\"\n    top_margin = image[:image.shape[0]//10, :]\n    bottom_margin = image[-image.shape[0]//10:, :]\n    return float((np.mean(top_margin) + np.mean(bottom_margin)) / 2)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Total count of pixels located in the middle third of the image\"\n    h, w = image.shape\n    mid_start_h = h // 3\n    mid_end_h = 2 * h // 3\n    mid_region = image[mid_start_h:mid_end_h]\n    return float(np.count_nonzero(mid_region))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Mean pixel intensity of pixels in the left half of the image'\n    left_half = image[:, :image.shape[1] // 2]\n    return float(np.mean(left_half))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Sum of pixel values in the bottom quarter of the image\"\n    h = image.shape[0]\n    bottom_quarter = image[3*h//4:h, :]\n    return float(np.sum(bottom_quarter))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Count of vertical edges (variation in pixel intensity) in the image.\"\n    gradient_x = np.gradient(image, axis=1)\n    vertical_edges_count = np.count_nonzero(np.abs(gradient_x) > 15)  # Threshold for edge detection\n    return float(vertical_edges_count)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Count of horizontal edges (variation in pixel intensity) in the image\"\n    gradient_x, gradient_y = np.gradient(image)\n    horizontal_edges = np.sum(np.abs(gradient_y))\n    return float(horizontal_edges)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Count of corners detected in the image using Harris corner detection\"\n    import cv2\n    corners = cv2.cornerHarris(image.astype(np.float32), blockSize=2, ksize=3, k=0.04)\n    return float(np.sum(corners > 0.01 * corners.max()))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of non-zero pixels in the top quarter to the bottom quarter of the image\"\n    h, w = image.shape\n    top_quarter = image[:h // 4, :]\n    bottom_quarter = image[h * 3 // 4:, :]\n    top_nonzero = np.count_nonzero(top_quarter)\n    bottom_nonzero = np.count_nonzero(bottom_quarter)\n    return float(top_nonzero / (bottom_nonzero + 1e-5))  # Avoid division by zero\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Ratio of vertical lines to total edges detected'\n    vertical_gradient = np.gradient(image, axis=1)\n    vertical_edges = np.count_nonzero(np.abs(vertical_gradient) > 10)\n    total_edges = np.count_nonzero(np.abs(np.gradient(image)) > 10)\n    return float(vertical_edges) / total_edges if total_edges > 0 else 0.0\n",
    "def feature(image: np.ndarray) -> float:\n    \"Measure the variance of pixel intensities in the horizontal center strip of the image.\"\n    h, w = image.shape\n    center_strip = image[h//2, :]\n    return float(np.var(center_strip))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Mean pixel intensity of the image margins (top and bottom)\"\n    top_margin = image[:image.shape[0]//10, :]\n    bottom_margin = image[-image.shape[0]//10:, :]\n    return float((np.mean(top_margin) + np.mean(bottom_margin)) / 2)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of horizontal pixel gradients to vertical pixel gradients\"\n    gradient_x, gradient_y = np.gradient(image)\n    horizontal_gradient = np.sum(np.abs(gradient_y))\n    vertical_gradient = np.sum(np.abs(gradient_x))\n    return horizontal_gradient / (vertical_gradient + 1e-5)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Average pixel intensity along the horizontal midline of the image\"\n    h, w = image.shape\n    midline = image[h // 2, :]\n    return float(np.mean(midline))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of the sum of pixel intensities in the center region to the total sum of pixel intensities in the image.\"\n    h, w = image.shape\n    center_region = image[h//4:3*h//4, w//4:3*w//4]\n    return float(np.sum(center_region)) / (np.sum(image) + 1e-10)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Average pixel intensity along the horizontal midline of the image\"\n    h, w = image.shape\n    midline = image[h // 2, :]\n    return float(np.mean(midline))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of the sum of pixel intensities in the center region to the total sum of pixel intensities in the image.\"\n    h, w = image.shape\n    center_region = image[h//4:3*h//4, w//4:3*w//4]\n    return float(np.sum(center_region)) / (np.sum(image) + 1e-10)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Mean pixel intensity of the image margins (top and bottom)\"\n    top_margin = image[:image.shape[0]//10, :]\n    bottom_margin = image[-image.shape[0]//10:, :]\n    return float((np.mean(top_margin) + np.mean(bottom_margin)) / 2)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Mean pixel intensity of the image margins (top and bottom)\"\n    top_margin = image[:image.shape[0]//10, :]\n    bottom_margin = image[-image.shape[0]//10:, :]\n    return float((np.mean(top_margin) + np.mean(bottom_margin)) / 2)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Proportion of pixels in the center region compared to the entire image\"\n    h, w = image.shape\n    center_region = image[h//4:3*h//4, w//4:3*w//4]\n    pixel_count = np.count_nonzero(image)\n    center_pixel_count = np.count_nonzero(center_region)\n    return float(center_pixel_count / pixel_count) if pixel_count > 0 else 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Proportion of pixels in the center region compared to the entire image\"\n    h, w = image.shape\n    center_region = image[h//4:3*h//4, w//4:3*w//4]\n    pixel_count = np.count_nonzero(image)\n    center_pixel_count = np.count_nonzero(center_region)\n    return float(center_pixel_count / pixel_count) if pixel_count > 0 else 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Determine the sum of pixel values in the top quarter of the image.\"\n    top_quarter = image[:image.shape[0] // 4, :]\n    return float(np.sum(top_quarter))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Count of corners detected in the image using Harris corner detection\"\n    import cv2\n    corners = cv2.cornerHarris(image.astype(np.float32), blockSize=2, ksize=3, k=0.04)\n    return float(np.sum(corners > 0.01 * corners.max()))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Mean pixel intensity of the image margins (top and bottom)\"\n    top_margin = image[:image.shape[0]//10, :]\n    bottom_margin = image[-image.shape[0]//10:, :]\n    return float((np.mean(top_margin) + np.mean(bottom_margin)) / 2)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Average pixel intensity along the horizontal midline of the image\"\n    h, w = image.shape\n    midline = image[h // 2, :]\n    return float(np.mean(midline))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Total count of pixels located in the middle third of the image\"\n    h, w = image.shape\n    mid_start_h = h // 3\n    mid_end_h = 2 * h // 3\n    mid_region = image[mid_start_h:mid_end_h]\n    return float(np.count_nonzero(mid_region))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Total count of pixels located in the middle third of the image\"\n    h, w = image.shape\n    mid_start_h = h // 3\n    mid_end_h = 2 * h // 3\n    mid_region = image[mid_start_h:mid_end_h]\n    return float(np.count_nonzero(mid_region))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Average pixel intensity along the horizontal midline of the image\"\n    h, w = image.shape\n    midline = image[h // 2, :]\n    return float(np.mean(midline))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Mean pixel intensity of the image margins (top and bottom)\"\n    top_margin = image[:image.shape[0]//10, :]\n    bottom_margin = image[-image.shape[0]//10:, :]\n    return float((np.mean(top_margin) + np.mean(bottom_margin)) / 2)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Proportion of pixels in the center region compared to the entire image\"\n    h, w = image.shape\n    center_region = image[h//4:3*h//4, w//4:3*w//4]\n    pixel_count = np.count_nonzero(image)\n    center_pixel_count = np.count_nonzero(center_region)\n    return float(center_pixel_count / pixel_count) if pixel_count > 0 else 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Mean pixel intensity of the image margins (top and bottom)\"\n    top_margin = image[:image.shape[0]//10, :]\n    bottom_margin = image[-image.shape[0]//10:, :]\n    return float((np.mean(top_margin) + np.mean(bottom_margin)) / 2)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Horizontal gradient magnitude at the middle row of the image\"\n    grad_x = np.gradient(image, axis=1)\n    return float(np.mean(np.abs(grad_x[image.shape[0] // 2])))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Count of corners detected in the image using Harris corner detection\"\n    import cv2\n    corners = cv2.cornerHarris(image.astype(np.float32), blockSize=2, ksize=3, k=0.04)\n    return float(np.sum(corners > 0.01 * corners.max()))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Sum of pixel values in the bottom quarter of the image\"\n    h = image.shape[0]\n    bottom_quarter = image[3*h//4:h, :]\n    return float(np.sum(bottom_quarter))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Sum of pixel values in the bottom quarter of the image\"\n    h = image.shape[0]\n    bottom_quarter = image[3*h//4:h, :]\n    return float(np.sum(bottom_quarter))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Count of non-zero pixels in the top quarter of the image\"\n    h, w = image.shape\n    top_quarter = image[:h // 4, :]\n    return float(np.count_nonzero(top_quarter))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Horizontal gradient magnitude at the middle row of the image\"\n    grad_x = np.gradient(image, axis=1)\n    return float(np.mean(np.abs(grad_x[image.shape[0] // 2])))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Calculate the ratio of the sum of pixel intensities in the top quarter to the bottom quarter\"\n    top_quarter_sum = np.sum(image[:image.shape[0]//4])\n    bottom_quarter_sum = np.sum(image[3*image.shape[0]//4:])\n    return float(top_quarter_sum / (bottom_quarter_sum + 1e-6))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Count of non-zero pixels in the top quarter of the image\"\n    h, w = image.shape\n    top_quarter = image[:h // 4, :]\n    return float(np.count_nonzero(top_quarter))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Determine the sum of pixel values in the top quarter of the image.\"\n    top_quarter = image[:image.shape[0] // 4, :]\n    return float(np.sum(top_quarter))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Count of corners detected in the image using Harris corner detection\"\n    import cv2\n    corners = cv2.cornerHarris(image.astype(np.float32), blockSize=2, ksize=3, k=0.04)\n    return float(np.sum(corners > 0.01 * corners.max()))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Mean pixel intensity of the image margins (top and bottom)\"\n    top_margin = image[:image.shape[0]//10, :]\n    bottom_margin = image[-image.shape[0]//10:, :]\n    return float((np.mean(top_margin) + np.mean(bottom_margin)) / 2)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Proportion of diagonal pixels (from top left to bottom right) to total pixels\"\n    h, w = image.shape\n    diagonal_count = min(h, w)\n    diagonal_sum = np.sum(image[np.arange(diagonal_count), np.arange(diagonal_count)])\n    total_sum = np.sum(image)\n    return float(diagonal_sum / total_sum) if total_sum > 0 else 0.0\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of non-zero pixels to total pixels in the image\"\n    total_pixels = image.size\n    non_zero_pixels = np.count_nonzero(image)\n    return float(non_zero_pixels) / total_pixels if total_pixels > 0 else 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of non-zero pixels to total pixels in the image\"\n    total_pixels = image.size\n    non_zero_pixels = np.count_nonzero(image)\n    return float(non_zero_pixels) / total_pixels if total_pixels > 0 else 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Standard deviation of pixel intensities in the whole image\"\n    return float(np.std(image))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Measure the variance of pixel intensities in the horizontal center strip of the image.\"\n    h, w = image.shape\n    center_strip = image[h//2, :]\n    return float(np.var(center_strip))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of non-zero pixels to total pixels in the image\"\n    total_pixels = image.size\n    non_zero_pixels = np.count_nonzero(image)\n    return float(non_zero_pixels) / total_pixels if total_pixels > 0 else 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Compactness of the object in the image defined as area/perimeter^2\"\n    thresholded_image = image > 128\n    area = np.sum(thresholded_image)\n    perimeter = np.sum(np.abs(np.gradient(thresholded_image.astype(float))))\n    return (area / (perimeter**2)) if perimeter > 0 else 0.0\n",
    "def feature(image: np.ndarray) -> float:\n    \"Sum of pixel intensities in the right half of the image\"\n    h, w = image.shape\n    right_half = image[:, w//2:]\n    return float(np.sum(right_half))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Mean pixel intensity of the image margins (top and bottom)\"\n    top_margin = image[:image.shape[0]//10, :]\n    bottom_margin = image[-image.shape[0]//10:, :]\n    return float((np.mean(top_margin) + np.mean(bottom_margin)) / 2)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Count of non-zero pixels in the central horizontal band of the image\"\n    try:\n        h, w = image.shape\n        center_band = image[h//2, :]\n        return float(np.count_nonzero(center_band))\n    except Exception as e:\n        return 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of the sum of pixel intensities in the center region to the total sum of pixel intensities in the image.\"\n    h, w = image.shape\n    center_region = image[h//4:3*h//4, w//4:3*w//4]\n    return float(np.sum(center_region)) / (np.sum(image) + 1e-10)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Compactness of the object in the image defined as area/perimeter^2\"\n    thresholded_image = image > 128\n    area = np.sum(thresholded_image)\n    perimeter = np.sum(np.abs(np.gradient(thresholded_image.astype(float))))\n    return (area / (perimeter**2)) if perimeter > 0 else 0.0\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of non-zero pixels to total pixels in the image\"\n    total_pixels = image.size\n    non_zero_pixels = np.count_nonzero(image)\n    return float(non_zero_pixels) / total_pixels if total_pixels > 0 else 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Difference between the mean intensity of the upper and lower halves of the image'\n    h, w = image.shape\n    upper_half_mean = np.mean(image[0:h//2, :])\n    lower_half_mean = np.mean(image[h//2:, :])\n    return float(upper_half_mean - lower_half_mean)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of non-zero pixels to total pixels in the image\"\n    total_pixels = image.size\n    non_zero_pixels = np.count_nonzero(image)\n    return float(non_zero_pixels) / total_pixels if total_pixels > 0 else 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Skewness of pixel intensity distribution in the image\"\n    return float((np.mean(image) - np.median(image)) / np.std(image)) if np.std(image) > 0 else 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Calculate the ratio of non-zero pixels in the lower half of the image to the total non-zero pixels.\"\n    h, w = image.shape\n    lower_half = image[h//2:, :]\n    total_non_zero = np.count_nonzero(image)\n    lower_non_zero = np.count_nonzero(lower_half)\n    return float(lower_non_zero / total_non_zero) if total_non_zero > 0 else 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Mean pixel intensity of the image edges\"\n    edges = np.gradient(image)\n    edge_magnitude = np.sqrt(edges[0]**2 + edges[1]**2)\n    return float(np.mean(edge_magnitude))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Mean pixel intensity of the image edges\"\n    edges = np.gradient(image)\n    edge_magnitude = np.sqrt(edges[0]**2 + edges[1]**2)\n    return float(np.mean(edge_magnitude))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of non-zero pixels to total pixels in the image\"\n    total_pixels = image.size\n    non_zero_pixels = np.count_nonzero(image)\n    return float(non_zero_pixels) / total_pixels if total_pixels > 0 else 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Calculate the ratio of non-zero pixels in the lower half of the image to the total non-zero pixels.\"\n    h, w = image.shape\n    lower_half = image[h//2:, :]\n    total_non_zero = np.count_nonzero(image)\n    lower_non_zero = np.count_nonzero(lower_half)\n    return float(lower_non_zero / total_non_zero) if total_non_zero > 0 else 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Calculate the ratio of the sum of pixel intensities in the top quarter to the bottom quarter\"\n    top_quarter_sum = np.sum(image[:image.shape[0]//4])\n    bottom_quarter_sum = np.sum(image[3*image.shape[0]//4:])\n    return float(top_quarter_sum / (bottom_quarter_sum + 1e-6))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Count of local maxima in the image\"\n    gradient_x, gradient_y = np.gradient(image)\n    gradients_magnitude = np.sqrt(gradient_x**2 + gradient_y**2)\n    local_maxima = np.count_nonzero((gradients_magnitude > 0) & (np.roll(gradients_magnitude, 1, axis=0) < gradients_magnitude) & (np.roll(gradients_magnitude, -1, axis=0) < gradients_magnitude))\n    return float(local_maxima)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of horizontal pixel gradients to vertical pixel gradients\"\n    gradient_x, gradient_y = np.gradient(image)\n    horizontal_gradient = np.sum(np.abs(gradient_y))\n    vertical_gradient = np.sum(np.abs(gradient_x))\n    return horizontal_gradient / (vertical_gradient + 1e-5)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of non-zero pixels to total pixels in the image\"\n    total_pixels = image.size\n    non_zero_pixels = np.count_nonzero(image)\n    return float(non_zero_pixels) / total_pixels if total_pixels > 0 else 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of non-zero pixels to total pixels in the image\"\n    total_pixels = image.size\n    non_zero_pixels = np.count_nonzero(image)\n    return float(non_zero_pixels) / total_pixels if total_pixels > 0 else 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Count of local maxima in the image based on pixel intensity'\n    gradient = np.gradient(image)\n    local_maxima = np.count_nonzero((gradient[0] > 0) & (np.roll(gradient[0], 1) < 0))\n    return float(local_maxima)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Sum of pixel values in the bottom quarter of the image\"\n    h = image.shape[0]\n    bottom_quarter = image[3*h//4:h, :]\n    return float(np.sum(bottom_quarter))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Contrast between the center region and the overall image\"\n    h, w = image.shape\n    center_region = image[h // 4:3 * h // 4, w // 4:3 * w // 4]\n    return float(np.std(center_region) / np.std(image)) if np.std(image) > 0 else 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Average distance of pixels from the center of the image'\n    h, w = image.shape\n    center_x, center_y = w // 2, h // 2\n    distances = np.sqrt((np.arange(h)[:, None] - center_y) ** 2 + (np.arange(w) - center_x) ** 2)\n    average_distance = np.mean(distances[image > 0])\n    return float(average_distance) if np.count_nonzero(image) > 0 else 0.0\n",
    "def feature(image: np.ndarray) -> float:\n    'High-frequency content measure using mean of gradients'\n    gradients = np.abs(np.gradient(image))\n    return float(np.mean(gradients[0]) + np.mean(gradients[1]))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Determine the sum of pixel values in the top quarter of the image.\"\n    top_quarter = image[:image.shape[0] // 4, :]\n    return float(np.sum(top_quarter))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of non-zero pixels in the top quarter to the bottom quarter of the image\"\n    h, w = image.shape\n    top_quarter = image[:h // 4, :]\n    bottom_quarter = image[h * 3 // 4:, :]\n    top_nonzero = np.count_nonzero(top_quarter)\n    bottom_nonzero = np.count_nonzero(bottom_quarter)\n    return float(top_nonzero / (bottom_nonzero + 1e-5))  # Avoid division by zero\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Maximum gradient magnitude in the image to assess edge strength\"\n    gradients = np.gradient(image.astype(float))\n    gradient_magnitude = np.sqrt(gradients[0]**2 + gradients[1]**2)\n    return float(np.max(gradient_magnitude))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Count of non-zero pixels in the central horizontal band of the image\"\n    try:\n        h, w = image.shape\n        center_band = image[h//2, :]\n        return float(np.count_nonzero(center_band))\n    except Exception as e:\n        return 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Density of changes in pixel intensity in the image.\"\n    gradient = np.gradient(image)\n    change_density = np.count_nonzero(gradient[0]) + np.count_nonzero(gradient[1])\n    return float(change_density) / (image.size)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Mean pixel intensity of the image edges\"\n    edges = np.gradient(image)\n    edge_magnitude = np.sqrt(edges[0]**2 + edges[1]**2)\n    return float(np.mean(edge_magnitude))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Sum of pixel intensities in the center column of the image\"\n    h, w = image.shape\n    center_col = image[:, w // 2]\n    return float(np.sum(center_col))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Mean pixel intensity of the diagonal from top-left to bottom-right'\n    diagonal = np.diagonal(image)\n    return float(np.mean(diagonal))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Measure the variance of pixel intensities in the horizontal center strip of the image.\"\n    h, w = image.shape\n    center_strip = image[h//2, :]\n    return float(np.var(center_strip))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of non-zero pixels to total pixels in the image\"\n    total_pixels = image.size\n    non_zero_pixels = np.count_nonzero(image)\n    return float(non_zero_pixels) / total_pixels if total_pixels > 0 else 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Mean pixel intensity of the rightmost quarter of the image.\"\n    w = image.shape[1]\n    right_quarter = image[:, 3*w//4:w]\n    return float(np.mean(right_quarter))\n",
    "def feature(image: np.ndarray) -> float:\n    'Average distance of pixels from the center of the image'\n    h, w = image.shape\n    center_x, center_y = w // 2, h // 2\n    distances = np.sqrt((np.arange(h)[:, None] - center_y) ** 2 + (np.arange(w) - center_x) ** 2)\n    average_distance = np.mean(distances[image > 0])\n    return float(average_distance) if np.count_nonzero(image) > 0 else 0.0\n",
    "def feature(image: np.ndarray) -> float:\n    \"Mean pixel intensity of the rightmost quarter of the image.\"\n    w = image.shape[1]\n    right_quarter = image[:, 3*w//4:w]\n    return float(np.mean(right_quarter))\n",
    "def feature(image: np.ndarray) -> float:\n    \"Standard deviation of pixel intensities in the corner regions\"\n    h, w = image.shape\n    top_left = image[0:h//2, 0:w//2]\n    top_right = image[0:h//2, w//2:w]\n    bottom_left = image[h//2:h, 0:w//2]\n    bottom_right = image[h//2:h, w//2:w]\n    corner_std = np.std([np.std(top_left), np.std(top_right), np.std(bottom_left), np.std(bottom_right)])\n    return float(corner_std)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Count of local maxima in the image based on pixel intensity'\n    gradient = np.gradient(image)\n    local_maxima = np.count_nonzero((gradient[0] > 0) & (np.roll(gradient[0], 1) < 0))\n    return float(local_maxima)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Average distance of pixels from the center of the image'\n    h, w = image.shape\n    center_x, center_y = w // 2, h // 2\n    distances = np.sqrt((np.arange(h)[:, None] - center_y) ** 2 + (np.arange(w) - center_x) ** 2)\n    average_distance = np.mean(distances[image > 0])\n    return float(average_distance) if np.count_nonzero(image) > 0 else 0.0\n",
    "def feature(image: np.ndarray) -> float:\n    \"Calculate the density of pixels in concentric squares from the center\"\n    h, w = image.shape\n    center = (h // 2, w // 2)\n    total_density = 0.0\n    for scale in range(1, 5):\n        square_region = image[center[0] - scale: center[0] + scale + 1, \n                              center[1] - scale: center[1] + scale + 1]\n        total_density += np.count_nonzero(square_region)\n    return total_density\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Count of non-zero pixels in the top quarter of the image\"\n    h, w = image.shape\n    top_quarter = image[:h // 4, :]\n    return float(np.count_nonzero(top_quarter))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Mean pixel intensity of the image margins (top and bottom)\"\n    top_margin = image[:image.shape[0]//10, :]\n    bottom_margin = image[-image.shape[0]//10:, :]\n    return float((np.mean(top_margin) + np.mean(bottom_margin)) / 2)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Count of horizontal edges (variation in pixel intensity) in the image\"\n    gradient_x, gradient_y = np.gradient(image)\n    horizontal_edges = np.sum(np.abs(gradient_y))\n    return float(horizontal_edges)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Count of corners detected in the image using Harris corner detection\"\n    import cv2\n    corners = cv2.cornerHarris(image.astype(np.float32), blockSize=2, ksize=3, k=0.04)\n    return float(np.sum(corners > 0.01 * corners.max()))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Count of horizontal edges (variation in pixel intensity) in the image\"\n    gradient_x, gradient_y = np.gradient(image)\n    horizontal_edges = np.sum(np.abs(gradient_y))\n    return float(horizontal_edges)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Calculate the standard deviation of pixel intensity in the edges (left and right)\"\n    left_edge = image[:, :image.shape[1] // 4]\n    right_edge = image[:, 3 * image.shape[1] // 4:]\n    return float(np.std(np.concatenate((left_edge, right_edge))))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Mean pixel intensity of the horizontal center strip of the image'\n    h, w = image.shape\n    center_strip = image[h // 2 - 1:h // 2 + 1, :]\n    return float(np.mean(center_strip))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Count of corners detected in the image using Harris corner detection\"\n    import cv2\n    corners = cv2.cornerHarris(image.astype(np.float32), blockSize=2, ksize=3, k=0.04)\n    return float(np.sum(corners > 0.01 * corners.max()))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of non-zero pixels in the top quarter to the bottom quarter of the image\"\n    h, w = image.shape\n    top_quarter = image[:h // 4, :]\n    bottom_quarter = image[h * 3 // 4:, :]\n    top_nonzero = np.count_nonzero(top_quarter)\n    bottom_nonzero = np.count_nonzero(bottom_quarter)\n    return float(top_nonzero / (bottom_nonzero + 1e-5))  # Avoid division by zero\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Proportion of diagonal pixels (from top left to bottom right) to total pixels\"\n    h, w = image.shape\n    diagonal_count = min(h, w)\n    diagonal_sum = np.sum(image[np.arange(diagonal_count), np.arange(diagonal_count)])\n    total_sum = np.sum(image)\n    return float(diagonal_sum / total_sum) if total_sum > 0 else 0.0\n",
    "def feature(image: np.ndarray) -> float:\n    \"Horizontal gradient magnitude at the middle row of the image\"\n    grad_x = np.gradient(image, axis=1)\n    return float(np.mean(np.abs(grad_x[image.shape[0] // 2])))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Determine the mean pixel intensity in the top-right quarter of the image.\"\n    h, w = image.shape\n    top_right_quarter = image[:h//2, w//2:]\n    return float(np.mean(top_right_quarter))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Proportion of diagonal pixels (from top left to bottom right) to total pixels\"\n    h, w = image.shape\n    diagonal_count = min(h, w)\n    diagonal_sum = np.sum(image[np.arange(diagonal_count), np.arange(diagonal_count)])\n    total_sum = np.sum(image)\n    return float(diagonal_sum / total_sum) if total_sum > 0 else 0.0\n",
    "def feature(image: np.ndarray) -> float:\n    \"Mean pixel intensity of the image margins (top and bottom)\"\n    top_margin = image[:image.shape[0]//10, :]\n    bottom_margin = image[-image.shape[0]//10:, :]\n    return float((np.mean(top_margin) + np.mean(bottom_margin)) / 2)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Calculate the ratio of the sum of upper half pixel intensities to the sum of the lower half pixel intensities.\"\n    h, w = image.shape\n    upper_half = image[:h//2]\n    lower_half = image[h//2:]\n    upper_sum = np.sum(upper_half)\n    lower_sum = np.sum(lower_half)\n    return upper_sum / (lower_sum + 1e-5)  # Avoid division by zero\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Proportion of diagonal pixels (from top left to bottom right) to total pixels\"\n    h, w = image.shape\n    diagonal_count = min(h, w)\n    diagonal_sum = np.sum(image[np.arange(diagonal_count), np.arange(diagonal_count)])\n    total_sum = np.sum(image)\n    return float(diagonal_sum / total_sum) if total_sum > 0 else 0.0\n",
    "def feature(image: np.ndarray) -> float:\n    \"Determine the sum of pixel values in the top quarter of the image.\"\n    top_quarter = image[:image.shape[0] // 4, :]\n    return float(np.sum(top_quarter))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Average pixel intensity along the horizontal midline of the image\"\n    h, w = image.shape\n    midline = image[h // 2, :]\n    return float(np.mean(midline))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of the sum of pixel intensities in the center region to the total sum of pixel intensities in the image.\"\n    h, w = image.shape\n    center_region = image[h//4:3*h//4, w//4:3*w//4]\n    return float(np.sum(center_region)) / (np.sum(image) + 1e-10)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Number of times intensity peaks (local maxima) in the image array.\"\n    gradient = np.gradient(image)\n    peaks = np.where((gradient[0] > 0) & (np.roll(gradient[0], -1) < 0))[0]\n    return float(len(peaks))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Difference between the mean intensity of the upper and lower halves of the image'\n    h, w = image.shape\n    upper_half_mean = np.mean(image[0:h//2, :])\n    lower_half_mean = np.mean(image[h//2:, :])\n    return float(upper_half_mean - lower_half_mean)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Mean intensity of non-zero pixels in the right half of the image\"\n    right_half = image[:, image.shape[1]//2:]\n    non_zero_intensities = right_half[right_half > 0]\n    return float(np.mean(non_zero_intensities)) if non_zero_intensities.size > 0 else 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Count of non-zero rows in the bottom half of the image\"\n    h, w = image.shape\n    bottom_half = image[h // 2:, :]\n    non_zero_rows = np.count_nonzero(np.any(bottom_half, axis=1))\n    return float(non_zero_rows)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Calculate the ratio of the sum of pixel intensities in the top quarter to the bottom quarter\"\n    top_quarter_sum = np.sum(image[:image.shape[0]//4])\n    bottom_quarter_sum = np.sum(image[3*image.shape[0]//4:])\n    return float(top_quarter_sum / (bottom_quarter_sum + 1e-6))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Count of non-zero rows in the bottom half of the image\"\n    h, w = image.shape\n    bottom_half = image[h // 2:, :]\n    non_zero_rows = np.count_nonzero(np.any(bottom_half, axis=1))\n    return float(non_zero_rows)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Difference in pixel intensity averages of the corners versus the center of the image.\"\n    corners = image[0, 0], image[0, -1], image[-1, 0], image[-1, -1]\n    center_h, center_w = image.shape[0] // 2, image.shape[1] // 2\n    center_region_avg = np.mean(image[center_h-1:center_h+1, center_w-1:center_w+1])\n    corners_avg = np.mean(corners)\n    return float(corners_avg - center_region_avg)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Determine the sum of pixel values in the top quarter of the image.\"\n    top_quarter = image[:image.shape[0] // 4, :]\n    return float(np.sum(top_quarter))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Determine the sum of pixel values in the top quarter of the image.\"\n    top_quarter = image[:image.shape[0] // 4, :]\n    return float(np.sum(top_quarter))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Difference between the mean intensity of the upper and lower halves of the image'\n    h, w = image.shape\n    upper_half_mean = np.mean(image[0:h//2, :])\n    lower_half_mean = np.mean(image[h//2:, :])\n    return float(upper_half_mean - lower_half_mean)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Difference in pixel intensity averages of the corners versus the center of the image.\"\n    corners = image[0, 0], image[0, -1], image[-1, 0], image[-1, -1]\n    center_h, center_w = image.shape[0] // 2, image.shape[1] // 2\n    center_region_avg = np.mean(image[center_h-1:center_h+1, center_w-1:center_w+1])\n    corners_avg = np.mean(corners)\n    return float(corners_avg - center_region_avg)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Calculate the density of pixels in concentric squares from the center\"\n    h, w = image.shape\n    center = (h // 2, w // 2)\n    total_density = 0.0\n    for scale in range(1, 5):\n        square_region = image[center[0] - scale: center[0] + scale + 1, \n                              center[1] - scale: center[1] + scale + 1]\n        total_density += np.count_nonzero(square_region)\n    return total_density\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Count of corners detected in the image using Harris corner detection\"\n    import cv2\n    corners = cv2.cornerHarris(image.astype(np.float32), blockSize=2, ksize=3, k=0.04)\n    return float(np.sum(corners > 0.01 * corners.max()))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Sum of pixel values in the bottom quarter of the image\"\n    h = image.shape[0]\n    bottom_quarter = image[3*h//4:h, :]\n    return float(np.sum(bottom_quarter))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Count of non-zero rows in the bottom half of the image\"\n    h, w = image.shape\n    bottom_half = image[h // 2:, :]\n    non_zero_rows = np.count_nonzero(np.any(bottom_half, axis=1))\n    return float(non_zero_rows)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Count of non-zero rows in the bottom half of the image\"\n    h, w = image.shape\n    bottom_half = image[h // 2:, :]\n    non_zero_rows = np.count_nonzero(np.any(bottom_half, axis=1))\n    return float(non_zero_rows)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Difference in pixel intensity averages of the corners versus the center of the image.\"\n    corners = image[0, 0], image[0, -1], image[-1, 0], image[-1, -1]\n    center_h, center_w = image.shape[0] // 2, image.shape[1] // 2\n    center_region_avg = np.mean(image[center_h-1:center_h+1, center_w-1:center_w+1])\n    corners_avg = np.mean(corners)\n    return float(corners_avg - center_region_avg)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Calculate the density of pixels in concentric squares from the center\"\n    h, w = image.shape\n    center = (h // 2, w // 2)\n    total_density = 0.0\n    for scale in range(1, 5):\n        square_region = image[center[0] - scale: center[0] + scale + 1, \n                              center[1] - scale: center[1] + scale + 1]\n        total_density += np.count_nonzero(square_region)\n    return total_density\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Calculate the image's vertical gradient mean\"\n    gradient = np.gradient(image, axis=0)\n    return float(np.mean(np.abs(gradient)))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Difference between the mean intensity of the upper and lower halves of the image'\n    h, w = image.shape\n    upper_half_mean = np.mean(image[0:h//2, :])\n    lower_half_mean = np.mean(image[h//2:, :])\n    return float(upper_half_mean - lower_half_mean)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Count of non-zero rows in the bottom half of the image\"\n    h, w = image.shape\n    bottom_half = image[h // 2:, :]\n    non_zero_rows = np.count_nonzero(np.any(bottom_half, axis=1))\n    return float(non_zero_rows)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Calculate the edge magnitude in the image using Sobel filter\"\n    sobel_x = np.array([[1, 0, -1], [2, 0, -2], [1, 0, -1]])\n    sobel_y = np.array([[1, 2, 1], [0, 0, 0], [-1, -2, -1]])\n    gradient_x = np.abs(np.convolve(image.flatten(), sobel_x.flatten(), mode='same').reshape(image.shape))\n    gradient_y = np.abs(np.convolve(image.flatten(), sobel_y.flatten(), mode='same').reshape(image.shape))\n    return float(np.mean(gradient_x + gradient_y))\n",
    "def feature(image: np.ndarray) -> float:\n    \"Count of corners detected in the image using Harris corner detection\"\n    import cv2\n    corners = cv2.cornerHarris(image.astype(np.float32), blockSize=2, ksize=3, k=0.04)\n    return float(np.sum(corners > 0.01 * corners.max()))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Count of horizontal edges (variation in pixel intensity) in the image\"\n    gradient_x, gradient_y = np.gradient(image)\n    horizontal_edges = np.sum(np.abs(gradient_y))\n    return float(horizontal_edges)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Difference in average intensity between the left and right halves of the image\"\n    h, w = image.shape\n    left_half = image[:, :w // 2]\n    right_half = image[:, w // 2:]\n    return float(np.mean(left_half) - np.mean(right_half))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Count of corners detected in the image using Harris corner detection\"\n    import cv2\n    corners = cv2.cornerHarris(image.astype(np.float32), blockSize=2, ksize=3, k=0.04)\n    return float(np.sum(corners > 0.01 * corners.max()))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Count of non-zero pixels in the top third of the image.\"\n    h, w = image.shape\n    top_third = image[:h//3, :]\n    return float(np.count_nonzero(top_third))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Mean pixel intensity in the left quarter of the image\"\n    left_quarter = image[:, :image.shape[1] // 4]\n    return float(np.mean(left_quarter))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Count of corners detected in the image using Harris corner detection\"\n    import cv2\n    corners = cv2.cornerHarris(image.astype(np.float32), blockSize=2, ksize=3, k=0.04)\n    return float(np.sum(corners > 0.01 * corners.max()))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Count of non-zero rows in the bottom half of the image\"\n    h, w = image.shape\n    bottom_half = image[h // 2:, :]\n    non_zero_rows = np.count_nonzero(np.any(bottom_half, axis=1))\n    return float(non_zero_rows)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Count of non-zero rows in the bottom half of the image\"\n    h, w = image.shape\n    bottom_half = image[h // 2:, :]\n    non_zero_rows = np.count_nonzero(np.any(bottom_half, axis=1))\n    return float(non_zero_rows)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Compute the row-wise sum of pixel intensities and return the maximum value\"\n    return float(np.max(np.sum(image, axis=1)))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Count of non-zero rows in the bottom half of the image\"\n    h, w = image.shape\n    bottom_half = image[h // 2:, :]\n    non_zero_rows = np.count_nonzero(np.any(bottom_half, axis=1))\n    return float(non_zero_rows)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Ratio of non-zero pixels in the top quarter to the image height'\n    top_quarter = image[:image.shape[0]//4, :]\n    count_non_zero_top = np.count_nonzero(top_quarter)\n    total_non_zero = np.count_nonzero(image)\n    return count_non_zero_top / total_non_zero if total_non_zero > 0 else 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Count of non-zero rows in the bottom half of the image\"\n    h, w = image.shape\n    bottom_half = image[h // 2:, :]\n    non_zero_rows = np.count_nonzero(np.any(bottom_half, axis=1))\n    return float(non_zero_rows)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Calculate the image's vertical gradient mean\"\n    gradient = np.gradient(image, axis=0)\n    return float(np.mean(np.abs(gradient)))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Count of corners detected in the image using Harris corner detection\"\n    import cv2\n    corners = cv2.cornerHarris(image.astype(np.float32), blockSize=2, ksize=3, k=0.04)\n    return float(np.sum(corners > 0.01 * corners.max()))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Count of non-zero pixels in the top quarter of the image\"\n    h, w = image.shape\n    top_quarter = image[:h // 4, :]\n    return float(np.count_nonzero(top_quarter))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of non-zero pixels to total pixels in the image\"\n    total_pixels = image.size\n    non_zero_pixels = np.count_nonzero(image)\n    return float(non_zero_pixels) / total_pixels if total_pixels > 0 else 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of non-zero pixels to total pixels in the image\"\n    total_pixels = image.size\n    non_zero_pixels = np.count_nonzero(image)\n    return float(non_zero_pixels) / total_pixels if total_pixels > 0 else 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of non-zero pixels to total pixels in the image\"\n    total_pixels = image.size\n    non_zero_pixels = np.count_nonzero(image)\n    return float(non_zero_pixels) / total_pixels if total_pixels > 0 else 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of non-zero pixels to total pixels in the image\"\n    total_pixels = image.size\n    non_zero_pixels = np.count_nonzero(image)\n    return float(non_zero_pixels) / total_pixels if total_pixels > 0 else 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of non-zero pixels to total pixels in the image\"\n    total_pixels = image.size\n    non_zero_pixels = np.count_nonzero(image)\n    return float(non_zero_pixels) / total_pixels if total_pixels > 0 else 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of non-zero pixels to total pixels in the image\"\n    total_pixels = image.size\n    non_zero_pixels = np.count_nonzero(image)\n    return float(non_zero_pixels) / total_pixels if total_pixels > 0 else 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Count of non-zero pixels in the central horizontal band of the image\"\n    try:\n        h, w = image.shape\n        center_band = image[h//2, :]\n        return float(np.count_nonzero(center_band))\n    except Exception as e:\n        return 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Count of horizontal lines detected in the image using gradient\"\n    gradient = np.gradient(image, axis=0)\n    horizontal_lines = np.sum(np.abs(gradient) > 50)  # Threshold to count significant horizontal edges\n    return float(horizontal_lines)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Difference in pixel intensity averages of the corners versus the center of the image.\"\n    corners = image[0, 0], image[0, -1], image[-1, 0], image[-1, -1]\n    center_h, center_w = image.shape[0] // 2, image.shape[1] // 2\n    center_region_avg = np.mean(image[center_h-1:center_h+1, center_w-1:center_w+1])\n    corners_avg = np.mean(corners)\n    return float(corners_avg - center_region_avg)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Count the number of vertical edges (maximum differences between adjacent columns).\"\n    vertical_edges = np.sum(np.abs(np.diff(image, axis=1)) > 20)\n    return float(vertical_edges)\n",
    "def feature(image: np.ndarray) -> float:\n    \"Sum of pixel values in the bottom quarter of the image\"\n    h = image.shape[0]\n    bottom_quarter = image[3*h//4:h, :]\n    return float(np.sum(bottom_quarter))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Edge pixel count based on gradient magnitude threshold\"\n    gx, gy = np.gradient(image)\n    gradient_magnitude = np.sqrt(gx**2 + gy**2)\n    edge_pixel_count = np.count_nonzero(gradient_magnitude > 50)\n    return float(edge_pixel_count)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Difference in mean intensity between the left and right edges\"\n    left_edge = image[:, :10]\n    right_edge = image[:, -10:]\n    return float(np.mean(left_edge) - np.mean(right_edge))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of non-zero pixels to total pixels in the image\"\n    total_pixels = image.size\n    non_zero_pixels = np.count_nonzero(image)\n    return float(non_zero_pixels) / total_pixels if total_pixels > 0 else 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of non-zero pixels to total pixels in the image\"\n    total_pixels = image.size\n    non_zero_pixels = np.count_nonzero(image)\n    return float(non_zero_pixels) / total_pixels if total_pixels > 0 else 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of non-zero pixels to total pixels in the image\"\n    total_pixels = image.size\n    non_zero_pixels = np.count_nonzero(image)\n    return float(non_zero_pixels) / total_pixels if total_pixels > 0 else 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of non-zero pixels to total pixels in the image\"\n    total_pixels = image.size\n    non_zero_pixels = np.count_nonzero(image)\n    return float(non_zero_pixels) / total_pixels if total_pixels > 0 else 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of non-zero pixels to total pixels in the image\"\n    total_pixels = image.size\n    non_zero_pixels = np.count_nonzero(image)\n    return float(non_zero_pixels) / total_pixels if total_pixels > 0 else 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of non-zero pixels to total pixels in the image\"\n    total_pixels = image.size\n    non_zero_pixels = np.count_nonzero(image)\n    return float(non_zero_pixels) / total_pixels if total_pixels > 0 else 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of non-zero pixels to total pixels in the image\"\n    total_pixels = image.size\n    non_zero_pixels = np.count_nonzero(image)\n    return float(non_zero_pixels) / total_pixels if total_pixels > 0 else 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of non-zero pixels to total pixels in the image\"\n    total_pixels = image.size\n    non_zero_pixels = np.count_nonzero(image)\n    return float(non_zero_pixels) / total_pixels if total_pixels > 0 else 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of pixel intensity in the top left quarter to bottom right quarter of the image\"\n    try:\n        top_left = image[:image.shape[0] // 2, :image.shape[1] // 2]\n        bottom_right = image[image.shape[0] // 2:, image.shape[1] // 2:]\n        return float(np.mean(top_left) / np.mean(bottom_right))\n    except Exception as e:\n        return 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Calculate the difference in mean intensities between the upper and lower quarter regions'\n    upper_quarter = image[:image.shape[0]//4, :]\n    lower_quarter = image[3*image.shape[0]//4:, :]\n    return float(np.mean(upper_quarter) - np.mean(lower_quarter))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Horizontal gradient magnitude at the middle row of the image\"\n    grad_x = np.gradient(image, axis=1)\n    return float(np.mean(np.abs(grad_x[image.shape[0] // 2])))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Total count of pixels located in the middle third of the image\"\n    h, w = image.shape\n    mid_start_h = h // 3\n    mid_end_h = 2 * h // 3\n    mid_region = image[mid_start_h:mid_end_h]\n    return float(np.count_nonzero(mid_region))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of non-zero pixels to total pixels in the image\"\n    total_pixels = image.size\n    non_zero_pixels = np.count_nonzero(image)\n    return float(non_zero_pixels) / total_pixels if total_pixels > 0 else 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Compute the row-wise sum of pixel intensities and return the maximum value\"\n    return float(np.max(np.sum(image, axis=1)))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Count of diagonal edge pixels in the image based on gradient'\n    gradient = np.gradient(image)\n    diagonal_edges = np.sum(np.abs(gradient[0] + gradient[1]) > 10)\n    return float(diagonal_edges)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of non-zero pixels to total pixels in the image\"\n    total_pixels = image.size\n    non_zero_pixels = np.count_nonzero(image)\n    return float(non_zero_pixels) / total_pixels if total_pixels > 0 else 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of non-zero pixels to total pixels in the image\"\n    total_pixels = image.size\n    non_zero_pixels = np.count_nonzero(image)\n    return float(non_zero_pixels) / total_pixels if total_pixels > 0 else 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Proportion of white pixels (pixel value 255) to non-zero pixels in the image'\n    white_pixel_count = np.count_nonzero(image==255)\n    non_zero_pixel_count = np.count_nonzero(image)\n    ratio = white_pixel_count / (non_zero_pixel_count + 1e-5)  # Adding small value to avoid division by zero\n    return float(ratio)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Count of horizontal edges (variation in pixel intensity) in the image\"\n    gradient_x, gradient_y = np.gradient(image)\n    horizontal_edges = np.sum(np.abs(gradient_y))\n    return float(horizontal_edges)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of non-zero pixels to total pixels in the image\"\n    total_pixels = image.size\n    non_zero_pixels = np.count_nonzero(image)\n    return float(non_zero_pixels) / total_pixels if total_pixels > 0 else 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Count of corners detected in the image using Harris corner detection\"\n    import cv2\n    corners = cv2.cornerHarris(image.astype(np.float32), blockSize=2, ksize=3, k=0.04)\n    return float(np.sum(corners > 0.01 * corners.max()))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of the number of vertical edges to the total number of edges.\"\n    gradient = np.gradient(image)\n    vertical_edges = np.count_nonzero(gradient[1])  # Vertical gradient count\n    total_edges = np.count_nonzero(gradient)\n    return float(vertical_edges) / float(total_edges) if total_edges > 0 else 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Count of non-zero columns in the image\"\n    non_zero_columns = np.count_nonzero(np.sum(image, axis=0))\n    return float(non_zero_columns)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Count of distinct pixel values in the image\"\n    unique_values = np.unique(image)\n    return float(len(unique_values))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of non-zero pixels to total pixels in the image\"\n    total_pixels = image.size\n    non_zero_pixels = np.count_nonzero(image)\n    return float(non_zero_pixels) / total_pixels if total_pixels > 0 else 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of non-zero pixels to total pixels in the image\"\n    total_pixels = image.size\n    non_zero_pixels = np.count_nonzero(image)\n    return float(non_zero_pixels) / total_pixels if total_pixels > 0 else 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of non-zero pixels to total pixels in the image\"\n    total_pixels = image.size\n    non_zero_pixels = np.count_nonzero(image)\n    return float(non_zero_pixels) / total_pixels if total_pixels > 0 else 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of non-zero pixels to total pixels in the image\"\n    total_pixels = image.size\n    non_zero_pixels = np.count_nonzero(image)\n    return float(non_zero_pixels) / total_pixels if total_pixels > 0 else 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Count of vertical edges detected in the image using Sobel filter'\n    sobel_x = np.array([[-1, 0, 1], [-2, 0, 2], [-1, 0, 1]])\n    edges = np.abs(np.convolve(image.flatten(), sobel_x.flatten(), 'same'))\n    return float(np.count_nonzero(edges))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Standard deviation of pixel intensities in the image's upper right quadrant\"\n    h, w = image.shape\n    upper_right = image[0:h//2, w//2:]\n    return float(np.std(upper_right))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Average width of white contours in the image'\n    thresholded = np.where(image > 150, 1, 0)\n    contours = np.sum(thresholded, axis=0)\n    return float(np.mean(contours[contours > 0])) if np.any(contours > 0) else 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Count of peaks in the histogram of pixel intensities'\n    histogram, _ = np.histogram(image, bins=256)\n    return float(np.sum(histogram > np.mean(histogram)))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Difference in pixel intensity averages of the corners versus the center of the image.\"\n    corners = image[0, 0], image[0, -1], image[-1, 0], image[-1, -1]\n    center_h, center_w = image.shape[0] // 2, image.shape[1] // 2\n    center_region_avg = np.mean(image[center_h-1:center_h+1, center_w-1:center_w+1])\n    corners_avg = np.mean(corners)\n    return float(corners_avg - center_region_avg)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'High-frequency content measure using mean of gradients'\n    gradients = np.abs(np.gradient(image))\n    return float(np.mean(gradients[0]) + np.mean(gradients[1]))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of non-zero pixels to total pixels in the image\"\n    total_pixels = image.size\n    non_zero_pixels = np.count_nonzero(image)\n    return float(non_zero_pixels) / total_pixels if total_pixels > 0 else 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Average pixel intensity in the top third of the image\"\n    h, w = image.shape\n    top_third = image[:h//3, :]\n    return float(np.mean(top_third))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Mean gradient magnitude around the corners of the image\"\n    corners = image[0:10, 0:10]  # Top left corner\n    corners = np.concatenate((corners, image[0:10, -10:]))  # Top right corner\n    corners = np.concatenate((corners, image[-10:, 0:10]))  # Bottom left corner\n    corners = np.concatenate((corners, image[-10:, -10:]))  # Bottom right corner\n    gx, gy = np.gradient(corners.astype(float))\n    corner_gradient_magnitude = np.sqrt(gx**2 + gy**2)\n    return float(np.mean(corner_gradient_magnitude))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Count of non-zero pixels in the top and bottom halves of the image'\n    h, w = image.shape\n    top_half = np.count_nonzero(image[:h//2])\n    bottom_half = np.count_nonzero(image[h//2:])\n    return float(top_half - bottom_half)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of non-zero pixels to total pixels in the image\"\n    total_pixels = image.size\n    non_zero_pixels = np.count_nonzero(image)\n    return float(non_zero_pixels) / total_pixels if total_pixels > 0 else 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Percentage of non-zero pixels in the bottom quarter of the image\"\n    h, w = image.shape\n    bottom_quarter = image[3*h//4:, :]\n    non_zero_count = np.count_nonzero(bottom_quarter)\n    total_count = bottom_quarter.size\n    return non_zero_count / total_count if total_count > 0 else 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Ratio of non-zero pixels in the upper left quadrant to the upper right quadrant'\n    h, w = image.shape\n    upper_left = np.count_nonzero(image[:h // 2, :w // 2])\n    upper_right = np.count_nonzero(image[:h // 2, w // 2:])\n    return float(upper_left) / (upper_right + 1e-6)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Mean pixel intensity of the horizontal center strip of the image'\n    h, w = image.shape\n    center_strip = image[h // 2 - 1:h // 2 + 1, :]\n    return float(np.mean(center_strip))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Count of local maxima in the image based on pixel intensity'\n    gradient = np.gradient(image)\n    local_maxima = np.count_nonzero((gradient[0] > 0) & (np.roll(gradient[0], 1) < 0))\n    return float(local_maxima)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Proportion of diagonal pixels (from top left to bottom right) to total pixels\"\n    h, w = image.shape\n    diagonal_count = min(h, w)\n    diagonal_sum = np.sum(image[np.arange(diagonal_count), np.arange(diagonal_count)])\n    total_sum = np.sum(image)\n    return float(diagonal_sum / total_sum) if total_sum > 0 else 0.0\n",
    "def feature(image: np.ndarray) -> float:\n    'Ratio of the number of non-zero pixels in the bottom third to total non-zero pixels in the image'\n    h, w = image.shape\n    bottom_third = image[2*h//3:, :]\n    total_non_zero = np.count_nonzero(image)\n    non_zero_bottom = np.count_nonzero(bottom_third)\n    return float(non_zero_bottom / total_non_zero) if total_non_zero > 0 else 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Ratio of the number of non-zero pixels in the bottom third to total non-zero pixels in the image'\n    h, w = image.shape\n    bottom_third = image[2*h//3:, :]\n    total_non_zero = np.count_nonzero(image)\n    non_zero_bottom = np.count_nonzero(bottom_third)\n    return float(non_zero_bottom / total_non_zero) if total_non_zero > 0 else 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Difference in average intensity between the left and right halves of the image\"\n    h, w = image.shape\n    left_half = image[:, :w // 2]\n    right_half = image[:, w // 2:]\n    return float(np.mean(left_half) - np.mean(right_half))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Difference in pixel intensity averages of the corners versus the center of the image.\"\n    corners = image[0, 0], image[0, -1], image[-1, 0], image[-1, -1]\n    center_h, center_w = image.shape[0] // 2, image.shape[1] // 2\n    center_region_avg = np.mean(image[center_h-1:center_h+1, center_w-1:center_w+1])\n    corners_avg = np.mean(corners)\n    return float(corners_avg - center_region_avg)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Ratio of the number of non-zero pixels in the bottom third to total non-zero pixels in the image'\n    h, w = image.shape\n    bottom_third = image[2*h//3:, :]\n    total_non_zero = np.count_nonzero(image)\n    non_zero_bottom = np.count_nonzero(bottom_third)\n    return float(non_zero_bottom / total_non_zero) if total_non_zero > 0 else 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Mean pixel intensity of the image margins (top and bottom)\"\n    top_margin = image[:image.shape[0]//10, :]\n    bottom_margin = image[-image.shape[0]//10:, :]\n    return float((np.mean(top_margin) + np.mean(bottom_margin)) / 2)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Difference in pixel intensity averages of the corners versus the center of the image.\"\n    corners = image[0, 0], image[0, -1], image[-1, 0], image[-1, -1]\n    center_h, center_w = image.shape[0] // 2, image.shape[1] // 2\n    center_region_avg = np.mean(image[center_h-1:center_h+1, center_w-1:center_w+1])\n    corners_avg = np.mean(corners)\n    return float(corners_avg - center_region_avg)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Variance of pixel intensities in the edge regions of the image\"\n    h, w = image.shape\n    edge_region = np.concatenate((image[:h//4, :], image[3*h//4:, :]))\n    return float(np.var(edge_region))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Measure the linearity of the pixel intensity profile along the rows of the image\"\n    profile = np.mean(image, axis=1)\n    return float(np.std(np.gradient(profile)))\n",
    "def feature(image: np.ndarray) -> float:\n    \"Mean pixel intensity of the image margins (top and bottom)\"\n    top_margin = image[:image.shape[0]//10, :]\n    bottom_margin = image[-image.shape[0]//10:, :]\n    return float((np.mean(top_margin) + np.mean(bottom_margin)) / 2)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Count of non-zero rows in the bottom half of the image\"\n    h, w = image.shape\n    bottom_half = image[h // 2:, :]\n    non_zero_rows = np.count_nonzero(np.any(bottom_half, axis=1))\n    return float(non_zero_rows)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Difference in pixel intensity averages of the corners versus the center of the image.\"\n    corners = image[0, 0], image[0, -1], image[-1, 0], image[-1, -1]\n    center_h, center_w = image.shape[0] // 2, image.shape[1] // 2\n    center_region_avg = np.mean(image[center_h-1:center_h+1, center_w-1:center_w+1])\n    corners_avg = np.mean(corners)\n    return float(corners_avg - center_region_avg)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Compute the row-wise sum of pixel intensities and return the maximum value\"\n    return float(np.max(np.sum(image, axis=1)))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Gradient magnitude average difference between left and right halves of the image\"\n    gradients = np.gradient(image)\n    left_gradient_magnitude = np.mean(np.sqrt(gradients[0][:, :image.shape[1]//2]**2 + gradients[1][:, :image.shape[1]//2]**2))\n    right_gradient_magnitude = np.mean(np.sqrt(gradients[0][:, image.shape[1]//2:]**2 + gradients[1][:, image.shape[1]//2:]**2))\n    return float(left_gradient_magnitude - right_gradient_magnitude)\n",
    "def feature(image: np.ndarray) -> float:\n    'Measure the density of edges within a certain distance from the center.'\n    h, w = image.shape\n    center_region = image[h//4:3*h//4, w//4:3*w//4]\n    edges = np.gradient(center_region)\n    edge_density = np.count_nonzero(edges[0]) + np.count_nonzero(edges[1])\n    return float(edge_density)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Gradient magnitude average difference between left and right halves of the image\"\n    gradients = np.gradient(image)\n    left_gradient_magnitude = np.mean(np.sqrt(gradients[0][:, :image.shape[1]//2]**2 + gradients[1][:, :image.shape[1]//2]**2))\n    right_gradient_magnitude = np.mean(np.sqrt(gradients[0][:, image.shape[1]//2:]**2 + gradients[1][:, image.shape[1]//2:]**2))\n    return float(left_gradient_magnitude - right_gradient_magnitude)\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of pixel intensity variance between left and right halves of the image\"\n    left_half = image[:, :image.shape[1] // 2]\n    right_half = image[:, image.shape[1] // 2:]\n    return float(np.var(left_half) / (np.var(right_half) + 1e-6))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Ratio of the number of non-zero pixels in the bottom third to total non-zero pixels in the image'\n    h, w = image.shape\n    bottom_third = image[2*h//3:, :]\n    total_non_zero = np.count_nonzero(image)\n    non_zero_bottom = np.count_nonzero(bottom_third)\n    return float(non_zero_bottom / total_non_zero) if total_non_zero > 0 else 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Ratio of the number of non-zero pixels in the bottom third to total non-zero pixels in the image'\n    h, w = image.shape\n    bottom_third = image[2*h//3:, :]\n    total_non_zero = np.count_nonzero(image)\n    non_zero_bottom = np.count_nonzero(bottom_third)\n    return float(non_zero_bottom / total_non_zero) if total_non_zero > 0 else 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Count of horizontal edges (variation in pixel intensity) in the image\"\n    gradient_x, gradient_y = np.gradient(image)\n    horizontal_edges = np.sum(np.abs(gradient_y))\n    return float(horizontal_edges)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Horizontal gradient magnitude at the middle row of the image\"\n    grad_x = np.gradient(image, axis=1)\n    return float(np.mean(np.abs(grad_x[image.shape[0] // 2])))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Count of local maxima in the image based on pixel intensity'\n    gradient = np.gradient(image)\n    local_maxima = np.count_nonzero((gradient[0] > 0) & (np.roll(gradient[0], 1) < 0))\n    return float(local_maxima)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Proportion of pixels in the center region compared to the entire image\"\n    h, w = image.shape\n    center_region = image[h//4:3*h//4, w//4:3*w//4]\n    pixel_count = np.count_nonzero(image)\n    center_pixel_count = np.count_nonzero(center_region)\n    return float(center_pixel_count / pixel_count) if pixel_count > 0 else 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Ratio of the number of non-zero pixels in the bottom third to total non-zero pixels in the image'\n    h, w = image.shape\n    bottom_third = image[2*h//3:, :]\n    total_non_zero = np.count_nonzero(image)\n    non_zero_bottom = np.count_nonzero(bottom_third)\n    return float(non_zero_bottom / total_non_zero) if total_non_zero > 0 else 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Calculate the ratio of non-zero pixels in the left quarter to the right quarter'\n    left_quarter = image[:, :image.shape[1] // 4]\n    right_quarter = image[:, 3*image.shape[1] // 4:]\n    non_zero_left = np.count_nonzero(left_quarter)\n    non_zero_right = np.count_nonzero(right_quarter)\n    return float(non_zero_left / (non_zero_right + 1e-10))  # Avoid division by zero\n",
    "def feature(image: np.ndarray) -> float:\n    \"Average pixel intensity along the horizontal midline of the image\"\n    h, w = image.shape\n    midline = image[h // 2, :]\n    return float(np.mean(midline))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of horizontal pixel gradients to vertical pixel gradients\"\n    gradient_x, gradient_y = np.gradient(image)\n    horizontal_gradient = np.sum(np.abs(gradient_y))\n    vertical_gradient = np.sum(np.abs(gradient_x))\n    return horizontal_gradient / (vertical_gradient + 1e-5)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Calculate the standard deviation of pixel intensities in the outer margins of the image.'\n    h, w = image.shape\n    top_margin = image[0:h//8, :]\n    bottom_margin = image[7*h//8:h, :]\n    outer_margins = np.concatenate((top_margin, bottom_margin), axis=0)\n    return float(np.std(outer_margins))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of pixel intensity variance between left and right halves of the image\"\n    left_half = image[:, :image.shape[1] // 2]\n    right_half = image[:, image.shape[1] // 2:]\n    return float(np.var(left_half) / (np.var(right_half) + 1e-6))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Sharpness of the image calculated as the standard deviation of pixel differences\"\n    gradient = np.gradient(image)\n    sharpness = np.std(np.abs(gradient[0]) + np.abs(gradient[1]))\n    return float(sharpness)\n",
    "def feature(image: np.ndarray) -> float:\n    \"Mean pixel intensity of the image margins (top and bottom)\"\n    top_margin = image[:image.shape[0]//10, :]\n    bottom_margin = image[-image.shape[0]//10:, :]\n    return float((np.mean(top_margin) + np.mean(bottom_margin)) / 2)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Count of non-zero rows in the bottom half of the image\"\n    h, w = image.shape\n    bottom_half = image[h // 2:, :]\n    non_zero_rows = np.count_nonzero(np.any(bottom_half, axis=1))\n    return float(non_zero_rows)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Mean pixel intensity of the horizontal center strip of the image'\n    h, w = image.shape\n    center_strip = image[h // 2 - 1:h // 2 + 1, :]\n    return float(np.mean(center_strip))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Calculate the ratio of non-zero pixels in the lower half of the image to the total non-zero pixels.\"\n    h, w = image.shape\n    lower_half = image[h//2:, :]\n    total_non_zero = np.count_nonzero(image)\n    lower_non_zero = np.count_nonzero(lower_half)\n    return float(lower_non_zero / total_non_zero) if total_non_zero > 0 else 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Count of non-zero rows in the bottom half of the image\"\n    h, w = image.shape\n    bottom_half = image[h // 2:, :]\n    non_zero_rows = np.count_nonzero(np.any(bottom_half, axis=1))\n    return float(non_zero_rows)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Ratio of the number of non-zero pixels in the bottom third to total non-zero pixels in the image'\n    h, w = image.shape\n    bottom_third = image[2*h//3:, :]\n    total_non_zero = np.count_nonzero(image)\n    non_zero_bottom = np.count_nonzero(bottom_third)\n    return float(non_zero_bottom / total_non_zero) if total_non_zero > 0 else 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Average pixel intensity in the top third of the image\"\n    h, w = image.shape\n    top_third = image[:h//3, :]\n    return float(np.mean(top_third))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Proportion of diagonal pixels (from top left to bottom right) to total pixels\"\n    h, w = image.shape\n    diagonal_count = min(h, w)\n    diagonal_sum = np.sum(image[np.arange(diagonal_count), np.arange(diagonal_count)])\n    total_sum = np.sum(image)\n    return float(diagonal_sum / total_sum) if total_sum > 0 else 0.0\n",
    "def feature(image: np.ndarray) -> float:\n    \"Horizontal gradient magnitude at the middle row of the image\"\n    grad_x = np.gradient(image, axis=1)\n    return float(np.mean(np.abs(grad_x[image.shape[0] // 2])))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of pixel intensity variance between left and right halves of the image\"\n    left_half = image[:, :image.shape[1] // 2]\n    right_half = image[:, image.shape[1] // 2:]\n    return float(np.var(left_half) / (np.var(right_half) + 1e-6))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Count of non-zero rows in the bottom half of the image\"\n    h, w = image.shape\n    bottom_half = image[h // 2:, :]\n    non_zero_rows = np.count_nonzero(np.any(bottom_half, axis=1))\n    return float(non_zero_rows)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Compute the row-wise sum of pixel intensities and return the maximum value\"\n    return float(np.max(np.sum(image, axis=1)))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Average distance of pixels from the center of the image'\n    h, w = image.shape\n    center_x, center_y = w // 2, h // 2\n    distances = np.sqrt((np.arange(h)[:, None] - center_y) ** 2 + (np.arange(w) - center_x) ** 2)\n    average_distance = np.mean(distances[image > 0])\n    return float(average_distance) if np.count_nonzero(image) > 0 else 0.0\n",
    "def feature(image: np.ndarray) -> float:\n    \"Maximum pixel count in a single row\"\n    return float(np.max(np.count_nonzero(image, axis=1)))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Ratio of the number of non-zero pixels in the bottom third to total non-zero pixels in the image'\n    h, w = image.shape\n    bottom_third = image[2*h//3:, :]\n    total_non_zero = np.count_nonzero(image)\n    non_zero_bottom = np.count_nonzero(bottom_third)\n    return float(non_zero_bottom / total_non_zero) if total_non_zero > 0 else 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Percentage of non-zero pixels in the bottom quarter of the image\"\n    h, w = image.shape\n    bottom_quarter = image[3*h//4:, :]\n    non_zero_count = np.count_nonzero(bottom_quarter)\n    total_count = bottom_quarter.size\n    return non_zero_count / total_count if total_count > 0 else 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Sharpness of the image calculated as the standard deviation of pixel differences\"\n    gradient = np.gradient(image)\n    sharpness = np.std(np.abs(gradient[0]) + np.abs(gradient[1]))\n    return float(sharpness)\n",
    "def feature(image: np.ndarray) -> float:\n    'Ratio of bright pixels in the top quarter of the image to the bottom quarter'\n    h, w = image.shape\n    top_quarter = image[:h//4, :]\n    bottom_quarter = image[3*h//4:, :]\n    bright_top = np.count_nonzero(top_quarter > 128)\n    bright_bottom = np.count_nonzero(bottom_quarter > 128)\n    return float(bright_top / (bright_bottom + 1e-5))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Variance of pixel intensities around the image center\"\n    h, w = image.shape\n    center_h, center_w = h // 2, w // 2\n    center_region = image[center_h-1:center_h+2, center_w-1:center_w+2]\n    return float(np.var(center_region))\n",
    "def feature(image: np.ndarray) -> float:\n    \"Distributed count of diagonally oriented pixels (anti-diagonal)\"\n    anti_diagonal_count = np.count_nonzero(np.diag(image[::-1]))\n    return float(anti_diagonal_count)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Ratio of the number of non-zero pixels in the bottom third to total non-zero pixels in the image'\n    h, w = image.shape\n    bottom_third = image[2*h//3:, :]\n    total_non_zero = np.count_nonzero(image)\n    non_zero_bottom = np.count_nonzero(bottom_third)\n    return float(non_zero_bottom / total_non_zero) if total_non_zero > 0 else 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Standard deviation of pixel intensities in the right third of the image'\n    h, w = image.shape\n    right_third = image[:, 2 * w // 3:]\n    return float(np.std(right_third))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Standard deviation of pixel intensities in the whole image\"\n    return float(np.std(image))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Average pixel intensity of the bottom third of the image.\"\n    h, w = image.shape\n    bottom_third = image[2*h//3:h]\n    return float(np.mean(bottom_third))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of horizontal pixel gradients to vertical pixel gradients\"\n    gradient_x, gradient_y = np.gradient(image)\n    horizontal_gradient = np.sum(np.abs(gradient_y))\n    vertical_gradient = np.sum(np.abs(gradient_x))\n    return horizontal_gradient / (vertical_gradient + 1e-5)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Proportion of pixels in the center region compared to the entire image\"\n    h, w = image.shape\n    center_region = image[h//4:3*h//4, w//4:3*w//4]\n    pixel_count = np.count_nonzero(image)\n    center_pixel_count = np.count_nonzero(center_region)\n    return float(center_pixel_count / pixel_count) if pixel_count > 0 else 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Standard deviation of pixel intensities in the lower outer margins of the image'\n    h, w = image.shape\n    lower_outer_margin = np.concatenate((image[h // 2:, :w // 4], image[h // 2:, 3*w // 4:]), axis=1)\n    return float(np.std(lower_outer_margin))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Distributed count of diagonally oriented pixels (anti-diagonal)\"\n    anti_diagonal_count = np.count_nonzero(np.diag(image[::-1]))\n    return float(anti_diagonal_count)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Ratio of the number of non-zero pixels in the bottom third to total non-zero pixels in the image'\n    h, w = image.shape\n    bottom_third = image[2*h//3:, :]\n    total_non_zero = np.count_nonzero(image)\n    non_zero_bottom = np.count_nonzero(bottom_third)\n    return float(non_zero_bottom / total_non_zero) if total_non_zero > 0 else 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of non-zero pixel count in the middle third to the total non-zero pixels\"\n    h, w = image.shape\n    middle_region = image[h // 3:2 * h // 3, :]\n    non_zero_middle = np.count_nonzero(middle_region)\n    total_non_zero = np.count_nonzero(image)\n    return float(non_zero_middle / total_non_zero) if total_non_zero > 0 else 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Calculate the density of pixels in concentric squares from the center\"\n    h, w = image.shape\n    center = (h // 2, w // 2)\n    total_density = 0.0\n    for scale in range(1, 5):\n        square_region = image[center[0] - scale: center[0] + scale + 1, \n                              center[1] - scale: center[1] + scale + 1]\n        total_density += np.count_nonzero(square_region)\n    return total_density\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of non-zero pixel count in the middle third to the total non-zero pixels\"\n    h, w = image.shape\n    middle_region = image[h // 3:2 * h // 3, :]\n    non_zero_middle = np.count_nonzero(middle_region)\n    total_non_zero = np.count_nonzero(image)\n    return float(non_zero_middle / total_non_zero) if total_non_zero > 0 else 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Ratio of the number of non-zero pixels in the bottom third to total non-zero pixels in the image'\n    h, w = image.shape\n    bottom_third = image[2*h//3:, :]\n    total_non_zero = np.count_nonzero(image)\n    non_zero_bottom = np.count_nonzero(bottom_third)\n    return float(non_zero_bottom / total_non_zero) if total_non_zero > 0 else 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Ratio of the number of non-zero pixels in the bottom third to total non-zero pixels in the image'\n    h, w = image.shape\n    bottom_third = image[2*h//3:, :]\n    total_non_zero = np.count_nonzero(image)\n    non_zero_bottom = np.count_nonzero(bottom_third)\n    return float(non_zero_bottom / total_non_zero) if total_non_zero > 0 else 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of non-zero pixel count in the middle third to the total non-zero pixels\"\n    h, w = image.shape\n    middle_region = image[h // 3:2 * h // 3, :]\n    non_zero_middle = np.count_nonzero(middle_region)\n    total_non_zero = np.count_nonzero(image)\n    return float(non_zero_middle / total_non_zero) if total_non_zero > 0 else 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Gradient magnitude in the center region of the image'\n    h, w = image.shape\n    center_h, center_w = h // 4, w // 4\n    center_region = image[center_h:3*center_h, center_w:3*center_w]\n    grad_x, grad_y = np.gradient(center_region.astype(float))\n    return float(np.mean(np.sqrt(grad_x**2 + grad_y**2)))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Difference in pixel intensity averages of the corners versus the center of the image.\"\n    corners = image[0, 0], image[0, -1], image[-1, 0], image[-1, -1]\n    center_h, center_w = image.shape[0] // 2, image.shape[1] // 2\n    center_region_avg = np.mean(image[center_h-1:center_h+1, center_w-1:center_w+1])\n    corners_avg = np.mean(corners)\n    return float(corners_avg - center_region_avg)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of pixel intensity variance between left and right halves of the image\"\n    left_half = image[:, :image.shape[1] // 2]\n    right_half = image[:, image.shape[1] // 2:]\n    return float(np.var(left_half) / (np.var(right_half) + 1e-6))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Calculate the density of pixels in concentric squares from the center\"\n    h, w = image.shape\n    center = (h // 2, w // 2)\n    total_density = 0.0\n    for scale in range(1, 5):\n        square_region = image[center[0] - scale: center[0] + scale + 1, \n                              center[1] - scale: center[1] + scale + 1]\n        total_density += np.count_nonzero(square_region)\n    return total_density\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Mean pixel intensity of the horizontal center strip of the image'\n    h, w = image.shape\n    center_strip = image[h // 2 - 1:h // 2 + 1, :]\n    return float(np.mean(center_strip))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Ratio of the number of non-zero pixels in the bottom third to total non-zero pixels in the image'\n    h, w = image.shape\n    bottom_third = image[2*h//3:, :]\n    total_non_zero = np.count_nonzero(image)\n    non_zero_bottom = np.count_nonzero(bottom_third)\n    return float(non_zero_bottom / total_non_zero) if total_non_zero > 0 else 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Proportion of diagonal pixels (from top left to bottom right) to total pixels\"\n    h, w = image.shape\n    diagonal_count = min(h, w)\n    diagonal_sum = np.sum(image[np.arange(diagonal_count), np.arange(diagonal_count)])\n    total_sum = np.sum(image)\n    return float(diagonal_sum / total_sum) if total_sum > 0 else 0.0\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of non-zero pixel count in the middle third to the total non-zero pixels\"\n    h, w = image.shape\n    middle_region = image[h // 3:2 * h // 3, :]\n    non_zero_middle = np.count_nonzero(middle_region)\n    total_non_zero = np.count_nonzero(image)\n    return float(non_zero_middle / total_non_zero) if total_non_zero > 0 else 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Difference between the mean intensity of the upper and lower halves of the image'\n    h, w = image.shape\n    upper_half_mean = np.mean(image[0:h//2, :])\n    lower_half_mean = np.mean(image[h//2:, :])\n    return float(upper_half_mean - lower_half_mean)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Difference between the mean intensity of the upper and lower halves of the image'\n    h, w = image.shape\n    upper_half_mean = np.mean(image[0:h//2, :])\n    lower_half_mean = np.mean(image[h//2:, :])\n    return float(upper_half_mean - lower_half_mean)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of non-zero pixel count in the middle third to the total non-zero pixels\"\n    h, w = image.shape\n    middle_region = image[h // 3:2 * h // 3, :]\n    non_zero_middle = np.count_nonzero(middle_region)\n    total_non_zero = np.count_nonzero(image)\n    return float(non_zero_middle / total_non_zero) if total_non_zero > 0 else 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Calculate the vertical gradient magnitude at the middle column of the image.\"\n    h, w = image.shape\n    middle_column = image[:, w // 2]\n    gradient = np.gradient(middle_column)\n    return float(np.mean(np.abs(gradient)))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Percentage of non-zero rows in the upper half of the image\"\n    upper_half = image[:image.shape[0] // 2]\n    non_zero_row_count = np.count_nonzero(np.any(upper_half > 0, axis=1))\n    return float(non_zero_row_count) / upper_half.shape[0]\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Calculate the ratio of non-zero pixels in the left quarter to the right quarter'\n    left_quarter = image[:, :image.shape[1] // 4]\n    right_quarter = image[:, 3*image.shape[1] // 4:]\n    non_zero_left = np.count_nonzero(left_quarter)\n    non_zero_right = np.count_nonzero(right_quarter)\n    return float(non_zero_left / (non_zero_right + 1e-10))  # Avoid division by zero\n",
    "def feature(image: np.ndarray) -> float:\n    \"Determine the mean pixel intensity in the top-right quarter of the image.\"\n    h, w = image.shape\n    top_right_quarter = image[:h//2, w//2:]\n    return float(np.mean(top_right_quarter))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of non-zero pixel count in the middle third to the total non-zero pixels\"\n    h, w = image.shape\n    middle_region = image[h // 3:2 * h // 3, :]\n    non_zero_middle = np.count_nonzero(middle_region)\n    total_non_zero = np.count_nonzero(image)\n    return float(non_zero_middle / total_non_zero) if total_non_zero > 0 else 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Determine the mean pixel intensity in the top-right quarter of the image.\"\n    h, w = image.shape\n    top_right_quarter = image[:h//2, w//2:]\n    return float(np.mean(top_right_quarter))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Horizontal gradient magnitude at the middle row of the image\"\n    grad_x = np.gradient(image, axis=1)\n    return float(np.mean(np.abs(grad_x[image.shape[0] // 2])))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Average intensity of non-zero pixels in the bottom half of the image.\"\n    h, w = image.shape\n    bottom_half = image[h//2:]\n    non_zero_intensity = bottom_half[bottom_half > 0]\n    return float(np.mean(non_zero_intensity)) if non_zero_intensity.size > 0 else 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Difference between the mean intensity of the upper and lower halves of the image'\n    h, w = image.shape\n    upper_half_mean = np.mean(image[0:h//2, :])\n    lower_half_mean = np.mean(image[h//2:, :])\n    return float(upper_half_mean - lower_half_mean)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Calculate the ratio of the sum of pixel intensities in the top quarter to the bottom quarter\"\n    top_quarter_sum = np.sum(image[:image.shape[0]//4])\n    bottom_quarter_sum = np.sum(image[3*image.shape[0]//4:])\n    return float(top_quarter_sum / (bottom_quarter_sum + 1e-6))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Calculate the density of pixels in concentric squares from the center\"\n    h, w = image.shape\n    center = (h // 2, w // 2)\n    total_density = 0.0\n    for scale in range(1, 5):\n        square_region = image[center[0] - scale: center[0] + scale + 1, \n                              center[1] - scale: center[1] + scale + 1]\n        total_density += np.count_nonzero(square_region)\n    return total_density\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Horizontal gradient magnitude at the middle row of the image\"\n    grad_x = np.gradient(image, axis=1)\n    return float(np.mean(np.abs(grad_x[image.shape[0] // 2])))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of horizontal pixel gradients to vertical pixel gradients\"\n    gradient_x, gradient_y = np.gradient(image)\n    horizontal_gradient = np.sum(np.abs(gradient_y))\n    vertical_gradient = np.sum(np.abs(gradient_x))\n    return horizontal_gradient / (vertical_gradient + 1e-5)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Count of corners detected in the image using Harris corner detection\"\n    import cv2\n    corners = cv2.cornerHarris(image.astype(np.float32), blockSize=2, ksize=3, k=0.04)\n    return float(np.sum(corners > 0.01 * corners.max()))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Count of corners detected in the image using Harris corner detection\"\n    import cv2\n    corners = cv2.cornerHarris(image.astype(np.float32), blockSize=2, ksize=3, k=0.04)\n    return float(np.sum(corners > 0.01 * corners.max()))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Calculate the symmetry of the image by comparing halves.'\n    h, w = image.shape\n    left_half = image[:, :w//2]\n    right_half = image[:, w//2:]\n    return float(np.mean(left_half) / (np.mean(right_half) or 1))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Edge pixel count based on gradient magnitude threshold\"\n    gx, gy = np.gradient(image)\n    gradient_magnitude = np.sqrt(gx**2 + gy**2)\n    edge_pixel_count = np.count_nonzero(gradient_magnitude > 50)\n    return float(edge_pixel_count)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Proportion of horizontal edges to total edges in the image\"\n    gradients = np.gradient(image.astype(float))\n    horizontal_edges = np.count_nonzero(gradients[0] > 0)\n    total_edges = np.count_nonzero(gradients[0]) + np.count_nonzero(gradients[1])\n    return horizontal_edges / total_edges if total_edges > 0 else 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Mean pixel intensity of the rightmost quarter of the image.\"\n    w = image.shape[1]\n    right_quarter = image[:, 3*w//4:w]\n    return float(np.mean(right_quarter))\n",
    "def feature(image: np.ndarray) -> float:\n    \"Mean gradient magnitude around the corners of the image\"\n    corners = image[0:10, 0:10]  # Top left corner\n    corners = np.concatenate((corners, image[0:10, -10:]))  # Top right corner\n    corners = np.concatenate((corners, image[-10:, 0:10]))  # Bottom left corner\n    corners = np.concatenate((corners, image[-10:, -10:]))  # Bottom right corner\n    gx, gy = np.gradient(corners.astype(float))\n    corner_gradient_magnitude = np.sqrt(gx**2 + gy**2)\n    return float(np.mean(corner_gradient_magnitude))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Count of vertical edges detected in the image using Sobel filter'\n    sobel_x = np.array([[-1, 0, 1], [-2, 0, 2], [-1, 0, 1]])\n    edges = np.abs(np.convolve(image.flatten(), sobel_x.flatten(), 'same'))\n    return float(np.count_nonzero(edges))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of non-zero pixel count in the middle third to the total non-zero pixels\"\n    h, w = image.shape\n    middle_region = image[h // 3:2 * h // 3, :]\n    non_zero_middle = np.count_nonzero(middle_region)\n    total_non_zero = np.count_nonzero(image)\n    return float(non_zero_middle / total_non_zero) if total_non_zero > 0 else 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Mean pixel intensity of the diagonal from bottom-left to top-right'\n    h, w = image.shape\n    diagonal = [image[h - i - 1, i] for i in range(min(h, w))]\n    return float(np.mean(diagonal))\n",
    "def feature(image: np.ndarray) -> float:\n    \"Variance of pixel intensities in the central region\"\n    h, w = image.shape\n    center_h, center_w = h // 4, w // 4\n    center_region = image[center_h:3*center_h, center_w:3*center_w]\n    return float(np.var(center_region))\n",
    "def feature(image: np.ndarray) -> float:\n    'Calculate the ratio of non-zero pixels in the left quarter to the right quarter'\n    left_quarter = image[:, :image.shape[1] // 4]\n    right_quarter = image[:, 3*image.shape[1] // 4:]\n    non_zero_left = np.count_nonzero(left_quarter)\n    non_zero_right = np.count_nonzero(right_quarter)\n    return float(non_zero_left / (non_zero_right + 1e-10))  # Avoid division by zero\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of pixel intensity variance between left and right halves of the image\"\n    left_half = image[:, :image.shape[1] // 2]\n    right_half = image[:, image.shape[1] // 2:]\n    return float(np.var(left_half) / (np.var(right_half) + 1e-6))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Ratio of bright pixels in the top quarter of the image to the bottom quarter'\n    h, w = image.shape\n    top_quarter = image[:h//4, :]\n    bottom_quarter = image[3*h//4:, :]\n    bright_top = np.count_nonzero(top_quarter > 128)\n    bright_bottom = np.count_nonzero(bottom_quarter > 128)\n    return float(bright_top / (bright_bottom + 1e-5))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Proportion of diagonal pixels (from top left to bottom right) to total pixels\"\n    h, w = image.shape\n    diagonal_count = min(h, w)\n    diagonal_sum = np.sum(image[np.arange(diagonal_count), np.arange(diagonal_count)])\n    total_sum = np.sum(image)\n    return float(diagonal_sum / total_sum) if total_sum > 0 else 0.0\n",
    "def feature(image: np.ndarray) -> float:\n    'Calculate the ratio of edge pixels (using the standard deviation) to total pixels'\n    edge_std = np.std(np.gradient(image.astype(float))[0])\n    total_pixels = image.size\n    return float(edge_std / total_pixels) if total_pixels > 0 else 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of non-zero pixel count in the middle third to the total non-zero pixels\"\n    h, w = image.shape\n    middle_region = image[h // 3:2 * h // 3, :]\n    non_zero_middle = np.count_nonzero(middle_region)\n    total_non_zero = np.count_nonzero(image)\n    return float(non_zero_middle / total_non_zero) if total_non_zero > 0 else 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Calculate the ratio of the sum of upper half pixel intensities to the sum of the lower half pixel intensities.\"\n    h, w = image.shape\n    upper_half = image[:h//2]\n    lower_half = image[h//2:]\n    upper_sum = np.sum(upper_half)\n    lower_sum = np.sum(lower_half)\n    return upper_sum / (lower_sum + 1e-5)  # Avoid division by zero\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Ratio of pixel intensity variance between the top and bottom halves of the image'\n    h, w = image.shape\n    top_half = image[:h//2, :]\n    bottom_half = image[h//2:, :]\n    variance_ratio = np.std(top_half) / (np.std(bottom_half) + 1e-5)  # Adding small value to avoid division by zero\n    return float(variance_ratio)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Mean pixel intensity of the image margins (top and bottom)\"\n    top_margin = image[:image.shape[0]//10, :]\n    bottom_margin = image[-image.shape[0]//10:, :]\n    return float((np.mean(top_margin) + np.mean(bottom_margin)) / 2)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of non-zero pixel count in the middle third to the total non-zero pixels\"\n    h, w = image.shape\n    middle_region = image[h // 3:2 * h // 3, :]\n    non_zero_middle = np.count_nonzero(middle_region)\n    total_non_zero = np.count_nonzero(image)\n    return float(non_zero_middle / total_non_zero) if total_non_zero > 0 else 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Percentage of non-zero pixels in the bottom quarter of the image\"\n    h, w = image.shape\n    bottom_quarter = image[3*h//4:, :]\n    non_zero_count = np.count_nonzero(bottom_quarter)\n    total_count = bottom_quarter.size\n    return non_zero_count / total_count if total_count > 0 else 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of non-zero pixels in the center region to non-zero pixels in the corners.\"\n    h, w = image.shape\n    center_region = image[h // 4:3 * h // 4, w // 4:3 * w // 4]\n    corners = np.concatenate((image[:h // 4, :w // 4], image[:h // 4, 3*w//4:w], \n                               image[3*h//4:h, :w // 4], image[3*h//4:h, 3*w//4:w]))\n    \n    center_nonzero = np.count_nonzero(center_region)\n    corners_nonzero = np.count_nonzero(corners)\n    return float(center_nonzero) / (corners_nonzero + 1e-6)\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of non-zero pixel count in the middle third to the total non-zero pixels\"\n    h, w = image.shape\n    middle_region = image[h // 3:2 * h // 3, :]\n    non_zero_middle = np.count_nonzero(middle_region)\n    total_non_zero = np.count_nonzero(image)\n    return float(non_zero_middle / total_non_zero) if total_non_zero > 0 else 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Percentage of non-zero rows in the upper half of the image\"\n    upper_half = image[:image.shape[0] // 2]\n    non_zero_row_count = np.count_nonzero(np.any(upper_half > 0, axis=1))\n    return float(non_zero_row_count) / upper_half.shape[0]\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of non-zero pixel count in the middle third to the total non-zero pixels\"\n    h, w = image.shape\n    middle_region = image[h // 3:2 * h // 3, :]\n    non_zero_middle = np.count_nonzero(middle_region)\n    total_non_zero = np.count_nonzero(image)\n    return float(non_zero_middle / total_non_zero) if total_non_zero > 0 else 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Horizontal gradient magnitude at the middle row of the image\"\n    grad_x = np.gradient(image, axis=1)\n    return float(np.mean(np.abs(grad_x[image.shape[0] // 2])))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of non-zero pixel count in the middle third to the total non-zero pixels\"\n    h, w = image.shape\n    middle_region = image[h // 3:2 * h // 3, :]\n    non_zero_middle = np.count_nonzero(middle_region)\n    total_non_zero = np.count_nonzero(image)\n    return float(non_zero_middle / total_non_zero) if total_non_zero > 0 else 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of non-zero pixels to total pixels in the image\"\n    total_pixels = image.size\n    non_zero_pixels = np.count_nonzero(image)\n    return float(non_zero_pixels) / total_pixels if total_pixels > 0 else 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Mean pixel intensity of the image corners'\n    h, w = image.shape\n    corners = np.concatenate((image[0, 0:w//4], image[0, 3*w//4:w], image[h//4, 0:w//4], image[h//4, 3*w//4:w]))\n    return float(np.mean(corners))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Variance of pixel intensities in the bottom quarter of the image'\n    h, w = image.shape\n    bottom_quarter = image[3 * h // 4:, :]\n    return float(np.var(bottom_quarter))\n",
    "def feature(image: np.ndarray) -> float:\n    \"Average pixel intensity of the bottom third of the image.\"\n    h, w = image.shape\n    bottom_third = image[2*h//3:h]\n    return float(np.mean(bottom_third))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Mean pixel intensity of the image corners'\n    h, w = image.shape\n    corners = np.concatenate((image[0, 0:w//4], image[0, 3*w//4:w], image[h//4, 0:w//4], image[h//4, 3*w//4:w]))\n    return float(np.mean(corners))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of non-zero pixels in the top quarter to the bottom quarter of the image\"\n    h, w = image.shape\n    top_quarter = image[:h // 4, :]\n    bottom_quarter = image[h * 3 // 4:, :]\n    top_nonzero = np.count_nonzero(top_quarter)\n    bottom_nonzero = np.count_nonzero(bottom_quarter)\n    return float(top_nonzero / (bottom_nonzero + 1e-5))  # Avoid division by zero\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of non-zero pixels to total pixels in the image\"\n    total_pixels = image.size\n    non_zero_pixels = np.count_nonzero(image)\n    return float(non_zero_pixels) / total_pixels if total_pixels > 0 else 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of non-zero pixels to total pixels in the image\"\n    total_pixels = image.size\n    non_zero_pixels = np.count_nonzero(image)\n    return float(non_zero_pixels) / total_pixels if total_pixels > 0 else 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of non-zero pixels to total pixels in the image\"\n    total_pixels = image.size\n    non_zero_pixels = np.count_nonzero(image)\n    return float(non_zero_pixels) / total_pixels if total_pixels > 0 else 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of non-zero pixels to total pixels in the image\"\n    total_pixels = image.size\n    non_zero_pixels = np.count_nonzero(image)\n    return float(non_zero_pixels) / total_pixels if total_pixels > 0 else 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of non-zero pixels to total pixels in the image\"\n    total_pixels = image.size\n    non_zero_pixels = np.count_nonzero(image)\n    return float(non_zero_pixels) / total_pixels if total_pixels > 0 else 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of non-zero pixels to total pixels in the image\"\n    total_pixels = image.size\n    non_zero_pixels = np.count_nonzero(image)\n    return float(non_zero_pixels) / total_pixels if total_pixels > 0 else 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Detection of horizontal edges using the Prewitt filter'\n    prewitt_y = np.array([[1, 1, 1], [0, 0, 0], [-1, -1, -1]])\n    edges = np.abs(np.convolve(image.flatten(), prewitt_y.flatten(), 'same'))\n    return float(np.count_nonzero(edges))\n",
    "def feature(image: np.ndarray) -> float:\n    'Measure the density of edges within a certain distance from the center.'\n    h, w = image.shape\n    center_region = image[h//4:3*h//4, w//4:3*w//4]\n    edges = np.gradient(center_region)\n    edge_density = np.count_nonzero(edges[0]) + np.count_nonzero(edges[1])\n    return float(edge_density)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Calculate the ratio of the sum of pixel intensities in the top quarter to the bottom quarter\"\n    top_quarter_sum = np.sum(image[:image.shape[0]//4])\n    bottom_quarter_sum = np.sum(image[3*image.shape[0]//4:])\n    return float(top_quarter_sum / (bottom_quarter_sum + 1e-6))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Count the number of rows that have more than a set number of non-zero pixels'\n    threshold = 5\n    high_pixel_rows = np.sum(np.count_nonzero(image, axis=1) > threshold)\n    return float(high_pixel_rows)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of non-zero pixels to total pixels in the image\"\n    total_pixels = image.size\n    non_zero_pixels = np.count_nonzero(image)\n    return float(non_zero_pixels) / total_pixels if total_pixels > 0 else 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Count of horizontal lines detected based on intensity gradients\"\n    horizontal_gradient = np.gradient(image, axis=0)\n    horizontal_lines = np.count_nonzero(np.abs(horizontal_gradient) > 20)\n    return float(horizontal_lines)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Count of non-zero pixels along the diagonals of the image.\"\n    h, w = image.shape\n    main_diagonal = image[range(min(h, w)), range(min(h, w))]\n    anti_diagonal = image[range(min(h, w)), range(min(h, w) - 1, -1, -1)]\n    return float(np.count_nonzero(main_diagonal)) + float(np.count_nonzero(anti_diagonal))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of horizontal pixel gradients to vertical pixel gradients\"\n    gradient_x, gradient_y = np.gradient(image)\n    horizontal_gradient = np.sum(np.abs(gradient_y))\n    vertical_gradient = np.sum(np.abs(gradient_x))\n    return horizontal_gradient / (vertical_gradient + 1e-5)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Standard deviation of pixel intensities in the whole image\"\n    return float(np.std(image))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of non-zero pixels to total pixels in the image\"\n    total_pixels = image.size\n    non_zero_pixels = np.count_nonzero(image)\n    return float(non_zero_pixels) / total_pixels if total_pixels > 0 else 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of non-zero pixels to total pixels in the image\"\n    total_pixels = image.size\n    non_zero_pixels = np.count_nonzero(image)\n    return float(non_zero_pixels) / total_pixels if total_pixels > 0 else 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of non-zero pixels to total pixels in the image\"\n    total_pixels = image.size\n    non_zero_pixels = np.count_nonzero(image)\n    return float(non_zero_pixels) / total_pixels if total_pixels > 0 else 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of non-zero pixels to total pixels in the image\"\n    total_pixels = image.size\n    non_zero_pixels = np.count_nonzero(image)\n    return float(non_zero_pixels) / total_pixels if total_pixels > 0 else 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of non-zero pixels to total pixels in the image\"\n    total_pixels = image.size\n    non_zero_pixels = np.count_nonzero(image)\n    return float(non_zero_pixels) / total_pixels if total_pixels > 0 else 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of non-zero pixels to total pixels in the image\"\n    total_pixels = image.size\n    non_zero_pixels = np.count_nonzero(image)\n    return float(non_zero_pixels) / total_pixels if total_pixels > 0 else 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of non-zero pixels to total pixels in the image\"\n    total_pixels = image.size\n    non_zero_pixels = np.count_nonzero(image)\n    return float(non_zero_pixels) / total_pixels if total_pixels > 0 else 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of non-zero pixels to total pixels in the image\"\n    total_pixels = image.size\n    non_zero_pixels = np.count_nonzero(image)\n    return float(non_zero_pixels) / total_pixels if total_pixels > 0 else 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of non-zero pixels to total pixels in the image\"\n    total_pixels = image.size\n    non_zero_pixels = np.count_nonzero(image)\n    return float(non_zero_pixels) / total_pixels if total_pixels > 0 else 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of non-zero pixels to total pixels in the image\"\n    total_pixels = image.size\n    non_zero_pixels = np.count_nonzero(image)\n    return float(non_zero_pixels) / total_pixels if total_pixels > 0 else 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Maximum intensity in the top-left corner region of the image'\n    return float(np.max(image[:image.shape[0] // 4, :image.shape[1] // 4]))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Calculate the difference between the maximum and minimum pixel values in the central region.\"\n    h, w = image.shape\n    center_region = image[h//4:3*h//4, w//4:3*w//4]\n    return float(np.max(center_region) - np.min(center_region))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of non-zero pixels to total pixels in the image\"\n    total_pixels = image.size\n    non_zero_pixels = np.count_nonzero(image)\n    return float(non_zero_pixels) / total_pixels if total_pixels > 0 else 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Calculate the average gradient magnitude in the image, which indicates edges.\"\n    gradients = np.sqrt(np.sum(np.gradient(image.astype(float)), axis=0)**2)\n    return float(np.mean(gradients))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Ratio of non-zero pixels in the center region to total pixels'\n    h, w = image.shape\n    center_region = image[h // 4: 3 * h // 4, w // 4: 3 * w // 4]\n    non_zero_count = np.count_nonzero(center_region)\n    total_count = center_region.size\n    return float(non_zero_count) / total_count if total_count > 0 else 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of non-zero pixels to total pixels in the image\"\n    total_pixels = image.size\n    non_zero_pixels = np.count_nonzero(image)\n    return float(non_zero_pixels) / total_pixels if total_pixels > 0 else 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Mean pixel intensity of pixels in the left half of the image'\n    left_half = image[:, :image.shape[1] // 2]\n    return float(np.mean(left_half))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Count of vertical edges detected in the image using Sobel filter'\n    sobel_x = np.array([[-1, 0, 1], [-2, 0, 2], [-1, 0, 1]])\n    edges = np.abs(np.convolve(image.flatten(), sobel_x.flatten(), 'same'))\n    return float(np.count_nonzero(edges))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of non-zero pixels to total pixels in the image\"\n    total_pixels = image.size\n    non_zero_pixels = np.count_nonzero(image)\n    return float(non_zero_pixels) / total_pixels if total_pixels > 0 else 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of non-zero pixels to total pixels in the image\"\n    total_pixels = image.size\n    non_zero_pixels = np.count_nonzero(image)\n    return float(non_zero_pixels) / total_pixels if total_pixels > 0 else 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of non-zero pixels to total pixels in the image\"\n    total_pixels = image.size\n    non_zero_pixels = np.count_nonzero(image)\n    return float(non_zero_pixels) / total_pixels if total_pixels > 0 else 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of non-zero pixels to total pixels in the image\"\n    total_pixels = image.size\n    non_zero_pixels = np.count_nonzero(image)\n    return float(non_zero_pixels) / total_pixels if total_pixels > 0 else 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of non-zero pixels to total pixels in the image\"\n    total_pixels = image.size\n    non_zero_pixels = np.count_nonzero(image)\n    return float(non_zero_pixels) / total_pixels if total_pixels > 0 else 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Sum of pixel values in the top-left quarter of the image\"\n    h, w = image.shape\n    top_left_quarter = image[:h // 2, :w // 2]\n    return float(np.sum(top_left_quarter))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Count of local maxima in the image based on pixel intensity'\n    gradient = np.gradient(image)\n    local_maxima = np.count_nonzero((gradient[0] > 0) & (np.roll(gradient[0], 1) < 0))\n    return float(local_maxima)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Mean pixel intensity of the horizontal center strip of the image'\n    h, w = image.shape\n    center_strip = image[h // 2 - 1:h // 2 + 1, :]\n    return float(np.mean(center_strip))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of non-zero pixels to total pixels in the image\"\n    total_pixels = image.size\n    non_zero_pixels = np.count_nonzero(image)\n    return float(non_zero_pixels) / total_pixels if total_pixels > 0 else 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of non-zero pixels to total pixels in the image\"\n    total_pixels = image.size\n    non_zero_pixels = np.count_nonzero(image)\n    return float(non_zero_pixels) / total_pixels if total_pixels > 0 else 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of non-zero pixels to total pixels in the image\"\n    total_pixels = image.size\n    non_zero_pixels = np.count_nonzero(image)\n    return float(non_zero_pixels) / total_pixels if total_pixels > 0 else 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of non-zero pixels to total pixels in the image\"\n    total_pixels = image.size\n    non_zero_pixels = np.count_nonzero(image)\n    return float(non_zero_pixels) / total_pixels if total_pixels > 0 else 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Proportion of pixels in the image that are near the maximum intensity\"\n    max_intensity = image.max()\n    threshold = max_intensity * 0.9\n    high_intensity_count = np.count_nonzero(image > threshold)\n    return float(high_intensity_count) / image.size\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of non-zero pixels to total pixels in the image\"\n    total_pixels = image.size\n    non_zero_pixels = np.count_nonzero(image)\n    return float(non_zero_pixels) / total_pixels if total_pixels > 0 else 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of non-zero pixels to total pixels in the image\"\n    total_pixels = image.size\n    non_zero_pixels = np.count_nonzero(image)\n    return float(non_zero_pixels) / total_pixels if total_pixels > 0 else 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of non-zero pixels to total pixels in the image\"\n    total_pixels = image.size\n    non_zero_pixels = np.count_nonzero(image)\n    return float(non_zero_pixels) / total_pixels if total_pixels > 0 else 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of non-zero pixels to total pixels in the image\"\n    total_pixels = image.size\n    non_zero_pixels = np.count_nonzero(image)\n    return float(non_zero_pixels) / total_pixels if total_pixels > 0 else 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of non-zero pixels to total pixels in the image\"\n    total_pixels = image.size\n    non_zero_pixels = np.count_nonzero(image)\n    return float(non_zero_pixels) / total_pixels if total_pixels > 0 else 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Mean pixel intensity of the horizontal center strip of the image'\n    h, w = image.shape\n    center_strip = image[h // 2 - 1:h // 2 + 1, :]\n    return float(np.mean(center_strip))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of horizontal pixel gradients to vertical pixel gradients\"\n    gradient_x, gradient_y = np.gradient(image)\n    horizontal_gradient = np.sum(np.abs(gradient_y))\n    vertical_gradient = np.sum(np.abs(gradient_x))\n    return horizontal_gradient / (vertical_gradient + 1e-5)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of the number of vertical edges to the total number of edges.\"\n    gradient = np.gradient(image)\n    vertical_edges = np.count_nonzero(gradient[1])  # Vertical gradient count\n    total_edges = np.count_nonzero(gradient)\n    return float(vertical_edges) / float(total_edges) if total_edges > 0 else 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Mean pixel intensity in the left quarter of the image\"\n    left_quarter = image[:, :image.shape[1] // 4]\n    return float(np.mean(left_quarter))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Count of local maxima in the image based on pixel intensity'\n    gradient = np.gradient(image)\n    local_maxima = np.count_nonzero((gradient[0] > 0) & (np.roll(gradient[0], 1) < 0))\n    return float(local_maxima)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Count of corners detected in the image using Harris corner detection\"\n    import cv2\n    corners = cv2.cornerHarris(image.astype(np.float32), blockSize=2, ksize=3, k=0.04)\n    return float(np.sum(corners > 0.01 * corners.max()))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Difference in pixel intensity averages of the corners versus the center of the image.\"\n    corners = image[0, 0], image[0, -1], image[-1, 0], image[-1, -1]\n    center_h, center_w = image.shape[0] // 2, image.shape[1] // 2\n    center_region_avg = np.mean(image[center_h-1:center_h+1, center_w-1:center_w+1])\n    corners_avg = np.mean(corners)\n    return float(corners_avg - center_region_avg)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Variance of pixel intensities in the top-left corner\"\n    h, w = image.shape\n    corner_region = image[0:h // 3, 0:w // 3]\n    return float(np.var(corner_region))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Count of local maxima in the image based on pixel intensity'\n    gradient = np.gradient(image)\n    local_maxima = np.count_nonzero((gradient[0] > 0) & (np.roll(gradient[0], 1) < 0))\n    return float(local_maxima)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Mean pixel intensity of the diagonal from bottom-left to top-right'\n    h, w = image.shape\n    diagonal = [image[h - i - 1, i] for i in range(min(h, w))]\n    return float(np.mean(diagonal))\n",
    "def feature(image: np.ndarray) -> float:\n    \"Count of non-zero rows in the bottom half of the image\"\n    h, w = image.shape\n    bottom_half = image[h // 2:, :]\n    non_zero_rows = np.count_nonzero(np.any(bottom_half, axis=1))\n    return float(non_zero_rows)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Variance of pixel intensities in the top-left corner\"\n    h, w = image.shape\n    corner_region = image[0:h // 3, 0:w // 3]\n    return float(np.var(corner_region))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of non-zero pixels in the top third to total non-zero pixels\"\n    h, w = image.shape\n    top_third = image[0:h//3, :]\n    total_non_zero = np.count_nonzero(image)\n    top_non_zero = np.count_nonzero(top_third)\n    return float(top_non_zero / total_non_zero) if total_non_zero > 0 else 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Percentage of non-zero rows in the upper half of the image\"\n    upper_half = image[:image.shape[0] // 2]\n    non_zero_row_count = np.count_nonzero(np.any(upper_half > 0, axis=1))\n    return float(non_zero_row_count) / upper_half.shape[0]\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Mean pixel intensity of the image edges\"\n    edges = np.gradient(image)\n    edge_magnitude = np.sqrt(edges[0]**2 + edges[1]**2)\n    return float(np.mean(edge_magnitude))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Variance of pixel intensities in the bottom half of the image\"\n    h, w = image.shape\n    bottom_half = image[h // 2:, :]\n    return float(np.var(bottom_half))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Difference between the mean intensity of the upper and lower halves of the image'\n    h, w = image.shape\n    upper_half_mean = np.mean(image[0:h//2, :])\n    lower_half_mean = np.mean(image[h//2:, :])\n    return float(upper_half_mean - lower_half_mean)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Variance of pixel intensities around the image center\"\n    h, w = image.shape\n    center_h, center_w = h // 2, w // 2\n    center_region = image[center_h-1:center_h+2, center_w-1:center_w+2]\n    return float(np.var(center_region))\n",
    "def feature(image: np.ndarray) -> float:\n    \"Difference in pixel intensity averages of the corners versus the center of the image.\"\n    corners = image[0, 0], image[0, -1], image[-1, 0], image[-1, -1]\n    center_h, center_w = image.shape[0] // 2, image.shape[1] // 2\n    center_region_avg = np.mean(image[center_h-1:center_h+1, center_w-1:center_w+1])\n    corners_avg = np.mean(corners)\n    return float(corners_avg - center_region_avg)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of non-zero pixel count in the middle third to the total non-zero pixels\"\n    h, w = image.shape\n    middle_region = image[h // 3:2 * h // 3, :]\n    non_zero_middle = np.count_nonzero(middle_region)\n    total_non_zero = np.count_nonzero(image)\n    return float(non_zero_middle / total_non_zero) if total_non_zero > 0 else 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Calculate the vertical gradient magnitude at the middle column of the image.\"\n    h, w = image.shape\n    middle_column = image[:, w // 2]\n    gradient = np.gradient(middle_column)\n    return float(np.mean(np.abs(gradient)))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Ratio of the number of non-zero pixels in the bottom third to total non-zero pixels in the image'\n    h, w = image.shape\n    bottom_third = image[2*h//3:, :]\n    total_non_zero = np.count_nonzero(image)\n    non_zero_bottom = np.count_nonzero(bottom_third)\n    return float(non_zero_bottom / total_non_zero) if total_non_zero > 0 else 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Determine the ratio of dark pixels (below a threshold) in the upper half to the total dark pixels in the image'\n    threshold = 50\n    dark_upper_half = np.count_nonzero(image[0:image.shape[0]//2] < threshold)\n    total_dark = np.count_nonzero(image < threshold)\n    return float(dark_upper_half / (total_dark + 1e-5))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of non-zero pixel count in the middle third to the total non-zero pixels\"\n    h, w = image.shape\n    middle_region = image[h // 3:2 * h // 3, :]\n    non_zero_middle = np.count_nonzero(middle_region)\n    total_non_zero = np.count_nonzero(image)\n    return float(non_zero_middle / total_non_zero) if total_non_zero > 0 else 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of non-zero pixel count in the middle third to the total non-zero pixels\"\n    h, w = image.shape\n    middle_region = image[h // 3:2 * h // 3, :]\n    non_zero_middle = np.count_nonzero(middle_region)\n    total_non_zero = np.count_nonzero(image)\n    return float(non_zero_middle / total_non_zero) if total_non_zero > 0 else 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Count of local minima based on pixel intensity'\n    local_minima = (image < np.roll(image, 1, axis=0)) & (image < np.roll(image, -1, axis=0))\n    return float(np.count_nonzero(local_minima))\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of non-zero pixel count in the middle third to the total non-zero pixels\"\n    h, w = image.shape\n    middle_region = image[h // 3:2 * h // 3, :]\n    non_zero_middle = np.count_nonzero(middle_region)\n    total_non_zero = np.count_nonzero(image)\n    return float(non_zero_middle / total_non_zero) if total_non_zero > 0 else 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Ratio of the number of non-zero pixels in the bottom third to total non-zero pixels in the image'\n    h, w = image.shape\n    bottom_third = image[2*h//3:, :]\n    total_non_zero = np.count_nonzero(image)\n    non_zero_bottom = np.count_nonzero(bottom_third)\n    return float(non_zero_bottom / total_non_zero) if total_non_zero > 0 else 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of non-zero pixel count in the middle third to the total non-zero pixels\"\n    h, w = image.shape\n    middle_region = image[h // 3:2 * h // 3, :]\n    non_zero_middle = np.count_nonzero(middle_region)\n    total_non_zero = np.count_nonzero(image)\n    return float(non_zero_middle / total_non_zero) if total_non_zero > 0 else 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Count of corners detected in the image using Harris corner detection\"\n    import cv2\n    corners = cv2.cornerHarris(image.astype(np.float32), blockSize=2, ksize=3, k=0.04)\n    return float(np.sum(corners > 0.01 * corners.max()))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of non-zero pixel count in the middle third to the total non-zero pixels\"\n    h, w = image.shape\n    middle_region = image[h // 3:2 * h // 3, :]\n    non_zero_middle = np.count_nonzero(middle_region)\n    total_non_zero = np.count_nonzero(image)\n    return float(non_zero_middle / total_non_zero) if total_non_zero > 0 else 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Number of prominent peaks in the intensity histogram'\n    hist, _ = np.histogram(image, bins=10)\n    peaks = np.sum(np.diff(hist) > 0)\n    return float(peaks)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Count of vertical lines in the image based on intensity gradient\"\n    gradient = np.gradient(image, axis=1)\n    vertical_lines = np.sum(np.abs(gradient) > 10)\n    return float(vertical_lines)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Proportion of pixels in the center region compared to the entire image\"\n    h, w = image.shape\n    center_region = image[h//4:3*h//4, w//4:3*w//4]\n    pixel_count = np.count_nonzero(image)\n    center_pixel_count = np.count_nonzero(center_region)\n    return float(center_pixel_count / pixel_count) if pixel_count > 0 else 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Mean of the maximum pixel intensity in the left half of the image\"\n    left_half = image[:, :image.shape[1] // 2]\n    return float(np.mean(np.max(left_half, axis=0)))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Mean pixel intensity of pixels in the left half of the image'\n    left_half = image[:, :image.shape[1] // 2]\n    return float(np.mean(left_half))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Entropy of the pixel intensity histogram\"\n    histogram, _ = np.histogram(image, bins=256, density=True)\n    histogram = histogram[histogram > 0]  # Avoid log(0)\n    entropy = -np.sum(histogram * np.log(histogram))\n    return float(entropy)\n",
    "def feature(image: np.ndarray) -> float:\n    \"Count of edge pixels detected in the left half using a gradient\"\n    gradient = np.abs(np.gradient(image, axis=1))\n    left_half_edges = gradient[:, :image.shape[1]//2]\n    return float(np.count_nonzero(left_half_edges > 0.1))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Standard deviation of pixel intensities in the corner regions\"\n    h, w = image.shape\n    top_left = image[0:h//2, 0:w//2]\n    top_right = image[0:h//2, w//2:w]\n    bottom_left = image[h//2:h, 0:w//2]\n    bottom_right = image[h//2:h, w//2:w]\n    corner_std = np.std([np.std(top_left), np.std(top_right), np.std(bottom_left), np.std(bottom_right)])\n    return float(corner_std)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of non-zero pixel count in the middle third to the total non-zero pixels\"\n    h, w = image.shape\n    middle_region = image[h // 3:2 * h // 3, :]\n    non_zero_middle = np.count_nonzero(middle_region)\n    total_non_zero = np.count_nonzero(image)\n    return float(non_zero_middle / total_non_zero) if total_non_zero > 0 else 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of non-zero pixel count in the middle third to the total non-zero pixels\"\n    h, w = image.shape\n    middle_region = image[h // 3:2 * h // 3, :]\n    non_zero_middle = np.count_nonzero(middle_region)\n    total_non_zero = np.count_nonzero(image)\n    return float(non_zero_middle / total_non_zero) if total_non_zero > 0 else 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Calculate the vertical gradient magnitude at the middle column of the image.\"\n    h, w = image.shape\n    middle_column = image[:, w // 2]\n    gradient = np.gradient(middle_column)\n    return float(np.mean(np.abs(gradient)))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Gradient magnitude average difference between left and right halves of the image\"\n    gradients = np.gradient(image)\n    left_gradient_magnitude = np.mean(np.sqrt(gradients[0][:, :image.shape[1]//2]**2 + gradients[1][:, :image.shape[1]//2]**2))\n    right_gradient_magnitude = np.mean(np.sqrt(gradients[0][:, image.shape[1]//2:]**2 + gradients[1][:, image.shape[1]//2:]**2))\n    return float(left_gradient_magnitude - right_gradient_magnitude)\n",
    "def feature(image: np.ndarray) -> float:\n    \"Variance of pixel intensities in the top-left corner\"\n    h, w = image.shape\n    corner_region = image[0:h // 3, 0:w // 3]\n    return float(np.var(corner_region))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Mean pixel intensity of the horizontal center strip of the image'\n    h, w = image.shape\n    center_strip = image[h // 2 - 1:h // 2 + 1, :]\n    return float(np.mean(center_strip))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Count of corners detected in the image using Harris corner detection\"\n    import cv2\n    corners = cv2.cornerHarris(image.astype(np.float32), blockSize=2, ksize=3, k=0.04)\n    return float(np.sum(corners > 0.01 * corners.max()))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Difference in pixel intensity averages of the corners versus the center of the image.\"\n    corners = image[0, 0], image[0, -1], image[-1, 0], image[-1, -1]\n    center_h, center_w = image.shape[0] // 2, image.shape[1] // 2\n    center_region_avg = np.mean(image[center_h-1:center_h+1, center_w-1:center_w+1])\n    corners_avg = np.mean(corners)\n    return float(corners_avg - center_region_avg)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Variance of pixel intensities in the top-left corner\"\n    h, w = image.shape\n    corner_region = image[0:h // 3, 0:w // 3]\n    return float(np.var(corner_region))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Ratio of bright pixels in the top quarter of the image to the bottom quarter'\n    h, w = image.shape\n    top_quarter = image[:h//4, :]\n    bottom_quarter = image[3*h//4:, :]\n    bright_top = np.count_nonzero(top_quarter > 128)\n    bright_bottom = np.count_nonzero(bottom_quarter > 128)\n    return float(bright_top / (bright_bottom + 1e-5))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Mean gradient magnitude around the corners of the image\"\n    corners = image[0:10, 0:10]  # Top left corner\n    corners = np.concatenate((corners, image[0:10, -10:]))  # Top right corner\n    corners = np.concatenate((corners, image[-10:, 0:10]))  # Bottom left corner\n    corners = np.concatenate((corners, image[-10:, -10:]))  # Bottom right corner\n    gx, gy = np.gradient(corners.astype(float))\n    corner_gradient_magnitude = np.sqrt(gx**2 + gy**2)\n    return float(np.mean(corner_gradient_magnitude))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Compute the ratio of non-zero pixels on the diagonal to total non-zero pixels\"\n    diag_non_zero = np.count_nonzero([image[i, i] for i in range(min(image.shape))])\n    total_non_zero = np.count_nonzero(image)\n    return float(diag_non_zero / (total_non_zero + 1e-12))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Standard deviation of pixel intensities in the right third of the image'\n    h, w = image.shape\n    right_third = image[:, 2 * w // 3:]\n    return float(np.std(right_third))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Variance of pixel intensity in the vertical edges of the image\"\n    vertical_edges = np.gradient(image, axis=1)\n    return float(np.var(vertical_edges))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of non-zero pixels in the top quarter to the bottom quarter of the image\"\n    h, w = image.shape\n    top_quarter = image[:h // 4, :]\n    bottom_quarter = image[h * 3 // 4:, :]\n    top_nonzero = np.count_nonzero(top_quarter)\n    bottom_nonzero = np.count_nonzero(bottom_quarter)\n    return float(top_nonzero / (bottom_nonzero + 1e-5))  # Avoid division by zero\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Count of horizontal edges (variation in pixel intensity) in the image\"\n    gradient_x, gradient_y = np.gradient(image)\n    horizontal_edges = np.sum(np.abs(gradient_y))\n    return float(horizontal_edges)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Standard deviation of pixel intensities in the bottom left quarter\"\n    h, w = image.shape\n    bottom_left_quarter = image[h//2:, :w//2]\n    return float(np.std(bottom_left_quarter))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Count of local maxima in the image based on pixel intensity'\n    gradient = np.gradient(image)\n    local_maxima = np.count_nonzero((gradient[0] > 0) & (np.roll(gradient[0], 1) < 0))\n    return float(local_maxima)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Variance of pixel intensities in the top-left corner\"\n    h, w = image.shape\n    corner_region = image[0:h // 3, 0:w // 3]\n    return float(np.var(corner_region))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Gradient magnitude average difference between left and right halves of the image\"\n    gradients = np.gradient(image)\n    left_gradient_magnitude = np.mean(np.sqrt(gradients[0][:, :image.shape[1]//2]**2 + gradients[1][:, :image.shape[1]//2]**2))\n    right_gradient_magnitude = np.mean(np.sqrt(gradients[0][:, image.shape[1]//2:]**2 + gradients[1][:, image.shape[1]//2:]**2))\n    return float(left_gradient_magnitude - right_gradient_magnitude)\n",
    "def feature(image: np.ndarray) -> float:\n    \"Calculate the average gradient magnitude in the image, which indicates edges.\"\n    gradients = np.sqrt(np.sum(np.gradient(image.astype(float)), axis=0)**2)\n    return float(np.mean(gradients))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Compute the row-wise sum of pixel intensities and return the maximum value\"\n    return float(np.max(np.sum(image, axis=1)))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Count of corners detected in the image using Harris corner detection\"\n    import cv2\n    corners = cv2.cornerHarris(image.astype(np.float32), blockSize=2, ksize=3, k=0.04)\n    return float(np.sum(corners > 0.01 * corners.max()))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of non-zero pixel count in the middle third to the total non-zero pixels\"\n    h, w = image.shape\n    middle_region = image[h // 3:2 * h // 3, :]\n    non_zero_middle = np.count_nonzero(middle_region)\n    total_non_zero = np.count_nonzero(image)\n    return float(non_zero_middle / total_non_zero) if total_non_zero > 0 else 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Count of corners detected in the image using Harris corner detection\"\n    import cv2\n    corners = cv2.cornerHarris(image.astype(np.float32), blockSize=2, ksize=3, k=0.04)\n    return float(np.sum(corners > 0.01 * corners.max()))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Difference in pixel intensity averages of the corners versus the center of the image.\"\n    corners = image[0, 0], image[0, -1], image[-1, 0], image[-1, -1]\n    center_h, center_w = image.shape[0] // 2, image.shape[1] // 2\n    center_region_avg = np.mean(image[center_h-1:center_h+1, center_w-1:center_w+1])\n    corners_avg = np.mean(corners)\n    return float(corners_avg - center_region_avg)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Mean pixel intensity difference between left and right quarters of the image\"\n    h, w = image.shape\n    left_quarter = image[:, :w // 4]\n    right_quarter = image[:, 3 * w // 4:]\n    return float(np.mean(left_quarter) - np.mean(right_quarter))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Variance of pixel intensities in the top-left corner\"\n    h, w = image.shape\n    corner_region = image[0:h // 3, 0:w // 3]\n    return float(np.var(corner_region))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Determine the mean pixel intensity in the top-right quarter of the image.\"\n    h, w = image.shape\n    top_right_quarter = image[:h//2, w//2:]\n    return float(np.mean(top_right_quarter))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Mean pixel intensity of the bottom left region of the image.\"\n    h, w = image.shape\n    bottom_left = image[2*h//3:h, :w//2]\n    return float(np.mean(bottom_left))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Sum of pixel values in the bottom quarter of the image\"\n    h = image.shape[0]\n    bottom_quarter = image[3*h//4:h, :]\n    return float(np.sum(bottom_quarter))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Count of corners detected in the image using Harris corner detection\"\n    import cv2\n    corners = cv2.cornerHarris(image.astype(np.float32), blockSize=2, ksize=3, k=0.04)\n    return float(np.sum(corners > 0.01 * corners.max()))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Calculate the average gradient magnitude in the image, which indicates edges.\"\n    gradients = np.sqrt(np.sum(np.gradient(image.astype(float)), axis=0)**2)\n    return float(np.mean(gradients))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of the number of non-zero pixels in the upper-left to lower-right quarters of the image.\"\n    h, w = image.shape\n    upper_left = image[:h//2, :w//2]\n    lower_right = image[h//2:, w//2:]\n    return float(np.count_nonzero(upper_left) / (np.count_nonzero(lower_right) + 1e-5))\n",
    "def feature(image: np.ndarray) -> float:\n    'Count of non-zero rows in the right half of the image'\n    right_half = image[:, image.shape[1]//2:]\n    non_zero_rows = np.count_nonzero(np.any(right_half != 0, axis=1))\n    return float(non_zero_rows)\n",
    "def feature(image: np.ndarray) -> float:\n    'Mean pixel intensity of the inner region compared to the full image'\n    h, w = image.shape\n    inner_region = image[h//4:3*h//4, w//4:3*w//4]\n    return float(np.mean(inner_region) / (np.mean(image) + 1))\n",
    "def feature(image: np.ndarray) -> float:\n    'Calculate the symmetry of the image by comparing halves.'\n    h, w = image.shape\n    left_half = image[:, :w//2]\n    right_half = image[:, w//2:]\n    return float(np.mean(left_half) / (np.mean(right_half) or 1))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Calculate the average gradient magnitude in the image, which indicates edges.\"\n    gradients = np.sqrt(np.sum(np.gradient(image.astype(float)), axis=0)**2)\n    return float(np.mean(gradients))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of the sum of pixel values in the bottom-third region to the top-third region\"\n    h, w = image.shape\n    top_third = image[0:h//3, :]\n    bottom_third = image[2*h//3:h, :]\n    top_sum = np.sum(top_third)\n    bottom_sum = np.sum(bottom_third)\n    return float(bottom_sum / (top_sum + 1e-10))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Ratio of non-zero pixels in the upper right quadrant to the total non-zero pixels'\n    h, w = image.shape\n    upper_right_q = image[:h//2, w//2:]\n    non_zero_upper_right = np.count_nonzero(upper_right_q)\n    total_non_zero = np.count_nonzero(image)\n    return float(non_zero_upper_right / total_non_zero) if total_non_zero > 0 else 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Proportion of total pixels that are centered within a defined intensity range.\"\n    center_region = image[image.shape[0]//4:3*image.shape[0]//4, image.shape[1]//4:3*image.shape[1]//4]\n    centered_pixels = np.count_nonzero((center_region > 100) & (center_region < 200))\n    return float(centered_pixels) / (image.size + 1e-5)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of the mean pixel intensity of the bottom quarter to the top quarter.\"\n    h, w = image.shape\n    top_quarter = image[:h//4, :]\n    bottom_quarter = image[3*h//4:, :]\n    mean_top = np.mean(top_quarter)\n    mean_bottom = np.mean(bottom_quarter)\n    return float(mean_bottom / mean_top) if mean_top > 0 else 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Gradient magnitude of the image at the center row'\n    h, w = image.shape\n    center_row = image[h // 2, :]\n    gradient = np.gradient(center_row)\n    return float(np.linalg.norm(gradient))\n",
    "def feature(image: np.ndarray) -> float:\n    'Count of dark pixels in the bottom third of the image.'\n    h, w = image.shape\n    bottom_third = image[2*h//3:]\n    dark_pixels = np.count_nonzero(bottom_third < 128)\n    return float(dark_pixels)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Ratio of the number of non-zero pixels in the bottom third to total non-zero pixels in the image'\n    h, w = image.shape\n    bottom_third = image[2*h//3:, :]\n    total_non_zero = np.count_nonzero(image)\n    non_zero_bottom = np.count_nonzero(bottom_third)\n    return float(non_zero_bottom / total_non_zero) if total_non_zero > 0 else 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Calculate the vertical gradient magnitude at the middle column of the image.\"\n    h, w = image.shape\n    middle_column = image[:, w // 2]\n    gradient = np.gradient(middle_column)\n    return float(np.mean(np.abs(gradient)))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Max width of detected horizontal lines from image gradients'\n    horizontal_gradient = np.abs(np.gradient(image, axis=0))\n    horizontal_lines = np.sum(horizontal_gradient > 10, axis=0)\n    return float(np.max(horizontal_lines)) if horizontal_lines.size > 0 else 0.0\n",
    "def feature(image: np.ndarray) -> float:\n    \"Standard deviation of pixel intensities in the image's upper right quadrant\"\n    h, w = image.shape\n    upper_right = image[0:h//2, w//2:]\n    return float(np.std(upper_right))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Determine the sum of pixel values in the top quarter of the image.\"\n    top_quarter = image[:image.shape[0] // 4, :]\n    return float(np.sum(top_quarter))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Distributed count of diagonally oriented pixels (anti-diagonal)\"\n    anti_diagonal_count = np.count_nonzero(np.diag(image[::-1]))\n    return float(anti_diagonal_count)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Mean pixel intensity of the bottom left region of the image.\"\n    h, w = image.shape\n    bottom_left = image[2*h//3:h, :w//2]\n    return float(np.mean(bottom_left))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Sum of pixel intensities in the center column of the image\"\n    h, w = image.shape\n    center_col = image[:, w // 2]\n    return float(np.sum(center_col))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of horizontal pixel gradients to vertical pixel gradients\"\n    gradient_x, gradient_y = np.gradient(image)\n    horizontal_gradient = np.sum(np.abs(gradient_y))\n    vertical_gradient = np.sum(np.abs(gradient_x))\n    return horizontal_gradient / (vertical_gradient + 1e-5)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Distributed count of diagonally oriented pixels (anti-diagonal)\"\n    anti_diagonal_count = np.count_nonzero(np.diag(image[::-1]))\n    return float(anti_diagonal_count)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of non-zero pixels in the top third to total non-zero pixels\"\n    h, w = image.shape\n    top_third = image[0:h//3, :]\n    total_non_zero = np.count_nonzero(image)\n    top_non_zero = np.count_nonzero(top_third)\n    return float(top_non_zero / total_non_zero) if total_non_zero > 0 else 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Variance of pixel intensities in the top-left corner\"\n    h, w = image.shape\n    corner_region = image[0:h // 3, 0:w // 3]\n    return float(np.var(corner_region))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Count of columns with non-zero pixels in the lower half of the image\"\n    h, w = image.shape\n    lower_half = image[h//2:, :]\n    return float(np.count_nonzero(np.any(lower_half > 0, axis=0)))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Count of corners detected in the image using Harris corner detection\"\n    import cv2\n    corners = cv2.cornerHarris(image.astype(np.float32), blockSize=2, ksize=3, k=0.04)\n    return float(np.sum(corners > 0.01 * corners.max()))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Mean pixel intensity of the right edge of the image'\n    h, w = image.shape\n    right_edge = image[:, -5:]  # Last 5 columns as edge\n    return float(np.mean(right_edge))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Average pixel intensity of the image corners\"\n    h, w = image.shape\n    corners = np.concatenate((image[:h//4, :w//4], image[:h//4, 3*w//4:], \n                               image[3*h//4:, :w//4], image[3*h//4:, 3*w//4:]))\n    return float(np.mean(corners))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Count of non-zero rows in the right half of the image'\n    right_half = image[:, image.shape[1]//2:]\n    non_zero_rows = np.count_nonzero(np.any(right_half != 0, axis=1))\n    return float(non_zero_rows)\n",
    "def feature(image: np.ndarray) -> float:\n    \"Count of corners detected in the image using a simple threshold.\"\n    corners = np.count_nonzero((image[:-1, :-1] - image[1:, :-1] != 0) & \n                               (image[:-1, :-1] - image[:-1, 1:] != 0))\n    return float(corners)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Mean gradient magnitude around the corners of the image\"\n    corners = image[0:10, 0:10]  # Top left corner\n    corners = np.concatenate((corners, image[0:10, -10:]))  # Top right corner\n    corners = np.concatenate((corners, image[-10:, 0:10]))  # Bottom left corner\n    corners = np.concatenate((corners, image[-10:, -10:]))  # Bottom right corner\n    gx, gy = np.gradient(corners.astype(float))\n    corner_gradient_magnitude = np.sqrt(gx**2 + gy**2)\n    return float(np.mean(corner_gradient_magnitude))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Count of columns with non-zero pixels in the lower half of the image\"\n    h, w = image.shape\n    lower_half = image[h//2:, :]\n    return float(np.count_nonzero(np.any(lower_half > 0, axis=0)))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Distributed count of diagonally oriented pixels (anti-diagonal)\"\n    anti_diagonal_count = np.count_nonzero(np.diag(image[::-1]))\n    return float(anti_diagonal_count)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Mean pixel intensity of the image corners'\n    h, w = image.shape\n    corners = np.concatenate((image[0, 0:w//4], image[0, 3*w//4:w], image[h//4, 0:w//4], image[h//4, 3*w//4:w]))\n    return float(np.mean(corners))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Count of columns with non-zero pixels in the lower half of the image\"\n    h, w = image.shape\n    lower_half = image[h//2:, :]\n    return float(np.count_nonzero(np.any(lower_half > 0, axis=0)))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Count of non-zero pixels in the upper left quarter of the image\"\n    h, w = image.shape\n    upper_left_quarter = image[0:h//2, 0:w//2]\n    return float(np.count_nonzero(upper_left_quarter))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Analyze the variance of pixel intensities in the image corners.'\n    corners = image[:5, :5].flatten().tolist() + image[:5, -5:].flatten().tolist() + \\\n              image[-5:, :5].flatten().tolist() + image[-5:, -5:].flatten().tolist()\n    variance = np.var(corners)\n    return float(variance)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of the sum of pixel values in the bottom-third region to the top-third region\"\n    h, w = image.shape\n    top_third = image[0:h//3, :]\n    bottom_third = image[2*h//3:h, :]\n    top_sum = np.sum(top_third)\n    bottom_sum = np.sum(bottom_third)\n    return float(bottom_sum / (top_sum + 1e-10))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Mean pixel intensity of the right edge of the image'\n    h, w = image.shape\n    right_edge = image[:, -5:]  # Last 5 columns as edge\n    return float(np.mean(right_edge))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Count of peaks in the pixel intensity histogram\"\n    hist, _ = np.histogram(image, bins=256)\n    peaks = np.where((hist[1:-1] > hist[:-2]) & (hist[1:-1] > hist[2:]))[0]\n    return float(len(peaks))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of non-zero pixels to total pixels in the image\"\n    total_pixels = image.size\n    non_zero_pixels = np.count_nonzero(image)\n    return float(non_zero_pixels) / total_pixels if total_pixels > 0 else 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Count of non-zero rows in the right half of the image'\n    right_half = image[:, image.shape[1]//2:]\n    non_zero_rows = np.count_nonzero(np.any(right_half != 0, axis=1))\n    return float(non_zero_rows)\n",
    "def feature(image: np.ndarray) -> float:\n    \"Calculate the average gradient magnitude in the image, which indicates edges.\"\n    gradients = np.sqrt(np.sum(np.gradient(image.astype(float)), axis=0)**2)\n    return float(np.mean(gradients))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Mean of the bottom-left quadrant of the image\"\n    h, w = image.shape\n    bottom_left = image[h // 2:, :w // 2]\n    return float(np.mean(bottom_left))\n",
    "def feature(image: np.ndarray) -> float:\n    'Difference between the mean intensity of the upper and lower halves of the image'\n    h, w = image.shape\n    upper_half_mean = np.mean(image[0:h//2, :])\n    lower_half_mean = np.mean(image[h//2:, :])\n    return float(upper_half_mean - lower_half_mean)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Distributed count of diagonally oriented pixels (anti-diagonal)\"\n    anti_diagonal_count = np.count_nonzero(np.diag(image[::-1]))\n    return float(anti_diagonal_count)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of the sum of pixel values in the bottom-third region to the top-third region\"\n    h, w = image.shape\n    top_third = image[0:h//3, :]\n    bottom_third = image[2*h//3:h, :]\n    top_sum = np.sum(top_third)\n    bottom_sum = np.sum(bottom_third)\n    return float(bottom_sum / (top_sum + 1e-10))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Percentage of central region that is above a specific intensity\"\n    h, w = image.shape\n    center_region = image[h // 4:3 * h // 4, w // 4:3 * w // 4]\n    above_threshold = np.count_nonzero(center_region > 100)\n    total_center_pixels = center_region.size\n    return float(above_threshold / total_center_pixels)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Mean pixel intensity of the diagonal from bottom-left to top-right'\n    h, w = image.shape\n    diagonal = [image[h - i - 1, i] for i in range(min(h, w))]\n    return float(np.mean(diagonal))\n",
    "def feature(image: np.ndarray) -> float:\n    'Count edges detected in the top half of the image using Sobel filter'\n    sobel_x = np.array([[1, 0, -1], [2, 0, -2], [1, 0, -1]])\n    edges_x = np.abs(np.convolve(image.flatten(), sobel_x.flatten(), mode='same')).reshape(image.shape)\n    return float(np.count_nonzero(edges_x[:image.shape[0] // 2]))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Proportion of black pixels in the center region compared to the entire image'\n    h, w = image.shape\n    center_region = image[h // 4:3 * h // 4, w // 4:3 * w // 4]\n    black_pixels_center = np.count_nonzero(center_region == 0)\n    total_black_pixels = np.count_nonzero(image == 0)\n    return float(black_pixels_center) / float(total_black_pixels) if total_black_pixels > 0 else 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Mean pixel intensity in the left quarter of the image\"\n    left_quarter = image[:, :image.shape[1] // 4]\n    return float(np.mean(left_quarter))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Ratio of non-zero pixels in the top quarter to the image height'\n    top_quarter = image[:image.shape[0]//4, :]\n    count_non_zero_top = np.count_nonzero(top_quarter)\n    total_non_zero = np.count_nonzero(image)\n    return count_non_zero_top / total_non_zero if total_non_zero > 0 else 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of non-zero pixel count in the middle third to the total non-zero pixels\"\n    h, w = image.shape\n    middle_region = image[h // 3:2 * h // 3, :]\n    non_zero_middle = np.count_nonzero(middle_region)\n    total_non_zero = np.count_nonzero(image)\n    return float(non_zero_middle / total_non_zero) if total_non_zero > 0 else 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Count of contours detected using a simple threshold.\"\n    thresh = np.where(image > 128, 1, 0)\n    return float(np.count_nonzero(np.gradient(thresh)))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of non-zero pixels to total pixels in the image\"\n    total_pixels = image.size\n    non_zero_pixels = np.count_nonzero(image)\n    return float(non_zero_pixels) / total_pixels if total_pixels > 0 else 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Difference in mean intensity of the upper left and lower right quadrants'\n    h, w = image.shape\n    upper_left = image[:h // 2, :w // 2]\n    lower_right = image[h // 2:, w // 2:]\n    return float(np.mean(upper_left) - np.mean(lower_right))\n",
    "def feature(image: np.ndarray) -> float:\n    'Calculate the ratio of edge pixels (using the standard deviation) to total pixels'\n    edge_std = np.std(np.gradient(image.astype(float))[0])\n    total_pixels = image.size\n    return float(edge_std / total_pixels) if total_pixels > 0 else 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Calculate the vertical gradient magnitude at the middle column of the image.\"\n    h, w = image.shape\n    middle_column = image[:, w // 2]\n    gradient = np.gradient(middle_column)\n    return float(np.mean(np.abs(gradient)))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of non-zero pixels in the top quarter to the bottom quarter of the image\"\n    h, w = image.shape\n    top_quarter = image[:h // 4, :]\n    bottom_quarter = image[h * 3 // 4:, :]\n    top_nonzero = np.count_nonzero(top_quarter)\n    bottom_nonzero = np.count_nonzero(bottom_quarter)\n    return float(top_nonzero / (bottom_nonzero + 1e-5))  # Avoid division by zero\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Calculate the vertical gradient magnitude at the middle column of the image.\"\n    h, w = image.shape\n    middle_column = image[:, w // 2]\n    gradient = np.gradient(middle_column)\n    return float(np.mean(np.abs(gradient)))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Variance of pixel intensities around the image center\"\n    h, w = image.shape\n    center_h, center_w = h // 2, w // 2\n    center_region = image[center_h-1:center_h+2, center_w-1:center_w+2]\n    return float(np.var(center_region))\n",
    "def feature(image: np.ndarray) -> float:\n    \"Count of corners detected in the image using Harris corner detection\"\n    import cv2\n    corners = cv2.cornerHarris(image.astype(np.float32), blockSize=2, ksize=3, k=0.04)\n    return float(np.sum(corners > 0.01 * corners.max()))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Percentage of non-zero rows in the upper half of the image\"\n    upper_half = image[:image.shape[0] // 2]\n    non_zero_row_count = np.count_nonzero(np.any(upper_half > 0, axis=1))\n    return float(non_zero_row_count) / upper_half.shape[0]\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Count the number of clusters of non-zero pixels in the image.\"\n    non_zero_clusters = np.where(np.diff(np.pad(image > 0, 1, mode='constant')))[0]\n    return float(len(non_zero_clusters) / (image.size))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Calculate the vertical gradient magnitude at the middle column of the image.\"\n    h, w = image.shape\n    middle_column = image[:, w // 2]\n    gradient = np.gradient(middle_column)\n    return float(np.mean(np.abs(gradient)))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Proportion of pixels in the center region compared to the entire image\"\n    h, w = image.shape\n    center_region = image[h//4:3*h//4, w//4:3*w//4]\n    pixel_count = np.count_nonzero(image)\n    center_pixel_count = np.count_nonzero(center_region)\n    return float(center_pixel_count / pixel_count) if pixel_count > 0 else 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Count of local maxima in the image based on pixel intensity'\n    gradient = np.gradient(image)\n    local_maxima = np.count_nonzero((gradient[0] > 0) & (np.roll(gradient[0], 1) < 0))\n    return float(local_maxima)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Count of horizontal edges (variation in pixel intensity) in the image\"\n    gradient_x, gradient_y = np.gradient(image)\n    horizontal_edges = np.sum(np.abs(gradient_y))\n    return float(horizontal_edges)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Calculate the density of non-zero pixels in concentric circles from the center\"\n    h, w = image.shape\n    center = (h // 2, w // 2)\n    densities = []\n    for radius in range(1, min(center) // 2):\n        mask = (np.sqrt((np.arange(h)[:, None] - center[0])**2 + (np.arange(w) - center[1])**2) <= radius)\n        densities.append(np.count_nonzero(image[mask]))\n    return float(np.mean(densities))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Count of vertical edges detected in the image using Sobel filter'\n    sobel_x = np.array([[-1, 0, 1], [-2, 0, 2], [-1, 0, 1]])\n    edges = np.abs(np.convolve(image.flatten(), sobel_x.flatten(), 'same'))\n    return float(np.count_nonzero(edges))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Ratio of pixel intensity variance between the top and bottom halves of the image'\n    h, w = image.shape\n    top_half = image[:h//2, :]\n    bottom_half = image[h//2:, :]\n    variance_ratio = np.std(top_half) / (np.std(bottom_half) + 1e-5)  # Adding small value to avoid division by zero\n    return float(variance_ratio)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Average pixel intensity of the bottom third of the image.\"\n    h, w = image.shape\n    bottom_third = image[2*h//3:h]\n    return float(np.mean(bottom_third))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Calculate the ratio of non-zero pixels in the left quarter to the right quarter'\n    left_quarter = image[:, :image.shape[1] // 4]\n    right_quarter = image[:, 3*image.shape[1] // 4:]\n    non_zero_left = np.count_nonzero(left_quarter)\n    non_zero_right = np.count_nonzero(right_quarter)\n    return float(non_zero_left / (non_zero_right + 1e-10))  # Avoid division by zero\n",
    "def feature(image: np.ndarray) -> float:\n    'Calculate the difference in mean intensities between the upper and lower quarter regions'\n    upper_quarter = image[:image.shape[0]//4, :]\n    lower_quarter = image[3*image.shape[0]//4:, :]\n    return float(np.mean(upper_quarter) - np.mean(lower_quarter))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Count of columns with non-zero pixels in the lower half of the image\"\n    h, w = image.shape\n    lower_half = image[h//2:, :]\n    return float(np.count_nonzero(np.any(lower_half > 0, axis=0)))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Calculate the vertical gradient magnitude at the middle column of the image.\"\n    h, w = image.shape\n    middle_column = image[:, w // 2]\n    gradient = np.gradient(middle_column)\n    return float(np.mean(np.abs(gradient)))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Percentage of non-zero rows in the upper half of the image\"\n    upper_half = image[:image.shape[0] // 2]\n    non_zero_row_count = np.count_nonzero(np.any(upper_half > 0, axis=1))\n    return float(non_zero_row_count) / upper_half.shape[0]\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Measure the linearity of the pixel intensity profile along the rows of the image\"\n    profile = np.mean(image, axis=1)\n    return float(np.std(np.gradient(profile)))\n",
    "def feature(image: np.ndarray) -> float:\n    \"Count of non-zero rows in the bottom half of the image\"\n    h, w = image.shape\n    bottom_half = image[h // 2:, :]\n    non_zero_rows = np.count_nonzero(np.any(bottom_half, axis=1))\n    return float(non_zero_rows)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Ratio of non-zero pixels in the top quarter to the image height'\n    top_quarter = image[:image.shape[0]//4, :]\n    count_non_zero_top = np.count_nonzero(top_quarter)\n    total_non_zero = np.count_nonzero(image)\n    return count_non_zero_top / total_non_zero if total_non_zero > 0 else 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Difference in pixel intensity averages of the corners versus the center of the image.\"\n    corners = image[0, 0], image[0, -1], image[-1, 0], image[-1, -1]\n    center_h, center_w = image.shape[0] // 2, image.shape[1] // 2\n    center_region_avg = np.mean(image[center_h-1:center_h+1, center_w-1:center_w+1])\n    corners_avg = np.mean(corners)\n    return float(corners_avg - center_region_avg)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Compactness of the image defined as the ratio of non-zero area to perimeter squared'\n    binary_image = (image > 0).astype(int)\n    area = np.sum(binary_image)\n    perimeter = np.count_nonzero(np.gradient(binary_image))\n    return float(area / (perimeter ** 2)) if perimeter > 0 else 0.0\n",
    "def feature(image: np.ndarray) -> float:\n    \"Mean pixel intensity of the image edges\"\n    edges = np.gradient(image)\n    edge_magnitude = np.sqrt(edges[0]**2 + edges[1]**2)\n    return float(np.mean(edge_magnitude))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Variance of pixel intensities around the image center\"\n    h, w = image.shape\n    center_h, center_w = h // 2, w // 2\n    center_region = image[center_h-1:center_h+2, center_w-1:center_w+2]\n    return float(np.var(center_region))\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of the sum of pixel values in the bottom-third region to the top-third region\"\n    h, w = image.shape\n    top_third = image[0:h//3, :]\n    bottom_third = image[2*h//3:h, :]\n    top_sum = np.sum(top_third)\n    bottom_sum = np.sum(bottom_third)\n    return float(bottom_sum / (top_sum + 1e-10))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of the mean pixel intensity of the bottom quarter to the top quarter.\"\n    h, w = image.shape\n    top_quarter = image[:h//4, :]\n    bottom_quarter = image[3*h//4:, :]\n    mean_top = np.mean(top_quarter)\n    mean_bottom = np.mean(bottom_quarter)\n    return float(mean_bottom / mean_top) if mean_top > 0 else 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Calculate the intensity variance in the regions formed by splitting the image vertically\"\n    left_half = image[:, :image.shape[1] // 2]\n    right_half = image[:, image.shape[1] // 2:]\n    return float(np.var(left_half) - np.var(right_half))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Count of corners detected in the image using Harris corner detection\"\n    import cv2\n    corners = cv2.cornerHarris(image.astype(np.float32), blockSize=2, ksize=3, k=0.04)\n    return float(np.sum(corners > 0.01 * corners.max()))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Mean of the maximum pixel values in each row\"\n    return float(np.mean(np.max(image, axis=1)))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Mean pixel intensity of pixels in the left half of the image'\n    left_half = image[:, :image.shape[1] // 2]\n    return float(np.mean(left_half))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Gradient magnitude of the image at the center row'\n    h, w = image.shape\n    center_row = image[h // 2, :]\n    gradient = np.gradient(center_row)\n    return float(np.linalg.norm(gradient))\n",
    "def feature(image: np.ndarray) -> float:\n    \"Count of vertical edges detected using Sobel filter\"\n    gradient_y = np.abs(np.gradient(image, axis=0))\n    vertical_edges = np.sum(gradient_y > 0)\n    return float(vertical_edges)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Variance of pixel intensities around the image center\"\n    h, w = image.shape\n    center_h, center_w = h // 2, w // 2\n    center_region = image[center_h-1:center_h+2, center_w-1:center_w+2]\n    return float(np.var(center_region))\n",
    "def feature(image: np.ndarray) -> float:\n    'Ratio of non-zero pixels in the upper right quadrant to the total non-zero pixels'\n    h, w = image.shape\n    upper_right_q = image[:h//2, w//2:]\n    non_zero_upper_right = np.count_nonzero(upper_right_q)\n    total_non_zero = np.count_nonzero(image)\n    return float(non_zero_upper_right / total_non_zero) if total_non_zero > 0 else 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Sharpness of the image calculated as the standard deviation of pixel differences\"\n    gradient = np.gradient(image)\n    sharpness = np.std(np.abs(gradient[0]) + np.abs(gradient[1]))\n    return float(sharpness)\n",
    "def feature(image: np.ndarray) -> float:\n    'Gradient magnitude of the image at the center row'\n    h, w = image.shape\n    center_row = image[h // 2, :]\n    gradient = np.gradient(center_row)\n    return float(np.linalg.norm(gradient))\n",
    "def feature(image: np.ndarray) -> float:\n    \"Measure of image sharpness based on variance of gradients.\"\n    gradients = np.gradient(image)\n    gradient_magnitude = np.sqrt(gradients[0]**2 + gradients[1]**2)\n    return float(np.std(gradient_magnitude))\n",
    "def feature(image: np.ndarray) -> float:\n    \"Mean pixel intensity of the bottom right quadrant of the image\"\n    h, w = image.shape\n    bottom_right = image[h//2:, w//2:]\n    return float(np.mean(bottom_right))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of non-zero pixels to total pixels in the image\"\n    total_pixels = image.size\n    non_zero_pixels = np.count_nonzero(image)\n    return float(non_zero_pixels) / total_pixels if total_pixels > 0 else 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Count of changes in intensity along the middle row of the image\"\n    mid_row = image[image.shape[0] // 2, :]\n    changes = np.sum(np.abs(np.diff(mid_row)) > 10)  # Threshold for detecting intensity change\n    return float(changes)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of non-zero pixels to total pixels in the image\"\n    total_pixels = image.size\n    non_zero_pixels = np.count_nonzero(image)\n    return float(non_zero_pixels) / total_pixels if total_pixels > 0 else 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of the mean pixel value of the left third to the right third of the image\"\n    h, w = image.shape\n    left_third_mean = np.mean(image[:, :w//3])\n    right_third_mean = np.mean(image[:, 2*w//3:])\n    return left_third_mean / (right_third_mean + 1e-5)\n",
    "def feature(image: np.ndarray) -> float:\n    \"Standard deviation of pixel intensities in the whole image\"\n    return float(np.std(image))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Average pixel intensity along the horizontal midline of the image\"\n    h, w = image.shape\n    midline = image[h // 2, :]\n    return float(np.mean(midline))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of non-zero pixels to total pixels in the image\"\n    total_pixels = image.size\n    non_zero_pixels = np.count_nonzero(image)\n    return float(non_zero_pixels) / total_pixels if total_pixels > 0 else 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Count of non-zero rows in the bottom half of the image\"\n    h, w = image.shape\n    bottom_half = image[h // 2:, :]\n    non_zero_rows = np.count_nonzero(np.any(bottom_half, axis=1))\n    return float(non_zero_rows)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Measure the density of edges within a certain distance from the center.'\n    h, w = image.shape\n    center_region = image[h//4:3*h//4, w//4:3*w//4]\n    edges = np.gradient(center_region)\n    edge_density = np.count_nonzero(edges[0]) + np.count_nonzero(edges[1])\n    return float(edge_density)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Difference between the mean intensity of the upper and lower halves of the image'\n    h, w = image.shape\n    upper_half_mean = np.mean(image[0:h//2, :])\n    lower_half_mean = np.mean(image[h//2:, :])\n    return float(upper_half_mean - lower_half_mean)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Count the number of rows that have more than a set number of non-zero pixels'\n    threshold = 5\n    high_pixel_rows = np.sum(np.count_nonzero(image, axis=1) > threshold)\n    return float(high_pixel_rows)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of non-zero pixel count in the middle third to the total non-zero pixels\"\n    h, w = image.shape\n    middle_region = image[h // 3:2 * h // 3, :]\n    non_zero_middle = np.count_nonzero(middle_region)\n    total_non_zero = np.count_nonzero(image)\n    return float(non_zero_middle / total_non_zero) if total_non_zero > 0 else 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Proportion of diagonal pixels (from top left to bottom right) to total pixels\"\n    h, w = image.shape\n    diagonal_count = min(h, w)\n    diagonal_sum = np.sum(image[np.arange(diagonal_count), np.arange(diagonal_count)])\n    total_sum = np.sum(image)\n    return float(diagonal_sum / total_sum) if total_sum > 0 else 0.0\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of non-zero pixels to total pixels in the image\"\n    total_pixels = image.size\n    non_zero_pixels = np.count_nonzero(image)\n    return float(non_zero_pixels) / total_pixels if total_pixels > 0 else 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Mean pixel intensity of the diagonal from top-left to bottom-right'\n    diagonal = np.diagonal(image)\n    return float(np.mean(diagonal))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Measure the central pixel intensity relative to the mean intensity of the image\"\n    mean_intensity = np.mean(image)\n    center_pixel = image[image.shape[0] // 2, image.shape[1] // 2]\n    return float(center_pixel / (mean_intensity + 1e-5))  # Avoid division by zero\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Sum of the pixel intensities in the upper half of the image'\n    upper_half = image[:image.shape[0] // 2, :]\n    return float(np.sum(upper_half))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Calculate the intensity variance in the regions formed by splitting the image vertically\"\n    left_half = image[:, :image.shape[1] // 2]\n    right_half = image[:, image.shape[1] // 2:]\n    return float(np.var(left_half) - np.var(right_half))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Count of corners detected in the image using a simple threshold.\"\n    corners = np.count_nonzero((image[:-1, :-1] - image[1:, :-1] != 0) & \n                               (image[:-1, :-1] - image[:-1, 1:] != 0))\n    return float(corners)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of non-zero pixels to total pixels in the image\"\n    total_pixels = image.size\n    non_zero_pixels = np.count_nonzero(image)\n    return float(non_zero_pixels) / total_pixels if total_pixels > 0 else 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Count of non-zero rows in the right half of the image'\n    right_half = image[:, image.shape[1]//2:]\n    non_zero_rows = np.count_nonzero(np.any(right_half != 0, axis=1))\n    return float(non_zero_rows)\n",
    "def feature(image: np.ndarray) -> float:\n    'Count of local maxima in the image based on pixel intensity'\n    gradient = np.gradient(image)\n    local_maxima = np.count_nonzero((gradient[0] > 0) & (np.roll(gradient[0], 1) < 0))\n    return float(local_maxima)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Measure the variance of pixel intensities in the horizontal center strip of the image.\"\n    h, w = image.shape\n    center_strip = image[h//2, :]\n    return float(np.var(center_strip))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of non-zero pixels in the top third to total non-zero pixels\"\n    h, w = image.shape\n    top_third = image[0:h//3, :]\n    total_non_zero = np.count_nonzero(image)\n    top_non_zero = np.count_nonzero(top_third)\n    return float(top_non_zero / total_non_zero) if total_non_zero > 0 else 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of non-zero pixels to total pixels in the image\"\n    total_pixels = image.size\n    non_zero_pixels = np.count_nonzero(image)\n    return float(non_zero_pixels) / total_pixels if total_pixels > 0 else 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of non-zero pixels in the center region to non-zero pixels in the corners.\"\n    h, w = image.shape\n    center_region = image[h // 4:3 * h // 4, w // 4:3 * w // 4]\n    corners = np.concatenate((image[:h // 4, :w // 4], image[:h // 4, 3*w//4:w], \n                               image[3*h//4:h, :w // 4], image[3*h//4:h, 3*w//4:w]))\n    \n    center_nonzero = np.count_nonzero(center_region)\n    corners_nonzero = np.count_nonzero(corners)\n    return float(center_nonzero) / (corners_nonzero + 1e-6)\n",
    "def feature(image: np.ndarray) -> float:\n    \"Calculate the sum of pixel intensities in concentric circles around the center.\"\n    h, w = image.shape\n    center = (h // 2, w // 2)\n    total_sum = 0\n    for r in range(1, min(center) // 2):  # For concentric circles\n        mask = (np.indices(image.shape) - np.array(center).reshape(2, 1, 1))**2\n        mask = (mask[0]**2 + mask[1]**2) <= r**2\n        total_sum += np.sum(image[mask])\n    return float(total_sum)\n",
    "def feature(image: np.ndarray) -> float:\n    \"Count of corners detected in the image using Harris corner detection\"\n    import cv2\n    corners = cv2.cornerHarris(image.astype(np.float32), blockSize=2, ksize=3, k=0.04)\n    return float(np.sum(corners > 0.01 * corners.max()))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Calculate the proportion of pixels in the bottom third of the image that are non-zero.\"\n    h, _ = image.shape\n    bottom_third = image[2*h // 3:, :]\n    non_zero_count = np.count_nonzero(bottom_third)\n    return float(non_zero_count) / (bottom_third.size) if bottom_third.size > 0 else 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Calculate the vertical gradient magnitude at the middle column of the image.\"\n    h, w = image.shape\n    middle_column = image[:, w // 2]\n    gradient = np.gradient(middle_column)\n    return float(np.mean(np.abs(gradient)))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Ratio of the number of non-zero pixels in the bottom third to total non-zero pixels in the image'\n    h, w = image.shape\n    bottom_third = image[2*h//3:, :]\n    total_non_zero = np.count_nonzero(image)\n    non_zero_bottom = np.count_nonzero(bottom_third)\n    return float(non_zero_bottom / total_non_zero) if total_non_zero > 0 else 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of non-zero pixels to total pixels in the image\"\n    total_pixels = image.size\n    non_zero_pixels = np.count_nonzero(image)\n    return float(non_zero_pixels) / total_pixels if total_pixels > 0 else 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of non-zero pixels to total pixels in the image\"\n    total_pixels = image.size\n    non_zero_pixels = np.count_nonzero(image)\n    return float(non_zero_pixels) / total_pixels if total_pixels > 0 else 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Density of pixels in the lower half compared to the upper half\"\n    h, w = image.shape\n    lower_half_density = np.count_nonzero(image[h//2:]) / (h * w)\n    upper_half_density = np.count_nonzero(image[:h//2]) / (h * w)\n    return float(lower_half_density - upper_half_density)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Mean pixel intensity of the diagonal from bottom-left to top-right'\n    h, w = image.shape\n    diagonal = [image[h - i - 1, i] for i in range(min(h, w))]\n    return float(np.mean(diagonal))\n",
    "def feature(image: np.ndarray) -> float:\n    'Mean pixel intensity of the image corners'\n    h, w = image.shape\n    corners = np.concatenate((image[0, 0:w//4], image[0, 3*w//4:w], image[h//4, 0:w//4], image[h//4, 3*w//4:w]))\n    return float(np.mean(corners))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Determine the ratio of dark pixels (below a threshold) in the upper half to the total dark pixels in the image'\n    threshold = 50\n    dark_upper_half = np.count_nonzero(image[0:image.shape[0]//2] < threshold)\n    total_dark = np.count_nonzero(image < threshold)\n    return float(dark_upper_half / (total_dark + 1e-5))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Proportion of diagonal pixels (from top left to bottom right) to total pixels\"\n    h, w = image.shape\n    diagonal_count = min(h, w)\n    diagonal_sum = np.sum(image[np.arange(diagonal_count), np.arange(diagonal_count)])\n    total_sum = np.sum(image)\n    return float(diagonal_sum / total_sum) if total_sum > 0 else 0.0\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of non-zero pixels to total pixels in the image\"\n    total_pixels = image.size\n    non_zero_pixels = np.count_nonzero(image)\n    return float(non_zero_pixels) / total_pixels if total_pixels > 0 else 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of pixel intensities in the bottom quarter relative to the entire image.\"\n    bottom_quarter = image[3 * image.shape[0] // 4:]\n    sum_bottom = np.sum(bottom_quarter)\n    sum_total = np.sum(image)\n    if sum_total == 0:\n        return 0.0\n    return float(sum_bottom) / sum_total\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Mean of the horizontal gradient magnitudes for the bottom half of the image\"\n    h, w = image.shape\n    bottom_half = image[h//2:, :]\n    horizontal_gradient = np.gradient(bottom_half, axis=1)\n    return float(np.mean(np.abs(horizontal_gradient)))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Count of corners detected in the image using Harris corner detection\"\n    import cv2\n    corners = cv2.cornerHarris(image.astype(np.float32), blockSize=2, ksize=3, k=0.04)\n    return float(np.sum(corners > 0.01 * corners.max()))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Count the number of rows that have more than a set number of non-zero pixels'\n    threshold = 5\n    high_pixel_rows = np.sum(np.count_nonzero(image, axis=1) > threshold)\n    return float(high_pixel_rows)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Average pixel intensity of the bottom third of the image.\"\n    h, w = image.shape\n    bottom_third = image[2*h//3:h]\n    return float(np.mean(bottom_third))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Measure the variance of pixel intensities in the horizontal center strip of the image.\"\n    h, w = image.shape\n    center_strip = image[h//2, :]\n    return float(np.var(center_strip))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Mean pixel intensity of the central horizontal band of the image\"\n    h, w = image.shape\n    central_band = image[h // 3: 2 * h // 3, :]\n    return float(np.mean(central_band))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of diagonal edge intensity to total edge intensity in the image\"\n    gradient = np.sqrt(np.gradient(image, axis=0)**2 + np.gradient(image, axis=1)**2)\n    diagonal_edges = gradient[np.diag_indices(min(image.shape))].sum()  # Diagonal edge intensity\n    total_edges = np.sum(gradient)\n    return float(diagonal_edges / total_edges) if total_edges > 0 else 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of diagonal edge intensity to total edge intensity in the image\"\n    gradient = np.sqrt(np.gradient(image, axis=0)**2 + np.gradient(image, axis=1)**2)\n    diagonal_edges = gradient[np.diag_indices(min(image.shape))].sum()  # Diagonal edge intensity\n    total_edges = np.sum(gradient)\n    return float(diagonal_edges / total_edges) if total_edges > 0 else 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Horizontal gradient magnitude at the middle row of the image\"\n    grad_x = np.gradient(image, axis=1)\n    return float(np.mean(np.abs(grad_x[image.shape[0] // 2])))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Difference in average intensity between the left and right halves of the image\"\n    h, w = image.shape\n    left_half = image[:, :w // 2]\n    right_half = image[:, w // 2:]\n    return float(np.mean(left_half) - np.mean(right_half))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Mean of the maximum pixel intensity in the left half of the image\"\n    left_half = image[:, :image.shape[1] // 2]\n    return float(np.mean(np.max(left_half, axis=0)))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Count of non-zero rows in the right half of the image'\n    right_half = image[:, image.shape[1]//2:]\n    non_zero_rows = np.count_nonzero(np.any(right_half != 0, axis=1))\n    return float(non_zero_rows)\n",
    "def feature(image: np.ndarray) -> float:\n    'Gradient magnitude of the image at the center row'\n    h, w = image.shape\n    center_row = image[h // 2, :]\n    gradient = np.gradient(center_row)\n    return float(np.linalg.norm(gradient))\n",
    "def feature(image: np.ndarray) -> float:\n    \"Count of non-zero pixels in the top quarter of the image\"\n    h, w = image.shape\n    top_quarter = image[:h // 4, :]\n    return float(np.count_nonzero(top_quarter))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of non-zero pixels to total pixels in the image\"\n    total_pixels = image.size\n    non_zero_pixels = np.count_nonzero(image)\n    return float(non_zero_pixels) / total_pixels if total_pixels > 0 else 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Sum of the pixel intensities in the upper half of the image'\n    upper_half = image[:image.shape[0] // 2, :]\n    return float(np.sum(upper_half))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Calculate the vertical gradient magnitude at the middle column of the image.\"\n    h, w = image.shape\n    middle_column = image[:, w // 2]\n    gradient = np.gradient(middle_column)\n    return float(np.mean(np.abs(gradient)))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of non-zero pixels to total pixels in the image\"\n    total_pixels = image.size\n    non_zero_pixels = np.count_nonzero(image)\n    return float(non_zero_pixels) / total_pixels if total_pixels > 0 else 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Difference in average intensity between the left and right halves of the image\"\n    h, w = image.shape\n    left_half = image[:, :w // 2]\n    right_half = image[:, w // 2:]\n    return float(np.mean(left_half) - np.mean(right_half))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Standard deviation of pixel intensities in the image's upper right quadrant\"\n    h, w = image.shape\n    upper_right = image[0:h//2, w//2:]\n    return float(np.std(upper_right))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Difference in average intensity between the left and right halves of the image\"\n    h, w = image.shape\n    left_half = image[:, :w // 2]\n    right_half = image[:, w // 2:]\n    return float(np.mean(left_half) - np.mean(right_half))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Mean intensity value of pixels within a circular region at the center of the image\"\n    h, w = image.shape\n    center = (h // 2, w // 2)\n    radius = min(h, w) // 6\n    y, x = np.ogrid[:h, :w]\n    mask = (y - center[0])**2 + (x - center[1])**2 <= radius**2\n    return float(np.mean(image[mask]))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of non-zero pixels to total pixels in the image\"\n    total_pixels = image.size\n    non_zero_pixels = np.count_nonzero(image)\n    return float(non_zero_pixels) / total_pixels if total_pixels > 0 else 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Sum of the top 10% pixel intensities in the image'\n    threshold = np.percentile(image, 90)\n    return float(np.sum(image[image > threshold]))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of pixel intensity variance between left and right halves of the image\"\n    left_half = image[:, :image.shape[1] // 2]\n    right_half = image[:, image.shape[1] // 2:]\n    return float(np.var(left_half) / (np.var(right_half) + 1e-6))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of non-zero pixels to total pixels in the image\"\n    total_pixels = image.size\n    non_zero_pixels = np.count_nonzero(image)\n    return float(non_zero_pixels) / total_pixels if total_pixels > 0 else 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of non-zero pixels to total pixels in the image\"\n    total_pixels = image.size\n    non_zero_pixels = np.count_nonzero(image)\n    return float(non_zero_pixels) / total_pixels if total_pixels > 0 else 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of non-zero pixels to total pixels in the image\"\n    total_pixels = image.size\n    non_zero_pixels = np.count_nonzero(image)\n    return float(non_zero_pixels) / total_pixels if total_pixels > 0 else 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of non-zero pixels to total pixels in the image\"\n    total_pixels = image.size\n    non_zero_pixels = np.count_nonzero(image)\n    return float(non_zero_pixels) / total_pixels if total_pixels > 0 else 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of non-zero pixels to total pixels in the image\"\n    total_pixels = image.size\n    non_zero_pixels = np.count_nonzero(image)\n    return float(non_zero_pixels) / total_pixels if total_pixels > 0 else 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of non-zero pixels to total pixels in the image\"\n    total_pixels = image.size\n    non_zero_pixels = np.count_nonzero(image)\n    return float(non_zero_pixels) / total_pixels if total_pixels > 0 else 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of non-zero pixels to total pixels in the image\"\n    total_pixels = image.size\n    non_zero_pixels = np.count_nonzero(image)\n    return float(non_zero_pixels) / total_pixels if total_pixels > 0 else 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Standard deviation of pixel intensities in the whole image\"\n    return float(np.std(image))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Determine the sum of pixel values in the top quarter of the image.\"\n    top_quarter = image[:image.shape[0] // 4, :]\n    return float(np.sum(top_quarter))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Determine the variance of pixel values in the central vertical strip of the image.\"\n    h, w = image.shape\n    central_strip = image[:, w // 2 - 1:w // 2 + 1]\n    return float(np.var(central_strip))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Mean pixel intensity of the bottom half of the image\"\n    h, w = image.shape\n    bottom_half = image[h//2:, :]\n    return float(np.mean(bottom_half))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of non-zero pixels to total pixels in the image\"\n    total_pixels = image.size\n    non_zero_pixels = np.count_nonzero(image)\n    return float(non_zero_pixels) / total_pixels if total_pixels > 0 else 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of non-zero pixels to total pixels in the image\"\n    total_pixels = image.size\n    non_zero_pixels = np.count_nonzero(image)\n    return float(non_zero_pixels) / total_pixels if total_pixels > 0 else 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Calculate the difference between the maximum and minimum pixel values in the central region.\"\n    h, w = image.shape\n    center_region = image[h//4:3*h//4, w//4:3*w//4]\n    return float(np.max(center_region) - np.min(center_region))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of non-zero pixels to total pixels in the image\"\n    total_pixels = image.size\n    non_zero_pixels = np.count_nonzero(image)\n    return float(non_zero_pixels) / total_pixels if total_pixels > 0 else 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of non-zero pixels to total pixels in the image\"\n    total_pixels = image.size\n    non_zero_pixels = np.count_nonzero(image)\n    return float(non_zero_pixels) / total_pixels if total_pixels > 0 else 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of non-zero pixels to total pixels in the image\"\n    total_pixels = image.size\n    non_zero_pixels = np.count_nonzero(image)\n    return float(non_zero_pixels) / total_pixels if total_pixels > 0 else 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of non-zero pixels to total pixels in the image\"\n    total_pixels = image.size\n    non_zero_pixels = np.count_nonzero(image)\n    return float(non_zero_pixels) / total_pixels if total_pixels > 0 else 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of non-zero pixels to total pixels in the image\"\n    total_pixels = image.size\n    non_zero_pixels = np.count_nonzero(image)\n    return float(non_zero_pixels) / total_pixels if total_pixels > 0 else 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of non-zero pixels to total pixels in the image\"\n    total_pixels = image.size\n    non_zero_pixels = np.count_nonzero(image)\n    return float(non_zero_pixels) / total_pixels if total_pixels > 0 else 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Difference between max and min pixel intensities\"\n    return float(np.max(image) - np.min(image))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Difference between max and min pixel intensities\"\n    return float(np.max(image) - np.min(image))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of non-zero pixels to total pixels in the image\"\n    total_pixels = image.size\n    non_zero_pixels = np.count_nonzero(image)\n    return float(non_zero_pixels) / total_pixels if total_pixels > 0 else 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of non-zero pixels to total pixels in the image\"\n    total_pixels = image.size\n    non_zero_pixels = np.count_nonzero(image)\n    return float(non_zero_pixels) / total_pixels if total_pixels > 0 else 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of non-zero pixels to total pixels in the image\"\n    total_pixels = image.size\n    non_zero_pixels = np.count_nonzero(image)\n    return float(non_zero_pixels) / total_pixels if total_pixels > 0 else 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of non-zero pixels to total pixels in the image\"\n    total_pixels = image.size\n    non_zero_pixels = np.count_nonzero(image)\n    return float(non_zero_pixels) / total_pixels if total_pixels > 0 else 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of non-zero pixels to total pixels in the image\"\n    total_pixels = image.size\n    non_zero_pixels = np.count_nonzero(image)\n    return float(non_zero_pixels) / total_pixels if total_pixels > 0 else 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Sum of pixel intensities in the center region\"\n    h, w = image.shape\n    center_h, center_w = h // 4, w // 4\n    center_region = image[center_h:3*center_h, center_w:3*center_w]\n    return float(np.sum(center_region))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of non-zero pixels to total pixels in the image\"\n    total_pixels = image.size\n    non_zero_pixels = np.count_nonzero(image)\n    return float(non_zero_pixels) / total_pixels if total_pixels > 0 else 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of non-zero pixels to total pixels in the image\"\n    total_pixels = image.size\n    non_zero_pixels = np.count_nonzero(image)\n    return float(non_zero_pixels) / total_pixels if total_pixels > 0 else 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of non-zero pixels to total pixels in the image\"\n    total_pixels = image.size\n    non_zero_pixels = np.count_nonzero(image)\n    return float(non_zero_pixels) / total_pixels if total_pixels > 0 else 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of non-zero pixels to total pixels in the image\"\n    total_pixels = image.size\n    non_zero_pixels = np.count_nonzero(image)\n    return float(non_zero_pixels) / total_pixels if total_pixels > 0 else 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of non-zero pixels to total pixels in the image\"\n    total_pixels = image.size\n    non_zero_pixels = np.count_nonzero(image)\n    return float(non_zero_pixels) / total_pixels if total_pixels > 0 else 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of non-zero pixels to total pixels in the image\"\n    total_pixels = image.size\n    non_zero_pixels = np.count_nonzero(image)\n    return float(non_zero_pixels) / total_pixels if total_pixels > 0 else 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of non-zero pixels to total pixels in the image\"\n    total_pixels = image.size\n    non_zero_pixels = np.count_nonzero(image)\n    return float(non_zero_pixels) / total_pixels if total_pixels > 0 else 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of non-zero pixels to total pixels in the image\"\n    total_pixels = image.size\n    non_zero_pixels = np.count_nonzero(image)\n    return float(non_zero_pixels) / total_pixels if total_pixels > 0 else 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of non-zero pixels to total pixels in the image\"\n    total_pixels = image.size\n    non_zero_pixels = np.count_nonzero(image)\n    return float(non_zero_pixels) / total_pixels if total_pixels > 0 else 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Measure the variance of pixel intensities in the horizontal center strip of the image.\"\n    h, w = image.shape\n    center_strip = image[h//2, :]\n    return float(np.var(center_strip))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of non-zero pixels to total pixels in the image\"\n    total_pixels = image.size\n    non_zero_pixels = np.count_nonzero(image)\n    return float(non_zero_pixels) / total_pixels if total_pixels > 0 else 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of non-zero pixels to total pixels in the image\"\n    total_pixels = image.size\n    non_zero_pixels = np.count_nonzero(image)\n    return float(non_zero_pixels) / total_pixels if total_pixels > 0 else 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of non-zero pixels to total pixels in the image\"\n    total_pixels = image.size\n    non_zero_pixels = np.count_nonzero(image)\n    return float(non_zero_pixels) / total_pixels if total_pixels > 0 else 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of non-zero pixels to total pixels in the image\"\n    total_pixels = image.size\n    non_zero_pixels = np.count_nonzero(image)\n    return float(non_zero_pixels) / total_pixels if total_pixels > 0 else 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of non-zero pixels to total pixels in the image\"\n    total_pixels = image.size\n    non_zero_pixels = np.count_nonzero(image)\n    return float(non_zero_pixels) / total_pixels if total_pixels > 0 else 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of non-zero pixels to total pixels in the image\"\n    total_pixels = image.size\n    non_zero_pixels = np.count_nonzero(image)\n    return float(non_zero_pixels) / total_pixels if total_pixels > 0 else 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of non-zero pixels to total pixels in the image\"\n    total_pixels = image.size\n    non_zero_pixels = np.count_nonzero(image)\n    return float(non_zero_pixels) / total_pixels if total_pixels > 0 else 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of non-zero pixels to total pixels in the image\"\n    total_pixels = image.size\n    non_zero_pixels = np.count_nonzero(image)\n    return float(non_zero_pixels) / total_pixels if total_pixels > 0 else 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of non-zero pixels to total pixels in the image\"\n    total_pixels = image.size\n    non_zero_pixels = np.count_nonzero(image)\n    return float(non_zero_pixels) / total_pixels if total_pixels > 0 else 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of non-zero pixels to total pixels in the image\"\n    total_pixels = image.size\n    non_zero_pixels = np.count_nonzero(image)\n    return float(non_zero_pixels) / total_pixels if total_pixels > 0 else 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of non-zero pixels to total pixels in the image\"\n    total_pixels = image.size\n    non_zero_pixels = np.count_nonzero(image)\n    return float(non_zero_pixels) / total_pixels if total_pixels > 0 else 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of non-zero pixels in the top quarter to the bottom quarter of the image\"\n    h, w = image.shape\n    top_quarter = image[:h // 4, :]\n    bottom_quarter = image[h * 3 // 4:, :]\n    top_nonzero = np.count_nonzero(top_quarter)\n    bottom_nonzero = np.count_nonzero(bottom_quarter)\n    return float(top_nonzero / (bottom_nonzero + 1e-5))  # Avoid division by zero\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Calculate the horizontal gradient of the image and return its mean.\"\n    gradients = np.gradient(image, axis=1)\n    return float(np.mean(gradients))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Calculate the intensity variance in the regions formed by splitting the image vertically\"\n    left_half = image[:, :image.shape[1] // 2]\n    right_half = image[:, image.shape[1] // 2:]\n    return float(np.var(left_half) - np.var(right_half))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Sharpness of the image calculated as the standard deviation of pixel differences\"\n    gradient = np.gradient(image)\n    sharpness = np.std(np.abs(gradient[0]) + np.abs(gradient[1]))\n    return float(sharpness)\n",
    "def feature(image: np.ndarray) -> float:\n    \"Count of columns with non-zero pixels in the lower half of the image\"\n    h, w = image.shape\n    lower_half = image[h//2:, :]\n    return float(np.count_nonzero(np.any(lower_half > 0, axis=0)))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of non-zero pixels in the upper-left quadrant to total non-zero pixels\"\n    upper_left = image[:image.shape[0] // 2, :image.shape[1] // 2]\n    total_non_zero = np.count_nonzero(image)\n    non_zero_upper_left = np.count_nonzero(upper_left)\n    return float(non_zero_upper_left / (total_non_zero + 1e-5))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Calculate the mean distance of high-intensity pixels from the center of the image\"\n    h, w = image.shape\n    center_h, center_w = h // 2, w // 2\n    high_intensity_pixels = np.argwhere(image > 200)\n    distances = np.linalg.norm(high_intensity_pixels - np.array([center_h, center_w]), axis=1)\n    return float(np.mean(distances)) if distances.size > 0 else 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Determine the ratio of dark pixels (below a threshold) in the upper half to the total dark pixels in the image'\n    threshold = 50\n    dark_upper_half = np.count_nonzero(image[0:image.shape[0]//2] < threshold)\n    total_dark = np.count_nonzero(image < threshold)\n    return float(dark_upper_half / (total_dark + 1e-5))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Ratio of non-zero pixels in the top quarter to the image height'\n    top_quarter = image[:image.shape[0]//4, :]\n    count_non_zero_top = np.count_nonzero(top_quarter)\n    total_non_zero = np.count_nonzero(image)\n    return count_non_zero_top / total_non_zero if total_non_zero > 0 else 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Count of vertical edges detected using gradient\"\n    gradient = np.gradient(image, axis=1)\n    vertical_edges = np.count_nonzero(np.abs(gradient) > np.std(image))\n    return float(vertical_edges)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Proportion of pixels in the center region compared to the entire image\"\n    h, w = image.shape\n    center_region = image[h//4:3*h//4, w//4:3*w//4]\n    pixel_count = np.count_nonzero(image)\n    center_pixel_count = np.count_nonzero(center_region)\n    return float(center_pixel_count / pixel_count) if pixel_count > 0 else 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Measure the linearity of the pixel intensity profile along the rows of the image\"\n    profile = np.mean(image, axis=1)\n    return float(np.std(np.gradient(profile)))\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of non-zero pixels in the bottom quarter to the whole image\"\n    bottom_quarter = image[3*image.shape[0] // 4:, :]\n    total_non_zero = np.count_nonzero(image)\n    non_zero_bottom = np.count_nonzero(bottom_quarter)\n    return float(non_zero_bottom / total_non_zero) if total_non_zero > 0 else 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Count of non-zero columns in the right half of the image\"\n    h, w = image.shape\n    right_half = image[:, w//2:]\n    return float(np.count_nonzero(np.any(right_half, axis=0)))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Mean pixel intensity difference between left and right quarters of the image\"\n    h, w = image.shape\n    left_quarter = image[:, :w // 4]\n    right_quarter = image[:, 3 * w // 4:]\n    return float(np.mean(left_quarter) - np.mean(right_quarter))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Difference in pixel intensity averages of the corners versus the center of the image.\"\n    corners = image[0, 0], image[0, -1], image[-1, 0], image[-1, -1]\n    center_h, center_w = image.shape[0] // 2, image.shape[1] // 2\n    center_region_avg = np.mean(image[center_h-1:center_h+1, center_w-1:center_w+1])\n    corners_avg = np.mean(corners)\n    return float(corners_avg - center_region_avg)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Ratio of the sum of pixel intensities in the top quarter to the total sum of pixel intensities'\n    h, w = image.shape\n    top_quarter = image[0:h//4, :]\n    return float(np.sum(top_quarter) / (np.sum(image) + 1e-7))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of non-zero pixels in the top third to total non-zero pixels\"\n    h, w = image.shape\n    top_third = image[0:h//3, :]\n    total_non_zero = np.count_nonzero(image)\n    top_non_zero = np.count_nonzero(top_third)\n    return float(top_non_zero / total_non_zero) if total_non_zero > 0 else 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Count of non-zero rows in the right half of the image'\n    right_half = image[:, image.shape[1]//2:]\n    non_zero_rows = np.count_nonzero(np.any(right_half != 0, axis=1))\n    return float(non_zero_rows)\n",
    "def feature(image: np.ndarray) -> float:\n    \"Proportion of pixels in the center region compared to the entire image\"\n    h, w = image.shape\n    center_region = image[h//4:3*h//4, w//4:3*w//4]\n    pixel_count = np.count_nonzero(image)\n    center_pixel_count = np.count_nonzero(center_region)\n    return float(center_pixel_count / pixel_count) if pixel_count > 0 else 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Ratio of bright pixels in the top quarter of the image to the bottom quarter'\n    h, w = image.shape\n    top_quarter = image[:h//4, :]\n    bottom_quarter = image[3*h//4:, :]\n    bright_top = np.count_nonzero(top_quarter > 128)\n    bright_bottom = np.count_nonzero(bottom_quarter > 128)\n    return float(bright_top / (bright_bottom + 1e-5))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Standard deviation of pixel intensities in the lower outer margins of the image'\n    h, w = image.shape\n    lower_outer_margin = np.concatenate((image[h // 2:, :w // 4], image[h // 2:, 3*w // 4:]), axis=1)\n    return float(np.std(lower_outer_margin))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Count of non-zero columns in the top half of the image\"\n    h, w = image.shape\n    top_half = image[:h//2, :]\n    non_zero_columns = np.count_nonzero(np.sum(top_half, axis=0))\n    return float(non_zero_columns)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Count of corners detected in the image using Harris corner detection\"\n    import cv2\n    corners = cv2.cornerHarris(image.astype(np.float32), blockSize=2, ksize=3, k=0.04)\n    return float(np.sum(corners > 0.01 * corners.max()))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of non-zero pixels in the top quarter to the bottom quarter of the image\"\n    h, w = image.shape\n    top_quarter = image[:h // 4, :]\n    bottom_quarter = image[h * 3 // 4:, :]\n    top_nonzero = np.count_nonzero(top_quarter)\n    bottom_nonzero = np.count_nonzero(bottom_quarter)\n    return float(top_nonzero / (bottom_nonzero + 1e-5))  # Avoid division by zero\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Count of non-zero rows in the bottom half of the image\"\n    h, w = image.shape\n    bottom_half = image[h // 2:, :]\n    non_zero_rows = np.count_nonzero(np.any(bottom_half, axis=1))\n    return float(non_zero_rows)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Difference in the count of non-zero rows between the left and right halves of the image'\n    h, w = image.shape\n    left_half_count = np.count_nonzero(np.any(image[:, :w // 2] > 0, axis=1))\n    right_half_count = np.count_nonzero(np.any(image[:, w // 2:] > 0, axis=1))\n    return float(left_half_count - right_half_count)\n",
    "def feature(image: np.ndarray) -> float:\n    'Ratio of pixel intensity variance between the top and bottom halves of the image'\n    h, w = image.shape\n    top_half = image[:h//2, :]\n    bottom_half = image[h//2:, :]\n    variance_ratio = np.std(top_half) / (np.std(bottom_half) + 1e-5)  # Adding small value to avoid division by zero\n    return float(variance_ratio)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of non-zero pixels to total pixels in the image\"\n    total_pixels = image.size\n    non_zero_pixels = np.count_nonzero(image)\n    return float(non_zero_pixels) / total_pixels if total_pixels > 0 else 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Standard deviation of pixel intensities in the top third of the image.\"\n    h, w = image.shape\n    top_third = image[:h//3, :]\n    return float(np.std(top_third))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Difference in pixel intensity averages of the corners versus the center of the image.\"\n    corners = image[0, 0], image[0, -1], image[-1, 0], image[-1, -1]\n    center_h, center_w = image.shape[0] // 2, image.shape[1] // 2\n    center_region_avg = np.mean(image[center_h-1:center_h+1, center_w-1:center_w+1])\n    corners_avg = np.mean(corners)\n    return float(corners_avg - center_region_avg)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Calculate the proportion of pixels in the bottom third of the image that are non-zero.\"\n    h, _ = image.shape\n    bottom_third = image[2*h // 3:, :]\n    non_zero_count = np.count_nonzero(bottom_third)\n    return float(non_zero_count) / (bottom_third.size) if bottom_third.size > 0 else 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Count of edges detected using the Sobel operator\"\n    sobel_x = np.array([[1, 0, -1], [2, 0, -2], [1, 0, -1]])\n    sobel_y = np.array([[1, 2, 1], [0, 0, 0], [-1, -2, -1]])\n    edges_x = np.abs(np.convolve(image.flatten(), sobel_x.flatten(), mode='same')).reshape(image.shape)\n    edges_y = np.abs(np.convolve(image.flatten(), sobel_y.flatten(), mode='same')).reshape(image.shape)\n    edges = np.sqrt(edges_x**2 + edges_y**2)\n    return float(np.count_nonzero(edges))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Difference between the mean intensity of the upper and lower halves of the image'\n    h, w = image.shape\n    upper_half_mean = np.mean(image[0:h//2, :])\n    lower_half_mean = np.mean(image[h//2:, :])\n    return float(upper_half_mean - lower_half_mean)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Mean pixel intensity of the rightmost quarter of the image.\"\n    w = image.shape[1]\n    right_quarter = image[:, 3*w//4:w]\n    return float(np.mean(right_quarter))\n",
    "def feature(image: np.ndarray) -> float:\n    'Determine the count of local minima in the image based on pixel intensity.'\n    local_minima = np.where((image < np.roll(image, 1)) & \n                             (image < np.roll(image, -1)))[0]\n    return float(len(local_minima))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Calculate the ratio of the sum of pixel intensities in the top quarter to the bottom quarter\"\n    top_quarter_sum = np.sum(image[:image.shape[0]//4])\n    bottom_quarter_sum = np.sum(image[3*image.shape[0]//4:])\n    return float(top_quarter_sum / (bottom_quarter_sum + 1e-6))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Standard deviation of pixel intensities in the whole image\"\n    return float(np.std(image))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Calculate the ratio of the sum of pixel intensities in the top quarter to the bottom quarter\"\n    top_quarter_sum = np.sum(image[:image.shape[0]//4])\n    bottom_quarter_sum = np.sum(image[3*image.shape[0]//4:])\n    return float(top_quarter_sum / (bottom_quarter_sum + 1e-6))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of the mean pixel intensity of the bottom quarter to the top quarter.\"\n    h, w = image.shape\n    top_quarter = image[:h//4, :]\n    bottom_quarter = image[3*h//4:, :]\n    mean_top = np.mean(top_quarter)\n    mean_bottom = np.mean(bottom_quarter)\n    return float(mean_bottom / mean_top) if mean_top > 0 else 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Standard deviation of pixel intensities in the top third of the image.\"\n    h, w = image.shape\n    top_third = image[:h//3, :]\n    return float(np.std(top_third))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Count of local minima in the image based on pixel intensity'\n    from scipy.ndimage import gaussian_filter\n    smoothed_image = gaussian_filter(image, sigma=1)\n    local_minima = (smoothed_image < np.roll(smoothed_image, 1, axis=0)) & \\\n                   (smoothed_image < np.roll(smoothed_image, -1, axis=0)) & \\\n                   (smoothed_image < np.roll(smoothed_image, 1, axis=1)) & \\\n                   (smoothed_image < np.roll(smoothed_image, -1, axis=1))\n    return float(np.sum(local_minima))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Count of non-zero pixels in the middle band of the image\"\n    mid_band = image[image.shape[0] // 4:3 * image.shape[0] // 4, :]\n    return float(np.count_nonzero(mid_band))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Standard deviation of pixel intensities in the center third of the image.\"\n    center_third = image[image.shape[0] // 3: 2*image.shape[0] // 3, :]\n    return float(np.std(center_third))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Mean pixel intensity difference between left and right quarters of the image\"\n    h, w = image.shape\n    left_quarter = image[:, :w // 4]\n    right_quarter = image[:, 3 * w // 4:]\n    return float(np.mean(left_quarter) - np.mean(right_quarter))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Count the number of transitions from dark to light across each row\"\n    horizontal_transitions = np.sum(np.diff(image > 127, axis=1).astype(int), axis=1)\n    return float(np.sum(horizontal_transitions))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Count of non-zero rows in the bottom half of the image\"\n    h, w = image.shape\n    bottom_half = image[h // 2:, :]\n    non_zero_rows = np.count_nonzero(np.any(bottom_half, axis=1))\n    return float(non_zero_rows)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Mean pixel intensity in the area around the top-right corner\"\n    h, w = image.shape\n    corner_region = image[0:h // 3, w // 2:w]\n    return float(np.mean(corner_region))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Difference in the count of non-zero rows between the left and right halves of the image'\n    h, w = image.shape\n    left_half_count = np.count_nonzero(np.any(image[:, :w // 2] > 0, axis=1))\n    right_half_count = np.count_nonzero(np.any(image[:, w // 2:] > 0, axis=1))\n    return float(left_half_count - right_half_count)\n",
    "def feature(image: np.ndarray) -> float:\n    'Difference in the count of non-zero rows between the left and right halves of the image'\n    h, w = image.shape\n    left_half_count = np.count_nonzero(np.any(image[:, :w // 2] > 0, axis=1))\n    right_half_count = np.count_nonzero(np.any(image[:, w // 2:] > 0, axis=1))\n    return float(left_half_count - right_half_count)\n",
    "def feature(image: np.ndarray) -> float:\n    'Mean pixel intensity of the horizontal center strip of the image'\n    h, w = image.shape\n    center_strip = image[h // 2 - 1:h // 2 + 1, :]\n    return float(np.mean(center_strip))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Count the number of rows that have more than a set number of non-zero pixels'\n    threshold = 5\n    high_pixel_rows = np.sum(np.count_nonzero(image, axis=1) > threshold)\n    return float(high_pixel_rows)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of pixel intensities in the bottom quarter relative to the entire image.\"\n    bottom_quarter = image[3 * image.shape[0] // 4:]\n    sum_bottom = np.sum(bottom_quarter)\n    sum_total = np.sum(image)\n    if sum_total == 0:\n        return 0.0\n    return float(sum_bottom) / sum_total\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Determine the sum of pixel values in the top quarter of the image.\"\n    top_quarter = image[:image.shape[0] // 4, :]\n    return float(np.sum(top_quarter))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Determine the count of local minima in the image based on pixel intensity.'\n    local_minima = np.where((image < np.roll(image, 1)) & \n                             (image < np.roll(image, -1)))[0]\n    return float(len(local_minima))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Compactness of the object in the image defined as area/perimeter^2\"\n    thresholded_image = image > 128\n    area = np.sum(thresholded_image)\n    perimeter = np.sum(np.abs(np.gradient(thresholded_image.astype(float))))\n    return (area / (perimeter**2)) if perimeter > 0 else 0.0\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of the sum of pixel intensities in the center region to the total sum of pixel intensities in the image.\"\n    h, w = image.shape\n    center_region = image[h//4:3*h//4, w//4:3*w//4]\n    return float(np.sum(center_region)) / (np.sum(image) + 1e-10)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Calculate the intensity variance in the regions formed by splitting the image vertically\"\n    left_half = image[:, :image.shape[1] // 2]\n    right_half = image[:, image.shape[1] // 2:]\n    return float(np.var(left_half) - np.var(right_half))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Count of maximum pixel value regions in the image'\n    return float(np.count_nonzero(image == np.max(image)))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Count of non-zero pixels in a 3x3 kernel around the center pixel\"\n    h, w = image.shape\n    center_pixel = image[h // 2, w // 2]\n    kernel = image[h // 2 - 1:h // 2 + 2, w // 2 - 1:w // 2 + 2]\n    return float(np.count_nonzero(kernel))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Calculate the standard deviation of pixel intensities in the outer margins of the image.'\n    h, w = image.shape\n    top_margin = image[0:h//8, :]\n    bottom_margin = image[7*h//8:h, :]\n    outer_margins = np.concatenate((top_margin, bottom_margin), axis=0)\n    return float(np.std(outer_margins))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of non-zero pixels to total pixels in the image\"\n    total_pixels = image.size\n    non_zero_pixels = np.count_nonzero(image)\n    return float(non_zero_pixels) / total_pixels if total_pixels > 0 else 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Standard deviation of pixel intensities in the corner regions\"\n    h, w = image.shape\n    top_left = image[0:h//2, 0:w//2]\n    top_right = image[0:h//2, w//2:w]\n    bottom_left = image[h//2:h, 0:w//2]\n    bottom_right = image[h//2:h, w//2:w]\n    corner_std = np.std([np.std(top_left), np.std(top_right), np.std(bottom_left), np.std(bottom_right)])\n    return float(corner_std)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Ratio of vertical lines to total edges detected'\n    vertical_gradient = np.gradient(image, axis=1)\n    vertical_edges = np.count_nonzero(np.abs(vertical_gradient) > 10)\n    total_edges = np.count_nonzero(np.abs(np.gradient(image)) > 10)\n    return float(vertical_edges) / total_edges if total_edges > 0 else 0.0\n",
    "def feature(image: np.ndarray) -> float:\n    'Count of dark pixels in the bottom third of the image.'\n    h, w = image.shape\n    bottom_third = image[2*h//3:]\n    dark_pixels = np.count_nonzero(bottom_third < 128)\n    return float(dark_pixels)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Count of edges detected in the image using gradient\"\n    gradient_x, gradient_y = np.gradient(image.astype(float))\n    edges = np.sqrt(gradient_x**2 + gradient_y**2)\n    return float(np.count_nonzero(edges > 20))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Count of regions where pixel intensity changes rapidly.'\n    edges = np.gradient(image)\n    rapid_change_count = np.count_nonzero(edges[0] > 20) + np.count_nonzero(edges[1] > 20)\n    return float(rapid_change_count)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Sum of pixel values in the top-left quarter of the image\"\n    h, w = image.shape\n    top_left_quarter = image[:h // 2, :w // 2]\n    return float(np.sum(top_left_quarter))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Mean gradient magnitude around the corners of the image\"\n    corners = image[0:10, 0:10]  # Top left corner\n    corners = np.concatenate((corners, image[0:10, -10:]))  # Top right corner\n    corners = np.concatenate((corners, image[-10:, 0:10]))  # Bottom left corner\n    corners = np.concatenate((corners, image[-10:, -10:]))  # Bottom right corner\n    gx, gy = np.gradient(corners.astype(float))\n    corner_gradient_magnitude = np.sqrt(gx**2 + gy**2)\n    return float(np.mean(corner_gradient_magnitude))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Count of horizontal edges (variation in pixel intensity) in the image\"\n    gradient_x, gradient_y = np.gradient(image)\n    horizontal_edges = np.sum(np.abs(gradient_y))\n    return float(horizontal_edges)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Calculate the average gradient magnitude in the image, which indicates edges.\"\n    gradients = np.sqrt(np.sum(np.gradient(image.astype(float)), axis=0)**2)\n    return float(np.mean(gradients))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of pixel intensity variance between left and right halves of the image\"\n    left_half = image[:, :image.shape[1] // 2]\n    right_half = image[:, image.shape[1] // 2:]\n    return float(np.var(left_half) / (np.var(right_half) + 1e-6))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Calculate the vertical gradient magnitude at the middle column of the image.\"\n    h, w = image.shape\n    middle_column = image[:, w // 2]\n    gradient = np.gradient(middle_column)\n    return float(np.mean(np.abs(gradient)))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Count of transitions between light and dark pixels in the image\"\n    transitions = np.sum(np.abs(np.diff(image.flatten())) > 128)  # 128 as a threshold\n    return float(transitions)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Count of horizontal edges (variation in pixel intensity) in the image\"\n    gradient_x, gradient_y = np.gradient(image)\n    horizontal_edges = np.sum(np.abs(gradient_y))\n    return float(horizontal_edges)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Difference in the count of non-zero rows between the left and right halves of the image'\n    h, w = image.shape\n    left_half_count = np.count_nonzero(np.any(image[:, :w // 2] > 0, axis=1))\n    right_half_count = np.count_nonzero(np.any(image[:, w // 2:] > 0, axis=1))\n    return float(left_half_count - right_half_count)\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of non-zero pixel count in the middle third to the total non-zero pixels\"\n    h, w = image.shape\n    middle_region = image[h // 3:2 * h // 3, :]\n    non_zero_middle = np.count_nonzero(middle_region)\n    total_non_zero = np.count_nonzero(image)\n    return float(non_zero_middle / total_non_zero) if total_non_zero > 0 else 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Count of non-zero columns in the right half of the image\"\n    h, w = image.shape\n    right_half = image[:, w//2:]\n    return float(np.count_nonzero(np.any(right_half, axis=0)))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Calculate the standard deviation of pixel intensity in the edges (left and right)\"\n    left_edge = image[:, :image.shape[1] // 4]\n    right_edge = image[:, 3 * image.shape[1] // 4:]\n    return float(np.std(np.concatenate((left_edge, right_edge))))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Standard deviation of pixel intensities in the whole image\"\n    return float(np.std(image))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of pixel intensity variance between left and right halves of the image\"\n    left_half = image[:, :image.shape[1] // 2]\n    right_half = image[:, image.shape[1] // 2:]\n    return float(np.var(left_half) / (np.var(right_half) + 1e-6))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Gradient magnitude average difference between left and right halves of the image\"\n    gradients = np.gradient(image)\n    left_gradient_magnitude = np.mean(np.sqrt(gradients[0][:, :image.shape[1]//2]**2 + gradients[1][:, :image.shape[1]//2]**2))\n    right_gradient_magnitude = np.mean(np.sqrt(gradients[0][:, image.shape[1]//2:]**2 + gradients[1][:, image.shape[1]//2:]**2))\n    return float(left_gradient_magnitude - right_gradient_magnitude)\n",
    "def feature(image: np.ndarray) -> float:\n    \"Count of vertical gradients (edges) in the image\"\n    vertical_gradient = np.abs(np.gradient(image, axis=1))\n    return float(np.count_nonzero(vertical_gradient))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Sum of pixel values in the bottom quarter of the image\"\n    h = image.shape[0]\n    bottom_quarter = image[3*h//4:h, :]\n    return float(np.sum(bottom_quarter))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Count of non-zero columns in the top half of the image\"\n    h, w = image.shape\n    top_half = image[:h//2, :]\n    non_zero_columns = np.count_nonzero(np.sum(top_half, axis=0))\n    return float(non_zero_columns)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Count of vertical edges in the image using Scharr operator.\"\n    from scipy.ndimage import convolve\n    scharr_x = np.array([[3, 0, -3], [10, 0, -10], [3, 0, -3]])\n    edge_magnitude = convolve(image, scharr_x)\n    return float(np.count_nonzero(edge_magnitude))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Calculate the vertical gradient magnitude at the middle column of the image.\"\n    h, w = image.shape\n    middle_column = image[:, w // 2]\n    gradient = np.gradient(middle_column)\n    return float(np.mean(np.abs(gradient)))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Calculate the ratio of the number of non-zero pixels in the bottom-left to the total non-zero pixels\"\n    h, w = image.shape\n    bottom_left = image[h//2:, :w//2]\n    total_non_zero = np.count_nonzero(image)\n    bottom_left_non_zero = np.count_nonzero(bottom_left)\n    return float(bottom_left_non_zero / total_non_zero) if total_non_zero > 0 else 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Ratio of the number of non-zero pixels in the bottom third to total non-zero pixels in the image'\n    h, w = image.shape\n    bottom_third = image[2*h//3:, :]\n    total_non_zero = np.count_nonzero(image)\n    non_zero_bottom = np.count_nonzero(bottom_third)\n    return float(non_zero_bottom / total_non_zero) if total_non_zero > 0 else 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Count of non-zero pixels in the central horizontal band of the image\"\n    try:\n        h, w = image.shape\n        center_band = image[h//2, :]\n        return float(np.count_nonzero(center_band))\n    except Exception as e:\n        return 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Average distance of pixels from the center of the image'\n    h, w = image.shape\n    center_x, center_y = w // 2, h // 2\n    distances = np.sqrt((np.arange(h)[:, None] - center_y) ** 2 + (np.arange(w) - center_x) ** 2)\n    average_distance = np.mean(distances[image > 0])\n    return float(average_distance) if np.count_nonzero(image) > 0 else 0.0\n",
    "def feature(image: np.ndarray) -> float:\n    \"Mean of the bottom-left quadrant of the image\"\n    h, w = image.shape\n    bottom_left = image[h // 2:, :w // 2]\n    return float(np.mean(bottom_left))\n",
    "def feature(image: np.ndarray) -> float:\n    \"Edge pixel count based on gradient magnitude threshold\"\n    gx, gy = np.gradient(image)\n    gradient_magnitude = np.sqrt(gx**2 + gy**2)\n    edge_pixel_count = np.count_nonzero(gradient_magnitude > 50)\n    return float(edge_pixel_count)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of the sum of pixel values in the bottom-third region to the top-third region\"\n    h, w = image.shape\n    top_third = image[0:h//3, :]\n    bottom_third = image[2*h//3:h, :]\n    top_sum = np.sum(top_third)\n    bottom_sum = np.sum(bottom_third)\n    return float(bottom_sum / (top_sum + 1e-10))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Total number of edges detected in the image'\n    gradient_x, gradient_y = np.gradient(image.astype(float))\n    edges = np.sqrt(gradient_x**2 + gradient_y**2)\n    return float(np.count_nonzero(edges > 10))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Gradient magnitude in the center region of the image'\n    h, w = image.shape\n    center_h, center_w = h // 4, w // 4\n    center_region = image[center_h:3*center_h, center_w:3*center_w]\n    grad_x, grad_y = np.gradient(center_region.astype(float))\n    return float(np.mean(np.sqrt(grad_x**2 + grad_y**2)))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Count of vertical edges found using gradient magnitudes\"\n    gradient_x = np.gradient(image, axis=1)\n    edge_count = np.count_nonzero(np.abs(gradient_x) > np.std(gradient_x))\n    return float(edge_count)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Count of local maxima in the image based on pixel intensity'\n    gradient = np.gradient(image)\n    local_maxima = np.count_nonzero((gradient[0] > 0) & (np.roll(gradient[0], 1) < 0))\n    return float(local_maxima)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Count of distinct pixel values in the bottom-right quarter of the image'\n    h, w = image.shape\n    bottom_right_quarter = image[h//2:, w//2:]\n    return float(len(np.unique(bottom_right_quarter)))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Determine the sum of pixel values in the top quarter of the image.\"\n    top_quarter = image[:image.shape[0] // 4, :]\n    return float(np.sum(top_quarter))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Count of non-zero rows in the right half of the image'\n    right_half = image[:, image.shape[1]//2:]\n    non_zero_rows = np.count_nonzero(np.any(right_half != 0, axis=1))\n    return float(non_zero_rows)\n",
    "def feature(image: np.ndarray) -> float:\n    \"Horizontal gradient magnitude at the middle row of the image\"\n    grad_x = np.gradient(image, axis=1)\n    return float(np.mean(np.abs(grad_x[image.shape[0] // 2])))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of non-zero pixel count in the middle third to the total non-zero pixels\"\n    h, w = image.shape\n    middle_region = image[h // 3:2 * h // 3, :]\n    non_zero_middle = np.count_nonzero(middle_region)\n    total_non_zero = np.count_nonzero(image)\n    return float(non_zero_middle / total_non_zero) if total_non_zero > 0 else 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Variance of pixel intensities in the top-left corner\"\n    h, w = image.shape\n    corner_region = image[0:h // 3, 0:w // 3]\n    return float(np.var(corner_region))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Mean of the bottom-left quadrant of the image\"\n    h, w = image.shape\n    bottom_left = image[h // 2:, :w // 2]\n    return float(np.mean(bottom_left))\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of the sum of pixel intensities in the middle column to the total sum of pixel intensities.\"\n    h, w = image.shape\n    middle_column = image[:, w // 2]\n    return float(np.sum(middle_column)) / np.sum(image)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of pixel intensity variance between left and right halves of the image\"\n    left_half = image[:, :image.shape[1] // 2]\n    right_half = image[:, image.shape[1] // 2:]\n    return float(np.var(left_half) / (np.var(right_half) + 1e-6))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Sum of pixel intensities in the center region\"\n    h, w = image.shape\n    center_h, center_w = h // 4, w // 4\n    center_region = image[center_h:3*center_h, center_w:3*center_w]\n    return float(np.sum(center_region))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Calculate the ratio of edge pixels (using the standard deviation) to total pixels'\n    edge_std = np.std(np.gradient(image.astype(float))[0])\n    total_pixels = image.size\n    return float(edge_std / total_pixels) if total_pixels > 0 else 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of non-zero pixels to total pixels in the image\"\n    total_pixels = image.size\n    non_zero_pixels = np.count_nonzero(image)\n    return float(non_zero_pixels) / total_pixels if total_pixels > 0 else 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of non-zero pixels in the bottom quarter to the whole image\"\n    bottom_quarter = image[3*image.shape[0] // 4:, :]\n    total_non_zero = np.count_nonzero(image)\n    non_zero_bottom = np.count_nonzero(bottom_quarter)\n    return float(non_zero_bottom / total_non_zero) if total_non_zero > 0 else 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Standard deviation of pixel intensities in the margins (left and right)\"\n    left_margin = image[:, :image.shape[1] // 8]\n    right_margin = image[:, -image.shape[1] // 8:]\n    return float(np.std(np.concatenate((left_margin.ravel(), right_margin.ravel()))))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Calculate the density of bright pixels in concentric rectangles around the center\"\n    h, w = image.shape\n    center = (h // 2, w // 2)\n    density = 0.0\n    for size in range(1, min(center) // 2):\n        rectangle = image[center[0]-size:center[0]+size, center[1]-size:center[1]+size]\n        density += np.count_nonzero(rectangle > 128) / rectangle.size\n    return density / (min(center) // 2)  # Normalize by the number of rectangles used\n",
    "def feature(image: np.ndarray) -> float:\n    \"Average pixel intensity in the top third of the image\"\n    h, w = image.shape\n    top_third = image[:h//3, :]\n    return float(np.mean(top_third))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Calculate the ratio of the number of non-zero pixels in the bottom-left to the total non-zero pixels\"\n    h, w = image.shape\n    bottom_left = image[h//2:, :w//2]\n    total_non_zero = np.count_nonzero(image)\n    bottom_left_non_zero = np.count_nonzero(bottom_left)\n    return float(bottom_left_non_zero / total_non_zero) if total_non_zero > 0 else 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Mean pixel intensity of the horizontal center strip of the image'\n    h, w = image.shape\n    center_strip = image[h // 2 - 1:h // 2 + 1, :]\n    return float(np.mean(center_strip))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Average distance of pixels from the center of the image'\n    h, w = image.shape\n    center_x, center_y = w // 2, h // 2\n    distances = np.sqrt((np.arange(h)[:, None] - center_y) ** 2 + (np.arange(w) - center_x) ** 2)\n    average_distance = np.mean(distances[image > 0])\n    return float(average_distance) if np.count_nonzero(image) > 0 else 0.0\n",
    "def feature(image: np.ndarray) -> float:\n    'Proportion of dark pixels (intensity < 50) in the top third versus bottom third of the image'\n    top_third = image[:image.shape[0] // 3, :]\n    bottom_third = image[2 * (image.shape[0] // 3):, :]\n    dark_pixels_top = np.count_nonzero(top_third < 50)\n    dark_pixels_bottom = np.count_nonzero(bottom_third < 50)\n    return float(dark_pixels_top / (dark_pixels_bottom + 1))  # Avoid division by zero\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Ratio of the number of non-zero pixels in the bottom third to total non-zero pixels in the image'\n    h, w = image.shape\n    bottom_third = image[2*h//3:, :]\n    total_non_zero = np.count_nonzero(image)\n    non_zero_bottom = np.count_nonzero(bottom_third)\n    return float(non_zero_bottom / total_non_zero) if total_non_zero > 0 else 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Mean pixel intensity of the diagonal from bottom-left to top-right'\n    h, w = image.shape\n    diagonal = [image[h - i - 1, i] for i in range(min(h, w))]\n    return float(np.mean(diagonal))\n",
    "def feature(image: np.ndarray) -> float:\n    'Count of non-zero rows in the right half of the image'\n    right_half = image[:, image.shape[1]//2:]\n    non_zero_rows = np.count_nonzero(np.any(right_half != 0, axis=1))\n    return float(non_zero_rows)\n",
    "def feature(image: np.ndarray) -> float:\n    'Count of non-zero rows in the right half of the image'\n    right_half = image[:, image.shape[1]//2:]\n    non_zero_rows = np.count_nonzero(np.any(right_half != 0, axis=1))\n    return float(non_zero_rows)\n",
    "def feature(image: np.ndarray) -> float:\n    \"Proportion of diagonal pixels (from top left to bottom right) to total pixels\"\n    h, w = image.shape\n    diagonal_count = min(h, w)\n    diagonal_sum = np.sum(image[np.arange(diagonal_count), np.arange(diagonal_count)])\n    total_sum = np.sum(image)\n    return float(diagonal_sum / total_sum) if total_sum > 0 else 0.0\n",
    "def feature(image: np.ndarray) -> float:\n    \"Horizontal gradient magnitude at the middle row of the image\"\n    grad_x = np.gradient(image, axis=1)\n    return float(np.mean(np.abs(grad_x[image.shape[0] // 2])))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Measure the variance of pixel intensities in the horizontal center strip of the image.\"\n    h, w = image.shape\n    center_strip = image[h//2, :]\n    return float(np.var(center_strip))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Count of vertical edges detected in the image using Sobel filter'\n    sobel_x = np.array([[-1, 0, 1], [-2, 0, 2], [-1, 0, 1]])\n    edges = np.abs(np.convolve(image.flatten(), sobel_x.flatten(), 'same'))\n    return float(np.count_nonzero(edges))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of non-zero pixels to total pixels in the image\"\n    total_pixels = image.size\n    non_zero_pixels = np.count_nonzero(image)\n    return float(non_zero_pixels) / total_pixels if total_pixels > 0 else 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Determine the mean pixel intensity in the top-right quarter of the image.\"\n    h, w = image.shape\n    top_right_quarter = image[:h//2, w//2:]\n    return float(np.mean(top_right_quarter))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Calculate the ratio of dark pixels in the upper quarter compared to the whole image.\"\n    dark_pixels_top_quarter = np.count_nonzero(image[:image.shape[0]//4, :] < 50)\n    total_dark_pixels = np.count_nonzero(image < 50)\n    ratio = dark_pixels_top_quarter / (total_dark_pixels + 1e-5)  # Avoid division by zero\n    return float(ratio)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Difference in the count of non-zero rows between the left and right halves of the image'\n    h, w = image.shape\n    left_half_count = np.count_nonzero(np.any(image[:, :w // 2] > 0, axis=1))\n    right_half_count = np.count_nonzero(np.any(image[:, w // 2:] > 0, axis=1))\n    return float(left_half_count - right_half_count)\n",
    "def feature(image: np.ndarray) -> float:\n    \"Sum of pixel intensities in the center column of the image\"\n    h, w = image.shape\n    center_col = image[:, w // 2]\n    return float(np.sum(center_col))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Mean pixel intensity in the area around the top-right corner\"\n    h, w = image.shape\n    corner_region = image[0:h // 3, w // 2:w]\n    return float(np.mean(corner_region))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of non-zero pixels in the center-third of the image to total non-zero pixels\"\n    h, w = image.shape\n    center_region = image[h//3:2*h//3, w//3:2*w//3]\n    non_zero_center = np.count_nonzero(center_region)\n    total_non_zero = np.count_nonzero(image)\n    return float(non_zero_center / total_non_zero) if total_non_zero > 0 else 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Count of non-zero rows in the right half of the image'\n    right_half = image[:, image.shape[1]//2:]\n    non_zero_rows = np.count_nonzero(np.any(right_half != 0, axis=1))\n    return float(non_zero_rows)\n",
    "def feature(image: np.ndarray) -> float:\n    \"Calculate the count of significant changes in pixel intensity along the diagonal.\"\n    diagonal = np.diagonal(image)\n    changes = np.sum(np.abs(np.diff(diagonal)) > 10)\n    return float(changes)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of non-zero pixels to total pixels in the image\"\n    total_pixels = image.size\n    non_zero_pixels = np.count_nonzero(image)\n    return float(non_zero_pixels) / total_pixels if total_pixels > 0 else 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of the mean pixel value of the left third to the right third of the image\"\n    h, w = image.shape\n    left_third_mean = np.mean(image[:, :w//3])\n    right_third_mean = np.mean(image[:, 2*w//3:])\n    return left_third_mean / (right_third_mean + 1e-5)\n",
    "def feature(image: np.ndarray) -> float:\n    \"Calculate the standard deviation of pixel values in the image edges\"\n    gradient_x = np.gradient(image, axis=1)\n    edge_means = np.abs(gradient_x)\n    return float(np.std(edge_means))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Difference in average intensity between the left and right halves of the image\"\n    h, w = image.shape\n    left_half = image[:, :w // 2]\n    right_half = image[:, w // 2:]\n    return float(np.mean(left_half) - np.mean(right_half))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Mean gradient magnitude around the corners of the image\"\n    corners = image[0:10, 0:10]  # Top left corner\n    corners = np.concatenate((corners, image[0:10, -10:]))  # Top right corner\n    corners = np.concatenate((corners, image[-10:, 0:10]))  # Bottom left corner\n    corners = np.concatenate((corners, image[-10:, -10:]))  # Bottom right corner\n    gx, gy = np.gradient(corners.astype(float))\n    corner_gradient_magnitude = np.sqrt(gx**2 + gy**2)\n    return float(np.mean(corner_gradient_magnitude))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of non-zero pixel count in the middle third to the total non-zero pixels\"\n    h, w = image.shape\n    middle_region = image[h // 3:2 * h // 3, :]\n    non_zero_middle = np.count_nonzero(middle_region)\n    total_non_zero = np.count_nonzero(image)\n    return float(non_zero_middle / total_non_zero) if total_non_zero > 0 else 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Entropy of the pixel intensity histogram\"\n    histogram, _ = np.histogram(image, bins=256, density=True)\n    histogram = histogram[histogram > 0]  # Avoid log(0)\n    entropy = -np.sum(histogram * np.log(histogram))\n    return float(entropy)\n",
    "def feature(image: np.ndarray) -> float:\n    \"Sum of pixel values in the bottom quarter of the image\"\n    h = image.shape[0]\n    bottom_quarter = image[3*h//4:h, :]\n    return float(np.sum(bottom_quarter))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Count of non-zero pixels in the middle vertical strip of the image.\"\n    h, w = image.shape\n    mid_strip = image[:, w//2 - w//10:w//2 + w//10]\n    return float(np.count_nonzero(mid_strip))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Ratio of the number of non-zero pixels in the bottom third to total non-zero pixels in the image'\n    h, w = image.shape\n    bottom_third = image[2*h//3:, :]\n    total_non_zero = np.count_nonzero(image)\n    non_zero_bottom = np.count_nonzero(bottom_third)\n    return float(non_zero_bottom / total_non_zero) if total_non_zero > 0 else 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Ratio of the number of isolated dark regions to total dark regions'\n    dark_threshold = 50\n    dark_regions = np.count_nonzero(image < dark_threshold)\n    isolated_dark = np.count_nonzero(np.diff(image < dark_threshold) != 0)\n    return float(isolated_dark / (dark_regions + 1e-5))  # Avoid division by zero\n",
    "def feature(image: np.ndarray) -> float:\n    \"Count of corners detected in the image using Harris corner detection\"\n    import cv2\n    corners = cv2.cornerHarris(image.astype(np.float32), blockSize=2, ksize=3, k=0.04)\n    return float(np.sum(corners > 0.01 * corners.max()))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of non-zero pixels to total pixels in the image\"\n    total_pixels = image.size\n    non_zero_pixels = np.count_nonzero(image)\n    return float(non_zero_pixels) / total_pixels if total_pixels > 0 else 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of non-zero pixels to total pixels in the image\"\n    total_pixels = image.size\n    non_zero_pixels = np.count_nonzero(image)\n    return float(non_zero_pixels) / total_pixels if total_pixels > 0 else 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Count of corners detected in the image using Harris corner detection\"\n    import cv2\n    corners = cv2.cornerHarris(image.astype(np.float32), blockSize=2, ksize=3, k=0.04)\n    return float(np.sum(corners > 0.01 * corners.max()))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Average gradient magnitude in the left half of the image.\"\n    try:\n        gradients = np.gradient(image.astype(float))\n        left_half_gradient = np.sqrt(gradients[0][:, :image.shape[1] // 2] ** 2 +\n                                               gradients[1][:, :image.shape[1] // 2] ** 2)\n        return float(np.mean(left_half_gradient))\n    except Exception:\n        return 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Difference in the count of non-zero rows between the left and right halves of the image'\n    h, w = image.shape\n    left_half_count = np.count_nonzero(np.any(image[:, :w // 2] > 0, axis=1))\n    right_half_count = np.count_nonzero(np.any(image[:, w // 2:] > 0, axis=1))\n    return float(left_half_count - right_half_count)\n",
    "def feature(image: np.ndarray) -> float:\n    \"Standard deviation of pixel intensities in the whole image\"\n    return float(np.std(image))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of pixel intensity variance between left and right halves of the image\"\n    left_half = image[:, :image.shape[1] // 2]\n    right_half = image[:, image.shape[1] // 2:]\n    return float(np.var(left_half) / (np.var(right_half) + 1e-6))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Average distance of pixels from the center of the image'\n    h, w = image.shape\n    center_x, center_y = w // 2, h // 2\n    distances = np.sqrt((np.arange(h)[:, None] - center_y) ** 2 + (np.arange(w) - center_x) ** 2)\n    average_distance = np.mean(distances[image > 0])\n    return float(average_distance) if np.count_nonzero(image) > 0 else 0.0\n",
    "def feature(image: np.ndarray) -> float:\n    \"Standard deviation of pixel intensities in the corner regions\"\n    h, w = image.shape\n    top_left = image[0:h//2, 0:w//2]\n    top_right = image[0:h//2, w//2:w]\n    bottom_left = image[h//2:h, 0:w//2]\n    bottom_right = image[h//2:h, w//2:w]\n    corner_std = np.std([np.std(top_left), np.std(top_right), np.std(bottom_left), np.std(bottom_right)])\n    return float(corner_std)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of non-zero pixels in the center-third of the image to total non-zero pixels\"\n    h, w = image.shape\n    center_region = image[h//3:2*h//3, w//3:2*w//3]\n    non_zero_center = np.count_nonzero(center_region)\n    total_non_zero = np.count_nonzero(image)\n    return float(non_zero_center / total_non_zero) if total_non_zero > 0 else 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Calculate the ratio of the number of vertical non-zero pixels to the total number of non-zero pixels.\"\n    total_non_zero = np.count_nonzero(image)\n    vertical_non_zero = np.count_nonzero(np.any(image > 0, axis=0))\n    return float(vertical_non_zero / total_non_zero) if total_non_zero > 0 else 0.0\n",
    "def feature(image: np.ndarray) -> float:\n    'Ratio of the sum of pixel intensities in the top quarter to the total sum of pixel intensities'\n    h, w = image.shape\n    top_quarter = image[0:h//4, :]\n    return float(np.sum(top_quarter) / (np.sum(image) + 1e-7))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of the sum of pixel intensities in the center region to the total sum of pixel intensities in the image.\"\n    h, w = image.shape\n    center_region = image[h//4:3*h//4, w//4:3*w//4]\n    return float(np.sum(center_region)) / (np.sum(image) + 1e-10)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Mean of the maximum pixel intensity over each column\"\n    return float(np.mean(np.max(image, axis=0)))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of non-zero pixels to total pixels in the image\"\n    total_pixels = image.size\n    non_zero_pixels = np.count_nonzero(image)\n    return float(non_zero_pixels) / total_pixels if total_pixels > 0 else 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Measure the variance of pixel intensities in the horizontal center strip of the image.\"\n    h, w = image.shape\n    center_strip = image[h//2, :]\n    return float(np.var(center_strip))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Count of horizontal gradients (edges) in the image\"\n    gradients = np.gradient(image, axis=0)\n    horizontal_edges = np.count_nonzero(gradients[0])\n    return float(horizontal_edges)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Difference between the mean intensity of the upper and lower halves of the image'\n    h, w = image.shape\n    upper_half_mean = np.mean(image[0:h//2, :])\n    lower_half_mean = np.mean(image[h//2:, :])\n    return float(upper_half_mean - lower_half_mean)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Calculate the density of non-zero pixels in concentric circles from the center\"\n    h, w = image.shape\n    center = (h // 2, w // 2)\n    densities = []\n    for radius in range(1, min(center) // 2):\n        mask = (np.sqrt((np.arange(h)[:, None] - center[0])**2 + (np.arange(w) - center[1])**2) <= radius)\n        densities.append(np.count_nonzero(image[mask]))\n    return float(np.mean(densities))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Calculate the ratio of the area of the image that is mid-toned (values between 128 and 192) to the total area'\n    mid_toned_area = np.count_nonzero((image >= 128) & (image <= 192))\n    total_area = image.size\n    return float(mid_toned_area) / total_area if total_area > 0 else 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Count of columns with non-zero pixels in the lower half of the image\"\n    h, w = image.shape\n    lower_half = image[h//2:, :]\n    return float(np.count_nonzero(np.any(lower_half > 0, axis=0)))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Mean pixel intensity of the bottom left region of the image.\"\n    h, w = image.shape\n    bottom_left = image[2*h//3:h, :w//2]\n    return float(np.mean(bottom_left))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of non-zero pixels to total pixels in the image\"\n    total_pixels = image.size\n    non_zero_pixels = np.count_nonzero(image)\n    return float(non_zero_pixels) / total_pixels if total_pixels > 0 else 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Ratio of pixel intensity in the bottom quarter to the top quarter of the image'\n    bottom_quarter = image[3*image.shape[0]//4:]\n    top_quarter = image[:image.shape[0]//4]\n    bottom_mean = np.mean(bottom_quarter) if np.count_nonzero(bottom_quarter) > 0 else 0\n    top_mean = np.mean(top_quarter) if np.count_nonzero(top_quarter) > 0 else 1  # Avoid division by zero\n    return float(bottom_mean / top_mean)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Ratio of pixel intensity variance between the top and bottom halves of the image'\n    h, w = image.shape\n    top_half = image[:h//2, :]\n    bottom_half = image[h//2:, :]\n    variance_ratio = np.std(top_half) / (np.std(bottom_half) + 1e-5)  # Adding small value to avoid division by zero\n    return float(variance_ratio)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Ratio of the number of non-zero pixels in the bottom third to total non-zero pixels in the image'\n    h, w = image.shape\n    bottom_third = image[2*h//3:, :]\n    total_non_zero = np.count_nonzero(image)\n    non_zero_bottom = np.count_nonzero(bottom_third)\n    return float(non_zero_bottom / total_non_zero) if total_non_zero > 0 else 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Difference in sum of non-zero pixels between the top and bottom halves'\n    h, w = image.shape\n    top_half = image[:h//2, :]\n    bottom_half = image[h//2:, :]\n    sum_top = np.sum(top_half[top_half > 0])\n    sum_bottom = np.sum(bottom_half[bottom_half > 0])\n    return float(sum_bottom - sum_top)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Standard deviation of pixel intensities in the lower outer margins of the image'\n    h, w = image.shape\n    lower_outer_margin = np.concatenate((image[h // 2:, :w // 4], image[h // 2:, 3*w // 4:]), axis=1)\n    return float(np.std(lower_outer_margin))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Calculate the density of non-zero pixels in concentric circles from the center\"\n    h, w = image.shape\n    center = (h // 2, w // 2)\n    densities = []\n    for radius in range(1, min(center) // 2):\n        mask = (np.sqrt((np.arange(h)[:, None] - center[0])**2 + (np.arange(w) - center[1])**2) <= radius)\n        densities.append(np.count_nonzero(image[mask]))\n    return float(np.mean(densities))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of non-zero pixels to total pixels in the image\"\n    total_pixels = image.size\n    non_zero_pixels = np.count_nonzero(image)\n    return float(non_zero_pixels) / total_pixels if total_pixels > 0 else 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Calculate the distance from the center of mass of the white pixels to the center of the image.\"\n    h, w = image.shape\n    y_indices, x_indices = np.nonzero(image)\n    if len(y_indices) == 0:\n        return float(h ** 2 + w ** 2)  # if no foreground pixels, return max distance\n    center_of_mass = np.array([np.mean(x_indices), np.mean(y_indices)])\n    center_of_image = np.array([w / 2, h / 2])\n    distance = np.linalg.norm(center_of_mass - center_of_image)\n    return float(distance)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Percentage of pixels that are above the mean intensity\"\n    mean_intensity = np.mean(image)\n    above_mean = np.count_nonzero(image > mean_intensity)\n    return float(above_mean) / image.size\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Calculate the percentage of pixels in the diagonal band towards the middle of the image.\"\n    band_width = 5\n    h, w = image.shape\n    diagonal_band = image[np.arange(h), np.arange(w)]\n    total_pixels = np.count_nonzero((np.arange(w) >= (w // 2 - band_width)) & \n                                     (np.arange(w) <= (w // 2 + band_width)))\n    band_pixels = np.count_nonzero(diagonal_band[(np.arange(h) >= (h // 2 - band_width)) & \n                                                  (np.arange(h) <= (h // 2 + band_width))])\n    return float(band_pixels) / total_pixels if total_pixels > 0 else 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Calculate the ratio of non-zero pixels in the left quarter to the right quarter'\n    left_quarter = image[:, :image.shape[1] // 4]\n    right_quarter = image[:, 3*image.shape[1] // 4:]\n    non_zero_left = np.count_nonzero(left_quarter)\n    non_zero_right = np.count_nonzero(right_quarter)\n    return float(non_zero_left / (non_zero_right + 1e-10))  # Avoid division by zero\n",
    "def feature(image: np.ndarray) -> float:\n    \"Average pixel intensity along the horizontal midline of the image\"\n    h, w = image.shape\n    midline = image[h // 2, :]\n    return float(np.mean(midline))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Count of local minima based on pixel intensity'\n    local_minima = (image < np.roll(image, 1, axis=0)) & (image < np.roll(image, -1, axis=0))\n    return float(np.count_nonzero(local_minima))\n",
    "def feature(image: np.ndarray) -> float:\n    \"Count of non-zero columns in the top half of the image\"\n    h, w = image.shape\n    top_half = image[:h//2, :]\n    non_zero_columns = np.count_nonzero(np.sum(top_half, axis=0))\n    return float(non_zero_columns)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of the number of non-zero pixels in the upper half to those in the lower half.\"\n    h, w = image.shape\n    upper_half = image[0:h//2]\n    lower_half = image[h//2:]\n    upper_non_zero = np.count_nonzero(upper_half)\n    lower_non_zero = np.count_nonzero(lower_half) + 1e-6  # Avoid division by zero\n    return float(upper_non_zero / lower_non_zero)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of non-zero pixels to total pixels in the image\"\n    total_pixels = image.size\n    non_zero_pixels = np.count_nonzero(image)\n    return float(non_zero_pixels) / total_pixels if total_pixels > 0 else 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Count of vertical lines (columns with uniform intensity) in the image\"\n    uniform_columns = np.where(np.std(image, axis=0) < 15)[0]\n    return float(len(uniform_columns))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Mean pixel intensity of the horizontal center strip of the image'\n    h, w = image.shape\n    center_strip = image[h // 2 - 1:h // 2 + 1, :]\n    return float(np.mean(center_strip))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Variance of pixel intensity in the horizontal centroid band of the image (middle 10% height)\"\n    h, w = image.shape\n    centroid_band = image[int(h * 0.45):int(h * 0.55), :]\n    return float(np.var(centroid_band))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Average distance of pixels from the center of the image'\n    h, w = image.shape\n    center_x, center_y = w // 2, h // 2\n    distances = np.sqrt((np.arange(h)[:, None] - center_y) ** 2 + (np.arange(w) - center_x) ** 2)\n    average_distance = np.mean(distances[image > 0])\n    return float(average_distance) if np.count_nonzero(image) > 0 else 0.0\n",
    "def feature(image: np.ndarray) -> float:\n    \"Sum of pixel values in the bottom quarter of the image\"\n    h = image.shape[0]\n    bottom_quarter = image[3*h//4:h, :]\n    return float(np.sum(bottom_quarter))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of the number of white pixels in the left half to the right half\"\n    left_half = image[:, :image.shape[1] // 2]\n    right_half = image[:, image.shape[1] // 2:]\n    left_white = np.count_nonzero(left_half > 0.8 * 255)\n    right_white = np.count_nonzero(right_half > 0.8 * 255)\n    return float(left_white / right_white) if right_white > 0 else float('inf')\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Difference between the mean intensity of the upper and lower halves of the image'\n    h, w = image.shape\n    upper_half_mean = np.mean(image[0:h//2, :])\n    lower_half_mean = np.mean(image[h//2:, :])\n    return float(upper_half_mean - lower_half_mean)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Determine the proportion of edge pixels in the upper half of the image.\"\n    edges = np.abs(np.gradient(image)[0]) + np.abs(np.gradient(image)[1])\n    upper_half_edges = np.count_nonzero(edges[:image.shape[0]//2])\n    total_edges = np.count_nonzero(edges)\n    return float(upper_half_edges) / total_edges if total_edges > 0 else 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of non-zero pixels to total pixels in the image\"\n    total_pixels = image.size\n    non_zero_pixels = np.count_nonzero(image)\n    return float(non_zero_pixels) / total_pixels if total_pixels > 0 else 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of non-zero pixels to total pixels in the image\"\n    total_pixels = image.size\n    non_zero_pixels = np.count_nonzero(image)\n    return float(non_zero_pixels) / total_pixels if total_pixels > 0 else 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Mean pixel intensity of the diagonal from top-left to bottom-right'\n    diagonal = np.diagonal(image)\n    return float(np.mean(diagonal))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Calculate the density of pixels in concentric squares from the center\"\n    h, w = image.shape\n    center = (h // 2, w // 2)\n    total_density = 0.0\n    for scale in range(1, 5):\n        square_region = image[center[0] - scale: center[0] + scale + 1, \n                              center[1] - scale: center[1] + scale + 1]\n        total_density += np.count_nonzero(square_region)\n    return total_density\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Calculate the number of peaks in pixel intensity across the image'\n    intensity_profile = np.sum(image, axis=0)\n    peaks = np.where((intensity_profile[1:-1] > intensity_profile[:-2]) & (intensity_profile[1:-1] > intensity_profile[2:]))[0]\n    return float(len(peaks))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Compactness of the object in the image defined as area/perimeter^2\"\n    thresholded_image = image > 128\n    area = np.sum(thresholded_image)\n    perimeter = np.sum(np.abs(np.gradient(thresholded_image.astype(float))))\n    return (area / (perimeter**2)) if perimeter > 0 else 0.0\n",
    "def feature(image: np.ndarray) -> float:\n    \"Count of corners detected in the image using Harris corner detection\"\n    import cv2\n    corners = cv2.cornerHarris(image.astype(np.float32), blockSize=2, ksize=3, k=0.04)\n    return float(np.sum(corners > 0.01 * corners.max()))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Mean of the horizontal gradient magnitudes for the bottom half of the image\"\n    h, w = image.shape\n    bottom_half = image[h//2:, :]\n    horizontal_gradient = np.gradient(bottom_half, axis=1)\n    return float(np.mean(np.abs(horizontal_gradient)))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Calculate the density of pixels in concentric squares from the center\"\n    h, w = image.shape\n    center = (h // 2, w // 2)\n    total_density = 0.0\n    for scale in range(1, 5):\n        square_region = image[center[0] - scale: center[0] + scale + 1, \n                              center[1] - scale: center[1] + scale + 1]\n        total_density += np.count_nonzero(square_region)\n    return total_density\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of non-zero pixels to total pixels in the image\"\n    total_pixels = image.size\n    non_zero_pixels = np.count_nonzero(image)\n    return float(non_zero_pixels) / total_pixels if total_pixels > 0 else 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Count of vertical edges detected in the image using Sobel filter'\n    sobel_x = np.array([[-1, 0, 1], [-2, 0, 2], [-1, 0, 1]])\n    edges = np.abs(np.convolve(image.flatten(), sobel_x.flatten(), 'same'))\n    return float(np.count_nonzero(edges))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of non-zero pixels to total pixels in the image\"\n    total_pixels = image.size\n    non_zero_pixels = np.count_nonzero(image)\n    return float(non_zero_pixels) / total_pixels if total_pixels > 0 else 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Compute the total sum of pixel values in the right third of the image.\"\n    h, w = image.shape\n    right_third = image[:, 2 * w // 3:]\n    return float(np.sum(right_third))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Count of regions where pixel intensity changes rapidly.'\n    edges = np.gradient(image)\n    rapid_change_count = np.count_nonzero(edges[0] > 20) + np.count_nonzero(edges[1] > 20)\n    return float(rapid_change_count)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of non-zero pixel count in the middle third to the total non-zero pixels\"\n    h, w = image.shape\n    middle_region = image[h // 3:2 * h // 3, :]\n    non_zero_middle = np.count_nonzero(middle_region)\n    total_non_zero = np.count_nonzero(image)\n    return float(non_zero_middle / total_non_zero) if total_non_zero > 0 else 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Measure the linearity of the pixel intensity profile along the rows of the image\"\n    profile = np.mean(image, axis=1)\n    return float(np.std(np.gradient(profile)))\n",
    "def feature(image: np.ndarray) -> float:\n    'Difference between the mean intensity of the upper and lower halves of the image'\n    h, w = image.shape\n    upper_half_mean = np.mean(image[0:h//2, :])\n    lower_half_mean = np.mean(image[h//2:, :])\n    return float(upper_half_mean - lower_half_mean)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of horizontal pixel gradients to vertical pixel gradients\"\n    gradient_x, gradient_y = np.gradient(image)\n    horizontal_gradient = np.sum(np.abs(gradient_y))\n    vertical_gradient = np.sum(np.abs(gradient_x))\n    return horizontal_gradient / (vertical_gradient + 1e-5)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Standard deviation of pixel intensities in the central vertical line of the image\"\n    h, w = image.shape\n    central_line = image[:, w//2]\n    return float(np.std(central_line))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Normalized variance of pixel intensities in the left half of the image.\"\n    h, w = image.shape\n    left_half = image[:, :w//2]\n    return float(np.var(left_half) / np.mean(left_half)) if np.mean(left_half) > 0 else 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Difference in the count of non-zero rows between the left and right halves of the image'\n    h, w = image.shape\n    left_half_count = np.count_nonzero(np.any(image[:, :w // 2] > 0, axis=1))\n    right_half_count = np.count_nonzero(np.any(image[:, w // 2:] > 0, axis=1))\n    return float(left_half_count - right_half_count)\n",
    "def feature(image: np.ndarray) -> float:\n    \"Mean of the horizontal gradient magnitudes for the bottom half of the image\"\n    h, w = image.shape\n    bottom_half = image[h//2:, :]\n    horizontal_gradient = np.gradient(bottom_half, axis=1)\n    return float(np.mean(np.abs(horizontal_gradient)))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Maximum pixel intensity in the bottom left corner of the image\"\n    bottom_left_corner = image[image.shape[0] * 2 // 3:, :image.shape[1] // 3]\n    return float(np.max(bottom_left_corner))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of non-zero pixels to total pixels in the image\"\n    total_pixels = image.size\n    non_zero_pixels = np.count_nonzero(image)\n    return float(non_zero_pixels) / total_pixels if total_pixels > 0 else 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Straightness of the main diagonal, calculated based on pixel intensity differences\"\n    h, w = image.shape\n    diagonal = np.diagonal(image)\n    diffs = np.abs(np.diff(diagonal))\n    return float(np.sum(diffs) / len(diffs)) if len(diffs) > 0 else 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Calculate the sum of pixel intensities in the left half of the bottom quarter of the image\"\n    bottom_quarter = image[3*image.shape[0]//4:]\n    left_half_bottom = bottom_quarter[:, :bottom_quarter.shape[1]//2]\n    return float(np.sum(left_half_bottom))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Standard deviation of pixel intensities in the whole image\"\n    return float(np.std(image))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Average intensity of the image's edge pixels.\"\n    gradient = np.gradient(image)\n    edge_pixels = (np.abs(gradient[0]) + np.abs(gradient[1])) > 0\n    return float(np.mean(image[edge_pixels]))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Standard deviation of pixel intensities in the top third of the image.\"\n    h, w = image.shape\n    top_third = image[:h//3, :]\n    return float(np.std(top_third))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Ratio of pixel intensity variance between the top and bottom halves of the image'\n    h, w = image.shape\n    top_half = image[:h//2, :]\n    bottom_half = image[h//2:, :]\n    variance_ratio = np.std(top_half) / (np.std(bottom_half) + 1e-5)  # Adding small value to avoid division by zero\n    return float(variance_ratio)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Estimate of image symmetry by comparing left and right halves.\"\n    h, w = image.shape\n    left_half = image[:, :w//2]\n    right_half = image[:, w//2:]\n    return float(np.sum(left_half) - np.sum(right_half))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Mean of the horizontal gradient magnitudes for the bottom half of the image\"\n    h, w = image.shape\n    bottom_half = image[h//2:, :]\n    horizontal_gradient = np.gradient(bottom_half, axis=1)\n    return float(np.mean(np.abs(horizontal_gradient)))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Mean pixel intensity of the image corners'\n    h, w = image.shape\n    corners = np.concatenate((image[0, 0:w//4], image[0, 3*w//4:w], image[h//4, 0:w//4], image[h//4, 3*w//4:w]))\n    return float(np.mean(corners))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Calculate the sum of pixel intensities in the left half of the bottom quarter of the image\"\n    bottom_quarter = image[3*image.shape[0]//4:]\n    left_half_bottom = bottom_quarter[:, :bottom_quarter.shape[1]//2]\n    return float(np.sum(left_half_bottom))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Calculate the vertical gradient magnitude at the middle column of the image.\"\n    h, w = image.shape\n    middle_column = image[:, w // 2]\n    gradient = np.gradient(middle_column)\n    return float(np.mean(np.abs(gradient)))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Measure the central pixel intensity relative to the mean intensity of the image\"\n    mean_intensity = np.mean(image)\n    center_pixel = image[image.shape[0] // 2, image.shape[1] // 2]\n    return float(center_pixel / (mean_intensity + 1e-5))  # Avoid division by zero\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of pixel intensities in the bottom quarter relative to the entire image.\"\n    bottom_quarter = image[3 * image.shape[0] // 4:]\n    sum_bottom = np.sum(bottom_quarter)\n    sum_total = np.sum(image)\n    if sum_total == 0:\n        return 0.0\n    return float(sum_bottom) / sum_total\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Calculate the vertical gradient magnitude at the middle column of the image.\"\n    h, w = image.shape\n    middle_column = image[:, w // 2]\n    gradient = np.gradient(middle_column)\n    return float(np.mean(np.abs(gradient)))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of the sum of pixel values in the bottom third to the total sum\"\n    h, w = image.shape\n    bottom_third = image[2*h//3:h, :]\n    total_sum = np.sum(image)\n    return float(np.sum(bottom_third)) / total_sum if total_sum > 0 else 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of non-zero pixels in the bottom quarter to the whole image\"\n    bottom_quarter = image[3*image.shape[0] // 4:, :]\n    total_non_zero = np.count_nonzero(image)\n    non_zero_bottom = np.count_nonzero(bottom_quarter)\n    return float(non_zero_bottom / total_non_zero) if total_non_zero > 0 else 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of the mean pixel intensity of the bottom quarter to the top quarter.\"\n    h, w = image.shape\n    top_quarter = image[:h//4, :]\n    bottom_quarter = image[3*h//4:, :]\n    mean_top = np.mean(top_quarter)\n    mean_bottom = np.mean(bottom_quarter)\n    return float(mean_bottom / mean_top) if mean_top > 0 else 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Compute the maximum vertical gradient in the image'\n    gradient_y = np.gradient(image, axis=0)\n    max_gradient = np.max(np.abs(gradient_y))\n    return float(max_gradient)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Ratio of pixel intensity variance between the top and bottom halves of the image'\n    h, w = image.shape\n    top_half = image[:h//2, :]\n    bottom_half = image[h//2:, :]\n    variance_ratio = np.std(top_half) / (np.std(bottom_half) + 1e-5)  # Adding small value to avoid division by zero\n    return float(variance_ratio)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of pixel intensities in the central horizontal line to total intensity in the image\"\n    center_line = image[image.shape[0] // 2, :]\n    return float(np.sum(center_line) / np.sum(image)) if np.sum(image) > 0 else 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Calculate the image's vertical gradient mean\"\n    gradient = np.gradient(image, axis=0)\n    return float(np.mean(np.abs(gradient)))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Calculate the sum of pixel intensities in concentric circles around the center.\"\n    h, w = image.shape\n    center = (h // 2, w // 2)\n    total_sum = 0\n    for r in range(1, min(center) // 2):  # For concentric circles\n        mask = (np.indices(image.shape) - np.array(center).reshape(2, 1, 1))**2\n        mask = (mask[0]**2 + mask[1]**2) <= r**2\n        total_sum += np.sum(image[mask])\n    return float(total_sum)\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of non-zero pixels in the top quarter to the bottom quarter of the image\"\n    h, w = image.shape\n    top_quarter = image[:h // 4, :]\n    bottom_quarter = image[h * 3 // 4:, :]\n    top_nonzero = np.count_nonzero(top_quarter)\n    bottom_nonzero = np.count_nonzero(bottom_quarter)\n    return float(top_nonzero / (bottom_nonzero + 1e-5))  # Avoid division by zero\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of non-zero pixel count in the middle third to the total non-zero pixels\"\n    h, w = image.shape\n    middle_region = image[h // 3:2 * h // 3, :]\n    non_zero_middle = np.count_nonzero(middle_region)\n    total_non_zero = np.count_nonzero(image)\n    return float(non_zero_middle / total_non_zero) if total_non_zero > 0 else 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Calculate the density of non-zero pixels in concentric circles from the center\"\n    h, w = image.shape\n    center = (h // 2, w // 2)\n    densities = []\n    for radius in range(1, min(center) // 2):\n        mask = (np.sqrt((np.arange(h)[:, None] - center[0])**2 + (np.arange(w) - center[1])**2) <= radius)\n        densities.append(np.count_nonzero(image[mask]))\n    return float(np.mean(densities))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Sum of pixel values in the top-left quarter of the image\"\n    h, w = image.shape\n    top_left_quarter = image[:h // 2, :w // 2]\n    return float(np.sum(top_left_quarter))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Ratio of the number of isolated dark regions to total dark regions'\n    dark_threshold = 50\n    dark_regions = np.count_nonzero(image < dark_threshold)\n    isolated_dark = np.count_nonzero(np.diff(image < dark_threshold) != 0)\n    return float(isolated_dark / (dark_regions + 1e-5))  # Avoid division by zero\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of non-zero pixels to total pixels in the image\"\n    total_pixels = image.size\n    non_zero_pixels = np.count_nonzero(image)\n    return float(non_zero_pixels) / total_pixels if total_pixels > 0 else 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of dark (low intensity) pixels in the left half to total dark pixels\"\n    left_half = image[:, :image.shape[1] // 2]\n    total_dark = np.count_nonzero(image < 50)\n    dark_in_left = np.count_nonzero(left_half < 50)\n    return float(dark_in_left / total_dark) if total_dark > 0 else 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Compute the total sum of pixel values in the right third of the image.\"\n    h, w = image.shape\n    right_third = image[:, 2 * w // 3:]\n    return float(np.sum(right_third))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Calculate the density of pixels in concentric squares from the center\"\n    h, w = image.shape\n    center = (h // 2, w // 2)\n    total_density = 0.0\n    for scale in range(1, 5):\n        square_region = image[center[0] - scale: center[0] + scale + 1, \n                              center[1] - scale: center[1] + scale + 1]\n        total_density += np.count_nonzero(square_region)\n    return total_density\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Mean of the horizontal gradient magnitudes for the bottom half of the image\"\n    h, w = image.shape\n    bottom_half = image[h//2:, :]\n    horizontal_gradient = np.gradient(bottom_half, axis=1)\n    return float(np.mean(np.abs(horizontal_gradient)))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Count the number of transitions from dark to light across each row\"\n    horizontal_transitions = np.sum(np.diff(image > 127, axis=1).astype(int), axis=1)\n    return float(np.sum(horizontal_transitions))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Compute the mean gradient magnitude in the lower half of the image.\"\n    gradients = np.gradient(image.astype(float))\n    gradient_magnitude = np.sqrt(gradients[0]**2 + gradients[1]**2)\n    h, _ = image.shape\n    lower_half = gradient_magnitude[h//2:, :]\n    return float(np.mean(lower_half))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of white pixels in the center region compared to the whole image\"\n    h, w = image.shape\n    center_h, center_w = h // 4, w // 4\n    center_region = image[center_h:3*center_h, center_w:3*center_w]\n    white_pixels_center = np.count_nonzero(center_region > 200)\n    total_white_pixels = np.count_nonzero(image > 200)\n    return float(white_pixels_center / (total_white_pixels + 1e-6))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Standard deviation of pixel intensities in the corner regions\"\n    h, w = image.shape\n    top_left = image[0:h//2, 0:w//2]\n    top_right = image[0:h//2, w//2:w]\n    bottom_left = image[h//2:h, 0:w//2]\n    bottom_right = image[h//2:h, w//2:w]\n    corner_std = np.std([np.std(top_left), np.std(top_right), np.std(bottom_left), np.std(bottom_right)])\n    return float(corner_std)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of pixel intensities in the central horizontal line to total intensity in the image\"\n    center_line = image[image.shape[0] // 2, :]\n    return float(np.sum(center_line) / np.sum(image)) if np.sum(image) > 0 else 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Calculate the intensity variance in the regions formed by splitting the image vertically\"\n    left_half = image[:, :image.shape[1] // 2]\n    right_half = image[:, image.shape[1] // 2:]\n    return float(np.var(left_half) - np.var(right_half))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Difference in the count of non-zero rows between the left and right halves of the image'\n    h, w = image.shape\n    left_half_count = np.count_nonzero(np.any(image[:, :w // 2] > 0, axis=1))\n    right_half_count = np.count_nonzero(np.any(image[:, w // 2:] > 0, axis=1))\n    return float(left_half_count - right_half_count)\n",
    "def feature(image: np.ndarray) -> float:\n    \"Percentage of non-zero rows in the upper half of the image\"\n    upper_half = image[:image.shape[0] // 2]\n    non_zero_row_count = np.count_nonzero(np.any(upper_half > 0, axis=1))\n    return float(non_zero_row_count) / upper_half.shape[0]\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Calculate the vertical gradient magnitude at the middle column of the image.\"\n    h, w = image.shape\n    middle_column = image[:, w // 2]\n    gradient = np.gradient(middle_column)\n    return float(np.mean(np.abs(gradient)))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of non-zero pixels to total pixels in the image\"\n    total_pixels = image.size\n    non_zero_pixels = np.count_nonzero(image)\n    return float(non_zero_pixels) / total_pixels if total_pixels > 0 else 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Variance of pixel intensities around the image center\"\n    h, w = image.shape\n    center_h, center_w = h // 2, w // 2\n    center_region = image[center_h-1:center_h+2, center_w-1:center_w+2]\n    return float(np.var(center_region))\n",
    "def feature(image: np.ndarray) -> float:\n    \"Calculate the intensity variance in the regions formed by splitting the image vertically\"\n    left_half = image[:, :image.shape[1] // 2]\n    right_half = image[:, image.shape[1] // 2:]\n    return float(np.var(left_half) - np.var(right_half))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Mean pixel intensity in the left quarter of the image\"\n    left_quarter = image[:, :image.shape[1] // 4]\n    return float(np.mean(left_quarter))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Ratio of the number of non-zero pixels in the bottom third to total non-zero pixels in the image'\n    h, w = image.shape\n    bottom_third = image[2*h//3:, :]\n    total_non_zero = np.count_nonzero(image)\n    non_zero_bottom = np.count_nonzero(bottom_third)\n    return float(non_zero_bottom / total_non_zero) if total_non_zero > 0 else 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Mean pixel intensity of the image corners'\n    h, w = image.shape\n    corners = np.concatenate((image[0, 0:w//4], image[0, 3*w//4:w], image[h//4, 0:w//4], image[h//4, 3*w//4:w]))\n    return float(np.mean(corners))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Count of horizontal gradients (edges) in the image\"\n    gradients = np.gradient(image, axis=0)\n    horizontal_edges = np.count_nonzero(gradients[0])\n    return float(horizontal_edges)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Mean pixel intensity of dark regions (intensity < threshold)\"\n    threshold = 50\n    dark_pixels = image[image < threshold]\n    return float(np.mean(dark_pixels)) if dark_pixels.size > 0 else 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of non-zero pixels to total pixels in the image\"\n    total_pixels = image.size\n    non_zero_pixels = np.count_nonzero(image)\n    return float(non_zero_pixels) / total_pixels if total_pixels > 0 else 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Difference in the count of non-zero rows between the left and right halves of the image'\n    h, w = image.shape\n    left_half_count = np.count_nonzero(np.any(image[:, :w // 2] > 0, axis=1))\n    right_half_count = np.count_nonzero(np.any(image[:, w // 2:] > 0, axis=1))\n    return float(left_half_count - right_half_count)\n",
    "def feature(image: np.ndarray) -> float:\n    \"Mean pixel intensity in the left quarter of the image\"\n    left_quarter = image[:, :image.shape[1] // 4]\n    return float(np.mean(left_quarter))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Proportion of diagonal pixels (from top left to bottom right) to total pixels\"\n    h, w = image.shape\n    diagonal_count = min(h, w)\n    diagonal_sum = np.sum(image[np.arange(diagonal_count), np.arange(diagonal_count)])\n    total_sum = np.sum(image)\n    return float(diagonal_sum / total_sum) if total_sum > 0 else 0.0\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of the number of vertical edges to the total number of edges.\"\n    gradient = np.gradient(image)\n    vertical_edges = np.count_nonzero(gradient[1])  # Vertical gradient count\n    total_edges = np.count_nonzero(gradient)\n    return float(vertical_edges) / float(total_edges) if total_edges > 0 else 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Mean of the horizontal gradient magnitudes for the bottom half of the image\"\n    h, w = image.shape\n    bottom_half = image[h//2:, :]\n    horizontal_gradient = np.gradient(bottom_half, axis=1)\n    return float(np.mean(np.abs(horizontal_gradient)))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Percentage of non-zero pixels within a circular area in the center of the image'\n    h, w = image.shape\n    center_region = image[h // 4:3 * h // 4, w // 4:3 * w // 4]\n    radius = min(center_region.shape) / 2.0\n    y, x = np.ogrid[:center_region.shape[0], :center_region.shape[1]]\n    mask = (x - center_region.shape[1] // 2)**2 + (y - center_region.shape[0] // 2)**2 <= radius**2\n    return float(np.count_nonzero(center_region[mask]) / (np.sum(mask) + 1e-5))  # Avoid division by zero\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of non-zero pixels to total pixels in the image\"\n    total_pixels = image.size\n    non_zero_pixels = np.count_nonzero(image)\n    return float(non_zero_pixels) / total_pixels if total_pixels > 0 else 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Mean of the horizontal gradient magnitudes for the bottom half of the image\"\n    h, w = image.shape\n    bottom_half = image[h//2:, :]\n    horizontal_gradient = np.gradient(bottom_half, axis=1)\n    return float(np.mean(np.abs(horizontal_gradient)))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of non-zero pixels to total pixels in the image\"\n    total_pixels = image.size\n    non_zero_pixels = np.count_nonzero(image)\n    return float(non_zero_pixels) / total_pixels if total_pixels > 0 else 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of non-zero pixels to total pixels in the image\"\n    total_pixels = image.size\n    non_zero_pixels = np.count_nonzero(image)\n    return float(non_zero_pixels) / total_pixels if total_pixels > 0 else 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Standard deviation of pixel intensities in the corner regions\"\n    h, w = image.shape\n    top_left = image[0:h//2, 0:w//2]\n    top_right = image[0:h//2, w//2:w]\n    bottom_left = image[h//2:h, 0:w//2]\n    bottom_right = image[h//2:h, w//2:w]\n    corner_std = np.std([np.std(top_left), np.std(top_right), np.std(bottom_left), np.std(bottom_right)])\n    return float(corner_std)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Measure the variance of pixel intensities in the top and bottom halves of the image.\"\n    top_half = image[:image.shape[0] // 2]\n    bottom_half = image[image.shape[0] // 2:]\n    return float(np.var(top_half) - np.var(bottom_half))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of non-zero pixels to total pixels in the image\"\n    total_pixels = image.size\n    non_zero_pixels = np.count_nonzero(image)\n    return float(non_zero_pixels) / total_pixels if total_pixels > 0 else 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Calculate the sum of pixel intensities in the left half of the bottom quarter of the image\"\n    bottom_quarter = image[3*image.shape[0]//4:]\n    left_half_bottom = bottom_quarter[:, :bottom_quarter.shape[1]//2]\n    return float(np.sum(left_half_bottom))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Ratio of the sum of pixel intensities in the top quarter to the total sum of pixel intensities'\n    h, w = image.shape\n    top_quarter = image[0:h//4, :]\n    return float(np.sum(top_quarter) / (np.sum(image) + 1e-7))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of the number of vertical edges to the total number of edges.\"\n    gradient = np.gradient(image)\n    vertical_edges = np.count_nonzero(gradient[1])  # Vertical gradient count\n    total_edges = np.count_nonzero(gradient)\n    return float(vertical_edges) / float(total_edges) if total_edges > 0 else 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of non-zero pixels to total pixels in the image\"\n    total_pixels = image.size\n    non_zero_pixels = np.count_nonzero(image)\n    return float(non_zero_pixels) / total_pixels if total_pixels > 0 else 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Average pixel intensity of the bottom third of the image.\"\n    h, w = image.shape\n    bottom_third = image[2*h//3:h]\n    return float(np.mean(bottom_third))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Gradient magnitude in the center region of the image'\n    h, w = image.shape\n    center_h, center_w = h // 4, w // 4\n    center_region = image[center_h:3*center_h, center_w:3*center_w]\n    grad_x, grad_y = np.gradient(center_region.astype(float))\n    return float(np.mean(np.sqrt(grad_x**2 + grad_y**2)))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Mean pixel intensity of the image margins (top and bottom)\"\n    top_margin = image[:image.shape[0]//10, :]\n    bottom_margin = image[-image.shape[0]//10:, :]\n    return float((np.mean(top_margin) + np.mean(bottom_margin)) / 2)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of non-zero pixels in the bottom quarter to the whole image\"\n    bottom_quarter = image[3*image.shape[0] // 4:, :]\n    total_non_zero = np.count_nonzero(image)\n    non_zero_bottom = np.count_nonzero(bottom_quarter)\n    return float(non_zero_bottom / total_non_zero) if total_non_zero > 0 else 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Mean of the maximum pixel intensity in the left half of the image\"\n    left_half = image[:, :image.shape[1] // 2]\n    return float(np.mean(np.max(left_half, axis=0)))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Count of local maxima in the image\"\n    gradient_x, gradient_y = np.gradient(image)\n    gradients_magnitude = np.sqrt(gradient_x**2 + gradient_y**2)\n    local_maxima = np.count_nonzero((gradients_magnitude > 0) & (np.roll(gradients_magnitude, 1, axis=0) < gradients_magnitude) & (np.roll(gradients_magnitude, -1, axis=0) < gradients_magnitude))\n    return float(local_maxima)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Variance of pixel intensities in the central region\"\n    h, w = image.shape\n    center_h, center_w = h // 4, w // 4\n    center_region = image[center_h:3*center_h, center_w:3*center_w]\n    return float(np.var(center_region))\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of non-zero pixels to total pixels in the image\"\n    total_pixels = image.size\n    non_zero_pixels = np.count_nonzero(image)\n    return float(non_zero_pixels) / total_pixels if total_pixels > 0 else 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Gradient magnitude average difference between left and right halves of the image\"\n    gradients = np.gradient(image)\n    left_gradient_magnitude = np.mean(np.sqrt(gradients[0][:, :image.shape[1]//2]**2 + gradients[1][:, :image.shape[1]//2]**2))\n    right_gradient_magnitude = np.mean(np.sqrt(gradients[0][:, image.shape[1]//2:]**2 + gradients[1][:, image.shape[1]//2:]**2))\n    return float(left_gradient_magnitude - right_gradient_magnitude)\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of non-zero pixels to total pixels in the image\"\n    total_pixels = image.size\n    non_zero_pixels = np.count_nonzero(image)\n    return float(non_zero_pixels) / total_pixels if total_pixels > 0 else 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Difference in average intensity between the left and right halves of the image\"\n    h, w = image.shape\n    left_half = image[:, :w // 2]\n    right_half = image[:, w // 2:]\n    return float(np.mean(left_half) - np.mean(right_half))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of non-zero pixels to total pixels in the image\"\n    total_pixels = image.size\n    non_zero_pixels = np.count_nonzero(image)\n    return float(non_zero_pixels) / total_pixels if total_pixels > 0 else 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of non-zero pixels to total pixels in the image\"\n    total_pixels = image.size\n    non_zero_pixels = np.count_nonzero(image)\n    return float(non_zero_pixels) / total_pixels if total_pixels > 0 else 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of non-zero pixels to total pixels in the image\"\n    total_pixels = image.size\n    non_zero_pixels = np.count_nonzero(image)\n    return float(non_zero_pixels) / total_pixels if total_pixels > 0 else 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Count of columns with a high intensity (above threshold) in the image\"\n    threshold = 200\n    high_intensity_columns = np.sum(np.any(image > threshold, axis=0))\n    return float(high_intensity_columns)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Count of horizontal edges (variation in pixel intensity) in the image\"\n    gradient_x, gradient_y = np.gradient(image)\n    horizontal_edges = np.sum(np.abs(gradient_y))\n    return float(horizontal_edges)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of the number of vertical edges to the total number of edges.\"\n    gradient = np.gradient(image)\n    vertical_edges = np.count_nonzero(gradient[1])  # Vertical gradient count\n    total_edges = np.count_nonzero(gradient)\n    return float(vertical_edges) / float(total_edges) if total_edges > 0 else 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Calculate the ratio of the sum of pixel intensities in the top quarter to the bottom quarter\"\n    top_quarter_sum = np.sum(image[:image.shape[0]//4])\n    bottom_quarter_sum = np.sum(image[3*image.shape[0]//4:])\n    return float(top_quarter_sum / (bottom_quarter_sum + 1e-6))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Mean pixel intensity of the diagonal from top-left to bottom-right'\n    diagonal = np.diagonal(image)\n    return float(np.mean(diagonal))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of non-zero pixels to total pixels in the image\"\n    total_pixels = image.size\n    non_zero_pixels = np.count_nonzero(image)\n    return float(non_zero_pixels) / total_pixels if total_pixels > 0 else 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of diagonal edge intensity to total edge intensity in the image\"\n    gradient = np.sqrt(np.gradient(image, axis=0)**2 + np.gradient(image, axis=1)**2)\n    diagonal_edges = gradient[np.diag_indices(min(image.shape))].sum()  # Diagonal edge intensity\n    total_edges = np.sum(gradient)\n    return float(diagonal_edges / total_edges) if total_edges > 0 else 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of non-zero pixels to total pixels in the image\"\n    total_pixels = image.size\n    non_zero_pixels = np.count_nonzero(image)\n    return float(non_zero_pixels) / total_pixels if total_pixels > 0 else 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of non-zero pixels to total pixels in the image\"\n    total_pixels = image.size\n    non_zero_pixels = np.count_nonzero(image)\n    return float(non_zero_pixels) / total_pixels if total_pixels > 0 else 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of non-zero pixels to total pixels in the image\"\n    total_pixels = image.size\n    non_zero_pixels = np.count_nonzero(image)\n    return float(non_zero_pixels) / total_pixels if total_pixels > 0 else 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of non-zero pixels to total pixels in the image\"\n    total_pixels = image.size\n    non_zero_pixels = np.count_nonzero(image)\n    return float(non_zero_pixels) / total_pixels if total_pixels > 0 else 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Proportion of horizontal edges to total edges in the image\"\n    grad_y, _ = np.gradient(image)\n    horizontal_edges = np.count_nonzero(grad_y > 0)  # Counting positive gradients\n    total_edges = np.count_nonzero(grad_y)\n    return float(horizontal_edges / total_edges) if total_edges > 0 else 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of non-zero pixels to total pixels in the image\"\n    total_pixels = image.size\n    non_zero_pixels = np.count_nonzero(image)\n    return float(non_zero_pixels) / total_pixels if total_pixels > 0 else 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Number of isolated zero pixels surrounded by non-zero pixels.\"\n    padded_image = np.pad(image, pad_width=1, mode='constant', constant_values=0)\n    isolated_zeros = np.sum((padded_image[1:-1, 1:-1] == 0) &\n                             (padded_image[0:-2, 1:-1] != 0) &\n                             (padded_image[2:, 1:-1] != 0) &\n                             (padded_image[1:-1, 0:-2] != 0) &\n                             (padded_image[1:-1, 2:] != 0))\n    return float(isolated_zeros)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of non-zero pixels to total pixels in the image\"\n    total_pixels = image.size\n    non_zero_pixels = np.count_nonzero(image)\n    return float(non_zero_pixels) / total_pixels if total_pixels > 0 else 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Mean pixel intensity of the bottom half of the image\"\n    h, w = image.shape\n    bottom_half = image[h//2:, :]\n    return float(np.mean(bottom_half))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of non-zero pixels to total pixels in the image\"\n    total_pixels = image.size\n    non_zero_pixels = np.count_nonzero(image)\n    return float(non_zero_pixels) / total_pixels if total_pixels > 0 else 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Average pixel intensity in the top third of the image\"\n    h, w = image.shape\n    top_third = image[:h//3, :]\n    return float(np.mean(top_third))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Sum of pixel intensities in the center column of the image\"\n    h, w = image.shape\n    center_col = image[:, w // 2]\n    return float(np.sum(center_col))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of non-zero pixels to total pixels in the image\"\n    total_pixels = image.size\n    non_zero_pixels = np.count_nonzero(image)\n    return float(non_zero_pixels) / total_pixels if total_pixels > 0 else 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Compute the row-wise sum of pixel intensities and return the maximum value\"\n    return float(np.max(np.sum(image, axis=1)))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of pixel intensity in the top left quarter to bottom right quarter of the image\"\n    try:\n        top_left = image[:image.shape[0] // 2, :image.shape[1] // 2]\n        bottom_right = image[image.shape[0] // 2:, image.shape[1] // 2:]\n        return float(np.mean(top_left) / np.mean(bottom_right))\n    except Exception as e:\n        return 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of non-zero pixels to total pixels in the image\"\n    total_pixels = image.size\n    non_zero_pixels = np.count_nonzero(image)\n    return float(non_zero_pixels) / total_pixels if total_pixels > 0 else 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Ratio of the number of non-zero pixels in the bottom third to total non-zero pixels in the image'\n    h, w = image.shape\n    bottom_third = image[2*h//3:, :]\n    total_non_zero = np.count_nonzero(image)\n    non_zero_bottom = np.count_nonzero(bottom_third)\n    return float(non_zero_bottom / total_non_zero) if total_non_zero > 0 else 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Count of non-zero rows in the right half of the image'\n    right_half = image[:, image.shape[1]//2:]\n    non_zero_rows = np.count_nonzero(np.any(right_half != 0, axis=1))\n    return float(non_zero_rows)\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of pixel intensities in the bottom quarter relative to the entire image.\"\n    bottom_quarter = image[3 * image.shape[0] // 4:]\n    sum_bottom = np.sum(bottom_quarter)\n    sum_total = np.sum(image)\n    if sum_total == 0:\n        return 0.0\n    return float(sum_bottom) / sum_total\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Ratio of the sum of pixel values in the upper third region to the total pixel values'\n    h, w = image.shape\n    upper_third = image[:h // 3, :]\n    return float(np.sum(upper_third) / (np.sum(image) + 1e-10))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Calculate the ratio of the sum of upper half pixel intensities to the sum of the lower half pixel intensities.\"\n    h, w = image.shape\n    upper_half = image[:h//2]\n    lower_half = image[h//2:]\n    upper_sum = np.sum(upper_half)\n    lower_sum = np.sum(lower_half)\n    return upper_sum / (lower_sum + 1e-5)  # Avoid division by zero\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Count of horizontal edges (variation in pixel intensity) in the image\"\n    gradient_x, gradient_y = np.gradient(image)\n    horizontal_edges = np.sum(np.abs(gradient_y))\n    return float(horizontal_edges)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Calculate the average gradient magnitude in the image, which indicates edges.\"\n    gradients = np.sqrt(np.sum(np.gradient(image.astype(float)), axis=0)**2)\n    return float(np.mean(gradients))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of non-zero pixels to total pixels in the image\"\n    total_pixels = image.size\n    non_zero_pixels = np.count_nonzero(image)\n    return float(non_zero_pixels) / total_pixels if total_pixels > 0 else 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Count of vertical edges in the image using gradient methods\"\n    gradient_x = np.gradient(image, axis=1)\n    vertical_edges = np.count_nonzero(np.abs(gradient_x) > 50)\n    return float(vertical_edges)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Check for presence of long vertical lines by summing column intensities\"\n    vertical_sum = np.sum(image, axis=0)\n    return float(np.max(vertical_sum) / np.sum(vertical_sum)) if np.sum(vertical_sum) > 0 else 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of non-zero pixels to total pixels in the image\"\n    total_pixels = image.size\n    non_zero_pixels = np.count_nonzero(image)\n    return float(non_zero_pixels) / total_pixels if total_pixels > 0 else 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of non-zero pixels to total pixels in the image\"\n    total_pixels = image.size\n    non_zero_pixels = np.count_nonzero(image)\n    return float(non_zero_pixels) / total_pixels if total_pixels > 0 else 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Average distance of pixels from the center of the image'\n    h, w = image.shape\n    center_x, center_y = w // 2, h // 2\n    distances = np.sqrt((np.arange(h)[:, None] - center_y) ** 2 + (np.arange(w) - center_x) ** 2)\n    average_distance = np.mean(distances[image > 0])\n    return float(average_distance) if np.count_nonzero(image) > 0 else 0.0\n",
    "def feature(image: np.ndarray) -> float:\n    \"Calculate the average gradient magnitude in the image, which indicates edges.\"\n    gradients = np.sqrt(np.sum(np.gradient(image.astype(float)), axis=0)**2)\n    return float(np.mean(gradients))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Difference between max and min pixel intensities\"\n    return float(np.max(image) - np.min(image))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Count of non-zero pixels in a defined center strip of the image'\n    h, w = image.shape\n    center_strip = image[h//4:3*h//4, w//4:w//4 + 10]  # 10 pixels wide\n    return float(np.count_nonzero(center_strip))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Excess of darker pixels (below a set threshold) in the top half of the image compared to the bottom half.\"\n    dark_threshold = 80\n    top_half_dark_pixels = np.count_nonzero(image[:image.shape[0] // 2] < dark_threshold)\n    bottom_half_dark_pixels = np.count_nonzero(image[image.shape[0] // 2:] < dark_threshold)\n    return float(top_half_dark_pixels - bottom_half_dark_pixels)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Difference in average intensity between the left and right halves of the image\"\n    h, w = image.shape\n    left_half = image[:, :w // 2]\n    right_half = image[:, w // 2:]\n    return float(np.mean(left_half) - np.mean(right_half))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Mean pixel intensity difference between left and right quarters of the image\"\n    h, w = image.shape\n    left_quarter = image[:, :w // 4]\n    right_quarter = image[:, 3 * w // 4:]\n    return float(np.mean(left_quarter) - np.mean(right_quarter))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Average pixel intensity of the image corners\"\n    h, w = image.shape\n    corners = np.concatenate((image[:h//4, :w//4], image[:h//4, 3*w//4:], \n                               image[3*h//4:, :w//4], image[3*h//4:, 3*w//4:]))\n    return float(np.mean(corners))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of pixel intensity in the top left quarter to bottom right quarter of the image\"\n    try:\n        top_left = image[:image.shape[0] // 2, :image.shape[1] // 2]\n        bottom_right = image[image.shape[0] // 2:, image.shape[1] // 2:]\n        return float(np.mean(top_left) / np.mean(bottom_right))\n    except Exception as e:\n        return 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Mean pixel intensity in the area around the top-right corner\"\n    h, w = image.shape\n    corner_region = image[0:h // 3, w // 2:w]\n    return float(np.mean(corner_region))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Average width of white contours in the image'\n    thresholded = np.where(image > 150, 1, 0)\n    contours = np.sum(thresholded, axis=0)\n    return float(np.mean(contours[contours > 0])) if np.any(contours > 0) else 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of non-zero pixels to total pixels in the image\"\n    total_pixels = image.size\n    non_zero_pixels = np.count_nonzero(image)\n    return float(non_zero_pixels) / total_pixels if total_pixels > 0 else 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of the sum of pixel intensities in the middle column to the total sum of pixel intensities.\"\n    h, w = image.shape\n    middle_column = image[:, w // 2]\n    return float(np.sum(middle_column)) / np.sum(image)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Proportion of non-zero pixels in the right half of the image\"\n    h, w = image.shape\n    right_half = image[:, w//2:]\n    non_zero_count = np.count_nonzero(right_half)\n    total_pixels = right_half.size\n    proportion = non_zero_count / total_pixels if total_pixels > 0 else 0.0\n    return float(proportion)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of the number of horizontal edges to the total number of edges detected in the image.\"\n    gx, gy = np.gradient(image)\n    edges = np.sqrt(gx ** 2 + gy ** 2)\n    horizontal_edges = np.sum(np.abs(gy))\n    total_edges = np.sum(edges)\n    return float(horizontal_edges / (total_edges + 1e-5))\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of pixel intensities in the central horizontal line to total intensity in the image\"\n    center_line = image[image.shape[0] // 2, :]\n    return float(np.sum(center_line) / np.sum(image)) if np.sum(image) > 0 else 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Percentage of pixels that are above the mean intensity\"\n    mean_intensity = np.mean(image)\n    above_mean = np.count_nonzero(image > mean_intensity)\n    return float(above_mean) / image.size\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of non-zero pixels to total pixels in the image\"\n    total_pixels = image.size\n    non_zero_pixels = np.count_nonzero(image)\n    return float(non_zero_pixels) / total_pixels if total_pixels > 0 else 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Mean pixel intensity of the diagonal from bottom-left to top-right'\n    h, w = image.shape\n    diagonal = [image[h - i - 1, i] for i in range(min(h, w))]\n    return float(np.mean(diagonal))\n",
    "def feature(image: np.ndarray) -> float:\n    \"Average pixel intensity of the image corners\"\n    h, w = image.shape\n    corners = np.concatenate((image[:h//4, :w//4], image[:h//4, 3*w//4:], \n                               image[3*h//4:, :w//4], image[3*h//4:, 3*w//4:]))\n    return float(np.mean(corners))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Calculate the symmetry of the image by comparing halves.'\n    h, w = image.shape\n    left_half = image[:, :w//2]\n    right_half = image[:, w//2:]\n    return float(np.mean(left_half) / (np.mean(right_half) or 1))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of non-zero pixels to total pixels in the image\"\n    total_pixels = image.size\n    non_zero_pixels = np.count_nonzero(image)\n    return float(non_zero_pixels) / total_pixels if total_pixels > 0 else 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of non-zero pixels to total pixels in the image\"\n    total_pixels = image.size\n    non_zero_pixels = np.count_nonzero(image)\n    return float(non_zero_pixels) / total_pixels if total_pixels > 0 else 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Determine the sum of pixel values in the top quarter of the image.\"\n    top_quarter = image[:image.shape[0] // 4, :]\n    return float(np.sum(top_quarter))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Mean pixel intensity of the image edges\"\n    edges = np.gradient(image)\n    edge_magnitude = np.sqrt(edges[0]**2 + edges[1]**2)\n    return float(np.mean(edge_magnitude))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Count of local minima in the image based on pixel intensity'\n    from scipy.ndimage import gaussian_filter\n    smoothed_image = gaussian_filter(image, sigma=1)\n    local_minima = (smoothed_image < np.roll(smoothed_image, 1, axis=0)) & \\\n                   (smoothed_image < np.roll(smoothed_image, -1, axis=0)) & \\\n                   (smoothed_image < np.roll(smoothed_image, 1, axis=1)) & \\\n                   (smoothed_image < np.roll(smoothed_image, -1, axis=1))\n    return float(np.sum(local_minima))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Standard deviation of pixel intensities in the corner regions\"\n    h, w = image.shape\n    top_left = image[0:h//2, 0:w//2]\n    top_right = image[0:h//2, w//2:w]\n    bottom_left = image[h//2:h, 0:w//2]\n    bottom_right = image[h//2:h, w//2:w]\n    corner_std = np.std([np.std(top_left), np.std(top_right), np.std(bottom_left), np.std(bottom_right)])\n    return float(corner_std)\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Standard deviation of pixel intensities in the left quarter of the image\"\n    h, w = image.shape\n    left_quarter = image[:, :w // 4]\n    return float(np.std(left_quarter))\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of non-zero pixels to total pixels in the image\"\n    total_pixels = image.size\n    non_zero_pixels = np.count_nonzero(image)\n    return float(non_zero_pixels) / total_pixels if total_pixels > 0 else 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Compactness of the object in the image defined as area/perimeter^2\"\n    thresholded_image = image > 128\n    area = np.sum(thresholded_image)\n    perimeter = np.sum(np.abs(np.gradient(thresholded_image.astype(float))))\n    return (area / (perimeter**2)) if perimeter > 0 else 0.0\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of non-zero pixels to total pixels in the image\"\n    total_pixels = image.size\n    non_zero_pixels = np.count_nonzero(image)\n    return float(non_zero_pixels) / total_pixels if total_pixels > 0 else 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of non-zero pixels to total pixels in the image\"\n    total_pixels = image.size\n    non_zero_pixels = np.count_nonzero(image)\n    return float(non_zero_pixels) / total_pixels if total_pixels > 0 else 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of non-zero pixels to total pixels in the image\"\n    total_pixels = image.size\n    non_zero_pixels = np.count_nonzero(image)\n    return float(non_zero_pixels) / total_pixels if total_pixels > 0 else 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of non-zero pixels to total pixels in the image\"\n    total_pixels = image.size\n    non_zero_pixels = np.count_nonzero(image)\n    return float(non_zero_pixels) / total_pixels if total_pixels > 0 else 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    \"Ratio of non-zero pixels to total pixels in the image\"\n    total_pixels = image.size\n    non_zero_pixels = np.count_nonzero(image)\n    return float(non_zero_pixels) / total_pixels if total_pixels > 0 else 0.0\n\n"
  ]
}