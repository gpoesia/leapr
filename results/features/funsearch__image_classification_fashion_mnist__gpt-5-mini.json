{"used_features": ["def feature(image: np.ndarray) -> float:\n    'Aspect ratio (width / height) of the image to capture tall vs wide items'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0:\n        return 0.0\n    return float(w) / float(h)\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Fraction of center-region pixels whose intensity deviates from global mean by more than one global std'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    # convert to grayscale\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    gmean = np.mean(gray)\n    gstd = np.std(gray)\n    if gstd == 0:\n        return 0.0\n    ch = max(1, h // 4)\n    cw = max(1, w // 4)\n    center = gray[ch:3*ch, cw:3*cw]\n    if center.size == 0:\n        return 0.0\n    mask = np.abs(center - gmean) > gstd\n    return float(np.count_nonzero(mask)) / float(center.size)\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Horizontal symmetry score: normalized mean absolute difference between left and mirrored right half (0 = identical)'\n    import numpy as np\n    if image is None:\n        return 1.0\n    h, w = image.shape[:2]\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    mid = w // 2\n    left = gray[:, :mid]\n    right = gray[:, w - mid:w]\n    if left.size == 0 or right.size == 0:\n        return 1.0\n    # flip right horizontally to compare\n    right_flipped = np.fliplr(right)\n    # pad smaller to match\n    if left.shape != right_flipped.shape:\n        mnw = min(left.shape[1], right_flipped.shape[1])\n        left = left[:, :mnw]\n        right_flipped = right_flipped[:, :mnw]\n    diff = np.abs(left - right_flipped)\n    denom = np.maximum(np.mean(gray) + 1e-8, 1e-8)\n    return float(np.mean(diff) / denom)\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Vertical symmetry score: normalized mean absolute difference between top and mirrored bottom half (0 = identical)'\n    import numpy as np\n    if image is None:\n        return 1.0\n    h, w = image.shape[:2]\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    mid = h // 2\n    top = gray[:mid, :]\n    bottom = gray[h - mid:h, :]\n    if top.size == 0 or bottom.size == 0:\n        return 1.0\n    bottom_flipped = np.flipud(bottom)\n    if top.shape != bottom_flipped.shape:\n        mnh = min(top.shape[0], bottom_flipped.shape[0])\n        top = top[:mnh, :]\n        bottom_flipped = bottom_flipped[:mnh, :]\n    diff = np.abs(top - bottom_flipped)\n    denom = np.maximum(np.mean(gray) + 1e-8, 1e-8)\n    return float(np.mean(diff) / denom)\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Average edge magnitude (gradient magnitude mean) of the grayscale image'\n    import numpy as np\n    if image is None:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    # normalize to avoid scale dependence\n    mx = np.max(gray)\n    if mx > 0:\n        gray = gray / mx\n    gy, gx = np.gradient(gray)\n    grad_mag = np.sqrt(gx * gx + gy * gy)\n    return float(np.mean(grad_mag))\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Difference in mean intensity between bottom half and top half (bottom_mean - top_mean)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    mid = h // 2\n    top = gray[:mid, :] if mid > 0 else gray\n    bottom = gray[mid:, :] if mid < h else gray\n    if top.size == 0 or bottom.size == 0:\n        return 0.0\n    return float(np.mean(bottom) - np.mean(top))\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Mean per-channel standard deviation (colorfulness); returns 0 for grayscale'\n    import numpy as np\n    if image is None:\n        return 0.0\n    if len(image.shape) != 3:\n        return 0.0\n    img = image.astype(float)\n    # compute std across spatial dims for each channel\n    channel_stds = [float(np.std(img[:, :, c])) for c in range(img.shape[2])]\n    if len(channel_stds) == 0:\n        return 0.0\n    return float(np.mean(channel_stds))\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Normalized object width estimate from horizontal projection of a simple intensity-based mask (0..1)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    gmin, gmax = np.min(gray), np.max(gray)\n    rng = gmax - gmin\n    # threshold relative to range\n    thr = gmin + 0.15 * (rng if rng > 0 else 1.0)\n    mask = gray < thr  # assume object darker than background; if not, still informative\n    col_counts = np.sum(mask, axis=0)\n    # consider a column part of object if it has at least 10% of rows marked\n    col_thresh = max(1, int(0.10 * h))\n    cols_obj = np.count_nonzero(col_counts >= col_thresh)\n    return float(cols_obj) / float(w)\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Fraction of columns that contain strong vertical edges (indicates vertical structure like trousers)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    # normalize\n    mx = np.max(gray)\n    if mx > 0:\n        gray = gray / mx\n    gy, gx = np.gradient(gray)\n    vert_edges = np.abs(gx)\n    col_sums = np.sum(vert_edges, axis=0)\n    # threshold relative to median\n    med = np.median(col_sums)\n    thresh = med * 1.5 + 1e-8\n    strong_cols = np.count_nonzero(col_sums > thresh)\n    return float(strong_cols) / float(w)\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Normalized offset (0..~1) of intensity centroid (weighted toward darker pixels) from image center'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    # weight darker pixels more (assume object may be darker); shift to [0,1]\n    gmin, gmax = np.min(gray), np.max(gray)\n    rng = gmax - gmin\n    if rng <= 0:\n        return 0.0\n    norm = (gray - gmin) / rng\n    weights = 1.0 - norm\n    total = np.sum(weights)\n    if total <= 0:\n        return 0.0\n    ys = np.arange(h).reshape(h, 1)\n    xs = np.arange(w).reshape(1, w)\n    cx = float(np.sum(weights * xs) / total)\n    cy = float(np.sum(weights * ys) / total)\n    # geometric center\n    gx_center = (w - 1) / 2.0\n    gy_center = (h - 1) / 2.0\n    dx = (cx - gx_center) / max(1.0, w / 2.0)\n    dy = (cy - gy_center) / max(1.0, h / 2.0)\n    dist = np.sqrt(dx * dx + dy * dy)\n    return float(dist)\n", "def feature(image: np.ndarray) -> float:\n    'Normalized row index of the topmost object pixel (0=top, 1=bottom) estimated from a simple mask'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    # grayscale\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    # adaptive threshold: use 60th percentile\n    thr = np.percentile(gray, 60)\n    mask_dark = gray < thr\n    mask_bright = gray > thr\n    mask = mask_dark if np.count_nonzero(mask_dark) >= np.count_nonzero(mask_bright) else mask_bright\n    if np.count_nonzero(mask) == 0:\n        return 0.0\n    # find topmost row that contains any mask pixel\n    rows = np.any(mask, axis=1)\n    top_idx = int(np.argmax(rows)) if np.any(rows) else h - 1\n    # normalize to [0,1]\n    return float(top_idx / max(1, h - 1))\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Fraction of image rows that contain object pixels (estimated object height proportion)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 50)\n    mask = gray < thr if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else gray > thr\n    if mask.size == 0:\n        return 0.0\n    row_has = np.any(mask, axis=1)\n    frac = float(np.count_nonzero(row_has)) / float(h)\n    return float(frac)\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Normalized horizontal offset of binary mask centroid from image center (negative = left, positive = right)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask1 = gray < thr\n    mask2 = gray > thr\n    mask = mask1 if np.count_nonzero(mask1) >= np.count_nonzero(mask2) else mask2\n    total = np.count_nonzero(mask)\n    if total == 0:\n        return 0.0\n    ys = np.arange(h).reshape(h, 1)\n    xs = np.arange(w).reshape(1, w)\n    cx = float(np.sum(mask * xs) / total)\n    center_x = (w - 1) / 2.0\n    offset = (cx - center_x) / max(1.0, w / 2.0)\n    return float(offset)\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Ratio of vertical edge energy to horizontal edge energy (higher => more vertical structure)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 2 or w < 2:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    # normalize\n    mx = np.max(gray)\n    if mx > 0:\n        gray = gray / mx\n    gy, gx = np.gradient(gray)\n    vert_energy = np.sum(np.abs(gx))\n    horz_energy = np.sum(np.abs(gy))\n    return float(vert_energy / (horz_energy + 1e-8))\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Relative darkness of the four corner patches compared to center (positive => corners darker)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    ph = max(1, h // 8)\n    pw = max(1, w // 8)\n    corners = []\n    corners.append(gray[0:ph, 0:pw])\n    corners.append(gray[0:ph, w - pw:w])\n    corners.append(gray[h - ph:h, 0:pw])\n    corners.append(gray[h - ph:h, w - pw:w])\n    corner_mean = np.mean([np.mean(c) if c.size > 0 else 0.0 for c in corners])\n    ch = max(1, h // 4)\n    cw = max(1, w // 4)\n    center = gray[ch:3*ch, cw:3*cw]\n    center_mean = float(np.mean(center)) if center.size > 0 else float(np.mean(gray))\n    denom = np.maximum(np.mean(gray) + 1e-8, 1e-8)\n    return float((corner_mean - center_mean) / denom)\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Fraction of pixels that are colorful (range across RGB channels exceeds a small threshold); 0 for grayscale'\n    import numpy as np\n    if image is None:\n        return 0.0\n    if len(image.shape) != 3:\n        return 0.0\n    img = image.astype(float)\n    ch_max = np.max(img, axis=2)\n    ch_min = np.min(img, axis=2)\n    pix_range = ch_max - ch_min\n    rng = np.max(pix_range)\n    thr = max(1e-6, 0.10 * rng)\n    colorful = pix_range > thr\n    return float(np.count_nonzero(colorful)) / float(img.shape[0] * img.shape[1])\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Fraction of mask pixels that lie in the bottom quarter of the image (useful for shoes/boots)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 50)\n    mask = gray < thr if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else gray > thr\n    total = np.count_nonzero(mask)\n    if total == 0:\n        return 0.0\n    bottom_region = mask[int(0.75*h):h, :]\n    bottom_count = np.count_nonzero(bottom_region)\n    return float(bottom_count) / float(total)\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Normalized standard deviation of the top contour (row index of first object pixel per column) measuring top irregularity'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 2 or w < 1:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = gray < thr if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else gray > thr\n    # for each column find topmost mask pixel; if none, set to h-1\n    top_idx = np.full((w,), h - 1, dtype=float)\n    any_in_col = np.any(mask, axis=0)\n    if np.any(any_in_col):\n        cols = np.where(any_in_col)[0]\n        # use argmax on inverted boolean per column to get first True\n        for c in cols:\n            col = mask[:, c]\n            top_idx[c] = float(np.argmax(col))\n    std_top = float(np.std(top_idx))\n    return float(std_top / max(1.0, h))\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Fill ratio of mask within its bounding box (mask_area / bbox_area), ranges 0..1'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 50)\n    mask = gray < thr if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else gray > thr\n    ys, xs = np.where(mask)\n    if ys.size == 0:\n        return 0.0\n    y0, y1 = ys.min(), ys.max()\n    x0, x1 = xs.min(), xs.max()\n    bbox_area = float((y1 - y0 + 1) * (x1 - x0 + 1))\n    mask_area = float(ys.size)\n    if bbox_area <= 0:\n        return 0.0\n    return float(mask_area / bbox_area)\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Fraction of rows that contain strong horizontal edges (useful to detect straps, soles, or hems)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 2 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    mx = np.max(gray)\n    if mx > 0:\n        gray = gray / mx\n    gy, gx = np.gradient(gray)\n    row_strength = np.sum(np.abs(gy), axis=1)\n    med = np.median(row_strength)\n    thresh = med * 1.5 + 1e-8\n    strong_rows = np.count_nonzero(row_strength > thresh)\n    return float(strong_rows) / float(h)\n", "def feature(image: np.ndarray) -> float:\n    'Mean width of object segments per row (normalized by image width): silhouette slenderness'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = gray < thr if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else gray > thr\n    widths = []\n    for r in range(h):\n        row = mask[r, :].astype(int)\n        if np.any(row):\n            pad = np.concatenate(([0], row, [0]))\n            diff = np.diff(pad)\n            starts = np.where(diff == 1)[0]\n            ends = np.where(diff == -1)[0]\n            seg_lengths = ends - starts\n            if seg_lengths.size > 0:\n                widths.append(np.mean(seg_lengths))\n    if len(widths) == 0:\n        return 0.0\n    mean_width = float(np.mean(widths))\n    return float(mean_width / max(1.0, float(w)))\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Median number of separate object segments per column (useful for detecting multi-part shapes)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = gray < thr if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else gray > thr\n    if not np.any(mask):\n        return 0.0\n    # pad top and bottom to detect segment starts\n    pad = np.vstack([np.zeros((1, w), dtype=bool), mask, np.zeros((1, w), dtype=bool)])\n    diff = np.diff(pad.astype(int), axis=0)\n    starts = diff == 1\n    seg_counts = np.sum(starts, axis=0)\n    return float(np.median(seg_counts))\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Proportion of pixels with strong vertical gradient (high |d/dx|) relative to local contrast'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 2 or w < 2:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    mx = np.max(np.abs(gray))\n    if mx > 0:\n        gray = gray / mx\n    gy, gx = np.gradient(gray)\n    magx = np.abs(gx)\n    if magx.size == 0:\n        return 0.0\n    thr = np.percentile(magx.flatten(), 85)\n    if thr <= 0:\n        return 0.0\n    strong = magx > thr\n    return float(np.count_nonzero(strong)) / float(h * w)\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Normalized top edge jaggedness: sum of absolute vertical changes of top contour divided by image height'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 1 or w < 1:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = gray < thr if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else gray > thr\n    top_idx = np.full((w,), float(h - 1), dtype=float)\n    any_in_col = np.any(mask, axis=0)\n    if np.any(any_in_col):\n        cols = np.where(any_in_col)[0]\n        for c in cols:\n            col = mask[:, c]\n            top_idx[c] = float(np.argmax(col))\n    diffs = np.abs(np.diff(top_idx))\n    sum_diff = float(np.sum(diffs))\n    return float(sum_diff / max(1.0, float(h)))\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Ratio of bottom quarter mask area to middle half mask area (compactness at bottom)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = gray < thr if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else gray > thr\n    total = np.count_nonzero(mask)\n    if total == 0:\n        return 0.0\n    bottom = mask[int(0.75*h):h, :]\n    mid = mask[int(0.25*h):int(0.75*h), :]\n    bottom_count = np.count_nonzero(bottom)\n    mid_count = np.count_nonzero(mid)\n    return float((bottom_count + 1.0) / (mid_count + 1.0))\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Normalized vertical centroid offset (positive = object lower than image center)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = gray < thr if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else gray > thr\n    total = np.count_nonzero(mask)\n    if total == 0:\n        return 0.0\n    ys = np.arange(h).reshape(h, 1)\n    cy = float(np.sum(mask * ys) / total)\n    center_y = (h - 1) / 2.0\n    offset = (cy - center_y) / max(1.0, h / 2.0)\n    return float(offset)\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Fraction of rows whose longest object segment is at least 60% of the maximum row-wise segment (indicates wide continuous shapes)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = gray < thr if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else gray > thr\n    max_per_row = []\n    for r in range(h):\n        row = mask[r, :].astype(int)\n        if np.any(row):\n            pad = np.concatenate(([0], row, [0]))\n            diff = np.diff(pad)\n            starts = np.where(diff == 1)[0]\n            ends = np.where(diff == -1)[0]\n            seg_lengths = ends - starts\n            if seg_lengths.size > 0:\n                max_per_row.append(np.max(seg_lengths))\n            else:\n                max_per_row.append(0)\n        else:\n            max_per_row.append(0)\n    if len(max_per_row) == 0:\n        return 0.0\n    max_all = max(max_per_row)\n    if max_all <= 0:\n        return 0.0\n    thresh = 0.6 * max_all\n    count = sum(1 for x in max_per_row if x >= thresh)\n    return float(count) / float(h)\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Mean green minus blue channel inside the object mask (RGB only), normalized to [-1,1]'\n    import numpy as np\n    if image is None:\n        return 0.0\n    if len(image.shape) != 3 or image.shape[2] < 3:\n        return 0.0\n    h, w, c = image.shape\n    img = image.astype(float)\n    gray = np.mean(img, axis=2)\n    thr = np.percentile(gray, 55)\n    mask = gray < thr if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else gray > thr\n    total = np.count_nonzero(mask)\n    if total == 0:\n        return 0.0\n    g = img[:, :, 1]\n    b = img[:, :, 2]\n    diff = g - b\n    mean_diff = float(np.sum(diff * mask) / total)\n    # normalize by possible dynamic range\n    denom = np.maximum(1.0, np.max(img) - np.min(img))\n    return float(mean_diff / denom)\n", "def feature(image: np.ndarray) -> float:\n    'Aspect ratio (width/height) of the mask bounding box (1.0 if undefined)'\n    import numpy as np\n    if image is None:\n        return 1.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 1.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 60)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    if not np.any(mask):\n        return 1.0\n    rows = np.where(np.any(mask, axis=1))[0]\n    cols = np.where(np.any(mask, axis=0))[0]\n    if rows.size == 0 or cols.size == 0:\n        return 1.0\n    bbox_h = float(rows[-1] - rows[0] + 1)\n    bbox_w = float(cols[-1] - cols[0] + 1)\n    if bbox_h <= 0:\n        return 1.0\n    return float(bbox_w / bbox_h)\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Ratio of average mask row-width in top quarter to bottom quarter (higher => wider at top)'\n    import numpy as np\n    if image is None:\n        return 1.0\n    h, w = image.shape[:2]\n    if h < 4 or w == 0:\n        return 1.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 60)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    q = max(1, h // 4)\n    top = mask[:q, :]\n    bottom = mask[h - q:h, :]\n    top_mean = float(np.mean(np.count_nonzero(top, axis=1)) / max(1.0, w))\n    bottom_mean = float(np.mean(np.count_nonzero(bottom, axis=1)) / max(1.0, w))\n    return float(top_mean / (bottom_mean + 1e-8))\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Normalized vertical centroid of the binary mask (0=top,1=bottom)'\n    import numpy as np\n    if image is None:\n        return 0.5\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.5\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 50)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    if not np.any(mask):\n        return 0.5\n    ys = np.arange(h).reshape(h, 1)\n    cy = float(np.sum(ys * mask) / (np.sum(mask) + 1e-8))\n    return float(cy / max(1.0, h - 1))\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Fraction of mask pixels that touch the image border (0..1)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    total = np.count_nonzero(mask)\n    if total == 0:\n        return 0.0\n    border = np.zeros_like(mask, dtype=bool)\n    border[0, :] = mask[0, :]\n    border[-1, :] = mask[-1, :]\n    border[:, 0] = border[:, 0] | mask[:, 0]\n    border[:, -1] = border[:, -1] | mask[:, -1]\n    border_count = np.count_nonzero(border)\n    return float(border_count) / float(total)\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Maximum vertical continuous span of mask in any column normalized by image height'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 60)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    if not np.any(mask):\n        return 0.0\n    max_span = 0\n    for c in range(w):\n        col = mask[:, c].astype(int)\n        if np.all(col == 0):\n            continue\n        padded = np.concatenate([[0], col, [0]])\n        diff = np.diff(padded)\n        starts = np.where(diff == 1)[0]\n        ends = np.where(diff == -1)[0]\n        if starts.size and ends.size:\n            spans = ends - starts\n            local_max = int(np.max(spans))\n            if local_max > max_span:\n                max_span = local_max\n    return float(max_span) / float(max(1, h))\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Average gradient magnitude along the mask boundary normalized by image gradient max'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 2 or w < 2:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    # create mask\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    if not np.any(mask):\n        return 0.0\n    # gradient magnitude\n    gy, gx = np.gradient(gray)\n    grad = np.sqrt(gx * gx + gy * gy)\n    mg = np.max(grad)\n    # morphological erosion via neighbor AND (no wrap)\n    eroded = mask.copy()\n    for dr in (-1, 0, 1):\n        for dc in (-1, 0, 1):\n            if dr == 0 and dc == 0:\n                continue\n            rolled = np.roll(mask, shift=(dr, dc), axis=(0, 1))\n            if dr == -1:\n                rolled[-1, :] = False\n            if dr == 1:\n                rolled[0, :] = False\n            if dc == -1:\n                rolled[:, -1] = False\n            if dc == 1:\n                rolled[:, 0] = False\n            eroded &= rolled\n    boundary = mask & (~eroded)\n    if not np.any(boundary):\n        return 0.0\n    mean_edge = float(np.mean(grad[boundary]))\n    return float(mean_edge / (mg + 1e-8))\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Relative variability (std/mean) of horizontal widths across upper half rows (higher => irregular top)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 2 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    upper = mask[:max(1, h // 2), :]\n    if upper.size == 0:\n        return 0.0\n    widths = np.count_nonzero(upper, axis=1).astype(float) / max(1.0, w)\n    mean_w = float(np.mean(widths))\n    std_w = float(np.std(widths))\n    return float(std_w / (mean_w + 1e-8))\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Normalized left-right mass difference (positive => more mass on left)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 50)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    total = float(np.count_nonzero(mask))\n    if total == 0.0:\n        return 0.0\n    mid = w // 2\n    left_count = float(np.count_nonzero(mask[:, :mid]))\n    right_count = float(np.count_nonzero(mask[:, mid:]))\n    return float((left_count - right_count) / (total + 1e-8))\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Fill ratio: mask area divided by its bounding-box area (1.0 if perfectly filled)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 60)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    if not np.any(mask):\n        return 0.0\n    rows = np.where(np.any(mask, axis=1))[0]\n    cols = np.where(np.any(mask, axis=0))[0]\n    if rows.size == 0 or cols.size == 0:\n        return 0.0\n    bbox_area = float((rows[-1] - rows[0] + 1) * (cols[-1] - cols[0] + 1))\n    if bbox_area <= 0.0:\n        return 0.0\n    area = float(np.count_nonzero(mask))\n    return float(area / bbox_area)\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Fraction of empty columns in the central vertical strip (higher => vertical gap between parts)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    c0 = max(0, w // 4)\n    c1 = min(w, 3 * w // 4)\n    if c1 <= c0:\n        return 0.0\n    center = mask[:, c0:c1]\n    empty_cols = np.sum(np.all(center == 0, axis=0))\n    return float(empty_cols) / float((c1 - c0))\n", "def feature(image: np.ndarray) -> float:\n    'Mask fill ratio: area of object mask divided by its bounding-box area (1.0 if undefined)'\n    import numpy as np\n    if image is None:\n        return 1.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 1.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = gray < thr if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else gray > thr\n    if not np.any(mask):\n        return 1.0\n    rows = np.where(np.any(mask, axis=1))[0]\n    cols = np.where(np.any(mask, axis=0))[0]\n    if rows.size == 0 or cols.size == 0:\n        return 1.0\n    bbox_h = float(rows[-1] - rows[0] + 1)\n    bbox_w = float(cols[-1] - cols[0] + 1)\n    bbox_area = bbox_h * bbox_w\n    if bbox_area <= 0:\n        return 1.0\n    area = float(np.count_nonzero(mask))\n    return float(area / bbox_area)\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Count of vertical connected row segments of the mask normalized by image height (higher => separated parts)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h <= 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 60)\n    mask = gray < thr if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else gray > thr\n    row_has = np.any(mask, axis=1).astype(int)\n    if row_has.sum() == 0:\n        return 0.0\n    diff = np.diff(np.concatenate(([0], row_has, [0])))\n    starts = np.where(diff == 1)[0]\n    ends = np.where(diff == -1)[0]\n    segments = max(0, len(starts))\n    return float(segments) / max(1.0, float(h))\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Skewness of vertical mass distribution (third standardized moment of row masses)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h <= 1 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = gray < thr if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else gray > thr\n    row_mass = np.sum(mask.astype(float), axis=1)\n    total = np.sum(row_mass)\n    if total <= 0:\n        return 0.0\n    probs = row_mass / (total + 1e-12)\n    ys = np.arange(h).astype(float)\n    mean_y = float(np.sum(probs * ys))\n    centered = ys - mean_y\n    m2 = float(np.sum(probs * (centered ** 2)))\n    m3 = float(np.sum(probs * (centered ** 3)))\n    if m2 <= 1e-12:\n        return 0.0\n    skew = m3 / (np.sqrt(m2) * m2 + 1e-12)\n    return float(skew)\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Simple colorfulness score: sum of absolute differences between RGB channel means (0 for grayscale)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    if len(image.shape) != 3:\n        return 0.0\n    h, w, c = image.shape\n    if c < 3 or h == 0 or w == 0:\n        return 0.0\n    arr = image.astype(float)\n    r_mean = float(np.mean(arr[:, :, 0]))\n    g_mean = float(np.mean(arr[:, :, 1]))\n    b_mean = float(np.mean(arr[:, :, 2]))\n    score = abs(r_mean - g_mean) + abs(r_mean - b_mean) + abs(g_mean - b_mean)\n    # normalize by dynamic range\n    denom = float(np.max(arr) - np.min(arr) + 1e-8)\n    return float(score / denom)\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Fraction of object mass located in the bottom 25% of the image (useful for shoes)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = gray < thr if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else gray > thr\n    total = np.count_nonzero(mask)\n    if total == 0:\n        return 0.0\n    cutoff = max(0, h - max(1, h // 4))\n    bottom_mask = mask[cutoff:, :]\n    bottom_count = np.count_nonzero(bottom_mask)\n    return float(bottom_count) / float(total)\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Elongation: ratio of major to minor eigenvalues of mask coordinate covariance (1.0 if undefined)'\n    import numpy as np\n    if image is None:\n        return 1.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 1.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = gray < thr if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else gray > thr\n    ys, xs = np.where(mask)\n    if ys.size < 3:\n        return 1.0\n    coords = np.vstack((xs.astype(float), ys.astype(float)))\n    cov = np.cov(coords)\n    # handle degenerate case\n    if cov.shape != (2, 2):\n        return 1.0\n    eig = np.linalg.eigvalsh(cov)\n    eig = np.sort(eig)[::-1]\n    if eig[1] <= 0:\n        return float(eig[0] / (eig[1] + 1e-8))\n    return float(eig[0] / eig[1])\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Ratio of top quarter average mask width to middle quarter average mask width (sleeve/shoulder indicator)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 4 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = gray < thr if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else gray > thr\n    top_end = max(1, h // 4)\n    mid_start = max(0, h // 2 - h // 8)\n    mid_end = min(h, mid_start + max(1, h // 4))\n    top_rows = mask[:top_end, :]\n    mid_rows = mask[mid_start:mid_end, :]\n    def avg_width(region):\n        if region.size == 0:\n            return 0.0\n        widths = np.count_nonzero(region, axis=1).astype(float)\n        if widths.size == 0:\n            return 0.0\n        return float(np.mean(widths)) / float(w)\n    top_w = avg_width(top_rows)\n    mid_w = avg_width(mid_rows)\n    if mid_w <= 1e-8:\n        return float(top_w / (mid_w + 1e-8))\n    return float(top_w / mid_w)\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Mask compactness estimate: perimeter^2 / area (lower = more compact), normalized by image area'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    area = float(np.count_nonzero(mask))\n    if area <= 0:\n        return 0.0\n    # approximate perimeter: count mask pixels that have at least one 4-neighbor background\n    pad = np.pad(mask.astype(np.uint8), ((1, 1), (1, 1)), mode='constant', constant_values=0)\n    center = pad[1:-1, 1:-1]\n    up = pad[:-2, 1:-1]\n    down = pad[2:, 1:-1]\n    left = pad[1:-1, :-2]\n    right = pad[1:-1, 2:]\n    neighbor_sum = up + down + left + right\n    boundary = (center.astype(bool)) & (neighbor_sum < 4)\n    perimeter = float(np.count_nonzero(boundary))\n    compact = (perimeter * perimeter) / (area + 1e-8)\n    # normalize by image area to keep values comparable\n    return float(compact / (float(h * w) + 1e-8))\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Standard deviation of gradient magnitude (texture variability), normalized'\n    import numpy as np\n    if image is None:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    if gray.size == 0:\n        return 0.0\n    gy, gx = np.gradient(gray)\n    grad = np.sqrt(gx * gx + gy * gy)\n    mx = np.max(grad)\n    if mx > 0:\n        grad = grad / mx\n    return float(np.std(grad))\n", "def feature(image: np.ndarray) -> float:\n    'Bounding-box aspect ratio (height/width) of the main object mask'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    # grayscale\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    # threshold to get mask\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    if not np.any(mask):\n        return 0.0\n    rows = np.where(np.any(mask, axis=1))[0]\n    cols = np.where(np.any(mask, axis=0))[0]\n    if rows.size == 0 or cols.size == 0:\n        return 0.0\n    bbox_h = float(rows[-1] - rows[0] + 1)\n    bbox_w = float(cols[-1] - cols[0] + 1)\n    if bbox_w <= 0:\n        return 0.0\n    return float(bbox_h / (bbox_w + 1e-8))\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Normalized vertical centroid of the mask (0=top, 1=bottom)'\n    import numpy as np\n    if image is None:\n        return 0.5\n    h, w = image.shape[:2]\n    if h == 0:\n        return 0.5\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    if not np.any(mask):\n        return 0.5\n    ys = np.arange(h)[:, None]\n    mass = mask.astype(float)\n    total = float(np.sum(mass)) + 1e-8\n    centroid_y = float(np.sum(ys * mass) / total)\n    return float(centroid_y / float(h))\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Average number of internal background segments per row inside object bbox (holes)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    if not np.any(mask):\n        return 0.0\n    rows = np.where(np.any(mask, axis=1))[0]\n    if rows.size == 0:\n        return 0.0\n    r0, r1 = rows[0], rows[-1]\n    counts = []\n    for r in range(r0, r1 + 1):\n        row = mask[r, :].astype(int)\n        if not np.any(row):\n            counts.append(0)\n            continue\n        # identify zero-runs that are strictly inside ones (surrounded)\n        pad = np.concatenate(([0], row, [0]))\n        diff = np.diff(pad)\n        starts = np.where(diff == -1)[0]  # zero run starts in pad indexing\n        ends = np.where(diff == 1)[0]     # zero run ends\n        # convert to original indexing and count those with ones on both sides\n        cnt = 0\n        for s, e in zip(starts, ends):\n            left_idx = s - 1\n            right_idx = e - 1\n            if left_idx >= 0 and right_idx < w and left_idx < right_idx:\n                if row[left_idx] == 1 and row[right_idx] == 1:\n                    cnt += 1\n        counts.append(cnt)\n    if len(counts) == 0:\n        return 0.0\n    return float(np.mean(counts))\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Mean gradient magnitude around object boundary (edge sharpness)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 2 or w < 2:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    if not np.any(mask):\n        return 0.0\n    # approximate boundary as mask pixels with any 4-neighbor background\n    pad = np.pad(mask.astype(np.uint8), ((1, 1), (1, 1)), mode='constant', constant_values=0)\n    center = pad[1:-1, 1:-1].astype(bool)\n    up = pad[:-2, 1:-1].astype(bool)\n    down = pad[2:, 1:-1].astype(bool)\n    left = pad[1:-1, :-2].astype(bool)\n    right = pad[1:-1, 2:].astype(bool)\n    neighbor_sum = up + down + left + right\n    boundary = center & (neighbor_sum < 4)\n    if not np.any(boundary):\n        # fallback: use mask border region via dilation of boundary\n        boundary = mask\n    gy, gx = np.gradient(gray)\n    grad_mag = np.sqrt(gx * gx + gy * gy)\n    vals = grad_mag[boundary]\n    if vals.size == 0:\n        return 0.0\n    # normalize by mean intensity to be scale-invariant\n    denom = (np.mean(gray) + 1e-8)\n    return float(np.mean(vals) / denom)\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Mean color saturation (RGB) approximated by (max-min)/max per pixel; 0 for grayscale'\n    import numpy as np\n    if image is None:\n        return 0.0\n    if len(image.shape) != 3 or image.shape[2] != 3:\n        return 0.0\n    img = image.astype(float)\n    mx = np.max(img, axis=2)\n    mn = np.min(img, axis=2)\n    # avoid division by zero where mx==0\n    sat = (mx - mn) / (mx + 1e-8)\n    return float(np.mean(sat))\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Ratio of vertical edge energy in upper quarter to lower quarter (detect top vs bottom detail)'\n    import numpy as np\n    if image is None:\n        return 1.0\n    h, w = image.shape[:2]\n    if h < 4 or w < 2:\n        return 1.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    gy, gx = np.gradient(gray)\n    vert = np.abs(gx)\n    q = max(1, h // 4)\n    top_sum = float(np.sum(vert[:q, :]))\n    bottom_sum = float(np.sum(vert[-q:, :]))\n    return float((top_sum + 1e-8) / (bottom_sum + 1e-8))\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Number of connected components in the bottom quarter of the mask (useful to detect two shoes)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    start = max(0, h - max(1, h // 4))\n    sub = mask[start:, :].astype(np.uint8)\n    sh, sw = sub.shape\n    if sh == 0 or sw == 0:\n        return 0.0\n    visited = np.zeros_like(sub, dtype=bool)\n    comps = 0\n    for i in range(sh):\n        for j in range(sw):\n            if sub[i, j] and not visited[i, j]:\n                comps += 1\n                # flood fill (4-connectivity)\n                stack = [(i, j)]\n                visited[i, j] = True\n                while stack:\n                    y, x = stack.pop()\n                    if y > 0 and sub[y - 1, x] and not visited[y - 1, x]:\n                        visited[y - 1, x] = True\n                        stack.append((y - 1, x))\n                    if y + 1 < sh and sub[y + 1, x] and not visited[y + 1, x]:\n                        visited[y + 1, x] = True\n                        stack.append((y + 1, x))\n                    if x > 0 and sub[y, x - 1] and not visited[y, x - 1]:\n                        visited[y, x - 1] = True\n                        stack.append((y, x - 1))\n                    if x + 1 < sw and sub[y, x + 1] and not visited[y, x + 1]:\n                        visited[y, x + 1] = True\n                        stack.append((y, x + 1))\n    return float(comps)\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Maximum horizontal contiguous mask span normalized by image width (max silhouette width)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    max_span = 0\n    for r in range(h):\n        row = mask[r, :].astype(int)\n        if np.any(row):\n            pad = np.concatenate(([0], row, [0]))\n            diff = np.diff(pad)\n            starts = np.where(diff == 1)[0]\n            ends = np.where(diff == -1)[0]\n            if ends.size > 0:\n                spans = ends - starts\n                max_span = max(max_span, int(np.max(spans)))\n    return float(max_span / float(w))\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Top-neck indicator: ratio of mean mask width in top 1/6 to next 1/6 (small = narrow neck)'\n    import numpy as np\n    if image is None:\n        return 1.0\n    h, w = image.shape[:2]\n    if h < 6 or w == 0:\n        return 1.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    top_h = max(1, h // 6)\n    next_h = max(1, h // 6)\n    top_region = mask[:top_h, :]\n    next_region = mask[top_h:top_h + next_h, :]\n    def mean_frac(region):\n        if region.size == 0:\n            return 0.0\n        widths = np.count_nonzero(region, axis=1).astype(float)\n        if widths.size == 0:\n            return 0.0\n        return float(np.mean(widths) / (float(w) + 1e-8))\n    top_w = mean_frac(top_region)\n    next_w = mean_frac(next_region)\n    return float((top_w + 1e-8) / (next_w + 1e-8))\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Texture roughness: variance of image Laplacian inside mask (higher = more textured)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 2 or w < 2:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    # compute Laplacian via second derivatives\n    gy, gx = np.gradient(gray)\n    gxx = np.gradient(gx, axis=1)\n    gyy = np.gradient(gy, axis=0)\n    lap = gxx + gyy\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    if np.any(mask):\n        vals = lap[mask]\n    else:\n        vals = lap.flatten()\n    if vals.size == 0:\n        return 0.0\n    return float(np.var(vals))\n", "def feature(image: np.ndarray) -> float:\n    'Normalized vertical center of mass of the foreground mask (0=top, 1=bottom)'\n    import numpy as np\n    if image is None:\n        return 0.5\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.5\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    ys, xs = np.where(mask)\n    if ys.size == 0:\n        return 0.5\n    center_y = np.mean(ys)\n    return float(center_y / max(1.0, (h - 1)))\n\n", "def feature(image: np.ndarray) -> float:\n    'Width/height aspect ratio of the mask bounding box (>=0, 1.0 if undefined)'\n    import numpy as np\n    if image is None:\n        return 1.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 1.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    ys, xs = np.where(mask)\n    if ys.size == 0:\n        return 1.0\n    miny, maxy = ys.min(), ys.max()\n    minx, maxx = xs.min(), xs.max()\n    bw = float(maxx - minx + 1)\n    bh = float(maxy - miny + 1)\n    if bh <= 0:\n        return 1.0\n    return float(bw / (bh + 1e-8))\n\n", "def feature(image: np.ndarray) -> float:\n    'Mask area divided by its bounding box area (fill ratio, 0..1)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    area = float(np.count_nonzero(mask))\n    if area == 0:\n        return 0.0\n    ys, xs = np.where(mask)\n    miny, maxy = ys.min(), ys.max()\n    minx, maxx = xs.min(), xs.max()\n    bbox_area = float((maxy - miny + 1) * (maxx - minx + 1))\n    if bbox_area <= 0:\n        return 0.0\n    return float(area / bbox_area)\n\n", "def feature(image: np.ndarray) -> float:\n    'Count of connected mask components with size >=1% image area, normalized by image area'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    area_thresh = max(1, int(0.01 * h * w))\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    visited = np.zeros_like(mask, dtype=bool)\n    comps = 0\n    for r in range(h):\n        for c in range(w):\n            if mask[r, c] and not visited[r, c]:\n                # BFS\n                stack = [(r, c)]\n                visited[r, c] = True\n                cnt = 0\n                while stack:\n                    y, x = stack.pop()\n                    cnt += 1\n                    if y > 0 and mask[y - 1, x] and not visited[y - 1, x]:\n                        visited[y - 1, x] = True\n                        stack.append((y - 1, x))\n                    if y + 1 < h and mask[y + 1, x] and not visited[y + 1, x]:\n                        visited[y + 1, x] = True\n                        stack.append((y + 1, x))\n                    if x > 0 and mask[y, x - 1] and not visited[y, x - 1]:\n                        visited[y, x - 1] = True\n                        stack.append((y, x - 1))\n                    if x + 1 < w and mask[y, x + 1] and not visited[y, x + 1]:\n                        visited[y, x + 1] = True\n                        stack.append((y, x + 1))\n                if cnt >= area_thresh:\n                    comps += 1\n    return float(comps) / float(max(1.0, h * w))\n\n", "def feature(image: np.ndarray) -> float:\n    'Relative darkness concentration in bottom 15% rows (ratio: bottom dark fraction / overall dark fraction)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 50)\n    overall_dark = np.count_nonzero(gray < thr)\n    bottom_h = max(1, int(0.15 * h))\n    bottom = gray[h - bottom_h:h, :]\n    bottom_dark = np.count_nonzero(bottom < thr)\n    if overall_dark <= 0:\n        return float(bottom_dark / float(h * w))\n    return float((bottom_dark / float(bottom.size)) / (overall_dark / float(gray.size)))\n\n", "def feature(image: np.ndarray) -> float:\n    'Sum of absolute differences of mean RGB in left vs right halves normalized by global mean (0 if grayscale)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    if len(image.shape) != 3:\n        return 0.0\n    h, w, c = image.shape\n    if h == 0 or w == 0:\n        return 0.0\n    left = image[:, :w // 2, :].astype(float)\n    right = image[:, w - w // 2:, :].astype(float)\n    left_mean = np.mean(left, axis=(0, 1))\n    right_mean = np.mean(right, axis=(0, 1))\n    diff = np.abs(left_mean - right_mean)\n    denom = np.maximum(np.mean(image.astype(float)), 1e-8)\n    return float(np.sum(diff) / denom)\n\n", "def feature(image: np.ndarray) -> float:\n    'Normalized horizontal center of mass of the foreground mask (0=left, 1=right)'\n    import numpy as np\n    if image is None:\n        return 0.5\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.5\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    ys, xs = np.where(mask)\n    if xs.size == 0:\n        return 0.5\n    center_x = np.mean(xs)\n    return float(center_x / max(1.0, (w - 1)))\n\n", "def feature(image: np.ndarray) -> float:\n    'Normalized vertical standard deviation of mask pixels (spread of object vertically)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    ys, xs = np.where(mask)\n    if ys.size == 0:\n        return 0.0\n    stdy = float(np.std(ys.astype(float)))\n    return float(stdy / float(max(1.0, h)))\n\n", "def feature(image: np.ndarray) -> float:\n    'Proportion of pixels that are local gradient maxima (corner-like) in 3x3 neighborhood'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 3 or w < 3:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    gy, gx = np.gradient(gray)\n    mag = np.hypot(gx, gy)\n    thr = np.percentile(mag.flatten(), 90)\n    # compare center > all neighbors\n    center = mag[1:-1, 1:-1]\n    neighs = [\n        mag[0:-2, 0:-2], mag[0:-2, 1:-1], mag[0:-2, 2:],\n        mag[1:-1, 0:-2],                 mag[1:-1, 2:],\n        mag[2:, 0:-2],   mag[2:, 1:-1],  mag[2:, 2:]\n    ]\n    greater = np.ones_like(center, dtype=bool)\n    for n in neighs:\n        greater &= (center > n)\n    strong = greater & (center > thr)\n    return float(np.count_nonzero(strong)) / float(h * w)\n", "def feature(image: np.ndarray) -> float:\n    'Colorfulness metric (Hasler-S\u00fcsstrunk) for RGB images, 0 for grayscale'\n    import numpy as np\n    if image is None:\n        return 0.0\n    if len(image.shape) != 3 or image.shape[2] < 3:\n        return 0.0\n    img = image.astype(float)\n    # Use only first three channels if extras exist\n    r = img[:, :, 0]\n    g = img[:, :, 1]\n    b = img[:, :, 2]\n    rg = r - g\n    yb = 0.5 * (r + g) - b\n    std_rg = np.std(rg)\n    std_yb = np.std(yb)\n    mean_rg = np.mean(rg)\n    mean_yb = np.mean(yb)\n    # Hasler and S\u00fcsstrunk colorfulness measure\n    colorfulness = np.sqrt(std_rg * std_rg + std_yb * std_yb) + 0.3 * np.sqrt(mean_rg * mean_rg + mean_yb * mean_yb)\n    if not np.isfinite(colorfulness):\n        return 0.0\n    return float(colorfulness)\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Normalized difference between mean intensity of top and bottom quarters'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 2 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    q = max(1, h // 4)\n    top_mean = np.mean(gray[:q, :]) if gray[:q, :].size else 0.0\n    bot_mean = np.mean(gray[-q:, :]) if gray[-q:, :].size else 0.0\n    denom = np.mean(gray) + 1e-8\n    return float((top_mean - bot_mean) / denom)\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Normalized vertical centroid of the main mask (0=top,1=bottom), 0.5 if undefined'\n    import numpy as np\n    if image is None:\n        return 0.5\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.5\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = gray < thr if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else gray > thr\n    ys, xs = np.where(mask)\n    if ys.size == 0:\n        return 0.5\n    centroid_y = float(np.mean(ys)) / float(h)\n    return float(np.clip(centroid_y, 0.0, 1.0))\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Number of contiguous mask segments in the central column strip (captures separated parts)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    c0 = max(0, w // 2 - max(1, w // 20))\n    c1 = min(w, w // 2 + max(1, w // 20))\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    col = np.any(mask[:, c0:c1], axis=1).astype(np.uint8)\n    if col.size == 0:\n        return 0.0\n    # count rising edges (0->1) to get number of segments\n    diffs = np.diff(np.concatenate(([0], col, [0])))\n    segments = np.sum(diffs == 1)\n    return float(segments)\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Fraction of mask pixels that touch the image border (0..1)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    total = np.count_nonzero(mask)\n    if total == 0:\n        return 0.0\n    # border pixels: top row, bottom row, left col, right col (avoid double counting corners by boolean OR)\n    border_mask = np.zeros_like(mask, dtype=bool)\n    border_mask[0, :] = mask[0, :]\n    border_mask[-1, :] = mask[-1, :]\n    border_mask[:, 0] = border_mask[:, 0] | mask[:, 0]\n    border_mask[:, -1] = border_mask[:, -1] | mask[:, -1]\n    border_count = np.count_nonzero(border_mask)\n    return float(border_count) / float(total)\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Mean saturation (approx) for RGB: (max-min)/max per pixel, 0 for grayscale'\n    import numpy as np\n    if image is None:\n        return 0.0\n    if len(image.shape) != 3 or image.shape[2] < 3:\n        return 0.0\n    img = image.astype(float)\n    r = img[:, :, 0]\n    g = img[:, :, 1]\n    b = img[:, :, 2]\n    mx = np.maximum(np.maximum(r, g), b)\n    mn = np.minimum(np.minimum(r, g), b)\n    # saturation approximately (max-min)/ (max + eps)\n    sat = (mx - mn) / (mx + 1e-8)\n    sat = np.clip(sat, 0.0, 1.0)\n    return float(np.mean(sat))\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Ratio of mask area in top half to bottom half (top_area / (bottom_area+eps))'\n    import numpy as np\n    if image is None:\n        return 1.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 1.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    half = h // 2\n    top_area = float(np.count_nonzero(mask[:half, :]))\n    bot_area = float(np.count_nonzero(mask[half:, :]))\n    return float(top_area / (bot_area + 1e-8))\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Entropy of edge orientation distribution (weighted by magnitude), normalized to [0,1]'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 2 or w < 2:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    gy, gx = np.gradient(gray)\n    mag = np.sqrt(gx * gx + gy * gy)\n    if np.sum(mag) == 0:\n        return 0.0\n    angles = np.arctan2(gy, gx)  # -pi..pi\n    # map to 8 bins\n    nbins = 8\n    bins = np.linspace(-np.pi, np.pi, nbins + 1)\n    hist = np.zeros(nbins, dtype=float)\n    flat_angles = angles.flatten()\n    flat_mag = mag.flatten()\n    inds = np.digitize(flat_angles, bins) - 1\n    inds = np.clip(inds, 0, nbins - 1)\n    for i in range(nbins):\n        hist[i] = np.sum(flat_mag[inds == i])\n    hist_sum = np.sum(hist)\n    if hist_sum <= 0:\n        return 0.0\n    p = hist / hist_sum\n    # entropy\n    eps = 1e-12\n    ent = -np.sum(np.where(p > 0, p * np.log(p + eps), 0.0))\n    # normalize by log(nbins)\n    ent_norm = ent / (np.log(nbins) + 1e-12)\n    return float(ent_norm)\n", "def feature(image: np.ndarray) -> float:\n    'Mean left-right symmetry of the image (0 = identical, larger = more asymmetric)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    # grayscale\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    # normalize\n    mx = np.max(gray) if gray.size else 0.0\n    if mx > 0:\n        gray = gray / mx\n    mid = w // 2\n    left = gray[:, :mid]\n    right = gray[:, w - mid:]\n    # mirror right to align with left\n    right_mirror = np.fliplr(right)\n    # resize to same if odd width\n    if left.shape[1] != right_mirror.shape[1]:\n        m = min(left.shape[1], right_mirror.shape[1])\n        left = left[:, :m]\n        right_mirror = right_mirror[:, :m]\n    if left.size == 0:\n        return 0.0\n    diff = np.abs(left - right_mirror)\n    score = np.mean(diff)\n    return float(score)\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Fraction of the foreground mask pixels located in the bottom 15% of the image (shoe indicator)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 60)\n    mask = gray < thr if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else gray > thr\n    total = np.count_nonzero(mask)\n    if total == 0:\n        return 0.0\n    bottom_h = max(1, h * 15 // 100)\n    bottom_mask = mask[-bottom_h:, :]\n    bottom_count = np.count_nonzero(bottom_mask)\n    return float(bottom_count / float(total))\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Number of connected components in binary mask (4-neighbor), normalized by image height'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    visited = np.zeros_like(mask, dtype=bool)\n    comps = 0\n    # iterate\n    for yi in range(h):\n        row = mask[yi]\n        for xi in range(w):\n            if row[xi] and not visited[yi, xi]:\n                comps += 1\n                # flood fill stack\n                stack = [(yi, xi)]\n                visited[yi, xi] = True\n                while stack:\n                    y, x = stack.pop()\n                    # 4-neighbors\n                    if y > 0 and mask[y - 1, x] and not visited[y - 1, x]:\n                        visited[y - 1, x] = True\n                        stack.append((y - 1, x))\n                    if y + 1 < h and mask[y + 1, x] and not visited[y + 1, x]:\n                        visited[y + 1, x] = True\n                        stack.append((y + 1, x))\n                    if x > 0 and mask[y, x - 1] and not visited[y, x - 1]:\n                        visited[y, x - 1] = True\n                        stack.append((y, x - 1))\n                    if x + 1 < w and mask[y, x + 1] and not visited[y, x + 1]:\n                        visited[y, x + 1] = True\n                        stack.append((y, x + 1))\n    return float(comps / max(1.0, float(h)))\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Average per-pixel saturation (HSV-like) across image (0..1), 0 for grayscale uniform'\n    import numpy as np\n    if image is None:\n        return 0.0\n    if len(image.shape) != 3:\n        return 0.0\n    arr = image.astype(float)\n    h, w, c = arr.shape\n    if c < 3 or h == 0 or w == 0:\n        return 0.0\n    r = arr[:, :, 0]\n    g = arr[:, :, 1]\n    b = arr[:, :, 2]\n    mx = np.maximum(np.maximum(r, g), b)\n    mn = np.minimum(np.minimum(r, g), b)\n    diff = mx - mn\n    # saturation definition relative to max (avoid division by zero)\n    sat = diff / (mx + 1e-8)\n    # mask invalid where mx is zero -> sat ~ 0\n    sat = np.clip(sat, 0.0, 1.0)\n    return float(np.mean(sat))\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Perimeter-to-area ratio of the binary mask (higher = more edge/complex shape)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    area = float(np.count_nonzero(mask))\n    if area == 0.0:\n        return 0.0\n    # boundary pixels where a neighbor is background\n    up = np.zeros_like(mask); up[1:, :] = mask[:-1, :]\n    down = np.zeros_like(mask); down[:-1, :] = mask[1:, :]\n    left = np.zeros_like(mask); left[:, 1:] = mask[:, :-1]\n    right = np.zeros_like(mask); right[:, :-1] = mask[:, 1:]\n    edge = mask & (~up | ~down | ~left | ~right)\n    perimeter = float(np.count_nonzero(edge))\n    return float(perimeter / (area + 1e-8))\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Ratio of mean mask width in bottom quarter to mean mask width in top quarter (clothing part indicator)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 4 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    top_end = max(1, h // 4)\n    bot_start = max(0, h - max(1, h // 4))\n    top_rows = mask[:top_end, :]\n    bot_rows = mask[bot_start:, :]\n    def mean_width(region):\n        if region.size == 0:\n            return 0.0\n        widths = np.count_nonzero(region, axis=1).astype(float) / max(1.0, w)\n        if widths.size == 0:\n            return 0.0\n        return float(np.mean(widths))\n    top_w = mean_width(top_rows)\n    bot_w = mean_width(bot_rows)\n    return float(bot_w / (top_w + 1e-8))\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Vertical spread of the mask: standard deviation of mask row indices normalized by image height'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = gray < thr if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else gray > thr\n    ys, xs = np.where(mask)\n    if ys.size == 0:\n        return 0.0\n    std_y = float(np.std(ys.astype(float)))\n    return float(std_y / max(1.0, float(h)))\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Bounding box width divided by height (aspect ratio), larger => wider objects like bags'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    ys, xs = np.where(mask)\n    if ys.size == 0:\n        return 0.0\n    miny, maxy = ys.min(), ys.max()\n    minx, maxx = xs.min(), xs.max()\n    bbox_h = float(maxy - miny + 1)\n    bbox_w = float(maxx - minx + 1)\n    if bbox_h <= 0:\n        return 0.0\n    return float(bbox_w / bbox_h)\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Number of holes in the mask (background components fully enclosed) normalized by mask area'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = gray < thr if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else gray > thr\n    area = np.count_nonzero(mask)\n    if area == 0:\n        return 0.0\n    ys, xs = np.where(mask)\n    miny, maxy = ys.min(), ys.max()\n    minx, maxx = xs.min(), xs.max()\n    # extract bbox and inverted (background) inside bbox\n    sub = mask[miny:maxy + 1, minx:maxx + 1]\n    inv = ~sub\n    sh, sw = inv.shape\n    # flood fill background components in inv; mark those touching border\n    visited = np.zeros_like(inv, dtype=bool)\n    holes = 0\n    for yi in range(sh):\n        for xi in range(sw):\n            if inv[yi, xi] and not visited[yi, xi]:\n                # new component\n                stack = [(yi, xi)]\n                visited[yi, xi] = True\n                touches_border = False\n                comp_size = 0\n                while stack:\n                    y, x = stack.pop()\n                    comp_size += 1\n                    if y == 0 or y == sh - 1 or x == 0 or x == sw - 1:\n                        touches_border = True\n                    # neighbors\n                    if y > 0 and inv[y - 1, x] and not visited[y - 1, x]:\n                        visited[y - 1, x] = True\n                        stack.append((y - 1, x))\n                    if y + 1 < sh and inv[y + 1, x] and not visited[y + 1, x]:\n                        visited[y + 1, x] = True\n                        stack.append((y + 1, x))\n                    if x > 0 and inv[y, x - 1] and not visited[y, x - 1]:\n                        visited[y, x - 1] = True\n                        stack.append((y, x - 1))\n                    if x + 1 < sw and inv[y, x + 1] and not visited[y, x + 1]:\n                        visited[y, x + 1] = True\n                        stack.append((y, x + 1))\n                if not touches_border and comp_size > 0:\n                    holes += 1\n    return float(holes / (area + 1e-8))\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Number of horizontal peaks in the column-sum projection of the mask, normalized by image width'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    col_sum = np.count_nonzero(mask, axis=0).astype(float)\n    if col_sum.size == 0:\n        return 0.0\n    # smooth a little with 3-wide median to reduce noise\n    padded = np.pad(col_sum, (1, 1), mode='edge')\n    smooth = (padded[:-2] + padded[1:-1] + padded[2:]) / 3.0\n    # find local maxima\n    diffs = np.diff(smooth)\n    signs = np.sign(diffs)\n    # count sign changes from positive to negative => peak\n    peaks = 0\n    for i in range(1, signs.size):\n        if signs[i - 1] > 0 and signs[i] < 0:\n            peaks += 1\n    return float(peaks / max(1.0, float(w)))\n", "def feature(image: np.ndarray) -> float:\n    'Left-right symmetry of the foreground mask (Jaccard overlap with horizontal flip)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    # grayscale conversion\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 50)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    if not np.any(mask):\n        return 0.0\n    flipped = np.fliplr(mask)\n    inter = np.count_nonzero(mask & flipped)\n    union = np.count_nonzero(mask | flipped)\n    if union == 0:\n        return 0.0\n    return float(inter / union)\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Bounding-box aspect ratio (height divided by width) of the detected foreground'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 60)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    if not np.any(mask):\n        return 0.0\n    ys, xs = np.where(mask)\n    miny, maxy = ys.min(), ys.max()\n    minx, maxx = xs.min(), xs.max()\n    bbox_h = float(maxy - miny + 1)\n    bbox_w = float(maxx - minx + 1)\n    if bbox_w <= 1e-8:\n        return float(bbox_h / (bbox_w + 1e-8))\n    return float(bbox_h / bbox_w)\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Horizontal centroid variation across rows: std of per-row x-centroids normalized by image width'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h <= 1 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    xs = np.arange(w).astype(float)\n    centroids = []\n    for r in range(h):\n        row = mask[r, :]\n        total = np.sum(row)\n        if total > 0:\n            centroids.append(float(np.sum(xs * row) / total))\n    if len(centroids) == 0:\n        return 0.0\n    centroids = np.array(centroids)\n    std_cent = float(np.std(centroids))\n    return float(std_cent / (w + 1e-8))\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Center versus border texture contrast: ratio of mean gradient magnitude in center to border'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 4 or w < 4:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    # normalize\n    mx = np.max(gray)\n    if mx > 0:\n        gray = gray / mx\n    gy, gx = np.gradient(gray)\n    grad = np.sqrt(gx * gx + gy * gy)\n    ch, cw = h // 4, w // 4\n    center = grad[ch:3*ch, cw:3*cw]\n    # border = full minus a slightly smaller inside region\n    border_mask = np.ones_like(grad, dtype=bool)\n    border_mask[ch:3*ch, cw:3*cw] = False\n    border = grad[border_mask]\n    if center.size == 0 or border.size == 0:\n        return 0.0\n    mean_center = float(np.mean(center))\n    mean_border = float(np.mean(border))\n    return float((mean_center + 1e-8) / (mean_border + 1e-8))\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Fraction of foreground mass located in the lower third of the image'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 3 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 50)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    total = float(np.count_nonzero(mask))\n    if total <= 0.0:\n        return 0.0\n    lower_start = (2 * h) // 3\n    lower_mass = float(np.count_nonzero(mask[lower_start:, :]))\n    return float(lower_mass / total)\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Count of prominent vertical peaks in horizontal projection (useful for leg separation) as a float'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    col_sums = np.sum(mask.astype(float), axis=0)\n    if np.max(col_sums) <= 0:\n        return 0.0\n    peak_thr = 0.25 * np.max(col_sums)\n    peaks = col_sums > peak_thr\n    # count rising edges = number of contiguous peak runs\n    if not np.any(peaks):\n        return 0.0\n    diffs = np.diff(peaks.astype(int))\n    rising = np.count_nonzero(diffs == 1)\n    # if first column starts with a peak, include it\n    if peaks[0]:\n        rising += 1\n    return float(rising)\n\n\n", "def feature(image: np.ndarray) -> float:\n    'High-frequency energy ratio: fraction of gradient energy above median level'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 2 or w < 2:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    gy, gx = np.gradient(gray)\n    grad_sq = gx * gx + gy * gy\n    median = np.median(grad_sq)\n    total = np.sum(grad_sq)\n    if total <= 0:\n        return 0.0\n    high_energy = np.sum(grad_sq[grad_sq > median])\n    return float(high_energy / (total + 1e-12))\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Normalized mean vertical-edge fraction inside detected foreground (vertical vs total gradient inside mask)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 2 or w < 2:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    if not np.any(mask):\n        return 0.0\n    gy, gx = np.gradient(gray)\n    vert = np.abs(gy)\n    horz = np.abs(gx)\n    vert_sum = float(np.sum(vert[mask]))\n    horz_sum = float(np.sum(horz[mask]))\n    total = vert_sum + horz_sum\n    if total <= 0:\n        return 0.0\n    return float(vert_sum / (total + 1e-12))\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Inter-channel mean difference normalized: std of channel means divided by their mean (0 for grayscale)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    if len(image.shape) != 3 or image.shape[2] != 3:\n        return 0.0\n    img = image.astype(float)\n    r_mean = float(np.mean(img[:, :, 0]))\n    g_mean = float(np.mean(img[:, :, 1]))\n    b_mean = float(np.mean(img[:, :, 2]))\n    means = np.array([r_mean, g_mean, b_mean])\n    mean_of_means = float(np.mean(means))\n    if mean_of_means <= 0:\n        return 0.0\n    std_means = float(np.std(means))\n    return float(std_means / (mean_of_means + 1e-12))\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Top-heaviness index: 1.0 if mass concentrated at top, 0.0 if at bottom (based on mask centroid)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 50)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    ys, xs = np.where(mask)\n    if ys.size == 0:\n        return 0.0\n    center_y = float(np.mean(ys))\n    # top-heavy => center_y small => index close to 1\n    idx = 1.0 - (center_y / float(max(1, h - 1)))\n    return float(idx)\n", "def feature(image: np.ndarray) -> float:\n    'Normalized vertical centroid of the main mask (0 = top, 1 = bottom)'\n    import numpy as np\n    if image is None:\n        return 0.5\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.5\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    ys, xs = np.where(mask)\n    if ys.size == 0:\n        return 0.5\n    cy = float(np.mean(ys))\n    return float(cy / float(h + 1e-8))\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Fraction of mask pixels located in the bottom third of the image'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = gray < thr if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else gray > thr\n    total = np.count_nonzero(mask)\n    if total == 0:\n        return 0.0\n    start = (2 * h) // 3\n    bottom_count = int(np.count_nonzero(mask[start:h, :]))\n    return float(bottom_count) / float(total)\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Mask area divided by its bounding-box area (fill ratio 0..1)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    ys, xs = np.where(mask)\n    if ys.size == 0:\n        return 0.0\n    miny, maxy = ys.min(), ys.max()\n    minx, maxx = xs.min(), xs.max()\n    bbox_area = float((maxy - miny + 1) * (maxx - minx + 1))\n    mask_area = float(ys.size)\n    if bbox_area <= 0:\n        return 0.0\n    return float(np.clip(mask_area / (bbox_area + 1e-8), 0.0, 1.0))\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Perimeter-to-area ratio of the mask (higher => more complex/elongated boundary)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 2 or w < 2:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = gray < thr if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else gray > thr\n    area = float(np.count_nonzero(mask))\n    if area <= 0:\n        return 0.0\n    # erosion via neighbor AND (same as other features)\n    eroded = mask.copy()\n    for dr in (-1, 0, 1):\n        for dc in (-1, 0, 1):\n            if dr == 0 and dc == 0:\n                continue\n            rolled = np.roll(mask, shift=(dr, dc), axis=(0, 1))\n            if dr == -1:\n                rolled[-1, :] = False\n            if dr == 1:\n                rolled[0, :] = False\n            if dc == -1:\n                rolled[:, -1] = False\n            if dc == 1:\n                rolled[:, 0] = False\n            eroded &= rolled\n    boundary = mask & (~eroded)\n    perim = float(np.count_nonzero(boundary))\n    return float(perim / (area + 1e-8))\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Horizontal (left-right) symmetry score normalized by image mean (0 = identical)'\n    import numpy as np\n    if image is None:\n        return 1.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 1.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    mid = w // 2\n    left = gray[:, :mid]\n    right = gray[:, w - mid:w]\n    if left.size == 0 or right.size == 0:\n        return 1.0\n    right_flipped = np.fliplr(right)\n    if left.shape != right_flipped.shape:\n        mnw = min(left.shape[1], right_flipped.shape[1])\n        left = left[:, :mnw]\n        right_flipped = right_flipped[:, :mnw]\n    diff = np.abs(left - right_flipped)\n    denom = np.maximum(np.mean(gray) + 1e-8, 1e-8)\n    return float(np.mean(diff) / denom)\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Mean Euclidean distance of mask pixels to their centroid normalized by image diagonal'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = gray < thr if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else gray > thr\n    ys, xs = np.where(mask)\n    if ys.size == 0:\n        return 0.0\n    cx = float(np.mean(xs))\n    cy = float(np.mean(ys))\n    d = np.sqrt((xs - cx) ** 2 + (ys - cy) ** 2)\n    mean_d = float(np.mean(d))\n    diag = np.sqrt(float(h * h + w * w))\n    return float(mean_d / (diag + 1e-8))\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Ratio of average mask width in top quarter to bottom quarter (sleeve vs pant indicator)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 4 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = gray < thr if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else gray > thr\n    top_end = max(1, h // 4)\n    bot_start = max(0, h - top_end)\n    top_rows = mask[:top_end, :]\n    bot_rows = mask[bot_start:h, :]\n    def avg_width(region):\n        if region.size == 0:\n            return 0.0\n        widths = np.count_nonzero(region, axis=1).astype(float)\n        if widths.size == 0:\n            return 0.0\n        return float(np.mean(widths)) / float(w + 1e-8)\n    top_w = avg_width(top_rows)\n    bot_w = avg_width(bot_rows)\n    return float(top_w / (bot_w + 1e-8))\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Edge orientation strength (0..1): how strongly edges align to a dominant orientation'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 2 or w < 2:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    gy, gx = np.gradient(gray)\n    grad = np.sqrt(gx * gx + gy * gy)\n    total = float(np.sum(grad))\n    if total <= 1e-8:\n        return 0.0\n    # angles and doubled-angle trick to capture orientation modulo 180 deg\n    theta = np.arctan2(gy, gx)\n    cos2 = np.cos(2.0 * theta)\n    sin2 = np.sin(2.0 * theta)\n    sx = float(np.sum(grad * cos2))\n    sy = float(np.sum(grad * sin2))\n    strength = np.sqrt(sx * sx + sy * sy) / (total + 1e-8)\n    return float(np.clip(strength, 0.0, 1.0))\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Ratio of mask area in left half to right half (1 = symmetric)'\n    import numpy as np\n    if image is None:\n        return 1.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 1.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    mid = w // 2\n    left_area = float(np.count_nonzero(mask[:, :mid]))\n    right_area = float(np.count_nonzero(mask[:, mid:]))\n    if right_area <= 0:\n        if left_area <= 0:\n            return 1.0\n        return float(left_area / (1e-8 + right_area))\n    return float(left_area / (right_area + 1e-8))\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Fraction of connected mask components that are small (<5% of total mask area)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    total_area = int(np.count_nonzero(mask))\n    if total_area == 0:\n        return 0.0\n    visited = np.zeros_like(mask, dtype=bool)\n    comps = 0\n    small = 0\n    thresh = max(1, int(total_area * 0.05))\n    # simple flood fill\n    for y in range(h):\n        for x in range(w):\n            if mask[y, x] and not visited[y, x]:\n                comps += 1\n                stack = [(y, x)]\n                visited[y, x] = True\n                comp_area = 0\n                while stack:\n                    cy, cx = stack.pop()\n                    comp_area += 1\n                    # 4-neighbors\n                    if cy > 0 and mask[cy - 1, cx] and not visited[cy - 1, cx]:\n                        visited[cy - 1, cx] = True\n                        stack.append((cy - 1, cx))\n                    if cy + 1 < h and mask[cy + 1, cx] and not visited[cy + 1, cx]:\n                        visited[cy + 1, cx] = True\n                        stack.append((cy + 1, cx))\n                    if cx > 0 and mask[cy, cx - 1] and not visited[cy, cx - 1]:\n                        visited[cy, cx - 1] = True\n                        stack.append((cy, cx - 1))\n                    if cx + 1 < w and mask[cy, cx + 1] and not visited[cy, cx + 1]:\n                        visited[cy, cx + 1] = True\n                        stack.append((cy, cx + 1))\n                if comp_area <= thresh:\n                    small += 1\n    if comps == 0:\n        return 0.0\n    return float(small) / float(comps)\n", "def feature(image: np.ndarray) -> float:\n    'Fraction of image pixels belonging to the main object mask (area fraction)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    # grayscale conversion\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    area = float(np.count_nonzero(mask))\n    return float(area / (h * w + 1e-8))\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Ratio of mean object width in top half to mean width in bottom half'\n    import numpy as np\n    if image is None:\n        return 1.0\n    h, w = image.shape[:2]\n    if h < 2 or w == 0:\n        return 1.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = gray < thr if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else gray > thr\n    top = mask[:h//2, :]\n    bot = mask[h//2:, :]\n    def mean_row_width(region):\n        if region.size == 0:\n            return 0.0\n        widths = np.count_nonzero(region, axis=1).astype(float)\n        if widths.size == 0:\n            return 0.0\n        return float(np.mean(widths)) / float(w)\n    top_w = mean_row_width(top)\n    bot_w = mean_row_width(bot)\n    return float(top_w / (bot_w + 1e-8))\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Vertical symmetry score: mean abs difference between top and vertically flipped bottom (normalized)'\n    import numpy as np\n    if image is None:\n        return 1.0\n    h, w = image.shape[:2]\n    if h < 2 or w == 0:\n        return 1.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    mid = h // 2\n    top = gray[:mid, :]\n    bot = gray[h - mid:, :]\n    if top.size == 0 or bot.size == 0:\n        return 1.0\n    bot_flipped = np.flipud(bot)\n    if top.shape != bot_flipped.shape:\n        mh = min(top.shape[0], bot_flipped.shape[0])\n        top = top[:mh, :]\n        bot_flipped = bot_flipped[:mh, :]\n    diff = np.abs(top - bot_flipped)\n    denom = np.maximum(np.mean(gray) + 1e-8, 1e-8)\n    return float(np.mean(diff) / denom)\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Normalized contrast between object interior and background (mask contrast)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    inside = gray[mask]\n    outside = gray[~mask]\n    if inside.size == 0 or outside.size == 0:\n        return 0.0\n    contrast = np.abs(np.mean(outside) - np.mean(inside))\n    denom = np.maximum(np.mean(gray) + 1e-8, 1e-8)\n    return float(contrast / denom)\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Count of distinct vertical blobs (contiguous column groups above threshold)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    # column sums of mask\n    thr = np.percentile(gray, 55)\n    mask = gray < thr if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else gray > thr\n    col_sums = np.sum(mask.astype(int), axis=0).astype(float)\n    if col_sums.size == 0:\n        return 0.0\n    # threshold columns by a fraction of max to get prominent columns\n    maxv = np.max(col_sums)\n    if maxv <= 0:\n        return 0.0\n    strong = col_sums > (0.25 * maxv)\n    # count contiguous True groups\n    # pad to catch edges\n    padded = np.concatenate([[0], strong.astype(int), [0]])\n    diffs = np.diff(padded)\n    starts = np.where(diffs == 1)[0]\n    ends = np.where(diffs == -1)[0]\n    count = max(0, len(starts))\n    return float(count)\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Normalized position of the first object pixel from top (how high object starts)'\n    import numpy as np\n    if image is None:\n        return 1.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 1.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    ys = np.where(np.any(mask, axis=1))[0]\n    if ys.size == 0:\n        return 1.0\n    first = float(ys[0]) / float(h)\n    return float(np.clip(first, 0.0, 1.0))\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Compactness (4*pi*area / perimeter^2) of the mask, higher is more compact'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    area = float(np.count_nonzero(mask))\n    if area == 0.0:\n        return 0.0\n    # estimate perimeter by counting boundary pixels (4-neighbor)\n    pad = np.pad(mask.astype(np.uint8), ((1, 1), (1, 1)), mode='constant', constant_values=0)\n    center = pad[1:-1, 1:-1].astype(bool)\n    up = pad[:-2, 1:-1].astype(bool)\n    down = pad[2:, 1:-1].astype(bool)\n    left = pad[1:-1, :-2].astype(bool)\n    right = pad[1:-1, 2:].astype(bool)\n    neighbor_sum = up + down + left + right\n    boundary = center & (neighbor_sum < 4)\n    perimeter = float(np.count_nonzero(boundary))\n    if perimeter <= 1e-8:\n        return 0.0\n    compact = (4.0 * np.pi * area) / (perimeter * perimeter + 1e-8)\n    return float(compact)\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Density of mask pixels in the central box (central 50% region)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 2 or w < 2:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = gray < thr if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else gray > thr\n    r0, r1 = h // 4, h - h // 4\n    c0, c1 = w // 4, w - w // 4\n    center_region = mask[r0:r1, c0:c1]\n    if center_region.size == 0:\n        return 0.0\n    density = float(np.count_nonzero(center_region)) / float(center_region.size)\n    return float(density)\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Inter-channel mean difference magnitude (RGB colorfulness proxy), 0 for grayscale'\n    import numpy as np\n    if image is None:\n        return 0.0\n    if len(image.shape) != 3 or image.shape[2] < 3:\n        return 0.0\n    # compute absolute differences between channel means\n    r_mean = float(np.mean(image[:, :, 0].astype(float)))\n    g_mean = float(np.mean(image[:, :, 1].astype(float)))\n    b_mean = float(np.mean(image[:, :, 2].astype(float)))\n    val = np.abs(r_mean - g_mean) + np.abs(r_mean - b_mean) + np.abs(g_mean - b_mean)\n    denom = max((r_mean + g_mean + b_mean) / 3.0, 1e-8)\n    return float(val / denom)\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Fraction of edge pixels whose gradient is more vertical than horizontal (orientation count)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 2 or w < 2:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    gy, gx = np.gradient(gray.astype(float))\n    grad_mag = np.sqrt(gx * gx + gy * gy)\n    strong = grad_mag > (np.percentile(grad_mag, 60) if np.any(grad_mag) else 0.0)\n    if not np.any(strong):\n        return 0.0\n    vert_dom = np.abs(gx) > np.abs(gy)\n    count = np.count_nonzero(strong & vert_dom)\n    total = np.count_nonzero(strong)\n    return float(count / (total + 1e-8))\n", "def feature(image: np.ndarray) -> float:\n    'Mask fill ratio: area of object mask divided by bounding box area'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    ys, xs = np.where(mask)\n    if ys.size == 0:\n        return 0.0\n    y0, y1 = ys.min(), ys.max()\n    x0, x1 = xs.min(), xs.max()\n    bbox_area = float((y1 - y0 + 1) * (x1 - x0 + 1))\n    if bbox_area <= 0:\n        return 0.0\n    mask_area = float(ys.size)\n    return float(mask_area / bbox_area)\n\n", "def feature(image: np.ndarray) -> float:\n    'Bounding-box height fraction: bounding box height relative to image height'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    ys = np.where(mask)[0]\n    if ys.size == 0:\n        return 0.0\n    bbox_h = float(ys.max() - ys.min() + 1)\n    return float(bbox_h / float(h))\n\n", "def feature(image: np.ndarray) -> float:\n    'Left-right mass balance: absolute normalized difference between left and right mask mass'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    mid = w // 2\n    left = np.count_nonzero(mask[:, :mid])\n    right = np.count_nonzero(mask[:, mid:])\n    total = left + right\n    if total == 0:\n        return 0.0\n    return float(abs(left - right) / float(total))\n\n", "def feature(image: np.ndarray) -> float:\n    'Vertical symmetry score (1.0 = perfectly symmetric, 0.0 = fully asymmetric) based on mask'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    # flip horizontally\n    flip = np.fliplr(mask)\n    # center alignment if odd width, compare overlapping region\n    min_w = min(mask.shape[1], flip.shape[1])\n    left = mask[:, :min_w]\n    right = flip[:, :min_w]\n    if left.size == 0:\n        return 0.0\n    diff = np.count_nonzero(left != right)\n    total = left.size\n    return float(1.0 - (diff / float(total)))\n\n", "def feature(image: np.ndarray) -> float:\n    'Perimeter-to-area ratio of mask using 4-neighborhood (higher => thinner/complex shape)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    area = np.count_nonzero(mask)\n    if area == 0:\n        return 0.0\n    # 4-neighbor shifts\n    up = np.roll(mask, -1, axis=0)\n    down = np.roll(mask, 1, axis=0)\n    left = np.roll(mask, -1, axis=1)\n    right = np.roll(mask, 1, axis=1)\n    # boundary handling: rolled pixels wrap; remove wrap effect by zeroing edges\n    up[-1, :] = False\n    down[0, :] = False\n    left[:, -1] = False\n    right[:, 0] = False\n    # perimeter pixels: mask pixel that has at least one neighbor False\n    neighbors_all = up & down & left & right\n    perimeter_pixels = np.count_nonzero(mask & (~neighbors_all))\n    return float(perimeter_pixels / float(area))\n\n", "def feature(image: np.ndarray) -> float:\n    'Vertical centroid position normalized (0.0 = top, 1.0 = bottom) of mask mass'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    ys, xs = np.where(mask)\n    if ys.size == 0:\n        return 0.0\n    yc = float(np.mean(ys))\n    return float(yc / float(h))\n\n", "def feature(image: np.ndarray) -> float:\n    'Average per-row transition count normalized by image width (complexity across rows)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w <= 1:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    # compute transitions per row\n    diffs = np.abs(np.diff(mask.astype(np.int8), axis=1))\n    transitions_per_row = np.sum(diffs, axis=1).astype(float)\n    # normalize by width\n    avg_trans = float(np.mean(transitions_per_row) / float(w))\n    return float(avg_trans)\n\n", "def feature(image: np.ndarray) -> float:\n    'Fraction of edge magnitude inside mask that is more vertical than horizontal (masked orientation)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 2 or w < 2:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    gy, gx = np.gradient(gray.astype(float))\n    mag = np.sqrt(gx * gx + gy * gy)\n    # restrict to mask and to reasonably strong edges\n    mag_masked = mag * mask\n    if np.sum(mag_masked) <= 0:\n        return 0.0\n    vert_dom = np.abs(gx) > np.abs(gy)\n    vert_mag = np.sum(mag_masked * vert_dom)\n    total_mag = np.sum(mag_masked)\n    return float(vert_mag / (total_mag + 1e-12))\n\n", "def feature(image: np.ndarray) -> float:\n    'Mean chroma (max - min across RGB channels) normalized by image dynamic range (0 for grayscale)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    if len(image.shape) != 3 or image.shape[2] < 3:\n        return 0.0\n    img = image.astype(float)\n    maxc = np.max(img, axis=2)\n    minc = np.min(img, axis=2)\n    chroma = maxc - minc\n    mean_chroma = float(np.mean(chroma))\n    denom = float(np.maximum(1.0, np.max(img) - np.min(img)))\n    return float(mean_chroma / denom)\n\n", "def feature(image: np.ndarray) -> float:\n    'Compactness relative to a circle: mask area divided by area of circle with radius = mean distance to centroid'\n    import numpy as np, math\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    ys, xs = np.where(mask)\n    if ys.size == 0:\n        return 0.0\n    yc = float(np.mean(ys))\n    xc = float(np.mean(xs))\n    dists = np.sqrt((ys - yc) ** 2 + (xs - xc) ** 2)\n    mean_r = float(np.mean(dists))\n    if mean_r <= 1e-6:\n        return float(1.0)  # extremely compact (single point)\n    circle_area = math.pi * (mean_r ** 2)\n    area = float(ys.size)\n    return float(area / (circle_area + 1e-12))\n", "def feature(image: np.ndarray) -> float:\n    'Vertical symmetry similarity of the main object mask (1.0 = perfect symmetry)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 50)\n    mask = gray < thr if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else gray > thr\n    ys, xs = np.where(mask)\n    if ys.size == 0:\n        return 0.0\n    miny, maxy = ys.min(), ys.max()\n    minx, maxx = xs.min(), xs.max()\n    sub = mask[miny:maxy + 1, minx:maxx + 1]\n    sh, sw = sub.shape\n    if sw == 0:\n        return 0.0\n    mid = sw // 2\n    left = sub[:, :mid]\n    right = sub[:, sw - mid:] if mid > 0 else np.zeros_like(left)\n    if left.size == 0 or right.size == 0:\n        return 0.0\n    right_flipped = np.fliplr(right)\n    # pad smaller side if odd width\n    if left.shape != right_flipped.shape:\n        lw, rw = left.shape[1], right_flipped.shape[1]\n        if lw > rw:\n            pad = np.zeros((sh, lw - rw), dtype=left.dtype)\n            right_flipped = np.concatenate([pad, right_flipped], axis=1)\n        else:\n            pad = np.zeros((sh, rw - lw), dtype=left.dtype)\n            left = np.concatenate([pad, left], axis=1)\n    diff = np.sum(np.abs(left.astype(float) - right_flipped.astype(float)))\n    area = float(np.count_nonzero(sub))\n    if area <= 0:\n        return 0.0\n    frac_diff = diff / (area + 1e-8)\n    sim = 1.0 - min(1.0, frac_diff)\n    return float(sim)\n\n", "def feature(image: np.ndarray) -> float:\n    'Mask fill ratio: fraction of bounding-box area occupied by mask (0..1)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    ys, xs = np.where(mask)\n    if ys.size == 0:\n        return 0.0\n    miny, maxy = ys.min(), ys.max()\n    minx, maxx = xs.min(), xs.max()\n    bbox_area = float((maxy - miny + 1) * (maxx - minx + 1))\n    mask_area = float(np.count_nonzero(mask))\n    if bbox_area <= 0:\n        return 0.0\n    return float(mask_area / (bbox_area + 1e-8))\n\n", "def feature(image: np.ndarray) -> float:\n    'Median contiguous mask segment length per row normalized by image width'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 60)\n    mask = gray < thr if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else gray > thr\n    seg_lengths = []\n    for r in range(h):\n        row = mask[r]\n        idx = np.where(row)[0]\n        if idx.size == 0:\n            continue\n        splits = np.where(np.diff(idx) > 1)[0]\n        if splits.size == 0:\n            seg_lengths.append(float(idx.size))\n        else:\n            starts = np.concatenate(([idx[0]], idx[splits + 1]))\n            ends = np.concatenate((idx[splits], [idx[-1]]))\n            seg_lengths.extend((ends - starts + 1).astype(float).tolist())\n    if len(seg_lengths) == 0:\n        return 0.0\n    med = float(np.median(np.array(seg_lengths)))\n    return float(med / max(1.0, float(w)))\n\n", "def feature(image: np.ndarray) -> float:\n    'Fraction of mask pixels located in the bottom third of the image'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    total = np.count_nonzero(mask)\n    if total == 0:\n        return 0.0\n    start = (2 * h) // 3\n    bottom_mask = mask[start:, :]\n    bottom_count = np.count_nonzero(bottom_mask)\n    return float(bottom_count / (total + 1e-8))\n\n", "def feature(image: np.ndarray) -> float:\n    'Mean color saturation for RGB images (0..1), 0 for grayscale'\n    import numpy as np\n    if image is None:\n        return 0.0\n    if len(image.shape) != 3 or image.shape[2] < 3:\n        return 0.0\n    img = image.astype(float)\n    r, g, b = img[:, :, 0], img[:, :, 1], img[:, :, 2]\n    mx = np.maximum(np.maximum(r, g), b)\n    mn = np.minimum(np.minimum(r, g), b)\n    sat = (mx - mn) / (mx + 1e-8)\n    # clip to [0,1]\n    sat = np.clip(sat, 0.0, 1.0)\n    return float(np.mean(sat))\n\n", "def feature(image: np.ndarray) -> float:\n    'Boundary complexity: fraction of mask pixels that lie on a 4-neighborhood boundary'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 2 or w < 2:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = gray < thr if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else gray > thr\n    area = np.count_nonzero(mask)\n    if area == 0:\n        return 0.0\n    p = np.pad(mask, ((1, 1), (1, 1)), mode='constant', constant_values=False)\n    center = p[1:-1, 1:-1]\n    up = p[:-2, 1:-1]\n    down = p[2:, 1:-1]\n    left = p[1:-1, :-2]\n    right = p[1:-1, 2:]\n    interior = center & up & down & left & right\n    boundary = center & (~interior)\n    bcount = np.count_nonzero(boundary)\n    return float(bcount / float(area + 1e-8))\n\n", "def feature(image: np.ndarray) -> float:\n    'Normalized vertical separation between top-third and bottom-third mask centroids'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 3 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    top_end = max(1, h // 3)\n    bot_start = h - top_end\n    top_mask = mask[:top_end, :]\n    bot_mask = mask[bot_start:, :]\n    if np.count_nonzero(top_mask) == 0 or np.count_nonzero(bot_mask) == 0:\n        return 0.0\n    top_ys, _ = np.where(top_mask)\n    bot_ys, _ = np.where(bot_mask)\n    # top region y coordinates are relative; convert to image coordinates\n    top_centroid = (np.mean(top_ys) + 0.0)  # relative to top region\n    bot_centroid = (np.mean(bot_ys) + bot_start)\n    # normalize by image height\n    sep = (bot_centroid - top_centroid) / float(h + 1e-8)\n    return float(sep)\n\n", "def feature(image: np.ndarray) -> float:\n    'Mean gradient magnitude inside the object mask normalized by global mean gradient'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 2 or w < 2:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    gy, gx = np.gradient(gray.astype(float))\n    grad_mag = np.sqrt(gx * gx + gy * gy)\n    global_mean = float(np.mean(grad_mag))\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    if np.count_nonzero(mask) == 0:\n        return 0.0\n    inside_mean = float(np.mean(grad_mag[mask]))\n    denom = max(global_mean, 1e-8)\n    return float(inside_mean / denom)\n\n", "def feature(image: np.ndarray) -> float:\n    'Count of connected mask components (flood fill) normalized by image area'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    visited = np.zeros_like(mask, dtype=bool)\n    comps = 0\n    for y in range(h):\n        for x in range(w):\n            if mask[y, x] and not visited[y, x]:\n                comps += 1\n                # flood fill stack\n                stack = [(y, x)]\n                visited[y, x] = True\n                while stack:\n                    yy, xx = stack.pop()\n                    if yy > 0 and mask[yy - 1, xx] and not visited[yy - 1, xx]:\n                        visited[yy - 1, xx] = True\n                        stack.append((yy - 1, xx))\n                    if yy + 1 < h and mask[yy + 1, xx] and not visited[yy + 1, xx]:\n                        visited[yy + 1, xx] = True\n                        stack.append((yy + 1, xx))\n                    if xx > 0 and mask[yy, xx - 1] and not visited[yy, xx - 1]:\n                        visited[yy, xx - 1] = True\n                        stack.append((yy, xx - 1))\n                    if xx + 1 < w and mask[yy, xx + 1] and not visited[yy, xx + 1]:\n                        visited[yy, xx + 1] = True\n                        stack.append((yy, xx + 1))\n    area = float(h * w)\n    return float(comps / (area + 1e-8))\n\n", "def feature(image: np.ndarray) -> float:\n    'Fraction of strong Harris-like corner responses inside the mask'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 3 or w < 3:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    gy, gx = np.gradient(gray.astype(float))\n    Ix2 = gx * gx\n    Iy2 = gy * gy\n    Ixy = gx * gy\n    # local 3x3 sum via padding and slicing\n    pIx2 = np.pad(Ix2, 1, mode='constant', constant_values=0.0)\n    pIy2 = np.pad(Iy2, 1, mode='constant', constant_values=0.0)\n    pIxy = np.pad(Ixy, 1, mode='constant', constant_values=0.0)\n    def local_sum(p):\n        return (p[:-2, :-2] + p[:-2, 1:-1] + p[:-2, 2:] +\n                p[1:-1, :-2] + p[1:-1, 1:-1] + p[1:-1, 2:] +\n                p[2:, :-2] + p[2:, 1:-1] + p[2:, 2:])\n    Sxx = local_sum(pIx2)\n    Syy = local_sum(pIy2)\n    Sxy = local_sum(pIxy)\n    # Harris response\n    k = 0.04\n    det = (Sxx * Syy) - (Sxy * Sxy)\n    trace = (Sxx + Syy)\n    R = det - k * (trace * trace)\n    # threshold strong corners at 90th percentile of positive responses\n    posR = R.copy()\n    posR[posR < 0] = 0.0\n    if not np.any(posR):\n        return 0.0\n    thrR = np.percentile(posR, 90)\n    strong = posR > thrR\n    thr_mask = np.percentile(gray, 55)\n    mask = (gray < thr_mask) if np.count_nonzero(gray < thr_mask) >= np.count_nonzero(gray > thr_mask) else (gray > thr_mask)\n    inside_strong = np.count_nonzero(strong & mask)\n    mask_area = np.count_nonzero(mask)\n    if mask_area == 0:\n        return 0.0\n    return float(inside_strong / (mask_area + 1e-8))\n", "def feature(image: np.ndarray) -> float:\n    'Bounding-box area ratio: bbox area divided by image area (smaller for small objects)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    # grayscale conversion\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    ys, xs = np.where(mask)\n    if ys.size == 0:\n        return 0.0\n    ymin, ymax = int(np.min(ys)), int(np.max(ys))\n    xmin, xmax = int(np.min(xs)), int(np.max(xs))\n    bbox_area = float((ymax - ymin + 1) * (xmax - xmin + 1))\n    img_area = float(h * w)\n    return float(bbox_area / (img_area + 1e-8))\n\n", "def feature(image: np.ndarray) -> float:\n    'Top-to-bottom mask area ratio: fraction of mask pixels in top third vs bottom third'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 3 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    top_end = max(1, h // 3)\n    bot_start = max(0, h - h // 3)\n    top_area = float(np.count_nonzero(mask[:top_end, :]))\n    bot_area = float(np.count_nonzero(mask[bot_start:, :]))\n    if bot_area <= 0:\n        return float(top_area / (1e-8 + bot_area))\n    return float(top_area / (bot_area + 1e-8))\n\n", "def feature(image: np.ndarray) -> float:\n    'Left-right symmetry of the mask: 1.0 = perfectly symmetric, 0.0 = fully asymmetric'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    if not np.any(mask):\n        return 0.0\n    # mirror left onto right and compute normalized overlap\n    mid = w // 2\n    left = mask[:, :mid]\n    if w % 2 == 0:\n        right = mask[:, mid:][:, ::-1]\n    else:\n        right = mask[:, mid+1:][:, ::-1]\n    # align sizes\n    min_c = min(left.shape[1], right.shape[1])\n    left = left[:, :min_c]\n    right = right[:, :min_c]\n    if min_c == 0:\n        return 0.0\n    overlap = np.count_nonzero(left & right)\n    total = max(1, np.count_nonzero(left | right))\n    return float(overlap / float(total))\n\n", "def feature(image: np.ndarray) -> float:\n    'Count of holes inside the main bounding box (enclosed background components)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    ys, xs = np.where(mask)\n    if ys.size == 0:\n        return 0.0\n    ymin, ymax = int(np.min(ys)), int(np.max(ys))\n    xmin, xmax = int(np.min(xs)), int(np.max(xs))\n    crop = mask[ymin:ymax+1, xmin:xmax+1]\n    ch, cw = crop.shape\n    bg = ~crop\n    visited = np.zeros_like(bg, dtype=bool)\n    # flood fill from border background to mark exterior background\n    stack = []\n    for x in range(cw):\n        if bg[0, x] and not visited[0, x]:\n            stack.append((0, x)); visited[0, x] = True\n        if bg[ch-1, x] and not visited[ch-1, x]:\n            stack.append((ch-1, x)); visited[ch-1, x] = True\n    for y in range(ch):\n        if bg[y, 0] and not visited[y, 0]:\n            stack.append((y, 0)); visited[y, 0] = True\n        if bg[y, cw-1] and not visited[y, cw-1]:\n            stack.append((y, cw-1)); visited[y, cw-1] = True\n    while stack:\n        cy, cx = stack.pop()\n        for ny, nx in ((cy-1, cx), (cy+1, cx), (cy, cx-1), (cy, cx+1)):\n            if 0 <= ny < ch and 0 <= nx < cw and bg[ny, nx] and not visited[ny, nx]:\n                visited[ny, nx] = True\n                stack.append((ny, nx))\n    # remaining bg pixels that are not visited are holes\n    holes_mask = bg & (~visited)\n    if not np.any(holes_mask):\n        return 0.0\n    # count connected components among holes\n    visited_h = np.zeros_like(holes_mask, dtype=bool)\n    holes = 0\n    for y in range(ch):\n        for x in range(cw):\n            if holes_mask[y, x] and not visited_h[y, x]:\n                holes += 1\n                stack = [(y, x)]\n                visited_h[y, x] = True\n                while stack:\n                    cy, cx = stack.pop()\n                    for ny, nx in ((cy-1, cx), (cy+1, cx), (cy, cx-1), (cy, cx+1)):\n                        if 0 <= ny < ch and 0 <= nx < cw and holes_mask[ny, nx] and not visited_h[ny, nx]:\n                            visited_h[ny, nx] = True\n                            stack.append((ny, nx))\n    return float(holes)\n\n", "def feature(image: np.ndarray) -> float:\n    'Bounding-box aspect ratio (height / width) of the mask'\n    import numpy as np\n    if image is None:\n        return 1.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 1.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    ys, xs = np.where(mask)\n    if ys.size == 0:\n        return 1.0\n    ymin, ymax = int(np.min(ys)), int(np.max(ys))\n    xmin, xmax = int(np.min(xs)), int(np.max(xs))\n    bw = float(xmax - xmin + 1)\n    bh = float(ymax - ymin + 1)\n    if bw <= 0:\n        return 1.0\n    return float(bh / (bw + 1e-8))\n\n", "def feature(image: np.ndarray) -> float:\n    'Mask fill ratio: mask area divided by its bounding-box area (solidity approximation)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    area = float(np.count_nonzero(mask))\n    if area == 0.0:\n        return 0.0\n    ys, xs = np.where(mask)\n    ymin, ymax = int(np.min(ys)), int(np.max(ys))\n    xmin, xmax = int(np.min(xs)), int(np.max(xs))\n    bbox_area = float((ymax - ymin + 1) * (xmax - xmin + 1))\n    if bbox_area <= 0:\n        return 0.0\n    return float(area / (bbox_area + 1e-8))\n\n", "def feature(image: np.ndarray) -> float:\n    'Average vertical run length: mean of largest contiguous mask segment height per column (normalized by image height)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    max_runs = []\n    for x in range(w):\n        col = mask[:, x]\n        if not np.any(col):\n            max_runs.append(0.0)\n            continue\n        # compute lengths of contiguous True runs\n        diffs = np.diff(np.concatenate(([0], col.view(np.int8), [0])))\n        starts = np.where(diffs == 1)[0]\n        ends = np.where(diffs == -1)[0]\n        lengths = ends - starts\n        if lengths.size == 0:\n            max_runs.append(0.0)\n        else:\n            max_runs.append(float(np.max(lengths)))\n    if len(max_runs) == 0:\n        return 0.0\n    mean_run = float(np.mean(max_runs))\n    return float(mean_run / (h + 1e-8))\n\n", "def feature(image: np.ndarray) -> float:\n    'Gradient orientation entropy (0..1): how varied edge directions are inside the image'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 2 or w < 2:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    gy, gx = np.gradient(gray.astype(float))\n    mag = np.sqrt(gx * gx + gy * gy)\n    if not np.any(mag):\n        return 0.0\n    # take only reasonably strong gradients to focus on edges\n    thresh = np.percentile(mag, 60)\n    mask = mag > thresh\n    if not np.any(mask):\n        mask = mag > 0\n    angles = np.arctan2(gy[mask], gx[mask])\n    # map to [0, pi) because orientations symmetric\n    angles = np.mod(angles, np.pi)\n    bins = 8\n    hist, _ = np.histogram(angles, bins=bins, range=(0.0, np.pi))\n    hist = hist.astype(float)\n    s = np.sum(hist)\n    if s <= 0:\n        return 0.0\n    p = hist / s\n    p = np.where(p > 0, p, 1e-12)\n    ent = -np.sum(p * np.log(p))\n    max_ent = np.log(bins)\n    return float(ent / (max_ent + 1e-12))\n\n", "def feature(image: np.ndarray) -> float:\n    'Fraction of strong edges located in the bottom third of the image (boots concentrated bottom)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 3 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    gy, gx = np.gradient(gray.astype(float))\n    mag = np.sqrt(gx * gx + gy * gy)\n    if not np.any(mag):\n        return 0.0\n    thr = np.percentile(mag, 70)\n    strong = mag > thr\n    total = np.count_nonzero(strong)\n    if total == 0:\n        return 0.0\n    bottom_start = max(0, (2 * h) // 3)\n    bottom_count = np.count_nonzero(strong[bottom_start:, :])\n    return float(bottom_count / float(total + 1e-8))\n\n", "def feature(image: np.ndarray) -> float:\n    'Mean (blue - red) inside mask for RGB images, 0.0 for grayscale (color bias in foreground)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    if len(image.shape) != 3 or image.shape[2] < 3:\n        return 0.0\n    h, w, c = image.shape\n    if h == 0 or w == 0:\n        return 0.0\n    # convert to float and channels\n    img = image.astype(float)\n    blue = img[:, :, 2]\n    red = img[:, :, 0]\n    gray = np.mean(img, axis=2)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    if not np.any(mask):\n        return 0.0\n    diff = blue - red\n    mean_diff = float(np.mean(diff[mask]))\n    return float(mean_diff)\n", "def feature(image: np.ndarray) -> float:\n    'Vertical symmetry score (1.0 = perfectly symmetric)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    # grayscale conversion\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    mx = np.max(gray) if np.max(gray) > 0 else 1.0\n    gray = gray / mx\n    # simple foreground mask\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    ys, xs = np.where(mask)\n    if ys.size == 0:\n        return 0.0\n    miny, maxy = ys.min(), ys.max()\n    minx, maxx = xs.min(), xs.max()\n    crop = gray[miny:maxy+1, minx:maxx+1]\n    cw = crop.shape[1]\n    if cw <= 1:\n        return 0.0\n    # split crop into left and right halves and compare\n    mid = cw // 2\n    left = crop[:, :mid]\n    right = crop[:, -mid:] if mid > 0 else crop[:, :mid]\n    # flip right horizontally\n    right_flipped = np.fliplr(right)\n    # make sizes equal\n    minw = min(left.shape[1], right_flipped.shape[1])\n    if minw == 0:\n        return 0.0\n    left = left[:, :minw]\n    right_flipped = right_flipped[:, :minw]\n    diff = np.abs(left - right_flipped)\n    mean_diff = float(np.mean(diff))\n    sym = 1.0 - mean_diff\n    # clamp to [0,1]\n    if sym < 0.0:\n        sym = 0.0\n    if sym > 1.0:\n        sym = 1.0\n    return float(sym)\n\n", "def feature(image: np.ndarray) -> float:\n    'Ratio of average mask width at top 10% to middle 40-60% (top_width / mid_width)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 4 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    top_h = max(1, h * 10 // 100)\n    top_rows = mask[:top_h, :]\n    mid_start = max(0, h * 40 // 100)\n    mid_end = min(h, h * 60 // 100)\n    mid_rows = mask[mid_start:mid_end, :]\n    if top_rows.size == 0 or mid_rows.size == 0:\n        return 0.0\n    top_widths = np.sum(top_rows.astype(float), axis=1)\n    mid_widths = np.sum(mid_rows.astype(float), axis=1)\n    top_avg = float(np.mean(top_widths)) if top_widths.size > 0 else 0.0\n    mid_avg = float(np.mean(mid_widths)) if mid_widths.size > 0 else 0.0\n    if mid_avg <= 0:\n        return 0.0\n    return float((top_avg + 1e-8) / (mid_avg + 1e-8))\n\n", "def feature(image: np.ndarray) -> float:\n    'Std of per-row mask widths in bottom 25% normalized by image width'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 2 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    bottom_start = max(0, h - max(1, h * 25 // 100))\n    bottom = mask[bottom_start:, :]\n    if bottom.size == 0:\n        return 0.0\n    widths = np.sum(bottom.astype(float), axis=1)\n    if widths.size == 0:\n        return 0.0\n    std_width = float(np.std(widths))\n    return float(std_width / (w + 1e-8))\n\n", "def feature(image: np.ndarray) -> float:\n    'Mean color channel range (mean of per-pixel (max-min) across RGB channels), 0 if grayscale'\n    import numpy as np\n    if image is None:\n        return 0.0\n    if len(image.shape) != 3 or image.shape[2] < 3:\n        return 0.0\n    img = image.astype(float)\n    # per-pixel channel range\n    ch_max = np.max(img, axis=2)\n    ch_min = np.min(img, axis=2)\n    rng = ch_max - ch_min\n    mx = np.max(img)\n    denom = mx if mx > 0 else 1.0\n    mean_rng = float(np.mean(rng) / denom)\n    return float(mean_rng)\n\n", "def feature(image: np.ndarray) -> float:\n    'Laplacian variance (high => more high-frequency texture)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 2 or w < 2:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    # normalize to [0,1]\n    mx = np.max(gray)\n    if mx > 0:\n        gray = gray / mx\n    # discrete Laplacian via neighbors\n    lap = np.roll(gray, 1, axis=0) + np.roll(gray, -1, axis=0) + np.roll(gray, 1, axis=1) + np.roll(gray, -1, axis=1) - 4.0 * gray\n    var_lap = float(np.var(lap))\n    return float(var_lap)\n\n", "def feature(image: np.ndarray) -> float:\n    'Mask edge density: approximate perimeter (edge pixels) divided by mask area'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    mask_i = mask.astype(np.int32)\n    # horizontal transitions\n    dx = np.abs(np.diff(mask_i, axis=1))\n    dy = np.abs(np.diff(mask_i, axis=0))\n    edge_count = int(np.sum(dx) + np.sum(dy))\n    area = int(np.count_nonzero(mask_i))\n    if area == 0:\n        return 0.0\n    return float(edge_count / (area + 1e-8))\n\n", "def feature(image: np.ndarray) -> float:\n    'Normalized distance between upper-half and lower-half centroids (0..1)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 2 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    if not np.any(mask):\n        return 0.0\n    mid = h // 2\n    top_mask = mask[:mid, :]\n    bottom_mask = mask[mid:, :]\n    def centroid(m, offset_y=0):\n        ys, xs = np.where(m)\n        if ys.size == 0:\n            return None\n        return (np.mean(xs).item(), np.mean(ys).item() + offset_y)\n    ctop = centroid(top_mask, offset_y=0)\n    cbottom = centroid(bottom_mask, offset_y=mid)\n    if ctop is None or cbottom is None:\n        return 0.0\n    dx = ctop[0] - cbottom[0]\n    dy = ctop[1] - cbottom[1]\n    dist = np.sqrt(dx*dx + dy*dy)\n    return float(dist / (float(h) + 1e-8))\n\n", "def feature(image: np.ndarray) -> float:\n    'Count of internal vertical gaps inside object mask (empty horizontal bands within bbox)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 3 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    ys, xs = np.where(mask)\n    if ys.size == 0:\n        return 0.0\n    miny, maxy = ys.min(), ys.max()\n    band = mask[miny:maxy+1, :]\n    row_sums = np.sum(band.astype(int), axis=1)\n    zero_rows = (row_sums == 0)\n    # count contiguous zero segments longer than 1% of image height (but at least 1)\n    min_len = max(1, h // 100)\n    count = 0\n    i = 0\n    L = zero_rows.size\n    while i < L:\n        if zero_rows[i]:\n            j = i\n            while j < L and zero_rows[j]:\n                j += 1\n            if (j - i) >= min_len:\n                count += 1\n            i = j\n        else:\n            i += 1\n    return float(count)\n\n", "def feature(image: np.ndarray) -> float:\n    'Shape compactness: mask area divided by squared perimeter (higher => more compact)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    area = float(np.count_nonzero(mask))\n    if area == 0.0:\n        return 0.0\n    m = mask.astype(np.int32)\n    dx = np.abs(np.diff(m, axis=1))\n    dy = np.abs(np.diff(m, axis=0))\n    perimeter = float(np.sum(dx) + np.sum(dy))\n    compact = area / (perimeter * perimeter + 1e-8)\n    return float(compact)\n\n", "def feature(image: np.ndarray) -> float:\n    'Mean intensity contrast between foreground mask and background (abs difference, normalized)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    mx = np.max(gray)\n    if mx <= 0:\n        mx = 1.0\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    fg = gray[mask]\n    bg = gray[~mask]\n    if fg.size == 0 or bg.size == 0:\n        return 0.0\n    contrast = abs(float(np.mean(fg) - np.mean(bg))) / float(mx)\n    return float(contrast)\n", "def feature(image: np.ndarray) -> float:\n    'Normalized left-right asymmetry: mean absolute difference between image and its mirror'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    flipped = np.fliplr(gray)\n    diff = np.abs(gray - flipped)\n    denom = np.mean(np.abs(gray)) + 1e-8\n    return float(np.mean(diff) / denom)\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Top-minus-bottom foreground fraction based on simple threshold mask (positive => more top)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    area = np.count_nonzero(mask)\n    if area == 0:\n        return 0.0\n    top_area = np.count_nonzero(mask[:h//2, :])\n    bottom_area = np.count_nonzero(mask[h//2:, :])\n    top_frac = float(top_area) / (area + 1e-8)\n    bottom_frac = float(bottom_area) / (area + 1e-8)\n    return float(top_frac - bottom_frac)\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Ratio of mean mask width around 25% height to mean width around 75% height (width25 / width75)'\n    import numpy as np\n    if image is None:\n        return 1.0\n    h, w = image.shape[:2]\n    if h < 4 or w == 0:\n        return 1.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    def mean_width_at_row_fraction(frac):\n        row = int(np.clip(frac * h, 0, h-1))\n        window = max(1, h // 20)\n        rows = mask[max(0, row-window):min(h, row+window+1), :]\n        if rows.size == 0:\n            return 0.0\n        widths = np.sum(rows.astype(float), axis=1)\n        return float(np.mean(widths)) if widths.size > 0 else 0.0\n    w25 = mean_width_at_row_fraction(0.25)\n    w75 = mean_width_at_row_fraction(0.75)\n    return float((w25 + 1e-8) / (w75 + 1e-8))\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Number of connected components in binary mask (4-neighborhood), capped for performance'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    visited = np.zeros_like(mask, dtype=bool)\n    comps = 0\n    area = np.count_nonzero(mask)\n    if area == 0:\n        return 0.0\n    # cap: if too many pixels, limit complexity by sampling grid\n    cap_pixels = 20000\n    if area > cap_pixels:\n        # approximate by scanning a downsampled grid\n        stride = int(np.ceil(np.sqrt(area / cap_pixels)))\n    else:\n        stride = 1\n    for y in range(0, h, stride):\n        for x in range(0, w, stride):\n            if not visited[y, x] and mask[y, x]:\n                comps += 1\n                # flood fill stack\n                stack = [(y, x)]\n                while stack:\n                    cy, cx = stack.pop()\n                    if cy < 0 or cy >= h or cx < 0 or cx >= w:\n                        continue\n                    if visited[cy, cx] or not mask[cy, cx]:\n                        continue\n                    visited[cy, cx] = True\n                    # 4-neighbors\n                    stack.append((cy-1, cx))\n                    stack.append((cy+1, cx))\n                    stack.append((cy, cx-1))\n                    stack.append((cy, cx+1))\n    return float(comps)\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Fraction of high-gradient pixels in the bottom quarter (edge activity near feet/shoes)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 2 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    gy, gx = np.gradient(gray.astype(float))\n    grad = np.sqrt(gx*gx + gy*gy)\n    thresh = np.percentile(grad, 60) if np.any(grad) else 0.0\n    strong = grad > thresh\n    bottom = strong[3*h//4:, :]\n    denom = float(bottom.size) + 1e-8\n    return float(np.count_nonzero(bottom) / denom)\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Largest continuous vertical background gap in the upper center strip (normalized by height)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    c1 = w // 3\n    c2 = max(c1+1, 2*w // 3)\n    strip = mask[:int(h*0.45), c1:c2]\n    if strip.size == 0:\n        return 0.0\n    # background rows where strip row sum is small\n    row_sums = np.sum(strip.astype(int), axis=1)\n    width = strip.shape[1]\n    bg = row_sums <= max(1, width // 10)\n    # find max consecutive True in bg\n    max_gap = 0\n    cur = 0\n    for v in bg:\n        if v:\n            cur += 1\n            if cur > max_gap:\n                max_gap = cur\n        else:\n            cur = 0\n    return float(max_gap / float(h + 1e-8))\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Aspect ratio (width / height) of the mask bounding box (1.0 if undefined)'\n    import numpy as np\n    if image is None:\n        return 1.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 1.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    ys, xs = np.where(mask)\n    if ys.size == 0:\n        return 1.0\n    miny, maxy = int(np.min(ys)), int(np.max(ys))\n    minx, maxx = int(np.min(xs)), int(np.max(xs))\n    bbox_h = maxy - miny + 1\n    bbox_w = maxx - minx + 1\n    if bbox_h <= 0:\n        return 1.0\n    return float(bbox_w / float(bbox_h + 1e-8))\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Texture roughness inside mask: std of gradient magnitude normalized by mean'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 2 or w < 2:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    gy, gx = np.gradient(gray.astype(float))\n    grad = np.sqrt(gx*gx + gy*gy)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    if not np.any(mask):\n        return 0.0\n    vals = grad[mask]\n    meanv = float(np.mean(vals)) + 1e-8\n    stdv = float(np.std(vals))\n    return float(stdv / meanv)\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Normalized horizontal centroid offset: abs(cx - center_x) / width'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    ys, xs = np.where(mask)\n    if xs.size == 0:\n        return 0.0\n    cx = float(np.mean(xs))\n    return float(abs(cx - (w / 2.0)) / (w + 1e-8))\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Fraction of columns with deep top boundary dips (columns where top mask row >> mean top)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    top_rows = np.full((w,), h, dtype=int)\n    for col in range(w):\n        col_mask = mask[:, col]\n        ys = np.where(col_mask)[0]\n        if ys.size > 0:\n            top_rows[col] = int(ys[0])\n    if np.all(top_rows == h):\n        return 0.0\n    mean_top = float(np.mean(top_rows[top_rows < h])) if np.any(top_rows < h) else float(h)\n    threshold = mean_top + max(1, int(0.05 * h))\n    dips = np.count_nonzero(top_rows > threshold)\n    return float(dips / float(w + 1e-8))\n", "def feature(image: np.ndarray) -> float:\n    'Aspect ratio of the mask bounding box (width / height), 0 if no mask'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 50)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    ys, xs = np.where(mask)\n    if ys.size == 0:\n        return 0.0\n    bbox_w = float(xs.max() - xs.min() + 1)\n    bbox_h = float(ys.max() - ys.min() + 1)\n    if bbox_h <= 0:\n        return 0.0\n    return float(bbox_w / (bbox_h + 1e-8))\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Median number of vertical connected segments per column (approx. component count)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 2 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 50)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    counts = []\n    for c in range(w):\n        col = mask[:, c].astype(np.int8)\n        if np.all(col == 0):\n            continue\n        # count rising edges (0->1)\n        dif = np.diff(np.concatenate(([0], col)))\n        starts = np.count_nonzero(dif == 1)\n        counts.append(float(starts))\n    if len(counts) == 0:\n        return 0.0\n    med = float(np.median(np.array(counts)))\n    # normalize by possible maximum segments (h/2)\n    return float(med / max(1.0, float(h) / 2.0))\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Vertical mirror symmetry score based on grayscale cross-correlation (0..1)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w < 2:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    # use central 90% horizontally to avoid borders\n    margin = max(1, int(w * 0.05))\n    left = gray[:, margin:w//2]\n    right = gray[:, (w - margin - (w//2 - margin)):w - margin] if (w - margin - (w//2 - margin)) < w - margin else gray[:, w//2:w - margin]\n    # make shapes equal\n    min_cols = min(left.shape[1], right.shape[1])\n    if min_cols < 1:\n        return 0.0\n    left = left[:, :min_cols]\n    right = right[:, :min_cols]\n    right_flipped = np.fliplr(right)\n    # normalize and compute correlation\n    L = left.flatten()\n    R = right_flipped.flatten()\n    Lm = L - np.mean(L)\n    Rm = R - np.mean(R)\n    denom = (np.sqrt(np.sum(Lm * Lm)) * np.sqrt(np.sum(Rm * Rm)) + 1e-8)\n    corr = float(np.sum(Lm * Rm) / denom)\n    # map correlation to [0,1]\n    return float((corr + 1.0) / 2.0)\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Colorfulness metric (Has value 0 for grayscale images)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    if len(image.shape) != 3 or image.shape[2] < 3:\n        return 0.0\n    img = image.astype(float)\n    R = img[:, :, 0]\n    G = img[:, :, 1]\n    B = img[:, :, 2]\n    rg = R - G\n    yb = 0.5 * (R + G) - B\n    std_rg = float(np.std(rg))\n    std_yb = float(np.std(yb))\n    mean_rg = float(np.mean(rg))\n    mean_yb = float(np.mean(yb))\n    colorfulness = np.sqrt(std_rg * std_rg + std_yb * std_yb) + 0.3 * np.sqrt(mean_rg * mean_rg + mean_yb * mean_yb)\n    return float(colorfulness)\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Fraction of strong edges that are diagonal (near 45 degrees)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 2 or w < 2:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    gy, gx = np.gradient(gray.astype(float))\n    mag = np.sqrt(gx * gx + gy * gy)\n    if not np.any(mag):\n        return 0.0\n    thresh = np.percentile(mag, 70)\n    strong = mag > thresh\n    if not np.any(strong):\n        return 0.0\n    # diagonal if abs(|gx|-|gy|) small relative to max\n    diff = np.abs(np.abs(gx) - np.abs(gy))\n    denom = np.maximum(np.abs(gx) + np.abs(gy), 1e-8)\n    diag = (diff / denom) < 0.25\n    count_diag = np.count_nonzero(strong & diag)\n    total = np.count_nonzero(strong)\n    return float(count_diag / (total + 1e-8))\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Proportion of mask pixels located in the bottom 20% of the image'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 50)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    total = float(np.count_nonzero(mask))\n    if total <= 0:\n        return 0.0\n    bottom_start = max(0, int(h * 0.8))\n    bottom_mask = mask[bottom_start:, :]\n    bottom_count = float(np.count_nonzero(bottom_mask))\n    return float(bottom_count / (total + 1e-8))\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Neckline notch depth: normalized drop at image center top vs shoulders (0..1)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 3 or w < 3:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = gray < thr if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else gray > thr\n    top_idx = np.full((w,), float(h - 1), dtype=float)\n    any_in_col = np.any(mask, axis=0)\n    if not np.any(any_in_col):\n        return 0.0\n    cols = np.where(any_in_col)[0]\n    for c in cols:\n        col = mask[:, c]\n        top_idx[c] = float(np.argmax(col))\n    center = w // 2\n    quarter = max(1, w // 8)\n    center_min = float(np.min(top_idx[max(0, center - quarter):min(w, center + quarter + 1)]))\n    left_shoulder = float(np.mean(top_idx[:max(1, w // 4)]))\n    right_shoulder = float(np.mean(top_idx[max(0, 3 * w // 4):]))\n    shoulder_avg = float((left_shoulder + right_shoulder) / 2.0)\n    depth = shoulder_avg - center_min\n    if depth <= 0:\n        return 0.0\n    return float(min(1.0, depth / (max(1.0, float(h)) * 0.5)))\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Approximate solidity: mask area divided by per-row filled spans (1==solid)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 50)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    area = float(np.count_nonzero(mask))\n    if area <= 0:\n        return 0.0\n    filled = 0.0\n    for r in range(h):\n        row = mask[r, :]\n        if not np.any(row):\n            continue\n        xs = np.where(row)[0]\n        span = float(xs[-1] - xs[0] + 1)\n        filled += span\n    if filled <= 0:\n        return 0.0\n    solidity = float(area / (filled + 1e-8))\n    return float(solidity)\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Relative bottom-center concentration: density in bottom-center patch / overall bottom density'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 2 or w < 2:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 50)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    bottom_h = max(1, int(h * 0.2))\n    bottom = mask[h - bottom_h:, :]\n    if not np.any(bottom):\n        return 0.0\n    center_w = max(1, int(w * 0.3))\n    cx0 = max(0, (w // 2) - (center_w // 2))\n    cx1 = min(w, cx0 + center_w)\n    center_patch = bottom[:, cx0:cx1]\n    center_count = float(np.count_nonzero(center_patch))\n    bottom_count = float(np.count_nonzero(bottom))\n    if bottom_count <= 0:\n        return 0.0\n    return float((center_count / (center_patch.size + 1e-8)) / (bottom_count / (bottom.size + 1e-8)))\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Texture strength inside mask: std of gradient magnitude within mask normalized by mean'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 2 or w < 2:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    gy, gx = np.gradient(gray.astype(float))\n    grad_mag = np.sqrt(gx * gx + gy * gy)\n    thr = np.percentile(gray, 50)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    masked = grad_mag[mask]\n    if masked.size == 0:\n        return 0.0\n    std = float(np.std(masked))\n    mean = float(np.mean(masked))\n    return float(std / (mean + 1e-8))\n", "def feature(image: np.ndarray) -> float:\n    'Vertical symmetry score of the central object region (1.0 = perfect symmetry)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    mid = w // 2\n    if mid == 0:\n        return 0.0\n    # use central half area to avoid border noise\n    left = gray[:, max(0, w//4):max(0, w//4)+mid]\n    right = gray[:, w - (left.shape[1]):w]\n    if left.size == 0 or right.size == 0:\n        return 0.0\n    right_flipped = np.fliplr(right)\n    diff = np.mean(np.abs(left - right_flipped))\n    denom = np.maximum(np.mean(gray), 1e-8)\n    score = 1.0 - (diff / denom)\n    return float(np.clip(score, 0.0, 1.0))\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Fraction of object mask area located in the bottom third of the image'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    total = np.count_nonzero(mask)\n    if total == 0:\n        return 0.0\n    bottom_start = (2 * h) // 3\n    bottom = np.count_nonzero(mask[bottom_start:, :])\n    return float(bottom) / float(total)\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Aspect ratio of the object bounding box (height / width)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 50)\n    mask = gray < thr if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else gray > thr\n    ys, xs = np.where(mask)\n    if ys.size == 0:\n        return 0.0\n    y0, y1 = ys.min(), ys.max()\n    x0, x1 = xs.min(), xs.max()\n    bbox_h = float(y1 - y0 + 1)\n    bbox_w = float(x1 - x0 + 1)\n    if bbox_w <= 0:\n        return 0.0\n    return float(bbox_h / (bbox_w + 1e-8))\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Average horizontal transition density per row (edges per row normalized by width)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w < 2:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    # transitions per row\n    row_trans = np.count_nonzero(mask[:, :-1] != mask[:, 1:], axis=1).astype(float)\n    avg = np.mean(row_trans) if row_trans.size > 0 else 0.0\n    return float(avg / float(w))\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Vertical centroid of the mask relative to image center (positive if lower than center)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 50)\n    mask = gray < thr if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else gray > thr\n    ys, xs = np.where(mask)\n    if ys.size == 0:\n        return 0.0\n    y_cent = float(np.mean(ys))\n    # normalized to [-0.5, 0.5]\n    return float((y_cent / float(h)) - 0.5)\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Perceived colorfulness metric (0 for grayscale images)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    if len(image.shape) != 3 or image.shape[2] < 3:\n        return 0.0\n    img = image.astype(float)\n    R = img[:, :, 0]\n    G = img[:, :, 1]\n    B = img[:, :, 2]\n    rg = R - G\n    yb = 0.5 * (R + G) - B\n    std_rg = np.std(rg)\n    std_yb = np.std(yb)\n    mean_rg = np.mean(rg)\n    mean_yb = np.mean(yb)\n    colorfulness = np.sqrt(std_rg ** 2 + std_yb ** 2) + 0.3 * np.sqrt(mean_rg ** 2 + mean_yb ** 2)\n    return float(colorfulness)\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Row index (normalized 0..1) with maximal horizontal edge energy (where object has strongest horizontal edges)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    gy, gx = np.gradient(gray.astype(float))\n    # horizontal edges correspond to vertical gradient (gy) magnitude\n    row_energy = np.sum(np.abs(gy), axis=1)\n    if np.all(row_energy == 0):\n        return 0.0\n    peak_row = int(np.argmax(row_energy))\n    return float(peak_row) / float(max(1, h - 1))\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Fraction of rows where the mask covers >=80% of image width (indicates wide/continuous garments)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    row_counts = np.count_nonzero(mask, axis=1).astype(float)\n    wide_rows = np.count_nonzero(row_counts >= 0.8 * float(w))\n    return float(wide_rows) / float(h)\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Variance of the image Laplacian approximation (higher -> more texture / sharpness)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 2 or w < 2:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    # approximate Laplacian with second derivatives\n    gy, gx = np.gradient(gray.astype(float))\n    gyy, _ = np.gradient(gy)\n    _, gxx = np.gradient(gx)\n    lap = gxx + gyy\n    return float(np.var(lap))\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Number of connected components in the thresholded mask (small components ignored), returned as a float'\n    import numpy as np\n    from collections import deque\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    vis = np.zeros_like(mask, dtype=bool)\n    comps = 0\n    min_area = max(1, (h * w) // 200)  # ignore tiny specks\n    for y in range(h):\n        for x in range(w):\n            if mask[y, x] and not vis[y, x]:\n                # BFS flood fill\n                comps += 1\n                area = 0\n                dq = deque()\n                dq.append((y, x))\n                vis[y, x] = True\n                while dq:\n                    yy, xx = dq.popleft()\n                    area += 1\n                    # 4-neighbors\n                    if yy > 0 and mask[yy - 1, xx] and not vis[yy - 1, xx]:\n                        vis[yy - 1, xx] = True\n                        dq.append((yy - 1, xx))\n                    if yy + 1 < h and mask[yy + 1, xx] and not vis[yy + 1, xx]:\n                        vis[yy + 1, xx] = True\n                        dq.append((yy + 1, xx))\n                    if xx > 0 and mask[yy, xx - 1] and not vis[yy, xx - 1]:\n                        vis[yy, xx - 1] = True\n                        dq.append((yy, xx - 1))\n                    if xx + 1 < w and mask[yy, xx + 1] and not vis[yy, xx + 1]:\n                        vis[yy, xx + 1] = True\n                        dq.append((yy, xx + 1))\n                # if component too small, subtract it from count\n                if area < min_area:\n                    comps -= 1\n    return float(max(0, comps))\n", "def feature(image: np.ndarray) -> float:\n    'Vertical centroid of the foreground mask normalized by image height (0=top,1=bottom)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    ys, xs = np.where(mask)\n    if ys.size == 0:\n        return 0.0\n    cy = float(np.mean(ys))\n    return float(cy / (h + 1e-8))\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Mask solidity: foreground area divided by its bounding-box area (0..1)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    total = np.count_nonzero(mask)\n    if total == 0:\n        return 0.0\n    ys, xs = np.where(mask)\n    ymin, ymax = int(np.min(ys)), int(np.max(ys))\n    xmin, xmax = int(np.min(xs)), int(np.max(xs))\n    bw = float(xmax - xmin + 1)\n    bh = float(ymax - ymin + 1)\n    bbox_area = bw * bh\n    if bbox_area <= 0:\n        return 0.0\n    return float(total / (bbox_area + 1e-8))\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Approximate shape elongation: ratio of smaller to larger PCA eigenvalue of mask coordinates (0..1)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    ys, xs = np.where(mask)\n    if ys.size < 2:\n        return 0.0\n    coords = np.stack([ys.astype(float), xs.astype(float)], axis=1)\n    cov = np.cov(coords, rowvar=False)\n    # handle degenerate cov\n    try:\n        eig = np.linalg.eigvalsh(cov)\n    except Exception:\n        return 0.0\n    eig = np.maximum(eig, 0.0)\n    if eig[1] <= 0:\n        return 0.0\n    ratio = eig[0] / (eig[1] + 1e-8)\n    return float(ratio)\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Fraction of foreground pixels that lie in the bottom 25% of the image'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    total = np.count_nonzero(mask)\n    if total == 0:\n        return 0.0\n    bottom_start = max(0, h - max(1, h // 4))\n    bottom_count = np.count_nonzero(mask[bottom_start:, :])\n    return float(bottom_count / (total + 1e-8))\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Mean horizontal run-length of mask segments (averaged over all segments) normalized by image width'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    seg_lengths = []\n    for r in range(h):\n        row = mask[r, :].astype(int)\n        if np.any(row):\n            pad = np.concatenate(([0], row, [0]))\n            d = np.diff(pad)\n            starts = np.where(d == 1)[0]\n            ends = np.where(d == -1)[0]\n            if starts.size > 0:\n                seg_lengths.extend((ends - starts).tolist())\n    if len(seg_lengths) == 0:\n        return 0.0\n    mean_len = float(np.mean(seg_lengths))\n    return float(mean_len / (w + 1e-8))\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Estimated number of vertical blobs by counting peaks in the vertical projection (integer-valued)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    vproj = np.sum(mask.astype(float), axis=1)\n    if vproj.size == 0:\n        return 0.0\n    vmax = np.max(vproj)\n    if vmax <= 0:\n        return 0.0\n    seg_mask = vproj > (0.12 * vmax)  # threshold to ignore light noise\n    pad = np.concatenate(([0], seg_mask.astype(int), [0]))\n    d = np.diff(pad)\n    starts = np.where(d == 1)[0]\n    ends = np.where(d == -1)[0]\n    count = starts.size\n    return float(count)\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Ratio of average mask width in bottom 10% to average width in middle 40-60%'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 5 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    bottom_h = max(1, h * 10 // 100)\n    bottom = mask[-bottom_h:, :]\n    mid_start = max(0, h * 40 // 100)\n    mid_end = min(h, h * 60 // 100)\n    mid = mask[mid_start:mid_end, :]\n    if bottom.size == 0 or mid.size == 0:\n        return 0.0\n    bottom_widths = np.sum(bottom.astype(float), axis=1)\n    mid_widths = np.sum(mid.astype(float), axis=1)\n    bottom_avg = float(np.mean(bottom_widths)) if bottom_widths.size > 0 else 0.0\n    mid_avg = float(np.mean(mid_widths)) if mid_widths.size > 0 else 0.0\n    if mid_avg <= 1e-8:\n        return 0.0\n    return float((bottom_avg + 1e-8) / (mid_avg + 1e-8))\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Approximate color saturation: mean pairwise absolute differences of RGB channels (0 for grayscale)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    if len(image.shape) != 3 or image.shape[2] < 3:\n        return 0.0\n    img = image.astype(float)\n    r = img[:, :, 0]\n    g = img[:, :, 1]\n    b = img[:, :, 2]\n    diff = (np.abs(r - g) + np.abs(g - b) + np.abs(b - r)) / 3.0\n    return float(np.mean(diff))\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Edge density in the central square region: fraction of strong gradient pixels in center'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 3 or w < 3:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    gy, gx = np.gradient(gray.astype(float))\n    mag = np.sqrt(gx * gx + gy * gy)\n    thr = np.percentile(mag, 75) if np.any(mag) else 0.0\n    strong = mag > thr\n    ch0, ch1 = h // 4, w // 4\n    center = strong[ch0:3*ch0 if 3*ch0 <= h else h, ch1:3*ch1 if 3*ch1 <= w else w]\n    if center.size == 0:\n        return 0.0\n    return float(np.count_nonzero(center) / (center.size + 1e-8))\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Top-bottom symmetry of the foreground mask (Jaccard overlap with vertical flip)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 50)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    if not np.any(mask):\n        return 0.0\n    flipped = np.flipud(mask)\n    inter = np.count_nonzero(mask & flipped)\n    union = np.count_nonzero(mask | flipped)\n    if union == 0:\n        return 0.0\n    return float(inter / union)\n", "def feature(image: np.ndarray) -> float:\n    'Normalized left-right symmetry of the main foreground mask (1 = perfectly symmetric)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    total = np.count_nonzero(mask)\n    if total == 0:\n        return 0.0\n    half = w // 2\n    left = mask[:, :half].astype(float)\n    right = mask[:, w - half:].astype(float)\n    # flip right to compare with left (align widths)\n    right_flipped = np.fliplr(right)\n    # if widths differ pad the smaller\n    if left.shape[1] != right_flipped.shape[1]:\n        minw = min(left.shape[1], right_flipped.shape[1])\n        left = left[:, :minw]\n        right_flipped = right_flipped[:, :minw]\n    diff = np.sum(np.abs(left - right_flipped))\n    diff_norm = float(diff) / (total + 1e-8)\n    sym = 1.0 - min(diff_norm, 1.0)\n    return float(sym)\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Relative darkness/brightness gap in a small top-center patch vs its surrounding (indicative of neck/strap openings)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 4 or w < 4:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    cx, cy = w // 2, h // 8\n    inner_w = max(2, w // 5)\n    inner_h = max(2, h // 8)\n    out_w = min(w, max(3, int(1.6 * inner_w)))\n    out_h = min(h, max(3, int(1.6 * inner_h)))\n    ix0 = max(0, cx - inner_w // 2); ix1 = min(w, cx + (inner_w + 1) // 2)\n    iy0 = max(0, cy - inner_h // 2); iy1 = min(h, cy + (inner_h + 1) // 2)\n    ox0 = max(0, cx - out_w // 2); ox1 = min(w, cx + (out_w + 1) // 2)\n    oy0 = max(0, cy - out_h // 2); oy1 = min(h, cy + (out_h + 1) // 2)\n    inner = gray[iy0:iy1, ix0:ix1]\n    outer = gray[oy0:oy1, ox0:ox1]\n    if inner.size == 0 or outer.size == 0:\n        return 0.0\n    inner_mean = float(np.mean(inner))\n    outer_mean = float(np.mean(outer))\n    # positive when inner is brighter than surrounding (gap), normalized\n    contrast = (inner_mean - outer_mean) / (abs(outer_mean) + 1e-8)\n    return float(contrast)\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Density of strong edges in the bottom 20% of the image (useful for shoe/boot detection)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 3 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    gy, gx = np.gradient(gray.astype(float))\n    grad = np.sqrt(gx * gx + gy * gy)\n    thresh = np.percentile(grad, 70) if np.any(grad) else 0.0\n    strong = grad > thresh\n    bottom_h = max(1, h * 20 // 100)\n    bottom_region = strong[-bottom_h:, :]\n    density = float(np.count_nonzero(bottom_region)) / float(bottom_region.size + 1e-8)\n    return float(density)\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Normalized count of prominent peaks in the vertical projection (number of separated vertical components)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if w < 3 or h == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    col_counts = np.sum(mask, axis=0).astype(float)\n    if np.all(col_counts == 0):\n        return 0.0\n    # simple smoothing\n    kern = np.array([1.0, 1.0, 1.0]) / 3.0\n    smooth = np.convolve(col_counts, kern, mode='same')\n    meanv = float(np.mean(smooth)); stdv = float(np.std(smooth))\n    peaks = 0\n    for i in range(1, w - 1):\n        if smooth[i] > smooth[i - 1] and smooth[i] > smooth[i + 1] and smooth[i] > (meanv + 0.5 * stdv):\n            peaks += 1\n    return float(peaks) / float(w)\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Lower-third split score: depth of valley between two strongest column peaks in the lower third (0..1)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 3 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    start = (2 * h) // 3\n    region = mask[start:, :]\n    if region.size == 0:\n        return 0.0\n    col_counts = np.sum(region, axis=0).astype(float)\n    if np.max(col_counts) <= 0:\n        return 0.0\n    # find two highest peaks\n    inds = np.argsort(col_counts)[-2:]\n    if inds.size < 2:\n        return 0.0\n    i1, i2 = int(inds[0]), int(inds[1])\n    if i1 == i2:\n        return 0.0\n    a, b = min(i1, i2), max(i1, i2)\n    valley = float(np.min(col_counts[a:b + 1])) if b >= a else float(np.min(col_counts))\n    peak_mean = 0.5 * (float(col_counts[i1]) + float(col_counts[i2]))\n    score = (peak_mean - valley) / (np.max(col_counts) + 1e-8)\n    score = max(0.0, min(1.0, score))\n    return float(score)\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Global mean gradient magnitude (texture/edge energy) normalized by image dynamic range'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 2 or w < 2:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    gy, gx = np.gradient(gray.astype(float))\n    grad = np.sqrt(gx * gx + gy * gy)\n    mean_grad = float(np.mean(grad))\n    dyn = float(np.max(gray) - np.min(gray))\n    return float(mean_grad / (dyn + 1e-8))\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Color uniformity measure for RGB: 1 = perfectly uniform color, 0 = maximally varied'\n    import numpy as np\n    if image is None:\n        return 0.0\n    if len(image.shape) != 3 or image.shape[2] < 3:\n        return 0.0\n    img = image.astype(float)\n    # per-pixel color spread\n    pix_std = np.std(img, axis=2)\n    mean_pix_std = float(np.mean(pix_std))\n    dyn = float(np.max(img) - np.min(img))\n    if dyn <= 1e-8:\n        return 1.0\n    uniformity = 1.0 - (mean_pix_std / (dyn + 1e-8))\n    return float(max(0.0, min(1.0, uniformity)))\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Mask compactness: fraction of bounding-box area occupied by foreground (0..1)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 60)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    if not np.any(mask):\n        return 0.0\n    ys, xs = np.where(mask)\n    miny, maxy = ys.min(), ys.max()\n    minx, maxx = xs.min(), xs.max()\n    bbox_area = float((maxy - miny + 1) * (maxx - minx + 1))\n    mask_area = float(np.count_nonzero(mask))\n    if bbox_area <= 0:\n        return 0.0\n    compactness = mask_area / (bbox_area + 1e-8)\n    return float(max(0.0, min(1.0, compactness)))\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Vertical centroid of the foreground mask normalized to image height (0=top,1=bottom)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    ys, xs = np.where(mask)\n    if ys.size == 0:\n        return 0.0\n    y_cent = float(np.mean(ys)) / float(h)\n    return float(max(0.0, min(1.0, y_cent)))\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Waist narrowness: 1 - (min row width / max row width) within central vertical band (higher = narrower waist)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 3 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    top = max(0, h * 30 // 100)\n    bottom = min(h, h * 70 // 100)\n    band = mask[top:bottom, :]\n    if band.size == 0:\n        return 0.0\n    row_counts = np.sum(band, axis=1).astype(float)\n    if row_counts.size == 0:\n        return 0.0\n    maxw = float(np.max(row_counts))\n    minw = float(np.min(row_counts))\n    if maxw <= 1e-8:\n        return 0.0\n    narrowness = 1.0 - (minw / (maxw + 1e-8))\n    return float(max(0.0, min(1.0, narrowness)))\n", "def feature(image: np.ndarray) -> float:\n    'Normalized vertical centroid of the main mask (0=top, 1=bottom)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    ys = np.where(mask)[0]\n    if ys.size == 0:\n        return 0.0\n    y_cent = float(np.mean(ys))\n    eps = 1e-8\n    return float(y_cent / (max(1.0, h - 1) + eps))\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Bounding-box aspect ratio of detected mask normalized by image aspect'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    ys, xs = np.where(mask)\n    if ys.size == 0:\n        return 0.0\n    ymin, ymax = int(np.min(ys)), int(np.max(ys))\n    xmin, xmax = int(np.min(xs)), int(np.max(xs))\n    bb_h = float(max(1, ymax - ymin + 1))\n    bb_w = float(max(1, xmax - xmin + 1))\n    img_aspect = float(h) / float(max(1, w))\n    aspect = bb_h / (bb_w + 1e-8)\n    return float(aspect / (img_aspect + 1e-8))\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Average number of vertical transitions per column in the binary mask (normalized)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 2 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    # compute transitions per column\n    trans = np.sum(mask[:-1, :] != mask[1:, :], axis=0).astype(float)\n    avg_trans = float(np.mean(trans)) if trans.size > 0 else 0.0\n    return float(avg_trans / (h + 1e-8))\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Difference between upper-half fill fraction and lower-half fill fraction (-1..1)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 2 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    mid = h // 2\n    upper = mask[:mid, :]\n    lower = mask[mid:, :]\n    upper_frac = float(np.count_nonzero(upper)) / float(max(1, upper.size))\n    lower_frac = float(np.count_nonzero(lower)) / float(max(1, lower.size))\n    return float(upper_frac - lower_frac)\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Ratio of mean gradient magnitude inside mask to mean outside (texture contrast)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 2 or w < 2:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    gy, gx = np.gradient(gray.astype(float))\n    grad = np.sqrt(gx * gx + gy * gy)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    inside = grad[mask]\n    outside = grad[~mask]\n    if inside.size == 0 or outside.size == 0:\n        return 0.0\n    mean_in = float(np.mean(inside))\n    mean_out = float(np.mean(outside))\n    return float(mean_in / (mean_out + 1e-8))\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Average mask width in upper quarter divided by average width in lower quarter'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 4 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    q = max(1, h // 4)\n    upper_rows = mask[:q, :]\n    lower_rows = mask[-q:, :]\n    up_widths = np.sum(upper_rows.astype(float), axis=1)\n    low_widths = np.sum(lower_rows.astype(float), axis=1)\n    up_avg = float(np.mean(up_widths)) if up_widths.size > 0 else 0.0\n    low_avg = float(np.mean(low_widths)) if low_widths.size > 0 else 0.0\n    if low_avg <= 0:\n        return 0.0\n    return float((up_avg + 1e-8) / (low_avg + 1e-8))\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Maximum contiguous vertical run of mask pixels in any column normalized by image height'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    max_run = 0\n    # iterate columns (images small enough for loop)\n    for c in range(w):\n        col = mask[:, c]\n        curr = 0\n        local_max = 0\n        # iterate rows in column\n        for v in col:\n            if v:\n                curr += 1\n                if curr > local_max:\n                    local_max = curr\n            else:\n                curr = 0\n        if local_max > max_run:\n            max_run = local_max\n    return float(max_run / (h + 1e-8))\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Absolute horizontal centroid offset from image center (0=centered, 1=edge)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    xs = np.where(mask)[1]\n    if xs.size == 0:\n        return 0.0\n    x_cent = float(np.mean(xs))\n    center = (w - 1) / 2.0\n    return float(abs(x_cent - center) / (max(1.0, center) + 1e-8))\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Fraction of mask pixels that touch the image border area (margin fraction)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    if not np.any(mask):\n        return 0.0\n    m = max(1, int(0.03 * min(h, w)))\n    border_mask = np.zeros_like(mask, dtype=bool)\n    border_mask[:m, :] = True\n    border_mask[-m:, :] = True\n    border_mask[:, :m] = True\n    border_mask[:, -m:] = True\n    touch = np.count_nonzero(mask & border_mask)\n    total = np.count_nonzero(mask)\n    return float(touch / (total + 1e-8))\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Approximate compactness: perimeter^2 divided by area for the mask (higher => more complex)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    area = float(np.count_nonzero(mask))\n    if area <= 0.0:\n        return 0.0\n    # neighbors without wrap-around\n    up = np.zeros_like(mask)\n    up[:-1, :] = mask[1:, :]\n    down = np.zeros_like(mask)\n    down[1:, :] = mask[:-1, :]\n    left = np.zeros_like(mask)\n    left[:, :-1] = mask[:, 1:]\n    right = np.zeros_like(mask)\n    right[:, 1:] = mask[:, :-1]\n    interior = up & down & left & right\n    boundary = mask & (~interior)\n    perimeter = float(np.count_nonzero(boundary))\n    return float((perimeter * perimeter) / (area + 1e-8))\n", "def feature(image: np.ndarray) -> float:\n    'Aspect ratio (width/height) of bounding box of the largest connected foreground component'\n    import numpy as np\n    if image is None:\n        return 1.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 1.0\n    # grayscale\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    visited = np.zeros_like(mask, dtype=bool)\n    best_bbox = None\n    best_area = 0\n    for y in range(h):\n        for x in range(w):\n            if mask[y, x] and not visited[y, x]:\n                # flood fill stack\n                minx, maxx = x, x\n                miny, maxy = y, y\n                area = 0\n                stack = [(y, x)]\n                visited[y, x] = True\n                while stack:\n                    cy, cx = stack.pop()\n                    area += 1\n                    if cx < minx: minx = cx\n                    if cx > maxx: maxx = cx\n                    if cy < miny: miny = cy\n                    if cy > maxy: maxy = cy\n                    # neighbors 4-connected\n                    if cy > 0 and mask[cy - 1, cx] and not visited[cy - 1, cx]:\n                        visited[cy - 1, cx] = True\n                        stack.append((cy - 1, cx))\n                    if cy + 1 < h and mask[cy + 1, cx] and not visited[cy + 1, cx]:\n                        visited[cy + 1, cx] = True\n                        stack.append((cy + 1, cx))\n                    if cx > 0 and mask[cy, cx - 1] and not visited[cy, cx - 1]:\n                        visited[cy, cx - 1] = True\n                        stack.append((cy, cx - 1))\n                    if cx + 1 < w and mask[cy, cx + 1] and not visited[cy, cx + 1]:\n                        visited[cy, cx + 1] = True\n                        stack.append((cy, cx + 1))\n                if area > best_area:\n                    best_area = area\n                    best_bbox = (minx, miny, maxx, maxy)\n    if best_bbox is None or best_area <= 0:\n        return 1.0\n    minx, miny, maxx, maxy = best_bbox\n    bw = maxx - minx + 1\n    bh = maxy - miny + 1\n    if bh <= 0:\n        return 1.0\n    return float(float(bw) / float(bh))\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Colorfulness metric for RGB images (0 for grayscale)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    if len(image.shape) != 3 or image.shape[2] != 3:\n        return 0.0\n    # use simple Hasler & S\u00fcsstrunk measure\n    R = image[:, :, 0].astype(float)\n    G = image[:, :, 1].astype(float)\n    B = image[:, :, 2].astype(float)\n    rg = R - G\n    yb = 0.5 * (R + G) - B\n    std_rg = float(np.std(rg))\n    std_yb = float(np.std(yb))\n    mean_rg = float(np.mean(np.abs(rg)))\n    mean_yb = float(np.mean(np.abs(yb)))\n    colorfulness = np.sqrt(std_rg * std_rg + std_yb * std_yb) + 0.3 * (mean_rg + mean_yb)\n    return float(colorfulness)\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Fraction of foreground pixels that lie within a narrow border (touching image edges)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    total = np.count_nonzero(mask)\n    if total == 0:\n        return 0.0\n    mh = max(1, h * 5 // 100)\n    mw = max(1, w * 5 // 100)\n    border_mask = np.zeros_like(mask, dtype=bool)\n    border_mask[:mh, :] = True\n    border_mask[h - mh:, :] = True\n    border_mask[:, :mw] = True\n    border_mask[:, w - mw:] = True\n    touching = np.count_nonzero(mask & border_mask)\n    return float(touching / (total + 1e-8))\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Vertical symmetry score (mean absolute difference between top half and flipped bottom)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 2 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    mid = h // 2\n    top = gray[:mid, :]\n    bottom = gray[h - mid:, :]\n    # flip bottom vertically to compare with top\n    bottom_flip = np.flipud(bottom)\n    # align widths if needed\n    if top.shape[0] == 0 or bottom_flip.shape[0] == 0:\n        return 0.0\n    m = min(top.shape[0], bottom_flip.shape[0])\n    top = top[:m, :]\n    bottom_flip = bottom_flip[:m, :]\n    diff = np.abs(top - bottom_flip)\n    return float(np.mean(diff))\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Average local 4-neighbor intensity variation (texture-like energy)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 2 or w < 2:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    # compute absolute differences with 4-neighbors using rolls, mask edges\n    up = np.roll(gray, 1, axis=0)\n    down = np.roll(gray, -1, axis=0)\n    left = np.roll(gray, 1, axis=1)\n    right = np.roll(gray, -1, axis=1)\n    # zero out invalid rolled edges to avoid wrap-around\n    up[0, :] = gray[0, :]\n    down[-1, :] = gray[-1, :]\n    left[:, 0] = gray[:, 0]\n    right[:, -1] = gray[:, -1]\n    diffs = (np.abs(gray - up) + np.abs(gray - down) + np.abs(gray - left) + np.abs(gray - right))\n    # average per-pixel\n    return float(np.mean(diffs))\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Count of connected foreground components (small integer returned as float)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    visited = np.zeros_like(mask, dtype=bool)\n    comps = 0\n    for y in range(h):\n        for x in range(w):\n            if mask[y, x] and not visited[y, x]:\n                comps += 1\n                # flood fill\n                stack = [(y, x)]\n                visited[y, x] = True\n                while stack:\n                    cy, cx = stack.pop()\n                    if cy > 0 and mask[cy - 1, cx] and not visited[cy - 1, cx]:\n                        visited[cy - 1, cx] = True\n                        stack.append((cy - 1, cx))\n                    if cy + 1 < h and mask[cy + 1, cx] and not visited[cy + 1, cx]:\n                        visited[cy + 1, cx] = True\n                        stack.append((cy + 1, cx))\n                    if cx > 0 and mask[cy, cx - 1] and not visited[cy, cx - 1]:\n                        visited[cy, cx - 1] = True\n                        stack.append((cy, cx - 1))\n                    if cx + 1 < w and mask[cy, cx + 1] and not visited[cy, cx + 1]:\n                        visited[cy, cx + 1] = True\n                        stack.append((cy, cx + 1))\n                # safety cap\n                if comps > 1000:\n                    break\n        if comps > 1000:\n            break\n    return float(comps)\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Ratio of average gradient magnitude inside the foreground mask to outside it'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 2 or w < 2:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    gy, gx = np.gradient(gray.astype(float))\n    grad = np.sqrt(gx * gx + gy * gy)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    inside = grad[mask]\n    outside = grad[~mask]\n    mean_in = float(np.mean(inside)) if inside.size > 0 else 0.0\n    mean_out = float(np.mean(outside)) if outside.size > 0 else 0.0\n    return float(mean_in / (mean_out + 1e-8))\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Ratio of average object width at mid-height (45-55%) to width near bottom (80-95%)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 4 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    # mid band\n    mid_start = max(0, h * 45 // 100)\n    mid_end = min(h, h * 55 // 100)\n    bottom_start = max(0, h * 80 // 100)\n    bottom_end = min(h, h * 95 // 100)\n    mid_rows = mask[mid_start:mid_end, :]\n    bottom_rows = mask[bottom_start:bottom_end, :]\n    if mid_rows.size == 0 or bottom_rows.size == 0:\n        return 0.0\n    mid_widths = np.sum(mid_rows.astype(float), axis=1)\n    bottom_widths = np.sum(bottom_rows.astype(float), axis=1)\n    mid_avg = float(np.mean(mid_widths)) if mid_widths.size > 0 else 0.0\n    bot_avg = float(np.mean(bottom_widths)) if bottom_widths.size > 0 else 0.0\n    if bot_avg <= 0:\n        return 0.0\n    return float((mid_avg + 1e-8) / (bot_avg + 1e-8))\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Dominant object orientation angle normalized to [-1,1] (negative = leaning left)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = gray < thr if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else gray > thr\n    ys, xs = np.where(mask)\n    if ys.size < 3:\n        return 0.0\n    coords = np.vstack((xs.astype(float), ys.astype(float)))\n    cov = np.cov(coords)\n    if cov.shape != (2, 2):\n        return 0.0\n    eigvals, eigvecs = np.linalg.eigh(cov)\n    # take eigenvector of largest eigenvalue\n    idx = int(np.argmax(eigvals))\n    vec = eigvecs[:, idx]\n    angle = np.arctan2(vec[1], vec[0])  # radians between -pi and pi\n    # convert to degrees and normalize to [-1,1] by dividing by 90 degrees\n    angle_deg = angle * (180.0 / np.pi)\n    # map to [-90,90]\n    if angle_deg > 90:\n        angle_deg -= 180\n    if angle_deg < -90:\n        angle_deg += 180\n    return float(angle_deg / 90.0)\n", "def feature(image: np.ndarray) -> float:\n    'Normalized vertical span of the main foreground (bounding box height / image height)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 50)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    ys, xs = np.where(mask)\n    if ys.size == 0:\n        return 0.0\n    span = float(np.max(ys) - np.min(ys) + 1)\n    return float(span / float(h))\n\n", "def feature(image: np.ndarray) -> float:\n    'Aspect ratio (height/width) of the main mask bounding box (0 if undefined)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = gray < thr if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else gray > thr\n    ys, xs = np.where(mask)\n    if ys.size == 0:\n        return 0.0\n    ymin, ymax = int(np.min(ys)), int(np.max(ys))\n    xmin, xmax = int(np.min(xs)), int(np.max(xs))\n    bw = float(xmax - xmin + 1)\n    bh = float(ymax - ymin + 1)\n    if bw <= 0:\n        return 0.0\n    return float(bh / (bw + 1e-8))\n\n", "def feature(image: np.ndarray) -> float:\n    'Principal axis orientation of the mask (0=horizontal, 1=vertical)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 50)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    ys, xs = np.where(mask)\n    if ys.size < 3:\n        return 0.0\n    # compute covariance of coordinates (x,y)\n    cx = np.mean(xs.astype(float))\n    cy = np.mean(ys.astype(float))\n    xs0 = xs.astype(float) - cx\n    ys0 = ys.astype(float) - cy\n    cov_xx = np.mean(xs0 * xs0)\n    cov_yy = np.mean(ys0 * ys0)\n    cov_xy = np.mean(xs0 * ys0)\n    # principal eigenvector angle\n    theta = 0.5 * np.arctan2(2 * cov_xy, (cov_xx - cov_yy) + 1e-12)\n    # angle of major axis (perpendicular if needed) -> map absolute angle to [0, pi/2]\n    ang = np.abs(theta)\n    if ang > np.pi/2:\n        ang = np.pi - ang\n    # map 0..pi/2 to 0..1 where 1 means vertical (pi/2)\n    return float(ang / (np.pi/2 + 1e-12))\n\n", "def feature(image: np.ndarray) -> float:\n    'Mask compactness: area / (perimeter^2) (higher = more compact)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    mask = mask.astype(bool)\n    area = float(np.count_nonzero(mask))\n    if area == 0:\n        return 0.0\n    # interior pixels are those with all 4-neighbors also True\n    interior = mask.copy()\n    interior &= np.roll(mask, 1, axis=0)\n    interior &= np.roll(mask, -1, axis=0)\n    interior &= np.roll(mask, 1, axis=1)\n    interior &= np.roll(mask, -1, axis=1)\n    boundary = mask & (~interior)\n    perimeter = float(np.count_nonzero(boundary))\n    if perimeter <= 0:\n        return float(area / (1e-8))\n    compact = area / ((perimeter * perimeter) + 1e-8)\n    return float(compact)\n\n", "def feature(image: np.ndarray) -> float:\n    'Number of connected foreground components (useful for separate shoes or bag + garment)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    mask = mask.astype(bool)\n    if not np.any(mask):\n        return 0.0\n    visited = np.zeros_like(mask, dtype=bool)\n    comps = 0\n    # scan and flood-fill\n    for y in range(h):\n        for x in range(w):\n            if mask[y, x] and not visited[y, x]:\n                comps += 1\n                stack = [(y, x)]\n                visited[y, x] = True\n                while stack:\n                    cy, cx = stack.pop()\n                    for ny, nx in ((cy-1, cx), (cy+1, cx), (cy, cx-1), (cy, cx+1)):\n                        if 0 <= ny < h and 0 <= nx < w and mask[ny, nx] and not visited[ny, nx]:\n                            visited[ny, nx] = True\n                            stack.append((ny, nx))\n    return float(comps)\n\n", "def feature(image: np.ndarray) -> float:\n    'Fraction of mask pixels located in the bottom left + right corner boxes (shoe indicator)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 2 or w < 2:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    total = np.count_nonzero(mask)\n    if total == 0:\n        return 0.0\n    box_h = max(1, int(h * 0.15))\n    box_w = max(1, int(w * 0.2))\n    bottom_start = h - box_h\n    left_box = mask[bottom_start:h, 0:box_w]\n    right_box = mask[bottom_start:h, w - box_w:w]\n    count = float(np.count_nonzero(left_box) + np.count_nonzero(right_box))\n    return float(count / (total + 1e-8))\n\n", "def feature(image: np.ndarray) -> float:\n    'Ratio of top-half edge energy to bottom-half edge energy (helps separate tops vs bottoms)'\n    import numpy as np\n    import numpy as _np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 2 or w < 2:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = _np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    gy, gx = _np.gradient(gray)\n    grad_mag = _np.sqrt(gx * gx + gy * gy)\n    mid = h // 2\n    top_energy = float(_np.sum(grad_mag[:mid, :]))\n    bottom_energy = float(_np.sum(grad_mag[mid:, :]))\n    if bottom_energy <= 0:\n        return float(top_energy / (bottom_energy + 1e-8))\n    return float(top_energy / bottom_energy)\n\n", "def feature(image: np.ndarray) -> float:\n    'Mean color saturation (RGB only) computed as mean((max-min)/max) across pixels; grayscale -> 0'\n    import numpy as np\n    if image is None:\n        return 0.0\n    if len(image.shape) != 3 or image.shape[2] < 3:\n        return 0.0\n    # compute per-pixel saturation\n    img = image.astype(float)\n    r = img[:, :, 0]\n    g = img[:, :, 1]\n    b = img[:, :, 2]\n    mx = np.maximum(np.maximum(r, g), b)\n    mn = np.minimum(np.minimum(r, g), b)\n    sat = np.zeros_like(mx, dtype=float)\n    nonzero = mx > 1e-8\n    sat[nonzero] = (mx[nonzero] - mn[nonzero]) / (mx[nonzero] + 1e-12)\n    return float(np.mean(sat))\n\n", "def feature(image: np.ndarray) -> float:\n    'Median vertical run length of foreground per column normalized by image height (long runs -> pants)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    col_means = []\n    for x in range(w):\n        col = mask[:, x].astype(int)\n        if np.all(col == 0):\n            continue\n        # find run lengths\n        padded = np.concatenate(([0], col, [0]))\n        diff = np.diff(padded)\n        starts = np.where(diff == 1)[0]\n        ends = np.where(diff == -1)[0]\n        runs = (ends - starts).astype(float)\n        if runs.size > 0:\n            col_means.append(np.mean(runs))\n    if len(col_means) == 0:\n        return 0.0\n    med = float(np.median(np.array(col_means)))\n    return float(med / float(h))\n\n", "def feature(image: np.ndarray) -> float:\n    'Ratio of center row mask width to maximum row mask width (detects narrow waist vs wide bag)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 50)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    row_widths = np.count_nonzero(mask, axis=1).astype(float)\n    if np.all(row_widths == 0):\n        return 0.0\n    center_row = h // 2\n    center_w = float(row_widths[center_row])\n    max_w = float(np.max(row_widths))\n    if max_w <= 0:\n        return 0.0\n    return float(center_w / (max_w + 1e-8))\n", "def feature(image: np.ndarray) -> float:\n    'Aspect ratio (width/height) of the main mask bounding box (1.0 square)'\n    import numpy as np\n    if image is None:\n        return 1.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 1.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    ys, xs = np.where(mask)\n    if ys.size == 0:\n        return 1.0\n    miny, maxy = int(np.min(ys)), int(np.max(ys))\n    minx, maxx = int(np.min(xs)), int(np.max(xs))\n    bbox_h = max(1, maxy - miny + 1)\n    bbox_w = max(1, maxx - minx + 1)\n    return float(bbox_w / float(bbox_h))\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Left-right symmetry: IoU between mask and horizontally flipped mask (0..1)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    flipped = np.fliplr(mask)\n    inter = np.count_nonzero(mask & flipped)\n    union = np.count_nonzero(mask | flipped)\n    if union == 0:\n        return 0.0\n    return float(inter / float(union))\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Ratio of mask mass in top half to bottom half (1 => equal)'\n    import numpy as np\n    if image is None:\n        return 1.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 1.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    mid = h // 2\n    top_mass = float(np.count_nonzero(mask[:mid, :]))\n    bot_mass = float(np.count_nonzero(mask[mid:, :]))\n    return float((top_mass + 1e-8) / (bot_mass + 1e-8))\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Count of distinct horizontal peaks in the mask row profile (normalized by height)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 3 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    row_sums = np.sum(mask.astype(float), axis=1)\n    # simple smoothing kernel\n    kernel = np.array([1.0, 1.0, 1.0])\n    smooth = np.convolve(row_sums, kernel, mode='same') / np.sum(kernel)\n    meanv = float(np.mean(smooth))\n    peaks = 0\n    for i in range(1, h - 1):\n        if smooth[i] > smooth[i - 1] and smooth[i] > smooth[i + 1] and smooth[i] > meanv * 0.8:\n            peaks += 1\n    return float(peaks / float(max(1, h)))\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Side concentration: fraction of mask area contained in the denser half (left or right)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    mid = w // 2\n    left = np.count_nonzero(mask[:, :mid])\n    right = np.count_nonzero(mask[:, mid:])\n    total = left + right\n    if total == 0:\n        return 0.0\n    return float(max(left, right) / float(total))\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Number of contiguous horizontal mask segments in upper 40% (useful for sleeves) normalized'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    top_h = max(1, (40 * h) // 100)\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask_top = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    mask_top = mask_top[:top_h, :]\n    col_any = np.any(mask_top, axis=0).astype(int)\n    if col_any.size == 0:\n        return 0.0\n    # count rises from 0 to 1\n    transitions = np.sum((col_any[1:] == 1) & (col_any[:-1] == 0))\n    # if first column is 1, that starts a segment\n    if col_any[0] == 1:\n        transitions += 1\n    return float(transitions / 10.0)  # scaled down to keep values moderate\n\n\n", "def feature(image: np.ndarray) -> float:\n    'RGB colorfulness: normalized sum of channel std deviations (0 for grayscale)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    if len(image.shape) != 3 or image.shape[2] < 3:\n        return 0.0\n    h, w, c = image.shape\n    if h == 0 or w == 0:\n        return 0.0\n    chans_std = np.std(image.astype(float).reshape(-1, c), axis=0)\n    mean_intensity = float(np.mean(image))\n    denom = mean_intensity + 1e-8\n    score = float(np.sum(chans_std) / denom)\n    return float(score)\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Proportion of edge energy concentrated in bottom 25% of image (0..1)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 2 or w < 2:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    gy, gx = np.gradient(gray.astype(float))\n    mag = np.sqrt(gx * gx + gy * gy)\n    total = float(np.sum(mag))\n    bottom_start = max(0, h - max(1, h // 4))\n    bottom_energy = float(np.sum(mag[bottom_start:, :]))\n    if total <= 0:\n        return 0.0\n    return float(bottom_energy / total)\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Mask compactness: mask area divided by bounding-box area (0..1, 1 = full rectangle)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    ys, xs = np.where(mask)\n    area = float(ys.size)\n    if area == 0:\n        return 0.0\n    miny, maxy = int(np.min(ys)), int(np.max(ys))\n    minx, maxx = int(np.min(xs)), int(np.max(xs))\n    bbox_h = max(1, maxy - miny + 1)\n    bbox_w = max(1, maxx - minx + 1)\n    bbox_area = float(bbox_h * bbox_w)\n    if bbox_area <= 0:\n        return 0.0\n    return float(area / bbox_area)\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Shoulder-to-waist width ratio: mean mask width near 15% rows divided by 55% rows'\n    import numpy as np\n    if image is None:\n        return 1.0\n    h, w = image.shape[:2]\n    if h < 4 or w == 0:\n        return 1.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    def avg_width_at(row_frac):\n        row = int(min(h - 1, max(0, int(row_frac * h))))\n        band = 2\n        start = max(0, row - band)\n        end = min(h, row + band + 1)\n        widths = np.sum(mask[start:end, :].astype(float), axis=1)\n        if widths.size == 0:\n            return 1.0\n        return float(np.mean(widths)) + 1e-8\n    shoulder = avg_width_at(0.15)\n    waist = avg_width_at(0.55)\n    return float(shoulder / float(waist + 1e-8))\n", "def feature(image: np.ndarray) -> float:\n    'Horizontal symmetry of the foreground mask (1.0 = perfectly symmetric)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    # grayscale for mask\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 50)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    total = np.count_nonzero(mask)\n    if total == 0:\n        return 0.0\n    flipped = np.fliplr(mask)\n    overlap = np.count_nonzero(mask & flipped)\n    return float(overlap / float(total + 1e-8))\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Normalized horizontal offset of mask centroid (0=center, 1=far edge)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 50)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    ys, xs = np.where(mask)\n    if xs.size == 0:\n        return 0.0\n    cx = float(np.mean(xs))\n    center = float(w - 1) / 2.0\n    dist = abs(cx - center)\n    return float(dist / (center + 1e-8))\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Colorfulness metric (Hasler-S\u00fcsstrunk) normalized to [0, ~1] for RGB, 0 for grayscale'\n    import numpy as np\n    if image is None:\n        return 0.0\n    if len(image.shape) != 3 or image.shape[2] < 3:\n        return 0.0\n    # use only first three channels as RGB\n    img = image[:, :, :3].astype(float)\n    R = img[:, :, 0]\n    G = img[:, :, 1]\n    B = img[:, :, 2]\n    rg = R - G\n    yb = 0.5 * (R + G) - B\n    std_rg = float(np.std(rg))\n    std_yb = float(np.std(yb))\n    mean_rg = float(np.mean(rg))\n    mean_yb = float(np.mean(yb))\n    raw = np.sqrt(std_rg * std_rg + std_yb * std_yb) + 0.3 * np.sqrt(mean_rg * mean_rg + mean_yb * mean_yb)\n    # normalize roughly by 255\n    return float(raw / 255.0)\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Mean saturation of pixels in RGB image (0-1), 0 for grayscale'\n    import numpy as np\n    if image is None:\n        return 0.0\n    if len(image.shape) != 3 or image.shape[2] < 3:\n        return 0.0\n    img = image[:, :, :3].astype(float)\n    mx = np.max(img, axis=2)\n    mn = np.min(img, axis=2)\n    # avoid division by zero\n    sat = np.zeros_like(mx, dtype=float)\n    nz = mx > 1e-8\n    sat[nz] = (mx[nz] - mn[nz]) / (mx[nz] + 1e-8)\n    return float(np.mean(sat))\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Edge density in the central vertical band (fraction of strong edges)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 2 or w < 2:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    gy, gx = np.gradient(gray)\n    mag = np.sqrt(gx * gx + gy * gy)\n    if not np.any(mag):\n        return 0.0\n    thr = np.percentile(mag, 70)\n    strong = mag > thr\n    # central vertical band ~20% width\n    left = max(0, int(w * 0.4))\n    right = min(w, int(w * 0.6) + 1)\n    band = strong[:, left:right]\n    if band.size == 0:\n        return 0.0\n    return float(np.count_nonzero(band) / float(band.size))\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Median number of horizontal mask segments per row (normalized by width)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 50)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    counts = []\n    for r in range(h):\n        row = mask[r, :].astype(np.int8)\n        if np.all(row == 0):\n            continue\n        dif = np.diff(np.concatenate(([0], row)))\n        starts = np.count_nonzero(dif == 1)\n        if starts > 0:\n            counts.append(float(starts))\n    if len(counts) == 0:\n        return 0.0\n    med = float(np.median(np.array(counts)))\n    # normalize by possible maximum segments (~w/2)\n    return float(med / max(1.0, float(w) / 2.0))\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Normalized vertical centroid of the mask (0=top, 1=bottom)'\n    import numpy as np\n    if image is None:\n        return 0.5\n    h, w = image.shape[:2]\n    if h == 0:\n        return 0.5\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 50)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    ys, xs = np.where(mask)\n    if ys.size == 0:\n        return 0.5\n    cy = float(np.mean(ys))\n    return float(cy / float(max(1, h - 1)))\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Fill ratio: mask area divided by its bounding-box area (1.0 = full bbox)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 50)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    total = np.count_nonzero(mask)\n    if total == 0:\n        return 0.0\n    ys, xs = np.where(mask)\n    y0, y1 = ys.min(), ys.max()\n    x0, x1 = xs.min(), xs.max()\n    bbox_area = float((y1 - y0 + 1) * (x1 - x0 + 1))\n    if bbox_area <= 0.0:\n        return 0.0\n    return float(total / bbox_area)\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Mean number of mask segments across a shoulder band (~10-20% height), indicates sleeve separation'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 3 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 50)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    center_row = int(max(0, min(h - 1, int(0.15 * h))))\n    band =  max(1, h // 50)  # small band\n    start = max(0, center_row - band)\n    end = min(h, center_row + band + 1)\n    seg_counts = []\n    for r in range(start, end):\n        row = mask[r, :].astype(np.int8)\n        if np.all(row == 0):\n            seg_counts.append(0.0)\n            continue\n        dif = np.diff(np.concatenate(([0], row)))\n        starts = np.count_nonzero(dif == 1)\n        seg_counts.append(float(starts))\n    if len(seg_counts) == 0:\n        return 0.0\n    return float(np.mean(seg_counts))\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Median number of mask segments per row within bottom third (helps identify separate shoes)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 3 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 50)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    start = (2 * h) // 3\n    counts = []\n    for r in range(start, h):\n        row = mask[r, :].astype(np.int8)\n        if np.all(row == 0):\n            continue\n        dif = np.diff(np.concatenate(([0], row)))\n        starts = np.count_nonzero(dif == 1)\n        counts.append(float(starts))\n    if len(counts) == 0:\n        return 0.0\n    med = float(np.median(np.array(counts)))\n    # normalize by 2 (0..2 typical for two shoes)\n    return float(med / 2.0)\n", "def feature(image: np.ndarray) -> float:\n    'Bounding-box aspect ratio of the foreground mask (width / height)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 50)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    coords = np.argwhere(mask)\n    if coords.size == 0:\n        return 0.0\n    ys, xs = coords[:, 0], coords[:, 1]\n    bbox_h = float(max(1, ys.max() - ys.min() + 1))\n    bbox_w = float(max(1, xs.max() - xs.min() + 1))\n    return float(bbox_w / (bbox_h + 1e-8))\n\n", "def feature(image: np.ndarray) -> float:\n    'Proportion of image area covered by the foreground mask'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 50)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    area = float(np.count_nonzero(mask))\n    return float(area / (float(h * w) + 1e-8))\n\n", "def feature(image: np.ndarray) -> float:\n    'Top-bottom (vertical) symmetry of the foreground mask (1.0 = symmetric)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 50)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    total = np.count_nonzero(mask)\n    if total == 0:\n        return 0.0\n    flipped = np.flipud(mask)\n    overlap = np.count_nonzero(mask & flipped)\n    return float(overlap / (total + 1e-8))\n\n", "def feature(image: np.ndarray) -> float:\n    'Fraction of center columns that are empty in the top band (indicates neck/opening)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 3 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 50)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    top_band_h = max(1, int(round(h * 0.12)))\n    c0, c1 = w // 4, (3 * w) // 4\n    top_center = mask[:top_band_h, c0:c1]\n    if top_center.size == 0:\n        return 0.0\n    # columns in center that have no foreground in the top band\n    col_empty = np.sum(np.all(top_center == 0, axis=0))\n    return float(col_empty / float(max(1, top_center.shape[1])))\n\n", "def feature(image: np.ndarray) -> float:\n    'Average number of foreground/background transitions per column (vertical segmentation)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 2 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 50)\n    mask = ((gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)).astype(np.uint8)\n    # transitions along each column\n    diffs = np.abs(np.diff(mask, axis=0))\n    transitions_per_col = np.sum(diffs, axis=0).astype(float)\n    return float(np.mean(transitions_per_col))\n\n", "def feature(image: np.ndarray) -> float:\n    'Ratio of horizontal-dominant edge pixels to vertical-dominant edge pixels'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 2 or w < 2:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    gy, gx = np.gradient(gray.astype(float))\n    grad_mag = np.sqrt(gx * gx + gy * gy)\n    thresh = np.percentile(grad_mag, 60) if np.any(grad_mag) else 0.0\n    strong = grad_mag > thresh\n    if not np.any(strong):\n        return 0.0\n    horiz = np.count_nonzero(strong & (np.abs(gy) > np.abs(gx)))\n    vert = np.count_nonzero(strong & (np.abs(gx) >= np.abs(gy)))\n    return float(horiz / (vert + 1e-8))\n\n", "def feature(image: np.ndarray) -> float:\n    'Ratio between the second and first tallest column peaks in the bottom third (leg separation indicator)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 50)\n    mask = ((gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)).astype(np.uint8)\n    start = int(h * (2.0 / 3.0))\n    bottom = mask[start:, :]\n    if bottom.size == 0:\n        return 0.0\n    col_sums = np.sum(bottom, axis=0).astype(float)\n    if np.all(col_sums == 0):\n        return 0.0\n    sorted_vals = np.sort(col_sums)[::-1]\n    first = float(sorted_vals[0])\n    second = float(sorted_vals[1]) if sorted_vals.size > 1 else 0.0\n    return float(second / (first + 1e-8))\n\n", "def feature(image: np.ndarray) -> float:\n    'Mean inter-channel standard deviation normalized by mean intensity (0 for grayscale)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    if len(image.shape) != 3 or image.shape[2] < 3:\n        return 0.0\n    # for RGB images compute per-pixel std across channels then average\n    img = image.astype(float)\n    per_pixel_std = np.std(img, axis=2)\n    mean_std = float(np.mean(per_pixel_std))\n    mean_intensity = float(np.mean(np.mean(img, axis=2)))\n    return float(mean_std / (mean_intensity + 1e-8))\n\n", "def feature(image: np.ndarray) -> float:\n    'Center texture minus corner texture (std in center region minus mean corner std) normalized'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 4 or w < 4:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    ch0, cw0 = h // 4, w // 4\n    center = gray[ch0:3*ch0, cw0:3*cw0]\n    if center.size == 0:\n        return 0.0\n    center_std = float(np.std(center))\n    # four corner patches\n    patch_h, patch_w = max(1, h // 8), max(1, w // 8)\n    corners = []\n    corners.append(gray[0:patch_h, 0:patch_w])\n    corners.append(gray[0:patch_h, -patch_w:])\n    corners.append(gray[-patch_h:, 0:patch_w])\n    corners.append(gray[-patch_h:, -patch_w:])\n    corner_stds = [float(np.std(p)) if p.size else 0.0 for p in corners]\n    mean_corner_std = float(np.mean(corner_stds))\n    denom = float(np.std(gray) + 1e-8)\n    return float((center_std - mean_corner_std) / denom)\n\n", "def feature(image: np.ndarray) -> float:\n    'Approximate perimeter-to-area ratio of the foreground mask (higher = more complex / thin shapes)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 50)\n    mask = ((gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)).astype(np.uint8)\n    area = float(np.count_nonzero(mask))\n    if area == 0.0:\n        return 0.0\n    # perimeter estimate: mask pixels that have any 4-neighbor background\n    up = np.zeros_like(mask); up[1:, :] = mask[:-1, :]\n    down = np.zeros_like(mask); down[:-1, :] = mask[1:, :]\n    left = np.zeros_like(mask); left[:, 1:] = mask[:, :-1]\n    right = np.zeros_like(mask); right[:, :-1] = mask[:, 1:]\n    neighbor_sum = up + down + left + right\n    boundary = np.logical_and(mask == 1, neighbor_sum < 4)\n    perimeter = float(np.count_nonzero(boundary))\n    return float(perimeter / (area + 1e-8))\n", "def feature(image: np.ndarray) -> float:\n    'Normalized bounding-box area of the foreground mask (0..1)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    idx = np.where(mask)\n    if idx[0].size == 0:\n        return 0.0\n    r0, r1 = int(np.min(idx[0])), int(np.max(idx[0]))\n    c0, c1 = int(np.min(idx[1])), int(np.max(idx[1]))\n    bbox_area = float((r1 - r0 + 1) * (c1 - c0 + 1))\n    img_area = float(max(1, h * w))\n    return float(bbox_area / img_area)\n\n", "def feature(image: np.ndarray) -> float:\n    'Average number of contiguous foreground segments per row (normalized by width)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    seg_counts = []\n    for r in range(h):\n        row = mask[r]\n        idx = np.where(row)[0]\n        if idx.size == 0:\n            continue\n        splits = np.where(np.diff(idx) > 1)[0]\n        nseg = 1 + splits.size\n        seg_counts.append(float(nseg))\n    if len(seg_counts) == 0:\n        return 0.0\n    avg_segs = float(np.mean(seg_counts))\n    return float(avg_segs / float(max(1, w)))\n\n", "def feature(image: np.ndarray) -> float:\n    'Ratio of mask mass in top third to bottom third (top_third / bottom_third)'\n    import numpy as np\n    if image is None:\n        return 1.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 1.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    t = max(1, h // 3)\n    top_mass = float(np.count_nonzero(mask[:t, :]))\n    bot_mass = float(np.count_nonzero(mask[h - t:, :]))\n    return float((top_mass + 1e-8) / (bot_mass + 1e-8))\n\n", "def feature(image: np.ndarray) -> float:\n    'Orientation concentration of strong edges (0..1, higher => more coherent orientation)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 2 or w < 2:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    gy, gx = np.gradient(gray.astype(float))\n    mag = np.sqrt(gx * gx + gy * gy)\n    if not np.any(mag):\n        return 0.0\n    thr = np.percentile(mag, 70)\n    strong = mag > thr\n    if not np.any(strong):\n        return 0.0\n    angles = np.arctan2(gy[strong], gx[strong])\n    # resultant vector length as orientation coherence (0..1)\n    c = np.mean(np.cos(angles))\n    s = np.mean(np.sin(angles))\n    R = np.sqrt(c * c + s * s)\n    return float(R)\n\n", "def feature(image: np.ndarray) -> float:\n    'Mean per-pixel color saturation (max-min across RGB channels), 0 for grayscale'\n    import numpy as np\n    if image is None:\n        return 0.0\n    if len(image.shape) != 3 or image.shape[2] < 3:\n        return 0.0\n    img = image.astype(float)\n    mx = np.max(img, axis=2)\n    mn = np.min(img, axis=2)\n    sat = mx - mn\n    # normalize by dynamic range if possible\n    denom = np.maximum(1.0, np.max(sat))\n    return float(np.mean(sat) / denom)\n\n", "def feature(image: np.ndarray) -> float:\n    'Mean (blue - red) channel value normalized (RGB images), 0 for grayscale'\n    import numpy as np\n    if image is None:\n        return 0.0\n    if len(image.shape) != 3 or image.shape[2] < 3:\n        return 0.0\n    img = image.astype(float)\n    b = img[:, :, 2]\n    r = img[:, :, 0]\n    diff = b - r\n    # normalize by maximum absolute channel range to keep in reasonable scale\n    norm = np.maximum(1.0, np.max(np.abs(diff)))\n    return float(np.mean(diff) / norm)\n\n", "def feature(image: np.ndarray) -> float:\n    'Fraction of foreground mask mass located in bottom 20% of image rows'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    total = float(np.count_nonzero(mask))\n    if total == 0:\n        return 0.0\n    cut = max(1, int(0.8 * h))\n    bottom_mass = float(np.count_nonzero(mask[cut:, :]))\n    return float(bottom_mass / total)\n\n", "def feature(image: np.ndarray) -> float:\n    'Aspect ratio (width / height) of the mask bounding box (1.0 if undefined)'\n    import numpy as np\n    if image is None:\n        return 1.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 1.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    idx = np.where(mask)\n    if idx[0].size == 0:\n        return 1.0\n    r0, r1 = int(np.min(idx[0])), int(np.max(idx[0]))\n    c0, c1 = int(np.min(idx[1])), int(np.max(idx[1]))\n    bbox_h = float(max(1, r1 - r0 + 1))\n    bbox_w = float(max(1, c1 - c0 + 1))\n    return float(bbox_w / bbox_h)\n\n", "def feature(image: np.ndarray) -> float:\n    'Mask compactness measured by isoperimetric ratio 4*pi*area / (perimeter^2) (0..~1)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    area = float(np.count_nonzero(mask))\n    if area == 0.0:\n        return 0.0\n    # approximate perimeter: mask pixels that have any 4-neighbor background\n    # pad to simplify edges\n    m = mask.astype(np.uint8)\n    pad = np.pad(m, ((1, 1), (1, 1)), mode='constant', constant_values=0)\n    perim = 0\n    perim += np.sum((pad[1:-1, 1:-1] == 1) & (pad[0:-2, 1:-1] == 0))\n    perim += np.sum((pad[1:-1, 1:-1] == 1) & (pad[2:, 1:-1] == 0))\n    perim += np.sum((pad[1:-1, 1:-1] == 1) & (pad[1:-1, 0:-2] == 0))\n    perim += np.sum((pad[1:-1, 1:-1] == 1) & (pad[1:-1, 2:] == 0))\n    perim = float(perim)\n    if perim <= 0.0:\n        return 0.0\n    iso = (4.0 * np.pi * area) / (perim * perim + 1e-12)\n    return float(iso)\n\n", "def feature(image: np.ndarray) -> float:\n    'Vertical projection peakiness: max row coverage divided by mean row coverage (>=1)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    row_counts = np.count_nonzero(mask, axis=1).astype(float)\n    if row_counts.size == 0:\n        return 0.0\n    mean_rc = float(np.mean(row_counts)) + 1e-8\n    max_rc = float(np.max(row_counts))\n    return float(max_rc / mean_rc)\n", "def feature(image: np.ndarray) -> float:\n    'Left-right symmetry of the foreground mask (1.0 = perfectly symmetric)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    # grayscale conversion\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    if not np.any(mask):\n        return 0.0\n    flipped = np.fliplr(mask)\n    # align sizes if odd widths (should be same)\n    diff = np.logical_xor(mask, flipped)\n    score = 1.0 - (np.mean(diff.astype(float)))\n    return float(score)\n\n", "def feature(image: np.ndarray) -> float:\n    'Count of small horizontal segments in the upper torso area (possible pockets/buttons)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 4 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    top_start = max(0, int(h * 0.10))\n    top_end = max(top_start + 1, int(h * 0.40))\n    region = mask[top_start:top_end, :]\n    if region.size == 0:\n        return 0.0\n    seg_count = 0\n    min_len = max(1, w // 30)\n    max_len = max(1, w // 3)\n    for row in region:\n        row_i = row.astype(int)\n        if not np.any(row_i):\n            continue\n        pad = np.concatenate(([0], row_i, [0]))\n        diff = np.diff(pad)\n        starts = np.where(diff == 1)[0]\n        ends = np.where(diff == -1)[0]\n        lengths = ends - starts\n        seg_count += int(np.sum((lengths >= min_len) & (lengths <= max_len)))\n    norm = float(max(1.0, (top_end - top_start)))\n    return float(seg_count / norm)\n\n", "def feature(image: np.ndarray) -> float:\n    'Colorfulness metric (higher for vivid colored items), 0 for grayscale inputs'\n    import numpy as np\n    if image is None:\n        return 0.0\n    if len(image.shape) != 3 or image.shape[2] != 3:\n        return 0.0\n    img = image.astype(float)\n    R = img[:, :, 0]\n    G = img[:, :, 1]\n    B = img[:, :, 2]\n    rg = R - G\n    yb = 0.5 * (R + G) - B\n    std_rg = float(np.std(rg))\n    std_yb = float(np.std(yb))\n    mean_rg = float(np.mean(rg))\n    mean_yb = float(np.mean(yb))\n    # Has been used in literature: colorfulness = sqrt(std^2 + mean^2) summed\n    col = np.sqrt(std_rg * std_rg + mean_rg * mean_rg) + np.sqrt(std_yb * std_yb + mean_yb * mean_yb)\n    # Normalize roughly by 255\n    return float(col / (255.0 + 1e-8))\n\n", "def feature(image: np.ndarray) -> float:\n    'Number of separate foreground islands touching the bottom band (helps detect two shoes)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 3 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    band_h = max(1, h * 20 // 100)\n    band = mask[-band_h:, :]\n    # collapse vertically: which columns have any mask in the bottom band\n    cols = np.any(band, axis=0)\n    if not np.any(cols):\n        return 0.0\n    pad = np.concatenate(([0], cols.astype(int), [0]))\n    diff = np.diff(pad)\n    starts = np.where(diff == 1)[0]\n    ends = np.where(diff == -1)[0]\n    islands = ends.size\n    # normalize by expected shoe count (max 4 for noise)\n    return float(min(islands, 4))\n\n", "def feature(image: np.ndarray) -> float:\n    'Relative sleeve/side extension: density in left+right quarters of upper half vs central upper half'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 4 or w < 4:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    top = mask[:max(1, h // 2), :]\n    if top.size == 0:\n        return 0.0\n    left = top[:, :max(1, w // 4)]\n    center = top[:, max(1, w // 4):max(1, (3 * w) // 4)]\n    right = top[:, max(1, (3 * w) // 4):]\n    left_density = float(np.mean(left.astype(float)))\n    right_density = float(np.mean(right.astype(float)))\n    center_density = float(np.mean(center.astype(float)))\n    score = (left_density + right_density) / (center_density + 1e-8)\n    return float(score)\n\n", "def feature(image: np.ndarray) -> float:\n    'Average absolute Laplacian magnitude inside mask (texture/roughness indicator)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 3 or w < 3:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    if not np.any(mask):\n        return 0.0\n    gy, gx = np.gradient(gray.astype(float))\n    gxx, _ = np.gradient(gx)\n    _, gyy = np.gradient(gy)\n    lap = np.abs(gxx + gyy)\n    val = np.mean(lap[mask])\n    return float(val / (np.mean(np.abs(gray)) + 1e-8))\n\n", "def feature(image: np.ndarray) -> float:\n    'Bounding-box aspect ratio of the detected foreground (height / width)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    ys, xs = np.where(mask)\n    if ys.size == 0:\n        return 0.0\n    ymin, ymax = int(np.min(ys)), int(np.max(ys))\n    xmin, xmax = int(np.min(xs)), int(np.max(xs))\n    bbox_h = float(max(1, (ymax - ymin + 1)))\n    bbox_w = float(max(1, (xmax - xmin + 1)))\n    return float(bbox_h / (bbox_w + 1e-8))\n\n", "def feature(image: np.ndarray) -> float:\n    'Vertical centroid (mean row index of mask) normalized by image height (0=top,1=bottom)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    ys, xs = np.where(mask)\n    if ys.size == 0:\n        return 0.0\n    mean_y = float(np.mean(ys))\n    return float(mean_y / float(h))\n\n", "def feature(image: np.ndarray) -> float:\n    'Fraction of columns that contain a long vertical strong edge streak (indicative of straps/long seams)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 3 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    gy, gx = np.gradient(gray.astype(float))\n    vert_mag = np.abs(gx)\n    if not np.any(vert_mag):\n        return 0.0\n    thr = np.percentile(vert_mag, 70)\n    strong = vert_mag > thr\n    min_run = max(1, int(h * 0.35))\n    col_count = 0\n    for c in range(w):\n        col = strong[:, c].astype(int)\n        if not np.any(col):\n            continue\n        # compute longest run of 1s in column\n        pad = np.concatenate(([0], col, [0]))\n        diff = np.diff(pad)\n        starts = np.where(diff == 1)[0]\n        ends = np.where(diff == -1)[0]\n        lengths = ends - starts\n        if lengths.size > 0 and np.max(lengths) >= min_run:\n            col_count += 1\n    return float(col_count / float(w + 1e-8))\n\n", "def feature(image: np.ndarray) -> float:\n    'Fraction of bounding-box pixels occupied by foreground (solidness of the object)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    ys, xs = np.where(mask)\n    if ys.size == 0:\n        return 0.0\n    ymin, ymax = int(np.min(ys)), int(np.max(ys))\n    xmin, xmax = int(np.min(xs)), int(np.max(xs))\n    bbox_area = float(max(1, (ymax - ymin + 1)) * max(1, (xmax - xmin + 1)))\n    fill = float(np.count_nonzero(mask[ymin:ymax+1, xmin:xmax+1]))\n    return float(fill / (bbox_area + 1e-8))\n", "def feature(image: np.ndarray) -> float:\n    'Bounding box height-to-width ratio of the foreground mask (taller -> larger)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    # grayscale\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask_dark = gray < thr\n    mask_bright = gray > thr\n    mask = mask_dark if np.count_nonzero(mask_dark) >= np.count_nonzero(mask_bright) else mask_bright\n    ys, xs = np.where(mask)\n    if ys.size == 0:\n        return 0.0\n    miny, maxy = int(ys.min()), int(ys.max())\n    minx, maxx = int(xs.min()), int(xs.max())\n    bbox_h = maxy - miny + 1\n    bbox_w = maxx - minx + 1\n    if bbox_w <= 0:\n        return 0.0\n    return float(bbox_h / float(bbox_w))\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Fraction of image area covered by mask (global mask area / image area)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    area_img = float(max(1, h * w))\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask_dark = gray < thr\n    mask_bright = gray > thr\n    mask = mask_dark if np.count_nonzero(mask_dark) >= np.count_nonzero(mask_bright) else mask_bright\n    mask_area = float(np.count_nonzero(mask))\n    return float(mask_area / area_img)\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Normalized vertical centroid of foreground mask (0=top, 1=bottom)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h <= 1 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    ys, xs = np.where(mask)\n    if ys.size == 0:\n        return 0.0\n    centroid_y = float(np.mean(ys))\n    return float(centroid_y / float(h - 1))\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Fraction of foreground mass located in the bottom 20% of the image'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    bottom_h = max(1, int(h * 0.20))\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    total = float(np.count_nonzero(mask))\n    if total == 0.0:\n        return 0.0\n    bottom_count = float(np.count_nonzero(mask[-bottom_h:, :]))\n    return float(bottom_count / total)\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Horizontal flip Jaccard overlap: left-right shape symmetry (higher = more symmetric)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 50)\n    mask_dark = gray < thr\n    mask_bright = gray > thr\n    mask = mask_dark if np.count_nonzero(mask_dark) >= np.count_nonzero(mask_bright) else mask_bright\n    if not np.any(mask):\n        return 0.0\n    flipped = np.fliplr(mask)\n    inter = np.count_nonzero(mask & flipped)\n    union = np.count_nonzero(mask | flipped)\n    if union == 0:\n        return 0.0\n    return float(inter / union)\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Color channel spread: (max channel mean - min channel mean) normalized by overall mean (0 for grayscale)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    if len(image.shape) != 3:\n        return 0.0\n    # compute per-channel mean\n    ch_means = [float(np.mean(image[:, :, i])) for i in range(image.shape[2])]\n    mn = min(ch_means)\n    mx = max(ch_means)\n    overall = float(np.mean(ch_means)) + 1e-8\n    return float((mx - mn) / overall)\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Principal-axis elongation of the mask: ratio of largest to smallest eigenvalue of pixel covariance'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    ys, xs = np.where(mask)\n    n = ys.size\n    if n <= 1:\n        return 0.0\n    # coordinates centered\n    cy = np.mean(ys)\n    cx = np.mean(xs)\n    dy = ys - cy\n    dx = xs - cx\n    cov_yy = np.mean(dy * dy)\n    cov_xx = np.mean(dx * dx)\n    cov_xy = np.mean(dx * dy)\n    cov = np.array([[cov_yy, cov_xy], [cov_xy, cov_xx]], dtype=float)\n    # eigenvalues\n    vals = np.linalg.eigvalsh(cov)  # sorted ascending\n    small = float(max(vals[0], 1e-12))\n    large = float(max(vals[1], small))\n    ratio = large / small\n    return float(ratio)\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Center vs border edge energy: average gradient magnitude in center region divided by border region'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 3 or w < 3:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    gy, gx = np.gradient(gray.astype(float))\n    grad = np.sqrt(gx * gx + gy * gy)\n    # define center as middle 50% both axes\n    r0, r1 = h // 4, (3 * h) // 4\n    c0, c1 = w // 4, (3 * w) // 4\n    center = grad[r0:r1, c0:c1]\n    # border is outside that center\n    border_mask = np.ones_like(grad, dtype=bool)\n    border_mask[r0:r1, c0:c1] = False\n    border = grad[border_mask]\n    if center.size == 0 or border.size == 0:\n        return 0.0\n    cen_mean = float(np.mean(center))\n    bor_mean = float(np.mean(border)) + 1e-8\n    return float(cen_mean / bor_mean)\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Coefficient of variation of mask width per row (std / mean of row widths)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    row_widths = np.sum(mask, axis=1).astype(float)\n    if row_widths.size == 0:\n        return 0.0\n    mean_w = float(np.mean(row_widths))\n    std_w = float(np.std(row_widths))\n    if mean_w <= 1e-8:\n        return 0.0\n    return float(std_w / mean_w)\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Top-edge variability: normalized standard deviation of topmost mask row positions across columns'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    # for each column find topmost mask row (or -1 if none)\n    top_rows = np.full(w, -1, dtype=int)\n    # compute any per column\n    cols_any = np.any(mask, axis=0)\n    if not np.any(cols_any):\n        return 0.0\n    for j in range(w):\n        if cols_any[j]:\n            col = mask[:, j]\n            top_rows[j] = int(np.argmax(col))\n    valid = top_rows[top_rows >= 0].astype(float)\n    if valid.size == 0:\n        return 0.0\n    std_top = float(np.std(valid))\n    return float(std_top / float(max(1, h)))\n", "def feature(image: np.ndarray) -> float:\n    'Mean color saturation (approx) for RGB images, 0 for grayscale'\n    import numpy as np\n    if image is None:\n        return 0.0\n    if len(image.shape) != 3 or image.shape[2] < 3:\n        return 0.0\n    # compute per-pixel saturation = (max-min)/(max+eps)\n    img = image.astype(float)\n    mx = np.max(img, axis=2)\n    mn = np.min(img, axis=2)\n    denom = np.maximum(mx, 1e-8)\n    sat = (mx - mn) / denom\n    return float(np.mean(sat))\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Ratio of mask pixels in upper half to lower half of image'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    upper = np.count_nonzero(mask[:h//2, :])\n    lower = np.count_nonzero(mask[h//2:, :])\n    return float(upper / (lower + 1e-8))\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Left-versus-right mask imbalance: (left_frac - right_frac) in [-1,1]'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    left = np.count_nonzero(mask[:, :w//3])\n    right = np.count_nonzero(mask[:, -w//3:]) if w//3 > 0 else 0\n    total = left + right + 1e-8\n    val = (left - right) / total\n    # clamp\n    if val < -1.0:\n        val = -1.0\n    if val > 1.0:\n        val = 1.0\n    return float(val)\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Mask extent: fraction of bounding box area filled by mask (compactness)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    ys, xs = np.where(mask)\n    if ys.size == 0:\n        return 0.0\n    miny, maxy = ys.min(), ys.max()\n    minx, maxx = xs.min(), xs.max()\n    bbox_area = float((maxy - miny + 1) * (maxx - minx + 1))\n    mask_area = float(ys.size)\n    return float(mask_area / (bbox_area + 1e-8))\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Average longest vertical run of mask pixels per column normalized by image height'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h <= 0 or w <= 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = ((gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)).astype(np.uint8)\n    longest = []\n    # iterate over columns (usually small)\n    for x in range(w):\n        col = mask[:, x]\n        max_run = 0\n        run = 0\n        for v in col:\n            if v:\n                run += 1\n                if run > max_run:\n                    max_run = run\n            else:\n                run = 0\n        longest.append(max_run)\n    if len(longest) == 0:\n        return 0.0\n    mean_long = float(np.mean(longest))\n    return float(mean_long / (h + 1e-8))\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Average longest horizontal run of mask pixels per row normalized by image width'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h <= 0 or w <= 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = ((gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)).astype(np.uint8)\n    longest = []\n    for y in range(h):\n        row = mask[y, :]\n        max_run = 0\n        run = 0\n        for v in row:\n            if v:\n                run += 1\n                if run > max_run:\n                    max_run = run\n            else:\n                run = 0\n        longest.append(max_run)\n    if len(longest) == 0:\n        return 0.0\n    mean_long = float(np.mean(longest))\n    return float(mean_long / (w + 1e-8))\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Density of strong edges in the lower quarter of the image (edges per pixel)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 2 or w < 2:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    gy, gx = np.gradient(gray.astype(float))\n    mag = np.sqrt(gx*gx + gy*gy)\n    if not np.any(mag):\n        return 0.0\n    thr = np.percentile(mag, 70)\n    strong = mag > thr\n    start_row = int(3 * h / 4)\n    lower_strong = np.count_nonzero(strong[start_row:, :])\n    lower_area = float(max(1, (h - start_row) * w))\n    return float(lower_strong / lower_area)\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Mean absolute Laplacian-like second-derivative normalized by mean gradient (texture measure)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 3 or w < 3:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    gy, gx = np.gradient(gray)\n    gxx = np.gradient(gx, axis=1)\n    gyy = np.gradient(gy, axis=0)\n    lap = gxx + gyy\n    mean_abs_lap = float(np.mean(np.abs(lap)))\n    mean_grad = float(np.mean(np.sqrt(gx*gx + gy*gy)))\n    return float(mean_abs_lap / (mean_grad + 1e-8))\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Mean radial distance of mask pixels to mask centroid normalized by image diagonal'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    ys, xs = np.where(mask)\n    if ys.size == 0:\n        return 0.0\n    cy = float(np.mean(ys))\n    cx = float(np.mean(xs))\n    d = np.sqrt((ys - cy)**2 + (xs - cx)**2)\n    mean_d = float(np.mean(d))\n    diag = np.sqrt(float(h*h + w*w))\n    return float(mean_d / (diag + 1e-8))\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Bounding-box aspect ratio of the masked object (height/width), 0 if no mask'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    ys, xs = np.where(mask)\n    if ys.size == 0:\n        return 0.0\n    miny, maxy = ys.min(), ys.max()\n    minx, maxx = xs.min(), xs.max()\n    bbox_h = float(maxy - miny + 1)\n    bbox_w = float(maxx - minx + 1)\n    if bbox_w <= 1e-8:\n        return float(bbox_h)\n    return float(bbox_h / bbox_w)\n", "def feature(image: np.ndarray) -> float:\n    'Fraction of detected foreground mass located in the top 30% of image rows'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    # grayscale conversion\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 50)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    total = float(np.count_nonzero(mask))\n    if total == 0.0:\n        return 0.0\n    cut = max(1, int(0.3 * h))\n    top_mass = float(np.count_nonzero(mask[:cut, :]))\n    return float(top_mass / total)\n\n", "def feature(image: np.ndarray) -> float:\n    'Normalized horizontal centroid offset (positive => object more to the right)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 50)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    total = np.count_nonzero(mask)\n    if total == 0:\n        return 0.0\n    xs = np.arange(w).reshape(1, w)\n    cx = float(np.sum(mask * xs) / float(total))\n    center_x = (w - 1) / 2.0\n    return float((cx - center_x) / max(1.0, w / 2.0))\n\n", "def feature(image: np.ndarray) -> float:\n    'Estimated number of separate horizontal blobs in the lower half (useful for two-shoe blobs)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 2 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 60)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    half = h // 2\n    region = mask[half:, :]\n    if region.size == 0:\n        return 0.0\n    # column projection\n    col_proj = np.count_nonzero(region, axis=0) > 0\n    # count connected True segments in projection\n    if not np.any(col_proj):\n        return 0.0\n    diffs = np.diff(col_proj.astype(int))\n    starts = np.count_nonzero(diffs == 1) + (1 if col_proj[0] else 0)\n    # limit to reasonable max\n    return float(min(10, starts))\n\n", "def feature(image: np.ndarray) -> float:\n    'Fraction of image rows that contain a strong horizontal edge concentration'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 3 or w < 3:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    gy, gx = np.gradient(gray.astype(float))\n    # gy corresponds to changes along rows => horizontal edges\n    row_edge_strength = np.mean(np.abs(gy), axis=1)\n    thresh = np.percentile(row_edge_strength, 70) if np.any(row_edge_strength) else 0.0\n    strong_rows = np.count_nonzero(row_edge_strength > thresh)\n    return float(strong_rows / float(h))\n\n", "def feature(image: np.ndarray) -> float:\n    'Mean per-pixel color channel spread (mean of max(channel)-min(channel)), 0 for grayscale'\n    import numpy as np\n    if image is None:\n        return 0.0\n    if len(image.shape) != 3 or image.shape[2] < 3:\n        return 0.0\n    img = image.astype(float)\n    spread = np.max(img, axis=2) - np.min(img, axis=2)\n    return float(np.mean(spread))\n\n", "def feature(image: np.ndarray) -> float:\n    'Ratio of mask width near the top (10%) to width near the bottom (85%) of the image'\n    import numpy as np\n    if image is None:\n        return 1.0\n    h, w = image.shape[:2]\n    if h < 4 or w == 0:\n        return 1.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    def avg_width_at_frac(frac):\n        row = int(min(h - 1, max(0, int(frac * h))))\n        band = max(1, h // 60)\n        start = max(0, row - band)\n        end = min(h, row + band + 1)\n        widths = np.sum(mask[start:end, :].astype(float), axis=1)\n        if widths.size == 0:\n            return 1.0\n        return float(np.mean(widths)) + 1e-8\n    top_w = avg_width_at_frac(0.10)\n    bot_w = avg_width_at_frac(0.85)\n    return float(top_w / (bot_w + 1e-8))\n\n", "def feature(image: np.ndarray) -> float:\n    'Approximate mask solidity: mask area divided by bounding-box area (0 if no mask)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 50)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    ys, xs = np.where(mask)\n    if ys.size == 0:\n        return 0.0\n    mask_area = float(ys.size)\n    bbox_w = float(xs.max() - xs.min() + 1)\n    bbox_h = float(ys.max() - ys.min() + 1)\n    bbox_area = bbox_w * bbox_h\n    if bbox_area <= 0.0:\n        return 0.0\n    return float(mask_area / (bbox_area + 1e-12))\n\n", "def feature(image: np.ndarray) -> float:\n    'Maximum vertical continuous mask run in any column normalized by image height'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    if not np.any(mask):\n        return 0.0\n    max_run = 0\n    # vectorized-ish per column: compute diffs to detect runs\n    for col in range(w):\n        col_vec = mask[:, col].astype(int)\n        if not np.any(col_vec):\n            continue\n        diffs = np.diff(np.concatenate(([0], col_vec, [0])))\n        starts = np.where(diffs == 1)[0]\n        ends = np.where(diffs == -1)[0]\n        if starts.size and ends.size:\n            runs = ends - starts\n            max_run = max(max_run, int(np.max(runs)))\n    return float(max_run / float(h))\n\n", "def feature(image: np.ndarray) -> float:\n    'Normalized average length of background gaps in center columns near the top (neckline-like gaps)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 4 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 50)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    top_rows = max(1, int(0.35 * h))\n    center_cols = slice(max(0, w//2 - max(1, w//10)), min(w, w//2 + max(1, w//10)))\n    region = mask[:top_rows, center_cols]\n    if region.size == 0:\n        return 0.0\n    # for each center column, measure longest consecutive zeros (background) that lies between mask segments\n    bg_gaps = []\n    for c in range(region.shape[1]):\n        col = region[:, c].astype(int)\n        if np.all(col == 0):\n            bg_gaps.append(region.shape[0])\n            continue\n        diffs = np.diff(np.concatenate(([0], col, [0])))\n        starts = np.where(diffs == 1)[0]\n        ends = np.where(diffs == -1)[0]\n        # background segments are between mask segments: find zero stretches between ones\n        zero_runs = []\n        prev_end = None\n        for s, e in zip(starts, ends):\n            if prev_end is None:\n                prev_end = e\n                continue\n            # gap between prev_end and next start\n            gap = s - prev_end\n            if gap > 0:\n                zero_runs.append(gap)\n            prev_end = e\n        if zero_runs:\n            bg_gaps.append(max(zero_runs))\n        else:\n            bg_gaps.append(0)\n    if len(bg_gaps) == 0:\n        return 0.0\n    avg_gap = float(np.mean(bg_gaps))\n    return float(avg_gap / float(top_rows))\n\n", "def feature(image: np.ndarray) -> float:\n    'Mean local 3x3 standard deviation inside the detected foreground mask normalized by global std'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 3 or w < 3:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    global_std = float(np.std(gray)) + 1e-8\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    if not np.any(mask):\n        return 0.0\n    # pad and compute 3x3 neighborhood sum and sumsq via shifted sums\n    p = np.pad(gray, ((1, 1), (1, 1)), mode='reflect')\n    s = (p[:-2, :-2] + p[:-2, 1:-1] + p[:-2, 2:] +\n         p[1:-1, :-2] + p[1:-1, 1:-1] + p[1:-1, 2:] +\n         p[2:, :-2] + p[2:, 1:-1] + p[2:, 2:])\n    sq = p * p\n    sqs = (sq[:-2, :-2] + sq[:-2, 1:-1] + sq[:-2, 2:] +\n           sq[1:-1, :-2] + sq[1:-1, 1:-1] + sq[1:-1, 2:] +\n           sq[2:, :-2] + sq[2:, 1:-1] + sq[2:, 2:])\n    mean3 = s / 9.0\n    var3 = (sqs / 9.0) - (mean3 * mean3)\n    var3 = np.maximum(var3, 0.0)\n    std3 = np.sqrt(var3)\n    # average std inside mask\n    mean_inside = float(np.sum(std3 * mask) / (np.count_nonzero(mask) + 1e-12))\n    return float(mean_inside / global_std)\n", "def feature(image: np.ndarray) -> float:\n    'Maximum continuous vertical run of object pixels in any column, normalized by image height'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 50)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    max_run = 0\n    for c in range(w):\n        col = mask[:, c]\n        # scan for longest True run\n        cur = 0\n        best = 0\n        for val in col:\n            if val:\n                cur += 1\n                if cur > best:\n                    best = cur\n            else:\n                cur = 0\n        if best > max_run:\n            max_run = best\n    if h <= 0:\n        return 0.0\n    return float(max_run / (h + 1e-8))\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Normalized vertical centroid of the detected object mask (0=top,1=bottom)'\n    import numpy as np\n    if image is None:\n        return 0.5\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.5\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    total = float(np.count_nonzero(mask))\n    if total == 0:\n        return 0.5\n    ys = np.arange(h).astype(float)[:, None]\n    cy = float(np.sum(ys * mask) / (total + 1e-8))\n    return float(np.clip(cy / float(h), 0.0, 1.0))\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Average number of vertical transitions (background<->foreground) per column normalized by height'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h <= 1 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 50)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    transitions = 0.0\n    for c in range(w):\n        col = mask[:, c].astype(int)\n        transitions += float(np.sum(np.abs(np.diff(col))))\n    avg_trans = transitions / float(w + 1e-8)\n    return float(avg_trans / (h + 1e-8))\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Mean normalized red-minus-blue channel difference (RGB only), grayscale -> 0'\n    import numpy as np\n    if image is None:\n        return 0.0\n    if len(image.shape) != 3 or image.shape[2] < 3:\n        return 0.0\n    img = image.astype(float)\n    r = np.mean(img[:, :, 0])\n    g = np.mean(img[:, :, 1])\n    b = np.mean(img[:, :, 2])\n    denom = (np.mean(img) + 1e-8)\n    return float((r - b) / denom)\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Normalized mean absolute Laplacian (second derivative) as a texture roughness measure'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 2 or w < 2:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    gy, gx = np.gradient(gray)\n    gyy, gyx = np.gradient(gy)\n    gxy, gxx = np.gradient(gx)\n    lap = gxx + gyy\n    denom = (np.mean(np.abs(gray)) + 1e-8)\n    return float(np.mean(np.abs(lap)) / denom)\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Fraction of object pixels that lie in the lower half of the image'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    total = np.count_nonzero(mask)\n    if total == 0:\n        return 0.0\n    lower = mask[h//2:, :]\n    lower_count = np.count_nonzero(lower)\n    return float(lower_count / (total + 1e-8))\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Normalized top-bottom asymmetry: mean absolute difference between image and its vertical flip'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    flipped = np.flipud(gray)\n    diff = np.abs(gray - flipped)\n    denom = np.mean(np.abs(gray)) + 1e-8\n    return float(np.mean(diff) / denom)\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Ratio of corner-like pixels to strong-edge pixels (cornerness), 0 if no strong edges'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 2 or w < 2:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    gy, gx = np.gradient(gray.astype(float))\n    grad_mag = np.sqrt(gx * gx + gy * gy)\n    if not np.any(grad_mag):\n        return 0.0\n    thresh = np.percentile(grad_mag, 65)\n    strong = grad_mag > thresh\n    if not np.any(strong):\n        return 0.0\n    # corner-like when both |gx| and |gy| are large relative to grad_mag\n    corner_mask = strong & (np.abs(gx) > 0.4 * grad_mag) & (np.abs(gy) > 0.4 * grad_mag)\n    return float(np.count_nonzero(corner_mask) / (np.count_nonzero(strong) + 1e-8))\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Fraction of mask pixels that lie within a central circle (radius = min(h,w)/4)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    cy = (h - 1) / 2.0\n    cx = (w - 1) / 2.0\n    rr = min(h, w) / 4.0\n    ys = np.arange(h).astype(float)[:, None]\n    xs = np.arange(w).astype(float)[None, :]\n    dist2 = (ys - cy) ** 2 + (xs - cx) ** 2\n    circle = dist2 <= (rr * rr + 1e-8)\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    total = np.count_nonzero(mask)\n    if total == 0:\n        return 0.0\n    inside = np.count_nonzero(mask & circle)\n    return float(inside / (total + 1e-8))\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Standard deviation of mean mask widths across vertical quartiles normalized by mean width'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    quart = max(1, h // 4)\n    means = []\n    for i in range(4):\n        start = i * quart\n        end = h if i == 3 else (i + 1) * quart\n        region = mask[start:end, :]\n        if region.size == 0:\n            means.append(0.0)\n        else:\n            means.append(float(np.mean(np.sum(region.astype(float), axis=1))))\n    means = np.array(means)\n    mean_all = float(np.mean(means)) + 1e-8\n    return float(np.std(means) / mean_all)\n", "def feature(image: np.ndarray) -> float:\n    'Left-right symmetry of the foreground mask (IoU with horizontally flipped mask)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = float(np.median(gray)) if np.any(gray >= 0) else 0.0\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    if not np.any(mask):\n        return 0.0\n    flipped = np.fliplr(mask)\n    inter = np.count_nonzero(mask & flipped)\n    union = np.count_nonzero(mask | flipped)\n    if union == 0:\n        return 0.0\n    return float(inter / union)\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Aspect ratio (width / height) of the foreground bounding box'\n    import numpy as np\n    if image is None:\n        return 1.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 1.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.mean(gray) if np.any(gray >= 0) else 0.0\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    ys, xs = np.where(mask)\n    if xs.size == 0 or ys.size == 0:\n        return 1.0\n    xmin, xmax = int(np.min(xs)), int(np.max(xs))\n    ymin, ymax = int(np.min(ys)), int(np.max(ys))\n    bw = float(xmax - xmin + 1)\n    bh = float(ymax - ymin + 1)\n    if bh <= 1e-8:\n        return float(bw)\n    return float(bw / bh)\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Normalized vertical center of mass of foreground mask (0=top, 1=bottom)'\n    import numpy as np\n    if image is None:\n        return 0.5\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.5\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 50)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    ys, xs = np.where(mask)\n    if ys.size == 0:\n        return 0.5\n    center_y = float(np.mean(ys))\n    return float(center_y / max(1.0, (h - 1)))\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Fraction of pixels that look like corners (both |gx| and |gy| large)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 2 or w < 2:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    gy, gx = np.gradient(gray.astype(float))\n    abs_gx = np.abs(gx)\n    abs_gy = np.abs(gy)\n    thresh_x = np.percentile(abs_gx, 70) if np.any(abs_gx) else 0.0\n    thresh_y = np.percentile(abs_gy, 70) if np.any(abs_gy) else 0.0\n    corners = (abs_gx > thresh_x) & (abs_gy > thresh_y)\n    total = float(h * w)\n    return float(np.count_nonzero(corners) / (total + 1e-8))\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Fraction of foreground pixels that lie in the bottom 25% of the image'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 50)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    total = np.count_nonzero(mask)\n    if total == 0:\n        return 0.0\n    bottom_start = max(0, int(h * 3 // 4))\n    bottom_mask = mask[bottom_start:, :]\n    bottom_count = np.count_nonzero(bottom_mask)\n    return float(bottom_count / float(total))\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Ratio of edge density in lower half to upper half ( >1 means more edges lower )'\n    import numpy as np\n    if image is None:\n        return 1.0\n    h, w = image.shape[:2]\n    if h < 2 or w < 2:\n        return 1.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    gy, gx = np.gradient(gray.astype(float))\n    grad_mag = np.sqrt(gx * gx + gy * gy)\n    thresh = np.percentile(grad_mag, 60) if np.any(grad_mag) else 0.0\n    strong = grad_mag > thresh\n    mid = h // 2\n    upper_count = np.count_nonzero(strong[:mid, :])\n    lower_count = np.count_nonzero(strong[mid:, :])\n    upper_area = float(max(1, mid * w))\n    lower_area = float(max(1, (h - mid) * w))\n    upper_density = upper_count / upper_area\n    lower_density = lower_count / lower_area\n    return float((lower_density + 1e-8) / (upper_density + 1e-8))\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Dominant color channel ratio (mean max channel / mean min channel), 1.0 for grayscale'\n    import numpy as np\n    if image is None:\n        return 1.0\n    if len(image.shape) != 3 or image.shape[2] < 3:\n        return 1.0\n    h, w, c = image.shape\n    if h == 0 or w == 0:\n        return 1.0\n    r = np.mean(image[:, :, 0].astype(float))\n    g = np.mean(image[:, :, 1].astype(float))\n    b = np.mean(image[:, :, 2].astype(float))\n    mx = max(r, g, b)\n    mn = min(r, g, b)\n    if mn <= 1e-8:\n        return float(mx / (mn + 1e-8))\n    return float(mx / mn)\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Average fraction of empty (background) pixels inside the foreground bounding box per row'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 50)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    ys, xs = np.where(mask)\n    if xs.size == 0 or ys.size == 0:\n        return 0.0\n    ymin, ymax = int(np.min(ys)), int(np.max(ys))\n    xmin, xmax = int(np.min(xs)), int(np.max(xs))\n    bbox = mask[ymin:ymax+1, xmin:xmax+1]\n    if bbox.size == 0:\n        return 0.0\n    row_empty_frac = np.mean(np.sum(~bbox, axis=1).astype(float) / float(max(1, bbox.shape[1])))\n    return float(row_empty_frac)\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Shoulder protrusion score: average lateral protrusion of mask edges in the upper 20% rows'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 4 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 50)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    top_h = max(1, h * 20 // 100)\n    rows = mask[:top_h, :]\n    if rows.size == 0:\n        return 0.0\n    xs = np.arange(w)\n    left_idx = np.full(rows.shape[0], w, dtype=int)\n    right_idx = np.full(rows.shape[0], -1, dtype=int)\n    for i in range(rows.shape[0]):\n        cols = np.where(rows[i, :])[0]\n        if cols.size > 0:\n            left_idx[i] = int(cols[0])\n            right_idx[i] = int(cols[-1])\n    valid = (right_idx >= 0)\n    if not np.any(valid):\n        return 0.0\n    center = w / 2.0\n    protrusion = ((center - left_idx[valid]) + (right_idx[valid] - center)) / 2.0\n    norm = w / 2.0\n    score = np.mean(protrusion / (norm + 1e-8))\n    return float(score)\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Compactness approx: perimeter^2 / area using 4-neighborhood perimeter estimate'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 50)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    area = float(np.count_nonzero(mask))\n    if area <= 0:\n        return 0.0\n    # perimeter: mask pixels that have at least one 4-neighbor background\n    up = np.zeros_like(mask); up[1:, :] = mask[:-1, :]\n    down = np.zeros_like(mask); down[:-1, :] = mask[1:, :]\n    left = np.zeros_like(mask); left[:, 1:] = mask[:, :-1]\n    right = np.zeros_like(mask); right[:, :-1] = mask[:, 1:]\n    neighbor_all = up & down & left & right\n    border_pixels = mask & (~neighbor_all)\n    perimeter = float(np.count_nonzero(border_pixels))\n    return float((perimeter * perimeter) / (area + 1e-8))\n", "def feature(image: np.ndarray) -> float:\n    'Left-right symmetry of the foreground mask (1.0 = perfect symmetry)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 50)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    if not np.any(mask):\n        return 0.0\n    # align halves (if odd width, ignore middle column)\n    mid = w // 2\n    left = mask[:, :mid]\n    right = mask[:, w - mid:][:, ::-1]\n    # compute Jaccard-like overlap\n    inter = np.count_nonzero(left & right)\n    union = np.count_nonzero(left | right)\n    if union == 0:\n        return 1.0\n    return float(inter / union)\n\n", "def feature(image: np.ndarray) -> float:\n    'Aspect ratio (width / height) of the foreground bounding box (1.0 if undefined)'\n    import numpy as np\n    if image is None:\n        return 1.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 1.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    ys, xs = np.where(mask)\n    if ys.size == 0:\n        return 1.0\n    miny, maxy = int(np.min(ys)), int(np.max(ys))\n    minx, maxx = int(np.min(xs)), int(np.max(xs))\n    bbox_h = maxy - miny + 1\n    bbox_w = maxx - minx + 1\n    if bbox_h <= 0:\n        return 1.0\n    return float(bbox_w / float(bbox_h))\n\n", "def feature(image: np.ndarray) -> float:\n    'Fraction of image pixels belonging to the foreground mask (0..1)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 50)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    area = float(np.count_nonzero(mask))\n    return float(area / float(h * w + 1e-12))\n\n", "def feature(image: np.ndarray) -> float:\n    'Ratio of foreground mass in the top third of the image (0..1)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 50)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    if not np.any(mask):\n        return 0.0\n    top_cut = max(1, h // 3)\n    top_area = np.count_nonzero(mask[:top_cut, :])\n    total_area = np.count_nonzero(mask)\n    return float(top_area / float(total_area + 1e-12))\n\n", "def feature(image: np.ndarray) -> float:\n    'Solidity surrogate: foreground area divided by bounding-box area (0..1)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    ys, xs = np.where(mask)\n    if ys.size == 0:\n        return 0.0\n    miny, maxy = int(np.min(ys)), int(np.max(ys))\n    minx, maxx = int(np.min(xs)), int(np.max(xs))\n    bbox_area = float((maxy - miny + 1) * (maxx - minx + 1))\n    if bbox_area <= 0:\n        return 0.0\n    area = float(ys.size)\n    return float(min(1.0, area / (bbox_area + 1e-12)))\n\n", "def feature(image: np.ndarray) -> float:\n    'Number of connected foreground components in the bottom quarter (small integer)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask_full = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    start_row = (3 * h) // 4\n    mask = np.zeros_like(mask_full, dtype=bool)\n    mask[start_row:, :] = mask_full[start_row:, :]\n    visited = np.zeros_like(mask, dtype=bool)\n    comps = 0\n    for y in range(start_row, h):\n        for x in range(w):\n            if mask[y, x] and not visited[y, x]:\n                comps += 1\n                # flood fill limited to bottom area\n                stack = [(y, x)]\n                visited[y, x] = True\n                while stack:\n                    cy, cx = stack.pop()\n                    if cy > start_row and mask[cy - 1, cx] and not visited[cy - 1, cx]:\n                        visited[cy - 1, cx] = True\n                        stack.append((cy - 1, cx))\n                    if cy + 1 < h and mask[cy + 1, cx] and not visited[cy + 1, cx]:\n                        visited[cy + 1, cx] = True\n                        stack.append((cy + 1, cx))\n                    if cx > 0 and mask[cy, cx - 1] and not visited[cy, cx - 1]:\n                        visited[cy, cx - 1] = True\n                        stack.append((cy, cx - 1))\n                    if cx + 1 < w and mask[cy, cx + 1] and not visited[cy, cx + 1]:\n                        visited[cy, cx + 1] = True\n                        stack.append((cy, cx + 1))\n                if comps > 50:\n                    break\n        if comps > 50:\n            break\n    return float(comps)\n\n", "def feature(image: np.ndarray) -> float:\n    'Colorfulness measure for RGB images (0 for grayscale), higher = more colorful'\n    import numpy as np\n    if image is None:\n        return 0.0\n    if len(image.shape) != 3 or image.shape[2] != 3:\n        return 0.0\n    img = image.astype(float)\n    R = img[:, :, 0]\n    G = img[:, :, 1]\n    B = img[:, :, 2]\n    rg = R - G\n    yb = 0.5 * (R + G) - B\n    std_rg = float(np.std(rg))\n    std_yb = float(np.std(yb))\n    mean_rg = float(np.mean(rg))\n    mean_yb = float(np.mean(yb))\n    colorfulness = np.sqrt(std_rg**2 + std_yb**2) + 0.3 * np.sqrt(mean_rg**2 + mean_yb**2)\n    return float(colorfulness)\n\n", "def feature(image: np.ndarray) -> float:\n    'Vertical coverage ratio: fraction of rows that contain any foreground pixel'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 50)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    if h == 0:\n        return 0.0\n    rows_with = np.count_nonzero(np.any(mask, axis=1))\n    return float(rows_with / float(h))\n\n", "def feature(image: np.ndarray) -> float:\n    'Perimeter-to-area ratio of the foreground mask (higher => more complex outline)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    area = float(np.count_nonzero(mask))\n    if area == 0.0:\n        return 0.0\n    # pad mask to avoid wrap-around from np.roll\n    pad = np.pad(mask, ((1, 1), (1, 1)), mode='constant', constant_values=False)\n    inner = pad[1:-1, 1:-1]\n    up = pad[:-2, 1:-1]\n    down = pad[2:, 1:-1]\n    left = pad[1:-1, :-2]\n    right = pad[1:-1, 2:]\n    boundary = inner & (~up | ~down | ~left | ~right)\n    perimeter = float(np.count_nonzero(boundary))\n    return float(perimeter / (area + 1e-12))\n\n", "def feature(image: np.ndarray) -> float:\n    'Mean gradient magnitude inside the foreground mask normalized by image diagonal'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 2 or w < 2:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    gy, gx = np.gradient(gray.astype(float))\n    mag = np.sqrt(gx * gx + gy * gy)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    if not np.any(mask):\n        return 0.0\n    mean_mag = float(np.mean(mag[mask]))\n    diag = np.sqrt(float(h * h + w * w))\n    return float(mean_mag / (diag + 1e-8))\n", "def feature(image: np.ndarray) -> float:\n    'Colorfulness metric based on rg and yb channels (Hasler-S\u00fcsstrunk style)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h_w = image.shape[:2]\n    if h_w[0] == 0 or h_w[1] == 0:\n        return 0.0\n    if len(image.shape) == 3 and image.shape[2] >= 3:\n        img = image.astype(float)\n        R = img[:, :, 0]\n        G = img[:, :, 1]\n        B = img[:, :, 2]\n        rg = R - G\n        yb = 0.5 * (R + G) - B\n        std_rg = float(np.std(rg))\n        std_yb = float(np.std(yb))\n        mean_rg = float(np.mean(rg))\n        mean_yb = float(np.mean(yb))\n        colorfulness = np.sqrt(std_rg * std_rg + std_yb * std_yb) + 0.3 * np.sqrt(mean_rg * mean_rg + mean_yb * mean_yb)\n        return float(colorfulness)\n    else:\n        # grayscale: colorfulness is zero\n        return 0.0\n\n", "def feature(image: np.ndarray) -> float:\n    'Left-right symmetry score of intensity (1 = perfect symmetry, 0 = totally asymmetric)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w < 2:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    mid = w // 2\n    left = gray[:, :mid]\n    right = gray[:, -mid:]\n    # flip right horizontally to compare\n    right_flip = np.fliplr(right)\n    # If widths differ (odd width), crop to smallest\n    minw = min(left.shape[1], right_flip.shape[1])\n    left = left[:, :minw]\n    right_flip = right_flip[:, :minw]\n    num = np.sum(np.abs(left - right_flip))\n    den = np.sum(np.abs(left) + np.abs(right_flip)) + 1e-8\n    # similarity in [0,1]\n    sim = 1.0 - (num / den)\n    return float(max(0.0, min(1.0, sim)))\n\n", "def feature(image: np.ndarray) -> float:\n    'Normalized top-versus-bottom mean intensity difference (top - bottom)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 2 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    t = max(1, h * 25 // 100)\n    top_mean = float(np.mean(gray[:t, :])) if t > 0 else 0.0\n    bottom_mean = float(np.mean(gray[-t:, :])) if t > 0 else 0.0\n    denom = (np.std(gray) + 1e-8)\n    diff = (top_mean - bottom_mean) / denom\n    return float(diff)\n\n", "def feature(image: np.ndarray) -> float:\n    'Count of prominent vertical peaks in the binarized column-sum profile (normalized)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w < 3:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 50)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    col_sums = np.sum(mask.astype(float), axis=0)\n    if np.all(col_sums == 0):\n        return 0.0\n    # local maxima detection\n    peaks = 0\n    maxval = float(np.max(col_sums))\n    thresh = max(1.0, 0.2 * maxval)\n    for i in range(1, col_sums.size - 1):\n        if col_sums[i] > col_sums[i - 1] and col_sums[i] > col_sums[i + 1] and col_sums[i] >= thresh:\n            peaks += 1\n    # normalize by possible peaks (image width)\n    norm = float(peaks) / float(max(1, w // 10))\n    return float(norm)\n\n", "def feature(image: np.ndarray) -> float:\n    'Ratio of mean gradient magnitude in center region to border regions (center / border)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 3 or w < 3:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    gy, gx = np.gradient(gray.astype(float))\n    grad = np.sqrt(gx * gx + gy * gy)\n    ch0, ch1 = h // 4, w // 4\n    center = grad[ch0:h - ch0, ch1:w - ch1]\n    border_mask = np.ones_like(grad, dtype=bool)\n    border_mask[ch0:h - ch0, ch1:w - ch1] = False\n    border = grad[border_mask]\n    center_mean = float(np.mean(center)) if center.size > 0 else 0.0\n    border_mean = float(np.mean(border)) if border.size > 0 else 1e-8\n    return float(center_mean / (border_mean + 1e-8))\n\n", "def feature(image: np.ndarray) -> float:\n    'Mean lower-third red minus blue channel value (useful for detecting shoes/color differences)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) != 3 or image.shape[2] < 3:\n        return 0.0\n    img = image.astype(float)\n    R = img[:, :, 0]\n    B = img[:, :, 2]\n    start = (2 * h) // 3\n    lower = R[start:, :] - B[start:, :]\n    # normalize by overall magnitude\n    denom = np.mean(np.abs(img)) + 1e-8\n    return float(np.mean(lower) / denom)\n\n", "def feature(image: np.ndarray) -> float:\n    'Entropy of gradient orientation histogram (8 bins), normalized to [0,1]'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 2 or w < 2:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    gy, gx = np.gradient(gray.astype(float))\n    angles = np.arctan2(gy, gx)  # -pi..pi\n    bins = 8\n    hist, _ = np.histogram(angles.flatten(), bins=bins, range=(-np.pi, np.pi))\n    hist = hist.astype(float)\n    total = np.sum(hist)\n    if total <= 0:\n        return 0.0\n    p = hist / total\n    eps = 1e-12\n    entropy = -np.sum(p * np.log(p + eps))\n    # normalize by max entropy log(bins)\n    norm = entropy / (np.log(bins) + 1e-12)\n    return float(norm)\n\n", "def feature(image: np.ndarray) -> float:\n    'Maximum horizontal band contrast: max abs(band_mean - global_mean) over 10%-height bands'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    global_mean = float(np.mean(gray))\n    band_h = max(1, h // 10)\n    maxdiff = 0.0\n    for start in range(0, h - band_h + 1, max(1, band_h // 2)):\n        band = gray[start:start + band_h, :]\n        diff = abs(float(np.mean(band)) - global_mean)\n        if diff > maxdiff:\n            maxdiff = diff\n    denom = (np.std(gray) + 1e-8)\n    return float(maxdiff / denom)\n\n", "def feature(image: np.ndarray) -> float:\n    'Bounding-box aspect ratio of dominant mask (width / height), returns 0 for no mask'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 50)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    ys, xs = np.where(mask)\n    if ys.size == 0:\n        return 0.0\n    y0, y1 = int(ys.min()), int(ys.max())\n    x0, x1 = int(xs.min()), int(xs.max())\n    height = max(1, y1 - y0 + 1)\n    width = max(1, x1 - x0 + 1)\n    ratio = float(width) / float(height)\n    return float(ratio)\n", "def feature(image: np.ndarray) -> float:\n    'Fraction of top 15% rows that are mostly background (helps detect low-placed items like shoes)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = float(np.median(gray))\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    top_rows = max(1, int(max(1, h * 0.15)))\n    top_region = mask[:top_rows, :]\n    bg_frac = 1.0 - (np.count_nonzero(top_region) / float(top_region.size) if top_region.size > 0 else 0.0)\n    return float(bg_frac)\n\n", "def feature(image: np.ndarray) -> float:\n    'Average horizontal half-width of mask in upper quarter relative to image half-width (sleeve spread)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 4 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = float(np.median(gray))\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    upper_h = max(1, h // 4)\n    rows = mask[:upper_h, :]\n    cx = (w - 1) / 2.0\n    half_widths = []\n    xs = np.arange(w)\n    for r in range(rows.shape[0]):\n        row = rows[r, :]\n        if np.any(row):\n            left = xs[row].min()\n            right = xs[row].max()\n            half_widths.append(max(0.0, min(cx, right - cx, cx - left)))\n    if len(half_widths) == 0:\n        return 0.0\n    avg_half = float(np.mean(half_widths))\n    return float(avg_half / (w / 2.0 + 1e-8))\n\n", "def feature(image: np.ndarray) -> float:\n    'Fraction of mask pixels located in bottom 25% of image (useful to detect shoes/trousers)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = float(np.median(gray))\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    total = float(np.count_nonzero(mask))\n    if total <= 0.0:\n        return 0.0\n    start = max(0, int(h - max(1, h * 0.25)))\n    bottom = mask[start:, :]\n    bottom_count = float(np.count_nonzero(bottom))\n    return float(bottom_count / total)\n\n", "def feature(image: np.ndarray) -> float:\n    'Mask compactness: area / (perimeter^2) approximated from mask gradients (higher => compact blob)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = float(np.median(gray))\n    mask = ((gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)).astype(float)\n    area = float(np.count_nonzero(mask))\n    if area <= 0.0:\n        return 0.0\n    gy, gx = np.gradient(mask)\n    edge = np.sqrt(gx * gx + gy * gy)\n    perim = float(np.count_nonzero(edge > 1e-6))\n    perim = max(perim, 1.0)\n    compactness = area / ((perim ** 2) + 1e-8)\n    # normalize by image area scale to keep values comparable\n    return float(compactness * (h * w) / (h * w + 1e-8))\n\n", "def feature(image: np.ndarray) -> float:\n    'Median number of horizontal mask segments per row (estimates separate blobs/shoes)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = float(np.median(gray))\n    mask = ((gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)).astype(np.uint8)\n    seg_counts = []\n    for r in range(h):\n        row = mask[r, :]\n        if np.any(row):\n            padded = np.concatenate(([0], row, [0])).astype(np.uint8)\n            segs = int(np.sum((padded[1:] == 1) & (padded[:-1] == 0)))\n            seg_counts.append(segs)\n    if len(seg_counts) == 0:\n        return 0.0\n    return float(np.median(np.array(seg_counts, dtype=float)))\n\n", "def feature(image: np.ndarray) -> float:\n    'Normalized vertical position (-1..1) of the row with maximum mask coverage (peak row location)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = float(np.median(gray))\n    mask = ((gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)).astype(np.uint8)\n    row_counts = np.count_nonzero(mask, axis=1)\n    if np.all(row_counts == 0):\n        return 0.0\n    peak_row = float(np.argmax(row_counts))\n    center = (h - 1) / 2.0\n    norm = (peak_row - center) / max(1.0, h / 2.0)\n    return float(np.clip(norm, -1.0, 1.0))\n\n", "def feature(image: np.ndarray) -> float:\n    'Mean dominant edge orientation (angle/pi in -1..1), computed from strong gradients (captures vertical vs diagonal structure)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 2 or w < 2:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    gy, gx = np.gradient(gray.astype(float))\n    mag = np.sqrt(gx * gx + gy * gy)\n    if not np.any(mag):\n        return 0.0\n    thresh = np.percentile(mag, 70)\n    strong = mag >= thresh\n    if not np.any(strong):\n        return 0.0\n    angles = np.arctan2(gy[strong], gx[strong])\n    s = float(np.mean(np.sin(angles)))\n    c = float(np.mean(np.cos(angles)))\n    mean_angle = float(np.arctan2(s, c))  # -pi..pi\n    return float(mean_angle / np.pi)\n\n", "def feature(image: np.ndarray) -> float:\n    'Mean color saturation for RGB images (0 for grayscale) using (max-min)/max per-pixel'\n    import numpy as np\n    if image is None:\n        return 0.0\n    if len(image.shape) != 3 or image.shape[2] < 3:\n        return 0.0\n    img = image.astype(float)\n    r = img[:, :, 0]\n    g = img[:, :, 1]\n    b = img[:, :, 2]\n    mx = np.maximum(np.maximum(r, g), b)\n    mn = np.minimum(np.minimum(r, g), b)\n    denom = mx.copy()\n    denom[denom == 0] = 1.0\n    sat = (mx - mn) / denom\n    return float(np.mean(sat))\n\n", "def feature(image: np.ndarray) -> float:\n    'Mask fill ratio: mask area divided by its bounding-box area (compactness inside bbox)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = float(np.median(gray))\n    mask = ((gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)).astype(np.uint8)\n    ys, xs = np.where(mask)\n    if ys.size == 0:\n        return 0.0\n    ymin, ymax = int(np.min(ys)), int(np.max(ys))\n    xmin, xmax = int(np.min(xs)), int(np.max(xs))\n    bbox_area = float(max(1, ymax - ymin + 1) * max(1, xmax - xmin + 1))\n    mask_area = float(np.count_nonzero(mask))\n    return float(mask_area / (bbox_area + 1e-8))\n\n", "def feature(image: np.ndarray) -> float:\n    'Ratio of average mask width in top 15% to bottom 15% rows (top/bottom width ratio)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 4 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = float(np.median(gray))\n    mask = ((gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)).astype(np.uint8)\n    top_h = max(1, int(h * 0.15))\n    bot_h = max(1, int(h * 0.15))\n    def avg_width(rows):\n        widths = []\n        xs = np.arange(w)\n        for r in range(rows.shape[0]):\n            row = rows[r, :]\n            if np.any(row):\n                left = xs[row].min()\n                right = xs[row].max()\n                widths.append(float(right - left + 1))\n        return float(np.mean(widths)) if len(widths) > 0 else 0.0\n    top_w = avg_width(mask[:top_h, :])\n    bottom_w = avg_width(mask[-bot_h:, :])\n    return float(top_w / (bottom_w + 1e-8))\n", "def feature(image: np.ndarray) -> float:\n    'Bounding-box width-to-height aspect ratio of the foreground mask'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 50)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    ys, xs = np.where(mask)\n    if ys.size == 0:\n        return 0.0\n    miny, maxy = int(np.min(ys)), int(np.max(ys))\n    minx, maxx = int(np.min(xs)), int(np.max(xs))\n    bbox_h = max(1, maxy - miny + 1)\n    bbox_w = max(1, maxx - minx + 1)\n    return float(bbox_w / bbox_h)\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Solidity-like measure: foreground area divided by its bounding-box area (0..1+)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 50)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    area = float(np.count_nonzero(mask))\n    if area == 0.0:\n        return 0.0\n    ys, xs = np.where(mask)\n    miny, maxy = int(np.min(ys)), int(np.max(ys))\n    minx, maxx = int(np.min(xs)), int(np.max(xs))\n    bbox_area = float(max(1, (maxy - miny + 1)) * max(1, (maxx - minx + 1)))\n    return float(area / (bbox_area + 1e-12))\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Normalized longest contiguous vertical run of foreground in any column (0..1)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 1 or w < 1:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 50)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    if not np.any(mask):\n        return 0.0\n    max_run = 0\n    # iterate columns (usually small width)\n    for col in range(w):\n        colv = mask[:, col].astype(np.uint8)\n        if colv.sum() == 0:\n            continue\n        # run-length: find lengths of contiguous ones\n        dif = np.diff(np.concatenate(([0], colv, [0])))\n        starts = np.where(dif == 1)[0]\n        ends = np.where(dif == -1)[0]\n        if starts.size and ends.size:\n            runs = ends - starts\n            local_max = int(np.max(runs))\n            if local_max > max_run:\n                max_run = local_max\n    return float(max_run / float(h))\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Vertical centroid of the foreground mask normalized by image height (0 top .. 1 bottom)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 50)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    ys = np.where(mask)[0]\n    if ys.size == 0:\n        return 0.0\n    cy = float(np.mean(ys))\n    return float(cy / float(h))\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Left-right symmetry score of the mask (0..1 where 1 is perfectly symmetric)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 50)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    area = float(np.count_nonzero(mask))\n    if area == 0.0:\n        return 0.0\n    # mirror left-right and compute overlap fraction\n    mirror = np.fliplr(mask)\n    overlap = float(np.count_nonzero(mask & mirror))\n    return float(overlap / (area + 1e-12))\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Fraction of foreground pixels located in the top quarter of the image'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 4 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 50)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    area = float(np.count_nonzero(mask))\n    if area == 0.0:\n        return 0.0\n    top = mask[:max(1, h // 4), :]\n    top_count = float(np.count_nonzero(top))\n    return float(top_count / (area + 1e-12))\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Fraction of foreground pixels located in the bottom quarter of the image'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 4 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 50)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    area = float(np.count_nonzero(mask))\n    if area == 0.0:\n        return 0.0\n    bottom = mask[(3 * h) // 4:, :]\n    bottom_count = float(np.count_nonzero(bottom))\n    return float(bottom_count / (area + 1e-12))\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Average number of foreground/background horizontal transitions per row in the top half normalized by width'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 2 or w < 2:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 50)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    top = mask[:max(1, h // 2), :]\n    rows = top.shape[0]\n    if rows == 0:\n        return 0.0\n    trans = 0.0\n    for r in range(rows):\n        row = top[r, :].astype(np.uint8)\n        trans += float(np.count_nonzero(row[:-1] != row[1:]))\n    avg_trans = trans / float(rows)\n    return float(avg_trans / float(w))\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Normalized intensity histogram entropy (0..1) using 16 bins'\n    import numpy as np\n    if image is None:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2).flatten()\n    else:\n        gray = image.astype(float).flatten()\n    if gray.size == 0:\n        return 0.0\n    # scale to 0..1\n    mn, mx = float(np.min(gray)), float(np.max(gray))\n    if mx > mn:\n        vals = (gray - mn) / (mx - mn)\n    else:\n        vals = gray * 0.0\n    bins = 16\n    hist, _ = np.histogram(vals, bins=bins, range=(0.0, 1.0))\n    probs = hist.astype(float) / float(np.sum(hist) + 1e-12)\n    probs = probs[probs > 0.0]\n    if probs.size == 0:\n        return 0.0\n    ent = -float(np.sum(probs * np.log(probs + 1e-12)))\n    # normalize by log(bins)\n    return float(ent / (np.log(float(bins)) + 1e-12))\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Left/right bias of mass in the upper half (positive => more mass on left, normalized -1..1)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 2 or w < 2:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 50)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    upper = mask[:max(1, h // 2), :]\n    total = float(np.count_nonzero(upper))\n    if total == 0.0:\n        return 0.0\n    left = float(np.count_nonzero(upper[:, :max(1, w // 2)]))\n    right = float(np.count_nonzero(upper[:, max(1, w // 2):]))\n    bias = (left - right) / (total + 1e-12)\n    # clamp to [-1,1]\n    if bias > 1.0:\n        bias = 1.0\n    if bias < -1.0:\n        bias = -1.0\n    return float(bias)\n", "def feature(image: np.ndarray) -> float:\n    'Absolute vertical symmetry: normalized correlation between left and mirrored right halves'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w < 2:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    left = gray[:, :w // 2]\n    right = gray[:, w - (w // 2):]\n    if left.size == 0 or right.size == 0:\n        return 0.0\n    # align widths\n    minw = min(left.shape[1], right.shape[1])\n    left = left[:, :minw].ravel()\n    right = np.fliplr(right[:, :minw]).ravel()\n    left_mean = left.mean() if left.size else 0.0\n    right_mean = right.mean() if right.size else 0.0\n    leftc = left - left_mean\n    rightc = right - right_mean\n    denom = np.sqrt(np.sum(leftc * leftc) * np.sum(rightc * rightc)) + 1e-8\n    corr = np.sum(leftc * rightc) / denom\n    return float(abs(corr))\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Absolute horizontal symmetry: normalized correlation between top and mirrored bottom halves'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 2 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    top = gray[:h // 2, :]\n    bot = gray[h - (h // 2):, :]\n    if top.size == 0 or bot.size == 0:\n        return 0.0\n    minh = min(top.shape[0], bot.shape[0])\n    top = top[:minh, :].ravel()\n    bot = np.flipud(bot[:minh, :]).ravel()\n    top_mean = top.mean() if top.size else 0.0\n    bot_mean = bot.mean() if bot.size else 0.0\n    topc = top - top_mean\n    botc = bot - bot_mean\n    denom = np.sqrt(np.sum(topc * topc) * np.sum(botc * botc)) + 1e-8\n    corr = np.sum(topc * botc) / denom\n    return float(abs(corr))\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Aspect ratio (width / height) of the mask bounding box (0 if no mask)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 60)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    ys, xs = np.where(mask)\n    if ys.size == 0:\n        return 0.0\n    ymin, ymax = ys.min(), ys.max()\n    xmin, xmax = xs.min(), xs.max()\n    box_w = float(xmax - xmin + 1)\n    box_h = float(ymax - ymin + 1)\n    if box_h <= 1e-8:\n        return 0.0\n    return float(box_w / box_h)\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Mask compactness approximated as (perimeter^2) / area using 4-neighborhood boundary'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = ((gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)).astype(np.bool_)\n    area = float(np.count_nonzero(mask))\n    if area <= 0.0:\n        return 0.0\n    padded = np.pad(mask, pad_width=1, mode='constant', constant_values=False)\n    up = padded[:-2, 1:-1]\n    down = padded[2:, 1:-1]\n    left = padded[1:-1, :-2]\n    right = padded[1:-1, 2:]\n    neighbor_count = (up.astype(int) + down.astype(int) + left.astype(int) + right.astype(int))\n    boundary = (mask & (neighbor_count < 4))\n    perimeter = float(np.count_nonzero(boundary))\n    compactness = (perimeter * perimeter) / (area + 1e-8)\n    return float(compactness)\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Edge density inside the mask: fraction of mask pixels with strong gradient'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 2 or w < 2:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    gy, gx = np.gradient(gray)\n    grad = np.sqrt(gx * gx + gy * gy)\n    edge_thr = np.percentile(grad, 70) if np.any(grad) else 0.0\n    strong = grad > edge_thr\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    mask_area = float(np.count_nonzero(mask))\n    if mask_area <= 0.0:\n        return 0.0\n    count = float(np.count_nonzero(strong & mask))\n    return float(count / (mask_area + 1e-8))\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Mean per-pixel color channel std (color saturation proxy), normalized to [0,1] (0 for grayscale)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    if len(image.shape) != 3 or image.shape[2] < 3:\n        return 0.0\n    img = image[:, :, :3].astype(float)\n    per_pixel_std = np.std(img, axis=2)\n    mean_std = float(np.mean(per_pixel_std))\n    return float(mean_std / 255.0)\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Ratio of mask area in bottom quarter to top quarter (bottom_quarter / (top_quarter+eps))'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 4 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    q = max(1, h // 4)\n    top = mask[:q, :]\n    bottom = mask[h - q:, :]\n    top_area = float(np.count_nonzero(top))\n    bottom_area = float(np.count_nonzero(bottom))\n    return float(bottom_area / (top_area + 1e-8))\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Normalized horizontal centroid of the mask (0 left, 1 right); 0.5 if no mask'\n    import numpy as np\n    if image is None:\n        return 0.5\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.5\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    area = float(np.count_nonzero(mask))\n    if area <= 0.0:\n        return 0.5\n    xs = np.arange(w, dtype=float)\n    sumx = float(np.sum((mask.astype(float) * xs)))\n    centroid_x = sumx / (area + 1e-8)\n    return float(centroid_x / max(1.0, w - 1.0))\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Top shoulder/arm indicator: (left_top_density + right_top_density) / (2 * center_top_density + eps)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 4 or w < 4:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    r0 = int(max(0, 0.10 * h))\n    r1 = int(min(h, 0.30 * h))\n    if r1 <= r0:\n        return 0.0\n    top_band = mask[r0:r1, :]\n    lw = max(1, int(0.40 * w))\n    left_box = top_band[:, :lw]\n    right_box = top_band[:, w - lw:]\n    c0 = int(0.30 * w)\n    c1 = int(0.70 * w)\n    center_box = top_band[:, c0:c1] if c1 > c0 else top_band[:, :]\n    left_density = float(np.count_nonzero(left_box)) / (left_box.size + 1e-8)\n    right_density = float(np.count_nonzero(right_box)) / (right_box.size + 1e-8)\n    center_density = float(np.count_nonzero(center_box)) / (center_box.size + 1e-8)\n    return float((left_density + right_density) / (2.0 * center_density + 1e-8))\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Fraction of strict local bright maxima (pixels > all 8 neighbors and > 95th percentile)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 3 or w < 3:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 95)\n    inner = gray[1:-1, 1:-1]\n    if inner.size == 0:\n        return 0.0\n    n = 0\n    # neighbors\n    n1 = gray[:-2, :-2]\n    n2 = gray[:-2, 1:-1]\n    n3 = gray[:-2, 2:]\n    n4 = gray[1:-1, :-2]\n    n5 = gray[1:-1, 2:]\n    n6 = gray[2:, :-2]\n    n7 = gray[2:, 1:-1]\n    n8 = gray[2:, 2:]\n    cond = (inner > n1) & (inner > n2) & (inner > n3) & (inner > n4) & (inner > n5) & (inner > n6) & (inner > n7) & (inner > n8) & (inner > thr)\n    count = float(np.count_nonzero(cond))\n    total_possible = float(inner.size)\n    return float(count / (total_possible + 1e-8))\n", "def feature(image: np.ndarray) -> float:\n    'Normalized vertical centroid of the foreground mask (0=top, 1=bottom)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    ys, xs = np.where(mask)\n    if ys.size == 0:\n        return 0.0\n    centroid_y = float(np.mean(ys))\n    return float(centroid_y / float(max(1, h - 1)))\n\n", "def feature(image: np.ndarray) -> float:\n    'Fraction of mask pixels located in the bottom third of the image'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    if not np.any(mask):\n        return 0.0\n    bottom_start = int(2 * h / 3)\n    bottom_mask = mask[bottom_start:, :]\n    bottom_count = float(np.count_nonzero(bottom_mask))\n    total_count = float(np.count_nonzero(mask))\n    return float(bottom_count / (total_count + 1e-8))\n\n", "def feature(image: np.ndarray) -> float:\n    'Aspect ratio of the mask bounding box (height / width)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    ys, xs = np.where(mask)\n    if ys.size == 0:\n        return 0.0\n    ymin, ymax = int(np.min(ys)), int(np.max(ys))\n    xmin, xmax = int(np.min(xs)), int(np.max(xs))\n    box_h = float(max(1, ymax - ymin + 1))\n    box_w = float(max(1, xmax - xmin + 1))\n    return float(box_h / (box_w + 1e-8))\n\n", "def feature(image: np.ndarray) -> float:\n    'Average number of foreground runs per column (indicates multiple vertical components)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    runs = []\n    for c in range(w):\n        col = mask[:, c].astype(int)\n        if col.size == 0:\n            runs.append(0)\n            continue\n        pad = np.concatenate(([0], col, [0]))\n        diff = np.diff(pad)\n        starts = np.where(diff == 1)[0]\n        ends = np.where(diff == -1)[0]\n        runs.append(max(0, starts.size))\n    if len(runs) == 0:\n        return 0.0\n    return float(np.mean(runs))\n\n", "def feature(image: np.ndarray) -> float:\n    'Ratio of mean mask width in the top 12% rows to mean mask width in the bottom 12% rows'\n    import numpy as np\n    if image is None:\n        return 1.0\n    h, w = image.shape[:2]\n    if h < 4 or w == 0:\n        return 1.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    band = max(1, int(h * 0.12))\n    top = mask[:band, :]\n    bottom = mask[-band:, :]\n    top_widths = np.sum(top, axis=1).astype(float)\n    bottom_widths = np.sum(bottom, axis=1).astype(float)\n    if top_widths.size == 0 or bottom_widths.size == 0:\n        return 1.0\n    mean_top = float(np.mean(top_widths)) + 1e-8\n    mean_bottom = float(np.mean(bottom_widths)) + 1e-8\n    return float(mean_top / mean_bottom)\n\n", "def feature(image: np.ndarray) -> float:\n    'Compactness estimate: mask area divided by perimeter (higher means more compact/filled)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    area = float(np.count_nonzero(mask))\n    if area == 0.0:\n        return 0.0\n    # compute perimeter by checking 4-neighborhood with padding\n    pad = np.pad(mask.astype(bool), pad_width=1, mode='constant', constant_values=False)\n    center = pad[1:-1, 1:-1]\n    up = pad[:-2, 1:-1]\n    down = pad[2:, 1:-1]\n    left = pad[1:-1, :-2]\n    right = pad[1:-1, 2:]\n    interior = center & up & down & left & right\n    perimeter_count = float(np.count_nonzero(center & (~interior)))\n    if perimeter_count <= 0.0:\n        return float(area)\n    return float(area / (perimeter_count + 1e-8))\n\n", "def feature(image: np.ndarray) -> float:\n    'Average gradient magnitude inside the foreground mask normalized by overall mean gradient'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 2 or w < 2:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    gy, gx = np.gradient(gray.astype(float))\n    grad_mag = np.sqrt(gx * gx + gy * gy)\n    global_mean = float(np.mean(grad_mag)) + 1e-8\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    if not np.any(mask):\n        return 0.0\n    mean_inside = float(np.mean(grad_mag[mask]))\n    return float(mean_inside / global_mean)\n\n", "def feature(image: np.ndarray) -> float:\n    'Fraction of top 10% rows that contain no foreground (measures a top gap / neckline)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    band = max(1, int(h * 0.10))\n    top_band = mask[:band, :]\n    empty_rows = float(np.sum(np.all(~top_band, axis=1)))\n    return float(empty_rows / float(band))\n\n", "def feature(image: np.ndarray) -> float:\n    'Average occupancy of small bottom-left and bottom-right corner squares (shoe corner score)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    box_h = max(1, int(h * 0.18))\n    box_w = max(1, int(w * 0.25))\n    bl = mask[-box_h:, :box_w]\n    br = mask[-box_h:, -box_w:]\n    bl_frac = float(np.count_nonzero(bl)) / float(bl.size + 1e-8)\n    br_frac = float(np.count_nonzero(br)) / float(br.size + 1e-8)\n    return float((bl_frac + br_frac) / 2.0)\n\n", "def feature(image: np.ndarray) -> float:\n    'Maximum left-right mirrored overlap after shifting up to 10% width (robust symmetry score)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    import numpy as np\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    if not np.any(mask):\n        return 0.0\n    mid = w // 2\n    left = mask[:, :mid]\n    right_base = mask[:, mid:][:, ::-1] if w % 2 == 0 else mask[:, mid+1:][:, ::-1]\n    max_shift = max(1, int(0.10 * w))\n    best = 0.0\n    # try shifting right side left/right against left side to allow small misalignments\n    for shift in range(-max_shift, max_shift + 1):\n        if shift < 0:\n            # shift right side right (padding on left)\n            pad = np.pad(right_base, ((0, 0), (0, -shift)), mode='constant', constant_values=False)\n            right = pad[:, -left.shape[1]:]\n        elif shift > 0:\n            pad = np.pad(right_base, ((0, 0), (shift, 0)), mode='constant', constant_values=False)\n            right = pad[:, :left.shape[1]]\n        else:\n            # no shift\n            right = right_base[:, :left.shape[1]]\n        # align widths\n        min_c = min(left.shape[1], right.shape[1])\n        if min_c <= 0:\n            continue\n        L = left[:, :min_c]\n        R = right[:, :min_c]\n        overlap = float(np.count_nonzero(L & R))\n        union = float(np.count_nonzero(L | R)) + 1e-8\n        score = overlap / union\n        if score > best:\n            best = score\n    return float(best)\n", "def feature(image: np.ndarray) -> float:\n    'Normalized foreground bounding-box aspect ratio (relative to image aspect)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h <= 1 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    ys, xs = np.where(mask)\n    if ys.size == 0:\n        return 0.0\n    miny, maxy = int(np.min(ys)), int(np.max(ys))\n    minx, maxx = int(np.min(xs)), int(np.max(xs))\n    bbox_h = max(1, maxy - miny + 1)\n    bbox_w = max(1, maxx - minx + 1)\n    img_aspect = float(w) / float(h)\n    bbox_aspect = float(bbox_w) / float(bbox_h)\n    # normalized so that 1.0 means bbox aspect equals image aspect\n    return float(bbox_aspect / (img_aspect + 1e-8))\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Foreground solidity: mask area divided by its bounding-box area (0..1)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    area = float(np.count_nonzero(mask))\n    if area == 0:\n        return 0.0\n    ys, xs = np.where(mask)\n    miny, maxy = int(np.min(ys)), int(np.max(ys))\n    minx, maxx = int(np.min(xs)), int(np.max(xs))\n    bbox_area = float(max(1, (maxy - miny + 1)) * max(1, (maxx - minx + 1)))\n    return float(area / (bbox_area + 1e-8))\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Fraction of center columns empty in bottom band (indicator of separated legs/shoes)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 2 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 50)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    bottom_h = max(1, int(round(h * 0.20)))\n    c0, c1 = w // 4, (3 * w) // 4\n    bottom_center = mask[h - bottom_h:h, c0:c1]\n    if bottom_center.size == 0:\n        return 0.0\n    col_empty = np.sum(np.all(bottom_center == 0, axis=0))\n    return float(col_empty / float(max(1, bottom_center.shape[1])))\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Count of separated strong column groups in the bottom quarter (number of leg/shoe blobs)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = gray < thr if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else gray > thr\n    start_row = int(max(0, h - max(1, int(round(h * 0.25)))))\n    region = mask[start_row:, :]\n    col_sums = np.sum(region.astype(int), axis=0).astype(float)\n    if col_sums.size == 0:\n        return 0.0\n    maxv = np.max(col_sums)\n    if maxv <= 0:\n        return 0.0\n    strong = col_sums > (0.25 * maxv)\n    padded = np.concatenate([[0], strong.astype(int), [0]])\n    diffs = np.diff(padded)\n    starts = np.where(diffs == 1)[0]\n    count = max(0, len(starts))\n    # return raw count but clipped to a reasonable range\n    return float(min(count, 5))\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Vertical symmetry score (1.0 = perfectly symmetric, 0.0 = very asymmetric)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w < 2:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = ((gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)).astype(float)\n    mid = w // 2\n    left = mask[:, :mid]\n    right = mask[:, w - mid:] if mid > 0 else mask[:, :]\n    # flip right horizontally to compare\n    right_flipped = np.fliplr(right) if right.size != 0 else right\n    # trim to same width\n    minw = min(left.shape[1] if left.size else 0, right_flipped.shape[1] if right_flipped.size else 0)\n    if minw == 0:\n        return 0.0\n    left_crop = left[:, :minw]\n    right_crop = right_flipped[:, :minw]\n    diff = np.abs(left_crop - right_crop)\n    mean_diff = float(np.mean(diff))\n    # normalize to [0,1], invert so 1 = symmetric\n    score = 1.0 - (mean_diff / (1.0 + 1e-8))\n    return float(max(0.0, min(1.0, score)))\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Ratio of mean edge magnitude in top third to bottom third (top_mean / bottom_mean)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 3 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    gy, gx = np.gradient(gray.astype(float))\n    grad = np.sqrt(gx * gx + gy * gy)\n    top = grad[:max(1, h // 3), :]\n    bottom = grad[max(0, h - h // 3):, :]\n    top_mean = float(np.mean(top)) if top.size else 0.0\n    bottom_mean = float(np.mean(bottom)) if bottom.size else 0.0\n    return float(top_mean / (bottom_mean + 1e-8))\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Length of top empty run in central columns (normalized by height) indicating neckline/opening'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h <= 1 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 50)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    c0 = max(0, int(w * 0.4))\n    c1 = min(w, int(w * 0.6) + 1)\n    center_cols = mask[:, c0:c1] if c1 > c0 else mask\n    if center_cols.size == 0:\n        return 0.0\n    # find number of rows from top that are fully empty in the center region\n    emptiness_per_row = np.all(center_cols == 0, axis=1)\n    # count consecutive True from top\n    top_empty = 0\n    for val in emptiness_per_row:\n        if val:\n            top_empty += 1\n        else:\n            break\n    return float(top_empty / float(h))\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Median contiguous mask run-length along rows (estimate of stroke/thickness), normalized by width'\n    import numpy as np\n    if image is None:\n        return 0.0\n    import numpy as np\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    run_lengths = []\n    for r in range(h):\n        row = mask[r, :].astype(int)\n        if np.any(row):\n            # find run lengths of contiguous ones\n            padded = np.concatenate([[0], row, [0]])\n            diffs = np.diff(padded)\n            starts = np.where(diffs == 1)[0]\n            ends = np.where(diffs == -1)[0]\n            lengths = (ends - starts).tolist()\n            run_lengths.extend(lengths)\n    if len(run_lengths) == 0:\n        return 0.0\n    med = float(np.median(np.array(run_lengths)))\n    return float(med / float(w + 1e-8))\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Contour roughness: border pixel count divided by mask area (higher -> more complex outline)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = ((gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)).astype(int)\n    area = float(np.count_nonzero(mask))\n    if area == 0:\n        return 0.0\n    # approximate border by differences with shifted masks\n    vert_diff = np.abs(mask[1:, :] - mask[:-1, :])\n    hor_diff = np.abs(mask[:, 1:] - mask[:, :-1])\n    border_count = float(np.sum(vert_diff) + np.sum(hor_diff))\n    return float(border_count / (area + 1e-8))\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Longest contiguous mask run in the center column (normalized by height) indicating continuous garment'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = ((gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)).astype(int)\n    center_col = mask[:, w // 2] if w > 0 else mask[:, 0]\n    if center_col.size == 0:\n        return 0.0\n    padded = np.concatenate([[0], center_col, [0]])\n    diffs = np.diff(padded)\n    starts = np.where(diffs == 1)[0]\n    ends = np.where(diffs == -1)[0]\n    if starts.size == 0:\n        return 0.0\n    lengths = ends - starts\n    longest = float(np.max(lengths))\n    return float(longest / float(h))\n", "def feature(image: np.ndarray) -> float:\n    'Normalized vertical centroid of the foreground mask (0=top,1=bottom)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 50)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    ys, xs = np.where(mask)\n    if ys.size == 0:\n        return 0.0\n    cy = float(np.mean(ys))\n    return float(cy / float(h + 1e-8))\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Left-right symmetry of the foreground mask measured as IoU with its mirror (1=perfect)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    flipped = np.fliplr(mask)\n    inter = np.count_nonzero(mask & flipped)\n    union = np.count_nonzero(mask | flipped)\n    if union == 0:\n        return 0.0\n    return float(inter / float(union))\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Count of prominent peaks in the column-sum profile (approx number of vertical components)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 50)\n    mask = gray < thr if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else gray > thr\n    colsum = np.sum(mask.astype(float), axis=0)\n    if np.all(colsum == 0):\n        return 0.0\n    # Smooth small noise\n    kernel = np.array([1.0, 1.0, 1.0])\n    smooth = np.convolve(colsum, kernel / kernel.sum(), mode='same')\n    peak_thresh = 0.25 * (np.max(smooth) if np.max(smooth) > 0 else 1.0)\n    peaks = 0\n    for i in range(1, w - 1):\n        if smooth[i] > smooth[i - 1] and smooth[i] > smooth[i + 1] and smooth[i] >= peak_thresh:\n            peaks += 1\n    # endpoints as possible peaks\n    if w >= 1 and smooth[0] > smooth[1] and smooth[0] >= peak_thresh:\n        peaks += 1\n    if w >= 2 and smooth[-1] > smooth[-2] and smooth[-1] >= peak_thresh:\n        peaks += 1\n    return float(peaks)\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Simple colorfulness score based on channel differences (0 for grayscale)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    if len(image.shape) != 3 or image.shape[2] < 3:\n        return 0.0\n    # use float conversions\n    r = image[:, :, 0].astype(float)\n    g = image[:, :, 1].astype(float)\n    b = image[:, :, 2].astype(float)\n    rg = r - g\n    yb = 0.5 * (r + g) - b\n    sigma_rg = float(np.std(rg))\n    sigma_yb = float(np.std(yb))\n    mean_rg = float(np.mean(np.abs(rg)))\n    mean_yb = float(np.mean(np.abs(yb)))\n    # Hasler-Suesstrunk inspired metric\n    score = np.sqrt(sigma_rg * sigma_rg + sigma_yb * sigma_yb) + 0.3 * np.sqrt(mean_rg * mean_rg + mean_yb * mean_yb)\n    return float(score)\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Perimeter-to-area proxy: strong-edge count divided by foreground area'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 2 or w < 2:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    gy, gx = np.gradient(gray.astype(float))\n    grad = np.sqrt(gx * gx + gy * gy)\n    thr = np.percentile(grad, 70) if np.any(grad) else 0.0\n    edges = grad > thr\n    thr2 = np.percentile(gray, 55)\n    mask = (gray < thr2) if np.count_nonzero(gray < thr2) >= np.count_nonzero(gray > thr2) else (gray > thr2)\n    area = float(np.count_nonzero(mask))\n    if area <= 0.0:\n        return 0.0\n    edge_count = float(np.count_nonzero(edges & mask))\n    return float(edge_count / (area + 1e-8))\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Fraction of adjacent columns where the top mask boundary is nearly horizontal (flat top indicator)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 60)\n    mask = gray < thr if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else gray > thr\n    top_rows = np.full((w,), h, dtype=int)\n    for c in range(w):\n        col = mask[:, c]\n        nz = np.nonzero(col)[0]\n        if nz.size > 0:\n            top_rows[c] = int(nz[0])\n    valid = (top_rows < h)\n    if np.count_nonzero(valid) <= 1:\n        return 0.0\n    # consider adjacent valid column pairs\n    counts = 0\n    pairs = 0\n    for c in range(w - 1):\n        if valid[c] and valid[c + 1]:\n            pairs += 1\n            if abs(int(top_rows[c]) - int(top_rows[c + 1])) <= 1:\n                counts += 1\n    if pairs == 0:\n        return 0.0\n    return float(counts / float(pairs))\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Skewness of per-row mask widths (positive means long tail to the right in width distribution)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h <= 1 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    widths = np.sum(mask.astype(float), axis=1)\n    if widths.size == 0:\n        return 0.0\n    mean_w = float(np.mean(widths))\n    std_w = float(np.std(widths))\n    if std_w < 1e-8:\n        return 0.0\n    skew = float(np.mean(((widths - mean_w) / std_w) ** 3))\n    return float(skew)\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Normalized contrast between center region and image border (positive => center brighter)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    ch0 = h // 4\n    cw0 = w // 4\n    center = gray[ch0:h - ch0, cw0:w - cw0]\n    # border: union of edges 10% wide\n    bh = max(1, h // 10)\n    bw = max(1, w // 10)\n    top = gray[:bh, :]\n    bottom = gray[-bh:, :]\n    left = gray[:, :bw]\n    right = gray[:, -bw:]\n    border_concat = np.concatenate([top.flatten(), bottom.flatten(), left.flatten(), right.flatten()])\n    if center.size == 0 or border_concat.size == 0:\n        return 0.0\n    center_mean = float(np.mean(center))\n    border_mean = float(np.mean(border_concat))\n    denom = abs(border_mean) + 1e-8\n    return float((center_mean - border_mean) / denom)\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Ratio of strong-edge density in top third vs bottom third (useful for tops vs shoes)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 3 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    gy, gx = np.gradient(gray.astype(float))\n    grad = np.sqrt(gx * gx + gy * gy)\n    thr = np.percentile(grad, 65) if np.any(grad) else 0.0\n    edges = grad > thr\n    top_h = h // 3\n    top_edges = np.count_nonzero(edges[:top_h, :])\n    bottom_edges = np.count_nonzero(edges[-top_h:, :])\n    top_pixels = float(top_h * w)\n    bottom_pixels = float(top_h * w)\n    top_density = float(top_edges) / (top_pixels + 1e-8)\n    bottom_density = float(bottom_edges) / (bottom_pixels + 1e-8)\n    return float(top_density / (bottom_density + 1e-8))\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Approximate hole fraction: zero pixels inside bounding-box that are enclosed horizontally and vertically'\n    import numpy as np\n    if image is None:\n        return 0.0\n    import numpy as _np\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = _np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = _np.percentile(gray, 55)\n    mask = (gray < thr) if _np.count_nonzero(gray < thr) >= _np.count_nonzero(gray > thr) else (gray > thr)\n    ys, xs = _np.where(mask)\n    if ys.size == 0:\n        return 0.0\n    miny, maxy = int(_np.min(ys)), int(_np.max(ys))\n    minx, maxx = int(_np.min(xs)), int(_np.max(xs))\n    bbox_h = maxy - miny + 1\n    bbox_w = maxx - minx + 1\n    if bbox_h <= 0 or bbox_w <= 0:\n        return 0.0\n    sub = mask[miny:maxy + 1, minx:maxx + 1]\n    bh, bw = sub.shape\n    holes = 0\n    # for each zero pixel check if there is mask on both sides in row and column\n    for r in range(bh):\n        row = sub[r, :]\n        left_cum = _np.maximum.accumulate(row.astype(int))\n        right_cum = _np.maximum.accumulate(row[::-1].astype(int))[::-1]\n        for c in range(bw):\n            if not row[c]:\n                left_exists = left_cum[c - 1] if c - 1 >= 0 else 0\n                right_exists = right_cum[c + 1] if c + 1 < bw else 0\n                if not left_exists or not right_exists:\n                    continue\n                col = sub[:, c]\n                up_exists = _np.any(col[:r]) if r - 1 >= 0 else False\n                down_exists = _np.any(col[r + 1:]) if r + 1 < bh else False\n                if up_exists and down_exists:\n                    holes += 1\n    bbox_area = float(bh * bw)\n    return float(holes / (bbox_area + 1e-8))\n", "def feature(image: np.ndarray) -> float:\n    'Left-right symmetry score of intensity (1.0 means perfectly symmetric)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    mid = w // 2\n    left = gray[:, :mid]\n    right = gray[:, w - mid:]\n    if left.size == 0 or right.size == 0:\n        return 0.0\n    # flip right to compare\n    right_flipped = np.fliplr(right)\n    # crop to same width if unequal\n    minw = min(left.shape[1], right_flipped.shape[1])\n    left = left[:, :minw]\n    right_flipped = right_flipped[:, :minw]\n    diff = np.abs(left - right_flipped)\n    rng = np.max(gray) - np.min(gray)\n    rng = rng if rng > 1e-8 else 1.0\n    score = 1.0 - (np.mean(diff) / rng)\n    return float(max(0.0, min(1.0, score)))\n\n", "def feature(image: np.ndarray) -> float:\n    'Mean mask width top-quarter divided by mean mask width bottom-quarter'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 4 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    tq = max(1, h // 4)\n    top = mask[:tq, :]\n    bottom = mask[-tq:, :]\n    top_widths = np.sum(top, axis=1).astype(float)\n    bot_widths = np.sum(bottom, axis=1).astype(float)\n    mean_top = float(np.mean(top_widths)) if top_widths.size > 0 else 0.0\n    mean_bot = float(np.mean(bot_widths)) if bot_widths.size > 0 else 0.0\n    if mean_bot <= 1e-8:\n        return float(mean_top / (1e-8 + mean_bot))\n    return float(mean_top / mean_bot)\n\n", "def feature(image: np.ndarray) -> float:\n    'Bounding box height-to-width aspect ratio of the foreground mask'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 50)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    rows = np.any(mask, axis=1)\n    cols = np.any(mask, axis=0)\n    if not np.any(rows) or not np.any(cols):\n        return 0.0\n    r_indices = np.where(rows)[0]\n    c_indices = np.where(cols)[0]\n    top, bottom = int(r_indices[0]), int(r_indices[-1])\n    left, right = int(c_indices[0]), int(c_indices[-1])\n    bh = float(bottom - top + 1)\n    bw = float(right - left + 1)\n    return float(bh / (bw + 1e-8))\n\n", "def feature(image: np.ndarray) -> float:\n    'Number of horizontal connected components (contiguous column groups with foreground)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    cols_any = np.any(mask, axis=0)\n    if cols_any.size == 0 or not np.any(cols_any):\n        return 0.0\n    # count rising edges 0->1 in columns\n    padded = np.concatenate([[False], cols_any.astype(bool)])\n    transitions = np.diff(padded.astype(int))\n    comps = np.count_nonzero(transitions == 1)\n    return float(comps)\n\n", "def feature(image: np.ndarray) -> float:\n    'Mean inter-channel color variance (colorfulness); 0 for grayscale'\n    import numpy as np\n    if image is None:\n        return 0.0\n    if len(image.shape) != 3 or image.shape[2] < 3:\n        return 0.0\n    # use float channels\n    im = image.astype(float)\n    r, g, b = im[:, :, 0], im[:, :, 1], im[:, :, 2]\n    diff_sum = np.mean(np.abs(r - g) + np.abs(r - b) + np.abs(g - b))\n    rng = np.max(im) - np.min(im)\n    rng = rng if rng > 1e-8 else 1.0\n    return float(diff_sum / rng)\n\n", "def feature(image: np.ndarray) -> float:\n    'Center vertical band mass divided by combined left+right side mass'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 50)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    left_w = int(max(1, w * 0.25))\n    right_w = left_w\n    center_start = left_w\n    center_end = w - right_w\n    center = mask[:, center_start:center_end]\n    sides = np.concatenate([mask[:, :left_w], mask[:, center_end:]], axis=1) if left_w + right_w < w else mask[:, :0]\n    center_mass = float(np.count_nonzero(center))\n    side_mass = float(np.count_nonzero(sides))\n    return float(center_mass / (side_mass + 1e-8))\n\n", "def feature(image: np.ndarray) -> float:\n    'Fraction of edge pixels dominated by vertical gradient (|gx| > |gy|)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 2 or w < 2:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    gy, gx = np.gradient(gray)\n    mag = np.sqrt(gx * gx + gy * gy)\n    if not np.any(mag):\n        return 0.0\n    mask = mag > np.percentile(mag, 50)\n    if np.count_nonzero(mask) == 0:\n        return 0.0\n    vert_dom = np.count_nonzero((np.abs(gx) > np.abs(gy)) & mask)\n    return float(vert_dom) / float(np.count_nonzero(mask))\n\n", "def feature(image: np.ndarray) -> float:\n    'Compactness of foreground: area / (perimeter^2) (higher -> more compact)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    area = float(np.count_nonzero(mask))\n    if area <= 0.0:\n        return 0.0\n    mp = np.pad(mask.astype(bool), ((1, 1), (1, 1)), mode='constant', constant_values=False)\n    center = mp[1:-1, 1:-1]\n    up = mp[:-2, 1:-1]\n    down = mp[2:, 1:-1]\n    left = mp[1:-1, :-2]\n    right = mp[1:-1, 2:]\n    edge_mask = center & ((~up) | (~down) | (~left) | (~right))\n    perimeter = float(np.count_nonzero(edge_mask))\n    if perimeter <= 0.0:\n        return float(area)  # compact as whole\n    compact = area / ((perimeter ** 2) + 1e-8)\n    return float(compact)\n\n", "def feature(image: np.ndarray) -> float:\n    'Average number of foreground segments per row (how many horizontal pieces across rows)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    m = mask.astype(bool)\n    # create left-shifted version with zero column at left\n    left = np.concatenate([np.zeros((h, 1), dtype=bool), m[:, :-1]], axis=1)\n    starts = m & (~left)\n    segments_per_row = np.sum(starts, axis=1).astype(float)\n    if segments_per_row.size == 0:\n        return 0.0\n    return float(np.mean(segments_per_row))\n\n", "def feature(image: np.ndarray) -> float:\n    'Maximum contiguous vertical foreground segment height normalized by image height'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 50)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    m = mask.astype(int)\n    # dynamic programming: consecutive ones count ending at each pixel\n    up_counts = np.zeros_like(m)\n    up_counts[0, :] = m[0, :]\n    for r in range(1, h):\n        up_counts[r, :] = (up_counts[r - 1, :] + 1) * m[r, :]\n    max_run = float(np.max(up_counts)) if up_counts.size > 0 else 0.0\n    return float(max_run / (h + 1e-8))\n", "def feature(image: np.ndarray) -> float:\n    'Left-right symmetry score of the main object (1.0 = perfectly symmetric)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    if not np.any(mask):\n        return 0.0\n    flipped = np.fliplr(gray)\n    flipped_mask = np.fliplr(mask)\n    common = mask & flipped_mask\n    if not np.any(common):\n        # fall back to compare within mask union\n        common = mask | flipped_mask\n    diff = np.abs(gray - flipped)\n    # measure normalized mean absolute difference over the chosen region\n    denom = (np.mean(np.abs(gray[common])) + 1e-8)\n    score = 1.0 - (np.mean(diff[common]) / denom)\n    return float(max(0.0, min(1.0, score)))\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Ratio of mask area in top third vs bottom third (top_area / bottom_area)'\n    import numpy as np\n    if image is None:\n        return 1.0\n    h, w = image.shape[:2]\n    if h < 3 or w == 0:\n        return 1.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    top_end = max(1, h // 3)\n    bottom_start = h - top_end\n    top_area = float(np.count_nonzero(mask[:top_end, :]))\n    bottom_area = float(np.count_nonzero(mask[bottom_start:, :]))\n    if bottom_area <= 0.0:\n        return float(top_area / (1.0 + 1e-8))\n    return float(top_area / (bottom_area + 1e-8))\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Aspect ratio (width/height) of the tight bounding box around the mask'\n    import numpy as np\n    if image is None:\n        return 1.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 1.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    ys, xs = np.where(mask)\n    if ys.size == 0:\n        return 1.0\n    miny, maxy = int(np.min(ys)), int(np.max(ys))\n    minx, maxx = int(np.min(xs)), int(np.max(xs))\n    box_h = max(1, maxy - miny + 1)\n    box_w = max(1, maxx - minx + 1)\n    # normalize by image aspect to keep values around 1 for average shapes\n    img_ratio = (w / (h + 1e-8))\n    ratio = (box_w / float(box_h + 1e-8)) / (img_ratio + 1e-8)\n    return float(ratio)\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Average absolute red-green color difference normalized by mean brightness'\n    import numpy as np\n    if image is None:\n        return 0.0\n    if len(image.shape) != 3:\n        return 0.0\n    arr = image.astype(float)\n    h, w, c = arr.shape\n    if c < 2 or h == 0 or w == 0:\n        return 0.0\n    r = arr[:, :, 0]\n    g = arr[:, :, 1]\n    diff = np.abs(r - g)\n    mean_brightness = np.mean((r + g + (arr[:, :, 2] if c > 2 else g)) / 3.0) + 1e-8\n    return float(np.mean(diff) / mean_brightness)\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Variance of the image Laplacian (high = more fine detail / texture)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 2 or w < 2:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    gx, gy = np.gradient(gray)\n    gxx, gxy = np.gradient(gx)\n    gyx, gyy = np.gradient(gy)\n    lap = gxx + gyy\n    return float(np.var(lap))\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Entropy of strong-edge gradient orientations (0..1 normalized)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 2 or w < 2:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    gy, gx = np.gradient(gray.astype(float))\n    mag = np.sqrt(gx * gx + gy * gy)\n    if not np.any(mag):\n        return 0.0\n    thr = np.percentile(mag, 70)\n    mask = mag > thr\n    if not np.any(mask):\n        return 0.0\n    angles = np.arctan2(gy[mask], gx[mask])  # -pi..pi\n    nbins = 12\n    hist, _ = np.histogram(angles, bins=nbins, range=(-np.pi, np.pi))\n    probs = hist.astype(float) / (np.sum(hist) + 1e-8)\n    probs = probs[probs > 0]\n    import math\n    ent = -float(np.sum(probs * np.log(probs + 1e-12)))\n    # normalize by log(nbins)\n    ent_norm = ent / (math.log(nbins) + 1e-12)\n    return float(max(0.0, min(1.0, ent_norm)))\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Average number of vertical mask transitions per column in the upper 35% (captures sleeves/shoulder gaps)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 4 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    top_h = max(1, int(0.35 * h))\n    region = mask[:top_h, :]\n    if region.size == 0:\n        return 0.0\n    # count transitions along each column\n    diffs = np.abs(np.diff(region.astype(int), axis=0))\n    trans_per_col = np.sum(diffs, axis=0).astype(float)\n    # normalize by max possible transitions (top_h-1)\n    max_trans = float(max(1, top_h - 1))\n    avg_trans = float(np.mean(trans_per_col) / max_trans)\n    return float(max(0.0, min(1.0, avg_trans)))\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Number of contiguous column groups in bottom 20% having object pixels (approximate foot/sole groups)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 2 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    bottom_h = max(1, int(0.20 * h))\n    bottom = mask[-bottom_h:, :]\n    cols_active = np.any(bottom, axis=0).astype(int)\n    if cols_active.size == 0:\n        return 0.0\n    # count transitions from 0->1 to get groups\n    transitions = np.diff(np.concatenate(([0], cols_active, [0])))\n    groups = int(np.sum(transitions == 1))\n    return float(groups)\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Fill ratio: mask area divided by tight bounding box area (0..1, smaller means hollow/complex silhouette)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    ys, xs = np.where(mask)\n    if ys.size == 0:\n        return 0.0\n    miny, maxy = int(np.min(ys)), int(np.max(ys))\n    minx, maxx = int(np.min(xs)), int(np.max(xs))\n    box_h = max(1, maxy - miny + 1)\n    box_w = max(1, maxx - minx + 1)\n    bbox_area = float(box_h * box_w)\n    mask_area = float(np.count_nonzero(mask))\n    return float(mask_area / (bbox_area + 1e-8))\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Normalized contrast: absolute difference between mean inside-mask and outside-mask intensities'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    inside = gray[mask]\n    outside = gray[~mask]\n    if inside.size == 0 or outside.size == 0:\n        return 0.0\n    mean_in = float(np.mean(inside))\n    mean_out = float(np.mean(outside))\n    denom = (np.mean(gray) + 1e-8)\n    return float(abs(mean_in - mean_out) / denom)\n", "def feature(image: np.ndarray) -> float:\n    'Fraction of rows that contain any foreground pixel (vertical coverage)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 50)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    rows_with = np.count_nonzero(np.any(mask, axis=1))\n    return float(rows_with / float(h + 1e-8))\n\n", "def feature(image: np.ndarray) -> float:\n    'Ratio of foreground density in top 30% to bottom 30% of the image'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 3:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 50)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    top_h = max(1, int(h * 0.3))\n    bot_h = max(1, int(h * 0.3))\n    top_count = float(np.count_nonzero(mask[:top_h, :]))\n    bot_count = float(np.count_nonzero(mask[h - bot_h:, :]))\n    return float((top_count + 1e-8) / (bot_count + 1e-8))\n\n", "def feature(image: np.ndarray) -> float:\n    'Left-right symmetry: normalized mean absolute difference between left half and mirrored right half'\n    import numpy as np\n    if image is None:\n        return 1.0\n    h, w = image.shape[:2]\n    if w < 2:\n        return 1.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    mid = w // 2\n    left = gray[:, :mid].astype(float)\n    right = gray[:, w - mid: w].astype(float)  # same width as left\n    if left.size == 0 or right.size == 0:\n        return 1.0\n    right_flipped = np.fliplr(right)\n    diff = np.abs(left - right_flipped)\n    # normalize by intensity range\n    denom = np.mean(np.abs(gray)) + 1e-8\n    score = np.mean(diff) / denom\n    # convert to similarity [0,1] by clamping and inverting\n    sim = 1.0 - min(1.0, score / 2.0)\n    return float(sim)\n\n", "def feature(image: np.ndarray) -> float:\n    'Number of distinct foreground segments across columns in the bottom region (shoe blobs count)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 2 or w < 2:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    bottom_h = max(1, int(h * 0.15))\n    bottom = mask[h - bottom_h:, :]\n    col_sum = np.sum(bottom, axis=0).astype(float)\n    if np.max(col_sum) <= 0:\n        return 0.0\n    cutoff = max(1.0, 0.3 * np.max(col_sum))\n    active = col_sum >= cutoff\n    # count connected segments in active columns\n    segs = np.sum(np.diff(np.concatenate(([0], active.astype(np.int32), [0]))) == 1)\n    return float(segs)\n\n", "def feature(image: np.ndarray) -> float:\n    'Ratio of mean mask width in upper shoulder rows to mean width in torso rows (shoulder/torso width)'\n    import numpy as np\n    if image is None:\n        return 1.0\n    h, w = image.shape[:2]\n    if h < 4 or w == 0:\n        return 1.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    shoulder_top = 1\n    shoulder_bottom = max(1, int(h * 0.20))\n    torso_top = max(shoulder_bottom + 1, int(h * 0.25))\n    torso_bottom = max(torso_top + 1, int(h * 0.50))\n    shoulder_rows = mask[shoulder_top:shoulder_bottom, :]\n    torso_rows = mask[torso_top:torso_bottom, :]\n    if shoulder_rows.size == 0 or torso_rows.size == 0:\n        return 1.0\n    shoulder_widths = np.sum(shoulder_rows, axis=1).astype(float)\n    torso_widths = np.sum(torso_rows, axis=1).astype(float)\n    if np.mean(torso_widths) <= 1e-8:\n        return 1.0\n    ratio = float(np.mean(shoulder_widths) / (np.mean(torso_widths) + 1e-8))\n    return float(ratio)\n\n", "def feature(image: np.ndarray) -> float:\n    'Normalized variability of gradient magnitude (std / mean) as a texture indicator'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 2 or w < 2:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    gy, gx = np.gradient(gray.astype(float))\n    grad = np.sqrt(gx * gx + gy * gy)\n    mean_g = float(np.mean(grad))\n    std_g = float(np.std(grad))\n    if mean_g <= 1e-8:\n        return 0.0\n    return float(std_g / (mean_g + 1e-8))\n\n", "def feature(image: np.ndarray) -> float:\n    'Asymmetry of vertical edge energy between left and right image quarters (0 symmetric, 1 very asymmetric)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 2 or w < 4:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    gy, gx = np.gradient(gray.astype(float))\n    vert_edges = np.abs(gx)\n    q = max(1, w // 4)\n    left_sum = float(np.sum(vert_edges[:, :q]))\n    right_sum = float(np.sum(vert_edges[:, -q:]))\n    total = left_sum + right_sum + 1e-8\n    asym = abs(left_sum - right_sum) / total\n    return float(asym)\n\n", "def feature(image: np.ndarray) -> float:\n    'Foreground solidity: mask area divided by bounding-box area (1 = fills bbox)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 50)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    ys, xs = np.where(mask)\n    if xs.size == 0 or ys.size == 0:\n        return 0.0\n    area = float(xs.size)\n    xmin, xmax = int(np.min(xs)), int(np.max(xs))\n    ymin, ymax = int(np.min(ys)), int(np.max(ys))\n    bbox_area = float((xmax - xmin + 1) * (ymax - ymin + 1))\n    if bbox_area <= 1e-8:\n        return 0.0\n    return float(area / bbox_area)\n\n", "def feature(image: np.ndarray) -> float:\n    'Fraction of background (no-mask) pixels in a small top-center patch (neck opening indicator)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 4 or w < 4:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 50)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    top_h = max(1, int(h * 0.20))\n    center_w = max(1, int(w * 0.20))\n    cx0 = max(0, (w // 2) - (center_w // 2))\n    cx1 = min(w, cx0 + center_w)\n    patch = mask[:top_h, cx0:cx1]\n    if patch.size == 0:\n        return 0.0\n    bg_frac = 1.0 - (float(np.count_nonzero(patch)) / float(patch.size))\n    return float(bg_frac)\n\n", "def feature(image: np.ndarray) -> float:\n    'Fraction of total gradient energy concentrated in the lower 40% of the image'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 2 or w < 2:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    gy, gx = np.gradient(gray.astype(float))\n    grad_energy = gx * gx + gy * gy\n    lower_h = max(1, int(h * 0.40))\n    lower_region = grad_energy[h - lower_h:, :]\n    total_energy = float(np.sum(grad_energy)) + 1e-8\n    lower_energy = float(np.sum(lower_region))\n    return float(lower_energy / total_energy)\n", "def feature(image: np.ndarray) -> float:\n    'Vertical centroid of the foreground mask normalized by image height (0 = top, 1 = bottom)'\n    import numpy as np\n    if image is None:\n        return 0.5\n    h, w = image.shape[:2]\n    if h == 0:\n        return 0.5\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 50)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    ys = np.where(mask)[0]\n    if ys.size == 0:\n        return 0.5\n    centroid = float(np.mean(ys))\n    return float(centroid / float(max(1, h - 1)))\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Left-right symmetry score of the object (1 = perfectly symmetric, 0 = very asymmetric)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w < 2:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    ys, xs = np.where(mask)\n    if ys.size == 0:\n        return 0.0\n    left = int(max(0, xs.min()))\n    right = int(min(w - 1, xs.max()))\n    # take vertical bounding box and compare left half to mirrored right half\n    bbox = gray[:, left:right + 1]\n    bbox_mask = mask[:, left:right + 1]\n    bw = bbox.shape[1]\n    if bw < 2:\n        return 1.0\n    mid = bw // 2\n    left_part = bbox[:, :mid] * bbox_mask[:, :mid]\n    right_part = bbox[:, -mid:] * bbox_mask[:, -mid:]\n    # mirror right\n    right_mirror = np.fliplr(right_part)\n    # align sizes\n    minw = min(left_part.shape[1], right_mirror.shape[1])\n    if minw == 0:\n        return 0.0\n    L = left_part[:, :minw]\n    R = right_mirror[:, :minw]\n    diff = np.abs(L - R)\n    norm = np.mean(np.abs(L) + np.abs(R)) + 1e-8\n    score = 1.0 - (np.mean(diff) / norm)\n    return float(max(0.0, min(1.0, score)))\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Ratio of mean intensity in the top quarter of the mask to the bottom quarter (top/bottom)'\n    import numpy as np\n    if image is None:\n        return 1.0\n    h, w = image.shape[:2]\n    if h < 4:\n        return 1.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 50)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    ys = np.where(mask)[0]\n    if ys.size == 0:\n        return 1.0\n    top_row = 0\n    bottom_row = h - 1\n    top_band_end = min(h, int(round(h * 0.25)))\n    bottom_band_start = max(0, h - int(round(h * 0.25)))\n    top_mask = mask[top_row:top_band_end, :]\n    bottom_mask = mask[bottom_band_start:bottom_row + 1, :]\n    if np.count_nonzero(top_mask) == 0 or np.count_nonzero(bottom_mask) == 0:\n        return 1.0\n    top_mean = np.mean(gray[top_row:top_band_end, :][top_mask])\n    bottom_mean = np.mean(gray[bottom_band_start:bottom_row + 1, :][bottom_mask])\n    return float((top_mean + 1e-8) / (bottom_mean + 1e-8))\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Colorfulness metric (Hasler-S\u00fcsstrunk style) computed from RGB channels (0 for grayscale input)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    if len(image.shape) != 3 or image.shape[2] != 3:\n        return 0.0\n    R = image[:, :, 0].astype(float)\n    G = image[:, :, 1].astype(float)\n    B = image[:, :, 2].astype(float)\n    rg = R - G\n    yb = 0.5 * (R + G) - B\n    std_rg = np.std(rg)\n    std_yb = np.std(yb)\n    mean_rg = np.mean(np.abs(rg))\n    mean_yb = np.mean(np.abs(yb))\n    colorfulness = np.sqrt(std_rg ** 2 + std_yb ** 2) + 0.3 * np.sqrt(mean_rg ** 2 + mean_yb ** 2)\n    return float(colorfulness)\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Normalized red-vs-green bias: (meanR - meanG) / meanIntensity in [-1,1]'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) != 3 or image.shape[2] != 3:\n        # grayscale: no red/green bias\n        return 0.0\n    R = np.mean(image[:, :, 0].astype(float))\n    G = np.mean(image[:, :, 1].astype(float))\n    I = np.mean(np.mean(image.astype(float), axis=2)) + 1e-8\n    val = (R - G) / I\n    # clamp to [-1,1] for stability\n    val = max(-1.0, min(1.0, val))\n    return float(val)\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Edge density in the central region: fraction of center pixels with strong gradient'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 3 or w < 3:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    cy0, cy1 = h // 4, (3 * h) // 4\n    cx0, cx1 = w // 4, (3 * w) // 4\n    center = gray[cy0:cy1, cx0:cx1]\n    if center.size == 0:\n        return 0.0\n    gy, gx = np.gradient(center.astype(float))\n    mag = np.sqrt(gx * gx + gy * gy)\n    thresh = np.percentile(mag, 70) if np.any(mag) else 1e9\n    strong = np.count_nonzero(mag > thresh)\n    total = mag.size\n    return float(strong) / float(total + 1e-8)\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Fraction of rows that contain two or more disjoint mask segments (indicates pant-leg or sandal separation)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    import numpy as np\n    h, w = image.shape[:2]\n    if h == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    multi_seg_rows = 0\n    for r in range(h):\n        row = mask[r, :].astype(int)\n        if np.any(row):\n            pad = np.concatenate(([0], row, [0]))\n            d = np.diff(pad)\n            starts = np.where(d == 1)[0]\n            ends = np.where(d == -1)[0]\n            seg_count = max(0, len(starts))\n            if seg_count >= 2:\n                multi_seg_rows += 1\n    return float(multi_seg_rows) / float(h)\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Perimeter^2 / area compactness of the mask (higher => more elongated or complex boundary)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    area = float(np.count_nonzero(mask))\n    if area == 0:\n        return 0.0\n    # perimeter estimate: mask pixels that have any 4-neighbor as background\n    m = mask.astype(int)\n    up = np.pad(m, ((1, 0), (0, 0)), mode='constant')[:-1, :]\n    down = np.pad(m, ((0, 1), (0, 0)), mode='constant')[1:, :]\n    left = np.pad(m, ((0, 0), (1, 0)), mode='constant')[:, :-1]\n    right = np.pad(m, ((0, 0), (0, 1)), mode='constant')[:, 1:]\n    neighbors = up + down + left + right\n    boundary = np.logical_and(m == 1, neighbors < 4)\n    perimeter = float(np.count_nonzero(boundary))\n    compactness = (perimeter ** 2) / (area + 1e-8)\n    return float(compactness)\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Mask elongation estimated by PCA eigenvalue ratio (large => elongated vertically/horizontally)'\n    import numpy as np\n    if image is None:\n        return 1.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 1.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 50)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    ys, xs = np.where(mask)\n    if ys.size < 3:\n        return 1.0\n    coords = np.vstack([xs.astype(float), ys.astype(float)])\n    mean = np.mean(coords, axis=1, keepdims=True)\n    coords_c = coords - mean\n    cov = np.cov(coords_c)\n    # eigenvalues\n    try:\n        vals = np.linalg.eigvalsh(cov)\n    except Exception:\n        return 1.0\n    vals = np.sort(vals)\n    small = max(vals[0], 1e-8)\n    ratio = vals[-1] / small\n    return float(ratio)\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Linear trend (slope) of mask width across rows (positive => width increases downward), normalized by image width'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 3 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    row_widths = np.sum(mask, axis=1).astype(float)\n    y = np.arange(h).astype(float)\n    # center and compute slope via least squares\n    yw = y - y.mean()\n    rw = row_widths - row_widths.mean()\n    denom = np.sum(yw * yw) + 1e-8\n    slope = np.sum(yw * rw) / denom\n    # normalize by image width so range is comparable\n    return float(slope / (float(w) + 1e-8))\n", "def feature(image: np.ndarray) -> float:\n    'Fraction of image occupied by the foreground bounding box (bbox area / image area)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 50)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    ys, xs = np.where(mask)\n    if ys.size == 0:\n        return 0.0\n    ymin, ymax = int(np.min(ys)), int(np.max(ys))\n    xmin, xmax = int(np.min(xs)), int(np.max(xs))\n    bbox_area = float(max(1, (ymax - ymin + 1)) * max(1, (xmax - xmin + 1)))\n    img_area = float(h * w)\n    return float(bbox_area / (img_area + 1e-8))\n\n", "def feature(image: np.ndarray) -> float:\n    'Vertical centroid offset of foreground (0=center, positive => top-heavy)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    ys = np.where(mask)[0]\n    if ys.size == 0:\n        return 0.0\n    cy = float(np.mean(ys)) / float(h)\n    # return 0 if centered, positive when centroid is above center (top-heavy)\n    return float(0.5 - cy)\n\n", "def feature(image: np.ndarray) -> float:\n    'Left-right symmetry score computed on central vertical band (1.0 = perfect symmetry)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w < 2:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    # use central vertical band to avoid background edges\n    col0 = w // 8\n    col1 = w - col0\n    band = gray[:, col0:col1]\n    mh, mw = band.shape\n    if mw < 2:\n        return 0.0\n    half = mw // 2\n    left = band[:, :half]\n    right = band[:, -half:]\n    # flip right horizontally to compare\n    right_flipped = np.fliplr(right)\n    # if shapes differ (odd width) crop to min\n    minw = min(left.shape[1], right_flipped.shape[1])\n    left = left[:, :minw]\n    right_flipped = right_flipped[:, :minw]\n    denom = np.mean(np.abs(band)) + 1e-8\n    diff = np.mean(np.abs(left - right_flipped))\n    score = 1.0 - (diff / denom)\n    return float(max(0.0, min(1.0, score)))\n\n", "def feature(image: np.ndarray) -> float:\n    'Foreground fill ratio inside its bounding box (mask area / bbox area)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 50)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    ys, xs = np.where(mask)\n    if ys.size == 0:\n        return 0.0\n    area = float(ys.size)\n    ymin, ymax = int(np.min(ys)), int(np.max(ys))\n    xmin, xmax = int(np.min(xs)), int(np.max(xs))\n    bbox_area = float(max(1, (ymax - ymin + 1)) * max(1, (xmax - xmin + 1)))\n    return float(area / (bbox_area + 1e-8))\n\n", "def feature(image: np.ndarray) -> float:\n    'Principal axis orientation of foreground normalized (1.0 = vertical, 0.0 = horizontal)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 2 or w < 2:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    ys, xs = np.where(mask)\n    if ys.size < 2:\n        return 0.0\n    cx = np.mean(xs)\n    cy = np.mean(ys)\n    X = np.vstack([(xs - cx), (ys - cy)])\n    cov = np.cov(X)\n    # guard numerical issues\n    try:\n        vals, vecs = np.linalg.eigh(cov)\n    except Exception:\n        return 0.0\n    # largest eigenvector\n    idx = np.argmax(vals)\n    vx, vy = vecs[:, idx]\n    angle = abs(np.arctan2(vy, vx))\n    # map to [0, pi/2]\n    angle = min(angle, np.pi - angle)\n    score = angle / (np.pi / 2.0)\n    return float(score)\n\n", "def feature(image: np.ndarray) -> float:\n    'Variance of the Laplacian (high values => more textured / detailed regions)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 2 or w < 2:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    gy, gx = np.gradient(gray.astype(float))\n    gyy, gyx = np.gradient(gy)\n    gxy, gxx = np.gradient(gx)\n    lap = gxx + gyy\n    var = float(np.var(lap))\n    # normalize by mean intensity to reduce scale dependence\n    norm = np.mean(np.abs(gray)) + 1e-8\n    return float(var / norm)\n\n", "def feature(image: np.ndarray) -> float:\n    'Color difference between upper and lower halves (RGB L2 distance normalized)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0:\n        return 0.0\n    if len(image.shape) != 3 or image.shape[2] < 3:\n        return 0.0\n    top = image[: max(1, h // 2), :, :].astype(float)\n    bot = image[h // 2 :, :, :].astype(float)\n    top_mean = np.mean(top.reshape(-1, 3), axis=0) if top.size else np.array([0.0, 0.0, 0.0])\n    bot_mean = np.mean(bot.reshape(-1, 3), axis=0) if bot.size else np.array([0.0, 0.0, 0.0])\n    diff = np.linalg.norm(top_mean - bot_mean)\n    denom = (np.mean(image.astype(float)) + 1e-8)\n    return float(diff / denom)\n\n", "def feature(image: np.ndarray) -> float:\n    'Fraction of connected foreground components that are small (small blobs / total blobs)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    visited = np.zeros_like(mask, dtype=bool)\n    comps = 0\n    small = 0\n    area_thresh = max(1, int(0.01 * h * w))\n    for y in range(h):\n        for x in range(w):\n            if mask[y, x] and not visited[y, x]:\n                comps += 1\n                # BFS\n                stack = [(y, x)]\n                visited[y, x] = True\n                cnt = 0\n                while stack:\n                    yy, xx = stack.pop()\n                    cnt += 1\n                    for dy in (-1, 0, 1):\n                        for dx in (-1, 0, 1):\n                            ny, nx = yy + dy, xx + dx\n                            if ny < 0 or ny >= h or nx < 0 or nx >= w:\n                                continue\n                            if not visited[ny, nx] and mask[ny, nx]:\n                                visited[ny, nx] = True\n                                stack.append((ny, nx))\n                if cnt <= area_thresh:\n                    small += 1\n    if comps == 0:\n        return 0.0\n    return float(small / float(comps))\n\n", "def feature(image: np.ndarray) -> float:\n    'Fraction of foreground area that lies in the bottom band of the image (bottom 15%)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    total = np.count_nonzero(mask)\n    if total == 0:\n        return 0.0\n    band_h = max(1, int(max(1, h * 0.15)))\n    bottom = mask[h - band_h :, :]\n    bottom_count = np.count_nonzero(bottom)\n    return float(bottom_count / float(total))\n\n", "def feature(image: np.ndarray) -> float:\n    'Kurtosis of foreground width per row (measures peakedness of vertical profile)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    row_widths = np.sum(mask, axis=1).astype(float)\n    if row_widths.size == 0:\n        return 0.0\n    mu = np.mean(row_widths)\n    sigma = np.std(row_widths)\n    if sigma < 1e-8:\n        return 0.0\n    kurt = np.mean(((row_widths - mu) ** 4)) / (sigma ** 4) - 3.0\n    return float(kurt)\n", "def feature(image: np.ndarray) -> float:\n    'Normalized left-right symmetry of the image intensity (1.0 = perfectly symmetric)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    # compare mirrored halves using the smaller half width\n    left_w = w // 2\n    right_w = w - left_w\n    min_w = min(left_w, right_w)\n    if min_w <= 0:\n        return 1.0\n    left = gray[:, :min_w]\n    right = gray[:, -min_w:]\n    right_flipped = np.fliplr(right)\n    diff = np.abs(left - right_flipped)\n    denom = float(np.max(gray) - np.min(gray))\n    if denom <= 1e-8:\n        return 1.0\n    score = 1.0 - float(np.mean(diff) / denom)\n    if score != score:\n        return 0.0\n    return float(max(0.0, min(1.0, score)))\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Normalized vertical centroid of the foreground mask (0=top, 1=bottom)'\n    import numpy as np\n    if image is None:\n        return 0.5\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.5\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = gray < thr if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else gray > thr\n    ys, xs = np.nonzero(mask)\n    if ys.size == 0:\n        return 0.5\n    centroid_y = float(np.mean(ys)) / float(max(1, h - 1))\n    return float(np.clip(centroid_y, 0.0, 1.0))\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Aspect ratio (width/height) of the foreground bounding box'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = gray < thr if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else gray > thr\n    ys, xs = np.nonzero(mask)\n    if ys.size == 0:\n        return 0.0\n    miny, maxy = int(np.min(ys)), int(np.max(ys))\n    minx, maxx = int(np.min(xs)), int(np.max(xs))\n    bbox_h = max(1, maxy - miny + 1)\n    bbox_w = max(1, maxx - minx + 1)\n    return float(bbox_w / float(bbox_h))\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Fractional distance from top to first foreground row (0 = touching top)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = gray < thr if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else gray > thr\n    rows_any = np.any(mask, axis=1)\n    if not np.any(rows_any):\n        return 0.0\n    first = int(np.argmax(rows_any))\n    return float(first / float(max(1, h - 1)))\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Mean number of foreground segments per column (runs of pixels) in the mask'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    # pad a false row at top so 0->1 transitions count segments\n    total_segments = 0\n    if w == 0:\n        return 0.0\n    for c in range(w):\n        col = mask[:, c].astype(bool)\n        if col.size == 0:\n            continue\n        padded = np.concatenate(([False], col))\n        transitions = np.count_nonzero((~padded[:-1]) & padded[1:])\n        total_segments += int(transitions)\n    return float(total_segments / float(w))\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Perimeter-to-area ratio of the foreground mask (higher = more complex/skinny)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 1 or w < 1:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    mask_bool = mask.astype(bool)\n    area = float(np.count_nonzero(mask_bool))\n    if area <= 0.0:\n        return 0.0\n    # compute 4-neighbor perimeter approximation\n    pad = np.pad(mask_bool, ((1, 1), (1, 1)), mode='constant', constant_values=False)\n    up = pad[:-2, 1:-1]\n    down = pad[2:, 1:-1]\n    left = pad[1:-1, :-2]\n    right = pad[1:-1, 2:]\n    neighbor_count = up.astype(int) + down.astype(int) + left.astype(int) + right.astype(int)\n    perimeter_pixels = mask_bool & (neighbor_count < 4)\n    perimeter = float(np.count_nonzero(perimeter_pixels))\n    return float(perimeter / area)\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Fraction of columns that contain two or more foreground segments (indicates holes/complex shape)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    cols_with_gap = 0\n    for c in range(w):\n        col = mask[:, c].astype(bool)\n        if col.size == 0:\n            continue\n        padded = np.concatenate(([False], col, [False]))\n        transitions = np.count_nonzero((~padded[:-1]) & padded[1:])\n        if transitions >= 2:\n            cols_with_gap += 1\n    return float(cols_with_gap / float(w))\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Proportion of foreground pixels located within the central box (center 50% by height and width)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    total = float(np.count_nonzero(mask))\n    if total <= 0.0:\n        return 0.0\n    r0, r1 = h // 4, (3 * h) // 4\n    c0, c1 = w // 4, (3 * w) // 4\n    center_count = float(np.count_nonzero(mask[r0:r1, c0:c1]))\n    return float(center_count / total)\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Ratio of vertical spread to horizontal spread of the foreground (std_y / std_x)'\n    import numpy as np\n    if image is None:\n        return 1.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 1.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    ys, xs = np.nonzero(mask)\n    if ys.size == 0:\n        return 1.0\n    std_y = float(np.std(ys))\n    std_x = float(np.std(xs))\n    if std_x <= 1e-8:\n        return float(1e3)  # very tall thin object\n    return float(std_y / std_x)\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Standard deviation of the bottom contour (last foreground row per column) normalized by image height'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 1 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = gray < thr if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else gray > thr\n    bottom_idx = np.full((w,), -1, dtype=float)\n    any_in_col = np.any(mask, axis=0)\n    cols = np.where(any_in_col)[0]\n    if cols.size == 0:\n        return 0.0\n    for c in cols:\n        col = mask[:, c]\n        # last occurrence index where True\n        r = np.max(np.where(col)[0])\n        bottom_idx[c] = float(r)\n    valid = bottom_idx[bottom_idx >= 0.0]\n    if valid.size == 0:\n        return 0.0\n    std = float(np.std(valid)) / float(max(1.0, float(h)))\n    return float(std)\n", "def feature(image: np.ndarray) -> float:\n    'Bounding-box aspect ratio (width / height) of the dominant mask region'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    # grayscale\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 50)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    ys, xs = np.where(mask)\n    if ys.size == 0:\n        return 0.0\n    ymin, ymax = int(ys.min()), int(ys.max())\n    xmin, xmax = int(xs.min()), int(xs.max())\n    bw = float(xmax - xmin + 1)\n    bh = float(ymax - ymin + 1)\n    if bh <= 1e-8:\n        return 0.0\n    result = bw / bh\n    return float(result)\n\n", "def feature(image: np.ndarray) -> float:\n    'Normalized vertical centroid of the mask (0=top, 1=bottom)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 50)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    ys, xs = np.where(mask)\n    if ys.size == 0:\n        return 0.5\n    centroid_y = float(np.mean(ys))\n    result = centroid_y / float(max(1, h - 1))\n    return float(result)\n\n", "def feature(image: np.ndarray) -> float:\n    'Left-right symmetry score (1.0 = perfectly symmetric, 0.0 = very asymmetric)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if w < 2:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    # crop to central vertical band to avoid border noise\n    cx = w // 2\n    bw = max(1, w // 2)\n    left = gray[:, max(0, cx - bw):cx]\n    right = gray[:, cx:min(w, cx + bw)]\n    # mirror right to compare\n    if left.size == 0 or right.size == 0:\n        return 0.0\n    # make same shape by trimming larger\n    min_c = min(left.shape[1], right.shape[1])\n    left = left[:, :min_c]\n    right = right[:, :min_c]\n    right_mirror = np.fliplr(right)\n    diff = np.abs(left - right_mirror)\n    denom = np.mean(np.abs(gray)) + 1e-8\n    score = 1.0 - (np.mean(diff) / denom)\n    # clamp to [0,1]\n    score = max(0.0, min(1.0, float(score)))\n    return float(score)\n\n", "def feature(image: np.ndarray) -> float:\n    'Perimeter-to-area compactness of the mask (higher => more complex / spiky shape)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 50)\n    mask = ((gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)).astype(np.uint8)\n    area = float(np.count_nonzero(mask))\n    if area <= 0.0:\n        return 0.0\n    # perimeter approximation via 4-neighbor boundary pixels\n    up = np.zeros_like(mask); up[1:, :] = mask[:-1, :]\n    down = np.zeros_like(mask); down[:-1, :] = mask[1:, :]\n    left = np.zeros_like(mask); left[:, 1:] = mask[:, :-1]\n    right = np.zeros_like(mask); right[:, :-1] = mask[:, 1:]\n    boundary = mask & ((up == 0) | (down == 0) | (left == 0) | (right == 0))\n    perimeter = float(np.count_nonzero(boundary))\n    result = (perimeter * perimeter) / (area + 1e-8)\n    return float(result)\n\n", "def feature(image: np.ndarray) -> float:\n    'Mean mask width in top 20% divided by mean mask width in bottom 20% (>1 if top wider)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 4 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    top_h = max(1, int(h * 0.20))\n    bot_h = max(1, int(h * 0.20))\n    top_rows = mask[:top_h, :]\n    bot_rows = mask[-bot_h:, :]\n    top_widths = np.sum(top_rows, axis=1).astype(float)\n    bot_widths = np.sum(bot_rows, axis=1).astype(float)\n    top_mean = float(np.mean(top_widths)) if top_widths.size else 0.0\n    bot_mean = float(np.mean(bot_widths)) if bot_widths.size else 0.0\n    if bot_mean <= 1e-8:\n        return float(top_mean / (float(w) + 1e-8))\n    result = top_mean / (bot_mean + 1e-8)\n    return float(result)\n\n", "def feature(image: np.ndarray) -> float:\n    'Horizontal centroid offset magnitude (0=centered, up to 0.5 = strong side bias)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 50)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    ys, xs = np.where(mask)\n    if xs.size == 0:\n        return 0.0\n    centroid_x = float(np.mean(xs))\n    offset = (centroid_x - (w - 1) / 2.0) / float(max(1, w))\n    result = abs(offset)\n    return float(result)\n\n", "def feature(image: np.ndarray) -> float:\n    'Ratio of gradient magnitude in center region to border region (center_energy / border_energy)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 2 or w < 2:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    gy, gx = np.gradient(gray.astype(float))\n    grad = np.sqrt(gx * gx + gy * gy)\n    ch0, ch1 = h // 4, w // 4\n    center = grad[ch0: h - ch0, ch1: w - ch1]\n    # border ring = full - center (use masks)\n    total = np.sum(grad) + 1e-8\n    center_sum = np.sum(center)\n    border_sum = total - center_sum\n    if border_sum <= 1e-8:\n        return float(center_sum / total)\n    result = center_sum / (border_sum + 1e-8)\n    return float(result)\n\n", "def feature(image: np.ndarray) -> float:\n    'Relative mid-frequency vertical pattern energy (detects stripes) from column profile FFT'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if w < 4:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    col_profile = np.mean(gray, axis=0)\n    col_profile = col_profile - np.mean(col_profile)\n    # real FFT\n    spec = np.abs(np.fft.rfft(col_profile))\n    total = np.sum(spec) + 1e-8\n    # exclude DC (freq 0) and very high freqs; look at mid-range (2..min(6, len-1))\n    n = spec.size\n    lo = 2\n    hi = min(6, n - 1)\n    if hi < lo:\n        return 0.0\n    mid_energy = np.sum(spec[lo:hi + 1])\n    result = mid_energy / total\n    return float(result)\n\n", "def feature(image: np.ndarray) -> float:\n    'Top-center opening fraction: fraction of unmasked pixels within top 10% center columns (neck/gap indicator)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 50)\n    mask = ((gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)).astype(np.uint8)\n    top_h = max(1, int(h * 0.10))\n    center_w = max(1, int(w * 0.30))\n    cx0 = max(0, (w - center_w) // 2)\n    cx1 = min(w, cx0 + center_w)\n    top_center = mask[:top_h, cx0:cx1]\n    total = float(top_center.size)\n    if total <= 0.0:\n        return 0.0\n    unmasked = float(np.count_nonzero(top_center == 0))\n    result = unmasked / (total + 1e-8)\n    return float(result)\n\n", "def feature(image: np.ndarray) -> float:\n    'Mean absolute red-green channel contrast normalized by overall intensity (0 if grayscale)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    if len(image.shape) != 3 or image.shape[2] < 3:\n        return 0.0\n    # safe float conversion\n    r = image[:, :, 0].astype(float)\n    g = image[:, :, 1].astype(float)\n    diff = np.abs(r - g)\n    denom = np.mean(np.abs(np.mean(image.astype(float), axis=2))) + 1e-8\n    result = np.mean(diff) / denom\n    return float(result)\n", "def feature(image: np.ndarray) -> float:\n    'Left-right vertical symmetry score (1.0 = perfect symmetry)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w < 2:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    # split left and right (drop middle column if odd)\n    mid = w // 2\n    if w % 2 == 0:\n        left = gray[:, :mid]\n        right = gray[:, mid:]\n    else:\n        left = gray[:, :mid]\n        right = gray[:, mid+1:]\n    # make shapes equal\n    minw = min(left.shape[1], right.shape[1])\n    if minw == 0:\n        return 0.0\n    left = left[:, :minw]\n    right = right[:, :minw]\n    right_flipped = np.fliplr(right)\n    diff = np.abs(left - right_flipped)\n    norm = (np.mean(np.abs(gray)) + 1e-8)\n    score = 1.0 - (np.mean(diff) / norm)\n    return float(np.clip(score, 0.0, 1.0))\n\n", "def feature(image: np.ndarray) -> float:\n    'Vertical centroid of the foreground mask (0=top, 1=bottom)'\n    import numpy as np\n    if image is None:\n        return 0.5\n    h, w = image.shape[:2]\n    if h == 0:\n        return 0.5\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 50)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    ys, xs = np.where(mask)\n    if ys.size == 0:\n        return 0.5\n    centroid_y = float(np.mean(ys)) / float(h)\n    return float(np.clip(centroid_y, 0.0, 1.0))\n\n", "def feature(image: np.ndarray) -> float:\n    'Count of prominent vertical peaks in the foreground projection (indicative of multiple parts)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    colsum = np.sum(mask.astype(float), axis=0)\n    if not np.any(colsum):\n        return 0.0\n    # simple smoothing\n    kernel = np.array([1.0, 1.0, 1.0])\n    smooth = np.convolve(colsum, kernel, mode='same')\n    thresh = np.percentile(smooth, 60)\n    peaks = 0\n    for i in range(1, smooth.size - 1):\n        if smooth[i] > thresh and smooth[i] > smooth[i - 1] and smooth[i] >= smooth[i + 1]:\n            peaks += 1\n    # consider endpoints\n    if smooth.size >= 1:\n        if smooth.size == 1 and smooth[0] > thresh:\n            peaks = 1\n        else:\n            if smooth[0] > thresh and smooth[0] >= smooth[1]:\n                peaks += 1\n            if smooth[-1] > thresh and smooth[-1] > smooth[-2]:\n                peaks += 1\n    return float(peaks)\n\n", "def feature(image: np.ndarray) -> float:\n    'Ratio of strong edge count in top half to bottom half (top/bottom)'\n    import numpy as np\n    if image is None:\n        return 1.0\n    h, w = image.shape[:2]\n    if h < 2 or w < 2:\n        return 1.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    gy, gx = np.gradient(gray.astype(float))\n    mag = np.sqrt(gx * gx + gy * gy)\n    if not np.any(mag):\n        return 1.0\n    thresh = np.percentile(mag, 70)\n    strong = mag > thresh\n    top_count = np.count_nonzero(strong[:h // 2, :])\n    bot_count = np.count_nonzero(strong[h // 2:, :])\n    return float(top_count / (bot_count + 1e-8))\n\n", "def feature(image: np.ndarray) -> float:\n    'Fraction of image rows that contain foreground (vertical coverage fraction)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 50)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    rows_with = np.count_nonzero(np.any(mask, axis=1))\n    return float(rows_with / float(h))\n\n", "def feature(image: np.ndarray) -> float:\n    'Mean color saturation (HSV-style) for RGB images, 0 for grayscale'\n    import numpy as np\n    if image is None:\n        return 0.0\n    if len(image.shape) != 3 or image.shape[2] < 3:\n        return 0.0\n    img = image.astype(float)\n    r = img[:, :, 0]\n    g = img[:, :, 1]\n    b = img[:, :, 2]\n    mx = np.maximum(np.maximum(r, g), b)\n    mn = np.minimum(np.minimum(r, g), b)\n    diff = mx - mn\n    # saturation per pixel\n    sat = np.where(mx > 0, diff / (mx + 1e-8), 0.0)\n    return float(np.mean(sat))\n\n", "def feature(image: np.ndarray) -> float:\n    'Horizontal centroid offset of the foreground (-0.5 left .. 0.5 right)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 50)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    ys, xs = np.where(mask)\n    if xs.size == 0:\n        return 0.0\n    centroid_x = float(np.mean(xs))\n    offset = (centroid_x - (w - 1) / 2.0) / float(w)\n    return float(np.clip(offset, -0.5, 0.5))\n\n", "def feature(image: np.ndarray) -> float:\n    'Standard deviation of gradient magnitude normalized by mean intensity (texture roughness)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 2 or w < 2:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    gy, gx = np.gradient(gray.astype(float))\n    mag = np.sqrt(gx * gx + gy * gy)\n    if not np.any(mag):\n        return 0.0\n    std_mag = float(np.std(mag))\n    denom = (np.mean(gray) + 1e-8)\n    return float(std_mag / denom)\n\n", "def feature(image: np.ndarray) -> float:\n    'Upper-arm protrusion index: mean foreground run count in upper band divided by center band'\n    import numpy as np\n    if image is None:\n        return 1.0\n    h, w = image.shape[:2]\n    if h == 0:\n        return 1.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    def runs_in_row(row):\n        row_bits = row.astype(np.int8)\n        if row_bits.size == 0:\n            return 0\n        diffs = np.diff(np.concatenate(([0], row_bits, [0])))\n        starts = np.count_nonzero(diffs == 1)\n        return int(starts)\n    upper_end = max(1, int(0.25 * h))\n    center_start = max(0, int(0.4 * h))\n    center_end = min(h, int(0.6 * h))\n    upper_runs = [runs_in_row(mask[r, :]) for r in range(0, upper_end)]\n    center_runs = [runs_in_row(mask[r, :]) for r in range(center_start, center_end)]\n    if len(upper_runs) == 0:\n        return 1.0\n    upper_mean = float(np.mean(upper_runs))\n    center_mean = float(np.mean(center_runs)) if len(center_runs) else 0.0\n    return float(upper_mean / (center_mean + 1e-8))\n\n", "def feature(image: np.ndarray) -> float:\n    'Color contrast between estimated foreground and background (RGB L2 normalized)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) != 3 or image.shape[2] < 3:\n        return 0.0\n    img = image.astype(float)\n    gray = np.mean(img, axis=2)\n    thr = np.percentile(gray, 50)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    fg = img[mask]\n    bg = img[~mask]\n    if fg.size == 0 or bg.size == 0:\n        return 0.0\n    fg_mean = np.mean(fg.reshape(-1, 3), axis=0)\n    bg_mean = np.mean(bg.reshape(-1, 3), axis=0)\n    diff = np.linalg.norm(fg_mean - bg_mean)\n    denom = (np.mean(gray) + 1e-8)\n    return float(diff / denom)\n", "def feature(image: np.ndarray) -> float:\n    'Horizontal symmetry: 1.0 means perfect left-right mirror, 0.0 means very asymmetric'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w < 2:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    # threshold to focus on object shape\n    thr = np.percentile(gray, 50)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    mid = w // 2\n    left = gray[:, :mid]\n    right = gray[:, w - mid:]\n    right_flipped = np.fliplr(right)\n    if left.shape != right_flipped.shape:\n        # pad smaller\n        mh = min(left.shape[1], right_flipped.shape[1])\n        left = left[:, :mh]\n        right_flipped = right_flipped[:, :mh]\n    diff = np.mean(np.abs(left - right_flipped)) if left.size else 0.0\n    norm = (np.mean(np.abs(gray)) + 1e-8)\n    score = 1.0 - float(diff / norm)\n    return float(max(0.0, min(1.0, score)))\n\n", "def feature(image: np.ndarray) -> float:\n    'Vertical symmetry: 1.0 means top-bottom mirror, 0.0 very asymmetric'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 2 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 50)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    top = gray[:h // 2, :]\n    bottom = gray[h - h // 2:, :]\n    bottom_flipped = np.flipud(bottom)\n    # align shapes\n    if top.shape != bottom_flipped.shape:\n        mh = min(top.shape[0], bottom_flipped.shape[0])\n        top = top[:mh, :]\n        bottom_flipped = bottom_flipped[:mh, :]\n    diff = np.mean(np.abs(top - bottom_flipped)) if top.size else 0.0\n    norm = (np.mean(np.abs(gray)) + 1e-8)\n    score = 1.0 - float(diff / norm)\n    return float(max(0.0, min(1.0, score)))\n\n", "def feature(image: np.ndarray) -> float:\n    'Colorfulness metric for RGB images (0 for grayscale)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    if len(image.shape) != 3 or image.shape[2] < 3:\n        return 0.0\n    img = image.astype(float)\n    R = img[:, :, 0]\n    G = img[:, :, 1]\n    B = img[:, :, 2]\n    # Hasler & Suesstrunk colorfulness measure\n    rg = R - G\n    yb = 0.5 * (R + G) - B\n    std_rg = float(np.std(rg))\n    std_yb = float(np.std(yb))\n    mean_rg = float(np.mean(np.abs(rg)))\n    mean_yb = float(np.mean(np.abs(yb)))\n    colorfulness = np.sqrt(std_rg ** 2 + std_yb ** 2) + 0.3 * (mean_rg + mean_yb)\n    # normalize by pixel value range if likely 0-255\n    denom = 255.0 if img.max() > 50 else (img.max() + 1e-8)\n    return float(colorfulness / (denom + 1e-8))\n\n", "def feature(image: np.ndarray) -> float:\n    'Bounding-box aspect ratio of the detected foreground mask (width / height)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 50)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    ys, xs = np.where(mask)\n    if ys.size == 0:\n        return 0.0\n    miny, maxy = int(ys.min()), int(ys.max())\n    minx, maxx = int(xs.min()), int(xs.max())\n    bw = maxx - minx + 1\n    bh = maxy - miny + 1\n    if bh <= 0:\n        return 0.0\n    return float(bw / float(bh))\n\n", "def feature(image: np.ndarray) -> float:\n    'Normalized vertical centroid position of foreground (0=top, 1=bottom)'\n    import numpy as np\n    if image is None:\n        return 0.5\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.5\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 50)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    ys, xs = np.nonzero(mask)\n    if ys.size == 0:\n        return 0.5\n    cy = float(np.mean(ys))\n    return float(cy / float(h - 1 + 1e-8))\n\n", "def feature(image: np.ndarray) -> float:\n    'Dominant edge orientation (circular mean) normalized to [-1,1] where 0 is horizontal'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 2 or w < 2:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    gy, gx = np.gradient(gray.astype(float))\n    mag = np.sqrt(gx * gx + gy * gy)\n    if not np.any(mag):\n        return 0.0\n    # consider only strong edges to avoid noise\n    thr = np.percentile(mag, 60)\n    mask = mag > thr\n    if np.count_nonzero(mask) == 0:\n        mask = mag > (np.mean(mag) * 0.5)\n    ang = np.arctan2(gy, gx)  # [-pi, pi]\n    vals = ang[mask]\n    mags = mag[mask]\n    # circular mean via complex representation\n    comp = np.sum(mags * np.exp(1j * vals))\n    if comp == 0:\n        return 0.0\n    mean_ang = np.angle(comp)  # [-pi, pi]\n    # normalize: 0 -> horizontal, +-pi/2 -> vertical. Map to [-1,1] by dividing by pi/2\n    return float(max(-1.0, min(1.0, mean_ang / (np.pi / 2.0))))\n\n", "def feature(image: np.ndarray) -> float:\n    'Approximate solidity: largest component area divided by its bounding-box area'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 50)\n    mask = ((gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)).astype(bool)\n    visited = np.zeros_like(mask, dtype=bool)\n    max_area = 0\n    max_bbox_area = 1\n    for y in range(h):\n        for x in range(w):\n            if mask[y, x] and not visited[y, x]:\n                # flood fill\n                stack = [(y, x)]\n                visited[y, x] = True\n                area = 0\n                miny, maxy = y, y\n                minx, maxx = x, x\n                while stack:\n                    yy, xx = stack.pop()\n                    area += 1\n                    if yy < miny: miny = yy\n                    if yy > maxy: maxy = yy\n                    if xx < minx: minx = xx\n                    if xx > maxx: maxx = xx\n                    if yy > 0 and mask[yy - 1, xx] and not visited[yy - 1, xx]:\n                        visited[yy - 1, xx] = True\n                        stack.append((yy - 1, xx))\n                    if yy + 1 < h and mask[yy + 1, xx] and not visited[yy + 1, xx]:\n                        visited[yy + 1, xx] = True\n                        stack.append((yy + 1, xx))\n                    if xx > 0 and mask[yy, xx - 1] and not visited[yy, xx - 1]:\n                        visited[yy, xx - 1] = True\n                        stack.append((yy, xx - 1))\n                    if xx + 1 < w and mask[yy, xx + 1] and not visited[yy, xx + 1]:\n                        visited[yy, xx + 1] = True\n                        stack.append((yy, xx + 1))\n                bbox_area = (maxy - miny + 1) * (maxx - minx + 1)\n                if area > max_area:\n                    max_area = area\n                    max_bbox_area = max(1, bbox_area)\n    if max_area == 0:\n        return 0.0\n    return float(max_area / float(max_bbox_area))\n\n", "def feature(image: np.ndarray) -> float:\n    'Mean of per-row longest foreground run lengths normalized by image width'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 50)\n    mask = ((gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)).astype(np.uint8)\n    runs = []\n    for r in range(h):\n        row = mask[r]\n        if row.size == 0:\n            runs.append(0)\n            continue\n        max_run = 0\n        cur = 0\n        for v in row:\n            if v:\n                cur += 1\n                if cur > max_run:\n                    max_run = cur\n            else:\n                cur = 0\n        runs.append(max_run)\n    if len(runs) == 0:\n        return 0.0\n    return float(np.mean(runs) / float(w + 1e-8))\n\n", "def feature(image: np.ndarray) -> float:\n    'Average of longest vertical foreground runs per column in bottom half, normalized by half-height'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 2 or w == 0:\n        return 0.0\n    bh_start = h // 2\n    bh = h - bh_start\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 50)\n    mask = ((gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)).astype(np.uint8)\n    if bh <= 0:\n        return 0.0\n    col_runs = []\n    bottom = mask[bh_start:, :]\n    for c in range(w):\n        col = bottom[:, c]\n        max_run = 0\n        cur = 0\n        for v in col:\n            if v:\n                cur += 1\n                if cur > max_run:\n                    max_run = cur\n            else:\n                cur = 0\n        col_runs.append(max_run)\n    if len(col_runs) == 0:\n        return 0.0\n    return float(np.mean(col_runs) / float(bh + 1e-8))\n\n", "def feature(image: np.ndarray) -> float:\n    'Number of contiguous top-region foreground groups (columns with first-foreground within top 30%) normalized by width'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    top_cut = max(1, int(0.30 * h))\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 50)\n    mask = ((gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr))\n    first_y = np.full(w, h, dtype=int)\n    for c in range(w):\n        col = mask[:, c]\n        ys = np.nonzero(col)[0]\n        if ys.size:\n            first_y[c] = int(ys[0])\n    cols_top = (first_y < top_cut).astype(int)\n    if cols_top.size == 0:\n        return 0.0\n    transitions = np.diff(np.concatenate(([0], cols_top, [0])))\n    groups = int(np.sum(transitions == 1))\n    return float(groups / float(w + 1e-8))\n", "def feature(image: np.ndarray) -> float:\n    'Fraction of foreground mask pixels located in the bottom 20% of the image (shoe indicator)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    # grayscale conversion\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    total = np.count_nonzero(mask)\n    if total == 0:\n        return 0.0\n    bottom_start = max(0, h - max(1, h // 5))\n    bottom_count = np.count_nonzero(mask[bottom_start:, :])\n    return float(bottom_count) / float(total)\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Relative width of a background gap centered at the top region (neckline/handle gap)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 3 or w < 3:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    top_band = max(1, h // 8)\n    band = mask[:top_band, :]\n    # look at the middle row of the band (or last if small)\n    row = band[min(top_band - 1, top_band // 2), :]\n    bg = ~row\n    # compute contiguous background run length around center\n    center = w // 2\n    left = 0\n    for i in range(center, -1, -1):\n        if not bg[i]:\n            left = center - i\n            break\n    else:\n        left = center + 1\n    right = 0\n    for i in range(center, w):\n        if not bg[i]:\n            right = i - center\n            break\n    else:\n        right = w - center\n    gap = left + right\n    return float(gap) / float(w)\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Mask fill ratio: mask pixel count divided by its bounding-box area (solidity-like)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 50)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    ys, xs = np.where(mask)\n    if ys.size == 0:\n        return 0.0\n    miny, maxy = int(np.min(ys)), int(np.max(ys))\n    minx, maxx = int(np.min(xs)), int(np.max(xs))\n    bbox_h = max(1, maxy - miny + 1)\n    bbox_w = max(1, maxx - minx + 1)\n    bbox_area = float(bbox_h * bbox_w)\n    mask_area = float(np.count_nonzero(mask))\n    return float(mask_area / (bbox_area + 1e-8))\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Normalized count of empty horizontal gaps (rows with zero mask) inside the object vertical extent'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 3 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    ys, _ = np.where(mask)\n    if ys.size == 0:\n        return 0.0\n    miny, maxy = int(np.min(ys)), int(np.max(ys))\n    vertical_slice = mask[miny:maxy+1, :]\n    row_sums = np.sum(vertical_slice, axis=1)\n    # rows that are empty inside bbox\n    empty = (row_sums == 0)\n    # count contiguous empty runs\n    runs = 0\n    in_run = False\n    for v in empty:\n        if v and not in_run:\n            runs += 1\n            in_run = True\n        elif not v:\n            in_run = False\n    return float(runs) / float(max(1, (maxy - miny + 1)))\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Standard deviation of per-row mask-centroid x positions normalized by image width'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 2 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 50)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    xs = np.arange(w).reshape(1, w)\n    centroids = []\n    for r in range(h):\n        row = mask[r, :]\n        cnt = np.count_nonzero(row)\n        if cnt == 0:\n            continue\n        cx = float(np.sum(row * xs) / float(cnt))\n        centroids.append(cx)\n    if len(centroids) == 0:\n        return 0.0\n    return float(np.std(np.array(centroids)) / max(1.0, float(w)))\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Presence and separation of two bright/bulk peaks near the bottom quarter (shoe pair score)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    import numpy as np\n    h, w = image.shape[:2]\n    if h < 4 or w < 4:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    bottom_h = max(1, h // 4)\n    cols = np.sum(mask[h - bottom_h:, :].astype(float), axis=0)\n    if np.all(cols == 0):\n        return 0.0\n    # smooth and find local peaks\n    kernel = np.ones(5) / 5.0\n    smooth = np.convolve(cols, kernel, mode='same')\n    meanv = float(np.mean(smooth))\n    peaks = []\n    for i in range(1, w - 1):\n        if smooth[i] > smooth[i - 1] and smooth[i] > smooth[i + 1] and smooth[i] > meanv * 0.5:\n            peaks.append((smooth[i], i))\n    if len(peaks) < 2:\n        return 0.0\n    peaks_sorted = sorted(peaks, reverse=True)[:2]\n    d = abs(peaks_sorted[0][1] - peaks_sorted[1][1])\n    return float(d) / float(w)\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Global texture roughness estimated by mean absolute image Laplacian'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 3 or w < 3:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    gray = gray.astype(float)\n    # normalize to reduce scale sensitivity\n    mx = np.max(np.abs(gray))\n    if mx > 0:\n        gray = gray / mx\n    gy, gx = np.gradient(gray)\n    gyy, gyx = np.gradient(gy)\n    gxy, gxx = np.gradient(gx)\n    lap = gxx + gyy\n    rough = float(np.mean(np.abs(lap)))\n    return float(rough)\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Mean per-pixel color saturation (RGB only), 0.0 for grayscale'\n    import numpy as np\n    if image is None:\n        return 0.0\n    if len(image.shape) != 3 or image.shape[2] < 3:\n        return 0.0\n    img = image.astype(float)\n    mx = np.max(img, axis=2)\n    mn = np.min(img, axis=2)\n    # avoid division by zero; saturation relative to local max\n    denom = mx + 1e-8\n    sat = (mx - mn) / denom\n    return float(np.mean(sat))\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Difference between mean mask width in bottom 15% and top 15% normalized by image width'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 4 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    band = max(1, h // 7)\n    top_widths = np.sum(mask[0:band, :].astype(float), axis=1)\n    bottom_widths = np.sum(mask[h - band:h, :].astype(float), axis=1)\n    mean_top = float(np.mean(top_widths)) if top_widths.size > 0 else 0.0\n    mean_bottom = float(np.mean(bottom_widths)) if bottom_widths.size > 0 else 0.0\n    diff = mean_bottom - mean_top\n    return float(diff / max(1.0, float(w)))\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Normalized entropy of strong gradient orientations (0..1), higher => diverse edge directions'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 2 or w < 2:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    gy, gx = np.gradient(gray.astype(float))\n    mag = np.sqrt(gx * gx + gy * gy)\n    if not np.any(mag):\n        return 0.0\n    thr = np.percentile(mag.flatten(), 60)\n    strong_mask = mag > thr\n    if not np.any(strong_mask):\n        return 0.0\n    ori = np.arctan2(gy, gx)\n    vals = ori[strong_mask].flatten()\n    bins = 16\n    hist, _ = np.histogram(vals, bins=bins, range=(-np.pi, np.pi))\n    p = hist.astype(float) / (np.sum(hist) + 1e-12)\n    p_nonzero = p[p > 0]\n    if p_nonzero.size == 0:\n        return 0.0\n    entropy = -np.sum(p_nonzero * np.log(p_nonzero))\n    # normalize by log(bins)\n    return float(entropy / (np.log(bins) + 1e-12))\n", "def feature(image: np.ndarray) -> float:\n    'Bounding-box aspect ratio (width / height) of the foreground mask'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    # convert to grayscale if needed\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 50)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    if not np.any(mask):\n        return 0.0\n    rows = np.where(np.any(mask, axis=1))[0]\n    cols = np.where(np.any(mask, axis=0))[0]\n    if rows.size == 0 or cols.size == 0:\n        return 0.0\n    bbox_h = float(rows[-1] - rows[0] + 1)\n    bbox_w = float(cols[-1] - cols[0] + 1)\n    if bbox_h <= 1e-8:\n        return 0.0\n    return float(bbox_w / (bbox_h + 1e-8))\n\n", "def feature(image: np.ndarray) -> float:\n    'Vertical symmetry score (1.0 = perfectly symmetric, 0.0 = very asymmetric)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w < 2:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    # use mask to focus on foreground symmetry if possible\n    thr = np.percentile(gray, 50)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    half = w // 2\n    left = gray[:, :half]\n    right = gray[:, w - half:]\n    mask_l = mask[:, :half]\n    mask_r = mask[:, w - half:]\n    # flip right horizontally\n    right_flipped = np.fliplr(right)\n    mask_r_flipped = np.fliplr(mask_r)\n    # overlap where both masked (foreground on both sides)\n    overlap = mask_l & mask_r_flipped\n    if np.count_nonzero(overlap) < 10:\n        # fallback to full-image symmetry if foreground overlap too small\n        left_full = gray[:, :half]\n        right_full = np.fliplr(gray[:, w - half:])\n        diff = np.abs(left_full - right_full)\n        denom = (np.max(gray) - np.min(gray) + 1e-8)\n        if denom <= 1e-8:\n            return 1.0\n        score = 1.0 - float(np.mean(diff) / denom)\n        return float(max(0.0, min(1.0, score)))\n    diff = np.abs(left - right_flipped)\n    score = 1.0 - float(np.mean(diff[overlap]) / (np.max(gray) - np.min(gray) + 1e-8))\n    return float(max(0.0, min(1.0, score)))\n\n", "def feature(image: np.ndarray) -> float:\n    'Perimeter-to-area compactness: perimeter / area (higher => more complex outline)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 50)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    area = float(np.count_nonzero(mask))\n    if area <= 0.0:\n        return 0.0\n    # compute 4-neighbor boundary via padding to avoid wrap\n    pad = np.pad(mask, 1, mode='constant', constant_values=False)\n    center = pad[1:-1, 1:-1]\n    up = pad[0:-2, 1:-1]\n    down = pad[2:, 1:-1]\n    left = pad[1:-1, 0:-2]\n    right = pad[1:-1, 2:]\n    neighbor_all = up & down & left & right\n    boundary = center & (~neighbor_all)\n    perimeter = float(np.count_nonzero(boundary))\n    return float(perimeter / (area + 1e-8))\n\n", "def feature(image: np.ndarray) -> float:\n    'Normalized radial spread: ratio (std(distance)/mean(distance)) of mask pixels from centroid'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    ys, xs = np.where(mask)\n    if xs.size == 0:\n        return 0.0\n    cx = float(np.mean(xs))\n    cy = float(np.mean(ys))\n    d = np.sqrt((xs - cx) ** 2 + (ys - cy) ** 2)\n    mean_d = float(np.mean(d))\n    std_d = float(np.std(d))\n    if mean_d <= 1e-8:\n        return 0.0\n    return float(std_d / (mean_d + 1e-8))\n\n", "def feature(image: np.ndarray) -> float:\n    'Median horizontal run-length of foreground per row normalized by image width'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    runs = []\n    for r in range(h):\n        row = mask[r, :].astype(np.uint8)\n        if not np.any(row):\n            continue\n        padded = np.pad(row, (1, 1), mode='constant', constant_values=0)\n        diff = np.diff(padded.astype(int))\n        starts = np.where(diff == 1)[0]\n        ends = np.where(diff == -1)[0]\n        lengths = (ends - starts).astype(float)\n        if lengths.size:\n            runs.extend(lengths.tolist())\n    if len(runs) == 0:\n        return 0.0\n    med = float(np.median(np.array(runs)))\n    return float(med / (w + 1e-8))\n\n", "def feature(image: np.ndarray) -> float:\n    'Mean absolute Laplacian energy (high values => more high-frequency texture)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 3 or w < 3:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    # pad with edge to avoid wrap-around artifacts\n    pad = np.pad(gray, 1, mode='edge').astype(float)\n    center = pad[1:-1, 1:-1]\n    up = pad[0:-2, 1:-1]\n    down = pad[2:, 1:-1]\n    left = pad[1:-1, 0:-2]\n    right = pad[1:-1, 2:]\n    lap = up + down + left + right - 4.0 * center\n    energy = float(np.mean(np.abs(lap)))\n    return float(energy)\n\n", "def feature(image: np.ndarray) -> float:\n    'Mean color saturation inside foreground mask for RGB images (0 for grayscale)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    if len(image.shape) != 3 or image.shape[2] < 3:\n        return 0.0\n    h, w, c = image.shape\n    if h == 0 or w == 0:\n        return 0.0\n    img = image.astype(float)\n    mx = np.max(img, axis=2)\n    mn = np.min(img, axis=2)\n    sat = (mx - mn) / (mx + 1e-8)\n    gray = np.mean(img, axis=2)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    if not np.any(mask):\n        return 0.0\n    mean_sat = float(np.mean(sat[mask]))\n    return float(mean_sat)\n\n", "def feature(image: np.ndarray) -> float:\n    'Horizontal centroid shift between top and bottom halves (abs delta x / width)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 2 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    top = mask[:h // 2, :]\n    bot = mask[h // 2:, :]\n    xs = np.arange(w).astype(float)\n    def centroid_x(m):\n        if not np.any(m):\n            return None\n        cols = np.sum(m, axis=0)\n        total = float(np.sum(cols))\n        if total <= 0:\n            return None\n        return float(np.sum(xs * cols) / total)\n    cx_top = centroid_x(top)\n    cx_bot = centroid_x(bot)\n    if cx_top is None or cx_bot is None:\n        return 0.0\n    return float(abs(cx_top - cx_bot) / (w + 1e-8))\n\n", "def feature(image: np.ndarray) -> float:\n    'Ratio of foreground width near 1/3 height to width near 2/3 height (upper / lower)'\n    import numpy as np\n    if image is None:\n        return 1.0\n    h, w = image.shape[:2]\n    if h < 3 or w == 0:\n        return 1.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    def mean_width_at_row_band(row_center):\n        band = 1 + max(0, int(round(h * 0.03)))\n        r0 = max(0, row_center - band)\n        r1 = min(h, row_center + band + 1)\n        sub = mask[r0:r1, :]\n        widths = []\n        for r in range(sub.shape[0]):\n            row = sub[r, :]\n            if not np.any(row):\n                continue\n            xs = np.where(row)[0]\n            widths.append(float(xs[-1] - xs[0] + 1))\n        if len(widths) == 0:\n            return 0.0\n        return float(np.mean(widths))\n    up_row = max(0, int(h * 1 / 3))\n    down_row = min(h - 1, int(h * 2 / 3))\n    w_up = mean_width_at_row_band(up_row)\n    w_down = mean_width_at_row_band(down_row)\n    if w_down <= 1e-8:\n        return float(w_up / (1e-8 + 1.0))\n    return float(w_up / (w_down + 1e-8))\n\n", "def feature(image: np.ndarray) -> float:\n    'Count of peaks in vertical projection of foreground (normalized by image width)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    proj = np.sum(mask.astype(float), axis=0)\n    if np.all(proj == 0):\n        return 0.0\n    # simple smoothing\n    pad = np.pad(proj, (1, 1), mode='edge')\n    smooth = (pad[:-2] + pad[1:-1] + pad[2:]) / 3.0\n    peaks = (smooth > np.roll(smooth, 1)) & (smooth > np.roll(smooth, -1))\n    thr_val = np.percentile(smooth, 50)\n    peaks = peaks & (smooth > thr_val)\n    count = float(np.count_nonzero(peaks))\n    return float(count / (w + 1e-8))\n", "def feature(image: np.ndarray) -> float:\n    'Bounding-box area of main mask divided by image area (small for shoes/bags)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    # grayscale\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 50)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    ys, xs = np.where(mask)\n    if ys.size == 0:\n        return 0.0\n    miny, maxy = int(np.min(ys)), int(np.max(ys))\n    minx, maxx = int(np.min(xs)), int(np.max(xs))\n    bbox_area = float((maxy - miny + 1) * (maxx - minx + 1))\n    img_area = float(h * w)\n    return float(bbox_area / (img_area + 1e-8))\n\n", "def feature(image: np.ndarray) -> float:\n    'Height-to-width aspect ratio of the mask bounding box (tall vs wide)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 50)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    ys, xs = np.where(mask)\n    if ys.size == 0:\n        return 0.0\n    miny, maxy = int(np.min(ys)), int(np.max(ys))\n    minx, maxx = int(np.min(xs)), int(np.max(xs))\n    height = float(maxy - miny + 1)\n    width = float(maxx - minx + 1)\n    return float((height + 1e-8) / (width + 1e-8))\n\n", "def feature(image: np.ndarray) -> float:\n    'Fraction of pixels in the bottom 10% of rows that belong to the mask'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    rows = max(1, h // 10)\n    bottom = mask[h - rows:h, :]\n    if bottom.size == 0:\n        return 0.0\n    return float(np.count_nonzero(bottom) / float(bottom.size))\n\n", "def feature(image: np.ndarray) -> float:\n    'Left-right symmetry of the mask measured as intersection-over-union with flipped mask'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 50)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    if not np.any(mask):\n        return 0.0\n    flipped = np.fliplr(mask)\n    inter = np.count_nonzero(mask & flipped)\n    union = np.count_nonzero(mask | flipped)\n    if union == 0:\n        return 0.0\n    return float(inter / float(union))\n\n", "def feature(image: np.ndarray) -> float:\n    'Ratio of principal eigenvalues of mask coordinates (elongation measure, near1 if very elongated)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 50)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    ys, xs = np.where(mask)\n    if ys.size < 2:\n        return 0.0\n    coords = np.vstack([ys.astype(float), xs.astype(float)])\n    cov = np.cov(coords)\n    if cov.shape != (2, 2):\n        return 0.0\n    eig = np.linalg.eigvals(cov)\n    eig = np.sort(np.real(eig))[::-1]\n    if eig[1] <= 0:\n        return 0.0\n    ratio = float(eig[0] / (eig[1] + 1e-8))\n    # normalize to a bounded scale with log\n    return float(np.log1p(ratio))\n\n", "def feature(image: np.ndarray) -> float:\n    'Number of contiguous mask segments in the central column (0..n), useful for leg separation'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    center_col = w // 2\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 50)\n    mask = ((gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)).astype(np.uint8)\n    col = mask[:, center_col]\n    if col.size == 0:\n        return 0.0\n    # count transitions from 0->1\n    dif = np.diff(np.concatenate([[0], col, [0]]))\n    starts = np.count_nonzero(dif == 1)\n    return float(starts)\n\n", "def feature(image: np.ndarray) -> float:\n    'Normalized contrast between mean foreground and mean background intensities (-1..1)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 50)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    if not np.any(mask):\n        return 0.0\n    fg_mean = float(np.mean(gray[mask]))\n    bg = gray[~mask]\n    if bg.size == 0:\n        return 0.0\n    bg_mean = float(np.mean(bg))\n    return float((fg_mean - bg_mean) / (abs(fg_mean) + abs(bg_mean) + 1e-8))\n\n", "def feature(image: np.ndarray) -> float:\n    'Fill factor: fraction of bounding box area occupied by mask (0..1)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    ys, xs = np.where(mask)\n    if ys.size == 0:\n        return 0.0\n    miny, maxy = int(np.min(ys)), int(np.max(ys))\n    minx, maxx = int(np.min(xs)), int(np.max(xs))\n    bbox_area = float((maxy - miny + 1) * (maxx - minx + 1))\n    mask_area = float(np.count_nonzero(mask))\n    return float(mask_area / (bbox_area + 1e-8))\n\n", "def feature(image: np.ndarray) -> float:\n    'Waist-like constriction: min row mask width divided by max row mask width (0..1)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 50)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    row_counts = np.count_nonzero(mask, axis=1).astype(float)\n    if row_counts.size == 0:\n        return 0.0\n    max_w = float(np.max(row_counts))\n    min_w = float(np.min(row_counts))\n    if max_w <= 0:\n        return 0.0\n    return float((min_w + 1e-8) / (max_w + 1e-8))\n\n", "def feature(image: np.ndarray) -> float:\n    'Fraction of mask pixels that touch the bottom image row (useful for boots/trousers)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    area = float(np.count_nonzero(mask))\n    if area == 0:\n        return 0.0\n    bottom_count = float(np.count_nonzero(mask[h - 1, :]))\n    return float(bottom_count / (area + 1e-8))\n", "def feature(image: np.ndarray) -> float:\n    'Left-right symmetry of the foreground mask (1.0 = perfectly symmetric)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    # convert to gray\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 50)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    area = np.count_nonzero(mask)\n    if area == 0:\n        return 0.0\n    flipped = np.fliplr(mask)\n    overlap = np.count_nonzero(mask & flipped)\n    # normalize by average area to be robust to slight cropping\n    denom = float(area + np.count_nonzero(flipped)) / 2.0 + 1e-8\n    return float(overlap / denom)\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Top-bottom symmetry of the foreground mask (1.0 = perfectly symmetric)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 50)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    area = np.count_nonzero(mask)\n    if area == 0:\n        return 0.0\n    flipped = np.flipud(mask)\n    overlap = np.count_nonzero(mask & flipped)\n    denom = float(area + np.count_nonzero(flipped)) / 2.0 + 1e-8\n    return float(overlap / denom)\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Shape elongation from PCA (ratio of principal axis to minor axis)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    coords = np.argwhere(mask)\n    if coords.shape[0] < 3:\n        return 0.0\n    # compute covariance and SVD for stable principal values\n    centered = coords.astype(float) - np.mean(coords.astype(float), axis=0)\n    try:\n        u, s, vt = np.linalg.svd(centered, full_matrices=False)\n    except Exception:\n        # fallback to covariance eigenvals\n        cov = np.cov(centered.T)\n        evals = np.linalg.eigvalsh(cov)\n        s = np.sqrt(np.maximum(evals, 0.0))\n    # s contains singular values; s[0] >= s[1]\n    if s.size < 2 or s[1] <= 0:\n        return float(s[0] / (1e-8 + 1.0))\n    ratio = float(s[0] / (s[1] + 1e-8))\n    return float(ratio)\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Compactness: perimeter^2 divided by area (higher = more outline relative to area)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 50)\n    mask = ((gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)).astype(bool)\n    area = float(np.count_nonzero(mask))\n    if area <= 0:\n        return 0.0\n    # perimeter approximated by counting mask pixels that have at least one 4-neighbor background\n    perim = 0\n    # pad to avoid bounds checks\n    pad = np.pad(mask, ((1, 1), (1, 1)), mode='constant', constant_values=False)\n    for dy, dx in ((-1,0),(1,0),(0,-1),(0,1)):\n        perim += np.sum(mask & ~pad[1+dy:1+dy+h,1+dx:1+dx+w])\n    # each border pixel counted at least once; perim is number of perimeter edges; make nonzero\n    perim = float(max(1, perim))\n    compact = (perim * perim) / (area + 1e-8)\n    return float(compact)\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Hole area fraction inside the foreground bounding box (0 = no holes)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 50)\n    mask = ((gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)).astype(bool)\n    coords = np.argwhere(mask)\n    if coords.size == 0:\n        return 0.0\n    ys, xs = coords[:, 0], coords[:, 1]\n    miny, maxy = int(ys.min()), int(ys.max())\n    minx, maxx = int(xs.min()), int(xs.max())\n    # bounding box region\n    sub = mask[miny:maxy+1, minx:maxx+1]\n    bh, bw = sub.shape\n    bbox_area = float(bh * bw)\n    if bbox_area <= 0:\n        return 0.0\n    # flood-fill background from bbox borders to identify external background\n    bg = ~sub\n    visited = np.zeros_like(bg, dtype=bool)\n    stack = []\n    # add border background positions\n    for i in range(bw):\n        if bg[0, i]:\n            stack.append((0, i))\n            visited[0, i] = True\n        if bg[bh-1, i]:\n            stack.append((bh-1, i))\n            visited[bh-1, i] = True\n    for j in range(bh):\n        if bg[j, 0] and not visited[j, 0]:\n            stack.append((j, 0)); visited[j, 0] = True\n        if bg[j, bw-1] and not visited[j, bw-1]:\n            stack.append((j, bw-1)); visited[j, bw-1] = True\n    while stack:\n        y, x = stack.pop()\n        for ny, nx in ((y-1,x),(y+1,x),(y,x-1),(y,x+1)):\n            if 0 <= ny < bh and 0 <= nx < bw and bg[ny, nx] and not visited[ny, nx]:\n                visited[ny, nx] = True\n                stack.append((ny, nx))\n    external_bg = np.count_nonzero(visited)\n    total_bg = np.count_nonzero(bg)\n    hole_pixels = total_bg - external_bg\n    return float(hole_pixels / (bbox_area + 1e-8))\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Average gradient magnitude along the mask boundary (higher = stronger edges at outline)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 2 or w < 2:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = ((gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)).astype(bool)\n    if not np.any(mask):\n        return 0.0\n    gy, gx = np.gradient(gray.astype(float))\n    grad_mag = np.sqrt(gx * gx + gy * gy)\n    # find boundary pixels (4-neighborhood)\n    pad = np.pad(mask, ((1,1),(1,1)), mode='constant', constant_values=False)\n    boundary = np.zeros_like(mask, dtype=bool)\n    for dy, dx in ((-1,0),(1,0),(0,-1),(0,1)):\n        neighbor = pad[1+dy:1+dy+h, 1+dx:1+dx+w]\n        boundary |= (mask & ~neighbor)\n    bcount = np.count_nonzero(boundary)\n    if bcount == 0:\n        return 0.0\n    avg_grad = float(np.sum(grad_mag[boundary]) / (bcount + 1e-8))\n    return float(avg_grad)\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Relative texture: coefficient of variation (std/mean) of intensities inside mask'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 60)\n    mask = ((gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)).astype(bool)\n    vals = gray[mask]\n    if vals.size == 0:\n        return 0.0\n    mean = float(np.mean(vals))\n    std = float(np.std(vals))\n    return float(std / (abs(mean) + 1e-8))\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Median horizontal mask width (pixels) normalized by image width'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = ((gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)).astype(bool)\n    row_widths = np.sum(mask.astype(float), axis=1)\n    if row_widths.size == 0:\n        return 0.0\n    med = float(np.median(row_widths))\n    return float(med / (w + 1e-8))\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Longest vertical run of mask (consecutive rows with mask) normalized by image height'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = ((gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)).astype(bool)\n    rows_has = np.any(mask, axis=1).astype(int)\n    if rows_has.sum() == 0:\n        return 0.0\n    max_run = 0\n    cur = 0\n    for v in rows_has:\n        if v:\n            cur += 1\n            if cur > max_run:\n                max_run = cur\n        else:\n            cur = 0\n    return float(max_run / (h + 1e-8))\n\n\n", "def feature(image: np.ndarray) -> float:\n    'RGB channel contrast: normalized difference between strongest and weakest channel means (0 for grayscale)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    if len(image.shape) != 3 or image.shape[2] < 3:\n        return 0.0\n    # safe conversion to float\n    img = image.astype(float)\n    means = [float(np.mean(img[:, :, i])) for i in range(3)]\n    mx = max(means)\n    mn = min(means)\n    denom = (mx + mn) + 1e-8\n    return float((mx - mn) / denom)\n", "def feature(image: np.ndarray) -> float:\n    'Foreground bounding-box aspect ratio (height / width) estimated from thresholded mask'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    # grayscale\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    ys, xs = np.where(mask)\n    if ys.size == 0:\n        return 0.0\n    bbox_h = float(ys.max() - ys.min() + 1)\n    bbox_w = float(xs.max() - xs.min() + 1)\n    if bbox_w < 1e-8:\n        return 0.0\n    return float(bbox_h / bbox_w)\n\n", "def feature(image: np.ndarray) -> float:\n    'Normalized vertical centroid of the foreground (0=top,1=bottom)'\n    import numpy as np\n    if image is None:\n        return 0.5\n    h, w = image.shape[:2]\n    if h == 0:\n        return 0.5\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    ys, xs = np.where(mask)\n    if ys.size == 0:\n        return 0.5\n    cy = float(np.mean(ys)) / float(max(1, h - 1))\n    return float(np.clip(cy, 0.0, 1.0))\n\n", "def feature(image: np.ndarray) -> float:\n    'Difference between mean corner intensity (bottom corners) and image center intensity'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    # grayscale\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    # regions\n    bw = max(1, w // 6)\n    bh = max(1, h // 6)\n    bl = gray[h - bh:h, 0:bw]\n    br = gray[h - bh:h, w - bw:w]\n    cx0 = h // 2 - bh // 2\n    cy0 = w // 2 - bw // 2\n    center = gray[max(0, cx0):min(h, cx0 + bh), max(0, cy0):min(w, cy0 + bw)]\n    if center.size == 0:\n        center_mean = np.mean(gray)\n    else:\n        center_mean = np.mean(center)\n    corner_mean = 0.0\n    cnt = 0\n    if bl.size > 0:\n        corner_mean += np.mean(bl); cnt += 1\n    if br.size > 0:\n        corner_mean += np.mean(br); cnt += 1\n    if cnt == 0:\n        return 0.0\n    corner_mean /= cnt\n    # positive if corners brighter than center\n    return float(corner_mean - center_mean)\n\n", "def feature(image: np.ndarray) -> float:\n    'Mean per-pixel RGB saturation (max-min) inside the foreground mask (0 for grayscale images)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    if len(image.shape) != 3 or image.shape[2] < 3:\n        return 0.0\n    h, w, c = image.shape\n    img = image.astype(float)\n    gray = np.mean(img, axis=2)\n    thr = np.percentile(gray, 55)\n    mask = gray < thr if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else gray > thr\n    if not np.any(mask):\n        return 0.0\n    R = img[:, :, 0]\n    G = img[:, :, 1]\n    B = img[:, :, 2]\n    sat = np.maximum.reduce([R, G, B]) - np.minimum.reduce([R, G, B])\n    mean_sat = float(np.sum(sat * mask) / np.count_nonzero(mask))\n    denom = max(1.0, float(np.max(img) - np.min(img)))\n    return float(mean_sat / denom)\n\n", "def feature(image: np.ndarray) -> float:\n    'Foreground area divided by its bounding-box area (solidity-like, in [0,1])'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    area = float(np.count_nonzero(mask))\n    if area == 0.0:\n        return 0.0\n    ys, xs = np.where(mask)\n    if ys.size == 0:\n        return 0.0\n    bbox_h = float(ys.max() - ys.min() + 1)\n    bbox_w = float(xs.max() - xs.min() + 1)\n    bbox_area = max(1.0, bbox_h * bbox_w)\n    return float(np.clip(area / bbox_area, 0.0, 1.0))\n\n", "def feature(image: np.ndarray) -> float:\n    'Number of foreground segments in the central vertical column (counts separated vertical blobs)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    col = w // 2\n    col_mask = mask[:, col] if col >= 0 and col < w else np.zeros((h,), dtype=bool)\n    if col_mask.size == 0:\n        return 0.0\n    # count rising edges from 0->1\n    padded = np.concatenate([[0], col_mask.astype(int), [0]])\n    transitions = np.diff(padded)\n    starts = np.count_nonzero(transitions == 1)\n    return float(starts)\n\n", "def feature(image: np.ndarray) -> float:\n    'Mean gradient magnitude in the lower quarter of the image normalized by global mean gradient'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 2 or w < 2:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    gy, gx = np.gradient(gray.astype(float))\n    grad = np.sqrt(gx * gx + gy * gy)\n    lower_start = (3 * h) // 4\n    lower = grad[lower_start:h, :]\n    mean_lower = float(np.mean(lower)) if lower.size > 0 else 0.0\n    mean_global = float(np.mean(grad)) + 1e-8\n    return float(mean_lower / mean_global)\n\n", "def feature(image: np.ndarray) -> float:\n    'Skewness of foreground row widths (third standardized moment), 0 if undefined'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    row_widths = np.sum(mask, axis=1).astype(float)\n    if row_widths.size == 0:\n        return 0.0\n    mu = np.mean(row_widths)\n    sigma = np.std(row_widths)\n    if sigma < 1e-8:\n        return 0.0\n    skew = np.mean(((row_widths - mu) ** 3)) / (sigma ** 3)\n    return float(skew)\n\n", "def feature(image: np.ndarray) -> float:\n    'Ratio of foreground fraction in top quarter vs bottom quarter (top_frac / bottom_frac)'\n    import numpy as np\n    if image is None:\n        return 1.0\n    h, w = image.shape[:2]\n    if h < 4 or w == 0:\n        return 1.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    top_h = max(1, h // 4)\n    top = mask[0:top_h, :]\n    bottom = mask[h - top_h:h, :]\n    top_frac = float(np.count_nonzero(top)) / float(top.size) if top.size > 0 else 0.0\n    bottom_frac = float(np.count_nonzero(bottom)) / float(bottom.size) if bottom.size > 0 else 0.0\n    return float(top_frac / (bottom_frac + 1e-8))\n\n", "def feature(image: np.ndarray) -> float:\n    'Compactness measure: perimeter^2 / area for the foreground (larger = less compact)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    area = float(np.count_nonzero(mask))\n    if area < 1e-8:\n        return 0.0\n    m = mask.astype(bool)\n    # pad with False so borders count as edges\n    pm = np.pad(m, ((1, 1), (1, 1)), mode='constant', constant_values=False)\n    up = pm[:-2, 1:-1]\n    down = pm[2:, 1:-1]\n    left = pm[1:-1, :-2]\n    right = pm[1:-1, 2:]\n    interior = up & down & left & right\n    # boundary pixels: mask True but not interior\n    boundary = m & (~interior)\n    perimeter = float(np.count_nonzero(boundary))\n    compactness = (perimeter * perimeter) / area\n    return float(compactness)\n", "def feature(image: np.ndarray) -> float:\n    'Bounding-box height-to-width ratio of the detected foreground mask'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 50)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    coords = np.argwhere(mask)\n    if coords.size == 0:\n        return 0.0\n    ys, xs = coords[:, 0], coords[:, 1]\n    bh = float(max(1, int(ys.max()) - int(ys.min()) + 1))\n    bw = float(max(1, int(xs.max()) - int(xs.min()) + 1))\n    return float(bh / (bw + 1e-8))\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Normalized vertical centroid of the foreground (0=top, 1=bottom)'\n    import numpy as np\n    if image is None:\n        return 0.5\n    h, w = image.shape[:2]\n    if h == 0:\n        return 0.5\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    ys = np.where(mask)[0]\n    if ys.size == 0:\n        return 0.5\n    y_mean = float(np.mean(ys))\n    return float(y_mean / max(1.0, (h - 1)))\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Fraction of image pixels belonging to the foreground mask (mask area / image area)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    total = float(max(1, h * w))\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 50)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    area = float(np.count_nonzero(mask))\n    return float(area / total)\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Left-right mirror symmetry score of the foreground mask (1.0 = perfect symmetry)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if w == 0 or h == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = ((gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)).astype(bool)\n    if not np.any(mask):\n        return 0.0\n    flipped = np.fliplr(mask)\n    # align centers; compute overlap\n    overlap = np.count_nonzero(mask & flipped)\n    area = float(np.count_nonzero(mask))\n    return float(overlap / (area + 1e-8))\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Perimeter-to-area ratio estimated from mask gradients (edge pixels / mask area)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 2 or w < 2:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 50)\n    mask = ((gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)).astype(float)\n    area = np.count_nonzero(mask)\n    if area == 0:\n        return 0.0\n    gy, gx = np.gradient(mask)\n    edge_strength = np.abs(gy) + np.abs(gx)\n    edge_pixels = float(np.count_nonzero(edge_strength > 0.1))\n    return float(edge_pixels / (float(area) + 1e-8))\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Average per-pixel color saturation (approx) for RGB images, 0 for grayscale'\n    import numpy as np\n    if image is None:\n        return 0.0\n    if len(image.shape) != 3 or image.shape[2] < 3:\n        return 0.0\n    img = image.astype(float)\n    mx = np.max(img, axis=2)\n    mn = np.min(img, axis=2)\n    denom = mx + 1e-8\n    sat = (mx - mn) / denom\n    return float(np.mean(sat))\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Mean foreground width at waist row (around 55% height) normalized by image width'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if w == 0 or h == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    row = int(min(h - 1, max(0, int(0.55 * h))))\n    band = max(1, int(h * 0.02))\n    start = max(0, row - band)\n    end = min(h, row + band + 1)\n    widths = np.sum(mask[start:end, :].astype(float), axis=1)\n    if widths.size == 0:\n        return 0.0\n    mean_width = float(np.mean(widths))\n    return float(mean_width / max(1.0, float(w)))\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Fraction of the bottom 12% of image rows occupied by foreground (bottom occupancy)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    box_h = max(1, int(h * 0.12))\n    bottom = mask[h - box_h:h, :]\n    occupied = float(np.count_nonzero(bottom))\n    area = float(box_h * w)\n    return float(occupied / (area + 1e-8))\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Fraction of empty pixels in the top 20% of the foreground bounding box (top gap ratio)'\n    import numpy as np\n    if image is None:\n        return 1.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 1.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 50)\n    mask = ((gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)).astype(bool)\n    coords = np.argwhere(mask)\n    if coords.size == 0:\n        return 1.0\n    ys, xs = coords[:, 0], coords[:, 1]\n    miny, maxy = int(ys.min()), int(ys.max())\n    minx, maxx = int(xs.min()), int(xs.max())\n    sub = mask[miny:maxy+1, minx:maxx+1]\n    bh = sub.shape[0]\n    top_band = max(1, int(bh * 0.2))\n    top_region = sub[0:top_band, :]\n    empty = float(np.count_nonzero(~top_region))\n    total = float(top_region.size)\n    return float(empty / (total + 1e-8))\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Ratio of high-frequency energy in the top half to the bottom half (laplacian energy ratio)'\n    import numpy as np\n    if image is None:\n        return 1.0\n    h, w = image.shape[:2]\n    if h < 3 or w < 3:\n        return 1.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    # compute Laplacian (same kernel used in other features)\n    pad = np.pad(gray, 1, mode='edge').astype(float)\n    center = pad[1:-1, 1:-1]\n    up = pad[0:-2, 1:-1]\n    down = pad[2:, 1:-1]\n    left = pad[1:-1, 0:-2]\n    right = pad[1:-1, 2:]\n    lap = up + down + left + right - 4.0 * center\n    mid = h // 2\n    top_energy = float(np.mean(np.abs(lap[0:mid, :]))) if mid > 0 else 0.0\n    bot_energy = float(np.mean(np.abs(lap[mid:, :]))) if h - mid > 0 else 0.0\n    return float((top_energy + 1e-8) / (bot_energy + 1e-8))\n", "def feature(image: np.ndarray) -> float:\n    'Fraction of image occupied by a simple foreground mask (area / image area)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    # grayscale convert\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 50)\n    mask_dark = gray < thr\n    mask_bright = gray > thr\n    mask = mask_dark if np.count_nonzero(mask_dark) >= np.count_nonzero(mask_bright) else mask_bright\n    area = float(np.count_nonzero(mask))\n    return float(area / float(h * w))\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Vertical centroid (center of mass) of the foreground mask normalized to [0,1]'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h <= 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 60)\n    mask = gray < thr if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else gray > thr\n    if np.count_nonzero(mask) == 0:\n        return 0.0\n    rows = np.arange(h).astype(float)\n    row_sums = np.sum(mask, axis=1).astype(float)\n    total = np.sum(row_sums)\n    if total <= 0:\n        return 0.0\n    v_cent = float(np.sum(rows * row_sums) / total)\n    return float(v_cent / max(1.0, h - 1))\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Average gradient magnitude in the bottom quarter normalized by global mean gradient'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    gy, gx = np.gradient(gray)\n    grad = np.sqrt(gx * gx + gy * gy)\n    bottom_start = (3 * h) // 4\n    bottom = grad[bottom_start:h, :]\n    if bottom.size == 0:\n        return 0.0\n    bottom_mean = float(np.mean(bottom))\n    global_mean = float(np.mean(grad)) + 1e-8\n    return float(bottom_mean / global_mean)\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Horizontal spread (std) of foreground x-coordinates in the top quarter normalized by image width'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = gray < thr if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else gray > thr\n    top_end = max(1, h // 4)\n    region = mask[:top_end, :]\n    if np.count_nonzero(region) == 0:\n        return 0.0\n    xs, ys = np.where(region)\n    if xs.size == 0:\n        return 0.0\n    std_x = float(np.std(ys.astype(float)))\n    return float(std_x / max(1.0, w))\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Aspect ratio (width / height) of the bounding box of the simple foreground mask'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 60)\n    mask = gray < thr if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else gray > thr\n    rows = np.any(mask, axis=1)\n    cols = np.any(mask, axis=0)\n    if not np.any(rows) or not np.any(cols):\n        return 0.0\n    rmin = int(np.argmax(rows))\n    rmax = int(len(rows) - 1 - np.argmax(rows[::-1]))\n    cmin = int(np.argmax(cols))\n    cmax = int(len(cols) - 1 - np.argmax(cols[::-1]))\n    bbox_h = max(1, rmax - rmin + 1)\n    bbox_w = max(1, cmax - cmin + 1)\n    return float(bbox_w / float(bbox_h + 1e-8))\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Count of prominent vertical peaks in the vertical profile (number of wide regions along height)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = gray < thr if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else gray > thr\n    row_widths = np.sum(mask, axis=1).astype(float)\n    if row_widths.size == 0:\n        return 0.0\n    maxw = np.max(row_widths)\n    if maxw <= 1e-8:\n        return 0.0\n    peak_thr = max(1.0, 0.5 * maxw)\n    above = row_widths >= peak_thr\n    # Count rising edges (0->1)\n    diffs = np.diff(above.astype(int))\n    peaks = int(np.sum(diffs == 1))\n    # if starts above threshold, count that as a peak\n    if above.size > 0 and above[0]:\n        peaks += 1\n    return float(peaks)\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Mean saturation in the central region (RGB only), 0 for grayscale'\n    import numpy as np\n    if image is None:\n        return 0.0\n    if len(image.shape) != 3 or image.shape[2] < 3:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    img = image.astype(float)\n    R = img[:, :, 0]\n    G = img[:, :, 1]\n    B = img[:, :, 2]\n    maxc = np.maximum(np.maximum(R, G), B)\n    minc = np.minimum(np.minimum(R, G), B)\n    sat = (maxc - minc) / (maxc + 1e-8)\n    ch = h // 4\n    cw = w // 4\n    center = sat[ch: h - ch if h - ch > ch else h, cw: w - cw if w - cw > cw else w]\n    if center.size == 0:\n        return 0.0\n    return float(np.mean(center))\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Top-bottom similarity: normalized correlation between top half and vertically flipped bottom half'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 2 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    top = gray[:h // 2, :]\n    bottom = gray[h - (h // 2):, :]\n    if top.size == 0 or bottom.size == 0:\n        return 0.0\n    # align heights\n    minh = min(top.shape[0], bottom.shape[0])\n    top = top[:minh, :].ravel()\n    bottom = np.flipud(bottom[:minh, :]) .ravel()\n    if top.size == 0 or bottom.size == 0:\n        return 0.0\n    tmean = top.mean()\n    bmean = bottom.mean()\n    tc = top - tmean\n    bc = bottom - bmean\n    denom = np.sqrt(np.sum(tc * tc) * np.sum(bc * bc)) + 1e-8\n    corr = np.sum(tc * bc) / denom\n    return float(abs(corr))\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Ratio of vertical gradient energy to horizontal gradient energy (captures dominant orientation)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    gy, gx = np.gradient(gray)\n    vert_energy = float(np.sum(np.abs(gy)))\n    horz_energy = float(np.sum(np.abs(gx))) + 1e-8\n    return float(vert_energy / horz_energy)\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Contrast between interior of foreground bounding box and its immediate border (border_mean - inner_mean) normalized'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = gray < thr if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else gray > thr\n    rows_any = np.any(mask, axis=1)\n    cols_any = np.any(mask, axis=0)\n    if not np.any(rows_any) or not np.any(cols_any):\n        return 0.0\n    rmin = int(np.argmax(rows_any))\n    rmax = int(len(rows_any) - 1 - np.argmax(rows_any[::-1]))\n    cmin = int(np.argmax(cols_any))\n    cmax = int(len(cols_any) - 1 - np.argmax(cols_any[::-1]))\n    # inner box\n    rmin, rmax = max(0, rmin), min(h - 1, rmax)\n    cmin, cmax = max(0, cmin), min(w - 1, cmax)\n    if rmax < rmin or cmax < cmin:\n        return 0.0\n    inner = gray[rmin:rmax + 1, cmin:cmax + 1]\n    # border box: expand by 5% of dims\n    pad_r = max(1, (rmax - rmin + 1) // 20)\n    pad_c = max(1, (cmax - cmin + 1) // 20)\n    ormin = max(0, rmin - pad_r)\n    ormax = min(h - 1, rmax + pad_r)\n    ocmin = max(0, cmin - pad_c)\n    ocmax = min(w - 1, cmax + pad_c)\n    outer = gray[ormin:ormax + 1, ocmin:ocmax + 1]\n    # border region is outer minus inner\n    if outer.size == 0 or inner.size == 0:\n        return 0.0\n    # compute means\n    inner_mean = float(np.mean(inner))\n    outer_mean = float(np.mean(outer))\n    border_mean = (outer_mean * outer.size - inner_mean * inner.size) / max(1.0, float(outer.size - inner.size))\n    denom = (abs(border_mean) + 1e-8)\n    return float((border_mean - inner_mean) / denom)\n", "def feature(image: np.ndarray) -> float:\n    'Bounding-box fill ratio: mask area divided by bounding-box area (1 = full)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 50)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    ys, xs = np.where(mask)\n    if ys.size == 0:\n        return 0.0\n    y0, y1 = ys.min(), ys.max()\n    x0, x1 = xs.min(), xs.max()\n    bbox_area = float((y1 - y0 + 1) * (x1 - x0 + 1))\n    mask_area = float(ys.size)\n    result = mask_area / (bbox_area + 1e-8)\n    return float(result)\n\n", "def feature(image: np.ndarray) -> float:\n    'Normalized vertical centroid of the foreground mask (0=top,1=bottom)'\n    import numpy as np\n    if image is None:\n        return 0.5\n    h, w = image.shape[:2]\n    if h == 0:\n        return 0.5\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 50)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    ys, xs = np.where(mask)\n    if ys.size == 0:\n        return 0.5\n    centroid_y = float(np.mean(ys)) / float(max(1, h - 1))\n    return float(centroid_y)\n\n", "def feature(image: np.ndarray) -> float:\n    'Left-right symmetry score of the mask (1.0 = perfectly symmetric)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 50)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    m = mask.astype(bool)\n    flipped = np.fliplr(m)\n    area = np.count_nonzero(m)\n    if area == 0:\n        return 0.0\n    diff = np.count_nonzero(np.logical_xor(m, flipped))\n    score = 1.0 - float(diff) / float(area)\n    return float(max(0.0, min(1.0, score)))\n\n", "def feature(image: np.ndarray) -> float:\n    'Fraction of foreground located in the central vertical band (centeredness)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    total = float(np.count_nonzero(mask))\n    if total == 0:\n        return 0.0\n    left = w // 4\n    right = w - left\n    center_frac = float(np.count_nonzero(mask[:, left:right])) / float(total)\n    return float(center_frac)\n\n", "def feature(image: np.ndarray) -> float:\n    'Edge contrast ratio: mean gradient magnitude in border vs center (higher => stronger border)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 3 or w < 3:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    gy, gx = np.gradient(gray)\n    grad = np.sqrt(gx * gx + gy * gy)\n    b = int(max(1, round(min(h, w) * 0.12)))\n    top = grad[:b, :]\n    bottom = grad[-b:, :]\n    left = grad[:, :b]\n    right = grad[:, -b:]\n    border_vals = np.concatenate([top.flatten(), bottom.flatten(), left.flatten(), right.flatten()])\n    ch = int(max(1, h // 4))\n    cw = int(max(1, w // 4))\n    center_vals = grad[ch:-ch or None, cw:-cw or None].flatten()\n    mean_border = float(np.mean(border_vals)) if border_vals.size > 0 else 0.0\n    mean_center = float(np.mean(center_vals)) if center_vals.size > 0 else 0.0\n    result = mean_border / (mean_center + 1e-8)\n    return float(result)\n\n", "def feature(image: np.ndarray) -> float:\n    'Number of prominent vertical peaks in the mask vertical profile (rows) (integer-like)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 3 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    row_widths = np.sum(mask, axis=1).astype(float)\n    if row_widths.size < 3:\n        return 0.0\n    mean_w = float(np.mean(row_widths))\n    peaks = 0\n    # count local maxima that are reasonably above baseline\n    for i in range(1, row_widths.size - 1):\n        if row_widths[i] > row_widths[i - 1] and row_widths[i] > row_widths[i + 1] and row_widths[i] > 0.5 * mean_w:\n            peaks += 1\n    return float(peaks)\n\n", "def feature(image: np.ndarray) -> float:\n    'Mean blue minus red channel normalized by overall brightness (positive => bluish)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    if len(image.shape) != 3 or image.shape[2] != 3:\n        return 0.0\n    img = image.astype(float)\n    R = img[:, :, 0]\n    G = img[:, :, 1]\n    B = img[:, :, 2]\n    meanR = float(np.mean(R))\n    meanB = float(np.mean(B))\n    mean_all = float(np.mean(img))\n    result = (meanB - meanR) / (abs(mean_all) + 1e-8)\n    return float(result)\n\n", "def feature(image: np.ndarray) -> float:\n    'Neck opening index: width near top (10%) divided by width a bit lower (22%) (lower => neck cut)'\n    import numpy as np\n    if image is None:\n        return 1.0\n    h, w = image.shape[:2]\n    if h < 6 or w == 0:\n        return 1.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    def width_at(frac):\n        row = int(min(h - 1, max(0, int(frac * h))))\n        band = max(1, int(h * 0.01))\n        start = max(0, row - band)\n        end = min(h, row + band + 1)\n        widths = np.sum(mask[start:end, :].astype(float), axis=1)\n        if widths.size == 0:\n            return 0.0\n        return float(np.mean(widths))\n    top_w = width_at(0.10)\n    lower_w = width_at(0.22)\n    result = top_w / (lower_w + 1e-8)\n    return float(result)\n\n", "def feature(image: np.ndarray) -> float:\n    'Fraction of mask pixels touching the bottom band (bottom 10% rows)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    total = float(np.count_nonzero(mask))\n    if total == 0.0:\n        return 0.0\n    band = max(1, int(round(h * 0.10)))\n    bottom_count = float(np.count_nonzero(mask[-band:, :]))\n    result = bottom_count / total\n    return float(result)\n\n", "def feature(image: np.ndarray) -> float:\n    'Bounding-box aspect ratio of the mask (height / width), 0 if no mask'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 50)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    ys, xs = np.where(mask)\n    if ys.size == 0:\n        return 0.0\n    height = float(ys.max() - ys.min() + 1)\n    width = float(xs.max() - xs.min() + 1)\n    if width <= 0.0:\n        return 0.0\n    return float(height / (width + 1e-8))\n", "def feature(image: np.ndarray) -> float:\n    'Normalized vertical centroid of the foreground mask (0=top,1=bottom)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 50)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    ys, xs = np.where(mask)\n    if ys.size == 0:\n        return 0.0\n    centroid_y = float(np.mean(ys))\n    return float(centroid_y / float(max(1, h - 1)))\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Bounding-box width-to-height ratio of the foreground mask (width/height)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    ys, xs = np.where(mask)\n    if ys.size == 0:\n        return 0.0\n    miny, maxy = int(np.min(ys)), int(np.max(ys))\n    minx, maxx = int(np.min(xs)), int(np.max(xs))\n    bw = float(maxx - minx + 1)\n    bh = float(maxy - miny + 1)\n    if bh <= 1e-8:\n        return 0.0\n    return float(bw / bh)\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Fraction of foreground pixels located in the bottom quarter of the image'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 50)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    total = float(np.count_nonzero(mask))\n    if total <= 0.0:\n        return 0.0\n    bottom_start = max(0, int(0.75 * h))\n    bottom_mask = mask[bottom_start:, :]\n    bottom_count = float(np.count_nonzero(bottom_mask))\n    return float(bottom_count / total)\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Colorfulness metric for RGB images (0 for grayscale) using rg/yb stats'\n    import numpy as np\n    if image is None:\n        return 0.0\n    if len(image.shape) != 3 or image.shape[2] < 3:\n        return 0.0\n    # operate on float channels\n    img = image.astype(float)\n    R = img[:, :, 0]\n    G = img[:, :, 1]\n    B = img[:, :, 2]\n    rg = R - G\n    yb = 0.5 * (R + G) - B\n    std_rg = float(np.std(rg))\n    std_yb = float(np.std(yb))\n    mean_rg = float(np.mean(rg))\n    mean_yb = float(np.mean(yb))\n    colorfulness = np.sqrt(std_rg * std_rg + std_yb * std_yb) + 0.3 * (abs(mean_rg) + abs(mean_yb))\n    return float(colorfulness)\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Foreground-background mean intensity contrast (background - foreground) normalized'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 50)\n    mask_fg = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    fg_vals = gray[mask_fg]\n    bg_vals = gray[~mask_fg]\n    if fg_vals.size == 0 or bg_vals.size == 0:\n        return 0.0\n    mean_fg = float(np.mean(fg_vals))\n    mean_bg = float(np.mean(bg_vals))\n    denom = float(np.std(gray) + 1e-8)\n    return float((mean_bg - mean_fg) / denom)\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Shoulder-to-hip mask width ratio (width at ~18% height divided by width at ~45% height)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 5 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    def row_width(row_index):\n        row = mask[min(h - 1, max(0, row_index)), :]\n        return float(np.count_nonzero(row))\n    shoulder_row = int(0.18 * h)\n    hip_row = int(0.45 * h)\n    shoulder_w = row_width(shoulder_row)\n    hip_w = row_width(hip_row)\n    if hip_w <= 1e-8:\n        return 0.0\n    return float((shoulder_w / hip_w))\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Left-right mass imbalance in center band (absolute difference normalized by total)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 3 or w < 2:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 50)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    start = int(0.30 * h)\n    end = int(0.70 * h)\n    band = mask[start:end, :]\n    if band.size == 0:\n        return 0.0\n    mid = w // 2\n    left_sum = float(np.count_nonzero(band[:, :mid]))\n    right_sum = float(np.count_nonzero(band[:, mid:]))\n    total = left_sum + right_sum\n    if total <= 0.0:\n        return 0.0\n    return float(abs(left_sum - right_sum) / total)\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Laplacian variance inside the foreground (texture energy indicator)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 3 or w < 3:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 50)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    # compute approximate Laplacian via gradients\n    gy, gx = np.gradient(gray.astype(float))\n    gxx = np.gradient(gx, axis=1)\n    gyy = np.gradient(gy, axis=0)\n    lap = gxx + gyy\n    lap_fg = lap[mask]\n    if lap_fg.size == 0:\n        return 0.0\n    # use variance (higher for textured objects like shoes)\n    return float(np.var(lap_fg))\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Relative top-edge gradient prominence: mean vertical gradient magnitude in top band / full image'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 2 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    gy, gx = np.gradient(gray.astype(float))\n    grad_mag = np.sqrt(gx * gx + gy * gy)\n    top_h = max(1, int(0.12 * h))\n    top_band = grad_mag[:top_h, :]\n    mean_top = float(np.mean(top_band)) if top_band.size > 0 else 0.0\n    mean_all = float(np.mean(grad_mag)) if grad_mag.size > 0 else 1.0\n    denom = max(1e-8, mean_all)\n    return float(mean_top / denom)\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Overall foreground pixel density (fraction of image pixels that belong to foreground)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    total_pixels = float(h * w)\n    if total_pixels <= 0.0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    fg_count = float(np.count_nonzero(mask))\n    return float(fg_count / total_pixels)\n", "def feature(image: np.ndarray) -> float:\n    'Ratio of mask mass in top half to bottom half ( >1 means more mass in top)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    top = float(np.count_nonzero(mask[:h // 2, :]))\n    bottom = float(np.count_nonzero(mask[h // 2:, :]))\n    if bottom <= 1e-8:\n        return float(top / (bottom + 1e-8))\n    return float(top / bottom)\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Vertical symmetry score computed on the binary mask (1.0 = perfect symmetry)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    mid = w // 2\n    left = mask[:, :mid].astype(float)\n    right = mask[:, w - left.shape[1]:].astype(float)\n    # flip right to align\n    right_flipped = right[:, ::-1]\n    total = np.sum(left) + np.sum(right_flipped) + 1e-8\n    diff = np.sum(np.abs(left - right_flipped))\n    score = 1.0 - (diff / total)\n    return float(score)\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Mean number of contiguous mask segments per row in the lower 40% (detects two-leg gap)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = ((gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)).astype(np.uint8)\n    start_row = int(h * 0.6)\n    rows = mask[start_row:, :]\n    if rows.size == 0:\n        return 0.0\n    seg_counts = []\n    for r in range(rows.shape[0]):\n        row = rows[r, :]\n        # count transitions from 0->1\n        prev = 0\n        seg = 0\n        for v in row:\n            if v and not prev:\n                seg += 1\n            prev = v\n        seg_counts.append(seg)\n    if len(seg_counts) == 0:\n        return 0.0\n    return float(np.mean(seg_counts))\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Perimeter-to-area ratio of the main mask (higher = thinner/more complex shapes)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = ((gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)).astype(np.uint8)\n    area = float(np.count_nonzero(mask))\n    if area <= 0:\n        return 0.0\n    # 4-neighbor boundary detection\n    padded = np.pad(mask, ((1, 1), (1, 1)), mode='constant', constant_values=0)\n    center = padded[1:-1, 1:-1]\n    up = padded[0:-2, 1:-1]\n    down = padded[2:, 1:-1]\n    left = padded[1:-1, 0:-2]\n    right = padded[1:-1, 2:]\n    boundary = (center & (~up | ~down | ~left | ~right)).astype(np.uint8)\n    perimeter = float(np.count_nonzero(boundary))\n    return float(perimeter / (area + 1e-8))\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Mean gradient magnitude of the gray image (texture/edge strength)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 2 or w < 2:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    gy, gx = np.gradient(gray.astype(float))\n    grad = np.sqrt(gx * gx + gy * gy)\n    mean_grad = float(np.mean(grad))\n    return float(mean_grad)\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Normalized red-minus-blue channel mean (positive => red bias, negative => blue bias), 0 for grayscale'\n    import numpy as np\n    if image is None:\n        return 0.0\n    if len(image.shape) != 3 or image.shape[2] < 3:\n        return 0.0\n    img = image.astype(float)\n    r = float(np.mean(img[:, :, 0]))\n    g = float(np.mean(img[:, :, 1]))\n    b = float(np.mean(img[:, :, 2]))\n    denom = (r + g + b) + 1e-8\n    return float((r - b) / denom)\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Minimum row mask width divided by maximum row mask width (small values = narrow waist / leg separation)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 50)\n    mask = ((gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)).astype(np.uint8)\n    row_widths = np.count_nonzero(mask, axis=1).astype(float)\n    if row_widths.size == 0:\n        return 0.0\n    max_w = float(np.max(row_widths))\n    min_w = float(np.min(row_widths))\n    if max_w <= 1e-8:\n        return 0.0\n    return float(min_w / (max_w + 1e-8))\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Fraction of rows in the upper 25% that show two opposing mask segments separated by a central gap'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = ((gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)).astype(np.uint8)\n    end_row = max(1, int(h * 0.25))\n    rows = mask[:end_row, :]\n    if rows.size == 0:\n        return 0.0\n    count = 0\n    for r in range(rows.shape[0]):\n        row = rows[r, :]\n        # find segments (start,end) indices\n        segs = []\n        in_seg = False\n        start = 0\n        for i, v in enumerate(row):\n            if v and not in_seg:\n                in_seg = True\n                start = i\n            if not v and in_seg:\n                in_seg = False\n                segs.append((start, i - 1))\n        if in_seg:\n            segs.append((start, row.size - 1))\n        if len(segs) >= 2:\n            # check if there is a central large gap between left-most and right-most\n            left_end = segs[0][1]\n            right_start = segs[-1][0]\n            gap = right_start - left_end\n            if gap >= max(2, int(0.12 * w)):  # sizable gap\n                count += 1\n    return float(count / (rows.shape[0] + 1e-8))\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Ratio of average mask width near top (10%) to average width near bottom (90%)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 4 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = ((gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)).astype(np.uint8)\n    def avg_width_at_frac(frac, band=2):\n        row = int(min(h - 1, max(0, int(frac * h))))\n        start = max(0, row - band)\n        end = min(h, row + band + 1)\n        widths = np.sum(mask[start:end, :].astype(float), axis=1)\n        if widths.size == 0:\n            return 0.0\n        return float(np.mean(widths))\n    top_w = avg_width_at_frac(0.10)\n    bot_w = avg_width_at_frac(0.90)\n    if bot_w <= 1e-8:\n        return float(top_w / (bot_w + 1e-8))\n    return float(top_w / bot_w)\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Mean absolute orientation angle (0..1) of mask boundary normals (0 = horizontal, 1 = vertical)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 2 or w < 2:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = ((gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)).astype(np.uint8)\n    if np.count_nonzero(mask) == 0:\n        return 0.0\n    gy, gx = np.gradient(gray.astype(float))\n    # boundary mask (4-neighbor)\n    padded = np.pad(mask, ((1, 1), (1, 1)), mode='constant', constant_values=0)\n    center = padded[1:-1, 1:-1]\n    up = padded[0:-2, 1:-1]\n    down = padded[2:, 1:-1]\n    left = padded[1:-1, 0:-2]\n    right = padded[1:-1, 2:]\n    boundary = (center & (~up | ~down | ~left | ~right))\n    if not np.any(boundary):\n        return 0.0\n    bx = gx[boundary]\n    by = gy[boundary]\n    # orientation angle relative to horizontal: atan2(|by|, |bx|) in [0, pi/2]\n    ang = np.arctan2(np.abs(by) + 1e-12, np.abs(bx) + 1e-12)\n    # normalize to 0..1 where 0 => horizontal (0 deg), 1 => vertical (90 deg)\n    norm = ang / (np.pi / 2.0)\n    return float(np.mean(norm))\n", "def feature(image: np.ndarray) -> float:\n    'Bounding-box width to height ratio of the foreground mask (w/h)'\n    import numpy as np\n    if image is None:\n        return 1.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 1.0\n    # grayscale\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = ((gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)).astype(bool)\n    if not np.any(mask):\n        return 1.0\n    rows = np.any(mask, axis=1)\n    cols = np.any(mask, axis=0)\n    r_idx = np.where(rows)[0]\n    c_idx = np.where(cols)[0]\n    if r_idx.size == 0 or c_idx.size == 0:\n        return 1.0\n    bbox_h = float(r_idx[-1] - r_idx[0] + 1)\n    bbox_w = float(c_idx[-1] - c_idx[0] + 1)\n    if bbox_h <= 0:\n        return 1.0\n    return float((bbox_w + 1e-8) / (bbox_h + 1e-8))\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Approximate number of connected components in the foreground mask (downsampled)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = ((gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)).astype(bool)\n    if not np.any(mask):\n        return 0.0\n    # downsample to speed up large images\n    max_side = max(h, w)\n    stride = int(max(1, max_side // 64))\n    m = mask[::stride, ::stride]\n    H, W = m.shape\n    visited = np.zeros_like(m, dtype=bool)\n    comps = 0\n    for i in range(H):\n        for j in range(W):\n            if m[i, j] and not visited[i, j]:\n                comps += 1\n                # BFS/DFS\n                stack = [(i, j)]\n                visited[i, j] = True\n                while stack:\n                    y, x = stack.pop()\n                    if y > 0 and m[y - 1, x] and not visited[y - 1, x]:\n                        visited[y - 1, x] = True\n                        stack.append((y - 1, x))\n                    if y + 1 < H and m[y + 1, x] and not visited[y + 1, x]:\n                        visited[y + 1, x] = True\n                        stack.append((y + 1, x))\n                    if x > 0 and m[y, x - 1] and not visited[y, x - 1]:\n                        visited[y, x - 1] = True\n                        stack.append((y, x - 1))\n                    if x + 1 < W and m[y, x + 1] and not visited[y, x + 1]:\n                        visited[y, x + 1] = True\n                        stack.append((y, x + 1))\n    # cap to avoid huge values\n    return float(min(comps, 100))\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Normalized horizontal centroid offset of the mask (-1 left .. +1 right)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = ((gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)).astype(bool)\n    if not np.any(mask):\n        return 0.0\n    xs = np.arange(w)[None, :]\n    mass = mask.astype(float)\n    total = float(np.sum(mass)) + 1e-8\n    centroid_x = float(np.sum(xs * mass) / total)\n    norm = (centroid_x / float(w) - 0.5) * 2.0\n    return float(max(-1.0, min(1.0, norm)))\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Magnitude-weighted average edge orientation in the center region mapped as cos(2*theta) (1=horizontal, -1=vertical)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 2 or w < 2:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    ch = max(1, h // 4)\n    cw = max(1, w // 4)\n    center = gray[ch:3*ch, cw:3*cw]\n    if center.size == 0:\n        return 0.0\n    gy, gx = np.gradient(center)\n    mag = np.sqrt(gx * gx + gy * gy)\n    if not np.any(mag):\n        return 0.0\n    angles = np.arctan2(gy, gx)\n    # cos(2*theta) discriminates horizontal vs vertical\n    val = np.sum(np.cos(2.0 * angles) * mag) / (np.sum(mag) + 1e-8)\n    return float(val)\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Fraction of mask pixels located in the bottom quartile of the image'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = ((gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)).astype(bool)\n    if not np.any(mask):\n        return 0.0\n    cut = max(1, h - h // 4)\n    bottom_mask = mask[cut:h, :]\n    return float(np.count_nonzero(bottom_mask) / (np.count_nonzero(mask) + 1e-8))\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Mean color saturation (HSV-style) for RGB images, 0 for grayscale'\n    import numpy as np\n    if image is None:\n        return 0.0\n    if len(image.shape) != 3 or image.shape[2] < 3:\n        return 0.0\n    rgb = image.astype(float)\n    # use channel order as provided (assume R,G,B)\n    mx = np.max(rgb, axis=2)\n    mn = np.min(rgb, axis=2)\n    sat = np.where(mx > 0, (mx - mn) / (mx + 1e-8), 0.0)\n    # clip and average\n    return float(np.mean(sat))\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Mask fill ratio: fraction of bounding-box area that is occupied by the mask (0..1)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = ((gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)).astype(bool)\n    if not np.any(mask):\n        return 0.0\n    rows = np.any(mask, axis=1)\n    cols = np.any(mask, axis=0)\n    r_idx = np.where(rows)[0]\n    c_idx = np.where(cols)[0]\n    if r_idx.size == 0 or c_idx.size == 0:\n        return 0.0\n    bbox_h = int(r_idx[-1] - r_idx[0] + 1)\n    bbox_w = int(c_idx[-1] - c_idx[0] + 1)\n    bbox_area = float(bbox_h * bbox_w) + 1e-8\n    mask_area = float(np.count_nonzero(mask))\n    return float(mask_area / bbox_area)\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Coefficient of variation (std/mean) of per-column longest foreground run lengths'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = ((gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)).astype(bool)\n    if not np.any(mask):\n        return 0.0\n    max_runs = np.zeros(w, dtype=float)\n    for col in range(w):\n        col_vals = mask[:, col]\n        max_run = 0\n        cur = 0\n        for v in col_vals:\n            if v:\n                cur += 1\n                if cur > max_run:\n                    max_run = cur\n            else:\n                cur = 0\n        max_runs[col] = float(max_run)\n    mean_r = float(np.mean(max_runs))\n    std_r = float(np.std(max_runs))\n    if mean_r <= 1e-8:\n        return 0.0\n    return float(std_r / (mean_r + 1e-8))\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Vertical slope of row mean intensity (positive = intensity increases downward) normalized by intensity range'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 2 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    row_mean = np.mean(gray, axis=1)\n    ys = np.arange(len(row_mean))\n    # fit linear slope\n    try:\n        p = np.polyfit(ys, row_mean, 1)\n        slope = float(p[0])\n    except Exception:\n        slope = 0.0\n    rng = float(np.max(row_mean) - np.min(row_mean)) + 1e-8\n    # normalize by height to keep values comparable\n    return float((slope / rng) * float(h))\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Fraction of mask pixels with high absolute Laplacian response (corner/edge density within mask)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 3 or w < 3:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = ((gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)).astype(bool)\n    if not np.any(mask):\n        return 0.0\n    # compute 4-neighbor Laplacian: 4*center - up - down - left - right\n    padded = np.pad(gray, ((1, 1), (1, 1)), mode='edge').astype(float)\n    center = padded[1:-1, 1:-1]\n    up = padded[0:-2, 1:-1]\n    down = padded[2:, 1:-1]\n    left = padded[1:-1, 0:-2]\n    right = padded[1:-1, 2:]\n    lap = (4.0 * center - up - down - left - right)\n    abs_lap = np.abs(lap)\n    thresh = np.percentile(abs_lap, 90) if np.any(abs_lap) else 1e-8\n    strong = abs_lap >= thresh\n    denom = float(np.count_nonzero(mask)) + 1e-8\n    return float(np.count_nonzero(strong & mask) / denom)\n", "def feature(image: np.ndarray) -> float:\n    'Normalized vertical centroid of the detected foreground mask (0 top -> 1 bottom)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 50)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    ys, xs = np.where(mask)\n    if ys.size == 0:\n        return 0.0\n    centroid_y = float(np.mean(ys))\n    return float(centroid_y / (h + 1e-8))\n\n", "def feature(image: np.ndarray) -> float:\n    'Ratio of mass in top 30% of image to mass in bottom 30% (higher => top-heavy)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 3:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    top_cut = int(max(1, np.round(h * 0.3)))\n    bottom_start = int(max(1, np.round(h * 0.7)))\n    top_mass = float(np.count_nonzero(mask[:top_cut, :]))\n    bottom_mass = float(np.count_nonzero(mask[bottom_start:, :]))\n    return float(top_mass / (bottom_mass + 1e-8))\n\n", "def feature(image: np.ndarray) -> float:\n    'Normalized count of significant vertical gaps in the mask projection (detects leg separation)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if w < 3:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 50)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    col_sum = np.sum(mask, axis=0).astype(float)\n    if np.max(col_sum) <= 0:\n        return 0.0\n    # smooth projection\n    k = min(7, max(1, w // 20))\n    kernel = np.ones(k) / float(k)\n    smooth = np.convolve(col_sum, kernel, mode='same')\n    gap_thresh = 0.35 * np.max(smooth)\n    low = smooth < gap_thresh\n    # count runs of consecutive low columns\n    if not np.any(low):\n        return 0.0\n    diffs = np.diff(low.astype(int))\n    starts = np.count_nonzero(diffs == 1)\n    # if sequence starts low, add one\n    if low[0]:\n        starts += 1\n    # normalize by image width\n    return float(starts / (w + 1e-8))\n\n", "def feature(image: np.ndarray) -> float:\n    'Ratio of mean mask width in upper quarter to mean mask width in lower quarter'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 4 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    q = max(1, h // 4)\n    top_rows = mask[:q, :]\n    bottom_rows = mask[-q:, :]\n    top_widths = np.sum(top_rows, axis=1).astype(float)\n    bottom_widths = np.sum(bottom_rows, axis=1).astype(float)\n    top_mean = float(np.mean(top_widths)) if top_widths.size > 0 else 0.0\n    bottom_mean = float(np.mean(bottom_widths)) if bottom_widths.size > 0 else 0.0\n    return float(top_mean / (bottom_mean + 1e-8))\n\n", "def feature(image: np.ndarray) -> float:\n    'Std of horizontal centroids computed for three vertical bands normalized by image width'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 3 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    bands = [ (0, h//3), (h//3, 2*h//3), (2*h//3, h) ]\n    centroids = []\n    xs = np.arange(w).astype(float)\n    for a, b in bands:\n        region = mask[a:b, :]\n        if region.size == 0:\n            continue\n        sums = np.sum(region, axis=0)\n        total = np.sum(sums)\n        if total > 0:\n            # compute x centroid for region\n            centroids.append(float(np.sum(xs * sums) / total))\n    if len(centroids) == 0:\n        return 0.0\n    return float(np.std(centroids) / (w + 1e-8))\n\n", "def feature(image: np.ndarray) -> float:\n    'Fraction of strong gradient pixels inside the bottom 25% band (edge density near ground)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 4 or w < 2:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    gy, gx = np.gradient(gray.astype(float))\n    grad = np.sqrt(gx * gx + gy * gy)\n    band_start = int(max(0, np.floor(h * 0.75)))\n    bottom_band = grad[band_start:, :]\n    if bottom_band.size == 0:\n        return 0.0\n    thresh = np.percentile(grad, 70) if np.any(grad) else 0.0\n    strong = bottom_band > thresh\n    return float(np.count_nonzero(strong) / (bottom_band.size + 1e-8))\n\n", "def feature(image: np.ndarray) -> float:\n    'Mask height normalized by image height (tallness of the item)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    ys, xs = np.where(mask)\n    if ys.size == 0:\n        return 0.0\n    mask_height = float(np.max(ys) - np.min(ys) + 1)\n    return float(mask_height / (h + 1e-8))\n\n", "def feature(image: np.ndarray) -> float:\n    'Absolute normalized shoulder slope estimate from left boundary between top and mid rows'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 6 or w < 3:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    rows = np.arange(h)\n    # define top band and middle band\n    top_idx = rows < int(max(1, h * 0.2))\n    mid_idx = (rows >= int(max(1, h * 0.4))) & (rows < int(max(1, h * 0.6)))\n    def mean_left(idx_mask):\n        ys = np.where(idx_mask)[0]\n        xs_left = []\n        for r in ys:\n            row = mask[r, :]\n            nz = np.where(row)[0]\n            if nz.size > 0:\n                xs_left.append(float(nz[0]))\n        return float(np.mean(xs_left)) if len(xs_left) > 0 else np.nan\n    left_top = mean_left(top_idx)\n    left_mid = mean_left(mid_idx)\n    if np.isnan(left_top) or np.isnan(left_mid):\n        return 0.0\n    slope = (left_mid - left_top) / (max(1.0, h * 0.2))\n    return float(abs(slope) / (w + 1e-8))\n\n", "def feature(image: np.ndarray) -> float:\n    'Normalized vertical entropy of the mask projection (0 concentrated -> 1 spread)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 2:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 50)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    row_sums = np.sum(mask, axis=1).astype(float)\n    total = float(np.sum(row_sums))\n    if total <= 0:\n        return 0.0\n    p = row_sums / total\n    p_nonzero = p[p > 0]\n    entropy = -float(np.sum(p_nonzero * np.log(p_nonzero)))\n    # normalize by log(number of rows)\n    denom = float(np.log(max(2, p.size)))\n    return float(entropy / (denom + 1e-8))\n\n", "def feature(image: np.ndarray) -> float:\n    'Rectangularity-like score: mean row width scaled by bbox width and penalized by width variability'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    ys, xs = np.where(mask)\n    if ys.size == 0:\n        return 0.0\n    miny, maxy = int(np.min(ys)), int(np.max(ys))\n    minx, maxx = int(np.min(xs)), int(np.max(xs))\n    bbox_w = float(maxx - minx + 1)\n    row_widths = np.sum(mask, axis=1).astype(float)\n    valid = row_widths[row_widths > 0]\n    if valid.size == 0 or bbox_w <= 0:\n        return 0.0\n    mean_rw = float(np.mean(valid))\n    std_rw = float(np.std(valid))\n    cv = std_rw / (mean_rw + 1e-8)\n    stability = max(0.0, 1.0 - cv)  # high when widths are consistent\n    rect_score = (mean_rw / (bbox_w + 1e-8)) * stability\n    return float(rect_score)\n", "def feature(image: np.ndarray) -> float:\n    'Left-right symmetry of the foreground mask (1.0 = perfectly symmetric)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    # grayscale\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 50)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    if not np.any(mask):\n        return 0.0\n    # split and mirror right half\n    mid = w // 2\n    left = mask[:, :mid].astype(float)\n    right = mask[:, w - mid:w].astype(float)[:, ::-1]\n    # pad smaller to same shape\n    if left.shape[1] != right.shape[1]:\n        mn = min(left.shape[1], right.shape[1])\n        left = left[:, :mn]\n        right = right[:, :mn]\n    diff = np.abs(left - right)\n    norm = float(np.sum(mask.astype(float))) + 1e-8\n    score = 1.0 - float(np.sum(diff)) / norm\n    return float(np.clip(score, 0.0, 1.0))\n\n", "def feature(image: np.ndarray) -> float:\n    'Ratio of mask area in top third to bottom third (top_area / (bottom_area+eps))'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 3 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    top_end = h // 3\n    bottom_start = (2 * h) // 3\n    top_count = float(np.count_nonzero(mask[0:top_end, :]))\n    bottom_count = float(np.count_nonzero(mask[bottom_start:h, :])) + 1e-8\n    return float(top_count / bottom_count)\n\n", "def feature(image: np.ndarray) -> float:\n    'Count of contiguous mask column groups in the bottom 25% (clipped to 5)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    start = max(0, h - max(1, h // 4))\n    band = mask[start:h, :]\n    # collapse to columns that have any mask\n    col_has = np.any(band, axis=0).astype(int)\n    if col_has.sum() == 0:\n        return 0.0\n    # count contiguous groups\n    diff = np.diff(np.concatenate(([0], col_has, [0])))\n    starts = np.where(diff == 1)[0]\n    ends = np.where(diff == -1)[0]\n    groups = max(0, len(starts))\n    return float(min(groups, 5))\n\n", "def feature(image: np.ndarray) -> float:\n    'Mask fill ratio: area(mask) divided by bounding-box area (0..1)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 50)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    if not np.any(mask):\n        return 0.0\n    rows = np.where(np.any(mask, axis=1))[0]\n    cols = np.where(np.any(mask, axis=0))[0]\n    if rows.size == 0 or cols.size == 0:\n        return 0.0\n    bbox_h = float(rows[-1] - rows[0] + 1)\n    bbox_w = float(cols[-1] - cols[0] + 1)\n    bbox_area = max(1.0, bbox_h * bbox_w)\n    mask_area = float(np.count_nonzero(mask))\n    return float(np.clip(mask_area / bbox_area, 0.0, 1.0))\n\n", "def feature(image: np.ndarray) -> float:\n    'Approximate mean color saturation inside the mask (0..1), 0 for grayscale images'\n    import numpy as np\n    if image is None:\n        return 0.0\n    if len(image.shape) != 3:\n        return 0.0\n    h, w, c = image.shape\n    if h == 0 or w == 0 or c < 3:\n        return 0.0\n    rgb = image.astype(float)\n    # approximate saturation by (max-min)/(max+eps) per pixel\n    mx = np.max(rgb, axis=2)\n    mn = np.min(rgb, axis=2)\n    sat = (mx - mn) / (mx + 1e-8)\n    gray = np.mean(rgb, axis=2)\n    thr = np.percentile(gray, 50)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    if not np.any(mask):\n        return 0.0\n    mean_sat = float(np.mean(sat[mask]))\n    return float(np.clip(mean_sat, 0.0, 1.0))\n\n", "def feature(image: np.ndarray) -> float:\n    'Normalized std of gradient magnitude in center region (texture energy center / whole)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 3 or w < 3:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    gy, gx = np.gradient(gray.astype(float))\n    grad = np.sqrt(gx * gx + gy * gy)\n    # center region middle half\n    r0, r1 = h // 4, (3 * h) // 4\n    c0, c1 = w // 4, (3 * w) // 4\n    center = grad[r0:r1, c0:c1]\n    whole_std = float(np.std(grad)) + 1e-8\n    center_std = float(np.std(center))\n    return float(center_std / whole_std)\n\n", "def feature(image: np.ndarray) -> float:\n    'Horizontal edge strength in top-center region (captures collars or necklines)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 5 or w < 5:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    gy, gx = np.gradient(gray.astype(float))\n    # horizontal edges produce large gy\n    top_end = max(1, h // 6)\n    c0 = max(0, w // 5)\n    c1 = min(w, (4 * w) // 5)\n    region = gy[0:top_end, c0:c1]\n    strength = float(np.sum(np.abs(region)))\n    # normalize by mask area if exists\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    norm = float(np.count_nonzero(mask)) + 1e-8\n    return float(strength / norm)\n\n", "def feature(image: np.ndarray) -> float:\n    'Longest vertical continuous run in center columns divided by image height (0..1)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 50)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    if not np.any(mask):\n        return 0.0\n    # use center 3 columns (or fewer if narrow)\n    center_col = w // 2\n    cols = [center_col]\n    if w > 2:\n        cols = [max(0, center_col - 1), center_col, min(w - 1, center_col + 1)]\n    col_mask = np.any(mask[:, cols], axis=1).astype(int)\n    if col_mask.sum() == 0:\n        return 0.0\n    # compute longest run of consecutive ones\n    dif = np.diff(np.concatenate(([0], col_mask, [0])))\n    starts = np.where(dif == 1)[0]\n    ends = np.where(dif == -1)[0]\n    runs = ends - starts\n    longest = float(np.max(runs)) if runs.size > 0 else 0.0\n    return float(longest / float(h))\n\n", "def feature(image: np.ndarray) -> float:\n    'Absolute left-right mask area imbalance (0 = balanced, 1 = all on one side)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 50)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    if not np.any(mask):\n        return 0.0\n    mid = w // 2\n    left_area = float(np.count_nonzero(mask[:, :mid]))\n    right_area = float(np.count_nonzero(mask[:, mid:]))\n    total = left_area + right_area + 1e-8\n    imbalance = abs(left_area - right_area) / total\n    return float(np.clip(imbalance, 0.0, 1.0))\n\n", "def feature(image: np.ndarray) -> float:\n    'Count of strong peaks in grayscale histogram within mask (normalized to 0..1)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 50)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    vals = gray[mask]\n    if vals.size == 0:\n        return 0.0\n    # histogram\n    bins = 16\n    hist, edges = np.histogram(vals.flatten(), bins=bins, range=(vals.min(), vals.max()))\n    if hist.max() == 0:\n        return 0.0\n    # peaks are bins with value >= 30% of max and greater than neighbors\n    thr_peak = 0.3 * hist.max()\n    peaks = 0\n    for i in range(bins):\n        if hist[i] >= thr_peak:\n            left = hist[i - 1] if i - 1 >= 0 else -1\n            right = hist[i + 1] if i + 1 < bins else -1\n            if hist[i] >= left and hist[i] >= right:\n                peaks += 1\n    # normalize peaks to [0,1]\n    return float(np.clip(peaks / float(bins), 0.0, 1.0))\n", "def feature(image: np.ndarray) -> float:\n    'Foreground bounding box width/height aspect ratio (normalized)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    # grayscale\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    coords = np.argwhere(mask)\n    if coords.size == 0:\n        return 0.0\n    ys, xs = coords[:, 0], coords[:, 1]\n    miny, maxy = int(np.min(ys)), int(np.max(ys))\n    minx, maxx = int(np.min(xs)), int(np.max(xs))\n    box_h = max(1, maxy - miny + 1)\n    box_w = max(1, maxx - minx + 1)\n    aspect = float(box_w) / float(box_h)\n    # normalize by image aspect to keep values comparable\n    img_aspect = float(w) / float(max(1, h))\n    return float(aspect / (img_aspect + 1e-8))\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Vertical normalized centroid of foreground (0=top,1=bottom)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    ys, xs = np.nonzero(mask)\n    if ys.size == 0:\n        # fallback to intensity centroid\n        ys_all = np.arange(h).reshape(h, 1) * np.ones((1, w))\n        total = np.sum(gray) + 1e-8\n        return float(np.sum(ys_all * gray) / (total * float(h)))\n    cy = float(np.mean(ys))\n    return float(cy / float(h - 1 + 1e-8))\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Fraction of foreground pixels located in bottom 25% of image'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    bottom_start = max(0, int(0.75 * h))\n    total_fg = np.count_nonzero(mask)\n    if total_fg == 0:\n        return 0.0\n    bottom_fg = np.count_nonzero(mask[bottom_start:h, :])\n    return float(bottom_fg / float(total_fg))\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Left-right symmetry score (1 - normalized L1 difference between halves)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if w < 2 or h == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    mid = w // 2\n    left = gray[:, :mid]\n    right = gray[:, w - mid:w]\n    if left.size == 0 or right.size == 0:\n        return 0.0\n    # flip right horizontally to compare\n    right_flipped = np.fliplr(right)\n    # resize if different sizes (when w odd)\n    if left.shape != right_flipped.shape:\n        min_w = min(left.shape[1], right_flipped.shape[1])\n        left = left[:, :min_w]\n        right_flipped = right_flipped[:, :min_w]\n    diff = np.abs(left - right_flipped)\n    # normalized by mean intensity to be scale-invariant\n    denom = (np.mean(np.abs(left)) + np.mean(np.abs(right_flipped))) / 2.0 + 1e-8\n    score = 1.0 - (np.mean(diff) / denom)\n    return float(score)\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Foreground elongation: (lambda1 - lambda2)/(lambda1 + lambda2) from 2D covariance of mask coords'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 2 or w < 2:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    pts = np.argwhere(mask).astype(float)\n    if pts.size == 0:\n        return 0.0\n    # coordinates: rows (y) and cols (x)\n    mean = np.mean(pts, axis=0)\n    centered = pts - mean\n    cov = np.dot(centered.T, centered) / float(max(1, centered.shape[0]))\n    # 2x2 covariance; compute eigenvalues analytically for stability\n    a = cov[0, 0]; b = cov[0, 1]; c = cov[1, 1]\n    trace = a + c\n    det = a * c - b * b\n    disc = max(0.0, trace * trace / 4.0 - det)\n    sqrt_disc = np.sqrt(disc)\n    lambda1 = max(1e-8, trace / 2.0 + sqrt_disc)\n    lambda2 = max(1e-8, trace / 2.0 - sqrt_disc)\n    elong = (lambda1 - lambda2) / (lambda1 + lambda2 + 1e-12)\n    return float(elong)\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Mid-frequency energy in row-profile FFT (detects horizontal banding)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 4:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    row_profile = np.mean(gray, axis=1)\n    row_profile = row_profile - np.mean(row_profile)\n    spec = np.abs(np.fft.rfft(row_profile))\n    total = np.sum(spec) + 1e-8\n    n = spec.size\n    lo = 2\n    hi = min(6, n - 1)\n    if hi < lo:\n        return 0.0\n    mid_energy = np.sum(spec[lo:hi + 1])\n    return float(mid_energy / total)\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Colorfulness proxy: mean of absolute channel differences normalized by mean intensity'\n    import numpy as np\n    if image is None:\n        return 0.0\n    if len(image.shape) != 3:\n        # grayscale has no colorfulness\n        return 0.0\n    h, w, c = image.shape\n    if c < 3 or h == 0 or w == 0:\n        return 0.0\n    img = image.astype(float)\n    r = img[:, :, 0]\n    g = img[:, :, 1]\n    b = img[:, :, 2]\n    diff_rg = np.abs(r - g)\n    diff_rb = np.abs(r - b)\n    val = np.mean(diff_rg + diff_rb)\n    denom = np.mean((r + g + b) / 3.0) + 1e-8\n    return float(val / denom)\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Mean absolute Laplacian magnitude in the center region (texture/edge curvature)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 3 or w < 3:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    # center region\n    ch0, ch1 = h // 4, w // 4\n    center = gray[ch0:3 * ch0 if 3 * ch0 <= h else h, ch1:3 * ch1 if 3 * ch1 <= w else w]\n    if center.size == 0:\n        center = gray\n    # compute 2D Laplacian via convolution with kernel [[0,1,0],[1,-4,1],[0,1,0]]\n    C = center.astype(float)\n    lap = np.zeros_like(C)\n    lap[1:-1, 1:-1] = (C[0:-2, 1:-1] + C[2:, 1:-1] + C[1:-1, 0:-2] + C[1:-1, 2:] - 4.0 * C[1:-1, 1:-1])\n    # border handling: approximate with simple differences\n    if C.shape[0] >= 2:\n        lap[0, :] = C[1, :] - C[0, :]\n        lap[-1, :] = C[-2, :] - C[-1, :]\n    if C.shape[1] >= 2:\n        lap[:, 0] = C[:, 1] - C[:, 0]\n        lap[:, -1] = C[:, -2] - C[:, -1]\n    mag = np.mean(np.abs(lap))\n    return float(mag)\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Average number of foreground runs per column (vertical segments) - measures straps/holes/complexity'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 2 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    runs = []\n    for col in range(w):\n        col_mask = mask[:, col].astype(np.uint8)\n        if col_mask.size == 0:\n            runs.append(0)\n            continue\n        # transitions from 0->1 indicate new run\n        trans = np.count_nonzero((col_mask[:-1] == 0) & (col_mask[1:] == 1))\n        # if column starts with foreground, count that run too\n        if col_mask[0]:\n            trans += 1\n        runs.append(trans)\n    if len(runs) == 0:\n        return 0.0\n    return float(np.mean(runs))\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Maximum vertical contiguous foreground run length across columns normalized by image height'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    max_run = 0\n    for col in range(w):\n        col_mask = mask[:, col]\n        if col_mask.size == 0:\n            continue\n        # find longest run of True in this column\n        run = 0\n        best = 0\n        for v in col_mask:\n            if v:\n                run += 1\n            else:\n                if run > best:\n                    best = run\n                run = 0\n        if run > best:\n            best = run\n        if best > max_run:\n            max_run = best\n    return float(max_run / float(max(1, h)))\n", "def feature(image: np.ndarray) -> float:\n    'Fraction of image occupied by the foreground mask (approximate object area)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 50)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    area = float(np.count_nonzero(mask))\n    return float(area / (h * w + 1e-8))\n\n", "def feature(image: np.ndarray) -> float:\n    'Left-right symmetry similarity (1.0 = perfect symmetry, 0.0 = very asymmetric)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    flipped = np.fliplr(gray)\n    diff = np.abs(gray - flipped)\n    denom = np.mean(np.abs(gray)) + 1e-8\n    sim = 1.0 - (np.mean(diff) / denom)\n    if sim < 0.0:\n        sim = 0.0\n    return float(sim)\n\n", "def feature(image: np.ndarray) -> float:\n    'Average number of contiguous foreground segments per row (mean 0->1 transitions)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 50)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    # handle width cases\n    if w == 1:\n        segs = np.array(mask[:, 0].astype(float))\n        return float(np.mean(segs))\n    left = mask[:, :-1]\n    right = mask[:, 1:]\n    starts = ((~left) & right).astype(int).sum(axis=1) + mask[:, 0].astype(int)\n    return float(np.mean(starts))\n\n", "def feature(image: np.ndarray) -> float:\n    'Maximum horizontal centroid displacement from image center (normalized by width)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h <= 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    xs = np.arange(w).astype(float)\n    centroids = []\n    for r in range(h):\n        row = mask[r, :]\n        total = float(np.sum(row))\n        if total > 0.0:\n            centroids.append(float(np.sum(xs * row) / total))\n    if len(centroids) == 0:\n        return 0.0\n    centroids = np.array(centroids)\n    center = float(w) / 2.0\n    max_dev = float(np.max(np.abs(centroids - center)))\n    return float(max_dev / (w + 1e-8))\n\n", "def feature(image: np.ndarray) -> float:\n    'Aspect ratio (height / width) of the bounding box of the foreground mask'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 50)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    ys, xs = np.where(mask)\n    if ys.size == 0 or xs.size == 0:\n        return 0.0\n    ymin, ymax = int(np.min(ys)), int(np.max(ys))\n    xmin, xmax = int(np.min(xs)), int(np.max(xs))\n    box_h = float(ymax - ymin + 1)\n    box_w = float(xmax - xmin + 1)\n    return float(box_h / (box_w + 1e-8))\n\n", "def feature(image: np.ndarray) -> float:\n    'Hollowness: fraction of empty pixels inside the mask bounding box (1.0 = empty box)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 50)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    ys, xs = np.where(mask)\n    if ys.size == 0:\n        return 0.0\n    ymin, ymax = int(np.min(ys)), int(np.max(ys))\n    xmin, xmax = int(np.min(xs)), int(np.max(xs))\n    box = mask[ymin:ymax+1, xmin:xmax+1]\n    if box.size == 0:\n        return 0.0\n    empty = float(box.size - np.count_nonzero(box))\n    return float(empty / (box.size + 1e-8))\n\n", "def feature(image: np.ndarray) -> float:\n    'Concentration of gradient orientations (resultant length of gradient angles, 0..1)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 2 or w < 2:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    gy, gx = np.gradient(gray.astype(float))\n    mag = np.sqrt(gx * gx + gy * gy)\n    weights = mag\n    if np.sum(weights) < 1e-8:\n        return 0.0\n    angles_cos = np.cos(np.arctan2(gy, gx))\n    angles_sin = np.sin(np.arctan2(gy, gx))\n    mc = float(np.sum(angles_cos * weights) / (np.sum(weights) + 1e-8))\n    ms = float(np.sum(angles_sin * weights) / (np.sum(weights) + 1e-8))\n    R = np.sqrt(mc * mc + ms * ms)\n    return float(R)\n\n", "def feature(image: np.ndarray) -> float:\n    'Ratio of mask area in lower third to upper third (high for shoes, low for tops/dresses)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 50)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    top_end = h // 3\n    low_start = (2 * h) // 3\n    top_area = float(np.count_nonzero(mask[:top_end, :]))\n    low_area = float(np.count_nonzero(mask[low_start:, :]))\n    return float(low_area / (top_area + 1e-8))\n\n", "def feature(image: np.ndarray) -> float:\n    'Top narrowness: 5th percentile of row widths in upper half normalized by max row width'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h <= 1 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    row_widths = np.sum(mask, axis=1).astype(float)\n    if row_widths.size == 0:\n        return 0.0\n    top_half = row_widths[:max(1, h // 2)]\n    max_w = np.max(row_widths) + 1e-8\n    p5 = float(np.percentile(top_half, 5)) if top_half.size > 0 else 0.0\n    return float(p5 / max_w)\n\n", "def feature(image: np.ndarray) -> float:\n    'Distance between two strongest column peaks in the lower half (normalized by width)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 50)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    start = h // 2\n    col_profile = np.sum(mask[start:, :], axis=0).astype(float)\n    if np.count_nonzero(col_profile) == 0:\n        return 0.0\n    idx = np.argsort(col_profile)[::-1]  # descending\n    # pick two distinct peaks with non-zero mass\n    valid = idx[col_profile[idx] > 0]\n    if valid.size < 2:\n        return 0.0\n    p1, p2 = int(valid[0]), int(valid[1])\n    dist = float(abs(p1 - p2))\n    return float(dist / (w + 1e-8))\n", "def feature(image: np.ndarray) -> float:\n    'Normalized vertical centroid of the foreground mask (0=top, 1=bottom)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    # grayscale\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    coords = np.argwhere(mask)\n    if coords.size == 0:\n        return 0.0\n    ys = coords[:, 0].astype(float)\n    centroid_y = np.mean(ys)\n    return float(centroid_y / max(1.0, float(h - 1)))\n\n", "def feature(image: np.ndarray) -> float:\n    'Left-right symmetry score of foreground intensities (1 highly symmetric, 0 asymmetric)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 2 or w < 2:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    center = w // 2\n    left = gray[:, :center]\n    right = gray[:, w - center:] if center > 0 else np.zeros_like(left)\n    left_mask = mask[:, :center]\n    right_mask = mask[:, w - center:]\n    if left.size == 0 or right.size == 0:\n        return 0.0\n    # flip right to align with left\n    right_flip = np.fliplr(right)\n    right_mask_flip = np.fliplr(right_mask)\n    overlap = (left_mask | right_mask_flip)\n    if not np.any(overlap):\n        return 0.0\n    diff = np.abs(left - right_flip)\n    mean_diff = float(np.mean(diff[overlap]))\n    mean_int = float(np.mean(np.abs(gray[mask])) if np.any(mask) else np.mean(np.abs(gray)) + 1e-8)\n    score = 1.0 - (mean_diff / (mean_int + 1e-8))\n    if not np.isfinite(score):\n        return 0.0\n    return float(max(0.0, min(1.0, score)))\n\n", "def feature(image: np.ndarray) -> float:\n    'Colorfulness measure for RGB images (0 for grayscale images)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    if len(image.shape) != 3 or image.shape[2] < 3:\n        return 0.0\n    # use Hasler & S\u00fcsstrunk colorfulness metric\n    img = image.astype(float)\n    R, G, B = img[:, :, 0], img[:, :, 1], img[:, :, 2]\n    rg = R - G\n    yb = 0.5 * (R + G) - B\n    std_rg = float(np.std(rg))\n    std_yb = float(np.std(yb))\n    mean_rg = float(np.mean(rg))\n    mean_yb = float(np.mean(yb))\n    colorfulness = std_rg + std_yb + 0.3 * (abs(mean_rg) + abs(mean_yb))\n    if not np.isfinite(colorfulness):\n        return 0.0\n    return float(colorfulness)\n\n", "def feature(image: np.ndarray) -> float:\n    'Ratio of foreground mass in upper 40% to lower 60% (higher => more top-heavy)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    total = float(np.count_nonzero(mask))\n    if total == 0:\n        return 0.0\n    cut = max(1, int(0.4 * h))\n    top_mass = float(np.count_nonzero(mask[:cut, :]))\n    bottom_mass = float(np.count_nonzero(mask[cut:, :]))\n    # return ratio top/(bottom+top) normalized to [0,1] centered on distribution\n    return float(top_mass / (total + 1e-8))\n\n", "def feature(image: np.ndarray) -> float:\n    'Number of connected foreground components (4-connected) in the mask'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = ((gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)).astype(bool)\n    visited = np.zeros_like(mask, dtype=bool)\n    comp_count = 0\n    # simple stack-based flood-fill\n    for y in range(h):\n        for x in range(w):\n            if mask[y, x] and not visited[y, x]:\n                comp_count += 1\n                stack = [(y, x)]\n                visited[y, x] = True\n                while stack:\n                    cy, cx = stack.pop()\n                    # neighbors 4-connectivity\n                    if cy > 0 and mask[cy - 1, cx] and not visited[cy - 1, cx]:\n                        visited[cy - 1, cx] = True\n                        stack.append((cy - 1, cx))\n                    if cy + 1 < h and mask[cy + 1, cx] and not visited[cy + 1, cx]:\n                        visited[cy + 1, cx] = True\n                        stack.append((cy + 1, cx))\n                    if cx > 0 and mask[cy, cx - 1] and not visited[cy, cx - 1]:\n                        visited[cy, cx - 1] = True\n                        stack.append((cy, cx - 1))\n                    if cx + 1 < w and mask[cy, cx + 1] and not visited[cy, cx + 1]:\n                        visited[cy, cx + 1] = True\n                        stack.append((cy, cx + 1))\n    return float(comp_count)\n\n", "def feature(image: np.ndarray) -> float:\n    'Average foreground width around shoulder row (20% height) normalized by image width'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    row = int(min(h - 1, max(0, int(0.20 * h))))\n    band = max(1, int(0.02 * h))\n    start = max(0, row - band)\n    end = min(h, row + band + 1)\n    widths = np.count_nonzero(mask[start:end, :], axis=1).astype(float)\n    if widths.size == 0:\n        return 0.0\n    mean_width = float(np.mean(widths))\n    return float(mean_width / max(1.0, float(w)))\n\n", "def feature(image: np.ndarray) -> float:\n    'Maximum vertical continuous foreground run length normalized by image height'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 1 or w < 1:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = ((gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)).astype(bool)\n    if not np.any(mask):\n        return 0.0\n    max_run = 0\n    for col in range(w):\n        col_vals = mask[:, col]\n        cur = 0\n        for v in col_vals:\n            if v:\n                cur += 1\n                if cur > max_run:\n                    max_run = cur\n            else:\n                cur = 0\n    return float(max_run / max(1.0, float(h)))\n\n", "def feature(image: np.ndarray) -> float:\n    'Perimeter-to-area ratio of the foreground mask (higher => more elongated/complex)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = ((gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)).astype(bool)\n    area = float(np.count_nonzero(mask))\n    if area == 0.0:\n        return 0.0\n    # perimeter approx: count mask pixels that have at least one 4-neighbor background\n    perim = 0\n    for y in range(h):\n        for x in range(w):\n            if not mask[y, x]:\n                continue\n            if y == 0 or x == 0 or y == h - 1 or x == w - 1:\n                perim += 1\n                continue\n            if not (mask[y - 1, x] and mask[y + 1, x] and mask[y, x - 1] and mask[y, x + 1]):\n                perim += 1\n    return float(perim / (area + 1e-8))\n\n", "def feature(image: np.ndarray) -> float:\n    'Entropy of gradient orientations (0..1, higher => more varied edge directions)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 2 or w < 2:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    gy, gx = np.gradient(gray.astype(float))\n    ang = np.arctan2(gy, gx)  # -pi..pi\n    ang = ang.flatten()\n    # focus on locations with some gradient magnitude\n    mag = np.sqrt(gx * gx + gy * gy).flatten()\n    strong_mask = mag > np.percentile(mag, 50) if ang.size > 0 else np.array([], dtype=bool)\n    if ang.size == 0 or not np.any(strong_mask):\n        return 0.0\n    ang_sel = ang[strong_mask]\n    bins = 12\n    hist, _ = np.histogram(ang_sel, bins=bins, range=(-np.pi, np.pi))\n    p = hist.astype(float) / (np.sum(hist) + 1e-8)\n    # entropy normalized by log(bins)\n    nz = p[p > 0]\n    ent = -np.sum(nz * np.log(nz + 1e-12))\n    norm_ent = ent / (np.log(bins) + 1e-12)\n    if not np.isfinite(norm_ent):\n        return 0.0\n    return float(max(0.0, min(1.0, norm_ent)))\n\n", "def feature(image: np.ndarray) -> float:\n    'Foreground solidity: mask area divided by its bounding-box area (0..1)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 50)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    coords = np.argwhere(mask)\n    if coords.size == 0:\n        return 0.0\n    area = float(coords.shape[0])\n    ys, xs = coords[:, 0], coords[:, 1]\n    bbox_h = float(max(1, ys.max() - ys.min() + 1))\n    bbox_w = float(max(1, xs.max() - xs.min() + 1))\n    bbox_area = bbox_h * bbox_w\n    solidity = area / (bbox_area + 1e-8)\n    if not np.isfinite(solidity):\n        return 0.0\n    return float(max(0.0, min(1.0, solidity)))\n", "def feature(image: np.ndarray) -> float:\n    'Fraction of foreground mask pixels located in the top 50% of image rows'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    # grayscale conversion\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 50)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    total = float(np.count_nonzero(mask))\n    if total <= 0.0:\n        return 0.0\n    top_cut = max(1, h // 2)\n    top_mass = float(np.count_nonzero(mask[:top_cut, :]))\n    return float(top_mass / total)\n\n", "def feature(image: np.ndarray) -> float:\n    'Relative mass of upper-left and upper-right (sleeve-like) regions vs upper-center'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 3 or w < 3:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 50)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    upper_h = max(1, h // 3)\n    third_w = max(1, w // 3)\n    left = float(np.count_nonzero(mask[:upper_h, :third_w]))\n    right = float(np.count_nonzero(mask[:upper_h, -third_w:]))\n    center = float(np.count_nonzero(mask[:upper_h, third_w:-third_w]))\n    denom = (center + 1e-8)\n    return float((left + right) / denom)\n\n", "def feature(image: np.ndarray) -> float:\n    'Ratio of maximum foreground row width to mean foreground row width (captures skirt/flare)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    row_widths = np.sum(mask, axis=1).astype(float)\n    if row_widths.size == 0:\n        return 0.0\n    mean_w = float(np.mean(row_widths[row_widths > 0])) if np.any(row_widths > 0) else 0.0\n    max_w = float(np.max(row_widths)) if row_widths.size > 0 else 0.0\n    if mean_w <= 1e-8:\n        return 0.0\n    return float(max_w / (mean_w + 1e-8))\n\n", "def feature(image: np.ndarray) -> float:\n    'Ratio of mean mask width in bottom 15% rows to mean mask width in top 15% rows'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 4:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 50)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    k = max(1, int(round(0.15 * h)))\n    top_rows = mask[:k, :]\n    bot_rows = mask[-k:, :]\n    top_mean = float(np.mean(np.sum(top_rows, axis=1))) if top_rows.size > 0 else 0.0\n    bot_mean = float(np.mean(np.sum(bot_rows, axis=1))) if bot_rows.size > 0 else 0.0\n    if top_mean <= 1e-8:\n        return float(bot_mean / (top_mean + 1e-8))  # will be large if top_mean ~0\n    return float(bot_mean / top_mean)\n\n", "def feature(image: np.ndarray) -> float:\n    'Absolute horizontal offset of mask centroid from image center normalized by width'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 50)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    ys, xs = np.where(mask)\n    if xs.size == 0:\n        return 0.0\n    cx = float(np.mean(xs))\n    offset = abs(cx - (w - 1) / 2.0)\n    return float(offset / (w + 1e-8))\n\n", "def feature(image: np.ndarray) -> float:\n    'Entropy of gradient magnitudes in the central square region (measures texture/edges)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 3 or w < 3:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    ch = max(1, h // 4)\n    cw = max(1, w // 4)\n    r0 = h // 2 - ch\n    c0 = w // 2 - cw\n    center = gray[max(0, r0):min(h, r0 + 2*ch), max(0, c0):min(w, c0 + 2*cw)]\n    if center.size == 0:\n        return 0.0\n    gy, gx = np.gradient(center.astype(float))\n    mag = np.sqrt(gx * gx + gy * gy).flatten()\n    if mag.size == 0 or np.all(mag == 0):\n        return 0.0\n    hist, _ = np.histogram(mag, bins=16, range=(mag.min(), mag.max()))\n    p = hist.astype(float) / (np.sum(hist) + 1e-12)\n    p_non = p[p > 0]\n    ent = -float(np.sum(p_non * np.log(p_non)))\n    # normalize by log(bins)\n    return float(ent / (np.log(max(2, p.size)) + 1e-12))\n\n", "def feature(image: np.ndarray) -> float:\n    'Colorfulness: mean pairwise absolute channel differences (0 for grayscale)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    if len(image.shape) != 3 or image.shape[2] < 3:\n        return 0.0\n    img = image.astype(float)\n    r = img[:, :, 0]\n    g = img[:, :, 1]\n    b = img[:, :, 2]\n    val = np.mean(np.abs(r - g) + np.abs(r - b) + np.abs(g - b)) / 3.0\n    # normalize by max possible if values appear to be in [0,255] or [0,1]\n    mx = max(1.0, np.max(img) - np.min(img))\n    return float(val / (mx + 1e-8))\n\n", "def feature(image: np.ndarray) -> float:\n    'Number of prominent peaks in the row-width profile within the upper half (detects separated shoulders/sleeves)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 6:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 50)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    upper = mask[:max(1, h // 2), :]\n    row_widths = np.sum(upper, axis=1).astype(float)\n    if row_widths.size < 3 or np.all(row_widths == 0):\n        return 0.0\n    # smooth with small moving average\n    kernel = np.ones(3) / 3.0\n    smooth = np.convolve(row_widths, kernel, mode='same')\n    # threshold peaks by being local max and above percentile\n    thr_val = np.percentile(smooth, 70)\n    peaks = 0\n    for i in range(1, smooth.size - 1):\n        if smooth[i] > smooth[i-1] and smooth[i] > smooth[i+1] and smooth[i] > thr_val:\n            peaks += 1\n    return float(peaks)\n\n", "def feature(image: np.ndarray) -> float:\n    'Ratio of left-right asymmetry in upper half to asymmetry in lower half (bag on one side detection)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 2 or w < 2:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 50)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    mid = w // 2\n    upper = mask[:h//2, :]\n    lower = mask[h//2:, :]\n    left_upper = float(np.count_nonzero(upper[:, :mid]))\n    right_upper = float(np.count_nonzero(upper[:, mid:]))\n    left_lower = float(np.count_nonzero(lower[:, :mid]))\n    right_lower = float(np.count_nonzero(lower[:, mid:]))\n    up_diff = abs(left_upper - right_upper)\n    low_diff = abs(left_lower - right_lower)\n    return float(up_diff / (low_diff + 1e-8))\n\n", "def feature(image: np.ndarray) -> float:\n    'Slope of the horizontal centroid of mask across rows (how much the object leans), normalized by width'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 3 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 50)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    ys = []\n    cx_rows = []\n    for r in range(h):\n        cols = np.where(mask[r, :])[0]\n        if cols.size > 0:\n            ys.append(float(r))\n            cx_rows.append(float(np.mean(cols)))\n    if len(ys) < 2:\n        return 0.0\n    ys = np.array(ys)\n    cx_rows = np.array(cx_rows)\n    # linear fit slope of cx = a * y + b\n    try:\n        a = np.polyfit(ys, cx_rows, 1)[0]\n    except Exception:\n        return 0.0\n    # normalize by image width to make values comparable\n    return float(abs(a) / (w + 1e-8))\n", "def feature(image: np.ndarray) -> float:\n    'Normalized vertical centroid of the main foreground mask (0 top -> 1 bottom)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0:\n        return 0.0\n    # grayscale\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 50)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    mask = mask.astype(bool)\n    if not np.any(mask):\n        return 0.0\n    rows = np.arange(h, dtype=float)\n    y_mean = float(np.sum(rows[:, None] * mask) / (np.count_nonzero(mask) + 1e-8))\n    return float(y_mean / max(1.0, h - 1))\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Fraction of image pixels belonging to foreground mask'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    total = float(max(1, h * w))\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 50)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    area = float(np.count_nonzero(mask))\n    return float(area / total)\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Compactness of mask: perimeter^2 / area (lower = more compact). 0 if undefined'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 1 or w < 1:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 50)\n    mask = ((gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)).astype(bool)\n    area = float(np.count_nonzero(mask))\n    if area <= 0.0:\n        return 0.0\n    # perimeter: count mask pixels with at least one 4-neighbor background\n    perim = 0\n    # pad to avoid bounds checks\n    padded = np.pad(mask, pad_width=1, mode='constant', constant_values=False)\n    for y in range(1, h + 1):\n        row = padded[y]\n        up = padded[y - 1]\n        down = padded[y + 1]\n        left = np.roll(row, 1)\n        right = np.roll(row, -1)\n        # compute where mask is True and any neighbor is False\n        neighbors_and = up & down & left & right\n        border = row & (~neighbors_and)\n        perim += int(np.count_nonzero(border))\n    if perim <= 0:\n        return 0.0\n    compact = (perim * perim) / (area + 1e-8)\n    return float(compact)\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Left-right symmetry score based on mask (1 = perfect symmetry, 0 = no symmetry)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 1 or w < 1:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 50)\n    mask = ((gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)).astype(float)\n    mid = w // 2\n    left = mask[:, :mid]\n    if w % 2 == 0:\n        right = mask[:, mid:]\n    else:\n        right = mask[:, mid + 1:]\n    if left.size == 0 or right.size == 0:\n        return 0.0\n    # flip right horizontally and crop/pad to match\n    right_flipped = np.fliplr(right)\n    # match widths\n    minw = min(left.shape[1], right_flipped.shape[1])\n    left_c = left[:, :minw]\n    right_c = right_flipped[:, :minw]\n    diff = np.abs(left_c - right_c)\n    denom = np.sum(left_c + right_c) + 1e-8\n    score = 1.0 - (np.sum(diff) / denom)\n    return float(max(0.0, min(1.0, score)))\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Mean color saturation (approx) for RGB images, 0 for grayscale'\n    import numpy as np\n    if image is None:\n        return 0.0\n    if len(image.shape) != 3 or image.shape[2] < 3:\n        return 0.0\n    img = image.astype(float)\n    r = img[:, :, 0]\n    g = img[:, :, 1]\n    b = img[:, :, 2]\n    vmax = np.maximum(np.maximum(r, g), b)\n    vmin = np.minimum(np.minimum(r, g), b)\n    # saturation approximation = (vmax - vmin) / (vmax + eps)\n    sat = (vmax - vmin) / (vmax + 1e-8)\n    # ignore NaNs/infs\n    sat_mean = float(np.nanmean(sat))\n    return float(max(0.0, min(1.0, sat_mean)))\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Number of connected foreground components (capped) normalized by image area'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 50)\n    mask = ((gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)).astype(bool)\n    visited = np.zeros_like(mask, dtype=bool)\n    comps = 0\n    max_comps = 50\n    for y in range(h):\n        for x in range(w):\n            if mask[y, x] and not visited[y, x]:\n                comps += 1\n                if comps >= max_comps:\n                    break\n                # flood fill\n                stack = [(y, x)]\n                visited[y, x] = True\n                while stack:\n                    cy, cx = stack.pop()\n                    if cy > 0 and mask[cy - 1, cx] and not visited[cy - 1, cx]:\n                        visited[cy - 1, cx] = True\n                        stack.append((cy - 1, cx))\n                    if cy + 1 < h and mask[cy + 1, cx] and not visited[cy + 1, cx]:\n                        visited[cy + 1, cx] = True\n                        stack.append((cy + 1, cx))\n                    if cx > 0 and mask[cy, cx - 1] and not visited[cy, cx - 1]:\n                        visited[cy, cx - 1] = True\n                        stack.append((cy, cx - 1))\n                    if cx + 1 < w and mask[cy, cx + 1] and not visited[cy, cx + 1]:\n                        visited[cy, cx + 1] = True\n                        stack.append((cy, cx + 1))\n        if comps >= max_comps:\n            break\n    area = float(max(1, h * w))\n    return float(min(max_comps, comps) / area)\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Kurtosis-like measure of mask vertical projection distribution (higher = heavy tails/spread)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 2:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 50)\n    mask = ((gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)).astype(float)\n    row_sums = np.sum(mask, axis=1)\n    n = row_sums.size\n    if n <= 1 or np.all(row_sums == 0):\n        return 0.0\n    mean = np.mean(row_sums)\n    std = np.std(row_sums)\n    if std <= 1e-8:\n        return 0.0\n    fourth = np.mean((row_sums - mean) ** 4)\n    kurt = fourth / (std ** 4 + 1e-12)\n    # normalize by a typical scale\n    return float(kurt)\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Mean intensity difference between top quarter and bottom quarter (top - bottom)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 4:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    top = gray[:h // 4, :]\n    bottom = gray[3 * h // 4:, :]\n    if top.size == 0 or bottom.size == 0:\n        return 0.0\n    top_mean = float(np.mean(top))\n    bottom_mean = float(np.mean(bottom))\n    # normalize by overall brightness range\n    rng = float(np.max(gray) - np.min(gray) + 1e-8)\n    return float((top_mean - bottom_mean) / rng)\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Entropy of edge orientation histogram (0..1), higher = more varied edge directions'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 2 or w < 2:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    gy, gx = np.gradient(gray)\n    mag = np.sqrt(gx * gx + gy * gy)\n    if not np.any(mag):\n        return 0.0\n    # focus on strong edges\n    thr = np.percentile(mag, 60)\n    mask = mag > thr\n    if not np.any(mask):\n        return 0.0\n    angles = np.arctan2(gy[mask], gx[mask])  # range -pi..pi\n    bins = 8\n    hist, _ = np.histogram(angles, bins=bins, range=(-np.pi, np.pi))\n    p = hist.astype(float) / (np.sum(hist) + 1e-8)\n    p_nonzero = p[p > 0]\n    ent = -np.sum(p_nonzero * np.log(p_nonzero))\n    # normalize by log(bins)\n    ent_norm = ent / (np.log(max(2, bins)) + 1e-12)\n    return float(max(0.0, min(1.0, ent_norm)))\n", "def feature(image: np.ndarray) -> float:\n    'Vertical centroid of the detected foreground normalized to [0,1] (0=top,1=bottom)'\n    import numpy as np\n    if image is None:\n        return 0.5\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.5\n    # grayscale\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 50)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    ys, xs = np.where(mask)\n    if ys.size == 0:\n        return 0.5\n    centroid_y = float(np.mean(ys))\n    return float(centroid_y / float(max(1, h - 1)))\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Aspect ratio (height / width) of the foreground bounding box (>=0)'\n    import numpy as np\n    if image is None:\n        return 1.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 1.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 50)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    ys, xs = np.where(mask)\n    if ys.size == 0:\n        return 1.0\n    ymin, ymax = int(np.min(ys)), int(np.max(ys))\n    xmin, xmax = int(np.min(xs)), int(np.max(xs))\n    bbox_h = float(max(1, ymax - ymin + 1))\n    bbox_w = float(max(1, xmax - xmin + 1))\n    return float(bbox_h / (bbox_w + 1e-8))\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Count of 4-connected foreground components (small components included)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 50)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    mask = mask.astype(np.uint8)\n    visited = np.zeros_like(mask, dtype=np.uint8)\n    comps = 0\n    for y in range(h):\n        for x in range(w):\n            if mask[y, x] and not visited[y, x]:\n                comps += 1\n                # flood fill stack\n                stack = [(y, x)]\n                visited[y, x] = 1\n                while stack:\n                    cy, cx = stack.pop()\n                    # neighbors 4-connected\n                    if cy > 0 and mask[cy - 1, cx] and not visited[cy - 1, cx]:\n                        visited[cy - 1, cx] = 1; stack.append((cy - 1, cx))\n                    if cy + 1 < h and mask[cy + 1, cx] and not visited[cy + 1, cx]:\n                        visited[cy + 1, cx] = 1; stack.append((cy + 1, cx))\n                    if cx > 0 and mask[cy, cx - 1] and not visited[cy, cx - 1]:\n                        visited[cy, cx - 1] = 1; stack.append((cy, cx - 1))\n                    if cx + 1 < w and mask[cy, cx + 1] and not visited[cy, cx + 1]:\n                        visited[cy, cx + 1] = 1; stack.append((cy, cx + 1))\n    return float(comps)\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Vertical top-bottom symmetry score of the foreground (1.0 = perfectly symmetric)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 2 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 50)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    top = mask[:h//2, :]\n    bottom = mask[h - (h//2):, :]\n    # flip bottom vertically to compare\n    bottom_flipped = np.flipud(bottom)\n    # crop to minimal overlapping height if sizes differ\n    mh = min(top.shape[0], bottom_flipped.shape[0])\n    if mh == 0:\n        return 0.0\n    top_c = top[:mh, :]\n    bot_c = bottom_flipped[:mh, :]\n    intersection = float(np.count_nonzero(top_c & bot_c))\n    union = float(np.count_nonzero(top_c | bot_c)) + 1e-8\n    score = intersection / union\n    return float(score)\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Mean Euclidean distance of foreground pixels to image center normalized to [0,1]'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    cy, cx = (h - 1) / 2.0, (w - 1) / 2.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 50)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    ys, xs = np.where(mask)\n    if ys.size == 0:\n        return 0.0\n    dists = np.sqrt((ys - cy) ** 2 + (xs - cx) ** 2)\n    mean_dist = float(np.mean(dists))\n    max_possible = np.sqrt(cx ** 2 + cy ** 2) + 1e-8\n    return float(mean_dist / max_possible)\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Perimeter-to-area ratio of the foreground mask (higher for elongated/complex shapes)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 50)\n    mask = ((gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)).astype(np.uint8)\n    area = float(np.count_nonzero(mask))\n    if area == 0:\n        return 0.0\n    # compute perimeter by counting boundary pixels via xor with shifted masks\n    p = 0\n    # vertical boundaries\n    p += np.count_nonzero(mask[:, :-1] != mask[:, 1:])\n    # horizontal boundaries\n    p += np.count_nonzero(mask[:-1, :] != mask[1:, :])\n    perimeter = float(p)\n    return float(perimeter / (area + 1e-8))\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Ratio of mean foreground width in bottom 25% rows to top 25% rows (helps separate shoes/pants vs tops)'\n    import numpy as np\n    if image is None:\n        return 1.0\n    h, w = image.shape[:2]\n    if h < 4 or w == 0:\n        return 1.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 50)\n    mask = ((gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)).astype(np.uint8)\n    band = max(1, h // 4)\n    top_band = mask[:band, :]\n    bottom_band = mask[h - band:, :]\n    top_widths = np.sum(top_band, axis=1).astype(float)\n    bottom_widths = np.sum(bottom_band, axis=1).astype(float)\n    top_mean = float(np.mean(top_widths)) + 1e-8\n    bottom_mean = float(np.mean(bottom_widths)) + 1e-8\n    return float(bottom_mean / top_mean)\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Average red bias magnitude (|R-G| + |R-B|) normalized by 510, 0 for grayscale images'\n    import numpy as np\n    if image is None:\n        return 0.0\n    if len(image.shape) != 3 or image.shape[2] != 3:\n        return 0.0\n    img = image.astype(float)\n    R = img[:, :, 0]\n    G = img[:, :, 1]\n    B = img[:, :, 2]\n    bias = np.mean(np.abs(R - G) + np.abs(R - B))\n    # max possible per pixel is 510 (255+255)\n    return float(bias / (510.0 + 1e-8))\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Fraction of foreground pixels that lie in the bottom 15% of the image (shoe/boot indicator)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 50)\n    mask = ((gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)).astype(np.uint8)\n    total = float(np.count_nonzero(mask))\n    if total == 0:\n        return 0.0\n    bottom_h = max(1, int(np.ceil(0.15 * h)))\n    bottom_mask = mask[h - bottom_h:, :]\n    bottom_count = float(np.count_nonzero(bottom_mask))\n    return float(bottom_count / (total + 1e-8))\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Shape compactness: (perimeter^2) / area (higher for less compact shapes), returns 0 for empty'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 50)\n    mask = ((gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)).astype(np.uint8)\n    area = float(np.count_nonzero(mask))\n    if area == 0:\n        return 0.0\n    p = 0\n    p += np.count_nonzero(mask[:, :-1] != mask[:, 1:])\n    p += np.count_nonzero(mask[:-1, :] != mask[1:, :])\n    perimeter = float(p) + 1e-8\n    compactness = (perimeter * perimeter) / area\n    return float(compactness)\n", "def feature(image: np.ndarray) -> float:\n    'Ratio of mask area in top 40% versus bottom 40% (top_area / bottom_area, clipped)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    # grayscale\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 50)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    top_h = max(1, (40 * h) // 100)\n    bot_start = max(0, h - top_h)\n    top_area = float(np.count_nonzero(mask[:top_h, :]))\n    bot_area = float(np.count_nonzero(mask[bot_start:, :]))\n    if bot_area <= 1e-8:\n        return float(min(10.0, top_area))  # avoid div by zero, saturate\n    return float(top_area / bot_area)\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Vertical centroid of the mask normalized to [0..1] (0=top,1=bottom)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h <= 0 or w <= 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 50)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    ys, xs = np.where(mask)\n    if ys.size == 0:\n        return 0.0\n    centroid_y = float(np.mean(ys))\n    return float(centroid_y / max(1.0, float(h - 1)))\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Number of connected foreground components (simple 4-neighbor flood fill), clipped to 20'\n    import numpy as np\n    from collections import deque\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = ((gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)).astype(bool)\n    visited = np.zeros_like(mask, dtype=bool)\n    comps = 0\n    for r in range(h):\n        for c in range(w):\n            if mask[r, c] and not visited[r, c]:\n                comps += 1\n                # flood fill\n                dq = deque()\n                dq.append((r, c))\n                visited[r, c] = True\n                while dq:\n                    yr, yc = dq.popleft()\n                    # 4-neighbors\n                    if yr > 0 and mask[yr - 1, yc] and not visited[yr - 1, yc]:\n                        visited[yr - 1, yc] = True\n                        dq.append((yr - 1, yc))\n                    if yr + 1 < h and mask[yr + 1, yc] and not visited[yr + 1, yc]:\n                        visited[yr + 1, yc] = True\n                        dq.append((yr + 1, yc))\n                    if yc > 0 and mask[yr, yc - 1] and not visited[yr, yc - 1]:\n                        visited[yr, yc - 1] = True\n                        dq.append((yr, yc - 1))\n                    if yc + 1 < w and mask[yr, yc + 1] and not visited[yr, yc + 1]:\n                        visited[yr, yc + 1] = True\n                        dq.append((yr, yc + 1))\n                if comps >= 20:\n                    # clip for stability\n                    return float(20.0)\n    return float(float(comps))\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Average horizontal protrusion of mask edges in upper quarter relative to torso center'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 4 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = ((gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)).astype(int)\n    top_h = max(1, h // 4)\n    center_x = w // 2\n    protrusions = []\n    for r in range(top_h):\n        row = mask[r, :]\n        if np.any(row):\n            left = np.argmax(row) if row[0] == 1 else np.where(row == 1)[0][0]\n            right = w - 1 - (np.argmax(row[::-1]) if row[-1] == 1 else np.where(row == 1)[0][-1])\n            # distances from center\n            left_dist = max(0, center_x - left)\n            right_dist = max(0, right - center_x)\n            protrusions.append((left_dist + right_dist) / 2.0)\n    if len(protrusions) == 0:\n        return 0.0\n    avg = float(np.mean(protrusions))\n    return float(avg / max(1.0, float(w)))\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Fraction of mask pixels located in bottom 20% of the image (shoe indicator)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 50)\n    mask = ((gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)).astype(bool)\n    total = float(np.count_nonzero(mask))\n    if total <= 0:\n        return 0.0\n    bottom_h = max(1, (20 * h) // 100)\n    bottom_area = float(np.count_nonzero(mask[h - bottom_h:, :]))\n    return float(bottom_area / total)\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Horizontal offset of mask centroid from image center normalized by width (signed)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w <= 1:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 50)\n    mask = ((gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)).astype(bool)\n    ys, xs = np.where(mask)\n    if xs.size == 0:\n        return 0.0\n    centroid_x = float(np.mean(xs))\n    center_x = float((w - 1) / 2.0)\n    return float((centroid_x - center_x) / max(1.0, float(w - 1)))\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Waist pinch index: normalized change between width at 25% and 55% heights (positive => narrower at waist)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 4 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = ((gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)).astype(int)\n    def row_width(r):\n        row = mask[r, :]\n        return float(np.count_nonzero(row))\n    r1 = min(h - 1, max(0, int(0.25 * h)))\n    r2 = min(h - 1, max(0, int(0.55 * h)))\n    w1 = row_width(r1)\n    w2 = row_width(r2)\n    denom = max(1.0, max(w1, w2))\n    # positive if w2 < w1 (narrower at waist)\n    return float((w1 - w2) / denom)\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Colorfulness metric for RGB images, 0 for grayscale inputs'\n    import numpy as np\n    if image is None:\n        return 0.0\n    if len(image.shape) != 3 or image.shape[2] < 3:\n        return 0.0\n    # simple Hasler & Suesstrunk inspired metric\n    r = image[:, :, 0].astype(float)\n    g = image[:, :, 1].astype(float)\n    b = image[:, :, 2].astype(float)\n    rg = r - g\n    yb = 0.5 * (r + g) - b\n    std_rg = float(np.std(rg))\n    std_yb = float(np.std(yb))\n    mean_rg = float(np.mean(rg))\n    mean_yb = float(np.mean(yb))\n    # colorfulness\n    score = np.sqrt(std_rg ** 2 + std_yb ** 2) + 0.3 * np.sqrt(mean_rg ** 2 + mean_yb ** 2)\n    # normalize roughly by dynamic range\n    denom = float(np.max(image) - np.min(image) + 1e-8)\n    return float(score / denom)\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Normalized high-frequency gradient energy in bottom quarter (shoes/textures)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 4 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    # normalize intensities\n    mx = float(np.max(gray))\n    if mx > 0:\n        gray = gray / mx\n    bottom_h = max(1, h // 4)\n    region = gray[h - bottom_h:, :]\n    gy, gx = np.gradient(region)\n    energy = float(np.sum(np.abs(gx)) + np.sum(np.abs(gy)))\n    # normalize by region area\n    area = float(region.size)\n    return float(energy / (area + 1e-8))\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Left-right imbalance score: absolute difference of mask area between left and right thirds (0..1)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w < 3:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 50)\n    mask = ((gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)).astype(bool)\n    third = max(1, w // 3)\n    left = float(np.count_nonzero(mask[:, :third]))\n    mid = float(np.count_nonzero(mask[:, third:2 * third]))\n    right = float(np.count_nonzero(mask[:, 2 * third:]))\n    total = left + mid + right\n    if total <= 0:\n        return 0.0\n    imbalance = abs(left - right) / total\n    return float(min(1.0, imbalance))\n", "def feature(image: np.ndarray) -> float:\n    'Aspect ratio (width / height) of the tight foreground bounding box, centered around object'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    # grayscale\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 60)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    ys, xs = np.where(mask)\n    if ys.size == 0:\n        return 0.0\n    minr, maxr = int(np.min(ys)), int(np.max(ys))\n    minc, maxc = int(np.min(xs)), int(np.max(xs))\n    bbox_h = max(1, maxr - minr + 1)\n    bbox_w = max(1, maxc - minc + 1)\n    result = float(bbox_w) / float(bbox_h + 1e-8)\n    return float(result)\n\n", "def feature(image: np.ndarray) -> float:\n    'Vertical centroid of foreground mask normalized to [0..1] (0=top,1=bottom)'\n    import numpy as np\n    if image is None:\n        return 0.5\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.5\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    ys, xs = np.where(mask)\n    if ys.size == 0:\n        return 0.5\n    centroid_y = float(np.mean(ys))\n    result = centroid_y / float(h - 1 + 1e-8)\n    return float(result)\n\n", "def feature(image: np.ndarray) -> float:\n    'Left-right symmetry score based on mean absolute difference between mirrored halves (1 symmetric, -1 worst)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 1 or w < 2:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    half = w // 2\n    left = gray[:, :half]\n    right = gray[:, w - half:]\n    # flip left to compare with right\n    left_flip = left[:, ::-1]\n    if left_flip.shape != right.shape:\n        # pad smaller to match\n        minr = min(left_flip.shape[1], right.shape[1])\n        left_flip = left_flip[:, :minr]\n        right = right[:, :minr]\n    diff = np.abs(left_flip - right)\n    denom = (np.mean(np.abs(left_flip)) + np.mean(np.abs(right))) / 2.0 + 1e-8\n    sim = 1.0 - (np.mean(diff) / denom)\n    # clamp between -1 and 1\n    sim = max(-1.0, min(1.0, float(sim)))\n    return float(sim)\n\n", "def feature(image: np.ndarray) -> float:\n    'Mean color saturation (RGB) measured as (max-min)/max per pixel, 0 for grayscale images'\n    import numpy as np\n    if image is None:\n        return 0.0\n    if len(image.shape) != 3 or image.shape[2] != 3:\n        return 0.0\n    img = image.astype(float)\n    r = img[:, :, 0]\n    g = img[:, :, 1]\n    b = img[:, :, 2]\n    mx = np.maximum(np.maximum(r, g), b)\n    mn = np.minimum(np.minimum(r, g), b)\n    sat = (mx - mn) / (mx + 1e-8)\n    # where max is zero set saturation to zero\n    sat = np.where(mx <= 1e-8, 0.0, sat)\n    result = float(np.mean(sat))\n    return float(result)\n\n", "def feature(image: np.ndarray) -> float:\n    'Top vs bottom mean brightness contrast normalized by overall mean (top25 - bottom25) / mean'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 4 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    top_h = max(1, h // 4)\n    bottom_h = max(1, h // 4)\n    top_mean = float(np.mean(gray[:top_h, :]))\n    bottom_mean = float(np.mean(gray[h - bottom_h:, :]))\n    denom = float(np.mean(gray)) + 1e-8\n    result = (top_mean - bottom_mean) / denom\n    return float(result)\n\n", "def feature(image: np.ndarray) -> float:\n    'Fraction of rows that have strong horizontal edge energy (indicates belts, hems, or separations)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 3 or w < 1:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    gy, gx = np.gradient(gray.astype(float))\n    edge_mag = np.abs(gy) + np.abs(gx)\n    # row energy\n    row_energy = np.mean(edge_mag, axis=1)\n    thr = np.percentile(row_energy, 75)\n    strong_rows = np.count_nonzero(row_energy > thr)\n    result = float(strong_rows) / float(h)\n    return float(result)\n\n", "def feature(image: np.ndarray) -> float:\n    'Average foreground width in the shoulder band (rows ~8%..22% of height) normalized by image width'\n    import numpy as np\n    if image is None:\n        return 0.5\n    h, w = image.shape[:2]\n    if h < 5 or w == 0:\n        return 0.5\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    start = int(max(0, h * 0.08))\n    end = int(min(h, h * 0.22))\n    if end <= start:\n        return 0.5\n    widths = []\n    for r in range(start, end):\n        cols = np.where(mask[r, :])[0]\n        if cols.size > 0:\n            widths.append(float(cols[-1] - cols[0] + 1))\n    if len(widths) == 0:\n        return 0.0\n    avg_w = float(np.mean(widths))\n    result = avg_w / float(w + 1e-8)\n    return float(result)\n\n", "def feature(image: np.ndarray) -> float:\n    'Left-right foreground imbalance: absolute difference in mask mass between halves normalized by total'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    half = w // 2\n    left_sum = float(np.count_nonzero(mask[:, :half]))\n    right_sum = float(np.count_nonzero(mask[:, half:]))\n    total = left_sum + right_sum + 1e-8\n    result = abs(left_sum - right_sum) / total\n    return float(result)\n\n", "def feature(image: np.ndarray) -> float:\n    'Top-edge horizontal gradient density: fraction of strong horizontal edges in the top 12% rows'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 3 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    top_h = max(1, int(h * 0.12))\n    gy, gx = np.gradient(gray.astype(float))\n    # horizontal gradient magnitude (changes left-right)\n    horiz = np.abs(gx)\n    band = horiz[:top_h, :]\n    if band.size == 0:\n        return 0.0\n    thr = np.percentile(band, 80)\n    strong = float(np.count_nonzero(band > thr))\n    result = strong / float(band.size)\n    return float(result)\n\n", "def feature(image: np.ndarray) -> float:\n    'Ratio of Laplacian variance in bottom 20% to top 20% (shoe texture vs upper garment texture)'\n    import numpy as np\n    if image is None:\n        return 1.0\n    h, w = image.shape[:2]\n    if h < 6 or w < 3:\n        return 1.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    gy, gx = np.gradient(gray.astype(float))\n    gxx = np.gradient(gx, axis=1)\n    gyy = np.gradient(gy, axis=0)\n    lap = gxx + gyy\n    band = max(1, h // 5)\n    top_lap = lap[:band, :].flatten()\n    bottom_lap = lap[h - band:, :].flatten()\n    if top_lap.size == 0 or bottom_lap.size == 0:\n        return 1.0\n    var_top = float(np.var(top_lap))\n    var_bottom = float(np.var(bottom_lap))\n    result = (var_bottom + 1e-8) / (var_top + 1e-8)\n    return float(result)\n", "def feature(image: np.ndarray) -> float:\n    'Foreground bounding-box aspect ratio (height / width) computed from a simple intensity mask'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    ys, xs = np.where(mask)\n    if ys.size == 0 or xs.size == 0:\n        return 0.0\n    bbox_h = float(ys.max() - ys.min() + 1)\n    bbox_w = float(xs.max() - xs.min() + 1)\n    if bbox_w <= 1e-8:\n        return 0.0\n    return float(bbox_h / bbox_w)\n\n", "def feature(image: np.ndarray) -> float:\n    'Normalized foreground area fraction (mask area / image area)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    area = float(h) * float(w)\n    if area <= 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    fg = float(np.count_nonzero(mask))\n    return float(fg / area)\n\n", "def feature(image: np.ndarray) -> float:\n    'Vertical centroid of mask (normalized 0.0 top to 1.0 bottom)'\n    import numpy as np\n    if image is None:\n        return 0.5\n    h, w = image.shape[:2]\n    if h == 0:\n        return 0.5\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    ys, xs = np.where(mask)\n    if ys.size == 0:\n        return 0.5\n    centroid_y = float(np.mean(ys))\n    return float(centroid_y / max(1.0, float(h - 1)))\n\n", "def feature(image: np.ndarray) -> float:\n    'Left-right symmetry score (mean absolute difference between left and mirrored right, normalized)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    # crop to even width for simpler mirroring\n    mid = w // 2\n    left = gray[:, :mid]\n    right = gray[:, w - mid:]\n    if left.size == 0 or right.size == 0:\n        return 0.0\n    right_flipped = np.fliplr(right)\n    # resize if shapes mismatch (when w is odd)\n    if left.shape != right_flipped.shape:\n        min_c = min(left.shape[1], right_flipped.shape[1])\n        left = left[:, :min_c]\n        right_flipped = right_flipped[:, :min_c]\n    diff = np.abs(left - right_flipped)\n    denom = np.mean(np.abs(gray)) + 1e-8\n    return float(np.mean(diff) / denom)\n\n", "def feature(image: np.ndarray) -> float:\n    'Major/minor axis ratio of mask point cloud (eigenvalue ratio of covariance)'\n    import numpy as np\n    if image is None:\n        return 1.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 1.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    ys, xs = np.where(mask)\n    if ys.size <= 1:\n        return 1.0\n    coords = np.vstack([xs.astype(float), ys.astype(float)])\n    cov = np.cov(coords)\n    # handle degenerate covariance\n    try:\n        vals = np.linalg.eigvalsh(cov)\n    except Exception:\n        return 1.0\n    vals = np.sort(vals)\n    small = max(vals[0], 1e-8)\n    large = max(vals[-1], small)\n    return float(large / small)\n\n", "def feature(image: np.ndarray) -> float:\n    'Edge density: fraction of pixels whose gradient magnitude exceeds the median magnitude'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 2 or w < 2:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    gy, gx = np.gradient(gray)\n    mag = np.sqrt(gx * gx + gy * gy)\n    med = np.median(mag)\n    if mag.size == 0:\n        return 0.0\n    count = float(np.count_nonzero(mag > med))\n    return float(count / float(mag.size))\n\n", "def feature(image: np.ndarray) -> float:\n    'Ratio of foreground widths at chest (~30% height) to hips (~60% height)'\n    import numpy as np\n    if image is None:\n        return 1.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 1.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    def row_width_at(frac):\n        row = int(min(h - 1, max(0, int(frac * h))))\n        band = max(1, int(h * 0.02))\n        start = max(0, row - band)\n        end = min(h, row + band + 1)\n        widths = np.sum(mask[start:end, :].astype(float), axis=1)\n        if widths.size == 0:\n            return 0.0\n        return float(np.mean(widths))\n    chest = row_width_at(0.30)\n    hips = row_width_at(0.60)\n    if hips <= 1e-8:\n        return float(chest)\n    return float(chest / hips)\n\n", "def feature(image: np.ndarray) -> float:\n    'Column-wise centroid spread: std of vertical centroids across columns normalized by image height'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h <= 1 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    centroids = []\n    rows = np.arange(h).astype(float)\n    for c in range(w):\n        col = mask[:, c].astype(float)\n        s = col.sum()\n        if s <= 0:\n            continue\n        cent = float((rows * col).sum() / (s + 1e-12))\n        centroids.append(cent)\n    if len(centroids) == 0:\n        return 0.0\n    std_cent = float(np.std(np.array(centroids)))\n    return float(std_cent / float(h))\n\n", "def feature(image: np.ndarray) -> float:\n    'Corner occupancy: fraction of mask pixels located within 10% image margin corners'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    total = float(np.count_nonzero(mask))\n    if total <= 0:\n        return 0.0\n    mh = max(1, int(0.10 * h))\n    mw = max(1, int(0.10 * w))\n    corners = 0\n    corners += np.count_nonzero(mask[:mh, :mw])\n    corners += np.count_nonzero(mask[:mh, w - mw: w])\n    corners += np.count_nonzero(mask[h - mh: h, :mw])\n    corners += np.count_nonzero(mask[h - mh: h, w - mw: w])\n    return float(corners / total)\n\n", "def feature(image: np.ndarray) -> float:\n    'Color channel dominance (max channel mean - min channel mean) normalized by overall mean; 0 for grayscale'\n    import numpy as np\n    if image is None:\n        return 0.0\n    if len(image.shape) != 3:\n        return 0.0\n    h, w, c = image.shape\n    if c < 3 or h == 0 or w == 0:\n        return 0.0\n    img = image.astype(float)\n    means = [float(np.mean(img[:, :, i])) for i in range(3)]\n    mx = max(means)\n    mn = min(means)\n    denom = float(np.mean(means)) + 1e-8\n    return float((mx - mn) / denom)\n", "def feature(image: np.ndarray) -> float:\n    'Aspect ratio of the foreground bounding box (width / height)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    ys, xs = np.where(mask)\n    if ys.size == 0:\n        return 0.0\n    miny, maxy = int(np.min(ys)), int(np.max(ys))\n    minx, maxx = int(np.min(xs)), int(np.max(xs))\n    bbox_h = float(max(1, maxy - miny + 1))\n    bbox_w = float(max(1, maxx - minx + 1))\n    return float(bbox_w / bbox_h)\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Fraction of image occupied by the foreground mask'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    total = h * w\n    if total == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    area = float(np.count_nonzero(mask))\n    return float(area / float(total))\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Normalized left-right mask asymmetry (0 symmetric -> higher = more asymmetric)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if w == 0 or h == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    mid = w // 2\n    left_sum = float(np.count_nonzero(mask[:, :mid]))\n    right_sum = float(np.count_nonzero(mask[:, w - mid:]))\n    total = left_sum + right_sum\n    if total <= 1e-8:\n        return 0.0\n    diff = abs(left_sum - right_sum)\n    return float(diff / total)\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Ratio of mean mask width in the top 15% rows to bottom 15% rows'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 4 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    band = max(1, int(0.15 * h))\n    top_rw = np.sum(mask[:band, :], axis=1).astype(float)\n    bottom_rw = np.sum(mask[h - band:, :], axis=1).astype(float)\n    top_mean = float(np.mean(top_rw)) if top_rw.size > 0 else 0.0\n    bottom_mean = float(np.mean(bottom_rw)) if bottom_rw.size > 0 else 0.0\n    return float(top_mean / (bottom_mean + 1e-8))\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Count of significant local minima in per-row mask widths (normalized by image height)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 3 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    row_widths = np.sum(mask, axis=1).astype(float)\n    # smooth widths\n    k = 5\n    kernel = np.ones(k) / float(k)\n    smooth = np.convolve(row_widths, kernel, mode='same')\n    med = np.median(smooth) if smooth.size > 0 else 0.0\n    minima = 0\n    for i in range(1, h - 1):\n        if smooth[i] < smooth[i - 1] and smooth[i] < smooth[i + 1] and smooth[i] < max(1e-6, 0.9 * med):\n            minima += 1\n    return float(minima / max(1.0, float(h)))\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Mean vertical run length of foreground pixels per column normalized by image height'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    run_lengths = []\n    for col in range(w):\n        col_vals = mask[:, col].astype(int)\n        if np.all(col_vals == 0):\n            continue\n        padded = np.concatenate(([0], col_vals, [0]))\n        diffs = np.diff(padded)\n        starts = np.where(diffs == 1)[0]\n        ends = np.where(diffs == -1)[0]\n        lengths = (ends - starts).tolist()\n        run_lengths.extend(lengths)\n    if len(run_lengths) == 0:\n        return 0.0\n    mean_run = float(np.mean(run_lengths))\n    return float(mean_run / max(1.0, float(h)))\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Edge concentration in a bottom-center triangular region relative to whole-image edge energy'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 3 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    gy, gx = np.gradient(gray.astype(float))\n    grad_mag = np.sqrt(gx * gx + gy * gy)\n    mean_all = float(np.mean(grad_mag)) if grad_mag.size > 0 else 0.0\n    start_row = int(0.7 * h)\n    if start_row >= h:\n        start_row = max(0, h - 1)\n    tri_mask = np.zeros_like(grad_mag, dtype=bool)\n    for r in range(start_row, h):\n        rel = (r - start_row) / max(1.0, (h - 1 - start_row))\n        half_w = int((0.5 - 0.5 * rel) * w)  # narrowing toward top of triangle\n        cx = w // 2\n        left = max(0, cx - half_w)\n        right = min(w, cx + half_w)\n        if left < right:\n            tri_mask[r, left:right] = True\n    if not np.any(tri_mask):\n        return 0.0\n    mean_tri = float(np.mean(grad_mag[tri_mask]))\n    denom = max(1e-8, mean_all)\n    return float(mean_tri / denom)\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Normalized inter-channel color variation (0 for grayscale)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    if len(image.shape) != 3 or image.shape[2] < 3:\n        return 0.0\n    img = image.astype(float)\n    ch_std = np.std(img, axis=(0, 1))\n    mean_chan_std = float(np.mean(ch_std))\n    intensity = np.mean(img, axis=2)\n    overall_std = float(np.std(intensity))\n    return float(mean_chan_std / (overall_std + 1e-8))\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Foreground area divided by bounding box area (proxy for convexity / compactness)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    ys, xs = np.where(mask)\n    if ys.size == 0:\n        return 0.0\n    area = float(ys.size)\n    miny, maxy = int(np.min(ys)), int(np.max(ys))\n    minx, maxx = int(np.min(xs)), int(np.max(xs))\n    bbox_area = float(max(1, maxy - miny + 1) * max(1, maxx - minx + 1))\n    return float(area / bbox_area)\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Shoulder/top spread: mean mask width in top 12% rows divided by bounding box width'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 3 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    ys, xs = np.where(mask)\n    if ys.size == 0:\n        return 0.0\n    minx, maxx = int(np.min(xs)), int(np.max(xs))\n    bbox_w = float(max(1, maxx - minx + 1))\n    top_rows = max(1, int(0.12 * h))\n    top_widths = np.sum(mask[:top_rows, :], axis=1).astype(float)\n    valid = top_widths[top_widths > 0]\n    if valid.size == 0:\n        return 0.0\n    mean_top = float(np.mean(valid))\n    return float(mean_top / (bbox_w + 1e-8))\n", "def feature(image: np.ndarray) -> float:\n    'Bounding-box aspect ratio normalized by image aspect ratio (tall vs wide items)'\n    import numpy as np\n    if image is None:\n        return 1.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 1.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    ys, xs = np.where(mask)\n    if ys.size == 0 or xs.size == 0:\n        return 1.0\n    bh = float(np.max(ys) - np.min(ys) + 1)\n    bw = float(np.max(xs) - np.min(xs) + 1)\n    if bw <= 1e-8:\n        return 1.0\n    img_ratio = float(h) / float(w)\n    bbox_ratio = bh / (bw + 1e-8)\n    return float((bbox_ratio + 1e-8) / (img_ratio + 1e-8))\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Mask fill fraction: mask area divided by bounding-box area (compactness)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    total = float(np.count_nonzero(mask))\n    if total == 0:\n        return 0.0\n    ys, xs = np.where(mask)\n    miny, maxy = int(np.min(ys)), int(np.max(ys))\n    minx, maxx = int(np.min(xs)), int(np.max(xs))\n    bbox_area = float((maxy - miny + 1) * (maxx - minx + 1))\n    if bbox_area <= 1e-8:\n        return 0.0\n    return float(total / bbox_area)\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Fraction of mask pixels located in the bottom 20% of the image (shoe/trouser indicator)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    total_mask = float(np.count_nonzero(mask))\n    if total_mask == 0:\n        return 0.0\n    bottom_h = max(1, int(0.20 * h))\n    bottom_mask = mask[h - bottom_h:, :]\n    bottom_count = float(np.count_nonzero(bottom_mask))\n    return float(bottom_count / (total_mask + 1e-8))\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Horizontal left-right asymmetry score of the mask (0 = perfectly symmetric)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    flipped = mask[:, ::-1]\n    diff = np.abs(mask.astype(float) - flipped.astype(float))\n    diff_sum = float(np.sum(diff))\n    # normalize by image area to keep in [0,1]\n    return float(diff_sum / float(h * w + 1e-8))\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Slope of row-wise mask widths across the middle third (positive => widening toward bottom)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 3 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    start = h // 3\n    end = min(h, 2 * (h // 3) + (h % 3))\n    rows = np.arange(start, end).astype(float)\n    if rows.size < 2:\n        return 0.0\n    widths = np.sum(mask[start:end, :].astype(float), axis=1)\n    if np.all(widths == 0):\n        return 0.0\n    # linear fit\n    try:\n        coeffs = np.polyfit(rows, widths, 1)\n        slope = float(coeffs[0])\n    except Exception:\n        slope = 0.0\n    # normalize by image width so scale is comparable across sizes\n    return float(slope / (w + 1e-8))\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Mean number of foreground runs per column (captures multi-part silhouettes like sleeves)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    runs = []\n    for c in range(w):\n        col = mask[:, c]\n        run_count = 0\n        in_run = False\n        for v in col:\n            if v and not in_run:\n                run_count += 1\n                in_run = True\n            elif not v:\n                in_run = False\n        runs.append(run_count)\n    if len(runs) == 0:\n        return 0.0\n    return float(np.mean(runs))\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Largest horizontal background gap in the top 12% center region normalized by image width'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 3 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 50)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    top_h = max(1, int(0.12 * h))\n    center_w = max(1, int(0.30 * w))\n    cx0 = max(0, (w // 2) - (center_w // 2))\n    cx1 = min(w, cx0 + center_w)\n    patch = mask[:top_h, cx0:cx1]\n    if patch.size == 0:\n        return 0.0\n    max_gap = 0\n    for r in range(patch.shape[0]):\n        row = ~patch[r, :]\n        curr = 0\n        for v in row:\n            if v:\n                curr += 1\n                if curr > max_gap:\n                    max_gap = curr\n            else:\n                curr = 0\n    return float(max_gap / (w + 1e-8))\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Normalized mean gradient magnitude (edge energy normalized by mean intensity)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 2 or w < 2:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    mx = np.max(gray)\n    if mx > 0:\n        gray = gray / mx\n    gy, gx = np.gradient(gray)\n    mag = np.sqrt(gx * gx + gy * gy)\n    mean_mag = float(np.mean(mag))\n    mean_intensity = float(np.mean(gray))\n    return float(mean_mag / (mean_intensity + 1e-8))\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Dominant color channel ratio: strongest channel mean divided by mean of other two (RGB only)'\n    import numpy as np\n    if image is None:\n        return 1.0\n    if len(image.shape) != 3 or image.shape[2] < 3:\n        return 1.0\n    r = image[:, :, 0].astype(float)\n    g = image[:, :, 1].astype(float)\n    b = image[:, :, 2].astype(float)\n    mr = float(np.mean(r))\n    mg = float(np.mean(g))\n    mb = float(np.mean(b))\n    mx = max(mr, mg, mb)\n    others = (mr + mg + mb - mx)\n    return float(mx / (others / 2.0 + 1e-8))\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Fraction of total mask area contained in a bottom-center box (shoe concentration)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    total = float(np.count_nonzero(mask))\n    if total == 0:\n        return 0.0\n    box_h = max(1, int(0.25 * h))\n    box_w = max(1, int(0.50 * w))\n    y0 = h - box_h\n    x0 = (w - box_w) // 2\n    box = mask[y0:, x0:x0 + box_w]\n    box_count = float(np.count_nonzero(box))\n    return float(box_count / (total + 1e-8))\n", "def feature(image: np.ndarray) -> float:\n    'Colorfulness metric based on rg and yb opponent channels (Hasler-Suesstrunk)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    if len(image.shape) != 3 or image.shape[2] < 3:\n        return 0.0\n    img = image.astype(float)\n    R = img[:, :, 0]\n    G = img[:, :, 1]\n    B = img[:, :, 2]\n    rg = R - G\n    yb = 0.5 * (R + G) - B\n    std_rg = float(np.std(rg))\n    std_yb = float(np.std(yb))\n    mean_rg = float(np.mean(rg))\n    mean_yb = float(np.mean(yb))\n    # Hasler and Suesstrunk colorfulness formula\n    colorfulness = np.sqrt(std_rg**2 + std_yb**2) + 0.3 * np.sqrt(mean_rg**2 + mean_yb**2)\n    return float(colorfulness)\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Vertical symmetry score (1 = perfect mirror across vertical axis)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    # create horizontally flipped version\n    flipped = np.fliplr(gray)\n    diff = np.abs(gray - flipped)\n    mean_diff = float(np.mean(diff))\n    mean_intensity = float(np.mean(gray)) + 1e-8\n    score = 1.0 - (mean_diff / mean_intensity)\n    # clamp to [0,1]\n    score = max(0.0, min(1.0, score))\n    return float(score)\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Horizontal symmetry score (1 = perfect mirror across horizontal axis)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    flipped = np.flipud(gray)\n    diff = np.abs(gray - flipped)\n    mean_diff = float(np.mean(diff))\n    mean_intensity = float(np.mean(gray)) + 1e-8\n    score = 1.0 - (mean_diff / mean_intensity)\n    score = max(0.0, min(1.0, score))\n    return float(score)\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Fraction of image occupied by a simple foreground mask (threshold by median)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    total = float(h * w)\n    if total == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 50)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    frac = float(np.count_nonzero(mask)) / (total + 1e-8)\n    return float(frac)\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Normalized top-vs-bottom mask imbalance: (top-bottom)/(top+bottom) in [-1,1]'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 50)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    if not np.any(mask):\n        return 0.0\n    mid = h // 2\n    top = float(np.count_nonzero(mask[:mid, :]))\n    bot = float(np.count_nonzero(mask[mid:, :]))\n    imbalance = (top - bot) / (top + bot + 1e-8)\n    return float(imbalance)\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Count of vertical mask runs (separate vertical strokes) normalized by width'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 50)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    if not np.any(mask):\n        return 0.0\n    cols_any = np.any(mask, axis=0).astype(int)\n    # count runs of consecutive True columns\n    prev = 0\n    runs = 0\n    for v in cols_any:\n        if v == 1 and prev == 0:\n            runs += 1\n        prev = v\n    result = float(runs) / float(w + 1e-8)\n    return float(result)\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Edge orientation coherence (1 = all edges share same orientation)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 2 or w < 2:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    gy, gx = np.gradient(gray)\n    mag = np.hypot(gx, gy)\n    if not np.any(mag):\n        return 0.0\n    thresh = np.percentile(mag, 70)\n    strong = mag > thresh\n    if np.count_nonzero(strong) == 0:\n        return 0.0\n    angles = np.arctan2(gy[strong], gx[strong])\n    cos_sum = float(np.sum(np.cos(angles)))\n    sin_sum = float(np.sum(np.sin(angles)))\n    n = float(angles.size)\n    r = np.hypot(cos_sum, sin_sum) / (n + 1e-8)\n    # r in [0,1], higher means more coherent orientation\n    return float(r)\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Bounding box area fraction of the foreground mask'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    total = float(max(1, h * w))\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 50)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    ys, xs = np.where(mask)\n    if ys.size == 0 or xs.size == 0:\n        return 0.0\n    ymin, ymax = int(np.min(ys)), int(np.max(ys))\n    xmin, xmax = int(np.min(xs)), int(np.max(xs))\n    box_area = float((ymax - ymin + 1) * (xmax - xmin + 1))\n    frac = box_area / total\n    return float(frac)\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Mean horizontal offset of mask row centroids from image center (0=centered)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 50)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    center_x = (w - 1) / 2.0\n    offsets = []\n    for y in range(h):\n        row = mask[y, :]\n        if np.any(row):\n            xs = np.where(row)[0].astype(float)\n            cx = float(np.mean(xs))\n            offsets.append(abs((cx - center_x) / max(1.0, w / 2.0)))\n    if len(offsets) == 0:\n        return 0.0\n    mean_offset = float(np.mean(offsets))\n    # clamp to [0,1]\n    mean_offset = max(0.0, min(1.0, mean_offset))\n    return float(mean_offset)\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Fraction of pixels that are \"warm\" (R dominant) in an RGB image'\n    import numpy as np\n    if image is None:\n        return 0.0\n    if len(image.shape) != 3 or image.shape[2] < 3:\n        return 0.0\n    img = image.astype(float)\n    R = img[:, :, 0]\n    G = img[:, :, 1]\n    B = img[:, :, 2]\n    # require R to be strictly greater than both and above a moderate intensity\n    thresh = np.percentile(R, 40)\n    warm = (R > G) & (R > B) & (R > thresh)\n    total = float(R.size)\n    if total == 0:\n        return 0.0\n    return float(np.count_nonzero(warm) / (total + 1e-8))\n", "def feature(image: np.ndarray) -> float:\n    'Vertical symmetry score (1.0 = perfectly symmetric, 0.0 = very asymmetric)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    # normalize to 0..1\n    mn, mx = float(np.min(gray)), float(np.max(gray))\n    if mx - mn < 1e-8:\n        return 1.0\n    norm = (gray - mn) / (mx - mn)\n    mirror = np.fliplr(norm)\n    # compare only the overlapping region (whole image)\n    diff = np.mean(np.abs(norm - mirror))\n    score = 1.0 - diff  # higher means more symmetric\n    return float(np.clip(score, 0.0, 1.0))\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Fraction of background in a small top-center patch (proxy for neck/opening)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 4 or w < 4:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    # top center box\n    box_h = max(1, h // 8)\n    box_w = max(1, w // 6)\n    r0 = 0\n    r1 = min(h, box_h)\n    c0 = max(0, (w // 2) - box_w // 2)\n    c1 = min(w, c0 + box_w)\n    patch = mask[r0:r1, c0:c1]\n    if patch.size == 0:\n        return 0.0\n    # fraction of background pixels in the patch (True=foreground)\n    bg_frac = 1.0 - (float(np.count_nonzero(patch)) / float(patch.size))\n    return float(bg_frac)\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Fraction of foreground pixels located in the bottom quarter of the image'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    total = float(np.count_nonzero(mask))\n    if total <= 0:\n        return 0.0\n    bottom_start = int(h * 3 // 4)\n    bottom_count = float(np.count_nonzero(mask[bottom_start:h, :]))\n    return float(bottom_count / total)\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Aspect ratio (width / height) of the foreground bounding box'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    ys, xs = np.where(mask)\n    if ys.size == 0:\n        return 0.0\n    miny, maxy = int(np.min(ys)), int(np.max(ys))\n    minx, maxx = int(np.min(xs)), int(np.max(xs))\n    bbox_h = float(max(1, maxy - miny + 1))\n    bbox_w = float(max(1, maxx - minx + 1))\n    return float(bbox_w / bbox_h)\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Average number of foreground segments per column (useful to detect two-legged pants)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 2 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = ((gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)).astype(np.uint8)\n    seg_counts = []\n    for col in range(w):\n        colv = mask[:, col]\n        if colv.size == 0:\n            seg_counts.append(0)\n            continue\n        # count transitions from 0->1 as segment starts\n        starts = np.sum((colv == 1) & (np.concatenate(([0], colv[:-1])) == 0))\n        seg_counts.append(int(starts))\n    if len(seg_counts) == 0:\n        return 0.0\n    return float(np.mean(seg_counts))\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Mean local width variation in the upper third (higher = more sleeve/neck complexity)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 3 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = ((gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)).astype(np.uint8)\n    top_h = max(1, h // 3)\n    row_widths = np.sum(mask[:top_h, :], axis=1).astype(float)\n    if row_widths.size <= 1:\n        return 0.0\n    # mean absolute diff normalized by image width\n    mad = np.mean(np.abs(np.diff(row_widths))) / float(w + 1e-8)\n    return float(mad)\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Horizontal centroid offset of the foreground from image center (-1..1)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = float(np.median(gray))\n    mask = ((gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)).astype(np.uint8)\n    ys, xs = np.where(mask)\n    if xs.size == 0:\n        return 0.0\n    cx = float(np.mean(xs))\n    center = (w - 1) / 2.0\n    norm = (cx - center) / max(1.0, w / 2.0)\n    return float(np.clip(norm, -1.0, 1.0))\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Mean color saturation (approx) for RGB images, 0.0 for grayscale'\n    import numpy as np\n    if image is None:\n        return 0.0\n    if len(image.shape) != 3 or image.shape[2] < 3:\n        return 0.0\n    img = image.astype(float)\n    R = img[:, :, 0]\n    G = img[:, :, 1]\n    B = img[:, :, 2]\n    mx = np.maximum(np.maximum(R, G), B)\n    mn = np.minimum(np.minimum(R, G), B)\n    denom = mx + 1e-8\n    sat = (mx - mn) / denom\n    return float(np.mean(sat))\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Edge density inside the central box (fraction of pixels with strong gradient)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 3 or w < 3:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    gy, gx = np.gradient(gray)\n    mag = np.sqrt(gx * gx + gy * gy)\n    if not np.any(mag):\n        return 0.0\n    # center box (middle 50% area)\n    r0 = h // 4\n    r1 = h - r0\n    c0 = w // 4\n    c1 = w - c0\n    center_mag = mag[r0:r1, c0:c1]\n    if center_mag.size == 0:\n        return 0.0\n    thr = np.percentile(center_mag, 70)\n    strong = float(np.count_nonzero(center_mag > thr))\n    return float(strong / (center_mag.size + 1e-8))\n\n\n", "def feature(image: np.ndarray) -> float:\n    'Count of pronounced peaks across columns in the lower half (2 peaks often => trousers)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    import numpy as np\n    h, w = image.shape[:2]\n    if h < 4 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = ((gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)).astype(np.uint8)\n    lower = mask[h // 2:, :]\n    if lower.size == 0:\n        return 0.0\n    col_sums = np.sum(lower, axis=0).astype(float)\n    maxv = float(np.max(col_sums)) if col_sums.size else 0.0\n    if maxv <= 0:\n        return 0.0\n    # normalized profile\n    prof = col_sums / (maxv + 1e-8)\n    # find local maxima above threshold\n    thresh = 0.25\n    peaks = 0\n    for i in range(1, prof.size - 1):\n        if prof[i] > prof[i - 1] and prof[i] > prof[i + 1] and prof[i] > thresh:\n            peaks += 1\n    return float(peaks)\n", "def feature(image: np.ndarray) -> float:\n    'Bounding-box aspect ratio of the detected foreground (height/width)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    # grayscale\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    ys, xs = np.where(mask)\n    if ys.size == 0:\n        return 0.0\n    miny, maxy = ys.min(), ys.max()\n    minx, maxx = xs.min(), xs.max()\n    bb_h = maxy - miny + 1\n    bb_w = maxx - minx + 1\n    if bb_w <= 0:\n        return 0.0\n    return float(bb_h / (bb_w + 1e-8))\n\n", "def feature(image: np.ndarray) -> float:\n    'Ratio of foreground fraction in top 40% vs bottom 40% of the image'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 2 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    top_h = max(1, h * 40 // 100)\n    bottom_h = top_h\n    top_count = float(np.count_nonzero(mask[:top_h, :]))\n    bottom_count = float(np.count_nonzero(mask[-bottom_h:, :]))\n    # return ratio top / bottom (balanced)\n    return float((top_count + 1e-8) / (bottom_count + 1e-8))\n\n", "def feature(image: np.ndarray) -> float:\n    'Mean gradient magnitude in the center region (texture/roughness)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 3 or w < 3:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    ch0 = h // 4\n    ch1 = 3 * h // 4\n    cw0 = w // 4\n    cw1 = 3 * w // 4\n    center = gray[ch0:ch1, cw0:cw1]\n    if center.size == 0:\n        return 0.0\n    gy, gx = np.gradient(center.astype(float))\n    mag = np.sqrt(gx * gx + gy * gy)\n    return float(np.mean(mag))\n\n", "def feature(image: np.ndarray) -> float:\n    'Vertical symmetry score comparing top and flipped bottom (1.0 = identical)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 2 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    mx = np.max(gray) if np.max(gray) > 0 else 1.0\n    gray = gray / mx\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    ys, xs = np.where(mask)\n    if ys.size == 0:\n        return 0.0\n    miny, maxy = ys.min(), ys.max()\n    minx, maxx = xs.min(), xs.max()\n    crop = gray[miny:maxy+1, minx:maxx+1]\n    ch = crop.shape[0]\n    if ch <= 1:\n        return 0.0\n    mid = ch // 2\n    top = crop[:mid, :]\n    bottom = crop[-mid:, :] if mid > 0 else crop[:mid, :]\n    bottom_flipped = np.flipud(bottom)\n    mh = min(top.shape[0], bottom_flipped.shape[0])\n    if mh == 0 or top.size == 0 or bottom_flipped.size == 0:\n        return 0.0\n    top = top[:mh, :]\n    bottom_flipped = bottom_flipped[:mh, :]\n    diff = np.abs(top - bottom_flipped)\n    mean_diff = float(np.mean(diff))\n    sym = 1.0 - mean_diff\n    if sym < 0.0:\n        sym = 0.0\n    if sym > 1.0:\n        sym = 1.0\n    return float(sym)\n\n", "def feature(image: np.ndarray) -> float:\n    'Count of local column peaks in the bottom quarter (useful for two-shoe peaks)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 4 or w < 3:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 60)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    start = 3 * h // 4\n    region = mask[start:, :]\n    if region.size == 0:\n        return 0.0\n    col_proj = np.count_nonzero(region, axis=0).astype(float)\n    if col_proj.sum() == 0:\n        return 0.0\n    # simple smoothing\n    kernel = np.array([1, 2, 1], dtype=float)\n    sm = np.convolve(col_proj, kernel, mode='same')\n    # find local maxima: element greater than immediate neighbors and above small threshold\n    peaks = 0\n    th = max(1.0, np.percentile(sm, 50) * 0.5)\n    for i in range(1, sm.size - 1):\n        if sm[i] > sm[i - 1] and sm[i] > sm[i + 1] and sm[i] >= th:\n            peaks += 1\n    return float(min(peaks, 10))\n\n", "def feature(image: np.ndarray) -> float:\n    'Background fraction in a small top-center box (detect neckline/neck hole)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    thr_h = max(1, h * 10 // 100)\n    thr_w = max(1, w * 20 // 100)\n    center_c = w // 2\n    left = max(0, center_c - thr_w // 2)\n    right = min(w, left + thr_w)\n    region = mask[:thr_h, left:right]\n    if region.size == 0:\n        return 0.0\n    bg_frac = 1.0 - float(np.mean(region.astype(float)))\n    return float(bg_frac)\n\n", "def feature(image: np.ndarray) -> float:\n    'Average horizontal extension from image center at shoulder rows (sleeve/shoulder score)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 5 or w < 3:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    start = max(0, int(h * 10 // 100))\n    end = max(start + 1, int(h * 25 // 100))\n    center_col = w // 2\n    exts = []\n    for row in range(start, min(end, h)):\n        row_mask = mask[row, :]\n        if np.any(row_mask[:center_col]):\n            left_idx = np.where(row_mask[:center_col])[0][0]\n            left_ext = center_col - left_idx\n        else:\n            left_ext = 0\n        if np.any(row_mask[center_col:]):\n            right_idx = np.where(row_mask[center_col:])[0][-1]  # index relative to center_col\n            right_ext = right_idx + 1\n        else:\n            right_ext = 0\n        exts.append(left_ext + right_ext)\n    if len(exts) == 0:\n        return 0.0\n    avg_ext = float(np.mean(exts))\n    return float(avg_ext / max(1.0, float(w)))\n\n", "def feature(image: np.ndarray) -> float:\n    'Colorfulness metric for RGB images (0 for grayscale)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    if len(image.shape) != 3 or image.shape[2] < 3:\n        return 0.0\n    img = image.astype(float)\n    r = img[:, :, 0].flatten()\n    g = img[:, :, 1].flatten()\n    b = img[:, :, 2].flatten()\n    rg = r - g\n    yb = 0.5 * (r + g) - b\n    std_rg = np.std(rg)\n    std_yb = np.std(yb)\n    mean_rg = np.mean(rg)\n    mean_yb = np.mean(yb)\n    colorfulness = np.sqrt(std_rg * std_rg + std_yb * std_yb) + 0.3 * np.sqrt(mean_rg * mean_rg + mean_yb * mean_yb)\n    return float(colorfulness)\n\n", "def feature(image: np.ndarray) -> float:\n    'Compactness estimate: area / (perimeter^2) for the foreground mask'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    area = float(np.count_nonzero(mask))\n    if area == 0.0:\n        return 0.0\n    # vertical transitions\n    vert = 0\n    if h > 1:\n        vert = np.count_nonzero(mask[:-1, :] != mask[1:, :])\n    # horizontal transitions\n    hor = 0\n    if w > 1:\n        hor = np.count_nonzero(mask[:, :-1] != mask[:, 1:])\n    perimeter = float(vert + hor)\n    if perimeter <= 1e-8:\n        return float(area)  # very compact (or single pixel)\n    compact = area / ((perimeter + 1e-8) ** 2)\n    return float(compact)\n\n", "def feature(image: np.ndarray) -> float:\n    'Normalized vertical centroid of the foreground mask (0 = top, 1 = bottom)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    ys, xs = np.where(mask)\n    if ys.size == 0:\n        return 0.0\n    cy = float(np.mean(ys)) / float(h)\n    return float(min(1.0, max(0.0, cy)))\n"]}
