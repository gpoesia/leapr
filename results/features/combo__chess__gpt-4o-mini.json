{
  "combined_from": [
    "results/features/did3__chess__gpt-4o-mini.json",
    "results/features/funsearch__chess__gpt-4o-mini.json"
  ],
  "used_features": [
    "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in central control based on pieces in central squares.\"\n    central_squares = [chess.E4, chess.E5, chess.D4, chess.D5]\n    white_control = sum(1 for square in central_squares if board.piece_at(square) is not None and board.piece_at(square).color == chess.WHITE)\n    black_control = sum(1 for square in central_squares if board.piece_at(square) is not None and board.piece_at(square).color == chess.BLACK)\n    result = float(white_control - black_control)\n    return result\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces that are pinned against the opponent's king.\"\n    pinned_pieces = 0\n    opponent_king_square = next(sq for sq, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color != board.turn)\n    \n    for square, piece in board.piece_map().items():\n        if piece.color == board.turn and piece.piece_type != chess.KING:\n            if board.is_attacked_by(not board.turn, square) and board.attackers(not board.turn, opponent_king_square):\n                pinned_pieces += 1\n\n    return float(pinned_pieces)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the mobility of knights for each player.\"\n    white_knight_mobility = sum(len(list(board.legal_moves)) for square in board.piece_map() if board.piece_map()[square].color == chess.WHITE and board.piece_map()[square].piece_type == chess.KNIGHT)\n    black_knight_mobility = sum(len(list(board.legal_moves)) for square in board.piece_map() if board.piece_map()[square].color == chess.BLACK and board.piece_map()[square].piece_type == chess.KNIGHT)\n    return float(white_knight_mobility - black_knight_mobility)\n\n",
    "def feature(board: chess.Board) -> float:\n    'Evaluates the overall imbalance in minor pieces between both sides.'\n    white_knights = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE and piece.piece_type == chess.KNIGHT)\n    black_knights = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK and piece.piece_type == chess.KNIGHT)\n    white_bishops = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE and piece.piece_type == chess.BISHOP)\n    black_bishops = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK and piece.piece_type == chess.BISHOP)\n    \n    result = float((white_knights - black_knights) + (white_bishops - black_bishops))\n    return result\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the number of pawns on the 5th rank for both sides, which can indicate advanced position.\"\n    white_pawns_on_5th = sum(1 for square in range(24, 32) if board.piece_at(square) and board.piece_at(square).color == chess.WHITE and board.piece_at(square).piece_type == chess.PAWN)\n    black_pawns_on_5th = sum(1 for square in range(16, 24) if board.piece_at(square) and board.piece_at(square).color == chess.BLACK and board.piece_at(square).piece_type == chess.PAWN)\n    return float(white_pawns_on_5th - black_pawns_on_5th)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Evaluates the number of pieces that are currently pinned.\"\n    pinned_pieces = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == board.turn:\n            for target in board.attackers(not piece.color, square):\n                if board.piece_at(target) and board.piece_at(target).piece_type == chess.KING:\n                    pinned_pieces += 1\n                    break\n    return float(pinned_pieces)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of connected pieces for each side, contributing to control and structure.\"\n    connected_white = sum(1 for square in board.piece_map() if board.piece_map()[square].color == chess.WHITE and (chess.square_file(square) > 0 and chess.square_file(square) < 7))\n    connected_black = sum(1 for square in board.piece_map() if board.piece_map()[square].color == chess.BLACK and (chess.square_file(square) > 0 and chess.square_file(square) < 7))\n    return float(connected_white - connected_black)\n",
    "def feature(board: chess.Board) -> float:\n    \"Determines the number of pieces that are on their original squares, indicating a lack of development.\"\n    original_square_count = 0\n    for square in board.piece_map():\n        piece = board.piece_at(square)\n        if piece and piece.color == board.turn:\n            if (piece.piece_type == chess.PAWN and (square in [chess.A2, chess.B2, chess.C2, chess.D2, chess.E2, chess.F2, chess.G2, chess.H2] if piece.color == chess.WHITE else\n                                                       square in [chess.A7, chess.B7, chess.C7, chess.D7, chess.E7, chess.F7, chess.G7, chess.H7])):\n                original_square_count += 1\n            elif (piece.piece_type in [chess.ROOK, chess.KNIGHT, chess.BISHOP] and (square in [chess.A1, chess.H1] if piece.color == chess.WHITE else\n                                                                                    square in [chess.A8, chess.H8])):\n                original_square_count += 1\n            elif (piece.piece_type == chess.QUEEN and (square in [chess.D1] if piece.color == chess.WHITE else square in [chess.D8])):\n                original_square_count += 1\n            elif (piece.piece_type == chess.KING and (square in [chess.E1] if piece.color == chess.WHITE else square in [chess.E8])):\n                original_square_count += 1\n    return float(original_square_count)\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of pawn chains (connected pawns) for both sides.\"\n    def count_pawn_chains(color):\n        chains = 0\n        for file in range(8):\n            chain = False\n            for rank in range(8):\n                square = chess.square(file, rank)\n                piece = board.piece_at(square)\n                if piece and piece.color == color and piece.piece_type == chess.PAWN:\n                    if not chain:\n                        chains += 1\n                        chain = True\n                else:\n                    chain = False\n        return chains\n    return float(count_pawn_chains(chess.WHITE) - count_pawn_chains(chess.BLACK))\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces on the edge of the board for both colors, indicating possible mobility.\"\n    edge_pieces_white = sum(1 for sq in board.piece_map() if board.piece_at(sq).color == chess.WHITE and (chess.square_file(sq) == 0 or chess.square_file(sq) == 7))\n    edge_pieces_black = sum(1 for sq in board.piece_map() if board.piece_at(sq).color == chess.BLACK and (chess.square_file(sq) == 0 or chess.square_file(sq) == 7))\n    return float(edge_pieces_white - edge_pieces_black)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the presence of pieces of both sides on the 7th rank, contributing to endgame dynamics.\"\n    seventh_rank_white = sum(1 for square in range(chess.A7, chess.H7) if board.piece_at(square) and board.piece_at(square).color == chess.WHITE)\n    seventh_rank_black = sum(1 for square in range(chess.A7, chess.H7) if board.piece_at(square) and board.piece_at(square).color == chess.BLACK)\n    return float(seventh_rank_white - seventh_rank_black)\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces each side has on the opponent's second rank.\"\n    white_on_second_rank = sum(1 for square in range(16, 24) if board.piece_at(square) and board.piece_at(square).color == chess.WHITE)\n    black_on_second_rank = sum(1 for square in range(48, 56) if board.piece_at(square) and board.piece_at(square).color == chess.BLACK)\n    return float(white_on_second_rank - black_on_second_rank)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces on the back rank for each color.\"\n    white_back_rank = sum(1 for square in range(0, 8) if board.piece_at(chess.square(square, 0)) and board.piece_at(chess.square(square, 0)).color == chess.WHITE)\n    black_back_rank = sum(1 for square in range(0, 8) if board.piece_at(chess.square(square, 7)) and board.piece_at(chess.square(square, 7)).color == chess.BLACK)\n    return float(white_back_rank - black_back_rank)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Evaluates the piece coordination by counting the number of pieces supporting each other.\"\n    support_count = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == board.turn:\n            for target in board.attackers(piece.color, square):\n                if board.piece_at(target) and board.piece_at(target).color == piece.color:\n                    support_count += 1\n    return float(support_count)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of isolated pawns for each side.\"\n    isolated_pawns_white = sum(1 for square in board.piece_map() if board.piece_map()[square].color == chess.WHITE and board.piece_map()[square].piece_type == chess.PAWN and (board.piece_at(chess.square_file(square) - 1) is None and board.piece_at(chess.square_file(square) + 1) is None))\n    isolated_pawns_black = sum(1 for square in board.piece_map() if board.piece_map()[square].color == chess.BLACK and board.piece_map()[square].piece_type == chess.PAWN and (board.piece_at(chess.square_file(square) - 1) is None and board.piece_at(chess.square_file(square) + 1) is None))\n    return float(isolated_pawns_white - isolated_pawns_black)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of double attacks (where a single piece attacks two opponent pieces).\"\n    double_attacks = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == chess.WHITE:\n            for move in board.legal_moves:\n                if move.from_square == square:\n                    attacked_pieces = [board.piece_at(move.to_square) for move in board.legal_moves if board.is_attacked_by(chess.BLACK, move.to_square)]\n                    if len(attacked_pieces) > 1:\n                        double_attacks += 1\n    return float(double_attacks)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates central pawn control by checking pawns in the center squares.\"\n    center_squares = {chess.E4, chess.E5, chess.D4, chess.D5}\n    white_center_control = sum(1 for square in center_squares if board.piece_at(square) and board.piece_at(square).color == chess.WHITE)\n    black_center_control = sum(1 for square in center_squares if board.piece_at(square) and board.piece_at(square).color == chess.BLACK)\n    return float(white_center_control - black_center_control)\n\n",
    "def feature(board: chess.Board) -> float:\n    'Counts the total number of squares attacked by each player\u2019s knights, indicating knight activity.'\n    knight_attack_squares_white = sum(1 for square, piece in board.piece_map().items() if piece.color == chess.WHITE and piece.piece_type == chess.KNIGHT and board.is_attacked_by(chess.BLACK, square))\n    knight_attack_squares_black = sum(1 for square, piece in board.piece_map().items() if piece.color == chess.BLACK and piece.piece_type == chess.KNIGHT and board.is_attacked_by(chess.WHITE, square))\n    return float(knight_attack_squares_white - knight_attack_squares_black)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the average distance of pieces from their starting position.\"\n    initial_positions = {\n        chess.WHITE: {chess.A2: 0, chess.B2: 0, chess.C2: 0, chess.D2: 0, chess.E2: 0, chess.F2: 0, chess.G2: 0, chess.H2: 0,\n                      chess.A1: 0, chess.B1: 0, chess.C1: 0, chess.D1: 0, chess.E1: 0, chess.F1: 0, chess.G1: 0, chess.H1: 0},\n        chess.BLACK: {chess.A7: 0, chess.B7: 0, chess.C7: 0, chess.D7: 0, chess.E7: 0, chess.F7: 0, chess.G7: 0, chess.H7: 0,\n                      chess.A8: 0, chess.B8: 0, chess.C8: 0, chess.D8: 0, chess.E8: 0, chess.F8: 0, chess.G8: 0, chess.H8: 0}\n    }\n    distance = 0\n    total_pieces = 0\n    for square, piece in board.piece_map().items():\n        if piece.color in initial_positions:\n            distance += chess.square_distance(square, next(iter(initial_positions[piece.color].keys())))\n            total_pieces += 1\n    return float(distance / total_pieces) if total_pieces > 0 else 0.0\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the total count of potential passed pawns for both players.\"\n    white_passed_pawns = 0\n    black_passed_pawns = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == chess.WHITE and piece.piece_type == chess.PAWN:\n            if not any(board.is_attacked_by(chess.BLACK, chess.parse_square(chess.square_name(file + 8))) for file in range(chess.square_file(square) - 1, chess.square_file(square) + 2)):\n                white_passed_pawns += 1\n        elif piece.color == chess.BLACK and piece.piece_type == chess.PAWN:\n            if not any(board.is_attacked_by(chess.WHITE, chess.parse_square(chess.square_name(file + 8))) for file in range(chess.square_file(square) - 1, chess.square_file(square) + 2)):\n                black_passed_pawns += 1\n    return float(white_passed_pawns - black_passed_pawns)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures how many squares each side's pieces control.\"\n    def controlled_squares(color):\n        controlled = set()\n        for move in board.legal_moves:\n            controlled.add(move.to_square)\n        return len(controlled)\n\n    white_controlled = controlled_squares(chess.WHITE)\n    black_controlled = controlled_squares(chess.BLACK)\n    return float(white_controlled - black_controlled)\n",
    "def feature(board: chess.Board) -> float:\n    \"Evaluates the number of pieces in play for each side.\"\n    white_piece_count = len([piece for piece in board.piece_map().values() if piece.color == chess.WHITE])\n    black_piece_count = len([piece for piece in board.piece_map().values() if piece.color == chess.BLACK])\n    return float(white_piece_count - black_piece_count)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Count the number of isolated pawns for each player.\"\n    isolated_pawns = 0\n    for square in board.piece_map():\n        piece = board.piece_at(square)\n        if piece is not None and piece.piece_type == chess.PAWN:\n            file_index = chess.square_file(square)\n            if (file_index > 0 and not board.piece_at(chess.parse_square(chess.square_name(square)[:-1] + chr(ord(chess.square_name(square)[-1]) - 1))) or\n                file_index < 7 and not board.piece_at(chess.parse_square(chess.square_name(square)[:-1] + chr(ord(chess.square_name(square)[-1]) + 1)))):\n                isolated_pawns += 1\n    return float(isolated_pawns)\n\n",
    "def feature(board: chess.Board) -> float:\n    'Calculates the total material value of all pieces on the board, weighted more for pieces in opponent half.'\n    material_score = 0.0\n    for square, piece in board.piece_map().items():\n        value = 1 if piece.piece_type == chess.PAWN else 3 if piece.piece_type in [chess.KNIGHT, chess.BISHOP] else 5 if piece.piece_type == chess.ROOK else 9 if piece.piece_type == chess.QUEEN else 0\n        if (piece.color == chess.WHITE and chess.square_rank(square) > 4) or (piece.color == chess.BLACK and chess.square_rank(square) < 4):\n            value *= 1.2\n        material_score += value if piece.color == chess.WHITE else -value\n    return material_score\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Determines the position of kings relative to pawns on the board.\"\n    white_king_pos = next(square for square, piece in board.piece_map().items() if piece.color == chess.WHITE and piece.piece_type == chess.KING)\n    black_king_pos = next(square for square, piece in board.piece_map().items() if piece.color == chess.BLACK and piece.piece_type == chess.KING)\n    white_pawns = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE and piece.piece_type == chess.PAWN)\n    black_pawns = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK and piece.piece_type == chess.PAWN)\n    return float(chess.square_distance(white_king_pos, black_king_pos) - (white_pawns - black_pawns))\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the number of available checks for both players.\"\n    white_checks = sum(1 for move in board.legal_moves if board.is_check())\n    board.turn = chess.BLACK  # Switch turn to count black checks\n    black_checks = sum(1 for move in board.legal_moves if board.is_check())\n    board.turn = chess.WHITE  # Reset turn\n    return float(white_checks - black_checks)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the disparity in control over center squares (d4, e4 for White; d5, e5 for Black).\"\n    center_squares = [chess.square(3, 3), chess.square(4, 3), chess.square(3, 4), chess.square(4, 4)]\n    white_control = sum(1 for square in center_squares if board.is_attacked_by(chess.WHITE, square))\n    black_control = sum(1 for square in center_squares if board.is_attacked_by(chess.BLACK, square))\n    return float(white_control - black_control)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the number of weak squares controlled by each player.\"\n    def count_weak_squares(color):\n        weak_squares = 0\n        enemy_color = chess.BLACK if color == chess.WHITE else chess.WHITE\n        for square in chess.SQUARES:\n            if board.is_attacked_by(enemy_color, square):\n                # Check if the square is unprotected\n                if not board.attackers(color, square):\n                    weak_squares += 1\n        return weak_squares\n\n    white_weak = count_weak_squares(chess.WHITE)\n    black_weak = count_weak_squares(chess.BLACK)\n    return float(white_weak - black_weak)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces that can move to a central square (d4, d5, e4, e5).\"\n    central_squares = [chess.parse_square('d4'), chess.parse_square('d5'), chess.parse_square('e4'), chess.parse_square('e5')]\n    control_count = sum(1 for piece in board.piece_map().values() if piece.color == board.turn and any(board.is_attacked_by(board.turn, sq) for sq in central_squares))\n    result = float(control_count)\n    return result\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of pins affecting pieces of both sides.\"\n    pin_count = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == board.turn:\n            for attacker in board.attackers(not board.turn, square):\n                if board.piece_at(attacker).piece_type == chess.ROOK or board.piece_at(attacker).piece_type == chess.QUEEN:\n                    for target in board.attackers(board.turn, square):\n                        if board.piece_at(target) is not None and board.piece_at(target).piece_type == chess.KING:\n                            pin_count += 1\n    return float(pin_count)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the number of pieces on the 7th rank for each side.\"\n    white_pieces_on_seventh = sum(1 for square in board.piece_map() if board.piece_map()[square].color == chess.WHITE and chess.square_rank(square) == 6)\n    black_pieces_on_seventh = sum(1 for square in board.piece_map() if board.piece_map()[square].color == chess.BLACK and chess.square_rank(square) == 1)\n    return float(white_pieces_on_seventh - black_pieces_on_seventh)\n\n",
    "def feature(board: chess.Board) -> float:\n    'Measures the average distance of pawns to the promotion rank.'\n    total_distance = 0\n    pawn_count = 0\n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.PAWN:\n            pawn_count += 1\n            total_distance += (7 - chess.square_rank(square))  # Distance to promotion rank (rank 8)\n    return total_distance / pawn_count if pawn_count > 0 else 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Evaluates the control of the center by counting the number of pieces controlling central squares.\"\n    central_squares = [chess.E4, chess.E5, chess.D4, chess.D5]\n    white_control = sum(1 for square in central_squares if board.is_attacked_by(chess.WHITE, square))\n    black_control = sum(1 for square in central_squares if board.is_attacked_by(chess.BLACK, square))\n    return float(white_control - black_control)\n\n",
    "def feature(board: chess.Board) -> float:\n    'Calculates the effect of pawn structure; number of isolated pawns for each side.'\n    def count_isolated_pawns(color):\n        return sum(1 for file in range(8) if board.piece_at(chess.square(file, 1 if color == chess.WHITE else 6)) == chess.PAWN and (file == 0 or not board.piece_at(chess.square(file - 1, 1 if color == chess.WHITE else 6)) == chess.PAWN) and (file == 7 or not board.piece_at(chess.square(file + 1, 1 if color == chess.WHITE else 6)) == chess.PAWN))\n    white_isolated_pawns = count_isolated_pawns(chess.WHITE)\n    black_isolated_pawns = count_isolated_pawns(chess.BLACK)\n    return float(white_isolated_pawns - black_isolated_pawns)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in pawn structure between players based on isolated and doubled pawns.\"\n    def pawn_structure_score(color):\n        return -sum(1 for square in board.piece_map() if board.piece_map()[square].color == color and (board.is_attacked_by(not color, square) or (board.piece_map()[square].piece_type == chess.PAWN and (board.piece_at(square + 1) == board.piece_at(square - 1) == None))))\n    \n    white_score = pawn_structure_score(chess.WHITE)\n    black_score = pawn_structure_score(chess.BLACK)\n    return float(white_score - black_score)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of squares attacked by each side's pieces.\"\n    def attacked_squares_count(color):\n        attacked_count = sum(1 for square in board.piece_map() if board.is_attacked_by(color, square))\n        return attacked_count\n    \n    white_attacked = attacked_squares_count(chess.WHITE)\n    black_attacked = attacked_squares_count(chess.BLACK)\n    return float(white_attacked - black_attacked)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the number of squares the opponent's king can escape to when in check.\"\n    if board.is_check():\n        king_square = next(square for square, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color == (chess.WHITE if board.turn else chess.BLACK))\n        escape_squares = sum(1 for move in board.legal_moves if board.piece_at(move.to_square) is None and move.to_square != king_square)\n        return float(escape_squares)\n    return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the difference in mobility between both sides.\"\n    white_mobility = len(list(board.legal_moves)) if board.turn else 0\n    board.push(chess.Move.null())  # Simulate opponent's turn\n    black_mobility = len(list(board.legal_moves)) if not board.turn else 0\n    board.pop()  # Undo the null move\n    return float(white_mobility - black_mobility)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the difference in the number of active pieces (pieces with legal moves) for both sides.\"\n    def active_piece_count(color):\n        return sum(1 for square in board.piece_map().keys() if board.piece_map()[square].color == color and len(list(board.legal_moves)) > 0)\n\n    white_active = active_piece_count(chess.WHITE)\n    black_active = active_piece_count(chess.BLACK)\n    return float(white_active - black_active)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the total number of developed pieces for each side.\"\n    def developed_pieces(color):\n        return sum(1 for square in board.piece_map() if board.piece_map()[square].color == color and chess.square_rank(square) > 1)\n    \n    white_development = developed_pieces(chess.WHITE)\n    black_development = developed_pieces(chess.BLACK)\n    return float(white_development - black_development)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the imbalance of material by counting excess pieces beyond the basic pawns.\"\n    material_values = {\n        chess.PAWN: 1,\n        chess.KNIGHT: 3,\n        chess.BISHOP: 3,\n        chess.ROOK: 5,\n        chess.QUEEN: 9,\n        chess.KING: 0\n    }\n    excess_white_material = sum(material_values[piece.piece_type] for piece in board.piece_map().values() \n                                  if piece.color == chess.WHITE and material_values[piece.piece_type] > 1) - \\\n                            sum(material_values[piece.piece_type] for piece in board.piece_map().values() \n                                  if piece.color == chess.BLACK and material_values[piece.piece_type] > 1)\n    return float(excess_white_material)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Evaluates the number of pieces of each type on the board.\"\n    piece_count = {chess.PAWN: 0, chess.KNIGHT: 0, chess.BISHOP: 0, chess.ROOK: 0, chess.QUEEN: 0, chess.KING: 0}\n    for piece in board.piece_map().values():\n        piece_count[piece.piece_type] += 1\n    return float(piece_count[chess.QUEEN] * 9 + piece_count[chess.ROOK] * 5 + \n                 piece_count[chess.BISHOP] * 3 + piece_count[chess.KNIGHT] * 3 + \n                 piece_count[chess.PAWN] * 1)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the material advantage controlled by rooks on open files for each side.\"\n    open_files = [file for file in range(8) if all(board.piece_at(chess.square(file, rank)) is None for rank in range(8))]\n    white_rooks_on_open_files = sum(1 for square in board.piece_map() if square in [chess.square(file, rank) for file in open_files for rank in range(8)] and board.piece_map()[square].color == chess.WHITE and board.piece_map()[square].piece_type == chess.ROOK)\n    black_rooks_on_open_files = sum(1 for square in board.piece_map() if square in [chess.square(file, rank) for file in open_files for rank in range(8)] and board.piece_map()[square].color == chess.BLACK and board.piece_map()[square].piece_type == chess.ROOK)\n    return float(white_rooks_on_open_files - black_rooks_on_open_files)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the material advantage of the pieces on the board.\"\n    material_values = {\n        chess.PAWN: 1,\n        chess.KNIGHT: 3,\n        chess.BISHOP: 3,\n        chess.ROOK: 5,\n        chess.QUEEN: 9,\n        chess.KING: 0\n    }\n    white_material = sum(material_values[piece.piece_type] for piece in board.piece_map().values() if piece.color == chess.WHITE)\n    black_material = sum(material_values[piece.piece_type] for piece in board.piece_map().values() if piece.color == chess.BLACK)\n    return float(white_material - black_material)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the average distance of pieces from the center of the board.\"\n    total_distance = 0\n    piece_count = 0\n    for sq in board.piece_map():\n        piece_count += 1\n        total_distance += chess.square_distance(sq, chess.parse_square('e4'))  # Center square\n    return total_distance / piece_count if piece_count > 0 else 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the total number of available checks for both players.\"\n    checks_available = sum(1 for move in board.legal_moves if board.gives_check(move))\n    return float(checks_available)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the ratio of minor pieces (knights and bishops) to major pieces (rooks and queens) for each side.\"\n    minor_pieces_white = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE and piece.piece_type in {chess.KNIGHT, chess.BISHOP})\n    major_pieces_white = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE and piece.piece_type in {chess.ROOK, chess.QUEEN})\n    minor_pieces_black = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK and piece.piece_type in {chess.KNIGHT, chess.BISHOP})\n    major_pieces_black = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK and piece.piece_type in {chess.ROOK, chess.QUEEN})\n    \n    white_ratio = minor_pieces_white / (major_pieces_white + 1e-10)\n    black_ratio = minor_pieces_black / (major_pieces_black + 1e-10)\n    \n    return float(white_ratio - black_ratio)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the number of pieces supported by pawns for each color.\"\n    def supported_pieces_count(color):\n        count = 0\n        for square, piece in board.piece_map().items():\n            if piece.color == color:\n                if piece.piece_type != chess.PAWN:\n                    file = chess.square_file(square)\n                    rank = chess.square_rank(square)\n                    if (board.piece_at(chess.square(file, rank - 1)) and board.piece_at(chess.square(file, rank - 1)).color == color) or \\\n                       (board.piece_at(chess.square(file - 1, rank - 1)) and board.piece_at(chess.square(file - 1, rank - 1)).color == color) or \\\n                       (board.piece_at(chess.square(file + 1, rank - 1)) and board.piece_at(chess.square(file + 1, rank - 1)).color == color):\n                        count += 1\n        return count\n\n    white_supported = supported_pieces_count(chess.WHITE)\n    black_supported = supported_pieces_count(chess.BLACK)\n    return float(white_supported - black_supported)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the total number of pieces that are pinned.\"\n    pinned_pieces = 0\n    for square, piece in board.piece_map().items():\n        if board.is_attacked_by(not piece.color, square):\n            attackers = board.attackers(not piece.color, square)\n            for attacker in attackers:\n                if board.is_attacked_by(piece.color, attacker):\n                    pinned_pieces += 1\n                    break\n    return float(pinned_pieces)\n\n",
    "def feature(board: chess.Board) -> float:\n    'Calculates the number of undefended pieces for both sides.'\n    def undefended_pieces(color):\n        return sum(1 for square in board.piece_map() if (board.piece_map()[square].color == color and \n            len(board.attackers(not color, square)) == 0))\n\n    white_undefended = undefended_pieces(chess.WHITE)\n    black_undefended = undefended_pieces(chess.BLACK)\n    return float(white_undefended - black_undefended)\n",
    "def feature(board: chess.Board) -> float:\n    'Counts the number of squares where pieces are expected to develop in the opening phase.'\n    development_squares = 0\n    for square in board.piece_map():\n        piece = board.piece_at(square)\n        if piece.color == chess.WHITE and piece.piece_type in [chess.KNIGHT, chess.BISHOP]:\n            if chess.square_rank(square) == 0:\n                development_squares += 1\n        elif piece.color == chess.BLACK and piece.piece_type in [chess.KNIGHT, chess.BISHOP]:\n            if chess.square_rank(square) == 7:\n                development_squares += 1\n    return float(development_squares)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the safety of each player's king by counting the number of defenders.\"\n    def count_defenders(king_square, color):\n        return sum(1 for square in chess.SQUARES if board.is_attacked_by(color, king_square) and\n                   board.piece_at(square) and board.piece_at(square).color == color)\n\n    white_king_square = next(square for square, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color == chess.WHITE)\n    black_king_square = next(square for square, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color == chess.BLACK)\n    \n    return float(count_defenders(white_king_square, chess.WHITE) - count_defenders(black_king_square, chess.BLACK))\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the total piece value for both sides and returns the difference.\"\n    piece_value = {chess.PAWN: 1, chess.KNIGHT: 3, chess.BISHOP: 3, chess.ROOK: 5, chess.QUEEN: 9, chess.KING: 0}\n    white_value = sum(piece_value[piece.piece_type] for piece in board.piece_map().values() if piece.color == chess.WHITE)\n    black_value = sum(piece_value[piece.piece_type] for piece in board.piece_map().values() if piece.color == chess.BLACK)\n    return float(white_value - black_value)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the control of key central squares (d4, e4, d5, e5) for both sides.\"\n    center_squares = [chess.D4, chess.E4, chess.D5, chess.E5]\n    white_control = sum(1 for square in center_squares if board.is_attacked_by(chess.WHITE, square))\n    black_control = sum(1 for square in center_squares if board.is_attacked_by(chess.BLACK, square))\n    return float(white_control - black_control)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the piece activity based on the number of pieces that can move to squares under attack.\"\n    activity_score = sum(1 for piece_square in board.piece_map() if any(board.is_attacked_by(board.turn, move.to_square) for move in board.legal_moves if move.from_square == piece_square))\n    return float(activity_score)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the total number of pieces pinned by the opposing side.\"\n    pinned_count = 0\n    for square in board.piece_map():\n        piece = board.piece_map()[square]\n        if board.is_attacked_by(not piece.color, square) and (piece.piece_type == chess.QUEEN or piece.piece_type == chess.ROOK):\n            pinned_count += 1\n    return float(pinned_count)\n\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the number of pieces on the opponent's side of the board.\"\n    opponent_half = range(0, 4) if board.turn else range(4, 8)\n    pieces_on_opponent_side = sum(1 for square, piece in board.piece_map().items() if piece.color == board.turn and chess.square_file(square) in opponent_half)\n    return float(pieces_on_opponent_side)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the number of squares controlled by each player, emphasizing spatial control.\"\n    white_control = sum(1 for sq in range(64) if board.is_attacked_by(chess.WHITE, sq))\n    black_control = sum(1 for sq in range(64) if board.is_attacked_by(chess.BLACK, sq))\n    return float(white_control - black_control)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in the number of reserves available for promotion.\"\n    def count_pawns(color):\n        return sum(1 for square in board.piece_map() if board.piece_map()[square].color == color and board.piece_map()[square].piece_type == chess.PAWN)\n\n    white_pawns = count_pawns(chess.WHITE)\n    black_pawns = count_pawns(chess.BLACK)\n    return float(white_pawns - black_pawns)\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the piece value of all pieces that are currently being attacked.\"\n    attacking_value = sum(piece.piece_type for sq, piece in board.piece_map().items() if board.is_attacked_by(chess.BLACK, sq)) \\\n                      - sum(piece.piece_type for sq, piece in board.piece_map().items() if board.is_attacked_by(chess.WHITE, sq))\n    return float(attacking_value)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of hanging pieces for the current player.\"\n    hanging_pieces = sum(1 for square, piece in board.piece_map().items() if piece.color == board.turn and board.is_attacked_by(not board.turn, square))\n    return float(hanging_pieces)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in material value of major pieces (rooks and queens) for each side.\"\n    material_values = {\n        chess.ROOK: 5,\n        chess.QUEEN: 9\n    }\n    def calculate_major_material(color):\n        return sum(material_values.get(piece.piece_type, 0) for piece in board.piece_map().values() if piece.color == color)\n    \n    white_major_material = calculate_major_material(chess.WHITE)\n    black_major_material = calculate_major_material(chess.BLACK)\n    return float(white_major_material - black_major_material)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the number of pieces attacking the opponent's king.\"\n    opponent_king_square = next(square for square, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color != board.turn)\n    attacking_count = len(board.attackers(board.turn, opponent_king_square))\n    return float(attacking_count)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the number of legal moves available for the current player.\"\n    return float(len(list(board.legal_moves)))\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the total absolute value of pieces for both players.\"\n    piece_values = {chess.PAWN: 1, chess.KNIGHT: 3, chess.BISHOP: 3, chess.ROOK: 5, chess.QUEEN: 9, chess.KING: 0}\n    total_value = sum(piece_values[piece.piece_type] for piece in board.piece_map().values())\n    return float(total_value)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in the number of pieces that are pinned against the opponent's king.\"\n    white_pinned = sum(1 for square in board.piece_map() if board.piece_map()[square].color == chess.WHITE and board.is_attacked_by(chess.BLACK, square))\n    black_pinned = sum(1 for square in board.piece_map() if board.piece_map()[square].color == chess.BLACK and board.is_attacked_by(chess.WHITE, square))\n    return float(white_pinned - black_pinned)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of squares that are defended by more than one piece for the player to move.\"\n    defended_squares = {}\n    for square, piece in board.piece_map().items():\n        if piece.color == board.turn:\n            for attacked_square in board.attackers(not board.turn, square):\n                if attacked_square not in defended_squares:\n                    defended_squares[attacked_square] = 0\n                defended_squares[attacked_square] += 1\n\n    multi_defended_count = sum(1 for count in defended_squares.values() if count > 1)\n    return float(multi_defended_count)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the material advantage considering the piece positioning.\"\n    material_values = {\n        chess.PAWN: 1,\n        chess.KNIGHT: 3,\n        chess.BISHOP: 3,\n        chess.ROOK: 5,\n        chess.QUEEN: 9,\n        chess.KING: 0\n    }\n    positional_advantage = sum(material_values[piece.piece_type] for square, piece in board.piece_map().items() if piece.color == board.turn) - sum(material_values[piece.piece_type] for square, piece in board.piece_map().items() if piece.color != board.turn)\n    \n    return float(positional_advantage)\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the number of tempo moves available for each player.\"\n    white_tempo_moves = sum(1 for move in board.legal_moves if board.turn is True)\n    black_tempo_moves = sum(1 for move in board.legal_moves if board.turn is False)\n    return float(white_tempo_moves - black_tempo_moves)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the total number of threats posed by pieces on the board.\"\n    total_threats = sum(len(board.attackers(not piece.color, square)) for square, piece in board.piece_map().items())\n    return float(total_threats)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the mobility of the current player's pieces by counting reevaluated legal move scores.\"\n    mobility_score = 0\n    for move in board.legal_moves:\n        board.push(move)\n        mobility_score += len(list(board.legal_moves))\n        board.pop()\n    return float(mobility_score)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the total number of pieces that are currently pinned by the opponent.\"\n    pinned_count = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == board.turn:\n            for target in board.legal_moves:\n                if board.is_attacked_by(not board.turn, target.to_square):\n                    pinned_count += 1\n                    break\n    return float(pinned_count)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the number of pieces attacking the opponent's king for both sides.\"\n    white_king_attackers = len(board.attackers(chess.BLACK, chess.parse_square('e8')))\n    black_king_attackers = len(board.attackers(chess.WHITE, chess.parse_square('e1')))\n    return float(white_king_attackers - black_king_attackers)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the total value of pieces for both players, distinguishing material strengths.\"\n    total_material = 0\n    piece_values = {chess.PAWN: 1, chess.KNIGHT: 3, chess.BISHOP: 3, chess.ROOK: 5, chess.QUEEN: 9, chess.KING: 0}\n    \n    for piece in board.piece_map().values():\n        total_material += piece_values[piece.piece_type] if piece.color == chess.WHITE else -piece_values[piece.piece_type]\n    \n    return float(total_material)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the potential for attacking the opponent's king by counting direct attacks.\"\n    opponent_color = chess.BLACK if board.turn else chess.WHITE\n    king_square = next((square for square in board.piece_map() if board.piece_map()[square].color == opponent_color and board.piece_map()[square].piece_type == chess.KING), None)\n    if king_square is None:\n        return 0.0\n    attack_count = sum(1 for square in board.piece_map() if board.piece_map()[square].color == board.turn and board.is_attacked_by(opponent_color, square))\n    return float(attack_count)\n\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the number of pieces that are pinning the opponent's pieces.\"\n    white_pins = sum(1 for square in board.piece_map() if board.piece_map()[square].color == chess.WHITE and \n                     any(board.is_attacked_by(chess.BLACK, square) for _ in board.legal_moves if board.is_check() and board.piece_at(square).piece_type != chess.KING))\n    \n    black_pins = sum(1 for square in board.piece_map() if board.piece_map()[square].color == chess.BLACK and \n                     any(board.is_attacked_by(chess.WHITE, square) for _ in board.legal_moves if board.is_check() and board.piece_at(square).piece_type != chess.KING))\n    \n    return float(white_pins - black_pins)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the balance of bishops with respect to their positioning (active vs passive).\"\n    def bishop_activity(color):\n        activity = 0\n        for square, piece in board.piece_map().items():\n            if piece.color == color and piece.piece_type == chess.BISHOP:\n                if chess.square_file(square) in [2, 5] and chess.square_rank(square) in [2, 5]:  # Active centers\n                    activity += 2\n                if chess.square_file(square) in [1, 6] and chess.square_rank(square) in [1, 6]:  # Passive positions\n                    activity -= 1\n        return activity\n\n    return float(bishop_activity(chess.WHITE) - bishop_activity(chess.BLACK))\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in king safety based on the distance of kings from the center.\"\n    white_king_square = next(square for square in board.piece_map() if board.piece_map()[square].color == chess.WHITE and board.piece_map()[square].piece_type == chess.KING)\n    black_king_square = next(square for square in board.piece_map() if board.piece_map()[square].color == chess.BLACK and board.piece_map()[square].piece_type == chess.KING)\n    white_distance = chess.square_distance(white_king_square, chess.E4) + chess.square_distance(white_king_square, chess.D4)\n    black_distance = chess.square_distance(black_king_square, chess.E4) + chess.square_distance(black_king_square, chess.D4)\n    return float(black_distance - white_distance)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the total number of pieces on each side's third rank, indicating potential advancement.\"\n    white_third_rank = sum(1 for square in board.piece_map() if board.piece_at(square).color == chess.WHITE and chess.square_rank(square) == 2)\n    black_third_rank = sum(1 for square in board.piece_map() if board.piece_at(square).color == chess.BLACK and chess.square_rank(square) == 5)\n    result = float(white_third_rank - black_third_rank)\n    return result\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the central control of pieces (e4, e5, d4, d5 squares).\"\n    center_squares = [chess.E4, chess.E5, chess.D4, chess.D5]\n    white_center_control = sum(1 for square in center_squares if board.is_attacked_by(chess.WHITE, square))\n    black_center_control = sum(1 for square in center_squares if board.is_attacked_by(chess.BLACK, square))\n    return float(white_center_control - black_center_control)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in the number of rooks on the 7th rank for both sides.\"\n    white_rooks_on_seventh = sum(1 for sq in board.piece_map() if board.piece_map()[sq].color == chess.WHITE and \n                                  board.piece_map()[sq].piece_type == chess.ROOK and chess.square_rank(sq) == 6)\n    black_rooks_on_seventh = sum(1 for sq in board.piece_map() if board.piece_map()[sq].color == chess.BLACK and \n                                  board.piece_map()[sq].piece_type == chess.ROOK and chess.square_rank(sq) == 6)\n    return float(white_rooks_on_seventh - black_rooks_on_seventh)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the difference in the number of doubled pawns each side has.\"\n    def count_doubled_pawns(color):\n        pawn_files = [0] * 8\n        for square in board.piece_map():\n            piece = board.piece_map()[square]\n            if piece.color == color and piece.piece_type == chess.PAWN:\n                pawn_files[chess.square_file(square)] += 1\n        return sum(max(0, count - 1) for count in pawn_files)\n\n    white_doubled = count_doubled_pawns(chess.WHITE)\n    black_doubled = count_doubled_pawns(chess.BLACK)\n    return float(white_doubled - black_doubled)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the number of potential outposts for knights in the opponent's territory.\"\n    knight_outpost_squares = [\n        chess.E5, chess.D5, chess.C6,\n        chess.E4, chess.D4, chess.C3,\n        chess.B3\n    ]\n    outpost_count = sum(1 for square in knight_outpost_squares if board.is_attacked_by(board.turn, square))\n    return float(outpost_count)\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of squares attacked by each color.\"\n    white_attacked = sum(board.is_attacked_by(chess.WHITE, square) for square in chess.SQUARES)\n    black_attacked = sum(board.is_attacked_by(chess.BLACK, square) for square in chess.SQUARES)\n    return float(white_attacked - black_attacked)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Determines the balance of piece types in terms of value and positional strength.\"\n    piece_values = {chess.PAWN: 1, chess.KNIGHT: 3, chess.BISHOP: 3.5, chess.ROOK: 5, chess.QUEEN: 9}\n    white_value = sum(piece_values.get(board.piece_map()[sq].piece_type, 0) for sq in board.piece_map() if board.piece_map()[sq].color == chess.WHITE)\n    black_value = sum(piece_values.get(board.piece_map()[sq].piece_type, 0) for sq in board.piece_map() if board.piece_map()[sq].color == chess.BLACK)\n    return float(white_value - black_value)\n",
    "def feature(board: chess.Board) -> float:\n    \"Evaluates the balance of minor pieces by comparing the number of knights and bishops for each side.\"\n    white_knights = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE and piece.piece_type == chess.KNIGHT)\n    white_bishops = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE and piece.piece_type == chess.BISHOP)\n    black_knights = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK and piece.piece_type == chess.KNIGHT)\n    black_bishops = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK and piece.piece_type == chess.BISHOP)\n    return float((white_knights + white_bishops) - (black_knights + black_bishops))\n\n",
    "def feature(board: chess.Board) -> float:\n    'Measures the activity of rooks by counting their control over open files.'\n    open_files = sum(1 for file in range(8) if not any(board.piece_at(chess.square(file, rank)) for rank in range(8)))\n    return float(open_files)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the activity of the pieces by counting the number of legal moves available to each side.\"\n    white_legal_moves = len(list(board.legal_moves)) if board.turn else 0\n    board.push(chess.Move.null())  # Push a null move to simulate other side's turn\n    black_legal_moves = len(list(board.legal_moves)) if not board.turn else 0\n    board.pop()  # Undo the null move\n    return float(white_legal_moves - black_legal_moves)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces each player has attacking the opponent's king.\"\n    def attacking_king_count(color):\n        king_square = next(sq for sq in board.piece_map() if board.piece_map()[sq].color == color and board.piece_map()[sq].piece_type == chess.KING)\n        return sum(1 for sq in board.piece_map() if board.is_attacked_by(color, king_square))\n\n    white_attacks = attacking_king_count(chess.WHITE)\n    black_attacks = attacking_king_count(chess.BLACK)\n    return float(white_attacks - black_attacks)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Evaluates how many pieces are placed on the 3rd rank or higher for both sides.\"\n    active_pieces = sum(1 for square, piece in board.piece_map().items() if piece.color == board.turn and chess.square_rank(square) > 1)\n    return float(active_pieces)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the development advantage by counting pieces developed for each player.\"\n    developed_white = sum(1 for square in board.piece_map() if board.piece_map()[square].color == chess.WHITE and chess.square_rank(square) != 0)\n    developed_black = sum(1 for square in board.piece_map() if board.piece_map()[square].color == chess.BLACK and chess.square_rank(square) != 7)\n    return float(developed_white - developed_black)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the total value of active pieces for the current player.\"\n    piece_values = {chess.PAWN: 1, chess.KNIGHT: 3, chess.BISHOP: 3, chess.ROOK: 5, chess.QUEEN: 9, chess.KING: 0}\n    total_value = sum(piece_values[piece.piece_type] for piece in board.piece_map().values() if piece.color == board.turn)\n    return float(total_value)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the ratio of pawns' positions to their potential strength.\"\n    pawn_position_values = {chess.PAWN: 1}\n    white_pawn_strength = sum(pawn_position_values[piece.piece_type] * chess.square_rank(square) for square, piece in board.piece_map().items() if piece.color == chess.WHITE and piece.piece_type == chess.PAWN)\n    black_pawn_strength = sum(pawn_position_values[piece.piece_type] * (7 - chess.square_rank(square)) for square, piece in board.piece_map().items() if piece.color == chess.BLACK and piece.piece_type == chess.PAWN)\n    total_strength = white_pawn_strength + black_pawn_strength\n    return float((white_pawn_strength / total_strength) - (black_pawn_strength / total_strength) if total_strength > 0 else 0.0)\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the difference in control of key squares (center and opponent's back rank).\"\n    key_squares = [chess.D4, chess.D5, chess.E4, chess.E5] + [chess.square(file, 0) for file in range(8)]\n    control = {chess.WHITE: 0, chess.BLACK: 0}\n    for square in key_squares:\n        if board.is_attacked_by(chess.WHITE, square):\n            control[chess.WHITE] += 1\n        if board.is_attacked_by(chess.BLACK, square):\n            control[chess.BLACK] += 1\n    return float(control[chess.WHITE] - control[chess.BLACK])\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the number of pawns on the 7th rank versus the 2nd rank.\"\n    white_pawns_on_7th = sum(1 for square in chess.SQUARES if board.piece_at(square) and board.piece_at(square).color == chess.WHITE and chess.square_rank(square) == 6)\n    black_pawns_on_2nd = sum(1 for square in chess.SQUARES if board.piece_at(square) and board.piece_at(square).color == chess.BLACK and chess.square_rank(square) == 1)\n    return float(white_pawns_on_7th - black_pawns_on_2nd)\n\n",
    "def feature(board: chess.Board) -> float:\n    'Calculates the distance of each player\u2019s king from its back rank, penalizing for being too far away.'\n    king_white_square = next(square for square, piece in board.piece_map().items() if piece.color == chess.WHITE and piece.piece_type == chess.KING)\n    king_black_square = next(square for square, piece in board.piece_map().items() if piece.color == chess.BLACK and piece.piece_type == chess.KING)\n    distance_to_back_rank_white = chess.square_rank(king_white_square)\n    distance_to_back_rank_black = 7 - chess.square_rank(king_black_square)\n    return float(distance_to_back_rank_white - distance_to_back_rank_black)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the total number of legal moves available to both sides.\"\n    white_moves = len(list(board.legal_moves))\n    black_moves = len(list(board.legal_moves))\n    return float(white_moves - black_moves)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the count of pieces on the opponent's side of the board.\"\n    white_pieces = sum(1 for square in range(32, 64) if board.piece_at(square) and board.piece_map()[square].color == chess.WHITE)\n    black_pieces = sum(1 for square in range(0, 32) if board.piece_at(square) and board.piece_map()[square].color == chess.BLACK)\n    return float(white_pieces - black_pieces)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the sum of the ranks occupied by each player's pieces.\"\n    white_sum_ranks = sum(chess.square_rank(square) for square, piece in board.piece_map().items() if piece.color == chess.WHITE)\n    black_sum_ranks = sum(chess.square_rank(square) for square, piece in board.piece_map().items() if piece.color == chess.BLACK)\n    return float(white_sum_ranks - black_sum_ranks)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in kings' safety based on the number of pawn shields.\"\n    white_shields = sum(1 for square in range(8) if board.piece_at(chess.square(square, 1)) and board.piece_at(chess.square(square, 1)).color == chess.WHITE)\n    black_shields = sum(1 for square in range(8) if board.piece_at(chess.square(square, 6)) and board.piece_at(chess.square(square, 6)).color == chess.BLACK)\n    return float(white_shields - black_shields)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in mobility for both sides based on legal moves.\"\n    white_mobility = len(list(board.legal_moves)) if board.turn else 0\n    black_mobility = len(list(board.legal_moves)) if not board.turn else 0\n    return float(white_mobility - black_mobility)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the number of potential checks each side can deliver on the next turn.\"\n    potential_checks = 0\n    for move in board.legal_moves:\n        board.push(move)\n        if board.is_check():\n            potential_checks += 1\n        board.pop()\n    return float(potential_checks)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the disparity in development by comparing the number of developed pieces.\"\n    developed_pieces_white = sum(1 for sq in board.piece_map() if board.piece_map()[sq].color == chess.WHITE and (chess.square_rank(sq) >= 5))\n    developed_pieces_black = sum(1 for sq in board.piece_map() if board.piece_map()[sq].color == chess.BLACK and (chess.square_rank(sq) <= 2))\n    result = developed_pieces_white - developed_pieces_black\n    return float(result)\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the number of squares controlled by pieces of each player.\"\n    def controlled_squares(color):\n        controlled = set()\n        for square, piece in board.piece_map().items():\n            if piece.color == color:\n                controlled.update(board.attackers(color, square))\n        return len(controlled)\n    \n    white_controlled = controlled_squares(chess.WHITE)\n    black_controlled = controlled_squares(chess.BLACK)\n    return float(white_controlled - black_controlled)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the total material value of pawns for each color.\"\n    white_pawn_value = len([p for p in board.piece_map().values() if p.color == chess.WHITE and p.piece_type == chess.PAWN]) * 1\n    black_pawn_value = len([p for p in board.piece_map().values() if p.color == chess.BLACK and p.piece_type == chess.PAWN]) * 1\n    return float(white_pawn_value - black_pawn_value)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the safety of the King for both sides by counting the number of pieces defending it.\"\n    white_king_sq = board.king(chess.WHITE)\n    black_king_sq = board.king(chess.BLACK)\n    white_defense = len(board.attackers(chess.WHITE, white_king_sq))\n    black_defense = len(board.attackers(chess.BLACK, black_king_sq))\n    return float(white_defense - black_defense)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the distance of each piece from the center of the board, promoting control.\"\n    center_squares = [chess.D4, chess.D5, chess.E4, chess.E5]\n    distance_sum = sum(chess.square_distance(square, center_square) for square in board.piece_map() for center_square in center_squares)\n    return float(distance_sum)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the activity score based on the number of pieces that can immediately attack the opponent's king.\"\n    white_king_square = next(square for square in board.piece_map() if board.piece_map()[square].color == chess.WHITE and board.piece_map()[square].piece_type == chess.KING)\n    black_king_square = next(square for square in board.piece_map() if board.piece_map()[square].color == chess.BLACK and board.piece_map()[square].piece_type == chess.KING)\n    \n    white_attacking_pieces = sum(1 for square in board.piece_map() if board.piece_map()[square].color == chess.WHITE and (board.is_attacked_by(chess.BLACK, square) and board.is_attacked_by(chess.BLACK, white_king_square)))\n    black_attacking_pieces = sum(1 for square in board.piece_map() if board.piece_map()[square].color == chess.BLACK and (board.is_attacked_by(chess.WHITE, square) and board.is_attacked_by(chess.WHITE, black_king_square)))\n    \n    return float(white_attacking_pieces - black_attacking_pieces)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in pawn advancement through the ranks.\"\n    white_pawn_advance = sum(1 for square in board.piece_map() if board.piece_map()[square].color == chess.WHITE and chess.square_rank(square) > 4)\n    black_pawn_advance = sum(1 for square in board.piece_map() if board.piece_map()[square].color == chess.BLACK and chess.square_rank(square) < 3)\n    return float(white_pawn_advance - black_pawn_advance)\n\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the number of squares controlled by each side's pawns.\"\n    def controlled_squares(color):\n        return sum(1 for square in range(64) if any(board.is_attacked_by(color, square) for pawn_square in board.piece_map() if board.piece_map()[pawn_square].color == color and \n                                                       board.piece_map()[pawn_square].piece_type == chess.PAWN))\n    \n    white_control = controlled_squares(chess.WHITE)\n    black_control = controlled_squares(chess.BLACK)\n    return float(white_control - black_control)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the tempo advantage based on the move order and unique moves played.\"\n    unique_moves = len(set(str(move) for move in board.legal_moves))\n    return float(unique_moves)\n",
    "def feature(board: chess.Board) -> float:\n    'Counts the number of doubled pawns for each side.'\n    def doubled_pawns(color):\n        files = set()\n        count = 0\n        for square, piece in board.piece_map().items():\n            if piece.color == color and piece.piece_type == chess.PAWN:\n                file = chess.square_file(square)\n                if file in files:\n                    count += 1\n                files.add(file)\n        return count\n\n    result = float(doubled_pawns(chess.WHITE) - doubled_pawns(chess.BLACK))\n    return result\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces attacking the opponent's major pieces (queen and rooks).\"\n    major_pieces = {chess.QUEEN, chess.ROOK}\n    attacks_count = sum(1 for square in board.piece_map() if board.piece_map()[square].color != board.turn and \n                        board.piece_map()[square].piece_type in major_pieces and \n                        any(board.is_attacked_by(board.turn, square) for attacker in board.attackers(board.turn, square)))\n    return float(attacks_count)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Evaluates king safety by counting the number of squares around it that are safe.\"\n    king_square = next((square for square, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color == board.turn), None)\n    if king_square is None:\n        return 0.0\n    safe_squares = sum(1 for dx in (-1, 0, 1) for dy in (-1, 0, 1) if (dx != 0 or dy != 0) and 0 <= chess.square_file(king_square) + dx < 8 and 0 <= chess.square_rank(king_square) + dy < 8 and not board.is_attacked_by(not board.turn, chess.square(chess.square_file(king_square) + dx, chess.square_rank(king_square) + dy)))\n    return float(safe_squares)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the number of pawns that are advanced to or beyond the fifth rank to assess pawn structure.\"\n    white_advanced_pawns = sum(1 for square in range(chess.A4, chess.H5) if board.piece_at(square) and board.piece_at(square).color == chess.WHITE and board.piece_at(square).piece_type == chess.PAWN)\n    black_advanced_pawns = sum(1 for square in range(chess.A4, chess.H5) if board.piece_at(square) and board.piece_at(square).color == chess.BLACK and board.piece_at(square).piece_type == chess.PAWN)\n    return float(white_advanced_pawns - black_advanced_pawns)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the influence on the center based on pawns and pieces attacking central squares.\"\n    central_squares = [chess.D4, chess.D5, chess.E4, chess.E5]\n    def center_influence(color):\n        return sum(1 for square in central_squares if board.is_attacked_by(color, square))\n    \n    white_influence = center_influence(chess.WHITE)\n    black_influence = center_influence(chess.BLACK)\n    return float(white_influence - black_influence)\n",
    "def feature(board: chess.Board) -> float:\n    'Counts the number of pawns reaching the 6th rank for white and the 3rd rank for black.'\n    white_pawn_rank = sum(1 for square in board.piece_map() if board.piece_map()[square].piece_type == chess.PAWN and chess.square_rank(square) == 5)\n    black_pawn_rank = sum(1 for square in board.piece_map() if board.piece_map()[square].piece_type == chess.PAWN and chess.square_rank(square) == 2)\n    return float(white_pawn_rank - black_pawn_rank)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the number of double pawns for each side.\"\n    white_double_pawns = sum(1 for square in board.piece_map() if board.piece_map()[square].color == chess.WHITE and\n                              len([1 for s in range(8) if board.piece_at(chess.square(s, chess.square_rank(square))) and \n                              board.piece_at(chess.square(s, chess.square_rank(square))).color == chess.WHITE]) > 1)\n    black_double_pawns = sum(1 for square in board.piece_map() if board.piece_map()[square].color == chess.BLACK and\n                              len([1 for s in range(8) if board.piece_at(chess.square(s, chess.square_rank(square))) and \n                              board.piece_at(chess.square(s, chess.square_rank(square))).color == chess.BLACK]) > 1)\n    return float(white_double_pawns - black_double_pawns)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Determines the number of pieces attacking the enemy king for each player, reflecting pressure on the king.\"\n    def count_attacks_king(color):\n        king_square = next(sq for sq, piece in board.piece_map().items() if piece.color == color and piece.piece_type == chess.KING)\n        return sum(1 for sq in board.piece_map() if board.is_attacked_by(color, king_square) and board.piece_at(sq).color != color)\n    \n    white_attack_count = count_attacks_king(chess.WHITE)\n    black_attack_count = count_attacks_king(chess.BLACK)\n    return float(white_attack_count - black_attack_count)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the distance of the kings from the center of the board.\"\n    white_king_square = next((square for square, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color == chess.WHITE), None)\n    black_king_square = next((square for square, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color == chess.BLACK), None)\n    if white_king_square and black_king_square:\n        white_distance = chess.square_distance(white_king_square, chess.E4) + chess.square_distance(white_king_square, chess.E5)\n        black_distance = chess.square_distance(black_king_square, chess.E4) + chess.square_distance(black_king_square, chess.E5)\n        return float(black_distance - white_distance)\n    return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the number of double pawns each side has.\"\n    white_double_pawns = sum(1 for file in range(8) if sum(1 for square in board.piece_map() if chess.square_file(square) == file and board.piece_map()[square].color == chess.WHITE and board.piece_map()[square].piece_type == chess.PAWN) > 1)\n    black_double_pawns = sum(1 for file in range(8) if sum(1 for square in board.piece_map() if chess.square_file(square) == file and board.piece_map()[square].color == chess.BLACK and board.piece_map()[square].piece_type == chess.PAWN) > 1)\n    return float(white_double_pawns - black_double_pawns)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the total value of all pieces in the central four squares.\"\n    central_squares = [chess.E4, chess.E5, chess.D4, chess.D5]\n    total_value = sum(board.piece_at(sq).piece_type for sq in central_squares if board.piece_at(sq) is not None)\n    return float(total_value)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the average distance of pieces from their opponent's back rank.\"\n    material_values = {\n        chess.PAWN: 1,\n        chess.KNIGHT: 3,\n        chess.BISHOP: 3,\n        chess.ROOK: 5,\n        chess.QUEEN: 9,\n        chess.KING: 0\n    }\n    distance_sum = 0\n    total_pieces = 0\n    for square in board.piece_map():\n        piece = board.piece_map()[square]\n        if piece.color == board.turn:\n            opponent_back_rank = 0 if piece.color == chess.WHITE else 7\n            distance_sum += chess.square_distance(square, chess.square(chess.square_file(square), opponent_back_rank))\n            total_pieces += 1\n    return float(distance_sum / total_pieces) if total_pieces > 0 else 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the total number of pieces in play, indicating dynamics in the position.\"\n    white_pieces = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE)\n    black_pieces = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK)\n    return float(white_pieces - black_pieces)\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces attacking the opponent's king.\"\n    opponent_king_square = next(square for square, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color != board.turn)\n    attacking_pieces = sum(1 for square, piece in board.piece_map().items() \n                           if piece.color == board.turn and square in board.attackers(not board.turn, opponent_king_square))\n    return float(attacking_pieces)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the number of pieces attacked by the opponent for each side.\"\n    attacks_white = sum(1 for square in board.piece_map() if board.piece_map()[square].color == chess.WHITE and board.is_attacked_by(chess.BLACK, square))\n    attacks_black = sum(1 for square in board.piece_map() if board.piece_map()[square].color == chess.BLACK and board.is_attacked_by(chess.WHITE, square))\n    return float(attacks_white - attacks_black)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the number of connected pawns for each side.\"\n    def connected_pawns(color):\n        count = 0\n        for square in board.piece_map():\n            if board.piece_map()[square].color == color and board.piece_map()[square].piece_type == chess.PAWN:\n                file = chess.square_file(square)\n                if (board.piece_at(chess.square(file - 1, chess.square_rank(square))) and \n                    board.piece_at(chess.square(file - 1, chess.square_rank(square))).color == color):\n                    count += 1\n                if (board.piece_at(chess.square(file + 1, chess.square_rank(square))) and \n                    board.piece_at(chess.square(file + 1, chess.square_rank(square))).color == color):\n                    count += 1\n        return count\n\n    white_connected = connected_pawns(chess.WHITE)\n    black_connected = connected_pawns(chess.BLACK)\n    return float(white_connected - black_connected)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the amount of control of key central squares.\"\n    central_squares = [chess.E4, chess.E5, chess.D4, chess.D5]\n    white_control = sum(1 for square in central_squares if board.is_attacked_by(chess.WHITE, square))\n    black_control = sum(1 for square in central_squares if board.is_attacked_by(chess.BLACK, square))\n    return float(white_control - black_control)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of squares available for the pieces of each side (mobility).\"\n    white_mobility = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE and len(list(board.legal_moves)) > 0)\n    black_mobility = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK and len(list(board.legal_moves)) > 0)\n    return float(white_mobility - black_mobility)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of squares controlled by each player's pieces.\"\n    white_control = sum(1 for square in chess.SQUARES if board.is_attacked_by(chess.WHITE, square))\n    black_control = sum(1 for square in chess.SQUARES if board.is_attacked_by(chess.BLACK, square))\n    return float(white_control - black_control)\n\n",
    "def feature(board: chess.Board) -> float:\n    'Measures mobility by counting the maximum number of possible moves for any single piece.'\n    max_moves = 0\n    for piece in board.piece_map().values():\n        if piece.color == board.turn:\n            piece_moves = len(list(board.legal_moves))  # Count all legal moves of that piece\n            if piece_moves > max_moves:\n                max_moves = piece_moves\n    result = float(max_moves)\n    return result\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of discovered attacks available for both players.\"\n    discovered_attacks = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == board.turn:\n            for move in board.legal_moves:\n                if move.from_square == square:\n                    new_board = board.copy()\n                    new_board.push(move)\n                    for target_square in chess.SQUARES:\n                        if new_board.is_attacked_by(not board.turn, target_square):\n                            discovered_attacks += 1\n    return float(discovered_attacks)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the ratio of pieces attacking versus pieces defending for both sides.\"\n    attacking_white = sum(1 for square in board.piece_map() if board.is_attacked_by(chess.BLACK, square))\n    defending_white = sum(1 for square in board.piece_map() if board.attackers(chess.WHITE, square))\n    attacking_black = sum(1 for square in board.piece_map() if board.is_attacked_by(chess.WHITE, square))\n    defending_black = sum(1 for square in board.piece_map() if board.attackers(chess.BLACK, square))\n    white_ratio = attacking_white / (defending_white + 1)  # Avoid division by zero\n    black_ratio = attacking_black / (defending_black + 1)  # Avoid division by zero\n    return float(white_ratio - black_ratio)\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the difference in active pieces (pieces moving towards the opponent's territory).\"\n    active_white = sum(1 for square, piece in board.piece_map().items() if piece.color == chess.WHITE and chess.square_rank(square) > 4)\n    active_black = sum(1 for square, piece in board.piece_map().items() if piece.color == chess.BLACK and chess.square_rank(square) < 3)\n    return float(active_white - active_black)\n\n",
    "def feature(board: chess.Board) -> float:\n    'Calculates the total mobility of knight pieces on the board.'\n    knight_mobility = sum(len(list(board.legal_moves)) for square in board.piece_map() if board.piece_map()[square].piece_type == chess.KNIGHT)\n    return float(knight_mobility)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the total distance of all rooks from their starting positions for each player.\"\n    def rook_distance(color):\n        return sum(chess.square_distance(square, chess.parse_square('a1' if color == chess.WHITE else 'a8')) for square in board.piece_map() if board.piece_map()[square].piece_type == chess.ROOK)\n    \n    white_distance = rook_distance(chess.WHITE)\n    black_distance = rook_distance(chess.BLACK)\n    return float(white_distance - black_distance)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Evaluates control over the center 4 squares of the board.\"\n    central_squares = [chess.E4, chess.E5, chess.D4, chess.D5]\n    center_control = 0\n    for square in central_squares:\n        if board.is_attacked_by(chess.WHITE, square):\n            center_control += 1\n        elif board.is_attacked_by(chess.BLACK, square):\n            center_control -= 1\n    return float(center_control)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the mobility of rooks by counting open files.\"\n    rook_mobility = 0\n    open_files = [f for f in range(8) if all(board.piece_at(chess.square(f, r)) is None for r in range(8))]\n    for square, piece in board.piece_map().items():\n        if piece.color == board.turn and piece.piece_type == chess.ROOK:\n            file = chess.square_file(square)\n            if file in open_files:\n                rook_mobility += 1\n    return float(rook_mobility)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Evaluates the average rank of each player's pieces.\"\n    def average_rank(color):\n        pieces = [board.piece_at(square) for square in board.piece_map() if board.piece_map()[square].color == color]\n        if not pieces:\n            return 0.0\n        return sum(chess.square_rank(square) for square in board.piece_map() if board.piece_map()[square].color == color) / len(pieces)\n\n    return float(average_rank(chess.WHITE) - average_rank(chess.BLACK))\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the material balance of minor pieces (knights and bishops) only.\"\n    minor_material_values = {chess.KNIGHT: 3, chess.BISHOP: 3}\n    def calculate_minor_material(color):\n        return sum(minor_material_values.get(piece.piece_type, 0) for piece in board.piece_map().values() if piece.color == color)\n\n    white_minor_material = calculate_minor_material(chess.WHITE)\n    black_minor_material = calculate_minor_material(chess.BLACK)\n    return float(white_minor_material - black_minor_material)\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces that are currently unprotected, i.e., not defended by any other piece.\"\n    def unprotected(color):\n        total_unprotected = 0\n        for square in board.piece_map():\n            piece = board.piece_map()[square]\n            if piece.color == color and all(not board.is_attacked_by(board.turn, square) for attacker in board.attackers(color, square)):\n                total_unprotected += 1\n        return total_unprotected\n\n    unprotected_white = unprotected(chess.WHITE)\n    unprotected_black = unprotected(chess.BLACK)\n    return float(unprotected_white - unprotected_black)\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the difference in piece mobility based on the distance from the center.\"\n    center_squares = [chess.D4, chess.D5, chess.E4, chess.E5]\n    mobility = sum(len(list(board.legal_moves)) for square in center_squares if board.piece_at(square))\n    return float(mobility)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the distance of pieces from their respective corners, evaluating potential for endgame.\"\n    def distance_to_corner(color):\n        corner_squares = [chess.A1, chess.H1] if color == chess.WHITE else [chess.A8, chess.H8]\n        return sum(chess.square_distance(sq, corner) for sq in board.piece_map() if board.piece_at(sq).color == color for corner in corner_squares)\n\n    white_distance = distance_to_corner(chess.WHITE)\n    black_distance = distance_to_corner(chess.BLACK)\n    return float(black_distance - white_distance)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the overall piece development by counting pieces on the 2nd and 7th ranks.\"\n    white_development = sum(1 for square in range(8, 16) if board.piece_at(square) and board.piece_at(square).color == chess.WHITE)\n    black_development = sum(1 for square in range(48, 56) if board.piece_at(square) and board.piece_at(square).color == chess.BLACK)\n    return float(white_development - black_development)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures how many pieces are attacking opponent's central squares (d4, d5, e4, e5).\"\n    central_squares = [chess.D4, chess.D5, chess.E4, chess.E5]\n    white_attackers = sum(board.is_attacked_by(chess.WHITE, sq) for sq in central_squares)\n    black_attackers = sum(board.is_attacked_by(chess.BLACK, sq) for sq in central_squares)\n    return float(white_attackers - black_attackers)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the number of pieces that are currently pinned by opposing pieces.\"\n    pinned_count = 0\n    for square in board.piece_map():\n        piece = board.piece_at(square)\n        if piece.color == board.turn:\n            for attacker in board.attackers(not board.turn, square):\n                pinned_count += 1\n    return float(pinned_count)\n\n",
    "def feature(board: chess.Board) -> float:\n    'Measures the total piece value difference weighted by the square distance from the home row.'\n    piece_map = board.piece_map()\n    total_value = 0.0\n    for square, piece in piece_map.items():\n        value = 0\n        if piece.piece_type == chess.PAWN:\n            value = 1\n        elif piece.piece_type == chess.KNIGHT:\n            value = 3\n        elif piece.piece_type == chess.BISHOP:\n            value = 3\n        elif piece.piece_type == chess.ROOK:\n            value = 5\n        elif piece.piece_type == chess.QUEEN:\n            value = 9\n        elif piece.piece_type == chess.KING:\n            value = 0  # King is invaluable in terms of material\n        distance = chess.square_rank(square)  # Distance from home row for each color\n        distance_adjusted_value = value * (8 - distance) if piece.color == chess.WHITE else value * distance\n        total_value += distance_adjusted_value if piece.color == chess.WHITE else -distance_adjusted_value\n    return total_value\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in piece activity between bishops and knights for both players.\"\n    white_knights = sum(1 for p in board.piece_map().values() if p.color == chess.WHITE and p.piece_type == chess.KNIGHT)\n    black_knights = sum(1 for p in board.piece_map().values() if p.color == chess.BLACK and p.piece_type == chess.KNIGHT)\n    white_bishops = sum(1 for p in board.piece_map().values() if p.color == chess.WHITE and p.piece_type == chess.BISHOP)\n    black_bishops = sum(1 for p in board.piece_map().values() if p.color == chess.BLACK and p.piece_type == chess.BISHOP)\n    result = (white_bishops - black_bishops) - (white_knights - black_knights)\n    return float(result)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the number of pieces developed (knights and bishops on their respective advanced ranks).\"\n    developed_pieces = sum(1 for square, piece in board.piece_map().items() if piece.color == board.turn and (piece.piece_type in {chess.KNIGHT, chess.BISHOP} and chess.square_rank(square) >= 2))\n    return float(developed_pieces)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of pawns that are safely advanced into the opponent's territory.\"\n    safe_advanced_pawns = sum(1 for square in chess.SQUARES if board.piece_at(square) and board.piece_at(square).color == chess.WHITE and chess.square_rank(square) >= 4)\n    return float(safe_advanced_pawns)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of square files controlled by each color's rooks.\"\n    white_files_controlled = set()\n    black_files_controlled = set()\n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.ROOK:\n            controlled_file = chess.square_file(square)\n            if piece.color == chess.WHITE:\n                white_files_controlled.add(controlled_file)\n            else:\n                black_files_controlled.add(controlled_file)\n    controlled_difference = len(white_files_controlled) - len(black_files_controlled)\n    return float(controlled_difference)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of isolated pawns for each side.\"\n    isolated_pawns = 0\n    for square in board.piece_map():\n        piece = board.piece_at(square)\n        if piece and piece.piece_type == chess.PAWN:\n            file = chess.square_file(square)\n            if (file > 0 and not board.piece_at(square - 1) or \n                file < 7 and not board.piece_at(square + 1)):\n                isolated_pawns += 1 if piece.color == chess.WHITE else -1\n    result = float(isolated_pawns)\n    return result\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Evaluates the average square value of all pieces on the board.\"\n    piece_square_values = {\n        chess.PAWN: 0.5, chess.KNIGHT: 2.5, chess.BISHOP: 3.0,\n        chess.ROOK: 4.5, chess.QUEEN: 6.0, chess.KING: 7.0\n    }\n    total_value = 0\n    piece_count = 0\n    for piece in board.piece_map().values():\n        total_value += piece_square_values.get(piece.piece_type, 0)\n        piece_count += 1\n    return total_value / piece_count if piece_count > 0 else 0.0\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of pawns each side has.\"\n    white_pawns = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE and piece.piece_type == chess.PAWN)\n    black_pawns = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK and piece.piece_type == chess.PAWN)\n    return float(white_pawns - black_pawns)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the difference in activity of rooks on open files.\"\n    white_rook_files = {chess.square_file(square) for square in board.piece_map() if board.piece_map()[square].color == chess.WHITE and board.piece_map()[square].piece_type == chess.ROOK}\n    black_rook_files = {chess.square_file(square) for square in board.piece_map() if board.piece_map()[square].color == chess.BLACK and board.piece_map()[square].piece_type == chess.ROOK}\n    return float(len(white_rook_files) - len(black_rook_files))\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the number of backward pawns for both sides.\"\n    backward_pawns = sum(1 for square, piece in board.piece_map().items() if piece.piece_type == chess.PAWN and (piece.color == chess.WHITE and chess.square_rank(square) == 3 or piece.color == chess.BLACK and chess.square_rank(square) == 4))\n    return float(backward_pawns)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the number of rooks actively controlling open files for both colors, indicating potential for attack.\"\n    white_rooks = sum(1 for square in board.piece_map() if board.piece_at(square).piece_type == chess.ROOK and board.piece_at(square).color == chess.WHITE \n                      and not any(board.piece_at(k) for k in board.piece_map() if chess.square_file(k) == chess.square_file(square) and chess.square_rank(k) > chess.square_rank(square)))\n    black_rooks = sum(1 for square in board.piece_map() if board.piece_at(square).piece_type == chess.ROOK and board.piece_at(square).color == chess.BLACK \n                      and not any(board.piece_at(k) for k in board.piece_map() if chess.square_file(k) == chess.square_file(square) and chess.square_rank(k) < chess.square_rank(square)))\n    return float(white_rooks - black_rooks)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the distance to the enemy king for all pieces of the side to move.\"\n    player_color = chess.WHITE if board.turn else chess.BLACK\n    enemy_king_square = next(square for square, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color != player_color)\n    distance_sum = sum(chess.square_distance(square, enemy_king_square) for square in board.piece_map() if board.piece_map()[square].color == player_color)\n    result = distance_sum / len(board.piece_map()) if len(board.piece_map()) > 0 else 0\n    return float(result)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Checks for the existence of unprotected pieces for both sides and evaluates their count.\"\n    unprotected_count = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == board.turn:\n            if not any(board.is_attacked_by(not piece.color, square) for square in board.attackers(piece.color, square)):\n                unprotected_count += 1\n    return float(unprotected_count)\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in development based on minor pieces' positions.\"\n    white_knights = sum(1 for square in board.piece_map() if board.piece_map()[square].color == chess.WHITE and board.piece_map()[square].piece_type == chess.KNIGHT and chess.square_rank(square) > 1)\n    black_knights = sum(1 for square in board.piece_map() if board.piece_map()[square].color == chess.BLACK and board.piece_map()[square].piece_type == chess.KNIGHT and chess.square_rank(square) < 6)\n    white_bishops = sum(1 for square in board.piece_map() if board.piece_map()[square].color == chess.WHITE and board.piece_map()[square].piece_type == chess.BISHOP and chess.square_rank(square) > 1)\n    black_bishops = sum(1 for square in board.piece_map() if board.piece_map()[square].color == chess.BLACK and board.piece_map()[square].piece_type == chess.BISHOP and chess.square_rank(square) < 6)\n    return float((white_knights + white_bishops) - (black_knights + black_bishops))\n\n\n",
    "def feature(board: chess.Board) -> float:\n    'Evaluates piece coordination by counting pairs of pieces within one knight move of each other.'\n    count_pairs = 0\n    piece_positions = list(board.piece_map().keys())\n    for i in range(len(piece_positions)):\n        for j in range(i + 1, len(piece_positions)):\n            if chess.square_distance(piece_positions[i], piece_positions[j]) <= 3:\n                count_pairs += 1\n    return float(count_pairs)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the number of pieces each player has on the opponent's half of the board.\"\n    white_advanced = sum(1 for square in board.piece_map() if board.piece_map()[square].color == chess.WHITE and chess.square_rank(square) > 3)\n    black_advanced = sum(1 for square in board.piece_map() if board.piece_map()[square].color == chess.BLACK and chess.square_rank(square) < 4)\n    return float(white_advanced - black_advanced)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in control over the f7 and f2 squares for tactical threats.\"\n    white_f2_control = 1 if board.is_attacked_by(chess.WHITE, chess.F2) else 0\n    black_f7_control = 1 if board.is_attacked_by(chess.BLACK, chess.F7) else 0\n    return float(white_f2_control - black_f7_control)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Computes the average rank of all pawns on the board to assess their advancement.\"\n    pawn_ranks = []\n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.PAWN:\n            pawn_ranks.append(chess.square_rank(square))\n    if not pawn_ranks:\n        return 0.0\n    return float(sum(pawn_ranks) / len(pawn_ranks))\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the number of pieces aligned with the opponent's king.\"\n    opponent_king_square = next((square for square, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color != board.turn), None)\n    aligned_count = 0\n    if opponent_king_square is not None:\n        for square in board.piece_map():\n            if board.piece_map()[square].color == board.turn and (chess.square_file(square) == chess.square_file(opponent_king_square) or chess.square_rank(square) == chess.square_rank(opponent_king_square)):\n                aligned_count += 1\n    return float(aligned_count)\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures material imbalance by evaluating the safety of the king in relation to major threats.\"\n    opponent_color = chess.BLACK if board.turn else chess.WHITE\n    king_square = next(square for square in board.piece_map() if board.piece_map()[square].color == board.turn and \n                       board.piece_map()[square].piece_type == chess.KING)\n    threats_count = sum(1 for square in board.piece_map() if board.piece_map()[square].color == opponent_color and \n                        board.is_attacked_by(board.turn, square))\n    return float(threats_count - board.is_check())\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the mobility of pieces in terms of unblocked pieces with legal moves.\"\n    mobility_count = 0\n    for piece in board.piece_map().values():\n        if piece.color == board.turn:\n            mobility_count += len(list(board.legal_moves))\n    return float(mobility_count)\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of squares that are attacked by both sides.\"\n    attacked_squares = len(set(square for square in range(64) if board.is_attacked_by(chess.WHITE, square) or board.is_attacked_by(chess.BLACK, square)))\n    return float(attacked_squares)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the potential to create passed pawns.\"\n    def has_passed_pawn(color):\n        for file in range(8):\n            pawn_square = chess.square(file, 1 if color == chess.WHITE else 6)\n            if board.piece_at(pawn_square) == chess.PAWN:\n                for attacked_square in (chess.square(file-1, 1 if color == chess.WHITE else 6), chess.square(file+1, 1 if color == chess.WHITE else 6)):\n                    if 0 <= file < 8 and board.is_attacked_by(not color, attacked_square):\n                        return 0\n                return 1\n        return 0\n    white_passed = has_passed_pawn(chess.WHITE)\n    black_passed = has_passed_pawn(chess.BLACK)\n    return float(white_passed - black_passed)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Determines the material balance considering remaining pieces types.\"\n    material_values = {\n        chess.PAWN: 1,\n        chess.KNIGHT: 3,\n        chess.BISHOP: 3,\n        chess.ROOK: 5,\n        chess.QUEEN: 9,\n        chess.KING: 0\n    }\n    white_material = sum(material_values[piece.piece_type] for piece in board.piece_map().values() if piece.color == chess.WHITE)\n    black_material = sum(material_values[piece.piece_type] for piece in board.piece_map().values() if piece.color == chess.BLACK)\n    return float(white_material - black_material)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the total number of squares that are available for promotion for each side.\"\n    white_promotion_squares = sum(1 for square in range(0, 8) if board.is_attacked_by(chess.WHITE, square))\n    black_promotion_squares = sum(1 for square in range(56, 64) if board.is_attacked_by(chess.BLACK, square))\n    return float(white_promotion_squares - black_promotion_squares)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in value between the most valuable piece of each side.\"\n    white_max_value = 0\n    black_max_value = 0\n    piece_values = {chess.PAWN: 1, chess.KNIGHT: 3, chess.BISHOP: 3, chess.ROOK: 5, chess.QUEEN: 9, chess.KING: 0}\n\n    for piece in board.piece_map().values():\n        if piece.color == chess.WHITE:\n            white_max_value = max(white_max_value, piece_values[piece.piece_type])\n        else:\n            black_max_value = max(black_max_value, piece_values[piece.piece_type])\n    \n    return float(white_max_value - black_max_value)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Evaluates the number of pieces pinned by each side.\"\n    def count_pinned_pieces(color):\n        return sum(1 for square in board.piece_map() if board.piece_map()[square].color == color and \n                   any(board.is_attacked_by(color, target_square) and \n                       board.is_attacked_by(chess.BLACK if color == chess.WHITE else chess.WHITE, square) \n                       for target_square in board.attackers(color, square))\n              )\n    \n    white_pinned = count_pinned_pieces(chess.WHITE)\n    black_pinned = count_pinned_pieces(chess.BLACK)\n    return float(white_pinned - black_pinned)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the total number of squares controlled by pieces of each color.\"\n    white_control = sum(1 for sq in chess.SQUARES if board.is_attacked_by(chess.WHITE, sq))\n    black_control = sum(1 for sq in chess.SQUARES if board.is_attacked_by(chess.BLACK, sq))\n    return float(white_control - black_control)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the total number of checks both sides can make next.\"\n    white_checks = sum(1 for move in board.legal_moves if board.gives_check(move))\n    result = float(white_checks)\n    return result\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the average value of pieces on the board to determine material quality.\"\n    value_mapping = {chess.PAWN: 1, chess.KNIGHT: 3, chess.BISHOP: 3, chess.ROOK: 5, chess.QUEEN: 9, chess.KING: 0}\n    total_value = sum(value_mapping[piece.piece_type] for piece in board.piece_map().values())\n    return total_value / max(1, len(board.piece_map()))  # avoid division by zero\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in central control by counting pieces in the center squares.\"\n    center_squares = [chess.E4, chess.E5, chess.D4, chess.D5]\n    white_control = sum(1 for square in center_squares if board.piece_at(square) and board.piece_at(square).color == chess.WHITE)\n    black_control = sum(1 for square in center_squares if board.piece_at(square) and board.piece_at(square).color == chess.BLACK)\n    return float(white_control - black_control)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the number of pieces that are advanced into the opponent's territory.\"\n    advanced_pieces_count = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == chess.WHITE and chess.square_rank(square) >= 4:\n            advanced_pieces_count += 1\n        elif piece.color == chess.BLACK and chess.square_rank(square) <= 3:\n            advanced_pieces_count -= 1\n    return float(advanced_pieces_count)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the control over the center (squares d4, d5, e4, e5) for both sides.\"\n    center_squares = [chess.D4, chess.D5, chess.E4, chess.E5]\n    white_control = sum(1 for square in center_squares if board.is_attacked_by(chess.WHITE, square))\n    black_control = sum(1 for square in center_squares if board.is_attacked_by(chess.BLACK, square))\n    return float(white_control - black_control)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the number of opponent pieces that are unprotected.\"\n    unprotected_count = 0\n    for square in board.piece_map():\n        piece = board.piece_at(square)\n        if piece and piece.color != board.turn:\n            if not board.attackers(board.turn, square):\n                unprotected_count += 1\n    return float(unprotected_count)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of open files available for rooks and queens for both sides.\"\n    open_files = sum(1 for file in range(8) if not any(board.piece_at(chess.square(file, rank)) for rank in range(8)))\n    return float(open_files)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of checks available for both colors, indicating potential threats.\"\n    white_checks = sum(1 for move in board.legal_moves if board.gives_check(move) and board.turn)\n    black_checks = sum(1 for move in board.legal_moves if board.gives_check(move) and not board.turn)\n    return float(white_checks - black_checks)\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the number of safe king squares available for both players.\"\n    white_king_square = next(square for square, piece in board.piece_map().items() if piece.color == chess.WHITE and piece.piece_type == chess.KING)\n    black_king_square = next(square for square, piece in board.piece_map().items() if piece.color == chess.BLACK and piece.piece_type == chess.KING)\n    \n    white_safe_squares = sum(1 for square in chess.SQUARES if board.is_attacked_by(chess.BLACK, square) == False)\n    black_safe_squares = sum(1 for square in chess.SQUARES if board.is_attacked_by(chess.WHITE, square) == False)\n    \n    return float(white_safe_squares - black_safe_squares)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the potential threats by calculating the number of legal moves that can capture the opponent's pieces.\"\n    threat_count_white = sum(1 for move in board.legal_moves if board.is_attacked_by(chess.BLACK, move.to_square))\n    threat_count_black = sum(1 for move in board.legal_moves if board.is_attacked_by(chess.WHITE, move.to_square))\n    return float(threat_count_white - threat_count_black)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the total number of pieces in the opponent's territory for each side.\"\n    white_in_enemy_territory = sum(1 for square, piece in board.piece_map().items() if piece.color == chess.WHITE and chess.square_rank(square) > 4)\n    black_in_enemy_territory = sum(1 for square, piece in board.piece_map().items() if piece.color == chess.BLACK and chess.square_rank(square) < 3)\n    return float(white_in_enemy_territory - black_in_enemy_territory)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the distance of each side's pawns to the promotion rank.\"\n    white_pawn_distance = sum(7 - chess.square_rank(sq) for sq, piece in board.piece_map().items() if piece.color == chess.WHITE and piece.piece_type == chess.PAWN)\n    black_pawn_distance = sum(chess.square_rank(sq) for sq, piece in board.piece_map().items() if piece.color == chess.BLACK and piece.piece_type == chess.PAWN)\n    return float(white_pawn_distance - black_pawn_distance)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the distance of all pieces to their respective opponent's king.\"\n    def distance_to_king(color):\n        king_square = next(square for square in board.piece_map() if board.piece_map()[square].piece_type == chess.KING and board.piece_map()[square].color == color)\n        return sum(chess.square_distance(square, king_square) for square in board.piece_map() if board.piece_map()[square].color != color)\n\n    white_distance = distance_to_king(chess.WHITE)\n    black_distance = distance_to_king(chess.BLACK)\n    result = black_distance - white_distance\n    return float(result)\n\n",
    "def feature(board: chess.Board) -> float:\n    'Calculates the total number of passed pawns for both colors.'\n    white_passed_pawns = sum(1 for square, piece in board.piece_map().items() if piece.color == chess.WHITE and piece.piece_type == chess.PAWN and not board.is_attacked_by(chess.BLACK, square))\n    black_passed_pawns = sum(1 for square, piece in board.piece_map().items() if piece.color == chess.BLACK and piece.piece_type == chess.PAWN and not board.is_attacked_by(chess.WHITE, square))\n    result = float(white_passed_pawns - black_passed_pawns)\n    return result\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Checks the number of defended squares around the opponent's king, indicating security.\"\n    opponent_king_square = next(square for square, piece in board.piece_map().items() \n                                 if piece.piece_type == chess.KING and piece.color == chess.BLACK)\n    defended_squares = sum(1 for square in chess.SQUARES if board.is_attacked_by(chess.WHITE, square))\n    return float(defended_squares)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of kingside and queenside pawn structures for both players, assessing endgame potential.\"\n    white_ks = sum(1 for square in board.piece_map() if board.piece_at(square).color == chess.WHITE and chess.square_rank(square) == 1 and chess.square_file(square) >= 4)\n    white_qs = sum(1 for square in board.piece_map() if board.piece_at(square).color == chess.WHITE and chess.square_rank(square) == 1 and chess.square_file(square) < 4)\n    black_ks = sum(1 for square in board.piece_map() if board.piece_at(square).color == chess.BLACK and chess.square_rank(square) == 6 and chess.square_file(square) >= 4)\n    black_qs = sum(1 for square in board.piece_map() if board.piece_at(square).color == chess.BLACK and chess.square_rank(square) == 6 and chess.square_file(square) < 4)\n    result = float((white_ks - black_ks) + (white_qs - black_qs))\n    return result\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the average distance of pieces from the center of the board for each color.\"\n    total_distance_white = total_distance_black = 0\n    piece_count_white = piece_count_black = 0\n    center_squares = [chess.E4, chess.E5, chess.D4, chess.D5]\n    for square, piece in board.piece_map().items():\n        distance = min(chess.square_distance(square, center) for center in center_squares)\n        if piece.color == chess.WHITE:\n            total_distance_white += distance\n            piece_count_white += 1\n        else:\n            total_distance_black += distance\n            piece_count_black += 1\n    avg_distance_white = total_distance_white / piece_count_white if piece_count_white > 0 else 0\n    avg_distance_black = total_distance_black / piece_count_black if piece_count_black > 0 else 0\n    return float(avg_distance_white - avg_distance_black)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the value of unprotected pieces for both sides.\"\n    def unprotected_value(color):\n        value = 0\n        for square, piece in board.piece_map().items():\n            if piece.color == color:\n                if not any(board.is_attacked_by(not color, square) for square in board.attackers(color, square)):\n                    value += {\n                        chess.PAWN: 1,\n                        chess.KNIGHT: 3,\n                        chess.BISHOP: 3,\n                        chess.ROOK: 5,\n                        chess.QUEEN: 9\n                    }.get(piece.piece_type, 0)\n        return value\n\n    return float(unprotected_value(chess.WHITE) - unprotected_value(chess.BLACK) )\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the potential pawn promotion advantage for each side.\"\n    white_promotion_pawns = sum(1 for square in range(56, 64) if board.piece_at(square) == chess.PAWN and board.piece_at(square).color == chess.WHITE)\n    black_promotion_pawns = sum(1 for square in range(0, 8) if board.piece_at(square) == chess.PAWN and board.piece_at(square).color == chess.BLACK)\n    return float(white_promotion_pawns - black_promotion_pawns)\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of pawn structures on each side that are doubled, isolated, or blocked.\"\n    def pawn_structure_weakness(color):\n        count = 0\n        for file in range(8):\n            pawn_count = sum(1 for rank in range(8) if board.piece_at(chess.square(file, rank)) == chess.PAWN and (piece := board.piece_at(chess.square(file, rank))).color == color)\n            if pawn_count > 1:\n                count += 1  # Count doubled pawns\n            if pawn_count == 1:\n                count += 0 if (file > 0 and board.piece_at(chess.square(file-1, rank)) != chess.PAWN) and (file < 7 and board.piece_at(chess.square(file+1, rank)) != chess.PAWN) else 1  # Isolated pawn\n        return count\n\n    white_weakness = pawn_structure_weakness(chess.WHITE)\n    black_weakness = pawn_structure_weakness(chess.BLACK)\n    return float(white_weakness - black_weakness)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the disparity in the number of minor pieces (knights and bishops) each side has.\"\n    white_minor_count = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE and piece.piece_type in {chess.KNIGHT, chess.BISHOP})\n    black_minor_count = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK and piece.piece_type in {chess.KNIGHT, chess.BISHOP})\n    return float(white_minor_count - black_minor_count)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the number of squares that are attacked but not defended.\"\n    attacked_not_defended = sum(1 for square in range(64) if board.is_attacked_by(board.turn, square) and not any(board.is_attacked_by(board.turn, target) for target in board.attackers(not board.turn, square)))\n    return float(attacked_not_defended)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the distance of the kings from the center of the board.\"\n    white_king_square = next(square for square, piece in board.piece_map().items() if piece.color == chess.WHITE and piece.piece_type == chess.KING)\n    black_king_square = next(square for square, piece in board.piece_map().items() if piece.color == chess.BLACK and piece.piece_type == chess.KING)\n    white_king_distance = chess.square_distance(white_king_square, chess.parse_square('e4'))\n    black_king_distance = chess.square_distance(black_king_square, chess.parse_square('e4'))\n    return float(black_king_distance - white_king_distance)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Computes the number of pieces attacking the same square for both sides, highlighting tactical conflicts.\"\n    attack_counts = {chess.WHITE: {}, chess.BLACK: {}}\n    \n    for square in range(64):\n        for attacker in board.attackers(chess.WHITE, square):\n            if square not in attack_counts[chess.WHITE]:\n                attack_counts[chess.WHITE][square] = 0\n            attack_counts[chess.WHITE][square] += 1\n            \n        for attacker in board.attackers(chess.BLACK, square):\n            if square not in attack_counts[chess.BLACK]:\n                attack_counts[chess.BLACK][square] = 0\n            attack_counts[chess.BLACK][square] += 1\n            \n    return float(sum(attack_counts[chess.WHITE].values()) - sum(attack_counts[chess.BLACK].values()))\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the number of pieces supported by their own pawns.\"\n    supported_pieces = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == board.turn:  # Only check pieces of the current turn's color\n            pawns_attacking = board.attackers(piece.color, square)\n            if any(board.piece_at(pawn) and board.piece_at(pawn).piece_type == chess.PAWN for pawn in pawns_attacking):\n                supported_pieces += 1\n    return float(supported_pieces)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the total number of squares controlled by each player's pieces.\"\n    white_controlled_squares = len(set(move.to_square for move in board.legal_moves if board.piece_map()[move.from_square].color == chess.WHITE))\n    black_controlled_squares = len(set(move.to_square for move in board.legal_moves if board.piece_map()[move.from_square].color == chess.BLACK))\n    return float(white_controlled_squares - black_controlled_squares)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces that are pinned for both sides.\"\n    def is_pinned(color):\n        pinned_count = 0\n        for square in board.piece_map():\n            piece = board.piece_map()[square]\n            if piece.color == color:\n                for attacker in board.attackers(not color, square):\n                    if board.piece_at(attacker).piece_type == chess.QUEEN or board.piece_at(attacker).piece_type == chess.ROOK or (board.piece_at(attacker).piece_type == chess.BISHOP and abs(chess.square_file(attacker) - chess.square_file(square)) == abs(chess.square_rank(attacker) - chess.square_rank(square))):\n                        pinned_count += 1\n                        break\n        return pinned_count\n\n    white_pinned = is_pinned(chess.WHITE)\n    black_pinned = is_pinned(chess.BLACK)\n    return float(white_pinned - black_pinned)\n\n",
    "def feature(board: chess.Board) -> float:\n    'Measures the distance of pieces to the opponent\\'s back rank.'\n    distance_score = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == board.turn:\n            distance = 7 - chess.square_rank(square) if piece.color == chess.WHITE else chess.square_rank(square)\n            distance_score += distance\n    return float(distance_score)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the distance to the opponent's back rank for each side.\"\n    white_king_square = next((s for s, p in board.piece_map().items() if p.color == chess.WHITE and p.piece_type == chess.KING), None)\n    black_king_square = next((s for s, p in board.piece_map().items() if p.color == chess.BLACK and p.piece_type == chess.KING), None)\n    white_distance = (7 - chess.square_rank(white_king_square)) if white_king_square is not None else float('inf')\n    black_distance = (chess.square_rank(black_king_square)) if black_king_square is not None else float('inf')\n    return float(white_distance - black_distance)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the difference in the number of pawn structures (connected pawns) for both players.\"\n    def connected_pawns_count(color):\n        count = 0\n        for file in range(8):\n            if board.piece_at(chess.square(file, 1 if color == chess.WHITE else 6)) and board.piece_at(chess.square(file, 1 if color == chess.WHITE else 6)).color == color:\n                if (file > 0 and board.piece_at(chess.square(file - 1, 1 if color == chess.WHITE else 6)) and board.piece_at(chess.square(file - 1, 1 if color == chess.WHITE else 6)).color == color) or \\\n                   (file < 7 and board.piece_at(chess.square(file + 1, 1 if color == chess.WHITE else 6)) and board.piece_at(chess.square(file + 1, 1 if color == chess.WHITE else 6)).color == color):\n                    count += 1\n        return count\n\n    white_connected = connected_pawns_count(chess.WHITE)\n    black_connected = connected_pawns_count(chess.BLACK)\n    return float(white_connected - black_connected)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces in the first two ranks for both players.\"\n    white_ranks = sum(1 for sq, piece in board.piece_map().items() if piece.color == chess.WHITE and chess.square_rank(sq) < 2)\n    black_ranks = sum(1 for sq, piece in board.piece_map().items() if piece.color == chess.BLACK and chess.square_rank(sq) > 5)\n    return float(white_ranks - black_ranks)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the number of squares controlled by current player's pawns.\"\n    controlled_squares = sum(1 for square in chess.SQUARES if board.piece_at(square) and board.piece_at(square).color == board.turn and chess.square_rank(square) == 5)\n    return float(controlled_squares)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the number of pieces each side has on the 7th rank.\"\n    white_7th_rank = sum(1 for square in range(0, 8) if board.piece_at(chess.square(square, 6)) and board.piece_at(chess.square(square, 6)).color == chess.WHITE)\n    black_7th_rank = sum(1 for square in range(0, 8) if board.piece_at(chess.square(square, 1)) and board.piece_at(chess.square(square, 1)).color == chess.BLACK)\n    return float(white_7th_rank - black_7th_rank)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the number of backward pawns for each player.\"\n    backward_pawns_white = sum(1 for square in board.piece_map() if board.piece_at(square).color == chess.WHITE and board.piece_at(square).piece_type == chess.PAWN and all(board.piece_at(chess.square(chess.square_file(square), rank)) is None for rank in range(chess.square_rank(square)+1, 8)))\n    backward_pawns_black = sum(1 for square in board.piece_map() if board.piece_at(square).color == chess.BLACK and board.piece_at(square).piece_type == chess.PAWN and all(board.piece_at(chess.square(chess.square_file(square), rank)) is None for rank in range(0, chess.square_rank(square))))\n    result = float(backward_pawns_white - backward_pawns_black)\n    return result\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces attacked but not defended by either side.\"\n    attacked_and_hanging = sum(1 for square, piece in board.piece_map().items() \n                                if board.is_attacked_by(chess.WHITE, square) and \n                                not any(board.is_attacked_by(chess.BLACK, attack_square) for attack_square in board.attackers(chess.BLACK, square)) or\n                                board.is_attacked_by(chess.BLACK, square) and \n                                not any(board.is_attacked_by(chess.WHITE, attack_square) for attack_square in board.attackers(chess.WHITE, square)))\n    \n    return float(attacked_and_hanging)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the number of pieces attacked by each side.\"\n    white_attacks = sum(1 for square in board.piece_map() if board.is_attacked_by(chess.WHITE, square))\n    black_attacks = sum(1 for square in board.piece_map() if board.is_attacked_by(chess.BLACK, square))\n    return float(white_attacks - black_attacks)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the number of passed pawns for both sides.\"\n    white_passed = sum(1 for sq, piece in board.piece_map().items() \n                       if piece.color == chess.WHITE and piece.piece_type == chess.PAWN \n                       and not board.is_attacked_by(chess.BLACK, sq))\n    black_passed = sum(1 for sq, piece in board.piece_map().items() \n                       if piece.color == chess.BLACK and piece.piece_type == chess.PAWN \n                       and not board.is_attacked_by(chess.WHITE, sq))\n    return float(white_passed - black_passed)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the safety of the king based on available escape squares.\"\n    white_king_square = next((square for square in board.piece_map() if board.piece_map()[square].color == chess.WHITE and board.piece_map()[square].piece_type == chess.KING), None)\n    black_king_square = next((square for square in board.piece_map() if board.piece_map()[square].color == chess.BLACK and board.piece_map()[square].piece_type == chess.KING), None)\n    \n    def escape_squares(king_square):\n        escape_moves = 0\n        for move in board.legal_moves:\n            if move.from_square == king_square:\n                escape_moves += 1\n        return escape_moves\n\n    score = escape_squares(white_king_square) - escape_squares(black_king_square)\n    return float(score)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the difference between the number of minor pieces (knights + bishops) remaining for both sides.\"\n    white_minor_count = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE and piece.piece_type in [chess.KNIGHT, chess.BISHOP])\n    black_minor_count = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK and piece.piece_type in [chess.KNIGHT, chess.BISHOP])\n    return white_minor_count - black_minor_count\n",
    "def feature(board: chess.Board) -> float:\n    \"Evaluates the control of major files by rooks for both sides.\"\n    def rook_control(file, color):\n        return any(board.piece_at(square) and board.piece_at(square).color == color and board.piece_at(square).piece_type == chess.ROOK for square in range(file, 64, 8))\n    \n    white_control = sum(1 for file in range(8) if rook_control(file, chess.WHITE))\n    black_control = sum(1 for file in range(8) if rook_control(file, chess.BLACK))\n    return float(white_control - black_control)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the total number of pieces that have mobility, evaluating their safety.\"\n    mobile_pieces = sum(1 for piece in board.piece_map().values() if len(list(board.legal_moves)) > 0)\n    return float(mobile_pieces)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Evaluates the position based on both players' kings' proximity to the center.\"\n    white_king_square = [square for square in board.piece_map() if board.piece_at(square).piece_type == chess.KING and board.piece_at(square).color == chess.WHITE][0]\n    black_king_square = [square for square in board.piece_map() if board.piece_at(square).piece_type == chess.KING and board.piece_at(square).color == chess.BLACK][0]\n    center_distance = (chess.square_distance(white_king_square, chess.parse_square('e4')) + \n                       chess.square_distance(black_king_square, chess.parse_square('e4')))\n    return float(center_distance)\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the mobility advantage by comparing the number of legal moves.\"\n    white_moves = len(list(board.legal_moves)) if board.turn == chess.WHITE else 0\n    black_moves = len(list(board.legal_moves)) if board.turn == chess.BLACK else 0\n    return float(white_moves - black_moves)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the tempo by counting the number of moves to check or checkmate.\"\n    tempo = 0\n    if board.is_check():\n        tempo = 1\n    elif board.is_checkmate():\n        tempo = -1\n    return float(tempo)\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the center control by evaluating the number of pieces on d4, d5, e4, and e5.\"\n    center_squares = [chess.D4, chess.D5, chess.E4, chess.E5]\n    white_center_control = sum(1 for square in center_squares if board.piece_at(square) and board.piece_at(square).color == chess.WHITE)\n    black_center_control = sum(1 for square in center_squares if board.piece_at(square) and board.piece_at(square).color == chess.BLACK)\n    return float(white_center_control - black_center_control)\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the distribution of material value over the board.\"\n    value_distribution = sum(piece.piece_type for piece in board.piece_map().values())\n    return float(value_distribution)\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the ratio of defenders to attackers for each player's pieces on the board.\"\n    white_defenders = sum(len(board.attackers(chess.WHITE, square)) for square in board.piece_map() if board.piece_at(square).color == chess.WHITE)\n    white_attackers = sum(len(board.attackers(chess.BLACK, square)) for square in board.piece_map() if board.piece_at(square).color == chess.WHITE)\n    black_defenders = sum(len(board.attackers(chess.BLACK, square)) for square in board.piece_map() if board.piece_at(square).color == chess.BLACK)\n    black_attackers = sum(len(board.attackers(chess.WHITE, square)) for square in board.piece_map() if board.piece_at(square).color == chess.BLACK)\n    result = (white_defenders / (white_attackers + 1e-7)) - (black_defenders / (black_attackers + 1e-7))\n    return float(result)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the exposed position of the kings' by counting the squares attacking each king.\"\n    white_king_square = next(square for square in board.piece_map() if board.piece_map()[square].color == chess.WHITE and board.piece_map()[square].piece_type == chess.KING)\n    black_king_square = next(square for square in board.piece_map() if board.piece_map()[square].color == chess.BLACK and board.piece_map()[square].piece_type == chess.KING)\n    white_exposure = sum(1 for square in chess.SQUARES_180 if board.is_attacked_by(chess.BLACK, square) and square in chess.SQUARES_180)\n    black_exposure = sum(1 for square in chess.SQUARES_180 if board.is_attacked_by(chess.WHITE, square) and square in chess.SQUARES_180)\n    return float(white_exposure - black_exposure)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the safety of major pieces (rooks and queens) considering their position.\"\n    piece_safety_values = {chess.ROOK: 0, chess.QUEEN: 1}\n    \n    def safety_score(color):\n        score = 0\n        for square, piece in board.piece_map().items():\n            if piece.color == color and piece.piece_type in piece_safety_values:\n                score += piece_safety_values[piece.piece_type]\n                if board.is_attacked_by(not color, square):\n                    score -= 1  # Penalize if the piece is attacked\n        return score\n    \n    white_safety = safety_score(chess.WHITE)\n    black_safety = safety_score(chess.BLACK)\n    return float(white_safety - black_safety)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the total number of pieces on the board.\"\n    total_pieces = len(board.piece_map())\n    return float(total_pieces)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the mobility advantage by calculating total legal moves for each side.\"\n    white_mobility = len(list(board.legal_moves))\n    black_mobility = len(list(board.legal_moves))\n    return float(white_mobility - black_mobility)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures overall piece safety by summing the safety of each piece.\"\n    piece_safety = 0\n    for square, piece in board.piece_map().items():\n        attackers = board.attackers(chess.WHITE if piece.color == chess.WHITE else chess.BLACK, square)\n        piece_safety += (4 - len(attackers)) if piece.color == chess.WHITE else -(4 - len(attackers))\n    return float(piece_safety)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Evaluates the threefold repetition rule possibility for each side.\"\n    white_repetition = board.is_repetition(chess.WHITE)\n    black_repetition = board.is_repetition(chess.BLACK)\n    return float(white_repetition - black_repetition)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Evaluates the position by calculating the total value of pieces under attack.\"\n    under_attack_value = 0\n    for square, piece in board.piece_map().items():\n        if board.is_attacked_by(not piece.color, square):\n            under_attack_value += piece.piece_type  # You can assign values here, e.g., using a dictionary\n    return float(under_attack_value)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the number of pieces that are pinned by each side.\"\n    def is_pinned(color):\n        pinned_count = 0\n        for square in board.piece_map():\n            piece = board.piece_map()[square]\n            if piece.color == color:\n                if board.is_attacked_by(not color, square):\n                    pinned_count += 1\n        return pinned_count\n\n    white_pinned = is_pinned(chess.WHITE)\n    black_pinned = is_pinned(chess.BLACK)\n    return float(white_pinned - black_pinned)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the impact of a piece's position by evaluating its rank and file control.\"\n    piece_control_value = 0.0\n    for square, piece in board.piece_map().items():\n        if piece.color == chess.WHITE:\n            piece_control_value += (chess.square_rank(square) + 1)  # Higher rank is better\n        else:\n            piece_control_value -= (chess.square_rank(square) + 1)\n    return piece_control_value\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the number of pieces beyond the 4th rank for both sides.\"\n    white_advanced = sum(1 for square in board.piece_map() if board.piece_map()[square].color == chess.WHITE and chess.square_rank(square) > 3)\n    black_advanced = sum(1 for square in board.piece_map() if board.piece_map()[square].color == chess.BLACK and chess.square_rank(square) < 4)\n    return float(white_advanced - black_advanced)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Evaluates the stability of the king position based on the number of squares its surrounded by.\"\n    white_king_squares = sum(1 for square in board.attackers(chess.WHITE, chess.parse_square('e1')))\n    black_king_squares = sum(1 for square in board.attackers(chess.BLACK, chess.parse_square('e8')))\n    return float(white_king_squares - black_king_squares)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the ratio of bishops to knights for both sides and returns their difference.\"\n    white_bishops = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE and piece.piece_type == chess.BISHOP)\n    white_knights = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE and piece.piece_type == chess.KNIGHT)\n    black_bishops = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK and piece.piece_type == chess.BISHOP)\n    black_knights = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK and piece.piece_type == chess.KNIGHT)\n\n    white_ratio = white_bishops / (white_knights + 1)  # Avoid division by zero\n    black_ratio = black_bishops / (black_knights + 1)  # Avoid division by zero\n    \n    return float(white_ratio - black_ratio)\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the distance of all kings from their respective corners.\"\n    white_king_square = next(sq for sq in board.piece_map() if board.piece_map()[sq].piece_type == chess.KING and board.piece_map()[sq].color == chess.WHITE)\n    black_king_square = next(sq for sq in board.piece_map() if board.piece_map()[sq].piece_type == chess.KING and board.piece_map()[sq].color == chess.BLACK)\n    white_distance = chess.square_distance(white_king_square, chess.A1)\n    black_distance = chess.square_distance(black_king_square, chess.H8)\n    return float(white_distance - black_distance)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the number of exits available to each side's king.\"\n    white_king_square = next(square for square, piece in board.piece_map().items() if piece.color == chess.WHITE and piece.piece_type == chess.KING)\n    black_king_square = next(square for square, piece in board.piece_map().items() if piece.color == chess.BLACK and piece.piece_type == chess.KING)\n    \n    white_king_exits = sum(1 for move in board.legal_moves if move.from_square == white_king_square)\n    black_king_exits = sum(1 for move in board.legal_moves if move.from_square == black_king_square)\n    \n    return float(white_king_exits - black_king_exits)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the pawn majority on one side of the board.\"\n    white_pawns = sum(1 for square in board.piece_map() if board.piece_at(square).piece_type == chess.PAWN and board.piece_at(square).color == chess.WHITE)\n    black_pawns = sum(1 for square in board.piece_map() if board.piece_at(square).piece_type == chess.PAWN and board.piece_at(square).color == chess.BLACK)\n    result = white_pawns - black_pawns\n    return float(result)\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the distance of pieces from the opponent's back rank.\"\n    piece_distances = []\n    for square, piece in board.piece_map().items():\n        if piece.color == board.turn:\n            distance = 7 - chess.square_rank(square) if board.turn == chess.WHITE else chess.square_rank(square)\n            piece_distances.append(distance)\n    return float(sum(piece_distances) / len(piece_distances)) if piece_distances else 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the average rank of all pawns on the board, with higher ranks indicating advancement.\"\n    pawns = [square for square, piece in board.piece_map().items() if piece.piece_type == chess.PAWN]\n    if not pawns:\n        return 0.0\n    avg_rank = sum(chess.square_rank(sq) for sq in pawns) / len(pawns)\n    return float(avg_rank)\n\n",
    "def feature(board: chess.Board) -> float:\n    'Calculates the total number of squares attacked by each side\u2019s pieces.'\n    total_attacks_white = sum(len(board.attackers(chess.WHITE, square)) for square in board.piece_map() if board.piece_map()[square].color == chess.WHITE)\n    total_attacks_black = sum(len(board.attackers(chess.BLACK, square)) for square in board.piece_map() if board.piece_map()[square].color == chess.BLACK)\n    return float(total_attacks_white - total_attacks_black)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Evaluates the piece development by counting pieces that are out of their starting rank.\"\n    developed_pieces = sum(1 for square, piece in board.piece_map().items() if piece.color == board.turn and\n                            ((piece.piece_type == chess.PAWN and chess.square_rank(square) > 1) or\n                             (piece.piece_type in {chess.KNIGHT, chess.BISHOP, chess.ROOK, chess.QUEEN} and chess.square_rank(square) > 0))) \n    return float(developed_pieces)\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of potential forks available for each side's knights.\"\n    def knight_forks(color):\n        knight_positions = [square for square, piece in board.piece_map().items() if piece.color == color and piece.piece_type == chess.KNIGHT]\n        forks = 0\n        for knight in knight_positions:\n            for target in board.attackers(not color, knight):\n                if board.piece_at(target) and board.piece_at(target).color != color:\n                    forks += 1\n        return forks\n    \n    return float(knight_forks(chess.WHITE) - knight_forks(chess.BLACK))\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in central control by pieces for both sides.\"\n    central_squares = [chess.D4, chess.E4, chess.D5, chess.E5]\n    white_control = sum(1 for square in central_squares if board.is_attacked_by(chess.WHITE, square))\n    black_control = sum(1 for square in central_squares if board.is_attacked_by(chess.BLACK, square))\n    return float(white_control - black_control)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures how many pieces are pinned for each color.\"\n    pinned_white = sum(1 for square in board.piece_map() \n                       if board.piece_map()[square].color == chess.WHITE and \n                       any(board.is_attacked_by(chess.BLACK, target) \n                           for target in board.attackers(chess.WHITE, square)))\n    pinned_black = sum(1 for square in board.piece_map() \n                       if board.piece_map()[square].color == chess.BLACK and \n                       any(board.is_attacked_by(chess.WHITE, target) \n                           for target in board.attackers(chess.BLACK, square)))\n    result = pinned_white - pinned_black\n    return float(result)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in the number of pawns for each side.\"\n    white_pawns = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE and piece.piece_type == chess.PAWN)\n    black_pawns = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK and piece.piece_type == chess.PAWN)\n    return float(white_pawns - black_pawns)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the proportion of pieces that can move to control more central squares.\"\n    central_squares = [chess.E4, chess.E5, chess.D4, chess.D5]\n    control = sum(1 for square in board.piece_map() if board.piece_map()[square].color == board.turn and square in central_squares)\n    total_pieces = sum(1 for piece in board.piece_map().values() if piece.color == board.turn)\n    return float(control / total_pieces) if total_pieces > 0 else 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Measures the total distance of each player\\'s pawns to the promotion rank.'\n    total_distance = 0\n    if board.turn:  # White's turn\n        for square in board.piece_map():\n            piece = board.piece_at(square)\n            if piece.piece_type == chess.PAWN and piece.color == chess.WHITE:\n                total_distance += (chess.square_rank(square) - 7)\n    else:  # Black's turn\n        for square in board.piece_map():\n            piece = board.piece_at(square)\n            if piece.piece_type == chess.PAWN and piece.color == chess.BLACK:\n                total_distance += (6 - chess.square_rank(square))\n    return float(total_distance)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the average distance of all pieces from the center of the board.\"\n    total_distance = 0\n    piece_count = 0\n    center_square = chess.parse_square('e4')\n    for square, piece in board.piece_map().items():\n        total_distance += chess.square_distance(square, center_square)\n        piece_count += 1\n    return float(total_distance / piece_count) if piece_count > 0 else 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the total piece value of pawns and indicates a pawn structure advantage.\"\n    pawn_value = sum(1 for piece in board.piece_map().values() if piece.piece_type == chess.PAWN and piece.color == (chess.WHITE if board.turn else chess.BLACK))\n    return float(pawn_value)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of piece pairs in close proximity (Manhattan distance = 1).\"\n    close_pairs = 0\n    squares = list(board.piece_map().keys())\n    for i in range(len(squares)):\n        for j in range(i + 1, len(squares)):\n            if chess.square_distance(squares[i], squares[j]) == 1:\n                close_pairs += 1\n    return float(close_pairs)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Computes the presence of major pieces (Queen, Rooks) for both sides.\"\n    white_major_pieces_count = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE and piece.piece_type in (chess.QUEEN, chess.ROOK))\n    black_major_pieces_count = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK and piece.piece_type in (chess.QUEEN, chess.ROOK))\n    return float(white_major_pieces_count - black_major_pieces_count)\n\n",
    "def feature(board: chess.Board) -> float:\n    'Counts the number of pieces out of their starting positions, indicating development.'\n    development = 0\n    initial_positions = {\n        chess.PAWN: [chess.A2, chess.B2, chess.C2, chess.D2, chess.E2, chess.F2, chess.G2, chess.H2],\n        chess.KNIGHT: [chess.B1, chess.G1, chess.B8, chess.G8],\n        chess.BISHOP: [chess.C1, chess.F1, chess.C8, chess.F8],\n        chess.ROOK: [chess.A1, chess.H1, chess.A8, chess.H8],\n        chess.QUEEN: [chess.D1, chess.D8],\n        chess.KING: [chess.E1, chess.E8]\n    }\n    \n    for square, piece in board.piece_map().items():\n        if square not in initial_positions.get(piece.piece_type, []):\n            development += 1\n    return float(development)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Evaluates the number of active squares (squares that can be reached by pieces) for each color.\"\n    white_active_squares = sum(1 for move in board.legal_moves if board.piece_at(move.from_square).color == chess.WHITE)\n    black_active_squares = sum(1 for move in board.legal_moves if board.piece_at(move.from_square).color == chess.BLACK)\n    return float(white_active_squares - black_active_squares)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the opponent's material lead, considering only pieces worth more than a pawn.\"\n    material_values = {\n        chess.PAWN: 1,\n        chess.KNIGHT: 3,\n        chess.BISHOP: 3,\n        chess.ROOK: 5,\n        chess.QUEEN: 9,\n        chess.KING: 0\n    }\n    opponent_material = sum(material_values[piece.piece_type] for piece in board.piece_map().values() if piece.color != board.turn)\n    return float(opponent_material)\n",
    "def feature(board: chess.Board) -> float:\n    'Counts how many pieces are controlling key squares on the board (C3, C6, F3, F6) as a mobility indicator.'\n    key_squares = [chess.C3, chess.C6, chess.F3, chess.F6]\n    control_count = sum(1 for square in key_squares for piece in board.piece_map().values() if board.is_attacked_by(piece.color, square))\n    return float(control_count)\n\n",
    "def feature(board: chess.Board) -> float:\n    'Measures the control of the center squares (d4, d5, e4, e5) for both players.'\n    center_squares = [chess.D4, chess.D5, chess.E4, chess.E5]\n    white_control = sum(1 for square in center_squares if board.is_attacked_by(chess.WHITE, square))\n    black_control = sum(1 for square in center_squares if board.is_attacked_by(chess.BLACK, square))\n    return float(white_control - black_control)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the number of control squares for pieces in the back rank.\"\n    control_squares = sum(1 for square, piece in board.piece_map().items() if piece.color == board.turn and chess.square_rank(square) == (0 if piece.color == chess.BLACK else 7) and len(board.attackers(not board.turn, square)))\n    return float(control_squares)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the number of pieces that can potentially fork opposing pieces.\"\n    forking_pieces_count = 0\n\n    for square, piece in board.piece_map().items():\n        if piece.color == chess.WHITE:\n            for move in board.legal_moves:\n                if move.from_square == square and board.is_attacked_by(chess.BLACK, move.to_square):\n                    forking_pieces_count += 1\n    \n    return float(forking_pieces_count)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the number of pieces that can be moved in one turn for each side and returns the difference.\"\n    white_moves = len(list(board.legal_moves)) * (1 if board.turn else 0)\n    black_moves = len(list(board.legal_moves)) * (1 if not board.turn else 0)\n    return float(white_moves - black_moves)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of active pieces (that can move) for both sides.\"\n    movable_white = sum(1 for square, piece in board.piece_map().items() if piece.color == chess.WHITE and len(list(board.legal_moves)) > 0)\n    movable_black = sum(1 for square, piece in board.piece_map().items() if piece.color == chess.BLACK and len(list(board.legal_moves)) > 0)\n    return float(movable_white - movable_black)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the total control over the board based on the pieces controlling squares.\"\n    controlled_squares = sum(1 for square in chess.SQUARES \n                             if any(board.is_attacked_by(piece.color, square) for piece in board.piece_map().values()))\n    return float(controlled_squares)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of open files for both sides, with a preference for connected rooks.\"\n    def open_files(color):\n        files = [file for file in range(8) if not any(board.piece_at(chess.square(file, rank)) for rank in range(8))]\n        connected_rooks = sum(1 for file in files if any(board.piece_at(chess.square(file, rank)) and board.piece_at(chess.square(file, rank)).piece_type == chess.ROOK and board.piece_at(chess.square(file, rank)).color == color for rank in range(8)))\n        return len(files) + connected_rooks\n    \n    white_files = open_files(chess.WHITE)\n    black_files = open_files(chess.BLACK)\n    return float(white_files - black_files)\n\n",
    "def feature(board: chess.Board) -> float:\n    'Calculates the total number of pieces attacked by both players as a measure of activity.'\n    white_attacked_count = sum(1 for sq in chess.SQUARES if board.is_attacked_by(chess.WHITE, sq))\n    black_attacked_count = sum(1 for sq in chess.SQUARES if board.is_attacked_by(chess.BLACK, sq))\n    return float(white_attacked_count - black_attacked_count)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the density of pieces in the center of the board.\"\n    center_squares = [chess.D4, chess.D5, chess.E4, chess.E5]\n    piece_count = sum(1 for sq in center_squares if board.piece_at(sq) is not None)\n    return float(piece_count)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the total number of pieces placed on the back rank for each side.\"\n    white_back_rank_pieces = sum(1 for square in range(64) if chess.square_rank(square) == 0 and board.piece_at(square) and board.piece_at(square).color == chess.WHITE)\n    black_back_rank_pieces = sum(1 for square in range(64) if chess.square_rank(square) == 7 and board.piece_at(square) and board.piece_at(square).color == chess.BLACK)\n    return float(white_back_rank_pieces - black_back_rank_pieces)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Evaluates the number of squares controlled by each player's pieces.\"\n    controlled_squares_white = set()\n    controlled_squares_black = set()\n    for sq, piece in board.piece_map().items():\n        if piece.color == chess.WHITE:\n            controlled_squares_white.update(board.attacks(sq))\n        else:\n            controlled_squares_black.update(board.attacks(sq))\n    return float(len(controlled_squares_white) - len(controlled_squares_black))\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the number of active pieces on the board, representing overall strength.\"\n    active_pieces = sum(1 for piece in board.piece_map().values() if piece.color == board.turn)\n    return float(active_pieces)\n\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces on the opponent's back rank as a measure of offensive pressure.\"\n    white_pieces_on_back_rank = sum(1 for square in board.piece_map() if board.piece_at(square).color == chess.WHITE and chess.square_rank(square) == 0)\n    black_pieces_on_back_rank = sum(1 for square in board.piece_map() if board.piece_at(square).color == chess.BLACK and chess.square_rank(square) == 7)\n\n    result = float(white_pieces_on_back_rank - black_pieces_on_back_rank)\n    return result\n\n",
    "def feature(board: chess.Board) -> float:\n    'Counts the number of pieces protected by pawns for each player.'\n    def count_protected_by_pawns(color):\n        protected_pieces = 0\n        for square, piece in board.piece_map().items():\n            if piece.color == color:\n                for pawn_offset in [-8, -7, -9]:\n                    if board.piece_at(square + pawn_offset) is not None and board.piece_at(square + pawn_offset).piece_type == chess.PAWN and board.piece_at(square + pawn_offset).color == color:\n                        protected_pieces += 1\n                        break\n        return protected_pieces\n    return float(count_protected_by_pawns(chess.WHITE) - count_protected_by_pawns(chess.BLACK))\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the distance of each player's king from the opponent's back rank, indicating aggression.\"\n    white_king_square = next(sq for sq, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color == chess.WHITE)\n    black_king_square = next(sq for sq, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color == chess.BLACK)\n    distance_white = 7 - chess.square_rank(black_king_square)\n    distance_black = chess.square_rank(white_king_square)\n    result = distance_white - distance_black\n    return float(result)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the total number of non-pawn pieces attacking opponent's pawns, indicating pressure on pawn structure.\"\n    white_piece_attacking_pawns = sum(1 for square in board.piece_map() if board.piece_at(square).color == chess.WHITE and \n                                       any(board.is_attacked_by(chess.BLACK, pawn_square) \n                                       for pawn_square in [chess.A7, chess.B7, chess.C7, chess.D7, chess.E7, chess.F7, chess.G7, chess.H7]))\n    black_piece_attacking_pawns = sum(1 for square in board.piece_map() if board.piece_at(square).color == chess.BLACK and \n                                       any(board.is_attacked_by(chess.WHITE, pawn_square) \n                                       for pawn_square in [chess.A2, chess.B2, chess.C2, chess.D2, chess.E2, chess.F2, chess.G2, chess.H2]))\n    return float(white_piece_attacking_pawns - black_piece_attacking_pawns)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the difference in the number of minor pieces each side has (knights and bishops).\"\n    white_minors = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE and piece.piece_type in {chess.KNIGHT, chess.BISHOP})\n    black_minors = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK and piece.piece_type in {chess.KNIGHT, chess.BISHOP})\n    return float(white_minors - black_minors)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the total piece placement value based on position strength.\"\n    piece_values = {\n        chess.PAWN: 1,\n        chess.KNIGHT: 3,\n        chess.BISHOP: 3,\n        chess.ROOK: 5,\n        chess.QUEEN: 9\n    }\n    positioning_value = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == board.turn:\n            positioning_value += piece_values.get(piece.piece_type, 0) * (8 - chess.square_rank(square))\n\n    return float(positioning_value)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the defending pieces each player's pawns have, indicating their solidity.\"\n    white_defended = sum(1 for square, piece in board.piece_map().items() if piece.color == chess.WHITE and piece.piece_type == chess.PAWN and any(board.is_attacked_by(chess.BLACK, square + offset) for offset in (-1, 1) if 0 <= square + offset <= 63))\n    black_defended = sum(1 for square, piece in board.piece_map().items() if piece.color == chess.BLACK and piece.piece_type == chess.PAWN and any(board.is_attacked_by(chess.WHITE, square + offset) for offset in (-1, 1) if 0 <= square + offset <= 63))\n    return float(white_defended - black_defended)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Assesses the imbalance of minor pieces on the board (knights versus bishops).\"\n    white_knights = sum(1 for square in board.piece_map() if board.piece_map()[square].color == chess.WHITE and board.piece_map()[square].piece_type == chess.KNIGHT)\n    black_knights = sum(1 for square in board.piece_map() if board.piece_map()[square].color == chess.BLACK and board.piece_map()[square].piece_type == chess.KNIGHT)\n    white_bishops = sum(1 for square in board.piece_map() if board.piece_map()[square].color == chess.WHITE and board.piece_map()[square].piece_type == chess.BISHOP)\n    black_bishops = sum(1 for square in board.piece_map() if board.piece_map()[square].color == chess.BLACK and board.piece_map()[square].piece_type == chess.BISHOP)\n    return float((white_knights - black_knights) + (white_bishops - black_bishops))\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the number of rooks each side has on open files.\"\n    def is_open_file(file, color):\n        for rank in range(8):\n            square = chess.square(file, rank)\n            if board.piece_at(square) is not None and board.piece_at(square).color == color:\n                return all(board.piece_at(chess.square(file, r)) is None for r in range(8) if r != rank)\n        return False\n\n    white_open_files = sum(1 for file in range(8) if is_open_file(file, chess.WHITE))\n    black_open_files = sum(1 for file in range(8) if is_open_file(file, chess.BLACK))\n    return float(white_open_files - black_open_files)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the control of the center squares (d4, d5, e4, e5) for both sides.\"\n    center_squares = [chess.D4, chess.D5, chess.E4, chess.E5]\n    white_control = sum(1 for square in center_squares if board.is_attacked_by(chess.WHITE, square))\n    black_control = sum(1 for square in center_squares if board.is_attacked_by(chess.BLACK, square))\n    return float(white_control - black_control)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Assesses whether both kings are safe, returning 1.0 for both safe, -1.0 for both unsafe, or 0.0 otherwise.\"\n    white_safe = not board.is_check() and not any(board.is_attacked_by(chess.BLACK, square) for square in board.piece_map() if board.piece_map()[square].color == chess.WHITE and board.piece_map()[square].piece_type == chess.KING)\n    black_safe = not board.is_check() and not any(board.is_attacked_by(chess.WHITE, square) for square in board.piece_map() if board.piece_map()[square].color == chess.BLACK and board.piece_map()[square].piece_type == chess.KING)\n    return float(1.0 if white_safe and black_safe else (-1.0 if not white_safe and not black_safe else 0.0))\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the king's distance to the center of the board to assess king safety.\"\n    white_king_square = board.king(chess.WHITE)\n    black_king_square = board.king(chess.BLACK)\n    if white_king_square is None or black_king_square is None:\n        return 0.0\n    distance_to_center_white = (chess.square_rank(white_king_square) - 3) ** 2 + (chess.square_file(white_king_square) - 3) ** 2\n    distance_to_center_black = (chess.square_rank(black_king_square) - 4) ** 2 + (chess.square_file(black_king_square) - 4) ** 2\n    return float(distance_to_center_white - distance_to_center_black)\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of pawns on the 7th rank for Black and the 2nd rank for White.\"\n    rank_counts = {chess.WHITE: 0, chess.BLACK: 0}\n    for square in chess.SQUARES:\n        piece = board.piece_at(square)\n        if piece and piece.piece_type == chess.PAWN:\n            if piece.color == chess.WHITE and chess.square_rank(square) == 1:\n                rank_counts[chess.WHITE] += 1\n            elif piece.color == chess.BLACK and chess.square_rank(square) == 6:\n                rank_counts[chess.BLACK] += 1\n    return float(rank_counts[chess.WHITE] - rank_counts[chess.BLACK])\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the material difference weighted by piece centrality (squares e4, d4, e5, d5).\"\n    central_squares = [chess.parse_square('e4'), chess.parse_square('d4'), chess.parse_square('e5'), chess.parse_square('d5')]\n    material_values = {chess.PAWN: 1, chess.KNIGHT: 3, chess.BISHOP: 3, chess.ROOK: 5, chess.QUEEN: 9, chess.KING: 0}\n    \n    def central_material(color):\n        return sum(material_values[piece.piece_type] for square, piece in board.piece_map().items() if piece.color == color and square in central_squares)\n    \n    white_central = central_material(chess.WHITE)\n    black_central = central_material(chess.BLACK)\n    \n    return float(white_central - black_central)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the distance from all pieces to the nearest enemy king.\"\n    enemy_king_square = next(square for square, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color != (chess.WHITE if board.turn else chess.BLACK))\n    distance_sum = sum(chess.square_distance(square, enemy_king_square) for square in board.piece_map().keys())\n    result = float(distance_sum)\n    return result\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in pawn structure between the two players, focusing on connected pawns.\"\n    connected_pawns = 0\n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.PAWN:\n            file = chess.square_file(square)\n            if file > 0 and board.piece_at(chess.square(file - 1, chess.square_rank(square))) == piece:\n                connected_pawns += 1\n            if file < 7 and board.piece_at(chess.square(file + 1, chess.square_rank(square))) == piece:\n                connected_pawns += 1\n    return float(connected_pawns)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the number of attacking pieces each side has.\"\n    white_attackers = sum(len(board.attackers(chess.WHITE, square)) for square in board.piece_map())\n    black_attackers = sum(len(board.attackers(chess.BLACK, square)) for square in board.piece_map())\n    return float(white_attackers - black_attackers)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the number of minor pieces (knights and bishops) each side has relative to the opponent.\"\n    white_minor = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE and piece.piece_type in {chess.KNIGHT, chess.BISHOP})\n    black_minor = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK and piece.piece_type in {chess.KNIGHT, chess.BISHOP})\n    return float(white_minor - black_minor)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the number of double attacks for both sides.\"\n    double_attacks = 0\n    for square, piece in board.piece_map().items():\n        current_attacks = board.attackers(not piece.color, square)\n        if len(current_attacks) >= 2:\n            double_attacks += 1\n    return float(double_attacks)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the distance of each player's pieces from their respective back ranks, indicating the development stage.\"\n    white_distance = sum(chess.square_rank(square) for square in board.piece_map() if board.piece_at(square).color == chess.WHITE)\n    black_distance = sum(7 - chess.square_rank(square) for square in board.piece_map() if board.piece_at(square).color == chess.BLACK)\n    return float(white_distance - black_distance)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the degree of king safety based on pawn structure.\"\n    def king_safety(color):\n        king_square = next(square for square, piece in board.piece_map().items() if piece.color == color and piece.piece_type == chess.KING)\n        safety = 0\n        for square in range(64):\n            piece = board.piece_at(square)\n            if piece and piece.color == color:\n                if chess.square_distance(king_square, square) <= 1:\n                    safety += 1\n        return safety\n\n    return float(king_safety(chess.WHITE) - king_safety(chess.BLACK))\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the mobility advantage between the two sides.\"\n    white_mobility = len(list(board.legal_moves)) if board.turn == chess.WHITE else len(list(board.legal_moves))\n    black_mobility = len(list(board.legal_moves)) if board.turn == chess.BLACK else len(list(board.legal_moves))\n    return float(white_mobility - black_mobility)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the number of squares adjacent to the opposing king that are attacked by the current player's pieces.\"\n    opponent_king_square = next(square for square, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color != board.turn)\n    adjacent_squares = [chess.square_file(opponent_king_square) + 1, chess.square_file(opponent_king_square) - 1]\n    controlled_squares = sum(1 for square in adjacent_squares if board.is_attacked_by(board.turn, square))\n    return float(controlled_squares)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces on the 7th rank for both sides.\"\n    white_seventh = sum(1 for square in range(56, 64) if board.piece_at(square) and board.piece_at(square).color == chess.WHITE)\n    black_seventh = sum(1 for square in range(0, 8) if board.piece_at(square) and board.piece_at(square).color == chess.BLACK)\n    return float(white_seventh - black_seventh)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the number of minor pieces (knights and bishops) for both sides.\"\n    minor_piece_count = sum(1 for piece in board.piece_map().values() if piece.piece_type in [chess.KNIGHT, chess.BISHOP])\n    return float(minor_piece_count)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the total center control defined as the number of pieces in the central squares (d4, d5, e4, e5).\"\n    central_squares = [chess.D4, chess.D5, chess.E4, chess.E5]\n    white_center = sum(1 for square in central_squares if board.piece_at(square) and board.piece_at(square).color == chess.WHITE)\n    black_center = sum(1 for square in central_squares if board.piece_at(square) and board.piece_at(square).color == chess.BLACK)\n    return float(white_center - black_center)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the number of pieces each player has on their opponent's 6th rank.\"\n    white_on_6th_rank = sum(1 for square in range(0, 8) if board.piece_at(chess.square(square, 5)) and board.piece_at(chess.square(square, 5)).color == chess.WHITE)\n    black_on_6th_rank = sum(1 for square in range(0, 8) if board.piece_at(chess.square(square, 2)) and board.piece_at(chess.square(square, 2)).color == chess.BLACK)\n    return float(white_on_6th_rank - black_on_6th_rank)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the number of pieces each side has beyond the 7th rank, indicating advancement.\"\n    white_pieces_advanced = sum(1 for sq in board.piece_map() if board.piece_at(sq).color == chess.WHITE and chess.square_rank(sq) >= 6)\n    black_pieces_advanced = sum(1 for sq in board.piece_map() if board.piece_at(sq).color == chess.BLACK and chess.square_rank(sq) <= 1)\n    return float(white_pieces_advanced - black_pieces_advanced)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the total value of all pieces supported by other pieces on the board.\"\n    value = 0.0\n    for sq, piece in board.piece_map().items():\n        if piece.color == chess.WHITE:\n            attackers = board.attackers(chess.WHITE, sq)\n            within_support_distance = sum(p.piece_type for p in (board.piece_map()[attacker] for attacker in attackers) if p.color == chess.WHITE)\n            value += within_support_distance * (1 if piece.color == chess.WHITE else -1)\n    return value\n\n",
    "def feature(board: chess.Board) -> float:\n    'Calculates the ratio of knights to all pieces for each color to evaluate piece diversity.'\n    white_knights = sum(1 for p in board.piece_map().values() if p.color == chess.WHITE and p.piece_type == chess.KNIGHT)\n    black_knights = sum(1 for p in board.piece_map().values() if p.color == chess.BLACK and p.piece_type == chess.KNIGHT)\n    total_pieces = len(board.piece_map())\n    if total_pieces == 0:\n        return 0.0\n    return (white_knights / total_pieces) - (black_knights / total_pieces)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the total number of squares controlled by each side.\"\n    white_controlled_squares = set()\n    black_controlled_squares = set()\n\n    for move in board.legal_moves:\n        if move.from_square in white_controlled_squares:\n            white_controlled_squares.add(move.to_square)\n        else:\n            black_controlled_squares.add(move.to_square)\n    \n    return float(len(white_controlled_squares) - len(black_controlled_squares))\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the piece mobility by calculating the average number of legal moves per piece.\"\n    total_moves = sum(len(list(board.legal_moves)) for piece in board.piece_map().values())\n    piece_count = len(board.piece_map())\n    return total_moves / piece_count if piece_count > 0 else 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the average piece distance from the opponent's back rank.\"\n    total_distance = 0\n    piece_count = 0\n    for square in board.piece_map():\n        piece = board.piece_at(square)\n        if piece:\n            target_rank = 7 if piece.color == chess.WHITE else 0\n            total_distance += chess.square_rank(square) - target_rank\n            piece_count += 1\n    return total_distance / piece_count if piece_count > 0 else 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the number of pieces obstructing each player's king mobility, indicating safety.\"\n    white_king_square = next(sq for sq in board.piece_map() if board.piece_at(sq).piece_type == chess.KING and board.piece_at(sq).color == chess.WHITE)\n    black_king_square = next(sq for sq in board.piece_map() if board.piece_at(sq).piece_type == chess.KING and board.piece_at(sq).color == chess.BLACK)\n\n    white_obstructed = sum(1 for move in board.legal_moves if move.from_square == white_king_square and board.piece_at(move.to_square) is not None)\n    black_obstructed = sum(1 for move in board.legal_moves if move.from_square == black_king_square and board.piece_at(move.to_square) is not None)\n\n    result = float(black_obstructed - white_obstructed)\n    return result\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces on the 7th and 2nd ranks.\"\n    white_on_7th = sum(1 for square in board.piece_map() if board.piece_map()[square].color == chess.WHITE and chess.square_rank(square) == 6)\n    black_on_2nd = sum(1 for square in board.piece_map() if board.piece_map()[square].color == chess.BLACK and chess.square_rank(square) == 1)\n    \n    return float(white_on_7th - black_on_2nd)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the number of open files available for each side's rooks.\"\n    open_files_white = sum(1 for file in range(8) if all(board.piece_at(chess.square(file, rank)) is None for rank in range(8) if board.turn == chess.WHITE))\n    open_files_black = sum(1 for file in range(8) if all(board.piece_at(chess.square(file, rank)) is None for rank in range(8) if board.turn == chess.BLACK))\n    return float(open_files_white - open_files_black)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces on the back rank (first and eighth ranks) for both sides.\"\n    back_rank_count = sum(1 for square in range(0, 8) if board.piece_at(square) and board.piece_at(square).color == board.turn) + \\\n                     sum(1 for square in range(56, 64) if board.piece_at(square) and board.piece_at(square).color != board.turn)\n    return float(back_rank_count)\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the total value of pieces on the board using standard piece values.\"\n    piece_values = {chess.PAWN: 1, chess.KNIGHT: 3, chess.BISHOP: 3, chess.ROOK: 5, chess.QUEEN: 9}\n    value = sum(piece_values.get(board.piece_at(sq).piece_type, 0) for sq in board.piece_map())\n    return float(value)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the number of squares attacked by all pieces of the player to move, indicating board control.\"\n    attacked_squares = set()\n    for square in board.piece_map():\n        piece = board.piece_at(square)\n        if piece and piece.color == board.turn:\n            for move in board.legal_moves:\n                if move.from_square == square:\n                    attacked_squares.add(move.to_square)\n    return float(len(attacked_squares))\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the central control by counting pieces in the central squares (d4, d5, e4, e5).\"\n    central_squares = [chess.parse_square('d4'), chess.parse_square('d5'), chess.parse_square('e4'), chess.parse_square('e5')]\n    control_count = sum(1 for square in central_squares if board.piece_at(square) and board.piece_at(square).color == board.turn)\n    return float(control_count)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the difference between the number of pieces on the board.\"\n    white_piece_count = len([piece for piece in board.piece_map().values() if piece.color == chess.WHITE])\n    black_piece_count = len([piece for piece in board.piece_map().values() if piece.color == chess.BLACK])\n    return float(white_piece_count - black_piece_count)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces that are pinned against their own king.\"\n    pinned_pieces = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == board.turn and board.is_attacked_by(not piece.color, square):\n            attackers = board.attackers(not piece.color, square)\n            if any(board.piece_at(attacker).piece_type == chess.KING for attacker in attackers):\n                pinned_pieces += 1\n    return float(pinned_pieces)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the number of squares controlled by each side, highlighting influence on the board.\"\n    controlled_squares_white = len([square for square in board.piece_map() if board.is_attacked_by(chess.WHITE, square)])\n    controlled_squares_black = len([square for square in board.piece_map() if board.is_attacked_by(chess.BLACK, square)])\n    return float(controlled_squares_white - controlled_squares_black)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the total number of forks available for each side.\"\n    def count_forks(color):\n        fork_count = 0\n        for square in board.legal_moves:\n            if board.piece_at(square.from_square).color == color:\n                # Check potential captures\n                for target in board.attackers(not color, square.to_square):\n                    if board.piece_at(target).color != color:\n                        fork_count += 1\n        return fork_count\n\n    white_forks = count_forks(chess.WHITE)\n    black_forks = count_forks(chess.BLACK)\n    return float(white_forks - black_forks)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the potential passed pawns each side has.\"\n    def is_passed_pawn(square, color):\n        if color == chess.WHITE:\n            return all(board.piece_at(chess.square_file(square) + i) is None for i in range(1, 8) if chess.square_file(square) + i < 8)\n        else:\n            return all(board.piece_at(chess.square_file(square) - i) is None for i in range(1, 8) if chess.square_file(square) - i >= 0)\n    \n    white_passed = sum(1 for square in board.piece_map() if board.piece_map()[square].color == chess.WHITE and board.piece_map()[square].piece_type == chess.PAWN and is_passed_pawn(square, chess.WHITE))\n    black_passed = sum(1 for square in board.piece_map() if board.piece_map()[square].color == chess.BLACK and board.piece_map()[square].piece_type == chess.PAWN and is_passed_pawn(square, chess.BLACK))\n    \n    return float(white_passed - black_passed)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the king safety by checking the number of attacks on the king.\"\n    king_square = next(square for square, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color == board.turn)\n    return float(len(board.attackers(not board.turn, king_square)))\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the average distance of pieces from the opponent's king, indicating the offensive potential.\"\n    opponent_king_square = next(square for square, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color == chess.BLACK)\n    total_distance = sum(chess.square_distance(square, opponent_king_square) for square in board.piece_map() if board.piece_map()[square].color == chess.WHITE)\n    piece_count = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE)\n    return total_distance / piece_count if piece_count > 0 else 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the control of the 7th rank by both sides.\"\n    white_seventh_control = sum(1 for square in range(chess.A7, chess.H7 + 1) if board.is_attacked_by(chess.WHITE, square))\n    black_seventh_control = sum(1 for square in range(chess.A7, chess.H7 + 1) if board.is_attacked_by(chess.BLACK, square))\n    return float(white_seventh_control - black_seventh_control)\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the total number of backward pawns for both players.\"\n    backward_pawns = 0\n    for square in board.piece_map():\n        if board.piece_at(square).piece_type == chess.PAWN:\n            if (board.turn and chess.square_rank(square) < 5) or (not board.turn and chess.square_rank(square) > 2):\n                backward_pawns += 1\n    return float(backward_pawns)\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in the number of pieces on the 7th and 2nd ranks.\"\n    white_seventh = sum(1 for sq in range(56, 64) if board.piece_at(sq) and board.piece_at(sq).color == chess.WHITE)\n    black_second = sum(1 for sq in range(8, 16) if board.piece_at(sq) and board.piece_at(sq).color == chess.BLACK)\n    result = white_seventh - black_second\n    return float(result)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the total control of the edges of the board (1st and 8th ranks, 1st and 8th files).\"\n    edge_squares = [square for square in range(64) if chess.square_rank(square) in {0, 7} or chess.square_file(square) in {0, 7}]\n    white_control = sum(1 for square in edge_squares if board.is_attacked_by(chess.WHITE, square))\n    black_control = sum(1 for square in edge_squares if board.is_attacked_by(chess.BLACK, square))\n    return float(white_control - black_control)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the total piece activity based on the number of potential attacks by each color.\"\n    white_activity = sum(len(board.attackers(chess.WHITE, square)) for square in board.piece_map() if board.piece_map()[square].color == chess.WHITE)\n    black_activity = sum(len(board.attackers(chess.BLACK, square)) for square in board.piece_map() if board.piece_map()[square].color == chess.BLACK)\n    return float(white_activity - black_activity)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the number of potential passed pawns for each player.\"\n    passed_pawn_count = 0\n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.PAWN:\n            file = chess.square_file(square)\n            rank = chess.square_rank(square)\n            is_passed = True\n            for enemy_file in range(max(0, file - 1), min(7, file + 2)):\n                if board.piece_at(chess.square(enemy_file, rank + 1)) and \\\n                   board.piece_at(chess.square(enemy_file, rank + 1)).color != piece.color:\n                    is_passed = False\n                    break\n            passed_pawn_count += 1 if piece.color == chess.WHITE and is_passed else -1 if piece.color == chess.BLACK and is_passed else 0\n    return float(passed_pawn_count)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the number of pieces each player has on the 7th rank to evaluate pressure on the opponent.\"\n    white_7th_rank = sum(1 for sq in range(chess.A7, chess.H7 + 1) if board.piece_at(sq) and board.piece_at(sq).color == chess.WHITE)\n    black_7th_rank = sum(1 for sq in range(chess.A7, chess.H7 + 1) if board.piece_at(sq) and board.piece_at(sq).color == chess.BLACK)\n    result = white_7th_rank - black_7th_rank\n    return float(result)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the number of squares attacked by all pieces of each color.\"\n    def count_attacked_squares(color):\n        attacked_squares = set()\n        for move in board.legal_moves:\n            if board.piece_at(move.from_square).color == color:\n                attacked_squares.add(move.to_square)\n        return len(attacked_squares)\n    white_attacked = count_attacked_squares(chess.WHITE)\n    black_attacked = count_attacked_squares(chess.BLACK)\n    return float(white_attacked - black_attacked)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the ratio of pieces to total squares on the board, assessing overall control.\"\n    controlled_squares = sum(1 for square in chess.SQUARES if board.is_attacked_by(board.turn, square))\n    return float(controlled_squares / 64) if controlled_squares > 0 else 0.0\n",
    "def feature(board: chess.Board) -> float:\n    \"Evaluates the distance from the center for pieces on the board.\"\n    center_squares = {chess.D4, chess.D5, chess.E4, chess.E5}\n    def piece_distance(color):\n        distance = sum(chess.square_distance(square, center_square) \n                       for square in board.piece_map() \n                       if board.piece_map()[square].color == color \n                       for center_square in center_squares)\n        return distance\n\n    white_distance = piece_distance(chess.WHITE)\n    black_distance = piece_distance(chess.BLACK)\n    return float(black_distance - white_distance)\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the number of pieces that have influence on central squares (d4, d5, e4, e5).\"\n    central_squares = [chess.D4, chess.D5, chess.E4, chess.E5]\n    control = sum(1 for square in central_squares if board.is_attacked_by(chess.WHITE, square)) \\\n              - sum(1 for square in central_squares if board.is_attacked_by(chess.BLACK, square))\n    return float(control)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the imbalance of pawn structure based on doubled pawns.\"\n    def count_doubled_pawns(color):\n        pawn_files = [file for file in range(8) if board.piece_at(chess.square(file, 1 if color == chess.WHITE else 6)) == chess.PAWN]\n        return sum(1 for file in pawn_files if pawn_files.count(file) > 1)\n    white_doubled = count_doubled_pawns(chess.WHITE)\n    black_doubled = count_doubled_pawns(chess.BLACK)\n    return float(white_doubled - black_doubled)\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of pawns on the 4th rank or higher for both sides.\"\n    white_advanced_pawns = sum(1 for sq in board.piece_map().keys() \n                                if board.piece_at(sq).piece_type == chess.PAWN and chess.square_rank(sq) >= 4 and board.piece_at(sq).color == chess.WHITE)\n    black_advanced_pawns = sum(1 for sq in board.piece_map().keys() \n                                if board.piece_at(sq).piece_type == chess.PAWN and chess.square_rank(sq) >= 4 and board.piece_at(sq).color == chess.BLACK)\n    return float(white_advanced_pawns - black_advanced_pawns)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the total value of pieces that have potential to attack the enemy king.\"\n    result = 0.0\n    for sq in board.piece_map():\n        piece = board.piece_at(sq)\n        if piece.color == board.turn:  # Only consider the current player's pieces\n            result += len(board.attackers(not board.turn, chess.KING))  # Count potential attackers on the enemy king\n    return result\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the number of possible forks available to each side from knights.\"\n    white_knight_forks = sum(1 for move in board.legal_moves if board.piece_map()[move.from_square].piece_type == chess.KNIGHT and len(board.attackers(board.piece_map()[move.from_square].color, move.to_square)) > 1)\n    black_knight_forks = sum(1 for move in board.legal_moves if board.piece_map()[move.from_square].piece_type == chess.KNIGHT and len(board.attackers(board.piece_map()[move.from_square].color, move.to_square)) > 1)\n    return float(white_knight_forks - black_knight_forks)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the total number of pieces controlled by each player.\"\n    white_controlled = sum(1 for square in board.piece_map() if board.piece_at(square).color == chess.WHITE and board.attackers(chess.WHITE, square))\n    black_controlled = sum(1 for square in board.piece_map() if board.piece_at(square).color == chess.BLACK and board.attackers(chess.BLACK, square))\n    return float(white_controlled - black_controlled)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the material difference considering the positions of pieces in the opponent's back rank.\"\n    material_values = {\n        chess.PAWN: 1,\n        chess.KNIGHT: 3,\n        chess.BISHOP: 3,\n        chess.ROOK: 5,\n        chess.QUEEN: 9,\n        chess.KING: 0\n    }\n    white_back_rank_material = sum(material_values[piece.piece_type] for square, piece in board.piece_map().items() \n                                    if piece.color == chess.WHITE and chess.square_rank(square) == 0)\n    black_back_rank_material = sum(material_values[piece.piece_type] for square, piece in board.piece_map().items() \n                                    if piece.color == chess.BLACK and chess.square_rank(square) == 7)\n    return float(white_back_rank_material - black_back_rank_material)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the total number of pieces remaining for each player to indicate material strength.\"\n    white_pieces = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE)\n    black_pieces = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK)\n    result = float(white_pieces - black_pieces)\n    return result\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the number of vulnerable pieces for the current player's turn, assessing potential threats.\"\n    vulnerable_count = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == board.turn:\n            if not board.is_attacked_by(not board.turn, square):\n                vulnerable_count += 1\n    return float(vulnerable_count)\n\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the pressure on the center squares based on piece positioning.\"\n    center_squares = [chess.D4, chess.D5, chess.E4, chess.E5]\n    white_pressure = sum(1 for square in center_squares if board.is_attacked_by(chess.WHITE, square))\n    black_pressure = sum(1 for square in center_squares if board.is_attacked_by(chess.BLACK, square))\n    return float(white_pressure - black_pressure)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Evaluates the number of pieces attacking the back rank of the opponent.\"\n    back_rank_attacks = sum(1 for square in range(0, 8) if board.is_attacked_by(board.turn, chess.square(square, 0 if board.turn else 7)))\n    return float(back_rank_attacks)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of isolated pawns on the board for both sides.\"\n    isolated_pawns = 0\n    for square in board.piece_map():\n        piece = board.piece_at(square)\n        if piece and piece.piece_type == chess.PAWN:\n            file_neighbors = [(square - 1, square + 1)]\n            if all(board.piece_at(s) is None for s in file_neighbors[0]):\n                isolated_pawns += 1 if piece.color == chess.WHITE else -1\n    return float(isolated_pawns)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the control of the center by counting pieces occupying central squares for both sides.\"\n    central_squares = [chess.D4, chess.D5, chess.E4, chess.E5]\n    white_control = sum(1 for square in central_squares if board.piece_at(square) and board.piece_at(square).color == chess.WHITE)\n    black_control = sum(1 for square in central_squares if board.piece_at(square) and board.piece_at(square).color == chess.BLACK)\n    return float(white_control - black_control)\n\n\n",
    "def feature(board: chess.Board) -> float:\n    'Calculates the piece safety rating for each color based on potential attacks.'\n    safety_score = {chess.WHITE: 0, chess.BLACK: 0}\n    for square, piece in board.piece_map().items():\n        attacks = len(board.attacks(square))\n        if piece.color == chess.WHITE:\n            safety_score[chess.WHITE] += (6 - attacks)\n        else:\n            safety_score[chess.BLACK] += (6 - attacks)\n    return float(safety_score[chess.WHITE] - safety_score[chess.BLACK])\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts potential checkmating threats by considering movable pieces towards the opponent's back rank.\"\n    threats = 0\n    for square in board.piece_map():\n        piece = board.piece_map()[square]\n        if piece.color == board.turn:\n            # Count legitimate moves that can threaten check\n            for move in board.legal_moves:\n                if move.to_square in (chess.A8, chess.B8, chess.C8, chess.D8, chess.E8, chess.F8, chess.G8, chess.H8) and board.is_checkmate():\n                    threats += 1\n    return float(threats)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the number of pieces on open files for both players.\"\n    open_files = [file for file in range(8) if all(board.piece_at(chess.square(file, rank)) is None for rank in range(8))]\n    white_open_file_pieces = sum(1 for square in board.piece_map() if square in [chess.square(file, rank) for file in open_files for rank in range(8)] and board.piece_map()[square].color == chess.WHITE)\n    black_open_file_pieces = sum(1 for square in board.piece_map() if square in [chess.square(file, rank) for file in open_files for rank in range(8)] and board.piece_map()[square].color == chess.BLACK)\n    return float(white_open_file_pieces - black_open_file_pieces)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the potential for pawn promotion by counting pawns on the 7th rank for both sides.\"\n    white_pawns_on_7th = sum(1 for square in range(56, 64) if board.piece_at(square) and board.piece_at(square).color == chess.WHITE and board.piece_at(square).piece_type == chess.PAWN)\n    black_pawns_on_7th = sum(1 for square in range(8, 16) if board.piece_at(square) and board.piece_at(square).color == chess.BLACK and board.piece_at(square).piece_type == chess.PAWN)\n    return float(white_pawns_on_7th - black_pawns_on_7th)\n\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of pawns on the 7th rank, indicating potential promotion threats.\"\n    white_pawns_on_seventh = sum(1 for square in board.piece_map() if \n                                   board.piece_map()[square].color == chess.WHITE and chess.square_rank(square) == 6)\n    black_pawns_on_seventh = sum(1 for square in board.piece_map() if \n                                   board.piece_map()[square].color == chess.BLACK and chess.square_rank(square) == 1)\n    return float(white_pawns_on_seventh - black_pawns_on_seventh)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the king safety by counting how many squares around the king are attacked.\"\n    king_square = None\n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.KING and piece.color == board.turn:\n            king_square = square\n            break\n    if king_square is None:\n        return 0.0\n    safety_count = sum(1 for square in chess.SQUARES if board.is_attacked_by(not board.turn, square) and chess.square_distance(king_square, square) == 1)\n    return float(safety_count)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the king's safety by counting the number of squares the king can move to that are not attacked.\"\n    king_square = board.king(chess.WHITE) if board.turn else board.king(chess.BLACK)\n    safe_moves = len([square for square in board.legal_moves if square.to_square != king_square and not board.is_attacked_by(not board.turn, square.to_square)])\n    return float(safe_moves)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the number of unprotected pieces for both sides.\"\n    def count_unprotected(color):\n        unprotected = 0\n        for square, piece in board.piece_map().items():\n            if piece.color == color:\n                if not any(board.is_attacked_by(not color, attacker) for attacker in board.attackers(not color, square)):\n                    unprotected += 1\n        return unprotected\n    white_unprotected = count_unprotected(chess.WHITE)\n    black_unprotected = count_unprotected(chess.BLACK)\n    return float(white_unprotected - black_unprotected)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the average distance of pieces of each color from the opponent's king.\"\n    def average_distance(color):\n        opponent_king_square = next(square for square in board.piece_map() if board.piece_map()[square].color != color and board.piece_map()[square].piece_type == chess.KING)\n        total_distance = sum(chess.square_distance(square, opponent_king_square) for square in board.piece_map() if board.piece_map()[square].color == color)\n        piece_count = sum(1 for square in board.piece_map() if board.piece_map()[square].color == color)\n        return total_distance / piece_count if piece_count > 0 else 0\n\n    white_distance = average_distance(chess.WHITE)\n    black_distance = average_distance(chess.BLACK)\n    return float(black_distance - white_distance)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of kingside and queenside castling rights.\"\n    white_castle_rights = int(board.has_castling_rights(chess.WHITE))\n    black_castle_rights = int(board.has_castling_rights(chess.BLACK))\n    return float(white_castle_rights - black_castle_rights)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the coordination of knights based on their proximity to each other.\"\n    knight_positions = [square for square in board.piece_map() if board.piece_map()[square].piece_type == chess.KNIGHT]\n    knight_distance = sum(chess.square_distance(knight_positions[i], knight_positions[j]) for i in range(len(knight_positions)) for j in range(i + 1, len(knight_positions)))\n    return float(knight_distance)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of back rank threats each side has against the opponent.\"\n    white_back_rank_threats = sum(1 for square in range(0, 8) if board.is_attacked_by(chess.BLACK, square) and chess.square_rank(square) == 0)\n    black_back_rank_threats = sum(1 for square in range(56, 64) if board.is_attacked_by(chess.WHITE, square) and chess.square_rank(square) == 7)\n    return float(white_back_rank_threats - black_back_rank_threats)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of grid squares occupied by pieces of each color.\"\n    white_controlled_squares = len([1 for square in board.piece_map() if board.piece_map()[square].color == chess.WHITE])\n    black_controlled_squares = len([1 for square in board.piece_map() if board.piece_map()[square].color == chess.BLACK])\n    return float(white_controlled_squares - black_controlled_squares)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the total number of Pawns each player has advanced past the 4th rank.\"\n    white_advanced = sum(1 for square in board.piece_map() if board.piece_at(square).color == chess.WHITE and chess.square_rank(square) > 3)\n    black_advanced = sum(1 for square in board.piece_map() if board.piece_at(square).color == chess.BLACK and chess.square_rank(square) < 4)\n    return float(white_advanced - black_advanced)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the total potential for pawn structure weaknesses (isolated, doubled pawns).\"\n    isolated_pawns = 0\n    doubled_pawns = 0\n    for file in range(8):\n        white_pawns = sum(1 for rank in range(8) if board.piece_at(chess.square(file, rank)) and \n                                                   board.piece_at(chess.square(file, rank)).piece_type == chess.PAWN and \n                                                   board.piece_at(chess.square(file, rank)).color == chess.WHITE)\n        black_pawns = sum(1 for rank in range(8) if board.piece_at(chess.square(file, rank)) and \n                                                   board.piece_at(chess.square(file, rank)).piece_type == chess.PAWN and \n                                                   board.piece_at(chess.square(file, rank)).color == chess.BLACK)\n        if white_pawns > 1:\n            doubled_pawns += (white_pawns - 1)\n        if black_pawns > 1:\n            doubled_pawns += (black_pawns - 1)\n        if (white_pawns == 1 and (file == 0 or board.piece_at(chess.square(file-1, 0)) is None) and \n            (file == 7 or board.piece_at(chess.square(file+1, 0)) is None)):\n            isolated_pawns += 1\n        if (black_pawns == 1 and (file == 0 or board.piece_at(chess.square(file-1, 7)) is None) and \n            (file == 7 or board.piece_at(chess.square(file+1, 7)) is None)):\n            isolated_pawns += 1\n    return float(isolated_pawns - doubled_pawns)\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the total number of squares that are attacked by the most active piece from each player.\"\n    highest_attack_pieces_white = max([len(board.attackers(chess.WHITE, sq)) for sq in board.piece_map() if board.piece_map()[sq].color == chess.WHITE], default=0)\n    highest_attack_pieces_black = max([len(board.attackers(chess.BLACK, sq)) for sq in board.piece_map() if board.piece_map()[sq].color == chess.BLACK], default=0)\n    result = highest_attack_pieces_white - highest_attack_pieces_black\n    return float(result)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of pawn breaks available for each side.\"\n    def pawn_breaks(color):\n        count = 0\n        for square, piece in board.piece_map().items():\n            if piece.color == color and piece.piece_type == chess.PAWN:\n                if (color == chess.WHITE and board.piece_at(square + 8) is None and \n                    (board.piece_at(square + 7) is not None and board.piece_at(square + 7).color != color)):\n                    count += 1\n                if (color == chess.BLACK and board.piece_at(square - 8) is None and \n                    (board.piece_at(square - 7) is not None and board.piece_at(square - 7).color != color)):\n                    count += 1\n        return count\n\n    white_breaks = pawn_breaks(chess.WHITE)\n    black_breaks = pawn_breaks(chess.BLACK)\n    return float(white_breaks - black_breaks)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces that are currently pinned.\"\n    pinned_count = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == board.turn:\n            for attacker in board.attackers(not board.turn, square):\n                if board.piece_at(attacker).piece_type in [chess.ROOK, chess.QUEEN]:\n                    pinned_count += 1\n                    break\n    return float(pinned_count)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the total piece value for both sides separately and returns the ratio of White to Black value.\"\n    white_value = sum(piece.piece_type for piece in board.piece_map().values() if piece.color == chess.WHITE)\n    black_value = sum(piece.piece_type for piece in board.piece_map().values() if piece.color == chess.BLACK)\n    return white_value / (black_value + 1e-5)  # Avoid division by zero\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the number of pawn structures for both sides, helping to identify positional weaknesses.\"\n    white_pawn_structure = sum(board.piece_at(sq) is not None and board.piece_at(sq).piece_type == chess.PAWN for sq in board.piece_map() if board.piece_map()[sq].color == chess.WHITE)\n    black_pawn_structure = sum(board.piece_at(sq) is not None and board.piece_at(sq).piece_type == chess.PAWN for sq in board.piece_map() if board.piece_map()[sq].color == chess.BLACK)\n    result = float(white_pawn_structure - black_pawn_structure)\n    return result\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of discovered attacks available for each player, indicating tactical opportunities.\"\n    white_discovered = sum(1 for move in board.legal_moves if board.is_attacked_by(chess.WHITE, move.to_square))\n    black_discovered = sum(1 for move in board.legal_moves if board.is_attacked_by(chess.BLACK, move.to_square))\n    return float(white_discovered - black_discovered)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces out of the back rank for each side.\"\n    white_ranked = sum(1 for square in range(0, 8) if board.piece_at(chess.square(square, 0)) and board.piece_at(chess.square(square, 0)).color == chess.WHITE)\n    black_ranked = sum(1 for square in range(0, 8) if board.piece_at(chess.square(square, 7)) and board.piece_at(chess.square(square, 7)).color == chess.BLACK)\n    return float(white_ranked - black_ranked)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the number of forks possible with knights for each side.\"\n    def count_knight_forks(color):\n        knight_squares = [square for square in board.piece_map() if board.piece_map()[square].color == color and board.piece_map()[square].piece_type == chess.KNIGHT]\n        forks = 0\n        for knight_square in knight_squares:\n            potential_targets = [square for square in board.piece_map() if board.piece_map()[square].color != color and square not in knight_squares]\n            if len(potential_targets) >= 2:\n                forks += 1\n        return forks\n\n    white_forks = count_knight_forks(chess.WHITE)\n    black_forks = count_knight_forks(chess.BLACK)\n    return float(white_forks - black_forks)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the phases of the game based on piece count and positioning.\"\n    piece_count = len(board.piece_map())\n    if piece_count > 30:\n        return 1.0  # Early game\n    elif piece_count > 15:\n        return 0.5  # Middle game\n    else:\n        return 0.0  # Endgame\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the number of pieces in the opponent's half of the board.\"\n    opponent_color = chess.BLACK if board.turn else chess.WHITE\n    opponent_pieces_in_half = sum(1 for square, piece in board.piece_map().items() if piece.color == opponent_color and chess.square_rank(square) >= 4)\n    return float(opponent_pieces_in_half)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of squares that are defended by more than one piece for the player to move.\"\n    defended_count = 0\n    for square in board.piece_map():\n        if board.is_attacked_by(board.turn, square):\n            attackers = len(board.attackers(board.turn, square))\n            if attackers > 1:\n                defended_count += 1\n    return float(defended_count)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of squares under attack by each side.\"\n    def attack_control(color):\n        return sum(1 for square in board.piece_map() if board.is_attacked_by(color, square))\n    \n    white_attack = attack_control(chess.WHITE)\n    black_attack = attack_control(chess.BLACK)\n    return float(white_attack - black_attack)\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the total number of piece types of each color on the board.\"\n    white_types = len(set(piece.piece_type for piece in board.piece_map().values() if piece.color == chess.WHITE))\n    black_types = len(set(piece.piece_type for piece in board.piece_map().values() if piece.color == chess.BLACK))\n    return float(white_types - black_types)\n\n",
    "def feature(board: chess.Board) -> float:\n    'Calculates the potential advancement of the most advanced pawn for each side.'\n    white_advanced = max((chess.square_rank(square) for square in board.piece_map() if board.piece_at(square).color == chess.WHITE and board.piece_at(square).piece_type == chess.PAWN), default=-1)\n    black_advanced = max((7 - chess.square_rank(square) for square in board.piece_map() if board.piece_at(square).color == chess.BLACK and board.piece_at(square).piece_type == chess.PAWN), default=-1)\n    return float(white_advanced - black_advanced)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the difference between the number of doubled pawns for each side.\"\n    white_doubled = sum(1 for square in range(8) if board.piece_at(chess.square(square, 1)) and board.piece_at(chess.square(square, 1)).color == chess.WHITE and board.piece_at(chess.square(square, 0)) is not None)\n    black_doubled = sum(1 for square in range(8) if board.piece_at(chess.square(square, 6)) and board.piece_at(chess.square(square, 6)).color == chess.BLACK and board.piece_at(chess.square(square, 7)) is not None)\n    return float(white_doubled - black_doubled)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the distance of each player's pieces from the center (d4, d5, e4, e5) and returns the difference.\"\n    central_squares = [chess.parse_square('d4'), chess.parse_square('d5'), chess.parse_square('e4'), chess.parse_square('e5')]\n    white_distance = sum(chess.square_distance(sq, csq) for sq in board.piece_map() if board.piece_at(sq).color == chess.WHITE for csq in central_squares)\n    black_distance = sum(chess.square_distance(sq, csq) for sq in board.piece_map() if board.piece_at(sq).color == chess.BLACK for csq in central_squares)\n    return black_distance - white_distance\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the difference in king safety based on the number of attacking squares around each king.\"\n    white_king_square = next(square for square in board.piece_map() if board.piece_map()[square].color == chess.WHITE and board.piece_map()[square].piece_type == chess.KING)\n    black_king_square = next(square for square in board.piece_map() if board.piece_map()[square].color == chess.BLACK and board.piece_map()[square].piece_type == chess.KING)\n\n    white_attack_count = sum(1 for square in chess.SQUARES_180 if board.is_attacked_by(chess.BLACK, square) and board.is_attacked_by(chess.BLACK, white_king_square))\n    black_attack_count = sum(1 for square in chess.SQUARES_180 if board.is_attacked_by(chess.WHITE, square) and board.is_attacked_by(chess.WHITE, black_king_square))\n\n    return float(white_attack_count - black_attack_count)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the presence of active pieces near the opponent's king.\"\n    white_threats = sum(1 for square in board.piece_map() if board.piece_map()[square].color == chess.WHITE and \n                        board.is_attacked_by(chess.BLACK, square))\n    black_threats = sum(1 for square in board.piece_map() if board.piece_map()[square].color == chess.BLACK and \n                        board.is_attacked_by(chess.WHITE, square))\n    return float(white_threats - black_threats)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the overall imbalance in piece value on the board.\"\n    piece_values = {chess.PAWN: 1, chess.KNIGHT: 3, chess.BISHOP: 3, chess.ROOK: 5, chess.QUEEN: 9, chess.KING: 0}\n    white_value = sum(piece_values[piece.piece_type] for piece in board.piece_map().values() if piece.color == chess.WHITE)\n    black_value = sum(piece_values[piece.piece_type] for piece in board.piece_map().values() if piece.color == chess.BLACK)\n    return float(white_value - black_value)\n\n",
    "def feature(board: chess.Board) -> float:\n    'Calculates the total number of pieces on the board, representing activity level.'\n    total_pieces = len(board.piece_map())\n    return float(total_pieces)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the number of pieces pinned against the king.\"\n    pinned_count = sum(1 for square in board.piece_map() if board.is_attacked_by(chess.WHITE, square) and board.piece_at(square).color == chess.BLACK)\n    return float(pinned_count)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the number of exposed kings for each side.\"\n    white_exposed = int(board.is_check() and not board.is_checkmate())\n    black_exposed = int(board.is_check() and not board.is_checkmate())\n    return float(white_exposed - black_exposed)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of potential forks available for each side.\"\n    white_forks = 0\n    black_forks = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == chess.WHITE:\n            if len(board.attackers(chess.BLACK, square)) > 1:\n                white_forks += 1\n        elif piece.color == chess.BLACK:\n            if len(board.attackers(chess.WHITE, square)) > 1:\n                black_forks += 1\n    return float(white_forks - black_forks)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the material advantage considering only minor pieces (knights and bishops).\"\n    material_values = {\n        chess.KNIGHT: 3,\n        chess.BISHOP: 3,\n    }\n    def calculate_minor_material(color):\n        return sum(material_values.get(piece.piece_type, 0) for piece in board.piece_map().values() if piece.color == color)\n    \n    white_minor_material = calculate_minor_material(chess.WHITE)\n    black_minor_material = calculate_minor_material(chess.BLACK)\n    \n    return float(white_minor_material - black_minor_material)\n\n",
    "def feature(board: chess.Board) -> float:\n    'Measures the distance of each side\u2019s pieces to the opponent\u2019s back rank.'\n    distance_white = sum(7 - chess.square_rank(square) for square in board.piece_map() if board.piece_map()[square].color == chess.WHITE)\n    distance_black = sum(chess.square_rank(square) for square in board.piece_map() if board.piece_map()[square].color == chess.BLACK)\n    return float(distance_white - distance_black)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the average piece distance to the opponent's king.\"\n    total_distance = 0\n    opponent_king_square = next(square for square, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color != board.turn)\n    for square in board.piece_map():\n        total_distance += chess.square_distance(square, opponent_king_square)\n    return total_distance / len(board.piece_map()) if board.piece_map() else 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    'Counts the number of pieces of each color in the opponent\u2019s half of the board.'\n    white_pieces_in_opponent_half = sum(1 for square, piece in board.piece_map().items() if piece.color == chess.WHITE and chess.square_rank(square) > 3)\n    black_pieces_in_opponent_half = sum(1 for square, piece in board.piece_map().items() if piece.color == chess.BLACK and chess.square_rank(square) < 4)\n    result = float(white_pieces_in_opponent_half - black_pieces_in_opponent_half)\n    return result\n\n",
    "def feature(board: chess.Board) -> float:\n    'Counts the number of attempted checks by each side in the current position.'\n    white_checks = sum(1 for move in board.legal_moves \n                       if board.is_check() and board.is_attacked_by(chess.BLACK, move.to_square))\n    black_checks = sum(1 for move in board.legal_moves \n                       if board.is_check() and board.is_attacked_by(chess.WHITE, move.to_square))\n    return float(white_checks - black_checks)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in the number of pieces on the back ranks of both sides.\"\n    white_back_rank = sum(1 for square in chess.SQUARES_180 if board.piece_at(square) and board.piece_at(square).color == chess.WHITE and chess.square_rank(square) == 0)\n    black_back_rank = sum(1 for square in chess.SQUARES_180 if board.piece_at(square) and board.piece_at(square).color == chess.BLACK and chess.square_rank(square) == 7)\n    return float(white_back_rank - black_back_rank)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the total number of squares where each player's pieces can move, indicating mobility.\"\n    white_mobility = len(list(board.legal_moves)) if board.turn else 0\n    black_mobility = len(list(board.legal_moves)) if not board.turn else 0\n    return float(white_mobility - black_mobility)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the total value of all pieces in terms of piece activity, based on their mobility.\"\n    piece_activity_values = {chess.PAWN: 1, chess.KNIGHT: 3, chess.BISHOP: 3, \n                             chess.ROOK: 5, chess.QUEEN: 9, chess.KING: 0}\n    activity_value = 0\n    for piece in board.piece_map().values():\n        mobility = len(list(board.legal_moves))\n        activity_value += piece_activity_values[piece.piece_type] * mobility if piece.color == chess.WHITE else -piece_activity_values[piece.piece_type] * mobility\n    return float(activity_value)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the total value of pieces each side has advanced past the 4th rank.\"\n    piece_values = {chess.PAWN: 1, chess.KNIGHT: 3, chess.BISHOP: 3, chess.ROOK: 5, chess.QUEEN: 9, chess.KING: 0}\n    white_advanced_value = sum(piece_values[piece.piece_type] for square, piece in board.piece_map().items() if piece.color == chess.WHITE and chess.square_rank(square) > 3)\n    black_advanced_value = sum(piece_values[piece.piece_type] for square, piece in board.piece_map().items() if piece.color == chess.BLACK and chess.square_rank(square) < 4)\n\n    return float(white_advanced_value - black_advanced_value)\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of pinned pieces around both kings.\"\n    def count_pinned_around_king(color):\n        king_square = next(square for square in board.piece_map() if board.piece_map()[square].piece_type == chess.KING and board.piece_map()[square].color == color)\n        pinned_count = 0\n        for square in board.piece_map():\n            if board.piece_map()[square].color == color and board.is_attacked_by(not color, square):\n                pinned_count += 1\n        return pinned_count\n\n    white_pinned_around_king = count_pinned_around_king(chess.WHITE)\n    black_pinned_around_king = count_pinned_around_king(chess.BLACK)\n    return float(white_pinned_around_king - black_pinned_around_king)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of doubled pawns for each side.\"\n    white_doubled_pawns = sum(1 for rank in range(8) for file in range(8) if board.piece_at(chess.square(file, rank)) == chess.PAWN and \n                                 len([sq for sq in board.piece_map() if chess.square_file(sq) == file and board.piece_at(sq).color == chess.WHITE]) > 1)\n    black_doubled_pawns = sum(1 for rank in range(8) for file in range(8) if board.piece_at(chess.square(file, rank)) == chess.PAWN and \n                                 len([sq for sq in board.piece_map() if chess.square_file(sq) == file and board.piece_at(sq).color == chess.BLACK]) > 1)\n    return float(white_doubled_pawns - black_doubled_pawns)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces attacking the opponent's king.\"\n    opponent_king_square = next((square for square, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color != board.turn), None)\n    if opponent_king_square is None:\n        return 0.0\n    attack_count = sum(1 for square in board.piece_map() if board.piece_map()[square].color == board.turn and board.is_attacked_by(board.turn, opponent_king_square))\n    return float(attack_count)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the total number of squares controlled by each side.\"\n    white_control = sum(1 for square in range(64) if board.is_attacked_by(chess.WHITE, square))\n    black_control = sum(1 for square in range(64) if board.is_attacked_by(chess.BLACK, square))\n    return float(white_control - black_control)\n\n",
    "def feature(board: chess.Board) -> float:\n    'Determines the average rank of pieces for both sides to evaluate their control of the board.'\n    total_white_rank = sum(chess.square_rank(square) for square in board.piece_map() if board.piece_map()[square].color == chess.WHITE)\n    total_black_rank = sum(chess.square_rank(square) for square in board.piece_map() if board.piece_map()[square].color == chess.BLACK)\n    white_avg_rank = total_white_rank / (len(board.piece_map()) / 2) if board.piece_map() else 0\n    black_avg_rank = total_black_rank / (len(board.piece_map()) / 2) if board.piece_map() else 0\n    return float(white_avg_rank - black_avg_rank)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the ratio of pieces each player has compared to the total piece count.\"\n    total_pieces = len(board.piece_map())\n    white_piece_count = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE)\n    return float(white_piece_count / total_pieces) if total_pieces > 0 else 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the vulnerability of respective kings based on piece proximity.\"\n    white_king_square = next(square for square, piece in board.piece_map().items() if piece.color == chess.WHITE and piece.piece_type == chess.KING)\n    black_king_square = next(square for square, piece in board.piece_map().items() if piece.color == chess.BLACK and piece.piece_type == chess.KING)\n\n    white_proximity = sum(chess.square_distance(white_king_square, square) for square, piece in board.piece_map().items() if piece.color == chess.BLACK)\n    black_proximity = sum(chess.square_distance(black_king_square, square) for square, piece in board.piece_map().items() if piece.color == chess.WHITE)\n\n    return float(black_proximity - white_proximity)\n",
    "def feature(board: chess.Board) -> float:\n    \"Evaluates the king's safety by counting the number of attacking pieces near the king.\"\n    king_square = next(square for square, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color == board.turn)\n    attackers_count = len(board.attackers(not board.turn, king_square))\n    return float(attackers_count)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of squares available to knights for each side.\"\n    def knight_moves(square):\n        knight_moves = [\n            (2, 1), (2, -1), (-2, 1), (-2, -1),\n            (1, 2), (1, -2), (-1, 2), (-1, -2)\n        ]\n        return sum(1 for dx, dy in knight_moves if 0 <= chess.square_file(square) + dx < 8 and \n                   0 <= chess.square_rank(square) + dy < 8)\n\n    white_knight_squares = sum(knight_moves(square) for square in board.piece_map() if board.piece_map()[square].color == chess.WHITE and board.piece_map()[square].piece_type == chess.KNIGHT)\n    black_knight_squares = sum(knight_moves(square) for square in board.piece_map() if board.piece_map()[square].color == chess.BLACK and board.piece_map()[square].piece_type == chess.KNIGHT)\n    return float(white_knight_squares - black_knight_squares)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the number of doubled pawns for each side, indicating structural weaknesses.\"\n    pawn_structure = {chess.WHITE: [], chess.BLACK: []}\n    for square in board.piece_map():\n        piece = board.piece_at(square)\n        if piece and piece.piece_type == chess.PAWN:\n            pawn_structure[piece.color].append(chess.square_file(square))\n    \n    white_doubled = sum(pawn_structure[chess.WHITE].count(file) > 1 for file in set(pawn_structure[chess.WHITE]))\n    black_doubled = sum(pawn_structure[chess.BLACK].count(file) > 1 for file in set(pawn_structure[chess.BLACK]))\n    return float(black_doubled - white_doubled)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the number of available checks the current player can deliver.\"\n    checks = sum(1 for move in board.legal_moves if board.is_check())\n    return float(checks)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the material disparity of minor pieces (knights and bishops) for both sides.\"\n    material_values = {chess.KNIGHT: 3, chess.BISHOP: 3}\n    white_minor_material = sum(material_values[piece.piece_type] for piece in board.piece_map().values() if piece.color == chess.WHITE and piece.piece_type in [chess.KNIGHT, chess.BISHOP])\n    black_minor_material = sum(material_values[piece.piece_type] for piece in board.piece_map().values() if piece.color == chess.BLACK and piece.piece_type in [chess.KNIGHT, chess.BISHOP])\n    return float(white_minor_material - black_minor_material)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the amount of space each side controls by measuring their pawn formation.\"\n    space_control = 0\n    for square in board.piece_map():\n        piece = board.piece_map()[square]\n        if piece.color == board.turn and piece.piece_type == chess.PAWN:\n            file_control = chess.square_file(square)\n            if (piece.color == chess.WHITE and file_control > 2) or (piece.color == chess.BLACK and file_control < 5):\n                space_control += 1\n    return float(space_control)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the number of potential discovered checks available to both players.\"\n    discovered_checks = 0\n    for move in board.legal_moves:\n        board.push(move)\n        if board.is_check():\n            discovered_checks += 1\n        board.pop()\n    return float(discovered_checks)\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the difference in the average distance of pieces from their respective back ranks.\"\n    white_distances = [7 - chess.square_rank(square) for square in board.piece_map() if board.piece_map()[square].color == chess.WHITE]\n    black_distances = [chess.square_rank(square) for square in board.piece_map() if board.piece_map()[square].color == chess.BLACK]\n    avg_white_distance = (sum(white_distances) / len(white_distances)) if white_distances else 0\n    avg_black_distance = (sum(black_distances) / len(black_distances)) if black_distances else 0\n    return float(avg_white_distance - avg_black_distance)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Evaluates the average distance of all pieces from their respective kings to assess safety.\"\n    pieces = board.piece_map()\n    king_square = next(sq for sq,(piece) in pieces.items() if piece.piece_type == chess.KING and piece.color == board.turn)\n    distances = [chess.square_distance(sq, king_square) for sq, piece in pieces.items() if piece.color == board.turn]\n    result = sum(distances) / len(distances) if distances else 0.0\n    return float(result)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the total piece mobility by calculating the sum of legal moves available for each piece type.\"\n    mobility_score = sum(len(list(board.legal_moves)) for square, piece in board.piece_map().items())\n    return float(mobility_score)\n\n",
    "def feature(board: chess.Board) -> float:\n    'Measures the difference in the number of pawns each player has relative to total pieces.'\n    white_pawn_count = sum(1 for p in board.piece_map().values() if p.color == chess.WHITE and p.piece_type == chess.PAWN)\n    black_pawn_count = sum(1 for p in board.piece_map().values() if p.color == chess.BLACK and p.piece_type == chess.PAWN)\n    total_piece_count = len(board.piece_map())\n    if total_piece_count == 0:\n        return 0.0\n    return (white_pawn_count - black_pawn_count) / total_piece_count\n\n",
    "def feature(board: chess.Board) -> float:\n    'Calculates the average distance of pieces from their respective kings to assess piece coordination.'\n    def average_distance_to_king(color):\n        king_square = next(square for square in board.piece_map() if board.piece_at(square).color == color and board.piece_at(square).piece_type == chess.KING)\n        total_distance = sum(chess.square_distance(king_square, square) for square in board.piece_map() if board.piece_at(square).color == color)\n        piece_count = sum(1 for piece in board.piece_map().values() if piece.color == color)\n        return total_distance / piece_count if piece_count > 0 else 0\n\n    white_avg_distance = average_distance_to_king(chess.WHITE)\n    black_avg_distance = average_distance_to_king(chess.BLACK)\n    return float(white_avg_distance - black_avg_distance)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the distance of pawns from the promotion rank to evaluate their activity.\"\n    pawn_distance = sum(chess.square_rank(square) for square, piece in board.piece_map().items() if piece.piece_type == chess.PAWN)\n    return float(pawn_distance)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the difference in development of knights versus bishops in the current position.\"\n    def piece_development(color):\n        knights = sum(1 for piece in board.piece_map().values() if piece.color == color and piece.piece_type == chess.KNIGHT)\n        bishops = sum(1 for piece in board.piece_map().values() if piece.color == color and piece.piece_type == chess.BISHOP)\n        return knights - bishops\n\n    white_development = piece_development(chess.WHITE)\n    black_development = piece_development(chess.BLACK)\n    return float(white_development)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces in the center (d4, d5, e4, e5) for both sides.\"\n    center_squares = [chess.D4, chess.D5, chess.E4, chess.E5]\n    white_center_count = sum(1 for square in center_squares if board.piece_at(square) and board.piece_at(square).color == chess.WHITE)\n    black_center_count = sum(1 for square in center_squares if board.piece_at(square) and board.piece_at(square).color == chess.BLACK)\n    return float(white_center_count - black_center_count)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Assesses the potential for pawn promotion based on pawn positions.\"\n    white_pawn_promotions = sum(1 for square in board.piece_map() if board.piece_map()[square].color == chess.WHITE and chess.square_rank(square) >= 5)\n    black_pawn_promotions = sum(1 for square in board.piece_map() if board.piece_map()[square].color == chess.BLACK and chess.square_rank(square) <= 2)\n    return float(white_pawn_promotions - black_pawn_promotions)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the total number of pieces (excluding pawns) that have no legal moves.\"\n    immobile_count = sum(1 for square, piece in board.piece_map().items() if piece.piece_type != chess.PAWN and len(list(board.legal_moves)) == 0)\n    return float(immobile_count)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the longest distance of pieces from their respective kings, indicating vulnerability.\"\n    max_distance_white = max([chess.square_distance(board.king(chess.WHITE), square) for square in board.piece_map() if board.piece_map()[square].color == chess.WHITE], default=0)\n    max_distance_black = max([chess.square_distance(board.king(chess.BLACK), square) for square in board.piece_map() if board.piece_map()[square].color == chess.BLACK], default=0)\n    return float(max_distance_white - max_distance_black)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the total number of squares where a piece of the current player is attacking.\"\n    color = chess.WHITE if board.turn else chess.BLACK\n    attacking_squares = sum(1 for square in range(64) if board.is_attacked_by(color, square))\n    return float(attacking_squares)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces directly opposing each other on the same file.\"\n    opposing_pairs = 0\n    for file in range(8):\n        white_piece = None\n        black_piece = None\n        for rank in range(8):\n            piece = board.piece_at(chess.square(file, rank))\n            if piece:\n                if piece.color == chess.WHITE:\n                    white_piece = piece\n                else:\n                    black_piece = piece\n        if white_piece and black_piece:\n            opposing_pairs += 1\n    return float(opposing_pairs)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Estimates the board's open files by counting rook placements on open files.\"\n    open_file_count = 0\n    for file in range(8):\n        if not any(board.piece_at(chess.square(file, rank)) for rank in range(8)):\n            open_file_count += 1\n    return float(open_file_count)\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the average distance of pieces to their respective kings.\"\n    white_king_square = next(sq for sq, piece in board.piece_map().items() if piece.color == chess.WHITE and piece.piece_type == chess.KING)\n    black_king_square = next(sq for sq, piece in board.piece_map().items() if piece.color == chess.BLACK and piece.piece_type == chess.KING)\n    distance_sum = {chess.WHITE: 0, chess.BLACK: 0}\n    piece_count = {chess.WHITE: 0, chess.BLACK: 0}\n    for square, piece in board.piece_map().items():\n        if piece:\n            if piece.color == chess.WHITE:\n                distance_sum[chess.WHITE] += chess.square_distance(square, white_king_square)\n                piece_count[chess.WHITE] += 1\n            else:\n                distance_sum[chess.BLACK] += chess.square_distance(square, black_king_square)\n                piece_count[chess.BLACK] += 1\n    avg_distance_white = distance_sum[chess.WHITE] / (piece_count[chess.WHITE] + 1e-9)\n    avg_distance_black = distance_sum[chess.BLACK] / (piece_count[chess.BLACK] + 1e-9)\n    return float(avg_distance_white - avg_distance_black)\n\n",
    "def feature(board: chess.Board) -> float:\n    'Counts the total number of undefended pieces for each side.'\n    undefended_count = sum(1 for square, piece in board.piece_map().items() if piece.color == board.turn and len(board.attackers(not piece.color, square)) == 0)\n    return float(undefended_count)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the difference in pawn structure between players.\"\n    def pawn_structure(color):\n        pawn_structure_value = 0\n        for square in chess.SQUARES:\n            piece = board.piece_at(square)\n            if piece and piece.color == color and piece.piece_type == chess.PAWN:\n                if chess.square_rank(square) == 6:  # 7th rank for white\n                    pawn_structure_value += 1\n                elif chess.square_rank(square) == 1:  # 2nd rank for black\n                    pawn_structure_value += 1\n        return pawn_structure_value\n\n    white_structure = pawn_structure(chess.WHITE)\n    black_structure = pawn_structure(chess.BLACK)\n    return float(white_structure - black_structure)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of passed pawns for both sides.\"\n    white_passed = sum(1 for square in board.piece_map() if board.piece_at(square).color == chess.WHITE and is_passed_pawn(board, square))\n    black_passed = sum(1 for square in board.piece_map() if board.piece_at(square).color == chess.BLACK and is_passed_pawn(board, square))\n    return float(white_passed - black_passed)\n\ndef is_passed_pawn(board, square):\n    \"\"\" Helper function to check if a pawn is passed \"\"\"\n    piece = board.piece_at(square)\n    if piece.piece_type != chess.PAWN:\n        return False\n    if piece.color == chess.WHITE:\n        return all(board.piece_at(chess.square_file(square) + 8 * r) is None for r in range(1, 8) for file in range(chess.square_file(square)))\n    else: # BLACK\n        return all(board.piece_at(chess.square_file(square) - 8 * r) is None for r in range(1, 8) for file in range(chess.square_file(square)))\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the total number of open files available for rooks.\"\n    white_open_files = sum(1 for file in range(8) if all(board.piece_at(chess.square(file, rank)) is None for rank in range(8) if board.piece_at(chess.square(file, rank)) and board.piece_at(chess.square(file, rank)).color == chess.WHITE))\n    black_open_files = sum(1 for file in range(8) if all(board.piece_at(chess.square(file, rank)) is None for rank in range(8) if board.piece_at(chess.square(file, rank)) and board.piece_at(chess.square(file, rank)).color == chess.BLACK))\n    return float(white_open_files - black_open_files)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the average distance of each player's pieces to the opponent's king.\"\n    white_king_square = next(sq for sq, p in board.piece_map().items() if p.piece_type == chess.KING and p.color == chess.WHITE)\n    black_king_square = next(sq for sq, p in board.piece_map().items() if p.piece_type == chess.KING and p.color == chess.BLACK)\n    \n    white_distances = [chess.square_distance(sq, black_king_square) for sq, p in board.piece_map().items() if p.color == chess.WHITE]\n    black_distances = [chess.square_distance(sq, white_king_square) for sq, p in board.piece_map().items() if p.color == chess.BLACK]\n    \n    avg_white_distance = sum(white_distances) / len(white_distances) if white_distances else 0.0\n    avg_black_distance = sum(black_distances) / len(black_distances) if black_distances else 0.0\n    \n    return avg_white_distance - avg_black_distance\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Evaluates the total value of pieces that are currently under attack.\"\n    threatened_value = 0.0\n    pieces = board.piece_map()\n    \n    for square, piece in pieces.items():\n        if board.is_attacked_by(chess.BLACK if piece.color == chess.WHITE else chess.WHITE, square):\n            threatened_value += piece.piece_type\n\n    return threatened_value\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the number of pieces attacking the opponent's king, indicating threats.\"\n    white_king_square = next(square for square, piece in board.piece_map().items() if piece.color == chess.WHITE and piece.piece_type == chess.KING)\n    black_king_square = next(square for square, piece in board.piece_map().items() if piece.color == chess.BLACK and piece.piece_type == chess.KING)\n    white_attacks = len(board.attackers(chess.WHITE, black_king_square))\n    black_attacks = len(board.attackers(chess.BLACK, white_king_square))\n    return float(white_attacks - black_attacks)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the number of potential discovered checks from each side's pieces.\"\n    white_discovered_checks = sum(1 for square in chess.SQUARES if board.piece_at(square) and board.piece_at(square).color == chess.WHITE and len(list(board.legal_moves)) > 1)\n    black_discovered_checks = sum(1 for square in chess.SQUARES if board.piece_at(square) and board.piece_at(square).color == chess.BLACK and len(list(board.legal_moves)) > 1)\n    return float(white_discovered_checks - black_discovered_checks)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of doubled pawns for both sides.\"\n    def doubled_pawns(color):\n        return sum(1 for file in range(8) if board.piece_at(chess.parse_square(f'{chr(file + 97)}2')) and color == chess.WHITE and board.piece_at(chess.parse_square(f'{chr(file + 97)}7')) and color == chess.BLACK)\n\n    white_doubled = doubled_pawns(chess.WHITE)\n    black_doubled = doubled_pawns(chess.BLACK)\n    return float(white_doubled - black_doubled)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the number of threats each player has by counting the pieces that are attacking and defending key squares (like the opponent's pieces).\"\n    white_threats = sum(1 for square in board.piece_map() if board.piece_map()[square].color == chess.WHITE and any(board.is_attacked_by(chess.BLACK, tgt_square) for tgt_square in board.attackers(chess.BLACK, square)))\n    black_threats = sum(1 for square in board.piece_map() if board.piece_map()[square].color == chess.BLACK and any(board.is_attacked_by(chess.WHITE, tgt_square) for tgt_square in board.attackers(chess.WHITE, square)))\n    return float(white_threats - black_threats)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the total value of pieces each player has on the board, weighted by standard piece values.\"\n    piece_values = {chess.PAWN: 1, chess.KNIGHT: 3, chess.BISHOP: 3, chess.ROOK: 5, chess.QUEEN: 9, chess.KING: 0}\n    total_value = sum(piece_values[piece.piece_type] for piece in board.piece_map().values())\n    return float(total_value)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the total distance of all pieces from their initial squares for each side.\"\n    def total_distance(color):\n        distance = 0\n        for square in board.piece_map():\n            piece = board.piece_map()[square]\n            if piece.color == color:\n                initial_position = piece.piece_type * 8 + (chess.square_rank(square) if color == chess.WHITE else 7 - chess.square_rank(square))\n                distance += chess.square_distance(square, initial_position)\n        return distance\n\n    white_distance = total_distance(chess.WHITE)\n    black_distance = total_distance(chess.BLACK)\n    return float(white_distance - black_distance)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces each side has on the back rank to assess defensiveness.\"\n    white_back_rank = [chess.A1, chess.B1, chess.C1, chess.D1, chess.E1, chess.F1, chess.G1, chess.H1]\n    black_back_rank = [chess.A8, chess.B8, chess.C8, chess.D8, chess.E8, chess.F8, chess.G8, chess.H8]\n    white_back_rank_count = sum(1 for square in white_back_rank if board.piece_at(square) is not None)\n    black_back_rank_count = sum(1 for square in black_back_rank if board.piece_at(square) is not None)\n    return float(white_back_rank_count - black_back_rank_count)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the total number of moves leading to potential forks (where one piece threatens two).\"\n    fork_count = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == board.turn:\n            potential_moves = board.legal_moves\n            for move in potential_moves:\n                if move.from_square == square:\n                    # Simulate the move\n                    board.push(move)\n                    if len(board.attackers(not board.turn, move.to_square)) > 1:\n                        fork_count += 1\n                    board.pop()\n    return float(fork_count)\n\n",
    "def feature(board: chess.Board) -> float:\n    'Calculates the total material value of pieces attacking the opponent\u2019s most advanced pawn.'\n    most_advanced_pawn_square = None\n    for square in board.piece_map():\n        if board.piece_at(square).piece_type == chess.PAWN and board.piece_at(square).color == chess.BLACK:\n            if most_advanced_pawn_square is None or chess.square_rank(square) > chess.square_rank(most_advanced_pawn_square):\n                most_advanced_pawn_square = square\n                \n    if most_advanced_pawn_square is None:\n        return 0.0\n    \n    attacking_value = 0\n    for attacker in board.attackers(chess.WHITE, most_advanced_pawn_square):\n        attacking_value += board.piece_at(attacker).piece_type  # Use piece_type as numeric value\n    return float(attacking_value)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the total number of pieces on the board for each player.\"\n    white_piece_count = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE)\n    black_piece_count = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK)\n    return float(white_piece_count - black_piece_count)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces that can be developed to active positions.\"\n    active_pieces = 0\n    for square in board.piece_map():\n        piece = board.piece_map()[square]\n        if piece.color == chess.WHITE and (piece.piece_type in [chess.KNIGHT, chess.BISHOP] and (chess.square_file(square) in [1, 2, 5, 6] or chess.square_rank(square) in [0, 1, 6, 7])):\n            active_pieces += 1\n        elif piece.color == chess.BLACK and (piece.piece_type in [chess.KNIGHT, chess.BISHOP] and (chess.square_file(square) in [1, 2, 5, 6] or chess.square_rank(square) in [0, 1, 6, 7])):\n            active_pieces -= 1\n    return float(active_pieces)\n",
    "def feature(board: chess.Board) -> float:\n    \"Evaluates the activity of the rooks on the board.\"\n    def rook_activity(color):\n        activity_score = 0\n        for square, piece in board.piece_map().items():\n            if piece.color == color and piece.piece_type == chess.ROOK:\n                file_control = sum(1 for rank in range(8) if board.piece_at(chess.square(chess.square_file(square), rank)) is None)\n                activity_score += file_control\n        return activity_score\n\n    white_activity = rook_activity(chess.WHITE)\n    black_activity = rook_activity(chess.BLACK)\n    return float(white_activity - black_activity)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the potential pawn mobility for both players.\"\n    white_pawn_mobility = sum(1 for square in board.piece_map() if board.piece_map()[square].color == chess.WHITE and board.piece_map()[square].piece_type == chess.PAWN and board.is_attacked_by(chess.BLACK, square + 8))\n    black_pawn_mobility = sum(1 for square in board.piece_map() if board.piece_map()[square].color == chess.BLACK and board.piece_map()[square].piece_type == chess.PAWN and board.is_attacked_by(chess.WHITE, square - 8))\n    return float(white_pawn_mobility - black_pawn_mobility)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the total number of pieces attacking each player's king, indicating threats.\"\n    attackers_white = len(board.attackers(chess.WHITE, board.king(chess.WHITE)))\n    attackers_black = len(board.attackers(chess.BLACK, board.king(chess.BLACK)))\n    return float(attackers_white - attackers_black)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of undefended pieces on the board.\"\n    undefended_count = sum(1 for square, piece in board.piece_map().items() if piece.color == board.turn and not any(board.is_attacked_by(not piece.color, square) for attacked_square in board.attackers(not piece.color, square)))\n    return float(undefended_count)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the distribution of pieces in the back rank for both players.\"\n    white_back_rank = sum(1 for square in range(0, 8) if board.piece_at(chess.square(square, 0)) and board.piece_at(chess.square(square, 0)).color == chess.WHITE)\n    black_back_rank = sum(1 for square in range(0, 8) if board.piece_at(chess.square(square, 7)) and board.piece_at(chess.square(square, 7)).color == chess.BLACK)\n    return float(white_back_rank - black_back_rank)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the total number of potential captures per player.\"\n    capture_count = {chess.WHITE: 0, chess.BLACK: 0}\n    \n    for move in board.legal_moves:\n        if board.piece_at(move.to_square) is not None:\n            capture_count[board.piece_at(move.to_square).color] += 1\n    \n    return float(capture_count[chess.WHITE] - capture_count[chess.BLACK])\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the number of squares attacked by each side's pieces.\"\n    white_attacks = sum(len(board.attackers(chess.WHITE, square)) for square in board.piece_map() if board.piece_map()[square].color == chess.WHITE)\n    black_attacks = sum(len(board.attackers(chess.BLACK, square)) for square in board.piece_map() if board.piece_map()[square].color == chess.BLACK)\n    return float(white_attacks - black_attacks)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the mobility difference based on the number of legal moves available.\"\n    white_legal_moves = len(list(board.legal_moves))\n    board.turn = not board.turn  # Switch turn to count black moves\n    black_legal_moves = len(list(board.legal_moves))\n    board.turn = not board.turn  # Restore original turn\n    return float(white_legal_moves - black_legal_moves)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the pawn structure's strength by evaluating connected pawns.\"\n    def connected_pawns(color):\n        count = 0\n        for square in board.piece_map():\n            if board.piece_map()[square].color == color and board.piece_map()[square].piece_type == chess.PAWN:\n                if (board.piece_at(chess.square_file(square) - 1) and board.piece_at(chess.square_file(square) - 1).color == color) or (board.piece_at(chess.square_file(square) + 1) and board.piece_at(chess.square_file(square) + 1).color == color):\n                    count += 1\n        return count\n    \n    white_connected = connected_pawns(chess.WHITE)\n    black_connected = connected_pawns(chess.BLACK)\n    return float(white_connected - black_connected)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Evaluates the position by counting the number of pieces that are controlling key squares in enemy territory.\"\n    control_count = sum(1 for square in chess.SQUARES if chess.square_rank(square) > 4 and board.is_attacked_by(chess.WHITE, square)) \\\n                  - sum(1 for square in chess.SQUARES if chess.square_rank(square) < 4 and board.is_attacked_by(chess.BLACK, square))\n    return float(control_count)\n",
    "def feature(board: chess.Board) -> float:\n    'Calculates the total piece value of both sides.'\n    piece_value = {\n        chess.PAWN: 1,\n        chess.KNIGHT: 3,\n        chess.BISHOP: 3,\n        chess.ROOK: 5,\n        chess.QUEEN: 9,\n        chess.KING: 0\n    }\n    white_value = sum(piece_value[piece.piece_type] for piece in board.piece_map().values() if piece.color == chess.WHITE)\n    black_value = sum(piece_value[piece.piece_type] for piece in board.piece_map().values() if piece.color == chess.BLACK)\n    result = float(white_value - black_value)\n    return result\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Assesses the mobility of the king by counting legal squares it can move to.\"\n    king_square = next((square for square, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color == board.turn), None)\n    if king_square is None:\n        return 0.0\n    legal_moves_count = sum(1 for move in board.legal_moves if move.from_square == king_square)\n    return float(legal_moves_count)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in the number of pieces on the board for both sides.\"\n    white_piece_count = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE)\n    black_piece_count = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK)\n    return float(white_piece_count - black_piece_count)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the total number of pieces in the opponent's half of the board.\"\n    white_pieces_in_opponent_half = sum(1 for square, piece in board.piece_map().items() \n                                         if piece.color == chess.WHITE and chess.square_rank(square) > 3)\n    black_pieces_in_opponent_half = sum(1 for square, piece in board.piece_map().items() \n                                         if piece.color == chess.BLACK and chess.square_rank(square) < 4)\n    result = white_pieces_in_opponent_half - black_pieces_in_opponent_half\n    return float(result)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the number of squares attacked by each side's rooks.\"\n    white_rook_control = sum(1 for square in board.piece_map() if board.piece_map()[square].color == chess.WHITE and board.is_attacked_by(chess.WHITE, square))\n    black_rook_control = sum(1 for square in board.piece_map() if board.piece_map()[square].color == chess.BLACK and board.is_attacked_by(chess.BLACK, square))\n    return float(white_rook_control - black_rook_control)\n\n",
    "def feature(board: chess.Board) -> float:\n    'Calculates the number of pieces that are pinned by the opponent.'\n    pinned_pieces = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == board.turn:\n            for attacker in board.attackers(not piece.color, square):\n                if board.piece_at(attacker) and board.piece_at(attacker).piece_type == chess.QUEEN:\n                    pinned_pieces += 1\n                    break\n    return float(pinned_pieces)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the total number of unprotected pieces for both players, signaling weakness.\"\n    white_unprotected = sum(1 for square, piece in board.piece_map().items() if piece.color == chess.WHITE and not board.attackers(chess.BLACK, square))\n    black_unprotected = sum(1 for square, piece in board.piece_map().items() if piece.color == chess.BLACK and not board.attackers(chess.WHITE, square))\n    result = white_unprotected - black_unprotected\n    return float(result)\n",
    "def feature(board: chess.Board) -> float:\n    \"Evaluates the king safety by counting pieces protecting each king.\"\n    white_king_square = board.king(chess.WHITE)\n    black_king_square = board.king(chess.BLACK)\n    white_protectors = sum(1 for square in board.piece_map() if board.piece_map()[square].color == chess.WHITE and chess.square_distance(square, white_king_square) <= 2)\n    black_protectors = sum(1 for square in board.piece_map() if board.piece_map()[square].color == chess.BLACK and chess.square_distance(square, black_king_square) <= 2)\n    return float(white_protectors - black_protectors)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the number of open files controlled by rooks for both players.\"\n    def open_files(color):\n        controlled_files = set()\n        for square, piece in board.piece_map().items():\n            if piece.color == color and piece.piece_type == chess.ROOK:\n                controlled_files.add(chess.square_file(square))\n        return len(controlled_files)\n    \n    white_open = open_files(chess.WHITE)\n    black_open = open_files(chess.BLACK)\n    return float(white_open - black_open)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Determines if any player has a complete piece integration (e.g. pieces connected).\"\n    def has_connected_pieces(color):\n        connected = set()\n        for square in range(64):\n            piece = board.piece_at(square)\n            if piece and piece.color == color:\n                connected.add(square)\n        return len(connected) >= 3  # arbitrary threshold for connected pieces\n    \n    white_connected = has_connected_pieces(chess.WHITE)\n    black_connected = has_connected_pieces(chess.BLACK)\n    return float(white_connected - black_connected)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the distance of all pieces from the center of the board (central squares).\"\n    center_squares = [chess.E4, chess.E5, chess.D4, chess.D5]\n    distance_sum = sum(chess.square_distance(square, center_square) for square in board.piece_map() for center_square in center_squares)\n    result = float(distance_sum)\n    return result\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the total number of pinned pieces for both sides, reflecting tactical weaknesses.\"\n    pinned_count = 0\n    for square, piece in board.piece_map().items():\n        if board.is_attacked_by(not piece.color, square):\n            attackers = board.attackers(not piece.color, square)\n            # Check if any piece is a king; if so, the piece is pinned.\n            if any(board.piece_at(king) and board.piece_at(king).piece_type == chess.KING for king in attackers):\n                pinned_count += 1\n    return float(pinned_count)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the ratio of minor pieces to total pieces for each color.\"\n    white_minor = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE and piece.piece_type in {chess.KNIGHT, chess.BISHOP})\n    black_minor = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK and piece.piece_type in {chess.KNIGHT, chess.BISHOP})\n    total_white = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE)\n    total_black = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK)\n    white_ratio = white_minor / total_white if total_white > 0 else 0.0\n    black_ratio = black_minor / total_black if total_black > 0 else 0.0\n    return float(white_ratio - black_ratio)\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the total number of pieces attacking opponent's pieces, indicating aggression level.\"\n    attacking_pieces = sum(1 for sq in board.piece_map() if board.piece_at(sq).color == board.turn and any(board.is_attacked_by(not board.piece_at(sq).color, target_sq) \n                                                for target_sq in board.piece_map() if board.piece_at(target_sq).color != board.turn))\n    return float(attacking_pieces)\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the piece activity score based on the number of legal moves for all pieces.\"\n    white_mobility = sum(len(list(board.legal_moves)) if board.piece_at(sq).color == chess.WHITE else 0 for sq in board.piece_map())\n    black_mobility = sum(len(list(board.legal_moves)) if board.piece_at(sq).color == chess.BLACK else 0 for sq in board.piece_map())\n    result = white_mobility - black_mobility\n    return float(result)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the ratio of pieces in the endgame compared to the total number of pieces on the board.\"\n    piece_count = len(board.piece_map())\n    endgame_pieces = sum(1 for piece in board.piece_map().values() if piece.piece_type in [chess.KING, chess.PAWN])\n    return float(endgame_pieces / piece_count) if piece_count > 0 else 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the distribution of pieces over the board based on rank positions.\"\n    white_distribution = [0] * 8\n    black_distribution = [0] * 8\n    for square, piece in board.piece_map().items():\n        if piece.color == chess.WHITE:\n            white_distribution[chess.square_rank(square)] += 1\n        else:\n            black_distribution[chess.square_rank(square)] += 1\n            \n    white_avg = sum(rank * count for rank, count in enumerate(white_distribution)) / sum(white_distribution) if sum(white_distribution) > 0 else 0\n    black_avg = sum(rank * count for rank, count in enumerate(black_distribution)) / sum(black_distribution) if sum(black_distribution) > 0 else 0\n    \n    return float(white_avg - black_avg)\n",
    "def feature(board: chess.Board) -> float:\n    \"Assesses the number of safe squares for each side's king considering current threats.\"\n    def safe_squares(color):\n        king_square = None\n        for square in board.piece_map():\n            piece = board.piece_map()[square]\n            if piece.color == color and piece.piece_type == chess.KING:\n                king_square = square\n                break\n        if king_square is None:\n            return 0\n        return sum(1 for sq in chess.SQUARES if board.is_attacked_by(not color, sq) is False and chess.square_distance(sq, king_square) <= 1)\n\n    white_safe = safe_squares(chess.WHITE)\n    black_safe = safe_squares(chess.BLACK)\n    return float(white_safe - black_safe)\n",
    "def feature(board: chess.Board) -> float:\n    \"Assesses the level of king safety based on the presence of attacking pieces.\"\n    white_king_square = next(square for square in board.piece_map() if board.piece_map()[square].color == chess.WHITE and board.piece_map()[square].piece_type == chess.KING)\n    black_king_square = next(square for square in board.piece_map() if board.piece_map()[square].color == chess.BLACK and board.piece_map()[square].piece_type == chess.KING)\n    white_threats = len(board.attackers(chess.BLACK, white_king_square))\n    black_threats = len(board.attackers(chess.WHITE, black_king_square))\n    return float(black_threats - white_threats)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the king safety by counting the number of squares around the king that are either occupied or attacked.\"\n    king_square = next(sq for sq, piece in board.piece_map().items() if piece.piece_type == chess.KING)\n    unsafe_squares = sum(1 for sq in chess.SQUARES_180 if board.is_attacked_by(chess.WHITE, sq) or board.piece_at(sq) is not None)\n    return float(unsafe_squares)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the number of active pieces for each side, defined as pieces that can move without being blocked.\"\n    active_white_pieces = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE and len(list(board.legal_moves)) > 0)\n    active_black_pieces = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK and len(list(board.legal_moves)) > 0)\n    return float(active_white_pieces - active_black_pieces)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the number of pawns advanced beyond their starting rank.\"\n    white_advanced = sum(1 for square in board.piece_map() if square in range(8, 16) and board.piece_map()[square].color == chess.WHITE)\n    black_advanced = sum(1 for square in board.piece_map() if square in range(48, 56) and board.piece_map()[square].color == chess.BLACK)\n    return float(white_advanced - black_advanced)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Assesses the presence of passed pawns for each color, which can be crucial in endgames.\"\n    def is_passed_pawn(square, color):\n        own_pawn = board.piece_at(square) and board.piece_at(square).color == color\n        if not own_pawn:\n            return False\n        file = chess.square_file(square)\n        for r in range(chess.square_rank(square) + 1, 8):\n            for f in (file - 1, file, file + 1):\n                if 0 <= f < 8 and (board.piece_at(chess.square(f, r)) and board.piece_at(chess.square(f, r)).color != color):\n                    return False\n        return True\n\n    white_passed = sum(is_passed_pawn(sq, chess.WHITE) for sq in chess.SQUARES)\n    black_passed = sum(is_passed_pawn(sq, chess.BLACK) for sq in chess.SQUARES)\n    return float(white_passed - black_passed)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Evaluates the total number of pieces attacking enemy pieces, counting only non-king pieces.\"\n    def attacking_piece_count(color):\n        count = 0\n        for square in board.piece_map():\n            if board.piece_map()[square].color == color:\n                for target in board.piece_map():\n                    if board.piece_map()[target].color != color and target != chess.square_file(board.piece_map()[square].piece_type):\n                        if square in board.attackers(color, target):\n                            count += 1\n        return count\n    white_attacks = attacking_piece_count(chess.WHITE)\n    black_attacks = attacking_piece_count(chess.BLACK)\n    return float(white_attacks - black_attacks)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the total number of pieces that are pinned or unprotected for each color.\"\n    def count_pinned(color):\n        pinned_count = 0\n        for square in board.piece_map():\n            piece = board.piece_map()[square]\n            if piece.color == color:\n                attackers = board.attackers(not color, square)\n                if attackers:  # If there are attackers\n                    for attacker_square in attackers:\n                        if board.piece_at(attacker_square).piece_type in [chess.ROOK, chess.QUEEN]: \n                            pinned_count += 1\n        return pinned_count\n\n    white_pinned = count_pinned(chess.WHITE)\n    black_pinned = count_pinned(chess.BLACK)\n    return float(white_pinned - black_pinned)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces that are unprotected by other pieces on each side.\"\n    def unprotected_pieces(color):\n        count = 0\n        for square, piece in board.piece_map().items():\n            if piece.color == color and not any(board.is_attacked_by(not color, square) for attacker_square in board.attackers(not color, square)):\n                count += 1\n        return count\n    \n    white_unprotected = unprotected_pieces(chess.WHITE)\n    black_unprotected = unprotected_pieces(chess.BLACK)\n    return float(white_unprotected - black_unprotected)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the number of squares controlled by each color, reflecting overall board control and influence.\"\n    white_controlled = sum([1 for square in chess.SQUARES if board.is_attacked_by(chess.WHITE, square)])\n    black_controlled = sum([1 for square in chess.SQUARES if board.is_attacked_by(chess.BLACK, square)])\n    control_ratio = (white_controlled - black_controlled) / (white_controlled + black_controlled + 1)  # Adding 1 to avoid division by zero\n    return float(control_ratio)\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the difference in the number of pieces on the queenside (a-d files) versus the kingside (e-h files).\"\n    queenside_count = sum(1 for sq in board.piece_map() if chess.square_file(sq) < 4)\n    kingside_count = sum(1 for sq in board.piece_map() if chess.square_file(sq) >= 4)\n    return float(queenside_count - kingside_count)\n\n",
    "def feature(board: chess.Board) -> float:\n    'Calculates the total value of pieces in the center of the board for both players.'\n    central_squares = [chess.D4, chess.D5, chess.E4, chess.E5]\n    value = 0\n    piece_values = {chess.PAWN: 1, chess.KNIGHT: 3, chess.BISHOP: 3, chess.ROOK: 5, chess.QUEEN: 9, chess.KING: 0}\n    \n    for sq in central_squares:\n        piece = board.piece_at(sq)\n        if piece is not None:\n            value += piece_values[piece.piece_type] if piece.color == chess.WHITE else -piece_values[piece.piece_type]\n    \n    return float(value)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the total material value of all pieces on the board.\"\n    piece_values = {\n        chess.PAWN: 1,\n        chess.KNIGHT: 3,\n        chess.BISHOP: 3,\n        chess.ROOK: 5,\n        chess.QUEEN: 9,\n        chess.KING: 0\n    }\n    total_value = sum(piece_values[piece.piece_type] for piece in board.piece_map().values())\n    return float(total_value)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the total number of squares controlled by each player's pieces.\"\n    control_count = {chess.WHITE: 0, chess.BLACK: 0}\n    \n    for square in chess.SQUARES:\n        if board.is_attacked_by(chess.WHITE, square):\n            control_count[chess.WHITE] += 1\n        if board.is_attacked_by(chess.BLACK, square):\n            control_count[chess.BLACK] += 1\n    \n    return float(control_count[chess.WHITE] - control_count[chess.BLACK])\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the proposed sacrifice material value of knights for each side.\"\n    knight_value = 0\n    for square in board.piece_map():\n        piece = board.piece_map()[square]\n        if piece.color == chess.WHITE and piece.piece_type == chess.KNIGHT:\n            knight_value += 3\n        elif piece.color == chess.BLACK and piece.piece_type == chess.KNIGHT:\n            knight_value -= 3\n    return float(knight_value) \n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the number of pieces occupying the first and eighth ranks.\"\n    pieces_on_first_rank = sum(1 for sq in board.piece_map() if chess.square_rank(sq) == 0)\n    pieces_on_eighth_rank = sum(1 for sq in board.piece_map() if chess.square_rank(sq) == 7)\n    \n    return float(pieces_on_first_rank - pieces_on_eighth_rank)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Assesses the total number of squares available for knights, reflecting mobility.\"\n    knight_mobility = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == chess.WHITE and piece.piece_type == chess.KNIGHT:\n            knight_mobility += len(list(board.legal_moves))\n        elif piece.color == chess.BLACK and piece.piece_type == chess.KNIGHT:\n            knight_mobility -= len(list(board.legal_moves))\n    return float(knight_mobility)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the average value of all pieces on the board weighted by their positions.\"\n    piece_values = {chess.PAWN: 1, chess.KNIGHT: 3, chess.BISHOP: 3, chess.ROOK: 5, chess.QUEEN: 9, chess.KING: 0}\n    total_weighted_value = 0\n    piece_count = 0\n    \n    for square, piece in board.piece_map().items():\n        total_weighted_value += piece_values[piece.piece_type] * (8 - chess.square_rank(square))\n        piece_count += 1\n    \n    return total_weighted_value / (piece_count if piece_count > 0 else 1)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the total number of pieces that are vulnerable to capture (attacked and undefended).\"\n    vulnerable_count = sum(1 for square, piece in board.piece_map().items() \n                           if piece.color == board.turn and \n                           board.is_attacked_by(chess.WHITE if piece.color == chess.BLACK else chess.BLACK, square))\n    return float(vulnerable_count)\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the number of critical squares attacked by each side.\"\n    critical_squares = [chess.D4, chess.E4, chess.D5, chess.E5, chess.C5, chess.C4, chess.F4, chess.F5]\n    white_control = sum(1 for square in critical_squares if board.is_attacked_by(chess.WHITE, square))\n    black_control = sum(1 for square in critical_squares if board.is_attacked_by(chess.BLACK, square))\n    return float(white_control - black_control)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Evaluates the presence of isolated pawns for both sides, impacting pawn structure.\"\n    def count_isolated_pawns(color):\n        isolated_count = 0\n        for square, piece in board.piece_map().items():\n            if piece.color == color and piece.piece_type == chess.PAWN:\n                if (square % 8 == 0 or not board.piece_at(square - 1) or board.piece_at(square - 1).color != color) and \\\n                   (square % 8 == 7 or not board.piece_at(square + 1) or board.piece_at(square + 1).color != color):\n                    isolated_count += 1\n        return isolated_count\n    \n    white_isolated = count_isolated_pawns(chess.WHITE)\n    black_isolated = count_isolated_pawns(chess.BLACK)\n    return float(white_isolated - black_isolated)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the pieces under threat for each side.\"\n    white_threatened = sum(1 for square in board.piece_map() if board.is_attacked_by(chess.BLACK, square))\n    black_threatened = sum(1 for square in board.piece_map() if board.is_attacked_by(chess.WHITE, square))\n    return float(white_threatened - black_threatened)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in central control by counting pieces on central squares.\"\n    central_squares = [chess.E4, chess.E5, chess.D4, chess.D5]\n    white_control = sum(1 for square in central_squares if board.piece_at(square) and board.piece_at(square).color == chess.WHITE)\n    black_control = sum(1 for square in central_squares if board.piece_at(square) and board.piece_at(square).color == chess.BLACK)\n    return float(white_control - black_control)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the number of pieces under attack by opponents.\"\n    white_under_attack = sum(1 for square in chess.SQUARES if board.piece_at(square) and board.piece_at(square).color == chess.WHITE and board.is_attacked_by(chess.BLACK, square))\n    black_under_attack = sum(1 for square in chess.SQUARES if board.piece_at(square) and board.piece_at(square).color == chess.BLACK and board.is_attacked_by(chess.WHITE, square))\n    return float(black_under_attack - white_under_attack)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the total value of pieces that are unprotected for each side.\"\n    def value_of_unprotected_pieces(color):\n        unprotected_value = 0\n        for square, piece in board.piece_map().items():\n            if piece.color == color and not board.is_attacked_by(not color, square):\n                unprotected_value += piece.piece_type\n        return unprotected_value\n    \n    return float(value_of_unprotected_pieces(chess.WHITE) - value_of_unprotected_pieces(chess.BLACK))\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the concentration of pieces in the center (d4, d5, e4, e5) for each side.\"\n    center_squares = [chess.parse_square('d4'), chess.parse_square('d5'), chess.parse_square('e4'), chess.parse_square('e5')]\n    white_center_control = sum(1 for square in center_squares if board.piece_at(square) and board.piece_at(square).color == chess.WHITE)\n    black_center_control = sum(1 for square in center_squares if board.piece_at(square) and board.piece_at(square).color == chess.BLACK)\n    return float(white_center_control - black_center_control)\n\n",
    "def feature(board: chess.Board) -> float:\n    'Counts the number of open files for both players, assessing control of the board.'\n    open_files = sum(1 for file in range(8) if all(board.piece_at(chess.square(file, rank)) is None for rank in range(8)))\n    return float(open_files)\n",
    "def feature(board: chess.Board) -> float:\n    'Calculates the total number of squares occupied by pawns.'\n    occupied_squares = sum(1 for piece in board.piece_map().values() if piece.piece_type == chess.PAWN)\n    return float(occupied_squares)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the number of safe squares for each side's pieces.\"\n    def safe_squares(color):\n        return sum(1 for square in board.piece_map() if board.piece_map()[square].color == color and not board.is_attacked_by(not color, square))\n    white_safe = safe_squares(chess.WHITE)\n    black_safe = safe_squares(chess.BLACK)\n    return float(white_safe - black_safe)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the difference in the total number of pawns on the 4th rank.\"\n    white_pawns_on_4th = sum(1 for square in chess.SQUARES if board.piece_at(square) and board.piece_at(square).color == chess.WHITE and chess.square_rank(square) == 3)\n    black_pawns_on_4th = sum(1 for square in chess.SQUARES if board.piece_at(square) and board.piece_at(square).color == chess.BLACK and chess.square_rank(square) == 4)\n    return float(white_pawns_on_4th - black_pawns_on_4th)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the development of pieces, determining which side has developed more pieces.\"\n    developed_pieces = {\n        chess.WHITE: sum(1 for square, piece in board.piece_map().items() if piece.color == chess.WHITE and (piece.piece_type in [chess.KNIGHT, chess.BISHOP] and chess.square_rank(square) > 1)),\n        chess.BLACK: sum(1 for square, piece in board.piece_map().items() if piece.color == chess.BLACK and (piece.piece_type in [chess.KNIGHT, chess.BISHOP] and chess.square_rank(square) < 6)),\n    }\n    return float(developed_pieces[chess.WHITE] - developed_pieces[chess.BLACK])\n\n",
    "def feature(board: chess.Board) -> float:\n    'Calculates the mobility ratio by comparing the number of legal moves for both players.'\n    white_moves = len(list(board.legal_moves))\n    board.turn = not board.turn  # Switch turn to count black moves\n    black_moves = len(list(board.legal_moves))\n    board.turn = not board.turn  # Switch turn back\n    return float(white_moves / (black_moves + 1e-5))  # Avoid division by zero\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in mobility between both players based on piece types.\"\n    white_mobility = sum(len(list(board.legal_moves)) for square, piece in board.piece_map().items() if piece.color == chess.WHITE)\n    black_mobility = sum(len(list(board.legal_moves)) for square, piece in board.piece_map().items() if piece.color == chess.BLACK)\n    return white_mobility - black_mobility\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces that are pinned by the opponent.\"\n    pinned_white = sum(1 for square, piece in board.piece_map().items() if piece.color == chess.WHITE and any(board.is_attacked_by(chess.BLACK, square) for square in board.attackers(chess.BLACK, square)))\n    pinned_black = sum(1 for square, piece in board.piece_map().items() if piece.color == chess.BLACK and any(board.is_attacked_by(chess.WHITE, square) for square in board.attackers(chess.WHITE, square)))\n    return float(pinned_white - pinned_black)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Determines the number of pawns on the 7th rank for both sides, indicating potential promotion.\"\n    seventh_rank_pawns_white = sum(1 for square in board.piece_map() if board.piece_at(square).color == chess.WHITE and chess.square_rank(square) == 6)\n    seventh_rank_pawns_black = sum(1 for square in board.piece_map() if board.piece_at(square).color == chess.BLACK and chess.square_rank(square) == 1)\n    return float(seventh_rank_pawns_white - seventh_rank_pawns_black)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the average value of pieces for each side relative to their total.\"\n    material_values = {\n        chess.PAWN: 1,\n        chess.KNIGHT: 3,\n        chess.BISHOP: 3,\n        chess.ROOK: 5,\n        chess.QUEEN: 9,\n        chess.KING: 0\n    }\n    def average_piece_value(color):\n        pieces = [material_values[piece.piece_type] for piece in board.piece_map().values() if piece.color == color]\n        return sum(pieces) / len(pieces) if pieces else 0\n    \n    white_average = average_piece_value(chess.WHITE)\n    black_average = average_piece_value(chess.BLACK)\n    return float(white_average - black_average)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the average distance of pieces from the opponent's king, measuring potential threats.\"\n    king_square = next((s for s, p in board.piece_map().items() if p.piece_type == chess.KING and p.color == (chess.WHITE if board.turn else chess.BLACK)), None)\n    piece_distances = [chess.square_distance(square, king_square) for square, piece in board.piece_map().items() if piece.color == (chess.WHITE if board.turn else chess.BLACK)]\n    return float(sum(piece_distances) / len(piece_distances)) if piece_distances else 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the number of squares vacated by opponent's pieces.\"\n    vacated_squares_white = sum(1 for square in range(64) if board.piece_at(square) and board.piece_at(square).color == chess.BLACK and not board.is_attacked_by(chess.WHITE, square))\n    vacated_squares_black = sum(1 for square in range(64) if board.piece_at(square) and board.piece_at(square).color == chess.WHITE and not board.is_attacked_by(chess.BLACK, square))\n    return float(vacated_squares_white - vacated_squares_black)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Assesses central pawn structure by counting the difference in central pawns for both players.\"\n    central_pawns_white = sum(1 for square in [chess.D4, chess.D5, chess.E4, chess.E5] if board.piece_at(square) and board.piece_at(square).color == chess.WHITE and board.piece_at(square).piece_type == chess.PAWN)\n    central_pawns_black = sum(1 for square in [chess.D4, chess.D5, chess.E4, chess.E5] if board.piece_at(square) and board.piece_at(square).color == chess.BLACK and board.piece_at(square).piece_type == chess.PAWN)\n    return float(central_pawns_white - central_pawns_black)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in pawn structure between the two sides.\"\n    def count_connected_pawns(color):\n        connected = 0\n        for file in range(8):\n            if board.piece_at(chess.square(file, 1 if color == chess.WHITE else 6)) == chess.PAWN:\n                if (file > 0 and board.piece_at(chess.square(file - 1, 1 if color == chess.WHITE else 6)) == chess.PAWN) or \\\n                   (file < 7 and board.piece_at(chess.square(file + 1, 1 if color == chess.WHITE else 6)) == chess.PAWN):\n                    connected += 1\n        return connected\n    white_connected = count_connected_pawns(chess.WHITE)\n    black_connected = count_connected_pawns(chess.BLACK)\n    return float(white_connected - black_connected)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Evaluates piece activity by counting the number of pieces that can move.\"\n    active_pieces = sum(1 for piece in board.piece_map().values() if len(list(board.legal_moves)) > 0)\n    return float(active_pieces)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the number of pieces on the board to assess material density.\"\n    piece_count = len(board.piece_map())\n    return float(piece_count)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in the number of pieces that are pinned by opponent pieces.\"\n    pinned_white = sum(1 for square in board.piece_map() if board.piece_map()[square].color == chess.WHITE and board.is_attacked_by(chess.BLACK, square))\n    pinned_black = sum(1 for square in board.piece_map() if board.piece_map()[square].color == chess.BLACK and board.is_attacked_by(chess.WHITE, square))\n    return float(pinned_white - pinned_black)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Evaluates the pawn structure by counting doubled pawns for each side.\"\n    def doubled_pawns(color):\n        pawn_files = [0] * 8\n        for square in board.piece_map():\n            piece = board.piece_map()[square]\n            if piece.color == color and piece.piece_type == chess.PAWN:\n                pawn_files[chess.square_file(square)] += 1\n        return sum(1 for count in pawn_files if count > 1)\n    \n    white_doubled = doubled_pawns(chess.WHITE)\n    black_doubled = doubled_pawns(chess.BLACK)\n    return float(white_doubled - black_doubled)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the average rank of pieces for each player as a measure of their position.\"\n    white_average_rank = sum(chess.square_rank(square) for square, piece in board.piece_map().items() if piece.color == chess.WHITE) / max(sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE), 1)\n    black_average_rank = sum(chess.square_rank(square) for square, piece in board.piece_map().items() if piece.color == chess.BLACK) / max(sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK), 1)\n    return white_average_rank - black_average_rank\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the number of pieces on the seventh rank for both sides, highlighting offensive potential.\"\n    seventh_rank_white = sum(1 for square in range(48, 56) if board.piece_at(square) is not None and board.piece_at(square).color == chess.WHITE)\n    seventh_rank_black = sum(1 for square in range(8, 16) if board.piece_at(square) is not None and board.piece_at(square).color == chess.BLACK)\n    return float(seventh_rank_white - seventh_rank_black)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the number of squares controlled by knights for each side.\"\n    def knight_control(color):\n        return sum(len([move for move in board.legal_moves if move.from_square == square]) for square in board.piece_map() if board.piece_map()[square].color == color and board.piece_map()[square].piece_type == chess.KNIGHT)\n    \n    white_knight_control = knight_control(chess.WHITE)\n    black_knight_control = knight_control(chess.BLACK)\n    return float(white_knight_control - black_knight_control)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of opposing pieces controlled by two squares next to the kings for safety assessment.\"\n    king_squares = [next((sq for sq, piece in board.piece_map().items() if piece.color == chess.WHITE and piece.piece_type == chess.KING), None),\n                    next((sq for sq, piece in board.piece_map().items() if piece.color == chess.BLACK and piece.piece_type == chess.KING), None)]\n    opposing_piece_count = sum(1 for sq in chess.SQUARES if board.piece_at(sq) and board.piece_at(sq).color != board.piece_at(king_squares[0]).color and chess.square_distance(sq, king_squares[0]) <= 1)\n    return float(opposing_piece_count)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the number of doubled pawns for each side.\"\n    def count_doubled_pawns(color):\n        pawn_squares = [square for square in board.piece_map() if board.piece_map()[square].piece_type == chess.PAWN and board.piece_map()[square].color == color]\n        return sum(1 for file in range(8) if sum(1 for square in pawn_squares if chess.square_file(square) == file) > 1)\n    \n    white_doubled = count_doubled_pawns(chess.WHITE)\n    black_doubled = count_doubled_pawns(chess.BLACK)\n    return float(white_doubled - black_doubled)\n\n",
    "def feature(board: chess.Board) -> float:\n    'Measures the total value of pieces in controlled squares for the player to move.'\n    controlled_value = 0\n    for square in board.piece_map():\n        piece = board.piece_at(square)\n        if piece.color == board.turn:\n            for move in board.legal_moves:\n                if move.from_square == square:\n                    controlled_value += piece.piece_type\n    return controlled_value\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in piece mobility based on attacks and legal moves available.\"\n    mobility_balance = len(list(board.legal_moves))\n    for square, piece in board.piece_map().items():\n        mobility_balance += len(board.attackers(piece.color, square)) * (-1 if piece.color == chess.WHITE else 1)\n    \n    return float(mobility_balance)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the number of pieces attacking the enemy's most advanced pawn.\"\n    white_advanced_pawns = [square for square in range(24, 32) if board.piece_at(square) and \n                            board.piece_at(square).piece_type == chess.PAWN and \n                            board.piece_at(square).color == chess.WHITE]\n    black_advanced_pawns = [square for square in range(8) if board.piece_at(square) and \n                            board.piece_at(square).piece_type == chess.PAWN and \n                            board.piece_at(square).color == chess.BLACK]\n    \n    white_attacks = sum(len(board.attackers(chess.BLACK, pawn_square)) for pawn_square in white_advanced_pawns)\n    black_attacks = sum(len(board.attackers(chess.WHITE, pawn_square)) for pawn_square in black_advanced_pawns)\n    return float(white_attacks - black_attacks)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Computes the difference in material value, emphasizing the value of major pieces.\"\n    piece_values = {chess.PAWN: 1, chess.KNIGHT: 3, chess.BISHOP: 3, chess.ROOK: 5, chess.QUEEN: 9, chess.KING: 0}\n    white_value = sum(piece_values[piece.piece_type] for piece in board.piece_map().values() if piece.color == chess.WHITE)\n    black_value = sum(piece_values[piece.piece_type] for piece in board.piece_map().values() if piece.color == chess.BLACK)\n    return white_value - black_value\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Evaluates the distance of the kings from the center of the board.\"\n    white_king_square = next((square for square, piece in board.piece_map().items() if piece.color == chess.WHITE and piece.piece_type == chess.KING), None)\n    black_king_square = next((square for square, piece in board.piece_map().items() if piece.color == chess.BLACK and piece.piece_type == chess.KING), None)\n    white_distance = chess.square_distance(28, white_king_square) if white_king_square is not None else 0\n    black_distance = chess.square_distance(28, black_king_square) if black_king_square is not None else 0\n    return float(black_distance - white_distance)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the total number of backward pawns for both players.\"\n    backward_pawns = 0\n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.PAWN:\n            if piece.color == chess.WHITE and board.piece_at(square + 8) is None and (square % 8 != 7):\n                backward_pawns += 1\n            elif piece.color == chess.BLACK and board.piece_at(square - 8) is None and (square % 8 != 0):\n                backward_pawns += 1\n    return float(backward_pawns)\n\n",
    "def feature(board: chess.Board) -> float:\n    'Counts the number of pawns on the 7th rank, indicating potential promotion and resulting positional strength.'\n    seventh_rank_pawns = sum(1 for square in board.piece_map() if board.piece_at(square).piece_type == chess.PAWN and chess.square_rank(square) == 6)\n    return float(seventh_rank_pawns)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces on each side that are pinned.\"\n    pinned_white = sum(1 for square in board.piece_map() if board.piece_map()[square].color == chess.WHITE and board.is_attacked_by(chess.BLACK, square) and board.is_attacked_by(chess.WHITE, square))\n    pinned_black = sum(1 for square in board.piece_map() if board.piece_map()[square].color == chess.BLACK and board.is_attacked_by(chess.WHITE, square) and board.is_attacked_by(chess.BLACK, square))\n    return float(pinned_white - pinned_black)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the distance of pieces from the opponent's back rank, indicating potential threats.\"\n    distance = 0\n    for square in chess.SQUARES:\n        piece = board.piece_at(square)\n        if piece is not None:\n            rank_distance = 7 - chess.square_rank(square) if piece.color == chess.WHITE else chess.square_rank(square)\n            distance += rank_distance if piece.color == chess.WHITE else -rank_distance\n    return float(distance)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of different piece types remaining for each player.\"\n    piece_types_white = {piece.piece_type for piece in board.piece_map().values() if piece.color == chess.WHITE}\n    piece_types_black = {piece.piece_type for piece in board.piece_map().values() if piece.color == chess.BLACK}\n\n    return float(len(piece_types_white) - len(piece_types_black))\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of pinned pieces each side has.\"\n    def is_pinned(square, color):\n        piece = board.piece_at(square)\n        if piece is None or piece.color != color:\n            return False\n        for attacker in board.attackers(not color, square):\n            for square_to_check in board.attackers(color, attacker):\n                if board.piece_at(square_to_check) and board.piece_at(square_to_check).piece_type == chess.KING:\n                    continue\n                return True\n        return False\n\n    white_pins = sum(1 for square in board.piece_map() if is_pinned(square, chess.WHITE))\n    black_pins = sum(1 for square in board.piece_map() if is_pinned(square, chess.BLACK))\n    return float(white_pins - black_pins)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the flexibility of pieces by counting the number of possible moves for each piece type.\"\n    flexibility_score = 0\n    for square in board.piece_map():\n        piece = board.piece_at(square)\n        if piece.color == board.turn:\n            flexibility_score += len(list(board.legal_moves))\n    return float(flexibility_score)\n\n",
    "def feature(board: chess.Board) -> float:\n    'Calculates the distance to the opponent\u2019s king for all pieces.'\n    opponent_king_square = next(square for square, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color != board.turn)\n    total_distance = sum(chess.square_distance(square, opponent_king_square) for square in board.piece_map() if board.piece_map()[square].color == board.turn)\n    return float(total_distance)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the control of central squares (d4, e4, d5, e5) based on piece position.\"\n    central_squares = [chess.D4, chess.E4, chess.D5, chess.E5]\n    control_score = sum(1 for square in central_squares if board.is_attacked_by(chess.WHITE, square)) - \\\n                    sum(1 for square in central_squares if board.is_attacked_by(chess.BLACK, square))\n    return float(control_score)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Assesses the number of pawns on the 7th rank for both sides.\"\n    pawns_on_seventh = sum(1 for square in range(48, 56) if board.piece_at(square) and board.piece_at(square).piece_type == chess.PAWN and board.piece_at(square).color == chess.WHITE)\n    pawns_on_second = sum(1 for square in range(8, 16) if board.piece_at(square) and board.piece_at(square).piece_type == chess.PAWN and board.piece_at(square).color == chess.BLACK)\n    return float(pawns_on_seventh - pawns_on_second)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the king safety score based on nearby pieces.\"\n    def king_safety(color):\n        king_square = next(square for square, piece in board.piece_map().items() if piece.color == color and piece.piece_type == chess.KING)\n        safety_score = 0\n        for square in board.piece_map():\n            piece = board.piece_at(square)\n            if piece and piece.color != color:\n                if chess.square_distance(king_square, square) <= 2:\n                    safety_score -= {chess.QUEEN: 3, chess.ROOK: 2, chess.BISHOP: 1, chess.KNIGHT: 1}.get(piece.piece_type, 0)\n        return safety_score\n\n    white_safety = king_safety(chess.WHITE)\n    black_safety = king_safety(chess.BLACK)\n    return float(white_safety - black_safety)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the potential for checkmate in the next few moves based on piece positions.\"\n    potential_checkmate = 0\n    if board.is_check():\n        potential_checkmate += 1\n    for move in board.legal_moves:\n        board.push(move)\n        if board.is_checkmate():\n            potential_checkmate += 1\n        board.pop()\n    return float(potential_checkmate)\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the ratio of minor piece value to total material value on the board.\"\n    minor_piece_value = sum(3 for square in board.piece_map() if board.piece_at(square).piece_type in (chess.KNIGHT, chess.BISHOP))\n    total_material_value = sum(1 for square in board.piece_map())  # Simple material count for now\n    if total_material_value == 0:\n        return 0.0\n    result = minor_piece_value / total_material_value\n    return float(result)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the total number of available squares for all pieces, giving an idea of piece mobility.\"\n    mobility_count = sum(len(list(board.legal_moves)) for square in board.piece_map() if board.piece_map()[square].color == board.turn)\n    return float(mobility_count)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the number of pawns passed for both sides, indicating potential for promotion.\"\n    white_passed_pawns = 0\n    black_passed_pawns = 0\n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.PAWN:\n            if piece.color == chess.WHITE and not any(board.is_attacked_by(chess.BLACK, square + i) for i in range(1, 9) if chess.square_file(square) + i < 8):\n                white_passed_pawns += 1\n            elif piece.color == chess.BLACK and not any(board.is_attacked_by(chess.WHITE, square - i) for i in range(1, 9) if chess.square_file(square) - i >= 0):\n                black_passed_pawns += 1\n    return float(white_passed_pawns - black_passed_pawns)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the ratio of minor pieces to total pieces for both sides.\"\n    white_minors = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE and piece.piece_type in (chess.KNIGHT, chess.BISHOP))\n    black_minors = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK and piece.piece_type in (chess.KNIGHT, chess.BISHOP))\n    total_white = len([piece for piece in board.piece_map().values() if piece.color == chess.WHITE])\n    total_black = len([piece for piece in board.piece_map().values() if piece.color == chess.BLACK])\n    white_ratio = white_minors / total_white if total_white > 0 else 0.0\n    black_ratio = black_minors / total_black if total_black > 0 else 0.0\n    return float(white_ratio - black_ratio)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Evaluates the number of available checks for both sides.\"\n    available_checks = 0\n    for move in board.legal_moves:\n        if board.piece_at(move.from_square).piece_type == chess.KING:\n            continue\n        if board.gives_check(move):\n            available_checks += 1 if board.piece_at(move.from_square).color == chess.WHITE else -1\n    return float(available_checks)\n",
    "def feature(board: chess.Board) -> float:\n    \"Evaluates the number of open files for rooks and queens.\"\n    open_files = sum(1 for file in range(8) if not any(board.piece_at(chess.square(file, rank)) for rank in range(8)))\n    return float(open_files * (1 if board.turn else -1))\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts how many pieces are currently attacking the opponent's king, illustrating direct threats.\"\n    white_king_square = next(sq for sq in board.piece_map() if board.piece_at(sq).piece_type == chess.KING and board.piece_at(sq).color == chess.WHITE)\n    black_king_square = next(sq for sq in board.piece_map() if board.piece_at(sq).piece_type == chess.KING and board.piece_at(sq).color == chess.BLACK)\n    white_attackers = len(board.attackers(chess.WHITE, black_king_square))\n    black_attackers = len(board.attackers(chess.BLACK, white_king_square))\n    return float(white_attackers - black_attackers)\n\n",
    "def feature(board: chess.Board) -> float:\n    'Calculates the total material value of pieces that are centralized (on ranks 3, 4, 5).'\n    material_value = 0\n    central_squares = [chess.E4, chess.E5, chess.D4, chess.D5, chess.C4, chess.C5, chess.F4, chess.F5]\n    piece_values = {\n        chess.PAWN: 1.0,\n        chess.KNIGHT: 3.0,\n        chess.BISHOP: 3.0,\n        chess.ROOK: 5.0,\n        chess.QUEEN: 9.0,\n        chess.KING: 0.0  # King's value is conceptually unique\n    }\n\n    for square in central_squares:\n        if board.piece_at(square):\n            piece = board.piece_at(square)\n            material_value += piece_values[piece.piece_type] if piece is not None else 0\n\n    return float(material_value)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Assesses the total distance of all pieces from their starting squares to capture development.\"\n    piece_initial_positions = {\n        chess.PAWN: [chess.A2, chess.B2, chess.C2, chess.D2, chess.E2, chess.F2, chess.G2, chess.H2],\n        chess.ROOK: [chess.A1, chess.H1],\n        chess.KNIGHT: [chess.B1, chess.G1],\n        chess.BISHOP: [chess.C1, chess.F1],\n        chess.QUEEN: [chess.D1],\n        chess.KING: [chess.E1],\n    }\n    white_distance_sum = sum(chess.square_distance(square, initial) for square, piece in board.piece_map().items() if piece.color == chess.WHITE for initial in piece_initial_positions.get(piece.piece_type, []))\n    black_distance_sum = sum(chess.square_distance(square, initial) for square, piece in board.piece_map().items() if piece.color == chess.BLACK for initial in piece_initial_positions.get(piece.piece_type, []))\n    return float(white_distance_sum - black_distance_sum)\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the number of pieces that can be immediately promoted.\"\n    promotable_pawns = 0\n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.PAWN:\n            if (piece.color == chess.WHITE and chess.square_rank(square) == 6) or \\\n               (piece.color == chess.BLACK and chess.square_rank(square) == 1):\n                promotable_pawns += 1\n    return float(promotable_pawns)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in the number of pawns on the 7th rank for each color.\"\n    pawns_rank_7 = {\n        chess.WHITE: sum(1 for square in board.piece_map() if (board.piece_map()[square].color == chess.WHITE and \n                                                                chess.square_rank(square) == 6)),\n        chess.BLACK: sum(1 for square in board.piece_map() if (board.piece_map()[square].color == chess.BLACK and \n                                                                chess.square_rank(square) == 1))\n    }\n    return float(pawns_rank_7[chess.WHITE] - pawns_rank_7[chess.BLACK])\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the number of pieces that are attacking pawns of the opponent.\"\n    white_attacks_on_pawns = sum(1 for square in board.piece_map() if board.piece_at(square).color == chess.WHITE and any(board.is_attacked_by(chess.WHITE, chess.parse_square(sq)) for sq in ['a7', 'b7', 'c7', 'd7', 'e7', 'f7', 'g7', 'h7']))\n    black_attacks_on_pawns = sum(1 for square in board.piece_map() if board.piece_at(square).color == chess.BLACK and any(board.is_attacked_by(chess.BLACK, chess.parse_square(sq)) for sq in ['a2', 'b2', 'c2', 'd2', 'e2', 'f2', 'g2', 'h2']))\n    return float(white_attacks_on_pawns - black_attacks_on_pawns)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of major pieces (rooks and queens) each side controls.\"\n    white_major = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE and piece.piece_type in {chess.ROOK, chess.QUEEN})\n    black_major = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK and piece.piece_type in {chess.ROOK, chess.QUEEN})\n    return float(white_major - black_major)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the control of key squares: f7, e7, f2, and e2.\"\n    key_squares = [chess.F7, chess.E7, chess.F2, chess.E2]\n    white_control = sum(1 for square in key_squares if board.is_attacked_by(chess.WHITE, square))\n    black_control = sum(1 for square in key_squares if board.is_attacked_by(chess.BLACK, square))\n    return float(white_control - black_control)\n\n",
    "def feature(board: chess.Board) -> float:\n    'Calculates the total distance of all pieces from their starting rank for each player.'\n    distance_w = sum(chess.square_rank(square) for square, piece in board.piece_map().items() if piece.color == chess.WHITE)\n    distance_b = sum(7 - chess.square_rank(square) for square, piece in board.piece_map().items() if piece.color == chess.BLACK)\n    return float(distance_w - distance_b)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the number of pieces controlled by each player using their respective pieces' positions.\"\n    white_control = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE and piece.piece_type != chess.KING)\n    black_control = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK and piece.piece_type != chess.KING)\n    return float(white_control - black_control)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the total number of piece exchanges that could lead to a stronger position.\"\n    potential_exchanges = 0\n    for move in board.legal_moves:\n        target_piece = board.piece_at(move.to_square)\n        if target_piece and target_piece.color != board.piece_at(move.from_square).color:\n            potential_exchanges += 1\n    return float(potential_exchanges)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the distance of pieces from the opponent's pawns, assessing pressure.\"\n    opponent_pawns = [square for square, piece in board.piece_map().items() if piece.piece_type == chess.PAWN and piece.color != board.turn]\n    distance_sum = sum(chess.square_distance(square, pawn) for square in board.piece_map() if board.piece_map()[square].color == board.turn for pawn in opponent_pawns)\n    return float(distance_sum)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces directly attacking the opponent's pieces.\"\n    attacking_count = sum(1 for square in board.piece_map() if board.is_attacked_by(not board.turn, square))\n    return float(attacking_count)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the average mobility of pieces for both players.\"\n    white_moves = sum(len(list(board.legal_moves)) for square, piece in board.piece_map().items() if piece.color == chess.WHITE)\n    black_moves = sum(len(list(board.legal_moves)) for square, piece in board.piece_map().items() if piece.color == chess.BLACK)\n    return float(white_moves - black_moves)\n\n",
    "def feature(board: chess.Board) -> float:\n    'Calculates the number of pieces attacking the same square for the current player.'\n    attacks = sum(len(board.attackers(board.turn, square)) for square in board.piece_map() if board.piece_map()[square].color == board.turn)\n    return float(attacks)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the average piece value for both colors based on the pieces present.\"\n    piece_values = {\n        chess.PAWN: 1,\n        chess.KNIGHT: 3,\n        chess.BISHOP: 3,\n        chess.ROOK: 5,\n        chess.QUEEN: 9,\n        chess.KING: 0\n    }\n    white_value = sum(piece_values[piece.piece_type] for piece in board.piece_map().values() if piece.color == chess.WHITE)\n    black_value = sum(piece_values[piece.piece_type] for piece in board.piece_map().values() if piece.color == chess.BLACK)\n    total_value = white_value + black_value\n    return float(white_value / total_value if total_value > 0 else 0)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the maximum distance of pieces from their respective kings.\"\n    max_distance = 0\n    king_square = board.king(chess.WHITE) if board.turn else board.king(chess.BLACK)\n\n    for square, piece in board.piece_map().items():\n        if piece.color == (chess.WHITE if board.turn else chess.BLACK):\n            distance = chess.square_distance(square, king_square)\n            max_distance = max(max_distance, distance)\n\n    return float(max_distance)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the number of threats against the opponent's pieces.\"\n    threats = 0\n    for square, piece in board.piece_map().items():\n        if piece.color != board.turn:\n            threats += len(list(board.attackers(board.turn, square)))\n    return float(threats)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of pawn chains for each side.\"\n    white_chains = 0\n    black_chains = 0\n    \n    def count_pawn_chain(start_square):\n        chain_length = 0\n        for sq in range(start_square, 64):\n            piece = board.piece_at(sq)\n            if piece and piece.piece_type == chess.PAWN and piece.color == chess.WHITE:\n                chain_length += 1\n            else:\n                break\n        return chain_length\n\n    for file in range(8):\n        chain_found = False\n        for rank in range(8):\n            square = chess.square(file, rank)\n            if board.piece_at(square) and board.piece_at(square).piece_type == chess.PAWN:\n                if board.piece_at(square).color == chess.WHITE:\n                    if not chain_found:\n                        white_chains += 1\n                        chain_found = True\n                else:\n                    chain_found = False\n    return float(white_chains - black_chains)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the interaction of pieces by counting the number of pieces defending their own.\"\n    defending_pieces = sum(1 for square in board.piece_map() if board.is_attacked_by(board.piece_map()[square].color, square))\n    return float(defending_pieces)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the material value of pieces available to each player and returns the ratio.\"\n    piece_values = {chess.PAWN: 1, chess.KNIGHT: 3, chess.BISHOP: 3, chess.ROOK: 5, chess.QUEEN: 9, chess.KING: 0}\n    white_value = sum(piece_values[board.piece_at(square).piece_type] for square in board.piece_map() if board.piece_at(square).color == chess.WHITE)\n    black_value = sum(piece_values[board.piece_at(square).piece_type] for square in board.piece_map() if board.piece_at(square).color == chess.BLACK)\n    return white_value / (black_value + 1e-10)  # Avoid division by zero\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces in front of the pawns for each side.\"\n    def count_pieces_in_front(color):\n        return sum(1 for square in board.piece_map().keys() if board.piece_map()[square].color == color and chess.square_rank(square) < 7)\n\n    white_pieces_in_front = count_pieces_in_front(chess.WHITE)\n    black_pieces_in_front = count_pieces_in_front(chess.BLACK)\n    \n    return float(white_pieces_in_front - black_pieces_in_front)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the king safety by counting the number of pawns in front of the kings.\"\n    white_king_square = next(sq for sq in board.piece_map() if board.piece_at(sq).color == chess.WHITE and board.piece_at(sq).piece_type == chess.KING)\n    black_king_square = next(sq for sq in board.piece_map() if board.piece_at(sq).color == chess.BLACK and board.piece_at(sq).piece_type == chess.KING)\n    white_pawns_in_front = sum(1 for sq in board.piece_map() if board.piece_at(sq).color == chess.WHITE and chess.square_rank(sq) > chess.square_rank(white_king_square))\n    black_pawns_in_front = sum(1 for sq in board.piece_map() if board.piece_at(sq).color == chess.BLACK and chess.square_rank(sq) < chess.square_rank(black_king_square))\n    return float(white_pawns_in_front - black_pawns_in_front)\n\n",
    "def feature(board: chess.Board) -> float:\n    'Evaluates the presence of pieces on the opponent\u2019s 7th and 2nd ranks which can indicate a strong position.'\n    white_threats = sum(1 for square in board.piece_map() if board.piece_map()[square].color == chess.WHITE and chess.square_rank(square) == 6)\n    black_threats = sum(1 for square in board.piece_map() if board.piece_map()[square].color == chess.BLACK and chess.square_rank(square) == 1)\n    return float(white_threats - black_threats)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the ratio of minor pieces to major pieces for both players.\"\n    minor_pieces_white = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE and piece.piece_type in (chess.KNIGHT, chess.BISHOP))\n    major_pieces_white = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE and piece.piece_type in (chess.ROOK, chess.QUEEN))\n\n    minor_pieces_black = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK and piece.piece_type in (chess.KNIGHT, chess.BISHOP))\n    major_pieces_black = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK and piece.piece_type in (chess.ROOK, chess.QUEEN))\n\n    ratio_white = minor_pieces_white / major_pieces_white if major_pieces_white > 0 else 0\n    ratio_black = minor_pieces_black / major_pieces_black if major_pieces_black > 0 else 0\n    return float(ratio_white - ratio_black)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of central control squares occupied by each side.\"\n    central_squares = [chess.D4, chess.D5, chess.E4, chess.E5]\n    white_control = sum(1 for square in central_squares if board.piece_at(square) and board.piece_at(square).color == chess.WHITE)\n    black_control = sum(1 for square in central_squares if board.piece_at(square) and board.piece_at(square).color == chess.BLACK)\n    return float(white_control - black_control)\n\n",
    "def feature(board: chess.Board) -> float:\n    'Evaluates piece mobility based on the number of legal moves each piece can make.'\n    def mobility(color):\n        return sum(len(list(board.legal_moves)) for square in board.piece_map() if board.piece_map()[square].color == color)\n\n    white_mobility = mobility(chess.WHITE)\n    black_mobility = mobility(chess.BLACK)\n    return float(white_mobility - black_mobility)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of doubled pawns on both sides.\"\n    def count_doubled_pawns(color):\n        files = {}\n        for square in board.piece_map():\n            piece = board.piece_at(square)\n            if piece and piece.color == color and piece.piece_type == chess.PAWN:\n                file = chess.square_file(square)\n                if file in files:\n                    files[file] += 1\n                else:\n                    files[file] = 1\n        return sum(1 for count in files.values() if count > 1)\n      \n    white_doubled = count_doubled_pawns(chess.WHITE)\n    black_doubled = count_doubled_pawns(chess.BLACK)\n    return float(white_doubled - black_doubled)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the number of potential pinning threats against both kings.\"\n    white_pinning_threats = sum(1 for square in board.piece_map().keys() if board.piece_map()[square].color == chess.WHITE and any(board.is_attacked_by(chess.BLACK, square) for square in board.attackers(chess.BLACK, square)))\n    black_pinning_threats = sum(1 for square in board.piece_map().keys() if board.piece_map()[square].color == chess.BLACK and any(board.is_attacked_by(chess.WHITE, square) for square in board.attackers(chess.WHITE, square)))\n    return float(white_pinning_threats - black_pinning_threats)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the number of pieces each side has positioned on the 7th rank, indicating potential promotion advantage.\"\n    white_7th_rank = sum(1 for square in range(56, 64) if board.piece_at(square) and board.piece_at(square).color == chess.WHITE)\n    black_7th_rank = sum(1 for square in range(0, 8) if board.piece_at(square) and board.piece_at(square).color == chess.BLACK)\n    return float(white_7th_rank - black_7th_rank)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in the number of pieces on the 2nd and 7th ranks.\"\n    white_second_rank_pieces = sum(1 for square in range(8, 16) if board.piece_at(square) and board.piece_at(square).color == chess.WHITE)\n    black_seventh_rank_pieces = sum(1 for square in range(56, 64) if board.piece_at(square) and board.piece_at(square).color == chess.BLACK)\n    return float(white_second_rank_pieces - black_seventh_rank_pieces)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces within three squares of the kings.\"\n    white_king_square = next(square for square in board.piece_map() if board.piece_at(square).color == chess.WHITE and board.piece_at(square).piece_type == chess.KING)\n    black_king_square = next(square for square in board.piece_map() if board.piece_at(square).color == chess.BLACK and board.piece_at(square).piece_type == chess.KING)\n    nearby_pieces = sum(1 for piece_square in board.piece_map() if (chess.square_distance(white_king_square, piece_square) <= 3 or chess.square_distance(black_king_square, piece_square) <= 3))\n    return float(nearby_pieces)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the number of active pieces (pieces with legal moves) for each color.\"\n    white_active = sum(1 for move in board.legal_moves if board.piece_at(move.from_square).color == chess.WHITE)\n    black_active = sum(1 for move in board.legal_moves if board.piece_at(move.from_square).color == chess.BLACK)\n    return float(white_active - black_active)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Evaluates the pawn structure by counting doubled pawns for each side.\"\n    def doubled_pawn_count(color):\n        count = 0\n        files = set()\n        for square, piece in board.piece_map().items():\n            if piece.color == color and piece.piece_type == chess.PAWN:\n                file = chess.square_file(square)\n                if file in files:\n                    count += 1\n                files.add(file)\n        return count\n\n    white_doubled = doubled_pawn_count(chess.WHITE)\n    black_doubled = doubled_pawn_count(chess.BLACK)\n    return float(black_doubled - white_doubled)\n\n\n",
    "def feature(board: chess.Board) -> float:\n    'Calculates the total piece activity based on their mobility.'\n    activity_score = 0.0\n    for piece in board.piece_map().values():\n        mobility = len(list(board.legal_moves))  # Count all legal moves available\n        activity_score += mobility\n    return activity_score\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in the distance of each side's pieces to the opponent's back rank.\"\n    white_distance = sum(7 - chess.square_rank(square) for square in board.piece_map() if board.piece_map()[square].color == chess.WHITE)\n    black_distance = sum(chess.square_rank(square) for square in board.piece_map() if board.piece_map()[square].color == chess.BLACK)\n    return float(white_distance - black_distance)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the total number of pieces on the back rank for each side to assess king safety.\"\n    white_back_rank = sum(1 for square in range(56, 64) if board.piece_at(square))\n    black_back_rank = sum(1 for square in range(0, 8) if board.piece_at(square))\n    result = white_back_rank - black_back_rank\n    return float(result)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of unprotected pieces for the current player.\"\n    unprotected_pieces = sum(1 for square, piece in board.piece_map().items() if piece.color == board.turn and not any(board.is_attacked_by(not board.turn, square) for attacker_square in board.attackers(not board.turn, square)))\n    return float(unprotected_pieces)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of rooks on the same file for each side.\"\n    rooks_per_file_white = [0] * 8\n    rooks_per_file_black = [0] * 8\n    for square in board.piece_map():\n        piece = board.piece_map()[square]\n        if piece.color == chess.WHITE and piece.piece_type == chess.ROOK:\n            rooks_per_file_white[chess.square_file(square)] += 1\n        elif piece.color == chess.BLACK and piece.piece_type == chess.ROOK:\n            rooks_per_file_black[chess.square_file(square)] += 1\n    return float(max(rooks_per_file_white) - max(rooks_per_file_black))\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in piece activity based on their attack potential.\"\n    def piece_activity(color):\n        activity = 0\n        for square in board.piece_map():\n            piece = board.piece_map()[square]\n            if piece.color == color:\n                activity += len(board.attackers(not color, square))\n        return activity\n    \n    white_activity = piece_activity(chess.WHITE)\n    black_activity = piece_activity(chess.BLACK)\n    return float(white_activity - black_activity)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Assesses the balance of bishops on the board.\"\n    white_bishops = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE and piece.piece_type == chess.BISHOP)\n    black_bishops = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK and piece.piece_type == chess.BISHOP)\n    return float(white_bishops - black_bishops)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in piece values between the two sides.\"\n    piece_values = {chess.PAWN: 1, chess.KNIGHT: 3, chess.BISHOP: 3, chess.ROOK: 5, chess.QUEEN: 9, chess.KING: 0}\n    white_value = sum(piece_values[board.piece_at(sq).piece_type] for sq in board.piece_map() if board.piece_at(sq).color == chess.WHITE)\n    black_value = sum(piece_values[board.piece_at(sq).piece_type] for sq in board.piece_map() if board.piece_at(sq).color == chess.BLACK)\n    return float(white_value - black_value)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Evaluates the presence of open files for rooks.\"\n    open_files = sum(1 for file in range(8) if not any(board.piece_at(chess.square(file, rank)) for rank in range(8)))\n    return float(open_files)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the number of pieces on the board for each side.\"\n    white_piece_count = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE)\n    black_piece_count = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK)\n    return float(white_piece_count - black_piece_count)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the mobility of knights for both colors by counting their potential moves.\"\n    def knight_moves_count(color):\n        count = 0\n        for square, piece in board.piece_map().items():\n            if piece.color == color and piece.piece_type == chess.KNIGHT:\n                count += len(list(board.legal_moves))  # Count potential moves for the knight\n        return count\n\n    result = knight_moves_count(chess.WHITE) - knight_moves_count(chess.BLACK)\n    return float(result)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the ratio of active pieces (pieces that can move) to total pieces.\"\n    total_pieces = len(board.piece_map())\n    active_pieces = sum(1 for move in board.legal_moves)\n    return float(active_pieces) / total_pieces if total_pieces > 0 else 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the sum of the distance of all pieces from the nearest opponent's piece.\"\n    total_distance = 0\n    for square, piece in board.piece_map().items():\n        opponent_color = chess.BLACK if piece.color == chess.WHITE else chess.WHITE\n        nearest_distance = min(chess.square_distance(square, opp_square) for opp_square in board.piece_map().keys() if board.piece_map()[opp_square].color == opponent_color)\n        total_distance += nearest_distance\n    return float(total_distance)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the presence of doubled pawns for each side.\"\n    doubled_pawns_white = sum(1 for square in board.piece_map() if board.piece_map()[square].color == chess.WHITE and \n                               board.piece_map()[square].piece_type == chess.PAWN and \n                               (board.piece_at(chess.square_file(square) + 8) is not None or board.piece_at(chess.square_file(square) - 8) is not None))\n    doubled_pawns_black = sum(1 for square in board.piece_map() if board.piece_map()[square].color == chess.BLACK and \n                               board.piece_map()[square].piece_type == chess.PAWN and \n                               (board.piece_at(chess.square_file(square) + 8) is not None or board.piece_at(chess.square_file(square) - 8) is not None))\n    return float(doubled_pawns_white - doubled_pawns_black)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in pawns that have reached the opponent's 7th rank.\"\n    white_pawns_on_7th = sum(1 for square in board.piece_map() if board.piece_map()[square].color == chess.WHITE and chess.square_rank(square) == 6)\n    black_pawns_on_7th = sum(1 for square in board.piece_map() if board.piece_map()[square].color == chess.BLACK and chess.square_rank(square) == 1)\n    return float(white_pawns_on_7th - black_pawns_on_7th)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Evaluates the number of squares under attack for both sides to assess control.\"\n    white_attacks = sum(1 for square in chess.SQUARES if board.is_attacked_by(chess.WHITE, square))\n    black_attacks = sum(1 for square in chess.SQUARES if board.is_attacked_by(chess.BLACK, square))\n    return float(white_attacks - black_attacks)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in central pawn control for both sides.\"\n    def central_pawn_control(color):\n        pawns = [square for square in board.piece_map() if board.piece_map()[square].piece_type == chess.PAWN and board.piece_map()[square].color == color]\n        return sum(1 for square in pawns if chess.square_file(square) in {3, 4})\n    \n    white_control = central_pawn_control(chess.WHITE)\n    black_control = central_pawn_control(chess.BLACK)\n    return float(white_control - black_control)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the number of isolated pawns for each color.\"\n    def isolated_pawns(color):\n        pawns = [square for square in board.piece_map() if board.piece_map()[square].color == color and \n                  board.piece_map()[square].piece_type == chess.PAWN]\n        isolated = 0\n        for pawn in pawns:\n            file = chess.square_file(pawn)\n            if not (board.piece_at(chess.parse_square(f'{chr(file + 97)}{chess.square_rank(pawn) + 1}')) or \n                                   board.piece_at(chess.parse_square(f'{chr(file + 97)}{chess.square_rank(pawn) - 1}'))):\n                isolated += 1\n        return isolated\n\n    white_isolated = isolated_pawns(chess.WHITE)\n    black_isolated = isolated_pawns(chess.BLACK)\n    return float(white_isolated - black_isolated)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the average distance of all pieces to the opponent's king.\"\n    opponent_king_square = next(square for square, piece in board.piece_map().items() \n                                 if piece.piece_type == chess.KING and piece.color != board.turn)\n    total_distance = sum(chess.square_distance(square, opponent_king_square) \n                         for square, piece in board.piece_map().items() if piece.color == board.turn)\n    piece_count = sum(1 for piece in board.piece_map().values() if piece.color == board.turn)\n    result = total_distance / (piece_count if piece_count > 0 else 1)\n    return float(result)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the number of extra squares controlled by pawns in the opponent's half.\"\n    controlled_by_white = sum(1 for square in range(0, 32) if board.is_attacked_by(chess.WHITE, square))\n    controlled_by_black = sum(1 for square in range(32, 64) if board.is_attacked_by(chess.BLACK, square))\n    return float(controlled_by_white - controlled_by_black)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Evaluates the potential for promotion based on the distance of pawns from promotion.\"\n    def promotion_potential(color):\n        return sum(8 - chess.square_rank(square) if color == chess.WHITE else chess.square_rank(square) for square, piece in board.piece_map().items() if piece.color == color and piece.piece_type == chess.PAWN)\n    \n    return float(promotion_potential(chess.WHITE) - promotion_potential(chess.BLACK))\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces on the board that are unprotected.\"\n    unprotected_pieces = sum(1 for square, piece in board.piece_map().items() if piece.color == board.turn and not any(board.is_attacked_by(not board.turn, target_square) for target_square in board.attackers(not board.turn, square)))\n    return float(unprotected_pieces)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the number of squares that are double attacked by both players.\"\n    double_attacked_squares = sum(1 for sq in chess.SQUARES if len(board.attackers(chess.WHITE, sq)) > 0 and len(board.attackers(chess.BLACK, sq)) > 0)\n    return float(double_attacked_squares)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the sum of distances of pieces to their respective home ranks.\"\n    white_distance = sum(chess.square_rank(sq) for sq in board.piece_map() if board.piece_at(sq).color == chess.WHITE)\n    black_distance = sum(7 - chess.square_rank(sq) for sq in board.piece_map() if board.piece_at(sq).color == chess.BLACK)\n    return float(white_distance - black_distance)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the score for potential configurations on the board.\"\n    potential_configs = sum(1 for square in board.piece_map() if board.piece_map()[square].color == board.turn)\n    return float(potential_configs)\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the total distance of all pieces to the center squares (d4, d5, e4, e5).\"\n    center_squares = [chess.parse_square('d4'), chess.parse_square('d5'), chess.parse_square('e4'), chess.parse_square('e5')]\n    total_distance = 0\n    for sq in board.piece_map():\n        total_distance += min(chess.square_distance(sq, center_sq) for center_sq in center_squares)\n    return float(total_distance)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces that are within one square of the opponent's king.\"\n    threat_pieces = 0\n    king_square = chess.KING if board.turn else chess.KING + 6\n    king_pos = board.king(chess.WHITE) if board.turn else board.king(chess.BLACK)\n    for square in board.piece_map():\n        piece = board.piece_at(square)\n        if piece:\n            if chess.square_distance(square, king_pos) == 1:\n                threat_pieces += 1\n    return float(threat_pieces)\n\n",
    "def feature(board: chess.Board) -> float:\n    'Evaluates the number of pieces on each player\\'s back rank to assess readiness for action.'\n    white_back_rank_pieces = sum(1 for square in range(8) if board.piece_at(chess.square(square, 0)) and board.piece_at(chess.square(square, 0)).color == chess.WHITE)\n    black_back_rank_pieces = sum(1 for square in range(8) if board.piece_at(chess.square(square, 7)) and board.piece_at(chess.square(square, 7)).color == chess.BLACK)\n    return float(white_back_rank_pieces - black_back_rank_pieces)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the number of squares attacked by each player's pieces.\"\n    white_attacks = sum(board.is_attacked_by(chess.WHITE, square) for square in board.piece_map())\n    black_attacks = sum(board.is_attacked_by(chess.BLACK, square) for square in board.piece_map())\n    return float(white_attacks - black_attacks)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces attacked by each player's pieces.\"\n    white_attacked = sum(1 for square in board.piece_map() if board.is_attacked_by(chess.WHITE, square))\n    black_attacked = sum(1 for square in board.piece_map() if board.is_attacked_by(chess.BLACK, square))\n    return float(white_attacked - black_attacked)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the average position value of each player's pieces.\"\n    piece_values = [0, 0]  # Index 0 for White, Index 1 for Black\n    for square, piece in board.piece_map().items():\n        if piece:\n            position_value = chess.square_file(square) + chess.square_rank(square)  # Simplified value based on position \n            piece_values[0 if piece.color == chess.WHITE else 1] += position_value\n    return float(piece_values[0] - piece_values[1])\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the total number of double pawns for both sides.\"\n    double_pawns = {'white': 0, 'black': 0}\n    pawn_files = [0] * 8\n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.PAWN:\n            pawn_files[chess.square_file(square)] += 1\n\n    for count in pawn_files:\n        if count > 1:\n            double_pawns['white' if board.turn else 'black'] += count - 1\n  \n    return float(double_pawns['white'] - double_pawns['black'])\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the mobility of knights for both sides.\"\n    white_knight_mobility = sum(len(list(board.legal_moves)) for square in board.piece_map() if board.piece_map()[square].color == chess.WHITE and board.piece_map()[square].piece_type == chess.KNIGHT)\n    black_knight_mobility = sum(len(list(board.legal_moves)) for square in board.piece_map() if board.piece_map()[square].color == chess.BLACK and board.piece_map()[square].piece_type == chess.KNIGHT)\n    return float(white_knight_mobility - black_knight_mobility)\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the ratio of bishops to pawns for each color, giving insight into piece value balance.\"\n    bishops_white = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE and piece.piece_type == chess.BISHOP)\n    bishops_black = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK and piece.piece_type == chess.BISHOP)\n    pawns_white = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE and piece.piece_type == chess.PAWN)\n    pawns_black = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK and piece.piece_type == chess.PAWN)\n    ratio_white = bishops_white / pawns_white if pawns_white > 0 else 0\n    ratio_black = bishops_black / pawns_black if pawns_black > 0 else 0\n    return float(ratio_white - ratio_black)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the number of pieces not currently defending any squares.\"\n    non_defending_pieces = sum(1 for square, piece in board.piece_map().items() if piece.color == board.turn and not board.attackers(piece.color, square))\n    return float(non_defending_pieces)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of potential discovered attacks by each player.\"\n    discovered_attacks_count = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == board.turn:\n            potential_moves = [move for move in board.legal_moves if board.piece_at(square) and chess.square_file(move.from_square) == chess.square_file(square)]\n            discovered_attacks_count += len(potential_moves)\n    return float(discovered_attacks_count)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the number of pinned pieces for each side.\"\n    def count_pinned_pieces(color):\n        pinned_count = 0\n        for square, piece in board.piece_map().items():\n            if piece.color == color:\n                for attacker_square in board.attackers(not color, square):\n                    if board.is_check():\n                        pinned_count += 1\n                        break\n        return pinned_count\n\n    white_pinned = count_pinned_pieces(chess.WHITE)\n    black_pinned = count_pinned_pieces(chess.BLACK)\n    return float(white_pinned - black_pinned)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the percentage of pawns advanced beyond the third rank, indicating pawn structure.\"\n    white_advanced = sum(1 for square in board.piece_map() \n                         if board.piece_map()[square].color == chess.WHITE and chess.square_rank(square) > 2)\n    black_advanced = sum(1 for square in board.piece_map() \n                         if board.piece_map()[square].color == chess.BLACK and chess.square_rank(square) < 5)\n    total_pawns = white_advanced + black_advanced\n    return float((white_advanced - black_advanced) / total_pawns) if total_pawns > 0 else 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the mobility of the pieces for the current player.\"\n    mobility_score = len(list(board.legal_moves))\n    return float(mobility_score)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the number of squares controlled by each player's pawns.\"\n    def pawn_control(color):\n        controlled_squares = set()\n        for square in board.piece_map():\n            piece = board.piece_at(square)\n            if piece and piece.color == color and piece.piece_type == chess.PAWN:\n                if chess.square_rank(square) < 7:\n                    controlled_squares.add(square + 7)  # Moves forward\n                controlled_squares.add(square + 8 - 2 * (color == chess.WHITE))  # Attacks diagonally\n                \n        return len(controlled_squares)\n\n    white_controlled = pawn_control(chess.WHITE)\n    black_controlled = pawn_control(chess.BLACK)\n    return float(white_controlled - black_controlled)\n\n",
    "def feature(board: chess.Board) -> float:\n    'Measures the central control based on pieces occupying or controlling central squares.'\n    central_squares = [chess.D4, chess.D5, chess.E4, chess.E5]\n    white_control = sum(1 for sq in central_squares if board.is_attacked_by(chess.WHITE, sq) or board.piece_at(sq) and board.piece_at(sq).color == chess.WHITE)\n    black_control = sum(1 for sq in central_squares if board.is_attacked_by(chess.BLACK, sq) or board.piece_at(sq) and board.piece_at(sq).color == chess.BLACK)\n    result = float(white_control - black_control)\n    return result\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts how many squares each side's knights can reach within one move.\"\n    def knight_reach(color):\n        knight_moves = 0\n        for square, piece in board.piece_map().items():\n            if piece.color == color and piece.piece_type == chess.KNIGHT:\n                knight_moves += len(list(board.legal_moves))\n        return knight_moves\n    white_knight_moves = knight_reach(chess.WHITE)\n    black_knight_moves = knight_reach(chess.BLACK)\n    return float(white_knight_moves - black_knight_moves)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the ratio of material values of pieces currently on board.\"\n    material_values = {\n        chess.PAWN: 1,\n        chess.KNIGHT: 3,\n        chess.BISHOP: 3,\n        chess.ROOK: 5,\n        chess.QUEEN: 9,\n        chess.KING: 0\n    }\n    total_white_value = sum(material_values[piece.piece_type] for piece in board.piece_map().values() if piece.color == chess.WHITE)\n    total_black_value = sum(material_values[piece.piece_type] for piece in board.piece_map().values() if piece.color == chess.BLACK)\n    return float(total_white_value / (total_black_value if total_black_value > 0 else 1))\n\n",
    "def feature(board: chess.Board) -> float:\n    'Counts the number of pawns ready to promote (on the 7th rank).'\n    promoting_pawns = sum(1 for square, piece in board.piece_map().items() if piece.piece_type == chess.PAWN and piece.color == board.turn and chess.square_rank(square) == 6)\n    return float(promoting_pawns)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Assesses the central control by counting pieces in the central squares.\"\n    central_squares = [chess.D4, chess.D5, chess.E4, chess.E5]\n    central_control = sum(1 for square in central_squares if board.piece_at(square) and board.piece_at(square).color == board.turn)\n    return float(central_control)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of squares that are double attacked by pieces of both sides.\"\n    double_attacked_squares = set(square for square in range(64) if len(board.attackers(chess.WHITE, square)) > 0 and len(board.attackers(chess.BLACK, square)) > 0)\n    return float(len(double_attacked_squares))\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the total material advantage of the current player over the opponent.\"\n    material_values = {\n        chess.PAWN: 1,\n        chess.KNIGHT: 3,\n        chess.BISHOP: 3,\n        chess.ROOK: 5,\n        chess.QUEEN: 9,\n        chess.KING: 0\n    }\n    player_material = sum(material_values[piece.piece_type] for piece in board.piece_map().values() if piece.color == board.turn)\n    opponent_material = sum(material_values[piece.piece_type] for piece in board.piece_map().values() if piece.color != board.turn)\n    return float(player_material - opponent_material)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the average rank of all pieces on the board, indicating position strength.\"\n    total_rank = 0\n    piece_count = 0\n    for square, piece in board.piece_map().items():\n        total_rank += chess.square_rank(square)\n        piece_count += 1\n    return float(total_rank / piece_count if piece_count > 0 else 0)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in king safety based on the number of attacking pieces near each king.\"\n    white_attacks = sum(1 for square in chess.SQUARES if board.is_attacked_by(chess.WHITE, square) and board.piece_at(square) and board.piece_at(square).piece_type == chess.KING)\n    black_attacks = sum(1 for square in chess.SQUARES if board.is_attacked_by(chess.BLACK, square) and board.piece_at(square) and board.piece_at(square).piece_type == chess.KING)\n    return float(white_attacks - black_attacks)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces on the seventh rank for each color.\"\n    white_seventh_rank = sum(1 for file in range(8) if board.piece_at(chess.square(file, 6)) and board.piece_at(chess.square(file, 6)).color == chess.WHITE)\n    black_seventh_rank = sum(1 for file in range(8) if board.piece_at(chess.square(file, 1)) and board.piece_at(chess.square(file, 1)).color == chess.BLACK)\n    return float(white_seventh_rank - black_seventh_rank)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the ratio of minor pieces to major pieces on the board.\"\n    minor_white = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE and piece.piece_type in {chess.KNIGHT, chess.BISHOP})\n    major_white = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE and piece.piece_type in {chess.ROOK, chess.QUEEN})\n    minor_black = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK and piece.piece_type in {chess.KNIGHT, chess.BISHOP})\n    major_black = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK and piece.piece_type in {chess.ROOK, chess.QUEEN})\n\n    white_ratio = minor_white / (major_white + 1)  # Prevent division by zero\n    black_ratio = minor_black / (major_black + 1)  # Prevent division by zero\n\n    return float(white_ratio - black_ratio)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of pinned pieces each side has.\"\n    def count_pinned(color):\n        pinned_count = 0\n        for square, piece in board.piece_map().items():\n            if piece.color == color:\n                for attacker in board.attackers(not color, square):\n                    if board.piece_at(attacker).piece_type in {chess.ROOK, chess.QUEEN}:\n                        pinned_count += 1\n                        break\n        return pinned_count\n    \n    white_pinned = count_pinned(chess.WHITE)\n    black_pinned = count_pinned(chess.BLACK)\n    return float(white_pinned - black_pinned)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the number of safe squares available for each king.\"\n    white_safe_squares = sum(1 for square in range(64) if board.is_attacked_by(chess.BLACK, square) and board.piece_at(square) is None)\n    black_safe_squares = sum(1 for square in range(64) if board.is_attacked_by(chess.WHITE, square) and board.piece_at(square) is None)\n    return float(white_safe_squares - black_safe_squares)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the ratio of piece types still on the board for each color.\"\n    piece_types_white = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE)\n    piece_types_black = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK)\n    return float(piece_types_white) / (piece_types_black if piece_types_black > 0 else 1)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the average material value of pieces in each player's back rank.\"\n    white_back_rank_value = sum(piece.piece_type for sq, piece in board.piece_map().items() if piece.color == chess.WHITE and chess.square_rank(sq) == 0)\n    black_back_rank_value = sum(piece.piece_type for sq, piece in board.piece_map().items() if piece.color == chess.BLACK and chess.square_rank(sq) == 7)\n    return float(white_back_rank_value - black_back_rank_value)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the number of threats each player can make.\"\n    white_threats = sum(1 for square in board.piece_map() if board.piece_map()[square].color == chess.WHITE and board.legal_moves.count() > 0)\n    black_threats = sum(1 for square in board.piece_map() if board.piece_map()[square].color == chess.BLACK and board.legal_moves.count() > 0)\n    return float(white_threats - black_threats)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Evaluates the number of central control squares occupied by each side.\"\n    central_squares = [chess.D4, chess.D5, chess.E4, chess.E5]\n    white_control = sum(1 for square in central_squares if board.piece_at(square) and board.piece_at(square).color == chess.WHITE)\n    black_control = sum(1 for square in central_squares if board.piece_at(square) and board.piece_at(square).color == chess.BLACK)\n    return float(white_control - black_control)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the total distance of all pieces from their respective kings, indicating possible vulnerability.\"\n    white_king_square = board.king(chess.WHITE)\n    black_king_square = board.king(chess.BLACK)\n    distances = sum(chess.square_distance(square, white_king_square) for square, piece in board.piece_map().items() if piece.color == chess.WHITE)\n    distances -= sum(chess.square_distance(square, black_king_square) for square, piece in board.piece_map().items() if piece.color == chess.BLACK)\n    return float(distances)\n\n",
    "def feature(board: chess.Board) -> float:\n    'Calculates the number of connected pawns for each player, indicating pawn structure strength.'\n    connected_pawn_count = 0\n    for file in range(8):\n        last_pawn_rank = -1\n        for rank in range(8):\n            square = chess.square(file, rank)\n            if board.piece_at(square) and board.piece_at(square).piece_type == chess.PAWN:\n                if last_pawn_rank == rank - 1:  # Check if connected\n                    connected_pawn_count += 1\n                last_pawn_rank = rank\n    return float(connected_pawn_count)\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the number of pieces coordinated to control the same square.\"\n    coordinated_threats = {}\n    for square in board.piece_map():\n        if square not in coordinated_threats:\n            coordinated_threats[square] = {'white': 0, 'black': 0}\n        for attacker in board.attackers(chess.WHITE, square):\n            coordinated_threats[square]['white'] += 1\n        for attacker in board.attackers(chess.BLACK, square):\n            coordinated_threats[square]['black'] += 1\n    total_coords = sum(abs(coords['white'] - coords['black']) for coords in coordinated_threats.values())\n    return float(total_coords)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Assesses the balance of material across the board compared to the number of pieces.\"\n    material_values = {\n        chess.PAWN: 1,\n        chess.KNIGHT: 3,\n        chess.BISHOP: 3,\n        chess.ROOK: 5,\n        chess.QUEEN: 9,\n        chess.KING: 0\n    }\n    total_material = sum(material_values[piece.piece_type] for piece in board.piece_map().values())\n    total_pieces = len(board.piece_map())\n    average_material = total_material / total_pieces if total_pieces > 0 else 0\n    return float(average_material)\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the strength of open files for rooks.\"\n    def open_files(color):\n        occupy_count = 0\n        for file in range(8):\n            is_open = True\n            for rank in range(8):\n                piece = board.piece_at(chess.square(file, rank))\n                if piece and piece.color == color:\n                    occupy_count += 1\n                    is_open = False\n                elif piece and piece.color != color:\n                    is_open = False\n            if is_open:\n                occupy_count += 1\n        return occupy_count\n\n    return float(open_files(chess.WHITE) - open_files(chess.BLACK))\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the influence of bishops based on their diagonal control.\"\n    def bishop_control(color):\n        return sum(1 for square in board.piece_map() if board.piece_map()[square].color == color and \n                   board.piece_map()[square].piece_type == chess.BISHOP)\n    white_control = bishop_control(chess.WHITE)\n    black_control = bishop_control(chess.BLACK)\n    return float(white_control - black_control)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the value of knights in the opponent's territory.\"\n    knight_value = 3\n    opponent_knight_value = sum(knight_value for square in board.piece_map() if board.piece_map()[square].color != board.turn and board.piece_map()[square].piece_type == chess.KNIGHT and chess.square_rank(square) > 4)\n    return float(opponent_knight_value)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the ratio of minor pieces to the total number of pieces for each player.\"\n    total_white_pieces = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE)\n    total_black_pieces = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK)\n    \n    minor_white = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE and piece.piece_type in [chess.KNIGHT, chess.BISHOP])\n    minor_black = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK and piece.piece_type in [chess.KNIGHT, chess.BISHOP])\n    \n    ratio_white = minor_white / total_white_pieces if total_white_pieces > 0 else 0.0\n    ratio_black = minor_black / total_black_pieces if total_black_pieces > 0 else 0.0\n    result = ratio_white - ratio_black\n    return float(result)\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of doubled pawns for both sides.\"\n    white_doubled = sum(1 for f in range(8) if len([sq for sq in range(8) if board.piece_at(chess.square(f, sq)) and board.piece_at(chess.square(f, sq)).color == chess.WHITE]) > 1)\n    black_doubled = sum(1 for f in range(8) if len([sq for sq in range(8) if board.piece_at(chess.square(f, sq)) and board.piece_at(chess.square(f, sq)).color == chess.BLACK]) > 1)\n    return float(white_doubled - black_doubled)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the number of pieces in the back rank for both sides.\"\n    back_rank_white = sum(1 for square in range(56, 64) if board.piece_at(square) and board.piece_at(square).color == chess.WHITE)\n    back_rank_black = sum(1 for square in range(0, 8) if board.piece_at(square) and board.piece_at(square).color == chess.BLACK)\n    return float(back_rank_white - back_rank_black)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in total piece value between both sides, including pawns.\"\n    material_values = {\n        chess.PAWN: 1,\n        chess.KNIGHT: 3,\n        chess.BISHOP: 3,\n        chess.ROOK: 5,\n        chess.QUEEN: 9,\n        chess.KING: 0\n    }\n    white_material = sum(material_values[piece.piece_type] for piece in board.piece_map().values() if piece.color == chess.WHITE)\n    black_material = sum(material_values[piece.piece_type] for piece in board.piece_map().values() if piece.color == chess.BLACK)\n    return float(white_material - black_material)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces each player has in the opponent\u2019s half of the board.\"\n    white_half = range(0, 4)\n    black_half = range(4, 8)\n    white_count = sum(1.0 for sq in board.piece_map() if board.piece_at(sq).color == chess.WHITE and chess.square_rank(sq) in white_half)\n    black_count = sum(1.0 for sq in board.piece_map() if board.piece_at(sq).color == chess.BLACK and chess.square_rank(sq) in black_half)\n    return white_count - black_count\n\n",
    "def feature(board: chess.Board) -> float:\n    'Counts the number of pieces on the back rank for each side indicating readiness for action.'\n    white_back_rank = sum(1 for square in range(0, 8) if board.piece_at(chess.A7 + square) and board.piece_at(chess.A7 + square).color == chess.WHITE)\n    black_back_rank = sum(1 for square in range(0, 8) if board.piece_at(chess.A1 + square) and board.piece_at(chess.A1 + square).color == chess.BLACK)\n    return float(white_back_rank - black_back_rank)\n\n",
    "def feature(board: chess.Board) -> float:\n    'Calculates the mobility of each side based on the number of legal moves available.'\n    white_mobility = len(list(board.legal_moves)) if board.turn == chess.WHITE else 0\n    black_mobility = len(list(board.legal_moves)) if board.turn == chess.BLACK else 0\n    return float(white_mobility - black_mobility)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the total number of pieces that can move immediately (legal moves).\"\n    total_legal_moves = len(list(board.legal_moves))\n    return float(total_legal_moves)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the number of minor pieces (knights and bishops) each side has.\"\n    white_minor_pieces = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE and piece.piece_type in [chess.KNIGHT, chess.BISHOP])\n    black_minor_pieces = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK and piece.piece_type in [chess.KNIGHT, chess.BISHOP])\n    return float(white_minor_pieces - black_minor_pieces)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of advanced pawns for each side.\"\n    advanced_white = sum(1 for square in board.piece_map() if board.piece_map()[square].color == chess.WHITE and board.piece_map()[square].piece_type == chess.PAWN and chess.square_rank(square) > 4)\n    advanced_black = sum(1 for square in board.piece_map() if board.piece_map()[square].color == chess.BLACK and board.piece_map()[square].piece_type == chess.PAWN and chess.square_rank(square) < 3)\n    return float(advanced_white - advanced_black)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the total material advantage for each side, factoring in piece types and counts.\"\n    material_values = {\n        chess.PAWN: 1,\n        chess.KNIGHT: 3,\n        chess.BISHOP: 3,\n        chess.ROOK: 5,\n        chess.QUEEN: 9,\n        chess.KING: 0\n    }\n    def calculate_material(color):\n        return sum(material_values[piece.piece_type] for piece in board.piece_map().values() if piece.color == color)\n\n    white_material = calculate_material(chess.WHITE)\n    black_material = calculate_material(chess.BLACK)\n    return float(white_material - black_material)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts how many pieces each side has that are unprotected (attacked but not defended).\"\n    def count_unprotected(color):\n        count = 0\n        for square, piece in board.piece_map().items():\n            if piece.color == color and board.is_attacked_by(not color, square) and not any(board.is_attacked_by(color, attacker) for attacker in board.attackers(not color, square)):\n                count += 1\n        return count\n    \n    white_unprotected = count_unprotected(chess.WHITE)\n    black_unprotected = count_unprotected(chess.BLACK)\n    return float(black_unprotected - white_unprotected)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the number of pieces being attacked by more than one opposing piece.\"\n    white_doubly_attacked = sum(1 for square in board.piece_map() if board.is_attacked_by(chess.BLACK, square) and len(board.attackers(chess.BLACK, square)) > 1)\n    black_doubly_attacked = sum(1 for square in board.piece_map() if board.is_attacked_by(chess.WHITE, square) and len(board.attackers(chess.WHITE, square)) > 1)\n    return float(white_doubly_attacked - black_doubly_attacked)\n",
    "def feature(board: chess.Board) -> float:\n    \"Gauges king safety by counting the number of pieces defending each king.\"\n    white_king_square = board.king(chess.WHITE)\n    black_king_square = board.king(chess.BLACK)\n    white_defenders = len(board.attackers(chess.WHITE, white_king_square))\n    black_defenders = len(board.attackers(chess.BLACK, black_king_square))\n    return float(white_defenders - black_defenders)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the distance of pieces from the opponents' back rank to identify potential threats.\"\n    distance_sum = 0.0\n    for square, piece in board.piece_map().items():\n        if piece.color == board.turn:\n            distance = 7 - chess.square_rank(square) if board.turn == chess.WHITE else chess.square_rank(square)\n            distance_sum += distance\n    return distance_sum\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Evaluates the king safety based on the number of pieces around each king.\"\n    def king_safety(color):\n        king_square = next(square for square in board.piece_map() if board.piece_map()[square].piece_type == chess.KING and board.piece_map()[square].color == color)\n        surrounding_pieces_count = sum(1 for square in board.piece_map() if chess.square_distance(square, king_square) <= 1 and board.piece_map()[square].color == color)\n        return surrounding_pieces_count\n    \n    white_safety = king_safety(chess.WHITE)\n    black_safety = king_safety(chess.BLACK)\n    return float(white_safety - black_safety)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the total value of pieces in play within the opponent's half.\"\n    white_value = sum(piece.piece_type for square, piece in board.piece_map().items() if piece.color == chess.WHITE and chess.square_rank(square) < 4)\n    black_value = sum(piece.piece_type for square, piece in board.piece_map().items() if piece.color == chess.BLACK and chess.square_rank(square) > 3)\n    return float(white_value - black_value)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the total number of pawns on the board for both players, indicating endgame prospects.\"\n    pawns = sum(1 for piece in board.piece_map().values() if piece.piece_type == chess.PAWN)\n    return float(pawns)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the pawns' advancement by calculating how many pawns are on the 6th and 7th ranks.\"\n    advancing_pawns = 0\n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.PAWN:\n            if (piece.color == chess.WHITE and chess.square_rank(square) >= 6) or \\\n               (piece.color == chess.BLACK and chess.square_rank(square) <= 1):\n                advancing_pawns += 1\n    return float(advancing_pawns)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the total number of pieces on the board to assess material density.\"\n    total_white = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE)\n    total_black = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK)\n    return float(total_white - total_black)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of semi-open files for both players.\"\n    semi_open_files = 0\n    for file in range(8):\n        white_pawn_present = any(board.piece_at(chess.square(file, rank)) and board.piece_at(chess.square(file, rank)).color == chess.WHITE for rank in range(8))\n        black_pawn_present = any(board.piece_at(chess.square(file, rank)) and board.piece_at(chess.square(file, rank)).color == chess.BLACK for rank in range(8))\n        if white_pawn_present and not black_pawn_present:\n            semi_open_files += 1\n        elif black_pawn_present and not white_pawn_present:\n            semi_open_files -= 1\n    return float(semi_open_files)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the total number of piece pairs that can attack each other.\"\n    pairs = 0\n    for square in chess.SQUARES:\n        if board.piece_at(square) is not None:\n            attackers = board.attackers(board.piece_at(square).color, square)\n            pairs += len(attackers)\n    return float(pairs)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the sum of the ranks of all pieces for each player, indicating potential advancement.\"\n    white_score = sum(chess.square_rank(square) for square in board.piece_map() if board.piece_map()[square].color == chess.WHITE)\n    black_score = sum(chess.square_rank(square) for square in board.piece_map() if board.piece_map()[square].color == chess.BLACK)\n    return float(white_score - black_score)\n\n",
    "def feature(board: chess.Board) -> float:\n    'Counts how many squares are under attack by pawns for the player to move.'\n    pawn_attack_squares = 0\n    for square in board.piece_map():\n        piece = board.piece_at(square)\n        if piece and piece.color == board.turn and piece.piece_type == chess.PAWN:\n            file = chess.square_file(square)\n            rank = chess.square_rank(square)\n            # Check diagonal attacks\n            if file > 0 and rank < 7 and board.is_attacked_by(not board.turn, chess.parse_square(chess.square_name(square - 9))):\n                pawn_attack_squares += 1\n            if file < 7 and rank < 7 and board.is_attacked_by(not board.turn, chess.parse_square(chess.square_name(square - 7))):\n                pawn_attack_squares += 1\n\n    return float(pawn_attack_squares)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Assesses the difference in the number of pieces on the seventh rank.\"\n    white_seventh_rank_pieces = sum(1 for square in range(56, 64) if board.piece_at(square) and board.piece_at(square).color == chess.WHITE)\n    black_seventh_rank_pieces = sum(1 for square in range(0, 8) if board.piece_at(square) and board.piece_at(square).color == chess.BLACK)\n    return float(white_seventh_rank_pieces - black_seventh_rank_pieces)\n\n",
    "def feature(board: chess.Board) -> float:\n    'Measures the ratio of bishops to total pieces for each color.'\n    bishops_count = {chess.WHITE: 0, chess.BLACK: 0}\n    total_pieces = {chess.WHITE: 0, chess.BLACK: 0}\n    for square, piece in board.piece_map().items():\n        total_pieces[piece.color] += 1\n        if piece.piece_type == chess.BISHOP:\n            bishops_count[piece.color] += 1\n    ratio = (bishops_count[chess.WHITE] / total_pieces[chess.WHITE] if total_pieces[chess.WHITE] > 0 else 0) - \\\n            (bishops_count[chess.BLACK] / total_pieces[chess.BLACK] if total_pieces[chess.BLACK] > 0 else 0)\n    return float(ratio)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Evaluates the balance of the center pawns for each side.\"\n    center_pawns = [chess.D4, chess.D5, chess.E4, chess.E5]\n    white_center_pawns = sum(1 for square in center_pawns if board.piece_at(square) and board.piece_at(square).color == chess.WHITE)\n    black_center_pawns = sum(1 for square in center_pawns if board.piece_at(square) and board.piece_at(square).color == chess.BLACK)\n    return float(white_center_pawns - black_center_pawns)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Checks if there are threats to the opponent's major pieces.\"\n    threats = 0\n    for square, piece in board.piece_map().items():\n        if piece.color != board.turn and piece.piece_type in [chess.QUEEN, chess.ROOK, chess.BISHOP]:\n            if board.is_attacked_by(board.turn, square):\n                threats += 1\n    return float(threats)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Evaluates the rook activity by counting the number of open files they control.\"\n    def open_files(color):\n        controlled_files = set()\n        for square in chess.SQUARES:\n            piece = board.piece_at(square)\n            if piece and piece.color == color and piece.piece_type == chess.ROOK:\n                controlled_files.add(chess.square_file(square))\n        open_file_count = sum(1 for f in range(8) if not any(board.piece_at(chess.square(f, r)) for r in range(8)))\n        return open_file_count\n    \n    return float(open_files(chess.WHITE) - open_files(chess.BLACK))\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of squares occupied by each player's pieces in the central area of the board (d4, d5, e4, e5).\"\n    central_squares = [chess.parse_square('d4'), chess.parse_square('d5'), chess.parse_square('e4'), chess.parse_square('e5')]\n    white_central_count = sum(1 for square in central_squares if board.piece_at(square) and board.piece_at(square).color == chess.WHITE)\n    black_central_count = sum(1 for square in central_squares if board.piece_at(square) and board.piece_at(square).color == chess.BLACK)\n    return float(white_central_count - black_central_count)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in mobility between both players.\"\n    white_legal_moves = len(list(board.legal_moves)) if board.turn == chess.WHITE else 0\n    black_legal_moves = len(list(board.legal_moves)) if board.turn == chess.BLACK else 0\n    return float(white_legal_moves - black_legal_moves)\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the coordination of major pieces (rooks and queens).\"\n    white_major = [piece for piece in board.piece_map().values() if piece.color == chess.WHITE and piece.piece_type in [chess.ROOK, chess.QUEEN]]\n    black_major = [piece for piece in board.piece_map().values() if piece.color == chess.BLACK and piece.piece_type in [chess.ROOK, chess.QUEEN]]\n    return float(len(white_major) - len(black_major))\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Evaluates the material imbalance, counting the total value of pieces for each side.\"\n    material_values = {\n        chess.PAWN: 1,\n        chess.KNIGHT: 3,\n        chess.BISHOP: 3,\n        chess.ROOK: 5,\n        chess.QUEEN: 9,\n        chess.KING: 0\n    }\n    white_material = sum(material_values[piece.piece_type] for piece in board.piece_map().values() if piece.color == chess.WHITE)\n    black_material = sum(material_values[piece.piece_type] for piece in board.piece_map().values() if piece.color == chess.BLACK)\n    return float(white_material - black_material)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Evaluates control of key squares, specifically those around the opponent's king.\"\n    key_squares = {chess.parse_square('e4'), chess.parse_square('e5'), chess.parse_square('d4'), chess.parse_square('d5')}\n    def key_square_control(color):\n        return sum(1 for square in key_squares if board.is_attacked_by(color, square))\n    \n    white_control = key_square_control(chess.WHITE)\n    black_control = key_square_control(chess.BLACK)\n    return float(white_control - black_control)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the total value of pieces for both players based on standard chess piece values.\"\n    piece_values = {\n        chess.PAWN: 1,\n        chess.KNIGHT: 3,\n        chess.BISHOP: 3,\n        chess.ROOK: 5,\n        chess.QUEEN: 9,\n        chess.KING: 0  # King value can generally be ignored as it doesn't influence material balance\n    }\n    white_value = sum(piece_values[piece.piece_type] for piece in board.piece_map().values() if piece.color == chess.WHITE)\n    black_value = sum(piece_values[piece.piece_type] for piece in board.piece_map().values() if piece.color == chess.BLACK)\n    return float(white_value - black_value)\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the number of pieces attacked by both colors.\"\n    white_attacks = sum(1 for square in board.piece_map() if board.is_attacked_by(chess.WHITE, square))\n    black_attacks = sum(1 for square in board.piece_map() if board.is_attacked_by(chess.BLACK, square))\n    \n    return float(white_attacks - black_attacks)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the amount of control over the center (e4, d4, e5, d5 squares) by each side.\"\n    center_squares = [chess.parse_square('e4'), chess.parse_square('d4'), chess.parse_square('e5'), chess.parse_square('d5')]\n    white_control = sum(1 for square in center_squares if board.is_attacked_by(chess.WHITE, square))\n    black_control = sum(1 for square in center_squares if board.is_attacked_by(chess.BLACK, square))\n    return float(white_control - black_control)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Determines the total distance of all pieces from their side of the board.\"\n    total_distance = sum(chess.square_rank(square) if piece.color == chess.WHITE else 7 - chess.square_rank(square) \n                         for square, piece in board.piece_map().items())\n    return float(total_distance)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the number of open files for rooks of each color.\"\n    open_files = sum(1 for file in range(8) \n                     if all(board.piece_at(chess.square(file, rank)) is None for rank in range(8)))\n    white_rooks = sum(1 for square in board.piece_map() \n                      if board.piece_map()[square].color == chess.WHITE and \n                      board.piece_map()[square].piece_type == chess.ROOK and \n                      chess.square_file(square) in range(open_files))\n    black_rooks = sum(1 for square in board.piece_map() \n                      if board.piece_map()[square].color == chess.BLACK and \n                      board.piece_map()[square].piece_type == chess.ROOK and \n                      chess.square_file(square) in range(open_files))\n    return float(white_rooks - black_rooks)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of squares attacked by each player.\"\n    attacked_white = len([square for square in chess.SQUARES if board.is_attacked_by(chess.WHITE, square)])\n    attacked_black = len([square for square in chess.SQUARES if board.is_attacked_by(chess.BLACK, square)])\n    return float(attacked_white - attacked_black)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Evaluates the king's safety by counting defending pieces around each side's king.\"\n    def king_safety(color):\n        king_square = next(square for square, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color == color)\n        return sum(1 for square in board.attackers(not color, king_square) if board.is_attacked_by(color, square))\n    white_safety = king_safety(chess.WHITE)\n    black_safety = king_safety(chess.BLACK)\n    return float(black_safety - white_safety)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Evaluates the presence of rooks on open files for both players.\"\n    open_file_count = 0\n    for file in range(8):\n        if all(board.piece_at(chess.square(file, rank)) is None for rank in range(8)):\n            if any(board.piece_at(chess.square(file, rank)).piece_type == chess.ROOK for rank in range(8) if board.piece_at(chess.square(file, rank)) is not None):\n                open_file_count += 1\n    return float(open_file_count)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of moves that put the opponent's king in check.\"\n    opponent_color = chess.BLACK if board.turn else chess.WHITE\n    check_count = sum(1 for move in board.legal_moves if board.is_check())\n    return float(check_count)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the control of the center squares (d4, d5, e4, e5) by each side.\"\n    center_squares = [chess.D4, chess.D5, chess.E4, chess.E5]\n    white_control = sum(1 for square in center_squares if board.is_attacked_by(chess.WHITE, square))\n    black_control = sum(1 for square in center_squares if board.is_attacked_by(chess.BLACK, square))\n    return float(white_control - black_control)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Evaluates the symmetry of the board by counting similar pieces in mirrored positions.\"\n    mirrored_positions = [(chess.A1, chess.H1), (chess.B1, chess.G1), (chess.C1, chess.F1), (chess.D1, chess.E1)]\n    symmetry_count = sum(1 for a, b in mirrored_positions if board.piece_at(a) and board.piece_at(b) and board.piece_at(a).color == board.piece_at(b).color)\n    return float(symmetry_count)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the control of the center squares by measuring pieces and pawn presence.\"\n    central_squares = [chess.D4, chess.D5, chess.E4, chess.E5]\n    white_control = sum(1 for square in central_squares if board.piece_at(square) and board.piece_at(square).color == chess.WHITE)\n    black_control = sum(1 for square in central_squares if board.piece_at(square) and board.piece_at(square).color == chess.BLACK)\n    return float(white_control - black_control)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the overall fitness of pawns considering their advanced positions.\"\n    advanced_pawns = sum(1 for square in board.piece_map() if board.piece_at(square).piece_type == chess.PAWN and (chess.square_rank(square) >= 4 if board.piece_at(square).color == chess.WHITE else chess.square_rank(square) <= 3))\n    return float(advanced_pawns)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures king safety by counting the number of squares available to move away from an attack.\"\n    king_square = next(square for square, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color == board.turn)\n    safe_moves = sum(1 for square in board.legal_moves if square.to_square == king_square and not board.is_attacked_by(not board.turn, square.to_square))\n    return float(safe_moves)\n\n",
    "def feature(board: chess.Board) -> float:\n    'Measures the number of doubled pawns for each side.'\n    white_doubled_pawns = sum(1 for file in range(8) if sum(1 for rank in range(8) if board.piece_at(chess.square(file, rank)) == chess.PAWN and piece.color == chess.WHITE) > 1)\n    black_doubled_pawns = sum(1 for file in range(8) if sum(1 for rank in range(8) if board.piece_at(chess.square(file, rank)) == chess.PAWN and piece.color == chess.BLACK) > 1)\n    return float(white_doubled_pawns - black_doubled_pawns)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Assesses the number of pieces currently defending each king to evaluate safety.\"\n    white_defenders = sum(1 for square in chess.SQUARES if board.is_attacked_by(chess.BLACK, square) and board.piece_at(square) is not None and board.piece_at(square).color == chess.WHITE)\n    black_defenders = sum(1 for square in chess.SQUARES if board.is_attacked_by(chess.WHITE, square) and board.piece_at(square) is not None and board.piece_at(square).color == chess.BLACK)\n    return float(white_defenders - black_defenders)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the number of pieces that are pinned (unable to move without exposing the king).\"\n    pinned_count = 0\n    for square in board.piece_map():\n        piece = board.piece_map()[square]\n        if piece.color == board.turn:\n            for move in board.legal_moves:\n                if move.from_square == square and board.is_check():\n                    pinned_count += 1\n    return float(pinned_count)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the activity of rooks by counting the number of open files available.\"\n    open_files = sum(1 for file in range(8) if all(board.piece_at(chess.square(file, rank)) is None for rank in range(8)))\n    result = float(open_files)\n    return result\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Evaluates the presence of hanging pieces susceptible to capture.\"\n    hanging_pieces = sum(1 for square, piece in board.piece_map().items() if piece.color == board.turn and not board.attackers(not piece.color, square))\n    return float(hanging_pieces)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the number of pieces each side has on the back rank.\"\n    white_back_rank_pieces = sum(1 for square in range(56, 64) if board.piece_at(square) and board.piece_at(square).color == chess.WHITE)\n    black_back_rank_pieces = sum(1 for square in range(0, 8) if board.piece_at(square) and board.piece_at(square).color == chess.BLACK)\n    return float(white_back_rank_pieces - black_back_rank_pieces)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of fork opportunities available for the player.\"\n    fork_opportunities = 0\n    for move in board.legal_moves:\n        board.push(move)\n        if len(board.attackers(board.piece_at(move.to_square).color, move.to_square)) > 1:\n            fork_opportunities += 1\n        board.pop()\n    return float(fork_opportunities)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in the number of pieces each side has on the promotion rank.\"\n    white_on_promotion = sum(1 for square in board.piece_map() if board.piece_map()[square].color == chess.WHITE and chess.square_rank(square) == 7)\n    black_on_promotion = sum(1 for square in board.piece_map() if board.piece_map()[square].color == chess.BLACK and chess.square_rank(square) == 0)\n    return float(white_on_promotion - black_on_promotion)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the number of advanced pawns for both sides.\"\n    white_advanced_pawns = sum(1 for square, piece in board.piece_map().items() if piece.color == chess.WHITE and piece.piece_type == chess.PAWN and chess.square_rank(square) >= 5)\n    black_advanced_pawns = sum(1 for square, piece in board.piece_map().items() if piece.color == chess.BLACK and piece.piece_type == chess.PAWN and chess.square_rank(square) <= 3)\n    return float(white_advanced_pawns - black_advanced_pawns)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the development of minor pieces, evaluating knights and bishops.\"\n    white_development = sum(1 for square in board.piece_map() if board.piece_at(square).color == chess.WHITE and board.piece_at(square).piece_type in (chess.KNIGHT, chess.BISHOP))\n    black_development = sum(1 for square in board.piece_map() if board.piece_at(square).color == chess.BLACK and board.piece_at(square).piece_type in (chess.KNIGHT, chess.BISHOP))\n    result = white_development - black_development\n    return float(result)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures control of the center by counting the pawns on d4, d5, e4, e5 squares.\"\n    center_control = 0\n    for square in [chess.parse_square('d4'), chess.parse_square('d5'), chess.parse_square('e4'), chess.parse_square('e5')]:\n        piece = board.piece_at(square)\n        if piece:\n            if piece.color == chess.WHITE:\n                center_control += 1\n            else:\n                center_control -= 1\n    return float(center_control)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Evaluates the potential for creating passed pawns depending on pawn structure.\"\n    white_passed = sum(1 for square in board.piece_map() if board.piece_map()[square].color == chess.WHITE and board.piece_map()[square].piece_type == chess.PAWN and not any(board.piece_at(file) for file in range(chess.square_file(square)) if board.piece_at(chess.parse_square(chess.square_name(file + chess.square_rank(square)))) is not None))\n    black_passed = sum(1 for square in board.piece_map() if board.piece_map()[square].color == chess.BLACK and board.piece_map()[square].piece_type == chess.PAWN and not any(board.piece_at(file) for file in range(chess.square_file(square)) if board.piece_at(chess.parse_square(chess.square_name(file + chess.square_rank(square)))) is not None))\n    return float(white_passed - black_passed)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the potential for promotion by counting pawns on the 7th rank.\"\n    white_pawns_on_7th = sum(1 for square in board.piece_map() if board.piece_map()[square].piece_type == chess.PAWN and board.piece_map()[square].color == chess.WHITE and chess.square_rank(square) == 6)\n    black_pawns_on_7th = sum(1 for square in board.piece_map() if board.piece_map()[square].piece_type == chess.PAWN and board.piece_map()[square].color == chess.BLACK and chess.square_rank(square) == 1)\n    return float(white_pawns_on_7th - black_pawns_on_7th)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the relative piece activity by counting pieces that have more than one legal move.\"\n    active_piece_count = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == board.turn:\n            legal_moves = list(board.legal_moves)\n            if any(move.from_square == square for move in legal_moves):\n                active_piece_count += 1\n    return float(active_piece_count)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the distance of kings from their respective front lines.\"\n    white_king_square = next(square for square, piece in board.piece_map().items() if piece.color == chess.WHITE and piece.piece_type == chess.KING)\n    black_king_square = next(square for square, piece in board.piece_map().items() if piece.color == chess.BLACK and piece.piece_type == chess.KING)\n    white_distance = 7 - chess.square_rank(white_king_square)\n    black_distance = chess.square_rank(black_king_square)\n    return float(white_distance - black_distance)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the total value of pieces on the board for each color.\"\n    piece_values = {chess.PAWN: 1, chess.KNIGHT: 3, chess.BISHOP: 3, chess.ROOK: 5, chess.QUEEN: 9, chess.KING: 0}\n    white_value = sum(piece_values[piece.piece_type] for piece in board.piece_map().values() if piece.color == chess.WHITE)\n    black_value = sum(piece_values[piece.piece_type] for piece in board.piece_map().values() if piece.color == chess.BLACK)\n    return float(white_value - black_value)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the distance of the closest opposing piece to the player's king.\"\n    king_square = next(square for square in board.piece_map() if board.piece_map()[square].piece_type == chess.KING and board.piece_map()[square].color == board.turn)\n    closest_piece_distance = float('inf')\n    \n    for square, piece in board.piece_map().items():\n        if piece.color != board.turn:\n            distance = chess.square_distance(king_square, square)\n            closest_piece_distance = min(closest_piece_distance, distance)\n\n    return 1 / (closest_piece_distance + 1)  # Return a value that increases as distance decreases\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the control of the center squares by both sides.\"\n    center_squares = [chess.E4, chess.E5, chess.D4, chess.D5]\n    white_control = sum(1 for square in center_squares if board.is_attacked_by(chess.WHITE, square))\n    black_control = sum(1 for square in center_squares if board.is_attacked_by(chess.BLACK, square))\n    return float(white_control - black_control)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the number of available captures for the current turn.\"\n    current_turn = board.turn\n    available_captures = sum(1 for move in board.legal_moves if board.piece_at(move.to_square) is not None and board.piece_at(move.to_square).color != current_turn)\n    return float(available_captures)\n\n",
    "def feature(board: chess.Board) -> float:\n    'Calculates the total distance of all pieces from their starting ranks.'\n    distance = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == chess.WHITE:\n            distance += chess.square_rank(square)  # Distance for white pieces\n        else:\n            distance += 7 - chess.square_rank(square)  # Distance for black pieces\n    return float(distance)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the total number of open files available for rooks.\"\n    def open_file_count(color):\n        count = 0\n        for file in range(8):\n            if all(not board.piece_at(chess.square(file, rank)) or board.piece_at(chess.square(file, rank)).color != color for rank in range(8)):\n                count += 1\n        return count\n\n    white_open_files = open_file_count(chess.WHITE)\n    black_open_files = open_file_count(chess.BLACK)\n    return float(white_open_files - black_open_files)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the pawn distance to promotion for each pawn to evaluate offensive potential.\"\n    total_distance = sum(7 - chess.square_rank(square) for square, piece in board.piece_map().items() if piece.piece_type == chess.PAWN)\n    return float(total_distance)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the total number of pieces being attacked by each side.\"\n    white_attacked = sum(1 for square in board.piece_map() if board.piece_map()[square].color == chess.WHITE and board.is_attacked_by(chess.BLACK, square))\n    black_attacked = sum(1 for square in board.piece_map() if board.piece_map()[square].color == chess.BLACK and board.is_attacked_by(chess.WHITE, square))\n    return float(white_attacked - black_attacked)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the number of pieces that are currently pinned by the opponent's pieces.\"\n    def count_pinned_pieces(color):\n        pinned_count = 0\n        for square, piece in board.piece_map().items():\n            if piece.color == color:\n                for target_square in board.attackers(not color, square):\n                    if board.piece_at(target_square):\n                        pinned_count += 1\n                        break\n        return pinned_count\n    \n    white_pinned = count_pinned_pieces(chess.WHITE)\n    black_pinned = count_pinned_pieces(chess.BLACK)\n    return float(white_pinned - black_pinned)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the sum of the distance of all pieces from their respective starting positions.\"\n    total_distance = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == chess.WHITE:\n            starting_rank = 6  # White pieces start from rank 6\n        else:\n            starting_rank = 1  # Black pieces start from rank 1\n            \n        distance = chess.square_rank(square) - starting_rank\n        total_distance += abs(distance)\n    return float(total_distance)\n\n",
    "def feature(board: chess.Board) -> float:\n    'Measures the difference in king safety, based on the number of defenders around each king.'\n    def king_safety(color):\n        king_square = next(square for square, piece in board.piece_map().items() if piece.color == color and piece.piece_type == chess.KING)\n        return len(board.attackers(color, king_square))\n\n    white_defenders = king_safety(chess.WHITE)\n    black_defenders = king_safety(chess.BLACK)\n    return float(black_defenders - white_defenders)\n\n",
    "def feature(board: chess.Board) -> float:\n    'Counts the number of squares controlled by each side based on piece placement.'\n    white_controlled_squares = set()\n    black_controlled_squares = set()\n    for square, piece in board.piece_map().items():\n        for move in board.legal_moves:\n            if move.from_square == square:\n                if piece.color == chess.WHITE:\n                    white_controlled_squares.add(move.to_square)\n                else:\n                    black_controlled_squares.add(move.to_square)\n    return float(len(white_controlled_squares) - len(black_controlled_squares))\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of defending pieces around the kings.\"\n    white_king_square = next(square for square, piece in board.piece_map().items() if piece.color == chess.WHITE and piece.piece_type == chess.KING)\n    black_king_square = next(square for square, piece in board.piece_map().items() if piece.color == chess.BLACK and piece.piece_type == chess.KING)\n    white_defenders = sum(board.is_attacked_by(chess.WHITE, square) for square in board.attackers(chess.BLACK, black_king_square))\n    black_defenders = sum(board.is_attacked_by(chess.BLACK, square) for square in board.attackers(chess.WHITE, white_king_square))\n    return float(white_defenders - black_defenders)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of squares that are attacked by each side, indicating potential tactical opportunities.\"\n    white_attacks = sum(1 for square in chess.SQUARES if board.is_attacked_by(chess.WHITE, square))\n    black_attacks = sum(1 for square in chess.SQUARES if board.is_attacked_by(chess.BLACK, square))\n    result = float(white_attacks - black_attacks)\n    return result\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the average distance of pieces from their home squares.\"\n    total_distance = 0\n    piece_count = 0\n    home_squares = {\n        chess.PAWN: [chess.A7, chess.B7, chess.C7, chess.D7, chess.E7, chess.F7, chess.G7, chess.H7],\n        chess.ROOK: [chess.A8, chess.H8],\n        chess.KNIGHT: [chess.B8, chess.G8],\n        chess.BISHOP: [chess.C8, chess.F8],\n        chess.QUEEN: [chess.D8],\n        chess.KING: [chess.E8],\n    }\n    \n    for square, piece in board.piece_map().items():\n        piece_count += 1\n        home_positions = home_squares.get(piece.piece_type, [])\n        for home in home_positions:\n            total_distance += chess.square_distance(square, home)\n    \n    return total_distance / piece_count if piece_count > 0 else 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the number of doubled pawns for each player.\"\n    def count_doubled_pawns(color):\n        pawn_files = [0] * 8\n        for square, piece in board.piece_map().items():\n            if piece.color == color and piece.piece_type == chess.PAWN:\n                pawn_files[chess.square_file(square)] += 1\n        return sum(1 for count in pawn_files if count > 1)\n\n    white_doubled = count_doubled_pawns(chess.WHITE)\n    black_doubled = count_doubled_pawns(chess.BLACK)\n    return float(white_doubled - black_doubled)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the distance of pieces from the center of the board.\"\n    center_squares = [chess.parse_square('d4'), chess.parse_square('d5'), chess.parse_square('e4'), chess.parse_square('e5')]\n    white_distance = sum(chess.square_distance(square, center) for center in center_squares for square in board.piece_map() if board.piece_map()[square].color == chess.WHITE)\n    black_distance = sum(chess.square_distance(square, center) for center in center_squares for square in board.piece_map() if board.piece_map()[square].color == chess.BLACK)\n    return float(black_distance - white_distance)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures how many pawns are on the 6th and 7th ranks, indicating promotion potential.\"\n    pawn_rank_count = sum(1 for square in range(chess.A7, chess.H7 + 1) if board.piece_at(square) is not None and board.piece_at(square).piece_type == chess.PAWN)\n    pawn_rank_count += sum(1 for square in range(chess.A6, chess.H6 + 1) if board.piece_at(square) is not None and board.piece_at(square).piece_type == chess.PAWN)\n    return float(pawn_rank_count)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the number of pieces attacking the opponent's king.\"\n    opponent_king_square = next(square for square in board.piece_map() if board.piece_map()[square].piece_type == chess.KING and board.piece_map()[square].color != board.turn)\n    attacking_pieces = sum(1 for piece_square in board.piece_map() if board.is_attacked_by(board.turn, piece_square) and board.piece_map()[piece_square].color == board.turn)\n    return float(attacking_pieces)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the number of pieces that can be developed in the next move.\"\n    white_developables = sum(1 for move in board.legal_moves if board.piece_map()[move.from_square].color == chess.WHITE and move.to_square in [chess.C3, chess.F3, chess.C6, chess.F6])\n    black_developables = sum(1 for move in board.legal_moves if board.piece_map()[move.from_square].color == chess.BLACK and move.to_square in [chess.C3, chess.F3, chess.C6, chess.F6])\n    return float(white_developables - black_developables)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in material value between the two sides, focusing on non-pawn pieces.\"\n    piece_value = {chess.KNIGHT: 3, chess.BISHOP: 3, chess.ROOK: 5, chess.QUEEN: 9}\n    white_value = sum(piece_value.get(piece.piece_type, 0) for piece in board.piece_map().values() if piece.color == chess.WHITE)\n    black_value = sum(piece_value.get(piece.piece_type, 0) for piece in board.piece_map().values() if piece.color == chess.BLACK)\n    result = white_value - black_value\n    return float(result)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the number of pieces that are currently pinned by an opponent's piece.\"\n    pinned_pieces = sum(1 for square, piece in board.piece_map().items() if piece.color == board.turn and board.is_attacked_by(not board.turn, square))\n    return float(pinned_pieces)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the threat level of the most powerful piece opposing the current turn.\"\n    opponent_color = chess.BLACK if board.turn else chess.WHITE\n    threat_value = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == opponent_color and piece.piece_type in {chess.QUEEN, chess.ROOK, chess.KNIGHT, chess.BISHOP}:\n            threat_value = max(threat_value, {chess.QUEEN: 9, chess.ROOK: 5, chess.KNIGHT: 3, chess.BISHOP: 3}[piece.piece_type])\n    return float(threat_value)\n",
    "def feature(board: chess.Board) -> float:\n    \"Assesses the king's activity based on the number of available escape routes.\"\n    king_square = next(square for square in board.piece_map() if board.piece_map()[square].color == board.turn and board.piece_map()[square].piece_type == chess.KING)\n    escape_routes = sum(1 for move in board.legal_moves if chess.square_distance(move.from_square, king_square) == 1)\n    return float(escape_routes)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the king safety index based on pawn coverage around kings.\"\n    white_king_safety = sum(1 for square in [chess.parse_square('g1'), chess.parse_square('f1'), chess.parse_square('g2'), chess.parse_square('f2')] \n                             if board.piece_at(square) is not None and board.piece_at(square).color == chess.WHITE)\n    black_king_safety = sum(1 for square in [chess.parse_square('g8'), chess.parse_square('f8'), chess.parse_square('g7'), chess.parse_square('f7')]\n                             if board.piece_at(square) is not None and board.piece_at(square).color == chess.BLACK)\n    return float(white_king_safety - black_king_safety)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the number of piece exchanges available for the current turn.\"\n    exchange_moves_count = sum(1 for move in board.legal_moves if \n                                board.is_attacked_by(not board.turn, move.to_square))\n    return float(exchange_moves_count)\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the number of pieces on the back rank for both sides.\"\n    white_back_rank = sum(1 for square in range(chess.A1, chess.H1 + 1) if board.piece_at(square) and board.piece_at(square).color == chess.WHITE)\n    black_back_rank = sum(1 for square in range(chess.A8, chess.H8 + 1) if board.piece_at(square) and board.piece_at(square).color == chess.BLACK)\n    return float(white_back_rank - black_back_rank)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the total material value for each side, normalized by the number of pieces.\"\n    material_values = {\n        chess.PAWN: 1,\n        chess.KNIGHT: 3,\n        chess.BISHOP: 3,\n        chess.ROOK: 5,\n        chess.QUEEN: 9,\n        chess.KING: 0\n    }\n    white_material = sum(material_values[piece.piece_type] for piece in board.piece_map().values() if piece.color == chess.WHITE)\n    black_material = sum(material_values[piece.piece_type] for piece in board.piece_map().values() if piece.color == chess.BLACK)\n    white_pieces_count = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE)\n    black_pieces_count = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK)\n    white_average = white_material / white_pieces_count if white_pieces_count > 0 else 0\n    black_average = black_material / black_pieces_count if black_pieces_count > 0 else 0\n    return float(white_average - black_average)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Assesses the pawn structure by counting isolated pawns.\"\n    isolated_pawns = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == board.turn and piece.piece_type == chess.PAWN:\n            file = chess.square_file(square)\n            if (board.piece_at(chess.square(file - 1, chess.square_rank(square))) is None and\n                board.piece_at(chess.square(file + 1, chess.square_rank(square))) is None):\n                isolated_pawns += 1\n    return float(isolated_pawns)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Quantifies the number of undeveloped minor pieces (knights and bishops) for both sides.\"\n    white_undeveloped = sum(1 for square in board.piece_map() if board.piece_map()[square].color == chess.WHITE and board.piece_map()[square].piece_type in (chess.KNIGHT, chess.BISHOP) and (chess.square_rank(square) == 0 or chess.square_rank(square) == 1))\n    black_undeveloped = sum(1 for square in board.piece_map() if board.piece_map()[square].color == chess.BLACK and board.piece_map()[square].piece_type in (chess.KNIGHT, chess.BISHOP) and (chess.square_rank(square) == 6 or chess.square_rank(square) == 7))\n    return float(white_undeveloped - black_undeveloped)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures how many checks the opponent can make in the next move.\"\n    opponent_checks = 0\n    for move in board.legal_moves:\n        opponent_board = board.copy()\n        opponent_board.push(move)\n        if opponent_board.is_check():\n            opponent_checks += 1\n    return float(opponent_checks)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the amount of space controlled by pawns for both sides.\"\n    white_space_control = sum(1 for square in board.piece_map() if board.piece_map()[square].color == chess.WHITE and board.piece_map()[square].piece_type == chess.PAWN and \n                               (board.piece_at(square + 8) is None or board.piece_at(square + 8) is None))\n    black_space_control = sum(1 for square in board.piece_map() if board.piece_map()[square].color == chess.BLACK and board.piece_map()[square].piece_type == chess.PAWN and \n                               (board.piece_at(square - 8) is None or board.piece_at(square - 8) is None))\n    return float(white_space_control - black_space_control)\n",
    "def feature(board: chess.Board) -> float:\n    \"Assesses piece positioning by averaging the ranks and files of all pieces.\"\n    position_sum = 0\n    total_pieces = 0\n    for square in range(0, 64):\n        piece = board.piece_at(square)\n        if piece is not None:\n            position_sum += (chess.square_rank(square) + chess.square_file(square))\n            total_pieces += 1\n    return position_sum / total_pieces if total_pieces > 0 else 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the piece activity of bishops based on their control over diagonals.\"\n    def bishop_activity(color):\n        return sum(1 for square in board.piece_map() if board.piece_map()[square].color == color \n                   and board.piece_map()[square].piece_type == chess.BISHOP \n                   and (chess.square_distance(square, chess.A1) < 7 or chess.square_distance(square, chess.H8) < 7))\n    \n    white_activity = bishop_activity(chess.WHITE)\n    black_activity = bishop_activity(chess.BLACK)\n    return float(white_activity - black_activity)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the influence of pieces on key squares (center and back rank).\"\n    key_squares = [chess.D4, chess.D5, chess.E4, chess.E5, chess.A8, chess.H8]\n    white_influence = sum(1 for square in key_squares if board.is_attacked_by(chess.WHITE, square))\n    black_influence = sum(1 for square in key_squares if board.is_attacked_by(chess.BLACK, square))\n    return float(white_influence - black_influence)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the total number of pieces that are currently defending each player's king.\"\n    white_defenders = sum(1 for sq in board.attackers(chess.WHITE, board.king(chess.WHITE)))\n    black_defenders = sum(1 for sq in board.attackers(chess.BLACK, board.king(chess.BLACK)))\n    return float(white_defenders - black_defenders)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Evaluates the control of the center squares (d4, e4, d5, e5).\"\n    center_squares = [chess.D4, chess.E4, chess.D5, chess.E5]\n    white_control = sum(1 for square in center_squares if board.is_attacked_by(chess.WHITE, square))\n    black_control = sum(1 for square in center_squares if board.is_attacked_by(chess.BLACK, square))\n    return float(white_control - black_control)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures king safety based on the number of squares around the king that are attacked.\"\n    king_square = next(square for square, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color == board.turn)\n    attacked_squares = sum(1 for square in chess.SQUARES if board.is_attacked_by(not board.turn, square) and chess.square_distance(square, king_square) <= 1)\n    return float(attacked_squares)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Assess if the position is potentially a draw due to insufficient material.\"\n    return float(1.0 if board.is_insufficient_material() else 0.0)\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the number of squares controlled by each player.\"\n    white_control = sum(1 for square in chess.SQUARES if board.is_attacked_by(chess.WHITE, square))\n    black_control = sum(1 for square in chess.SQUARES if board.is_attacked_by(chess.BLACK, square))\n    return float(white_control - black_control)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the mobility of bishops by counting the number of diagonally accessible squares.\"\n    def bishop_mobility(color):\n        mobility = 0\n        for square in board.piece_map():\n            if board.piece_map()[square].color == color and board.piece_map()[square].piece_type == chess.BISHOP:\n                rank, file = chess.square_rank(square), chess.square_file(square)\n                for dx in range(-7, 8):\n                    for dy in range(-7, 8):\n                        if abs(dx) == abs(dy) and dx != 0:\n                            target_square = chess.square(file + dx, rank + dy)\n                            if 0 <= file + dx < 8 and 0 <= rank + dy < 8 and board.piece_at(target_square) is None:\n                                mobility += 1\n        return mobility\n\n    white_mobility = bishop_mobility(chess.WHITE)\n    black_mobility = bishop_mobility(chess.BLACK)\n    return float(white_mobility - black_mobility)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the difference in king safety by counting nearby enemy pieces.\"\n    def count_threats(color):\n        threat_count = 0\n        king_square = next(square for square, piece in board.piece_map().items() if piece.color == color and piece.piece_type == chess.KING)\n        for attacker in board.attackers(not color, king_square):\n            threat_count += 1\n        return threat_count\n    \n    white_threats = count_threats(chess.WHITE)\n    black_threats = count_threats(chess.BLACK)\n    return float(black_threats - white_threats)\n\n",
    "def feature(board: chess.Board) -> float:\n    'Calculates the number of pieces that are currently pinned to their own king.'\n    pinned_pieces = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == board.turn:\n            if board.is_attacked_by(not piece.color, square):\n                # Check if this piece is pinned by the opponent's line piece\n                for attacker in board.attackers(not piece.color, square):\n                    if board.piece_at(attacker).piece_type in (chess.ROOK, chess.QUEEN):\n                        if (piece.color == chess.WHITE and square < attacker) or (piece.color == chess.BLACK and square > attacker):\n                            pinned_pieces += 1\n                            break\n    return float(pinned_pieces)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Evaluates the structural integrity of each player's pawn structure.\"\n    white_pawns = [square for square in board.piece_map() if board.piece_at(square).piece_type == chess.PAWN and board.piece_at(square).color == chess.WHITE]\n    black_pawns = [square for square in board.piece_map() if board.piece_at(square).piece_type == chess.PAWN and board.piece_at(square).color == chess.BLACK]\n    white_pawn_structure = sum(1 for pawn in white_pawns if board.piece_at(pawn - 8) is None)\n    black_pawn_structure = sum(1 for pawn in black_pawns if board.piece_at(pawn + 8) is None)\n    return float(white_pawn_structure - black_pawn_structure)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the mobility of both players by counting their legal moves.\"\n    white_mobility = len(list(board.legal_moves)) if board.turn else 0\n    black_mobility = len(list(board.legal_moves)) if not board.turn else 0\n    return float(white_mobility - black_mobility)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the total number of pawn chains for each side.\"\n    def count_pawn_chains(color):\n        pawn_chains = 0\n        for file in range(8):\n            chain_active = False\n            for rank in range(8):\n                square = chess.square(file, rank)\n                if board.piece_at(square) and board.piece_at(square).color == color and board.piece_at(square).piece_type == chess.PAWN:\n                    if not chain_active:\n                        pawn_chains += 1\n                        chain_active = True\n                else:\n                    chain_active = False\n        return pawn_chains\n    return float(count_pawn_chains(chess.WHITE) - count_pawn_chains(chess.BLACK))\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the ratio of pieces defending each king for both sides.\"\n    def defending_pieces(color):\n        king_square = next(square for square in board.piece_map() if board.piece_map()[square].color == color and board.piece_map()[square].piece_type == chess.KING)\n        return sum(1 for square in board.piece_map() if board.piece_map()[square].color == color and board.is_attacked_by(color, king_square))\n\n    white_defenders = defending_pieces(chess.WHITE)\n    black_defenders = defending_pieces(chess.BLACK)\n    return float(white_defenders - black_defenders)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the total number of pieces that are pinned by the opponent.\"\n    pinned_count = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == chess.WHITE:\n            for move in board.legal_moves:\n                if move.from_square == square and board.is_check():\n                    pinned_count += 1\n    return float(pinned_count)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the number of pieces pinned against the king for both sides.\"\n    pinned_pieces = 0\n    for square, piece in board.piece_map().items():\n        if piece.piece_type != chess.KING and board.is_attacked_by(not piece.color, square):\n            # Check if the piece is pinned against their king\n            if board.is_attacked_by(piece.color, next(sq for sq, p in board.piece_map().items() if p.piece_type == chess.KING and p.color == piece.color)):\n                pinned_pieces += 1\n    return float(pinned_pieces)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the number of potential discovered attacks that can be made.\"\n    discovered_attacks = 0\n    for square in board.piece_map():\n        piece = board.piece_map()[square]\n        if piece.color == board.turn:\n            for move in board.legal_moves:\n                if move.from_square == square:\n                    # Assuming the move may uncover an attack\n                    potential_target = move.to_square\n                    for target in board.attackers(not piece.color, potential_target):\n                        if board.piece_map()[target].color != piece.color:\n                            discovered_attacks += 1\n    return float(discovered_attacks)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Evaluates the number of pieces on the back rank for each side.\"\n    white_back_rank = sum(1 for square in board.piece_map() \n                          if board.piece_map()[square].color == chess.WHITE and \n                          chess.square_rank(square) == 0)\n    black_back_rank = sum(1 for square in board.piece_map() \n                          if board.piece_map()[square].color == chess.BLACK and \n                          chess.square_rank(square) == 7)\n    return float(white_back_rank - black_back_rank)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Evaluates the total number of squares controlled by pieces on the back rank.\"\n    back_rank_squares = [chess.A8, chess.B8, chess.C8, chess.D8, chess.E8, chess.F8, chess.G8, chess.H8] if board.turn == chess.BLACK else [chess.A1, chess.B1, chess.C1, chess.D1, chess.E1, chess.F1, chess.G1, chess.H1]\n    controlled_squares = sum(1 for square in back_rank_squares if board.is_attacked_by(board.turn, square))\n    return float(controlled_squares)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the distance of pieces from the opponent's king.\"\n    white_king_square = next(square for square, piece in board.piece_map().items() if piece.color == chess.WHITE and piece.piece_type == chess.KING)\n    black_king_square = next(square for square, piece in board.piece_map().items() if piece.color == chess.BLACK and piece.piece_type == chess.KING)\n    distances = [chess.square_distance(square, black_king_square) for square in board.piece_map() if board.piece_map()[square].color == chess.WHITE]\n    return float(sum(distances) / len(distances)) if distances else 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Computes the value of pieces in play weighted by their distance to the center.\"\n    piece_value = {chess.PAWN: 1, chess.KNIGHT: 3, chess.BISHOP: 3, chess.ROOK: 5, chess.QUEEN: 9, chess.KING: 0}\n    total_value = sum(piece_value[board.piece_at(square).piece_type] / (1 + chess.square_distance(square, chess.D4)) for square in board.piece_map() if board.piece_at(square) is not None)\n    return float(total_value)\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the mobility of pieces by counting the number of squares each piece can move to.\"\n    def count_mobility(color):\n        return sum(len(list(board.legal_moves)) for key, piece in board.piece_map().items() if piece.color == color)\n    \n    white_mobility = count_mobility(chess.WHITE)\n    black_mobility = count_mobility(chess.BLACK)\n    return float(white_mobility - black_mobility)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the number of isolated pawns for each side.\"\n    def isolated_pawn_count(color):\n        count = 0\n        for square in board.piece_map():\n            piece = board.piece_map()[square]\n            if piece.color == color and piece.piece_type == chess.PAWN:\n                file = chess.square_file(square)\n                if not (board.piece_at(chess.square(file - 1, chess.square_rank(square))) and board.piece_at(chess.square(file - 1, chess.square_rank(square))).color == color) and \\\n                        not (board.piece_at(chess.square(file + 1, chess.square_rank(square))) and board.piece_at(chess.square(file + 1, chess.square_rank(square))).color == color):\n                    count += 1\n        return count\n\n    white_isolated = isolated_pawn_count(chess.WHITE)\n    black_isolated = isolated_pawn_count(chess.BLACK)\n    return float(white_isolated - black_isolated)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the mobility of the current player by counting legal moves.\"\n    mobility = len(list(board.legal_moves))\n    return float(mobility)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Evaluates king safety by counting the number of available escape squares around the kings.\"\n    def escape_squares_count(color):\n        king_square = next(square for square in board.piece_map() if board.piece_map()[square].color == color and board.piece_map()[square].piece_type == chess.KING)\n        return sum(1 for square in range(64) if chess.square_distance(king_square, square) == 1 and board.piece_at(square) is None)\n    white_escape = escape_squares_count(chess.WHITE)\n    black_escape = escape_squares_count(chess.BLACK)\n    return float(white_escape - black_escape)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the potential for double attacks by counting attacking pieces.\"\n    white_double_attack = sum(1 for square in board.piece_map() if board.piece_map()[square].color == chess.WHITE and len(board.attackers(chess.BLACK, square)) > 1)\n    black_double_attack = sum(1 for square in board.piece_map() if board.piece_map()[square].color == chess.BLACK and len(board.attackers(chess.WHITE, square)) > 1)\n    return float(white_double_attack - black_double_attack)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the number of pieces on the back rank for each color.\"\n    white_back_rank = sum(1 for square in range(56, 64) if board.piece_at(square) and board.piece_at(square).color == chess.WHITE)\n    black_back_rank = sum(1 for square in range(0, 8) if board.piece_at(square) and board.piece_at(square).color == chess.BLACK)\n    return float(white_back_rank - black_back_rank)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of squares with more than one piece to assess congestion.\"\n    congested_squares = sum(1 for square in board.piece_map() if \n                             len(board.attackers(chess.WHITE, square)) > 1 or \n                             len(board.attackers(chess.BLACK, square)) > 1)\n    result = float(congested_squares)\n    return result\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the total number of squares attacked by each side.\"\n    white_attacked = len(board.attackers(chess.WHITE, chess.A1)) + \\\n                     len(board.attackers(chess.WHITE, chess.A2)) + \\\n                     len(board.attackers(chess.WHITE, chess.A3)) + \\\n                     len(board.attackers(chess.WHITE, chess.A4)) + \\\n                     len(board.attackers(chess.WHITE, chess.A5)) + \\\n                     len(board.attackers(chess.WHITE, chess.A6)) + \\\n                     len(board.attackers(chess.WHITE, chess.A7)) + \\\n                     len(board.attackers(chess.WHITE, chess.A8))\n                     \n    black_attacked = len(board.attackers(chess.BLACK, chess.A1)) + \\\n                     len(board.attackers(chess.BLACK, chess.A2)) + \\\n                     len(board.attackers(chess.BLACK, chess.A3)) + \\\n                     len(board.attackers(chess.BLACK, chess.A4)) + \\\n                     len(board.attackers(chess.BLACK, chess.A5)) + \\\n                     len(board.attackers(chess.BLACK, chess.A6)) + \\\n                     len(board.attackers(chess.BLACK, chess.A7)) + \\\n                     len(board.attackers(chess.BLACK, chess.A8))\n                     \n    return float(white_attacked - black_attacked)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Determines the number of pieces each side has on the center four squares for spatial control.\"\n    center_squares = [chess.D4, chess.D5, chess.E4, chess.E5]\n    white_center_pieces = sum(1 for square in center_squares if board.piece_at(square) and board.piece_at(square).color == chess.WHITE)\n    black_center_pieces = sum(1 for square in center_squares if board.piece_at(square) and board.piece_at(square).color == chess.BLACK)\n    return float(white_center_pieces - black_center_pieces)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the number of squares under attack by each side.\"\n    white_attacks = sum(1 for square in range(64) if board.is_attacked_by(chess.WHITE, square))\n    black_attacks = sum(1 for square in range(64) if board.is_attacked_by(chess.BLACK, square))\n    return float(white_attacks - black_attacks)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the number of pinned pieces for both sides.\"\n    pinned_pieces = 0\n    for square, piece in board.piece_map().items():\n        for move in board.legal_moves:\n            if move.from_square == square:\n                target_piece = board.piece_at(move.to_square)\n                if target_piece and target_piece.color != piece.color and board.is_attacked_by(piece.color, move.to_square):\n                    pinned_pieces += 1\n                    break\n    return float(pinned_pieces)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the number of pawns advanced past the opponent's 4th rank.\"\n    advanced_pawns = 0\n    \n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.PAWN and piece.color == chess.WHITE:\n            if chess.square_rank(square) > 3:\n                advanced_pawns += 1\n        elif piece.piece_type == chess.PAWN and piece.color == chess.BLACK:\n            if chess.square_rank(square) < 4:\n                advanced_pawns += 1\n    \n    return float(advanced_pawns)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in piece activity by considering the number of legal moves each side has.\"\n    white_moves = len(list(board.legal_moves))\n    black_moves = len(list(board.legal_moves))\n    return float(white_moves - black_moves)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the potential mobility of rooks based on the number of open files.\"\n    open_files = sum(1 for file in range(8) if all(board.piece_at(file + rank * 8) is None for rank in range(8)))\n    return float(open_files)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in piece value between each side, considering only the major pieces.\"\n    major_piece_values = {\n        chess.ROOK: 5,\n        chess.QUEEN: 9\n    }\n    white_major_value = sum(major_piece_values.get(piece.piece_type, 0) for piece in board.piece_map().values() if piece.color == chess.WHITE)\n    black_major_value = sum(major_piece_values.get(piece.piece_type, 0) for piece in board.piece_map().values() if piece.color == chess.BLACK)\n    return float(white_major_value - black_major_value)\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the average distance of each side's pieces from their back rank.\"\n    def average_distance(color):\n        distances = []\n        for square, piece in board.piece_map().items():\n            if piece.color == color:\n                distances.append(chess.square_rank(square) if color == chess.WHITE else 7 - chess.square_rank(square))\n        return sum(distances) / len(distances) if distances else 0\n\n    white_average_distance = average_distance(chess.WHITE)\n    black_average_distance = average_distance(chess.BLACK)\n    return float(white_average_distance - black_average_distance)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the total number of pawn islands for each side.\"\n    def count_pawn_islands(color):\n        rank_groups = [[] for _ in range(8)]\n        for square, piece in board.piece_map().items():\n            if piece.color == color and piece.piece_type == chess.PAWN:\n                file = chess.square_file(square)\n                rank_groups[file].append(square)\n        return sum(1 for group in rank_groups if group)\n    \n    white_islands = count_pawn_islands(chess.WHITE)\n    black_islands = count_pawn_islands(chess.BLACK)\n    return float(white_islands - black_islands)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the mobility of both sides based on the number of legal moves.\"\n    white_mobility = len(list(board.legal_moves)) if board.turn == chess.WHITE else 0\n    black_mobility = len(list(board.legal_moves)) if board.turn == chess.BLACK else 0\n    return float(white_mobility - black_mobility)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the kings' safety scores based on surrounding piece protection.\"\n    def king_safety(color):\n        king_square = next(square for square, piece in board.piece_map().items() if piece.color == color and piece.piece_type == chess.KING)\n        return sum(1 for square in board.attackers(color, king_square))\n    \n    white_safety = king_safety(chess.WHITE)\n    black_safety = king_safety(chess.BLACK)\n    return float(white_safety - black_safety)\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the potential for piece development by counting piece types that can move.\"\n    mobile_pieces = sum(1 for move in board.legal_moves)\n    return float(mobile_pieces)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in the number of pieces near the corners for each side.\"\n    def pieces_in_corners(color):\n        corner_squares = [chess.A1, chess.A8, chess.H1, chess.H8]\n        return sum(1 for square in corner_squares if board.piece_at(square) and board.piece_at(square).color == color)\n\n    white_corners = pieces_in_corners(chess.WHITE)\n    black_corners = pieces_in_corners(chess.BLACK)\n    return float(white_corners - black_corners)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Evaluates the number of pieces each side has on the second rank, indicating development.\"\n    white_second_rank = sum(1 for square in range(0, 8) if board.piece_at(chess.square(square, 1)) and board.piece_at(chess.square(square, 1)).color == chess.WHITE)\n    black_second_rank = sum(1 for square in range(0, 8) if board.piece_at(chess.square(square, 6)) and board.piece_at(chess.square(square, 6)).color == chess.BLACK)\n    return float(white_second_rank - black_second_rank)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the average piece value of pieces within the opponent's territory.\"\n    opponent_piece_values = {\n        chess.PAWN: 1, chess.KNIGHT: 3, chess.BISHOP: 3,\n        chess.ROOK: 5, chess.QUEEN: 9, chess.KING: 0\n    }\n    opponent_territory_count = 0\n    total_value = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == (chess.WHITE if board.turn else chess.BLACK):\n            if chess.square_rank(square) > 4:  # Assuming 0-3 for one side, 4-7 for the other.\n                total_value += opponent_piece_values[piece.piece_type]\n                opponent_territory_count += 1\n    return total_value / opponent_territory_count if opponent_territory_count > 0 else 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the number of pieces each side has on the back rank.\"\n    back_rank = [chess.A8, chess.B8, chess.C8, chess.D8, chess.E8, chess.F8, chess.G8, chess.H8] if board.turn == chess.BLACK else [chess.A1, chess.B1, chess.C1, chess.D1, chess.E1, chess.F1, chess.G1, chess.H1]\n    white_back_rank = sum(1 for square in back_rank if board.piece_at(square) and board.piece_at(square).color == chess.WHITE)\n    black_back_rank = sum(1 for square in back_rank if board.piece_at(square) and board.piece_at(square).color == chess.BLACK)\n    return float(white_back_rank - black_back_rank)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the number of squares controlled by each side.\"\n    white_control = sum(1 for square in chess.SQUARES if board.is_attacked_by(chess.WHITE, square))\n    black_control = sum(1 for square in chess.SQUARES if board.is_attacked_by(chess.BLACK, square))\n    result = white_control - black_control\n    return float(result)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in the number of rooks on open files.\"\n    open_files_white = sum(1 for square in range(56, 64) if board.piece_at(square) and board.piece_at(square).color == chess.WHITE and chess.square_file(square) != 0 and not any(board.piece_at(chess.square_file(square) + i) for i in range(1, 8)))\n    open_files_black = sum(1 for square in range(0, 8) if board.piece_at(square) and board.piece_at(square).color == chess.BLACK and chess.square_file(square) != 0 and not any(board.piece_at(chess.square_file(square) - i) for i in range(1, 8)))\n    return float(open_files_white - open_files_black)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the material value of all pieces that can be captured immediately.\"\n    material_value = 0\n    for move in board.legal_moves:\n        target_piece = board.piece_at(move.to_square)\n        if target_piece:\n            material_value += target_piece.piece_type\n    return float(material_value)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the number of pieces each player has in the opponent's half of the board.\"\n    white_in_enemy_half = sum(1 for square, piece in board.piece_map().items() \n                                if piece.color == chess.WHITE and chess.square_rank(square) > 4)\n    black_in_enemy_half = sum(1 for square, piece in board.piece_map().items() \n                                if piece.color == chess.BLACK and chess.square_rank(square) < 4)\n    result = float(white_in_enemy_half - black_in_enemy_half)\n    return result\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the central control for both sides.\"\n    central_squares = [chess.E4, chess.D4, chess.E5, chess.D5]\n    white_control = sum(1 for square in central_squares if board.is_attacked_by(chess.WHITE, square))\n    black_control = sum(1 for square in central_squares if board.is_attacked_by(chess.BLACK, square))\n    return float(white_control - black_control)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the imbalance in piece value by comparing knights and bishops for both sides.\"\n    material_values = {chess.PAWN: 1, chess.KNIGHT: 3, chess.BISHOP: 3}\n    white_knights = sum(material_values[chess.KNIGHT] for piece in board.piece_map().values() if piece.color == chess.WHITE and piece.piece_type == chess.KNIGHT)\n    white_bishops = sum(material_values[chess.BISHOP] for piece in board.piece_map().values() if piece.color == chess.WHITE and piece.piece_type == chess.BISHOP)\n    black_knights = sum(material_values[chess.KNIGHT] for piece in board.piece_map().values() if piece.color == chess.BLACK and piece.piece_type == chess.KNIGHT)\n    black_bishops = sum(material_values[chess.BISHOP] for piece in board.piece_map().values() if piece.color == chess.BLACK and piece.piece_type == chess.BISHOP)\n    return float((white_knights - black_knights) + (white_bishops - black_bishops))\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Evaluates the difference in mobility based on the number of legal moves.\"\n    white_mobility = len(list(board.legal_moves)) if board.turn == chess.WHITE else 0\n    black_mobility = len(list(board.legal_moves)) if board.turn == chess.BLACK else 0\n    return float(white_mobility - black_mobility)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of opponent's pieces that can be easily captured without retaliation.\"\n    unprotected_threats = sum(1 for square, piece in board.piece_map().items() if piece.color != board.turn and not any(board.is_attacked_by(not board.turn, target_square) for target_square in board.attackers(board.turn, square)))\n    return float(unprotected_threats)\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces attacked by both players to indicate pressure.\"\n    white_attacks = sum(1 for square in board.piece_map() if board.is_attacked_by(chess.WHITE, square))\n    black_attacks = sum(1 for square in board.piece_map() if board.is_attacked_by(chess.BLACK, square))\n    return float(white_attacks - black_attacks)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the number of isolated pawns for each side.\"\n    def is_isolated_pawn(square, color):\n        file = chess.square_file(square)\n        if color == chess.WHITE:\n            return (file == 0 or board.piece_at(chess.square(file - 1, 1)) is None) and (file == 7 or board.piece_at(chess.square(file + 1, 1)) is None)\n        else:\n            return (file == 0 or board.piece_at(chess.square(file - 1, 6)) is None) and (file == 7 or board.piece_at(chess.square(file + 1, 6)) is None)\n\n    white_isolated = sum(1 for square in board.piece_map() if board.piece_map()[square].color == chess.WHITE and board.piece_map()[square].piece_type == chess.PAWN and is_isolated_pawn(square, chess.WHITE))\n    black_isolated = sum(1 for square in board.piece_map() if board.piece_map()[square].color == chess.BLACK and board.piece_map()[square].piece_type == chess.PAWN and is_isolated_pawn(square, chess.BLACK))\n\n    return float(white_isolated - black_isolated)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts how many pieces each player has attacking their opponent's pieces.\"\n    white_attacks = sum(1 for square in chess.SQUARES for move in board.legal_moves if board.is_attacked_by(chess.WHITE, move.to_square) and board.piece_at(move.to_square) and board.piece_at(move.to_square).color != chess.WHITE)\n    black_attacks = sum(1 for square in chess.SQUARES for move in board.legal_moves if board.is_attacked_by(chess.BLACK, move.to_square) and board.piece_at(move.to_square) and board.piece_at(move.to_square).color != chess.BLACK)\n    return float(white_attacks - black_attacks)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the total distance of all pieces from the center of the board, reflecting overall control.\"\n    total_distance = 0\n    for square, piece in board.piece_map().items():\n        total_distance += chess.square_distance(square, chess.parse_square('d4')) + chess.square_distance(square, chess.parse_square('e4'))\n    return float(total_distance)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates mobility advantage by examining legal moves.\"\n    white_mobility = len(list(board.legal_moves)) if board.turn == chess.WHITE else 0\n    black_mobility = len(list(board.legal_moves)) if board.turn == chess.BLACK else 0\n    return float(white_mobility - black_mobility)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the number of potential threats considering piece safety.\"\n    threats = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == board.turn:\n            threats += len(list(board.attackers(not board.turn, square)))\n    return float(threats)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the distance of the kings from the center (e4 and e5).\"\n    white_king_square = next((square for square, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color == chess.WHITE), None)\n    black_king_square = next((square for square, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color == chess.BLACK), None)\n    if white_king_square is not None and black_king_square is not None:\n        distance_white = chess.square_distance(white_king_square, chess.E4)\n        distance_black = chess.square_distance(black_king_square, chess.E5)\n        return float(distance_white - distance_black)\n    return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Determines the number of squares attacking pawns by both players.\"\n    white_attacks = sum(1 for square in board.piece_map() \n                        if board.piece_map()[square].color == chess.WHITE and \n                        board.piece_map()[square].piece_type == chess.PAWN and \n                        any(board.is_attacked_by(chess.BLACK, attack_square) for attack_square in board.attackers(chess.WHITE, square)))\n    black_attacks = sum(1 for square in board.piece_map() \n                        if board.piece_map()[square].color == chess.BLACK and \n                        board.piece_map()[square].piece_type == chess.PAWN and \n                        any(board.is_attacked_by(chess.WHITE, attack_square) for attack_square in board.attackers(chess.BLACK, square)))\n    result = float(white_attacks - black_attacks)\n    return result\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in potential future threats by counting pieces that can attack on the next move.\"\n    white_threats = sum(1 for square in board.piece_map() if board.piece_map()[square].color == chess.WHITE and board.is_attacked_by(chess.BLACK, square))\n    black_threats = sum(1 for square in board.piece_map() if board.piece_map()[square].color == chess.BLACK and board.is_attacked_by(chess.WHITE, square))\n    return float(white_threats - black_threats)\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the number of squares occupied by both players' knights.\"\n    knight_count = sum(1 for square, piece in board.piece_map().items() \n                       if piece.piece_type == chess.KNIGHT\n                      )\n    return float(knight_count)\n\n",
    "def feature(board: chess.Board) -> float:\n    'Measures the number of legal moves available for the player to move.'\n    return float(len(list(board.legal_moves)))  # Number of legal moves\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the potential of the rooks by counting their ranks and files control.\"\n    rook_value = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == board.turn and piece.piece_type == chess.ROOK:\n            rook_value += (chess.square_rank(square) + chess.square_file(square))\n    return float(rook_value)\n\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in the number of pawns advanced for each side.\"\n    white_advanced_pawns = sum(1 for sq in board.piece_map() if board.piece_at(sq).piece_type == chess.PAWN and chess.square_rank(sq) > 4)\n    black_advanced_pawns = sum(1 for sq in board.piece_map() if board.piece_at(sq).piece_type == chess.PAWN and chess.square_rank(sq) < 3)\n    \n    return float(white_advanced_pawns - black_advanced_pawns)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the distance of each player's pieces from their king to assess support.\"\n    white_king_square = next(sq for sq, p in board.piece_map().items() if p.piece_type == chess.KING and p.color == chess.WHITE)\n    black_king_square = next(sq for sq, p in board.piece_map().items() if p.piece_type == chess.KING and p.color == chess.BLACK)\n    \n    white_distance = sum(chess.square_distance(white_king_square, sq) for sq, piece in board.piece_map().items() if piece.color == chess.WHITE)\n    black_distance = sum(chess.square_distance(black_king_square, sq) for sq, piece in board.piece_map().items() if piece.color == chess.BLACK)\n\n    return float(white_distance - black_distance)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the region of the board each king controls (defined by the squares around them).\"\n    def king_control(sq):\n        king_squares = [sq + 1, sq - 1, sq + 8, sq - 8, sq + 7, sq - 7, sq + 9, sq - 9]\n        return sum(1 for ksq in king_squares if ksq in chess.SQUARES and board.is_attacked_by(board.piece_at(sq).color, ksq))\n\n    white_king_square = next(square for square, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color == chess.WHITE)\n    black_king_square = next(square for square, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color == chess.BLACK)\n    return float(king_control(white_king_square) - king_control(black_king_square))\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in pawn structure between both sides by comparing isolated and doubled pawns.\"\n    white_isolated = 0\n    black_isolated = 0\n    white_doubled = 0\n    black_doubled = 0\n\n    def analyze_pawns():\n        for file in range(8):\n            white_pawn = board.piece_at(chess.square(file, 1))\n            black_pawn = board.piece_at(chess.square(file, 6))\n            if (white_pawn and white_pawn.piece_type == chess.PAWN):\n                if (file > 0 and not board.piece_at(chess.square(file - 1, 1))) and (file < 7 and not board.piece_at(chess.square(file + 1, 1))):\n                    nonlocal white_isolated\n                    white_isolated += 1\n                elif (file < 7 and board.piece_at(chess.square(file + 1, 1)) and board.piece_at(chess.square(file + 1, 1)).piece_type == chess.PAWN):\n                    nonlocal white_doubled\n                    white_doubled += 1\n\n            if (black_pawn and black_pawn.piece_type == chess.PAWN):\n                if (file > 0 and not board.piece_at(chess.square(file - 1, 6))) and (file < 7 and not board.piece_at(chess.square(file + 1, 6))):\n                    nonlocal black_isolated\n                    black_isolated += 1\n                elif (file < 7 and board.piece_at(chess.square(file + 1, 6)) and board.piece_at(chess.square(file + 1, 6)).piece_type == chess.PAWN):\n                    nonlocal black_doubled\n                    black_doubled += 1\n    analyze_pawns()\n    return float(white_isolated - black_isolated + (white_doubled - black_doubled))\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the balance of central pawn structure for each side.\"\n    central_pawns_white = sum(1 for square in [chess.E4, chess.E5, chess.D4, chess.D5] \n                               if board.piece_at(square) and board.piece_at(square).color == chess.WHITE)\n    central_pawns_black = sum(1 for square in [chess.E4, chess.E5, chess.D4, chess.D5] \n                               if board.piece_at(square) and board.piece_at(square).color == chess.BLACK)\n    return float(central_pawns_white - central_pawns_black)\n",
    "def feature(board: chess.Board) -> float:\n    \"Determines the proportion of the board occupied by each player, highlighting spatial control.\"\n    total_squares = 64\n    white_occupied = len([square for square in board.piece_map() if board.piece_map()[square].color == chess.WHITE])\n    black_occupied = len([square for square in board.piece_map() if board.piece_map()[square].color == chess.BLACK])\n    result = (white_occupied - black_occupied) / total_squares\n    return float(result)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the control of open files by rooks for both sides.\"\n    white_rook_control = sum(1 for square in board.piece_map() if board.piece_map()[square].color == chess.WHITE and board.piece_map()[square].piece_type == chess.ROOK and not any(board.is_attacked_by(chess.BLACK, sq) for sq in board.piece_map() if chess.square_file(square) == chess.square_file(sq)))\n    black_rook_control = sum(1 for square in board.piece_map() if board.piece_map()[square].color == chess.BLACK and board.piece_map()[square].piece_type == chess.ROOK and not any(board.is_attacked_by(chess.WHITE, sq) for sq in board.piece_map() if chess.square_file(square) == chess.square_file(sq)))\n    return float(white_rook_control - black_rook_control)\n\n",
    "def feature(board: chess.Board) -> float:\n    'Calculates the sum of the absolute ranks of all pieces of a player to assess position advantage.'\n    total_rank = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == chess.WHITE:\n            total_rank += chess.square_rank(square) + 1  # +1 to make ranks 1-indexed\n    return float(total_rank)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the control of the back rank.\"\n    back_rank_control = sum(1 for square in range(0, 8) if board.is_attacked_by(board.turn, chess.square(square, 0 if board.turn else 7)))\n    return float(back_rank_control)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the number of pieces in opponent's territory for each side.\"\n    white_in_opponent_territory = sum(1 for square in board.piece_map() if board.piece_map()[square].color == chess.WHITE and chess.square_rank(square) >= 4)\n    black_in_opponent_territory = sum(1 for square in board.piece_map() if board.piece_map()[square].color == chess.BLACK and chess.square_rank(square) <= 3)\n    return float(white_in_opponent_territory - black_in_opponent_territory)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Assesses the number of hanging pieces for each side.\"\n    hanging_pieces = sum(1 for square, piece in board.piece_map().items() \n                         if piece.color == board.turn and not any(board.is_attacked_by(not piece.color, target_square) \n                         for target_square in board.attackers(piece.color, square)))\n    return float(hanging_pieces)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the number of unprotected pieces for both colors, which may indicate vulnerabilities.\"\n    unprotected_count = 0.0\n    for square in board.piece_map():\n        piece = board.piece_map()[square]\n        if piece.color == chess.WHITE:\n            if not any(board.is_attacked_by(chess.BLACK, attacked_square) for attacked_square in board.attackers(chess.WHITE, square)):\n                unprotected_count += 1.0\n        else:\n            if not any(board.is_attacked_by(chess.WHITE, attacked_square) for attacked_square in board.attackers(chess.BLACK, square)):\n                unprotected_count -= 1.0\n    return unprotected_count\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the distance of pieces from their promotion ranks for both players.\"\n    white_pawn_distance = sum(chess.square_rank(square) for square in board.piece_map() if board.piece_at(square).color == chess.WHITE and board.piece_at(square).piece_type == chess.PAWN)\n    black_pawn_distance = sum(7 - chess.square_rank(square) for square in board.piece_map() if board.piece_at(square).color == chess.BLACK and board.piece_at(square).piece_type == chess.PAWN)\n    return float(white_pawn_distance - black_pawn_distance)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in the number of minor pieces each side has.\"\n    white_minor_pieces = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE and piece.piece_type in {chess.KNIGHT, chess.BISHOP})\n    black_minor_pieces = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK and piece.piece_type in {chess.KNIGHT, chess.BISHOP})\n    return float(white_minor_pieces - black_minor_pieces)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Evaluates the presence of pinned pieces on the opponent's side.\"\n    pin_count = sum(1 for square, piece in board.piece_map().items() if piece.color == board.turn and any(board.is_attacked_by(not piece.color, square) for attacker in board.attackers(not piece.color, square)))\n    return float(pin_count)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Evaluates piece imbalance by considering the positional advantage of each piece.\"\n    piece_values = {chess.PAWN: 1, chess.KNIGHT: 3, chess.BISHOP: 3, chess.ROOK: 5, chess.QUEEN: 9, chess.KING: 0}\n    value_sum = 0\n    for piece in board.piece_map().values():\n        value_sum += piece_values[piece.piece_type] * (1 if piece.color == chess.WHITE else -1)\n    return float(value_sum)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in the number of knights on advanced squares (ranks 5 and higher for white, rank 4 and lower for black).\"\n    advanced_knights_white = sum(1 for square in board.piece_map() if board.piece_map()[square].color == chess.WHITE and chess.square_rank(square) >= 4)\n    advanced_knights_black = sum(1 for square in board.piece_map() if board.piece_map()[square].color == chess.BLACK and chess.square_rank(square) <= 3)\n    return float(advanced_knights_white - advanced_knights_black)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the mobility for each side based on legal moves.\"\n    white_mobility = len(list(board.legal_moves)) if board.turn == chess.WHITE else 0\n    black_mobility = len(list(board.legal_moves)) if board.turn == chess.BLACK else 0\n    return float(white_mobility - black_mobility)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the number of pieces pinned by either color, indicating tactical opportunities.\"\n    pinned_pieces = 0\n    for square in board.piece_map():\n        piece = board.piece_at(square)\n        if piece.color == board.turn:  # Only for the current player's pieces\n            for attacker in board.attackers(not piece.color, square):\n                if board.is_attacked_by(piece.color, attacker):\n                    pinned_pieces += 1\n    return float(pinned_pieces)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Evaluates the king safety by counting the total number of squares around the king that are attacked.\"\n    king_square = next(square for square, piece in board.piece_map().items() if piece.piece_type == chess.KING)\n    attacked_squares = sum(1 for sq in chess.SQUARES if board.is_attacked_by(chess.WHITE if board.turn else chess.BLACK, sq))\n    result = float(attacked_squares)\n    return result\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the difference in the number of passed pawns for each player.\"\n    def count_passed_pawns(color):\n        passed_pawn_count = 0\n        for square in chess.SQUARES:\n            piece = board.piece_at(square)\n            if piece and piece.color == color and piece.piece_type == chess.PAWN:\n                rank = chess.square_rank(square)\n                if (color == chess.WHITE and all(board.piece_at(chess.square(file, rank)) is None for file in range(chess.square_file(square) + 1, 8))) or \\\n                   (color == chess.BLACK and all(board.piece_at(chess.square(file, rank)) is None for file in range(0, chess.square_file(square)))):\n                    passed_pawn_count += 1\n        return passed_pawn_count\n\n    return float(count_passed_pawns(chess.WHITE) - count_passed_pawns(chess.BLACK)) \n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of doubled pawns for each side.\"\n    def count_doubled_pawns(color):\n        pawn_files = [0] * 8\n        for square in board.piece_map():\n            if board.piece_map()[square].color == color and board.piece_map()[square].piece_type == chess.PAWN:\n                pawn_files[chess.square_file(square)] += 1\n        return sum(1 for count in pawn_files if count > 1)\n    \n    white_doubled = count_doubled_pawns(chess.WHITE)\n    black_doubled = count_doubled_pawns(chess.BLACK)\n    return float(white_doubled - black_doubled)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the total number of open files available for rooks and queens of both colors.\"\n    open_files_white = sum(1 for file in range(8) if not any(board.piece_at(chess.square(file, rank)) and board.piece_at(chess.square(file, rank)).color == chess.WHITE for rank in range(8)))\n    open_files_black = sum(1 for file in range(8) if not any(board.piece_at(chess.square(file, rank)) and board.piece_at(chess.square(file, rank)).color == chess.BLACK for rank in range(8)))\n    return float(open_files_white - open_files_black)\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the number of pieces in the opponents' half of the board for spatial control.\"\n    white_pieces_in_opponent_half = sum(1 for square in board.piece_map() if board.piece_map()[square].color == chess.WHITE and chess.square_rank(square) > 3)\n    black_pieces_in_opponent_half = sum(1 for square in board.piece_map() if board.piece_map()[square].color == chess.BLACK and chess.square_rank(square) < 4)\n    return float(white_pieces_in_opponent_half - black_pieces_in_opponent_half)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Assesses the effectiveness of pawns as blockers or protectors of pieces.\"\n    protected_pawns = sum(1 for square, piece in board.piece_map().items() if piece.color == board.turn and piece.piece_type == chess.PAWN and any(board.is_attacked_by(not board.turn, square) for attack_square in board.attackers(board.turn, square)))\n    return float(protected_pawns)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the number of pieces attacking the opponent's king.\"\n    white_king_square = next(square for square, piece in board.piece_map().items() if piece.color == chess.WHITE and piece.piece_type == chess.KING)\n    black_king_square = next(square for square, piece in board.piece_map().items() if piece.color == chess.BLACK and piece.piece_type == chess.KING)\n    white_attackers = sum(1 for square in board.legal_moves if board.is_attacked_by(chess.BLACK, white_king_square))\n    black_attackers = sum(1 for square in board.legal_moves if board.is_attacked_by(chess.WHITE, black_king_square))\n    return float(white_attackers - black_attackers)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures pawn structure strength by counting connected pawns.\"\n    def connected_pawns(color):\n        pawns = [square for square in board.piece_map() if board.piece_map()[square].piece_type == chess.PAWN and board.piece_map()[square].color == color]\n        connections = 0\n        for square in pawns:\n            if abs(chess.square_file(square) - chess.square_file(square + 1)) <= 1:  # Check for horizontal connection\n                connections += 1\n        return connections\n\n    white_connections = connected_pawns(chess.WHITE)\n    black_connections = connected_pawns(chess.BLACK)\n    return float(white_connections - black_connections)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the historical pawn structure by counting doubled pawns for each side.\"\n    def doubled_pawn_count(color):\n        pawns = [square for square in board.piece_map() if board.piece_map()[square].piece_type == chess.PAWN and board.piece_map()[square].color == color]\n        return sum(1 for rank in range(8) if len([sq for sq in pawns if chess.square_rank(sq) == rank]) > 1)\n\n    white_doubled = doubled_pawn_count(chess.WHITE)\n    black_doubled = doubled_pawn_count(chess.BLACK)\n    return float(black_doubled - white_doubled)\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in king safety based on the number of squares around the king that are controlled by the opponent.\"\n    white_king_pos = next(square for square in board.piece_map() if board.piece_map()[square].color == chess.WHITE and board.piece_map()[square].piece_type == chess.KING)\n    black_king_pos = next(square for square in board.piece_map() if board.piece_map()[square].color == chess.BLACK and board.piece_map()[square].piece_type == chess.KING)\n    \n    white_threats = sum(board.is_attacked_by(chess.BLACK, square) for square in chess.SQUARES)\n    black_threats = sum(board.is_attacked_by(chess.WHITE, square) for square in chess.SQUARES)\n    \n    return float(black_threats - white_threats)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Assesses the number of pieces on open files for each side.\"\n    def open_file_count(color):\n        return sum(1 for file in range(8) if all(board.piece_at(chess.parse_square(chr(file + 97) + str(rank + 1))) is None or board.piece_at(chess.parse_square(chr(file + 97) + str(rank + 1))).color == color for rank in range(8)))\n\n    white_open_files = open_file_count(chess.WHITE)\n    black_open_files = open_file_count(chess.BLACK)\n    return float(white_open_files - black_open_files)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the number of squares under attack by each side.\"\n    white_attacks = sum(1 for square in chess.SQUARES if board.is_attacked_by(chess.WHITE, square))\n    black_attacks = sum(1 for square in chess.SQUARES if board.is_attacked_by(chess.BLACK, square))\n    return float(white_attacks - black_attacks)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Assesses the number of duplicated pieces for each color, indicating potential overcrowding.\"\n    def duplicated_count(color):\n        count = 0\n        piece_types = {}\n        for sq in board.piece_map():\n            piece = board.piece_at(sq)\n            if piece.color == color:\n                piece_types[piece.piece_type] = piece_types.get(piece.piece_type, 0) + 1\n        return sum(max(0, count - 1) for count in piece_types.values())\n\n    white_duplicates = duplicated_count(chess.WHITE)\n    black_duplicates = duplicated_count(chess.BLACK)\n    return float(white_duplicates - black_duplicates)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in pawn structure by counting isolated pawns for each side.\"\n    def isolated_pawns(color):\n        pawns = [square for square, piece in board.piece_map().items() if piece.color == color and piece.piece_type == chess.PAWN]\n        isolated = 0\n        for pawn in pawns:\n            file = chess.square_file(pawn)\n            if (file > 0 and not board.piece_at(chess.parse_square(chess.square_name(pawn)[0] + str(chess.square_rank(pawn) + 1))) and \n                board.piece_at(chess.parse_square(chess.square_name(pawn)[0] + str(chess.square_rank(pawn) - 1))) is None):\n                isolated += 1\n        return isolated\n    \n    white_isolated = isolated_pawns(chess.WHITE)\n    black_isolated = isolated_pawns(chess.BLACK)\n    return float(white_isolated - black_isolated)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures how many pieces each side has in the opponent's territory.\"\n    white_in_enemy_territory = sum(1 for square in board.piece_map() if board.piece_map()[square].color == chess.WHITE and chess.square_rank(square) > 4)\n    black_in_enemy_territory = sum(1 for square in board.piece_map() if board.piece_map()[square].color == chess.BLACK and chess.square_rank(square) < 3)\n    return float(white_in_enemy_territory - black_in_enemy_territory)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the difference in the number of pieces with more than one legal move for both players.\"\n    white_mobility = sum(1 for move in board.legal_moves if board.piece_at(move.from_square).color == chess.WHITE and board.piece_at(move.from_square).piece_type in (chess.KNIGHT, chess.BISHOP, chess.ROOK, chess.QUEEN))\n    black_mobility = sum(1 for move in board.legal_moves if board.piece_at(move.from_square).color == chess.BLACK and board.piece_at(move.from_square).piece_type in (chess.KNIGHT, chess.BISHOP, chess.ROOK, chess.QUEEN))\n    return float(white_mobility - black_mobility)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the mobility advantage by counting total pieces versus their squares.\"\n    total_pieces = sum(1 for piece in board.piece_map().values())\n    total_squares = len(board.piece_map())\n    return float(total_squares / (total_pieces if total_pieces > 0 else 1))\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the number of pins affecting pieces for both sides.\"\n    white_pins = sum(1 for square in board.piece_map() if board.is_attacked_by(chess.BLACK, square) and board.piece_map()[square].color == chess.WHITE)\n    black_pins = sum(1 for square in board.piece_map() if board.is_attacked_by(chess.WHITE, square) and board.piece_map()[square].color == chess.BLACK)\n    return float(white_pins - black_pins)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of hanging pieces on the board for both sides.\"\n    hanging_count = sum(1 for square, piece in board.piece_map().items() \n                        if piece.color == board.turn and len(board.attackers(not board.turn, square)) > 0)\n    return float(hanging_count)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the ratio of minor pieces (knights and bishops) to major pieces (rooks and queens).\"\n    minor_count = sum(1 for piece in board.piece_map().values() if piece.piece_type in [chess.KNIGHT, chess.BISHOP])\n    major_count = sum(1 for piece in board.piece_map().values() if piece.piece_type in [chess.ROOK, chess.QUEEN])\n    return float(minor_count / (major_count + 1))  # Avoid division by zero\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the presence of pawns on the 7th rank for each side.\"\n    pawns_on_seventh_white = sum(1 for square in range(56, 64) if board.piece_at(square) and board.piece_at(square).color == chess.WHITE and board.piece_at(square).piece_type == chess.PAWN)\n    pawns_on_seventh_black = sum(1 for square in range(0, 8) if board.piece_at(square) and board.piece_at(square).color == chess.BLACK and board.piece_at(square).piece_type == chess.PAWN)\n    return float(pawns_on_seventh_white - pawns_on_seventh_black)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the number of pawn promotions that could be achieved in future moves.\"\n    white_promotions = sum(1 for square in range(8, 16) if board.piece_at(square) and board.piece_at(square).color == chess.WHITE)\n    black_promotions = sum(1 for square in range(48, 56) if board.piece_at(square) and board.piece_at(square).color == chess.BLACK)\n    return float(white_promotions - black_promotions)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Evaluates the presence of passed pawns for each color.\"\n    def passed_pawn_count(color):\n        count = 0\n        for sq, piece in board.piece_map().items():\n            if piece.color == color and piece.piece_type == chess.PAWN:\n                file = chess.square_file(sq)\n                rank = chess.square_rank(sq)\n                if color == chess.WHITE and all(board.piece_at(chess.parse_square(chess.square_name(file + (i * 8)))) is None for i in range(rank + 1, 8)):\n                    count += 1\n                elif color == chess.BLACK and all(board.piece_at(chess.parse_square(chess.square_name(file + (i * 8)))) is None for i in range(0, rank)):\n                    count += 1\n        return count\n\n    return float(passed_pawn_count(chess.WHITE) - passed_pawn_count(chess.BLACK))\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in pawn structure for both sides by counting isolated pawns.\"\n    def count_isolated_pawns(color):\n        return sum(1 for sq, piece in board.piece_map().items() if piece.color == color and\n                   (chess.square_file(sq) == 0 or board.piece_at(sq - 1) is None) and\n                   (chess.square_file(sq) == 7 or board.piece_at(sq + 1) is None))\n    return float(count_isolated_pawns(chess.WHITE) - count_isolated_pawns(chess.BLACK))\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the number of doubled pawns for each side.\"\n    def count_doubled_pawns(color):\n        pawn_files = [0] * 8\n        for square, piece in board.piece_map().items():\n            if piece.color == color and piece.piece_type == chess.PAWN:\n                file = chess.square_file(square)\n                pawn_files[file] += 1\n        return sum(1 for count in pawn_files if count > 1)\n\n    white_doubled = count_doubled_pawns(chess.WHITE)\n    black_doubled = count_doubled_pawns(chess.BLACK)\n    return float(white_doubled - black_doubled)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the total threats posed by each player by counting how many opponent pieces are attacked.\"\n    white_threats = sum(1 for square in board.piece_map() if board.is_attacked_by(chess.WHITE, square))\n    black_threats = sum(1 for square in board.piece_map() if board.is_attacked_by(chess.BLACK, square))\n    result = white_threats - black_threats\n    return float(result)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of squares occupied by both players' pieces to gauge control of the board.\"\n    occupied_squares = len(board.piece_map())\n    return float(occupied_squares)\n\n",
    "def feature(board: chess.Board) -> float:\n    'Measures how many pieces are actively protecting each other.'\n    result = 0.0\n    for square in board.piece_map():\n        piece = board.piece_at(square)\n        if piece:\n            for target_square in board.attackers(piece.color, square):\n                if board.is_attacked_by(piece.color, target_square):\n                    result += 1.0\n    return result\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the average distance of pieces from their respective king's squares.\"\n    white_king_square = next(square for square in board.piece_map() if board.piece_at(square).piece_type == chess.KING and board.piece_at(square).color == chess.WHITE)\n    black_king_square = next(square for square in board.piece_map() if board.piece_at(square).piece_type == chess.KING and board.piece_at(square).color == chess.BLACK)\n    white_distance = sum(chess.square_distance(square, white_king_square) for square in board.piece_map() if board.piece_at(square).color == chess.WHITE)\n    black_distance = sum(chess.square_distance(square, black_king_square) for square in board.piece_map() if board.piece_at(square).color == chess.BLACK)\n    return float(white_distance - black_distance)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the distance of each king from the center, reflecting king safety.\"\n    center_squares = [chess.D4, chess.D5, chess.E4, chess.E5]\n    king_distance = 0\n    for square in [board.king(chess.WHITE), board.king(chess.BLACK)]:\n        if square is not None:\n            for center in center_squares:\n                king_distance += chess.square_distance(square, center)\n    return float(king_distance)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of pawns for each color.\"\n    white_pawns = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE and piece.piece_type == chess.PAWN)\n    black_pawns = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK and piece.piece_type == chess.PAWN)\n    return float(white_pawns - black_pawns)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the distance of all pawns from their starting ranks, assessing advancement.\"\n    white_pawn_advancement = sum(chess.square_rank(square) for square in board.piece_map() if board.piece_map()[square].color == chess.WHITE and board.piece_map()[square].piece_type == chess.PAWN)\n    black_pawn_advancement = sum(7 - chess.square_rank(square) for square in board.piece_map() if board.piece_map()[square].color == chess.BLACK and board.piece_map()[square].piece_type == chess.PAWN)\n    return float(white_pawn_advancement - black_pawn_advancement)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the number of pieces each side has on the back rank.\"\n    white_back_rank = sum(1 for square in range(0, 8) if board.piece_at(chess.square(square, 0)) and board.piece_at(chess.square(square, 0)).color == chess.WHITE)\n    black_back_rank = sum(1 for square in range(0, 8) if board.piece_at(chess.square(square, 7)) and board.piece_at(chess.square(square, 7)).color == chess.BLACK)\n    return float(white_back_rank - black_back_rank)\n\n",
    "def feature(board: chess.Board) -> float:\n    'Calculates the distance of each player\u2019s pieces from the opponent\u2019s king to assess pressure.'\n    white_king_square = next(square for square in board.piece_map() if board.piece_map()[square].piece_type == chess.KING and board.piece_map()[square].color == chess.WHITE)\n    black_king_square = next(square for square in board.piece_map() if board.piece_map()[square].piece_type == chess.KING and board.piece_map()[square].color == chess.BLACK)\n    white_distances = sum(chess.square_distance(square, black_king_square) for square in board.piece_map() if board.piece_map()[square].color == chess.WHITE)\n    black_distances = sum(chess.square_distance(square, white_king_square) for square in board.piece_map() if board.piece_map()[square].color == chess.BLACK)\n    return float(white_distances - black_distances)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the number of doubled pawns for both sides.\"\n    def count_doubled_pawns(color):\n        pawn_files = {}\n        for square, piece in board.piece_map().items():\n            if piece.color == color and piece.piece_type == chess.PAWN:\n                file = chess.square_file(square)\n                pawn_files[file] = pawn_files.get(file, 0) + 1\n        return sum(count - 1 for count in pawn_files.values() if count > 1)\n    white_doubled = count_doubled_pawns(chess.WHITE)\n    black_doubled = count_doubled_pawns(chess.BLACK)\n    return float(white_doubled - black_doubled)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the total value of pieces on the board considering their types.\"\n    piece_values = {\n        chess.PAWN: 1,\n        chess.KNIGHT: 3,\n        chess.BISHOP: 3,\n        chess.ROOK: 5,\n        chess.QUEEN: 9,\n        chess.KING: 0  # Kings are invaluable\n    }\n    total_value = 0.0\n    for piece in board.piece_map().values():\n        value = piece_values[piece.piece_type] if piece.color == chess.WHITE else -piece_values[piece.piece_type]\n        total_value += value\n    return total_value\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces on the back rank for each side.\"\n    back_rank_white = sum(1 for square in range(56, 64) if board.piece_at(square) and board.piece_at(square).color == chess.WHITE)\n    back_rank_black = sum(1 for square in range(0, 8) if board.piece_at(square) and board.piece_at(square).color == chess.BLACK)\n    return float(back_rank_white - back_rank_black)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the material imbalance by counting the value of pieces each side has on the board.\"\n    material_value = {chess.PAWN: 1, chess.KNIGHT: 3, chess.BISHOP: 3, chess.ROOK: 5, chess.QUEEN: 9, chess.KING: 0}\n    white_material = sum(material_value[board.piece_at(sq).piece_type] for sq in board.piece_map() if board.piece_at(sq).color == chess.WHITE)\n    black_material = sum(material_value[board.piece_at(sq).piece_type] for sq in board.piece_map() if board.piece_at(sq).color == chess.BLACK)\n    return float(white_material - black_material)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the mobility advantage between both sides.\"\n    white_mobility = len(list(board.legal_moves)) if board.turn == chess.WHITE else 0\n    black_mobility = len(list(board.legal_moves)) if board.turn == chess.BLACK else 0\n    return float(white_mobility - black_mobility)\n\n",
    "def feature(board: chess.Board) -> float:\n    'Measures the number of pins against each king by either side.'\n    def pins(color):\n        king_square = next(square for square, piece in board.piece_map().items() if piece.color == color and piece.piece_type == chess.KING)\n        return sum(1 for square in board.piece_map() if (board.piece_map()[square].color != color and \n            board.attackers(color, square) and board.is_attacked_by(color, king_square)))\n\n    white_pins = pins(chess.WHITE)\n    black_pins = pins(chess.BLACK)\n    return float(white_pins - black_pins)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Evaluates the potential pawn advancement for each side.\"\n    def pawn_advancement(color):\n        advancement = 0\n        for square, piece in board.piece_map().items():\n            if piece.color == color and piece.piece_type == chess.PAWN:\n                advancement += chess.square_rank(square)  # Higher rank means more advanced\n        return advancement\n\n    return float(pawn_advancement(chess.WHITE) - pawn_advancement(chess.BLACK))\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in the number of knights each player has on the board.\"\n    white_knights = len([p for p in board.piece_map().values() if p.piece_type == chess.KNIGHT and p.color == chess.WHITE])\n    black_knights = len([p for p in board.piece_map().values() if p.piece_type == chess.KNIGHT and p.color == chess.BLACK])\n    return float(white_knights - black_knights)\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the total number of attack squares for all pieces, reflecting strategic position strength.\"\n    total_attacks = sum(len(board.attackers(attacker.color, square)) for square, attacker in board.piece_map().items())\n    return float(total_attacks)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the difference in active pieces (pieces not blocked by pawns) for both sides.\"\n    def active_pieces(color):\n        return sum(1 for square, piece in board.piece_map().items() \n                   if piece.color == color and piece.piece_type != chess.PAWN and \n                   square not in board.attackers(not color, square))\n    \n    white_active = active_pieces(chess.WHITE)\n    black_active = active_pieces(chess.BLACK)\n    return float(white_active - black_active)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the potential square control across the board.\"\n    control_squares = sum(1 for square in board.piece_map() if board.legal_moves.count() > 0)\n    return float(control_squares)\n\n",
    "def feature(board: chess.Board) -> float:\n    'Measures the control of central squares (d4, d5, e4, e5) based on occupying pieces.'\n    central_squares = [chess.parse_square(sq) for sq in ['d4', 'd5', 'e4', 'e5']]\n    white_control = sum(1 for sq in central_squares if board.piece_at(sq) and board.piece_at(sq).color == chess.WHITE)\n    black_control = sum(1 for sq in central_squares if board.piece_at(sq) and board.piece_at(sq).color == chess.BLACK)\n    return float(white_control - black_control)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in material value of pieces beyond the 7th rank.\"\n    material_values = {\n        chess.PAWN: 1,\n        chess.KNIGHT: 3,\n        chess.BISHOP: 3,\n        chess.ROOK: 5,\n        chess.QUEEN: 9,\n        chess.KING: 0\n    }\n    white_material = sum(material_values[piece.piece_type] for square, piece in board.piece_map().items() if piece.color == chess.WHITE and chess.square_rank(square) >= 7)\n    black_material = sum(material_values[piece.piece_type] for square, piece in board.piece_map().items() if piece.color == chess.BLACK and chess.square_rank(square) <= 1)\n    return float(white_material - black_material)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the difference in total pawn structure (isolated, doubled, and passed pawns).\"\n    white_pawns = {sq for sq in board.piece_map() if board.piece_at(sq).color == chess.WHITE and board.piece_at(sq).piece_type == chess.PAWN}\n    black_pawns = {sq for sq in board.piece_map() if board.piece_at(sq).color == chess.BLACK and board.piece_at(sq).piece_type == chess.PAWN}\n    \n    def pawn_structure(pawns):\n        isolated = sum(1 for sq in pawns if (board.piece_at(sq).color == chess.WHITE and (sq - 1) not in pawns and (sq + 1) not in pawns))\n        doubled = sum(1 for file in range(8) if any(sq for sq in pawns if chess.square_file(sq) == file) > 1)\n        return float(isolated - doubled)\n    \n    return pawn_structure(white_pawns) - pawn_structure(black_pawns)\n\n",
    "def feature(board: chess.Board) -> float:\n    'Determines the piece activity by counting the number of pieces that can move to an open square.'\n    mobility_count = 0\n    for move in board.legal_moves:\n        mobility_count += 1\n    result = float(mobility_count)\n    return result\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in doubled pawns between both sides.\"\n    def count_doubled_pawns(color):\n        return sum(1 for file in range(8) if sum(1 for square in chess.SQUARES if board.piece_at(square) and board.piece_at(square).piece_type == chess.PAWN and board.piece_at(square).color == color and chess.square_file(square) == file) > 1)\n    white_doubled = count_doubled_pawns(chess.WHITE)\n    black_doubled = count_doubled_pawns(chess.BLACK)\n    return float(black_doubled - white_doubled)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the sum of the ranks of all white pieces on the board.\"\n    total_rank = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == chess.WHITE:\n            total_rank += chess.square_rank(square)\n    return float(total_rank)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the risk of losing pieces based on the number of attackers surrounding the opponent's pieces.\"\n    def piece_risk(color):\n        risk = 0\n        for square in board.piece_map():\n            if board.piece_map()[square].color == color:\n                attackers = sum(1 for att in board.attackers(chess.BLACK if color == chess.WHITE else chess.WHITE, square))\n                risk += attackers\n        return risk\n\n    white_risk = piece_risk(chess.WHITE)\n    black_risk = piece_risk(chess.BLACK)\n    return float(white_risk - black_risk)\n",
    "def feature(board: chess.Board) -> float:\n    'Counts the number of rook connections (open files) available for each player to evaluate piece coordination.'\n    white_rook_files = {chess.square_file(square) for square in board.piece_map() if (piece := board.piece_at(square)) and piece.color == chess.WHITE and piece.piece_type == chess.ROOK}\n    black_rook_files = {chess.square_file(square) for square in board.piece_map() if (piece := board.piece_at(square)) and piece.color == chess.BLACK and piece.piece_type == chess.ROOK}\n    result = float(len(white_rook_files) - len(black_rook_files))\n    return result\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of potential threats (opponent pieces that can be threatened next move).\"\n    threats = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == board.turn:\n            for move in board.legal_moves:\n                if move.from_square == square and (board.piece_at(move.to_square) is None or board.piece_at(move.to_square).color != board.turn):\n                    threats += 1\n    return float(threats)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of threats against pieces in the opponent's territory.\"\n    threats = sum(1 for square in range(32, 64) if board.piece_at(square) and board.is_attacked_by(not board.turn, square))\n    return float(threats)\n",
    "def feature(board: chess.Board) -> float:\n    \"Evaluates the number of unprotected pieces on the board for both sides.\"\n    unprotected_count = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == board.turn and not board.is_attacked_by(not board.turn, square):\n            unprotected_count += 1\n    return float(unprotected_count)\n\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the mobility of each side by counting legal moves.\"\n    white_moves = len(list(board.legal_moves)) if board.turn else 0\n    black_moves = len(list(board.legal_moves)) if not board.turn else 0\n    return float(white_moves - black_moves)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the difference in number of pawns each side has in the opponent's territory.\"\n    white_pawns_in_opponent_territory = sum(1 for square, piece in board.piece_map().items() if piece.color == chess.WHITE and chess.square_rank(square) > 4)\n    black_pawns_in_opponent_territory = sum(1 for square, piece in board.piece_map().items() if piece.color == chess.BLACK and chess.square_rank(square) < 4)\n    return float(white_pawns_in_opponent_territory - black_pawns_in_opponent_territory)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in the number of pawns on the 7th rank for both sides.\"\n    white_7th_rank = sum(1 for square in board.piece_map() if board.piece_map()[square].color == chess.WHITE and chess.square_rank(square) == 6)\n    black_7th_rank = sum(1 for square in board.piece_map() if board.piece_map()[square].color == chess.BLACK and chess.square_rank(square) == 1)\n    return float(white_7th_rank - black_7th_rank)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the total value of pieces in the opponent's half of the board for aggression evaluation.\"\n    piece_values = {chess.PAWN: 1, chess.KNIGHT: 3, chess.BISHOP: 3, chess.ROOK: 5, chess.QUEEN: 9, chess.KING: 0}\n    total_value_white = sum(piece_values[board.piece_at(square).piece_type] for square in board.piece_map() if board.piece_at(square).color == chess.WHITE and chess.square_rank(square) > 4)\n    total_value_black = sum(piece_values[board.piece_at(square).piece_type] for square in board.piece_map() if board.piece_at(square).color == chess.BLACK and chess.square_rank(square) < 4)\n    return float(total_value_white - total_value_black)\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the piece activity by counting the number of pieces that can move.\"\n    active_pieces = sum(1 for piece in board.piece_map().values() if piece.color == board.turn and len(list(board.legal_moves)) > 0)\n    return float(active_pieces)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the number of squares occupied by each color around their respective kings.\"\n    white_king_square = next((sq for sq in board.piece_map() if board.piece_at(sq).piece_type == chess.KING and board.piece_at(sq).color == chess.WHITE), None)\n    black_king_square = next((sq for sq in board.piece_map() if board.piece_at(sq).piece_type == chess.KING and board.piece_at(sq).color == chess.BLACK), None)\n    white_controlled = sum(1 for square in chess.SQUARES if board.is_attacked_by(chess.WHITE, square))\n    black_controlled = sum(1 for square in chess.SQUARES if board.is_attacked_by(chess.BLACK, square))\n    return float(white_controlled - black_controlled)\n\n",
    "def feature(board: chess.Board) -> float:\n    'Measures the central control by counting pieces in central squares (d4, d5, e4, e5).'\n    central_squares = [chess.D4, chess.D5, chess.E4, chess.E5]\n    central_control_white = sum(1 for square in central_squares if board.piece_at(square) and board.piece_at(square).color == chess.WHITE)\n    central_control_black = sum(1 for square in central_squares if board.piece_at(square) and board.piece_at(square).color == chess.BLACK)\n    return float(central_control_white - central_control_black)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the distance of pawns to promotion for each player.\"\n    white_pawn_distance = sum(7 - chess.square_rank(square) for square in board.piece_map() if board.piece_map()[square].color == chess.WHITE and board.piece_map()[square].piece_type == chess.PAWN)\n    black_pawn_distance = sum(chess.square_rank(square) for square in board.piece_map() if board.piece_map()[square].color == chess.BLACK and board.piece_map()[square].piece_type == chess.PAWN)\n    return float(white_pawn_distance - black_pawn_distance)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the number of doubled pawns each side has on the board.\"\n    white_doubled_pawns = len([square for square in chess.SQUARES if board.piece_at(square) and board.piece_at(square).color == chess.WHITE and sum(1 for sq in chess.SQUARES if board.piece_at(sq) and chess.square_file(sq) == chess.square_file(square) and board.piece_at(sq).color == chess.WHITE) > 1])\n    black_doubled_pawns = len([square for square in chess.SQUARES if board.piece_at(square) and board.piece_at(square).color == chess.BLACK and sum(1 for sq in chess.SQUARES if board.piece_at(sq) and chess.square_file(sq) == chess.square_file(square) and board.piece_at(sq).color == chess.BLACK) > 1])\n    return float(white_doubled_pawns - black_doubled_pawns)\n\n",
    "def feature(board: chess.Board) -> float:\n    'Measures the overall piece activity by calculating the total of all pieces\u2019 legal moves.'\n    total_activity = 0\n    for piece in board.piece_map().values():\n        total_activity += len(list(board.legal_moves))\n    return float(total_activity)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Evaluates space control by measuring the number of unoccupied squares in the central area.\"\n    central_squares = [chess.E4, chess.E5, chess.D4, chess.D5]\n    central_control = sum(1 for square in central_squares if board.piece_at(square) is None)\n    return float(central_control)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the average distance of pieces from the center of the board.\"\n    center_squares = [chess.E4, chess.E5, chess.D4, chess.D5]\n    total_distance = 0\n    piece_count = 0\n    \n    for square, piece in board.piece_map().items():\n        total_distance += min(chess.square_distance(square, cs) for cs in center_squares)\n        piece_count += 1\n    \n    result = total_distance / piece_count if piece_count > 0 else 0.0\n    return result\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the number of pinned pieces each side has.\"\n    def count_pinned(color):\n        pinned_count = 0\n        for square, piece in board.piece_map().items():\n            if piece.color == color:\n                for attacker in board.attackers(not color, square):\n                    if board.piece_at(attacker).piece_type == chess.QUEEN or (board.piece_at(attacker).piece_type == chess.ROOK and (attacker // 8 == square // 8)) or (board.piece_at(attacker).piece_type == chess.BISHOP and (attacker % 8 == square % 8)):\n                        pinned_count += 1\n                        break\n        return pinned_count\n    white_pinned = count_pinned(chess.WHITE)\n    black_pinned = count_pinned(chess.BLACK)\n    return float(white_pinned - black_pinned)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces each side has that are currently pinned.\"\n    def count_pinned(color):\n        pinned_count = 0\n        for square in board.piece_map():\n            piece = board.piece_map()[square]\n            if piece.color == color:\n                for attacker in board.attackers(not color, square):\n                    if board.piece_at(attacker) and board.piece_at(attacker).piece_type == chess.QUEEN:\n                        pinned_count += 1\n        return pinned_count\n\n    white_pinned = count_pinned(chess.WHITE)\n    black_pinned = count_pinned(chess.BLACK)\n    return float(white_pinned - black_pinned)\n\n",
    "def feature(board: chess.Board) -> float:\n    'Measures the number of connecting pawns to analyze pawn structure.'\n    connected_pawn_count = 0\n    for file in range(8):\n        for rank in range(8):\n            square = chess.square(file, rank)\n            piece = board.piece_at(square)\n            if piece and piece.piece_type == chess.PAWN:\n                left_square = chess.square(file - 1, rank) if file > 0 else None\n                right_square = chess.square(file + 1, rank) if file < 7 else None\n                if (left_square is not None and board.piece_at(left_square) and board.piece_at(left_square).piece_type == chess.PAWN) or \\\n                   (right_square is not None and board.piece_at(right_square) and board.piece_at(right_square).piece_type == chess.PAWN):\n                    connected_pawn_count += 1\n    return float(connected_pawn_count)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the average distance of pieces to the enemy's king.\"\n    white_king_square = next(s for s in board.piece_map() if board.piece_at(s).piece_type == chess.KING and board.piece_at(s).color == chess.WHITE)\n    black_king_square = next(s for s in board.piece_map() if board.piece_at(s).piece_type == chess.KING and board.piece_at(s).color == chess.BLACK)\n    average_distance_white = sum(chess.square_distance(s, black_king_square) for s in board.piece_map() if board.piece_at(s).color == chess.WHITE) / (len(board.piece_map()) // 2)\n    average_distance_black = sum(chess.square_distance(s, white_king_square) for s in board.piece_map() if board.piece_at(s).color == chess.BLACK) / (len(board.piece_map()) // 2)\n    return float(average_distance_white - average_distance_black)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the total number of squares occupied by each side.\"\n    white_occupied = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE)\n    black_occupied = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK)\n    return float(white_occupied - black_occupied)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the potential for piece development by counting undeveloped pieces.\"\n    undeveloped_white = sum(1 for square, piece in board.piece_map().items() if piece.color == chess.WHITE and piece.piece_type in {chess.KNIGHT, chess.BISHOP} and chess.square_rank(square) < 2)\n    undeveloped_black = sum(1 for square, piece in board.piece_map().items() if piece.color == chess.BLACK and piece.piece_type in {chess.KNIGHT, chess.BISHOP} and chess.square_rank(square) > 5)\n    return float(undeveloped_black - undeveloped_white)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the total number of legal moves for the player to move.\"\n    return float(len(list(board.legal_moves)))\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the average distance of pawns from their starting rank, highlighting pawn progress.\"\n    pawn_distance_sum = sum(chess.square_rank(square) for square, piece in board.piece_map().items() if piece.piece_type == chess.PAWN)\n    pawn_count = sum(1 for square, piece in board.piece_map().items() if piece.piece_type == chess.PAWN)\n    return float(pawn_distance_sum) / pawn_count if pawn_count > 0 else 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces attacked by each side.\"\n    white_attacked = sum(1 for square in board.piece_map() if board.is_attacked_by(chess.WHITE, square))\n    black_attacked = sum(1 for square in board.piece_map() if board.is_attacked_by(chess.BLACK, square))\n    return float(white_attacked - black_attacked)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the pawn structure by counting isolated, doubled, and passed pawns.\"\n    def pawn_structure(color):\n        pawns = [square for square in board.piece_map() if board.piece_map()[square].color == color and board.piece_map()[square].piece_type == chess.PAWN]\n        isolated = sum(1 for sq in pawns if not (board.piece_at(sq - 8) and board.piece_at(sq + 8)))\n        doubled = sum(1 for file in range(8) if sum(1 for rank in range(8) if board.piece_at(chess.square(file, rank)) == chess.PAWN and piece.color == color) > 1)\n        return isolated + doubled\n    \n    white_structure = pawn_structure(chess.WHITE)\n    black_structure = pawn_structure(chess.BLACK)\n    return float(white_structure - black_structure)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the number of double attacks from pieces of each side.\"\n    def count_double_attacks(color):\n        double_attacks = 0\n        for sq, piece in board.piece_map().items():\n            if piece.color == color:\n                for move in board.legal_moves:\n                    if move.from_square == sq and board.is_attacked_by(not color, move.to_square):\n                        double_attacks += 1\n        return double_attacks\n    white_doubles = count_double_attacks(chess.WHITE)\n    black_doubles = count_double_attacks(chess.BLACK)\n    return float(white_doubles - black_doubles)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the total distance of all pieces from the opponent's back rank.\"\n    total_distance = 0\n    opponent_back_rank = 0 if board.turn else 7\n    for square, piece in board.piece_map().items():\n        if piece.color == (chess.WHITE if board.turn else chess.BLACK):\n            total_distance += chess.square_rank(square) - opponent_back_rank\n    return float(total_distance)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the difference in bishop pair advantage.\"\n    white_bishops = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE and piece.piece_type == chess.BISHOP)\n    black_bishops = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK and piece.piece_type == chess.BISHOP)\n    return float(white_bishops - black_bishops)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the pawn structure stability by assessing double pawns.\"\n    double_pawn_count = sum(1 for square in range(8) for color in (chess.WHITE, chess.BLACK) if \n                             sum(1 for sq in range(8) if (board.piece_at(sq) and board.piece_at(sq).color == color)) > 1)\n    return float(-double_pawn_count)  # Negative value since double pawns are a weakness\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the number of open files for rooks.\"\n    open_files = sum(1 for file in range(8) if not any(board.piece_at(chess.square(file, rank)) for rank in range(8)))\n    return float(open_files)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the presence of unprotected pieces on the board for both sides.\"\n    unprotected_pieces = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == board.turn:\n            if not board.attackers(chess.BLACK if piece.color == chess.WHITE else chess.WHITE, square):\n                unprotected_pieces += 1 if piece.color == chess.WHITE else -1\n    return float(unprotected_pieces)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of connected pawns for each player.\"\n    connected_pawns = {chess.WHITE: 0, chess.BLACK: 0}\n    \n    def count_connected(color):\n        pawns = [square for square in board.piece_map() if board.piece_map()[square].color == color and board.piece_map()[square].piece_type == chess.PAWN]\n        for square in pawns:\n            if board.piece_at(square + 1) and board.piece_at(square + 1).color == color:\n                connected_pawns[color] += 1\n            if board.piece_at(square - 1) and board.piece_at(square - 1).color == color:\n                connected_pawns[color] += 1\n    \n    count_connected(chess.WHITE)\n    count_connected(chess.BLACK)\n    \n    return float(connected_pawns[chess.WHITE] - connected_pawns[chess.BLACK])\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Evaluates the number of pieces that are controlling the center squares.\"\n    center_squares = [chess.D4, chess.D5, chess.E4, chess.E5]\n    white_control = sum(1 for sq in center_squares if board.is_attacked_by(chess.WHITE, sq))\n    black_control = sum(1 for sq in center_squares if board.is_attacked_by(chess.BLACK, sq))\n    return float(white_control - black_control)\n\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the total number of minor pieces (knights and bishops) remaining for both sides.\"\n    white_minor = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE and piece.piece_type in [chess.KNIGHT, chess.BISHOP])\n    black_minor = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK and piece.piece_type in [chess.KNIGHT, chess.BISHOP])\n    return float(white_minor - black_minor)\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the number of pieces pinned by the opponent's major pieces.\"\n    pinned_pieces = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == board.turn and (piece.piece_type in {chess.KING, chess.QUEEN, chess.ROOK}):\n            if any(board.is_attacked_by(not piece.color, target_square) for target_square in board.attackers(piece.color, square)):\n                pinned_pieces += 1\n    return float(pinned_pieces)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the number of isolated pawns for both players.\"\n    def is_isolated(square):\n        file = chess.square_file(square)\n        return (board.piece_at(chess.square(file - 1, chess.square_rank(square))) is None and\n                board.piece_at(chess.square(file + 1, chess.square_rank(square))) is None)\n\n    white_isolated = sum(1 for square in board.piece_map() if (board.piece_at(square).color == chess.WHITE and \n                        board.piece_at(square).piece_type == chess.PAWN and is_isolated(square)))\n    black_isolated = sum(1 for square in board.piece_map() if (board.piece_at(square).color == chess.BLACK and \n                        board.piece_at(square).piece_type == chess.PAWN and is_isolated(square)))\n    return float(white_isolated - black_isolated)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the density of pieces for each player's third rank.\"\n    white_third_rank_density = sum(1 for square in chess.SQUARES if board.piece_at(square) and board.piece_at(square).color == chess.WHITE and 16 <= square <= 23)\n    black_third_rank_density = sum(1 for square in chess.SQUARES if board.piece_at(square) and board.piece_at(square).color == chess.BLACK and 24 <= square <= 31)\n    return float(white_third_rank_density - black_third_rank_density)\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of available checks by both players.\"\n    checks = sum(1 for move in board.legal_moves if board.gives_check(move))\n    return float(checks)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the number of pieces on the back rank for each side.\"\n    back_rank_white = sum(1 for square in range(56, 64) if board.piece_at(square) and board.piece_at(square).color == chess.WHITE)\n    back_rank_black = sum(1 for square in range(0, 8) if board.piece_at(square) and board.piece_at(square).color == chess.BLACK)\n    return float(back_rank_white - back_rank_black)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Determines the total number of squares controlled by each side, based on piece placement.\"\n    white_controlled = sum(1 for square in range(64) if board.is_attacked_by(chess.WHITE, square))\n    black_controlled = sum(1 for square in range(64) if board.is_attacked_by(chess.BLACK, square))\n    return float(white_controlled - black_controlled)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of development moves made by each side (pieces moved from their original positions).\"\n    def count_development(color):\n        return sum(1 for square in board.piece_map() if board.piece_map()[square].color == color and \n                   chess.square_rank(square) < 6)\n    white_development = count_development(chess.WHITE)\n    black_development = count_development(chess.BLACK)\n    return float(white_development - black_development)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the pawn structure quality by counting doubled and isolated pawns.\"\n    def pawn_structure(color):\n        pawns = [square for square in board.piece_map() if board.piece_map()[square].color == color and board.piece_map()[square].piece_type == chess.PAWN]\n        doubles = sum(1 for square in pawns if board.piece_at(square + 8) and \n                      board.piece_at(square + 8).color == color)  # Check for doubled pawns\n        isolated = sum(1 for square in pawns if not (board.piece_at(square - 1) and board.piece_at(square - 1).color == color) and \n                                        not (board.piece_at(square + 1) and board.piece_at(square + 1).color == color))  # Check for isolated\n        return doubles + isolated\n\n    white_structure = pawn_structure(chess.WHITE)\n    black_structure = pawn_structure(chess.BLACK)\n    return float(white_structure - black_structure)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in the number of pawns on the third and sixth ranks.\"\n    white_third_rank_pawns = sum(1 for square in range(24, 32) if board.piece_at(square) and board.piece_at(square).color == chess.WHITE and board.piece_at(square).piece_type == chess.PAWN)\n    black_sixth_rank_pawns = sum(1 for square in range(48, 56) if board.piece_at(square) and board.piece_at(square).color == chess.BLACK and board.piece_at(square).piece_type == chess.PAWN)\n    return float(white_third_rank_pawns - black_sixth_rank_pawns)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the number of potential forks available for each player.\"\n    potential_forks = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == chess.WHITE:\n            for move in board.legal_moves:\n                if move.from_square == square:\n                    if len(board.attackers(chess.BLACK, move.to_square)) > 1:\n                        potential_forks += 1\n        else:\n            for move in board.legal_moves:\n                if move.from_square == square:\n                    if len(board.attackers(chess.WHITE, move.to_square)) > 1:\n                        potential_forks += 1\n    return float(potential_forks)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the number of legal pawn moves available for each player.\"\n    white_pawn_moves = sum(1 for move in board.legal_moves if board.piece_at(move.from_square).piece_type == chess.PAWN and board.piece_at(move.from_square).color == chess.WHITE)\n    black_pawn_moves = sum(1 for move in board.legal_moves if board.piece_at(move.from_square).piece_type == chess.PAWN and board.piece_at(move.from_square).color == chess.BLACK)\n    return float(white_pawn_moves - black_pawn_moves)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the distance of pawns to promotion to evaluate offensive potential.\"\n    pawn_distance_to_promotion = sum(7 - chess.square_rank(square) for square in board.piece_map() if board.piece_at(square).piece_type == chess.PAWN and board.piece_at(square).color == board.turn)\n    \n    result = float(pawn_distance_to_promotion)\n    return result\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the total value of isolated pawns for both players.\"\n    result = 0.0\n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.PAWN:\n            if not board.is_attacked_by(piece.color, square):\n                if (board.piece_at(square + 1) is None and board.piece_at(square - 1) is None): \n                    result += 1.0\n    return result\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the total number of pawns for each color on the board.\"\n    white_pawns = sum(1 for square in chess.SQUARES if board.piece_at(square) and board.piece_at(square).piece_type == chess.PAWN and board.piece_at(square).color == chess.WHITE)\n    black_pawns = sum(1 for square in chess.SQUARES if board.piece_at(square) and board.piece_at(square).piece_type == chess.PAWN and board.piece_at(square).color == chess.BLACK)\n    return float(white_pawns - black_pawns)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the average position rank of all the pieces on the board for each color.\"\n    def piece_rank_value():\n        total_rank = 0\n        piece_count = 0\n        for square, piece in board.piece_map().items():\n            total_rank += chess.square_rank(square) + 1  # rank is 0-7, we use 1-8\n            piece_count += 1\n        return total_rank / piece_count if piece_count else 0\n\n    white_average_rank = piece_rank_value()\n    return float(white_average_rank)\n\n",
    "def feature(board: chess.Board) -> float:\n    'Measures the number of backward pawns for each color, indicating potential weaknesses in pawn structure.'\n    backward_pawns_white = sum(1 for sq in board.piece_map() if board.piece_map()[sq].piece_type == chess.PAWN and \n                                board.piece_map()[sq].color == chess.WHITE and \n                                chess.square_rank(sq) < 7 and (board.piece_at(sq + 8) is None))\n    backward_pawns_black = sum(1 for sq in board.piece_map() if board.piece_map()[sq].piece_type == chess.PAWN and \n                                board.piece_map()[sq].color == chess.BLACK and \n                                chess.square_rank(sq) > 0 and (board.piece_at(sq - 8) is None))\n    return float(backward_pawns_white - backward_pawns_black)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the safety of the king based on the number of available escape squares.\"\n    king_square = next(square for square, piece in board.piece_map().items() if piece.color == board.turn and piece.piece_type == chess.KING)\n    escape_squares = sum(1 for move in board.legal_moves if move.to_square == king_square)\n    return float(escape_squares)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the mobility of pieces by counting legal moves available for each side.\"\n    white_mobility = len(list(board.legal_moves)) if board.turn else 0\n    black_mobility = len(list(board.legal_moves)) if not board.turn else 0\n    return float(white_mobility - black_mobility)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Evaluates the mobility of the knights on the board.\"\n    def knight_mobility(color):\n        mobility = 0\n        for square, piece in board.piece_map().items():\n            if piece.color == color and piece.piece_type == chess.KNIGHT:\n                mobility += len(list(board.legal_moves))\n        return mobility\n\n    return float(knight_mobility(chess.WHITE) - knight_mobility(chess.BLACK))\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Evaluates the presence of major pieces (Queens and Rooks) for both players.\"\n    white_major_piece_count = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE and piece.piece_type in (chess.QUEEN, chess.ROOK))\n    black_major_piece_count = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK and piece.piece_type in (chess.QUEEN, chess.ROOK))\n    return float(white_major_piece_count - black_major_piece_count)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the number of squares controlled by each player, considering the influence of pieces.\"\n    white_control = sum(1 for square in chess.SQUARES if board.is_attacked_by(chess.WHITE, square))\n    black_control = sum(1 for square in chess.SQUARES if board.is_attacked_by(chess.BLACK, square))\n    return float(white_control - black_control)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of pawn moves made by each side, indicating pawn structure development.\"\n    white_pawn_moves = sum(1 for square in board.piece_map() if board.piece_map()[square].color == chess.WHITE and board.fullmove_number > 1)\n    black_pawn_moves = sum(1 for square in board.piece_map() if board.piece_map()[square].color == chess.BLACK and board.fullmove_number > 1)\n    return float(white_pawn_moves - black_pawn_moves)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Evaluates the mobility by counting the number of legal moves available to each side.\"\n    white_moves = len(list(board.legal_moves)) if board.turn else 0\n    black_moves = len(list(board.legal_moves)) if not board.turn else 0\n    return float(white_moves - black_moves)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Evaluates the presence of isolated pawns for each side.\"\n    def isolated_pawn_count(color):\n        count = 0\n        for square in chess.SQUARES:\n            piece = board.piece_at(square)\n            if piece and piece.color == color and piece.piece_type == chess.PAWN:\n                file = chess.square_file(square)\n                if (file > 0 and board.piece_at(chess.square(file - 1, chess.square_rank(square))) is None) and \\\n                   (file < 7 and board.piece_at(chess.square(file + 1, chess.square_rank(square))) is None):\n                    count += 1\n        return count\n\n    white_isolated = isolated_pawn_count(chess.WHITE)\n    black_isolated = isolated_pawn_count(chess.BLACK)\n    return float(white_isolated - black_isolated)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the mobility ratio of white to black by comparing legal moves.\"\n    white_moves = len(list(board.legal_moves))\n    board.turn = False\n    black_moves = len(list(board.legal_moves))\n    return float(white_moves - black_moves)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the number of minor pieces on the board for each player.\"\n    white_minor = sum(1 for piece in board.piece_map().values() \n                      if piece.color == chess.WHITE and piece.piece_type in {chess.KNIGHT, chess.BISHOP})\n    black_minor = sum(1 for piece in board.piece_map().values() \n                      if piece.color == chess.BLACK and piece.piece_type in {chess.KNIGHT, chess.BISHOP})\n    return float(white_minor - black_minor)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Evaluates mobility by considering the total number of legal moves per piece.\"\n    total_mobility = 0.0\n    for piece in board.piece_map().values():\n        if piece.color == board.turn:\n            total_mobility += len(list(board.legal_moves))\n    return total_mobility\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures how many pawns are on the 7th rank (for white) or 2nd rank (for black).\"\n    white_pawns_on_7th = sum(1 for square in range(56, 64) if board.piece_at(square) and board.piece_at(square).piece_type == chess.PAWN)\n    black_pawns_on_2nd = sum(1 for square in range(8) if board.piece_at(square) and board.piece_at(square).piece_type == chess.PAWN)\n    return float(white_pawns_on_7th - black_pawns_on_2nd)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the total influence of the rooks on open files.\"\n    influence_score = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == board.turn and piece.piece_type == chess.ROOK:\n            file_controlled = chess.square_file(square)\n            if not any(board.piece_at(s) for s in range(file_controlled * 8, (file_controlled + 1) * 8)):\n                influence_score += 1\n    return float(influence_score)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures piece coordination by counting pairs of pieces that can attack the same square.\"\n    attack_pairs = 0\n    for square in chess.SQUARES:\n        if board.is_attacked_by(chess.WHITE, square) and board.is_attacked_by(chess.BLACK, square):\n            attack_pairs += 1\n    return float(attack_pairs)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the distribution of pawns on the board, which can influence strategic decisions.\"\n    white_pawns = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE and piece.piece_type == chess.PAWN)\n    black_pawns = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK and piece.piece_type == chess.PAWN)\n    return float(white_pawns - black_pawns)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the number of checks given by both players based on total piece activity.\"\n    checks = sum(1 for move in board.legal_moves if board.gives_check(move))\n    return float(checks)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the positional advantage by calculating the number of pieces on the seventh rank.\"\n    seventh_rank_count = sum(1 for square in chess.SQUARES if chess.square_rank(square) == 6 and board.piece_at(square) is not None and board.piece_at(square).color == chess.WHITE) \\\n                       - sum(1 for square in chess.SQUARES if chess.square_rank(square) == 1 and board.piece_at(square) is not None and board.piece_at(square).color == chess.BLACK)\n                       \n    return float(seventh_rank_count)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the tempo by counting the turn of side that leads to more capturing moves.\"\n    def capturing_moves(color):\n        return sum(1 for move in board.legal_moves if board.is_attacked_by(not color, move.to_square))\n    \n    white_captures = capturing_moves(chess.WHITE)\n    black_captures = capturing_moves(chess.BLACK)\n    return float(white_captures - black_captures)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the number of pieces in the opponent's back rank.\"\n    white_back_rank_count = sum(1 for square in range(56, 64) if board.piece_at(square) and board.piece_at(square).color == chess.WHITE)\n    black_back_rank_count = sum(1 for square in range(0, 8) if board.piece_at(square) and board.piece_at(square).color == chess.BLACK)\n    return float(black_back_rank_count - white_back_rank_count)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the total number of pieces attacking the opponent's pieces.\"\n    white_attack_count = sum(1 for square in board.piece_map() if board.piece_map()[square].color == chess.WHITE for attack_square in board.attackers(chess.BLACK, square) if attack_square)\n    black_attack_count = sum(1 for square in board.piece_map() if board.piece_map()[square].color == chess.BLACK for attack_square in board.attackers(chess.WHITE, square) if attack_square)\n    return float(white_attack_count - black_attack_count)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the score based on the number of pieces that control the opponent's pieces.\"\n    score = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == board.turn:\n            score += len(board.attackers(not piece.color, square))\n    return float(score)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Evaluates the pawn structure by counting weaknesses for both sides.\"\n    def pawn_structure_weaknesses(color):\n        weaknesses = 0\n        for square in range(64):\n            if board.piece_at(square) and board.piece_at(square).color == color and board.piece_at(square).piece_type == chess.PAWN:\n                if (square > 7 and not board.piece_at(square - 8)) or (square < 56 and not board.piece_at(square + 8)):\n                    weaknesses += 1\n        return weaknesses\n    \n    white_weaknesses = pawn_structure_weaknesses(chess.WHITE)\n    black_weaknesses = pawn_structure_weaknesses(chess.BLACK)\n    return float(black_weaknesses - white_weaknesses)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the distance of both kings to their respective corners.\"\n    white_king_square = next(square for square, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color == chess.WHITE)\n    black_king_square = next(square for square, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color == chess.BLACK)\n    white_corner_distance = min(chess.square_distance(white_king_square, corner) for corner in [chess.A1, chess.H1, chess.A8, chess.H8])\n    black_corner_distance = min(chess.square_distance(black_king_square, corner) for corner in [chess.A1, chess.H1, chess.A8, chess.H8])\n    return float(black_corner_distance - white_corner_distance)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the total number of pieces on the 2nd and 7th ranks for each player.\"\n    back_rank_white = sum(1 for square in range(16, 24) if board.piece_at(square) and board.piece_at(square).color == chess.WHITE)\n    back_rank_black = sum(1 for square in range(48, 56) if board.piece_at(square) and board.piece_at(square).color == chess.BLACK)\n    return float(back_rank_white - back_rank_black)\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the total number of unprotected pieces for each side.\"\n    white_unprotected = sum(1 for square, piece in board.piece_map().items() if piece.color == chess.WHITE and not board.is_attacked_by(chess.BLACK, square))\n    black_unprotected = sum(1 for square, piece in board.piece_map().items() if piece.color == chess.BLACK and not board.is_attacked_by(chess.WHITE, square))\n    return float(white_unprotected - black_unprotected)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the number of discovered attacks for both colors.\"\n    discovered_attacks = 0\n    for square in board.piece_map():\n        piece = board.piece_map()[square]\n        for move in board.legal_moves:\n            if move.from_square == square:\n                target_piece = board.piece_at(move.to_square)\n                if target_piece and target_piece.color != piece.color and board.is_attacked_by(piece.color, move.to_square):\n                    discovered_attacks += 1\n    return float(discovered_attacks)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the number of pieces in the opponent's attacking range.\"\n    attacking_pieces_count = sum(1 for square in board.piece_map() if board.is_attacked_by(board.turn, square))\n    return float(attacking_pieces_count)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the total mobility of both sides by counting the number of legal moves.\"\n    white_moves = len(list(board.legal_moves)) if board.turn else 0\n    board.turn = not board.turn\n    black_moves = len(list(board.legal_moves))\n    board.turn = not board.turn\n    result = white_moves - black_moves\n    return float(result)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the average distance of all pieces from their starting positions.\"\n    total_distance = sum(chess.square_distance(square, piece.piece_type) for square, piece in board.piece_map().items())\n    average_distance = total_distance / len(board.piece_map()) if board.piece_map() else 0\n    return float(average_distance)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the total number of threats against the opponent's king.\"\n    opponent_color = chess.BLACK if board.turn else chess.WHITE\n    threats = sum(1 for square in board.piece_map() if board.piece_map()[square].color == opponent_color and board.is_attacked_by(board.turn, square))\n    return float(threats)\n\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the ratio of force to the number of pieces on the board.\"\n    material_values = {\n        chess.PAWN: 1,\n        chess.KNIGHT: 3,\n        chess.BISHOP: 3,\n        chess.ROOK: 5,\n        chess.QUEEN: 9,\n    }\n    total_material = sum(material_values.get(piece.piece_type, 0) for piece in board.piece_map().values())\n    total_pieces = len(board.piece_map())\n    return float(total_material / (total_pieces if total_pieces > 0 else 1))\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the strength of pawn structure by assessing the number of connected pawns.\"\n    connected_pawns = 0\n    for file in range(8):\n        last_pawn = -1\n        for rank in range(8):\n            square = chess.square(file, rank)\n            piece = board.piece_at(square)\n            if piece and piece.piece_type == chess.PAWN:\n                if last_pawn == -1 or last_pawn == rank - 1:\n                    connected_pawns += 1\n                last_pawn = rank\n    return float(connected_pawns)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the central pawn structure by counting pawns on central files.\"\n    central_pawns = sum(1 for square in [chess.D4, chess.E4, chess.D5, chess.E5] if board.piece_at(square) and board.piece_at(square).piece_type == chess.PAWN)\n    return float(central_pawns)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the king safety by counting pawns shielding each king.\"\n    def pawn_shields_king(color):\n        count = 0\n        king_square = next(square for square, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color == color)\n        king_file = chess.square_file(king_square)\n        for file_shift in [-1, 0, 1]:\n            pawn_square = chess.square(king_file + file_shift, chess.square_rank(king_square) - 1)\n            if board.piece_at(pawn_square) and board.piece_at(pawn_square).color == color and chess.square_rank(king_square) > 0:\n                count += 1\n        return count\n\n    white_shields = pawn_shields_king(chess.WHITE)\n    black_shields = pawn_shields_king(chess.BLACK)\n    return float(white_shields - black_shields)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the number of potential discovered attacks from each side.\"\n    discovered_attacks = 0\n    for move in board.legal_moves:\n        board.push(move)\n        for target_square in board.legal_moves:\n            if board.is_attacked_by(not board.turn, target_square.to_square):\n                discovered_attacks += 1\n                break\n        board.pop()\n    return float(discovered_attacks)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces within two squares of each player's king, indicating tactical presence.\"\n    white_king = next(sq for sq in board.piece_map() \n                      if board.piece_at(sq).piece_type == chess.KING and board.piece_at(sq).color == chess.WHITE)\n    black_king = next(sq for sq in board.piece_map() \n                      if board.piece_at(sq).piece_type == chess.KING and board.piece_at(sq).color == chess.BLACK)\n    white_near_king = sum(1 for sq in board.piece_map() \n                          if chess.square_distance(white_king, sq) <= 2 and \n                          board.piece_at(sq).color == chess.WHITE)\n    black_near_king = sum(1 for sq in board.piece_map() \n                          if chess.square_distance(black_king, sq) <= 2 and \n                          board.piece_at(sq).color == chess.BLACK)\n    result = white_near_king - black_near_king\n    return float(result)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the number of pieces located on the opponent's third rank for offensive pressure.\"\n    pieces_third_rank_white = sum(1 for square in board.piece_map() \n                                     if chess.square_rank(square) == 5 and \n                                     board.piece_at(square).color == chess.WHITE)\n    pieces_third_rank_black = sum(1 for square in board.piece_map() \n                                     if chess.square_rank(square) == 2 and \n                                     board.piece_at(square).color == chess.BLACK)\n    return float(pieces_third_rank_white - pieces_third_rank_black)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the total material value considering piece type and its position on the board.\"\n    material_values = {chess.PAWN: 1, chess.KNIGHT: 3, chess.BISHOP: 3, chess.ROOK: 5, chess.QUEEN: 9, chess.KING: 0}\n    white_value = sum(material_values[piece.piece_type] for piece in board.piece_map().values() if piece.color == chess.WHITE)\n    black_value = sum(material_values[piece.piece_type] for piece in board.piece_map().values() if piece.color == chess.BLACK)\n    return float(white_value - black_value)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the number of backward pawns for both colors to assess pawn structure.\"\n    backward_pawns_count = 0\n    for square in board.piece_map():\n        piece = board.piece_at(square)\n        if piece and piece.piece_type == chess.PAWN:\n            if (piece.color == chess.WHITE and board.piece_at(square + 8) is None) or (piece.color == chess.BLACK and board.piece_at(square - 8) is None):\n                backward_pawns_count += 1\n    return float(backward_pawns_count)\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the total distance of all pieces from their respective home ranks to evaluate piece activity.\"\n    white_distance = sum(7 - chess.square_rank(square) for square, piece in board.piece_map().items() if piece.color == chess.WHITE)\n    black_distance = sum(chess.square_rank(square) for square, piece in board.piece_map().items() if piece.color == chess.BLACK)\n    return float(white_distance - black_distance)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Evaluates the coordination between queen and rook for both sides.\"\n    def has_rook_and_queen(color):\n        return any(piece.piece_type == chess.ROOK for piece in board.piece_map().values() if piece.color == color) and any(piece.piece_type == chess.QUEEN for piece in board.piece_map().values() if piece.color == color)\n\n    white_coordination = 1.0 if has_rook_and_queen(chess.WHITE) else 0.0\n    black_coordination = 1.0 if has_rook_and_queen(chess.BLACK) else 0.0\n    return float(white_coordination - black_coordination)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the presence of dangerous passed pawns that may promote.\"\n    passed_pawns_count = 0\n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.PAWN and piece.color == board.turn:\n            if (piece.color == chess.WHITE and square >= chess.A5) or (piece.color == chess.BLACK and square <= chess.H4):\n                passed = True\n                for file in range(chess.square_file(square) - 1, chess.square_file(square) + 2):\n                    if (file >= 0 and file < 8) and board.piece_at(chess.square(file, chess.square_rank(square) - (1 if piece.color == chess.WHITE else -1))):\n                        passed = False\n                        break\n                if passed:\n                    passed_pawns_count += 1 if piece.color == chess.WHITE else -1\n    return float(passed_pawns_count)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the king's safety by counting the number of pawns that protect it.\"\n    king_square = next(square for square, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color == board.turn)\n    protecting_pawns = sum(1 for square in range(64) if board.piece_at(square) and board.piece_at(square).piece_type == chess.PAWN and \n                           abs(chess.square_file(square) - chess.square_file(king_square)) <= 1 and \n                           abs(chess.square_rank(square) - chess.square_rank(king_square)) <= 1)\n    return float(protecting_pawns)\n\n",
    "def feature(board: chess.Board) -> float:\n    'Computes the control of central squares (d4, d5, e4, e5) by each side.'\n    central_squares = [chess.D4, chess.D5, chess.E4, chess.E5]\n    white_control = sum(1 for square in central_squares if board.is_attacked_by(chess.WHITE, square))\n    black_control = sum(1 for square in central_squares if board.is_attacked_by(chess.BLACK, square))\n    return float(white_control - black_control)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the number of pieces of each color that are pinned.\"\n    def is_pinned(color):\n        pinned_count = 0\n        for square, piece in board.piece_map().items():\n            if piece.color == color:\n                if any(board.attackers(color, square)):\n                    pinned_count += 1\n        return pinned_count\n    \n    white_pinned = is_pinned(chess.WHITE)\n    black_pinned = is_pinned(chess.BLACK)\n    return float(white_pinned - black_pinned)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the material value of the most valuable piece remaining for each player.\"\n    piece_value = {chess.PAWN: 1, chess.KNIGHT: 3, chess.BISHOP: 3, chess.ROOK: 5, chess.QUEEN: 9, chess.KING: 0}\n    white_valuable = max((piece_value[piece.piece_type] for sq, piece in board.piece_map().items() if piece.color == chess.WHITE), default=0)\n    black_valuable = max((piece_value[piece.piece_type] for sq, piece in board.piece_map().items() if piece.color == chess.BLACK), default=0)\n    return float(white_valuable - black_valuable)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in the number of opponent's pieces on the back rank.\"\n    white_back_rank_pieces = sum(1 for square in range(56, 64) if board.piece_at(square) and board.piece_at(square).color == chess.WHITE)\n    black_back_rank_pieces = sum(1 for square in range(0, 8) if board.piece_at(square) and board.piece_at(square).color == chess.BLACK)\n    return float(black_back_rank_pieces - white_back_rank_pieces)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the king safety by counting the number of pieces around the king's position.\"\n    def king_safety(color):\n        king_square = next(square for square, piece in board.piece_map().items() if piece.color == color and piece.piece_type == chess.KING)\n        return sum(1 for square in board.piece_map() if square in board.attackers(color, king_square))\n    \n    white_king_safety = king_safety(chess.WHITE)\n    black_king_safety = king_safety(chess.BLACK)\n    return float(black_king_safety - white_king_safety)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of different piece types present on the board.\"\n    piece_types = set()\n    for piece in board.piece_map().values():\n        piece_types.add(piece.piece_type)\n    return float(len(piece_types))\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Evaluates the mobility of the rooks based on their openness and control of files.\"\n    rook_mobility = sum(1 for square, piece in board.piece_map().items() \n                        if piece.color == board.turn and piece.piece_type == chess.ROOK and\n                        all(board.piece_at(chess.square(file, rank)) is None for file in range(8) \n                            for rank in range(8) if chess.square_file(square) == file))\n    return float(rook_mobility)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the number of outposts for knights for each side.\"\n    white_outposts = sum(1 for square in board.piece_map() if board.piece_map()[square].color == chess.WHITE and board.piece_map()[square].piece_type == chess.KNIGHT and chess.square_rank(square) in [5, 6])\n    black_outposts = sum(1 for square in board.piece_map() if board.piece_map()[square].color == chess.BLACK and board.piece_map()[square].piece_type == chess.KNIGHT and chess.square_rank(square) in [2, 3])\n    return float(white_outposts - black_outposts)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces each player has on the fourth rank, indicating advanced position.\"\n    white_on_fourth = len([square for square in board.piece_map() if board.piece_map()[square].color == chess.WHITE and chess.square_rank(square) == 3])\n    black_on_fourth = len([square for square in board.piece_map() if board.piece_map()[square].color == chess.BLACK and chess.square_rank(square) == 3])\n    return float(white_on_fourth - black_on_fourth)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the total piece activity based on how many squares each piece controls.\"\n    piece_control = {chess.WHITE: 0, chess.BLACK: 0}\n    for square in board.piece_map():\n        piece_color = board.piece_map()[square].color\n        piece_control[piece_color] += len(list(board.legal_moves))\n    return float(piece_control[chess.WHITE] - piece_control[chess.BLACK])\n\n",
    "def feature(board: chess.Board) -> float:\n    'Calculates the total number of attacking pieces for both players, highlighting their ability to threaten.'\n    white_attacks = sum(len(board.attackers(chess.WHITE, square)) for square in board.piece_map() if board.piece_map()[square].color == chess.WHITE)\n    black_attacks = sum(len(board.attackers(chess.BLACK, square)) for square in board.piece_map() if board.piece_map()[square].color == chess.BLACK)\n    return float(white_attacks - black_attacks)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the number of open files for rooks for both sides.\"\n    def open_files(color):\n        return sum(1 for file in range(8) if all(board.piece_at(chess.square(file, rank)) is None for rank in range(8) \n                                                   if board.piece_at(chess.square(file, rank)) and board.piece_at(chess.square(file, rank)).color != color))\n    \n    white_open_files = open_files(chess.WHITE)\n    black_open_files = open_files(chess.BLACK)\n    return float(white_open_files - black_open_files)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the ratio of major pieces (rooks and queens) to minor pieces (knights and bishops).\"\n    major_pieces = sum(1 for piece in board.piece_map().values() if piece.piece_type in {chess.ROOK, chess.QUEEN})\n    minor_pieces = sum(1 for piece in board.piece_map().values() if piece.piece_type in {chess.KNIGHT, chess.BISHOP})\n    return float(major_pieces / (minor_pieces + 1))  # Adding 1 to avoid division by zero\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Evaluates the pawn structure's overall strengths, including the number of protected pawns.\"\n    def count_protected_pawns(color):\n        protected_count = 0\n        for square in chess.SQUARES:\n            piece = board.piece_at(square)\n            if piece and piece.color == color and piece.piece_type == chess.PAWN:\n                file = chess.square_file(square)\n                rank = chess.square_rank(square)\n                if (file > 0 and board.is_attacked_by(not color, chess.square(file - 1, rank))) or \\\n                   (file < 7 and board.is_attacked_by(not color, chess.square(file + 1, rank))):\n                    protected_count += 1\n        return protected_count\n\n    white_protected = count_protected_pawns(chess.WHITE)\n    black_protected = count_protected_pawns(chess.BLACK)\n    return float(white_protected - black_protected)\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the piece activity by counting the distance of pieces from the center of the board.\"\n    center_squares = [chess.D4, chess.D5, chess.E4, chess.E5]\n    \n    def distance_from_center(square):\n        return min(chess.square_distance(square, cs) for cs in center_squares)\n    \n    white_activity = sum(distance_from_center(square) for square in board.piece_map() if board.piece_map()[square].color == chess.WHITE)\n    black_activity = sum(distance_from_center(square) for square in board.piece_map() if board.piece_map()[square].color == chess.BLACK)\n    \n    return float(black_activity - white_activity)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of rooks on open files for each side.\"\n    white_open_files = sum(1 for file in range(8) if all(board.piece_at(chess.square(file, rank)) is None for rank in range(8) if board.piece_at(chess.square(file, rank)) and board.piece_at(chess.square(file, rank)).color == chess.WHITE))\n    black_open_files = sum(1 for file in range(8) if all(board.piece_at(chess.square(file, rank)) is None for rank in range(8) if board.piece_at(chess.square(file, rank)) and board.piece_at(chess.square(file, rank)).color == chess.BLACK))\n    return float(white_open_files - black_open_files)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in the number of major pieces (rooks and queens) each side has.\"\n    def count_major_pieces(color):\n        return sum(1 for piece in board.piece_map().values() if piece.color == color and piece.piece_type in {chess.ROOK, chess.QUEEN})\n    \n    white_major = count_major_pieces(chess.WHITE)\n    black_major = count_major_pieces(chess.BLACK)\n    return float(white_major - black_major)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the number of pawns that have advanced to the 5th rank or beyond.\"\n    advanced_pawns = sum(1 for square, piece in board.piece_map().items() if piece.piece_type == chess.PAWN and \n                         (piece.color == chess.WHITE and chess.square_rank(square) >= 4 or \n                          piece.color == chess.BLACK and chess.square_rank(square) <= 3))\n    return float(advanced_pawns)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in piece activity based on distance from home squares.\"\n    activity_score = 0.0\n    \n    for square, piece in board.piece_map().items():\n        distance = chess.square_rank(square) if piece.color == chess.WHITE else 7 - chess.square_rank(square)\n        activity_score += distance if piece.color == chess.WHITE else -distance\n    \n    return activity_score\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Evaluates the number of potential back-rank weaknesses for each side.\"\n    def back_rank_weakness(color):\n        piece_rows = {chess.WHITE: 0, chess.BLACK: 7}\n        return sum(1 for square in range(8) if board.is_attacked_by(not color, chess.square(square, piece_rows[color])))\n\n    white_weakness = back_rank_weakness(chess.WHITE)\n    black_weakness = back_rank_weakness(chess.BLACK)\n    return float(black_weakness - white_weakness)\n",
    "def feature(board: chess.Board) -> float:\n    'Calculates the distribution of pieces across files, reflecting control of the center.'\n    file_control = [0] * 8\n    for square in board.piece_map():\n        piece = board.piece_at(square)\n        if piece:\n            file_control[chess.square_file(square)] += 1 if piece.color == chess.WHITE else -1\n    return float(max(file_control) - min(file_control))\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the number of pawns that are on the 3rd and 6th ranks for each side.\"\n    white_pawns = sum(1 for square in board.piece_map() if board.piece_map()[square].color == chess.WHITE and chess.square_rank(square) == 5)\n    black_pawns = sum(1 for square in board.piece_map() if board.piece_map()[square].color == chess.BLACK and chess.square_rank(square) == 2)\n    return float(white_pawns - black_pawns)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces that are participating in threats to the opponent's pieces.\"\n    threats = sum(1 for square in board.piece_map() if board.is_attacked_by(not board.turn, square))\n    return float(threats)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the total value of pieces each side has while considering the positions of their kings.\"\n    material_values = {\n        chess.PAWN: 1,\n        chess.KNIGHT: 3,\n        chess.BISHOP: 3,\n        chess.ROOK: 5,\n        chess.QUEEN: 9,\n        chess.KING: 0\n    }\n    white_value = sum(material_values[piece.piece_type] for piece in board.piece_map().values() if piece.color == chess.WHITE)\n    black_value = sum(material_values[piece.piece_type] for piece in board.piece_map().values() if piece.color == chess.BLACK)\n    \n    white_king_pos = sum(chess.square_rank(square) for square in board.piece_map() if board.piece_map()[square].piece_type == chess.KING and board.piece_map()[square].color == chess.WHITE)\n    black_king_pos = sum(chess.square_rank(square) for square in board.piece_map() if board.piece_map()[square].piece_type == chess.KING and board.piece_map()[square].color == chess.BLACK)\n    \n    adjusted_white_value = white_value - (white_king_pos / 10)\n    adjusted_black_value = black_value - ((7 - black_king_pos) / 10)\n    \n    return float(adjusted_white_value - adjusted_black_value)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the total value of pieces for the player to move.\"\n    piece_values = {chess.PAWN: 1, chess.KNIGHT: 3, chess.BISHOP: 3, chess.ROOK: 5, chess.QUEEN: 9, chess.KING: 0}\n    total_value = 0.0\n    for square, piece in board.piece_map().items():\n        if piece.color == board.turn:\n            total_value += piece_values.get(piece.piece_type, 0)\n    return total_value\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in values of pieces on each side that are on the board's edge.\"\n    edge_squares = {chess.A1, chess.B1, chess.C1, chess.D1, chess.E1, chess.F1, chess.G1, chess.H1,\n                    chess.A8, chess.B8, chess.C8, chess.D8, chess.E8, chess.F8, chess.G8, chess.H8}\n    \n    material_values = {\n        chess.PAWN: 1,\n        chess.KNIGHT: 3,\n        chess.BISHOP: 3,\n        chess.ROOK: 5,\n        chess.QUEEN: 9,\n        chess.KING: 0\n    }\n    \n    edge_value_white = sum(material_values[piece.piece_type] for square, piece in board.piece_map().items() if piece.color == chess.WHITE and square in edge_squares)\n    edge_value_black = sum(material_values[piece.piece_type] for square, piece in board.piece_map().items() if piece.color == chess.BLACK and square in edge_squares)\n\n    return float(edge_value_white - edge_value_black)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the total number of pieces on the board.\"\n    total_piece_count = len(board.piece_map())\n    return float(total_piece_count)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in the number of potential forks by knights for both sides.\"\n    knight_forks = {chess.WHITE: 0, chess.BLACK: 0}\n    knight_squares = [s for s in board.piece_map() if board.piece_map()[s].piece_type == chess.KNIGHT]\n    for square in knight_squares:\n        for attacker in board.attackers(board.piece_map()[square].color, square):\n            if board.piece_map()[attacker].color != board.piece_map()[square].color:\n                knight_forks[board.piece_map()[square].color] += 1\n    return float(knight_forks[chess.WHITE] - knight_forks[chess.BLACK])\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the number of major pieces for both sides.\"\n    white_major_count = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE and piece.piece_type in {chess.ROOK, chess.QUEEN})\n    black_major_count = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK and piece.piece_type in {chess.ROOK, chess.QUEEN})\n    return float(white_major_count - black_major_count)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the total number of squares attacked by each player's pieces.\"\n    white_attacks = sum(1 for square in board.piece_map() if board.piece_map()[square].color == chess.WHITE and board.is_attacked_by(chess.WHITE, square))\n    black_attacks = sum(1 for square in board.piece_map() if board.piece_map()[square].color == chess.BLACK and board.is_attacked_by(chess.BLACK, square))\n    return float(white_attacks - black_attacks)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in the number of major pieces (rook and queen) each side has on the board.\"\n    def count_major_pieces(color):\n        return sum(1 for square, piece in board.piece_map().items() if piece.color == color and piece.piece_type in {chess.ROOK, chess.QUEEN})\n    white_major = count_major_pieces(chess.WHITE)\n    black_major = count_major_pieces(chess.BLACK)\n    return float(white_major - black_major)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in number of attacking pieces each side has.\"\n    white_attackers = sum(1 for square in chess.SQUARES if board.is_attacked_by(chess.WHITE, square))\n    black_attackers = sum(1 for square in chess.SQUARES if board.is_attacked_by(chess.BLACK, square))\n    return float(white_attackers - black_attackers)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in control of the center squares (d4, d5, e4, e5).\"\n    center_squares = [chess.D4, chess.D5, chess.E4, chess.E5]\n    control_white = sum(board.is_attacked_by(chess.WHITE, sq) for sq in center_squares)\n    control_black = sum(board.is_attacked_by(chess.BLACK, sq) for sq in center_squares)\n    return float(control_white - control_black)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Evaluates pawn advancement by calculating the average rank of pawns for each side.\"\n    def average_pawn_rank(color):\n        pawns = [chess.square_rank(square) for square in board.piece_map() \n                  if board.piece_map()[square].color == color and board.piece_map()[square].piece_type == chess.PAWN]\n        return sum(pawns) / len(pawns) if pawns else 0\n    \n    white_avg_rank = average_pawn_rank(chess.WHITE)\n    black_avg_rank = average_pawn_rank(chess.BLACK)\n    return float(white_avg_rank - black_avg_rank)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the average rank of pawns for each player.\"\n    def average_pawn_rank(color):\n        pawns = [chess.square_rank(square) for square in board.piece_map() if board.piece_map()[square].color == color and board.piece_map()[square].piece_type == chess.PAWN]\n        return sum(pawns) / (len(pawns) + 1)  # Prevent division by zero\n\n    white_avg_rank = average_pawn_rank(chess.WHITE)\n    black_avg_rank = average_pawn_rank(chess.BLACK)\n    result = white_avg_rank - black_avg_rank\n    return float(result)\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the average distance of each player's pieces from their respective kings to indicate safety.\"\n    white_king = board.king(chess.WHITE)\n    black_king = board.king(chess.BLACK)\n    \n    if white_king is None or black_king is None:\n        return 0.0\n    \n    white_dist = sum(chess.square_distance(white_king, square) for square in board.piece_map() if board.piece_at(square).color == chess.WHITE) / (len(board.piece_map()) // 2)\n    black_dist = sum(chess.square_distance(black_king, square) for square in board.piece_map() if board.piece_at(square).color == chess.BLACK) / (len(board.piece_map()) // 2)\n\n    return float(white_dist - black_dist)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the bishops' control of diagonals in terms of the number of open squares on those diagonals.\"\n    def bishop_control(color):\n        total_control = 0\n        for square in board.piece_map():\n            piece = board.piece_map()[square]\n            if piece.color == color and piece.piece_type == chess.BISHOP:\n                total_control += sum(1 for sq in chess.SQUARES if board.is_attacked_by(color, sq) and chess.square_file(square) != chess.square_file(sq))\n        return total_control\n\n    white_control = bishop_control(chess.WHITE)\n    black_control = bishop_control(chess.BLACK)\n    return float(white_control - black_control)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the total pairs of pawns on adjacent files for both sides.\"\n    white_pawn_files = {chess.square_file(square) for square in chess.SQUARES if board.piece_at(square) and board.piece_at(square).color == chess.WHITE and board.piece_at(square).piece_type == chess.PAWN}\n    black_pawn_files = {chess.square_file(square) for square in chess.SQUARES if board.piece_at(square) and board.piece_at(square).color == chess.BLACK and board.piece_at(square).piece_type == chess.PAWN}\n    \n    white_pairs = sum(1 for f in white_pawn_files if f + 1 in white_pawn_files or f - 1 in white_pawn_files)\n    black_pairs = sum(1 for f in black_pawn_files if f + 1 in black_pawn_files or f - 1 in black_pawn_files)\n    \n    return float(white_pairs - black_pairs)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the distribution of pieces across ranks to indicate control of the board.\"\n    white_distribution = sum(1 for square in board.piece_map() if board.piece_at(square).color == chess.WHITE and chess.square_rank(square) >= 4)\n    black_distribution = sum(1 for square in board.piece_map() if board.piece_at(square).color == chess.BLACK and chess.square_rank(square) <= 3)\n    result = white_distribution - black_distribution\n    return float(result)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the king's safety based on the number of escape squares.\"\n    king_square = next(square for square in board.piece_map() if board.piece_map()[square].piece_type == chess.KING and board.piece_map()[square].color == board.turn)\n    escape_squares = sum(1 for move in board.legal_moves if move.from_square == king_square)\n    return float(escape_squares)\n",
    "def feature(board: chess.Board) -> float:\n    \"Determines the number of doubled pawns for both sides, affecting pawn structure.\"\n    def count_doubled_pawns(color):\n        ranks = [0] * 8\n        for square, piece in board.piece_map().items():\n            if piece.color == color and piece.piece_type == chess.PAWN:\n                ranks[chess.square_rank(square)] += 1\n        return sum(max(0, count - 1) for count in ranks)\n    \n    white_doubled = count_doubled_pawns(chess.WHITE)\n    black_doubled = count_doubled_pawns(chess.BLACK)\n    return float(white_doubled - black_doubled)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the ratio of pawns to total pieces for each color.\"\n    white_pawn_count = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE and piece.piece_type == chess.PAWN)\n    black_pawn_count = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK and piece.piece_type == chess.PAWN)\n    total_white_piece_count = len([piece for piece in board.piece_map().values() if piece.color == chess.WHITE])\n    total_black_piece_count = len([piece for piece in board.piece_map().values() if piece.color == chess.BLACK])\n    \n    white_ratio = white_pawn_count / total_white_piece_count if total_white_piece_count > 0 else 0\n    black_ratio = black_pawn_count / total_black_piece_count if total_black_piece_count > 0 else 0\n\n    return float(white_ratio - black_ratio)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of doubled pawns for each color.\"\n    white_doubled = sum(1 for file in range(8) if (board.piece_at(chess.parse_square(f'{chr(file + 97)}2')) and board.piece_at(chess.parse_square(f'{chr(file + 97)}3'))))\n    black_doubled = sum(1 for file in range(8) if (board.piece_at(chess.parse_square(f'{chr(file + 97)}7')) and board.piece_at(chess.parse_square(f'{chr(file + 97)}6'))))\n    return float(white_doubled - black_doubled)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the activity of the queen based on its potential to attack.\"\n    white_queen = next((square for square in board.piece_map() if board.piece_map()[square].color == chess.WHITE and board.piece_map()[square].piece_type == chess.QUEEN), None)\n    black_queen = next((square for square in board.piece_map() if board.piece_map()[square].color == chess.BLACK and board.piece_map()[square].piece_type == chess.QUEEN), None)\n    white_queen_activity = len([move for move in board.legal_moves if move.from_square == white_queen]) if white_queen else 0\n    black_queen_activity = len([move for move in board.legal_moves if move.from_square == black_queen]) if black_queen else 0\n    return float(white_queen_activity - black_queen_activity)\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the quality of pawn advancement based on pawn distance to promotion.\"\n    def pawn_advancement(color):\n        advancement = 0\n        for square in board.piece_map():\n            piece = board.piece_at(square)\n            if piece and piece.color == color and piece.piece_type == chess.PAWN:\n                rank = chess.square_rank(square)\n                advancement += (6 - rank) if color == chess.WHITE else (rank - 1)\n        return advancement\n\n    return float(pawn_advancement(chess.WHITE) - pawn_advancement(chess.BLACK))\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the average distance of pieces from the center of the board.\"\n    total_distance = 0\n    piece_count = 0\n    center_squares = [chess.D4, chess.D5, chess.E4, chess.E5]\n    \n    for square in board.piece_map():\n        piece_count += 1\n        distance = min(chess.square_distance(square, csq) for csq in center_squares)\n        total_distance += distance\n    \n    return total_distance / piece_count if piece_count > 0 else 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the number of pieces aligned with the opponent's king, simulating a potential check.\"\n    opponent_king_square = next(square for square in board.piece_map() if board.piece_map()[square].color != board.turn and board.piece_map()[square].piece_type == chess.KING)\n    alignments = sum(1 for square, piece in board.piece_map().items() if piece.color == board.turn and (chess.square_file(square) == chess.square_file(opponent_king_square) or chess.square_rank(square) == chess.square_rank(opponent_king_square)))\n    return float(alignments)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the density of pieces in the center of the board.\"\n    center_squares = [chess.D4, chess.D5, chess.E4, chess.E5]\n    white_center_density = sum(1 for square in center_squares if board.piece_at(square) and board.piece_at(square).color == chess.WHITE)\n    black_center_density = sum(1 for square in center_squares if board.piece_at(square) and board.piece_at(square).color == chess.BLACK)\n    return float(white_center_density - black_center_density)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces unable to move due to being blocked or pinned for each side.\"\n    blocked_pieces_white = sum(1 for square in board.piece_map() if board.piece_map()[square].color == chess.WHITE and not any(board.piece_at(move.to_square) for move in board.legal_moves))\n    blocked_pieces_black = sum(1 for square in board.piece_map() if board.piece_map()[square].color == chess.BLACK and not any(board.piece_at(move.to_square) for move in board.legal_moves))\n    return float(blocked_pieces_white - blocked_pieces_black)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the mobility of each side by counting the number of legal captures available.\"\n    white_captures = sum(1 for move in board.legal_moves if move.to_square in [m.to_square for m in board.legal_moves if board.piece_at(m.to_square) and board.piece_at(m.to_square).color == chess.BLACK])\n    black_captures = sum(1 for move in board.legal_moves if move.to_square in [m.to_square for m in board.legal_moves if board.piece_at(m.to_square) and board.piece_at(m.to_square).color == chess.WHITE])\n    return float(white_captures - black_captures)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Evaluates the symmetry of pieces on both sides for potential attacking chances.\"\n    symmetry_score = 0\n    for square in board.piece_map():\n        piece = board.piece_at(square)\n        mirrored_square = chess.square(7 - chess.square_file(square), chess.square_rank(square))\n        if piece and board.piece_at(mirrored_square) is not None:\n            symmetry_score += 1\n    return float(symmetry_score)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in the number of moves available between both players.\"\n    white_moves = len(list(board.legal_moves)) if board.turn == chess.WHITE else 0\n    black_moves = len(list(board.legal_moves)) if board.turn == chess.BLACK else 0\n    return float(white_moves - black_moves)\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the material value difference between white and black.\"\n    material_values = {\n        chess.PAWN: 1,\n        chess.KNIGHT: 3,\n        chess.BISHOP: 3,\n        chess.ROOK: 5,\n        chess.QUEEN: 9,\n        chess.KING: 0  # King has no material value\n    }\n    white_material = sum(material_values[piece.piece_type] for piece in board.piece_map().values() if piece.color == chess.WHITE)\n    black_material = sum(material_values[piece.piece_type] for piece in board.piece_map().values() if piece.color == chess.BLACK)\n    return float(white_material - black_material)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the number of pieces in the opponent's half of the board.\"\n    opponent_half = range(0, 32) if board.turn else range(32, 64)\n    piece_count = sum(1 for square, piece in board.piece_map().items() if piece.color == board.turn and square in opponent_half)\n    return float(piece_count)\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the number of isolated pawns for each side.\"\n    def isolated_pawns(color):\n        count = 0\n        for file in range(8):\n            if board.piece_at(chess.square(file, 1 if color == chess.WHITE else 6)) == chess.PAWN:\n                if (file > 0 and board.piece_at(chess.square(file-1, 1 if color == chess.WHITE else 6)) != chess.PAWN) and \\\n                   (file < 7 and board.piece_at(chess.square(file+1, 1 if color == chess.WHITE else 6)) != chess.PAWN):\n                    count += 1\n        return count\n    white_isolated = isolated_pawns(chess.WHITE)\n    black_isolated = isolated_pawns(chess.BLACK)\n    return float(white_isolated - black_isolated)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the number of pieces attacking the opponent's advanced pawns.\"\n    attacking_count = 0\n    for sq in board.piece_map():\n        piece = board.piece_at(sq)\n        if piece.color == board.turn:\n            # Check if this piece is attacking any opponent's advanced pawn\n            for target in board.piece_map():\n                target_piece = board.piece_at(target)\n                if target_piece and target_piece.color != piece.color and target_piece.piece_type == chess.PAWN:\n                    if (piece.color == chess.WHITE and chess.square_rank(target) == 6) or \\\n                       (piece.color == chess.BLACK and chess.square_rank(target) == 1):\n                        if board.is_attacked_by(piece.color, target):\n                            attacking_count += 1\n    return float(attacking_count)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the total square control by counting how many squares are attacked by each player's pieces.\"\n    white_control = sum(board.is_attacked_by(chess.WHITE, sq) for sq in range(64))\n    black_control = sum(board.is_attacked_by(chess.BLACK, sq) for sq in range(64))\n    return float(white_control - black_control)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the central control by counting pieces occupying or attacking the central squares.\"\n    central_squares = [chess.E4, chess.E5, chess.D4, chess.D5]\n    white_control = sum(1 for square in central_squares if board.is_attacked_by(chess.WHITE, square) or board.piece_at(square) and board.piece_at(square).color == chess.WHITE)\n    black_control = sum(1 for square in central_squares if board.is_attacked_by(chess.BLACK, square) or board.piece_at(square) and board.piece_at(square).color == chess.BLACK)\n    return float(white_control - black_control)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Determines the presence of dangerous passed pawns for the current player.\"\n    passed_pawn_count = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == board.turn and piece.piece_type == chess.PAWN:\n            if all(board.piece_at(chess.square(file, square_rank)) is None for file in range(chess.square_file(square) + 1, 8) for square_rank in range(chess.square_rank(square) + 1, 8)):\n                passed_pawn_count += 1\n    return float(passed_pawn_count)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the total value of each player's pieces expressed in terms of material.\"\n    material_values = {\n        chess.PAWN: 1,\n        chess.KNIGHT: 3,\n        chess.BISHOP: 3,\n        chess.ROOK: 5,\n        chess.QUEEN: 9\n    }\n    total_value = sum(material_values.get(piece.piece_type, 0) for piece in board.piece_map().values())\n    return float(total_value)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Evaluates the king's safety based on the number of pieces defending it.\"\n    white_king_square = next((square for square in board.piece_map() if board.piece_map()[square].color == chess.WHITE and board.piece_map()[square].piece_type == chess.KING), None)\n    black_king_square = next((square for square in board.piece_map() if board.piece_map()[square].color == chess.BLACK and board.piece_map()[square].piece_type == chess.KING), None)\n    white_defenders = len(board.attackers(chess.WHITE, white_king_square)) if white_king_square else 0\n    black_defenders = len(board.attackers(chess.BLACK, black_king_square)) if black_king_square else 0\n    return float(white_defenders - black_defenders)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the total value of pieces controlling key squares (d4, d5, e4, e5).\"\n    key_squares = [chess.D4, chess.D5, chess.E4, chess.E5]\n    control_value = 0\n    for square in key_squares:\n        for piece in board.attackers(chess.WHITE, square):\n            control_value += board.piece_at(piece).piece_type\n        for piece in board.attackers(chess.BLACK, square):\n            control_value -= board.piece_at(piece).piece_type\n    return float(control_value)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in the number of pieces in the endgame stage for both sides.\"\n    endgame_threshold = 5 \n    white_pieces = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE)\n    black_pieces = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK)\n    return float((white_pieces < endgame_threshold) - (black_pieces < endgame_threshold))\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the number of relative attacks on pieces, indicating tactical awareness.\"\n    white_attacks = sum(len(board.attackers(chess.WHITE, square)) for square in board.piece_map())\n    black_attacks = sum(len(board.attackers(chess.BLACK, square)) for square in board.piece_map())\n    return float(white_attacks - black_attacks)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in piece value locations based on piece placement.\"\n    piece_values = {chess.PAWN: 1, chess.KNIGHT: 3, chess.BISHOP: 3, chess.ROOK: 5, chess.QUEEN: 9, chess.KING: 0}\n    def value_position(color):\n        total_value = 0\n        for square, piece in board.piece_map().items():\n            if piece.color == color:\n                total_value += piece_values[piece.piece_type] * (8 - chess.square_rank(square) if color == chess.WHITE else chess.square_rank(square))\n        return total_value\n    white_position_value = value_position(chess.WHITE)\n    black_position_value = value_position(chess.BLACK)\n    return float(white_position_value - black_position_value)\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of squares controlled by each player.\"\n    controlled_by_white = len([square for square in chess.SQUARES if board.is_attacked_by(chess.WHITE, square)])\n    controlled_by_black = len([square for square in chess.SQUARES if board.is_attacked_by(chess.BLACK, square)])\n    control_difference = controlled_by_white - controlled_by_black\n    return float(control_difference)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the total number of pieces each side can capture next move.\"\n    white_captures = sum(1 for move in board.legal_moves \n                         if board.piece_at(move.to_square) and \n                         board.piece_at(move.to_square).color == chess.BLACK)\n    black_captures = sum(1 for move in board.legal_moves \n                         if board.piece_at(move.to_square) and \n                         board.piece_at(move.to_square).color == chess.WHITE)\n    return float(white_captures - black_captures)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the number of potential pawn promotions on the board.\"\n    promotions = 0.0\n    for square in range(64):\n        piece = board.piece_at(square)\n        if piece and piece.piece_type == chess.PAWN:\n            if (piece.color == chess.WHITE and chess.square_rank(square) == 6) or \\\n               (piece.color == chess.BLACK and chess.square_rank(square) == 1):\n                promotions += 1\n    return promotions\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces that are attacking enemy pawns to assess pressure.\"\n    white_attacks = sum(1 for square in chess.SQUARES if board.is_attacked_by(chess.WHITE, square) and board.piece_at(square) and board.piece_at(square).piece_type == chess.PAWN)\n    black_attacks = sum(1 for square in chess.SQUARES if board.is_attacked_by(chess.BLACK, square) and board.piece_at(square) and board.piece_at(square).piece_type == chess.PAWN)\n    return float(white_attacks - black_attacks)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the advancement of pawns for each side.\"\n    white_advanced_pawns = sum(1 for square in board.piece_map() if board.piece_map()[square].color == chess.WHITE and chess.square_rank(square) > 4)\n    black_advanced_pawns = sum(1 for square in board.piece_map() if board.piece_map()[square].color == chess.BLACK and chess.square_rank(square) < 3)\n    return float(white_advanced_pawns - black_advanced_pawns)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the material balance between white and black pieces.\"\n    material_values = {\n        chess.PAWN: 1,\n        chess.KNIGHT: 3,\n        chess.BISHOP: 3,\n        chess.ROOK: 5,\n        chess.QUEEN: 9,\n        chess.KING: 0  # King is not valued as it's not capturable\n    }\n    white_material = sum(material_values[piece.piece_type] for piece in board.piece_map().values() if piece.color == chess.WHITE)\n    black_material = sum(material_values[piece.piece_type] for piece in board.piece_map().values() if piece.color == chess.BLACK)\n    return float(white_material - black_material)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the control of the center squares (d4, d5, e4, e5) by each side.\"\n    center_squares = [chess.parse_square(sq) for sq in ['d4', 'd5', 'e4', 'e5']]\n    white_control = sum(1 for square in center_squares if board.is_attacked_by(chess.WHITE, square))\n    black_control = sum(1 for square in center_squares if board.is_attacked_by(chess.BLACK, square))\n    return float(white_control - black_control)\n\n",
    "def feature(board: chess.Board) -> float:\n    'Calculates the total number of defenders for each piece on the board.'\n    defenders = sum(len(board.attackers(piece.color, square)) for square, piece in board.piece_map().items())\n    return float(defenders)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in the number of pawns past the opponent's 4th rank.\"\n    white_pawns_advanced = sum(1 for square in board.piece_map() if board.piece_map()[square].color == chess.WHITE and chess.square_rank(square) >= 4)\n    black_pawns_advanced = sum(1 for square in board.piece_map() if board.piece_map()[square].color == chess.BLACK and chess.square_rank(square) <= 3)\n    return float(white_pawns_advanced - black_pawns_advanced)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the amount of potential pawn promotion for each side.\"\n    white_pawn_promotions = sum(1 for square in board.piece_map() if board.piece_map()[square].color == chess.WHITE and chess.square_rank(square) == 6)\n    black_pawn_promotions = sum(1 for square in board.piece_map() if board.piece_map()[square].color == chess.BLACK and chess.square_rank(square) == 1)\n    return float(white_pawn_promotions - black_pawn_promotions)\n\n",
    "def feature(board: chess.Board) -> float:\n    'Calculates the concentration of pieces within a 3x3 area around the kings.'\n    white_king_square = next(sq for sq in board.piece_map() \n                              if board.piece_at(sq).color == chess.WHITE and \n                              board.piece_at(sq).piece_type == chess.KING\n                             )\n    black_king_square = next(sq for sq in board.piece_map() \n                              if board.piece_at(sq).color == chess.BLACK and \n                              board.piece_at(sq).piece_type == chess.KING\n                             )\n    white_neighbors = sum(1 for square in chess.SQUARES \n                          if chess.square_distance(square, white_king_square) <= 2 and \n                          board.piece_at(square) is not None and \n                          board.piece_at(square).color == chess.WHITE\n                         )\n    black_neighbors = sum(1 for square in chess.SQUARES \n                          if chess.square_distance(square, black_king_square) <= 2 and \n                          board.piece_at(square) is not None and \n                          board.piece_at(square).color == chess.BLACK\n                         )\n    return float(white_neighbors - black_neighbors)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Examines the pawn majority on each side to assess endgame potential.\"\n    white_pawn_files = [chess.square_file(square) for square in range(8) if board.piece_at(chess.parse_square(chess.square_name(square))) and board.piece_at(chess.parse_square(chess.square_name(square))).color == chess.WHITE]\n    black_pawn_files = [chess.square_file(square) for square in range(56, 64) if board.piece_at(chess.parse_square(chess.square_name(square))) and board.piece_at(chess.parse_square(chess.square_name(square))).color == chess.BLACK]\n    return float(len(white_pawn_files) - len(black_pawn_files))\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts how many pieces are hanging (unprotected and can be captured next move).\"\n    hanging_count = sum(1 for square in board.piece_map() if board.piece_at(square) and \n                        not any(board.is_attacked_by(board.piece_at(square).color, attacker_square) for attacker_square in board.attackers(\n                            chess.BLACK if board.piece_at(square).color == chess.WHITE else chess.WHITE, square)))\n    return float(hanging_count)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces pinned by the opponent's pieces.\"\n    pinned_count = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == board.turn:\n            for target in board.attackers(board.turn, square):\n                if board.piece_at(target) and board.piece_at(target).color != board.turn:\n                    pinned_count += 1\n                    break\n    return float(pinned_count)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the influence of each player by counting how many squares are attacked.\"\n    white_attacks = sum(1 for square in chess.SQUARES if board.is_attacked_by(chess.WHITE, square))\n    black_attacks = sum(1 for square in chess.SQUARES if board.is_attacked_by(chess.BLACK, square))\n    return float(white_attacks - black_attacks)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the presence of pieces on strategic squares (c3, c6, f3, f6).\"\n    strategic_squares = [chess.C3, chess.C6, chess.F3, chess.F6]\n    white_strategic_count = sum(1 for square in strategic_squares if board.piece_at(square) and board.piece_at(square).color == chess.WHITE)\n    black_strategic_count = sum(1 for square in strategic_squares if board.piece_at(square) and board.piece_at(square).color == chess.BLACK)\n    return float(white_strategic_count - black_strategic_count)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the piece activity by evaluating pieces not on their starting positions.\"\n    def piece_activity(color):\n        count = 0\n        for square, piece in board.piece_map().items():\n            if piece.color == color:\n                starting_rank = 1 if color == chess.WHITE else 6\n                if chess.square_rank(square) != starting_rank:\n                    count += 1\n        return count\n\n    white_activity = piece_activity(chess.WHITE)\n    black_activity = piece_activity(chess.BLACK)\n    return float(white_activity - black_activity)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the number of pins for each side based on current piece positions.\"\n    pinned_pieces = 0\n    for square in board.piece_map():\n        piece = board.piece_at(square)\n        if piece:\n            # Check if there's a potential to pin this piece\n            for attacking_square in board.attackers(not piece.color, square):\n                if board.is_attacked_by(piece.color, attacking_square):\n                    pinned_pieces += 1\n                    break\n    result = pinned_pieces\n    return result\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the sum of ranks occupied by each player's pawns.\"\n    white_pawn_ranks = sum(chess.square_rank(sq) for sq in board.piece_map() if board.piece_at(sq).color == chess.WHITE and board.piece_at(sq).piece_type == chess.PAWN)\n    black_pawn_ranks = sum(7 - chess.square_rank(sq) for sq in board.piece_map() if board.piece_at(sq).color == chess.BLACK and board.piece_at(sq).piece_type == chess.PAWN)\n\n    return float(white_pawn_ranks - black_pawn_ranks)\n",
    "def feature(board: chess.Board) -> float:\n    \"Evaluates the pawn structure by counting isolated pawns for each side.\"\n    white_isolated_pawns = sum(1 for file in range(8) if board.piece_at(chess.square(file, 1)) == chess.PAWN and (file == 0 or file == 7 or (board.piece_at(chess.square(file - 1, 1)) is None and board.piece_at(chess.square(file + 1, 1)) is None)))\n    black_isolated_pawns = sum(1 for file in range(8) if board.piece_at(chess.square(file, 6)) == chess.PAWN and (file == 0 or file == 7 or (board.piece_at(chess.square(file - 1, 6)) is None and board.piece_at(chess.square(file + 1, 6)) is None)))\n    return float(white_isolated_pawns - black_isolated_pawns)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Assesses king safety by counting the number of escape squares available for each king.\"\n    white_king = next(square for square in board.piece_map() if board.piece_at(square).color == chess.WHITE and board.piece_at(square).piece_type == chess.KING)\n    black_king = next(square for square in board.piece_map() if board.piece_at(square).color == chess.BLACK and board.piece_at(square).piece_type == chess.KING)\n    white_escape_squares = sum(1 for move in board.legal_moves if chess.square_distance(white_king, move.to_square) == 1)\n    black_escape_squares = sum(1 for move in board.legal_moves if chess.square_distance(black_king, move.to_square) == 1)\n    return float(white_escape_squares - black_escape_squares)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the balance of piece types by comparing the total number of minor and major pieces of both sides.\"\n    piece_count = {\n        chess.WHITE: {'minor': 0, 'major': 0},\n        chess.BLACK: {'minor': 0, 'major': 0}\n    }\n    \n    for piece in board.piece_map().values():\n        if piece.piece_type in {chess.KNIGHT, chess.BISHOP}:\n            piece_count[piece.color]['minor'] += 1\n        elif piece.piece_type in {chess.ROOK, chess.QUEEN}:\n            piece_count[piece.color]['major'] += 1\n\n    return float(piece_count[chess.WHITE]['minor'] + piece_count[chess.WHITE]['major'] - (piece_count[chess.BLACK]['minor'] + piece_count[chess.BLACK]['major']))\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the number of squares attacked by both players' pieces to assess control.\"\n    white_attacked_squares = len(set(square for move in board.legal_moves if board.piece_at(move.from_square).color == chess.WHITE for square in board.attacks(move.to_square)))\n    black_attacked_squares = len(set(square for move in board.legal_moves if board.piece_at(move.from_square).color == chess.BLACK for square in board.attacks(move.to_square)))\n    return float(white_attacked_squares - black_attacked_squares)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the number of passed pawns for each player and returns the difference.\"\n    def is_passed_pawn(square, color):\n        if color == chess.WHITE:\n            for rank in range(chess.square_rank(square) + 1, 8):\n                if board.piece_at(chess.square(chess.square_file(square), rank)) and board.piece_at(chess.square(chess.square_file(square), rank)).color == chess.BLACK:\n                    return False\n        else:\n            for rank in range(chess.square_rank(square)):\n                if board.piece_at(chess.square(chess.square_file(square), rank)) and board.piece_at(chess.square(chess.square_file(square), rank)).color == chess.WHITE:\n                    return False\n        return True\n    \n    white_passed = sum(1 for sq in board.piece_map() if board.piece_map()[sq].color == chess.WHITE and is_passed_pawn(sq, chess.WHITE))\n    black_passed = sum(1 for sq in board.piece_map() if board.piece_map()[sq].color == chess.BLACK and is_passed_pawn(sq, chess.BLACK))\n    \n    return float(white_passed - black_passed)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of unprotected pieces for each player.\"\n    white_unprotected = sum(1 for square, piece in board.piece_map().items() if piece.color == chess.WHITE and not board.is_attacked_by(chess.BLACK, square))\n    black_unprotected = sum(1 for square, piece in board.piece_map().items() if piece.color == chess.BLACK and not board.is_attacked_by(chess.WHITE, square))\n    return float(white_unprotected - black_unprotected)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in active pieces (pieces able to move) for both sides.\"\n    white_active = sum(1 for move in board.legal_moves if board.piece_map()[move.from_square].color == chess.WHITE)\n    black_active = sum(1 for move in board.legal_moves if board.piece_map()[move.from_square].color == chess.BLACK)\n    return float(white_active - black_active)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the average distance of pieces to the opponent's king for both sides.\"\n    def average_distance(color):\n        king_square = next(square for square, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color == (color))\n        distances = [chess.square_distance(square, king_square) for square, piece in board.piece_map().items() if piece.color == color]\n        return sum(distances) / len(distances) if distances else 0\n    \n    white_avg_distance = average_distance(chess.WHITE)\n    black_avg_distance = average_distance(chess.BLACK)\n    return float(black_avg_distance - white_avg_distance)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of forks available for each side, considering multiple attacking pieces.\"\n    white_forks = len([move for move in board.legal_moves \n                       if len(board.attackers(chess.BLACK, move.to_square)) > 1])\n    black_forks = len([move for move in board.legal_moves \n                       if len(board.attackers(chess.WHITE, move.to_square)) > 1])\n    return float(white_forks - black_forks)\n\n",
    "def feature(board: chess.Board) -> float:\n    'Measures the pawn structure by counting isolated pawns to evaluate weakness.'\n    isolated_pawn_count = 0\n    for square in board.piece_map():\n        if board.piece_at(square).piece_type == chess.PAWN:\n            file = chess.square_file(square)\n            if (board.piece_at(chess.square(file - 1, chess.square_rank(square))) == None and\n                board.piece_at(chess.square(file + 1, chess.square_rank(square))) == None):\n                isolated_pawn_count += 1\n    return float(isolated_pawn_count) \n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the number of pieces that are pinned against the king.\"\n    pinned_pieces = sum(1 for square, piece in board.piece_map().items() if piece.color == board.turn and any(board.is_attacked_by(board.turn, square) for target in board.piece_map().values() if target.piece_type == chess.KING))\n    return float(pinned_pieces)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the total value of pieces in the opponent's half of the board for aggression evaluation.\"\n    white_value = 0\n    black_value = 0\n    \n    for square, piece in board.piece_map().items():\n        piece_value = {chess.PAWN: 1, chess.KNIGHT: 3, chess.BISHOP: 3, chess.ROOK: 5, chess.QUEEN: 9, chess.KING: 0}[piece.piece_type]\n        if piece.color == chess.WHITE and chess.square_rank(square) > 3:\n            white_value += piece_value\n        elif piece.color == chess.BLACK and chess.square_rank(square) < 4:\n            black_value += piece_value\n            \n    return float(white_value - black_value)\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of squares controlled by each color based on piece attacks.\"\n    white_control = sum(1 for square in chess.SQUARES if board.is_attacked_by(chess.WHITE, square))\n    black_control = sum(1 for square in chess.SQUARES if board.is_attacked_by(chess.BLACK, square))\n    return float(white_control - black_control)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the number of pawns that are advanced (rank 4 or higher) for each side.\"\n    white_advanced = sum(1 for square, piece in board.piece_map().items() if piece.color == chess.WHITE and piece.piece_type == chess.PAWN and chess.square_rank(square) >= 4)\n    black_advanced = sum(1 for square, piece in board.piece_map().items() if piece.color == chess.BLACK and piece.piece_type == chess.PAWN and chess.square_rank(square) <= 3)\n    return float(white_advanced - black_advanced)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the number of pieces controlling center squares for each side.\"\n    center_squares = [chess.E4, chess.E5, chess.D4, chess.D5]\n    white_control = sum(1 for square in center_squares if board.is_attacked_by(chess.WHITE, square))\n    black_control = sum(1 for square in center_squares if board.is_attacked_by(chess.BLACK, square))\n    return float(white_control - black_control)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures control of the center squares (d4, d5, e4, e5).\"\n    center_squares = [chess.D4, chess.D5, chess.E4, chess.E5]\n    white_control = sum(1 for square in center_squares if board.is_attacked_by(chess.WHITE, square))\n    black_control = sum(1 for square in center_squares if board.is_attacked_by(chess.BLACK, square))\n    return float(white_control - black_control)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the total number of attackers on the opponent's pieces.\"\n    attacker_count = sum(len(board.attackers(board.turn, square)) for square in board.piece_map() if board.piece_map()[square].color != board.turn)\n    return float(attacker_count)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the distance of the kings from the center of the board, assessing their mobility and safety.\"\n    king_square = next(square for square in board.piece_map() if board.piece_at(square).piece_type == chess.KING and board.piece_at(square).color == board.turn)\n    distance_from_center = chess.square_distance(king_square, chess.parse_square('e4')) + chess.square_distance(king_square, chess.parse_square('e5'))\n    return float(distance_from_center)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the difference in number of developed pieces for both players.\"\n    white_developed = sum(1 for square in board.piece_map() if board.piece_map()[square].color == chess.WHITE and chess.square_rank(square) > 1)\n    black_developed = sum(1 for square in board.piece_map() if board.piece_map()[square].color == chess.BLACK and chess.square_rank(square) < 6)\n    return float(white_developed - black_developed)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Evaluates the number of squares that are defended by multiple pieces.\"\n    defended_squares = sum(1 for square in range(64) if sum(1 for piece in board.piece_map().values() if board.is_attacked_by(piece.color, square)) > 1)\n    return float(defended_squares)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the total number of attacked pieces by the opponent.\"\n    attacked_pieces_count = 0\n    for square in board.piece_map():\n        if board.is_attacked_by(not board.turn, square):\n            attacked_pieces_count += 1\n    return float(attacked_pieces_count)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the overall material imbalance based on the pieces captured.\"\n    material_values = {\n        chess.PAWN: 1,\n        chess.KNIGHT: 3,\n        chess.BISHOP: 3,\n        chess.ROOK: 5,\n        chess.QUEEN: 9,\n        chess.KING: 0\n    }\n    white_material = sum(material_values[piece.piece_type] for piece in board.piece_map().values() if piece.color == chess.WHITE)\n    black_material = sum(material_values[piece.piece_type] for piece in board.piece_map().values() if piece.color == chess.BLACK)\n    return float(white_material - black_material)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the average distance of pieces from their opponent's king.\"\n    white_king_square = next(sq for sq in board.piece_map() if board.piece_map()[sq].color == chess.WHITE and board.piece_map()[sq].piece_type == chess.KING)\n    black_king_square = next(sq for sq in board.piece_map() if board.piece_map()[sq].color == chess.BLACK and board.piece_map()[sq].piece_type == chess.KING)\n    white_distance = sum(chess.square_distance(sq, black_king_square) for sq in board.piece_map() if board.piece_map()[sq].color == chess.WHITE)\n    black_distance = sum(chess.square_distance(sq, white_king_square) for sq in board.piece_map() if board.piece_map()[sq].color == chess.BLACK)\n    white_piece_count = len([sq for sq in board.piece_map() if board.piece_map()[sq].color == chess.WHITE])\n    black_piece_count = len([sq for sq in board.piece_map() if board.piece_map()[sq].color == chess.BLACK])\n    \n    return float((white_distance / (white_piece_count or 1)) - (black_distance / (black_piece_count or 1)))\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the ratio of pawns to the total pieces for both players.\"\n    total_pawns = len([p for p in board.piece_map().values() if p.piece_type == chess.PAWN])\n    total_pieces = len(board.piece_map())\n    return float(total_pawns / total_pieces) if total_pieces > 0 else 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the number of isolated pawns for both sides.\"\n    isolated_pawn_count = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == board.turn and piece.piece_type == chess.PAWN:\n            file = chess.square_file(square)\n            if not (board.piece_at(chess.square(file - 1, chess.square_rank(square))) and \n                    board.piece_at(chess.square(file + 1, chess.square_rank(square)))):\n                isolated_pawn_count += 1\n    return float(isolated_pawn_count)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the piece activity based on the number of legal moves for each side.\"\n    white_activity = len(list(board.legal_moves)) if board.turn == chess.WHITE else 0\n    black_activity = len(list(board.legal_moves)) if board.turn == chess.BLACK else 0\n    return float(white_activity - black_activity)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Evaluates control over the sixth and third ranks for both sides.\"\n    white_control = sum(1 for square in range(48, 56) if board.is_attacked_by(chess.WHITE, square))\n    black_control = sum(1 for square in range(8, 16) if board.is_attacked_by(chess.BLACK, square))\n    return float(white_control - black_control)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces attacking each king for both sides.\"\n    white_king_square = next(square for square in board.piece_map() if board.piece_map()[square].color == chess.WHITE and \n                              board.piece_map()[square].piece_type == chess.KING)\n    black_king_square = next(square for square in board.piece_map() if board.piece_map()[square].color == chess.BLACK and \n                              board.piece_map()[square].piece_type == chess.KING)\n    white_attackers = len(board.attackers(chess.BLACK, white_king_square))\n    black_attackers = len(board.attackers(chess.WHITE, black_king_square))\n    return float(white_attackers - black_attackers)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Assesses the king's safety by counting pieces within one square of the opponent's king.\"\n    opponent_king_square = next((square for square, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color != board.turn), None)\n    if opponent_king_square is None:\n        return 0.0\n    safe_zone = sum(1 for square in range(64) if chess.square_distance(square, opponent_king_square) <= 1 and board.piece_at(square) is not None)\n    return float(safe_zone)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the distance of pawns to the promotion rank for both colors, showing potential for advancement.\"\n    white_pawn_distances = [7 - chess.square_rank(square) for square, piece in board.piece_map().items() if piece.color == chess.WHITE and piece.piece_type == chess.PAWN]\n    black_pawn_distances = [chess.square_rank(square) for square, piece in board.piece_map().items() if piece.color == chess.BLACK and piece.piece_type == chess.PAWN]\n    avg_distance_white = sum(white_pawn_distances) / len(white_pawn_distances) if white_pawn_distances else 0\n    avg_distance_black = sum(black_pawn_distances) / len(black_pawn_distances) if black_pawn_distances else 0\n    return avg_distance_white - avg_distance_black\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces attacked by both sides.\"\n    attack_count = {chess.WHITE: 0, chess.BLACK: 0}\n    for square in board.piece_map():\n        piece = board.piece_at(square)\n        for attack_square in board.attackers(piece.color, square):\n            attack_count[piece.color] += 1\n    return float(attack_count[chess.WHITE] - attack_count[chess.BLACK])\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the number of pieces controlled by each side, including pawns, on critical central squares.\"\n    central_squares = [chess.E4, chess.E5, chess.D4, chess.D5]\n    white_control = sum(1 for square in central_squares if board.is_attacked_by(chess.WHITE, square))\n    black_control = sum(1 for square in central_squares if board.is_attacked_by(chess.BLACK, square))\n    return float(white_control - black_control)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces supporting each player's pawns.\"\n    white_support = 0.0\n    black_support = 0.0\n    for square in chess.SQUARES:\n        piece = board.piece_at(square)\n        if piece and piece.piece_type == chess.PAWN:\n            if piece.color == chess.WHITE:\n                white_support += len(list(board.attackers(chess.WHITE, square)))\n            else:\n                black_support += len(list(board.attackers(chess.BLACK, square)))\n    return white_support - black_support\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the presence of active vs inactive pieces (non-king) for each player.\"\n    def active_piece_score(color):\n        score = 0\n        for square, piece in board.piece_map().items():\n            if piece.color == color and piece.piece_type != chess.KING:\n                score += len(list(board.legal_moves))\n        return score\n    white_activity = active_piece_score(chess.WHITE)\n    black_activity = active_piece_score(chess.BLACK)\n    return float(white_activity - black_activity)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the number of pieces that are currently defended by other pieces.\"\n    defended_count = sum(1 for square, piece in board.piece_map().items() if piece.color == board.turn and len(board.attackers(piece.color, square)) > 0)\n    return float(defended_count)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the number of unprotected pieces each side has.\"\n    unprotected_white = sum(1 for square, piece in board.piece_map().items() if piece.color == chess.WHITE and all(not board.is_attacked_by(chess.BLACK, square) for square in board.attackers(chess.BLACK, square)))\n    unprotected_black = sum(1 for square, piece in board.piece_map().items() if piece.color == chess.BLACK and all(not board.is_attacked_by(chess.WHITE, square) for square in board.attackers(chess.WHITE, square)))\n    return float(unprotected_white - unprotected_black)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the threats posed by minor pieces to the opponent's major pieces.\"\n    threat_score = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == board.turn and piece.piece_type in {chess.KNIGHT, chess.BISHOP}:\n            for target in board.legal_moves:\n                if target.to_square in board.piece_map() and board.piece_map()[target.to_square].piece_type in {chess.QUEEN, chess.ROOK}:\n                    threat_score += 1\n    return float(threat_score)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the potential for pawn promotion based on pawn positions.\"\n    promotion_pawns = sum(1 for square, piece in board.piece_map().items() if piece.color == board.turn and piece.piece_type == chess.PAWN and (chess.square_rank(square) == (7 if piece.color == chess.WHITE else 0)))\n    return float(promotion_pawns)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the potential mobility difference by counting total legal moves available for each side.\"\n    white_moves = len(list(board.legal_moves)) if board.turn else 0\n    black_moves = len(list(board.legal_moves)) if not board.turn else 0\n    return float(white_moves - black_moves)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the total number of connected pieces of each side.\"\n    def count_connected_pieces(color):\n        connected_count = 0\n        visited = set()\n        for square in board.piece_map():\n            if board.piece_map()[square].color == color and square not in visited:\n                connected_count += 1\n                visited.add(square)\n                for offset in [-1, 1, -8, 8, -7, -9, 7, 9]:  # Check adjacent squares\n                    adjacent_square = square + offset\n                    if 0 <= adjacent_square < 64 and (adjacent_square in board.piece_map() and board.piece_map()[adjacent_square].color == color):\n                        visited.add(adjacent_square)\n        return connected_count\n\n    white_connected = count_connected_pieces(chess.WHITE)\n    black_connected = count_connected_pieces(chess.BLACK)\n    return float(white_connected - black_connected)\n\n",
    "def feature(board: chess.Board) -> float:\n    'Calculates the number of backward pawns for each color, indicating vulnerabilities.'\n    backward_pawns = 0\n    for sq, piece in board.piece_map().items():\n        if piece.piece_type == chess.PAWN:\n            if piece.color == chess.WHITE and (piece.color == chess.WHITE and \n                (board.piece_at(sq + 8) is None or\n                (board.piece_at(sq + 8) and chess.square_rank(sq + 8) < chess.square_rank(sq)))):\n                backward_pawns += 1\n            elif piece.color == chess.BLACK and (piece.color == chess.BLACK and \n                (board.piece_at(sq - 8) is None or\n                (board.piece_at(sq - 8) and chess.square_rank(sq - 8) > chess.square_rank(sq)))):\n                backward_pawns -= 1\n    return float(backward_pawns)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the distribution of pieces across the board, assessing how concentrated they are.\"\n    piece_distribution = {chess.WHITE: 0, chess.BLACK: 0}\n    for sq in range(64):\n        piece = board.piece_at(sq)\n        if piece:\n            piece_distribution[piece.color] += 1 / (1 + chess.square_distance(sq, chess.parse_square('e4')))\n    return float(piece_distribution[chess.WHITE] - piece_distribution[chess.BLACK])\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the average distance of pieces from the center of the board for each side.\"\n    def average_piece_distance(color):\n        total_distance = 0\n        piece_count = 0\n        for square in board.piece_map():\n            piece = board.piece_map()[square]\n            if piece.color == color:\n                total_distance += chess.square_distance(square, chess.square(4, 4))\n                piece_count += 1\n        return total_distance / piece_count if piece_count > 0 else 0\n\n    white_avg_distance = average_piece_distance(chess.WHITE)\n    black_avg_distance = average_piece_distance(chess.BLACK)\n    return float(white_avg_distance - black_avg_distance)\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the piece activity of rooks on open files for both sides.\"\n    def rook_activity(color):\n        activity = 0\n        for square, piece in board.piece_map().items():\n            if piece.color == color and piece.piece_type == chess.ROOK:\n                if all(board.piece_at(sq) is None for sq in range(8) if chess.square_file(sq) == chess.square_file(square)):\n                    activity += 1\n        return activity\n    \n    white_activity = rook_activity(chess.WHITE)\n    black_activity = rook_activity(chess.BLACK)\n    return float(white_activity - black_activity)\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the number of unopposed pieces by color within the opponent's zone.\"\n    def unopposed_count(color):\n        count = 0\n        for square in chess.SQUARES_180:\n            if board.piece_at(square) and board.piece_at(square).color == color and not any(board.is_attacked_by(not color, square) for attacked_square in board.attackers(not color, square)):\n                count += 1\n        return count\n    \n    white_unopposed = unopposed_count(chess.WHITE)\n    black_unopposed = unopposed_count(chess.BLACK)\n    return float(white_unopposed - black_unopposed)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the total number of minor pieces (knights and bishops) for each player.\"\n    def count_minor_pieces(color):\n        return sum(1 for piece in board.piece_map().values() if piece.color == color and piece.piece_type in {chess.KNIGHT, chess.BISHOP})\n\n    white_minors = count_minor_pieces(chess.WHITE)\n    black_minors = count_minor_pieces(chess.BLACK)\n    return float(white_minors - black_minors)\n",
    "def feature(board: chess.Board) -> float:\n    \"Scores the number of threats to the opponent's pieces relative to the number of defended pieces.\"\n    threats = sum(1 for square in board.piece_map() if board.is_attacked_by(chess.WHITE, square) and board.piece_map()[square].color == chess.BLACK)\n    defenses = sum(1 for square in board.piece_map() if board.is_attacked_by(chess.BLACK, square) and board.piece_map()[square].color == chess.WHITE)\n    return float(threats - defenses)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures material balance, excluding pawns, in relation to the total number of pieces.\"\n    material_values = {\n        chess.KNIGHT: 3,\n        chess.BISHOP: 3,\n        chess.ROOK: 5,\n        chess.QUEEN: 9\n    }\n    def calculate_material(color):\n        return sum(material_values.get(piece.piece_type, 0) for piece in board.piece_map().values() if piece.color == color)\n\n    white_material = calculate_material(chess.WHITE)\n    black_material = calculate_material(chess.BLACK)\n    total_pieces = sum(1 for piece in board.piece_map().values())\n    \n    return float((white_material / (total_pieces if total_pieces else 1)) - (black_material / (total_pieces if total_pieces else 1)))\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of pinned pieces for each color.\"\n    def count_pinned_pieces(color):\n        pinned = 0\n        for square, piece in board.piece_map().items():\n            if piece.color == color:\n                if board.attackers(not color, square):\n                    pinned += 1\n        return pinned\n    white_pinned = count_pinned_pieces(chess.WHITE)\n    black_pinned = count_pinned_pieces(chess.BLACK)\n    return float(white_pinned - black_pinned)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the number of piece pairs (connected pieces) each side has.\"\n    connected_pairs = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == board.turn:\n            for move in board.legal_moves:\n                if move.from_square == square and board.piece_at(move.to_square) is not None:\n                    connected_pairs += 1\n    return float(connected_pairs)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces positioned on central squares.\"\n    central_squares = [chess.E4, chess.E5, chess.D4, chess.D5]\n    central_control = sum(1 for square in central_squares if board.piece_at(square) and board.piece_at(square).color == chess.WHITE) - \\\n                     sum(1 for square in central_squares if board.piece_at(square) and board.piece_at(square).color == chess.BLACK)\n    return float(central_control)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Evaluates the vulnerability of the king based on nearby attacks.\"\n    white_king_square = next(square for square, piece in board.piece_map().items() if piece.color == chess.WHITE and piece.piece_type == chess.KING)\n    black_king_square = next(square for square, piece in board.piece_map().items() if piece.color == chess.BLACK and piece.piece_type == chess.KING)\n    white_king_vulnerability = sum(1 for square in chess.SQUARES if board.is_attacked_by(chess.BLACK, square) and chess.square_distance(white_king_square, square) <= 1)\n    black_king_vulnerability = sum(1 for square in chess.SQUARES if board.is_attacked_by(chess.WHITE, square) and chess.square_distance(black_king_square, square) <= 1)\n    return float(white_king_vulnerability - black_king_vulnerability)\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the overall piece activity by counting active pieces (not blocked by pawns).\"\n    active_white = sum(1 for square in board.piece_map() if board.piece_map()[square].color == chess.WHITE and chess.square_rank(square) < 6)\n    active_black = sum(1 for square in board.piece_map() if board.piece_map()[square].color == chess.BLACK and chess.square_rank(square) > 1)\n    return float(active_white - active_black)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the number of unprotected pieces for each side.\"\n    unprotected_pieces = {chess.WHITE: 0, chess.BLACK: 0}\n    for square, piece in board.piece_map().items():\n        if piece.color == chess.WHITE:\n            if not any(board.is_attacked_by(chess.BLACK, target_square) for target_square in board.attackers(piece.color, square)):\n                unprotected_pieces[chess.WHITE] += 1\n        else:\n            if not any(board.is_attacked_by(chess.WHITE, target_square) for target_square in board.attackers(piece.color, square)):\n                unprotected_pieces[chess.BLACK] += 1\n    return float(unprotected_pieces[chess.WHITE] - unprotected_pieces[chess.BLACK])\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the imbalance in rooks' activity based on their control of open files.\"\n    white_rook_control = sum(1 for square in board.piece_map() if board.piece_map()[square].color == chess.WHITE and \n                              (chess.square_file(square) == 0 or chess.square_file(square) == 7))\n    black_rook_control = sum(1 for square in board.piece_map() if board.piece_map()[square].color == chess.BLACK and \n                              (chess.square_file(square) == 0 or chess.square_file(square) == 7))\n    return float(white_rook_control - black_rook_control)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Evaluates the difference in rooks and queens for both sides.\"\n    material_values = {\n        chess.ROOK: 5,\n        chess.QUEEN: 9\n    }\n    white_material = sum(material_values.get(piece.piece_type, 0) for piece in board.piece_map().values() if piece.color == chess.WHITE)\n    black_material = sum(material_values.get(piece.piece_type, 0) for piece in board.piece_map().values() if piece.color == chess.BLACK)\n    return float(white_material - black_material)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the total piece count disadvantage for each side.\"\n    white_piece_count = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE)\n    black_piece_count = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK)\n    return float(black_piece_count - white_piece_count)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of potential discovered checks for both colors.\"\n    discovered_checks = 0\n    \n    for square in board.piece_map():\n        if board.piece_at(square).color == board.turn:\n            for move in board.legal_moves:\n                if board.is_check() or board.is_checkmate():\n                    continue\n                temp_board = board.copy()\n                temp_board.push(move)\n                if temp_board.is_check() and board.piece_at(square).piece_type in (chess.ROOK, chess.QUEEN, chess.BISHOP):\n                    discovered_checks += 1\n    \n    return float(discovered_checks)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces defending each player's king, adding layers of safety.\"\n    white_king_square = next((sq for sq, piece in board.piece_map().items() if piece.color == chess.WHITE and piece.piece_type == chess.KING), None)\n    black_king_square = next((sq for sq, piece in board.piece_map().items() if piece.color == chess.BLACK and piece.piece_type == chess.KING), None)\n\n    white_defenders = sum(1 for sq, piece in board.piece_map().items() if piece.color == chess.WHITE and sq != white_king_square and piece.piece_type != chess.KING and board.is_attacked_by(chess.BLACK, white_king_square))\n    black_defenders = sum(1 for sq, piece in board.piece_map().items() if piece.color == chess.BLACK and sq != black_king_square and piece.piece_type != chess.KING and board.is_attacked_by(chess.WHITE, black_king_square))\n\n    return float(white_defenders - black_defenders)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the number of potential discoveries (pieces that can move away to reveal an attack).\"\n    discovery_count = 0\n    for square in board.piece_map():\n        piece = board.piece_at(square)\n        if piece.color == board.turn:\n            for move in board.legal_moves:\n                if move.from_square == square:\n                    board.push(move)\n                    # Check if after move there is an attack\n                    if board.is_attacked_by(not board.turn, move.to_square):\n                        discovery_count += 1\n                    board.pop()\n    return float(discovery_count)\n\n",
    "def feature(board: chess.Board) -> float:\n    'Measures the number of pieces safely positioned away from threats.'\n    safe_pieces = 0\n    for square, piece in board.piece_map().items():\n        if all(not board.is_attacked_by(not piece.color, square) for square in board.attackers(piece.color, square)):\n            safe_pieces += 1\n    return float(safe_pieces)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the difference in pawn structure between both sides.\"\n    def pawn_structure_score(color):\n        score = 0\n        for file in range(8):\n            if board.piece_at(chess.square(file, 1 if color == chess.BLACK else 6)) and board.piece_at(chess.square(file, 1 if color == chess.BLACK else 6)).piece_type == chess.PAWN:\n                score += 1\n        return score\n\n    white_structure_score = pawn_structure_score(chess.WHITE)\n    black_structure_score = pawn_structure_score(chess.BLACK)\n    return float(white_structure_score - black_structure_score)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the pressure on the opponent's pieces (attacks and potential captures).\"\n    def piece_pressure(color):\n        pressure = 0\n        for square, piece in board.piece_map().items():\n            if piece.color == color:\n                for target in board.legal_moves:\n                    if target.to_square == square:\n                        pressure += 1\n        return pressure\n\n    return float(piece_pressure(chess.WHITE) - piece_pressure(chess.BLACK))\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the distance of each player's pieces from their opponent's back rank, indicating pressure on the opponent.\"\n    white_distance = sum(7 - chess.square_rank(sq) for sq, piece in board.piece_map().items() if piece.color == chess.WHITE)\n    black_distance = sum(chess.square_rank(sq) for sq, piece in board.piece_map().items() if piece.color == chess.BLACK)\n    return float(white_distance - black_distance)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of pawn structures that are isolated from other pawns.\"\n    isolated_pawn_count = 0\n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.PAWN:\n            file = chess.square_file(square)\n            if (file > 0 and board.piece_at(chess.square(file - 1, chess.square_rank(square))) and\n                board.piece_at(chess.square(file + 1, chess.square_rank(square)))):\n                continue\n            isolated_pawn_count += 1\n    return float(isolated_pawn_count)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the total piece value difference between both sides excluding pawns.\"\n    piece_values = {chess.KNIGHT: 3, chess.BISHOP: 3, chess.ROOK: 5, chess.QUEEN: 9}\n    white_value = sum(piece_values.get(piece.piece_type, 0) for piece in board.piece_map().values() if piece.color == chess.WHITE)\n    black_value = sum(piece_values.get(piece.piece_type, 0) for piece in board.piece_map().values() if piece.color == chess.BLACK)\n    return float(white_value - black_value)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the presence of pieces that can create threats to the opponent's king.\"\n    threat_multiplier = {chess.QUEEN: 9, chess.ROOK: 5, chess.KNIGHT: 3, chess.BISHOP: 3}\n    threats = sum(threat_multiplier[piece.piece_type] for square, piece in board.piece_map().items() \n                   if piece.color == board.turn and piece.piece_type in threat_multiplier)\n    return float(threats)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the number of squares attacked by the current player's pieces.\"\n    attacker_count = sum(len(board.attackers(board.turn, square)) for square in board.piece_map() if board.piece_map()[square].color == board.turn)\n    return float(attacker_count)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the number of doubled pawns for each side, as a disadvantage.\"\n    def count_doubled_pawns(color):\n        pawn_files = [0] * 8\n        for square, piece in board.piece_map().items():\n            if piece.color == color and piece.piece_type == chess.PAWN:\n                pawn_files[chess.square_file(square)] += 1\n        return sum(1 for count in pawn_files if count > 1)\n    \n    white_doubled = count_doubled_pawns(chess.WHITE)\n    black_doubled = count_doubled_pawns(chess.BLACK)\n    return float(black_doubled - white_doubled)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the distance of the kings from the center of the board, indicating safety and mobility.\"\n    white_king_square = next(square for square, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color == chess.WHITE)\n    black_king_square = next(square for square, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color == chess.BLACK)\n    white_distance = chess.square_distance(white_king_square, chess.E4)  # Center square\n    black_distance = chess.square_distance(black_king_square, chess.E4)\n    result = black_distance - white_distance  # Positive if White's king is closer\n    return float(result)\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the value of pieces that have potential to promote.\"\n    promotion_squares = [chess.A7, chess.B7, chess.C7, chess.D7, chess.E7, chess.F7, chess.G7, chess.H7]\n    white_promoting = sum(1 for square in promotion_squares if board.piece_at(square) and board.piece_at(square).color == chess.WHITE)\n    black_promoting = sum(1 for square in promotion_squares if board.piece_at(square) and board.piece_at(square).color == chess.BLACK)\n    return float(white_promoting - black_promoting)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the efficiency of piece placements near the opponent's king.\"\n    efficiency = sum(1 for square in board.piece_map() if board.piece_map()[square].color == board.turn and board.is_attacked_by(not board.turn, square))\n    return float(efficiency)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the number of pieces attacked and defended for each side to assess position strength.\"\n    piece_map = board.piece_map()\n    white_attacked = sum(1 for square, piece in piece_map.items() if piece.color == chess.WHITE and board.is_attacked_by(chess.BLACK, square))\n    white_defended = sum(1 for square, piece in piece_map.items() if piece.color == chess.WHITE and len(list(board.attackers(chess.WHITE, square))) > 0)\n    \n    black_attacked = sum(1 for square, piece in piece_map.items() if piece.color == chess.BLACK and board.is_attacked_by(chess.WHITE, square))\n    black_defended = sum(1 for square, piece in piece_map.items() if piece.color == chess.BLACK and len(list(board.attackers(chess.BLACK, square))) > 0)\n\n    return float((white_defended - white_attacked) - (black_defended - black_attacked))\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the total number of pieces attacking the opposing king.\"\n    white_attackers = sum(1 for square in board.piece_map() if board.piece_map()[square].color == chess.WHITE and board.is_attacked_by(chess.BLACK, square))\n    black_attackers = sum(1 for square in board.piece_map() if board.piece_map()[square].color == chess.BLACK and board.is_attacked_by(chess.WHITE, square))\n    return float(white_attackers - black_attackers)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the total number of pawns on the board to assess pawn structure.\"\n    pawn_count = sum(1 for piece in board.piece_map().values() if piece.piece_type == chess.PAWN)\n    return float(pawn_count)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in pawn structure, checking for doubled, isolated, or backward pawns.\"\n    white_pawns = [square for square in board.piece_map() if board.piece_map()[square].color == chess.WHITE and board.piece_map()[square].piece_type == chess.PAWN]\n    black_pawns = [square for square in board.piece_map() if board.piece_map()[square].color == chess.BLACK and board.piece_map()[square].piece_type == chess.PAWN]\n    white_structure = sum(1 for sq in white_pawns if (chess.square_file(sq), chess.square_rank(sq)) in [(file, rank) for file in range(8) for rank in range(8) if rank < 7])  # Example counting logic for structure\n    black_structure = sum(1 for sq in black_pawns if (chess.square_file(sq), chess.square_rank(sq)) in [(file, rank) for file in range(8) for rank in range(8) if rank > 0])  \n    return float(white_structure - black_structure)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Evaluates the king's safety based on the number of pieces surrounding it.\"\n    def king_safety(color):\n        king_square = next(square for square in board.piece_map() if board.piece_map()[square].color == color and board.piece_map()[square].piece_type == chess.KING)\n        surrounding_pieces = sum(1 for square in range(64) if chess.square_distance(king_square, square) == 1 and board.piece_at(square) and board.piece_at(square).color == color)\n        return surrounding_pieces\n\n    white_safety = king_safety(chess.WHITE)\n    black_safety = king_safety(chess.BLACK)\n    return float(white_safety - black_safety)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the distance of pawns to their promotion rank for both players.\"\n    white_pawn_distance = sum(7 - chess.square_rank(sq) for sq in board.piece_map() if board.piece_map()[sq].piece_type == chess.PAWN and board.piece_map()[sq].color == chess.WHITE)\n    black_pawn_distance = sum(chess.square_rank(sq) for sq in board.piece_map() if board.piece_map()[sq].piece_type == chess.PAWN and board.piece_map()[sq].color == chess.BLACK)\n    return float(white_pawn_distance - black_pawn_distance)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the number of pieces each player has in the opponent's half of the board.\"\n    white_pieces_in_enemy_half = sum(1 for square, piece in board.piece_map().items() if piece.color == chess.WHITE and chess.square_rank(square) > 3)\n    black_pieces_in_enemy_half = sum(1 for square, piece in board.piece_map().items() if piece.color == chess.BLACK and chess.square_rank(square) < 4)\n    result = white_pieces_in_enemy_half - black_pieces_in_enemy_half\n    return float(result)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the number of pieces controlled by each player, weighted by their distance to the opponent's back rank.\"\n    control_weight = 0\n    piece_count = 0\n    \n    for square, piece in board.piece_map().items():\n        if piece.color == chess.WHITE:\n            control_weight += 1 / (chess.square_rank(square) + 1)  # Closer to back rank gives higher weight\n        elif piece.color == chess.BLACK:\n            control_weight -= 1 / (8 - chess.square_rank(square))  # Closer to back rank gives lower weight\n        piece_count += 1\n    \n    result = control_weight / piece_count if piece_count > 0 else 0.0\n    return result\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Evaluates the king safety by counting squares around the king that are attacked.\"\n    king_square = next((square for square, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color == board.turn), None)\n    if king_square is None:\n        return 0.0\n    unsafe_squares = sum(1 for square in chess.SQUARES if board.is_attacked_by(not board.turn, square) and chess.square_distance(square, king_square) <= 1)\n    return float(unsafe_squares)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the total number of legal captures available in the current position.\"\n    captures_white = sum(1 for move in board.legal_moves if board.piece_at(move.to_square) and board.piece_at(move.to_square).color == chess.BLACK)\n    captures_black = sum(1 for move in board.legal_moves if board.piece_at(move.to_square) and board.piece_at(move.to_square).color == chess.WHITE)\n    return float(captures_white - captures_black)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the average piece value of the remaining pieces for both colors.\"\n    piece_values = {\n        chess.PAWN: 1,\n        chess.KNIGHT: 3,\n        chess.BISHOP: 3,\n        chess.ROOK: 5,\n        chess.QUEEN: 9,\n        chess.KING: 0\n    }\n    white_value = sum(piece_values[piece.piece_type] for piece in board.piece_map().values() if piece.color == chess.WHITE)\n    black_value = sum(piece_values[piece.piece_type] for piece in board.piece_map().values() if piece.color == chess.BLACK)\n    total_value = white_value + black_value\n    return float(white_value - black_value) / (total_value + 1)  # Avoid division by zero\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the average rank of pieces for both sides.\"\n    white_squares = [sq for sq, piece in board.piece_map().items() if piece.color == chess.WHITE]\n    black_squares = [sq for sq, piece in board.piece_map().items() if piece.color == chess.BLACK]\n    white_avg_rank = sum(chess.square_rank(sq) for sq in white_squares) / (len(white_squares) or 1)\n    black_avg_rank = sum(chess.square_rank(sq) for sq in black_squares) / (len(black_squares) or 1)\n    return float(white_avg_rank - black_avg_rank)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the pawn structure by counting isolated pawns.\"\n    def is_isolated(square, color):\n        file = chess.square_file(square)\n        return (not board.piece_at(chess.parse_square(chess.square_name(square)[0] + str(i))) and \n                not board.piece_at(chess.parse_square(chess.square_name(square)[1] + str(i))) \n                for i in range(1, 9) if chess.square_rank(square) == i)\n\n    white_isolated = sum(1 for square in board.piece_map() if board.piece_map()[square].color == chess.WHITE and board.piece_map()[square].piece_type == chess.PAWN and is_isolated(square, chess.WHITE))\n    black_isolated = sum(1 for square in board.piece_map() if board.piece_map()[square].color == chess.BLACK and board.piece_map()[square].piece_type == chess.PAWN and is_isolated(square, chess.BLACK))\n    return float(white_isolated - black_isolated)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the total number of direct threats (pieces that can capture without being captured) for each side.\"\n    white_threats = sum(1 for move in board.legal_moves if board.piece_at(move.to_square) is None or (board.piece_at(move.to_square).color != chess.WHITE and board.is_attacked_by(chess.WHITE, move.to_square)))\n    black_threats = sum(1 for move in board.legal_moves if board.piece_at(move.to_square) is None or (board.piece_at(move.to_square).color != chess.BLACK and board.is_attacked_by(chess.BLACK, move.to_square)))\n    return float(white_threats - black_threats)\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the total value of captured pieces (from the perspective of the current player).\"\n    piece_values = {chess.PAWN: 1, chess.KNIGHT: 3, chess.BISHOP: 3, chess.ROOK: 5, chess.QUEEN: 9, chess.KING: 0}\n    captured_value = 0\n    for square in range(64):\n        piece = board.piece_at(square)\n        if piece and piece.color != board.turn:\n            captured_value += piece_values[piece.piece_type]\n    return float(captured_value)\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of double attacks available for the player to move.\"\n    double_attacks = 0\n    for square in board.piece_map():\n        piece = board.piece_at(square)\n        if piece.color == board.turn:\n            attackers_count = len(board.attackers(piece.color, square))\n            if attackers_count > 1:  # For double attacks\n                double_attacks += 1\n    return float(double_attacks)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces that have control over central squares (d4, d5, e4, e5).\"\n    central_squares = [chess.parse_square('d4'), chess.parse_square('d5'), chess.parse_square('e4'), chess.parse_square('e5')]\n    control_count = sum(1 for square in central_squares if board.is_attacked_by(chess.WHITE, square) or board.is_attacked_by(chess.BLACK, square))\n    return float(control_count)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in the number of squares occupied by strong pieces (Q, R) vs weak pieces (P, N).\"\n    strong_count = 0\n    weak_count = 0\n    for piece in board.piece_map().values():\n        if piece.color == board.turn:\n            if piece.piece_type in (chess.QUEEN, chess.ROOK):\n                strong_count += 1\n            elif piece.piece_type in (chess.PAWN, chess.KNIGHT):\n                weak_count += 1\n    return float(strong_count - weak_count)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Evaluates the number of threats, counting pieces attacking opponent's major pieces.\"\n    major_piece_threats = sum(1 for square in board.piece_map() if board.piece_map()[square].piece_type in [chess.QUEEN, chess.ROOK] and board.is_attacked_by(not board.turn, square))\n    return float(major_piece_threats)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in the number of protected pawns for each side.\"\n    white_protected_pawns = sum(1 for square in board.piece_map() if board.piece_map()[square].color == chess.WHITE and \n                                 board.piece_map()[square].piece_type == chess.PAWN and \n                                 any(board.is_attacked_by(chess.BLACK, attack_square) for attack_square in board.attackers(chess.WHITE, square)))\n    black_protected_pawns = sum(1 for square in board.piece_map() if board.piece_map()[square].color == chess.BLACK and \n                                 board.piece_map()[square].piece_type == chess.PAWN and \n                                 any(board.is_attacked_by(chess.WHITE, attack_square) for attack_square in board.attackers(chess.BLACK, square)))\n    return float(white_protected_pawns - black_protected_pawns)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the total number of pawns each player has advanced past the fourth rank.\"\n    white_advanced_pawns = sum(1 for square in board.piece_map() if board.piece_map()[square].color == chess.WHITE and chess.square_rank(square) > 3 and board.piece_map()[square].piece_type == chess.PAWN)\n    black_advanced_pawns = sum(1 for square in board.piece_map() if board.piece_map()[square].color == chess.BLACK and chess.square_rank(square) < 4 and board.piece_map()[square].piece_type == chess.PAWN)\n    return float(white_advanced_pawns - black_advanced_pawns)\n\n",
    "def feature(board: chess.Board) -> float:\n    'Assesses the knight mobility for both sides, counting possible knight moves.'\n    white_knight_moves = sum(len(list(board.legal_moves)) for square in chess.SQUARES \n                              if board.piece_at(square) is not None and board.piece_at(square).piece_type == chess.KNIGHT \n                              and board.piece_at(square).color == chess.WHITE)\n    black_knight_moves = sum(len(list(board.legal_moves)) for square in chess.SQUARES \n                              if board.piece_at(square) is not None and board.piece_at(square).piece_type == chess.KNIGHT \n                              and board.piece_at(square).color == chess.BLACK)\n    result = float(white_knight_moves - black_knight_moves)\n    return result\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the control of center squares (d4, e4 for White; d5, e5 for Black).\"\n    def center_control(color):\n        center_squares = [chess.D4, chess.E4] if color == chess.WHITE else [chess.D5, chess.E5]\n        control_count = sum(1 for square in center_squares if board.is_attacked_by(color, square))\n        return control_count\n\n    white_control = center_control(chess.WHITE)\n    black_control = center_control(chess.BLACK)\n    return float(white_control - black_control)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the mobility of pieces based on the number of legal moves available.\"\n    white_mobility = sum(1 for move in board.legal_moves if board.piece_map()[move.from_square].color == chess.WHITE)\n    black_mobility = sum(1 for move in board.legal_moves if board.piece_map()[move.from_square].color == chess.BLACK)\n    return float(white_mobility - black_mobility)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Evaluates the presence of control over the center squares (d4, d5, e4, e5).\"\n    center_squares = [chess.D4, chess.D5, chess.E4, chess.E5]\n    white_center_control = sum(1 for square in center_squares if board.is_attacked_by(chess.WHITE, square))\n    black_center_control = sum(1 for square in center_squares if board.is_attacked_by(chess.BLACK, square))\n    return float(white_center_control - black_center_control)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of doubled pawns for each side.\"\n    pawn_positions = {chess.WHITE: set(), chess.BLACK: set()}\n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.PAWN:\n            pawn_positions[piece.color].add(chess.square_file(square))\n    double_pawns = {color: len(pawns) - len(set(pawns)) for color, pawns in pawn_positions.items()}\n    return float(double_pawns[chess.WHITE] - double_pawns[chess.BLACK])\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the control of central squares (d4, d5, e4, e5) by each side.\"\n    central_squares = [chess.D4, chess.E4, chess.D5, chess.E5]\n    white_control = sum(1 for square in central_squares if board.is_attacked_by(chess.WHITE, square))\n    black_control = sum(1 for square in central_squares if board.is_attacked_by(chess.BLACK, square))\n    return float(white_control - black_control)\n\n",
    "def feature(board: chess.Board) -> float:\n    'Measures the number of squares controlled by each player based on piece influence.'\n    controlled_white = len(set(move.to_square for move in board.legal_moves if board.piece_at(move.from_square).color == chess.WHITE))\n    controlled_black = len(set(move.to_square for move in board.legal_moves if board.piece_at(move.from_square).color == chess.BLACK))\n    return float(controlled_white - controlled_black)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the clustering of pieces in relation to each color's respective half of the board.\"\n    white_cluster_radius = sum(chess.square_file(square) < 4 for square in board.piece_map() if board.piece_map()[square].color == chess.WHITE)\n    black_cluster_radius = sum(chess.square_file(square) > 3 for square in board.piece_map() if board.piece_map()[square].color == chess.BLACK)\n    return float(white_cluster_radius - black_cluster_radius)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of connected pawns for each side to assess pawn structure.\"\n    def count_connected_pawns(color):\n        connected_count = 0\n        pawns = [square for square, piece in board.piece_map().items() if piece.color == color and piece.piece_type == chess.PAWN]\n        for pawn in pawns:\n            if (board.piece_at(pawn - 1) and board.piece_at(pawn - 1).color == color) or (board.piece_at(pawn + 1) and board.piece_at(pawn + 1).color == color):\n                connected_count += 1\n        return connected_count\n    \n    connected_white = count_connected_pawns(chess.WHITE)\n    connected_black = count_connected_pawns(chess.BLACK)\n    return float(connected_white - connected_black)\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the number of open files for both sides.\"\n    def count_open_files(color):\n        open_files = 0\n        for file in range(8):\n            if all(board.piece_at(chess.square(file, rank)) is None for rank in range(8) if (color == chess.WHITE and rank > 0) or (color == chess.BLACK and rank < 7)):\n                open_files += 1\n        return open_files\n\n    white_open_files = count_open_files(chess.WHITE)\n    black_open_files = count_open_files(chess.BLACK)\n    return float(white_open_files - black_open_files)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the difference in the number of pieces threatening the opponent's king.\"\n    white_threats = sum(1 for square in board.attackers(chess.WHITE, chess.parse_square('e8')) if board.piece_at(square) is not None and board.piece_at(square).color == chess.WHITE)\n    black_threats = sum(1 for square in board.attackers(chess.BLACK, chess.parse_square('e1')) if board.piece_at(square) is not None and board.piece_at(square).color == chess.BLACK)\n    return float(white_threats - black_threats)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the potential pawn structures by counting connected pawns.\"\n    connected_pawn_count = 0\n    for square in board.piece_map():\n        piece = board.piece_map()[square]\n        if piece.piece_type == chess.PAWN:\n            if board.piece_at(square + 1) and board.piece_at(square + 1).piece_type == chess.PAWN and board.piece_at(square + 1).color == piece.color:\n                connected_pawn_count += 1\n            if board.piece_at(square - 1) and board.piece_at(square - 1).piece_type == chess.PAWN and board.piece_at(square - 1).color == piece.color:\n                connected_pawn_count += 1\n    return float(connected_pawn_count)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the mobility of pieces by counting how many squares each piece can legally move to.\"\n    mobility = sum(len(list(board.legal_moves)) for square in board.piece_map() if board.piece_at(square).color == board.turn)\n    return float(mobility)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the difference in the number of squares available in the opponent's territory.\"\n    def available_squares(color):\n        count = 0\n        start_rank = 0 if color == chess.WHITE else 5\n        end_rank = 3 if color == chess.WHITE else 8\n        for square in range(start_rank * 8, end_rank * 8):\n            if board.is_attacked_by(color, square):\n                count += 1\n        return count\n\n    white_available = available_squares(chess.WHITE)\n    black_available = available_squares(chess.BLACK)\n    return float(white_available - black_available)\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces that can move to an unprotected square on the next turn.\"\n    unprotected_squares = [square for square in chess.SQUARES if not board.is_attacked_by(chess.WHITE, square) and not board.is_attacked_by(chess.BLACK, square)]\n    movable_pieces = sum(1 for move in board.legal_moves if move.to_square in unprotected_squares)\n    return float(movable_pieces)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the number of pieces in the endgame versus the total number of pieces.\"\n    total_pieces = len(board.piece_map())\n    endgame_pieces = sum(1 for piece in board.piece_map().values() if piece.piece_type in {chess.KING, chess.PAWN})\n    return float(endgame_pieces) / total_pieces if total_pieces > 0 else 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the overall piece count for both players.\"\n    white_piece_count = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE)\n    black_piece_count = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK)\n    return float(white_piece_count - black_piece_count)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in number of pieces attacking critical squares (central and back rank).\"\n    critical_squares = [chess.D4, chess.E4, chess.D5, chess.E5, chess.D1, chess.E1, chess.D8, chess.E8]\n    white_attacks = sum(board.is_attacked_by(chess.WHITE, square) for square in critical_squares)\n    black_attacks = sum(board.is_attacked_by(chess.BLACK, square) for square in critical_squares)\n    return float(white_attacks - black_attacks)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces that can move to a square attacking the enemy king.\"\n    white_attack_moves = sum(1 for move in board.legal_moves if board.piece_at(move.to_square) and \n                              board.is_attacked_by(chess.BLACK, move.to_square) and \n                              board.piece_at(move.to_square).color == chess.WHITE)\n    black_attack_moves = sum(1 for move in board.legal_moves if board.piece_at(move.to_square) and \n                              board.is_attacked_by(chess.WHITE, move.to_square) and \n                              board.piece_at(move.to_square).color == chess.BLACK)\n    return float(white_attack_moves - black_attack_moves)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts how many pieces are within two squares of the opponent's king.\"\n    opponent_king_square = board.king(not board.turn)\n    close_pieces_count = 0\n    for square in board.piece_map():\n        piece = board.piece_at(square)\n        if piece and piece.color == board.turn and chess.square_distance(square, opponent_king_square) <= 2:\n            close_pieces_count += 1\n    return float(close_pieces_count)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the mobility of the king by counting the number of legal moves available to it.\"\n    king_square = board.king(chess.WHITE) if board.turn else board.king(chess.BLACK)\n    legal_king_moves = sum(1 for move in board.legal_moves if move.from_square == king_square)\n    return float(legal_king_moves)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces attacking the opponent's king.\"\n    white_king_square = next(square for square, piece in board.piece_map().items() if piece.color == chess.WHITE and piece.piece_type == chess.KING)\n    black_king_square = next(square for square, piece in board.piece_map().items() if piece.color == chess.BLACK and piece.piece_type == chess.KING)\n    white_attackers = len(board.attackers(chess.WHITE, black_king_square))\n    black_attackers = len(board.attackers(chess.BLACK, white_king_square))\n    return float(white_attackers - black_attackers)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the number of available captures for each player in the current position.\"\n    white_captures = sum(1 for move in board.legal_moves if move.to_square in board.piece_map() and board.piece_map()[move.to_square].color == chess.BLACK)\n    black_captures = sum(1 for move in board.legal_moves if move.to_square in board.piece_map() and board.piece_map()[move.to_square].color == chess.WHITE)\n    return float(white_captures - black_captures)\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in piece activity based on unsupported pieces.\"\n    white_activity = sum(1 for square, piece in board.piece_map().items() \n                         if piece.color == chess.WHITE and not any(board.is_attacked_by(chess.BLACK, attacker) for attacker in board.attackers(chess.BLACK, square)))\n    black_activity = sum(1 for square, piece in board.piece_map().items() \n                         if piece.color == chess.BLACK and not any(board.is_attacked_by(chess.WHITE, attacker) for attacker in board.attackers(chess.WHITE, square)))\n    result = float(white_activity - black_activity)\n    return result\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the presence of double pawns for both sides.\"\n    white_double_pawns = sum(1 for square in board.piece_map() if board.piece_map()[square].color == chess.WHITE and board.piece_map()[square].piece_type == chess.PAWN and len([s for s in range(8) if board.piece_at(s) and board.piece_at(s).color == chess.WHITE and chess.square_file(square) == chess.square_file(s)]) > 1)\n    black_double_pawns = sum(1 for square in board.piece_map() if board.piece_map()[square].color == chess.BLACK and board.piece_map()[square].piece_type == chess.PAWN and len([s for s in range(8) if board.piece_at(s) and board.piece_at(s).color == chess.BLACK and chess.square_file(square) == chess.square_file(s)]) > 1)\n    return float(white_double_pawns - black_double_pawns)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Evaluates the level of king safety based on available escape squares.\"\n    escape_squares = 0\n    king_square = [square for square, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color == board.turn]\n    if not king_square:\n        return float(-1)\n    for move in board.legal_moves:\n        if move.to_square in board.attackers(not board.turn, king_square[0]):\n            escape_squares -= 1\n        else:\n            escape_squares += 1\n    return float(escape_squares)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of times each player's pieces attack each other's pieces.\"\n    def attacking_moves(color):\n        attacks = sum(1 for move in board.legal_moves if board.piece_at(move.from_square).color == color and board.attackers(not color, move.to_square))\n        return attacks\n\n    white_attacks = attacking_moves(chess.WHITE)\n    black_attacks = attacking_moves(chess.BLACK)\n    return float(white_attacks - black_attacks)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the number of pieces that have no legal moves (blocked pieces).\"\n    blocked_count = sum(1 for square, piece in board.piece_map().items() if piece.color == board.turn and not list(board.legal_moves) and piece.color == board.turn)\n    return float(blocked_count)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the difference in piece development by counting pieces on the 2nd and 7th ranks.\"\n    white_development = sum(1 for square in range(8) if board.piece_at(chess.square(square, 1)))\n    black_development = sum(1 for square in range(8) if board.piece_at(chess.square(square, 6)))\n    return float(white_development - black_development)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the number of pieces that are pinned by the opponent's pieces.\"\n    pinned_pieces = sum(1 for square, piece in board.piece_map().items() if piece.color == board.turn and any(board.is_attacked_by(not board.turn, square) for target_square in board.piece_map() if board.piece_map()[target_square].piece_type == chess.KING))\n    return float(pinned_pieces)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the number of squares controlled by each player's pawns.\"\n    controlled_squares = sum(1 for square in board.piece_map() \n                              if board.piece_map()[square].piece_type == chess.PAWN and \n                              board.piece_map()[square].color == board.turn and \n                              any(board.is_attacked_by(chess.BLACK if board.turn else chess.WHITE, target_square) \n                                  for target_square in board.attackers(board.turn, square)))\n    return float(controlled_squares)\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the king's safety based on the number of adjacent attacking squares.\"\n    king_square = next((square for square, piece in board.piece_map().items() \n                        if piece.piece_type == chess.KING and piece.color == board.turn), None)\n    return float(len(board.attackers(not board.turn, king_square)))\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in piece types between players to reflect material variety.\"\n    piece_values = {chess.PAWN: 1, chess.KNIGHT: 3, chess.BISHOP: 3, chess.ROOK: 5, chess.QUEEN: 9, chess.KING: 0}\n    white_material = sum(piece_values[piece.piece_type] for piece in board.piece_map().values() if piece.color == chess.WHITE)\n    black_material = sum(piece_values[piece.piece_type] for piece in board.piece_map().values() if piece.color == chess.BLACK)\n    return float(white_material - black_material)\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the total number of squares controlled by each side.\"\n    white_controlled_squares = sum(1 for square in range(64) if board.is_attacked_by(chess.WHITE, square))\n    black_controlled_squares = sum(1 for square in range(64) if board.is_attacked_by(chess.BLACK, square))\n    return float(white_controlled_squares - black_controlled_squares)\n\n",
    "def feature(board: chess.Board) -> float:\n    'Counts the number of pieces that are attacking opponent pieces.'\n    attack_count = 0\n    for square in board.piece_map():\n        piece = board.piece_at(square)\n        if piece.color != board.turn:\n            attackers = board.attackers(board.turn, square)\n            attack_count += len(attackers)\n    return float(attack_count)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of doubled pawns for each player.\"\n    white_doubled = 0\n    black_doubled = 0\n    pawn_squares = {}\n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.PAWN:\n            file = chess.square_file(square)\n            if file not in pawn_squares:\n                pawn_squares[file] = {chess.WHITE: 0, chess.BLACK: 0}\n            pawn_squares[file][piece.color] += 1\n\n    for counts in pawn_squares.values():\n        if counts[chess.WHITE] > 1:\n            white_doubled += counts[chess.WHITE] - 1\n        if counts[chess.BLACK] > 1:\n            black_doubled += counts[chess.BLACK] - 1\n\n    return float(white_doubled - black_doubled)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures development imbalance by assessing the number of developed pieces relative to the total pieces.\"\n    developed_white = sum(1 for square in board.piece_map() if board.piece_map()[square].color == chess.WHITE and \n                           chess.square_rank(square) > 1)\n    developed_black = sum(1 for square in board.piece_map() if board.piece_map()[square].color == chess.BLACK and \n                           chess.square_rank(square) > 6)\n    \n    total_white = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE)\n    total_black = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK)\n    \n    return float((developed_white / max(1, total_white)) - (developed_black / max(1, total_black))) \n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the total value of pieces located on the last two ranks, indicating an active position.\"\n    active_piece_value = 0\n    for square in board.piece_map():\n        piece = board.piece_at(square)\n        if piece is not None and (chess.square_rank(square) == 6 or chess.square_rank(square) == 7 if piece.color == chess.WHITE else chess.square_rank(square) == 1 or chess.square_rank(square) == 0):\n            active_piece_value += piece.piece_type\n    return float(active_piece_value)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the distance to the nearest opponent's piece for all pieces of the current side.\"\n    distances = []\n    for square in board.piece_map():\n        piece = board.piece_at(square)\n        if piece.color == board.turn:\n            nearest_distance = min(chess.square_distance(square, opp_square) for opp_square in board.piece_map() if board.piece_at(opp_square).color != piece.color)\n            distances.append(nearest_distance)\n    return float(sum(distances)) / max(1, len(distances))\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the square control by summing the number of attacks made by pieces.\"\n    total_attacks = 0\n    for square in range(64):\n        total_attacks += len(board.attackers(chess.WHITE, square)) - len(board.attackers(chess.BLACK, square))\n    return float(total_attacks)\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the number of discovered attacks available for each side.\"\n    def discovered_attacks(color):\n        count = 0\n        for square, piece in board.piece_map().items():\n            if piece.color == color:\n                for move in board.legal_moves:\n                    if board.is_check() and move.from_square == square:\n                        continue\n                    board.push(move)\n                    if board.is_check():\n                        count += 1\n                    board.pop()\n        return count\n    \n    return float(discovered_attacks(chess.WHITE) - discovered_attacks(chess.BLACK))\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces in optimal attacking formation (e.g., pieces supporting each other).\"\n    formation_count = sum(1 for square, piece in board.piece_map().items() if piece.color == board.turn and (chess.square_rank(square) == 1 or chess.square_rank(square) == 6) and any(board.is_attacked_by(board.turn, attacking_square) for attacking_square in board.attackers(board.turn, square)))\n    return float(formation_count)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the number of pawns in the opponent's half of the board for each side.\"\n    white_pawn_authority = sum(1 for square in board.piece_map() if board.piece_map()[square].color == chess.WHITE and board.piece_map()[square].piece_type == chess.PAWN and chess.square_rank(square) > 4)\n    black_pawn_authority = sum(1 for square in board.piece_map() if board.piece_map()[square].color == chess.BLACK and board.piece_map()[square].piece_type == chess.PAWN and chess.square_rank(square) < 3)\n    return float(white_pawn_authority - black_pawn_authority)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the number of advanced pawns (pawns on the 4th rank or beyond) for both sides.\"\n    advanced_pawns = sum(1 for square, piece in board.piece_map().items() if piece.piece_type == chess.PAWN and piece.color == board.turn and chess.square_rank(square) >= 4)\n    return float(advanced_pawns)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the number of squares controlled by each player excluding occupied squares.\"\n    controlled_white = len([square for square in chess.SQUARES if board.is_attacked_by(chess.WHITE, square) and board.piece_at(square) is None])\n    controlled_black = len([square for square in chess.SQUARES if board.is_attacked_by(chess.BLACK, square) and board.piece_at(square) is None])\n    return float(controlled_white - controlled_black)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates material ratio between white and black pieces.\"\n    white_material = sum(piece.piece_type for piece in board.piece_map().values() if piece.color == chess.WHITE)\n    black_material = sum(piece.piece_type for piece in board.piece_map().values() if piece.color == chess.BLACK)\n    return (white_material / (black_material + 1)) if black_material > 0 else float('inf')\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the number of pieces each player has that are actively participating in the attack.\"\n    attacking_pieces = sum(1 for move in board.legal_moves if board.piece_at(move.from_square).color == board.turn)\n    return float(attacking_pieces)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the total number of attacking pieces of each side.\"\n    white_attackers = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE)\n    black_attackers = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK)\n    return float(white_attackers - black_attackers)\n\n",
    "def feature(board: chess.Board) -> float:\n    'Measures the total number of pieces attacking squares occupied by enemy pieces.'\n    attack_count = 0\n    for square in board.piece_map():\n        piece = board.piece_at(square)\n        if piece:\n            for attacker in board.attackers(piece.color, square):\n                if board.is_attacked_by(not piece.color, square):\n                    attack_count += 1\n    return float(attack_count)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the number of squares controlled by both sides' pieces.\"\n    controlled_squares_white = sum(1 for square in range(64) if board.is_attacked_by(chess.WHITE, square))\n    controlled_squares_black = sum(1 for square in range(64) if board.is_attacked_by(chess.BLACK, square))\n    return float(controlled_squares_white - controlled_squares_black)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the distribution of pawns across the ranks, assessing pawn structure.\"\n    pawn_distribution = [0] * 8\n    for square in chess.SQUARES:\n        piece = board.piece_at(square)\n        if piece and piece.piece_type == chess.PAWN:\n            pawn_distribution[chess.square_rank(square)] += 1\n    return float(max(pawn_distribution) - min(pawn_distribution))\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the number of pieces attacking the opponent's king.\"\n    opponent_color = chess.BLACK if board.turn else chess.WHITE\n    king_square = next(square for square, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color == opponent_color)\n    attackers_count = len(board.attackers(board.turn, king_square))\n    return float(attackers_count)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of developed pieces for each side (not on the back rank).\"\n    developed_white = sum(1 for square in chess.SQUARES if board.piece_at(square) and board.piece_at(square).color == chess.WHITE and chess.square_rank(square) > 1)\n    developed_black = sum(1 for square in chess.SQUARES if board.piece_at(square) and board.piece_at(square).color == chess.BLACK and chess.square_rank(square) < 6)\n    return float(developed_white - developed_black)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Evaluates the number of potential pawn promotions for both sides.\"\n    white_promotion_pawns = sum(1 for square in board.piece_map() if board.piece_map()[square].color == chess.WHITE and \n                                 chess.square_rank(square) == 6)\n    black_promotion_pawns = sum(1 for square in board.piece_map() if board.piece_map()[square].color == chess.BLACK and \n                                 chess.square_rank(square) == 1)\n    return float(white_promotion_pawns - black_promotion_pawns)\n",
    "def feature(board: chess.Board) -> float:\n    'Determines the number of squares attacked by minor pieces to assess zone control.'\n    attacked_squares = set()\n    for square in board.piece_map():\n        piece = board.piece_at(square)\n        if piece.color == board.turn and piece.piece_type in {chess.KNIGHT, chess.BISHOP}:\n            attacked_squares.update(board.attackers(piece.color, square))\n    return float(len(attacked_squares))\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces that can attack the opponent's king.\"\n    white_attacks = sum(1 for square in chess.SQUARES if board.is_attacked_by(chess.WHITE, square) and board.piece_at(square) and board.piece_at(square).color == chess.BLACK)\n    black_attacks = sum(1 for square in chess.SQUARES if board.is_attacked_by(chess.BLACK, square) and board.piece_at(square) and board.piece_at(square).color == chess.WHITE)\n    return float(white_attacks - black_attacks)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the piece activity by counting the number of legal moves available for each side.\"\n    white_legal_moves = len(list(board.legal_moves)) if board.turn else 0\n    black_legal_moves = len(list(board.legal_moves)) if not board.turn else 0\n    return float(white_legal_moves - black_legal_moves)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Determines the average piece value for each side.\"\n    piece_values = {chess.PAWN: 1, chess.KNIGHT: 3, chess.BISHOP: 3, chess.ROOK: 5, chess.QUEEN: 9, chess.KING: 0}\n    white_value = sum(piece_values[piece.piece_type] for piece in board.piece_map().values() if piece.color == chess.WHITE)\n    black_value = sum(piece_values[piece.piece_type] for piece in board.piece_map().values() if piece.color == chess.BLACK)\n    total_value = white_value + black_value\n    return (white_value - black_value) / (total_value if total_value > 0 else 1)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the overall position imbalance based on pawn structure.\"\n    white_pawns = len([p for p in board.piece_map().values() if p.piece_type == chess.PAWN and p.color == chess.WHITE])\n    black_pawns = len([p for p in board.piece_map().values() if p.piece_type == chess.PAWN and p.color == chess.BLACK])\n    return float(white_pawns - black_pawns)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in piece mobility for both sides based on legal moves.\"\n    white_mobility = len(list(board.legal_moves)) if board.turn else 0\n    black_mobility = len(list(board.legal_moves)) if not board.turn else 0\n    return float(white_mobility - black_mobility)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the number of pieces within the opponent's reach, indicating potential threats.\"\n    reach = sum(len(board.attackers(piece.color, square)) for square in board.piece_map() for piece in [board.piece_at(square)] if piece)\n    return float(reach)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Tracks the number of pieces on each player's back rank.\"\n    white_back_rank_pieces = sum(1 for square in range(56, 64) if board.piece_at(square) and board.piece_at(square).color == chess.WHITE)\n    black_back_rank_pieces = sum(1 for square in range(0, 8) if board.piece_at(square) and board.piece_at(square).color == chess.BLACK)\n    return float(white_back_rank_pieces - black_back_rank_pieces)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures distribution of pieces on the eighth rank, indicating readiness for promotion.\"\n    eighth_rank_count = sum(1 for square in range(chess.A8, chess.H8 + 1) if board.piece_at(square) is not None)\n    return float(eighth_rank_count)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the total value of pawns on the board, giving insight into pawn structure.\"\n    pawn_value = 1.0\n    total_value = 0.0\n    for piece in board.piece_map().values():\n        if piece.piece_type == chess.PAWN:\n            total_value += pawn_value if piece.color == chess.WHITE else -pawn_value\n    return total_value\n\n",
    "def feature(board: chess.Board) -> float:\n    'Calculates the number of piece pairs (two pieces of the same color on adjacent squares) for each side.'\n    piece_pairs = 0\n    for square1 in board.piece_map():\n        for square2 in board.piece_map():\n            if square1 != square2 and board.piece_map()[square1].color == board.piece_map()[square2].color:\n                if chess.square_distance(square1, square2) == 1:  # Adjacent squares\n                    piece_pairs += 1\n    return float(piece_pairs)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Evaluates the potential threats by counting attacking squares of pieces for both sides.\"\n    white_threats = sum(1 for square in board.piece_map() if board.piece_map()[square].color == chess.WHITE for target in board.attackers(chess.BLACK, square))\n    black_threats = sum(1 for square in board.piece_map() if board.piece_map()[square].color == chess.BLACK for target in board.attackers(chess.WHITE, square))\n    return float(white_threats - black_threats)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the potential for checkmating the opponent by counting how many pieces can deliver check.\"\n    check_potential = sum(1 for square, piece in board.piece_map().items() \n                           if piece.color == board.turn and piece.piece_type != chess.KING and \n                           square in [m.to_square for m in board.legal_moves if m.to_square in board.attackers(not board.turn, square)])\n    return float(check_potential)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the difference in the number of pieces in each player's possession that can promote.\"\n    white_promising = sum(1 for square in board.piece_map() if board.piece_map()[square].color == chess.WHITE and chess.square_rank(square) == 6)\n    black_promising = sum(1 for square in board.piece_map() if board.piece_map()[square].color == chess.BLACK and chess.square_rank(square) == 1)\n    return float(white_promising - black_promising)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Evaluates the number of pawn structures on the 4th and 5th ranks for both players to assess potential mobility.\"\n    white_pawn_structure = sum(1 for sq in range(32, 48) if board.piece_at(sq) and board.piece_at(sq).piece_type == chess.PAWN)\n    black_pawn_structure = sum(1 for sq in range(16, 32) if board.piece_at(sq) and board.piece_at(sq).piece_type == chess.PAWN)\n    result = white_pawn_structure - black_pawn_structure\n    return float(result)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the number of pieces poised for promotion (pawns on 7th rank).\"\n    promotion_candidates = sum(1 for sq in board.piece_map() if board.piece_map()[sq].piece_type == chess.PAWN and chess.square_rank(sq) == 6)\n    return float(promotion_candidates)\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the number of pieces of each color that are currently under attack.\"\n    under_attack_count = {chess.WHITE: 0, chess.BLACK: 0}\n    \n    for square, piece in board.piece_map().items():\n        if board.is_attacked_by(chess.WHITE, square):\n            under_attack_count[chess.WHITE] += 1\n        if board.is_attacked_by(chess.BLACK, square):\n            under_attack_count[chess.BLACK] += 1\n\n    return float(under_attack_count[chess.WHITE] - under_attack_count[chess.BLACK])\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the mobility of pieces based on central control.\"\n    central_sq_white = sum(1 for square in board.piece_map() if board.piece_map()[square].color == chess.WHITE and \n                            chess.square_file(square) in (3, 4) and chess.square_rank(square) in (3, 4))\n    \n    central_sq_black = sum(1 for square in board.piece_map() if board.piece_map()[square].color == chess.BLACK and \n                            chess.square_file(square) in (3, 4) and chess.square_rank(square) in (3, 4))\n    \n    return float(central_sq_white - central_sq_black)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the total number of pieces near each king, assessing protection.\"\n    king_proximity_squares = [chess.square_file(square) + chess.square_rank(square) for square in range(chess.A1, chess.H8 + 1)]\n    \n    white_king_square = next(square for square in board.piece_map() if board.piece_at(square).color == chess.WHITE and board.piece_at(square).piece_type == chess.KING)\n    black_king_square = next(square for square in board.piece_map() if board.piece_at(square).color == chess.BLACK and board.piece_at(square).piece_type == chess.KING)\n\n    white_protection = sum(1 for square in king_proximity_squares if board.is_attacked_by(chess.BLACK, square))\n    black_protection = sum(1 for square in king_proximity_squares if board.is_attacked_by(chess.WHITE, square))\n    return float(white_protection - black_protection)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of underdeveloped pieces for both sides, indicating potential for future mobility.\"\n    white_underdeveloped = sum(1 for square, piece in board.piece_map().items() if piece.color == chess.WHITE and (piece.piece_type in [chess.KNIGHT, chess.BISHOP] and (chess.square_rank(square) < 2 or chess.square_rank(square) > 5)))\n    black_underdeveloped = sum(1 for square, piece in board.piece_map().items() if piece.color == chess.BLACK and (piece.piece_type in [chess.KNIGHT, chess.BISHOP] and (chess.square_rank(square) < 2 or chess.square_rank(square) > 5)))\n    return float(white_underdeveloped - black_underdeveloped)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the material imbalance by counting the total value of pieces each side has.\"\n    piece_values = {chess.PAWN: 1, chess.KNIGHT: 3, chess.BISHOP: 3, chess.ROOK: 5, chess.QUEEN: 9}\n    white_value = sum(piece_values.get(piece.piece_type, 0) for piece in board.piece_map().values() if piece.color == chess.WHITE)\n    black_value = sum(piece_values.get(piece.piece_type, 0) for piece in board.piece_map().values() if piece.color == chess.BLACK)\n    return float(white_value - black_value)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the total number of pawn moves that could be played by each side.\"\n    pawn_move_count = 0\n    for square, piece in board.piece_map().items():\n        if piece and piece.piece_type == chess.PAWN:\n            for move in board.legal_moves:\n                if move.from_square == square:\n                    pawn_move_count += 1\n    return float(pawn_move_count)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the number of moves left in the game according to the halfmove clock.\"\n    halfmove_limit = 50 \n    return float(halfmove_limit - board.halfmove_clock)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the control over the center squares (d4, d5, e4, e5) by rooks and queens.\"\n    center_squares = [chess.parse_square('d4'), chess.parse_square('d5'), chess.parse_square('e4'), chess.parse_square('e5')]\n    white_control = sum(1 for square in center_squares if board.piece_at(square) and board.piece_at(square).color == chess.WHITE and board.piece_at(square).piece_type in [chess.ROOK, chess.QUEEN])\n    black_control = sum(1 for square in center_squares if board.piece_at(square) and board.piece_at(square).color == chess.BLACK and board.piece_at(square).piece_type in [chess.ROOK, chess.QUEEN])\n    return float(white_control - black_control)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Evaluates the risk of losing pieces based on how many are attacked.\"\n    white_attacked = sum(1 for square in board.piece_map() if board.piece_map()[square].color == chess.WHITE and \n                          board.is_attacked_by(chess.BLACK, square))\n    black_attacked = sum(1 for square in board.piece_map() if board.piece_map()[square].color == chess.BLACK and \n                          board.is_attacked_by(chess.WHITE, square))\n    return float(white_attacked - black_attacked)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the advancement of pieces towards the opponent's back rank.\"\n    white_advanced = sum(1 for square, piece in board.piece_map().items() if piece.color == chess.WHITE and chess.square_rank(square) > 4)\n    black_advanced = sum(1 for square, piece in board.piece_map().items() if piece.color == chess.BLACK and chess.square_rank(square) < 3)\n    return float(white_advanced - black_advanced)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the depth of the player's piece formation towards the opponent's back rank.\"\n    formation_depth = sum(8 - chess.square_rank(square) for square, piece in board.piece_map().items() if piece.color == chess.WHITE)\n    result = float(formation_depth)\n    return result\n\n",
    "def feature(board: chess.Board) -> float:\n    'Measures the material balance adjusted for piece positioning.'\n    piece_positions = {\n        chess.KNIGHT: (3, 2),\n        chess.BISHOP: (3, 2),\n        chess.ROOK: (5, 1),\n        chess.QUEEN: (9, 0)\n    }\n    \n    positional_value_white = sum(piece_positions.get(piece.piece_type, (0, 0))[0] for piece in board.piece_map().values() if piece.color == chess.WHITE)\n    positional_value_black = sum(piece_positions.get(piece.piece_type, (0, 0))[1] for piece in board.piece_map().values() if piece.color == chess.BLACK)\n    \n    return float(positional_value_white - positional_value_black)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Evaluates the king's safety by counting the number of squares around it that are attacked.\"\n    king_square = next((square for square, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color == board.turn), None)\n    if king_square is None:\n        return 0.0\n    threatened_squares = sum(1 for square in chess.SQUARES_180 if board.is_attacked_by(not board.turn, square))\n    return float(threatened_squares)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the number of pawns each player has on the board.\"\n    white_pawns = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE and piece.piece_type == chess.PAWN)\n    black_pawns = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK and piece.piece_type == chess.PAWN)\n    return float(white_pawns - black_pawns)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the ratio of knights to bishops on the board for each player, indicating piece balance.\"\n    knight_count = sum(1 for piece in board.piece_map().values() if piece.piece_type == chess.KNIGHT and piece.color == board.turn)\n    bishop_count = sum(1 for piece in board.piece_map().values() if piece.piece_type == chess.BISHOP and piece.color == board.turn)\n    return float(knight_count / (bishop_count + 1))  # Added 1 to prevent division by zero\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the number of doubled pawns for each side.\"\n    doubled_pawns_white = sum(1 for square in board.piece_map() if board.piece_map()[square].color == chess.WHITE and board.piece_map()[square].piece_type == chess.PAWN and (board.piece_at(chess.square_file(square) + 8) is not None or board.piece_at(chess.square_file(square) - 8) is not None))\n    doubled_pawns_black = sum(1 for square in board.piece_map() if board.piece_map()[square].color == chess.BLACK and board.piece_map()[square].piece_type == chess.PAWN and (board.piece_at(chess.square_file(square) + 8) is not None or board.piece_at(chess.square_file(square) - 8) is not None))\n    return float(doubled_pawns_white - doubled_pawns_black)\n\n",
    "def feature(board: chess.Board) -> float:\n    'Counts the number of non-pawn pieces remaining for each player to assess piece strength.'\n    non_pawn_types = {chess.KNIGHT, chess.BISHOP, chess.ROOK, chess.QUEEN, chess.KING}\n    white_non_pawns = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE and piece.piece_type in non_pawn_types)\n    black_non_pawns = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK and piece.piece_type in non_pawn_types)\n    return float(white_non_pawns - black_non_pawns)\n\n",
    "def feature(board: chess.Board) -> float:\n    'Assesses the potential safety of the kings by counting the number of escape squares.'\n    escape_squares_w = sum(1 for sq in board.attacks(chess.KING if board.turn else chess.BLACK) if chess.square_file(sq) in range(8) and chess.square_rank(sq) in range(8))\n    escape_squares_b = sum(1 for sq in board.attacks(chess.KING if not board.turn else chess.WHITE) if chess.square_file(sq) in range(8) and chess.square_rank(sq) in range(8))\n    return float(escape_squares_w - escape_squares_b)\n\n",
    "def feature(board: chess.Board) -> float:\n    'Calculates the pawn structure value: doubled pawns, isolated pawns, and passed pawns.'\n    def pawn_structure_value(color):\n        value = 0\n        pawns = [sq for sq in board.piece_map() if board.piece_at(sq).piece_type == chess.PAWN and board.piece_at(sq).color == color]\n        files = {}\n        for pawn in pawns:\n            file = chess.square_file(pawn)\n            if file in files:\n                files[file].append(pawn)\n            else:\n                files[file] = [pawn]\n        for file, pawns in files.items():\n            # Doubling\n            if len(pawns) > 1:\n                value -= 1  # Penalize doubled pawns\n            # Isolated\n            if file > 0 and (file - 1 not in files or len(files[file - 1]) == 0) and (file + 1 not in files or len(files[file + 1]) == 0):\n                value -= 1  # Penalize isolated pawns\n        return value\n\n    result = float(pawn_structure_value(chess.WHITE) - pawn_structure_value(chess.BLACK))\n    return result\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Determines the number of pieces in the opponent's half of the board.\"\n    opponent_half = range(0, 4) if board.turn else range(4, 8)\n    return float(sum(1 for square, piece in board.piece_map().items() if chess.square_rank(square) in opponent_half))\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the number of pieces that are currently being developed towards the center.\"\n    development_count = 0\n    center_squares = [chess.D4, chess.E4, chess.D5, chess.E5]\n    for square, piece in board.piece_map().items():\n        if piece.color == board.turn and (piece.piece_type in {chess.KNIGHT, chess.BISHOP, chess.QUEEN}):\n            if square in center_squares:\n                development_count += 1\n    return float(development_count)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of squares controlled by pieces on the 2nd and 7th ranks for each side.\"\n    def controlled_squares_count(color, rank):\n        return sum(1 for square in chess.SQUARES if board.is_attacked_by(color, square) and chess.square_rank(square) != rank)\n\n    white_control = controlled_squares_count(chess.WHITE, 1)\n    black_control = controlled_squares_count(chess.BLACK, 6)\n    return float(white_control - black_control)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the number of pieces that are pinned against the king.\"\n    pinned_count = 0\n    king_square = None\n    \n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.KING and piece.color == board.turn:\n            king_square = square\n    \n    if king_square is not None:\n        for square, piece in board.piece_map().items():\n            if piece.color != board.turn:\n                if board.is_attacked_by(board.turn, square):\n                    if any(board.piece_at(s) and board.piece_at(s).color == board.turn for s in board.attackers(piece.color, square)):\n                        pinned_count += 1\n                        \n    return float(pinned_count)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in numbers of light-squared and dark-squared pieces for positional assessment.\"\n    color_count = {chess.WHITE: {'light': 0, 'dark': 0}, chess.BLACK: {'light': 0, 'dark': 0}}\n    for square, piece in board.piece_map().items():\n        if piece.piece_type != chess.PAWN:  # Exclude pawns from this count\n            color_type = 'light' if (chess.square_file(square) + chess.square_rank(square)) % 2 == 0 else 'dark'\n            color_count[piece.color][color_type] += 1\n    return float(color_count[chess.WHITE]['light'] - color_count[chess.BLACK]['light']) - float(color_count[chess.WHITE]['dark'] - color_count[chess.BLACK]['dark'])\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the ratio of minor pieces to major pieces that each side has.\"\n    white_minor = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE and piece.piece_type in (chess.KNIGHT, chess.BISHOP))\n    white_major = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE and piece.piece_type in (chess.ROOK, chess.QUEEN))\n    black_minor = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK and piece.piece_type in (chess.KNIGHT, chess.BISHOP))\n    black_major = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK and piece.piece_type in (chess.ROOK, chess.QUEEN))\n    ratio_white = white_minor / (white_major + 1)  # Adding 1 to avoid division by zero\n    ratio_black = black_minor / (black_major + 1)  # Adding 1 to avoid division by zero\n    return float(ratio_white - ratio_black)\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in the number of controlling bishops on diagonals.\"\n    def count_bishops(color):\n        return sum(1 for square, piece in board.piece_map().items() if piece.color == color and piece.piece_type == chess.BISHOP)\n    return float(count_bishops(chess.WHITE) - count_bishops(chess.BLACK))\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the balance of remaining pieces compared to the maximum possible.\"\n    total_pieces = len(board.piece_map())\n    total_possible = 32  # 16 per side at the start\n    return float((total_possible - total_pieces) / total_possible)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the number of double attacks possible on both players' less valuable pieces.\"\n    def count_double_attacks(color):\n        count = 0\n        for square in board.piece_map():\n            piece = board.piece_at(square)\n            if piece.color == color:\n                attackers = board.attackers(not color, square)\n                if len(attackers) > 1:\n                    count += 1\n        return count\n\n    white_double_attacks = count_double_attacks(chess.WHITE)\n    black_double_attacks = count_double_attacks(chess.BLACK)\n    return float(white_double_attacks - black_double_attacks)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the mobility of pieces by counting the number of legal moves.\"\n    mobility = len(list(board.legal_moves))\n    return float(mobility)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the total number of pieces that are unprotected (not attacked by any opposing pieces).\"\n    unprotected_count = 0\n    for square, piece in board.piece_map().items():\n        if not board.is_attacked_by(not piece.color, square):\n            unprotected_count += 1\n    return float(unprotected_count)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the number of times pieces attack the opponent's pieces.\"\n    attack_score = sum(len(board.attackers(not piece.color, square)) for square, piece in board.piece_map().items() if piece.color == board.turn)\n    return float(attack_score)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the central control by counting pieces in the central squares.\"\n    central_squares = [chess.E4, chess.E5, chess.D4, chess.D5]\n    control_count = sum(1 for square in central_squares if board.piece_at(square) and board.piece_at(square).color == chess.WHITE)\n    return float(control_count)\n\n",
    "def feature(board: chess.Board) -> float:\n    'Calculates the difference in active pieces (pieces that can move) for each side.'\n    white_active_pieces = sum(1 for move in board.legal_moves if board.piece_at(move.from_square).color == chess.WHITE)\n    black_active_pieces = sum(1 for move in board.legal_moves if board.piece_at(move.from_square).color == chess.BLACK)\n    return float(white_active_pieces - black_active_pieces)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the positional advantage based on the number of pieces on the 7th and 2nd ranks.\"\n    white_seventh_rank = sum(1 for square in range(56, 64) if board.piece_at(square) is not None and board.piece_at(square).color == chess.WHITE)\n    black_second_rank = sum(1 for square in range(8, 16) if board.piece_at(square) is not None and board.piece_at(square).color == chess.BLACK)\n    return float(white_seventh_rank - black_second_rank)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts pieces trapped with no legal moves left to escape.\"\n    trapped_pieces = sum(1 for square, piece in board.piece_map().items() if piece.color == board.turn and not list(board.legal_moves) and all(board.is_attacked_by(not board.turn, square)))\n    return float(trapped_pieces)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the number of rook connections (where rooks control the same file or rank).\"\n    rook_positions = [square for square, piece in board.piece_map().items() \n                      if piece.piece_type == chess.ROOK]\n    connection_count = sum(1 for square1 in rook_positions \n                           for square2 in rook_positions \n                           if square1 != square2 and \n                           (chess.square_file(square1) == chess.square_file(square2) or \n                            chess.square_rank(square1) == chess.square_rank(square2))\n                          )\n    return float(connection_count)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the distance of the pieces from their home squares.\"\n    total_distance = sum(chess.square_rank(square) if piece.color == chess.WHITE else (7 - chess.square_rank(square)) for square, piece in board.piece_map().items())\n    return float(total_distance)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the imbalance in piece distribution across different ranks for each side.\"\n    white_rank_distribution = [0] * 8\n    black_rank_distribution = [0] * 8\n    for square, piece in board.piece_map().items():\n        if piece.color == chess.WHITE:\n            white_rank_distribution[chess.square_rank(square)] += 1\n        else:\n            black_rank_distribution[chess.square_rank(square)] += 1\n    return float(sum(white_rank_distribution) - sum(black_rank_distribution))\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures kingside activity, evaluating the development of pieces around the king.\"\n    kingside_pieces = sum(1 for square in range(60, 64) if board.piece_at(square) and board.piece_at(square).color == board.turn)\n    return float(kingside_pieces)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the number of loose pieces that can be easily captured without retaliation.\"\n    loose_piece_count = 0\n    for square, piece in board.piece_map().items():\n        if any(board.is_attacked_by(piece.color, sq) for sq in board.attackers(not piece.color, square)):\n            loose_piece_count += 1\n    return float(loose_piece_count)\n\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of hanging pieces (pieces that can be captured without retaliation) for each side.\"\n    def count_hanging_pieces(color):\n        count = 0\n        for square, piece in board.piece_map().items():\n            if piece.color == color and board.is_attacked_by(not color, square) and not any(board.is_attacked_by(color, attacker) for attacker in board.attackers(not color, square)):\n                count += 1\n        return count\n    \n    white_hanging = count_hanging_pieces(chess.WHITE)\n    black_hanging = count_hanging_pieces(chess.BLACK)\n    return float(black_hanging - white_hanging)\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates pawn structure by counting the number of isolated pawns.\"\n    isolated_pawns = 0\n    for file in range(8):\n        white_pawn = board.piece_at(chess.square(file, 1))\n        black_pawn = board.piece_at(chess.square(file, 6))\n        if white_pawn and white_pawn.color == chess.WHITE and ((file > 0 and not board.piece_at(chess.square(file - 1, 1))) and (file < 7 and not board.piece_at(chess.square(file + 1, 1)))):\n            isolated_pawns += 1\n        if black_pawn and black_pawn.color == chess.BLACK and ((file > 0 and not board.piece_at(chess.square(file - 1, 6))) and (file < 7 and not board.piece_at(chess.square(file + 1, 6)))):\n            isolated_pawns -= 1\n    return float(isolated_pawns)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in piece activity by assessing piece positions relative to the center.\"\n    central_squares = [chess.D4, chess.E4, chess.D5, chess.E5]\n    white_active = sum(1 for square in board.piece_map() if board.piece_map()[square].color == chess.WHITE and square in central_squares)\n    black_active = sum(1 for square in board.piece_map() if board.piece_map()[square].color == chess.BLACK and square in central_squares)\n    return float(white_active - black_active)\n",
    "def feature(board: chess.Board) -> float:\n    \"Checks for potential discovered attacks by counting pieces that can move away from the line of attack.\"\n    discovered_counts = {chess.WHITE: 0, chess.BLACK: 0}\n    for square in chess.SQUARES:\n        if board.piece_at(square) and board.piece_at(square).piece_type in {chess.ROOK, chess.QUEEN}:\n            for move in board.legal_moves:\n                if move.from_square == square:\n                    piece_on_target = board.piece_at(move.to_square)\n                    if piece_on_target and piece_on_target.color != board.piece_at(square).color:\n                        discovered_counts[board.piece_at(square).color] += 1\n    return float(discovered_counts[chess.WHITE]) - float(discovered_counts[chess.BLACK])\n\n",
    "def feature(board: chess.Board) -> float:\n    'Calculates the difference in central control between both sides.'\n    central_control_white = sum(1 for square in [chess.D4, chess.D5, chess.E4, chess.E5] if board.is_attacked_by(chess.WHITE, square))\n    central_control_black = sum(1 for square in [chess.D4, chess.D5, chess.E4, chess.E5] if board.is_attacked_by(chess.BLACK, square))\n    return float(central_control_white - central_control_black)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the king's safety based on the number of pieces defending it.\"\n    white_king_square = next(square for square in board.piece_map() if board.piece_map()[square].color == chess.WHITE and board.piece_map()[square].piece_type == chess.KING)\n    black_king_square = next(square for square in board.piece_map() if board.piece_map()[square].color == chess.BLACK and board.piece_map()[square].piece_type == chess.KING)\n    white_defenders = sum(1 for square in board.piece_map() if board.piece_map()[square].color == chess.WHITE and board.is_attacked_by(chess.BLACK, white_king_square))\n    black_defenders = sum(1 for square in board.piece_map() if board.piece_map()[square].color == chess.BLACK and board.is_attacked_by(chess.WHITE, black_king_square))\n    return float(white_defenders - black_defenders)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces that are on the opponent's half of the board.\"\n    opponent_half_control = sum(1 for square, piece in board.piece_map().items() \n                                  if piece.color == board.turn and \n                                  (piece.color == chess.WHITE and chess.square_rank(square) > 3 or \n                                   piece.color == chess.BLACK and chess.square_rank(square) < 4))\n    return float(opponent_half_control)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces attacking the center squares.\"\n    center_squares = [chess.D4, chess.D5, chess.E4, chess.E5]\n    white_center_attack = sum(1 for square in center_squares if board.is_attacked_by(chess.WHITE, square))\n    black_center_attack = sum(1 for square in center_squares if board.is_attacked_by(chess.BLACK, square))\n    return float(white_center_attack - black_center_attack)\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the activity level of pieces by counting how many legal moves each side has.\"\n    white_moves = len(list(board.legal_moves))\n    # Simulate opponent's turn to check for black's moves\n    board.push(chess.Move.null())\n    black_moves = len(list(board.legal_moves))\n    board.pop()\n    return float(white_moves - black_moves)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the total number of pieces each side has in the opponent's territory (ranks 6-8 for White, ranks 1-3 for Black).\"\n    white_territory_count = 0\n    black_territory_count = 0\n    for square, piece in board.piece_map().items():\n        rank = chess.square_rank(square)\n        if piece.color == chess.WHITE and rank >= 6:\n            white_territory_count += 1\n        elif piece.color == chess.BLACK and rank <= 2:\n            black_territory_count += 1\n    return float(white_territory_count - black_territory_count)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the distance of the most advanced pawn from the opponent's back rank.\"\n    white_advanced_pawn = max((7 - chess.square_rank(square) for square in board.piece_map() if board.piece_at(square).piece_type == chess.PAWN and board.piece_at(square).color == chess.WHITE), default=0)\n    black_advanced_pawn = max((chess.square_rank(square) for square in board.piece_map() if board.piece_at(square).piece_type == chess.PAWN and board.piece_at(square).color == chess.BLACK), default=0)\n    result = white_advanced_pawn - black_advanced_pawn\n    return float(result)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Evaluates the development of pieces by counting the number of pieces developed from their starting positions.\"\n    initial_positions = {\n        chess.ROOK: [0, 1, 56, 57],\n        chess.KNIGHT: [2, 5, 58, 61],\n        chess.BISHOP: [3, 4, 59, 60],\n        chess.QUEEN: [3, 4],\n        chess.KING: [60, 4]\n    }\n    developed_count = 0\n    for piece_type, squares in initial_positions.items():\n        developed_count += sum(1 for square in board.piece_map() \n                               if board.piece_map()[square].piece_type == piece_type and \n                               square not in squares and \n                               board.piece_map()[square].color == board.turn)\n    return float(developed_count)\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the total distance of all pieces from the center of the board.\"\n    center_distance = 0\n    center_squares = [chess.E4, chess.E5, chess.D4, chess.D5]\n    for square, piece in board.piece_map().items():\n        distance_to_center = min(chess.square_distance(square, csq) for csq in center_squares)\n        center_distance += distance_to_center\n    return float(center_distance)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the number of times each player has attacking pieces aimed at each other's kings.\"\n    white_attacks = sum(1 for square in board.piece_map() if board.is_attacked_by(chess.WHITE, square) and (square in board.attacks(board.king(chess.BLACK))))\n    black_attacks = sum(1 for square in board.piece_map() if board.is_attacked_by(chess.BLACK, square) and (square in board.attacks(board.king(chess.WHITE))))\n    return float(white_attacks - black_attacks)\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the number of squares controlled by each player.\"\n    def controlled_squares(color):\n        controlled = sum(1 for square in range(64) if board.is_attacked_by(color, square))\n        return controlled\n\n    white_controlled = controlled_squares(chess.WHITE)\n    black_controlled = controlled_squares(chess.BLACK)\n    return float(white_controlled - black_controlled)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the control of the center squares (d4, d5, e4, e5) for both sides.\"\n    center_squares = [chess.parse_square('d4'), chess.parse_square('d5'), chess.parse_square('e4'), chess.parse_square('e5')]\n    white_center_control = sum(1 for sq in center_squares if board.is_attacked_by(chess.WHITE, sq))\n    black_center_control = sum(1 for sq in center_squares if board.is_attacked_by(chess.BLACK, sq))\n    return float(white_center_control - black_center_control)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the activity of rooks on open files.\"\n    def rook_activity(color):\n        return sum(1 for square, piece in board.piece_map().items() if piece.color == color and piece.piece_type == chess.ROOK and (not board.piece_at(chess.parse_square(chess.square_name(square)[0] + '1')) or \n                not board.piece_at(chess.parse_square(chess.square_name(square)[0] + '8'))))\n    \n    return float(rook_activity(chess.WHITE) - rook_activity(chess.BLACK))\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the number of pieces each player has connected on the same rank.\"\n    connected_white = sum(1 for rank in range(8) if any(board.piece_at(chess.square(file, rank)) and board.piece_at(chess.square(file, rank)).color == chess.WHITE for file in range(8)))\n    connected_black = sum(1 for rank in range(8) if any(board.piece_at(chess.square(file, rank)) and board.piece_at(chess.square(file, rank)).color == chess.BLACK for file in range(8)))\n    result = connected_white - connected_black\n    return float(result)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the overall material value of pieces on the board for both sides.\"\n    material_value = sum(piece.piece_type for piece in board.piece_map().values())\n    return float(material_value)\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the number of doubled pawns for each color.\"\n    def doubled_pawns(color):\n        pawns = [square for square in board.piece_map() if board.piece_map()[square].color == color and \n                  board.piece_map()[square].piece_type == chess.PAWN]\n        files = {}\n        for pawn in pawns:\n            file = chess.square_file(pawn)\n            if file not in files:\n                files[file] = []\n            files[file].append(pawn)\n        return sum(len(squares) - 1 for squares in files.values() if len(squares) > 1)\n\n    white_doubled = doubled_pawns(chess.WHITE)\n    black_doubled = doubled_pawns(chess.BLACK)\n    return float(white_doubled - black_doubled)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the number of pieces trapped or with limited movement opportunities.\"\n    trapped_pieces_count = sum(1 for square, piece in board.piece_map().items() if piece.color == board.turn and len(list(board.legal_moves)) == 0)\n    return float(trapped_pieces_count)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the number of square defenders for each player's king to measure safety.\"\n    white_king_square = next(square for square, piece in board.piece_map().items() if piece.color == chess.WHITE and piece.piece_type == chess.KING)\n    black_king_square = next(square for square, piece in board.piece_map().items() if piece.color == chess.BLACK and piece.piece_type == chess.KING)\n    \n    white_king_defense = len(board.attackers(chess.WHITE, white_king_square))\n    black_king_defense = len(board.attackers(chess.BLACK, black_king_square))\n    \n    return float(white_king_defense - black_king_defense)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the total number of pieces in the center 4 squares for each side.\"\n    center_squares = [chess.D4, chess.D5, chess.E4, chess.E5]\n    white_center_count = sum(1 for square in center_squares if board.piece_at(square) and board.piece_at(square).color == chess.WHITE)\n    black_center_count = sum(1 for square in center_squares if board.piece_at(square) and board.piece_at(square).color == chess.BLACK)\n    return float(white_center_count - black_center_count)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the piece development advantage by counting undeveloped pieces.\"\n    undeveloped_white = sum(1 for square in [chess.B1, chess.C1, chess.G1, chess.H1] if board.piece_at(square) is not None and board.piece_at(square).color == chess.WHITE)\n    undeveloped_black = sum(1 for square in [chess.B8, chess.C8, chess.G8, chess.H8] if board.piece_at(square) is not None and board.piece_at(square).color == chess.BLACK)\n    return float(undeveloped_black - undeveloped_white)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the total value of pawns considering positions for both sides.\"\n    pawn_value = {chess.PAWN: 1}\n    total_pawn_value = sum(pawn_value[piece.piece_type] for piece in board.piece_map().values() \n                            if piece.piece_type == chess.PAWN and piece.color == board.turn)\n    return float(total_pawn_value)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the average distance of secured pieces from the enemy's back rank.\"\n    total_distance = 0\n    piece_count = 0\n    for square in board.piece_map():\n        piece = board.piece_at(square)\n        if (piece.color == chess.WHITE and piece.piece_type != chess.KING) or (piece.color == chess.BLACK and piece.piece_type != chess.KING):\n            distance = chess.square_distance(square, chess.parse_square('a8' if piece.color == chess.BLACK else 'h1'))\n            total_distance += distance\n            piece_count += 1\n    return total_distance / piece_count if piece_count > 0 else 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the central control, counting pieces in the center squares (d4, d5, e4, e5).\"\n    center_squares = [chess.parse_square('d4'), chess.parse_square('d5'), chess.parse_square('e4'), chess.parse_square('e5')]\n    white_control = sum(1 for square in center_squares if board.piece_at(square) and board.piece_at(square).color == chess.WHITE)\n    black_control = sum(1 for square in center_squares if board.piece_at(square) and board.piece_at(square).color == chess.BLACK)\n    return float(white_control - black_control)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Evaluates how many pieces are aligned on the same file, indicating potential vertical control.\"\n    file_control = [0] * 8\n    for square in board.piece_map():\n        file_index = chess.square_file(square)\n        file_control[file_index] += 1\n    return float(max(file_control))  # Return maximum pieces on the same file.\n",
    "def feature(board: chess.Board) -> float:\n    'Evaluates the balance of material by counting how many pieces are on the board relative to pawns.'\n    piece_count = len(board.piece_map())\n    pawn_count = sum(1 for square in board.piece_map() if board.piece_map()[square].piece_type == chess.PAWN)\n    return float(piece_count - pawn_count) / max(piece_count, 1)  # Avoid division by zero\n\n",
    "def feature(board: chess.Board) -> float:\n    'Measures the number of pieces pinned by each side.'\n    def count_pins(color):\n        return sum(1 for square in board.piece_map() if board.piece_map()[square].color == color and any(board.is_attacked_by(not color, pin_square) for pin_square in board.attackers(color, square)))\n    white_pins = count_pins(chess.WHITE)\n    black_pins = count_pins(chess.BLACK)\n    return float(white_pins - black_pins)\n\n",
    "def feature(board: chess.Board) -> float:\n    'Measures the number of pieces under attack by the opponent.'\n    under_attack_count = sum(1 for square in board.piece_map() if board.piece_map()[square].color == board.turn and board.is_attacked_by(not board.turn, square))\n    return float(under_attack_count)\n\n",
    "def feature(board: chess.Board) -> float:\n    'Measures the ratio of pieces currently attacking the opponent\\'s pieces to those that are defended.'\n    attacking_pieces = sum(1 for square in board.piece_map() if board.is_attacked_by(chess.WHITE, square) or board.is_attacked_by(chess.BLACK, square))\n    defended_pieces = sum(1 for square in board.piece_map() if len(board.attackers(chess.WHITE, square)) > 0 or len(board.attackers(chess.BLACK, square)) > 0)\n    return float(attacking_pieces) / (defended_pieces + 1e-10)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces that are pinned, indicating potential tactical vulnerabilities.\"\n    pinned_count = 0\n    for square in board.piece_map().keys():\n        piece = board.piece_at(square)\n        if piece and piece.color == board.turn:\n            for attacker in board.attackers(not board.turn, square):\n                if board.is_attacked_by(board.turn, attacker):\n                    pinned_count += 1\n                    break\n    return float(pinned_count)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the number of squares controlled by bishops of each side.\"\n    white_bishop_control = sum(1 for square in range(64) if board.is_attacked_by(chess.WHITE, square) and any(piece.piece_type == chess.BISHOP for piece in board.piece_map().values() if piece.color == chess.WHITE))\n    black_bishop_control = sum(1 for square in range(64) if board.is_attacked_by(chess.BLACK, square) and any(piece.piece_type == chess.BISHOP for piece in board.piece_map().values() if piece.color == chess.BLACK))\n    return float(white_bishop_control - black_bishop_control)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Checks if either side is in check and assigns values accordingly.\"\n    if board.is_check():\n        return -1.0\n    return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in number of advanced pawns for both sides.\"\n    white_advanced_pawns = sum(1 for square in board.piece_map() if board.piece_map()[square].color == chess.WHITE and chess.square_rank(square) >= 4)\n    black_advanced_pawns = sum(1 for square in board.piece_map() if board.piece_map()[square].color == chess.BLACK and chess.square_rank(square) <= 3)\n    return float(white_advanced_pawns - black_advanced_pawns)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of pawns advanced past the fourth rank, indicating aggressive positioning.\"\n    advanced_pawns = 0\n    for square in board.piece_map():\n        piece = board.piece_at(square)\n        if piece is not None and piece.piece_type == chess.PAWN:\n            if (piece.color == chess.WHITE and chess.square_rank(square) > 3) or \\\n               (piece.color == chess.BLACK and chess.square_rank(square) < 4):\n                advanced_pawns += 1\n    return float(advanced_pawns)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the average distance of all pieces from the opponent's back rank.\"\n    white_distance = sum(chess.square_rank(square) for square in board.piece_map() if board.piece_map()[square].color == chess.WHITE) / max(1, len(board.piece_map()))\n    black_distance = sum(7 - chess.square_rank(square) for square in board.piece_map() if board.piece_map()[square].color == chess.BLACK) / max(1, len(board.piece_map()))\n    return float(white_distance - black_distance)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces that are currently pinned, indicating potential tactical vulnerabilities.\"\n    pinned_count = sum(1 for square in board.piece_map() if board.is_attacked_by(not board.turn, square) and len(board.attackers(board.piece_map()[square].color, square)) > 1)\n    return float(pinned_count)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the number of pieces that are pinned against their own king.\"\n    pinned_count = 0\n    for square in board.piece_map():\n        piece = board.piece_at(square)\n        if piece and board.is_attacked_by(board.turn, square):\n            # Check if the piece is pinned\n            if len(board.attackers(not board.turn, square)) > 0:\n                pinned_count += 1\n    return float(pinned_count)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the number of times each side can check the opponent's king in one move.\"\n    white_checks = sum(1 for move in board.legal_moves if board.is_check() and move.to_square in [square for square in board.piece_map() if board.piece_map()[square].color == chess.BLACK and board.is_attacked_by(chess.WHITE, square)])\n    black_checks = sum(1 for move in board.legal_moves if board.is_check() and move.to_square in [square for square in board.piece_map() if board.piece_map()[square].color == chess.WHITE and board.is_attacked_by(chess.BLACK, square)])\n    return float(white_checks - black_checks)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the difference in central pawn control between players.\"\n    central_squares = [chess.D4, chess.D5, chess.E4, chess.E5]\n    white_central_pawns = sum(1 for sq in central_squares if board.piece_at(sq) is not None and board.piece_at(sq).color == chess.WHITE and board.piece_at(sq).piece_type == chess.PAWN)\n    black_central_pawns = sum(1 for sq in central_squares if board.piece_at(sq) is not None and board.piece_at(sq).color == chess.BLACK and board.piece_at(sq).piece_type == chess.PAWN)\n    return float(white_central_pawns - black_central_pawns)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the average position value of all pieces, weighted by their types.\"\n    piece_values = {chess.PAWN: 1.0, chess.KNIGHT: 3.0, chess.BISHOP: 3.0, chess.ROOK: 5.0, chess.QUEEN: 9.0, chess.KING: 0.0}\n    total_value = sum(piece_values[board.piece_at(square).piece_type] for square in board.piece_map() if board.piece_at(square))\n    num_pieces = len(board.piece_map())\n    return total_value / num_pieces if num_pieces > 0 else 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of squares controlled by each side excluding occupied squares.\"\n    controlled_squares_white = {square for square in range(64) if board.is_attacked_by(chess.WHITE, square) and board.piece_at(square) is None}\n    controlled_squares_black = {square for square in range(64) if board.is_attacked_by(chess.BLACK, square) and board.piece_at(square) is None}\n    \n    return float(len(controlled_squares_white) - len(controlled_squares_black))\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Evaluates the average piece activity based on the number of squares controlled.\"\n    piece_activity = 0\n    for square, piece in board.piece_map().items():\n        piece_activity += len(board.attackers(not piece.color, square))\n    return float(piece_activity)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the mobility of major pieces (rooks and queens) for each side.\"\n    white_mobility = sum(len(list(board.legal_moves))\n                        for square in board.piece_map() \n                        if board.piece_map()[square].color == chess.WHITE and \n                        board.piece_map()[square].piece_type in [chess.ROOK, chess.QUEEN])\n    black_mobility = sum(len(list(board.legal_moves))\n                        for square in board.piece_map() \n                        if board.piece_map()[square].color == chess.BLACK and \n                        board.piece_map()[square].piece_type in [chess.ROOK, chess.QUEEN])\n    result = white_mobility - black_mobility\n    return float(result)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the distance of each piece from the opponent's king, indicating pressure.\"\n    white_king_square = next(square for square, piece in board.piece_map().items() if piece.color == chess.WHITE and piece.piece_type == chess.KING)\n    black_king_square = next(square for square, piece in board.piece_map().items() if piece.color == chess.BLACK and piece.piece_type == chess.KING)\n    total_distance = 0\n    \n    for square, piece in board.piece_map().items():\n        if piece.color == chess.WHITE:\n            total_distance += chess.square_distance(square, black_king_square)\n        elif piece.color == chess.BLACK:\n            total_distance -= chess.square_distance(square, white_king_square)\n    \n    return float(total_distance)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the distance to the opponent's king for each piece, reflecting the pressure on the opponent.\"\n    opponent_king_square = next(sq for sq in board.piece_map() if board.piece_at(sq).piece_type == chess.KING and board.piece_at(sq).color != board.turn)\n    total_distance = sum(chess.square_distance(sq, opponent_king_square) for sq in board.piece_map() if board.piece_at(sq).color == board.turn)\n    return 1.0 / (total_distance + 1)  # Adding 1 to avoid division by zero\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the difference in central control by counting pieces in the center squares.\"\n    center_squares = [chess.E4, chess.E5, chess.D4, chess.D5]\n    white_center_control = sum(1 for square in center_squares if board.piece_at(square) and board.piece_at(square).color == chess.WHITE)\n    black_center_control = sum(1 for square in center_squares if board.piece_at(square) and board.piece_at(square).color == chess.BLACK)\n    return float(white_center_control - black_center_control)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the total number of connected pawns for both sides.\"\n    def count_connected_pawns(color):\n        connected = 0\n        pawns = [sq for sq, piece in board.piece_map().items() if piece.color == color and piece.piece_type == chess.PAWN]\n        for sq in pawns:\n            if sq - 1 in pawns or sq + 1 in pawns:\n                connected += 1\n        return connected\n\n    return float(count_connected_pawns(chess.WHITE) - count_connected_pawns(chess.BLACK))\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the potential threats against opponent's king based on proximity.\"\n    king_square = next(square for square, piece in board.piece_map().items() if piece.color != board.turn and piece.piece_type == chess.KING)\n    threats = sum(1 for square, piece in board.piece_map().items() if piece.color == board.turn and chess.square_distance(square, king_square) == 1)\n    return float(threats)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the distance of pieces to each king, indicating threats and potential for checkmate.\"\n    distance_to_king = []\n    king_square = board.king(chess.WHITE) if board.turn == chess.WHITE else board.king(chess.BLACK)\n    for square in board.piece_map():\n        piece = board.piece_at(square)\n        if piece.color == board.turn:\n            distance_to_king.append(chess.square_distance(square, king_square))\n    return float(sum(distance_to_king) / (len(distance_to_king) if distance_to_king else 1))\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures king safety based on the distribution of pawns around each king.\"\n    def king_safety(color):\n        king_square = next(square for square, piece in board.piece_map().items() if piece.color == color and piece.piece_type == chess.KING)\n        safety_value = 0\n        for square in range(64):\n            if board.piece_at(square) and board.piece_at(square).color == color and board.piece_at(square).piece_type == chess.PAWN:\n                distance = chess.square_distance(king_square, square)\n                safety_value += max(0, (3 - distance))\n        return safety_value\n\n    white_safety = king_safety(chess.WHITE)\n    black_safety = king_safety(chess.BLACK)\n    return float(white_safety - black_safety)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the total piece activity by measuring the number of legal moves available for each side.\"\n    white_legal_moves = len(list(board.legal_moves)) \n    black_legal_moves = len(list(board.legal_moves))\n    \n    return float(white_legal_moves - black_legal_moves)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the difference in total piece value lost due to attacks.\"\n    material_values = {\n        chess.PAWN: 1,\n        chess.KNIGHT: 3,\n        chess.BISHOP: 3,\n        chess.ROOK: 5,\n        chess.QUEEN: 9,\n        chess.KING: 0\n    }\n    \n    def lost_material(color):\n        loss_value = 0\n        for square, piece in board.piece_map().items():\n            if piece.color == color and board.is_attacked_by(not color, square):\n                loss_value += material_values[piece.piece_type]\n        return loss_value\n    \n    white_loss = lost_material(chess.WHITE)\n    black_loss = lost_material(chess.BLACK)\n    return float(black_loss - white_loss)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Evaluates the number of squares left unoccupied for pawns to potentially promote.\"\n    white_pawn_promotable = sum(1 for sq in board.piece_map() if board.piece_map()[sq].piece_type == chess.PAWN and board.piece_map()[sq].color == chess.WHITE and chess.square_rank(sq) == 6)\n    black_pawn_promotable = sum(1 for sq in board.piece_map() if board.piece_map()[sq].piece_type == chess.PAWN and board.piece_map()[sq].color == chess.BLACK and chess.square_rank(sq) == 1)\n    return float(white_pawn_promotable - black_pawn_promotable)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of backward pawns for both sides.\"\n    backward_pawn_count = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == board.turn and piece.piece_type == chess.PAWN:\n            rank = chess.square_rank(square)\n            if rank < 7 and not (board.piece_at(chess.square(chess.square_file(square), rank + 1)) is None or \n                                 board.piece_at(chess.square(chess.square_file(square) - 1, rank + 1)) is None or \n                                 board.piece_at(chess.square(chess.square_file(square) + 1, rank + 1)) is None):\n                backward_pawn_count += 1\n    return float(backward_pawn_count)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the king's safety based on the number of pieces defending it.\"\n    king_square = next(square for square, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color == board.turn)\n    defending_pieces = sum(1 for square in board.piece_map() if board.piece_map()[square].color == board.turn \n                           and square in board.attackers(not board.turn, king_square))\n    return float(defending_pieces)\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the ratio of bishops to knights for both players, assessing piece coordination and control.\"\n    white_bishops = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE and piece.piece_type == chess.BISHOP)\n    black_bishops = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK and piece.piece_type == chess.BISHOP)\n    return float(white_bishops - black_bishops)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Evaluates the number of pieces that are actively contributing to the attack for both sides.\"\n    attacking_pieces = 0\n    for square, piece in board.piece_map().items():\n        attack_moves = sum(1 for move in board.legal_moves if move.from_square == square)\n        if attack_moves > 0:\n            attacking_pieces += 1 if piece.color == chess.WHITE else -1\n    return float(attacking_pieces)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the number of squares controlled by each side.\"\n    controlled_squares = {chess.WHITE: set(), chess.BLACK: set()}\n    \n    for square in range(64):\n        if board.is_attacked_by(chess.WHITE, square):\n            controlled_squares[chess.WHITE].add(square)\n        if board.is_attacked_by(chess.BLACK, square):\n            controlled_squares[chess.BLACK].add(square)\n    \n    result = len(controlled_squares[chess.WHITE]) - len(controlled_squares[chess.BLACK])\n    return float(result)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the number of pieces on the last rank for each side.\"\n    white_last_rank_pieces = sum(1 for square in board.piece_map() if board.piece_map()[square].color == chess.WHITE and chess.square_rank(square) == 7)\n    black_last_rank_pieces = sum(1 for square in board.piece_map() if board.piece_map()[square].color == chess.BLACK and chess.square_rank(square) == 0)\n    return float(white_last_rank_pieces - black_last_rank_pieces)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the total number of pieces on the board, providing a sense of material density.\"\n    return float(len(board.piece_map()))\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in the number of knights controlling the center squares.\"\n    center_squares = {chess.D4, chess.D5, chess.E4, chess.E5}\n    def knight_control(color):\n        control_count = sum(1 for square in board.piece_map() if board.piece_map()[square].color == color and \n                            board.piece_map()[square].piece_type == chess.KNIGHT and \n                            any(chess.square_distance(square, center) == 1 for center in center_squares))\n        return control_count\n\n    white_knights = knight_control(chess.WHITE)\n    black_knights = knight_control(chess.BLACK)\n    return float(white_knights - black_knights)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the number of isolated pawns for each color.\"\n    white_isolated = sum(1 for sq, piece in board.piece_map().items() \n                          if piece.color == chess.WHITE and piece.piece_type == chess.PAWN and \n                          not (board.is_attacked_by(chess.BLACK, sq - 1) or board.is_attacked_by(chess.BLACK, sq + 1)))\n    black_isolated = sum(1 for sq, piece in board.piece_map().items() \n                         if piece.color == chess.BLACK and piece.piece_type == chess.PAWN and \n                         not (board.is_attacked_by(chess.WHITE, sq - 1) or board.is_attacked_by(chess.WHITE, sq + 1)))\n    return float(white_isolated - black_isolated)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of attacked squares by each player's pieces.\"\n    white_attacks = sum(board.is_attacked_by(chess.WHITE, square) for square in chess.SQUARES)\n    black_attacks = sum(board.is_attacked_by(chess.BLACK, square) for square in chess.SQUARES)\n    return float(white_attacks - black_attacks)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of moves each side has in the current position.\"\n    white_moves = len(list(board.legal_moves)) if board.turn == chess.WHITE else 0\n    black_moves = len(list(board.legal_moves)) if board.turn == chess.BLACK else 0\n    return float(white_moves - black_moves)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the total distance of all pieces from their respective best squares.\"\n    distance = 0\n    for sq, piece in board.piece_map().items():\n        best_pos = piece.piece_type - 1  # Simplified logic for where each type of piece wants to go\n        distance += chess.square_distance(sq, best_pos)\n    return float(distance)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the edge piece mobility by counting pieces on the a and h files.\"\n    white_edge_pieces = sum(1 for square in board.piece_map() if board.piece_map()[square].color == chess.WHITE and chess.square_file(square) in (0, 7))\n    black_edge_pieces = sum(1 for square in board.piece_map() if board.piece_map()[square].color == chess.BLACK and chess.square_file(square) in (0, 7))\n    return float(white_edge_pieces - black_edge_pieces)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of doubled pawns for each side.\"\n    white_doubled_pawns = sum(1 for file in range(8) if sum(1 for rank in range(8) if board.piece_at(chess.square(file, rank)) == chess.PAWN and board.piece_at(chess.square(file, rank)).color == chess.WHITE) > 1)\n    black_doubled_pawns = sum(1 for file in range(8) if sum(1 for rank in range(8) if board.piece_at(chess.square(file, rank)) == chess.PAWN and board.piece_at(chess.square(file, rank)).color == chess.BLACK) > 1)\n    return float(white_doubled_pawns - black_doubled_pawns)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Evaluates the imbalance in material due to missing high-value pieces.\"\n    material_values = {\n        chess.PAWN: 1,\n        chess.KNIGHT: 3,\n        chess.BISHOP: 3,\n        chess.ROOK: 5,\n        chess.QUEEN: 9,\n        chess.KING: 0\n    }\n    white_high_value = sum(material_values[piece.piece_type] for piece in board.piece_map().values() if piece.color == chess.WHITE and piece.piece_type in [chess.ROOK, chess.QUEEN])\n    black_high_value = sum(material_values[piece.piece_type] for piece in board.piece_map().values() if piece.color == chess.BLACK and piece.piece_type in [chess.ROOK, chess.QUEEN])\n    return float(white_high_value - black_high_value)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the knight activity based on control of the central squares.\"\n    knight_control = sum(1 for square in board.piece_map() if board.piece_map()[square].piece_type == chess.KNIGHT and board.piece_map()[square].color == board.turn)\n    central_squares = [chess.D4, chess.D5, chess.E4, chess.E5]\n    return float(sum(1 for square in central_squares if square in board.attackers(board.turn, square))) * knight_control\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of pawn-promoting squares each side has access to.\"\n    def promotion_squares(color):\n        return sum(1 for square in range(0, 8) if board.piece_at(square) == chess.PAWN and board.piece_map()[square].color == color)\n\n    white_promotions = promotion_squares(chess.WHITE)\n    black_promotions = promotion_squares(chess.BLACK)\n    return float(white_promotions - black_promotions)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the sum of the values of pieces that are currently pinned.\"\n    material_values = {\n        chess.PAWN: 1,\n        chess.KNIGHT: 3,\n        chess.BISHOP: 3,\n        chess.ROOK: 5,\n        chess.QUEEN: 9,\n        chess.KING: 0\n    }\n    pinned_value = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == board.turn and board.is_attacked_by(not board.turn, square):\n            pinned_value += material_values.get(piece.piece_type, 0)\n    return float(pinned_value)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the ratio of the active pieces to the total pieces for both sides.\"\n    total_pieces = len(board.piece_map())\n    active_pieces = sum(1 for move in board.legal_moves)\n    \n    if total_pieces == 0:\n        return 0.0\n    \n    return float(active_pieces / total_pieces)\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the mobility of pieces based on the number of legal moves available.\"\n    white_mobility = sum(1 for move in board.legal_moves if board.piece_at(move.from_square) and board.piece_at(move.from_square).color == chess.WHITE)\n    black_mobility = sum(1 for move in board.legal_moves if board.piece_at(move.from_square) and board.piece_at(move.from_square).color == chess.BLACK)\n    return float(white_mobility - black_mobility)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the number of passed pawns for each side.\"\n    def count_passed_pawns(color):\n        passed_count = 0\n        for square, piece in board.piece_map().items():\n            if piece.color == color and piece.piece_type == chess.PAWN:\n                file = chess.square_file(square)\n                is_passed = True\n                for enemy_square in range(0, 8):\n                    if (color == chess.WHITE and enemy_square < chess.square_rank(square)) or (color == chess.BLACK and enemy_square > chess.square_rank(square)):\n                        if board.piece_at(chess.square(file, enemy_square)) and board.piece_at(chess.square(file, enemy_square)).color != color:\n                            is_passed = False\n                            break\n                if is_passed:\n                    passed_count += 1\n        return passed_count\n\n    white_passed = count_passed_pawns(chess.WHITE)\n    black_passed = count_passed_pawns(chess.BLACK)\n    return float(white_passed - black_passed)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the number of squares attacked by both sides to reflect control over the board.\"\n    white_attacks = len([square for square in board.piece_map() if board.is_attacked_by(chess.WHITE, square)])\n    black_attacks = len([square for square in board.piece_map() if board.is_attacked_by(chess.BLACK, square)])\n    return float(white_attacks - black_attacks)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces that are controlling lines or diagonals (ranks, files, and diagonals).\"\n    def count_controlled_lines(color):\n        control_count = 0\n        for square in board.piece_map():\n            if board.piece_at(square).color == color:\n                if board.is_attacked_by(color, square):\n                    control_count += 1\n        return control_count\n    return float(count_controlled_lines(chess.WHITE) - count_controlled_lines(chess.BLACK))\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the ratio of the pieces present in the two halves of the board.\"\n    white_in_half = sum(1 for sq in board.piece_map() if board.piece_at(sq).color == chess.WHITE and chess.square_file(sq) < 4)\n    black_in_half = sum(1 for sq in board.piece_map() if board.piece_at(sq).color == chess.BLACK and chess.square_file(sq) < 4)\n    return float(white_in_half - black_in_half)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Checks the number of attacking configurations with respect to each player's pieces.\"\n    white_attacking_configs = sum(1 for move in board.legal_moves if board.is_attacked_by(chess.WHITE, move.to_square))\n    black_attacking_configs = sum(1 for move in board.legal_moves if board.is_attacked_by(chess.BLACK, move.to_square))\n    return float(white_attacking_configs - black_attacking_configs)\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the central control based on pieces in central squares.\"\n    central_squares = [chess.E4, chess.E5, chess.D4, chess.D5]\n    white_control = sum(1 for square in central_squares if board.is_attacked_by(chess.WHITE, square))\n    black_control = sum(1 for square in central_squares if board.is_attacked_by(chess.BLACK, square))\n    return float(white_control - black_control)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the mobility difference based on the number of legal moves available to each side.\"\n    white_mobility = len(list(board.legal_moves)) if board.turn == chess.WHITE else len(list(board.legal_moves))  # Current turn\n    black_mobility = len(list(board.legal_moves)) if board.turn == chess.BLACK else len(list(board.legal_moves))  # Current turn\n    return float(white_mobility - black_mobility)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the pawn structure's integrity through doubled pawns.\"\n    white_doubled_pawns = sum(1 for file in range(8) if sum(1 for rank in range(8) if board.piece_at(chess.parse_square(f'{chr(97 + file)}{rank + 1}') ) and board.piece_at(chess.parse_square(f'{chr(97 + file)}{rank + 1}') ).color == chess.WHITE) > 1)\n    black_doubled_pawns = sum(1 for file in range(8) if sum(1 for rank in range(8) if board.piece_at(chess.parse_square(f'{chr(97 + file)}{rank + 1}') ) and board.piece_at(chess.parse_square(f'{chr(97 + file)}{rank + 1}') ).color == chess.BLACK) > 1)\n    return float(black_doubled_pawns - white_doubled_pawns)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Checks the status of key pieces to determine relative strength of each player's setup.\"\n    key_piece_status = {\n        chess.QUEEN: 0,\n        chess.ROOK: 1,\n        chess.BISHOP: 2,\n        chess.KNIGHT: 3\n    }\n    \n    def calculate_key_piece_strength(color):\n        strength = 0\n        for piece in board.piece_map().values():\n            if piece.color == color and piece.piece_type in key_piece_status:\n                strength += 1\n        return strength\n\n    white_strength = calculate_key_piece_strength(chess.WHITE)\n    black_strength = calculate_key_piece_strength(chess.BLACK)\n    return float(white_strength - black_strength)\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the mobility of major pieces (rooks and queens) for each side.\"\n    white_major_mobility = sum(len([move for move in board.legal_moves if move.from_square == square]) \n                                for square in board.piece_map() if board.piece_map()[square].color == chess.WHITE and \n                                board.piece_map()[square].piece_type in {chess.ROOK, chess.QUEEN})\n    black_major_mobility = sum(len([move for move in board.legal_moves if move.from_square == square]) \n                                for square in board.piece_map() if board.piece_map()[square].color == chess.BLACK and \n                                board.piece_map()[square].piece_type in {chess.ROOK, chess.QUEEN})\n    return float(white_major_mobility - black_major_mobility)\n\n",
    "def feature(board: chess.Board) -> float:\n    'Calculates the difference in pawn structure between white and black.'\n    white_pawn_structure = len([square for square in board.piece_map() \n                                 if board.piece_at(square).piece_type == chess.PAWN \n                                 and board.piece_at(square).color == chess.WHITE \n                                 and chess.square_rank(square) >= 4])\n    black_pawn_structure = len([square for square in board.piece_map() \n                                 if board.piece_at(square).piece_type == chess.PAWN \n                                 and board.piece_at(square).color == chess.BLACK \n                                 and chess.square_rank(square) >= 4])\n    return float(white_pawn_structure - black_pawn_structure)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the total number of pawns each player has that are not blocked (pawns that can advance).\"\n    unblockable_pawns = sum(1 for square in board.piece_map() if board.piece_map()[square].piece_type == chess.PAWN and \n                            ((board.piece_map()[square].color == chess.WHITE and \n                             board.piece_at(square + 8) is None) or \n                             (board.piece_map()[square].color == chess.BLACK and \n                             board.piece_at(square - 8) is None)))\n    return float(unblockable_pawns)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the number of controlling pieces versus defending pieces on critical squares.\"\n    critical_squares = [chess.E4, chess.D4, chess.E5, chess.D5]\n    white_control = sum(1 for square in critical_squares if board.is_attacked_by(chess.WHITE, square))\n    black_control = sum(1 for square in critical_squares if board.is_attacked_by(chess.BLACK, square))\n    return float(white_control - black_control)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Assesses king safety by counting the number of squares around kings that are attacked.\"\n    white_king_square = next(sq for sq, piece in board.piece_map().items() if piece.color == chess.WHITE and piece.piece_type == chess.KING)\n    black_king_square = next(sq for sq, piece in board.piece_map().items() if piece.color == chess.BLACK and piece.piece_type == chess.KING)\n    white_king_threats = sum(1 for sq in chess.SQUARES if board.is_attacked_by(chess.BLACK, sq) and chess.square_distance(sq, white_king_square) <= 1)\n    black_king_threats = sum(1 for sq in chess.SQUARES if board.is_attacked_by(chess.WHITE, sq) and chess.square_distance(sq, black_king_square) <= 1)\n    return float(white_king_threats - black_king_threats)\n",
    "def feature(board: chess.Board) -> float:\n    \"Evaluates the number of threats posed by the current player's pieces.\"\n    threats_count = sum(1 for square in board.piece_map() if board.piece_map()[square].color == board.turn and len(list(board.attackers(not board.turn, square))) > 0)\n    return float(threats_count)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the safety of kings by assessing available escape squares.\"\n    def king_safety(color):\n        king_square = next(square for square, piece in board.piece_map().items() if piece.color == color and piece.piece_type == chess.KING)\n        return sum(1 for move in board.legal_moves if chess.square_distance(king_square, move.to_square) == 1)\n    white_safety = king_safety(chess.WHITE)\n    black_safety = king_safety(chess.BLACK)\n    return float(white_safety - black_safety)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of pawns on the fifth rank or higher, indicating advanced pawn structure.\"\n    advanced_pawns = sum(1 for square in board.piece_map() if board.piece_at(square).piece_type == chess.PAWN and chess.square_rank(square) >= 4)\n    return float(advanced_pawns)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the number of pieces each player has on the eighth and first ranks.\"\n    major_rank_count = 0\n    for square in [chess.A8, chess.B8, chess.C8, chess.D8, chess.E8, chess.F8, chess.G8, chess.H8,\n                   chess.A1, chess.B1, chess.C1, chess.D1, chess.E1, chess.F1, chess.G1, chess.H1]:\n        piece = board.piece_at(square)\n        if piece:\n            major_rank_count += 1\n    return float(major_rank_count)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in mobility of the pieces for both players.\"\n    white_mobility = sum(len(list(board.legal_moves)) for square in board.piece_map() if board.piece_map()[square].color == chess.WHITE)\n    black_mobility = sum(len(list(board.legal_moves)) for square in board.piece_map() if board.piece_map()[square].color == chess.BLACK)\n    return float(white_mobility - black_mobility)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the distance of the king from the center for each side.\"\n    white_king_square = next(square for square, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color == chess.WHITE)\n    black_king_square = next(square for square, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color == chess.BLACK)\n\n    white_king_distance = abs(chess.square_file(white_king_square) - 3.5) + abs(chess.square_rank(white_king_square) - 3.5)\n    black_king_distance = abs(chess.square_file(black_king_square) - 3.5) + abs(chess.square_rank(black_king_square) - 3.5)\n    \n    return float(black_king_distance - white_king_distance)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the ratio of rooks to total pieces for each player.\"\n    white_rooks = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE and piece.piece_type == chess.ROOK)\n    black_rooks = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK and piece.piece_type == chess.ROOK)\n    total_white = len([piece for piece in board.piece_map().values() if piece.color == chess.WHITE])\n    total_black = len([piece for piece in board.piece_map().values() if piece.color == chess.BLACK])\n    ratio_white = white_rooks / total_white if total_white > 0 else 0.0\n    ratio_black = black_rooks / total_black if total_black > 0 else 0.0\n    result = ratio_white - ratio_black\n    return float(result)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the number of back rank threats for each side.\"\n    white_back_rank_threats = sum(1 for square in chess.SQUARES_180 if board.is_attacked_by(chess.BLACK, square) and (chess.square_rank(square) == 0))\n    black_back_rank_threats = sum(1 for square in chess.SQUARES_180 if board.is_attacked_by(chess.WHITE, square) and (chess.square_rank(square) == 7))\n    return float(white_back_rank_threats - black_back_rank_threats)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of hanging pieces for each side.\"\n    hanging_white = sum(1 for square in board.piece_map() if board.piece_map()[square].color == chess.WHITE and \n                         not any(board.is_attacked_by(chess.BLACK, square) for move in board.legal_moves if move.from_square == square))\n    hanging_black = sum(1 for square in board.piece_map() if board.piece_map()[square].color == chess.BLACK and \n                         not any(board.is_attacked_by(chess.WHITE, square) for move in board.legal_moves if move.from_square == square))\n    return float(hanging_white - hanging_black)\n\n",
    "def feature(board: chess.Board) -> float:\n    'Measures the number of major pieces (rook and queen) remaining for each side.'\n    major_pieces_white = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE and piece.piece_type in {chess.ROOK, chess.QUEEN})\n    major_pieces_black = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK and piece.piece_type in {chess.ROOK, chess.QUEEN})\n    return float(major_pieces_white - major_pieces_black)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the number of squares controlled by each side on the opponent's side of the board.\"\n    white_control = sum(1 for square in range(32, 64) if board.is_attacked_by(chess.WHITE, square))\n    black_control = sum(1 for square in range(0, 32) if board.is_attacked_by(chess.BLACK, square))\n    return float(white_control - black_control)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the degree of piece development (pieces moved off the back row).\"\n    developed_white = sum(1 for square in range(8, 16) \n                          if board.piece_at(square) and board.piece_at(square).color == chess.WHITE)\n    developed_black = sum(1 for square in range(48, 56) \n                          if board.piece_at(square) and board.piece_at(square).color == chess.BLACK)\n    return float(developed_white - developed_black)\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of developed pieces for each side, excluding the pawns.\"\n    developed_pieces_count = sum(1 for square, piece in board.piece_map().items() \n                                  if piece.color == board.turn and piece.piece_type in \n                                  {chess.KNIGHT, chess.BISHOP, chess.ROOK, chess.QUEEN} and \n                                  (chess.square_rank(square) > 0 if piece.color == chess.WHITE else chess.square_rank(square) < 7))\n    return float(developed_pieces_count)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Assesses the presence of passed pawns for both sides, as an indicator of endgame potential.\"\n    white_passed = sum(1 for sq in chess.SQUARES if board.piece_at(sq) and board.piece_at(sq).color == chess.WHITE and \n                        all(board.piece_at(square) is None or board.piece_at(square).color == chess.WHITE for square in board.attacks(sq))) \n    black_passed = sum(1 for sq in chess.SQUARES if board.piece_at(sq) and board.piece_at(sq).color == chess.BLACK and \n                        all(board.piece_at(square) is None or board.piece_at(square).color == chess.BLACK for square in board.attacks(sq)))\n    return float(white_passed - black_passed)\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures mobility by counting the number of legal moves for both players.\"\n    white_moves = len(list(board.legal_moves) if board.turn else [])\n    board.turn = not board.turn  # Switch turn for black moves\n    black_moves = len(list(board.legal_moves))\n    board.turn = not board.turn  # Revert turn\n    \n    return float(white_moves - black_moves)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the number of pawns on the 2nd rank for White and the 7th rank for Black.\"\n    white_pawns_on_rank = sum(1 for square in range(8, 16) if board.piece_at(square) and board.piece_at(square).color == chess.WHITE)\n    black_pawns_on_rank = sum(1 for square in range(48, 56) if board.piece_at(square) and board.piece_at(square).color == chess.BLACK)\n    return float(white_pawns_on_rank - black_pawns_on_rank)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the difference in the number of pieces that can move to the opponent's back rank.\"\n    def back_rank_threats(color):\n        return sum(1 for square in range(8) if board.is_attacked_by(color, chess.square(square, 0 if color == chess.WHITE else 7)))\n\n    white_threats = back_rank_threats(chess.WHITE)\n    black_threats = back_rank_threats(chess.BLACK)\n    return float(white_threats - black_threats)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the number of squares where each side has a rook that influences the center.\"\n    rook_squares = [chess.A4, chess.B4, chess.C4, chess.D4, chess.E4, chess.F4, chess.G4, chess.H4,\n                    chess.A5, chess.B5, chess.C5, chess.D5, chess.E5, chess.F5, chess.G5, chess.H5]\n    white_rook_control = sum(1 for square in board.piece_map() if board.piece_at(square).color == chess.WHITE and board.piece_at(square).piece_type == chess.ROOK and any(board.is_attacked_by(chess.BLACK, sq) for sq in rook_squares))\n    black_rook_control = sum(1 for square in board.piece_map() if board.piece_at(square).color == chess.BLACK and board.piece_at(square).piece_type == chess.ROOK and any(board.is_attacked_by(chess.WHITE, sq) for sq in rook_squares))\n    result = float(white_rook_control - black_rook_control)\n    return result\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the number of potential future threats by counting pieces that can attack the opponent's king.\"\n    threats_to_king = len([1 for square in chess.SQUARES if board.is_attacked_by(not board.turn, square) and board.piece_at(square) is not None])\n    return float(threats_to_king)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the number of doubled pawns for each side.\"\n    def doubled_pawns(color):\n        pawns = [square for square, piece in board.piece_map().items() if piece.color == color and piece.piece_type == chess.PAWN]\n        files = [chess.square_file(pawn) for pawn in pawns]\n        return len(files) - len(set(files))\n\n    white_doubled = doubled_pawns(chess.WHITE)\n    black_doubled = doubled_pawns(chess.BLACK)\n    return float(white_doubled - black_doubled)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the king safety for each player by counting how many pawns protect their king.\"\n    white_king_square = board.king(chess.WHITE)\n    black_king_square = board.king(chess.BLACK)\n    white_protected = sum(1 for square in board.piece_map() if board.piece_at(square).piece_type == chess.PAWN and board.is_attacked_by(chess.BLACK, square) and chess.square_distance(square, white_king_square) <= 1)\n    black_protected = sum(1 for square in board.piece_map() if board.piece_at(square).piece_type == chess.PAWN and board.is_attacked_by(chess.WHITE, square) and chess.square_distance(square, black_king_square) <= 1)\n    return float(white_protected - black_protected)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the average distance from each piece to the opposite king.\"\n    king_white = next(sq for sq, piece in board.piece_map().items() if piece.color == chess.WHITE and piece.piece_type == chess.KING)\n    king_black = next(sq for sq, piece in board.piece_map().items() if piece.color == chess.BLACK and piece.piece_type == chess.KING)\n    \n    total_distance = sum(chess.square_distance(sq, king_black) for sq, piece in board.piece_map().items() if piece.color == chess.WHITE)\n    total_distance += sum(chess.square_distance(sq, king_white) for sq, piece in board.piece_map().items() if piece.color == chess.BLACK)\n    total_pieces = len(board.piece_map().keys())\n    return total_distance / max(1, total_pieces)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Determines the number of double threats made by both sides, illustrating offensive capabilities.\"\n    double_threats = 0.0\n    for square in board.piece_map():\n        if board.is_attacked_by(board.turn, square) and len(board.attackers(board.turn, square)) > 1:\n            double_threats += 1.0\n    return double_threats\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the initiative based on the number of available checks.\"\n    white_checks = sum(1 for move in board.legal_moves if board.gives_check(move))\n    black_checks = sum(1 for move in board.legal_moves if not board.gives_check(move))\n    return float(white_checks - black_checks)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the average distance of pieces from the opponent's back rank to indicate offensive positioning.\"\n    def average_distance(color):\n        total_distance = 0\n        count = 0\n        for square in board.piece_map():\n            piece = board.piece_map()[square]\n            if piece.color == color:\n                distance = chess.square_distance(square, 0 if color == chess.BLACK else 56)\n                total_distance += distance\n                count += 1\n        return total_distance / count if count > 0 else 0\n    \n    white_avg_distance = average_distance(chess.WHITE)\n    black_avg_distance = average_distance(chess.BLACK)\n    result = white_avg_distance - black_avg_distance\n    return float(result)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the control of the corners of the board by each player.\"\n    corner_squares = [chess.A1, chess.A8, chess.H1, chess.H8]\n    white_corners = sum(1 for square in corner_squares if board.piece_at(square) and board.piece_at(square).color == chess.WHITE)\n    black_corners = sum(1 for square in corner_squares if board.piece_at(square) and board.piece_at(square).color == chess.BLACK)\n    result = float(white_corners - black_corners)\n    return result\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in material considering only high-value pieces remaining on the board.\"\n    high_value_material = {\n        chess.KNIGHT: 3,\n        chess.BISHOP: 3,\n        chess.ROOK: 5,\n        chess.QUEEN: 9,\n        chess.KING: 0\n    }\n    white_high_value = sum(high_value_material[piece.piece_type] for piece in board.piece_map().values() if piece.color == chess.WHITE and piece.piece_type in high_value_material)\n    black_high_value = sum(high_value_material[piece.piece_type] for piece in board.piece_map().values() if piece.color == chess.BLACK and piece.piece_type in high_value_material)\n    return float(white_high_value - black_high_value)\n",
    "def feature(board: chess.Board) -> float:\n    'Measures the potential to create a passed pawn by counting pawns that have no opposing pawns in front of them.'\n    def passed_pawns(color):\n        return sum(1 for square in board.piece_map() if (board.piece_map()[square].color == color and \n            (color == chess.WHITE and square in range(chess.A5, chess.H8)) or \n            (color == chess.BLACK and square in range(chess.A2, chess.H5)) and \n            not (board.piece_at(square + 8) if color == chess.WHITE else board.piece_at(square - 8) if square >= 8 else None)))\n\n    white_passed = passed_pawns(chess.WHITE)\n    black_passed = passed_pawns(chess.BLACK)\n    return float(white_passed - black_passed)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the total number of legal moves available to both players.\"\n    legal_moves_white = len(list(board.legal_moves)) if board.turn else 0\n    legal_moves_black = len(list(board.legal_moves)) if not board.turn else 0\n    return float(legal_moves_white - legal_moves_black)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Evaluates the coordination of pieces attacking the same target.\"\n    attacking_pairs = 0\n    for square in range(64):\n        if board.is_attacked_by(chess.WHITE, square) and board.is_attacked_by(chess.BLACK, square):\n            attacking_pairs += len(board.attackers(chess.WHITE, square)) + len(board.attackers(chess.BLACK, square))\n    return float(attacking_pairs)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the potential for pawn promotion by counting advanced pawns near the 7th rank.\"\n    advanced_promotions = sum(1 for square in chess.SQUARES if board.piece_at(square) and board.piece_at(square).color == board.turn and chess.square_rank(square) == 6)\n    return float(advanced_promotions)\n\n",
    "def feature(board: chess.Board) -> float:\n    'Calculates the number of passive pieces for each color, which are not defending or attacking any piece.'\n    passive_white = sum(1 for square in board.piece_map() if board.piece_map()[square].color == chess.WHITE and not any(board.is_attacked_by(chess.BLACK, square) for move in board.legal_moves if move.from_square == square))\n    passive_black = sum(1 for square in board.piece_map() if board.piece_map()[square].color == chess.BLACK and not any(board.is_attacked_by(chess.WHITE, square) for move in board.legal_moves if move.from_square == square))\n    return float(passive_white - passive_black)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the mobility advantage based on the number of legal moves.\"\n    white_moves = len(list(board.legal_moves)) if board.turn == chess.WHITE else len(list(board.legal_moves))\n    black_moves = len(list(board.legal_moves)) if board.turn == chess.BLACK else len(list(board.legal_moves))\n    return float(white_moves - black_moves)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of minor pieces (knights and bishops) each side has.\"\n    minor_white = sum(1 for p in board.piece_map().values() if p.color == chess.WHITE and p.piece_type in [chess.KNIGHT, chess.BISHOP])\n    minor_black = sum(1 for p in board.piece_map().values() if p.color == chess.BLACK and p.piece_type in [chess.KNIGHT, chess.BISHOP])\n    return float(minor_white - minor_black)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in the average rank of pawns for both sides.\"\n    def average_pawn_rank(color):\n        pawns = [chess.square_rank(square) for square in board.piece_map() if board.piece_map()[square].color == color and board.piece_map()[square].piece_type == chess.PAWN]\n        return sum(pawns) / len(pawns) if pawns else 0\n    \n    white_pawn_avg = average_pawn_rank(chess.WHITE)\n    black_pawn_avg = average_pawn_rank(chess.BLACK)\n    return float(white_pawn_avg - black_pawn_avg)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures how many pieces each player has supported by another piece.\"\n    white_support = sum(1 for sq in board.piece_map() if board.piece_map()[sq].color == chess.WHITE and any(board.is_attacked_by(chess.WHITE, sq) for sq in board.attackers(chess.BLACK, sq)))\n    black_support = sum(1 for sq in board.piece_map() if board.piece_map()[sq].color == chess.BLACK and any(board.is_attacked_by(chess.BLACK, sq) for sq in board.attackers(chess.WHITE, sq)))\n    return float(white_support - black_support)\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the distance of each side's pawns to the opponent's back rank, emphasizing advancement.\"\n    def pawn_distance(color):\n        total_distance = 0\n        for square in board.piece_map():\n            if board.piece_map()[square].color == color and board.piece_map()[square].piece_type == chess.PAWN:\n                if color == chess.WHITE:\n                    total_distance += chess.square_rank(square)  # Distance to rank 8\n                else:\n                    total_distance += 7 - chess.square_rank(square)  # Distance to rank 1\n        return total_distance\n\n    white_distance = pawn_distance(chess.WHITE)\n    black_distance = pawn_distance(chess.BLACK)\n    return float(white_distance - black_distance)\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in the number of pawns each player has.\"\n    white_pawns = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE and piece.piece_type == chess.PAWN)\n    black_pawns = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK and piece.piece_type == chess.PAWN)\n    return float(white_pawns - black_pawns)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Detects if there is a potential of a back rank checkmate.\"\n    if board.is_checkmate():\n        return 0.0\n    white_back_rank_checkmate = any(board.is_attacked_by(chess.BLACK, square) for square in range(56, 64) if board.piece_at(square) and board.piece_at(square).color == chess.WHITE)\n    black_back_rank_checkmate = any(board.is_attacked_by(chess.WHITE, square) for square in range(0, 8) if board.piece_at(square) and board.piece_at(square).color == chess.BLACK)\n    return float(white_back_rank_checkmate - black_back_rank_checkmate)\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of unoccupied squares to gauge space control.\"\n    empty_squares = sum(1 for square in chess.SQUARES if board.piece_at(square) is None)\n    return float(empty_squares)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the distance of each king to the center of the board.\"\n    white_king_square = next((square for square in chess.SQUARES if board.piece_at(square) and board.piece_at(square).piece_type == chess.KING and board.piece_at(square).color == chess.WHITE), None)\n    black_king_square = next((square for square in chess.SQUARES if board.piece_at(square) and board.piece_at(square).piece_type == chess.KING and board.piece_at(square).color == chess.BLACK), None)\n    if white_king_square is not None and black_king_square is not None:\n        white_distance = chess.square_distance(white_king_square, chess.square(4, 4))\n        black_distance = chess.square_distance(black_king_square, chess.square(4, 4))\n        return float(white_distance - black_distance)\n    return 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the average distance of pieces from the opponent's back rank.\"\n    total_distance = 0\n    total_pieces = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == chess.WHITE:\n            total_distance += chess.square_rank(square)  # How many ranks away from black's back rank (row 0)\n            total_pieces += 1\n    return total_distance / total_pieces if total_pieces > 0 else 0.0\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the number of pieces that are attacking the opponent's king.\"\n    king_square = board.king(chess.WHITE) if board.turn else board.king(chess.BLACK)\n    attackers_count = len(board.attackers(chess.WHITE if board.turn else chess.BLACK, king_square))\n    return float(attackers_count)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of squares controlled by each side's pieces.\"\n    white_controlled_squares = sum(1 for square in chess.SQUARES if board.is_attacked_by(chess.WHITE, square))\n    black_controlled_squares = sum(1 for square in chess.SQUARES if board.is_attacked_by(chess.BLACK, square))\n    return float(white_controlled_squares - black_controlled_squares)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the distance of each player's pieces from their respective home ranks.\"\n    distance_score = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == chess.WHITE:\n            distance_score += chess.square_rank(square)  # Closer to home is better\n        else:\n            distance_score -= chess.square_rank(square)  # Closer to home is worse\n    return float(distance_score)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the percentage of pieces that are on their starting squares for both sides.\"\n    starting_positions = {\n        chess.WHITE: {chess.A2, chess.B2, chess.C2, chess.D2, chess.E2, chess.F2, chess.G2, chess.H2, chess.A1, chess.B1, chess.C1, chess.D1, chess.E1, chess.F1, chess.G1, chess.H1},\n        chess.BLACK: {chess.A7, chess.B7, chess.C7, chess.D7, chess.E7, chess.F7, chess.G7, chess.H7, chess.A8, chess.B8, chess.C8, chess.D8, chess.E8, chess.F8, chess.G8, chess.H8}\n    }\n    on_starting_sq = {\n        chess.WHITE: sum(1 for sq in starting_positions[chess.WHITE] if board.piece_at(sq) is not None),\n        chess.BLACK: sum(1 for sq in starting_positions[chess.BLACK] if board.piece_at(sq) is not None)\n    }\n    total_on_starting_squares = on_starting_sq[chess.WHITE] + on_starting_sq[chess.BLACK]\n    return float(total_on_starting_squares) / (16.0 if total_on_starting_squares else 1)  # Normalizing to maximum possible pieces\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the disparity in the number of pieces each side has on the 7th and 8th ranks.\"\n    white_pieces_on_ranks = sum(1 for square, piece in board.piece_map().items() if piece.color == chess.WHITE and chess.square_rank(square) >= 6)\n    black_pieces_on_ranks = sum(1 for square, piece in board.piece_map().items() if piece.color == chess.BLACK and chess.square_rank(square) <= 1)\n    return float(white_pieces_on_ranks - black_pieces_on_ranks)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in the number of pieces in the opponent's home rank.\"\n    white_pieces_in_rank_8 = sum(1 for square in range(56, 64) if board.piece_at(square) and board.piece_at(square).color == chess.WHITE)\n    black_pieces_in_rank_1 = sum(1 for square in range(0, 8) if board.piece_at(square) and board.piece_at(square).color == chess.BLACK)\n    return float(white_pieces_in_rank_8 - black_pieces_in_rank_1)\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the number of pieces that are pinned to the king.\"\n    pinned_count = 0\n    for square, piece in board.piece_map().items():\n        if piece.color == board.turn:\n            if board.is_attacked_by(not board.turn, square):\n                pinned_count += 1\n    return float(pinned_count)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of doubled pawns for both players, penalizing structural weaknesses.\"\n    doubled_pawns = 0\n    pawn_files = {}\n    for square, piece in board.piece_map().items():\n        if piece.piece_type == chess.PAWN:\n            file = chess.square_file(square)\n            if file not in pawn_files:\n                pawn_files[file] = 0\n            pawn_files[file] += 1\n    \n    doubled_pawns = sum(max(0, count - 1) for count in pawn_files.values())\n    return float(doubled_pawns)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Evaluates the distance of the closest knight to the opposing king.\"\n    white_king_square = next(sq for sq, piece in board.piece_map().items() if piece.color == chess.WHITE and piece.piece_type == chess.KING)\n    black_king_square = next(sq for sq, piece in board.piece_map().items() if piece.color == chess.BLACK and piece.piece_type == chess.KING)\n    knights = [sq for sq, piece in board.piece_map().items() if piece.color == chess.WHITE and piece.piece_type == chess.KNIGHT]\n    if knights:\n        closest_distance = min(chess.square_distance(sq, black_king_square) for sq in knights)\n        return float(closest_distance)\n    return float(10)  # Arbitrary high value if no knights are present\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Evaluates the number of development moves available for each side's minor pieces.\"\n    white_development_moves = sum(1 for square in board.piece_map().keys() if board.piece_map()[square].color == chess.WHITE and board.piece_map()[square].piece_type in [chess.KNIGHT, chess.BISHOP] and chess.square_rank(square) < 6)\n    black_development_moves = sum(1 for square in board.piece_map().keys() if board.piece_map()[square].color == chess.BLACK and board.piece_map()[square].piece_type in [chess.KNIGHT, chess.BISHOP] and chess.square_rank(square) > 1)\n    return float(white_development_moves - black_development_moves)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of potential discovered check possibilities for both sides.\"\n    discovered_checks = 0\n    for sq in board.piece_map():\n        piece = board.piece_at(sq)\n        if piece.color == board.turn:\n            for move in board.legal_moves:\n                if move.from_square == sq:\n                    board.push(move)\n                    if board.is_check():\n                        discovered_checks += 1\n                    board.pop()\n    return float(discovered_checks)\n\n",
    "def feature(board: chess.Board) -> float:\n    'Measures the piece activity by counting pieces on active files (central and kingside files).'\n    active_files = [2, 3, 4, 5]  # Central and kingside files (c, d, e, f)\n    white_activity = sum(1 for sq in board.piece_map() if board.piece_at(sq).color == chess.WHITE and chess.square_file(sq) in active_files)\n    black_activity = sum(1 for sq in board.piece_map() if board.piece_at(sq).color == chess.BLACK and chess.square_file(sq) in active_files)\n    result = white_activity - black_activity\n    return float(result)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the distance of the closest enemy piece to the current player's king.\"\n    king_square = next(square for square, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color == board.turn)\n    closest_distance = min(chess.square_distance(king_square, square) for square, piece in board.piece_map().items() if piece.color != board.turn) if any(piece.color != board.turn for piece in board.piece_map().values()) else 8\n    return float(closest_distance)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the king safety by checking the number of pieces around the kings for both sides.\"\n    def king_safety(color):\n        king_square = next(square for square, piece in board.piece_map().items() if piece.color == color and piece.piece_type == chess.KING)\n        return sum(1 for square in board.attackers(color, king_square)) + sum(1 for square in range(64) if board.is_attacked_by(color, square) and board.piece_at(square))\n    white_safety = king_safety(chess.WHITE)\n    black_safety = king_safety(chess.BLACK)\n    return float(white_safety - black_safety)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in development between both sides' pieces.\"\n    white_developed = sum(1 for square in board.piece_map() if board.piece_map()[square].color == chess.WHITE and \n                          (chess.square_rank(square) > 1 or chess.square_file(square) > 1))\n    \n    black_developed = sum(1 for square in board.piece_map() if board.piece_map()[square].color == chess.BLACK and \n                          (chess.square_rank(square) < 6 or chess.square_file(square) < 6))\n    \n    return float(white_developed - black_developed)\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the number of available legal moves for each side, indicating positional flexibility.\"\n    white_moves = len(list(board.legal_moves)) if board.turn else 0\n    black_moves = len(list(board.legal_moves)) if not board.turn else 0\n    return float(white_moves - black_moves)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of isolated pawns for both sides.\"\n    def is_isolated(square, color):\n        pawn_file = chess.square_file(square)\n        return (board.piece_at(square).piece_type == chess.PAWN and \n                not (board.piece_at(chess.parse_square(chess.square_name(square).replace(str(chess.square_rank(square)), str(chess.square_rank(square) + 1))) or None) or\n                     board.piece_at(chess.parse_square(chess.square_name(square).replace(str(chess.square_rank(square)), str(chess.square_rank(square) - 1))) or None)))\n\n    isolated_white = sum(1 for square in board.piece_map() if board.piece_map()[square].color == chess.WHITE and is_isolated(square, chess.WHITE))\n    isolated_black = sum(1 for square in board.piece_map() if board.piece_map()[square].color == chess.BLACK and is_isolated(square, chess.BLACK))\n    return float(isolated_white - isolated_black)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Evaluates the activity of both queens on the board.\"\n    def queen_activity(color):\n        activity_score = 0\n        for square, piece in board.piece_map().items():\n            if piece.color == color and piece.piece_type == chess.QUEEN:\n                activity_score += 1 if chess.square_file(square) in {3, 4} else 0\n        return activity_score\n\n    white_activity = queen_activity(chess.WHITE)\n    black_activity = queen_activity(chess.BLACK)\n    return float(white_activity - black_activity)\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in the number of pieces controlled by each player's pawns.\"\n    white_controlled_squares = sum(1 for square in board.piece_map() if board.piece_at(square).color == chess.WHITE and board.piece_at(square).piece_type == chess.PAWN and board.attackers(chess.WHITE, square))\n    black_controlled_squares = sum(1 for square in board.piece_map() if board.piece_at(square).color == chess.BLACK and board.piece_at(square).piece_type == chess.PAWN and board.attackers(chess.BLACK, square))\n    return float(white_controlled_squares - black_controlled_squares)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the distribution of pieces across ranks for both sides.\"\n    def piece_distribution(color):\n        distribution = [0] * 8\n        for square, piece in board.piece_map().items():\n            if piece.color == color:\n                distribution[chess.square_rank(square)] += 1\n        return distribution\n    white_distribution = piece_distribution(chess.WHITE)\n    black_distribution = piece_distribution(chess.BLACK)\n    return float(sum(white_distribution) - sum(black_distribution))\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in mobility of knights for each side.\"\n    def knight_mobility(color):\n        return sum(len([move for move in board.legal_moves if move.from_square == square]) for square in board.piece_map() if board.piece_map()[square].color == color and board.piece_map()[square].piece_type == chess.KNIGHT)\n\n    white_mobility = knight_mobility(chess.WHITE)\n    black_mobility = knight_mobility(chess.BLACK)\n    return float(white_mobility - black_mobility)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of potentially forkable pieces by knights for both sides.\"\n    knight_forks = sum(1 for square in board.piece_map() if board.piece_map()[square].piece_type == chess.KNIGHT and board.piece_map()[square].color == board.turn)\n    return float(knight_forks) * 0.5  # Weight slightly for contribution to the evaluation\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of protected pawns for the current player.\"\n    protected_pawns = sum(1 for square, piece in board.piece_map().items() if piece.color == board.turn and piece.piece_type == chess.PAWN and any(board.is_attacked_by(board.turn, attacker) for attacker in board.attackers(board.turn, square)))\n    return float(protected_pawns)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the number of pieces on the 7th (for White) or 2nd (for Black) ranks as indicators of pressure.\"\n    white_pressure = sum(1 for square in range(48, 56) if board.piece_at(square) and board.piece_at(square).color == chess.WHITE)\n    black_pressure = sum(1 for square in range(8, 16) if board.piece_at(square) and board.piece_at(square).color == chess.BLACK)\n    return float(white_pressure - black_pressure)\n\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the total material advantage with a focus on minor pieces.\"\n    material_values = {\n        chess.PAWN: 1,\n        chess.KNIGHT: 3,\n        chess.BISHOP: 3,\n        chess.ROOK: 5,\n        chess.QUEEN: 9,\n        chess.KING: 0\n    }\n    minor_piece_value = sum(material_values[piece.piece_type] for piece in board.piece_map().values() if piece.color == chess.WHITE and piece.piece_type in [chess.KNIGHT, chess.BISHOP])\n    opponent_minor_piece_value = sum(material_values[piece.piece_type] for piece in board.piece_map().values() if piece.color == chess.BLACK and piece.piece_type in [chess.KNIGHT, chess.BISHOP])\n    return float(minor_piece_value - opponent_minor_piece_value)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the distance in moves to reach the opponent's back rank.\"\n    distance_to_back_rank = sum(7 - chess.square_rank(square) for square, piece in board.piece_map().items() if piece.color == board.turn)\n    return float(distance_to_back_rank)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the number of pieces currently in danger of capture.\"\n    threatened_count = sum(1 for square, piece in board.piece_map().items() if piece.color == board.turn and board.is_attacked_by(not piece.color, square))\n    return float(threatened_count)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the material distribution, taking into account the value of pieces within the opponent's territory.\"\n    value_map = {chess.PAWN: 1, chess.KNIGHT: 3, chess.BISHOP: 3, chess.ROOK: 5, chess.QUEEN: 9, chess.KING: 0}\n    material_difference = 0.0\n    for square, piece in board.piece_map().items():\n        if (piece.color == board.turn and chess.square_rank(square) > 4) or (piece.color != board.turn and chess.square_rank(square) < 4):\n            material_difference += value_map.get(piece.piece_type, 0) * (1 if piece.color == board.turn else -1)\n    return float(material_difference)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Evaluates the center control by counting pieces in central squares.\"\n    central_squares = [chess.D4, chess.E4, chess.D5, chess.E5]\n    white_control = sum(1 for square in central_squares if board.piece_at(square) and board.piece_at(square).color == chess.WHITE)\n    black_control = sum(1 for square in central_squares if board.piece_at(square) and board.piece_at(square).color == chess.BLACK)\n    return float(white_control - black_control)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the total piece value for mobile pieces only.\"\n    mobile_value = 0\n    for move in board.legal_moves:\n        piece = board.piece_at(move.from_square)\n        mobile_value += piece.piece_type if piece.color == board.turn else -piece.piece_type\n    return float(mobile_value)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Evaluates the number of pieces on the board versus total pawn structure.\"\n    total_pieces = len(board.piece_map())\n    total_pawns = sum(1 for piece in board.piece_map().values() if piece.piece_type == chess.PAWN)\n    return float(total_pieces - total_pawns)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the number of connected pawns for each side.\"\n    def connected_pawns(color):\n        count = 0\n        for file in range(8):\n            if board.piece_at(chess.square(file, 1 if color == chess.WHITE else 6)) == chess.PAWN:\n                if (file > 0 and board.piece_at(chess.square(file-1, 1 if color == chess.WHITE else 6)) == chess.PAWN) or \\\n                   (file < 7 and board.piece_at(chess.square(file+1, 1 if color == chess.WHITE else 6)) == chess.PAWN):\n                    count += 1\n        return count\n    white_connected = connected_pawns(chess.WHITE)\n    black_connected = connected_pawns(chess.BLACK)\n    return float(white_connected - black_connected)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Evaluates the distribution of the pieces: sum of distances of all pieces to the center.\"\n    center_square = chess.E4\n    total_distance = sum(chess.square_distance(square, center_square) for square in board.piece_map())\n    return float(total_distance)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures how many pieces are positioned on the seventh rank.\"\n    white_seventh_rank = sum(1 for square in board.piece_map() if board.piece_at(square).color == chess.WHITE and chess.square_rank(square) == 6)\n    black_seventh_rank = sum(1 for square in board.piece_map() if board.piece_at(square).color == chess.BLACK and chess.square_rank(square) == 1)\n    return float(white_seventh_rank - black_seventh_rank)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the number of connected pawns for each color.\"\n    def count_connected_pawns(color):\n        connected_pawn_count = 0\n        for square, piece in board.piece_map().items():\n            if piece.color == color and piece.piece_type == chess.PAWN:\n                file = chess.square_file(square)\n                if (board.piece_at(chess.parse_square(chess.square_name(square + 1))) and \n                    board.piece_at(chess.parse_square(chess.square_name(square - 1))) \n                    and board.piece_at(chess.parse_square(chess.square_name(square + 1))).color == color):\n                    connected_pawn_count += 1\n        return connected_pawn_count\n    white_connected = count_connected_pawns(chess.WHITE)\n    black_connected = count_connected_pawns(chess.BLACK)\n    return float(white_connected - black_connected)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the number of attacked pieces for each color.\"\n    white_attacked = sum(1 for square in board.piece_map() if board.is_attacked_by(chess.WHITE, square))\n    black_attacked = sum(1 for square in board.piece_map() if board.is_attacked_by(chess.BLACK, square))\n    return float(white_attacked - black_attacked)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the position of pawns in relation to the opponent's back rank.\"\n    white_advanced_pawns = sum(1 for square in board.piece_map() if board.piece_map()[square].color == chess.WHITE and board.piece_map()[square].piece_type == chess.PAWN and chess.square_rank(square) >= 4)\n    black_advanced_pawns = sum(1 for square in board.piece_map() if board.piece_map()[square].color == chess.BLACK and board.piece_map()[square].piece_type == chess.PAWN and chess.square_rank(square) <= 3)\n    return float(white_advanced_pawns - black_advanced_pawns)\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the potential mobility of each side based on the number of legal moves.\"\n    white_legal_moves = len(list(board.legal_moves)) if board.turn == chess.WHITE else 0\n    black_legal_moves = len(list(board.legal_moves)) if board.turn == chess.BLACK else 0\n    return float(white_legal_moves - black_legal_moves)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the balance of minor pieces by evaluating knights and bishops.\"\n    material_values = {\n        chess.KNIGHT: 3,\n        chess.BISHOP: 3\n    }\n    white_minor_material = sum(material_values[piece.piece_type] for piece in board.piece_map().values() if piece.color == chess.WHITE and piece.piece_type in material_values)\n    black_minor_material = sum(material_values[piece.piece_type] for piece in board.piece_map().values() if piece.color == chess.BLACK and piece.piece_type in material_values)\n    return float(white_minor_material - black_minor_material)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in mobility between the two players by counting potential legal captures.\"\n    white_captures = sum(1 for move in board.legal_moves if board.piece_at(move.to_square) and board.piece_at(move.to_square).color == chess.BLACK)\n    black_captures = sum(1 for move in board.legal_moves if board.piece_at(move.to_square) and board.piece_at(move.to_square).color == chess.WHITE)\n    return float(white_captures - black_captures)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Evaluates material imbalance by calculating the difference in the remaining pieces of both players.\"\n    material_values = {chess.PAWN: 1, chess.KNIGHT: 3, chess.BISHOP: 3, chess.ROOK: 5, chess.QUEEN: 9, chess.KING: 0}\n    white_material = sum(material_values[piece.piece_type] for piece in board.piece_map().values() if piece.color == chess.WHITE)\n    black_material = sum(material_values[piece.piece_type] for piece in board.piece_map().values() if piece.color == chess.BLACK)\n    return float(white_material - black_material)\n\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of major pieces (rooks and queens) on the board, giving an idea of endgame readiness.\"\n    major_pieces_count = {\n        chess.WHITE: 0,\n        chess.BLACK: 0\n    }\n    for piece in board.piece_map().values():\n        if piece.piece_type in {chess.ROOK, chess.QUEEN}:\n            major_pieces_count[piece.color] += 1\n    return float(major_pieces_count[chess.WHITE] - major_pieces_count[chess.BLACK])\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Evaluates the number of pieces controlled by each side in the opponent's territory.\"\n    white_controlled_in_black_territory = sum(1 for square in range(0, 32) if board.is_attacked_by(chess.WHITE, square))\n    black_controlled_in_white_territory = sum(1 for square in range(32, 64) if board.is_attacked_by(chess.BLACK, square))\n    return float(white_controlled_in_black_territory - black_controlled_in_white_territory)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in piece value between each player's most advanced pieces.\"\n    white_advanced_value = sum(piece.piece_type for square, piece in board.piece_map().items() if piece.color == chess.WHITE and chess.square_rank(square) > 4)\n    black_advanced_value = sum(piece.piece_type for square, piece in board.piece_map().items() if piece.color == chess.BLACK and chess.square_rank(square) < 4)\n    return float(white_advanced_value - black_advanced_value)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of squares controlled by each player and gives a score based on that.\"\n    controlled_white = sum(1 for move in board.legal_moves if move.from_square == chess.WHITE)\n    controlled_black = sum(1 for move in board.legal_moves if move.from_square == chess.BLACK)\n    return float(controlled_white - controlled_black)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of potential discovered attacks available for the player to move.\"\n    discovered_attack_count = 0\n    for square in chess.SQUARES:\n        piece = board.piece_at(square)\n        if piece and piece.color == board.turn:\n            for move in board.legal_moves:\n                if move.from_square == square and board.is_attacked_by(not board.turn, move.to_square):\n                    discovered_attack_count += 1\n    return float(discovered_attack_count)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Assesses the positional advantage based on control of key central squares.\"\n    central_squares = [chess.D4, chess.E4, chess.D5, chess.E5]\n    white_control = sum(board.is_attacked_by(chess.WHITE, square) for square in central_squares)\n    black_control = sum(board.is_attacked_by(chess.BLACK, square) for square in central_squares)\n    return float(white_control - black_control)\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the average rank of all pieces for White.\"\n    total_rank = sum(chess.square_rank(sq) for sq, piece in board.piece_map().items() if piece.color == chess.WHITE)\n    count = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE)\n    result = total_rank / count if count > 0 else 0.0\n    return float(result)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates the difference in space control within the opponent's territory.\"\n    white_space_control = sum(1 for square in range(32, 64) if board.is_attacked_by(chess.WHITE, square))\n    black_space_control = sum(1 for square in range(0, 32) if board.is_attacked_by(chess.BLACK, square))\n    return float(white_space_control - black_space_control)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Evaluates the number of pieces that can potentially be sacrificed.\"\n    sacrificing_potential = sum(1 for piece in board.piece_map().values() if piece.color == board.turn and piece.piece_type in {chess.ROOK, chess.QUEEN, chess.BISHOP})\n    return float(sacrificing_potential)\n",
    "def feature(board: chess.Board) -> float:\n    \"Measures the number of possible checks the current player can execute in their next move.\"\n    checks = sum(1 for move in board.legal_moves if board.gives_check(move))\n    return float(checks)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Evaluates the impact of open files for rooks on a chessboard.\"\n    def open_files(color):\n        return sum(1 for file in range(8) if all(board.piece_at(chess.square(file, rank)) is None for rank in range(8) if chess.square(file, rank) in board.piece_map() and board.piece_map()[chess.square(file, rank)].color != color))\n    \n    white_open_files = open_files(chess.WHITE)\n    black_open_files = open_files(chess.BLACK)\n    return float(white_open_files - black_open_files)\n",
    "def feature(board: chess.Board) -> float:\n    \"Calculates control of the center (squares d4, d5, e4, e5) by counting controlled squares.\"\n    center_squares = [chess.D4, chess.D5, chess.E4, chess.E5]\n    white_control = sum(1 for square in center_squares if board.is_attacked_by(chess.WHITE, square))\n    black_control = sum(1 for square in center_squares if board.is_attacked_by(chess.BLACK, square))\n    return float(white_control - black_control)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of pawn chains on the board.\"\n    pawn_chains = 0\n    pawn_positions = [square for square, piece in board.piece_map().items() if piece.piece_type == chess.PAWN]\n    for file in range(8):\n        chain_count = 0\n        for rank in range(8):\n            square = chess.square(file, rank)\n            if square in pawn_positions:\n                chain_count += 1\n            else:\n                if chain_count > 0:\n                    pawn_chains += 1\n                chain_count = 0\n        if chain_count > 0:\n            pawn_chains += 1\n    return float(pawn_chains)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Evaluates the mobility of pieces by counting available moves for each color.\"\n    white_moves = len(list(board.legal_moves))\n    board.turn = not board.turn  # Switch to the other player\n    black_moves = len(list(board.legal_moves))\n    board.turn = not board.turn  # Restore original turn\n    result = float(white_moves - black_moves)\n    return result\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of minor pieces (knights and bishops) each side has.\"\n    white_minors = sum(1 for piece in board.piece_map().values() if piece.color == chess.WHITE and piece.piece_type in [chess.KNIGHT, chess.BISHOP])\n    black_minors = sum(1 for piece in board.piece_map().values() if piece.color == chess.BLACK and piece.piece_type in [chess.KNIGHT, chess.BISHOP])\n    return float(white_minors - black_minors)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the total number of potential discovered attacks for each player, indicating tactical opportunities.\"\n    discovered_attacks = 0\n    for square in board.piece_map():\n        piece = board.piece_at(square)\n        if piece.color == board.turn:\n            for move in board.legal_moves:\n                if move.from_square == square and board.is_attacked_by(not piece.color, move.to_square):\n                    discovered_attacks += 1\n    return float(discovered_attacks)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of pieces that can move to attack the opponent's pawns.\"\n    attacking_pawn_moves = sum(1 for sq in board.piece_map() if board.piece_at(sq).color == chess.WHITE for move in board.legal_moves if move.to_square in board.attackers(chess.BLACK, sq) and board.piece_at(sq).piece_type == chess.PAWN)\n    attacking_pawn_moves += sum(1 for sq in board.piece_map() if board.piece_at(sq).color == chess.BLACK for move in board.legal_moves if move.to_square in board.attackers(chess.WHITE, sq) and board.piece_at(sq).piece_type == chess.PAWN)\n    return float(attacking_pawn_moves)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of attacks on each side's king.\"\n    white_king_square = next(square for square, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color == chess.WHITE)\n    black_king_square = next(square for square, piece in board.piece_map().items() if piece.piece_type == chess.KING and piece.color == chess.BLACK)\n    \n    white_king_attacks = len(board.attackers(chess.BLACK, white_king_square))\n    black_king_attacks = len(board.attackers(chess.WHITE, black_king_square))\n    \n    return float(white_king_attacks - black_king_attacks)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of squares controlled by each player's pawns, indicating pawn power and influence.\"\n    def controlled_by_pawns(color):\n        controlled_squares = set()\n        for square in range(64):\n            if board.piece_at(square) is not None and board.piece_at(square).color == color and board.piece_at(square).piece_type == chess.PAWN:\n                if color == chess.WHITE:\n                    if square >= 8:\n                        controlled_squares.add(square - 8)\n                    if square % 8 != 0:\n                        controlled_squares.add(square - 7)\n                    if square % 8 != 7:\n                        controlled_squares.add(square - 9)\n                else:\n                    if square <= 55:\n                        controlled_squares.add(square + 8)\n                    if square % 8 != 0:\n                        controlled_squares.add(square + 9)\n                    if square % 8 != 7:\n                        controlled_squares.add(square + 7)\n\n        return len(controlled_squares)\n\n    white_controlled = controlled_by_pawns(chess.WHITE)\n    black_controlled = controlled_by_pawns(chess.BLACK)\n    return float(white_controlled - black_controlled)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Counts the number of central squares controlled by each side.\"\n    central_squares = [chess.D4, chess.D5, chess.E4, chess.E5]\n    white_control = sum(1 for sq in central_squares if board.is_attacked_by(chess.WHITE, sq))\n    black_control = sum(1 for sq in central_squares if board.is_attacked_by(chess.BLACK, sq))\n    return float(white_control - black_control)\n\n"
  ]
}