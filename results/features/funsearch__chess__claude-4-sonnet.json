{
  "used_features": [
    "def feature(board: chess.Board) -> float:\n    \"Material balance in centipawns (positive favors white)\"\n    piece_values = {chess.PAWN: 100, chess.KNIGHT: 320, chess.BISHOP: 330, chess.ROOK: 500, chess.QUEEN: 900, chess.KING: 0}\n    white_material = sum(piece_values[piece.piece_type] for piece in board.piece_map().values() if piece.color == chess.WHITE)\n    black_material = sum(piece_values[piece.piece_type] for piece in board.piece_map().values() if piece.color == chess.BLACK)\n    return float(white_material - black_material)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Number of legal moves available to the current player\"\n    return float(len(list(board.legal_moves)))\n\n",
    "def feature(board: chess.Board) -> float:\n    \"King safety measured by number of attackers around each king\"\n    def king_danger(king_square, attacking_color):\n        danger = 0\n        for square in [king_square + delta for delta in [-9, -8, -7, -1, 1, 7, 8, 9]]:\n            if 0 <= square <= 63 and board.is_attacked_by(attacking_color, square):\n                danger += 1\n        return danger\n    \n    white_king = board.king(chess.WHITE)\n    black_king = board.king(chess.BLACK)\n    if white_king is None or black_king is None:\n        return 0.0\n    \n    white_danger = king_danger(white_king, chess.BLACK)\n    black_danger = king_danger(black_king, chess.WHITE)\n    return float(black_danger - white_danger)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Center control score based on pieces attacking central squares\"\n    central_squares = [chess.D4, chess.D5, chess.E4, chess.E5]\n    white_control = sum(len(board.attackers(chess.WHITE, sq)) for sq in central_squares)\n    black_control = sum(len(board.attackers(chess.BLACK, sq)) for sq in central_squares)\n    return float(white_control - black_control)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Development score based on pieces moved from starting squares\"\n    starting_positions = {\n        chess.WHITE: [chess.B1, chess.C1, chess.F1, chess.G1],  # Knights and bishops\n        chess.BLACK: [chess.B8, chess.C8, chess.F8, chess.G8]\n    }\n    \n    white_developed = sum(1 for sq in starting_positions[chess.WHITE] if board.piece_at(sq) is None)\n    black_developed = sum(1 for sq in starting_positions[chess.BLACK] if board.piece_at(sq) is None)\n    return float(white_developed - black_developed)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Pawn structure quality: doubled, isolated, and backward pawns penalty\"\n    white_penalty = 0\n    black_penalty = 0\n    \n    for square in chess.SQUARES:\n        piece = board.piece_at(square)\n        if piece and piece.piece_type == chess.PAWN:\n            file = chess.square_file(square)\n            rank = chess.square_rank(square)\n            \n            # Check for doubled pawns\n            direction = 1 if piece.color == chess.WHITE else -1\n            for r in range(rank + direction, 8 if piece.color == chess.WHITE else -1, direction):\n                if r < 0 or r > 7:\n                    break\n                check_square = chess.square(file, r)\n                check_piece = board.piece_at(check_square)\n                if check_piece and check_piece.piece_type == chess.PAWN and check_piece.color == piece.color:\n                    if piece.color == chess.WHITE:\n                        white_penalty += 1\n                    else:\n                        black_penalty += 1\n                    break\n            \n            # Check for isolated pawns\n            isolated = True\n            for adj_file in [file - 1, file + 1]:\n                if 0 <= adj_file <= 7:\n                    for r in range(8):\n                        adj_square = chess.square(adj_file, r)\n                        adj_piece = board.piece_at(adj_square)\n                        if adj_piece and adj_piece.piece_type == chess.PAWN and adj_piece.color == piece.color:\n                            isolated = False\n                            break\n                if not isolated:\n                    break\n            \n            if isolated:\n                if piece.color == chess.WHITE:\n                    white_penalty += 1\n                else:\n                    black_penalty += 1\n    \n    return float(black_penalty - white_penalty)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Piece activity: sum of squares each piece can reach\"\n    white_activity = 0\n    black_activity = 0\n    \n    for square in chess.SQUARES:\n        piece = board.piece_at(square)\n        if piece and piece.piece_type != chess.PAWN and piece.piece_type != chess.KING:\n            # Count squares this piece attacks\n            attacks = len(board.attackers(piece.color, square))\n            activity_score = len([s for s in chess.SQUARES if board.is_attacked_by(piece.color, s)])\n            \n            if piece.color == chess.WHITE:\n                white_activity += activity_score\n            else:\n                black_activity += activity_score\n    \n    return float(white_activity - black_activity) / 64.0\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Rook mobility and open file control\"\n    white_rook_mobility = 0\n    black_rook_mobility = 0\n    \n    for square in chess.SQUARES:\n        piece = board.piece_at(square)\n        if piece and piece.piece_type == chess.ROOK:\n            file = chess.square_file(square)\n            rank = chess.square_rank(square)\n            \n            # Count open squares on file and rank\n            mobility = 0\n            # Check file (up and down)\n            for r in range(8):\n                if r != rank:\n                    check_square = chess.square(file, r)\n                    if board.piece_at(check_square) is None:\n                        mobility += 1\n            # Check rank (left and right)\n            for f in range(8):\n                if f != file:\n                    check_square = chess.square(f, rank)\n                    if board.piece_at(check_square) is None:\n                        mobility += 1\n            \n            if piece.color == chess.WHITE:\n                white_rook_mobility += mobility\n            else:\n                black_rook_mobility += mobility\n    \n    return float(white_rook_mobility - black_rook_mobility)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Passed pawn advantage weighted by advancement\"\n    white_passed = 0\n    black_passed = 0\n    \n    for square in chess.SQUARES:\n        piece = board.piece_at(square)\n        if piece and piece.piece_type == chess.PAWN:\n            file = chess.square_file(square)\n            rank = chess.square_rank(square)\n            is_passed = True\n            \n            # Check if pawn is passed\n            for check_file in [file - 1, file, file + 1]:\n                if 0 <= check_file <= 7:\n                    if piece.color == chess.WHITE:\n                        for check_rank in range(rank + 1, 8):\n                            check_square = chess.square(check_file, check_rank)\n                            check_piece = board.piece_at(check_square)\n                            if check_piece and check_piece.piece_type == chess.PAWN and check_piece.color == chess.BLACK:\n                                is_passed = False\n                                break\n                    else:\n                        for check_rank in range(rank - 1, -1, -1):\n                            check_square = chess.square(check_file, check_rank)\n                            check_piece = board.piece_at(check_square)\n                            if check_piece and check_piece.piece_type == chess.PAWN and check_piece.color == chess.WHITE:\n                                is_passed = False\n                                break\n            \n            if is_passed:\n                advancement = rank if piece.color == chess.WHITE else (7 - rank)\n                if piece.color == chess.WHITE:\n                    white_passed += advancement\n                else:\n                    black_passed += advancement\n    \n    return float(white_passed - black_passed)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Bishop pair advantage and diagonal control strength\"\n    white_bishops = sum(1 for piece in board.piece_map().values() if piece.piece_type == chess.BISHOP and piece.color == chess.WHITE)\n    black_bishops = sum(1 for piece in board.piece_map().values() if piece.piece_type == chess.BISHOP and piece.color == chess.BLACK)\n    \n    bishop_pair_bonus = 0\n    if white_bishops >= 2:\n        bishop_pair_bonus += 50\n    if black_bishops >= 2:\n        bishop_pair_bonus -= 50\n    \n    # Add diagonal control\n    diagonals = [(1, 1), (1, -1), (-1, 1), (-1, -1)]\n    white_diagonal_control = 0\n    black_diagonal_control = 0\n    \n    for square in chess.SQUARES:\n        piece = board.piece_at(square)\n        if piece and piece.piece_type == chess.BISHOP:\n            file, rank = chess.square_file(square), chess.square_rank(square)\n            control = 0\n            for df, dr in diagonals:\n                for i in range(1, 8):\n                    new_file, new_rank = file + i * df, rank + i * dr\n                    if 0 <= new_file < 8 and 0 <= new_rank < 8:\n                        target_square = chess.square(new_file, new_rank)\n                        if board.piece_at(target_square) is None:\n                            control += 1\n                        else:\n                            break\n            \n            if piece.color == chess.WHITE:\n                white_diagonal_control += control\n            else:\n                black_diagonal_control += control\n    \n    return float(bishop_pair_bonus + white_diagonal_control - black_diagonal_control)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Knight outpost strength on supported advanced squares\"\n    outpost_squares = {\n        chess.WHITE: [chess.C6, chess.D6, chess.E6, chess.F6, chess.C5, chess.D5, chess.E5, chess.F5],\n        chess.BLACK: [chess.C3, chess.D3, chess.E3, chess.F3, chess.C4, chess.D4, chess.E4, chess.F4]\n    }\n    \n    white_outposts = 0\n    black_outposts = 0\n    \n    for color in [chess.WHITE, chess.BLACK]:\n        for square in outpost_squares[color]:\n            piece = board.piece_at(square)\n            if piece and piece.piece_type == chess.KNIGHT and piece.color == color:\n                # Check if supported by own pawn\n                file, rank = chess.square_file(square), chess.square_rank(square)\n                supported = False\n                pawn_rank = rank - 1 if color == chess.WHITE else rank + 1\n                for pawn_file in [file - 1, file + 1]:\n                    if 0 <= pawn_file <= 7 and 0 <= pawn_rank <= 7:\n                        pawn_square = chess.square(pawn_file, pawn_rank)\n                        pawn_piece = board.piece_at(pawn_square)\n                        if pawn_piece and pawn_piece.piece_type == chess.PAWN and pawn_piece.color == color:\n                            supported = True\n                            break\n                \n                if supported:\n                    if color == chess.WHITE:\n                        white_outposts += 1\n                    else:\n                        black_outposts += 1\n    \n    return float(white_outposts - black_outposts)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Tactical pin and fork potential based on piece alignments\"\n    white_tactical = 0\n    black_tactical = 0\n    \n    for square in chess.SQUARES:\n        piece = board.piece_at(square)\n        if piece and piece.piece_type in [chess.ROOK, chess.QUEEN, chess.BISHOP]:\n            file, rank = chess.square_file(square), chess.square_rank(square)\n            directions = []\n            if piece.piece_type in [chess.ROOK, chess.QUEEN]:\n                directions.extend([(0, 1), (0, -1), (1, 0), (-1, 0)])\n            if piece.piece_type in [chess.BISHOP, chess.QUEEN]:\n                directions.extend([(1, 1), (1, -1), (-1, 1), (-1, -1)])\n            \n            for df, dr in directions:\n                enemy_pieces = []\n                for i in range(1, 8):\n                    new_file, new_rank = file + i * df, rank + i * dr\n                    if not (0 <= new_file <= 7 and 0 <= new_rank <= 7):\n                        break\n                    target_square = chess.square(new_file, new_rank)\n                    target_piece = board.piece_at(target_square)\n                    if target_piece:\n                        if target_piece.color != piece.color:\n                            enemy_pieces.append(target_piece)\n                        break\n                \n                # Pin potential: enemy piece between attacker and valuable target\n                if len(enemy_pieces) >= 1:\n                    for i in range(len(enemy_pieces) - 1):\n                        if enemy_pieces[i + 1].piece_type in [chess.QUEEN, chess.ROOK, chess.KING]:\n                            if piece.color == chess.WHITE:\n                                white_tactical += 1\n                            else:\n                                black_tactical += 1\n    \n    return float(white_tactical - black_tactical)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Passed pawn advancement score weighted by file and rank\"\n    white_passed = 0\n    black_passed = 0\n    \n    for square in chess.SQUARES:\n        piece = board.piece_at(square)\n        if piece and piece.piece_type == chess.PAWN:\n            file, rank = chess.square_file(square), chess.square_rank(square)\n            is_passed = True\n            \n            if piece.color == chess.WHITE:\n                # Check if any black pawns can stop this pawn\n                for check_rank in range(rank + 1, 8):\n                    for check_file in [file - 1, file, file + 1]:\n                        if 0 <= check_file <= 7:\n                            check_square = chess.square(check_file, check_rank)\n                            check_piece = board.piece_at(check_square)\n                            if check_piece and check_piece.piece_type == chess.PAWN and check_piece.color == chess.BLACK:\n                                is_passed = False\n                                break\n                    if not is_passed:\n                        break\n                if is_passed:\n                    white_passed += (rank + 1) * (1 + abs(file - 3.5) * 0.1)\n            else:\n                # Check if any white pawns can stop this pawn\n                for check_rank in range(0, rank):\n                    for check_file in [file - 1, file, file + 1]:\n                        if 0 <= check_file <= 7:\n                            check_square = chess.square(check_file, check_rank)\n                            check_piece = board.piece_at(check_square)\n                            if check_piece and check_piece.piece_type == chess.PAWN and check_piece.color == chess.WHITE:\n                                is_passed = False\n                                break\n                    if not is_passed:\n                        break\n                if is_passed:\n                    black_passed += (8 - rank) * (1 + abs(file - 3.5) * 0.1)\n    \n    return float(white_passed - black_passed)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Weak squares around each king controlled by opponent pieces\"\n    def weak_squares_near_king(king_square, attacking_color):\n        if king_square is None:\n            return 0\n        weak_count = 0\n        king_file, king_rank = chess.square_file(king_square), chess.square_rank(king_square)\n        \n        for df in [-1, 0, 1]:\n            for dr in [-1, 0, 1]:\n                if df == 0 and dr == 0:\n                    continue\n                new_file, new_rank = king_file + df, king_rank + dr\n                if 0 <= new_file <= 7 and 0 <= new_rank <= 7:\n                    target_square = chess.square(new_file, new_rank)\n                    if board.piece_at(target_square) is None and board.is_attacked_by(attacking_color, target_square):\n                        weak_count += 1\n        return weak_count\n    \n    white_king = board.king(chess.WHITE)\n    black_king = board.king(chess.BLACK)\n    \n    white_weak = weak_squares_near_king(white_king, chess.BLACK)\n    black_weak = weak_squares_near_king(black_king, chess.WHITE)\n    \n    return float(black_weak - white_weak)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Connected rook strength when both rooks are on the same rank or file\"\n    white_connected = 0\n    black_connected = 0\n    \n    white_rooks = [sq for sq, piece in board.piece_map().items() if piece.piece_type == chess.ROOK and piece.color == chess.WHITE]\n    black_rooks = [sq for sq, piece in board.piece_map().items() if piece.piece_type == chess.ROOK and piece.color == chess.BLACK]\n    \n    for i in range(len(white_rooks)):\n        for j in range(i + 1, len(white_rooks)):\n            sq1, sq2 = white_rooks[i], white_rooks[j]\n            if chess.square_file(sq1) == chess.square_file(sq2) or chess.square_rank(sq1) == chess.square_rank(sq2):\n                # Check if path is clear\n                if chess.square_file(sq1) == chess.square_file(sq2):\n                    min_rank, max_rank = sorted([chess.square_rank(sq1), chess.square_rank(sq2)])\n                    clear = all(board.piece_at(chess.square(chess.square_file(sq1), r)) is None for r in range(min_rank + 1, max_rank))\n                else:\n                    min_file, max_file = sorted([chess.square_file(sq1), chess.square_file(sq2)])\n                    clear = all(board.piece_at(chess.square(f, chess.square_rank(sq1))) is None for f in range(min_file + 1, max_file))\n                if clear:\n                    white_connected += 1\n    \n    for i in range(len(black_rooks)):\n        for j in range(i + 1, len(black_rooks)):\n            sq1, sq2 = black_rooks[i], black_rooks[j]\n            if chess.square_file(sq1) == chess.square_file(sq2) or chess.square_rank(sq1) == chess.square_rank(sq2):\n                if chess.square_file(sq1) == chess.square_file(sq2):\n                    min_rank, max_rank = sorted([chess.square_rank(sq1), chess.square_rank(sq2)])\n                    clear = all(board.piece_at(chess.square(chess.square_file(sq1), r)) is None for r in range(min_rank + 1, max_rank))\n                else:\n                    min_file, max_file = sorted([chess.square_file(sq1), chess.square_file(sq2)])\n                    clear = all(board.piece_at(chess.square(f, chess.square_rank(sq1))) is None for f in range(min_file + 1, max_file))\n                if clear:\n                    black_connected += 1\n    \n    return float(white_connected - black_connected)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Weak squares in opponent's half controlled by own pieces\"\n    weak_squares_white = 0\n    weak_squares_black = 0\n    \n    for square in chess.SQUARES:\n        file, rank = chess.square_file(square), chess.square_rank(square)\n        \n        # Check white weak squares (ranks 5-7)\n        if rank >= 4 and not board.is_attacked_by(chess.BLACK, square):\n            # Check if no black pawns can defend this square\n            can_be_defended = False\n            for pawn_file in [file - 1, file + 1]:\n                if 0 <= pawn_file <= 7:\n                    for pawn_rank in range(rank - 1, -1, -1):\n                        pawn_square = chess.square(pawn_file, pawn_rank)\n                        pawn = board.piece_at(pawn_square)\n                        if pawn and pawn.piece_type == chess.PAWN and pawn.color == chess.BLACK:\n                            can_be_defended = True\n                            break\n            if not can_be_defended and board.is_attacked_by(chess.WHITE, square):\n                weak_squares_white += 1\n        \n        # Check black weak squares (ranks 0-2)  \n        if rank <= 3 and not board.is_attacked_by(chess.WHITE, square):\n            can_be_defended = False\n            for pawn_file in [file - 1, file + 1]:\n                if 0 <= pawn_file <= 7:\n                    for pawn_rank in range(rank + 1, 8):\n                        pawn_square = chess.square(pawn_file, pawn_rank)\n                        pawn = board.piece_at(pawn_square)\n                        if pawn and pawn.piece_type == chess.PAWN and pawn.color == chess.WHITE:\n                            can_be_defended = True\n                            break\n            if not can_be_defended and board.is_attacked_by(chess.BLACK, square):\n                weak_squares_black += 1\n    \n    return float(weak_squares_white - weak_squares_black)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Pawn structure health: isolated, doubled, and backward pawns penalty\"\n    white_penalty = 0\n    black_penalty = 0\n    \n    for square in chess.SQUARES:\n        piece = board.piece_at(square)\n        if piece and piece.piece_type == chess.PAWN:\n            file, rank = chess.square_file(square), chess.square_rank(square)\n            \n            # Check for isolated pawn\n            isolated = True\n            for adj_file in [file - 1, file + 1]:\n                if 0 <= adj_file <= 7:\n                    for check_rank in range(8):\n                        adj_square = chess.square(adj_file, check_rank)\n                        adj_piece = board.piece_at(adj_square)\n                        if adj_piece and adj_piece.piece_type == chess.PAWN and adj_piece.color == piece.color:\n                            isolated = False\n                            break\n            \n            # Check for doubled pawn\n            doubled = False\n            for check_rank in range(8):\n                if check_rank != rank:\n                    check_square = chess.square(file, check_rank)\n                    check_piece = board.piece_at(check_square)\n                    if check_piece and check_piece.piece_type == chess.PAWN and check_piece.color == piece.color:\n                        doubled = True\n                        break\n            \n            penalty = 0\n            if isolated:\n                penalty += 15\n            if doubled:\n                penalty += 10\n            \n            if piece.color == chess.WHITE:\n                white_penalty += penalty\n            else:\n                black_penalty += penalty\n    \n    return float(black_penalty - white_penalty)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Rook activity on open and semi-open files\"\n    white_activity = 0\n    black_activity = 0\n    \n    for file in range(8):\n        white_pawns = sum(1 for rank in range(8) if board.piece_at(chess.square(file, rank)) and board.piece_at(chess.square(file, rank)).piece_type == chess.PAWN and board.piece_at(chess.square(file, rank)).color == chess.WHITE)\n        black_pawns = sum(1 for rank in range(8) if board.piece_at(chess.square(file, rank)) and board.piece_at(chess.square(file, rank)).piece_type == chess.PAWN and board.piece_at(chess.square(file, rank)).color == chess.BLACK)\n        \n        for rank in range(8):\n            piece = board.piece_at(chess.square(file, rank))\n            if piece and piece.piece_type == chess.ROOK:\n                bonus = 0\n                if white_pawns == 0 and black_pawns == 0:  # Open file\n                    bonus = 20\n                elif (piece.color == chess.WHITE and white_pawns == 0) or (piece.color == chess.BLACK and black_pawns == 0):  # Semi-open\n                    bonus = 10\n                \n                if piece.color == chess.WHITE:\n                    white_activity += bonus\n                else:\n                    black_activity += bonus\n    \n    return float(white_activity - black_activity)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Passed pawn advancement score weighted by distance from promotion\"\n    white_score = 0\n    black_score = 0\n    \n    for square in chess.SQUARES:\n        piece = board.piece_at(square)\n        if piece and piece.piece_type == chess.PAWN:\n            file, rank = chess.square_file(square), chess.square_rank(square)\n            is_passed = True\n            \n            # Check if pawn is passed\n            for enemy_file in [file - 1, file, file + 1]:\n                if 0 <= enemy_file <= 7:\n                    start_rank = rank + 1 if piece.color == chess.WHITE else 0\n                    end_rank = 8 if piece.color == chess.WHITE else rank\n                    for check_rank in range(start_rank, end_rank):\n                        if 0 <= check_rank <= 7:\n                            enemy_square = chess.square(enemy_file, check_rank)\n                            enemy_piece = board.piece_at(enemy_square)\n                            if enemy_piece and enemy_piece.piece_type == chess.PAWN and enemy_piece.color != piece.color:\n                                is_passed = False\n                                break\n            \n            if is_passed:\n                advancement = rank if piece.color == chess.WHITE else (7 - rank)\n                score = advancement * advancement\n                if piece.color == chess.WHITE:\n                    white_score += score\n                else:\n                    black_score += score\n    \n    return float(white_score - black_score)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Bishop pair advantage and diagonal control strength\"\n    white_bishops = sum(1 for piece in board.piece_map().values() if piece.piece_type == chess.BISHOP and piece.color == chess.WHITE)\n    black_bishops = sum(1 for piece in board.piece_map().values() if piece.piece_type == chess.BISHOP and piece.color == chess.BLACK)\n    \n    bishop_pair_bonus = 0\n    if white_bishops >= 2:\n        bishop_pair_bonus += 50\n    if black_bishops >= 2:\n        bishop_pair_bonus -= 50\n    \n    diagonal_control = 0\n    for square in chess.SQUARES:\n        piece = board.piece_at(square)\n        if piece and piece.piece_type == chess.BISHOP:\n            diag_squares = 0\n            for direction in [7, 9, -7, -9]:\n                test_square = square + direction\n                while 0 <= test_square <= 63 and chess.square_distance(square, test_square) == abs(direction) * (abs(test_square - square) // abs(direction)):\n                    diag_squares += 1\n                    if board.piece_at(test_square):\n                        break\n                    test_square += direction\n            if piece.color == chess.WHITE:\n                diagonal_control += diag_squares\n            else:\n                diagonal_control -= diag_squares\n    \n    return float(bishop_pair_bonus + diagonal_control * 2)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Connected rook pairs on open or semi-open files\"\n    white_connected = 0\n    black_connected = 0\n    \n    for file in range(8):\n        white_rooks = []\n        black_rooks = []\n        pawns_on_file = 0\n        \n        for rank in range(8):\n            square = chess.square(file, rank)\n            piece = board.piece_at(square)\n            if piece:\n                if piece.piece_type == chess.ROOK:\n                    if piece.color == chess.WHITE:\n                        white_rooks.append(rank)\n                    else:\n                        black_rooks.append(rank)\n                elif piece.piece_type == chess.PAWN:\n                    pawns_on_file += 1\n        \n        file_multiplier = 2.0 if pawns_on_file == 0 else 1.0 if pawns_on_file == 1 else 0.5\n        \n        if len(white_rooks) >= 2:\n            white_connected += file_multiplier\n        if len(black_rooks) >= 2:\n            black_connected += file_multiplier\n    \n    return float(white_connected - black_connected)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Piece coordination score based on mutual protection\"\n    white_coordination = 0\n    black_coordination = 0\n    \n    for square in chess.SQUARES:\n        piece = board.piece_at(square)\n        if piece and piece.piece_type != chess.KING:\n            defenders = len(board.attackers(piece.color, square))\n            piece_value = {chess.PAWN: 1, chess.KNIGHT: 3, chess.BISHOP: 3, chess.ROOK: 5, chess.QUEEN: 9}.get(piece.piece_type, 0)\n            coordination_bonus = defenders * piece_value\n            \n            if piece.color == chess.WHITE:\n                white_coordination += coordination_bonus\n            else:\n                black_coordination += coordination_bonus\n    \n    return float(white_coordination - black_coordination)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Pawn structure evaluation focusing on doubled, isolated, and backward pawns\"\n    white_penalty = 0\n    black_penalty = 0\n    \n    for file in range(8):\n        white_pawns = []\n        black_pawns = []\n        \n        for rank in range(8):\n            square = chess.square(file, rank)\n            piece = board.piece_at(square)\n            if piece and piece.piece_type == chess.PAWN:\n                if piece.color == chess.WHITE:\n                    white_pawns.append(rank)\n                else:\n                    black_pawns.append(rank)\n        \n        # Doubled pawns penalty\n        if len(white_pawns) > 1:\n            white_penalty += (len(white_pawns) - 1) * 10\n        if len(black_pawns) > 1:\n            black_penalty += (len(black_pawns) - 1) * 10\n        \n        # Isolated pawns penalty\n        if white_pawns:\n            has_adjacent = False\n            for adj_file in [file - 1, file + 1]:\n                if 0 <= adj_file <= 7:\n                    for adj_rank in range(8):\n                        adj_square = chess.square(adj_file, adj_rank)\n                        adj_piece = board.piece_at(adj_square)\n                        if adj_piece and adj_piece.piece_type == chess.PAWN and adj_piece.color == chess.WHITE:\n                            has_adjacent = True\n                            break\n            if not has_adjacent:\n                white_penalty += 15\n        \n        if black_pawns:\n            has_adjacent = False\n            for adj_file in [file - 1, file + 1]:\n                if 0 <= adj_file <= 7:\n                    for adj_rank in range(8):\n                        adj_square = chess.square(adj_file, adj_rank)\n                        adj_piece = board.piece_at(adj_square)\n                        if adj_piece and adj_piece.piece_type == chess.PAWN and adj_piece.color == chess.BLACK:\n                            has_adjacent = True\n                            break\n            if not has_adjacent:\n                black_penalty += 15\n    \n    return float(black_penalty - white_penalty)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Tempo evaluation based on which side has the move in tactical positions\"\n    move_count = len(list(board.legal_moves))\n    in_check = board.is_check()\n    \n    # Count attacking moves (captures and checks)\n    attacking_moves = 0\n    for move in board.legal_moves:\n        temp_board = board.copy()\n        temp_board.push(move)\n        if temp_board.is_check() or board.piece_at(move.to_square) is not None:\n            attacking_moves += 1\n    \n    tempo_value = attacking_moves / max(move_count, 1) * 100\n    \n    if in_check:\n        tempo_value += 50\n    \n    return float(tempo_value if board.turn == chess.WHITE else -tempo_value)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Knight outposts on strong squares protected by pawns\"\n    white_outposts = 0\n    black_outposts = 0\n    \n    for square in chess.SQUARES:\n        piece = board.piece_at(square)\n        if piece and piece.piece_type == chess.KNIGHT:\n            file, rank = chess.square_file(square), chess.square_rank(square)\n            \n            # Check if protected by own pawn\n            protected = False\n            if piece.color == chess.WHITE:\n                for pawn_file in [file - 1, file + 1]:\n                    if 0 <= pawn_file <= 7 and rank > 0:\n                        pawn_square = chess.square(pawn_file, rank - 1)\n                        pawn = board.piece_at(pawn_square)\n                        if pawn and pawn.piece_type == chess.PAWN and pawn.color == chess.WHITE:\n                            protected = True\n                            break\n                \n                # Check if in opponent territory and can't be attacked by enemy pawns\n                if protected and rank >= 4:\n                    outpost = True\n                    for enemy_file in [file - 1, file + 1]:\n                        if 0 <= enemy_file <= 7:\n                            for enemy_rank in range(rank + 1, 8):\n                                enemy_square = chess.square(enemy_file, enemy_rank)\n                                enemy_piece = board.piece_at(enemy_square)\n                                if enemy_piece and enemy_piece.piece_type == chess.PAWN and enemy_piece.color == chess.BLACK:\n                                    outpost = False\n                                    break\n                    if outpost:\n                        white_outposts += (rank - 3) * 10\n            else:\n                for pawn_file in [file - 1, file + 1]:\n                    if 0 <= pawn_file <= 7 and rank < 7:\n                        pawn_square = chess.square(pawn_file, rank + 1)\n                        pawn = board.piece_at(pawn_square)\n                        if pawn and pawn.piece_type == chess.PAWN and pawn.color == chess.BLACK:\n                            protected = True\n                            break\n                \n                if protected and rank <= 3:\n                    outpost = True\n                    for enemy_file in [file - 1, file + 1]:\n                        if 0 <= enemy_file <= 7:\n                            for enemy_rank in range(rank - 1, -1, -1):\n                                enemy_square = chess.square(enemy_file, enemy_rank)\n                                enemy_piece = board.piece_at(enemy_square)\n                                if enemy_piece and enemy_piece.piece_type == chess.PAWN and enemy_piece.color == chess.WHITE:\n                                    outpost = False\n                                    break\n                    if outpost:\n                        black_outposts += (4 - rank) * 10\n    \n    return float(white_outposts - black_outposts)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Bishop pair advantage weighted by open diagonals and center control\"\n    white_bishops = sum(1 for piece in board.piece_map().values() if piece.piece_type == chess.BISHOP and piece.color == chess.WHITE)\n    black_bishops = sum(1 for piece in board.piece_map().values() if piece.piece_type == chess.BISHOP and piece.color == chess.BLACK)\n    \n    bishop_pair_bonus = 0\n    if white_bishops >= 2:\n        bishop_pair_bonus += 50\n    if black_bishops >= 2:\n        bishop_pair_bonus -= 50\n    \n    # Bonus for controlling long diagonals\n    long_diagonal_squares = [chess.A1, chess.B2, chess.C3, chess.D4, chess.E5, chess.F6, chess.G7, chess.H8,\n                           chess.A8, chess.B7, chess.C6, chess.D5, chess.E4, chess.F3, chess.G2, chess.H1]\n    white_diagonal_control = sum(1 for sq in long_diagonal_squares if board.is_attacked_by(chess.WHITE, sq))\n    black_diagonal_control = sum(1 for sq in long_diagonal_squares if board.is_attacked_by(chess.BLACK, sq))\n    \n    return float(bishop_pair_bonus + (white_diagonal_control - black_diagonal_control) * 5)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Pawn structure quality: doubled, isolated, and backward pawns penalty\"\n    white_penalty = 0\n    black_penalty = 0\n    \n    for file in range(8):\n        white_pawns_on_file = []\n        black_pawns_on_file = []\n        \n        for rank in range(8):\n            piece = board.piece_at(chess.square(file, rank))\n            if piece and piece.piece_type == chess.PAWN:\n                if piece.color == chess.WHITE:\n                    white_pawns_on_file.append(rank)\n                else:\n                    black_pawns_on_file.append(rank)\n        \n        # Doubled pawns penalty\n        if len(white_pawns_on_file) > 1:\n            white_penalty += (len(white_pawns_on_file) - 1) * 20\n        if len(black_pawns_on_file) > 1:\n            black_penalty += (len(black_pawns_on_file) - 1) * 20\n        \n        # Isolated pawns penalty\n        has_adjacent_white = False\n        has_adjacent_black = False\n        for adj_file in [file - 1, file + 1]:\n            if 0 <= adj_file <= 7:\n                for rank in range(8):\n                    piece = board.piece_at(chess.square(adj_file, rank))\n                    if piece and piece.piece_type == chess.PAWN:\n                        if piece.color == chess.WHITE:\n                            has_adjacent_white = True\n                        else:\n                            has_adjacent_black = True\n        \n        if white_pawns_on_file and not has_adjacent_white:\n            white_penalty += 15\n        if black_pawns_on_file and not has_adjacent_black:\n            black_penalty += 15\n    \n    return float(black_penalty - white_penalty)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Rook activity score based on open files and rank control\"\n    white_activity = 0\n    black_activity = 0\n    \n    for square in chess.SQUARES:\n        piece = board.piece_at(square)\n        if piece and piece.piece_type == chess.ROOK:\n            file = chess.square_file(square)\n            rank = chess.square_rank(square)\n            activity = 0\n            \n            # Check for open file (no pawns)\n            open_file = True\n            for r in range(8):\n                check_square = chess.square(file, r)\n                check_piece = board.piece_at(check_square)\n                if check_piece and check_piece.piece_type == chess.PAWN:\n                    open_file = False\n                    break\n            if open_file:\n                activity += 20\n            \n            # Check for 7th/2nd rank penetration\n            if (piece.color == chess.WHITE and rank == 6) or (piece.color == chess.BLACK and rank == 1):\n                activity += 15\n            \n            # Mobility bonus\n            mobility = len([move for move in board.legal_moves if move.from_square == square])\n            activity += mobility * 2\n            \n            if piece.color == chess.WHITE:\n                white_activity += activity\n            else:\n                black_activity += activity\n    \n    return float(white_activity - black_activity)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"King safety measured by pawn shelter and nearby enemy pieces\"\n    white_safety = 0\n    black_safety = 0\n    \n    white_king_square = None\n    black_king_square = None\n    \n    for square in chess.SQUARES:\n        piece = board.piece_at(square)\n        if piece and piece.piece_type == chess.KING:\n            if piece.color == chess.WHITE:\n                white_king_square = square\n            else:\n                black_king_square = square\n    \n    for color, king_square in [(chess.WHITE, white_king_square), (chess.BLACK, black_king_square)]:\n        if king_square is None:\n            continue\n        \n        file, rank = chess.square_file(king_square), chess.square_rank(king_square)\n        safety = 0\n        \n        # Pawn shelter\n        pawn_direction = 1 if color == chess.WHITE else -1\n        for df in [-1, 0, 1]:\n            if 0 <= file + df <= 7 and 0 <= rank + pawn_direction <= 7:\n                pawn_square = chess.square(file + df, rank + pawn_direction)\n                pawn = board.piece_at(pawn_square)\n                if pawn and pawn.piece_type == chess.PAWN and pawn.color == color:\n                    safety += 10\n        \n        # Enemy piece proximity penalty\n        for df in range(-2, 3):\n            for dr in range(-2, 3):\n                if 0 <= file + df <= 7 and 0 <= rank + dr <= 7:\n                    nearby_square = chess.square(file + df, rank + dr)\n                    nearby_piece = board.piece_at(nearby_square)\n                    if nearby_piece and nearby_piece.color != color:\n                        distance = max(abs(df), abs(dr))\n                        if nearby_piece.piece_type == chess.QUEEN:\n                            safety -= 15 // distance\n                        elif nearby_piece.piece_type == chess.ROOK:\n                            safety -= 10 // distance\n        \n        if color == chess.WHITE:\n            white_safety = safety\n        else:\n            black_safety = safety\n    \n    return float(white_safety - black_safety)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Knight outposts on strong squares protected by pawns\"\n    outpost_value = 0\n    for square in chess.SQUARES:\n        piece = board.piece_at(square)\n        if piece and piece.piece_type == chess.KNIGHT:\n            file, rank = chess.square_file(square), chess.square_rank(square)\n            \n            # Check if knight is in enemy territory\n            if (piece.color == chess.WHITE and rank >= 4) or (piece.color == chess.BLACK and rank <= 3):\n                # Check if protected by own pawn\n                protected_by_pawn = False\n                pawn_rank = rank - 1 if piece.color == chess.WHITE else rank + 1\n                for pawn_file in [file - 1, file + 1]:\n                    if 0 <= pawn_file <= 7 and 0 <= pawn_rank <= 7:\n                        pawn_square = chess.square(pawn_file, pawn_rank)\n                        pawn = board.piece_at(pawn_square)\n                        if pawn and pawn.piece_type == chess.PAWN and pawn.color == piece.color:\n                            protected_by_pawn = True\n                            break\n                \n                # Check if enemy pawns can't attack this square\n                safe_from_pawns = True\n                enemy_pawn_rank = rank - 1 if piece.color == chess.BLACK else rank + 1\n                for enemy_file in [file - 1, file + 1]:\n                    if 0 <= enemy_file <= 7 and 0 <= enemy_pawn_rank <= 7:\n                        enemy_square = chess.square(enemy_file, enemy_pawn_rank)\n                        enemy_pawn = board.piece_at(enemy_square)\n                        if enemy_pawn and enemy_pawn.piece_type == chess.PAWN and enemy_pawn.color != piece.color:\n                            safe_from_pawns = False\n                            break\n                \n                if protected_by_pawn and safe_from_pawns:\n                    outpost_value += 30 if piece.color == chess.WHITE else -30\n    \n    return float(outpost_value)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"King safety based on pawn shield and nearby enemy pieces\"\n    white_safety = 0\n    black_safety = 0\n    \n    for color in [chess.WHITE, chess.BLACK]:\n        king_square = board.king(color)\n        if king_square is None:\n            continue\n            \n        king_file = chess.square_file(king_square)\n        king_rank = chess.square_rank(king_square)\n        safety = 0\n        \n        # Pawn shield bonus\n        shield_ranks = [king_rank + 1, king_rank + 2] if color == chess.WHITE else [king_rank - 1, king_rank - 2]\n        for shield_rank in shield_ranks:\n            if 0 <= shield_rank <= 7:\n                for shield_file in [king_file - 1, king_file, king_file + 1]:\n                    if 0 <= shield_file <= 7:\n                        shield_square = chess.square(shield_file, shield_rank)\n                        piece = board.piece_at(shield_square)\n                        if piece and piece.piece_type == chess.PAWN and piece.color == color:\n                            safety += 10\n        \n        # Enemy piece proximity penalty\n        for square in chess.SQUARES:\n            piece = board.piece_at(square)\n            if piece and piece.color != color and piece.piece_type in [chess.QUEEN, chess.ROOK, chess.BISHOP, chess.KNIGHT]:\n                distance = chess.square_distance(king_square, square)\n                if distance <= 3:\n                    piece_threat = {chess.QUEEN: 30, chess.ROOK: 20, chess.BISHOP: 15, chess.KNIGHT: 15}[piece.piece_type]\n                    safety -= piece_threat // distance\n        \n        if color == chess.WHITE:\n            white_safety = safety\n        else:\n            black_safety = safety\n    \n    return float(white_safety - black_safety)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Bishop pair advantage and open diagonal control\"\n    white_bishops = 0\n    black_bishops = 0\n    white_diagonal_control = 0\n    black_diagonal_control = 0\n    \n    for square in chess.SQUARES:\n        piece = board.piece_at(square)\n        if piece and piece.piece_type == chess.BISHOP:\n            if piece.color == chess.WHITE:\n                white_bishops += 1\n                white_diagonal_control += len([move for move in board.legal_moves if move.from_square == square])\n            else:\n                black_bishops += 1\n                black_diagonal_control += len([move for move in board.legal_moves if move.from_square == square])\n    \n    bishop_pair_bonus = 0\n    if white_bishops >= 2:\n        bishop_pair_bonus += 30\n    if black_bishops >= 2:\n        bishop_pair_bonus -= 30\n    \n    return float(bishop_pair_bonus + white_diagonal_control - black_diagonal_control)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Passed pawn advancement and promotion threats\"\n    white_score = 0\n    black_score = 0\n    \n    for square in chess.SQUARES:\n        piece = board.piece_at(square)\n        if piece and piece.piece_type == chess.PAWN:\n            file = chess.square_file(square)\n            rank = chess.square_rank(square)\n            \n            if piece.color == chess.WHITE:\n                is_passed = True\n                for check_rank in range(rank + 1, 8):\n                    for check_file in [file - 1, file, file + 1]:\n                        if 0 <= check_file <= 7:\n                            check_square = chess.square(check_file, check_rank)\n                            check_piece = board.piece_at(check_square)\n                            if check_piece and check_piece.piece_type == chess.PAWN and check_piece.color == chess.BLACK:\n                                is_passed = False\n                                break\n                if is_passed:\n                    distance_to_promotion = 7 - rank\n                    white_score += (8 - distance_to_promotion) ** 2\n            else:\n                is_passed = True\n                for check_rank in range(rank - 1, -1, -1):\n                    for check_file in [file - 1, file, file + 1]:\n                        if 0 <= check_file <= 7:\n                            check_square = chess.square(check_file, check_rank)\n                            check_piece = board.piece_at(check_square)\n                            if check_piece and check_piece.piece_type == chess.PAWN and check_piece.color == chess.WHITE:\n                                is_passed = False\n                                break\n                if is_passed:\n                    distance_to_promotion = rank\n                    black_score += (8 - distance_to_promotion) ** 2\n    \n    return float(white_score - black_score)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"King safety evaluation based on pawn shelter and open lines near the king\"\n    white_safety = 0\n    black_safety = 0\n    \n    # Find kings\n    white_king = black_king = None\n    for square in chess.SQUARES:\n        piece = board.piece_at(square)\n        if piece and piece.piece_type == chess.KING:\n            if piece.color == chess.WHITE:\n                white_king = square\n            else:\n                black_king = square\n    \n    for king_square, color in [(white_king, chess.WHITE), (black_king, chess.BLACK)]:\n        if king_square is None:\n            continue\n            \n        safety = 0\n        king_file, king_rank = chess.square_file(king_square), chess.square_rank(king_square)\n        \n        # Check pawn shelter\n        shelter_ranks = [king_rank + 1, king_rank + 2] if color == chess.WHITE else [king_rank - 1, king_rank - 2]\n        for shelter_rank in shelter_ranks:\n            if 0 <= shelter_rank <= 7:\n                for file_offset in [-1, 0, 1]:\n                    shelter_file = king_file + file_offset\n                    if 0 <= shelter_file <= 7:\n                        shelter_square = chess.square(shelter_file, shelter_rank)\n                        piece = board.piece_at(shelter_square)\n                        if piece and piece.piece_type == chess.PAWN and piece.color == color:\n                            safety += 10\n        \n        # Penalty for open files near king\n        for file_offset in [-1, 0, 1]:\n            check_file = king_file + file_offset\n            if 0 <= check_file <= 7:\n                has_pawn = False\n                for rank in range(8):\n                    piece = board.piece_at(chess.square(check_file, rank))\n                    if piece and piece.piece_type == chess.PAWN:\n                        has_pawn = True\n                        break\n                if not has_pawn:\n                    safety -= 20\n        \n        if color == chess.WHITE:\n            white_safety = safety\n        else:\n            black_safety = safety\n    \n    return float(white_safety - black_safety)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Pawn structure weakness: isolated, doubled, and backward pawns\"\n    white_weakness = 0\n    black_weakness = 0\n    \n    pawn_files = {chess.WHITE: set(), chess.BLACK: set()}\n    pawn_positions = {chess.WHITE: [], chess.BLACK: []}\n    \n    for square in chess.SQUARES:\n        piece = board.piece_at(square)\n        if piece and piece.piece_type == chess.PAWN:\n            file = chess.square_file(square)\n            rank = chess.square_rank(square)\n            pawn_files[piece.color].add(file)\n            pawn_positions[piece.color].append((file, rank))\n    \n    for color in [chess.WHITE, chess.BLACK]:\n        for file, rank in pawn_positions[color]:\n            weakness = 0\n            \n            # Isolated pawn\n            if file - 1 not in pawn_files[color] and file + 1 not in pawn_files[color]:\n                weakness += 20\n            \n            # Doubled pawn\n            file_count = sum(1 for f, r in pawn_positions[color] if f == file)\n            if file_count > 1:\n                weakness += 15\n            \n            # Backward pawn\n            can_advance = True\n            next_rank = rank + 1 if color == chess.WHITE else rank - 1\n            if 0 <= next_rank <= 7:\n                next_square = chess.square(file, next_rank)\n                if board.is_attacked_by(chess.WHITE if color == chess.BLACK else chess.BLACK, next_square):\n                    has_support = False\n                    for support_file in [file - 1, file + 1]:\n                        if 0 <= support_file <= 7:\n                            for f, r in pawn_positions[color]:\n                                if f == support_file and ((color == chess.WHITE and r < rank) or (color == chess.BLACK and r > rank)):\n                                    has_support = True\n                    if not has_support:\n                        weakness += 10\n            \n            if color == chess.WHITE:\n                white_weakness += weakness\n            else:\n                black_weakness += weakness\n    \n    return float(black_weakness - white_weakness)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Central square control by pawns and pieces\"\n    central_squares = [chess.D4, chess.D5, chess.E4, chess.E5]\n    extended_center = [chess.C3, chess.C4, chess.C5, chess.C6, chess.D3, chess.D6, chess.E3, chess.E6, chess.F3, chess.F4, chess.F5, chess.F6]\n    \n    white_control = 0\n    black_control = 0\n    \n    for square in central_squares:\n        if board.is_attacked_by(chess.WHITE, square):\n            white_control += 3\n            piece = board.piece_at(square)\n            if piece and piece.color == chess.WHITE:\n                white_control += 5\n        if board.is_attacked_by(chess.BLACK, square):\n            black_control += 3\n            piece = board.piece_at(square)\n            if piece and piece.color == chess.BLACK:\n                black_control += 5\n    \n    for square in extended_center:\n        if board.is_attacked_by(chess.WHITE, square):\n            white_control += 1\n        if board.is_attacked_by(chess.BLACK, square):\n            black_control += 1\n    \n    return float(white_control - black_control)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Passed pawn evaluation weighted by advancement and king distance\"\n    white_passed = 0\n    black_passed = 0\n    \n    white_king = black_king = None\n    for square in chess.SQUARES:\n        piece = board.piece_at(square)\n        if piece and piece.piece_type == chess.KING:\n            if piece.color == chess.WHITE:\n                white_king = square\n            else:\n                black_king = square\n    \n    for square in chess.SQUARES:\n        piece = board.piece_at(square)\n        if piece and piece.piece_type == chess.PAWN:\n            file, rank = chess.square_file(square), chess.square_rank(square)\n            is_passed = True\n            \n            # Check if no opposing pawns can stop this pawn\n            if piece.color == chess.WHITE:\n                for check_file in [file - 1, file, file + 1]:\n                    if 0 <= check_file <= 7:\n                        for check_rank in range(rank + 1, 8):\n                            check_square = chess.square(check_file, check_rank)\n                            check_piece = board.piece_at(check_square)\n                            if check_piece and check_piece.piece_type == chess.PAWN and check_piece.color == chess.BLACK:\n                                is_passed = False\n                                break\n                    if not is_passed:\n                        break\n                \n                if is_passed:\n                    advancement_bonus = (rank - 1) * 20\n                    king_distance_bonus = 0\n                    if black_king:\n                        king_distance = chess.square_distance(square, black_king)\n                        king_distance_bonus = max(0, 7 - king_distance) * 10\n                    white_passed += advancement_bonus + king_distance_bonus\n            \n            else:  # Black pawn\n                for check_file in [file - 1, file, file + 1]:\n                    if 0 <= check_file <= 7:\n                        for check_rank in range(rank - 1, -1, -1):\n                            check_square = chess.square(check_file, check_rank)\n                            check_piece = board.piece_at(check_square)\n                            if check_piece and check_piece.piece_type == chess.PAWN and check_piece.color == chess.WHITE:\n                                is_passed = False\n                                break\n                    if not is_passed:\n                        break\n                \n                if is_passed:\n                    advancement_bonus = (6 - rank) * 20\n                    king_distance_bonus = 0\n                    if white_king:\n                        king_distance = chess.square_distance(square, white_king)\n                        king_distance_bonus = max(0, 7 - king_distance) * 10\n                    black_passed += advancement_bonus + king_distance_bonus\n    \n    return float(white_passed - black_passed)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Center control evaluation for the four central squares\"\n    center_squares = [chess.D4, chess.D5, chess.E4, chess.E5]\n    white_control = 0\n    black_control = 0\n    \n    for square in center_squares:\n        white_attackers = len(board.attackers(chess.WHITE, square))\n        black_attackers = len(board.attackers(chess.BLACK, square))\n        \n        piece = board.piece_at(square)\n        if piece:\n            if piece.color == chess.WHITE:\n                white_control += 20\n            else:\n                black_control += 20\n        \n        white_control += white_attackers * 5\n        black_control += black_attackers * 5\n    \n    return float(white_control - black_control)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"King safety evaluation based on pawn shield and nearby enemy pieces\"\n    white_safety = 0\n    black_safety = 0\n    \n    for color in [chess.WHITE, chess.BLACK]:\n        king_square = board.king(color)\n        if king_square is None:\n            continue\n            \n        king_file, king_rank = chess.square_file(king_square), chess.square_rank(king_square)\n        safety = 0\n        \n        # Pawn shield bonus\n        shield_ranks = [king_rank + 1, king_rank + 2] if color == chess.WHITE else [king_rank - 1, king_rank - 2]\n        for shield_rank in shield_ranks:\n            if 0 <= shield_rank <= 7:\n                for shield_file in [king_file - 1, king_file, king_file + 1]:\n                    if 0 <= shield_file <= 7:\n                        shield_square = chess.square(shield_file, shield_rank)\n                        piece = board.piece_at(shield_square)\n                        if piece and piece.piece_type == chess.PAWN and piece.color == color:\n                            safety += 10\n        \n        # Penalty for nearby enemy pieces\n        for file_offset in [-2, -1, 0, 1, 2]:\n            for rank_offset in [-2, -1, 0, 1, 2]:\n                if file_offset == 0 and rank_offset == 0:\n                    continue\n                check_file, check_rank = king_file + file_offset, king_rank + rank_offset\n                if 0 <= check_file <= 7 and 0 <= check_rank <= 7:\n                    check_square = chess.square(check_file, check_rank)\n                    piece = board.piece_at(check_square)\n                    if piece and piece.color != color:\n                        safety -= 5 * (3 - max(abs(file_offset), abs(rank_offset)))\n        \n        if color == chess.WHITE:\n            white_safety = safety\n        else:\n            black_safety = safety\n    \n    return float(white_safety - black_safety)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Bishop pair advantage and diagonal control\"\n    white_bishops = 0\n    black_bishops = 0\n    white_diagonal_control = 0\n    black_diagonal_control = 0\n    \n    for square in chess.SQUARES:\n        piece = board.piece_at(square)\n        if piece and piece.piece_type == chess.BISHOP:\n            if piece.color == chess.WHITE:\n                white_bishops += 1\n            else:\n                black_bishops += 1\n            \n            # Count diagonal squares controlled\n            file, rank = chess.square_file(square), chess.square_rank(square)\n            for df, dr in [(1, 1), (1, -1), (-1, 1), (-1, -1)]:\n                for i in range(1, 8):\n                    new_file, new_rank = file + i * df, rank + i * dr\n                    if not (0 <= new_file <= 7 and 0 <= new_rank <= 7):\n                        break\n                    target_square = chess.square(new_file, new_rank)\n                    if board.piece_at(target_square) is not None:\n                        break\n                    if piece.color == chess.WHITE:\n                        white_diagonal_control += 1\n                    else:\n                        black_diagonal_control += 1\n    \n    # Bishop pair bonus\n    pair_bonus = 0\n    if white_bishops >= 2:\n        pair_bonus += 50\n    if black_bishops >= 2:\n        pair_bonus -= 50\n    \n    return float(pair_bonus + white_diagonal_control - black_diagonal_control)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Knight outposts on strong squares protected by pawns\"\n    outpost_score = 0\n    \n    for square in chess.SQUARES:\n        piece = board.piece_at(square)\n        if piece and piece.piece_type == chess.KNIGHT:\n            file, rank = chess.square_file(square), chess.square_rank(square)\n            \n            # Check if knight is on 4th, 5th, or 6th rank for white (3rd, 4th, 5th for black)\n            if ((piece.color == chess.WHITE and 3 <= rank <= 5) or \n                (piece.color == chess.BLACK and 2 <= rank <= 4)):\n                \n                # Check if protected by own pawn\n                protected = False\n                pawn_squares = []\n                if piece.color == chess.WHITE:\n                    pawn_squares = [chess.square(file-1, rank-1), chess.square(file+1, rank-1)]\n                else:\n                    pawn_squares = [chess.square(file-1, rank+1), chess.square(file+1, rank+1)]\n                \n                for pawn_sq in pawn_squares:\n                    if 0 <= chess.square_file(pawn_sq) <= 7:\n                        pawn_piece = board.piece_at(pawn_sq)\n                        if pawn_piece and pawn_piece.piece_type == chess.PAWN and pawn_piece.color == piece.color:\n                            protected = True\n                            break\n                \n                if protected:\n                    # Check if enemy pawns can attack this square\n                    can_be_attacked = False\n                    enemy_pawn_squares = []\n                    if piece.color == chess.WHITE:\n                        enemy_pawn_squares = [chess.square(file-1, rank+1), chess.square(file+1, rank+1)]\n                    else:\n                        enemy_pawn_squares = [chess.square(file-1, rank-1), chess.square(file+1, rank-1)]\n                    \n                    for enemy_sq in enemy_pawn_squares:\n                        if 0 <= chess.square_file(enemy_sq) <= 7 and 0 <= chess.square_rank(enemy_sq) <= 7:\n                            enemy_piece = board.piece_at(enemy_sq)\n                            if enemy_piece and enemy_piece.piece_type == chess.PAWN and enemy_piece.color != piece.color:\n                                can_be_attacked = True\n                                break\n                    \n                    if not can_be_attacked:\n                        score = 25 if piece.color == chess.WHITE else -25\n                        outpost_score += score\n    \n    return float(outpost_score)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Bishop pair advantage bonus\"\n    white_bishops = 0\n    black_bishops = 0\n    \n    for square in chess.SQUARES:\n        piece = board.piece_at(square)\n        if piece and piece.piece_type == chess.BISHOP:\n            if piece.color == chess.WHITE:\n                white_bishops += 1\n            else:\n                black_bishops += 1\n    \n    bonus = 0\n    if white_bishops >= 2:\n        bonus += 30\n    if black_bishops >= 2:\n        bonus -= 30\n    \n    return float(bonus)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"King safety evaluation based on pawn shelter and open lines near the king\"\n    white_safety = 0\n    black_safety = 0\n    \n    for color in [chess.WHITE, chess.BLACK]:\n        king_square = board.king(color)\n        if king_square is None:\n            continue\n            \n        king_file = chess.square_file(king_square)\n        king_rank = chess.square_rank(king_square)\n        safety = 0\n        \n        # Check pawn shelter in front of king\n        direction = 1 if color == chess.WHITE else -1\n        for file_offset in [-1, 0, 1]:\n            check_file = king_file + file_offset\n            if 0 <= check_file <= 7:\n                has_pawn_shield = False\n                for rank_offset in [1, 2]:\n                    check_rank = king_rank + direction * rank_offset\n                    if 0 <= check_rank <= 7:\n                        shield_square = chess.square(check_file, check_rank)\n                        piece = board.piece_at(shield_square)\n                        if piece and piece.piece_type == chess.PAWN and piece.color == color:\n                            has_pawn_shield = True\n                            safety += 10\n                            break\n                if not has_pawn_shield:\n                    safety -= 15\n        \n        # Penalty for enemy pieces attacking king zone\n        for file_offset in range(-1, 2):\n            for rank_offset in range(-1, 2):\n                check_file = king_file + file_offset\n                check_rank = king_rank + rank_offset\n                if 0 <= check_file <= 7 and 0 <= check_rank <= 7:\n                    zone_square = chess.square(check_file, check_rank)\n                    if board.is_attacked_by(not color, zone_square):\n                        safety -= 5\n        \n        if color == chess.WHITE:\n            white_safety = safety\n        else:\n            black_safety = safety\n    \n    return float(white_safety - black_safety)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Pin pressure: value of pieces that are pinned and cannot move freely\"\n    pinned_value = 0\n    piece_values = {chess.PAWN: 100, chess.KNIGHT: 320, chess.BISHOP: 330, chess.ROOK: 500, chess.QUEEN: 900}\n    \n    for color in [chess.WHITE, chess.BLACK]:\n        king_square = board.king(color)\n        if king_square is None:\n            continue\n        enemy_color = chess.BLACK if color == chess.WHITE else chess.WHITE\n        \n        # Check for pins along ranks, files, and diagonals\n        directions = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (1, -1), (-1, 1), (-1, -1)]\n        \n        for dx, dy in directions:\n            pinned_piece = None\n            king_file, king_rank = chess.square_file(king_square), chess.square_rank(king_square)\n            \n            for distance in range(1, 8):\n                new_file, new_rank = king_file + dx * distance, king_rank + dy * distance\n                if not (0 <= new_file <= 7 and 0 <= new_rank <= 7):\n                    break\n                \n                square = chess.square(new_file, new_rank)\n                piece = board.piece_at(square)\n                \n                if piece:\n                    if piece.color == color and pinned_piece is None:\n                        pinned_piece = (piece, square)\n                    elif piece.color == enemy_color:\n                        if pinned_piece and ((abs(dx) + abs(dy) == 1 and piece.piece_type in [chess.ROOK, chess.QUEEN]) or \n                                           (abs(dx) == abs(dy) and piece.piece_type in [chess.BISHOP, chess.QUEEN])):\n                            value = piece_values.get(pinned_piece[0].piece_type, 0)\n                            pinned_value += value if color == chess.BLACK else -value\n                        break\n    \n    return float(pinned_value)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Hanging pieces: undefended pieces that can be captured for free\"\n    hanging_value = 0\n    piece_values = {chess.PAWN: 100, chess.KNIGHT: 320, chess.BISHOP: 330, chess.ROOK: 500, chess.QUEEN: 900}\n    \n    for square, piece in board.piece_map().items():\n        if board.is_attacked_by(chess.BLACK if piece.color == chess.WHITE else chess.WHITE, square):\n            if not board.is_attacked_by(piece.color, square):\n                value = piece_values.get(piece.piece_type, 0)\n                hanging_value += value if piece.color == chess.BLACK else -value\n    \n    return float(hanging_value)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Pawn structure weaknesses: isolated, doubled, and backward pawns\"\n    white_weakness = 0\n    black_weakness = 0\n    \n    pawn_files = {chess.WHITE: set(), chess.BLACK: set()}\n    pawn_positions = {chess.WHITE: [], chess.BLACK: []}\n    \n    for square in chess.SQUARES:\n        piece = board.piece_at(square)\n        if piece and piece.piece_type == chess.PAWN:\n            file = chess.square_file(square)\n            rank = chess.square_rank(square)\n            pawn_files[piece.color].add(file)\n            pawn_positions[piece.color].append((file, rank))\n    \n    for color in [chess.WHITE, chess.BLACK]:\n        for file, rank in pawn_positions[color]:\n            # Isolated pawns\n            if file - 1 not in pawn_files[color] and file + 1 not in pawn_files[color]:\n                if color == chess.WHITE:\n                    white_weakness += 20\n                else:\n                    black_weakness += 20\n            \n            # Doubled pawns\n            file_count = sum(1 for f, r in pawn_positions[color] if f == file)\n            if file_count > 1:\n                if color == chess.WHITE:\n                    white_weakness += 15 * (file_count - 1)\n                else:\n                    black_weakness += 15 * (file_count - 1)\n    \n    return float(black_weakness - white_weakness)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Knight outpost strength on protected squares in enemy territory\"\n    white_outposts = 0\n    black_outposts = 0\n    \n    for square in chess.SQUARES:\n        piece = board.piece_at(square)\n        if piece and piece.piece_type == chess.KNIGHT:\n            file, rank = chess.square_file(square), chess.square_rank(square)\n            \n            # Check if in enemy territory and protected\n            if piece.color == chess.WHITE and rank >= 4:\n                if board.is_attacked_by(chess.WHITE, square):\n                    # Check if enemy pawns can attack this square\n                    can_be_attacked = False\n                    for pawn_file in [file - 1, file + 1]:\n                        if 0 <= pawn_file <= 7 and rank > 0:\n                            pawn_square = chess.square(pawn_file, rank - 1)\n                            pawn = board.piece_at(pawn_square)\n                            if pawn and pawn.piece_type == chess.PAWN and pawn.color == chess.BLACK:\n                                can_be_attacked = True\n                                break\n                    if not can_be_attacked:\n                        white_outposts += (rank - 3) * 15\n            \n            elif piece.color == chess.BLACK and rank <= 3:\n                if board.is_attacked_by(chess.BLACK, square):\n                    can_be_attacked = False\n                    for pawn_file in [file - 1, file + 1]:\n                        if 0 <= pawn_file <= 7 and rank < 7:\n                            pawn_square = chess.square(pawn_file, rank + 1)\n                            pawn = board.piece_at(pawn_square)\n                            if pawn and pawn.piece_type == chess.PAWN and pawn.color == chess.WHITE:\n                                can_be_attacked = True\n                                break\n                    if not can_be_attacked:\n                        black_outposts += (4 - rank) * 15\n    \n    return float(white_outposts - black_outposts)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Bishop pair advantage and diagonal control\"\n    white_bishops = 0\n    black_bishops = 0\n    white_diagonal_control = 0\n    black_diagonal_control = 0\n    \n    for square in chess.SQUARES:\n        piece = board.piece_at(square)\n        if piece and piece.piece_type == chess.BISHOP:\n            if piece.color == chess.WHITE:\n                white_bishops += 1\n                # Count controlled diagonal squares\n                for move in board.legal_moves:\n                    if move.from_square == square:\n                        white_diagonal_control += 1\n            else:\n                black_bishops += 1\n                for move in board.legal_moves:\n                    if move.from_square == square:\n                        black_diagonal_control += 1\n    \n    bishop_pair_bonus = 0\n    if white_bishops >= 2:\n        bishop_pair_bonus += 50\n    if black_bishops >= 2:\n        bishop_pair_bonus -= 50\n    \n    return float(bishop_pair_bonus + white_diagonal_control - black_diagonal_control)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Queen activity and centralization score\"\n    white_queen_activity = 0\n    black_queen_activity = 0\n    \n    for square in chess.SQUARES:\n        piece = board.piece_at(square)\n        if piece and piece.piece_type == chess.QUEEN:\n            file, rank = chess.square_file(square), chess.square_rank(square)\n            \n            # Centralization bonus (distance from center)\n            center_distance = min(abs(file - 3.5), abs(file - 4.5)) + min(abs(rank - 3.5), abs(rank - 4.5))\n            centralization = max(0, 7 - center_distance) * 10\n            \n            # Mobility count\n            mobility = len([move for move in board.legal_moves if move.from_square == square])\n            \n            activity = centralization + mobility * 3\n            \n            if piece.color == chess.WHITE:\n                white_queen_activity += activity\n            else:\n                black_queen_activity += activity\n    \n    return float(white_queen_activity - black_queen_activity)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Knight outposts on strong squares supported by pawns\"\n    white_outposts = 0\n    black_outposts = 0\n    \n    for square in chess.SQUARES:\n        piece = board.piece_at(square)\n        if piece and piece.piece_type == chess.KNIGHT:\n            file, rank = chess.square_file(square), chess.square_rank(square)\n            \n            # Check if knight is in opponent's half\n            if piece.color == chess.WHITE and rank >= 4:\n                # Check if supported by own pawn\n                for support_file in [file - 1, file + 1]:\n                    if 0 <= support_file <= 7 and rank > 0:\n                        support_square = chess.square(support_file, rank - 1)\n                        support_piece = board.piece_at(support_square)\n                        if support_piece and support_piece.piece_type == chess.PAWN and support_piece.color == chess.WHITE:\n                            # Check if enemy pawns cannot attack this square\n                            cannot_be_attacked = True\n                            for enemy_file in [file - 1, file + 1]:\n                                if 0 <= enemy_file <= 7:\n                                    for enemy_rank in range(rank + 1, 8):\n                                        enemy_square = chess.square(enemy_file, enemy_rank)\n                                        enemy_piece = board.piece_at(enemy_square)\n                                        if enemy_piece and enemy_piece.piece_type == chess.PAWN and enemy_piece.color == chess.BLACK:\n                                            cannot_be_attacked = False\n                                            break\n                            if cannot_be_attacked:\n                                white_outposts += 25\n                                break\n            \n            elif piece.color == chess.BLACK and rank <= 3:\n                for support_file in [file - 1, file + 1]:\n                    if 0 <= support_file <= 7 and rank < 7:\n                        support_square = chess.square(support_file, rank + 1)\n                        support_piece = board.piece_at(support_square)\n                        if support_piece and support_piece.piece_type == chess.PAWN and support_piece.color == chess.BLACK:\n                            cannot_be_attacked = True\n                            for enemy_file in [file - 1, file + 1]:\n                                if 0 <= enemy_file <= 7:\n                                    for enemy_rank in range(rank - 1, -1, -1):\n                                        enemy_square = chess.square(enemy_file, enemy_rank)\n                                        enemy_piece = board.piece_at(enemy_square)\n                                        if enemy_piece and enemy_piece.piece_type == chess.PAWN and enemy_piece.color == chess.WHITE:\n                                            cannot_be_attacked = False\n                                            break\n                            if cannot_be_attacked:\n                                black_outposts += 25\n                                break\n    \n    return float(white_outposts - black_outposts)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Passed pawn advancement score weighted by promotion distance\"\n    white_score = 0\n    black_score = 0\n    \n    for square in chess.SQUARES:\n        piece = board.piece_at(square)\n        if piece and piece.piece_type == chess.PAWN:\n            file, rank = chess.square_file(square), chess.square_rank(square)\n            \n            if piece.color == chess.WHITE:\n                # Check if no black pawns can stop this pawn\n                is_passed = True\n                for enemy_file in [file - 1, file, file + 1]:\n                    if 0 <= enemy_file <= 7:\n                        for enemy_rank in range(rank + 1, 8):\n                            enemy_square = chess.square(enemy_file, enemy_rank)\n                            enemy_piece = board.piece_at(enemy_square)\n                            if enemy_piece and enemy_piece.piece_type == chess.PAWN and enemy_piece.color == chess.BLACK:\n                                is_passed = False\n                                break\n                if is_passed:\n                    white_score += (rank + 1) ** 2 * 5\n            \n            else:  # BLACK pawn\n                is_passed = True\n                for enemy_file in [file - 1, file, file + 1]:\n                    if 0 <= enemy_file <= 7:\n                        for enemy_rank in range(rank - 1, -1, -1):\n                            enemy_square = chess.square(enemy_file, enemy_rank)\n                            enemy_piece = board.piece_at(enemy_square)\n                            if enemy_piece and enemy_piece.piece_type == chess.PAWN and enemy_piece.color == chess.WHITE:\n                                is_passed = False\n                                break\n                if is_passed:\n                    black_score += (8 - rank) ** 2 * 5\n    \n    return float(white_score - black_score)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Knight outpost strength on defended squares in enemy territory\"\n    white_outposts = 0\n    black_outposts = 0\n    \n    for square in chess.SQUARES:\n        piece = board.piece_at(square)\n        if piece and piece.piece_type == chess.KNIGHT:\n            file, rank = chess.square_file(square), chess.square_rank(square)\n            \n            if piece.color == chess.WHITE and rank >= 4:\n                # Check if defended by own pawn\n                defended = False\n                for defend_file in [file - 1, file + 1]:\n                    if 0 <= defend_file <= 7 and rank > 0:\n                        defend_square = chess.square(defend_file, rank - 1)\n                        defend_piece = board.piece_at(defend_square)\n                        if defend_piece and defend_piece.piece_type == chess.PAWN and defend_piece.color == chess.WHITE:\n                            defended = True\n                            break\n                \n                # Check if enemy pawns can attack\n                can_be_attacked = False\n                for attack_file in [file - 1, file + 1]:\n                    if 0 <= attack_file <= 7:\n                        for attack_rank in range(rank + 1, 8):\n                            attack_square = chess.square(attack_file, attack_rank)\n                            attack_piece = board.piece_at(attack_square)\n                            if attack_piece and attack_piece.piece_type == chess.PAWN and attack_piece.color == chess.BLACK:\n                                can_be_attacked = True\n                                break\n                \n                if defended and not can_be_attacked:\n                    white_outposts += 20 + rank * 5\n            \n            elif piece.color == chess.BLACK and rank <= 3:\n                defended = False\n                for defend_file in [file - 1, file + 1]:\n                    if 0 <= defend_file <= 7 and rank < 7:\n                        defend_square = chess.square(defend_file, rank + 1)\n                        defend_piece = board.piece_at(defend_square)\n                        if defend_piece and defend_piece.piece_type == chess.PAWN and defend_piece.color == chess.BLACK:\n                            defended = True\n                            break\n                \n                can_be_attacked = False\n                for attack_file in [file - 1, file + 1]:\n                    if 0 <= attack_file <= 7:\n                        for attack_rank in range(rank - 1, -1, -1):\n                            attack_square = chess.square(attack_file, attack_rank)\n                            attack_piece = board.piece_at(attack_square)\n                            if attack_piece and attack_piece.piece_type == chess.PAWN and attack_piece.color == chess.WHITE:\n                                can_be_attacked = True\n                                break\n                \n                if defended and not can_be_attacked:\n                    black_outposts += 20 + (7 - rank) * 5\n    \n    return float(white_outposts - black_outposts)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Endgame king activity and centralization score\"\n    total_material = sum(1 for piece in board.piece_map().values() if piece.piece_type != chess.KING)\n    if total_material > 12:\n        return 0.0\n    \n    white_king_activity = 0\n    black_king_activity = 0\n    \n    for square in chess.SQUARES:\n        piece = board.piece_at(square)\n        if piece and piece.piece_type == chess.KING:\n            file, rank = chess.square_file(square), chess.square_rank(square)\n            center_distance = abs(file - 3.5) + abs(rank - 3.5)\n            centralization = (7 - center_distance) * 15\n            \n            # King mobility in endgame\n            mobility = len([move for move in board.legal_moves if move.from_square == square])\n            activity = centralization + mobility * 8\n            \n            if piece.color == chess.WHITE:\n                white_king_activity = activity\n            else:\n                black_king_activity = activity\n    \n    return float(white_king_activity - black_king_activity)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Passed pawn advancement and promotion threats\"\n    white_passed_score = 0\n    black_passed_score = 0\n    \n    for square in chess.SQUARES:\n        piece = board.piece_at(square)\n        if piece and piece.piece_type == chess.PAWN:\n            file, rank = chess.square_file(square), chess.square_rank(square)\n            is_passed = True\n            \n            if piece.color == chess.WHITE:\n                for check_rank in range(rank + 1, 8):\n                    for check_file in [file - 1, file, file + 1]:\n                        if 0 <= check_file <= 7:\n                            check_square = chess.square(check_file, check_rank)\n                            check_piece = board.piece_at(check_square)\n                            if check_piece and check_piece.piece_type == chess.PAWN and check_piece.color == chess.BLACK:\n                                is_passed = False\n                                break\n                if is_passed:\n                    advancement = rank - 1\n                    white_passed_score += advancement * advancement * 10\n            else:\n                for check_rank in range(rank - 1, -1, -1):\n                    for check_file in [file - 1, file, file + 1]:\n                        if 0 <= check_file <= 7:\n                            check_square = chess.square(check_file, check_rank)\n                            check_piece = board.piece_at(check_square)\n                            if check_piece and check_piece.piece_type == chess.PAWN and check_piece.color == chess.WHITE:\n                                is_passed = False\n                                break\n                if is_passed:\n                    advancement = 6 - rank\n                    black_passed_score += advancement * advancement * 10\n    \n    return float(white_passed_score - black_passed_score)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"King safety based on pawn shield and attacking pieces near the king\"\n    white_safety = 0\n    black_safety = 0\n    \n    for color in [chess.WHITE, chess.BLACK]:\n        king_square = board.king(color)\n        if king_square is None:\n            continue\n        \n        king_file, king_rank = chess.square_file(king_square), chess.square_rank(king_square)\n        safety = 0\n        \n        # Pawn shield bonus\n        shield_ranks = [king_rank + 1, king_rank + 2] if color == chess.WHITE else [king_rank - 1, king_rank - 2]\n        for shield_rank in shield_ranks:\n            if 0 <= shield_rank <= 7:\n                for shield_file in [king_file - 1, king_file, king_file + 1]:\n                    if 0 <= shield_file <= 7:\n                        shield_square = chess.square(shield_file, shield_rank)\n                        piece = board.piece_at(shield_square)\n                        if piece and piece.piece_type == chess.PAWN and piece.color == color:\n                            safety += 15\n        \n        # Penalty for enemy pieces attacking king area\n        for dx in [-1, 0, 1]:\n            for dy in [-1, 0, 1]:\n                check_file, check_rank = king_file + dx, king_rank + dy\n                if 0 <= check_file <= 7 and 0 <= check_rank <= 7:\n                    check_square = chess.square(check_file, check_rank)\n                    enemy_color = chess.BLACK if color == chess.WHITE else chess.WHITE\n                    if board.is_attacked_by(enemy_color, check_square):\n                        safety -= 10\n        \n        if color == chess.WHITE:\n            white_safety = safety\n        else:\n            black_safety = safety\n    \n    return float(white_safety - black_safety)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Passed pawn evaluation with advancement bonus\"\n    white_passed = 0\n    black_passed = 0\n    \n    for square in chess.SQUARES:\n        piece = board.piece_at(square)\n        if piece and piece.piece_type == chess.PAWN:\n            file, rank = chess.square_file(square), chess.square_rank(square)\n            is_passed = True\n            \n            if piece.color == chess.WHITE:\n                # Check if any black pawns can stop this pawn\n                for check_file in [file - 1, file, file + 1]:\n                    if 0 <= check_file <= 7:\n                        for check_rank in range(rank + 1, 8):\n                            check_square = chess.square(check_file, check_rank)\n                            check_piece = board.piece_at(check_square)\n                            if check_piece and check_piece.piece_type == chess.PAWN and check_piece.color == chess.BLACK:\n                                is_passed = False\n                                break\n                if is_passed:\n                    advancement_bonus = (rank - 1) * 10\n                    white_passed += 20 + advancement_bonus\n            else:\n                for check_file in [file - 1, file, file + 1]:\n                    if 0 <= check_file <= 7:\n                        for check_rank in range(rank - 1, -1, -1):\n                            check_square = chess.square(check_file, check_rank)\n                            check_piece = board.piece_at(check_square)\n                            if check_piece and check_piece.piece_type == chess.PAWN and check_piece.color == chess.WHITE:\n                                is_passed = False\n                                break\n                if is_passed:\n                    advancement_bonus = (6 - rank) * 10\n                    black_passed += 20 + advancement_bonus\n    \n    return float(white_passed - black_passed)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"King safety measured by attackers near king and pawn shelter quality\"\n    white_safety = 0\n    black_safety = 0\n    \n    for color in [chess.WHITE, chess.BLACK]:\n        king_square = None\n        for square in chess.SQUARES:\n            piece = board.piece_at(square)\n            if piece and piece.piece_type == chess.KING and piece.color == color:\n                king_square = square\n                break\n        \n        if king_square is not None:\n            file, rank = chess.square_file(king_square), chess.square_rank(king_square)\n            safety = 50\n            \n            # Count enemy attackers in king vicinity\n            enemy_color = chess.BLACK if color == chess.WHITE else chess.WHITE\n            for f in range(max(0, file-2), min(8, file+3)):\n                for r in range(max(0, rank-2), min(8, rank+3)):\n                    check_square = chess.square(f, r)\n                    if board.is_attacked_by(enemy_color, check_square):\n                        safety -= 8\n            \n            # Pawn shelter bonus\n            shelter_files = [file-1, file, file+1]\n            for shelter_file in shelter_files:\n                if 0 <= shelter_file <= 7:\n                    shelter_rank = rank + (1 if color == chess.WHITE else -1)\n                    if 0 <= shelter_rank <= 7:\n                        shelter_square = chess.square(shelter_file, shelter_rank)\n                        shelter_piece = board.piece_at(shelter_square)\n                        if shelter_piece and shelter_piece.piece_type == chess.PAWN and shelter_piece.color == color:\n                            safety += 15\n            \n            if color == chess.WHITE:\n                white_safety = safety\n            else:\n                black_safety = safety\n    \n    return float(white_safety - black_safety)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Bishop pair advantage and diagonal control strength\"\n    white_bishops = []\n    black_bishops = []\n    \n    for square in chess.SQUARES:\n        piece = board.piece_at(square)\n        if piece and piece.piece_type == chess.BISHOP:\n            if piece.color == chess.WHITE:\n                white_bishops.append(square)\n            else:\n                black_bishops.append(square)\n    \n    white_score = 0\n    black_score = 0\n    \n    # Bishop pair bonus\n    if len(white_bishops) >= 2:\n        white_score += 30\n    if len(black_bishops) >= 2:\n        black_score += 30\n    \n    # Diagonal control\n    for bishop_square in white_bishops:\n        mobility = len([move for move in board.legal_moves if move.from_square == bishop_square])\n        white_score += mobility * 3\n    \n    for bishop_square in black_bishops:\n        # Temporarily switch turns to get black bishop mobility\n        board.turn = not board.turn\n        mobility = len([move for move in board.legal_moves if move.from_square == bishop_square])\n        board.turn = not board.turn\n        black_score += mobility * 3\n    \n    return float(white_score - black_score)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Pawn structure quality: doubled, isolated, and backward pawns penalty\"\n    white_penalty = 0\n    black_penalty = 0\n    \n    for file in range(8):\n        white_pawns = []\n        black_pawns = []\n        for rank in range(8):\n            piece = board.piece_at(chess.square(file, rank))\n            if piece and piece.piece_type == chess.PAWN:\n                if piece.color == chess.WHITE:\n                    white_pawns.append(rank)\n                else:\n                    black_pawns.append(rank)\n        \n        # Doubled pawns penalty\n        if len(white_pawns) > 1:\n            white_penalty += (len(white_pawns) - 1) * 20\n        if len(black_pawns) > 1:\n            black_penalty += (len(black_pawns) - 1) * 20\n        \n        # Isolated pawns penalty\n        if white_pawns:\n            has_support = False\n            for adj_file in [file - 1, file + 1]:\n                if 0 <= adj_file <= 7:\n                    for rank in range(8):\n                        piece = board.piece_at(chess.square(adj_file, rank))\n                        if piece and piece.piece_type == chess.PAWN and piece.color == chess.WHITE:\n                            has_support = True\n                            break\n            if not has_support:\n                white_penalty += 15\n        \n        if black_pawns:\n            has_support = False\n            for adj_file in [file - 1, file + 1]:\n                if 0 <= adj_file <= 7:\n                    for rank in range(8):\n                        piece = board.piece_at(chess.square(adj_file, rank))\n                        if piece and piece.piece_type == chess.PAWN and piece.color == chess.BLACK:\n                            has_support = True\n                            break\n            if not has_support:\n                black_penalty += 15\n    \n    return float(black_penalty - white_penalty)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Piece coordination: pieces defending each other\"\n    white_coordination = 0\n    black_coordination = 0\n    \n    for square in chess.SQUARES:\n        piece = board.piece_at(square)\n        if piece and piece.piece_type != chess.KING:\n            defenders = len(board.attackers(piece.color, square))\n            if defenders > 0:\n                piece_value = {chess.PAWN: 1, chess.KNIGHT: 3, chess.BISHOP: 3, chess.ROOK: 5, chess.QUEEN: 9}.get(piece.piece_type, 0)\n                coordination_score = defenders * piece_value\n                if piece.color == chess.WHITE:\n                    white_coordination += coordination_score\n                else:\n                    black_coordination += coordination_score\n    \n    return float(white_coordination - black_coordination)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Control of key central squares (d4, d5, e4, e5)\"\n    central_squares = [chess.D4, chess.D5, chess.E4, chess.E5]\n    white_control = 0\n    black_control = 0\n    \n    for square in central_squares:\n        white_attackers = len(board.attackers(chess.WHITE, square))\n        black_attackers = len(board.attackers(chess.BLACK, square))\n        \n        piece = board.piece_at(square)\n        if piece:\n            if piece.color == chess.WHITE:\n                white_control += 20\n            else:\n                black_control += 20\n        \n        white_control += white_attackers * 5\n        black_control += black_attackers * 5\n    \n    return float(white_control - black_control)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Rook activity on open and semi-open files\"\n    white_rook_activity = 0\n    black_rook_activity = 0\n    \n    # Find all pawns by file\n    pawn_files = {chess.WHITE: set(), chess.BLACK: set()}\n    for square in chess.SQUARES:\n        piece = board.piece_at(square)\n        if piece and piece.piece_type == chess.PAWN:\n            pawn_files[piece.color].add(chess.square_file(square))\n    \n    for square in chess.SQUARES:\n        piece = board.piece_at(square)\n        if piece and piece.piece_type == chess.ROOK:\n            file = chess.square_file(square)\n            rank = chess.square_rank(square)\n            activity = 0\n            \n            # Open file bonus (no pawns on file)\n            if file not in pawn_files[chess.WHITE] and file not in pawn_files[chess.BLACK]:\n                activity += 25\n            # Semi-open file bonus (only enemy pawns on file)\n            elif file not in pawn_files[piece.color]:\n                activity += 15\n            \n            # 7th/2nd rank bonus\n            if (piece.color == chess.WHITE and rank == 6) or (piece.color == chess.BLACK and rank == 1):\n                activity += 20\n            \n            # Mobility\n            mobility = len([move for move in board.legal_moves if move.from_square == square])\n            activity += mobility * 2\n            \n            if piece.color == chess.WHITE:\n                white_rook_activity += activity\n            else:\n                black_rook_activity += activity\n    \n    return float(white_rook_activity - black_rook_activity)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Piece coordination and tactical motifs detection\"\n    coordination_score = 0\n    \n    for square in chess.SQUARES:\n        piece = board.piece_at(square)\n        if piece:\n            defenders = len(board.attackers(piece.color, square))\n            attackers = len(board.attackers(not piece.color, square))\n            \n            # Overloaded pieces (defending multiple pieces)\n            if defenders == 1:\n                defender_square = list(board.attackers(piece.color, square))[0]\n                defended_by_this = sum(1 for sq in chess.SQUARES \n                                     if board.piece_at(sq) and board.piece_at(sq).color == piece.color\n                                     and defender_square in board.attackers(piece.color, sq))\n                if defended_by_this > 2:\n                    if piece.color == chess.WHITE:\n                        coordination_score -= 10\n                    else:\n                        coordination_score += 10\n            \n            # Well-defended pieces bonus\n            if defenders > attackers and piece.piece_type in [chess.QUEEN, chess.ROOK]:\n                if piece.color == chess.WHITE:\n                    coordination_score += 5\n                else:\n                    coordination_score -= 5\n    \n    return float(coordination_score)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Piece mobility weighted by piece value and position\"\n    mobility_score = 0\n    piece_values = {chess.PAWN: 1, chess.KNIGHT: 3, chess.BISHOP: 3, chess.ROOK: 5, chess.QUEEN: 9}\n    \n    for square in chess.SQUARES:\n        piece = board.piece_at(square)\n        if piece and piece.piece_type != chess.KING:\n            moves = len([move for move in board.legal_moves if move.from_square == square])\n            weight = piece_values.get(piece.piece_type, 0)\n            if piece.color == chess.WHITE:\n                mobility_score += moves * weight\n            else:\n                mobility_score -= moves * weight\n    \n    return float(mobility_score)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Passed pawns evaluation with advancement bonus\"\n    passed_pawn_score = 0\n    \n    for file in range(8):\n        for rank in range(8):\n            square = chess.square(file, rank)\n            piece = board.piece_at(square)\n            if piece and piece.piece_type == chess.PAWN:\n                is_passed = True\n                if piece.color == chess.WHITE:\n                    # Check if any black pawns can stop this pawn\n                    for check_file in [file-1, file, file+1]:\n                        if 0 <= check_file <= 7:\n                            for check_rank in range(rank+1, 8):\n                                check_piece = board.piece_at(chess.square(check_file, check_rank))\n                                if check_piece and check_piece.piece_type == chess.PAWN and check_piece.color == chess.BLACK:\n                                    is_passed = False\n                    if is_passed:\n                        passed_pawn_score += 20 + rank * 10\n                else:\n                    # Check for white pawns that can stop this pawn\n                    for check_file in [file-1, file, file+1]:\n                        if 0 <= check_file <= 7:\n                            for check_rank in range(rank-1, -1, -1):\n                                check_piece = board.piece_at(chess.square(check_file, check_rank))\n                                if check_piece and check_piece.piece_type == chess.PAWN and check_piece.color == chess.WHITE:\n                                    is_passed = False\n                    if is_passed:\n                        passed_pawn_score -= 20 + (7-rank) * 10\n    \n    return float(passed_pawn_score)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Rook activity on open and semi-open files\"\n    white_rook_activity = 0\n    black_rook_activity = 0\n    \n    for square in chess.SQUARES:\n        piece = board.piece_at(square)\n        if piece and piece.piece_type == chess.ROOK:\n            file = chess.square_file(square)\n            rank = chess.square_rank(square)\n            \n            # Check if on open file (no pawns)\n            open_file = True\n            semi_open = True\n            for r in range(8):\n                check_piece = board.piece_at(chess.square(file, r))\n                if check_piece and check_piece.piece_type == chess.PAWN:\n                    open_file = False\n                    if check_piece.color == piece.color:\n                        semi_open = False\n                    break\n            \n            activity = 0\n            if open_file:\n                activity += 25\n            elif semi_open:\n                activity += 15\n            \n            # 7th rank bonus for rooks\n            if (piece.color == chess.WHITE and rank == 6) or (piece.color == chess.BLACK and rank == 1):\n                activity += 20\n            \n            if piece.color == chess.WHITE:\n                white_rook_activity += activity\n            else:\n                black_rook_activity += activity\n    \n    return float(white_rook_activity - black_rook_activity)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Bishop pair advantage and diagonal control\"\n    white_bishops = 0\n    black_bishops = 0\n    white_diagonal_control = 0\n    black_diagonal_control = 0\n    \n    for square in chess.SQUARES:\n        piece = board.piece_at(square)\n        if piece and piece.piece_type == chess.BISHOP:\n            if piece.color == chess.WHITE:\n                white_bishops += 1\n            else:\n                black_bishops += 1\n            \n            # Count diagonal squares controlled\n            moves = len([move for move in board.legal_moves if move.from_square == square])\n            if piece.color == chess.WHITE:\n                white_diagonal_control += moves\n            else:\n                black_diagonal_control += moves\n    \n    # Bishop pair bonus\n    white_score = white_diagonal_control * 2\n    black_score = black_diagonal_control * 2\n    \n    if white_bishops >= 2:\n        white_score += 30\n    if black_bishops >= 2:\n        black_score += 30\n    \n    return float(white_score - black_score)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Rook activity on open and semi-open files\"\n    white_score = 0\n    black_score = 0\n    \n    # Find files with pawns\n    files_with_white_pawns = set()\n    files_with_black_pawns = set()\n    \n    for square in chess.SQUARES:\n        piece = board.piece_at(square)\n        if piece and piece.piece_type == chess.PAWN:\n            file = chess.square_file(square)\n            if piece.color == chess.WHITE:\n                files_with_white_pawns.add(file)\n            else:\n                files_with_black_pawns.add(file)\n    \n    # Score rooks based on file openness\n    for square in chess.SQUARES:\n        piece = board.piece_at(square)\n        if piece and piece.piece_type == chess.ROOK:\n            file = chess.square_file(square)\n            score = 0\n            \n            if file not in files_with_white_pawns and file not in files_with_black_pawns:\n                score += 25  # Open file\n            elif (piece.color == chess.WHITE and file not in files_with_white_pawns) or \\\n                 (piece.color == chess.BLACK and file not in files_with_black_pawns):\n                score += 15  # Semi-open file\n            \n            # Bonus for 7th/2nd rank\n            rank = chess.square_rank(square)\n            if (piece.color == chess.WHITE and rank == 6) or (piece.color == chess.BLACK and rank == 1):\n                score += 20\n            \n            if piece.color == chess.WHITE:\n                white_score += score\n            else:\n                black_score += score\n    \n    return float(white_score - black_score)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Control of key central squares e4, e5, d4, d5\"\n    central_squares = [chess.E4, chess.E5, chess.D4, chess.D5]\n    white_control = 0\n    black_control = 0\n    \n    for square in central_squares:\n        white_attackers = len(board.attackers(chess.WHITE, square))\n        black_attackers = len(board.attackers(chess.BLACK, square))\n        \n        # Bonus for occupying central squares\n        piece = board.piece_at(square)\n        if piece:\n            if piece.color == chess.WHITE:\n                white_control += 15\n            else:\n                black_control += 15\n        \n        # Control difference\n        white_control += white_attackers * 3\n        black_control += black_attackers * 3\n    \n    return float(white_control - black_control)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Tempo and development advantage in opening/middlegame\"\n    if board.fullmove_number > 20:\n        return 0.0\n    \n    white_development = 0\n    black_development = 0\n    \n    # Check if pieces are developed from starting squares\n    starting_squares = {\n        chess.WHITE: [chess.B1, chess.C1, chess.F1, chess.G1],  # Knights and bishops\n        chess.BLACK: [chess.B8, chess.C8, chess.F8, chess.G8]\n    }\n    \n    for color in [chess.WHITE, chess.BLACK]:\n        for square in starting_squares[color]:\n            piece = board.piece_at(square)\n            # Penalty if piece still on starting square\n            if piece and piece.color == color and piece.piece_type in [chess.KNIGHT, chess.BISHOP]:\n                if color == chess.WHITE:\n                    white_development -= 10\n                else:\n                    black_development -= 10\n    \n    # Castling bonus\n    if board.has_castling_rights(chess.WHITE):\n        white_development -= 5\n    if board.has_castling_rights(chess.BLACK):\n        black_development -= 5\n    \n    return float(white_development - black_development)\n",
    "def feature(board: chess.Board) -> float:\n    \"Rook activity on open and semi-open files\"\n    white_rook_activity = 0\n    black_rook_activity = 0\n    \n    for square in chess.SQUARES:\n        piece = board.piece_at(square)\n        if piece and piece.piece_type == chess.ROOK:\n            file = chess.square_file(square)\n            \n            # Check if file is open or semi-open\n            own_pawns = 0\n            enemy_pawns = 0\n            for rank in range(8):\n                check_square = chess.square(file, rank)\n                check_piece = board.piece_at(check_square)\n                if check_piece and check_piece.piece_type == chess.PAWN:\n                    if check_piece.color == piece.color:\n                        own_pawns += 1\n                    else:\n                        enemy_pawns += 1\n            \n            activity = 0\n            if own_pawns == 0 and enemy_pawns == 0:\n                activity = 25  # Open file\n            elif own_pawns == 0:\n                activity = 15  # Semi-open file\n            \n            # Add mobility bonus\n            mobility = len([move for move in board.legal_moves if move.from_square == square])\n            activity += mobility * 2\n            \n            if piece.color == chess.WHITE:\n                white_rook_activity += activity\n            else:\n                black_rook_activity += activity\n    \n    return float(white_rook_activity - black_rook_activity)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Pawn structure evaluation including doubled, isolated, and passed pawns\"\n    white_structure = 0\n    black_structure = 0\n    \n    for file in range(8):\n        white_pawns = []\n        black_pawns = []\n        \n        for rank in range(8):\n            square = chess.square(file, rank)\n            piece = board.piece_at(square)\n            if piece and piece.piece_type == chess.PAWN:\n                if piece.color == chess.WHITE:\n                    white_pawns.append(rank)\n                else:\n                    black_pawns.append(rank)\n        \n        # Doubled pawns penalty\n        if len(white_pawns) > 1:\n            white_structure -= 20 * (len(white_pawns) - 1)\n        if len(black_pawns) > 1:\n            black_structure -= 20 * (len(black_pawns) - 1)\n        \n        # Isolated pawns penalty\n        if white_pawns:\n            has_support = False\n            for adj_file in [file - 1, file + 1]:\n                if 0 <= adj_file <= 7:\n                    for rank in range(8):\n                        adj_square = chess.square(adj_file, rank)\n                        adj_piece = board.piece_at(adj_square)\n                        if adj_piece and adj_piece.piece_type == chess.PAWN and adj_piece.color == chess.WHITE:\n                            has_support = True\n                            break\n            if not has_support:\n                white_structure -= 15\n        \n        if black_pawns:\n            has_support = False\n            for adj_file in [file - 1, file + 1]:\n                if 0 <= adj_file <= 7:\n                    for rank in range(8):\n                        adj_square = chess.square(adj_file, rank)\n                        adj_piece = board.piece_at(adj_square)\n                        if adj_piece and adj_piece.piece_type == chess.PAWN and adj_piece.color == chess.BLACK:\n                            has_support = True\n                            break\n            if not has_support:\n                black_structure -= 15\n    \n    return float(white_structure - black_structure)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Passed pawns weighted by advancement and support\"\n    passed_pawn_score = 0\n    \n    for square in chess.SQUARES:\n        piece = board.piece_at(square)\n        if piece and piece.piece_type == chess.PAWN:\n            file, rank = chess.square_file(square), chess.square_rank(square)\n            is_passed = True\n            \n            # Check if any enemy pawns can stop this pawn\n            enemy_color = chess.BLACK if piece.color == chess.WHITE else chess.WHITE\n            direction = 1 if piece.color == chess.WHITE else -1\n            \n            for check_file in [file-1, file, file+1]:\n                if 0 <= check_file <= 7:\n                    for check_rank in range(rank + direction, 8 if piece.color == chess.WHITE else -1, direction):\n                        if 0 <= check_rank <= 7:\n                            check_square = chess.square(check_file, check_rank)\n                            check_piece = board.piece_at(check_square)\n                            if check_piece and check_piece.piece_type == chess.PAWN and check_piece.color == enemy_color:\n                                is_passed = False\n                                break\n                if not is_passed:\n                    break\n            \n            if is_passed:\n                advancement = rank if piece.color == chess.WHITE else 7 - rank\n                support = 1 if board.is_attacked_by(piece.color, square) else 0\n                score = (advancement ** 2) * (1 + support) * 10\n                passed_pawn_score += score if piece.color == chess.WHITE else -score\n    \n    return float(passed_pawn_score)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Doubled, isolated and backward pawn penalties\"\n    pawn_penalty = 0\n    \n    for color in [chess.WHITE, chess.BLACK]:\n        file_pawns = [[] for _ in range(8)]\n        \n        # Collect pawns by file\n        for square in chess.SQUARES:\n            piece = board.piece_at(square)\n            if piece and piece.piece_type == chess.PAWN and piece.color == color:\n                file = chess.square_file(square)\n                rank = chess.square_rank(square)\n                file_pawns[file].append(rank)\n        \n        for file in range(8):\n            pawn_count = len(file_pawns[file])\n            \n            # Doubled pawns penalty\n            if pawn_count > 1:\n                penalty = (pawn_count - 1) * 20\n                pawn_penalty += penalty if color == chess.BLACK else -penalty\n            \n            # Isolated pawns penalty\n            if pawn_count > 0:\n                has_neighbor = False\n                for neighbor_file in [file-1, file+1]:\n                    if 0 <= neighbor_file <= 7 and len(file_pawns[neighbor_file]) > 0:\n                        has_neighbor = True\n                        break\n                \n                if not has_neighbor:\n                    penalty = 15 * pawn_count\n                    pawn_penalty += penalty if color == chess.BLACK else -penalty\n    \n    return float(pawn_penalty)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Pawn structure weaknesses: isolated, doubled, and backward pawns\"\n    white_weaknesses = 0\n    black_weaknesses = 0\n    \n    pawn_files = {chess.WHITE: set(), chess.BLACK: set()}\n    pawn_positions = {chess.WHITE: [], chess.BLACK: []}\n    \n    for square in chess.SQUARES:\n        piece = board.piece_at(square)\n        if piece and piece.piece_type == chess.PAWN:\n            file = chess.square_file(square)\n            rank = chess.square_rank(square)\n            pawn_files[piece.color].add(file)\n            pawn_positions[piece.color].append((file, rank, square))\n    \n    for color in [chess.WHITE, chess.BLACK]:\n        for file, rank, square in pawn_positions[color]:\n            # Isolated pawn\n            if file-1 not in pawn_files[color] and file+1 not in pawn_files[color]:\n                if color == chess.WHITE:\n                    white_weaknesses += 25\n                else:\n                    black_weaknesses += 25\n            \n            # Doubled pawn\n            same_file_pawns = sum(1 for f, r, s in pawn_positions[color] if f == file)\n            if same_file_pawns > 1:\n                if color == chess.WHITE:\n                    white_weaknesses += 15\n                else:\n                    black_weaknesses += 15\n    \n    return float(black_weaknesses - white_weaknesses)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Rook activity: open files, seventh rank presence, and connectivity\"\n    white_rook_activity = 0\n    black_rook_activity = 0\n    \n    # Find pawns on each file\n    file_pawns = [0] * 8\n    for square in chess.SQUARES:\n        piece = board.piece_at(square)\n        if piece and piece.piece_type == chess.PAWN:\n            file_pawns[chess.square_file(square)] += 1\n    \n    for square in chess.SQUARES:\n        piece = board.piece_at(square)\n        if piece and piece.piece_type == chess.ROOK:\n            file = chess.square_file(square)\n            rank = chess.square_rank(square)\n            activity = 0\n            \n            # Open file bonus\n            if file_pawns[file] == 0:\n                activity += 30\n            elif file_pawns[file] == 1:\n                activity += 15  # Semi-open\n            \n            # Seventh rank bonus\n            if (piece.color == chess.WHITE and rank == 6) or (piece.color == chess.BLACK and rank == 1):\n                activity += 25\n            \n            # Mobility\n            mobility = len([move for move in board.legal_moves if move.from_square == square])\n            activity += mobility * 2\n            \n            if piece.color == chess.WHITE:\n                white_rook_activity += activity\n            else:\n                black_rook_activity += activity\n    \n    return float(white_rook_activity - black_rook_activity)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Rook on open file bonus weighted by file importance\"\n    score = 0\n    for square in chess.SQUARES:\n        piece = board.piece_at(square)\n        if piece and piece.piece_type == chess.ROOK:\n            file = chess.square_file(square)\n            is_open = True\n            for rank in range(8):\n                check_piece = board.piece_at(chess.square(file, rank))\n                if check_piece and check_piece.piece_type == chess.PAWN:\n                    is_open = False\n                    break\n            if is_open:\n                file_value = 10 + abs(file - 3.5) * 2\n                if piece.color == chess.WHITE:\n                    score += file_value\n                else:\n                    score -= file_value\n    return float(score)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Knight outpost evaluation on strong squares\"\n    outpost_score = 0\n    for square in chess.SQUARES:\n        piece = board.piece_at(square)\n        if piece and piece.piece_type == chess.KNIGHT:\n            file, rank = chess.square_file(square), chess.square_rank(square)\n            is_outpost = False\n            \n            if piece.color == chess.WHITE and rank >= 4:\n                is_outpost = True\n                for adj_file in [file - 1, file + 1]:\n                    if 0 <= adj_file <= 7:\n                        for check_rank in range(rank, 8):\n                            check_piece = board.piece_at(chess.square(adj_file, check_rank))\n                            if check_piece and check_piece.piece_type == chess.PAWN and check_piece.color == chess.BLACK:\n                                is_outpost = False\n            elif piece.color == chess.BLACK and rank <= 3:\n                is_outpost = True\n                for adj_file in [file - 1, file + 1]:\n                    if 0 <= adj_file <= 7:\n                        for check_rank in range(0, rank + 1):\n                            check_piece = board.piece_at(chess.square(adj_file, check_rank))\n                            if check_piece and check_piece.piece_type == chess.PAWN and check_piece.color == chess.WHITE:\n                                is_outpost = False\n            \n            if is_outpost:\n                bonus = 25 + (3 - abs(file - 3.5)) * 5\n                if piece.color == chess.WHITE:\n                    outpost_score += bonus\n                else:\n                    outpost_score -= bonus\n    \n    return float(outpost_score)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Rook activity on open and semi-open files\"\n    white_score = 0\n    black_score = 0\n    \n    # Map files to pawn presence\n    file_pawns = {f: {'white': 0, 'black': 0} for f in range(8)}\n    for square in chess.SQUARES:\n        piece = board.piece_at(square)\n        if piece and piece.piece_type == chess.PAWN:\n            file = chess.square_file(square)\n            if piece.color == chess.WHITE:\n                file_pawns[file]['white'] += 1\n            else:\n                file_pawns[file]['black'] += 1\n    \n    for square in chess.SQUARES:\n        piece = board.piece_at(square)\n        if piece and piece.piece_type == chess.ROOK:\n            file = chess.square_file(square)\n            rank = chess.square_rank(square)\n            \n            # Open file bonus (no pawns)\n            if file_pawns[file]['white'] == 0 and file_pawns[file]['black'] == 0:\n                bonus = 50\n            # Semi-open file bonus (no own pawns)\n            elif (piece.color == chess.WHITE and file_pawns[file]['white'] == 0) or \\\n                 (piece.color == chess.BLACK and file_pawns[file]['black'] == 0):\n                bonus = 25\n            else:\n                bonus = 0\n            \n            # 7th rank bonus for rooks\n            if (piece.color == chess.WHITE and rank == 6) or (piece.color == chess.BLACK and rank == 1):\n                bonus += 30\n            \n            if piece.color == chess.WHITE:\n                white_score += bonus\n            else:\n                black_score += bonus\n    \n    return float(white_score - black_score)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Control of key central squares e4, e5, d4, d5\"\n    central_squares = [chess.E4, chess.E5, chess.D4, chess.D5]\n    white_control = 0\n    black_control = 0\n    \n    for square in central_squares:\n        white_attackers = len(board.attackers(chess.WHITE, square))\n        black_attackers = len(board.attackers(chess.BLACK, square))\n        \n        # Occupancy bonus\n        piece = board.piece_at(square)\n        if piece:\n            if piece.color == chess.WHITE:\n                white_control += 20\n            else:\n                black_control += 20\n        \n        # Control differential\n        white_control += white_attackers * 5\n        black_control += black_attackers * 5\n    \n    return float(white_control - black_control)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Control of critical central squares e4, e5, d4, d5 by pieces and pawns\"\n    central_squares = [chess.E4, chess.E5, chess.D4, chess.D5]\n    white_control = 0\n    black_control = 0\n    \n    for square in central_squares:\n        piece = board.piece_at(square)\n        if piece:\n            if piece.color == chess.WHITE:\n                white_control += 15\n            else:\n                black_control += 15\n        \n        white_attackers = len(board.attackers(chess.WHITE, square))\n        black_attackers = len(board.attackers(chess.BLACK, square))\n        white_control += white_attackers * 3\n        black_control += black_attackers * 3\n    \n    return float(white_control - black_control)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Open and semi-open file control by rooks and queens\"\n    white_score = 0\n    black_score = 0\n    \n    for file_idx in range(8):\n        white_pawns = 0\n        black_pawns = 0\n        white_heavy = 0\n        black_heavy = 0\n        \n        for rank in range(8):\n            square = chess.square(file_idx, rank)\n            piece = board.piece_at(square)\n            if piece:\n                if piece.piece_type == chess.PAWN:\n                    if piece.color == chess.WHITE:\n                        white_pawns += 1\n                    else:\n                        black_pawns += 1\n                elif piece.piece_type in [chess.ROOK, chess.QUEEN]:\n                    if piece.color == chess.WHITE:\n                        white_heavy += 1\n                    else:\n                        black_heavy += 1\n        \n        if white_pawns == 0 and white_heavy > 0:\n            white_score += 25 if black_pawns == 0 else 15\n        if black_pawns == 0 and black_heavy > 0:\n            black_score += 25 if white_pawns == 0 else 15\n    \n    return float(white_score - black_score)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Pawn structure evaluation including doubled, isolated, and backward pawns\"\n    white_penalty = 0\n    black_penalty = 0\n    \n    pawn_files = {chess.WHITE: [], chess.BLACK: []}\n    for square in chess.SQUARES:\n        piece = board.piece_at(square)\n        if piece and piece.piece_type == chess.PAWN:\n            file = chess.square_file(square)\n            pawn_files[piece.color].append(file)\n    \n    for color in [chess.WHITE, chess.BLACK]:\n        files = pawn_files[color]\n        penalty = 0\n        \n        # Doubled pawns penalty\n        for file in range(8):\n            count = files.count(file)\n            if count > 1:\n                penalty += (count - 1) * 20\n        \n        # Isolated pawns penalty\n        for file in files:\n            if (file - 1 not in files) and (file + 1 not in files):\n                penalty += 25\n        \n        if color == chess.WHITE:\n            white_penalty = penalty\n        else:\n            black_penalty = penalty\n    \n    return float(black_penalty - white_penalty)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Passed pawn advancement bonus weighted by file and rank progression\"\n    white_passed_bonus = 0\n    black_passed_bonus = 0\n    \n    for square in chess.SQUARES:\n        piece = board.piece_at(square)\n        if piece and piece.piece_type == chess.PAWN:\n            file, rank = chess.square_file(square), chess.square_rank(square)\n            is_passed = True\n            \n            # Check if pawn is passed (no enemy pawns blocking or controlling)\n            enemy_color = chess.BLACK if piece.color == chess.WHITE else chess.WHITE\n            direction = 1 if piece.color == chess.WHITE else -1\n            \n            for check_file in [file-1, file, file+1]:\n                if 0 <= check_file <= 7:\n                    for check_rank in range(rank + direction, 8 if piece.color == chess.WHITE else -1, direction):\n                        if 0 <= check_rank <= 7:\n                            check_square = chess.square(check_file, check_rank)\n                            check_piece = board.piece_at(check_square)\n                            if check_piece and check_piece.piece_type == chess.PAWN and check_piece.color == enemy_color:\n                                is_passed = False\n                                break\n                if not is_passed:\n                    break\n            \n            if is_passed:\n                advancement = rank if piece.color == chess.WHITE else 7 - rank\n                bonus = advancement * advancement * 10\n                if piece.color == chess.WHITE:\n                    white_passed_bonus += bonus\n                else:\n                    black_passed_bonus += bonus\n    \n    return float(white_passed_bonus - black_passed_bonus)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Control of key central squares (e4, e5, d4, d5) by pieces and pawns\"\n    central_squares = [chess.E4, chess.E5, chess.D4, chess.D5]\n    white_control = 0\n    black_control = 0\n    \n    for square in central_squares:\n        piece = board.piece_at(square)\n        if piece:\n            weight = 20 if piece.piece_type == chess.PAWN else 10\n            if piece.color == chess.WHITE:\n                white_control += weight\n            else:\n                black_control += weight\n        \n        # Add points for attacking these squares\n        if board.is_attacked_by(chess.WHITE, square):\n            white_control += 5\n        if board.is_attacked_by(chess.BLACK, square):\n            black_control += 5\n    \n    return float(white_control - black_control)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Tempo advantage measured by developing moves vs non-developing moves\"\n    if board.fullmove_number > 15:\n        return 0.0\n    \n    developed_pieces = {chess.WHITE: 0, chess.BLACK: 0}\n    starting_squares = {\n        chess.WHITE: [chess.B1, chess.C1, chess.F1, chess.G1],\n        chess.BLACK: [chess.B8, chess.C8, chess.F8, chess.G8]\n    }\n    \n    for color in [chess.WHITE, chess.BLACK]:\n        for square in chess.SQUARES:\n            piece = board.piece_at(square)\n            if piece and piece.color == color and piece.piece_type in [chess.KNIGHT, chess.BISHOP]:\n                if square not in starting_squares[color]:\n                    developed_pieces[color] += 1\n    \n    tempo_score = (developed_pieces[chess.WHITE] - developed_pieces[chess.BLACK]) * 25\n    return float(tempo_score)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Pawn structure quality: isolated, doubled, and backward pawns penalty\"\n    white_penalty = 0\n    black_penalty = 0\n    \n    pawn_positions = {chess.WHITE: [], chess.BLACK: []}\n    for square in chess.SQUARES:\n        piece = board.piece_at(square)\n        if piece and piece.piece_type == chess.PAWN:\n            pawn_positions[piece.color].append(square)\n    \n    for color in [chess.WHITE, chess.BLACK]:\n        for square in pawn_positions[color]:\n            file, rank = chess.square_file(square), chess.square_rank(square)\n            penalty = 0\n            \n            # Isolated pawn check\n            adjacent_files = [file-1, file+1]\n            has_adjacent_pawn = any(chess.square_file(p) in adjacent_files for p in pawn_positions[color])\n            if not has_adjacent_pawn:\n                penalty += 15\n            \n            # Doubled pawn check\n            same_file_pawns = sum(1 for p in pawn_positions[color] if chess.square_file(p) == file)\n            if same_file_pawns > 1:\n                penalty += 10\n            \n            # Backward pawn check\n            direction = 1 if color == chess.WHITE else -1\n            support_rank = rank - direction\n            has_support = any(chess.square_file(p) in adjacent_files and chess.square_rank(p) == support_rank for p in pawn_positions[color])\n            can_advance = 0 <= rank + direction <= 7\n            if can_advance and not has_support:\n                advance_square = chess.square(file, rank + direction)\n                enemy_pawns = [p for p in pawn_positions[chess.BLACK if color == chess.WHITE else chess.WHITE]]\n                blocks_advance = any(chess.square_file(p) in adjacent_files and \n                                   (chess.square_rank(p) - (rank + direction)) * direction >= 0 for p in enemy_pawns)\n                if blocks_advance:\n                    penalty += 12\n            \n            if color == chess.WHITE:\n                white_penalty += penalty\n            else:\n                black_penalty += penalty\n    \n    return float(black_penalty - white_penalty)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Knight outpost strength on 6th/7th rank with pawn support\"\n    white_outposts = 0\n    black_outposts = 0\n    \n    for square in chess.SQUARES:\n        piece = board.piece_at(square)\n        if piece and piece.piece_type == chess.KNIGHT:\n            file, rank = chess.square_file(square), chess.square_rank(square)\n            \n            if piece.color == chess.WHITE and rank >= 5:\n                # Check for pawn support\n                support_squares = [chess.square(file-1, rank-1), chess.square(file+1, rank-1)]\n                for support_sq in support_squares:\n                    if 0 <= chess.square_file(support_sq) <= 7:\n                        support_piece = board.piece_at(support_sq)\n                        if support_piece and support_piece.piece_type == chess.PAWN and support_piece.color == chess.WHITE:\n                            # Check if enemy pawns can attack this square\n                            enemy_can_attack = False\n                            for enemy_file in [file-1, file+1]:\n                                if 0 <= enemy_file <= 7:\n                                    enemy_sq = chess.square(enemy_file, rank+1)\n                                    if chess.square_rank(enemy_sq) <= 7:\n                                        enemy_piece = board.piece_at(enemy_sq)\n                                        if enemy_piece and enemy_piece.piece_type == chess.PAWN and enemy_piece.color == chess.BLACK:\n                                            enemy_can_attack = True\n                            if not enemy_can_attack:\n                                white_outposts += (rank - 4) * 15\n                                break\n            \n            elif piece.color == chess.BLACK and rank <= 2:\n                support_squares = [chess.square(file-1, rank+1), chess.square(file+1, rank+1)]\n                for support_sq in support_squares:\n                    if 0 <= chess.square_file(support_sq) <= 7:\n                        support_piece = board.piece_at(support_sq)\n                        if support_piece and support_piece.piece_type == chess.PAWN and support_piece.color == chess.BLACK:\n                            enemy_can_attack = False\n                            for enemy_file in [file-1, file+1]:\n                                if 0 <= enemy_file <= 7:\n                                    enemy_sq = chess.square(enemy_file, rank-1)\n                                    if chess.square_rank(enemy_sq) >= 0:\n                                        enemy_piece = board.piece_at(enemy_sq)\n                                        if enemy_piece and enemy_piece.piece_type == chess.PAWN and enemy_piece.color == chess.WHITE:\n                                            enemy_can_attack = True\n                            if not enemy_can_attack:\n                                black_outposts += (3 - rank) * 15\n                                break\n    \n    return float(white_outposts - black_outposts)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Rook penetration on 7th and 8th ranks weighted by enemy king exposure\"\n    penetration_score = 0\n    \n    # Find enemy king positions\n    white_king_file = black_king_file = None\n    for square in chess.SQUARES:\n        piece = board.piece_at(square)\n        if piece and piece.piece_type == chess.KING:\n            if piece.color == chess.WHITE:\n                white_king_file = chess.square_file(square)\n            else:\n                black_king_file = chess.square_file(square)\n    \n    for square in chess.SQUARES:\n        piece = board.piece_at(square)\n        if piece and piece.piece_type == chess.ROOK:\n            rank = chess.square_rank(square)\n            file = chess.square_file(square)\n            \n            if piece.color == chess.WHITE and rank >= 6:  # 7th or 8th rank\n                base_score = 25 if rank == 6 else 15\n                # Bonus if near enemy king\n                if black_king_file is not None and abs(file - black_king_file) <= 2:\n                    base_score *= 1.5\n                penetration_score += base_score\n                \n            elif piece.color == chess.BLACK and rank <= 1:  # 2nd or 1st rank\n                base_score = 25 if rank == 1 else 15\n                # Bonus if near enemy king\n                if white_king_file is not None and abs(file - white_king_file) <= 2:\n                    base_score *= 1.5\n                penetration_score -= base_score\n    \n    return float(penetration_score)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Piece coordination measured by mutual protection chains\"\n    white_coordination = black_coordination = 0\n    \n    for square in chess.SQUARES:\n        piece = board.piece_at(square)\n        if piece and piece.piece_type != chess.KING:\n            # Count how many friendly pieces protect this piece\n            protectors = len(board.attackers(piece.color, square))\n            \n            # Weight by piece value\n            piece_weights = {chess.PAWN: 1, chess.KNIGHT: 3, chess.BISHOP: 3, chess.ROOK: 5, chess.QUEEN: 9}\n            weight = piece_weights.get(piece.piece_type, 0)\n            coordination_value = protectors * weight\n            \n            if piece.color == chess.WHITE:\n                white_coordination += coordination_value\n            else:\n                black_coordination += coordination_value\n    \n    return float(white_coordination - black_coordination)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Space advantage in central and extended center squares\"\n    center_squares = [chess.D4, chess.D5, chess.E4, chess.E5]\n    extended_center = [chess.C3, chess.C4, chess.C5, chess.C6, chess.D3, chess.D6, \n                      chess.E3, chess.E6, chess.F3, chess.F4, chess.F5, chess.F6]\n    \n    white_space = black_space = 0\n    \n    # Control of center squares\n    for square in center_squares:\n        if board.is_attacked_by(chess.WHITE, square):\n            white_space += 10\n        if board.is_attacked_by(chess.BLACK, square):\n            black_space += 10\n    \n    # Control of extended center\n    for square in extended_center:\n        if board.is_attacked_by(chess.WHITE, square):\n            white_space += 5\n        if board.is_attacked_by(chess.BLACK, square):\n            black_space += 5\n    \n    return float(white_space - black_space)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Rook activity on open and semi-open files\"\n    white_rook_activity = 0\n    black_rook_activity = 0\n    \n    for square in chess.SQUARES:\n        piece = board.piece_at(square)\n        if piece and piece.piece_type == chess.ROOK:\n            file = chess.square_file(square)\n            rank = chess.square_rank(square)\n            \n            # Check if file is open or semi-open\n            own_pawns = 0\n            enemy_pawns = 0\n            for r in range(8):\n                file_piece = board.piece_at(chess.square(file, r))\n                if file_piece and file_piece.piece_type == chess.PAWN:\n                    if file_piece.color == piece.color:\n                        own_pawns += 1\n                    else:\n                        enemy_pawns += 1\n            \n            activity = 0\n            if own_pawns == 0 and enemy_pawns == 0:  # Open file\n                activity += 30\n            elif own_pawns == 0:  # Semi-open file\n                activity += 20\n            \n            # Bonus for 7th/2nd rank\n            if (piece.color == chess.WHITE and rank == 6) or (piece.color == chess.BLACK and rank == 1):\n                activity += 25\n            \n            if piece.color == chess.WHITE:\n                white_rook_activity += activity\n            else:\n                black_rook_activity += activity\n    \n    return float(white_rook_activity - black_rook_activity)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Pawn structure weaknesses: doubled, isolated, and backward pawns\"\n    white_weakness = 0\n    black_weakness = 0\n    \n    for file in range(8):\n        white_pawns = []\n        black_pawns = []\n        for rank in range(8):\n            piece = board.piece_at(chess.square(file, rank))\n            if piece and piece.piece_type == chess.PAWN:\n                if piece.color == chess.WHITE:\n                    white_pawns.append(rank)\n                else:\n                    black_pawns.append(rank)\n        \n        # Doubled pawns penalty\n        if len(white_pawns) > 1:\n            white_weakness += 15 * (len(white_pawns) - 1)\n        if len(black_pawns) > 1:\n            black_weakness += 15 * (len(black_pawns) - 1)\n        \n        # Isolated pawns penalty\n        has_adjacent = False\n        for adj_file in [file - 1, file + 1]:\n            if 0 <= adj_file <= 7:\n                for rank in range(8):\n                    piece = board.piece_at(chess.square(adj_file, rank))\n                    if piece and piece.piece_type == chess.PAWN:\n                        if piece.color == chess.WHITE and white_pawns:\n                            has_adjacent = True\n                        elif piece.color == chess.BLACK and black_pawns:\n                            has_adjacent = True\n        \n        if white_pawns and not has_adjacent:\n            white_weakness += 20\n        if black_pawns and not has_adjacent:\n            black_weakness += 20\n    \n    return float(black_weakness - white_weakness)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Seventh rank penetration by rooks and queens\"\n    score = 0\n    for square in chess.SQUARES:\n        piece = board.piece_at(square)\n        if piece and piece.piece_type in [chess.ROOK, chess.QUEEN]:\n            rank = chess.square_rank(square)\n            if piece.color == chess.WHITE and rank == 6:\n                score += 30 if piece.piece_type == chess.ROOK else 25\n            elif piece.color == chess.BLACK and rank == 1:\n                score -= 30 if piece.piece_type == chess.ROOK else 25\n    return float(score)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Passed pawn advancement and support evaluation\"\n    score = 0\n    for square in chess.SQUARES:\n        piece = board.piece_at(square)\n        if piece and piece.piece_type == chess.PAWN:\n            file, rank = chess.square_file(square), chess.square_rank(square)\n            is_passed = True\n            \n            # Check if any enemy pawns block this pawn's path\n            enemy_color = chess.BLACK if piece.color == chess.WHITE else chess.WHITE\n            direction = 1 if piece.color == chess.WHITE else -1\n            \n            for check_file in [file-1, file, file+1]:\n                if 0 <= check_file <= 7:\n                    for check_rank in range(rank + direction, 8 if piece.color == chess.WHITE else -1, direction):\n                        if 0 <= check_rank <= 7:\n                            check_piece = board.piece_at(chess.square(check_file, check_rank))\n                            if check_piece and check_piece.piece_type == chess.PAWN and check_piece.color == enemy_color:\n                                is_passed = False\n                                break\n                if not is_passed:\n                    break\n            \n            if is_passed:\n                advancement = rank if piece.color == chess.WHITE else 7 - rank\n                passed_score = advancement * advancement * 10\n                if piece.color == chess.WHITE:\n                    score += passed_score\n                else:\n                    score -= passed_score\n    \n    return float(score)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Bishop pair advantage and diagonal control\"\n    white_bishops = 0\n    black_bishops = 0\n    white_diagonal_control = 0\n    black_diagonal_control = 0\n    \n    for square in chess.SQUARES:\n        piece = board.piece_at(square)\n        if piece and piece.piece_type == chess.BISHOP:\n            if piece.color == chess.WHITE:\n                white_bishops += 1\n                white_diagonal_control += len([move for move in board.legal_moves if move.from_square == square])\n            else:\n                black_bishops += 1\n                black_diagonal_control += len([move for move in board.legal_moves if move.from_square == square])\n    \n    bishop_pair_bonus = 0\n    if white_bishops >= 2:\n        bishop_pair_bonus += 50\n    if black_bishops >= 2:\n        bishop_pair_bonus -= 50\n    \n    return float(bishop_pair_bonus + white_diagonal_control - black_diagonal_control)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Pawn structure quality including doubled, isolated, and backward pawns\"\n    white_penalty = 0\n    black_penalty = 0\n    \n    for square in chess.SQUARES:\n        piece = board.piece_at(square)\n        if piece and piece.piece_type == chess.PAWN:\n            file, rank = chess.square_file(square), chess.square_rank(square)\n            \n            # Check for doubled pawns\n            for other_rank in range(8):\n                if other_rank != rank:\n                    other_square = chess.square(file, other_rank)\n                    other_piece = board.piece_at(other_square)\n                    if other_piece and other_piece.piece_type == chess.PAWN and other_piece.color == piece.color:\n                        if piece.color == chess.WHITE:\n                            white_penalty += 15\n                        else:\n                            black_penalty += 15\n                        break\n            \n            # Check for isolated pawns\n            has_adjacent = False\n            for adj_file in [file-1, file+1]:\n                if 0 <= adj_file <= 7:\n                    for check_rank in range(8):\n                        check_piece = board.piece_at(chess.square(adj_file, check_rank))\n                        if check_piece and check_piece.piece_type == chess.PAWN and check_piece.color == piece.color:\n                            has_adjacent = True\n                            break\n                if has_adjacent:\n                    break\n            \n            if not has_adjacent:\n                if piece.color == chess.WHITE:\n                    white_penalty += 20\n                else:\n                    black_penalty += 20\n    \n    return float(black_penalty - white_penalty)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Knight outpost evaluation on strong squares in enemy territory\"\n    score = 0\n    \n    for square in chess.SQUARES:\n        piece = board.piece_at(square)\n        if piece and piece.piece_type == chess.KNIGHT:\n            file, rank = chess.square_file(square), chess.square_rank(square)\n            \n            # Check if knight is in enemy territory\n            in_enemy_territory = (piece.color == chess.WHITE and rank >= 4) or (piece.color == chess.BLACK and rank <= 3)\n            \n            if in_enemy_territory:\n                # Check if protected by own pawn\n                pawn_support = False\n                for support_file in [file-1, file+1]:\n                    if 0 <= support_file <= 7:\n                        support_rank = rank + (-1 if piece.color == chess.WHITE else 1)\n                        if 0 <= support_rank <= 7:\n                            support_piece = board.piece_at(chess.square(support_file, support_rank))\n                            if support_piece and support_piece.piece_type == chess.PAWN and support_piece.color == piece.color:\n                                pawn_support = True\n                                break\n                \n                # Check if enemy pawns can attack this square\n                enemy_pawn_attack = False\n                for attack_file in [file-1, file+1]:\n                    if 0 <= attack_file <= 7:\n                        attack_rank = rank + (1 if piece.color == chess.WHITE else -1)\n                        if 0 <= attack_rank <= 7:\n                            attack_piece = board.piece_at(chess.square(attack_file, attack_rank))\n                            if attack_piece and attack_piece.piece_type == chess.PAWN and attack_piece.color != piece.color:\n                                enemy_pawn_attack = True\n                                break\n                \n                if pawn_support and not enemy_pawn_attack:\n                    outpost_value = 25\n                    if piece.color == chess.WHITE:\n                        score += outpost_value\n                    else:\n                        score -= outpost_value\n    \n    return float(score)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Endgame king activity and centralization bonus\"\n    piece_count = len(board.piece_map())\n    if piece_count > 20:\n        return 0.0\n    \n    white_king_activity = 0\n    black_king_activity = 0\n    \n    for square in chess.SQUARES:\n        piece = board.piece_at(square)\n        if piece and piece.piece_type == chess.KING:\n            file, rank = chess.square_file(square), chess.square_rank(square)\n            # Distance from center (lower is better in endgame)\n            center_distance = abs(file - 3.5) + abs(rank - 3.5)\n            centralization = (7 - center_distance) * 10\n            \n            # King mobility in endgame\n            mobility = 0\n            for df in [-1, 0, 1]:\n                for dr in [-1, 0, 1]:\n                    if df == 0 and dr == 0:\n                        continue\n                    new_file, new_rank = file + df, rank + dr\n                    if 0 <= new_file <= 7 and 0 <= new_rank <= 7:\n                        target_square = chess.square(new_file, new_rank)\n                        if not board.piece_at(target_square) or board.piece_at(target_square).color != piece.color:\n                            mobility += 5\n            \n            activity = centralization + mobility\n            if piece.color == chess.WHITE:\n                white_king_activity = activity\n            else:\n                black_king_activity = activity\n    \n    return float(white_king_activity - black_king_activity)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Passed pawn evaluation with advancement and support bonuses\"\n    white_passed = 0\n    black_passed = 0\n    \n    for file in range(8):\n        for rank in range(8):\n            piece = board.piece_at(chess.square(file, rank))\n            if piece and piece.piece_type == chess.PAWN:\n                is_passed = True\n                \n                if piece.color == chess.WHITE:\n                    # Check if any black pawns can stop this pawn\n                    for check_rank in range(rank + 1, 8):\n                        for check_file in [file - 1, file, file + 1]:\n                            if 0 <= check_file <= 7:\n                                blocker = board.piece_at(chess.square(check_file, check_rank))\n                                if blocker and blocker.piece_type == chess.PAWN and blocker.color == chess.BLACK:\n                                    is_passed = False\n                                    break\n                        if not is_passed:\n                            break\n                    \n                    if is_passed:\n                        advancement_bonus = (rank - 1) * 20\n                        support_bonus = 10 if board.is_attacked_by(chess.WHITE, chess.square(file, rank)) else 0\n                        white_passed += advancement_bonus + support_bonus\n                \n                else:\n                    for check_rank in range(rank - 1, -1, -1):\n                        for check_file in [file - 1, file, file + 1]:\n                            if 0 <= check_file <= 7:\n                                blocker = board.piece_at(chess.square(check_file, check_rank))\n                                if blocker and blocker.piece_type == chess.PAWN and blocker.color == chess.WHITE:\n                                    is_passed = False\n                                    break\n                        if not is_passed:\n                            break\n                    \n                    if is_passed:\n                        advancement_bonus = (6 - rank) * 20\n                        support_bonus = 10 if board.is_attacked_by(chess.BLACK, chess.square(file, rank)) else 0\n                        black_passed += advancement_bonus + support_bonus\n    \n    return float(white_passed - black_passed)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Passed pawn advancement and promotion potential\"\n    white_passed = 0\n    black_passed = 0\n    \n    for square in chess.SQUARES:\n        piece = board.piece_at(square)\n        if piece and piece.piece_type == chess.PAWN:\n            file, rank = chess.square_file(square), chess.square_rank(square)\n            \n            if piece.color == chess.WHITE:\n                # Check if white pawn is passed\n                is_passed = True\n                for enemy_file in [file - 1, file, file + 1]:\n                    if 0 <= enemy_file <= 7:\n                        for enemy_rank in range(rank + 1, 8):\n                            enemy_square = chess.square(enemy_file, enemy_rank)\n                            enemy_piece = board.piece_at(enemy_square)\n                            if enemy_piece and enemy_piece.piece_type == chess.PAWN and enemy_piece.color == chess.BLACK:\n                                is_passed = False\n                                break\n                        if not is_passed:\n                            break\n                \n                if is_passed:\n                    white_passed += (rank - 1) * 20 + 10\n            else:\n                # Check if black pawn is passed\n                is_passed = True\n                for enemy_file in [file - 1, file, file + 1]:\n                    if 0 <= enemy_file <= 7:\n                        for enemy_rank in range(rank - 1, -1, -1):\n                            enemy_square = chess.square(enemy_file, enemy_rank)\n                            enemy_piece = board.piece_at(enemy_square)\n                            if enemy_piece and enemy_piece.piece_type == chess.PAWN and enemy_piece.color == chess.WHITE:\n                                is_passed = False\n                                break\n                        if not is_passed:\n                            break\n                \n                if is_passed:\n                    black_passed += (6 - rank) * 20 + 10\n    \n    return float(white_passed - black_passed)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Rook activity on open and semi-open files\"\n    white_rook_activity = 0\n    black_rook_activity = 0\n    \n    for square in chess.SQUARES:\n        piece = board.piece_at(square)\n        if piece and piece.piece_type == chess.ROOK:\n            file = chess.square_file(square)\n            \n            # Check if file is open or semi-open\n            own_pawns = 0\n            enemy_pawns = 0\n            \n            for rank in range(8):\n                file_square = chess.square(file, rank)\n                file_piece = board.piece_at(file_square)\n                if file_piece and file_piece.piece_type == chess.PAWN:\n                    if file_piece.color == piece.color:\n                        own_pawns += 1\n                    else:\n                        enemy_pawns += 1\n            \n            activity = 0\n            if own_pawns == 0 and enemy_pawns == 0:\n                activity = 25  # Open file\n            elif own_pawns == 0 and enemy_pawns > 0:\n                activity = 15  # Semi-open file\n            \n            # Add mobility bonus\n            mobility = len([move for move in board.legal_moves if move.from_square == square])\n            activity += mobility * 2\n            \n            if piece.color == chess.WHITE:\n                white_rook_activity += activity\n            else:\n                black_rook_activity += activity\n    \n    return float(white_rook_activity - black_rook_activity)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Passed pawn advancement bonus weighted by proximity to promotion\"\n    passed_pawn_score = 0\n    \n    for square in chess.SQUARES:\n        piece = board.piece_at(square)\n        if piece and piece.piece_type == chess.PAWN:\n            file = chess.square_file(square)\n            rank = chess.square_rank(square)\n            \n            # Check if pawn is passed\n            is_passed = True\n            if piece.color == chess.WHITE:\n                for check_rank in range(rank + 1, 8):\n                    for check_file in [file - 1, file, file + 1]:\n                        if 0 <= check_file <= 7:\n                            check_piece = board.piece_at(chess.square(check_file, check_rank))\n                            if check_piece and check_piece.piece_type == chess.PAWN and check_piece.color == chess.BLACK:\n                                is_passed = False\n                                break\n                    if not is_passed:\n                        break\n                if is_passed:\n                    bonus = (rank - 1) ** 2 * 10\n                    passed_pawn_score += bonus\n            else:\n                for check_rank in range(0, rank):\n                    for check_file in [file - 1, file, file + 1]:\n                        if 0 <= check_file <= 7:\n                            check_piece = board.piece_at(chess.square(check_file, check_rank))\n                            if check_piece and check_piece.piece_type == chess.PAWN and check_piece.color == chess.WHITE:\n                                is_passed = False\n                                break\n                    if not is_passed:\n                        break\n                if is_passed:\n                    bonus = (6 - rank) ** 2 * 10\n                    passed_pawn_score -= bonus\n    \n    return float(passed_pawn_score)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Center control evaluation counting pieces attacking central squares\"\n    center_squares = [chess.D4, chess.D5, chess.E4, chess.E5]\n    extended_center = [chess.C3, chess.C4, chess.C5, chess.C6, chess.D3, chess.D6, chess.E3, chess.E6, chess.F3, chess.F4, chess.F5, chess.F6]\n    \n    control_score = 0\n    \n    for square in center_squares:\n        white_attackers = len(board.attackers(chess.WHITE, square))\n        black_attackers = len(board.attackers(chess.BLACK, square))\n        control_score += (white_attackers - black_attackers) * 15\n    \n    for square in extended_center:\n        white_attackers = len(board.attackers(chess.WHITE, square))\n        black_attackers = len(board.attackers(chess.BLACK, square))\n        control_score += (white_attackers - black_attackers) * 5\n    \n    return float(control_score)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Piece development bonus for knights and bishops moved from starting squares\"\n    development_score = 0\n    \n    starting_squares = {\n        chess.WHITE: [chess.B1, chess.G1, chess.C1, chess.F1],\n        chess.BLACK: [chess.B8, chess.G8, chess.C8, chess.F8]\n    }\n    \n    for color in [chess.WHITE, chess.BLACK]:\n        developed_pieces = 0\n        for square in starting_squares[color]:\n            piece = board.piece_at(square)\n            if not piece or piece.piece_type not in [chess.KNIGHT, chess.BISHOP] or piece.color != color:\n                developed_pieces += 1\n        \n        multiplier = 1 if color == chess.WHITE else -1\n        development_score += developed_pieces * 25 * multiplier\n    \n    return float(development_score)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Passed pawn advancement bonus weighted by file and protection\"\n    white_passed = 0\n    black_passed = 0\n    \n    for square in chess.SQUARES:\n        piece = board.piece_at(square)\n        if piece and piece.piece_type == chess.PAWN:\n            file, rank = chess.square_file(square), chess.square_rank(square)\n            is_passed = True\n            \n            if piece.color == chess.WHITE:\n                # Check for blocking enemy pawns ahead\n                for check_rank in range(rank + 1, 8):\n                    for check_file in [file - 1, file, file + 1]:\n                        if 0 <= check_file <= 7:\n                            check_square = chess.square(check_file, check_rank)\n                            blocking_piece = board.piece_at(check_square)\n                            if blocking_piece and blocking_piece.piece_type == chess.PAWN and blocking_piece.color == chess.BLACK:\n                                is_passed = False\n                                break\n                    if not is_passed:\n                        break\n                \n                if is_passed and rank >= 3:\n                    bonus = (rank - 2) * 15\n                    # Extra bonus for protected passed pawns\n                    if board.is_attacked_by(chess.WHITE, square):\n                        bonus *= 1.5\n                    white_passed += bonus\n            else:\n                for check_rank in range(rank - 1, -1, -1):\n                    for check_file in [file - 1, file, file + 1]:\n                        if 0 <= check_file <= 7:\n                            check_square = chess.square(check_file, check_rank)\n                            blocking_piece = board.piece_at(check_square)\n                            if blocking_piece and blocking_piece.piece_type == chess.PAWN and blocking_piece.color == chess.WHITE:\n                                is_passed = False\n                                break\n                    if not is_passed:\n                        break\n                \n                if is_passed and rank <= 4:\n                    bonus = (5 - rank) * 15\n                    if board.is_attacked_by(chess.BLACK, square):\n                        bonus *= 1.5\n                    black_passed += bonus\n    \n    return float(white_passed - black_passed)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Rook activity on open and semi-open files\"\n    white_rook_activity = 0\n    black_rook_activity = 0\n    \n    for square in chess.SQUARES:\n        piece = board.piece_at(square)\n        if piece and piece.piece_type == chess.ROOK:\n            file = chess.square_file(square)\n            \n            # Check if file is open (no pawns) or semi-open (no own pawns)\n            own_pawns = enemy_pawns = 0\n            for rank in range(8):\n                check_square = chess.square(file, rank)\n                check_piece = board.piece_at(check_square)\n                if check_piece and check_piece.piece_type == chess.PAWN:\n                    if check_piece.color == piece.color:\n                        own_pawns += 1\n                    else:\n                        enemy_pawns += 1\n            \n            activity = 0\n            if own_pawns == 0 and enemy_pawns == 0:  # Open file\n                activity = 30\n            elif own_pawns == 0:  # Semi-open file\n                activity = 20\n            \n            # Bonus for 7th/2nd rank\n            rank = chess.square_rank(square)\n            if (piece.color == chess.WHITE and rank == 6) or (piece.color == chess.BLACK and rank == 1):\n                activity += 25\n            \n            if piece.color == chess.WHITE:\n                white_rook_activity += activity\n            else:\n                black_rook_activity += activity\n    \n    return float(white_rook_activity - black_rook_activity)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Rook on open and semi-open files weighted by file importance\"\n    white_score = 0\n    black_score = 0\n    \n    for file_idx in range(8):\n        white_pawns = sum(1 for rank in range(8) if board.piece_at(chess.square(file_idx, rank)) and \n                         board.piece_at(chess.square(file_idx, rank)).piece_type == chess.PAWN and \n                         board.piece_at(chess.square(file_idx, rank)).color == chess.WHITE)\n        black_pawns = sum(1 for rank in range(8) if board.piece_at(chess.square(file_idx, rank)) and \n                         board.piece_at(chess.square(file_idx, rank)).piece_type == chess.PAWN and \n                         board.piece_at(chess.square(file_idx, rank)).color == chess.BLACK)\n        \n        file_multiplier = 1.5 if file_idx in [3, 4] else 1.0\n        \n        for rank in range(8):\n            piece = board.piece_at(chess.square(file_idx, rank))\n            if piece and piece.piece_type == chess.ROOK:\n                if piece.color == chess.WHITE:\n                    if white_pawns == 0 and black_pawns == 0:\n                        white_score += 50 * file_multiplier\n                    elif white_pawns == 0:\n                        white_score += 25 * file_multiplier\n                else:\n                    if white_pawns == 0 and black_pawns == 0:\n                        black_score += 50 * file_multiplier\n                    elif black_pawns == 0:\n                        black_score += 25 * file_multiplier\n    \n    return float(white_score - black_score)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Weak squares (holes) in pawn structure that can be occupied by enemy pieces\"\n    white_holes = 0\n    black_holes = 0\n    \n    for square in chess.SQUARES:\n        file, rank = chess.square_file(square), chess.square_rank(square)\n        \n        if 2 <= rank <= 5:\n            is_white_hole = True\n            is_black_hole = True\n            \n            for check_file in [file - 1, file + 1]:\n                if 0 <= check_file <= 7:\n                    for check_rank in range(rank, 8):\n                        check_piece = board.piece_at(chess.square(check_file, check_rank))\n                        if check_piece and check_piece.piece_type == chess.PAWN and check_piece.color == chess.WHITE:\n                            is_white_hole = False\n                    \n                    for check_rank in range(0, rank + 1):\n                        check_piece = board.piece_at(chess.square(check_file, check_rank))\n                        if check_piece and check_piece.piece_type == chess.PAWN and check_piece.color == chess.BLACK:\n                            is_black_hole = False\n            \n            own_pawn = board.piece_at(square)\n            if own_pawn and own_pawn.piece_type == chess.PAWN:\n                is_white_hole = False\n                is_black_hole = False\n            \n            if is_white_hole and rank >= 4:\n                white_holes += (rank - 3) * 10\n            if is_black_hole and rank <= 3:\n                black_holes += (4 - rank) * 10\n    \n    return float(black_holes - white_holes)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Rook activity on open and semi-open files\"\n    white_score = 0\n    black_score = 0\n    \n    for square in chess.SQUARES:\n        piece = board.piece_at(square)\n        if piece and piece.piece_type == chess.ROOK:\n            file = chess.square_file(square)\n            \n            # Check if file is open (no pawns) or semi-open (no own pawns)\n            own_pawns = 0\n            enemy_pawns = 0\n            for rank in range(8):\n                check_piece = board.piece_at(chess.square(file, rank))\n                if check_piece and check_piece.piece_type == chess.PAWN:\n                    if check_piece.color == piece.color:\n                        own_pawns += 1\n                    else:\n                        enemy_pawns += 1\n            \n            file_bonus = 0\n            if own_pawns == 0 and enemy_pawns == 0:\n                file_bonus = 30  # Open file\n            elif own_pawns == 0:\n                file_bonus = 15  # Semi-open file\n            \n            if piece.color == chess.WHITE:\n                white_score += file_bonus\n            else:\n                black_score += file_bonus\n    \n    return float(white_score - black_score)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Pawn structure weaknesses: isolated, doubled, and backward pawns\"\n    white_weakness = 0\n    black_weakness = 0\n    \n    for file in range(8):\n        white_pawns_on_file = []\n        black_pawns_on_file = []\n        \n        for rank in range(8):\n            piece = board.piece_at(chess.square(file, rank))\n            if piece and piece.piece_type == chess.PAWN:\n                if piece.color == chess.WHITE:\n                    white_pawns_on_file.append(rank)\n                else:\n                    black_pawns_on_file.append(rank)\n        \n        # Doubled pawns penalty\n        if len(white_pawns_on_file) > 1:\n            white_weakness += 20 * (len(white_pawns_on_file) - 1)\n        if len(black_pawns_on_file) > 1:\n            black_weakness += 20 * (len(black_pawns_on_file) - 1)\n        \n        # Isolated pawns penalty\n        has_adjacent_white = False\n        has_adjacent_black = False\n        for adj_file in [file - 1, file + 1]:\n            if 0 <= adj_file <= 7:\n                for rank in range(8):\n                    adj_piece = board.piece_at(chess.square(adj_file, rank))\n                    if adj_piece and adj_piece.piece_type == chess.PAWN:\n                        if adj_piece.color == chess.WHITE:\n                            has_adjacent_white = True\n                        else:\n                            has_adjacent_black = True\n        \n        if white_pawns_on_file and not has_adjacent_white:\n            white_weakness += 15\n        if black_pawns_on_file and not has_adjacent_black:\n            black_weakness += 15\n    \n    return float(black_weakness - white_weakness)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Knight outpost evaluation based on strong squares defended by pawns\"\n    white_outposts = 0\n    black_outposts = 0\n    \n    for square in chess.SQUARES:\n        piece = board.piece_at(square)\n        if piece and piece.piece_type == chess.KNIGHT:\n            file, rank = chess.square_file(square), chess.square_rank(square)\n            \n            # Check if knight is defended by own pawn\n            defended_by_pawn = False\n            pawn_squares = []\n            if piece.color == chess.WHITE:\n                pawn_squares = [chess.square(file-1, rank-1), chess.square(file+1, rank-1)]\n            else:\n                pawn_squares = [chess.square(file-1, rank+1), chess.square(file+1, rank+1)]\n            \n            for pawn_sq in pawn_squares:\n                if 0 <= chess.square_file(pawn_sq) <= 7 and 0 <= chess.square_rank(pawn_sq) <= 7:\n                    pawn_piece = board.piece_at(pawn_sq)\n                    if pawn_piece and pawn_piece.piece_type == chess.PAWN and pawn_piece.color == piece.color:\n                        defended_by_pawn = True\n                        break\n            \n            if defended_by_pawn:\n                # Check if enemy pawns can attack this square\n                enemy_can_attack = False\n                enemy_color = chess.BLACK if piece.color == chess.WHITE else chess.WHITE\n                enemy_pawn_files = [file-1, file+1]\n                \n                for enemy_file in enemy_pawn_files:\n                    if 0 <= enemy_file <= 7:\n                        enemy_rank = rank + (1 if piece.color == chess.BLACK else -1)\n                        if 0 <= enemy_rank <= 7:\n                            for check_rank in range(enemy_rank, 8 if enemy_color == chess.WHITE else -1, 1 if enemy_color == chess.WHITE else -1):\n                                if 0 <= check_rank <= 7:\n                                    check_square = chess.square(enemy_file, check_rank)\n                                    check_piece = board.piece_at(check_square)\n                                    if check_piece and check_piece.piece_type == chess.PAWN and check_piece.color == enemy_color:\n                                        enemy_can_attack = True\n                                        break\n                                if enemy_can_attack:\n                                    break\n                \n                if not enemy_can_attack:\n                    outpost_value = 25\n                    if 2 <= rank <= 5:  # Extra bonus for central ranks\n                        outpost_value += 15\n                    \n                    if piece.color == chess.WHITE:\n                        white_outposts += outpost_value\n                    else:\n                        black_outposts += outpost_value\n    \n    return float(white_outposts - black_outposts)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Control of key central squares e4, e5, d4, d5 by pieces and pawns\"\n    central_squares = [chess.E4, chess.E5, chess.D4, chess.D5]\n    white_control = 0\n    black_control = 0\n    \n    for square in central_squares:\n        piece = board.piece_at(square)\n        if piece:\n            weight = 3 if piece.piece_type == chess.PAWN else 2\n            if piece.color == chess.WHITE:\n                white_control += weight\n            else:\n                black_control += weight\n        \n        white_attackers = len(board.attackers(chess.WHITE, square))\n        black_attackers = len(board.attackers(chess.BLACK, square))\n        white_control += white_attackers\n        black_control += black_attackers\n    \n    return float(white_control - black_control)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Piece coordination measured by mutual protection between pieces\"\n    white_protection = 0\n    black_protection = 0\n    \n    for square in chess.SQUARES:\n        piece = board.piece_at(square)\n        if piece and piece.piece_type != chess.KING:\n            protection_count = len(board.attackers(piece.color, square))\n            piece_value = {chess.PAWN: 1, chess.KNIGHT: 3, chess.BISHOP: 3, chess.ROOK: 5, chess.QUEEN: 9}.get(piece.piece_type, 0)\n            \n            if piece.color == chess.WHITE:\n                white_protection += protection_count * piece_value\n            else:\n                black_protection += protection_count * piece_value\n    \n    return float(white_protection - black_protection)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Weak squares in opponent territory controlled by pieces\"\n    white_weak_control = 0\n    black_weak_control = 0\n    \n    for square in chess.SQUARES:\n        rank = chess.square_rank(square)\n        \n        if rank >= 5:  # Black's territory\n            if board.attackers(chess.WHITE, square) and not board.attackers(chess.BLACK, square):\n                white_weak_control += 1\n        elif rank <= 2:  # White's territory\n            if board.attackers(chess.BLACK, square) and not board.attackers(chess.WHITE, square):\n                black_weak_control += 1\n    \n    return float(white_weak_control - black_weak_control)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Piece activity weighted by distance from own back rank\"\n    white_activity = 0\n    black_activity = 0\n    \n    for square in chess.SQUARES:\n        piece = board.piece_at(square)\n        if piece and piece.piece_type != chess.KING:\n            rank = chess.square_rank(square)\n            \n            if piece.color == chess.WHITE:\n                advancement = rank\n                white_activity += advancement * 2\n            else:\n                advancement = 7 - rank\n                black_activity += advancement * 2\n    \n    return float(white_activity - black_activity)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Tactical pressure from pins, skewers, and discovered attack potential\"\n    pressure_score = 0\n    \n    for square in chess.SQUARES:\n        piece = board.piece_at(square)\n        if piece and piece.piece_type in [chess.BISHOP, chess.ROOK, chess.QUEEN]:\n            moves = [move for move in board.legal_moves if move.from_square == square]\n            \n            for move in moves:\n                board.push(move)\n                if board.is_check():\n                    weight = 5 if piece.piece_type == chess.QUEEN else 3\n                    if piece.color == chess.WHITE:\n                        pressure_score += weight\n                    else:\n                        pressure_score -= weight\n                board.pop()\n    \n    return float(pressure_score)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Control of key central squares e4, d4, e5, d5 weighted by piece values\"\n    central_squares = [chess.E4, chess.D4, chess.E5, chess.D5]\n    piece_values = {chess.PAWN: 1, chess.KNIGHT: 3, chess.BISHOP: 3, chess.ROOK: 5, chess.QUEEN: 9}\n    white_control = 0\n    black_control = 0\n    \n    for square in central_squares:\n        white_attackers = board.attackers(chess.WHITE, square)\n        black_attackers = board.attackers(chess.BLACK, square)\n        \n        for attacker_square in white_attackers:\n            piece = board.piece_at(attacker_square)\n            if piece:\n                white_control += piece_values.get(piece.piece_type, 0)\n        \n        for attacker_square in black_attackers:\n            piece = board.piece_at(attacker_square)\n            if piece:\n                black_control += piece_values.get(piece.piece_type, 0)\n    \n    return float(white_control - black_control)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Bishop pair bonus and diagonal control evaluation\"\n    white_bishops = 0\n    black_bishops = 0\n    white_diagonal_control = 0\n    black_diagonal_control = 0\n    \n    for square in chess.SQUARES:\n        piece = board.piece_at(square)\n        if piece and piece.piece_type == chess.BISHOP:\n            if piece.color == chess.WHITE:\n                white_bishops += 1\n                mobility = len([move for move in board.legal_moves if move.from_square == square])\n                white_diagonal_control += mobility\n            else:\n                black_bishops += 1\n                mobility = len([move for move in board.legal_moves if move.from_square == square])\n                black_diagonal_control += mobility\n    \n    bishop_pair_bonus = 0\n    if white_bishops >= 2:\n        bishop_pair_bonus += 50\n    if black_bishops >= 2:\n        bishop_pair_bonus -= 50\n    \n    return float(bishop_pair_bonus + white_diagonal_control - black_diagonal_control)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Pawn structure quality: doubled, isolated, and backward pawns penalty\"\n    white_penalty = 0\n    black_penalty = 0\n    \n    for file_idx in range(8):\n        white_pawns = []\n        black_pawns = []\n        \n        for rank in range(8):\n            square = chess.square(file_idx, rank)\n            piece = board.piece_at(square)\n            if piece and piece.piece_type == chess.PAWN:\n                if piece.color == chess.WHITE:\n                    white_pawns.append(rank)\n                else:\n                    black_pawns.append(rank)\n        \n        # Doubled pawns penalty\n        if len(white_pawns) > 1:\n            white_penalty += 20 * (len(white_pawns) - 1)\n        if len(black_pawns) > 1:\n            black_penalty += 20 * (len(black_pawns) - 1)\n        \n        # Isolated pawns penalty\n        if white_pawns:\n            has_neighbor = False\n            for neighbor_file in [file_idx - 1, file_idx + 1]:\n                if 0 <= neighbor_file <= 7:\n                    for rank in range(8):\n                        neighbor_square = chess.square(neighbor_file, rank)\n                        neighbor_piece = board.piece_at(neighbor_square)\n                        if neighbor_piece and neighbor_piece.piece_type == chess.PAWN and neighbor_piece.color == chess.WHITE:\n                            has_neighbor = True\n                            break\n            if not has_neighbor:\n                white_penalty += 15\n        \n        if black_pawns:\n            has_neighbor = False\n            for neighbor_file in [file_idx - 1, file_idx + 1]:\n                if 0 <= neighbor_file <= 7:\n                    for rank in range(8):\n                        neighbor_square = chess.square(neighbor_file, rank)\n                        neighbor_piece = board.piece_at(neighbor_square)\n                        if neighbor_piece and neighbor_piece.piece_type == chess.PAWN and neighbor_piece.color == chess.BLACK:\n                            has_neighbor = True\n                            break\n            if not has_neighbor:\n                black_penalty += 15\n    \n    return float(black_penalty - white_penalty)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Bishop pair advantage and bishop quality on long diagonals\"\n    white_bishops = 0\n    black_bishops = 0\n    white_diagonal_control = 0\n    black_diagonal_control = 0\n    \n    for square in chess.SQUARES:\n        piece = board.piece_at(square)\n        if piece and piece.piece_type == chess.BISHOP:\n            if piece.color == chess.WHITE:\n                white_bishops += 1\n                # Bonus for bishops on long diagonals\n                file, rank = chess.square_file(square), chess.square_rank(square)\n                if (file == rank) or (file + rank == 7):\n                    white_diagonal_control += 15\n            else:\n                black_bishops += 1\n                file, rank = chess.square_file(square), chess.square_rank(square)\n                if (file == rank) or (file + rank == 7):\n                    black_diagonal_control += 15\n    \n    bishop_pair_bonus = 0\n    if white_bishops >= 2:\n        bishop_pair_bonus += 25\n    if black_bishops >= 2:\n        bishop_pair_bonus -= 25\n    \n    return float(bishop_pair_bonus + white_diagonal_control - black_diagonal_control)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Knight outpost evaluation on strong squares protected by pawns\"\n    white_outposts = 0\n    black_outposts = 0\n    \n    for square in chess.SQUARES:\n        piece = board.piece_at(square)\n        if piece and piece.piece_type == chess.KNIGHT:\n            file, rank = chess.square_file(square), chess.square_rank(square)\n            \n            # Check if knight is protected by own pawn\n            pawn_protected = False\n            if piece.color == chess.WHITE:\n                for pawn_file in [file - 1, file + 1]:\n                    if 0 <= pawn_file <= 7 and rank > 0:\n                        pawn_square = chess.square(pawn_file, rank - 1)\n                        pawn_piece = board.piece_at(pawn_square)\n                        if pawn_piece and pawn_piece.piece_type == chess.PAWN and pawn_piece.color == chess.WHITE:\n                            pawn_protected = True\n                            break\n            else:\n                for pawn_file in [file - 1, file + 1]:\n                    if 0 <= pawn_file <= 7 and rank < 7:\n                        pawn_square = chess.square(pawn_file, rank + 1)\n                        pawn_piece = board.piece_at(pawn_square)\n                        if pawn_piece and pawn_piece.piece_type == chess.PAWN and pawn_piece.color == chess.BLACK:\n                            pawn_protected = True\n                            break\n            \n            if pawn_protected:\n                # Award points for advanced, centralized outposts\n                advancement = rank if piece.color == chess.WHITE else (7 - rank)\n                centrality = 4 - min(abs(file - 3), abs(file - 4))\n                outpost_value = (advancement + centrality) * 8\n                \n                if piece.color == chess.WHITE:\n                    white_outposts += outpost_value\n                else:\n                    black_outposts += outpost_value\n    \n    return float(white_outposts - black_outposts)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Pawn structure weakness: isolated, doubled, and backward pawns\"\n    white_weakness = 0\n    black_weakness = 0\n    \n    pawn_files = {chess.WHITE: set(), chess.BLACK: set()}\n    pawn_positions = {chess.WHITE: [], chess.BLACK: []}\n    \n    for square in chess.SQUARES:\n        piece = board.piece_at(square)\n        if piece and piece.piece_type == chess.PAWN:\n            file = chess.square_file(square)\n            rank = chess.square_rank(square)\n            pawn_files[piece.color].add(file)\n            pawn_positions[piece.color].append((file, rank))\n    \n    for color in [chess.WHITE, chess.BLACK]:\n        weakness = 0\n        for file, rank in pawn_positions[color]:\n            # Isolated pawn\n            if file-1 not in pawn_files[color] and file+1 not in pawn_files[color]:\n                weakness += 20\n            \n            # Doubled pawns\n            same_file_count = sum(1 for f, r in pawn_positions[color] if f == file)\n            if same_file_count > 1:\n                weakness += 15\n            \n            # Backward pawn\n            is_backward = True\n            for adj_file in [file-1, file+1]:\n                for f, r in pawn_positions[color]:\n                    if f == adj_file and ((color == chess.WHITE and r >= rank) or (color == chess.BLACK and r <= rank)):\n                        is_backward = False\n                        break\n            if is_backward and same_file_count == 1:\n                weakness += 12\n        \n        if color == chess.WHITE:\n            white_weakness = weakness\n        else:\n            black_weakness = weakness\n    \n    return float(black_weakness - white_weakness)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Tempo advantage based on whose turn it is and position type\"\n    tempo_value = 15\n    \n    # Adjust tempo value based on position complexity\n    total_pieces = len(board.piece_map())\n    if total_pieces < 16:  # Endgame\n        tempo_value = 25\n    elif total_pieces > 24:  # Opening\n        tempo_value = 10\n    \n    # Check if position is tactical (many attacks/captures available)\n    tactical_moves = sum(1 for move in board.legal_moves if board.is_attacked_by(not board.turn, move.to_square))\n    if tactical_moves > 3:\n        tempo_value += 10\n    \n    return float(tempo_value if board.turn == chess.WHITE else -tempo_value)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Control of key central squares e4, e5, d4, d5\"\n    central_squares = [chess.E4, chess.E5, chess.D4, chess.D5]\n    white_control = 0\n    black_control = 0\n    \n    for square in central_squares:\n        white_attackers = len(board.attackers(chess.WHITE, square))\n        black_attackers = len(board.attackers(chess.BLACK, square))\n        \n        piece = board.piece_at(square)\n        if piece:\n            if piece.color == chess.WHITE:\n                white_control += 20 + white_attackers * 5\n            else:\n                black_control += 20 + black_attackers * 5\n        else:\n            white_control += white_attackers * 3\n            black_control += black_attackers * 3\n    \n    return float(white_control - black_control)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Pawn structure weaknesses: isolated, doubled, and backward pawns\"\n    white_weaknesses = 0\n    black_weaknesses = 0\n    \n    pawn_files = {chess.WHITE: set(), chess.BLACK: set()}\n    pawn_positions = {chess.WHITE: [], chess.BLACK: []}\n    \n    for square in chess.SQUARES:\n        piece = board.piece_at(square)\n        if piece and piece.piece_type == chess.PAWN:\n            file = chess.square_file(square)\n            rank = chess.square_rank(square)\n            pawn_files[piece.color].add(file)\n            pawn_positions[piece.color].append((file, rank, square))\n    \n    for color in [chess.WHITE, chess.BLACK]:\n        for file, rank, square in pawn_positions[color]:\n            penalty = 0\n            \n            # Isolated pawn (no friendly pawns on adjacent files)\n            if (file - 1 not in pawn_files[color] and file + 1 not in pawn_files[color]):\n                penalty += 20\n            \n            # Doubled pawns (multiple pawns on same file)\n            same_file_pawns = sum(1 for f, r, s in pawn_positions[color] if f == file)\n            if same_file_pawns > 1:\n                penalty += 15 * (same_file_pawns - 1)\n            \n            # Backward pawn (cannot advance and no pawn support)\n            can_advance = True\n            next_rank = rank + 1 if color == chess.WHITE else rank - 1\n            if 0 <= next_rank <= 7:\n                next_square = chess.square(file, next_rank)\n                if board.piece_at(next_square) or board.is_attacked_by(chess.BLACK if color == chess.WHITE else chess.WHITE, next_square):\n                    has_support = any(abs(f - file) == 1 and ((color == chess.WHITE and r == rank - 1) or (color == chess.BLACK and r == rank + 1)) for f, r, s in pawn_positions[color])\n                    if not has_support:\n                        penalty += 10\n            \n            if color == chess.WHITE:\n                white_weaknesses += penalty\n            else:\n                black_weaknesses += penalty\n    \n    return float(black_weaknesses - white_weaknesses)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Passed pawn advancement and promotion threats\"\n    score = 0\n    for square in chess.SQUARES:\n        piece = board.piece_at(square)\n        if piece and piece.piece_type == chess.PAWN:\n            file, rank = chess.square_file(square), chess.square_rank(square)\n            is_passed = True\n            \n            # Check if pawn is passed (no enemy pawns blocking)\n            enemy_color = chess.BLACK if piece.color == chess.WHITE else chess.WHITE\n            direction = 1 if piece.color == chess.WHITE else -1\n            \n            for check_file in [file-1, file, file+1]:\n                if 0 <= check_file <= 7:\n                    for check_rank in range(rank + direction, 8 if piece.color == chess.WHITE else -1, direction):\n                        if 0 <= check_rank <= 7:\n                            check_square = chess.square(check_file, check_rank)\n                            check_piece = board.piece_at(check_square)\n                            if check_piece and check_piece.piece_type == chess.PAWN and check_piece.color == enemy_color:\n                                is_passed = False\n                                break\n                    if not is_passed:\n                        break\n            \n            if is_passed:\n                advancement = rank if piece.color == chess.WHITE else 7 - rank\n                value = advancement * advancement * 5\n                score += value if piece.color == chess.WHITE else -value\n    \n    return float(score)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Rook positioning on open and semi-open files\"\n    score = 0\n    for file_idx in range(8):\n        white_pawns = sum(1 for rank in range(8) if board.piece_at(chess.square(file_idx, rank)) and \n                         board.piece_at(chess.square(file_idx, rank)).piece_type == chess.PAWN and \n                         board.piece_at(chess.square(file_idx, rank)).color == chess.WHITE)\n        black_pawns = sum(1 for rank in range(8) if board.piece_at(chess.square(file_idx, rank)) and \n                         board.piece_at(chess.square(file_idx, rank)).piece_type == chess.PAWN and \n                         board.piece_at(chess.square(file_idx, rank)).color == chess.BLACK)\n        \n        is_open = white_pawns == 0 and black_pawns == 0\n        is_semi_open_white = white_pawns == 0 and black_pawns > 0\n        is_semi_open_black = black_pawns == 0 and white_pawns > 0\n        \n        for rank in range(8):\n            piece = board.piece_at(chess.square(file_idx, rank))\n            if piece and piece.piece_type == chess.ROOK:\n                bonus = 0\n                if is_open:\n                    bonus = 25\n                elif (is_semi_open_white and piece.color == chess.WHITE) or (is_semi_open_black and piece.color == chess.BLACK):\n                    bonus = 15\n                score += bonus if piece.color == chess.WHITE else -bonus\n    \n    return float(score)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Rook placement on open and semi-open files\"\n    white_rook_file_score = 0\n    black_rook_file_score = 0\n    \n    for square in chess.SQUARES:\n        piece = board.piece_at(square)\n        if piece and piece.piece_type == chess.ROOK:\n            file = chess.square_file(square)\n            \n            # Check if file is open or semi-open\n            white_pawns_on_file = 0\n            black_pawns_on_file = 0\n            for rank in range(8):\n                file_piece = board.piece_at(chess.square(file, rank))\n                if file_piece and file_piece.piece_type == chess.PAWN:\n                    if file_piece.color == chess.WHITE:\n                        white_pawns_on_file += 1\n                    else:\n                        black_pawns_on_file += 1\n            \n            bonus = 0\n            if white_pawns_on_file == 0 and black_pawns_on_file == 0:\n                bonus = 30  # Open file\n            elif (piece.color == chess.WHITE and white_pawns_on_file == 0) or (piece.color == chess.BLACK and black_pawns_on_file == 0):\n                bonus = 15  # Semi-open file\n            \n            if piece.color == chess.WHITE:\n                white_rook_file_score += bonus\n            else:\n                black_rook_file_score += bonus\n    \n    return float(white_rook_file_score - black_rook_file_score)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Passed pawn evaluation weighted by advancement and support\"\n    passed_pawn_score = 0\n    \n    for square in chess.SQUARES:\n        piece = board.piece_at(square)\n        if piece and piece.piece_type == chess.PAWN:\n            file = chess.square_file(square)\n            rank = chess.square_rank(square)\n            is_passed = True\n            \n            # Check for enemy pawns blocking or attacking\n            if piece.color == chess.WHITE:\n                for check_file in [file - 1, file, file + 1]:\n                    if 0 <= check_file <= 7:\n                        for check_rank in range(rank + 1, 8):\n                            check_piece = board.piece_at(chess.square(check_file, check_rank))\n                            if check_piece and check_piece.piece_type == chess.PAWN and check_piece.color == chess.BLACK:\n                                is_passed = False\n                                break\n                        if not is_passed:\n                            break\n            else:\n                for check_file in [file - 1, file, file + 1]:\n                    if 0 <= check_file <= 7:\n                        for check_rank in range(0, rank):\n                            check_piece = board.piece_at(chess.square(check_file, check_rank))\n                            if check_piece and check_piece.piece_type == chess.PAWN and check_piece.color == chess.WHITE:\n                                is_passed = False\n                                break\n                        if not is_passed:\n                            break\n            \n            if is_passed:\n                advancement = rank if piece.color == chess.WHITE else 7 - rank\n                bonus = advancement * advancement * 8\n                passed_pawn_score += bonus if piece.color == chess.WHITE else -bonus\n    \n    return float(passed_pawn_score)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Pawn structure weaknesses: isolated, doubled, and backward pawns\"\n    white_weaknesses = 0\n    black_weaknesses = 0\n    \n    pawn_files = {chess.WHITE: set(), chess.BLACK: set()}\n    pawn_positions = {chess.WHITE: [], chess.BLACK: []}\n    \n    for square in chess.SQUARES:\n        piece = board.piece_at(square)\n        if piece and piece.piece_type == chess.PAWN:\n            file = chess.square_file(square)\n            rank = chess.square_rank(square)\n            pawn_files[piece.color].add(file)\n            pawn_positions[piece.color].append((file, rank, square))\n    \n    for color in [chess.WHITE, chess.BLACK]:\n        for file, rank, square in pawn_positions[color]:\n            weaknesses = 0\n            \n            # Isolated pawn\n            if (file - 1 not in pawn_files[color]) and (file + 1 not in pawn_files[color]):\n                weaknesses += 20\n            \n            # Doubled pawn\n            file_pawns = [p for p in pawn_positions[color] if p[0] == file]\n            if len(file_pawns) > 1:\n                weaknesses += 15\n            \n            # Backward pawn\n            can_advance = True\n            next_rank = rank + (1 if color == chess.WHITE else -1)\n            if 0 <= next_rank <= 7:\n                next_square = chess.square(file, next_rank)\n                if board.is_attacked_by(chess.BLACK if color == chess.WHITE else chess.WHITE, next_square):\n                    adjacent_support = False\n                    for adj_file in [file - 1, file + 1]:\n                        if 0 <= adj_file <= 7:\n                            for adj_rank in range((rank - 1) if color == chess.WHITE else (rank + 1), 8 if color == chess.WHITE else -1, 1 if color == chess.WHITE else -1):\n                                if 0 <= adj_rank <= 7:\n                                    adj_square = chess.square(adj_file, adj_rank)\n                                    adj_piece = board.piece_at(adj_square)\n                                    if adj_piece and adj_piece.piece_type == chess.PAWN and adj_piece.color == color:\n                                        adjacent_support = True\n                                        break\n                            if adjacent_support:\n                                break\n                    if not adjacent_support:\n                        weaknesses += 10\n            \n            if color == chess.WHITE:\n                white_weaknesses += weaknesses\n            else:\n                black_weaknesses += weaknesses\n    \n    return float(black_weaknesses - white_weaknesses)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Control of key central squares e4, e5, d4, d5\"\n    central_squares = [chess.E4, chess.E5, chess.D4, chess.D5]\n    white_control = 0\n    black_control = 0\n    \n    for square in central_squares:\n        white_attackers = len(board.attackers(chess.WHITE, square))\n        black_attackers = len(board.attackers(chess.BLACK, square))\n        \n        piece = board.piece_at(square)\n        if piece:\n            if piece.color == chess.WHITE:\n                white_control += 20\n            else:\n                black_control += 20\n        \n        white_control += white_attackers * 5\n        black_control += black_attackers * 5\n    \n    return float(white_control - black_control)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Pawn structure weakness: isolated, doubled, and backward pawns\"\n    white_weakness = 0\n    black_weakness = 0\n    \n    # Find all pawns and their files\n    white_pawns = {}\n    black_pawns = {}\n    \n    for square in chess.SQUARES:\n        piece = board.piece_at(square)\n        if piece and piece.piece_type == chess.PAWN:\n            file = chess.square_file(square)\n            rank = chess.square_rank(square)\n            if piece.color == chess.WHITE:\n                if file not in white_pawns:\n                    white_pawns[file] = []\n                white_pawns[file].append(rank)\n            else:\n                if file not in black_pawns:\n                    black_pawns[file] = []\n                black_pawns[file].append(rank)\n    \n    # Check for doubled pawns and isolated pawns\n    for file in range(8):\n        if file in white_pawns:\n            if len(white_pawns[file]) > 1:\n                white_weakness += 20  # Doubled pawns\n            if file-1 not in white_pawns and file+1 not in white_pawns:\n                white_weakness += 25  # Isolated pawn\n        \n        if file in black_pawns:\n            if len(black_pawns[file]) > 1:\n                black_weakness += 20\n            if file-1 not in black_pawns and file+1 not in black_pawns:\n                black_weakness += 25\n    \n    return float(black_weakness - white_weakness)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Passed pawn evaluation weighted by advancement and support\"\n    white_score = 0\n    black_score = 0\n    \n    for square in chess.SQUARES:\n        piece = board.piece_at(square)\n        if piece and piece.piece_type == chess.PAWN:\n            file = chess.square_file(square)\n            rank = chess.square_rank(square)\n            \n            is_passed = True\n            if piece.color == chess.WHITE:\n                # Check if any black pawns block this pawn's path\n                for check_rank in range(rank + 1, 8):\n                    for check_file in [file - 1, file, file + 1]:\n                        if 0 <= check_file <= 7:\n                            check_square = chess.square(check_file, check_rank)\n                            check_piece = board.piece_at(check_square)\n                            if check_piece and check_piece.piece_type == chess.PAWN and check_piece.color == chess.BLACK:\n                                is_passed = False\n                                break\n                    if not is_passed:\n                        break\n                \n                if is_passed:\n                    advancement_bonus = (rank - 1) * 15\n                    support_bonus = len(board.attackers(chess.WHITE, square)) * 10\n                    white_score += advancement_bonus + support_bonus\n            else:\n                # Check for black passed pawns\n                for check_rank in range(rank - 1, -1, -1):\n                    for check_file in [file - 1, file, file + 1]:\n                        if 0 <= check_file <= 7:\n                            check_square = chess.square(check_file, check_rank)\n                            check_piece = board.piece_at(check_square)\n                            if check_piece and check_piece.piece_type == chess.PAWN and check_piece.color == chess.WHITE:\n                                is_passed = False\n                                break\n                    if not is_passed:\n                        break\n                \n                if is_passed:\n                    advancement_bonus = (6 - rank) * 15\n                    support_bonus = len(board.attackers(chess.BLACK, square)) * 10\n                    black_score += advancement_bonus + support_bonus\n    \n    return float(white_score - black_score)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Control of key central squares (d4, d5, e4, e5) by pieces and pawns\"\n    central_squares = [chess.D4, chess.D5, chess.E4, chess.E5]\n    white_control = 0\n    black_control = 0\n    \n    for square in central_squares:\n        piece = board.piece_at(square)\n        if piece:\n            if piece.color == chess.WHITE:\n                white_control += 10 if piece.piece_type == chess.PAWN else 5\n            else:\n                black_control += 10 if piece.piece_type == chess.PAWN else 5\n        \n        white_attackers = len(board.attackers(chess.WHITE, square))\n        black_attackers = len(board.attackers(chess.BLACK, square))\n        white_control += white_attackers * 2\n        black_control += black_attackers * 2\n    \n    return float(white_control - black_control)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Rook placement on open and semi-open files with connectivity bonus\"\n    white_score = 0\n    black_score = 0\n    \n    file_pawns = [[] for _ in range(8)]\n    for square in chess.SQUARES:\n        piece = board.piece_at(square)\n        if piece and piece.piece_type == chess.PAWN:\n            file_pawns[chess.square_file(square)].append(piece.color)\n    \n    for square in chess.SQUARES:\n        piece = board.piece_at(square)\n        if piece and piece.piece_type == chess.ROOK:\n            file = chess.square_file(square)\n            rank = chess.square_rank(square)\n            score = 0\n            \n            own_pawns = file_pawns[file].count(piece.color)\n            enemy_pawns = file_pawns[file].count(chess.WHITE if piece.color == chess.BLACK else chess.BLACK)\n            \n            if own_pawns == 0 and enemy_pawns == 0:\n                score += 30  # Open file\n            elif own_pawns == 0:\n                score += 20  # Semi-open file\n            \n            # 7th/2nd rank bonus\n            if (piece.color == chess.WHITE and rank == 6) or (piece.color == chess.BLACK and rank == 1):\n                score += 25\n            \n            # Rook connectivity (same rank or file as other rook)\n            for other_square in chess.SQUARES:\n                other_piece = board.piece_at(other_square)\n                if (other_piece and other_piece.piece_type == chess.ROOK and \n                    other_piece.color == piece.color and other_square != square):\n                    if (chess.square_file(other_square) == file or \n                        chess.square_rank(other_square) == rank):\n                        score += 15\n                        break\n            \n            if piece.color == chess.WHITE:\n                white_score += score\n            else:\n                black_score += score\n    \n    return float(white_score - black_score)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Passed pawn advancement weighted by distance to promotion\"\n    white_passed = 0\n    black_passed = 0\n    \n    for square in chess.SQUARES:\n        piece = board.piece_at(square)\n        if piece and piece.piece_type == chess.PAWN:\n            file, rank = chess.square_file(square), chess.square_rank(square)\n            is_passed = True\n            \n            if piece.color == chess.WHITE:\n                # Check if any black pawns can stop this pawn\n                for check_file in [file-1, file, file+1]:\n                    if 0 <= check_file <= 7:\n                        for check_rank in range(rank+1, 8):\n                            check_piece = board.piece_at(chess.square(check_file, check_rank))\n                            if check_piece and check_piece.piece_type == chess.PAWN and check_piece.color == chess.BLACK:\n                                is_passed = False\n                                break\n                if is_passed and rank > 1:\n                    white_passed += (rank - 1) ** 2 * 10\n            else:\n                # Check if any white pawns can stop this pawn\n                for check_file in [file-1, file, file+1]:\n                    if 0 <= check_file <= 7:\n                        for check_rank in range(0, rank):\n                            check_piece = board.piece_at(chess.square(check_file, check_rank))\n                            if check_piece and check_piece.piece_type == chess.PAWN and check_piece.color == chess.WHITE:\n                                is_passed = False\n                                break\n                if is_passed and rank < 6:\n                    black_passed += (6 - rank) ** 2 * 10\n    \n    return float(white_passed - black_passed)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Rook on open and semi-open files evaluation\"\n    white_rook_files = 0\n    black_rook_files = 0\n    \n    file_pawn_count = [0] * 8  # Count pawns per file\n    for square in chess.SQUARES:\n        piece = board.piece_at(square)\n        if piece and piece.piece_type == chess.PAWN:\n            file_pawn_count[chess.square_file(square)] += 1\n    \n    for square in chess.SQUARES:\n        piece = board.piece_at(square)\n        if piece and piece.piece_type == chess.ROOK:\n            file = chess.square_file(square)\n            if file_pawn_count[file] == 0:  # Open file\n                if piece.color == chess.WHITE:\n                    white_rook_files += 30\n                else:\n                    black_rook_files += 30\n            else:\n                # Check for semi-open file (no own pawns)\n                own_pawns = 0\n                for rank in range(8):\n                    check_piece = board.piece_at(chess.square(file, rank))\n                    if check_piece and check_piece.piece_type == chess.PAWN and check_piece.color == piece.color:\n                        own_pawns += 1\n                if own_pawns == 0:\n                    if piece.color == chess.WHITE:\n                        white_rook_files += 15\n                    else:\n                        black_rook_files += 15\n    \n    return float(white_rook_files - black_rook_files)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Rook on open and semi-open files weighted by file importance\"\n    score = 0\n    piece_values = {chess.ROOK: 20, chess.QUEEN: 10}\n    \n    for file in range(8):\n        white_pawns = sum(1 for rank in range(8) if board.piece_at(chess.square(file, rank)) and board.piece_at(chess.square(file, rank)).piece_type == chess.PAWN and board.piece_at(chess.square(file, rank)).color == chess.WHITE)\n        black_pawns = sum(1 for rank in range(8) if board.piece_at(chess.square(file, rank)) and board.piece_at(chess.square(file, rank)).piece_type == chess.PAWN and board.piece_at(chess.square(file, rank)).color == chess.BLACK)\n        \n        for rank in range(8):\n            piece = board.piece_at(chess.square(file, rank))\n            if piece and piece.piece_type in [chess.ROOK, chess.QUEEN]:\n                bonus = 0\n                if white_pawns == 0 and black_pawns == 0:  # Open file\n                    bonus = piece_values[piece.piece_type]\n                elif (piece.color == chess.WHITE and white_pawns == 0) or (piece.color == chess.BLACK and black_pawns == 0):  # Semi-open\n                    bonus = piece_values[piece.piece_type] // 2\n                \n                # Central files more important\n                file_importance = 1.0 + (2 - abs(file - 3.5)) * 0.2\n                bonus *= file_importance\n                \n                if piece.color == chess.WHITE:\n                    score += bonus\n                else:\n                    score -= bonus\n    \n    return float(score)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Weak squares in opponent territory controlled by pieces\"\n    score = 0\n    \n    for square in chess.SQUARES:\n        file, rank = chess.square_file(square), chess.square_rank(square)\n        piece = board.piece_at(square)\n        \n        # Focus on squares in opponent territory\n        if rank >= 5:  # White's advanced squares\n            if not piece or piece.color == chess.BLACK:\n                white_attackers = len(list(board.attackers(chess.WHITE, square)))\n                black_attackers = len(list(board.attackers(chess.BLACK, square)))\n                if white_attackers > black_attackers:\n                    control_strength = white_attackers - black_attackers\n                    score += control_strength * (rank - 4) * 3\n        \n        elif rank <= 2:  # Black's advanced squares\n            if not piece or piece.color == chess.WHITE:\n                black_attackers = len(list(board.attackers(chess.BLACK, square)))\n                white_attackers = len(list(board.attackers(chess.WHITE, square)))\n                if black_attackers > white_attackers:\n                    control_strength = black_attackers - white_attackers\n                    score -= control_strength * (3 - rank) * 3\n    \n    return float(score)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"King safety measured by pawn shield completeness and piece proximity\"\n    white_safety = 0\n    black_safety = 0\n    \n    white_king_square = None\n    black_king_square = None\n    \n    for square in chess.SQUARES:\n        piece = board.piece_at(square)\n        if piece and piece.piece_type == chess.KING:\n            if piece.color == chess.WHITE:\n                white_king_square = square\n            else:\n                black_king_square = square\n    \n    for king_square, color, safety_var in [(white_king_square, chess.WHITE, 'white'), (black_king_square, chess.BLACK, 'black')]:\n        if king_square is None:\n            continue\n            \n        file, rank = chess.square_file(king_square), chess.square_rank(king_square)\n        safety_score = 0\n        \n        # Pawn shield evaluation\n        direction = 1 if color == chess.WHITE else -1\n        for shield_file in [file-1, file, file+1]:\n            if 0 <= shield_file <= 7:\n                shield_rank = rank + direction\n                if 0 <= shield_rank <= 7:\n                    shield_square = chess.square(shield_file, shield_rank)\n                    shield_piece = board.piece_at(shield_square)\n                    if shield_piece and shield_piece.piece_type == chess.PAWN and shield_piece.color == color:\n                        safety_score += 20\n        \n        # Penalty for enemy pieces near king\n        for check_square in chess.SQUARES:\n            distance = chess.square_distance(king_square, check_square)\n            if distance <= 2:\n                piece = board.piece_at(check_square)\n                if piece and piece.color != color and piece.piece_type != chess.KING:\n                    safety_score -= (3 - distance) * 10\n        \n        if safety_var == 'white':\n            white_safety = safety_score\n        else:\n            black_safety = safety_score\n    \n    return float(white_safety - black_safety)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"King safety measured by attacking pieces near the king and pawn shield strength\"\n    white_safety = 0\n    black_safety = 0\n    \n    for color in [chess.WHITE, chess.BLACK]:\n        king_square = board.king(color)\n        if king_square is None:\n            continue\n            \n        king_file, king_rank = chess.square_file(king_square), chess.square_rank(king_square)\n        safety_score = 0\n        \n        # Pawn shield evaluation\n        shield_ranks = [king_rank + 1, king_rank + 2] if color == chess.WHITE else [king_rank - 1, king_rank - 2]\n        for shield_rank in shield_ranks:\n            if 0 <= shield_rank <= 7:\n                for file_offset in [-1, 0, 1]:\n                    shield_file = king_file + file_offset\n                    if 0 <= shield_file <= 7:\n                        shield_square = chess.square(shield_file, shield_rank)\n                        piece = board.piece_at(shield_square)\n                        if piece and piece.piece_type == chess.PAWN and piece.color == color:\n                            safety_score += 15\n        \n        # Enemy piece attacks near king\n        for file_offset in range(-2, 3):\n            for rank_offset in range(-2, 3):\n                check_file, check_rank = king_file + file_offset, king_rank + rank_offset\n                if 0 <= check_file <= 7 and 0 <= check_rank <= 7:\n                    check_square = chess.square(check_file, check_rank)\n                    enemy_attackers = board.attackers(not color, check_square)\n                    safety_score -= len(enemy_attackers) * 8\n        \n        if color == chess.WHITE:\n            white_safety = safety_score\n        else:\n            black_safety = safety_score\n    \n    return float(white_safety - black_safety)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Bishop pair advantage and bishop mobility on long diagonals\"\n    white_bishops = 0\n    black_bishops = 0\n    white_diagonal_control = 0\n    black_diagonal_control = 0\n    \n    for square in chess.SQUARES:\n        piece = board.piece_at(square)\n        if piece and piece.piece_type == chess.BISHOP:\n            if piece.color == chess.WHITE:\n                white_bishops += 1\n            else:\n                black_bishops += 1\n            \n            # Evaluate diagonal control\n            file, rank = chess.square_file(square), chess.square_rank(square)\n            diagonal_moves = 0\n            \n            for direction in [(1, 1), (1, -1), (-1, 1), (-1, -1)]:\n                for distance in range(1, 8):\n                    new_file, new_rank = file + direction[0] * distance, rank + direction[1] * distance\n                    if 0 <= new_file <= 7 and 0 <= new_rank <= 7:\n                        target_square = chess.square(new_file, new_rank)\n                        target_piece = board.piece_at(target_square)\n                        if target_piece is None:\n                            diagonal_moves += 1\n                        else:\n                            if target_piece.color != piece.color:\n                                diagonal_moves += 1\n                            break\n                    else:\n                        break\n            \n            if piece.color == chess.WHITE:\n                white_diagonal_control += diagonal_moves\n            else:\n                black_diagonal_control += diagonal_moves\n    \n    bishop_pair_bonus = 0\n    if white_bishops >= 2:\n        bishop_pair_bonus += 50\n    if black_bishops >= 2:\n        bishop_pair_bonus -= 50\n    \n    return float(bishop_pair_bonus + white_diagonal_control - black_diagonal_control)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Bishop pair advantage and long diagonal control\"\n    white_bishops = 0\n    black_bishops = 0\n    diagonal_control = 0\n    \n    for square in chess.SQUARES:\n        piece = board.piece_at(square)\n        if piece and piece.piece_type == chess.BISHOP:\n            if piece.color == chess.WHITE:\n                white_bishops += 1\n            else:\n                black_bishops += 1\n            \n            # Long diagonal control bonus\n            file, rank = chess.square_file(square), chess.square_rank(square)\n            if (file == rank) or (file + rank == 7):  # On main diagonals\n                moves = len([move for move in board.legal_moves if move.from_square == square])\n                if piece.color == chess.WHITE:\n                    diagonal_control += moves * 4\n                else:\n                    diagonal_control -= moves * 4\n    \n    bishop_pair_bonus = 0\n    if white_bishops >= 2:\n        bishop_pair_bonus += 30\n    if black_bishops >= 2:\n        bishop_pair_bonus -= 30\n    \n    return float(bishop_pair_bonus + diagonal_control)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Knight outposts on strong squares in enemy territory\"\n    outpost_score = 0\n    \n    for square in chess.SQUARES:\n        piece = board.piece_at(square)\n        if piece and piece.piece_type == chess.KNIGHT:\n            file, rank = chess.square_file(square), chess.square_rank(square)\n            \n            # Check if in enemy territory\n            in_enemy_territory = (piece.color == chess.WHITE and rank >= 4) or (piece.color == chess.BLACK and rank <= 3)\n            \n            if in_enemy_territory:\n                # Check if defended by own pawn\n                pawn_support = False\n                support_ranks = [rank - 1] if piece.color == chess.WHITE else [rank + 1]\n                for support_rank in support_ranks:\n                    if 0 <= support_rank <= 7:\n                        for file_offset in [-1, 1]:\n                            support_file = file + file_offset\n                            if 0 <= support_file <= 7:\n                                support_square = chess.square(support_file, support_rank)\n                                support_piece = board.piece_at(support_square)\n                                if support_piece and support_piece.piece_type == chess.PAWN and support_piece.color == piece.color:\n                                    pawn_support = True\n                \n                # Check if enemy pawns cannot attack\n                enemy_pawn_attack = False\n                attack_ranks = [rank - 1] if piece.color == chess.BLACK else [rank + 1]\n                for attack_rank in attack_ranks:\n                    if 0 <= attack_rank <= 7:\n                        for file_offset in [-1, 1]:\n                            attack_file = file + file_offset\n                            if 0 <= attack_file <= 7:\n                                attack_square = chess.square(attack_file, attack_rank)\n                                attack_piece = board.piece_at(attack_square)\n                                if attack_piece and attack_piece.piece_type == chess.PAWN and attack_piece.color != piece.color:\n                                    enemy_pawn_attack = True\n                \n                if pawn_support and not enemy_pawn_attack:\n                    score = 25 + (rank if piece.color == chess.WHITE else 7 - rank) * 5\n                    if piece.color == chess.WHITE:\n                        outpost_score += score\n                    else:\n                        outpost_score -= score\n    \n    return float(outpost_score)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Pawn structure weaknesses: isolated, doubled, and backward pawns\"\n    white_weaknesses = 0\n    black_weaknesses = 0\n    \n    pawn_files = {chess.WHITE: set(), chess.BLACK: set()}\n    pawn_positions = {chess.WHITE: [], chess.BLACK: []}\n    \n    for square in chess.SQUARES:\n        piece = board.piece_at(square)\n        if piece and piece.piece_type == chess.PAWN:\n            file = chess.square_file(square)\n            rank = chess.square_rank(square)\n            pawn_files[piece.color].add(file)\n            pawn_positions[piece.color].append((file, rank))\n    \n    for color in [chess.WHITE, chess.BLACK]:\n        for file, rank in pawn_positions[color]:\n            penalty = 0\n            # Isolated pawn\n            if file-1 not in pawn_files[color] and file+1 not in pawn_files[color]:\n                penalty += 15\n            # Doubled pawn\n            same_file_pawns = sum(1 for f, r in pawn_positions[color] if f == file)\n            if same_file_pawns > 1:\n                penalty += 10\n            # Backward pawn\n            can_advance = True\n            advance_rank = rank + (1 if color == chess.WHITE else -1)\n            if 0 <= advance_rank <= 7:\n                advance_square = chess.square(file, advance_rank)\n                if board.piece_at(advance_square) or board.is_attacked_by(not color, advance_square):\n                    can_advance = False\n            if not can_advance:\n                penalty += 8\n                \n            if color == chess.WHITE:\n                white_weaknesses += penalty\n            else:\n                black_weaknesses += penalty\n    \n    return float(black_weaknesses - white_weaknesses)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Rook activity on open and semi-open files\"\n    white_score = 0\n    black_score = 0\n    \n    for square in chess.SQUARES:\n        piece = board.piece_at(square)\n        if piece and piece.piece_type == chess.ROOK:\n            file = chess.square_file(square)\n            \n            # Check if file is open or semi-open\n            own_pawns = 0\n            enemy_pawns = 0\n            for rank in range(8):\n                check_square = chess.square(file, rank)\n                check_piece = board.piece_at(check_square)\n                if check_piece and check_piece.piece_type == chess.PAWN:\n                    if check_piece.color == piece.color:\n                        own_pawns += 1\n                    else:\n                        enemy_pawns += 1\n            \n            bonus = 0\n            if own_pawns == 0 and enemy_pawns == 0:\n                bonus = 30  # Open file\n            elif own_pawns == 0:\n                bonus = 20  # Semi-open file\n            \n            if piece.color == chess.WHITE:\n                white_score += bonus\n            else:\n                black_score += bonus\n    \n    return float(white_score - black_score)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Bishop pair advantage and activity on long diagonals\"\n    white_bishops = 0\n    black_bishops = 0\n    white_diagonal_control = 0\n    black_diagonal_control = 0\n    \n    for square in chess.SQUARES:\n        piece = board.piece_at(square)\n        if piece and piece.piece_type == chess.BISHOP:\n            file, rank = chess.square_file(square), chess.square_rank(square)\n            \n            if piece.color == chess.WHITE:\n                white_bishops += 1\n                # Bonus for long diagonal control\n                if (file == rank) or (file + rank == 7):\n                    white_diagonal_control += 15\n            else:\n                black_bishops += 1\n                if (file == rank) or (file + rank == 7):\n                    black_diagonal_control += 15\n    \n    pair_bonus = 0\n    if white_bishops >= 2:\n        pair_bonus += 25\n    if black_bishops >= 2:\n        pair_bonus -= 25\n    \n    return float(pair_bonus + white_diagonal_control - black_diagonal_control)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Rook activity on open and semi-open files\"\n    white_rook_activity = 0\n    black_rook_activity = 0\n    \n    # Find pawns by file\n    white_pawns_by_file = set()\n    black_pawns_by_file = set()\n    for square in chess.SQUARES:\n        piece = board.piece_at(square)\n        if piece and piece.piece_type == chess.PAWN:\n            file = chess.square_file(square)\n            if piece.color == chess.WHITE:\n                white_pawns_by_file.add(file)\n            else:\n                black_pawns_by_file.add(file)\n    \n    # Evaluate rooks\n    for square in chess.SQUARES:\n        piece = board.piece_at(square)\n        if piece and piece.piece_type == chess.ROOK:\n            file = chess.square_file(square)\n            activity = 0\n            \n            # Open file (no pawns)\n            if file not in white_pawns_by_file and file not in black_pawns_by_file:\n                activity += 30\n            # Semi-open file (no own pawns)\n            elif file not in (white_pawns_by_file if piece.color == chess.WHITE else black_pawns_by_file):\n                activity += 15\n            \n            if piece.color == chess.WHITE:\n                white_rook_activity += activity\n            else:\n                black_rook_activity += activity\n    \n    return float(white_rook_activity - black_rook_activity)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Knight outposts on strong squares protected by pawns\"\n    white_outposts = 0\n    black_outposts = 0\n    \n    for square in chess.SQUARES:\n        piece = board.piece_at(square)\n        if piece and piece.piece_type == chess.KNIGHT:\n            file, rank = chess.square_file(square), chess.square_rank(square)\n            \n            # Check if knight is protected by own pawn\n            pawn_support = False\n            support_rank = rank - 1 if piece.color == chess.WHITE else rank + 1\n            if 0 <= support_rank <= 7:\n                for df in [-1, 1]:\n                    if 0 <= file + df <= 7:\n                        support_square = chess.square(file + df, support_rank)\n                        support_piece = board.piece_at(support_square)\n                        if (support_piece and support_piece.piece_type == chess.PAWN and \n                            support_piece.color == piece.color):\n                            pawn_support = True\n                            break\n            \n            # Check if it's an advanced outpost\n            if pawn_support:\n                if piece.color == chess.WHITE and rank >= 4:\n                    white_outposts += 25\n                elif piece.color == chess.BLACK and rank <= 3:\n                    black_outposts += 25\n    \n    return float(white_outposts - black_outposts)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Knight outpost evaluation on strong squares supported by pawns\"\n    white_outposts = 0\n    black_outposts = 0\n    \n    for square in chess.SQUARES:\n        piece = board.piece_at(square)\n        if piece and piece.piece_type == chess.KNIGHT:\n            file, rank = chess.square_file(square), chess.square_rank(square)\n            \n            # Check if knight is on an advanced rank\n            if piece.color == chess.WHITE and rank >= 4:\n                # Check for pawn support\n                support_squares = [chess.square(file-1, rank-1), chess.square(file+1, rank-1)] if file > 0 and file < 7 else []\n                for support_sq in support_squares:\n                    if 0 <= support_sq <= 63:\n                        support_piece = board.piece_at(support_sq)\n                        if support_piece and support_piece.piece_type == chess.PAWN and support_piece.color == chess.WHITE:\n                            # Check if enemy pawns can't attack this square\n                            can_be_attacked = False\n                            for enemy_file in [file-1, file+1]:\n                                if 0 <= enemy_file <= 7:\n                                    for enemy_rank in range(rank, 8):\n                                        enemy_sq = chess.square(enemy_file, enemy_rank)\n                                        enemy_piece = board.piece_at(enemy_sq)\n                                        if enemy_piece and enemy_piece.piece_type == chess.PAWN and enemy_piece.color == chess.BLACK:\n                                            can_be_attacked = True\n                                            break\n                                if can_be_attacked:\n                                    break\n                            if not can_be_attacked:\n                                white_outposts += 30\n            elif piece.color == chess.BLACK and rank <= 3:\n                support_squares = [chess.square(file-1, rank+1), chess.square(file+1, rank+1)] if file > 0 and file < 7 else []\n                for support_sq in support_squares:\n                    if 0 <= support_sq <= 63:\n                        support_piece = board.piece_at(support_sq)\n                        if support_piece and support_piece.piece_type == chess.PAWN and support_piece.color == chess.BLACK:\n                            can_be_attacked = False\n                            for enemy_file in [file-1, file+1]:\n                                if 0 <= enemy_file <= 7:\n                                    for enemy_rank in range(rank, -1, -1):\n                                        enemy_sq = chess.square(enemy_file, enemy_rank)\n                                        enemy_piece = board.piece_at(enemy_sq)\n                                        if enemy_piece and enemy_piece.piece_type == chess.PAWN and enemy_piece.color == chess.WHITE:\n                                            can_be_attacked = True\n                                            break\n                                if can_be_attacked:\n                                    break\n                            if not can_be_attacked:\n                                black_outposts += 30\n    \n    return float(white_outposts - black_outposts)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Passed pawn evaluation weighted by advancement and support\"\n    white_passed = 0\n    black_passed = 0\n    \n    for square in chess.SQUARES:\n        piece = board.piece_at(square)\n        if piece and piece.piece_type == chess.PAWN:\n            file, rank = chess.square_file(square), chess.square_rank(square)\n            is_passed = True\n            \n            # Check if pawn is passed\n            if piece.color == chess.WHITE:\n                for check_rank in range(rank + 1, 8):\n                    for check_file in [file - 1, file, file + 1]:\n                        if 0 <= check_file <= 7:\n                            check_square = chess.square(check_file, check_rank)\n                            enemy_piece = board.piece_at(check_square)\n                            if enemy_piece and enemy_piece.piece_type == chess.PAWN and enemy_piece.color == chess.BLACK:\n                                is_passed = False\n                                break\n                if is_passed:\n                    bonus = (rank - 1) * 15\n                    # Support bonus\n                    if board.is_attacked_by(chess.WHITE, square):\n                        bonus += 10\n                    white_passed += bonus\n            else:\n                for check_rank in range(0, rank):\n                    for check_file in [file - 1, file, file + 1]:\n                        if 0 <= check_file <= 7:\n                            check_square = chess.square(check_file, check_rank)\n                            enemy_piece = board.piece_at(check_square)\n                            if enemy_piece and enemy_piece.piece_type == chess.PAWN and enemy_piece.color == chess.WHITE:\n                                is_passed = False\n                                break\n                if is_passed:\n                    bonus = (6 - rank) * 15\n                    if board.is_attacked_by(chess.BLACK, square):\n                        bonus += 10\n                    black_passed += bonus\n    \n    return float(white_passed - black_passed)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Rook positioning on open and semi-open files\"\n    white_rook_score = 0\n    black_rook_score = 0\n    \n    # Analyze each file for pawn presence\n    file_status = {}\n    for file_idx in range(8):\n        white_pawns = 0\n        black_pawns = 0\n        for rank in range(8):\n            piece = board.piece_at(chess.square(file_idx, rank))\n            if piece and piece.piece_type == chess.PAWN:\n                if piece.color == chess.WHITE:\n                    white_pawns += 1\n                else:\n                    black_pawns += 1\n        file_status[file_idx] = (white_pawns, black_pawns)\n    \n    for square in chess.SQUARES:\n        piece = board.piece_at(square)\n        if piece and piece.piece_type == chess.ROOK:\n            file_idx = chess.square_file(square)\n            white_pawns, black_pawns = file_status[file_idx]\n            \n            score = 0\n            if white_pawns == 0 and black_pawns == 0:  # Open file\n                score += 25\n            elif piece.color == chess.WHITE and white_pawns == 0:  # Semi-open for white\n                score += 15\n            elif piece.color == chess.BLACK and black_pawns == 0:  # Semi-open for black\n                score += 15\n            \n            if piece.color == chess.WHITE:\n                white_rook_score += score\n            else:\n                black_rook_score += score\n    \n    return float(white_rook_score - black_rook_score)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Backward pawns that cannot advance safely and lack pawn support\"\n    backward_score = 0\n    \n    for square in chess.SQUARES:\n        piece = board.piece_at(square)\n        if piece and piece.piece_type == chess.PAWN:\n            file = chess.square_file(square)\n            rank = chess.square_rank(square)\n            \n            # Check if pawn lacks support from adjacent pawns behind it\n            has_support = False\n            support_rank = rank - 1 if piece.color == chess.WHITE else rank + 1\n            if 0 <= support_rank <= 7:\n                for support_file in [file - 1, file + 1]:\n                    if 0 <= support_file <= 7:\n                        support_square = chess.square(support_file, support_rank)\n                        support_piece = board.piece_at(support_square)\n                        if support_piece and support_piece.piece_type == chess.PAWN and support_piece.color == piece.color:\n                            has_support = True\n                            break\n            \n            # Check if advance would be attacked by enemy pawns\n            advance_rank = rank + 1 if piece.color == chess.WHITE else rank - 1\n            if 0 <= advance_rank <= 7 and not has_support:\n                advance_square = chess.square(file, advance_rank)\n                if not board.piece_at(advance_square):  # Square is empty\n                    attacked_by_enemy_pawn = False\n                    for enemy_file in [file - 1, file + 1]:\n                        if 0 <= enemy_file <= 7:\n                            enemy_rank = advance_rank - 1 if piece.color == chess.WHITE else advance_rank + 1\n                            if 0 <= enemy_rank <= 7:\n                                enemy_square = chess.square(enemy_file, enemy_rank)\n                                enemy_piece = board.piece_at(enemy_square)\n                                if enemy_piece and enemy_piece.piece_type == chess.PAWN and enemy_piece.color != piece.color:\n                                    attacked_by_enemy_pawn = True\n                                    break\n                    \n                    if attacked_by_enemy_pawn:\n                        penalty = -20\n                        backward_score += penalty if piece.color == chess.WHITE else -penalty\n    \n    return float(backward_score)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Bishop pair advantage and diagonal control strength\"\n    white_bishops = []\n    black_bishops = []\n    \n    for square in chess.SQUARES:\n        piece = board.piece_at(square)\n        if piece and piece.piece_type == chess.BISHOP:\n            if piece.color == chess.WHITE:\n                white_bishops.append(square)\n            else:\n                black_bishops.append(square)\n    \n    score = 0\n    \n    # Bishop pair bonus\n    if len(white_bishops) >= 2:\n        score += 50\n    if len(black_bishops) >= 2:\n        score -= 50\n    \n    # Diagonal control evaluation\n    for bishop_square in white_bishops:\n        diagonal_control = 0\n        for move in board.legal_moves:\n            if move.from_square == bishop_square:\n                diagonal_control += 1\n        score += diagonal_control * 3\n    \n    for bishop_square in black_bishops:\n        diagonal_control = 0\n        for move in board.legal_moves:\n            if move.from_square == bishop_square:\n                diagonal_control += 1\n        score -= diagonal_control * 3\n    \n    return float(score)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Pawn structure quality including passed pawns, doubled pawns, and pawn islands\"\n    white_score = 0\n    black_score = 0\n    white_files = [False] * 8\n    black_files = [False] * 8\n    \n    for square in chess.SQUARES:\n        piece = board.piece_at(square)\n        if piece and piece.piece_type == chess.PAWN:\n            file = chess.square_file(square)\n            rank = chess.square_rank(square)\n            \n            if piece.color == chess.WHITE:\n                white_files[file] = True\n                # Check for passed pawn\n                passed = True\n                for check_rank in range(rank + 1, 8):\n                    for check_file in [file - 1, file, file + 1]:\n                        if 0 <= check_file <= 7:\n                            check_square = chess.square(check_file, check_rank)\n                            check_piece = board.piece_at(check_square)\n                            if check_piece and check_piece.piece_type == chess.PAWN and check_piece.color == chess.BLACK:\n                                passed = False\n                if passed and rank > 3:\n                    white_score += (rank - 3) * 20\n                    \n                # Check for doubled pawns\n                for check_rank in range(rank + 1, 8):\n                    check_square = chess.square(file, check_rank)\n                    check_piece = board.piece_at(check_square)\n                    if check_piece and check_piece.piece_type == chess.PAWN and check_piece.color == chess.WHITE:\n                        white_score -= 15\n            else:\n                black_files[file] = True\n                # Check for passed pawn\n                passed = True\n                for check_rank in range(0, rank):\n                    for check_file in [file - 1, file, file + 1]:\n                        if 0 <= check_file <= 7:\n                            check_square = chess.square(check_file, check_rank)\n                            check_piece = board.piece_at(check_square)\n                            if check_piece and check_piece.piece_type == chess.PAWN and check_piece.color == chess.WHITE:\n                                passed = False\n                if passed and rank < 4:\n                    black_score += (4 - rank) * 20\n                    \n                # Check for doubled pawns\n                for check_rank in range(0, rank):\n                    check_square = chess.square(file, check_rank)\n                    check_piece = board.piece_at(check_square)\n                    if check_piece and check_piece.piece_type == chess.PAWN and check_piece.color == chess.BLACK:\n                        black_score -= 15\n    \n    # Count pawn islands (groups of connected pawns)\n    white_islands = sum(1 for i in range(8) if white_files[i] and (i == 0 or not white_files[i-1]))\n    black_islands = sum(1 for i in range(8) if black_files[i] and (i == 0 or not black_files[i-1]))\n    \n    white_score -= white_islands * 10\n    black_score -= black_islands * 10\n    \n    return float(white_score - black_score)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Passed pawn evaluation weighted by advancement and file\"\n    white_passed = 0\n    black_passed = 0\n    \n    for square in chess.SQUARES:\n        piece = board.piece_at(square)\n        if piece and piece.piece_type == chess.PAWN:\n            file = chess.square_file(square)\n            rank = chess.square_rank(square)\n            is_passed = True\n            \n            if piece.color == chess.WHITE:\n                # Check for blocking black pawns ahead and on adjacent files\n                for check_rank in range(rank + 1, 8):\n                    for check_file in [file - 1, file, file + 1]:\n                        if 0 <= check_file <= 7:\n                            check_square = chess.square(check_file, check_rank)\n                            check_piece = board.piece_at(check_square)\n                            if check_piece and check_piece.piece_type == chess.PAWN and check_piece.color == chess.BLACK:\n                                is_passed = False\n                                break\n                    if not is_passed:\n                        break\n                if is_passed:\n                    advancement_bonus = (rank - 1) * 20\n                    file_bonus = 10 if file in [2, 3, 4, 5] else 5\n                    white_passed += advancement_bonus + file_bonus\n            else:\n                for check_rank in range(rank - 1, -1, -1):\n                    for check_file in [file - 1, file, file + 1]:\n                        if 0 <= check_file <= 7:\n                            check_square = chess.square(check_file, check_rank)\n                            check_piece = board.piece_at(check_square)\n                            if check_piece and check_piece.piece_type == chess.PAWN and check_piece.color == chess.WHITE:\n                                is_passed = False\n                                break\n                    if not is_passed:\n                        break\n                if is_passed:\n                    advancement_bonus = (6 - rank) * 20\n                    file_bonus = 10 if file in [2, 3, 4, 5] else 5\n                    black_passed += advancement_bonus + file_bonus\n    \n    return float(white_passed - black_passed)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Bishop pair bonus and bishop mobility on long diagonals\"\n    white_bishops = 0\n    black_bishops = 0\n    white_mobility = 0\n    black_mobility = 0\n    \n    for square in chess.SQUARES:\n        piece = board.piece_at(square)\n        if piece and piece.piece_type == chess.BISHOP:\n            mobility = len([move for move in board.legal_moves if move.from_square == square])\n            if piece.color == chess.WHITE:\n                white_bishops += 1\n                white_mobility += mobility * 3\n            else:\n                black_bishops += 1\n                black_mobility += mobility * 3\n    \n    white_score = white_mobility + (50 if white_bishops >= 2 else 0)\n    black_score = black_mobility + (50 if black_bishops >= 2 else 0)\n    \n    return float(white_score - black_score)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Control of key central squares (e4, e5, d4, d5) by pieces and pawns\"\n    central_squares = [chess.E4, chess.E5, chess.D4, chess.D5]\n    white_control = 0\n    black_control = 0\n    \n    for square in central_squares:\n        white_attackers = len(board.attackers(chess.WHITE, square))\n        black_attackers = len(board.attackers(chess.BLACK, square))\n        \n        piece = board.piece_at(square)\n        if piece:\n            if piece.color == chess.WHITE:\n                white_control += 15\n            else:\n                black_control += 15\n        \n        white_control += white_attackers * 3\n        black_control += black_attackers * 3\n    \n    return float(white_control - black_control)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Bishop pair advantage and long diagonal control\"\n    white_bishops = []\n    black_bishops = []\n    \n    for square in chess.SQUARES:\n        piece = board.piece_at(square)\n        if piece and piece.piece_type == chess.BISHOP:\n            if piece.color == chess.WHITE:\n                white_bishops.append(square)\n            else:\n                black_bishops.append(square)\n    \n    score = 0\n    if len(white_bishops) == 2:\n        score += 30\n    if len(black_bishops) == 2:\n        score -= 30\n    \n    # Long diagonal control bonus\n    long_diagonals = [chess.A1, chess.B2, chess.C3, chess.D4, chess.E5, chess.F6, chess.G7, chess.H8,\n                     chess.A8, chess.B7, chess.C6, chess.D5, chess.E4, chess.F3, chess.G2, chess.H1]\n    \n    for square in long_diagonals:\n        piece = board.piece_at(square)\n        if piece and piece.piece_type == chess.BISHOP:\n            if piece.color == chess.WHITE:\n                score += 5\n            else:\n                score -= 5\n    \n    return float(score)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Pawn structure quality: doubled, isolated, and backward pawns penalty\"\n    white_penalty = 0\n    black_penalty = 0\n    \n    white_pawns = {}\n    black_pawns = {}\n    \n    for square in chess.SQUARES:\n        piece = board.piece_at(square)\n        if piece and piece.piece_type == chess.PAWN:\n            file = chess.square_file(square)\n            rank = chess.square_rank(square)\n            if piece.color == chess.WHITE:\n                if file not in white_pawns:\n                    white_pawns[file] = []\n                white_pawns[file].append(rank)\n            else:\n                if file not in black_pawns:\n                    black_pawns[file] = []\n                black_pawns[file].append(rank)\n    \n    # Doubled pawns\n    for file_pawns in white_pawns.values():\n        if len(file_pawns) > 1:\n            white_penalty += 20 * (len(file_pawns) - 1)\n    \n    for file_pawns in black_pawns.values():\n        if len(file_pawns) > 1:\n            black_penalty += 20 * (len(file_pawns) - 1)\n    \n    # Isolated pawns\n    for file in white_pawns:\n        if (file - 1 not in white_pawns) and (file + 1 not in white_pawns):\n            white_penalty += 15\n    \n    for file in black_pawns:\n        if (file - 1 not in black_pawns) and (file + 1 not in black_pawns):\n            black_penalty += 15\n    \n    return float(black_penalty - white_penalty)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Doubled, isolated, and backward pawn penalties\"\n    white_penalty = 0\n    black_penalty = 0\n    \n    # Count pawns per file\n    file_pawns = {'white': [0]*8, 'black': [0]*8}\n    pawn_positions = {'white': [], 'black': []}\n    \n    for square in chess.SQUARES:\n        piece = board.piece_at(square)\n        if piece and piece.piece_type == chess.PAWN:\n            file = chess.square_file(square)\n            if piece.color == chess.WHITE:\n                file_pawns['white'][file] += 1\n                pawn_positions['white'].append(square)\n            else:\n                file_pawns['black'][file] += 1\n                pawn_positions['black'].append(square)\n    \n    # Doubled pawns penalty\n    for file_count in file_pawns['white']:\n        if file_count > 1:\n            white_penalty += (file_count - 1) * 15\n    for file_count in file_pawns['black']:\n        if file_count > 1:\n            black_penalty += (file_count - 1) * 15\n    \n    # Isolated pawns penalty\n    for file in range(8):\n        if file_pawns['white'][file] > 0:\n            has_neighbor = False\n            if file > 0 and file_pawns['white'][file-1] > 0:\n                has_neighbor = True\n            if file < 7 and file_pawns['white'][file+1] > 0:\n                has_neighbor = True\n            if not has_neighbor:\n                white_penalty += 20\n        \n        if file_pawns['black'][file] > 0:\n            has_neighbor = False\n            if file > 0 and file_pawns['black'][file-1] > 0:\n                has_neighbor = True\n            if file < 7 and file_pawns['black'][file+1] > 0:\n                has_neighbor = True\n            if not has_neighbor:\n                black_penalty += 20\n    \n    return float(black_penalty - white_penalty)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Bishop pair advantage and bad bishops trapped by own pawns\"\n    white_bishops = []\n    black_bishops = []\n    \n    for square in chess.SQUARES:\n        piece = board.piece_at(square)\n        if piece and piece.piece_type == chess.BISHOP:\n            if piece.color == chess.WHITE:\n                white_bishops.append(square)\n            else:\n                black_bishops.append(square)\n    \n    score = 0\n    \n    # Bishop pair bonus\n    if len(white_bishops) >= 2:\n        score += 30\n    if len(black_bishops) >= 2:\n        score -= 30\n    \n    # Bad bishops penalty (bishops blocked by own pawns)\n    for bishop_sq in white_bishops:\n        mobility = len([move for move in board.legal_moves if move.from_square == bishop_sq])\n        if mobility <= 3:\n            score -= 15\n    \n    for bishop_sq in black_bishops:\n        mobility = len([move for move in board.legal_moves if move.from_square == bishop_sq])\n        if mobility <= 3:\n            score += 15\n    \n    return float(score)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Weak squares (holes) in pawn structure controlled by opponent pieces\"\n    weak_square_score = 0\n    \n    for square in chess.SQUARES:\n        file, rank = chess.square_file(square), chess.square_rank(square)\n        \n        # Check if square is a potential weak square (can't be defended by pawns)\n        for color in [chess.WHITE, chess.BLACK]:\n            is_weak = True\n            # Check if own pawns can defend this square\n            for pawn_file in [file - 1, file + 1]:\n                if 0 <= pawn_file <= 7:\n                    pawn_rank = rank - 1 if color == chess.WHITE else rank + 1\n                    if 0 <= pawn_rank <= 7:\n                        pawn_square = chess.square(pawn_file, pawn_rank)\n                        piece = board.piece_at(pawn_square)\n                        if piece and piece.piece_type == chess.PAWN and piece.color == color:\n                            is_weak = False\n                            break\n            \n            if is_weak and board.is_attacked_by(not color, square):\n                bonus = 10 if rank in [2, 3, 4, 5] else 5  # Central weak squares more valuable\n                if color == chess.WHITE:\n                    weak_square_score -= bonus\n                else:\n                    weak_square_score += bonus\n    \n    return float(weak_square_score)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Doubled, isolated, and backward pawn penalties\"\n    pawn_structure_score = 0\n    \n    for color in [chess.WHITE, chess.BLACK]:\n        multiplier = 1 if color == chess.WHITE else -1\n        file_pawns = [[] for _ in range(8)]\n        \n        # Group pawns by file\n        for square in chess.SQUARES:\n            piece = board.piece_at(square)\n            if piece and piece.piece_type == chess.PAWN and piece.color == color:\n                file = chess.square_file(square)\n                rank = chess.square_rank(square)\n                file_pawns[file].append(rank)\n        \n        for file in range(8):\n            if len(file_pawns[file]) > 1:\n                pawn_structure_score -= 15 * multiplier  # Doubled pawns\n            \n            if len(file_pawns[file]) == 1:\n                # Check for isolated pawns\n                has_adjacent_pawn = False\n                for adjacent_file in [file - 1, file + 1]:\n                    if 0 <= adjacent_file <= 7 and file_pawns[adjacent_file]:\n                        has_adjacent_pawn = True\n                        break\n                \n                if not has_adjacent_pawn:\n                    pawn_structure_score -= 20 * multiplier  # Isolated pawn\n                else:\n                    # Check for backward pawns\n                    pawn_rank = file_pawns[file][0]\n                    is_backward = True\n                    for adjacent_file in [file - 1, file + 1]:\n                        if 0 <= adjacent_file <= 7:\n                            for adj_rank in file_pawns[adjacent_file]:\n                                if (color == chess.WHITE and adj_rank >= pawn_rank) or \\\n                                   (color == chess.BLACK and adj_rank <= pawn_rank):\n                                    is_backward = False\n                                    break\n                    if is_backward:\n                        pawn_structure_score -= 12 * multiplier  # Backward pawn\n    \n    return float(pawn_structure_score)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Passed pawn evaluation with advancement and support bonuses\"\n    white_passed = 0\n    black_passed = 0\n    \n    for square in chess.SQUARES:\n        piece = board.piece_at(square)\n        if piece and piece.piece_type == chess.PAWN:\n            file, rank = chess.square_file(square), chess.square_rank(square)\n            is_passed = True\n            \n            if piece.color == chess.WHITE:\n                # Check for blocking black pawns\n                for check_rank in range(rank + 1, 8):\n                    for check_file in [file - 1, file, file + 1]:\n                        if 0 <= check_file <= 7:\n                            check_square = chess.square(check_file, check_rank)\n                            check_piece = board.piece_at(check_square)\n                            if check_piece and check_piece.piece_type == chess.PAWN and check_piece.color == chess.BLACK:\n                                is_passed = False\n                                break\n                    if not is_passed:\n                        break\n                \n                if is_passed:\n                    advancement_bonus = (rank - 1) ** 2 * 10\n                    white_passed += advancement_bonus\n            else:\n                for check_rank in range(rank - 1, -1, -1):\n                    for check_file in [file - 1, file, file + 1]:\n                        if 0 <= check_file <= 7:\n                            check_square = chess.square(check_file, check_rank)\n                            check_piece = board.piece_at(check_square)\n                            if check_piece and check_piece.piece_type == chess.PAWN and check_piece.color == chess.WHITE:\n                                is_passed = False\n                                break\n                    if not is_passed:\n                        break\n                \n                if is_passed:\n                    advancement_bonus = (6 - rank) ** 2 * 10\n                    black_passed += advancement_bonus\n    \n    return float(white_passed - black_passed)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Rook placement on open and semi-open files\"\n    white_rook_files = 0\n    black_rook_files = 0\n    \n    # Count pawns on each file\n    file_pawns = [[] for _ in range(8)]\n    for square in chess.SQUARES:\n        piece = board.piece_at(square)\n        if piece and piece.piece_type == chess.PAWN:\n            file_pawns[chess.square_file(square)].append(piece.color)\n    \n    for square in chess.SQUARES:\n        piece = board.piece_at(square)\n        if piece and piece.piece_type == chess.ROOK:\n            file = chess.square_file(square)\n            file_colors = file_pawns[file]\n            \n            if piece.color == chess.WHITE:\n                if not file_colors:  # Open file\n                    white_rook_files += 25\n                elif chess.BLACK not in file_colors:  # Semi-open file\n                    white_rook_files += 15\n            else:\n                if not file_colors:\n                    black_rook_files += 25\n                elif chess.WHITE not in file_colors:\n                    black_rook_files += 15\n    \n    return float(white_rook_files - black_rook_files)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Knight outpost strength on opponent's side of the board\"\n    score = 0\n    for square in chess.SQUARES:\n        piece = board.piece_at(square)\n        if piece and piece.piece_type == chess.KNIGHT:\n            file, rank = chess.square_file(square), chess.square_rank(square)\n            \n            # Check if knight is on opponent's side\n            on_enemy_side = (piece.color == chess.WHITE and rank >= 4) or (piece.color == chess.BLACK and rank <= 3)\n            if not on_enemy_side:\n                continue\n                \n            # Check if knight is protected by own pawn\n            protected = False\n            for pawn_file in [file - 1, file + 1]:\n                if 0 <= pawn_file <= 7:\n                    pawn_rank = rank - 1 if piece.color == chess.WHITE else rank + 1\n                    if 0 <= pawn_rank <= 7:\n                        pawn_square = chess.square(pawn_file, pawn_rank)\n                        pawn = board.piece_at(pawn_square)\n                        if pawn and pawn.piece_type == chess.PAWN and pawn.color == piece.color:\n                            protected = True\n                            break\n            \n            # Check if enemy pawns can attack the knight\n            can_be_attacked = False\n            enemy_color = chess.BLACK if piece.color == chess.WHITE else chess.WHITE\n            for enemy_file in [file - 1, file + 1]:\n                if 0 <= enemy_file <= 7:\n                    enemy_rank = rank + 1 if piece.color == chess.WHITE else rank - 1\n                    if 0 <= enemy_rank <= 7:\n                        enemy_square = chess.square(enemy_file, enemy_rank)\n                        enemy_piece = board.piece_at(enemy_square)\n                        if enemy_piece and enemy_piece.piece_type == chess.PAWN and enemy_piece.color == enemy_color:\n                            can_be_attacked = True\n                            break\n            \n            if protected and not can_be_attacked:\n                outpost_value = 25 if rank in [4, 5] else 15\n                score += outpost_value if piece.color == chess.WHITE else -outpost_value\n    \n    return float(score)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Tempo advantage based on whose turn it is and position activity\"\n    base_tempo = 10.0 if board.turn == chess.WHITE else -10.0\n    \n    # Adjust tempo based on piece development\n    development_bonus = 0\n    back_rank = 0 if board.turn == chess.WHITE else 7\n    second_rank = 1 if board.turn == chess.WHITE else 6\n    \n    developed_pieces = 0\n    total_pieces = 0\n    \n    for square in chess.SQUARES:\n        piece = board.piece_at(square)\n        if piece and piece.color == board.turn and piece.piece_type in [chess.KNIGHT, chess.BISHOP]:\n            total_pieces += 1\n            rank = chess.square_rank(square)\n            if rank != back_rank:\n                developed_pieces += 1\n    \n    if total_pieces > 0:\n        development_ratio = developed_pieces / total_pieces\n        development_bonus = development_ratio * 15\n    \n    tempo_value = base_tempo + development_bonus\n    return float(tempo_value if board.turn == chess.WHITE else -tempo_value)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Pawn structure quality: doubled, isolated, and backward pawns penalty\"\n    white_penalty = 0\n    black_penalty = 0\n    \n    pawn_files = {chess.WHITE: [], chess.BLACK: []}\n    for square in chess.SQUARES:\n        piece = board.piece_at(square)\n        if piece and piece.piece_type == chess.PAWN:\n            pawn_files[piece.color].append(chess.square_file(square))\n    \n    for color in [chess.WHITE, chess.BLACK]:\n        files = pawn_files[color]\n        penalty = 0\n        \n        # Doubled pawns\n        for file_idx in range(8):\n            count = files.count(file_idx)\n            if count > 1:\n                penalty += (count - 1) * 25\n        \n        # Isolated pawns\n        for file_idx in set(files):\n            if (file_idx - 1 not in files and file_idx + 1 not in files):\n                penalty += 30\n        \n        if color == chess.WHITE:\n            white_penalty = penalty\n        else:\n            black_penalty = penalty\n    \n    return float(black_penalty - white_penalty)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Knight outpost evaluation on strong squares in enemy territory\"\n    outpost_score = 0\n    \n    for square in chess.SQUARES:\n        piece = board.piece_at(square)\n        if piece and piece.piece_type == chess.KNIGHT:\n            file, rank = chess.square_file(square), chess.square_rank(square)\n            \n            # Check if knight is in enemy territory\n            in_enemy_territory = (piece.color == chess.WHITE and rank >= 4) or (piece.color == chess.BLACK and rank <= 3)\n            \n            if in_enemy_territory:\n                # Check if square is defended by own pawn\n                defended_by_pawn = False\n                for pawn_file in [file - 1, file + 1]:\n                    if 0 <= pawn_file <= 7:\n                        pawn_rank = rank - 1 if piece.color == chess.WHITE else rank + 1\n                        if 0 <= pawn_rank <= 7:\n                            pawn_piece = board.piece_at(chess.square(pawn_file, pawn_rank))\n                            if pawn_piece and pawn_piece.piece_type == chess.PAWN and pawn_piece.color == piece.color:\n                                defended_by_pawn = True\n                                break\n                \n                # Check if enemy pawns can attack this square\n                can_be_attacked_by_pawn = False\n                for enemy_file in [file - 1, file + 1]:\n                    if 0 <= enemy_file <= 7:\n                        enemy_rank = rank - 1 if piece.color == chess.BLACK else rank + 1\n                        if 0 <= enemy_rank <= 7:\n                            enemy_piece = board.piece_at(chess.square(enemy_file, enemy_rank))\n                            if enemy_piece and enemy_piece.piece_type == chess.PAWN and enemy_piece.color != piece.color:\n                                can_be_attacked_by_pawn = True\n                                break\n                \n                if defended_by_pawn and not can_be_attacked_by_pawn:\n                    bonus = 25\n                    outpost_score += bonus if piece.color == chess.WHITE else -bonus\n    \n    return float(outpost_score)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Bishop pair advantage in open positions\"\n    white_bishops = 0\n    black_bishops = 0\n    \n    for square in chess.SQUARES:\n        piece = board.piece_at(square)\n        if piece and piece.piece_type == chess.BISHOP:\n            if piece.color == chess.WHITE:\n                white_bishops += 1\n            else:\n                black_bishops += 1\n    \n    # Count pawns to determine position openness\n    total_pawns = sum(1 for piece in board.piece_map().values() if piece.piece_type == chess.PAWN)\n    openness_factor = max(1.0, (16 - total_pawns) / 8.0)\n    \n    bishop_pair_bonus = 0\n    if white_bishops >= 2:\n        bishop_pair_bonus += 30 * openness_factor\n    if black_bishops >= 2:\n        bishop_pair_bonus -= 30 * openness_factor\n    \n    return float(bishop_pair_bonus)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Pawn structure evaluation including doubled, isolated, and passed pawns\"\n    white_score = 0\n    black_score = 0\n    \n    for file in range(8):\n        white_pawns = []\n        black_pawns = []\n        for rank in range(8):\n            square = chess.square(file, rank)\n            piece = board.piece_at(square)\n            if piece and piece.piece_type == chess.PAWN:\n                if piece.color == chess.WHITE:\n                    white_pawns.append(rank)\n                else:\n                    black_pawns.append(rank)\n        \n        # Doubled pawns penalty\n        if len(white_pawns) > 1:\n            white_score -= 20 * (len(white_pawns) - 1)\n        if len(black_pawns) > 1:\n            black_score -= 20 * (len(black_pawns) - 1)\n        \n        # Isolated pawns penalty\n        has_adjacent = False\n        for adj_file in [file - 1, file + 1]:\n            if 0 <= adj_file <= 7:\n                for rank in range(8):\n                    square = chess.square(adj_file, rank)\n                    piece = board.piece_at(square)\n                    if piece and piece.piece_type == chess.PAWN:\n                        has_adjacent = True\n                        break\n        \n        if white_pawns and not has_adjacent:\n            white_score -= 15\n        if black_pawns and not has_adjacent:\n            black_score -= 15\n    \n    return float(white_score - black_score)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Rook activity including open files and 7th rank occupation\"\n    white_score = 0\n    black_score = 0\n    \n    for square in chess.SQUARES:\n        piece = board.piece_at(square)\n        if piece and piece.piece_type == chess.ROOK:\n            file, rank = chess.square_file(square), chess.square_rank(square)\n            \n            # Open file bonus\n            file_pawns = 0\n            for check_rank in range(8):\n                check_square = chess.square(file, check_rank)\n                check_piece = board.piece_at(check_square)\n                if check_piece and check_piece.piece_type == chess.PAWN:\n                    file_pawns += 1\n            \n            open_file_bonus = 20 if file_pawns == 0 else (10 if file_pawns == 1 else 0)\n            \n            # 7th rank bonus\n            seventh_rank_bonus = 0\n            if (piece.color == chess.WHITE and rank == 6) or (piece.color == chess.BLACK and rank == 1):\n                seventh_rank_bonus = 25\n            \n            # Mobility\n            mobility = len([move for move in board.legal_moves if move.from_square == square])\n            \n            total_score = open_file_bonus + seventh_rank_bonus + mobility * 2\n            \n            if piece.color == chess.WHITE:\n                white_score += total_score\n            else:\n                black_score += total_score\n    \n    return float(white_score - black_score)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Rook activity on open and semi-open files\"\n    white_rook_activity = 0\n    black_rook_activity = 0\n    \n    # Count pawns on each file\n    file_pawns = {chess.WHITE: [0] * 8, chess.BLACK: [0] * 8}\n    for square in chess.SQUARES:\n        piece = board.piece_at(square)\n        if piece and piece.piece_type == chess.PAWN:\n            file = chess.square_file(square)\n            file_pawns[piece.color][file] += 1\n    \n    for square in chess.SQUARES:\n        piece = board.piece_at(square)\n        if piece and piece.piece_type == chess.ROOK:\n            file = chess.square_file(square)\n            activity = 0\n            \n            # Open file bonus (no pawns)\n            if file_pawns[chess.WHITE][file] == 0 and file_pawns[chess.BLACK][file] == 0:\n                activity += 25\n            # Semi-open file bonus (no own pawns)\n            elif file_pawns[piece.color][file] == 0:\n                activity += 15\n            \n            if piece.color == chess.WHITE:\n                white_rook_activity += activity\n            else:\n                black_rook_activity += activity\n    \n    return float(white_rook_activity - black_rook_activity)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Rook activity on open and semi-open files\"\n    score = 0\n    \n    for square in chess.SQUARES:\n        piece = board.piece_at(square)\n        if piece and piece.piece_type == chess.ROOK:\n            file = chess.square_file(square)\n            \n            # Check if file is open (no pawns) or semi-open (no own pawns)\n            own_pawns = 0\n            enemy_pawns = 0\n            for rank in range(8):\n                check_piece = board.piece_at(chess.square(file, rank))\n                if check_piece and check_piece.piece_type == chess.PAWN:\n                    if check_piece.color == piece.color:\n                        own_pawns += 1\n                    else:\n                        enemy_pawns += 1\n            \n            if own_pawns == 0 and enemy_pawns == 0:\n                bonus = 30  # Open file\n            elif own_pawns == 0:\n                bonus = 20  # Semi-open file\n            else:\n                bonus = 0\n            \n            if piece.color == chess.WHITE:\n                score += bonus\n            else:\n                score -= bonus\n    \n    return float(score)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Bishops on long diagonals and bishop pair advantage\"\n    score = 0\n    white_bishops = 0\n    black_bishops = 0\n    \n    for square in chess.SQUARES:\n        piece = board.piece_at(square)\n        if piece and piece.piece_type == chess.BISHOP:\n            file, rank = chess.square_file(square), chess.square_rank(square)\n            \n            # Long diagonal bonus (a1-h8 and h1-a8)\n            if (file - rank == 0) or (file + rank == 7):\n                diagonal_bonus = 15\n                if piece.color == chess.WHITE:\n                    score += diagonal_bonus\n                else:\n                    score -= diagonal_bonus\n            \n            if piece.color == chess.WHITE:\n                white_bishops += 1\n            else:\n                black_bishops += 1\n    \n    # Bishop pair bonus\n    if white_bishops >= 2:\n        score += 25\n    if black_bishops >= 2:\n        score -= 25\n    \n    return float(score)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Endgame king activity and centralization\"\n    total_material = sum(1 for piece in board.piece_map().values() if piece.piece_type != chess.KING)\n    \n    # Only evaluate in endgame (low material)\n    if total_material > 12:\n        return 0.0\n    \n    score = 0\n    for color in [chess.WHITE, chess.BLACK]:\n        king_square = board.king(color)\n        if king_square is None:\n            continue\n            \n        file, rank = chess.square_file(king_square), chess.square_rank(king_square)\n        \n        # Centralization bonus\n        center_distance = abs(file - 3.5) + abs(rank - 3.5)\n        centralization = (7 - center_distance) * 8\n        \n        # King activity (squares attacked)\n        activity = len(board.attackers(color, king_square))\n        \n        total_score = centralization + activity * 5\n        \n        if color == chess.WHITE:\n            score += total_score\n        else:\n            score -= total_score\n    \n    return float(score)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Rook placement on open and semi-open files\"\n    white_score = 0\n    black_score = 0\n    \n    for file_idx in range(8):\n        white_pawns = sum(1 for rank in range(8) if board.piece_at(chess.square(file_idx, rank)) and board.piece_at(chess.square(file_idx, rank)).piece_type == chess.PAWN and board.piece_at(chess.square(file_idx, rank)).color == chess.WHITE)\n        black_pawns = sum(1 for rank in range(8) if board.piece_at(chess.square(file_idx, rank)) and board.piece_at(chess.square(file_idx, rank)).piece_type == chess.PAWN and board.piece_at(chess.square(file_idx, rank)).color == chess.BLACK)\n        \n        for rank in range(8):\n            piece = board.piece_at(chess.square(file_idx, rank))\n            if piece and piece.piece_type == chess.ROOK:\n                if piece.color == chess.WHITE:\n                    if white_pawns == 0 and black_pawns == 0:\n                        white_score += 30  # Open file\n                    elif white_pawns == 0:\n                        white_score += 20  # Semi-open file\n                else:\n                    if white_pawns == 0 and black_pawns == 0:\n                        black_score += 30  # Open file\n                    elif black_pawns == 0:\n                        black_score += 20  # Semi-open file\n    \n    return float(white_score - black_score)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Bishop pair advantage and bad bishop penalty\"\n    white_bishops = []\n    black_bishops = []\n    \n    for square in chess.SQUARES:\n        piece = board.piece_at(square)\n        if piece and piece.piece_type == chess.BISHOP:\n            if piece.color == chess.WHITE:\n                white_bishops.append(square)\n            else:\n                black_bishops.append(square)\n    \n    score = 0\n    \n    # Bishop pair bonus\n    if len(white_bishops) >= 2:\n        score += 25\n    if len(black_bishops) >= 2:\n        score -= 25\n    \n    # Bad bishop penalty (bishop blocked by own pawns)\n    for bishop_square in white_bishops:\n        blocked_pawns = 0\n        for square in chess.SQUARES:\n            piece = board.piece_at(square)\n            if piece and piece.piece_type == chess.PAWN and piece.color == chess.WHITE:\n                if (chess.square_rank(square) + chess.square_file(square)) % 2 == (chess.square_rank(bishop_square) + chess.square_file(bishop_square)) % 2:\n                    blocked_pawns += 1\n        if blocked_pawns > 4:\n            score -= 15\n    \n    for bishop_square in black_bishops:\n        blocked_pawns = 0\n        for square in chess.SQUARES:\n            piece = board.piece_at(square)\n            if piece and piece.piece_type == chess.PAWN and piece.color == chess.BLACK:\n                if (chess.square_rank(square) + chess.square_file(square)) % 2 == (chess.square_rank(bishop_square) + chess.square_file(bishop_square)) % 2:\n                    blocked_pawns += 1\n        if blocked_pawns > 4:\n            score += 15\n    \n    return float(score)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Rook activity and control of open and semi-open files\"\n    rook_activity = 0\n    \n    for square in chess.SQUARES:\n        piece = board.piece_at(square)\n        if piece and piece.piece_type == chess.ROOK:\n            file, rank = chess.square_file(square), chess.square_rank(square)\n            \n            # Check if on open file (no pawns on file)\n            open_file = True\n            semi_open = True\n            for check_rank in range(8):\n                check_piece = board.piece_at(chess.square(file, check_rank))\n                if check_piece and check_piece.piece_type == chess.PAWN:\n                    open_file = False\n                    if check_piece.color == piece.color:\n                        semi_open = False\n            \n            score = 0\n            if open_file:\n                score += 30\n            elif semi_open:\n                score += 15\n            \n            # Seventh rank bonus\n            if (piece.color == chess.WHITE and rank == 6) or (piece.color == chess.BLACK and rank == 1):\n                score += 20\n            \n            if piece.color == chess.WHITE:\n                rook_activity += score\n            else:\n                rook_activity -= score\n    \n    return float(rook_activity)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Bishop pair advantage and diagonal control\"\n    white_bishops = 0\n    black_bishops = 0\n    diagonal_control = 0\n    \n    for square in chess.SQUARES:\n        piece = board.piece_at(square)\n        if piece and piece.piece_type == chess.BISHOP:\n            if piece.color == chess.WHITE:\n                white_bishops += 1\n            else:\n                black_bishops += 1\n            \n            # Count diagonal squares controlled\n            mobility = len([move for move in board.legal_moves if move.from_square == square])\n            if piece.color == chess.WHITE:\n                diagonal_control += mobility * 2\n            else:\n                diagonal_control -= mobility * 2\n    \n    # Bishop pair bonus\n    bishop_pair_bonus = 0\n    if white_bishops >= 2:\n        bishop_pair_bonus += 25\n    if black_bishops >= 2:\n        bishop_pair_bonus -= 25\n    \n    return float(diagonal_control + bishop_pair_bonus)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Knight outpost evaluation on squares defended by pawns but not attackable by enemy pawns\"\n    outpost_score = 0\n    \n    for square in chess.SQUARES:\n        piece = board.piece_at(square)\n        if piece and piece.piece_type == chess.KNIGHT:\n            file, rank = chess.square_file(square), chess.square_rank(square)\n            \n            # Check if defended by own pawn\n            defended_by_pawn = False\n            pawn_ranks = [rank - 1] if piece.color == chess.WHITE else [rank + 1]\n            for pawn_rank in pawn_ranks:\n                if 0 <= pawn_rank <= 7:\n                    for pawn_file in [file - 1, file + 1]:\n                        if 0 <= pawn_file <= 7:\n                            pawn_square = chess.square(pawn_file, pawn_rank)\n                            pawn_piece = board.piece_at(pawn_square)\n                            if pawn_piece and pawn_piece.piece_type == chess.PAWN and pawn_piece.color == piece.color:\n                                defended_by_pawn = True\n            \n            # Check if attackable by enemy pawns\n            attackable_by_enemy_pawn = False\n            enemy_pawn_ranks = [rank - 1] if piece.color == chess.BLACK else [rank + 1]\n            for enemy_rank in enemy_pawn_ranks:\n                if 0 <= enemy_rank <= 7:\n                    for enemy_file in [file - 1, file + 1]:\n                        if 0 <= enemy_file <= 7:\n                            enemy_square = chess.square(enemy_file, enemy_rank)\n                            enemy_piece = board.piece_at(enemy_square)\n                            if enemy_piece and enemy_piece.piece_type == chess.PAWN and enemy_piece.color != piece.color:\n                                attackable_by_enemy_pawn = True\n            \n            if defended_by_pawn and not attackable_by_enemy_pawn:\n                bonus = 25 if rank in [3, 4, 5] else 15\n                outpost_score += bonus if piece.color == chess.WHITE else -bonus\n    \n    return float(outpost_score)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Bishop pair advantage and diagonal control evaluation\"\n    white_bishops = []\n    black_bishops = []\n    \n    for square in chess.SQUARES:\n        piece = board.piece_at(square)\n        if piece and piece.piece_type == chess.BISHOP:\n            if piece.color == chess.WHITE:\n                white_bishops.append(square)\n            else:\n                black_bishops.append(square)\n    \n    score = 0\n    \n    # Bishop pair bonus\n    if len(white_bishops) >= 2:\n        score += 50\n    if len(black_bishops) >= 2:\n        score -= 50\n    \n    # Long diagonal control\n    long_diagonals = [(chess.A1, chess.H8), (chess.H1, chess.A8)]\n    for start, end in long_diagonals:\n        white_controls = any(board.is_attacked_by(chess.WHITE, sq) for sq in [start, end])\n        black_controls = any(board.is_attacked_by(chess.BLACK, sq) for sq in [start, end])\n        if white_controls:\n            score += 15\n        if black_controls:\n            score -= 15\n    \n    return float(score)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Rook activity on open and semi-open files with rank control\"\n    rook_activity = 0\n    \n    for square in chess.SQUARES:\n        piece = board.piece_at(square)\n        if piece and piece.piece_type == chess.ROOK:\n            file, rank = chess.square_file(square), chess.square_rank(square)\n            activity = 0\n            \n            # Check if rook is on open file (no pawns)\n            open_file = True\n            for check_rank in range(8):\n                check_square = chess.square(file, check_rank)\n                check_piece = board.piece_at(check_square)\n                if check_piece and check_piece.piece_type == chess.PAWN:\n                    open_file = False\n                    break\n            \n            if open_file:\n                activity += 25\n            else:\n                # Check for semi-open file (no own pawns)\n                semi_open = True\n                for check_rank in range(8):\n                    check_square = chess.square(file, check_rank)\n                    check_piece = board.piece_at(check_square)\n                    if check_piece and check_piece.piece_type == chess.PAWN and check_piece.color == piece.color:\n                        semi_open = False\n                        break\n                if semi_open:\n                    activity += 15\n            \n            # Seventh rank bonus\n            if (piece.color == chess.WHITE and rank == 6) or (piece.color == chess.BLACK and rank == 1):\n                activity += 20\n            \n            if piece.color == chess.WHITE:\n                rook_activity += activity\n            else:\n                rook_activity -= activity\n    \n    return float(rook_activity)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Bishop pair advantage and diagonal control\"\n    white_bishops = []\n    black_bishops = []\n    \n    for square in chess.SQUARES:\n        piece = board.piece_at(square)\n        if piece and piece.piece_type == chess.BISHOP:\n            if piece.color == chess.WHITE:\n                white_bishops.append(square)\n            else:\n                black_bishops.append(square)\n    \n    score = 0\n    \n    # Bishop pair bonus\n    if len(white_bishops) >= 2:\n        score += 30\n    if len(black_bishops) >= 2:\n        score -= 30\n    \n    # Long diagonal control\n    long_diagonals = [chess.A1, chess.B2, chess.C3, chess.D4, chess.E5, chess.F6, chess.G7, chess.H8,\n                     chess.A8, chess.B7, chess.C6, chess.D5, chess.E4, chess.F3, chess.G2, chess.H1]\n    \n    for bishop_square in white_bishops:\n        if bishop_square in long_diagonals:\n            score += 10\n    for bishop_square in black_bishops:\n        if bishop_square in long_diagonals:\n            score -= 10\n    \n    return float(score)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Rook activity on open and semi-open files\"\n    white_rook_activity = 0\n    black_rook_activity = 0\n    \n    for square in chess.SQUARES:\n        piece = board.piece_at(square)\n        if piece and piece.piece_type == chess.ROOK:\n            file = chess.square_file(square)\n            rank = chess.square_rank(square)\n            \n            # Check if file is open or semi-open\n            own_pawns_on_file = 0\n            enemy_pawns_on_file = 0\n            \n            for check_rank in range(8):\n                check_piece = board.piece_at(chess.square(file, check_rank))\n                if check_piece and check_piece.piece_type == chess.PAWN:\n                    if check_piece.color == piece.color:\n                        own_pawns_on_file += 1\n                    else:\n                        enemy_pawns_on_file += 1\n            \n            # Score based on file type\n            if own_pawns_on_file == 0 and enemy_pawns_on_file == 0:\n                activity = 50  # Open file\n            elif own_pawns_on_file == 0:\n                activity = 30  # Semi-open file\n            else:\n                activity = 10  # Closed file\n            \n            # Bonus for 7th/2nd rank\n            if (piece.color == chess.WHITE and rank == 6) or (piece.color == chess.BLACK and rank == 1):\n                activity += 20\n            \n            if piece.color == chess.WHITE:\n                white_rook_activity += activity\n            else:\n                black_rook_activity += activity\n    \n    return float(white_rook_activity - black_rook_activity)\n\n",
    "def feature(board: chess.Board) -> float:\n    \"Bishop pair advantage and diagonal control\"\n    white_bishops = []\n    black_bishops = []\n    \n    for square in chess.SQUARES:\n        piece = board.piece_at(square)\n        if piece and piece.piece_type == chess.BISHOP:\n            if piece.color == chess.WHITE:\n                white_bishops.append(square)\n            else:\n                black_bishops.append(square)\n    \n    score = 0\n    \n    # Bishop pair bonus\n    if len(white_bishops) >= 2:\n        score += 40\n    if len(black_bishops) >= 2:\n        score -= 40\n    \n    # Diagonal control\n    for bishops, multiplier in [(white_bishops, 1), (black_bishops, -1)]:\n        for bishop_square in bishops:\n            diagonal_control = 0\n            # Count squares controlled on diagonals\n            for direction in [(1, 1), (1, -1), (-1, 1), (-1, -1)]:\n                file, rank = chess.square_file(bishop_square), chess.square_rank(bishop_square)\n                for distance in range(1, 8):\n                    new_file = file + direction[0] * distance\n                    new_rank = rank + direction[1] * distance\n                    if 0 <= new_file <= 7 and 0 <= new_rank <= 7:\n                        target_square = chess.square(new_file, new_rank)\n                        target_piece = board.piece_at(target_square)\n                        diagonal_control += 2\n                        if target_piece:\n                            break\n                    else:\n                        break\n            score += diagonal_control * multiplier\n    \n    return float(score)\n\n"
  ]
}