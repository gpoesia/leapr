{
  "combined_from": [
    "results/features/did3__image_classification_fashion_mnist__gpt-5-mini.json",
    "results/features/funsearch__image_classification_fashion_mnist__gpt-5-mini.json"
  ],
  "used_features": [
    "def feature(image: np.ndarray) -> float:\n    'Mean intensity difference between the shoulder side strips and the top-center strip (side_mean - center_mean)'\n    import numpy as np\n    gray = np.mean(image, axis=2) if len(image.shape) == 3 else image.astype(np.float32)\n    h, w = gray.shape\n    bg = np.percentile(gray, 10)\n    fg = np.percentile(gray, 90)\n    thr = (bg + fg) / 2.0\n    mask = gray > thr\n    if not mask.any():\n        return 0.0\n    rows = np.any(mask, axis=1)\n    cols = np.any(mask, axis=0)\n    rmin = np.argmax(rows)\n    rmax = h - 1 - np.argmax(rows[::-1])\n    cmin = np.argmax(cols)\n    cmax = w - 1 - np.argmax(cols[::-1])\n    if rmax <= rmin or cmax <= cmin:\n        return 0.0\n    bbox = gray[rmin:rmax+1, cmin:cmax+1]\n    bh, bw = bbox.shape\n    top_h = max(1, bh // 5)\n    center_w = max(1, bw // 5)\n    center_start = (bw - center_w) // 2\n    center_strip = bbox[0:top_h, center_start:center_start + center_w]\n    side_w = max(1, bw // 6)\n    left_strip = bbox[0:top_h, 0:side_w]\n    right_strip = bbox[0:top_h, -side_w:]\n    side_mean = float((np.mean(left_strip) + np.mean(right_strip)) / 2.0)\n    center_mean = float(np.mean(center_strip))\n    return float(side_mean - center_mean)\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Ratio of object width near the very top to width a bit lower (width_at_10pct / width_at_30pct) - indicates shoulder tapering'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    h, w = gray.shape[:2]\n    mn, mx = float(np.min(gray)), float(np.max(gray))\n    if mx <= mn:\n        return 0.0\n    mask = gray > (mn + 0.2 * (mx - mn))\n    # bounding box of mask\n    ys, xs = np.where(mask)\n    if ys.size == 0:\n        return 0.0\n    top, bottom = int(np.min(ys)), int(np.max(ys))\n    bh = max(1, bottom - top + 1)\n    # rows at 10% and 30% within bbox\n    r10 = top + max(0, int(0.10 * bh))\n    r30 = top + max(0, int(0.30 * bh))\n    def row_width(row):\n        row_mask = mask[row, :]\n        if np.any(row_mask):\n            cols = np.where(row_mask)[0]\n            return float(cols[-1] - cols[0] + 1)\n        return 0.0\n    w10 = row_width(min(h - 1, r10))\n    w30 = row_width(min(h - 1, r30))\n    denom = w30 if w30 > 0 else 1.0\n    return float(w10 / denom)\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Small collar intensity: mean intensity in a narrow central upper patch minus surrounding upper intensity (positive if a collar/bright center exists)'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    top_h = max(1, h // 8)\n    center_c0 = max(0, w//2 - max(1, w//10))\n    center_c1 = min(w, w//2 + max(1, w//10))\n    central_patch = gray[0:top_h, center_c0:center_c1]\n    surrounding_patch = gray[0:top_h, :]\n    # exclude central from surrounding\n    surround_vals = np.concatenate([surrounding_patch[:, :center_c0].ravel(), surrounding_patch[:, center_c1:].ravel()]) if center_c0>0 or center_c1<w else surrounding_patch.ravel()\n    if central_patch.size == 0 or surround_vals.size == 0:\n        return 0.0\n    center_mean = float(np.mean(central_patch))\n    surround_mean = float(np.mean(surround_vals))\n    denom = float(np.max(gray) - np.min(gray)) if np.max(gray) != np.min(gray) else 1.0\n    return float((center_mean - surround_mean) / denom)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Count of peaks in vertical projection of foreground (normalized by image width)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    proj = np.sum(mask.astype(float), axis=0)\n    if np.all(proj == 0):\n        return 0.0\n    # simple smoothing\n    pad = np.pad(proj, (1, 1), mode='edge')\n    smooth = (pad[:-2] + pad[1:-1] + pad[2:]) / 3.0\n    peaks = (smooth > np.roll(smooth, 1)) & (smooth > np.roll(smooth, -1))\n    thr_val = np.percentile(smooth, 50)\n    peaks = peaks & (smooth > thr_val)\n    count = float(np.count_nonzero(peaks))\n    return float(count / (w + 1e-8))\n",
    "def feature(image: np.ndarray) -> float:\n    'Standard deviation of the bottom contour (last foreground row per column) normalized by image height'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 1 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = gray < thr if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else gray > thr\n    bottom_idx = np.full((w,), -1, dtype=float)\n    any_in_col = np.any(mask, axis=0)\n    cols = np.where(any_in_col)[0]\n    if cols.size == 0:\n        return 0.0\n    for c in cols:\n        col = mask[:, c]\n        # last occurrence index where True\n        r = np.max(np.where(col)[0])\n        bottom_idx[c] = float(r)\n    valid = bottom_idx[bottom_idx >= 0.0]\n    if valid.size == 0:\n        return 0.0\n    std = float(np.std(valid)) / float(max(1.0, float(h)))\n    return float(std)\n",
    "def feature(image: np.ndarray) -> float:\n    'Normalized top-minus-bottom mean intensity (shirts often have darker collar/top than bottom)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    top_h = max(1, h // 4)\n    bottom_h = max(1, h // 4)\n    top_mean = np.mean(gray[:top_h, :]) if top_h > 0 else 0.0\n    bottom_mean = np.mean(gray[-bottom_h:, :]) if bottom_h > 0 else 0.0\n    denom = (np.mean(gray) + 1e-9)\n    return float((top_mean - bottom_mean) / denom)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Concentration of bottom-quarter foreground pixels in the central columns relative to sides (coats often have central extension downwards)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    mx = gray.max() if gray.size else 1.0\n    if mx > 0:\n        gray = gray / mx\n    h, w = gray.shape\n    thr = max(0.02, np.mean(gray) * 0.75)\n    mask = gray > thr\n    if not mask.any():\n        return 0.0\n    ys, xs = np.where(mask)\n    top, bottom, left, right = ys.min(), ys.max(), xs.min(), xs.max()\n    bh = max(1, bottom - top + 1)\n    start = top + int(round(bh * 0.75))\n    start = min(start, bottom)\n    bottom_mask = mask[start:bottom+1, :]\n    if not bottom_mask.any():\n        return 0.0\n    # center columns defined as middle 20% of bbox width\n    bw = max(1, right - left + 1)\n    center_w = max(1, int(round(bw * 0.20)))\n    cx0 = left + bw//2 - center_w//2\n    cx1 = cx0 + center_w\n    cx0 = max(0, cx0); cx1 = min(w, cx1)\n    center_count = float(np.sum(bottom_mask[:, cx0:cx1]))\n    total_bottom = float(np.sum(bottom_mask))\n    return float(center_count / max(1e-6, total_bottom))\n",
    "def feature(image: np.ndarray) -> float:\n    'Relative mass of object pixels in left/right upper quarters vs central upper third (indicates sleeve protrusions)'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    med = np.median(gray); sd = np.std(gray)\n    if sd < 1e-6:\n        return 0.0\n    mask = (gray > med + 0.25 * sd) | (gray < med - 0.25 * sd)\n    if not np.any(mask):\n        return 0.0\n    rows, cols = np.where(mask)\n    minr, maxr = rows.min(), rows.max()\n    minc, maxc = cols.min(), cols.max()\n    bh = maxr - minr + 1; bw = maxc - minc + 1\n    upper_h = max(1, int(bh * 0.35))\n    top_slice = (slice(minr, minr + upper_h), slice(minc, maxc + 1))\n    submask = mask[top_slice]\n    if submask.size == 0:\n        return 0.0\n    third = max(1, bw // 3)\n    left_block = submask[:, :third]\n    center_block = submask[:, third:third + third]\n    right_block = submask[:, -third:]\n    left_count = np.count_nonzero(left_block)\n    right_count = np.count_nonzero(right_block)\n    center_count = np.count_nonzero(center_block) + 1e-9\n    return float((left_count + right_count) / center_count)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Perimeter-to-area ratio estimated from mask gradients (edge pixels / mask area)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 2 or w < 2:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 50)\n    mask = ((gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)).astype(float)\n    area = np.count_nonzero(mask)\n    if area == 0:\n        return 0.0\n    gy, gx = np.gradient(mask)\n    edge_strength = np.abs(gy) + np.abs(gx)\n    edge_pixels = float(np.count_nonzero(edge_strength > 0.1))\n    return float(edge_pixels / (float(area) + 1e-8))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Relative diagonal edge strength ((45\u00b0 and -45\u00b0) vs axis-aligned), highlighting lapels or diagonal seams'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    gx, gy = np.gradient(gray)\n    diag1 = np.abs(gx + gy)\n    diag2 = np.abs(gx - gy)\n    diag_mean = float(np.mean(diag1) + np.mean(diag2))\n    axis_mean = float(np.mean(np.abs(gx)) + np.mean(np.abs(gy)))\n    eps = 1e-6\n    return float(diag_mean / (axis_mean + eps))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Neck hole area fraction inside a small top-center rectangle (non-object pixels indicating round neck)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    cx = w // 2\n    bw = max(1, w // 6)\n    bh = max(1, h // 10)\n    top = 0\n    region = gray[top:top+bh, max(0, cx-bw):min(w, cx+bw)]\n    if region.size == 0:\n        return 0.0\n    # define mask for object\n    thr = np.mean(gray) * 0.6\n    obj = gray > thr\n    region_obj = obj[top:top+bh, max(0, cx-bw):min(w, cx+bw)]\n    hole = (~region_obj).astype(float)\n    # proportion of hole pixels\n    prop = float(np.sum(hole) / max(1.0, hole.size))\n    return prop\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Bounding-box aspect ratio of the masked object (height/width), 0 if no mask'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    ys, xs = np.where(mask)\n    if ys.size == 0:\n        return 0.0\n    miny, maxy = ys.min(), ys.max()\n    minx, maxx = xs.min(), xs.max()\n    bbox_h = float(maxy - miny + 1)\n    bbox_w = float(maxx - minx + 1)\n    if bbox_w <= 1e-8:\n        return float(bbox_h)\n    return float(bbox_h / bbox_w)\n",
    "def feature(image: np.ndarray) -> float:\n    'Fraction of zero (background) pixels inside the object bounding box (indicates holes/straps)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    mn, mx = float(np.min(gray)), float(np.max(gray))\n    eps = 1e-8\n    if mx - mn < eps:\n        return 0.0\n    norm = (gray - mn) / (mx - mn)\n    mask = norm > 0.2\n    if not np.any(mask):\n        return 0.0\n    rows = np.where(mask.any(axis=1))[0]\n    cols = np.where(mask.any(axis=0))[0]\n    if rows.size == 0 or cols.size == 0:\n        return 0.0\n    r0, r1 = rows[0], rows[-1]\n    c0, c1 = cols[0], cols[-1]\n    bbox = mask[r0:r1 + 1, c0:c1 + 1]\n    area = bbox.size\n    if area == 0:\n        return 0.0\n    hole_fraction = 1.0 - (np.sum(bbox) / area)\n    return float(hole_fraction)\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Bounding-box height-to-width ratio of the detected foreground mask'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 50)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    coords = np.argwhere(mask)\n    if coords.size == 0:\n        return 0.0\n    ys, xs = coords[:, 0], coords[:, 1]\n    bh = float(max(1, int(ys.max()) - int(ys.min()) + 1))\n    bw = float(max(1, int(xs.max()) - int(xs.min()) + 1))\n    return float(bh / (bw + 1e-8))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Fraction of pixels that are colorful (range across RGB channels exceeds a small threshold); 0 for grayscale'\n    import numpy as np\n    if image is None:\n        return 0.0\n    if len(image.shape) != 3:\n        return 0.0\n    img = image.astype(float)\n    ch_max = np.max(img, axis=2)\n    ch_min = np.min(img, axis=2)\n    pix_range = ch_max - ch_min\n    rng = np.max(pix_range)\n    thr = max(1e-6, 0.10 * rng)\n    colorful = pix_range > thr\n    return float(np.count_nonzero(colorful)) / float(img.shape[0] * img.shape[1])\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Left-right asymmetry score of the object silhouette (0 = perfectly symmetric, larger -> more asymmetric)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    thr = np.mean(gray) + 0.15 * (np.max(gray) - np.min(gray))\n    mask = gray > thr\n    if not mask.any():\n        mask = gray > np.mean(gray)\n        if not mask.any():\n            return 0.0\n    left = mask[:, :w//2]\n    right = mask[:, w - (w//2):][:, ::-1]  # mirrored right half\n    # pad to same shape if odd width\n    min_cols = min(left.shape[1], right.shape[1])\n    left = left[:, :min_cols]\n    right = right[:, :min_cols]\n    diff = np.abs(left.astype(float) - right.astype(float))\n    asym = np.sum(diff) / (np.sum(mask.astype(float)) + 1e-8)\n    return float(asym)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Fraction of columns in the object bounding box that contain a background pixel in the middle third while having object pixels both above and below (indicative of straps/handles/waist gaps)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    h, w = gray.shape[:2]\n    rng = float(np.max(gray) - np.min(gray))\n    if rng < 1e-6:\n        return 0.0\n    thresh = float(np.mean(gray) + 0.12 * rng)\n    mask = gray > thresh\n    ys, xs = np.where(mask)\n    if xs.size == 0:\n        return 0.0\n    min_r, max_r = int(np.min(ys)), int(np.max(ys))\n    min_c, max_c = int(np.min(xs)), int(np.max(xs))\n    if max_c - min_c + 1 <= 0:\n        return 0.0\n    mid_start = min_r + (max_r - min_r) // 3\n    mid_end = min_r + 2 * (max_r - min_r) // 3\n    count = 0\n    total_cols = 0\n    for c in range(min_c, max_c+1):\n        total_cols += 1\n        col = mask[min_r:max_r+1, c]\n        if col.size == 0:\n            continue\n        # check if there exists a background pixel in middle third\n        mid_region = col[mid_start - min_r:mid_end - min_r + 1]\n        if not np.any(mid_region == False):\n            continue\n        # check object exists above and below that mid background\n        above = np.any(col[:max(1, mid_start - min_r)])\n        below = np.any(col[min(mid_end - min_r + 1, col.size):])\n        if above and below:\n            count += 1\n    if total_cols == 0:\n        return 0.0\n    return float(count) / float(total_cols)\n",
    "def feature(image: np.ndarray) -> float:\n    'Normalized longest contiguous vertical run of foreground in any column (0..1)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 1 or w < 1:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 50)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    if not np.any(mask):\n        return 0.0\n    max_run = 0\n    # iterate columns (usually small width)\n    for col in range(w):\n        colv = mask[:, col].astype(np.uint8)\n        if colv.sum() == 0:\n            continue\n        # run-length: find lengths of contiguous ones\n        dif = np.diff(np.concatenate(([0], colv, [0])))\n        starts = np.where(dif == 1)[0]\n        ends = np.where(dif == -1)[0]\n        if starts.size and ends.size:\n            runs = ends - starts\n            local_max = int(np.max(runs))\n            if local_max > max_run:\n                max_run = local_max\n    return float(max_run / float(h))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Fraction of bottom-half mass located in the central 30% width (indicates centered narrow foot/strap)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    h, w = gray.shape[:2]\n    thr = np.percentile(gray, 70)\n    mask = gray > thr\n    if np.count_nonzero(mask) == 0:\n        mask = gray > np.mean(gray)\n    if np.count_nonzero(mask) == 0:\n        return 0.0\n    rows = np.any(mask, axis=1)\n    r_inds = np.where(rows)[0]\n    if r_inds.size == 0:\n        return 0.0\n    r0, r1 = r_inds[0], r_inds[-1]\n    mid_row = r0 + (r1 - r0 + 1) // 2\n    bottom_mask = mask[mid_row:r1 + 1, :]\n    if np.count_nonzero(bottom_mask) == 0:\n        return 0.0\n    center_left = max(0, int(np.floor(w * 0.35)))\n    center_right = min(w, int(np.ceil(w * 0.65)))\n    center_count = np.count_nonzero(bottom_mask[:, center_left:center_right])\n    frac = center_count / float(np.count_nonzero(bottom_mask) + 1e-9)\n    return float(frac)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Slope magnitude of the centroid x-position across the upper third (captures shoulder outward/inward curvature), normalized by image width'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    h, w = gray.shape\n    thresh = np.mean(gray) * 0.6 + np.min(gray) * 0.4\n    obj = gray > thresh\n    upper_h = max(2, h // 3)\n    xs = []\n    ys = []\n    for r in range(upper_h):\n        cols = np.where(obj[r])[0]\n        if cols.size == 0:\n            continue\n        centroid_x = float(np.mean(cols))\n        xs.append(centroid_x)\n        ys.append(float(r))\n    if len(xs) < 2:\n        return 0.0\n    xs = np.array(xs)\n    ys = np.array(ys)\n    # simple linear fit slope (dx/dy)\n    # slope = covariance(xs, ys)/var(ys)\n    ys_mean = np.mean(ys)\n    xs_mean = np.mean(xs)\n    cov = np.sum((ys - ys_mean) * (xs - xs_mean))\n    var_y = np.sum((ys - ys_mean)**2) + 1e-6\n    slope = cov / var_y\n    # normalize by width per row: slope in pixels per row -> convert to fraction of width per image height\n    norm = abs(slope) * (upper_h / (w + 1e-6))\n    return float(norm)\n",
    "def feature(image: np.ndarray) -> float:\n    'Center vertical band mass divided by combined left+right side mass'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 50)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    left_w = int(max(1, w * 0.25))\n    right_w = left_w\n    center_start = left_w\n    center_end = w - right_w\n    center = mask[:, center_start:center_end]\n    sides = np.concatenate([mask[:, :left_w], mask[:, center_end:]], axis=1) if left_w + right_w < w else mask[:, :0]\n    center_mass = float(np.count_nonzero(center))\n    side_mass = float(np.count_nonzero(sides))\n    return float(center_mass / (side_mass + 1e-8))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Shoulder/top spread: mean mask width in top 12% rows divided by bounding box width'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 3 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    ys, xs = np.where(mask)\n    if ys.size == 0:\n        return 0.0\n    minx, maxx = int(np.min(xs)), int(np.max(xs))\n    bbox_w = float(max(1, maxx - minx + 1))\n    top_rows = max(1, int(0.12 * h))\n    top_widths = np.sum(mask[:top_rows, :], axis=1).astype(float)\n    valid = top_widths[top_widths > 0]\n    if valid.size == 0:\n        return 0.0\n    mean_top = float(np.mean(valid))\n    return float(mean_top / (bbox_w + 1e-8))\n",
    "def feature(image: np.ndarray) -> float:\n    'Count of prominent vertical peaks in the foreground projection (indicative of multiple parts)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    colsum = np.sum(mask.astype(float), axis=0)\n    if not np.any(colsum):\n        return 0.0\n    # simple smoothing\n    kernel = np.array([1.0, 1.0, 1.0])\n    smooth = np.convolve(colsum, kernel, mode='same')\n    thresh = np.percentile(smooth, 60)\n    peaks = 0\n    for i in range(1, smooth.size - 1):\n        if smooth[i] > thresh and smooth[i] > smooth[i - 1] and smooth[i] >= smooth[i + 1]:\n            peaks += 1\n    # consider endpoints\n    if smooth.size >= 1:\n        if smooth.size == 1 and smooth[0] > thresh:\n            peaks = 1\n        else:\n            if smooth[0] > thresh and smooth[0] >= smooth[1]:\n                peaks += 1\n            if smooth[-1] > thresh and smooth[-1] > smooth[-2]:\n                peaks += 1\n    return float(peaks)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Vertical centroid of the object normalized within its bounding box (values near 1 => centroid lower in bbox)'\n    import numpy as np\n    img = np.asarray(image)\n    if img.size == 0:\n        return 0.0\n    if img.ndim == 3:\n        gray = np.mean(img, axis=2)\n    else:\n        gray = img.astype(float)\n    thr = np.percentile(gray, 50)\n    mask = gray > thr\n    if not np.any(mask):\n        return 0.0\n    ys, xs = np.where(mask)\n    miny, maxy = ys.min(), ys.max()\n    bbox_h = maxy - miny + 1\n    if bbox_h <= 0:\n        return 0.0\n    cy = ys.mean()\n    norm = (cy - miny) / float(bbox_h)\n    return float(norm)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Difference between upper-half fill fraction and lower-half fill fraction (-1..1)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 2 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    mid = h // 2\n    upper = mask[:mid, :]\n    lower = mask[mid:, :]\n    upper_frac = float(np.count_nonzero(upper)) / float(max(1, upper.size))\n    lower_frac = float(np.count_nonzero(lower)) / float(max(1, lower.size))\n    return float(upper_frac - lower_frac)\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Fraction of columns with object contact in the bottom 20% rows (indicates dress/long bottom coverage vs top-only)'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    thr = float(np.percentile(gray, 75))\n    mask = gray >= thr\n    if np.count_nonzero(mask) < 10:\n        thr = float(np.mean(gray))\n        mask = gray > thr\n    bottom_rows = slice(max(0, h - max(1, h // 5)), h)\n    bottom_mask = mask[bottom_rows, :]\n    if bottom_mask.size == 0:\n        return 0.0\n    col_presence = np.any(bottom_mask, axis=0)\n    return float(np.count_nonzero(col_presence)) / float(w)\n",
    "def feature(image: np.ndarray) -> float:\n    'Approximate mask solidity: mask area divided by bounding-box area (0 if no mask)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 50)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    ys, xs = np.where(mask)\n    if ys.size == 0:\n        return 0.0\n    mask_area = float(ys.size)\n    bbox_w = float(xs.max() - xs.min() + 1)\n    bbox_h = float(ys.max() - ys.min() + 1)\n    bbox_area = bbox_w * bbox_h\n    if bbox_area <= 0.0:\n        return 0.0\n    return float(mask_area / (bbox_area + 1e-12))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Center-focused bottom fill: fraction of bottom-20% object pixels that lie within the central 40% of the bbox width'\n    import numpy as np\n    if image is None:\n        return 0.0\n    img = np.mean(image, axis=2) if len(image.shape) == 3 else image.astype(float)\n    thr = max(np.max(img) * 0.05, np.mean(img) * 0.1, 1e-6)\n    mask = img > thr\n    if not mask.any():\n        return 0.0\n    rows_any = np.any(mask, axis=1)\n    cols_any = np.any(mask, axis=0)\n    rmin, rmax = np.where(rows_any)[0][0], np.where(rows_any)[0][-1]\n    cmin, cmax = np.where(cols_any)[0][0], np.where(cols_any)[0][-1]\n    sub = mask[rmin:rmax+1, cmin:cmax+1]\n    h, w = sub.shape\n    bottom_h = max(1, h * 20 // 100)\n    bottom = sub[h-bottom_h:h, :]\n    total_bottom = float(bottom.sum())\n    if total_bottom == 0.0:\n        return 0.0\n    center_left = int(w * 0.3)\n    center_right = int(w * 0.7)\n    center_count = float(bottom[:, center_left:center_right].sum())\n    return float(center_count / total_bottom)\n",
    "def feature(image: np.ndarray) -> float:\n    'Left-right vertical symmetry score (lower is more symmetric): mean absolute difference between halves normalized by mean intensity'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    h, w = gray.shape\n    mid = w // 2\n    left = gray[:, :mid]\n    right = gray[:, w - mid:][:, ::-1]  # mirrored right half\n    # pad smaller half if odd width\n    if left.shape != right.shape:\n        minw = min(left.shape[1], right.shape[1])\n        left = left[:, :minw]\n        right = right[:, :minw]\n    diff = np.abs(left - right)\n    denom = np.mean(gray) if np.mean(gray) > 1e-6 else 1.0\n    score = np.mean(diff) / denom\n    return float(score)\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Left-right symmetry: normalized mean absolute difference between left half and mirrored right half'\n    import numpy as np\n    if image is None:\n        return 1.0\n    h, w = image.shape[:2]\n    if w < 2:\n        return 1.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    mid = w // 2\n    left = gray[:, :mid].astype(float)\n    right = gray[:, w - mid: w].astype(float)  # same width as left\n    if left.size == 0 or right.size == 0:\n        return 1.0\n    right_flipped = np.fliplr(right)\n    diff = np.abs(left - right_flipped)\n    # normalize by intensity range\n    denom = np.mean(np.abs(gray)) + 1e-8\n    score = np.mean(diff) / denom\n    # convert to similarity [0,1] by clamping and inverting\n    sim = 1.0 - min(1.0, score / 2.0)\n    return float(sim)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Mean gradient magnitude inside the object mask normalized by global mean gradient'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 2 or w < 2:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    gy, gx = np.gradient(gray.astype(float))\n    grad_mag = np.sqrt(gx * gx + gy * gy)\n    global_mean = float(np.mean(grad_mag))\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    if np.count_nonzero(mask) == 0:\n        return 0.0\n    inside_mean = float(np.mean(grad_mag[mask]))\n    denom = max(global_mean, 1e-8)\n    return float(inside_mean / denom)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Upper-central vertical gradient prominence: mean absolute vertical gradient in a central strip of upper half'\n    import numpy as np\n    if image is None:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    if h < 3 or w < 3:\n        return 0.0\n    # compute gradients\n    gy, gx = np.gradient(gray.astype(float))\n    top_h = max(1, h // 2)\n    center_w = max(1, w // 5)\n    c0 = max(0, (w // 2) - center_w // 2)\n    strip = gy[0:top_h, c0:c0 + center_w]\n    val = float(np.mean(np.abs(strip)))\n    # normalize by overall mean absolute horizontal gradient in that strip to emphasize vertical features\n    strip_dx = gx[0:top_h, c0:c0 + center_w]\n    denom = float(np.mean(np.abs(strip_dx)))\n    if denom <= 1e-8:\n        return val\n    return float(val / denom)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Mean absolute horizontal gradient magnitude in a small top-center window (collar/neck edge detector)'\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    gm = gray.mean()\n    gs = gray.std() if gray.std() > 0 else 1.0\n    thr = gm - 0.15 * gs\n    mask = gray < thr\n    ys, xs = np.where(mask)\n    # fallback to global top area if no object mask\n    if ys.size == 0:\n        top0 = 0\n        top1 = max(1, h // 6)\n        cx0 = max(0, w // 2 - max(1, w // 10))\n        cx1 = min(w, w // 2 + max(1, w // 10))\n        window = gray[top0:top1, cx0:cx1]\n    else:\n        y0, y1 = int(ys.min()), int(ys.max()) + 1\n        x0, x1 = int(xs.min()), int(xs.max()) + 1\n        top0 = y0\n        top1 = min(h, y0 + max(1, (y1 - y0) // 6))\n        cx0 = max(x0, x0 + (x1 - x0)//2 - max(1, (x1 - x0)//10))\n        cx1 = min(x1, cx0 + max(1, (x1 - x0)//5))\n        window = gray[top0:top1, cx0:cx1]\n    if window.size == 0:\n        return 0.0\n    gy, gx = np.gradient(window.astype(float))\n    mag = np.abs(gx)\n    return float(np.mean(mag))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Mask elongation estimated by PCA eigenvalue ratio (large => elongated vertically/horizontally)'\n    import numpy as np\n    if image is None:\n        return 1.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 1.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 50)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    ys, xs = np.where(mask)\n    if ys.size < 3:\n        return 1.0\n    coords = np.vstack([xs.astype(float), ys.astype(float)])\n    mean = np.mean(coords, axis=1, keepdims=True)\n    coords_c = coords - mean\n    cov = np.cov(coords_c)\n    # eigenvalues\n    try:\n        vals = np.linalg.eigvalsh(cov)\n    except Exception:\n        return 1.0\n    vals = np.sort(vals)\n    small = max(vals[0], 1e-8)\n    ratio = vals[-1] / small\n    return float(ratio)\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Perimeter-to-area ratio of the foreground mask (higher = more complex/skinny)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 1 or w < 1:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    mask_bool = mask.astype(bool)\n    area = float(np.count_nonzero(mask_bool))\n    if area <= 0.0:\n        return 0.0\n    # compute 4-neighbor perimeter approximation\n    pad = np.pad(mask_bool, ((1, 1), (1, 1)), mode='constant', constant_values=False)\n    up = pad[:-2, 1:-1]\n    down = pad[2:, 1:-1]\n    left = pad[1:-1, :-2]\n    right = pad[1:-1, 2:]\n    neighbor_count = up.astype(int) + down.astype(int) + left.astype(int) + right.astype(int)\n    perimeter_pixels = mask_bool & (neighbor_count < 4)\n    perimeter = float(np.count_nonzero(perimeter_pixels))\n    return float(perimeter / area)\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Horizontal symmetry score: normalized mean absolute difference between left and mirrored right half (0 = identical)'\n    import numpy as np\n    if image is None:\n        return 1.0\n    h, w = image.shape[:2]\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    mid = w // 2\n    left = gray[:, :mid]\n    right = gray[:, w - mid:w]\n    if left.size == 0 or right.size == 0:\n        return 1.0\n    # flip right horizontally to compare\n    right_flipped = np.fliplr(right)\n    # pad smaller to match\n    if left.shape != right_flipped.shape:\n        mnw = min(left.shape[1], right_flipped.shape[1])\n        left = left[:, :mnw]\n        right_flipped = right_flipped[:, :mnw]\n    diff = np.abs(left - right_flipped)\n    denom = np.maximum(np.mean(gray) + 1e-8, 1e-8)\n    return float(np.mean(diff) / denom)\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Fraction of foreground pixels that lie in the bottom 25% of the image'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 50)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    total = np.count_nonzero(mask)\n    if total == 0:\n        return 0.0\n    bottom_start = max(0, int(h * 3 // 4))\n    bottom_mask = mask[bottom_start:, :]\n    bottom_count = np.count_nonzero(bottom_mask)\n    return float(bottom_count / float(total))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Upper-sleeve mass score: (left+right upper third mass - center upper third mass) normalized by upper mass'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    top_third = max(1, h // 3)\n    region = gray[:top_third, :]\n    thr = 0.5 * np.mean(region) + 0.5 * np.min(region)\n    bin_reg = region > thr\n    left_box = bin_reg[:, :max(1, w // 4)]\n    right_box = bin_reg[:, -max(1, w // 4):]\n    center_box = bin_reg[:, w // 4:3 * w // 4]\n    left_mass = float(np.count_nonzero(left_box))\n    right_mass = float(np.count_nonzero(right_box))\n    center_mass = float(np.count_nonzero(center_box))\n    total_upper = left_mass + right_mass + center_mass\n    if total_upper == 0:\n        return 0.0\n    score = (left_mass + right_mass - center_mass) / total_upper\n    return float(score)\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Mean of maximum contiguous horizontal segment lengths across rows in the bottom quarter (normalized)'\n    import numpy as np\n    img = np.array(image, copy=False)\n    h, w = img.shape[:2]\n    start_row = (3 * h) // 4\n    t = float(np.mean(img) + 0.1 * np.std(img))\n    bw = (img > t).astype(np.uint8)\n    bottom = bw[start_row:h, :]\n    if bottom.size == 0 or np.count_nonzero(bottom) == 0:\n        return 0.0\n    max_lengths = []\n    for row in bottom:\n        dif = np.diff(np.concatenate(([0], row, [0])))\n        starts = np.where(dif == 1)[0]\n        ends = np.where(dif == -1)[0]\n        if starts.size:\n            max_lengths.append(float(np.max(ends - starts)))\n        else:\n            max_lengths.append(0.0)\n    avg_max = float(np.mean(max_lengths))\n    return float(avg_max / max(1.0, w))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Fraction of connected mask components that are small (<5% of total mask area)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    total_area = int(np.count_nonzero(mask))\n    if total_area == 0:\n        return 0.0\n    visited = np.zeros_like(mask, dtype=bool)\n    comps = 0\n    small = 0\n    thresh = max(1, int(total_area * 0.05))\n    # simple flood fill\n    for y in range(h):\n        for x in range(w):\n            if mask[y, x] and not visited[y, x]:\n                comps += 1\n                stack = [(y, x)]\n                visited[y, x] = True\n                comp_area = 0\n                while stack:\n                    cy, cx = stack.pop()\n                    comp_area += 1\n                    # 4-neighbors\n                    if cy > 0 and mask[cy - 1, cx] and not visited[cy - 1, cx]:\n                        visited[cy - 1, cx] = True\n                        stack.append((cy - 1, cx))\n                    if cy + 1 < h and mask[cy + 1, cx] and not visited[cy + 1, cx]:\n                        visited[cy + 1, cx] = True\n                        stack.append((cy + 1, cx))\n                    if cx > 0 and mask[cy, cx - 1] and not visited[cy, cx - 1]:\n                        visited[cy, cx - 1] = True\n                        stack.append((cy, cx - 1))\n                    if cx + 1 < w and mask[cy, cx + 1] and not visited[cy, cx + 1]:\n                        visited[cy, cx + 1] = True\n                        stack.append((cy, cx + 1))\n                if comp_area <= thresh:\n                    small += 1\n    if comps == 0:\n        return 0.0\n    return float(small) / float(comps)\n",
    "def feature(image: np.ndarray) -> float:\n    'Ratio of object width in the upper quarter to width in the middle third (detects prominent sleeves)'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(np.float32)\n    else:\n        gray = image.astype(np.float32)\n    h, w = gray.shape[:2]\n    thr = np.mean(gray) + 0.25 * (np.max(gray) - np.min(gray))\n    mask = gray > thr\n    if np.count_nonzero(mask) == 0:\n        thr = np.mean(gray)\n        mask = gray > thr\n        if np.count_nonzero(mask) == 0:\n            return 0.0\n    # upper quarter\n    uend = max(1, h // 4)\n    upper = mask[0:uend, :]\n    upper_cols = np.where(np.any(upper, axis=0))[0]\n    upper_width = float(upper_cols.size)\n    # middle third\n    mstart = h // 3\n    mend = min(h, 2 * h // 3)\n    mid = mask[mstart:mend, :]\n    mid_cols = np.where(np.any(mid, axis=0))[0]\n    mid_width = float(mid_cols.size) if mid_cols.size > 0 else 1.0\n    result = float(upper_width / mid_width)\n    return result\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Edge density: fraction of pixels whose gradient magnitude exceeds the median magnitude'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 2 or w < 2:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    gy, gx = np.gradient(gray)\n    mag = np.sqrt(gx * gx + gy * gy)\n    med = np.median(mag)\n    if mag.size == 0:\n        return 0.0\n    count = float(np.count_nonzero(mag > med))\n    return float(count / float(mag.size))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Aspect ratio (width / height) of the foreground bounding box (1.0 if undefined)'\n    import numpy as np\n    if image is None:\n        return 1.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 1.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    ys, xs = np.where(mask)\n    if ys.size == 0:\n        return 1.0\n    miny, maxy = int(np.min(ys)), int(np.max(ys))\n    minx, maxx = int(np.min(xs)), int(np.max(xs))\n    bbox_h = maxy - miny + 1\n    bbox_w = maxx - minx + 1\n    if bbox_h <= 0:\n        return 1.0\n    return float(bbox_w / float(bbox_h))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Mask area divided by its bounding-box area (fill ratio 0..1)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    ys, xs = np.where(mask)\n    if ys.size == 0:\n        return 0.0\n    miny, maxy = ys.min(), ys.max()\n    minx, maxx = xs.min(), xs.max()\n    bbox_area = float((maxy - miny + 1) * (maxx - minx + 1))\n    mask_area = float(ys.size)\n    if bbox_area <= 0:\n        return 0.0\n    return float(np.clip(mask_area / (bbox_area + 1e-8), 0.0, 1.0))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Fraction of pixels that look like corners (both |gx| and |gy| large)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 2 or w < 2:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    gy, gx = np.gradient(gray.astype(float))\n    abs_gx = np.abs(gx)\n    abs_gy = np.abs(gy)\n    thresh_x = np.percentile(abs_gx, 70) if np.any(abs_gx) else 0.0\n    thresh_y = np.percentile(abs_gy, 70) if np.any(abs_gy) else 0.0\n    corners = (abs_gx > thresh_x) & (abs_gy > thresh_y)\n    total = float(h * w)\n    return float(np.count_nonzero(corners) / (total + 1e-8))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Count of separated strong column groups in the bottom quarter (number of leg/shoe blobs)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = gray < thr if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else gray > thr\n    start_row = int(max(0, h - max(1, int(round(h * 0.25)))))\n    region = mask[start_row:, :]\n    col_sums = np.sum(region.astype(int), axis=0).astype(float)\n    if col_sums.size == 0:\n        return 0.0\n    maxv = np.max(col_sums)\n    if maxv <= 0:\n        return 0.0\n    strong = col_sums > (0.25 * maxv)\n    padded = np.concatenate([[0], strong.astype(int), [0]])\n    diffs = np.diff(padded)\n    starts = np.where(diffs == 1)[0]\n    count = max(0, len(starts))\n    # return raw count but clipped to a reasonable range\n    return float(min(count, 5))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Fraction of total mask area contained in a bottom-center box (shoe concentration)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    total = float(np.count_nonzero(mask))\n    if total == 0:\n        return 0.0\n    box_h = max(1, int(0.25 * h))\n    box_w = max(1, int(0.50 * w))\n    y0 = h - box_h\n    x0 = (w - box_w) // 2\n    box = mask[y0:, x0:x0 + box_w]\n    box_count = float(np.count_nonzero(box))\n    return float(box_count / (total + 1e-8))\n",
    "def feature(image: np.ndarray) -> float:\n    'Ratio of boundary (edge) foreground pixels to total foreground area (perimeter-to-area proxy)'\n    import numpy as np\n    h, w = image.shape[:2]\n    gray = np.mean(image, axis=2) if image.ndim == 3 else image.astype(float)\n    # threshold adaptively\n    thr = max(np.percentile(gray, 75), np.mean(gray) * 0.5, 1e-6)\n    fg = gray > thr\n    total_fg = int(fg.sum())\n    if total_fg == 0:\n        return 0.0\n    # boundary: foreground pixel that has any 4-neighbor background or is on image edge\n    padded = np.pad(fg, 1, mode='constant', constant_values=False)\n    boundary = 0\n    for dy, dx in ((1,0),(-1,0),(0,1),(0,-1)):\n        neighbor = padded[1+dy:h+1+dy, 1+dx:w+1+dx]\n        boundary += (fg & (~neighbor))\n    # boundary count: union over the four checks\n    boundary_count = int((boundary > 0).sum())\n    return float(boundary_count / total_fg)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Vertical mirror symmetry score based on grayscale cross-correlation (0..1)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w < 2:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    # use central 90% horizontally to avoid borders\n    margin = max(1, int(w * 0.05))\n    left = gray[:, margin:w//2]\n    right = gray[:, (w - margin - (w//2 - margin)):w - margin] if (w - margin - (w//2 - margin)) < w - margin else gray[:, w//2:w - margin]\n    # make shapes equal\n    min_cols = min(left.shape[1], right.shape[1])\n    if min_cols < 1:\n        return 0.0\n    left = left[:, :min_cols]\n    right = right[:, :min_cols]\n    right_flipped = np.fliplr(right)\n    # normalize and compute correlation\n    L = left.flatten()\n    R = right_flipped.flatten()\n    Lm = L - np.mean(L)\n    Rm = R - np.mean(R)\n    denom = (np.sqrt(np.sum(Lm * Lm)) * np.sqrt(np.sum(Rm * Rm)) + 1e-8)\n    corr = float(np.sum(Lm * Rm) / denom)\n    # map correlation to [0,1]\n    return float((corr + 1.0) / 2.0)\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Number of contiguous column groups in bottom 20% having object pixels (approximate foot/sole groups)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 2 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    bottom_h = max(1, int(0.20 * h))\n    bottom = mask[-bottom_h:, :]\n    cols_active = np.any(bottom, axis=0).astype(int)\n    if cols_active.size == 0:\n        return 0.0\n    # count transitions from 0->1 to get groups\n    transitions = np.diff(np.concatenate(([0], cols_active, [0])))\n    groups = int(np.sum(transitions == 1))\n    return float(groups)\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Fraction of image occupied by a simple foreground mask (threshold by median)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    total = float(h * w)\n    if total == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 50)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    frac = float(np.count_nonzero(mask)) / (total + 1e-8)\n    return float(frac)\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Hemline straightness: standard deviation of the bottom-most object row per column normalized by image height (lower -> straighter hem)'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    thr = np.percentile(gray, 75)\n    mask = gray > thr\n    if np.count_nonzero(mask) == 0:\n        thr = gray.mean()\n        mask = gray > thr\n    if np.count_nonzero(mask) == 0:\n        return 1.0\n    bottom_positions = np.full(w, -1, dtype=int)\n    for c in range(w):\n        rows = np.where(mask[:, c])[0]\n        if rows.size:\n            bottom_positions[c] = rows.max()\n    valid = bottom_positions >= 0\n    if not np.any(valid):\n        return 1.0\n    std_pos = float(np.std(bottom_positions[valid]))\n    return std_pos / max(1.0, h)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Laplacian variance (high => more high-frequency texture)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 2 or w < 2:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    # normalize to [0,1]\n    mx = np.max(gray)\n    if mx > 0:\n        gray = gray / mx\n    # discrete Laplacian via neighbors\n    lap = np.roll(gray, 1, axis=0) + np.roll(gray, -1, axis=0) + np.roll(gray, 1, axis=1) + np.roll(gray, -1, axis=1) - 4.0 * gray\n    var_lap = float(np.var(lap))\n    return float(var_lap)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Texture roughness inside mask: std of gradient magnitude normalized by mean'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 2 or w < 2:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    gy, gx = np.gradient(gray.astype(float))\n    grad = np.sqrt(gx*gx + gy*gy)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    if not np.any(mask):\n        return 0.0\n    vals = grad[mask]\n    meanv = float(np.mean(vals)) + 1e-8\n    stdv = float(np.std(vals))\n    return float(stdv / meanv)\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Slope of the horizontal centroid of mask across rows (how much the object leans), normalized by width'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 3 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 50)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    ys = []\n    cx_rows = []\n    for r in range(h):\n        cols = np.where(mask[r, :])[0]\n        if cols.size > 0:\n            ys.append(float(r))\n            cx_rows.append(float(np.mean(cols)))\n    if len(ys) < 2:\n        return 0.0\n    ys = np.array(ys)\n    cx_rows = np.array(cx_rows)\n    # linear fit slope of cx = a * y + b\n    try:\n        a = np.polyfit(ys, cx_rows, 1)[0]\n    except Exception:\n        return 0.0\n    # normalize by image width to make values comparable\n    return float(abs(a) / (w + 1e-8))\n",
    "def feature(image: np.ndarray) -> float:\n    'Fraction of foreground mask pixels located in the bottom 20% of the image (shoe indicator)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    # grayscale conversion\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    total = np.count_nonzero(mask)\n    if total == 0:\n        return 0.0\n    bottom_start = max(0, h - max(1, h // 5))\n    bottom_count = np.count_nonzero(mask[bottom_start:, :])\n    return float(bottom_count) / float(total)\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Vertical center-line contrast: strength of a vertical darker/brighter line near the object center (indicative of buttons/opening)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    flat = gray.flatten()\n    if flat.size == 0:\n        return 0.0\n    hist, bins = np.histogram(flat, bins=16)\n    bg_bin = np.argmax(hist)\n    bg_val = 0.5 * (bins[bg_bin] + bins[min(bg_bin+1, len(bins)-1)])\n    tol = max(1e-6, 0.12 * (np.max(flat) - np.min(flat)))\n    mask = np.abs(gray - bg_val) > tol\n    if not np.any(mask):\n        return 0.0\n    rows = np.where(np.any(mask, axis=1))[0]\n    cols = np.where(np.any(mask, axis=0))[0]\n    r0, r1 = rows[0], rows[-1] + 1\n    c0, c1 = cols[0], cols[-1] + 1\n    sub = gray[r0:r1, c0:c1]\n    h, w = sub.shape\n    center_col = w // 2\n    strip_w = max(1, w // 10)\n    left = sub[:, max(0, center_col - strip_w):center_col]\n    center = sub[:, center_col:center_col + strip_w]\n    right = sub[:, center_col + strip_w:min(w, center_col + 2*strip_w)]\n    # compute vertical mean differences\n    center_mean = np.mean(center)\n    side_mean = np.mean(np.hstack([left, right])) if (left.size + right.size) > 0 else center_mean\n    # measure how consistently center deviates across rows\n    row_diffs = np.abs(np.mean(center, axis=1) - np.mean(np.hstack([left, right]) if (left.size + right.size) > 0 else center, axis=1))\n    consistency = float(np.mean(row_diffs) / (np.std(sub) + 1e-6))\n    strength = float(np.abs(center_mean - side_mean) / (np.std(sub) + 1e-6) * consistency)\n    return strength\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Fraction of foreground pixels that lie in the bottom 25% of the image'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    total = np.count_nonzero(mask)\n    if total == 0:\n        return 0.0\n    bottom_start = max(0, h - max(1, h // 4))\n    bottom_count = np.count_nonzero(mask[bottom_start:, :])\n    return float(bottom_count / (total + 1e-8))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Normalized vertical centroid of the foreground mask (0=top, 1=bottom)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    # grayscale\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    coords = np.argwhere(mask)\n    if coords.size == 0:\n        return 0.0\n    ys = coords[:, 0].astype(float)\n    centroid_y = np.mean(ys)\n    return float(centroid_y / max(1.0, float(h - 1)))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Mean gradient magnitude in the center region (texture/roughness)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 3 or w < 3:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    ch0 = h // 4\n    ch1 = 3 * h // 4\n    cw0 = w // 4\n    cw1 = 3 * w // 4\n    center = gray[ch0:ch1, cw0:cw1]\n    if center.size == 0:\n        return 0.0\n    gy, gx = np.gradient(center.astype(float))\n    mag = np.sqrt(gx * gx + gy * gy)\n    return float(np.mean(mag))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Top corner mass ratio: (mass in top-left+top-right small squares) / (mass in top-center square)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    h, w = gray.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    maxv = float(np.max(gray))\n    if maxv == 0:\n        return 0.0\n    thresh = maxv * 0.05\n    mask = (gray > thresh).astype(float)\n    box_h = max(1, h // 6)\n    box_w = max(1, w // 6)\n    top_left = mask[:box_h, :box_w].sum()\n    top_right = mask[:box_h, w - box_w:].sum()\n    center_start = max(0, (w // 2) - box_w // 2)\n    top_center = mask[:box_h, center_start:center_start + box_w].sum()\n    eps = 1e-8\n    return float((top_left + top_right + eps) / (top_center + eps))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Top-bottom symmetry of the foreground mask (1.0 = perfectly symmetric)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 50)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    area = np.count_nonzero(mask)\n    if area == 0:\n        return 0.0\n    flipped = np.flipud(mask)\n    overlap = np.count_nonzero(mask & flipped)\n    denom = float(area + np.count_nonzero(flipped)) / 2.0 + 1e-8\n    return float(overlap / denom)\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Average number of foreground runs per column (indicates multiple vertical components)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    runs = []\n    for c in range(w):\n        col = mask[:, c].astype(int)\n        if col.size == 0:\n            runs.append(0)\n            continue\n        pad = np.concatenate(([0], col, [0]))\n        diff = np.diff(pad)\n        starts = np.where(diff == 1)[0]\n        ends = np.where(diff == -1)[0]\n        runs.append(max(0, starts.size))\n    if len(runs) == 0:\n        return 0.0\n    return float(np.mean(runs))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Skewness of per-row mask widths (positive means long tail to the right in width distribution)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h <= 1 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    widths = np.sum(mask.astype(float), axis=1)\n    if widths.size == 0:\n        return 0.0\n    mean_w = float(np.mean(widths))\n    std_w = float(np.std(widths))\n    if std_w < 1e-8:\n        return 0.0\n    skew = float(np.mean(((widths - mean_w) / std_w) ** 3))\n    return float(skew)\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Side concentration: fraction of mask area contained in the denser half (left or right)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    mid = w // 2\n    left = np.count_nonzero(mask[:, :mid])\n    right = np.count_nonzero(mask[:, mid:])\n    total = left + right\n    if total == 0:\n        return 0.0\n    return float(max(left, right) / float(total))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Aspect ratio (width/height) of the foreground bounding box'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = gray < thr if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else gray > thr\n    ys, xs = np.nonzero(mask)\n    if ys.size == 0:\n        return 0.0\n    miny, maxy = int(np.min(ys)), int(np.max(ys))\n    minx, maxx = int(np.min(xs)), int(np.max(xs))\n    bbox_h = max(1, maxy - miny + 1)\n    bbox_w = max(1, maxx - minx + 1)\n    return float(bbox_w / float(bbox_h))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Fraction of image pixels belonging to the main object mask (area fraction)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    # grayscale conversion\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    area = float(np.count_nonzero(mask))\n    return float(area / (h * w + 1e-8))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Average contiguous object width in the left and right upper-mid bands (sleeve thickness / prominence)'\n    if image is None:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    maxv = gray.max()\n    if maxv <= 0 or h < 3 or w < 3:\n        return 0.0\n    thresh = maxv * 0.10\n    mask = gray > thresh\n    top = max(0, h // 6)\n    mid = max(1, h // 2)\n    rows = range(top, mid)\n    side_w = max(1, w // 4)\n    left_area = mask[top:mid, 0:side_w]\n    right_area = mask[top:mid, max(0, w-side_w):w]\n    def avg_largest_segment(area):\n        if area.size == 0:\n            return 0.0\n        widths = []\n        for r in range(area.shape[0]):\n            row = area[r, :]\n            if not row.any():\n                widths.append(0)\n                continue\n            # find contiguous True segments and take the largest\n            diffs = np.diff(np.concatenate(([0], row.astype(int), [0])))\n            starts = np.where(diffs == 1)[0]\n            ends = np.where(diffs == -1)[0]\n            seg_widths = (ends - starts).tolist() if starts.size else [0]\n            widths.append(max(seg_widths) if seg_widths else 0)\n        return float(np.mean(widths) / max(1.0, area.shape[1]))\n    left_w = avg_largest_segment(left_area)\n    right_w = avg_largest_segment(right_area)\n    return float(0.5 * (left_w + right_w))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Depth of central valley in bottom third: 1.0 means strong center gap relative to side peaks, 0.0 means no valley'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    thr = np.mean(gray) + 0.15 * (np.max(gray) - np.min(gray))\n    mask = gray > thr\n    if np.count_nonzero(mask) == 0:\n        thr = np.percentile(gray, 50)\n        mask = gray > thr\n        if np.count_nonzero(mask) == 0:\n            return 0.0\n    top = max(0, (2*h)//3)\n    bottom_third = mask[top:h, :]\n    col_sums = bottom_third.sum(axis=0).astype(float)\n    if col_sums.sum() == 0:\n        return 0.0\n    center_idx = w // 2\n    center_val = float(col_sums[center_idx])\n    # mean of two highest side peaks (exclude center to avoid bias)\n    if w > 3:\n        side_vals = np.copy(col_sums)\n        side_vals[max(0, center_idx-1):min(w, center_idx+2)] = 0\n        top_peaks = np.sort(side_vals)[-2:] if w >= 3 else np.sort(col_sums)[-2:]\n    else:\n        top_peaks = np.sort(col_sums)[-2:]\n    peaks_mean = float(np.mean(top_peaks)) if top_peaks.size > 0 else float(col_sums.max())\n    if peaks_mean <= 0:\n        return 0.0\n    depth = 1.0 - (center_val / peaks_mean)\n    depth = float(np.clip(depth, 0.0, 1.0))\n    return depth\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Average absolute slope of outer object edges between top quarter and mid-height (sleeve edge angle proxy)'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    mx = float(np.max(gray))\n    if mx <= 0:\n        return 0.0\n    mask = gray > (mx * 0.05)\n    if not np.any(mask):\n        return 0.0\n    ys, xs = np.where(mask)\n    top, left, bottom, right = ys.min(), xs.min(), ys.max(), xs.max()\n    bh = bottom - top + 1\n    bw = right - left + 1\n    # band from top quarter to mid-height\n    y0 = top + max(0, int(0.10 * bh))\n    y1 = top + max(1, int(0.45 * bh))\n    band = mask[y0:y1+1, left:right+1]\n    if band.size == 0:\n        return 0.0\n    rows = band.shape[0]\n    # compute leftmost and rightmost object column per row\n    left_edges = []\n    right_edges = []\n    for r in range(rows):\n        row = band[r]\n        cols = np.where(row)[0]\n        if cols.size > 0:\n            left_edges.append(float(cols.min()))\n            right_edges.append(float(cols.max()))\n    if len(left_edges) < 2 or len(right_edges) < 2:\n        return 0.0\n    # slope = change in column index over number of rows (normalize by bbox height)\n    left_slope = (left_edges[-1] - left_edges[0]) / (rows + 1e-9)\n    right_slope = (right_edges[-1] - right_edges[0]) / (rows + 1e-9)\n    avg_slope = (abs(left_slope) + abs(right_slope)) / 2.0\n    # normalize by bbox width to make scale-invariant\n    norm = float(avg_slope / max(1.0, bw))\n    return norm\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Fraction of image rows that contain object pixels (estimated object height proportion)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 50)\n    mask = gray < thr if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else gray > thr\n    if mask.size == 0:\n        return 0.0\n    row_has = np.any(mask, axis=1)\n    frac = float(np.count_nonzero(row_has)) / float(h)\n    return float(frac)\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Sleeve extent ratio: (left+right upper object pixels) / central upper object pixels (higher when sleeves are prominent)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    thr = np.mean(gray) + 0.25 * (np.max(gray) - np.mean(gray))\n    upper_h = max(1, h // 3)\n    # left, center, right regions in upper band\n    lw = max(1, w // 4)\n    cw = max(1, w // 4)\n    rw = max(1, w - lw - cw)\n    left = gray[0:upper_h, 0:lw] > thr\n    center = gray[0:upper_h, lw:lw + cw] > thr\n    right = gray[0:upper_h, lw + cw:lw + cw + rw] > thr\n    left_count = np.count_nonzero(left)\n    right_count = np.count_nonzero(right)\n    center_count = np.count_nonzero(center)\n    denom = center_count if center_count > 0 else 1.0\n    ratio = (left_count + right_count) / float(denom)\n    return float(ratio)\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Minimum row mask width divided by maximum row mask width (small values = narrow waist / leg separation)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 50)\n    mask = ((gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)).astype(np.uint8)\n    row_widths = np.count_nonzero(mask, axis=1).astype(float)\n    if row_widths.size == 0:\n        return 0.0\n    max_w = float(np.max(row_widths))\n    min_w = float(np.min(row_widths))\n    if max_w <= 1e-8:\n        return 0.0\n    return float(min_w / (max_w + 1e-8))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Concentration of vertical projection peaks (rows): largest of top-3 peaks divided by their sum (higher = one dominant band)'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    thr = np.mean(gray)\n    mask = gray > thr\n    if np.count_nonzero(mask) < max(1, h * w * 0.01):\n        mask = gray < thr\n    vproj = np.sum(mask, axis=1).astype(float)\n    if np.all(vproj == 0):\n        return 0.0\n    # find top 3 peak values\n    top3 = np.sort(vproj)[-3:]\n    s = float(np.sum(top3))\n    if s <= 0.0:\n        return 0.0\n    return float(top3[-1] / s)\n",
    "def feature(image: np.ndarray) -> float:\n    'Bottom edge irregularity: standard deviation of left/right edge x-positions over the bottom 15% rows normalized by image width'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    rng = gray.max() - gray.min()\n    thr = np.mean(gray) + (0.12 * rng if rng > 0 else 0.0)\n    mask = gray > thr\n    rows = max(1, h * 15 // 100)\n    lefts = []\n    rights = []\n    for r in range(h - rows, h):\n        row = mask[r, :]\n        if row.any():\n            cols = np.where(row)[0]\n            lefts.append(float(cols[0]))\n            rights.append(float(cols[-1]))\n    if not lefts:\n        return 0.0\n    std_left = float(np.std(lefts))\n    std_right = float(np.std(rights))\n    return float((std_left + std_right) / (2.0 * max(1.0, w)))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Average horizontal transition density per row (edges per row normalized by width)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w < 2:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    # transitions per row\n    row_trans = np.count_nonzero(mask[:, :-1] != mask[:, 1:], axis=1).astype(float)\n    avg = np.mean(row_trans) if row_trans.size > 0 else 0.0\n    return float(avg / float(w))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Standard deviation of per-row mask-centroid x positions normalized by image width'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 2 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 50)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    xs = np.arange(w).reshape(1, w)\n    centroids = []\n    for r in range(h):\n        row = mask[r, :]\n        cnt = np.count_nonzero(row)\n        if cnt == 0:\n            continue\n        cx = float(np.sum(row * xs) / float(cnt))\n        centroids.append(cx)\n    if len(centroids) == 0:\n        return 0.0\n    return float(np.std(np.array(centroids)) / max(1.0, float(w)))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Relative bottom-center concentration: density in bottom-center patch / overall bottom density'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 2 or w < 2:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 50)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    bottom_h = max(1, int(h * 0.2))\n    bottom = mask[h - bottom_h:, :]\n    if not np.any(bottom):\n        return 0.0\n    center_w = max(1, int(w * 0.3))\n    cx0 = max(0, (w // 2) - (center_w // 2))\n    cx1 = min(w, cx0 + center_w)\n    center_patch = bottom[:, cx0:cx1]\n    center_count = float(np.count_nonzero(center_patch))\n    bottom_count = float(np.count_nonzero(bottom))\n    if bottom_count <= 0:\n        return 0.0\n    return float((center_count / (center_patch.size + 1e-8)) / (bottom_count / (bottom.size + 1e-8)))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Upper-vs-lower width difference: (width at upper third - width at lower third) normalized by image width'\n    try:\n        if len(image.shape) == 3:\n            gray = np.mean(image.astype(float), axis=2)\n        else:\n            gray = image.astype(float)\n    except Exception:\n        return 0.0\n    h, w = gray.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    thr = (np.mean(gray) + np.min(gray)) / 2.0\n    mask = (gray > thr)\n    upper = mask[:max(1, h // 3), :]\n    lower = mask[max(0, h - max(1, h // 3)):, :]\n    def span_width(region):\n        if not np.any(region):\n            return 0\n        cols = np.where(np.any(region, axis=0))[0]\n        return int(cols[-1] - cols[0] + 1)\n    uw = span_width(upper)\n    lw = span_width(lower)\n    diff = (uw - lw) / float(w)\n    # clamp to [-1,1]\n    diff = max(-1.0, min(1.0, diff))\n    return float(diff)\n",
    "def feature(image: np.ndarray) -> float:\n    'Approximate perimeter-to-area ratio of the object (higher for strap-like objects)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    try:\n        thresh = float(np.percentile(gray, 50))\n    except Exception:\n        thresh = float(np.mean(gray))\n    mask = (gray > thresh).astype(np.uint8)\n    if not np.any(mask):\n        return 0.0\n    # approximate boundary by gradient of mask\n    gy, gx = np.gradient(mask.astype(float))\n    boundary = (np.abs(gy) + np.abs(gx)) > 0.0\n    perimeter = float(np.count_nonzero(boundary))\n    area = float(np.count_nonzero(mask))\n    if area <= 0:\n        return 0.0\n    return perimeter / area\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Horizontal separation between two main column peaks (captures pair separation for two shoes) normalized by bbox width'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    m, s = np.mean(gray), np.std(gray)\n    mask = gray > (m + 0.5 * s)\n    if not np.any(mask):\n        return 0.0\n    rows, cols = np.where(mask)\n    rmin, rmax = rows.min(), rows.max()\n    cmin, cmax = cols.min(), cols.max()\n    region = mask[rmin:rmax + 1, cmin:cmax + 1]\n    col_sums = np.sum(region, axis=0).astype(float)\n    if col_sums.size == 0 or col_sums.max() == 0:\n        return 0.0\n    idx1 = int(np.argmax(col_sums))\n    col_sums2 = col_sums.copy()\n    left = max(0, idx1 - 3)\n    right = min(col_sums2.size - 1, idx1 + 3)\n    col_sums2[left:right + 1] = 0\n    idx2 = int(np.argmax(col_sums2))\n    if col_sums[idx2] == 0:\n        return 0.0\n    separation = abs(idx2 - idx1) / float(max(1, region.shape[1]))\n    return float(separation)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Normalized neck-gap depth: distance from top of bbox to first central foreground pixel (higher when there is a deep collar notch)'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    thr = np.mean(gray) + 0.1 * (np.max(gray) - np.min(gray))\n    fg = gray > thr\n    coords = np.argwhere(fg)\n    if coords.size == 0:\n        return 0.0\n    r0, c0 = coords.min(axis=0)\n    r1, c1 = coords.max(axis=0) + 1\n    box = fg[r0:r1, c0:c1]\n    bh, bw = box.shape\n    center_col = bw // 2\n    # find first foreground row at center column (search outward a small horizontal window if exact center empty)\n    gap_row = None\n    for rr in range(bh):\n        window = box[rr, max(0, center_col - 1):min(bw, center_col + 2)]\n        if np.any(window):\n            gap_row = rr\n            break\n    if gap_row is None:\n        return float(bh)  # no center pixel found -> maximum gap\n    return float(gap_row / max(1.0, bh - 1.0))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Normalized vertical centroid of the detected object mask (0=top,1=bottom)'\n    import numpy as np\n    if image is None:\n        return 0.5\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.5\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    total = float(np.count_nonzero(mask))\n    if total == 0:\n        return 0.5\n    ys = np.arange(h).astype(float)[:, None]\n    cy = float(np.sum(ys * mask) / (total + 1e-8))\n    return float(np.clip(cy / float(h), 0.0, 1.0))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Vertical centroid of foreground mask normalized to [0..1] (0=top,1=bottom)'\n    import numpy as np\n    if image is None:\n        return 0.5\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.5\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    ys, xs = np.where(mask)\n    if ys.size == 0:\n        return 0.5\n    centroid_y = float(np.mean(ys))\n    result = centroid_y / float(h - 1 + 1e-8)\n    return float(result)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Mean color saturation for RGB images (0..1), 0 for grayscale'\n    import numpy as np\n    if image is None:\n        return 0.0\n    if len(image.shape) != 3 or image.shape[2] < 3:\n        return 0.0\n    img = image.astype(float)\n    r, g, b = img[:, :, 0], img[:, :, 1], img[:, :, 2]\n    mx = np.maximum(np.maximum(r, g), b)\n    mn = np.minimum(np.minimum(r, g), b)\n    sat = (mx - mn) / (mx + 1e-8)\n    # clip to [0,1]\n    sat = np.clip(sat, 0.0, 1.0)\n    return float(np.mean(sat))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Mean number of foreground segments per column (runs of pixels) in the mask'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    # pad a false row at top so 0->1 transitions count segments\n    total_segments = 0\n    if w == 0:\n        return 0.0\n    for c in range(w):\n        col = mask[:, c].astype(bool)\n        if col.size == 0:\n            continue\n        padded = np.concatenate(([False], col))\n        transitions = np.count_nonzero((~padded[:-1]) & padded[1:])\n        total_segments += int(transitions)\n    return float(total_segments / float(w))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Perimeter-to-area compactness of the object mask (perimeter^2 / area), higher means more complex boundary'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    mx = float(np.max(gray))\n    if mx <= 0:\n        return 0.0\n    mask = (gray > (mx * 0.1)).astype(float)\n    area = float(np.sum(mask))\n    if area <= 0:\n        return 0.0\n    gy, gx = np.gradient(mask)\n    edge = np.hypot(gx, gy)\n    perimeter = float(np.sum(edge > 0.1))\n    # compactness normalized\n    compact = (perimeter * perimeter) / area\n    return float(compact)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Number of prominent vertical peaks in the mask vertical profile (rows) (integer-like)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 3 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    row_widths = np.sum(mask, axis=1).astype(float)\n    if row_widths.size < 3:\n        return 0.0\n    mean_w = float(np.mean(row_widths))\n    peaks = 0\n    # count local maxima that are reasonably above baseline\n    for i in range(1, row_widths.size - 1):\n        if row_widths[i] > row_widths[i - 1] and row_widths[i] > row_widths[i + 1] and row_widths[i] > 0.5 * mean_w:\n            peaks += 1\n    return float(peaks)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Ratio of average object width at mid-height (45-55%) to width near bottom (80-95%)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 4 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    # mid band\n    mid_start = max(0, h * 45 // 100)\n    mid_end = min(h, h * 55 // 100)\n    bottom_start = max(0, h * 80 // 100)\n    bottom_end = min(h, h * 95 // 100)\n    mid_rows = mask[mid_start:mid_end, :]\n    bottom_rows = mask[bottom_start:bottom_end, :]\n    if mid_rows.size == 0 or bottom_rows.size == 0:\n        return 0.0\n    mid_widths = np.sum(mid_rows.astype(float), axis=1)\n    bottom_widths = np.sum(bottom_rows.astype(float), axis=1)\n    mid_avg = float(np.mean(mid_widths)) if mid_widths.size > 0 else 0.0\n    bot_avg = float(np.mean(bottom_widths)) if bottom_widths.size > 0 else 0.0\n    if bot_avg <= 0:\n        return 0.0\n    return float((mid_avg + 1e-8) / (bot_avg + 1e-8))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Normalized vertical centroid of foreground mask (0=top, 1=bottom)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h <= 1 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    ys, xs = np.where(mask)\n    if ys.size == 0:\n        return 0.0\n    centroid_y = float(np.mean(ys))\n    return float(centroid_y / float(h - 1))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Ratio of gradient magnitude in center region to border region (center_energy / border_energy)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 2 or w < 2:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    gy, gx = np.gradient(gray.astype(float))\n    grad = np.sqrt(gx * gx + gy * gy)\n    ch0, ch1 = h // 4, w // 4\n    center = grad[ch0: h - ch0, ch1: w - ch1]\n    # border ring = full - center (use masks)\n    total = np.sum(grad) + 1e-8\n    center_sum = np.sum(center)\n    border_sum = total - center_sum\n    if border_sum <= 1e-8:\n        return float(center_sum / total)\n    result = center_sum / (border_sum + 1e-8)\n    return float(result)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Normalized radial spread: ratio (std(distance)/mean(distance)) of mask pixels from centroid'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    ys, xs = np.where(mask)\n    if xs.size == 0:\n        return 0.0\n    cx = float(np.mean(xs))\n    cy = float(np.mean(ys))\n    d = np.sqrt((xs - cx) ** 2 + (ys - cy) ** 2)\n    mean_d = float(np.mean(d))\n    std_d = float(np.std(d))\n    if mean_d <= 1e-8:\n        return 0.0\n    return float(std_d / (mean_d + 1e-8))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Median contiguous mask segment length per row normalized by image width'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 60)\n    mask = gray < thr if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else gray > thr\n    seg_lengths = []\n    for r in range(h):\n        row = mask[r]\n        idx = np.where(row)[0]\n        if idx.size == 0:\n            continue\n        splits = np.where(np.diff(idx) > 1)[0]\n        if splits.size == 0:\n            seg_lengths.append(float(idx.size))\n        else:\n            starts = np.concatenate(([idx[0]], idx[splits + 1]))\n            ends = np.concatenate((idx[splits], [idx[-1]]))\n            seg_lengths.extend((ends - starts + 1).astype(float).tolist())\n    if len(seg_lengths) == 0:\n        return 0.0\n    med = float(np.median(np.array(seg_lengths)))\n    return float(med / max(1.0, float(w)))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Aspect ratio of the object bounding box (height / width)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 50)\n    mask = gray < thr if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else gray > thr\n    ys, xs = np.where(mask)\n    if ys.size == 0:\n        return 0.0\n    y0, y1 = ys.min(), ys.max()\n    x0, x1 = xs.min(), xs.max()\n    bbox_h = float(y1 - y0 + 1)\n    bbox_w = float(x1 - x0 + 1)\n    if bbox_w <= 0:\n        return 0.0\n    return float(bbox_h / (bbox_w + 1e-8))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Standard deviation of horizontal span (width) across rows in the bottom half (higher -> more flare/irregular bottom)'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    h, w = gray.shape\n    thr = np.mean(gray) + 0.15 * np.std(gray)\n    mask = gray > thr\n    if np.count_nonzero(mask) == 0:\n        thr2 = np.max(gray) * 0.1\n        mask = gray > thr2\n        if np.count_nonzero(mask) == 0:\n            return 0.0\n    bottom = mask[max(0, h // 2):, :]\n    widths = []\n    for row in bottom:\n        cols = np.where(row)[0]\n        if cols.size == 0:\n            widths.append(0.0)\n        else:\n            widths.append(float(cols[-1] - cols[0] + 1))\n    if len(widths) == 0:\n        return 0.0\n    return float(np.std(widths) / float(w))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Proportion of image area covered by the foreground mask'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 50)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    area = float(np.count_nonzero(mask))\n    return float(area / (float(h * w) + 1e-8))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Fraction of image columns that have object pixels touching the bottom 10% of rows (indicates long garments)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    h, w = gray.shape[:2]\n    maxv = float(np.max(gray)) if np.size(gray) else 0.0\n    if maxv <= 0:\n        return 0.0\n    thresh = maxv * 0.10\n    mask = gray > thresh\n    bottom_rows = max(1, int(np.ceil(h * 0.10)))\n    bottom_region = mask[-bottom_rows:, :]\n    cols_with_contact = np.sum(np.any(bottom_region, axis=0))\n    return float(cols_with_contact / float(w))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Fill factor: fraction of bounding box area occupied by mask (0..1)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    ys, xs = np.where(mask)\n    if ys.size == 0:\n        return 0.0\n    miny, maxy = int(np.min(ys)), int(np.max(ys))\n    minx, maxx = int(np.min(xs)), int(np.max(xs))\n    bbox_area = float((maxy - miny + 1) * (maxx - minx + 1))\n    mask_area = float(np.count_nonzero(mask))\n    return float(mask_area / (bbox_area + 1e-8))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Object compactness: object area divided by bounding-box area (higher => more filled/compact)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    thr = np.mean(gray) + 0.15 * (np.max(gray) - np.mean(gray))\n    mask = gray > thr\n    cnt = int(np.count_nonzero(mask))\n    if cnt == 0:\n        return 0.0\n    rows = np.any(mask, axis=1)\n    cols = np.any(mask, axis=0)\n    if not np.any(rows) or not np.any(cols):\n        return 0.0\n    rmin, rmax = int(np.where(rows)[0][0]), int(np.where(rows)[0][-1])\n    cmin, cmax = int(np.where(cols)[0][0]), int(np.where(cols)[0][-1])\n    bbox_area = float((rmax - rmin + 1) * (cmax - cmin + 1))\n    if bbox_area <= 0:\n        return 0.0\n    return float(cnt / bbox_area)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Maximum width of a vertical background run within a top-center strip (detect neck hole width), normalized by bbox width'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    if h < 4 or w < 4:\n        return 0.0\n    # mask\n    border = np.concatenate([gray[0, :], gray[-1, :], gray[:, 0], gray[:, -1]])\n    bg = float(np.median(border)); mean_int = float(np.mean(gray))\n    thresh = (bg + mean_int) / 2.0\n    mask = gray > thresh if mean_int >= bg else gray < thresh\n    rows, cols = np.where(mask)\n    if rows.size == 0:\n        return 0.0\n    rmin, rmax = rows.min(), rows.max()\n    cmin, cmax = cols.min(), cols.max()\n    top_h = max(1, (rmax - rmin + 1) // 5)\n    c0 = max(cmin, (cmin + cmax)//2 - max(1, (cmax-cmin)//6))\n    c1 = min(cmax+1, (cmin + cmax)//2 + max(1, (cmax-cmin)//6))\n    max_zero_run = 0\n    for c in range(c0, c1):\n        # look for longest vertical run of background (zeros) starting near rmin within top_h\n        col = mask[rmin:rmin+top_h, c]\n        if col.size == 0:\n            continue\n        # zero-run lengths in this column\n        zeros = (~col).astype(int)\n        if zeros.sum() == 0:\n            continue\n        # compute longest consecutive ones in zeros\n        dif = np.diff(np.concatenate(([0], zeros, [0])))\n        starts = np.where(dif == 1)[0]\n        ends = np.where(dif == -1)[0]\n        runs = (ends - starts)\n        if runs.size:\n            max_zero_run = max(max_zero_run, runs.max())\n    bbox_w = max(1, cmax - cmin + 1)\n    return float(max_zero_run / bbox_w)\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Fraction of image pixels belonging to foreground mask'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    total = float(max(1, h * w))\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 50)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    area = float(np.count_nonzero(mask))\n    return float(area / total)\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Pocket-like uniform patch score in the lower third: 1.0 = presence of a very low-variance patch relative to global variance'\n    import numpy as np\n    gray = np.mean(image, axis=2) if len(image.shape) == 3 else image.astype(float)\n    h, w = gray.shape[:2]\n    if h < 8 or w < 8:\n        return 0.0\n    lower0 = max(0, h - h // 3)\n    region = gray[lower0:h, :]\n    global_var = float(np.var(region))\n    if global_var <= 1e-8:\n        return 0.0\n    win = 8\n    min_var = float('inf')\n    for r in range(0, max(1, region.shape[0] - win + 1), max(1, win // 2)):\n        for c in range(0, max(1, region.shape[1] - win + 1), max(1, win // 2)):\n            patch = region[r : r + win, c : c + win]\n            if patch.size == 0:\n                continue\n            v = float(np.var(patch))\n            if v < min_var:\n                min_var = v\n    if min_var == float('inf'):\n        return 0.0\n    # score higher when min_var is much smaller than global_var\n    score = 1.0 - float(np.clip(min_var / (global_var + 1e-8), 0.0, 1.0))\n    return float(score)\n",
    "def feature(image: np.ndarray) -> float:\n    'Average number of foreground segments per row (rows with multiple separated segments indicate straps/gaps typical of sandals)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    thresh = float(np.mean(gray))\n    bin_img = (gray > thresh).astype(np.uint8)\n    segments_per_row = []\n    for r in range(h):\n        row = bin_img[r, :]\n        # pad with zeros to detect starts\n        padded = np.concatenate(([0], row, [0]))\n        diff = np.diff(padded)\n        starts = np.sum(diff == 1)\n        segments_per_row.append(starts)\n    result = np.mean(segments_per_row) if len(segments_per_row) > 0 else 0.0\n    return float(result)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Top shoulder/arm indicator: (left_top_density + right_top_density) / (2 * center_top_density + eps)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 4 or w < 4:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    r0 = int(max(0, 0.10 * h))\n    r1 = int(min(h, 0.30 * h))\n    if r1 <= r0:\n        return 0.0\n    top_band = mask[r0:r1, :]\n    lw = max(1, int(0.40 * w))\n    left_box = top_band[:, :lw]\n    right_box = top_band[:, w - lw:]\n    c0 = int(0.30 * w)\n    c1 = int(0.70 * w)\n    center_box = top_band[:, c0:c1] if c1 > c0 else top_band[:, :]\n    left_density = float(np.count_nonzero(left_box)) / (left_box.size + 1e-8)\n    right_density = float(np.count_nonzero(right_box)) / (right_box.size + 1e-8)\n    center_density = float(np.count_nonzero(center_box)) / (center_box.size + 1e-8)\n    return float((left_density + right_density) / (2.0 * center_density + 1e-8))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Hem straightness: average std deviation of left and right edge columns in the bottom region (lower = straighter hem)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    bg_h, bg_w = max(1, h // 10), max(1, w // 10)\n    bg = np.mean(gray[:bg_h, :bg_w])\n    gm = np.mean(gray)\n    thresh = (bg + gm) / 2.0\n    object_is_darker = gm < bg\n    if object_is_darker:\n        mask = gray < thresh\n    else:\n        mask = gray > thresh\n    r0 = max(0, h - max(1, h // 6))\n    rows = []\n    lefts = []\n    rights = []\n    for r in range(r0, h):\n        cols = np.where(mask[r, :])[0]\n        if cols.size > 0:\n            lefts.append(cols[0])\n            rights.append(cols[-1])\n            rows.append(r)\n    if len(lefts) < 2:\n        return 0.0\n    lefts = np.array(lefts, dtype=float)\n    rights = np.array(rights, dtype=float)\n    std_mean = float((np.std(lefts) + np.std(rights)) / 2.0)\n    return float(std_mean / max(1.0, w))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Vertical spread concentration: standard deviation of foreground row indices normalized by bounding-box height (lower means vertically concentrated)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape\n    if h == 0 or w == 0:\n        return 0.0\n    thr = float(np.percentile(gray, 65))\n    mask = gray > thr\n    if not mask.any():\n        return 0.0\n    ys, xs = np.nonzero(mask)\n    if ys.size == 0:\n        return 0.0\n    rows_any = np.any(mask, axis=1)\n    rmin = int(np.argmax(rows_any))\n    rmax = h - int(np.argmax(rows_any[::-1])) - 1\n    bbox_h = float(max(1.0, rmax - rmin + 1))\n    std_rows = float(np.std(ys))\n    return float(std_rows / bbox_h)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Solidity surrogate: foreground area divided by bounding-box area (0..1)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    ys, xs = np.where(mask)\n    if ys.size == 0:\n        return 0.0\n    miny, maxy = int(np.min(ys)), int(np.max(ys))\n    minx, maxx = int(np.min(xs)), int(np.max(xs))\n    bbox_area = float((maxy - miny + 1) * (maxx - minx + 1))\n    if bbox_area <= 0:\n        return 0.0\n    area = float(ys.size)\n    return float(min(1.0, area / (bbox_area + 1e-12)))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Horizontal centroid offset of the object inside bbox (absolute normalized offset from center)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(np.float32)\n    else:\n        gray = image.astype(np.float32)\n    mn, mx = float(np.min(gray)), float(np.max(gray))\n    if mx > mn:\n        gray = (gray - mn) / (mx - mn)\n    else:\n        gray = gray * 0.0\n    fg = gray > 0.2\n    ys, xs = np.where(fg)\n    if ys.size == 0:\n        return 0.0\n    rmin, rmax = int(ys.min()), int(ys.max())\n    cmin, cmax = int(xs.min()), int(xs.max())\n    bbox_w = float(cmax - cmin + 1)\n    if bbox_w <= 0.0:\n        return 0.0\n    centroid_x = float(np.mean(xs))\n    center_x = float((cmin + cmax) / 2.0)\n    offset = float(abs(centroid_x - center_x) / bbox_w)\n    return offset\n",
    "def feature(image: np.ndarray) -> float:\n    'Approximate entropy (Shannon) of intensities in the central torso box (captures textured details like pockets/buttons)'\n    import numpy as np\n    h, w = image.shape[:2]\n    gray = np.mean(image, axis=2) if image.ndim == 3 else image.astype(float)\n    rng = gray.max() - gray.min() if gray.size else 0.0\n    th = float(np.mean(gray) + 0.10 * float(rng))\n    mask = gray > th\n    if mask.sum() < max(5, int(0.01 * h * w)):\n        mask = gray < (np.mean(gray) - 0.10 * float(rng))\n    ys, xs = np.where(mask)\n    if xs.size == 0:\n        return 0.0\n    ymin, ymax = ys.min(), ys.max()\n    xmin, xmax = xs.min(), xs.max()\n    # central torso region: middle 50% vertically and horizontally\n    yr0 = ymin + (ymax - ymin) // 4\n    yr1 = ymin + 3 * (ymax - ymin) // 4\n    xr0 = xmin + (xmax - xmin) // 4\n    xr1 = xmin + 3 * (xmax - xmin) // 4\n    torso = gray[yr0:yr1+1, xr0:xr1+1].flatten()\n    if torso.size == 0:\n        return 0.0\n    # histogram into 16 bins\n    hist, _ = np.histogram(torso, bins=16, range=(float(gray.min()), float(gray.max())), density=False)\n    probs = hist.astype(float) / (hist.sum() + 1e-9)\n    probs = probs[probs > 0]\n    entropy = -float(np.sum(probs * np.log(probs + 1e-12)))\n    # normalize by log(num_bins)\n    norm = np.log(16.0)\n    return float(entropy / (norm + 1e-12))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Normalized vertical centroid of the foreground mask (0=top, 1=bottom)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    ys, xs = np.where(mask)\n    if ys.size == 0:\n        return 0.0\n    centroid_y = float(np.mean(ys))\n    return float(centroid_y / float(max(1, h - 1)))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Mean per-pixel color saturation (RGB only), 0.0 for grayscale'\n    import numpy as np\n    if image is None:\n        return 0.0\n    if len(image.shape) != 3 or image.shape[2] < 3:\n        return 0.0\n    img = image.astype(float)\n    mx = np.max(img, axis=2)\n    mn = np.min(img, axis=2)\n    # avoid division by zero; saturation relative to local max\n    denom = mx + 1e-8\n    sat = (mx - mn) / denom\n    return float(np.mean(sat))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Concentration of gradient orientations (resultant length of gradient angles, 0..1)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 2 or w < 2:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    gy, gx = np.gradient(gray.astype(float))\n    mag = np.sqrt(gx * gx + gy * gy)\n    weights = mag\n    if np.sum(weights) < 1e-8:\n        return 0.0\n    angles_cos = np.cos(np.arctan2(gy, gx))\n    angles_sin = np.sin(np.arctan2(gy, gx))\n    mc = float(np.sum(angles_cos * weights) / (np.sum(weights) + 1e-8))\n    ms = float(np.sum(angles_sin * weights) / (np.sum(weights) + 1e-8))\n    R = np.sqrt(mc * mc + ms * ms)\n    return float(R)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Ratio of foreground width near 1/3 height to width near 2/3 height (upper / lower)'\n    import numpy as np\n    if image is None:\n        return 1.0\n    h, w = image.shape[:2]\n    if h < 3 or w == 0:\n        return 1.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    def mean_width_at_row_band(row_center):\n        band = 1 + max(0, int(round(h * 0.03)))\n        r0 = max(0, row_center - band)\n        r1 = min(h, row_center + band + 1)\n        sub = mask[r0:r1, :]\n        widths = []\n        for r in range(sub.shape[0]):\n            row = sub[r, :]\n            if not np.any(row):\n                continue\n            xs = np.where(row)[0]\n            widths.append(float(xs[-1] - xs[0] + 1))\n        if len(widths) == 0:\n            return 0.0\n        return float(np.mean(widths))\n    up_row = max(0, int(h * 1 / 3))\n    down_row = min(h - 1, int(h * 2 / 3))\n    w_up = mean_width_at_row_band(up_row)\n    w_down = mean_width_at_row_band(down_row)\n    if w_down <= 1e-8:\n        return float(w_up / (1e-8 + 1.0))\n    return float(w_up / (w_down + 1e-8))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Column-wise centroid spread: std of vertical centroids across columns normalized by image height'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h <= 1 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    centroids = []\n    rows = np.arange(h).astype(float)\n    for c in range(w):\n        col = mask[:, c].astype(float)\n        s = col.sum()\n        if s <= 0:\n            continue\n        cent = float((rows * col).sum() / (s + 1e-12))\n        centroids.append(cent)\n    if len(centroids) == 0:\n        return 0.0\n    std_cent = float(np.std(np.array(centroids)))\n    return float(std_cent / float(h))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Average number of foreground segments per row in the bottom half of the object bbox (higher if split hems or legs)'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    minv, maxv = float(np.min(gray)), float(np.max(gray))\n    if maxv <= minv + 1e-9:\n        return 0.0\n    thr = np.mean(gray) + 0.12 * (maxv - np.mean(gray))\n    mask = gray > thr\n    if np.count_nonzero(mask) == 0:\n        return 0.0\n    rows, cols = np.where(mask)\n    y0, y1 = int(rows.min()), int(rows.max())\n    x0, x1 = int(cols.min()), int(cols.max())\n    bh = max(1, y1 - y0 + 1)\n    bottom_start = y0 + bh // 2\n    bottom = mask[bottom_start:y1+1, x0:x1+1]\n    seg_counts = []\n    for r in range(bottom.shape[0]):\n        row = bottom[r, :]\n        if not np.any(row):\n            continue\n        # transitions from 0 to 1 indicate new segment\n        transitions = np.diff(np.concatenate(([0], row.astype(int), [0])))\n        segs = int(np.sum(transitions == 1))\n        seg_counts.append(segs)\n    if len(seg_counts) == 0:\n        return 0.0\n    return float(np.mean(seg_counts))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Normalized mean horizontal extent of object pixels from center at shoulder level (upper-middle rows)'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    flat = gray.flatten()\n    if flat.size == 0:\n        return 0.0\n    thr = np.percentile(flat, 60)\n    if np.std(flat) < 1e-6:\n        thr = np.max(flat) * 0.5\n    mask = gray > thr\n    # shoulder band: rows from 15% to 40% of height\n    r1 = max(0, int(h * 15 // 100))\n    r2 = min(h, max(r1 + 1, int(h * 40 // 100)))\n    band = mask[r1:r2, :]\n    if band.size == 0:\n        return 0.0\n    xs = np.where(band)\n    if xs[1].size == 0:\n        return 0.0\n    center_x = w / 2.0\n    # distance of each foreground pixel horizontally from center\n    dists = np.abs(xs[1].astype(float) - center_x)\n    mean_dist = np.mean(dists)\n    # normalize by half-width\n    return float(mean_dist / max(1.0, center_x))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Estimated heel height: normalized vertical distance from bottom to highest pixel in the back region (left/right 20%)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    thr = np.mean(gray)\n    mask = gray > thr\n    if np.count_nonzero(mask) == 0:\n        thr = np.percentile(gray, 75)\n        mask = gray > thr\n    if np.count_nonzero(mask) == 0:\n        return 0.0\n    # define back regions on both sides and take the higher (closer to top) structure\n    side_width = max(1, w // 5)\n    left_region = mask[:, :side_width]\n    right_region = mask[:, -side_width:]\n    def highest_foreground(region, col_offset):\n        rows, cols = np.where(region)\n        if rows.size == 0:\n            return h  # no foreground -> treat as bottom\n        # actual row indices\n        return np.min(rows)\n    left_top = highest_foreground(left_region, 0)\n    right_top = highest_foreground(right_region, w - side_width)\n    top_in_back = min(left_top, right_top)\n    # heel height normalized (0 = at bottom, 1 = at top)\n    heel_height_norm = (h - 1 - top_in_back) / max(1.0, h - 1)\n    return float(heel_height_norm)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Vertical centroid of the foreground mask normalized to image height (0=top,1=bottom)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    ys, xs = np.where(mask)\n    if ys.size == 0:\n        return 0.0\n    y_cent = float(np.mean(ys)) / float(h)\n    return float(max(0.0, min(1.0, y_cent)))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Median number of separate object segments per column (useful for detecting multi-part shapes)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = gray < thr if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else gray > thr\n    if not np.any(mask):\n        return 0.0\n    # pad top and bottom to detect segment starts\n    pad = np.vstack([np.zeros((1, w), dtype=bool), mask, np.zeros((1, w), dtype=bool)])\n    diff = np.diff(pad.astype(int), axis=0)\n    starts = diff == 1\n    seg_counts = np.sum(starts, axis=0)\n    return float(np.median(seg_counts))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Asymmetry between left and right halves of the lower half of the bounding box (captures single-heel or angled shoes)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    if gray.size == 0:\n        return 0.0\n    rng = float(np.max(gray) - np.min(gray))\n    if rng <= 0:\n        mask = gray > 0\n    else:\n        thresh = float(np.mean(gray) + 0.25 * rng)\n        mask = gray > thresh\n        if np.count_nonzero(mask) == 0:\n            mask = gray > np.mean(gray)\n    rows, cols = np.where(mask)\n    if rows.size == 0:\n        return 0.0\n    top, bottom = int(rows.min()), int(rows.max())\n    left, right = int(cols.min()), int(cols.max())\n    mid_row = top + (bottom - top) // 2\n    # extract lower half region\n    region = mask[mid_row:bottom+1, left:right+1]\n    if region.size == 0:\n        return 0.0\n    mid_col_index = (right - left) // 2\n    left_count = int(np.count_nonzero(region[:, :mid_col_index+1]))\n    right_count = int(np.count_nonzero(region[:, mid_col_index+1:]))\n    total = left_count + right_count\n    return float(abs(left_count - right_count)) / float(max(1, total))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Normalized variance of the vertical column-sum profile of the object (captures evenness vs peaked straps)'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    p30, p70 = np.percentile(gray, [30, 70])\n    bin_high = gray > p70\n    bin_low = gray < p30\n    fg = bin_high if bin_high.sum() < bin_low.sum() and bin_high.sum() > 0 else (bin_low if bin_low.sum() > 0 else (gray > gray.mean()))\n    coords = np.argwhere(fg)\n    if coords.size == 0:\n        return 0.0\n    r0, c0 = coords.min(axis=0)\n    r1, c1 = coords.max(axis=0) + 1\n    sub = fg[r0:r1, c0:c1].astype(float)\n    col_sums = sub.sum(axis=0)\n    if col_sums.size == 0:\n        return 0.0\n    var = np.var(col_sums)\n    mean = np.mean(col_sums)\n    return float(var / (mean + 1e-9))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Proportion of pixels that are local gradient maxima (corner-like) in 3x3 neighborhood'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 3 or w < 3:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    gy, gx = np.gradient(gray)\n    mag = np.hypot(gx, gy)\n    thr = np.percentile(mag.flatten(), 90)\n    # compare center > all neighbors\n    center = mag[1:-1, 1:-1]\n    neighs = [\n        mag[0:-2, 0:-2], mag[0:-2, 1:-1], mag[0:-2, 2:],\n        mag[1:-1, 0:-2],                 mag[1:-1, 2:],\n        mag[2:, 0:-2],   mag[2:, 1:-1],  mag[2:, 2:]\n    ]\n    greater = np.ones_like(center, dtype=bool)\n    for n in neighs:\n        greater &= (center > n)\n    strong = greater & (center > thr)\n    return float(np.count_nonzero(strong)) / float(h * w)\n",
    "def feature(image: np.ndarray) -> float:\n    'Left-right extremity asymmetry between top and bottom quarters: average absolute normalized difference of left/right edges'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    thresh = float(np.percentile(gray, 50))\n    mask = gray > thresh\n    if mask.sum() == 0:\n        mask = gray > (gray.max() * 0.05) if gray.max() != 0 else (gray != gray)\n    def left_right_at_row_range(r0, r1):\n        lefts = []\n        rights = []\n        for r in range(r0, min(h, r1)):\n            cols = np.where(mask[r, :])[0]\n            if cols.size == 0:\n                continue\n            lefts.append(cols[0])\n            rights.append(cols[-1])\n        if len(lefts) == 0:\n            return None\n        return (np.mean(lefts), np.mean(rights))\n    top_range = left_right_at_row_range(0, max(1, h // 4))\n    bot_range = left_right_at_row_range(max(0, 3 * h // 4), h)\n    if top_range is None or bot_range is None:\n        return 0.0\n    top_left, top_right = top_range\n    bot_left, bot_right = bot_range\n    left_asym = abs(top_left - bot_left) / float(max(1, w))\n    right_asym = abs(top_right - bot_right) / float(max(1, w))\n    return float(0.5 * (left_asym + right_asym))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Average gradient magnitude inside the foreground mask normalized by overall mean gradient'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 2 or w < 2:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    gy, gx = np.gradient(gray.astype(float))\n    grad_mag = np.sqrt(gx * gx + gy * gy)\n    global_mean = float(np.mean(grad_mag)) + 1e-8\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    if not np.any(mask):\n        return 0.0\n    mean_inside = float(np.mean(grad_mag[mask]))\n    return float(mean_inside / global_mean)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Ratio of average mask width at top 10% to middle 40-60% (top_width / mid_width)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 4 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    top_h = max(1, h * 10 // 100)\n    top_rows = mask[:top_h, :]\n    mid_start = max(0, h * 40 // 100)\n    mid_end = min(h, h * 60 // 100)\n    mid_rows = mask[mid_start:mid_end, :]\n    if top_rows.size == 0 or mid_rows.size == 0:\n        return 0.0\n    top_widths = np.sum(top_rows.astype(float), axis=1)\n    mid_widths = np.sum(mid_rows.astype(float), axis=1)\n    top_avg = float(np.mean(top_widths)) if top_widths.size > 0 else 0.0\n    mid_avg = float(np.mean(mid_widths)) if mid_widths.size > 0 else 0.0\n    if mid_avg <= 0:\n        return 0.0\n    return float((top_avg + 1e-8) / (mid_avg + 1e-8))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Fraction of image occupied by the foreground mask (approximate object area)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 50)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    area = float(np.count_nonzero(mask))\n    return float(area / (h * w + 1e-8))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Shoulder-to-midbody width ratio: mean object width near top (10%) divided by mean width near 40% (helps detect broad shoulders)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    h, w = gray.shape[:2]\n    thr = np.mean(gray) + 0.5 * np.std(gray)\n    mask = (gray > thr)\n    def mean_width(row_start, row_end):\n        widths = []\n        for r in range(max(0, row_start), min(h, row_end)):\n            cols = np.where(mask[r, :])[0]\n            if cols.size:\n                widths.append(float(cols[-1] - cols[0] + 1))\n        return float(np.mean(widths)) if widths else 0.0\n    band = max(1, h // 40)\n    shoulder_w = mean_width(h//10 - band, h//10 + band)\n    mid_w = mean_width(h*40//100 - band, h*40//100 + band)\n    if mid_w <= 0:\n        return 0.0\n    return float(shoulder_w / mid_w)\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Relative \"sleeve drop\": average bottom y of side columns minus center bottom y, normalized by image height (positive if sides extend lower)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    mx = np.max(gray)\n    if mx <= 0:\n        return 0.0\n    mask = gray > (mx * 0.05)\n    if np.count_nonzero(mask) == 0:\n        return 0.0\n    bottoms = -np.ones(w, dtype=int)\n    for c in range(w):\n        col = mask[:, c]\n        nz = np.nonzero(col)[0]\n        if nz.size:\n            bottoms[c] = nz[-1]\n    left_cols = list(range(0, max(1, w // 4)))\n    right_cols = list(range(max(0, w - w // 4), w))\n    center_cols = list(range(max(0, w // 2 - max(1, w // 10)), min(w, w // 2 + max(1, w // 10))))\n    def avg_valid(arr):\n        vals = [bottoms[i] for i in arr if bottoms[i] >= 0]\n        return float(np.mean(vals)) if len(vals) > 0 else -1.0\n    left_avg = avg_valid(left_cols)\n    right_avg = avg_valid(right_cols)\n    center_avg = avg_valid(center_cols)\n    if center_avg < 0:\n        return 0.0\n    side_avg = (left_avg if left_avg >= 0 else center_avg) if right_avg < 0 and left_avg >= 0 else \\\n               (right_avg if left_avg < 0 and right_avg >= 0 else ( (left_avg + right_avg) / 2.0 ))\n    if side_avg is None:\n        return 0.0\n    result = (side_avg - center_avg) / float(h)\n    return float(result)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Entropy of edge orientation distribution (weighted by magnitude), normalized to [0,1]'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 2 or w < 2:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    gy, gx = np.gradient(gray)\n    mag = np.sqrt(gx * gx + gy * gy)\n    if np.sum(mag) == 0:\n        return 0.0\n    angles = np.arctan2(gy, gx)  # -pi..pi\n    # map to 8 bins\n    nbins = 8\n    bins = np.linspace(-np.pi, np.pi, nbins + 1)\n    hist = np.zeros(nbins, dtype=float)\n    flat_angles = angles.flatten()\n    flat_mag = mag.flatten()\n    inds = np.digitize(flat_angles, bins) - 1\n    inds = np.clip(inds, 0, nbins - 1)\n    for i in range(nbins):\n        hist[i] = np.sum(flat_mag[inds == i])\n    hist_sum = np.sum(hist)\n    if hist_sum <= 0:\n        return 0.0\n    p = hist / hist_sum\n    # entropy\n    eps = 1e-12\n    ent = -np.sum(np.where(p > 0, p * np.log(p + eps), 0.0))\n    # normalize by log(nbins)\n    ent_norm = ent / (np.log(nbins) + 1e-12)\n    return float(ent_norm)\n",
    "def feature(image: np.ndarray) -> float:\n    'Vertical symmetry score (1.0 = perfectly symmetric)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    # grayscale conversion\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    mx = np.max(gray) if np.max(gray) > 0 else 1.0\n    gray = gray / mx\n    # simple foreground mask\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    ys, xs = np.where(mask)\n    if ys.size == 0:\n        return 0.0\n    miny, maxy = ys.min(), ys.max()\n    minx, maxx = xs.min(), xs.max()\n    crop = gray[miny:maxy+1, minx:maxx+1]\n    cw = crop.shape[1]\n    if cw <= 1:\n        return 0.0\n    # split crop into left and right halves and compare\n    mid = cw // 2\n    left = crop[:, :mid]\n    right = crop[:, -mid:] if mid > 0 else crop[:, :mid]\n    # flip right horizontally\n    right_flipped = np.fliplr(right)\n    # make sizes equal\n    minw = min(left.shape[1], right_flipped.shape[1])\n    if minw == 0:\n        return 0.0\n    left = left[:, :minw]\n    right_flipped = right_flipped[:, :minw]\n    diff = np.abs(left - right_flipped)\n    mean_diff = float(np.mean(diff))\n    sym = 1.0 - mean_diff\n    # clamp to [0,1]\n    if sym < 0.0:\n        sym = 0.0\n    if sym > 1.0:\n        sym = 1.0\n    return float(sym)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Mean absolute horizontal gradient magnitude in the central columns of the bottom half (sensitive to strong vertical gaps between legs).'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    if h < 4 or w < 2:\n        return 0.0\n    # compute gradients\n    gy, gx = np.gradient(gray)\n    bottom_gx = gx[h//2:, :]\n    # central columns region\n    c0, c1 = max(0, w//3), min(w, (2*w)//3)\n    region = bottom_gx[:, c0:c1]\n    if region.size == 0:\n        return 0.0\n    return float(np.mean(np.abs(region)))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Mean local 3x3 standard deviation inside the detected foreground mask normalized by global std'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 3 or w < 3:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    global_std = float(np.std(gray)) + 1e-8\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    if not np.any(mask):\n        return 0.0\n    # pad and compute 3x3 neighborhood sum and sumsq via shifted sums\n    p = np.pad(gray, ((1, 1), (1, 1)), mode='reflect')\n    s = (p[:-2, :-2] + p[:-2, 1:-1] + p[:-2, 2:] +\n         p[1:-1, :-2] + p[1:-1, 1:-1] + p[1:-1, 2:] +\n         p[2:, :-2] + p[2:, 1:-1] + p[2:, 2:])\n    sq = p * p\n    sqs = (sq[:-2, :-2] + sq[:-2, 1:-1] + sq[:-2, 2:] +\n           sq[1:-1, :-2] + sq[1:-1, 1:-1] + sq[1:-1, 2:] +\n           sq[2:, :-2] + sq[2:, 1:-1] + sq[2:, 2:])\n    mean3 = s / 9.0\n    var3 = (sqs / 9.0) - (mean3 * mean3)\n    var3 = np.maximum(var3, 0.0)\n    std3 = np.sqrt(var3)\n    # average std inside mask\n    mean_inside = float(np.sum(std3 * mask) / (np.count_nonzero(mask) + 1e-12))\n    return float(mean_inside / global_std)\n",
    "def feature(image: np.ndarray) -> float:\n    'Relative width of a background gap centered at the top region (neckline/handle gap)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 3 or w < 3:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    top_band = max(1, h // 8)\n    band = mask[:top_band, :]\n    # look at the middle row of the band (or last if small)\n    row = band[min(top_band - 1, top_band // 2), :]\n    bg = ~row\n    # compute contiguous background run length around center\n    center = w // 2\n    left = 0\n    for i in range(center, -1, -1):\n        if not bg[i]:\n            left = center - i\n            break\n    else:\n        left = center + 1\n    right = 0\n    for i in range(center, w):\n        if not bg[i]:\n            right = i - center\n            break\n    else:\n        right = w - center\n    gap = left + right\n    return float(gap) / float(w)\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Fraction of pixels that are \"warm\" (R dominant) in an RGB image'\n    import numpy as np\n    if image is None:\n        return 0.0\n    if len(image.shape) != 3 or image.shape[2] < 3:\n        return 0.0\n    img = image.astype(float)\n    R = img[:, :, 0]\n    G = img[:, :, 1]\n    B = img[:, :, 2]\n    # require R to be strictly greater than both and above a moderate intensity\n    thresh = np.percentile(R, 40)\n    warm = (R > G) & (R > B) & (R > thresh)\n    total = float(R.size)\n    if total == 0:\n        return 0.0\n    return float(np.count_nonzero(warm) / (total + 1e-8))\n",
    "def feature(image: np.ndarray) -> float:\n    'Fraction of object pixels that lie in the bottom quarter of the image (0..1)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    thr = (np.mean(gray) + np.min(gray)) * 0.5\n    mask = gray > thr\n    total = float(np.count_nonzero(mask))\n    if total == 0:\n        return 0.0\n    bottom_band = mask[int(3*h/4):h, :]\n    bottom_count = float(np.count_nonzero(bottom_band))\n    return bottom_count / total\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Horizontal symmetry: 1.0 means perfect left-right mirror, 0.0 means very asymmetric'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w < 2:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    # threshold to focus on object shape\n    thr = np.percentile(gray, 50)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    mid = w // 2\n    left = gray[:, :mid]\n    right = gray[:, w - mid:]\n    right_flipped = np.fliplr(right)\n    if left.shape != right_flipped.shape:\n        # pad smaller\n        mh = min(left.shape[1], right_flipped.shape[1])\n        left = left[:, :mh]\n        right_flipped = right_flipped[:, :mh]\n    diff = np.mean(np.abs(left - right_flipped)) if left.size else 0.0\n    norm = (np.mean(np.abs(gray)) + 1e-8)\n    score = 1.0 - float(diff / norm)\n    return float(max(0.0, min(1.0, score)))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Left-right sleeve asymmetry: mean absolute difference between left extent and right extent across middle rows (normalized)'\n    import numpy as np\n    try:\n        if len(image.shape) == 3:\n            gray = np.mean(image, axis=2).astype(float)\n        else:\n            gray = image.astype(float)\n    except Exception:\n        return 0.0\n    import numpy as np\n    h, w = gray.shape[:2]\n    if h < 4 or w < 4:\n        return 0.0\n    thr = np.percentile(gray, 50)\n    mask = gray > thr\n    # consider middle half of rows\n    r0, r1 = h // 4, h - h // 4\n    band = mask[r0:r1, :]\n    if band.size == 0:\n        return 0.0\n    left_extents = []\n    right_extents = []\n    for row in band:\n        cols = np.nonzero(row)[0]\n        if cols.size:\n            left_extents.append(float(cols[0]))\n            right_extents.append(float(cols[-1]))\n    if not left_extents:\n        return 0.0\n    # distances from edges\n    left_d = np.array(left_extents)\n    right_d = np.array([w - 1 - x for x in right_extents])\n    diff = np.abs(left_d - right_d)\n    # normalized by width\n    score = float(diff.mean() / max(1.0, w - 1))\n    return float(np.clip(score, 0.0, 1.0))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Peak brightness of small top-left/top-right corner patches relative to top-center (collar points detector)'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    if h < 4 or w < 4:\n        return 0.0\n    patch_h = max(1, h // 10)\n    patch_w = max(1, w // 8)\n    tl = gray[0:patch_h, 0:patch_w]\n    tr = gray[0:patch_h, w-patch_w:w]\n    tc = gray[0:patch_h, w//2 - patch_w//2 : w//2 + patch_w//2 + 1]\n    # use max minus center mean to highlight pointy collars\n    tl_peak = float(np.max(tl)) if tl.size else 0.0\n    tr_peak = float(np.max(tr)) if tr.size else 0.0\n    tc_mean = float(np.mean(tc)) if tc.size else 1.0\n    denom = max(1.0, float(np.ptp(gray)))\n    score = ((tl_peak + tr_peak) / 2.0 - tc_mean) / denom\n    return float(score)\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Symmetry of mass between left and right halves in the bottom 30% rows (low=>imbalanced, high=>two separated shoes)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    eps = 1e-8\n    thresh = max(np.mean(gray) * 0.5, np.max(gray) * 0.05, eps)\n    mask = (gray > thresh).astype(float)\n    start = int(h * 0.7)\n    bottom = mask[start:h, :]\n    left = bottom[:, :w // 2].sum()\n    right = bottom[:, w // 2:].sum()\n    total = left + right + eps\n    # return balance score between 0 and 1 where 1 means perfectly balanced\n    return float(1.0 - (abs(left - right) / total))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Vertical mirror-symmetry score (1.0 = perfectly symmetric, 0.0 = totally asymmetric) within object bounding box'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape\n    if h == 0 or w == 0:\n        return 0.0\n    mx = float(np.max(gray))\n    thr = float(np.mean(gray)) + 0.08 * (mx - float(np.mean(gray)))\n    mask = gray > thr\n    if np.count_nonzero(mask) == 0:\n        mask = gray > float(np.mean(gray))\n    nz = np.where(mask)\n    if nz[0].size == 0:\n        return 0.0\n    r0, r1 = int(nz[0].min()), int(nz[0].max())\n    c0, c1 = int(nz[1].min()), int(nz[1].max())\n    sub = gray[r0:r1+1, c0:c1+1]\n    ch, cw = sub.shape\n    if cw < 2:\n        return 0.0\n    mid = cw // 2\n    left = sub[:, :mid]\n    if cw % 2 == 0:\n        right = sub[:, mid:]\n    else:\n        right = sub[:, mid+1:]\n    # flip right horizontally to compare to left (make sizes equal)\n    if left.shape[1] == right.shape[1]:\n        right_flipped = np.fliplr(right)\n    else:\n        # crop the wider one\n        minw = min(left.shape[1], right.shape[1])\n        left = left[:, :minw]\n        right_flipped = np.fliplr(right[:, :minw])\n    denom = np.sum(np.abs(left)) + np.sum(np.abs(right_flipped)) + 1e-8\n    diff = np.sum(np.abs(left - right_flipped))\n    score = 1.0 - (diff / denom)\n    # clamp\n    return float(max(0.0, min(1.0, score)))\n",
    "def feature(image: np.ndarray) -> float:\n    'Mean absolute orientation angle (0..1) of mask boundary normals (0 = horizontal, 1 = vertical)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 2 or w < 2:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = ((gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)).astype(np.uint8)\n    if np.count_nonzero(mask) == 0:\n        return 0.0\n    gy, gx = np.gradient(gray.astype(float))\n    # boundary mask (4-neighbor)\n    padded = np.pad(mask, ((1, 1), (1, 1)), mode='constant', constant_values=0)\n    center = padded[1:-1, 1:-1]\n    up = padded[0:-2, 1:-1]\n    down = padded[2:, 1:-1]\n    left = padded[1:-1, 0:-2]\n    right = padded[1:-1, 2:]\n    boundary = (center & (~up | ~down | ~left | ~right))\n    if not np.any(boundary):\n        return 0.0\n    bx = gx[boundary]\n    by = gy[boundary]\n    # orientation angle relative to horizontal: atan2(|by|, |bx|) in [0, pi/2]\n    ang = np.arctan2(np.abs(by) + 1e-12, np.abs(bx) + 1e-12)\n    # normalize to 0..1 where 0 => horizontal (0 deg), 1 => vertical (90 deg)\n    norm = ang / (np.pi / 2.0)\n    return float(np.mean(norm))\n",
    "def feature(image: np.ndarray) -> float:\n    'Normalized left-right symmetry score: 1 - (L1 diff / total), higher = more symmetric'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    thr = float(np.percentile(gray, 50))\n    mask = gray > thr\n    if not np.any(mask):\n        return 0.0\n    rows = np.any(mask, axis=1)\n    cols = np.any(mask, axis=0)\n    rmin, rmax = int(np.argmax(rows)), len(rows) - int(np.argmax(rows[::-1])) - 1\n    cmin, cmax = int(np.argmax(cols)), len(cols) - int(np.argmax(cols[::-1])) - 1\n    bbox = gray[rmin:rmax+1, cmin:cmax+1]\n    if bbox.size == 0:\n        return 0.0\n    # mirror right half onto left half (centered)\n    h, w = bbox.shape\n    mid = w // 2\n    left = bbox[:, :mid]\n    right = np.fliplr(bbox[:, w - left.shape[1]:]) if left.shape[1] > 0 else np.zeros_like(left)\n    denom = np.sum(np.abs(left)) + np.sum(np.abs(right)) + 1e-9\n    diff = np.sum(np.abs(left - right))\n    score = 1.0 - diff / denom\n    return float(score)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Fraction of rows whose longest object segment is at least 60% of the maximum row-wise segment (indicates wide continuous shapes)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = gray < thr if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else gray > thr\n    max_per_row = []\n    for r in range(h):\n        row = mask[r, :].astype(int)\n        if np.any(row):\n            pad = np.concatenate(([0], row, [0]))\n            diff = np.diff(pad)\n            starts = np.where(diff == 1)[0]\n            ends = np.where(diff == -1)[0]\n            seg_lengths = ends - starts\n            if seg_lengths.size > 0:\n                max_per_row.append(np.max(seg_lengths))\n            else:\n                max_per_row.append(0)\n        else:\n            max_per_row.append(0)\n    if len(max_per_row) == 0:\n        return 0.0\n    max_all = max(max_per_row)\n    if max_all <= 0:\n        return 0.0\n    thresh = 0.6 * max_all\n    count = sum(1 for x in max_per_row if x >= thresh)\n    return float(count) / float(h)\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Asymmetry of widths measured from center to left and right in the middle third: normalized absolute difference (0 symmetric)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    gray = np.mean(image, axis=2) if len(image.shape) == 3 else image.astype(float)\n    h, w = gray.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    thr = float(np.percentile(gray, 80))\n    mask = gray > thr\n    midr0, midr1 = h//3, 2*h//3\n    left_dists = []\n    right_dists = []\n    center_col = w // 2\n    for r in range(midr0, midr1):\n        row = mask[r, :]\n        if not row.any():\n            continue\n        cols = np.where(row)[0]\n        leftmost, rightmost = cols[0], cols[-1]\n        left_dists.append(float(center_col - leftmost))\n        right_dists.append(float(rightmost - center_col))\n    if len(left_dists) == 0 or len(right_dists) == 0:\n        return 0.0\n    left_mean = float(np.mean(left_dists))\n    right_mean = float(np.mean(right_dists))\n    denom = max(1.0, left_mean + right_mean)\n    return float(abs(left_mean - right_mean) / denom)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Normalized foreground area fraction (mask area / image area)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    area = float(h) * float(w)\n    if area <= 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    fg = float(np.count_nonzero(mask))\n    return float(fg / area)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Ratio of top quarter average mask width to middle quarter average mask width (sleeve/shoulder indicator)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 4 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = gray < thr if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else gray > thr\n    top_end = max(1, h // 4)\n    mid_start = max(0, h // 2 - h // 8)\n    mid_end = min(h, mid_start + max(1, h // 4))\n    top_rows = mask[:top_end, :]\n    mid_rows = mask[mid_start:mid_end, :]\n    def avg_width(region):\n        if region.size == 0:\n            return 0.0\n        widths = np.count_nonzero(region, axis=1).astype(float)\n        if widths.size == 0:\n            return 0.0\n        return float(np.mean(widths)) / float(w)\n    top_w = avg_width(top_rows)\n    mid_w = avg_width(mid_rows)\n    if mid_w <= 1e-8:\n        return float(top_w / (mid_w + 1e-8))\n    return float(top_w / mid_w)\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Mean gradient magnitude in the lower quarter of the image normalized by global mean gradient'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 2 or w < 2:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    gy, gx = np.gradient(gray.astype(float))\n    grad = np.sqrt(gx * gx + gy * gy)\n    lower_start = (3 * h) // 4\n    lower = grad[lower_start:h, :]\n    mean_lower = float(np.mean(lower)) if lower.size > 0 else 0.0\n    mean_global = float(np.mean(grad)) + 1e-8\n    return float(mean_lower / mean_global)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Maximum vertical continuous mask run in any column normalized by image height'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    if not np.any(mask):\n        return 0.0\n    max_run = 0\n    # vectorized-ish per column: compute diffs to detect runs\n    for col in range(w):\n        col_vec = mask[:, col].astype(int)\n        if not np.any(col_vec):\n            continue\n        diffs = np.diff(np.concatenate(([0], col_vec, [0])))\n        starts = np.where(diffs == 1)[0]\n        ends = np.where(diffs == -1)[0]\n        if starts.size and ends.size:\n            runs = ends - starts\n            max_run = max(max_run, int(np.max(runs)))\n    return float(max_run / float(h))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Edge density normalized by sqrt(area): mean gradient magnitude inside bbox divided by sqrt(object area)'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    mean, std = float(np.mean(gray)), float(np.std(gray))\n    thresh = mean + 0.25 * std\n    mask_bool = gray > thresh\n    if not mask_bool.any():\n        return 0.0\n    ys, xs = np.where(mask_bool)\n    top, bottom = ys.min(), ys.max()\n    left, right = xs.min(), xs.max()\n    bbox = gray[top:bottom+1, left:right+1].astype(float)\n    gy, gx = np.gradient(bbox)\n    gmag = np.sqrt(gx**2 + gy**2)\n    # consider only gradient inside the mask region (mapped to bbox coords)\n    mask_bbox = mask_bool[top:bottom+1, left:right+1]\n    if not mask_bbox.any():\n        return 0.0\n    mean_g = float(np.mean(gmag[mask_bbox]))\n    area = float(np.count_nonzero(mask_bbox))\n    return float(mean_g / (np.sqrt(area) + 1e-6))\n",
    "def feature(image: np.ndarray) -> float:\n    'Maximum left-right mirrored overlap after shifting up to 10% width (robust symmetry score)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    import numpy as np\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    if not np.any(mask):\n        return 0.0\n    mid = w // 2\n    left = mask[:, :mid]\n    right_base = mask[:, mid:][:, ::-1] if w % 2 == 0 else mask[:, mid+1:][:, ::-1]\n    max_shift = max(1, int(0.10 * w))\n    best = 0.0\n    # try shifting right side left/right against left side to allow small misalignments\n    for shift in range(-max_shift, max_shift + 1):\n        if shift < 0:\n            # shift right side right (padding on left)\n            pad = np.pad(right_base, ((0, 0), (0, -shift)), mode='constant', constant_values=False)\n            right = pad[:, -left.shape[1]:]\n        elif shift > 0:\n            pad = np.pad(right_base, ((0, 0), (shift, 0)), mode='constant', constant_values=False)\n            right = pad[:, :left.shape[1]]\n        else:\n            # no shift\n            right = right_base[:, :left.shape[1]]\n        # align widths\n        min_c = min(left.shape[1], right.shape[1])\n        if min_c <= 0:\n            continue\n        L = left[:, :min_c]\n        R = right[:, :min_c]\n        overlap = float(np.count_nonzero(L & R))\n        union = float(np.count_nonzero(L | R)) + 1e-8\n        score = overlap / union\n        if score > best:\n            best = score\n    return float(best)\n",
    "def feature(image: np.ndarray) -> float:\n    'Entropy of gradient orientation histogram (8 bins), normalized to [0,1]'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 2 or w < 2:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    gy, gx = np.gradient(gray.astype(float))\n    angles = np.arctan2(gy, gx)  # -pi..pi\n    bins = 8\n    hist, _ = np.histogram(angles.flatten(), bins=bins, range=(-np.pi, np.pi))\n    hist = hist.astype(float)\n    total = np.sum(hist)\n    if total <= 0:\n        return 0.0\n    p = hist / total\n    eps = 1e-12\n    entropy = -np.sum(p * np.log(p + eps))\n    # normalize by max entropy log(bins)\n    norm = entropy / (np.log(bins) + 1e-12)\n    return float(norm)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Left-right asymmetry of intensity within the object bounding box (normalized L1 difference)'\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.mean(gray) + 0.25 * (np.max(gray) - np.mean(gray))\n    mask = gray > thr\n    if np.count_nonzero(mask) == 0:\n        thr = np.mean(gray)\n        mask = gray > thr\n    if np.count_nonzero(mask) == 0:\n        return 0.0\n    rows, cols = np.where(mask)\n    r0, r1 = rows.min(), rows.max()\n    c0, c1 = cols.min(), cols.max()\n    sub = gray[r0:r1+1, c0:c1+1]\n    sub_mask = mask[r0:r1+1, c0:c1+1]\n    bh, bw = sub.shape\n    if bw < 2:\n        return 0.0\n    mid = bw // 2\n    left = sub[:, :mid]\n    right = sub[:, bw-mid:][:, ::-1]  # mirror right to align\n    left_mask = sub_mask[:, :mid]\n    right_mask = sub_mask[:, bw-mid:][:, ::-1]\n    valid = left_mask & right_mask\n    if np.count_nonzero(valid) == 0:\n        # fallback to comparing intensity sums per side\n        left_sum = float(np.sum(sub * (sub_mask.astype(float)) * (np.arange(bw) < mid)))\n        right_sum = float(np.sum(sub * (sub_mask.astype(float)) * (np.arange(bw) >= mid)))\n        denom = max(1.0, left_sum + right_sum)\n        return float(abs(left_sum - right_sum) / denom)\n    diff = np.abs(left - right) * valid\n    return float(np.sum(diff) / np.count_nonzero(valid) / (np.max(gray) - np.min(gray) + 1e-9))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Normalized horizontal centroid of the mask (0 left, 1 right); 0.5 if no mask'\n    import numpy as np\n    if image is None:\n        return 0.5\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.5\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    area = float(np.count_nonzero(mask))\n    if area <= 0.0:\n        return 0.5\n    xs = np.arange(w, dtype=float)\n    sumx = float(np.sum((mask.astype(float) * xs)))\n    centroid_x = sumx / (area + 1e-8)\n    return float(centroid_x / max(1.0, w - 1.0))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Top-half vs bottom-half horizontal spread ratio: std of x positions in top half divided by bottom half (sleeves widen top)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape\n    thr = max(gray.mean() * 0.4, gray.max() * 0.05)\n    mask = gray > thr\n    top_mask = mask[:h//2, :]\n    bottom_mask = mask[h//2:, :]\n    tx, ty = np.nonzero(top_mask)\n    bx, by = np.nonzero(bottom_mask)\n    if tx.size == 0 or bx.size == 0:\n        return 1.0\n    top_xs = ty.astype(float)\n    bot_xs = by.astype(float)\n    top_std = top_xs.std()\n    bot_std = bot_xs.std()\n    if bot_std < 1e-6:\n        return float(top_std)\n    return float(top_std / (bot_std + 1e-8))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Linear trend (slope) of mask width across rows (positive => width increases downward), normalized by image width'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 3 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    row_widths = np.sum(mask, axis=1).astype(float)\n    y = np.arange(h).astype(float)\n    # center and compute slope via least squares\n    yw = y - y.mean()\n    rw = row_widths - row_widths.mean()\n    denom = np.sum(yw * yw) + 1e-8\n    slope = np.sum(yw * rw) / denom\n    # normalize by image width so range is comparable\n    return float(slope / (float(w) + 1e-8))\n",
    "def feature(image: np.ndarray) -> float:\n    'Compactness of foreground: area / (perimeter^2) (higher -> more compact)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    area = float(np.count_nonzero(mask))\n    if area <= 0.0:\n        return 0.0\n    mp = np.pad(mask.astype(bool), ((1, 1), (1, 1)), mode='constant', constant_values=False)\n    center = mp[1:-1, 1:-1]\n    up = mp[:-2, 1:-1]\n    down = mp[2:, 1:-1]\n    left = mp[1:-1, :-2]\n    right = mp[1:-1, 2:]\n    edge_mask = center & ((~up) | (~down) | (~left) | (~right))\n    perimeter = float(np.count_nonzero(edge_mask))\n    if perimeter <= 0.0:\n        return float(area)  # compact as whole\n    compact = area / ((perimeter ** 2) + 1e-8)\n    return float(compact)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Absolute angle (degrees) of the object principal axis from horizontal (PCA on foreground coordinates)'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    mask = (gray > 0)\n    coords = np.column_stack(np.where(mask))\n    if coords.shape[0] < 3:\n        return 0.0\n    # coords are (row, col) -> treat as (y, x)\n    ys = coords[:, 0].astype(float)\n    xs = coords[:, 1].astype(float)\n    X = np.vstack([xs - xs.mean(), ys - ys.mean()])\n    cov = np.cov(X)\n    try:\n        vals, vecs = np.linalg.eigh(cov)\n    except np.linalg.LinAlgError:\n        return 0.0\n    # largest eigenvector\n    v = vecs[:, np.argmax(vals)]\n    angle_rad = np.arctan2(v[1], v[0])\n    angle_deg = np.abs(angle_rad * 180.0 / np.pi)\n    # normalize to [0,90] by taking min(angle, 180-angle)\n    angle_deg = min(angle_deg, 180.0 - angle_deg)\n    return float(angle_deg)\n",
    "def feature(image: np.ndarray) -> float:\n    'Proportion of edge energy concentrated in bottom 25% of image (0..1)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 2 or w < 2:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    gy, gx = np.gradient(gray.astype(float))\n    mag = np.sqrt(gx * gx + gy * gy)\n    total = float(np.sum(mag))\n    bottom_start = max(0, h - max(1, h // 4))\n    bottom_energy = float(np.sum(mag[bottom_start:, :]))\n    if total <= 0:\n        return 0.0\n    return float(bottom_energy / total)\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Difference in mean intensity between bottom half and top half (bottom_mean - top_mean)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    mid = h // 2\n    top = gray[:mid, :] if mid > 0 else gray\n    bottom = gray[mid:, :] if mid < h else gray\n    if top.size == 0 or bottom.size == 0:\n        return 0.0\n    return float(np.mean(bottom) - np.mean(top))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Normalized vertical centroid of the foreground mask (0=top,1=bottom)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 50)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    ys, xs = np.where(mask)\n    if ys.size == 0:\n        return 0.0\n    cy = float(np.mean(ys))\n    return float(cy / float(h + 1e-8))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Ratio of strong edge count in top half to bottom half (top/bottom)'\n    import numpy as np\n    if image is None:\n        return 1.0\n    h, w = image.shape[:2]\n    if h < 2 or w < 2:\n        return 1.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    gy, gx = np.gradient(gray.astype(float))\n    mag = np.sqrt(gx * gx + gy * gy)\n    if not np.any(mag):\n        return 1.0\n    thresh = np.percentile(mag, 70)\n    strong = mag > thresh\n    top_count = np.count_nonzero(strong[:h // 2, :])\n    bot_count = np.count_nonzero(strong[h // 2:, :])\n    return float(top_count / (bot_count + 1e-8))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Normalized intensity histogram entropy (0..1) using 16 bins'\n    import numpy as np\n    if image is None:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2).flatten()\n    else:\n        gray = image.astype(float).flatten()\n    if gray.size == 0:\n        return 0.0\n    # scale to 0..1\n    mn, mx = float(np.min(gray)), float(np.max(gray))\n    if mx > mn:\n        vals = (gray - mn) / (mx - mn)\n    else:\n        vals = gray * 0.0\n    bins = 16\n    hist, _ = np.histogram(vals, bins=bins, range=(0.0, 1.0))\n    probs = hist.astype(float) / float(np.sum(hist) + 1e-12)\n    probs = probs[probs > 0.0]\n    if probs.size == 0:\n        return 0.0\n    ent = -float(np.sum(probs * np.log(probs + 1e-12)))\n    # normalize by log(bins)\n    return float(ent / (np.log(float(bins)) + 1e-12))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Normalized vertical centroid of the mask (0=top, 1=bottom)'\n    import numpy as np\n    if image is None:\n        return 0.5\n    h, w = image.shape[:2]\n    if h == 0:\n        return 0.5\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 50)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    ys, xs = np.where(mask)\n    if ys.size == 0:\n        return 0.5\n    cy = float(np.mean(ys))\n    return float(cy / float(max(1, h - 1)))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Ratio of center row mask width to maximum row mask width (detects narrow waist vs wide bag)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 50)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    row_widths = np.count_nonzero(mask, axis=1).astype(float)\n    if np.all(row_widths == 0):\n        return 0.0\n    center_row = h // 2\n    center_w = float(row_widths[center_row])\n    max_w = float(np.max(row_widths))\n    if max_w <= 0:\n        return 0.0\n    return float(center_w / (max_w + 1e-8))\n",
    "def feature(image: np.ndarray) -> float:\n    'Sleeve protrusion index: (max width in top quarter - mid-body width) / mid-body width (positive => sleeves extend beyond torso)'\n    import numpy as np\n    eps = 1e-6\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    if gray.size == 0:\n        return 0.0\n    thr = np.mean(gray) + 0.05 * (float(gray.max()) - np.mean(gray))\n    mask = gray > thr\n    if not mask.any():\n        return 0.0\n    rows = np.where(mask.any(axis=1))[0]\n    cols = np.where(mask.any(axis=0))[0]\n    if rows.size == 0 or cols.size == 0:\n        return 0.0\n    r0, r1 = rows[0], rows[-1]\n    c0, c1 = cols[0], cols[-1]\n    h = r1 - r0 + 1\n    top_q_end = r0 + max(1, h // 4)\n    mid_row = r0 + h // 2\n    def row_width(r):\n        row = mask[r, c0:c1+1]\n        nz = np.where(row)[0]\n        if nz.size:\n            return float(nz[-1] - nz[0] + 1)\n        return 0.0\n    top_widths = [row_width(r) for r in range(r0, top_q_end+1)]\n    mid_w = row_width(mid_row) + eps\n    max_top = float(np.max(top_widths)) if len(top_widths) else 0.0\n    return float((max_top - mid_w) / mid_w)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Vertical symmetry score (1.0 = perfectly symmetric, 0.0 = very asymmetric)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    # normalize to 0..1\n    mn, mx = float(np.min(gray)), float(np.max(gray))\n    if mx - mn < 1e-8:\n        return 1.0\n    norm = (gray - mn) / (mx - mn)\n    mirror = np.fliplr(norm)\n    # compare only the overlapping region (whole image)\n    diff = np.mean(np.abs(norm - mirror))\n    score = 1.0 - diff  # higher means more symmetric\n    return float(np.clip(score, 0.0, 1.0))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Top-center brightness ratio: mean brightness in small top-center region divided by mean of top-side regions (neck opening indicator)'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    nz = np.argwhere(gray > 0)\n    if nz.size == 0:\n        return 0.0\n    r0, c0 = nz.min(axis=0); r1, c1 = nz.max(axis=0)\n    bbox = gray[r0:r1+1, c0:c1+1]\n    bh, bw = bbox.shape\n    th = max(1, bh // 6)\n    cw = max(1, bw // 6)\n    center_start = max(0, bw//2 - cw//2); center_end = min(bw, center_start + cw)\n    left_start = 0; left_end = min(bw, cw)\n    right_start = max(0, bw - cw); right_end = bw\n    center_region = bbox[0:th, center_start:center_end]\n    side_region = np.concatenate((bbox[0:th, left_start:left_end].ravel(), bbox[0:th, right_start:right_end].ravel()))\n    mc = np.mean(center_region) if center_region.size else 0.0\n    ms = np.mean(side_region) if side_region.size else 1.0\n    if ms == 0:\n        return float(mc)\n    return float(mc / (ms + 1e-9))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Average occupancy of small bottom-left and bottom-right corner squares (shoe corner score)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    box_h = max(1, int(h * 0.18))\n    box_w = max(1, int(w * 0.25))\n    bl = mask[-box_h:, :box_w]\n    br = mask[-box_h:, -box_w:]\n    bl_frac = float(np.count_nonzero(bl)) / float(bl.size + 1e-8)\n    br_frac = float(np.count_nonzero(br)) / float(br.size + 1e-8)\n    return float((bl_frac + br_frac) / 2.0)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Top-edge variability: normalized standard deviation of topmost mask row positions across columns'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    # for each column find topmost mask row (or -1 if none)\n    top_rows = np.full(w, -1, dtype=int)\n    # compute any per column\n    cols_any = np.any(mask, axis=0)\n    if not np.any(cols_any):\n        return 0.0\n    for j in range(w):\n        if cols_any[j]:\n            col = mask[:, j]\n            top_rows[j] = int(np.argmax(col))\n    valid = top_rows[top_rows >= 0].astype(float)\n    if valid.size == 0:\n        return 0.0\n    std_top = float(np.std(valid))\n    return float(std_top / float(max(1, h)))\n",
    "def feature(image: np.ndarray) -> float:\n    'Bounding-box solidity: fraction of foreground pixels within the bbox (higher = bulkier garment)'\n    import numpy as np\n    gray = np.mean(image, axis=2) if len(image.shape) == 3 else image.astype(float)\n    thr = max(0.1 * np.max(gray), np.mean(gray) * 0.25)\n    mask = gray > thr\n    ys, xs = np.where(mask)\n    if ys.size == 0:\n        return 0.0\n    top, bottom = ys.min(), ys.max()\n    left, right = xs.min(), xs.max()\n    bbox_area = float((bottom - top + 1) * (right - left + 1))\n    if bbox_area <= 0:\n        return 0.0\n    fg_in_bbox = np.sum(mask[top:bottom+1, left:right+1])\n    return float(fg_in_bbox / bbox_area)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Edge density (gradient magnitude) in the middle vertical band of the bounding box (higher => more structure like lapels)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    p60 = np.percentile(gray, 60)\n    p40 = np.percentile(gray, 40)\n    mask = (gray >= p60) if (gray >= p60).sum() >= (gray <= p40).sum() else (gray <= p40)\n    if mask.sum() == 0:\n        return 0.0\n    ys, xs = np.where(mask)\n    y0, y1 = ys.min(), ys.max()\n    x0, x1 = xs.min(), xs.max()\n    if x1 < x0 or y1 < y0:\n        return 0.0\n    sub = gray[y0:y1+1, x0:x1+1]\n    # gradient\n    gy, gx = np.gradient(sub.astype(float))\n    mag = np.sqrt(gy*gy + gx*gx)\n    H, W = mag.shape\n    mid_left = max(0, W//2 - max(1, W//8))\n    mid_right = min(W, W//2 + max(1, W//8))\n    band = mag[:, mid_left:mid_right]\n    if band.size == 0:\n        return 0.0\n    score = float(np.mean(band) / (np.mean(mag) + 1e-6))\n    return score\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Ratio of mean mask width around 25% height to mean width around 75% height (width25 / width75)'\n    import numpy as np\n    if image is None:\n        return 1.0\n    h, w = image.shape[:2]\n    if h < 4 or w == 0:\n        return 1.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    def mean_width_at_row_fraction(frac):\n        row = int(np.clip(frac * h, 0, h-1))\n        window = max(1, h // 20)\n        rows = mask[max(0, row-window):min(h, row+window+1), :]\n        if rows.size == 0:\n            return 0.0\n        widths = np.sum(rows.astype(float), axis=1)\n        return float(np.mean(widths)) if widths.size > 0 else 0.0\n    w25 = mean_width_at_row_fraction(0.25)\n    w75 = mean_width_at_row_fraction(0.75)\n    return float((w25 + 1e-8) / (w75 + 1e-8))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Aspect ratio (width / height) of the tight foreground bounding box, centered around object'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    # grayscale\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 60)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    ys, xs = np.where(mask)\n    if ys.size == 0:\n        return 0.0\n    minr, maxr = int(np.min(ys)), int(np.max(ys))\n    minc, maxc = int(np.min(xs)), int(np.max(xs))\n    bbox_h = max(1, maxr - minr + 1)\n    bbox_w = max(1, maxc - minc + 1)\n    result = float(bbox_w) / float(bbox_h + 1e-8)\n    return float(result)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Top-bottom symmetry of the foreground mask (Jaccard overlap with vertical flip)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 50)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    if not np.any(mask):\n        return 0.0\n    flipped = np.flipud(mask)\n    inter = np.count_nonzero(mask & flipped)\n    union = np.count_nonzero(mask | flipped)\n    if union == 0:\n        return 0.0\n    return float(inter / union)\n",
    "def feature(image: np.ndarray) -> float:\n    'Mean foreground width at waist row (around 55% height) normalized by image width'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if w == 0 or h == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    row = int(min(h - 1, max(0, int(0.55 * h))))\n    band = max(1, int(h * 0.02))\n    start = max(0, row - band)\n    end = min(h, row + band + 1)\n    widths = np.sum(mask[start:end, :].astype(float), axis=1)\n    if widths.size == 0:\n        return 0.0\n    mean_width = float(np.mean(widths))\n    return float(mean_width / max(1.0, float(w)))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Ratio of mean object width in the top third vs the bottom third of the object bounding box (top_width / bottom_width)'\n    import numpy as np\n    gray = np.mean(image, axis=2) if len(image.shape) == 3 else image.astype(float)\n    thr = np.percentile(gray, 60)\n    mask = gray > thr\n    if np.count_nonzero(mask) < 10:\n        mask = gray > 0\n        if np.count_nonzero(mask) < 10:\n            return 0.0\n    ys, xs = np.where(mask)\n    top, left, bottom, right = ys.min(), xs.min(), ys.max(), xs.max()\n    bbox_h = bottom - top + 1\n    def mean_width_in_band(y0, y1):\n        widths = []\n        for r in range(y0, y1+1):\n            row = mask[r, left:right+1]\n            if np.any(row):\n                idx = np.where(row)[0]\n                widths.append(idx[-1] - idx[0] + 1)\n        return np.mean(widths) if widths else 0.0\n    top_h = max(0, top)\n    top_band_bottom = top + max(0, int(np.floor(bbox_h / 3.0)) - 1)\n    bottom_band_top = top + int(np.ceil(2*bbox_h/3.0))\n    top_w = mean_width_in_band(top, top_band_bottom)\n    bottom_w = mean_width_in_band(bottom_band_top, bottom)\n    return float((top_w + 1e-6) / (bottom_w + 1e-6))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Average horizontal contrast across a small top-center strip (detects collar/neckline contrast)'\n    import numpy as np\n    gray = np.mean(image, axis=2) if len(image.shape) == 3 else image.astype(float)\n    h, w = gray.shape[:2]\n    # take a narrow strip near the top center\n    strip_h = max(1, h // 16)\n    strip_w = max(1, w // 6)\n    r0 = max(0, h // 20)\n    c0 = max(0, (w - strip_w) // 2)\n    center_strip = gray[r0:r0 + strip_h, c0:c0 + strip_w]\n    if center_strip.size == 0:\n        return 0.0\n    # side strips of same height to left and right\n    left_c = max(0, c0 - strip_w)\n    right_c = min(w - strip_w, c0 + strip_w)\n    left_strip = gray[r0:r0 + strip_h, left_c:left_c + strip_w]\n    right_strip = gray[r0:r0 + strip_h, right_c:right_c + strip_w]\n    center_mean = float(np.mean(center_strip))\n    side_mean = float(np.mean(np.concatenate((left_strip.flatten(), right_strip.flatten())))) if left_strip.size + right_strip.size > 0 else center_mean\n    return float(side_mean - center_mean)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Normalized vertical centroid of the foreground mask (0=top, 1=bottom)'\n    import numpy as np\n    if image is None:\n        return 0.5\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.5\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = gray < thr if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else gray > thr\n    ys, xs = np.nonzero(mask)\n    if ys.size == 0:\n        return 0.5\n    centroid_y = float(np.mean(ys)) / float(max(1, h - 1))\n    return float(np.clip(centroid_y, 0.0, 1.0))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Mean absolute horizontal-edge strength around the waist/mid-lower torso area'\n    import numpy as np\n    gray = np.mean(image, axis=2) if len(image.shape) == 3 else image.astype(float)\n    h, w = gray.shape[:2]\n    gy = np.abs(np.gradient(gray, axis=0))\n    r0 = int(h * 0.55)\n    r1 = int(min(h, h * 0.8))\n    c0, c1 = w // 4, 3 * w // 4\n    region = gy[r0:r1, c0:c1]\n    if region.size == 0:\n        return 0.0\n    return float(np.mean(region))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Ratio of average bottom-10%-rows width to average top-10%-rows width (bottom/fullness indicator)'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    mx = float(np.max(gray))\n    if mx <= 0:\n        return 0.0\n    thr = max(np.mean(gray), mx * 0.2)\n    mask = gray > thr\n    coords = np.argwhere(mask)\n    if coords.size == 0:\n        return 0.0\n    r0, c0 = coords.min(axis=0)\n    r1, c1 = coords.max(axis=0)\n    bh = r1 - r0 + 1\n    top_n = max(1, bh // 10)\n    bot_n = top_n\n    def avg_width(row_start, row_end):\n        widths = []\n        for r in range(row_start, min(row_end+1, r1+1)):\n            row = mask[r, c0:c1+1]\n            if np.any(row):\n                left = int(np.argmax(row))\n                right = int(c1 - c0 - np.argmax(row[::-1]))\n                widths.append(right - left + 1)\n        return float(np.mean(widths)) if widths else 0.0\n    top_width = avg_width(r0, r0 + top_n - 1)\n    bot_width = avg_width(r1 - bot_n + 1, r1)\n    if top_width <= 1e-6:\n        return float(bot_width)  # avoid division by zero; give absolute bottom width\n    return float(bot_width / top_width)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Center-column fill continuity below midline: fraction of filled pixels in the center column from mid to bottom (high for full skirts)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    thr = np.mean(gray) + 0.15 * (np.max(gray) - np.min(gray))\n    mask = gray > thr\n    col = w // 2\n    seg = mask[h//2:, col] if col < w else np.zeros((h - h//2,), dtype=bool)\n    if seg.size == 0:\n        return 0.0\n    filled = int(np.count_nonzero(seg))\n    return float(filled / seg.size)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Number of small dark spots vertically aligned in the central stripe (e.g., buttons) normalized by image height'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    cx = w // 2\n    halfw = max(1, w // 10)\n    stripe = gray[:, max(0, cx - halfw):min(w, cx + halfw)]\n    # dark blob detection via adaptive threshold\n    thresh = np.percentile(stripe, 30)\n    dark = stripe < thresh\n    # collapse horizontally and look for vertical connected runs of dark pixels\n    colsum = dark.any(axis=1).astype(int)\n    runs = 0\n    inrun = False\n    for v in colsum:\n        if v and not inrun:\n            runs += 1\n            inrun = True\n        elif not v:\n            inrun = False\n    return float(runs / max(1, h))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Fraction of the object foreground located within the top 15% of the bounding box height (bags with handles may concentrate at very top)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    rng = float(np.max(gray) - np.min(gray))\n    thresh = float(np.mean(gray) + 0.12 * rng)\n    mask = gray >= thresh\n    if np.count_nonzero(mask) == 0:\n        mask = gray > np.min(gray)\n    rows = np.any(mask, axis=1)\n    cols = np.any(mask, axis=0)\n    if not np.any(rows) or not np.any(cols):\n        return 0.0\n    r0, r1 = np.argmax(rows), len(rows) - 1 - np.argmax(rows[::-1])\n    c0, c1 = np.argmax(cols), len(cols) - 1 - np.argmax(cols[::-1])\n    sub = mask[r0:r1+1, c0:c1+1]\n    h = sub.shape[0]\n    top_k = max(1, int(np.ceil(0.15 * h)))\n    top_region = sub[:top_k, :]\n    total_fg = float(np.count_nonzero(sub))\n    top_fg = float(np.count_nonzero(top_region))\n    return float((top_fg + 1e-6) / (total_fg + 1e-6))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Edge density in the central region: fraction of center pixels with strong gradient'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 3 or w < 3:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    cy0, cy1 = h // 4, (3 * h) // 4\n    cx0, cx1 = w // 4, (3 * w) // 4\n    center = gray[cy0:cy1, cx0:cx1]\n    if center.size == 0:\n        return 0.0\n    gy, gx = np.gradient(center.astype(float))\n    mag = np.sqrt(gx * gx + gy * gy)\n    thresh = np.percentile(mag, 70) if np.any(mag) else 1e9\n    strong = np.count_nonzero(mag > thresh)\n    total = mag.size\n    return float(strong) / float(total + 1e-8)\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Average gradient magnitude in the shoulder regions (top quarter, lateral 15-40% columns) to detect sleeve/shoulder edges'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    mx = gray.max() if gray.size else 0.0\n    thresh = mx * 0.05 if mx > 0 else 0.0\n    mask = gray > thresh\n    if not mask.any():\n        return 0.0\n    rows = np.any(mask, axis=1)\n    cols = np.any(mask, axis=0)\n    rmin, rmax = np.argmax(rows), len(rows) - 1 - np.argmax(rows[::-1])\n    cmin, cmax = np.argmax(cols), len(cols) - 1 - np.argmax(cols[::-1])\n    h = max(1, rmax - rmin + 1)\n    w = max(1, cmax - cmin + 1)\n    top_q = rmin + max(1, int(h * 0.0)), rmin + max(1, int(h * 0.25))\n    left_region = (rmin + 1, rmin + max(1, int(h * 0.25)), cmin + max(1, int(w * 0.15)), cmin + max(1, int(w * 0.40)))\n    right_region = (rmin + 1, rmin + max(1, int(h * 0.25)), cmax - max(1, int(w * 0.40)) + 1, cmax - max(1, int(w * 0.15)) + 1)\n    gx, gy = np.gradient(gray.astype(float))\n    grad_mag = np.sqrt(gx * gx + gy * gy)\n    vals = []\n    for (r0, r1, c0, c1) in [left_region, right_region]:\n        r0 = max(0, min(gray.shape[0], r0))\n        r1 = max(0, min(gray.shape[0], r1))\n        c0 = max(0, min(gray.shape[1], c0))\n        c1 = max(0, min(gray.shape[1], c1))\n        if r1 > r0 and c1 > c0:\n            region = grad_mag[r0:r1, c0:c1]\n            vals.append(np.mean(region) if region.size else 0.0)\n    return float(np.mean(vals) if vals else 0.0)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Fraction of top 20% rows of the object bounding box that are occupied (captures open-top shapes like sandals or bags)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    gray = np.mean(image, axis=2) if len(image.shape) == 3 else image.astype(np.float32)\n    if np.nanstd(gray) == 0 and np.max(gray) == 0:\n        return 0.0\n    thresh = np.percentile(gray, 70)\n    mask = gray > thresh\n    if not mask.any():\n        return 0.0\n    ys = np.where(mask.any(axis=1))[0]\n    xs = np.where(mask.any(axis=0))[0]\n    if ys.size == 0 or xs.size == 0:\n        return 0.0\n    r0, r1 = ys[0], ys[-1]\n    bbox_h = max(1, r1 - r0 + 1)\n    top_h = max(1, bbox_h // 5)\n    top_region = mask[r0:r0+top_h, xs[0]:xs[-1]+1]\n    fraction = float(np.sum(top_region) / max(1, top_region.size))\n    return fraction\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Normalized std of gradient magnitude in center region (texture energy center / whole)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 3 or w < 3:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    gy, gx = np.gradient(gray.astype(float))\n    grad = np.sqrt(gx * gx + gy * gy)\n    # center region middle half\n    r0, r1 = h // 4, (3 * h) // 4\n    c0, c1 = w // 4, (3 * w) // 4\n    center = grad[r0:r1, c0:c1]\n    whole_std = float(np.std(grad)) + 1e-8\n    center_std = float(np.std(center))\n    return float(center_std / whole_std)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Left-right symmetry score of the object (1 = perfectly symmetric, 0 = very asymmetric)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w < 2:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    ys, xs = np.where(mask)\n    if ys.size == 0:\n        return 0.0\n    left = int(max(0, xs.min()))\n    right = int(min(w - 1, xs.max()))\n    # take vertical bounding box and compare left half to mirrored right half\n    bbox = gray[:, left:right + 1]\n    bbox_mask = mask[:, left:right + 1]\n    bw = bbox.shape[1]\n    if bw < 2:\n        return 1.0\n    mid = bw // 2\n    left_part = bbox[:, :mid] * bbox_mask[:, :mid]\n    right_part = bbox[:, -mid:] * bbox_mask[:, -mid:]\n    # mirror right\n    right_mirror = np.fliplr(right_part)\n    # align sizes\n    minw = min(left_part.shape[1], right_mirror.shape[1])\n    if minw == 0:\n        return 0.0\n    L = left_part[:, :minw]\n    R = right_mirror[:, :minw]\n    diff = np.abs(L - R)\n    norm = np.mean(np.abs(L) + np.abs(R)) + 1e-8\n    score = 1.0 - (np.mean(diff) / norm)\n    return float(max(0.0, min(1.0, score)))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Coefficient of variation (std/mean) of object horizontal width across rows inside bbox (higher -> flared or irregular shape)'\n    import numpy as np\n    if image is None or image.size == 0:\n        return 0.0\n    gray = np.mean(image, axis=2) if len(image.shape) == 3 else image.astype(float)\n    gray = np.nan_to_num(gray)\n    thresh = np.percentile(gray, 50.0)\n    mask = gray > thresh\n    if not np.any(mask):\n        return 0.0\n    rows, cols = np.where(mask)\n    r0, r1 = rows.min(), rows.max()\n    c0, c1 = cols.min(), cols.max()\n    widths = []\n    for r in range(r0, r1 + 1):\n        row = mask[r, c0:c1 + 1]\n        non = np.nonzero(row)[0]\n        if non.size == 0:\n            widths.append(0)\n        else:\n            widths.append(float(non[-1] - non[0] + 1))\n    widths = np.array(widths)\n    meanw = np.mean(widths)\n    stdw = np.std(widths)\n    if meanw <= 0:\n        return 0.0\n    return float(stdw / meanw)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Entropy of edge orientation histogram (higher if many different edge directions present), normalized to [0,1]'\n    import numpy as np\n    if image is None:\n        return 0.0\n    gray = np.mean(image, axis=2) if len(image.shape) == 3 else image.astype(float)\n    h, w = gray.shape[:2]\n    if h < 2 or w < 2:\n        return 0.0\n    gx = np.gradient(gray, axis=1)\n    gy = np.gradient(gray, axis=0)\n    orient = np.arctan2(gy, gx)  # range [-pi, pi]\n    # build histogram of orientations\n    bins = 16\n    hist, _ = np.histogram(orient.flatten(), bins=bins, range=(-np.pi, np.pi))\n    hist = hist.astype(float)\n    s = hist.sum()\n    if s <= 0:\n        return 0.0\n    p = hist / s\n    # entropy\n    eps = 1e-12\n    ent = -np.sum(p * np.log(p + eps))\n    # normalize: max entropy is log(bins)\n    max_ent = float(np.log(bins))\n    return float(ent / (max_ent + 1e-12))\n",
    "def feature(image: np.ndarray) -> float:\n    'Average number of contiguous foreground segments per row (mean 0->1 transitions)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 50)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    # handle width cases\n    if w == 1:\n        segs = np.array(mask[:, 0].astype(float))\n        return float(np.mean(segs))\n    left = mask[:, :-1]\n    right = mask[:, 1:]\n    starts = ((~left) & right).astype(int).sum(axis=1) + mask[:, 0].astype(int)\n    return float(np.mean(starts))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Average local 4-neighbor intensity variation (texture-like energy)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 2 or w < 2:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    # compute absolute differences with 4-neighbors using rolls, mask edges\n    up = np.roll(gray, 1, axis=0)\n    down = np.roll(gray, -1, axis=0)\n    left = np.roll(gray, 1, axis=1)\n    right = np.roll(gray, -1, axis=1)\n    # zero out invalid rolled edges to avoid wrap-around\n    up[0, :] = gray[0, :]\n    down[-1, :] = gray[-1, :]\n    left[:, 0] = gray[:, 0]\n    right[:, -1] = gray[:, -1]\n    diffs = (np.abs(gray - up) + np.abs(gray - down) + np.abs(gray - left) + np.abs(gray - right))\n    # average per-pixel\n    return float(np.mean(diffs))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Vertical position of the object centroid within its bbox (normalized 0..1: top..bottom)'\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    gm = gray.mean()\n    gs = gray.std() if gray.std() > 0 else 1.0\n    thr = gm - 0.15 * gs\n    mask = gray < thr\n    ys, xs = np.where(mask)\n    if ys.size == 0:\n        return 0.0\n    y0, y1 = int(ys.min()), int(ys.max()) + 1\n    x0, x1 = int(xs.min()), int(xs.max()) + 1\n    crop = mask[y0:y1, x0:x1]\n    coords = np.column_stack(np.where(crop))\n    if coords.size == 0:\n        return 0.0\n    centroid_row = coords[:,0].mean()\n    bh = max(1, y1 - y0)\n    ratio = centroid_row / bh\n    return float(ratio)\n",
    "def feature(image: np.ndarray) -> float:\n    'Bounding-box area of main mask divided by image area (small for shoes/bags)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    # grayscale\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 50)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    ys, xs = np.where(mask)\n    if ys.size == 0:\n        return 0.0\n    miny, maxy = int(np.min(ys)), int(np.max(ys))\n    minx, maxx = int(np.min(xs)), int(np.max(xs))\n    bbox_area = float((maxy - miny + 1) * (maxx - minx + 1))\n    img_area = float(h * w)\n    return float(bbox_area / (img_area + 1e-8))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Bounding-box aspect ratio of the mask (height / width), 0 if no mask'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 50)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    ys, xs = np.where(mask)\n    if ys.size == 0:\n        return 0.0\n    height = float(ys.max() - ys.min() + 1)\n    width = float(xs.max() - xs.min() + 1)\n    if width <= 0.0:\n        return 0.0\n    return float(height / (width + 1e-8))\n",
    "def feature(image: np.ndarray) -> float:\n    'Mean lower-third red minus blue channel value (useful for detecting shoes/color differences)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) != 3 or image.shape[2] < 3:\n        return 0.0\n    img = image.astype(float)\n    R = img[:, :, 0]\n    B = img[:, :, 2]\n    start = (2 * h) // 3\n    lower = R[start:, :] - B[start:, :]\n    # normalize by overall magnitude\n    denom = np.mean(np.abs(img)) + 1e-8\n    return float(np.mean(lower) / denom)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Standard deviation of bottommost object row across columns (normalized) \u2014 measures hem curvature or uneven bottom edge'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(np.float32)\n    else:\n        gray = image.astype(np.float32)\n    h, w = gray.shape[:2]\n    mn, mx = np.min(gray), np.max(gray)\n    if mx - mn < 1e-6:\n        binary = gray > mx * 0.5\n    else:\n        thr = float(np.percentile(gray, 50))\n        binary = gray > thr\n    bottoms = np.full((w,), -1, dtype=np.int32)\n    for c in range(w):\n        col = binary[:, c]\n        inds = np.where(col)[0]\n        if inds.size:\n            bottoms[c] = int(inds[-1])\n    valid = bottoms[bottoms >= 0]\n    if valid.size == 0:\n        return 0.0\n    std = float(np.std(valid))\n    return float(std / max(1.0, h))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Absolute horizontal offset of mask centroid from image center normalized by width'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 50)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    ys, xs = np.where(mask)\n    if xs.size == 0:\n        return 0.0\n    cx = float(np.mean(xs))\n    offset = abs(cx - (w - 1) / 2.0)\n    return float(offset / (w + 1e-8))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Ratio of vertical gradient energy to horizontal gradient energy (captures dominant orientation)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    gy, gx = np.gradient(gray)\n    vert_energy = float(np.sum(np.abs(gy)))\n    horz_energy = float(np.sum(np.abs(gx))) + 1e-8\n    return float(vert_energy / horz_energy)\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Coefficient of variation (std/mean) of object horizontal width across rows inside bounding box (shape tapering)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    thr = max(np.mean(gray) * 0.6, np.max(gray) * 0.05)\n    mask = gray > thr\n    if mask.sum() == 0:\n        return 0.0\n    # bounding rows that contain object\n    rows = np.where(np.any(mask, axis=1))[0]\n    if rows.size == 0:\n        return 0.0\n    widths = []\n    for r in rows:\n        cols = np.where(mask[r])[0]\n        if cols.size:\n            widths.append(float(cols[-1] - cols[0] + 1))\n    if not widths:\n        return 0.0\n    widths = np.array(widths)\n    mean_w = float(np.mean(widths))\n    std_w = float(np.std(widths))\n    if mean_w < 1e-6:\n        return float(std_w)\n    return float(std_w / mean_w)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Aspect ratio (width/height) of bounding box of the largest connected foreground component'\n    import numpy as np\n    if image is None:\n        return 1.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 1.0\n    # grayscale\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    visited = np.zeros_like(mask, dtype=bool)\n    best_bbox = None\n    best_area = 0\n    for y in range(h):\n        for x in range(w):\n            if mask[y, x] and not visited[y, x]:\n                # flood fill stack\n                minx, maxx = x, x\n                miny, maxy = y, y\n                area = 0\n                stack = [(y, x)]\n                visited[y, x] = True\n                while stack:\n                    cy, cx = stack.pop()\n                    area += 1\n                    if cx < minx: minx = cx\n                    if cx > maxx: maxx = cx\n                    if cy < miny: miny = cy\n                    if cy > maxy: maxy = cy\n                    # neighbors 4-connected\n                    if cy > 0 and mask[cy - 1, cx] and not visited[cy - 1, cx]:\n                        visited[cy - 1, cx] = True\n                        stack.append((cy - 1, cx))\n                    if cy + 1 < h and mask[cy + 1, cx] and not visited[cy + 1, cx]:\n                        visited[cy + 1, cx] = True\n                        stack.append((cy + 1, cx))\n                    if cx > 0 and mask[cy, cx - 1] and not visited[cy, cx - 1]:\n                        visited[cy, cx - 1] = True\n                        stack.append((cy, cx - 1))\n                    if cx + 1 < w and mask[cy, cx + 1] and not visited[cy, cx + 1]:\n                        visited[cy, cx + 1] = True\n                        stack.append((cy, cx + 1))\n                if area > best_area:\n                    best_area = area\n                    best_bbox = (minx, miny, maxx, maxy)\n    if best_bbox is None or best_area <= 0:\n        return 1.0\n    minx, miny, maxx, maxy = best_bbox\n    bw = maxx - minx + 1\n    bh = maxy - miny + 1\n    if bh <= 0:\n        return 1.0\n    return float(float(bw) / float(bh))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Variance of the Laplacian (high values => more textured / detailed regions)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 2 or w < 2:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    gy, gx = np.gradient(gray.astype(float))\n    gyy, gyx = np.gradient(gy)\n    gxy, gxx = np.gradient(gx)\n    lap = gxx + gyy\n    var = float(np.var(lap))\n    # normalize by mean intensity to reduce scale dependence\n    norm = np.mean(np.abs(gray)) + 1e-8\n    return float(var / norm)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Estimated perimeter-to-area ratio from mask edges (higher indicates more jagged/elongated shape)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    thr = np.mean(gray) + 0.2 * (np.max(gray) - np.min(gray))\n    mask = gray > thr\n    if np.count_nonzero(mask) == 0:\n        mask = gray > np.mean(gray)\n    area = np.count_nonzero(mask)\n    if area == 0:\n        return 0.0\n    # compute simple perimeter: differences with shifted masks (4-neighbor)\n    m = mask.astype(np.uint8)\n    right_diff = np.logical_xor(m[:, :-1], m[:, 1:]).sum()\n    down_diff = np.logical_xor(m[:-1, :], m[1:, :]).sum()\n    perimeter = right_diff + down_diff\n    return float(perimeter / max(1, area))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Variance of the image Laplacian (high = more fine detail / texture)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 2 or w < 2:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    gx, gy = np.gradient(gray)\n    gxx, gxy = np.gradient(gx)\n    gyx, gyy = np.gradient(gy)\n    lap = gxx + gyy\n    return float(np.var(lap))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Left-right symmetry: normalized absolute difference of object centroids (x) as fraction of image width'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    if gray.max() == gray.min():\n        return 0.0\n    b = max(1, int(min(h, w) * 0.05))\n    border = np.concatenate([gray[:b, :].ravel(), gray[-b:, :].ravel(), gray[:, :b].ravel(), gray[:, -b:].ravel()])\n    border_mean = float(np.mean(border))\n    global_mean = float(np.mean(gray))\n    if border_mean > global_mean:\n        thr = np.percentile(gray, 40)\n        mask = gray < thr\n    else:\n        thr = np.percentile(gray, 60)\n        mask = gray > thr\n    mask = mask.astype(bool)\n    cnt = mask.sum()\n    if cnt == 0:\n        return 0.0\n    ys, xs = np.where(mask)\n    cx = float(xs.mean())\n    center_x = (w - 1) / 2.0\n    return float(abs(cx - center_x) / max(1.0, center_x))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Ratio of foreground mass in upper 40% to lower 60% (higher => more top-heavy)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    total = float(np.count_nonzero(mask))\n    if total == 0:\n        return 0.0\n    cut = max(1, int(0.4 * h))\n    top_mass = float(np.count_nonzero(mask[:cut, :]))\n    bottom_mass = float(np.count_nonzero(mask[cut:, :]))\n    # return ratio top/(bottom+top) normalized to [0,1] centered on distribution\n    return float(top_mass / (total + 1e-8))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Normalized center dip of the top contour: shoulder average top-row minus center top-row (positive when center dips down)'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    h, w = gray.shape[:2]\n    flat = gray.flatten()\n    if np.std(flat) < 1e-6:\n        return 0.0\n    th_high = np.percentile(flat, 75)\n    th_low = np.percentile(flat, 25)\n    mask_high = gray > th_high\n    mask_low = gray < th_low\n    mask = mask_high if np.count_nonzero(mask_high) >= np.count_nonzero(mask_low) else mask_low\n    if np.count_nonzero(mask) == 0:\n        return 0.0\n    # find topmost foreground row for each column (h if none)\n    top_rows = np.full(w, h, dtype=float)\n    for c in range(w):\n        ys = np.where(mask[:, c])[0]\n        if ys.size:\n            top_rows[c] = float(ys[0])\n    center_col = w // 2\n    shoulder_left = max(0, w//4)\n    shoulder_right = min(w-1, 3*w//4)\n    # average shoulder top (use small neighborhood)\n    shoulder_idx = [max(0, shoulder_left-1), shoulder_left, shoulder_left+1, shoulder_right-1, shoulder_right, min(w-1, shoulder_right+1)]\n    shoulder_vals = [top_rows[i] for i in shoulder_idx if 0 <= i < w]\n    if len(shoulder_vals) == 0:\n        return 0.0\n    shoulder_mean = float(np.mean(shoulder_vals))\n    center_top = float(top_rows[center_col]) if 0 <= center_col < w else h\n    # positive when center is lower (dips down)\n    dip = shoulder_mean - center_top\n    return float(dip) / float(h)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Kurtosis-like measure of mask vertical projection distribution (higher = heavy tails/spread)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 2:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 50)\n    mask = ((gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)).astype(float)\n    row_sums = np.sum(mask, axis=1)\n    n = row_sums.size\n    if n <= 1 or np.all(row_sums == 0):\n        return 0.0\n    mean = np.mean(row_sums)\n    std = np.std(row_sums)\n    if std <= 1e-8:\n        return 0.0\n    fourth = np.mean((row_sums - mean) ** 4)\n    kurt = fourth / (std ** 4 + 1e-12)\n    # normalize by a typical scale\n    return float(kurt)\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Shape compactness: (perimeter^2) / area (higher for less compact shapes), returns 0 for empty'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 50)\n    mask = ((gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)).astype(np.uint8)\n    area = float(np.count_nonzero(mask))\n    if area == 0:\n        return 0.0\n    p = 0\n    p += np.count_nonzero(mask[:, :-1] != mask[:, 1:])\n    p += np.count_nonzero(mask[:-1, :] != mask[1:, :])\n    perimeter = float(p) + 1e-8\n    compactness = (perimeter * perimeter) / area\n    return float(compactness)\n",
    "def feature(image: np.ndarray) -> float:\n    'Skewness of vertical mass distribution (third standardized moment of row masses)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h <= 1 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = gray < thr if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else gray > thr\n    row_mass = np.sum(mask.astype(float), axis=1)\n    total = np.sum(row_mass)\n    if total <= 0:\n        return 0.0\n    probs = row_mass / (total + 1e-12)\n    ys = np.arange(h).astype(float)\n    mean_y = float(np.sum(probs * ys))\n    centered = ys - mean_y\n    m2 = float(np.sum(probs * (centered ** 2)))\n    m3 = float(np.sum(probs * (centered ** 3)))\n    if m2 <= 1e-12:\n        return 0.0\n    skew = m3 / (np.sqrt(m2) * m2 + 1e-12)\n    return float(skew)\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Fraction of top 10% rows that contain no foreground (measures a top gap / neckline)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    band = max(1, int(h * 0.10))\n    top_band = mask[:band, :]\n    empty_rows = float(np.sum(np.all(~top_band, axis=1)))\n    return float(empty_rows / float(band))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Distance between two strongest column peaks in the lower half (normalized by width)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 50)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    start = h // 2\n    col_profile = np.sum(mask[start:, :], axis=0).astype(float)\n    if np.count_nonzero(col_profile) == 0:\n        return 0.0\n    idx = np.argsort(col_profile)[::-1]  # descending\n    # pick two distinct peaks with non-zero mass\n    valid = idx[col_profile[idx] > 0]\n    if valid.size < 2:\n        return 0.0\n    p1, p2 = int(valid[0]), int(valid[1])\n    dist = float(abs(p1 - p2))\n    return float(dist / (w + 1e-8))\n",
    "def feature(image: np.ndarray) -> float:\n    'Mask compactness estimate: perimeter^2 / area (lower = more compact), normalized by image area'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    area = float(np.count_nonzero(mask))\n    if area <= 0:\n        return 0.0\n    # approximate perimeter: count mask pixels that have at least one 4-neighbor background\n    pad = np.pad(mask.astype(np.uint8), ((1, 1), (1, 1)), mode='constant', constant_values=0)\n    center = pad[1:-1, 1:-1]\n    up = pad[:-2, 1:-1]\n    down = pad[2:, 1:-1]\n    left = pad[1:-1, :-2]\n    right = pad[1:-1, 2:]\n    neighbor_sum = up + down + left + right\n    boundary = (center.astype(bool)) & (neighbor_sum < 4)\n    perimeter = float(np.count_nonzero(boundary))\n    compact = (perimeter * perimeter) / (area + 1e-8)\n    # normalize by image area to keep values comparable\n    return float(compact / (float(h * w) + 1e-8))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Average count of horizontal gradient sign changes per row in the upper half central band (captures collar corners)'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    gy, gx = np.gradient(gray.astype(float))\n    # focus on upper half and central columns\n    r0, r1 = 0, max(1, h//2)\n    c0, c1 = max(0, w//4), min(w, 3*w//4)\n    band = gx[r0:r1, c0:c1]\n    if band.size == 0:\n        return 0.0\n    signs = np.sign(band)\n    # count sign changes along columns for each row\n    changes_per_row = np.sum(signs[:, 1:] * signs[:, :-1] < 0, axis=1)\n    avg_changes = float(np.mean(changes_per_row))\n    return float(avg_changes / max(1.0, (c1 - c0)))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Mean dominant edge orientation (angle/pi in -1..1), computed from strong gradients (captures vertical vs diagonal structure)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 2 or w < 2:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    gy, gx = np.gradient(gray.astype(float))\n    mag = np.sqrt(gx * gx + gy * gy)\n    if not np.any(mag):\n        return 0.0\n    thresh = np.percentile(mag, 70)\n    strong = mag >= thresh\n    if not np.any(strong):\n        return 0.0\n    angles = np.arctan2(gy[strong], gx[strong])\n    s = float(np.mean(np.sin(angles)))\n    c = float(np.mean(np.cos(angles)))\n    mean_angle = float(np.arctan2(s, c))  # -pi..pi\n    return float(mean_angle / np.pi)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Contrast between the central vertical strip and the flanking side strips (center_mean - side_mean) / (side_mean + eps)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    strip_w = max(1, w // 6)\n    c0 = max(0, w // 2 - strip_w // 2)\n    c1 = min(w, c0 + strip_w)\n    left0 = max(0, c0 - strip_w)\n    left1 = c0\n    right0 = c1\n    right1 = min(w, c1 + strip_w)\n    center_mean = float(np.mean(gray[:, c0:c1])) if (c1 - c0) > 0 else 0.0\n    left_mean = float(np.mean(gray[:, left0:left1])) if (left1 - left0) > 0 else center_mean\n    right_mean = float(np.mean(gray[:, right0:right1])) if (right1 - right0) > 0 else center_mean\n    side_mean = 0.5 * (left_mean + right_mean)\n    contrast = (center_mean - side_mean) / (abs(side_mean) + 1e-6)\n    return float(contrast)\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Shoulder-to-waist width ratio: mean mask width near 15% rows divided by 55% rows'\n    import numpy as np\n    if image is None:\n        return 1.0\n    h, w = image.shape[:2]\n    if h < 4 or w == 0:\n        return 1.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    def avg_width_at(row_frac):\n        row = int(min(h - 1, max(0, int(row_frac * h))))\n        band = 2\n        start = max(0, row - band)\n        end = min(h, row + band + 1)\n        widths = np.sum(mask[start:end, :].astype(float), axis=1)\n        if widths.size == 0:\n            return 1.0\n        return float(np.mean(widths)) + 1e-8\n    shoulder = avg_width_at(0.15)\n    waist = avg_width_at(0.55)\n    return float(shoulder / float(waist + 1e-8))\n",
    "def feature(image: np.ndarray) -> float:\n    'Fill ratio: object pixel area divided by its bounding-box area (indicates hollow/flare shapes)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    rng = float(np.max(gray) - np.min(gray))\n    thresh = float(np.mean(gray) + 0.15 * (rng if rng != 0 else 1.0))\n    mask = gray > thresh\n    area = float(np.count_nonzero(mask))\n    if area == 0:\n        return 0.0\n    coords = np.argwhere(mask)\n    min_r, min_c = int(np.min(coords[:, 0])), int(np.min(coords[:, 1]))\n    max_r, max_c = int(np.max(coords[:, 0])), int(np.max(coords[:, 1]))\n    bbox_area = float((max_r - min_r + 1) * (max_c - min_c + 1))\n    if bbox_area <= 0:\n        return 0.0\n    return float(area / bbox_area)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'RGB channel contrast: normalized difference between strongest and weakest channel means (0 for grayscale)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    if len(image.shape) != 3 or image.shape[2] < 3:\n        return 0.0\n    # safe conversion to float\n    img = image.astype(float)\n    means = [float(np.mean(img[:, :, i])) for i in range(3)]\n    mx = max(means)\n    mn = min(means)\n    denom = (mx + mn) + 1e-8\n    return float((mx - mn) / denom)\n",
    "def feature(image: np.ndarray) -> float:\n    'Normalized width where the object attains its maximum width in the upper half (shoulder peak width fraction)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    mx = float(np.max(gray))\n    thr = max(0.3 * float(np.mean(gray)), 0.1 * mx)\n    mask = gray > thr\n    coords = np.argwhere(mask)\n    if coords.size == 0:\n        return 0.0\n    ys = coords[:,0]; xs = coords[:,1]\n    miny, maxy = int(ys.min()), int(ys.max())\n    midy = miny + max(1, (maxy - miny) // 2)\n    widths = []\n    for r in range(miny, midy+1):\n        rowxs = xs[ys == r]\n        if rowxs.size == 0:\n            widths.append(0)\n        else:\n            widths.append(int(rowxs.max() - rowxs.min() + 1))\n    if len(widths) == 0:\n        return 0.0\n    peak = max(widths)\n    bbox_width = int(xs.max() - xs.min() + 1)\n    if bbox_width == 0:\n        return 0.0\n    return float(peak / bbox_width)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Ratio of mask mass in top half to bottom half ( >1 means more mass in top)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    top = float(np.count_nonzero(mask[:h // 2, :]))\n    bottom = float(np.count_nonzero(mask[h // 2:, :]))\n    if bottom <= 1e-8:\n        return float(top / (bottom + 1e-8))\n    return float(top / bottom)\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Approximate convexity ratio: object area divided by area of convex-like envelope built from per-row left/right extents (1 = fully convex)'\n    try:\n        if len(image.shape) == 3:\n            gray = np.mean(image, axis=2)\n        else:\n            gray = image.astype(float)\n    except Exception:\n        return 0.0\n    h, w = gray.shape[:2]\n    rng = float(gray.max() - gray.min())\n    thr = float(gray.mean()) + max(0.05 * rng, 1e-6)\n    mask = gray > thr\n    if not np.any(mask):\n        return 0.0\n    rows_idx = np.where(mask.any(axis=1))[0]\n    if rows_idx.size == 0:\n        return 0.0\n    top, bottom = rows_idx[0], rows_idx[-1]\n    lefts = np.full(bottom - top + 1, w, dtype=float)\n    rights = np.full(bottom - top + 1, -1, dtype=float)\n    for i, r in enumerate(range(top, bottom + 1)):\n        cols = np.where(mask[r])[0]\n        if cols.size:\n            lefts[i] = cols[0]\n            rights[i] = cols[-1]\n    # fill missing rows by linear interpolation\n    ys = np.arange(top, bottom + 1)\n    valid = rights >= lefts\n    if not np.any(valid):\n        return 0.0\n    if valid.sum() < len(valid):\n        # interp lefts and rights separately\n        good_idx = np.where(valid)[0]\n        lefts[~valid] = np.interp(np.where(~valid)[0], good_idx, lefts[good_idx])\n        rights[~valid] = np.interp(np.where(~valid)[0], good_idx, rights[good_idx])\n    # compute hull-like area by trapezoidal integration: sum of widths per row\n    hull_widths = np.maximum(0.0, rights - lefts + 1.0)\n    hull_area = float(hull_widths.sum())\n    obj_area = float(mask.sum())\n    if hull_area <= 0:\n        return 0.0\n    return float(obj_area / hull_area)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Aspect ratio (height/width) of the main mask bounding box (0 if undefined)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = gray < thr if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else gray > thr\n    ys, xs = np.where(mask)\n    if ys.size == 0:\n        return 0.0\n    ymin, ymax = int(np.min(ys)), int(np.max(ys))\n    xmin, xmax = int(np.min(xs)), int(np.max(xs))\n    bw = float(xmax - xmin + 1)\n    bh = float(ymax - ymin + 1)\n    if bw <= 0:\n        return 0.0\n    return float(bh / (bw + 1e-8))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Normalized mean absolute Laplacian (second derivative) as a texture roughness measure'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 2 or w < 2:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    gy, gx = np.gradient(gray)\n    gyy, gyx = np.gradient(gy)\n    gxy, gxx = np.gradient(gx)\n    lap = gxx + gyy\n    denom = (np.mean(np.abs(gray)) + 1e-8)\n    return float(np.mean(np.abs(lap)) / denom)\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Maximum contiguous vertical foreground segment height normalized by image height'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 50)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    m = mask.astype(int)\n    # dynamic programming: consecutive ones count ending at each pixel\n    up_counts = np.zeros_like(m)\n    up_counts[0, :] = m[0, :]\n    for r in range(1, h):\n        up_counts[r, :] = (up_counts[r - 1, :] + 1) * m[r, :]\n    max_run = float(np.max(up_counts)) if up_counts.size > 0 else 0.0\n    return float(max_run / (h + 1e-8))\n",
    "def feature(image: np.ndarray) -> float:\n    'Vertical coverage ratio: fraction of rows that contain any foreground pixel'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 50)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    if h == 0:\n        return 0.0\n    rows_with = np.count_nonzero(np.any(mask, axis=1))\n    return float(rows_with / float(h))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Normalized vertical reflection asymmetry (left-right mirror difference normalized by object mass)'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    mx = float(np.max(gray))\n    if mx <= 0:\n        return 0.0\n    thr = max(np.mean(gray), mx * 0.2)\n    mask = (gray > thr).astype(np.uint8)\n    coords = np.argwhere(mask)\n    if coords.size == 0:\n        return 0.0\n    r0, c0 = coords.min(axis=0)\n    r1, c1 = coords.max(axis=0)\n    sub = mask[r0:r1+1, c0:c1+1]\n    h, w = sub.shape\n    mid = w // 2\n    left = sub[:, :mid]\n    right = sub[:, w-mid:][:, ::-1] if mid > 0 else np.zeros_like(left)\n    # pad to same shape if widths differ\n    if left.shape[1] != right.shape[1]:\n        mn = min(left.shape[1], right.shape[1])\n        left = left[:, :mn]\n        right = right[:, :mn]\n    diff = np.sum(np.abs(left.astype(float) - right.astype(float)))\n    denom = float(np.sum(sub)) + 1e-6\n    return float(diff / denom)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Average edge magnitude (gradient magnitude mean) of the grayscale image'\n    import numpy as np\n    if image is None:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    # normalize to avoid scale dependence\n    mx = np.max(gray)\n    if mx > 0:\n        gray = gray / mx\n    gy, gx = np.gradient(gray)\n    grad_mag = np.sqrt(gx * gx + gy * gy)\n    return float(np.mean(grad_mag))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Number of separate foreground islands touching the bottom band (helps detect two shoes)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 3 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    band_h = max(1, h * 20 // 100)\n    band = mask[-band_h:, :]\n    # collapse vertically: which columns have any mask in the bottom band\n    cols = np.any(band, axis=0)\n    if not np.any(cols):\n        return 0.0\n    pad = np.concatenate(([0], cols.astype(int), [0]))\n    diff = np.diff(pad)\n    starts = np.where(diff == 1)[0]\n    ends = np.where(diff == -1)[0]\n    islands = ends.size\n    # normalize by expected shoe count (max 4 for noise)\n    return float(min(islands, 4))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Edge orientation strength (0..1): how strongly edges align to a dominant orientation'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 2 or w < 2:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    gy, gx = np.gradient(gray)\n    grad = np.sqrt(gx * gx + gy * gy)\n    total = float(np.sum(grad))\n    if total <= 1e-8:\n        return 0.0\n    # angles and doubled-angle trick to capture orientation modulo 180 deg\n    theta = np.arctan2(gy, gx)\n    cos2 = np.cos(2.0 * theta)\n    sin2 = np.sin(2.0 * theta)\n    sx = float(np.sum(grad * cos2))\n    sy = float(np.sum(grad * sin2))\n    strength = np.sqrt(sx * sx + sy * sy) / (total + 1e-8)\n    return float(np.clip(strength, 0.0, 1.0))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Bottom-skew measure: difference between centroid row and median row of bright pixels normalized by height'\n    import numpy as np\n    gray = np.mean(image, axis=2) if len(image.shape) == 3 else image.astype(float)\n    h, w = gray.shape[:2]\n    if np.all(gray == 0):\n        return 0.0\n    th = np.percentile(gray, 70)\n    mask = gray > th\n    rows_idx, cols_idx = np.where(mask)\n    if rows_idx.size == 0:\n        return 0.0\n    centroid = rows_idx.mean()\n    median_row = np.median(rows_idx)\n    # positive -> centroid lower than median (mass concentrated lower)\n    return float((centroid - median_row) / max(1, h))\n",
    "def feature(image: np.ndarray) -> float:\n    'Normalized variation of the top contour (std of topmost object row per column divided by height) \u2014 measures top irregularity/curvature'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    h, w = gray.shape[:2]\n    thresh = (np.mean(gray) + np.min(gray)) / 2.0\n    binary = gray > thresh\n    if not np.any(binary):\n        return 0.0\n    # topmost True row per column; if none, set to h (bottom sentinel)\n    rows = np.arange(h)[:, None]\n    top_rows = np.where(binary, rows, h).min(axis=0)\n    std_top = float(np.std(top_rows[top_rows < h])) if np.any(top_rows < h) else float(h)\n    return std_top / max(1.0, float(h))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Vertical symmetry similarity of the main object mask (1.0 = perfect symmetry)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 50)\n    mask = gray < thr if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else gray > thr\n    ys, xs = np.where(mask)\n    if ys.size == 0:\n        return 0.0\n    miny, maxy = ys.min(), ys.max()\n    minx, maxx = xs.min(), xs.max()\n    sub = mask[miny:maxy + 1, minx:maxx + 1]\n    sh, sw = sub.shape\n    if sw == 0:\n        return 0.0\n    mid = sw // 2\n    left = sub[:, :mid]\n    right = sub[:, sw - mid:] if mid > 0 else np.zeros_like(left)\n    if left.size == 0 or right.size == 0:\n        return 0.0\n    right_flipped = np.fliplr(right)\n    # pad smaller side if odd width\n    if left.shape != right_flipped.shape:\n        lw, rw = left.shape[1], right_flipped.shape[1]\n        if lw > rw:\n            pad = np.zeros((sh, lw - rw), dtype=left.dtype)\n            right_flipped = np.concatenate([pad, right_flipped], axis=1)\n        else:\n            pad = np.zeros((sh, rw - lw), dtype=left.dtype)\n            left = np.concatenate([pad, left], axis=1)\n    diff = np.sum(np.abs(left.astype(float) - right_flipped.astype(float)))\n    area = float(np.count_nonzero(sub))\n    if area <= 0:\n        return 0.0\n    frac_diff = diff / (area + 1e-8)\n    sim = 1.0 - min(1.0, frac_diff)\n    return float(sim)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Left-right symmetry overlap of the object mask (higher => more symmetric garment)'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    thr = float(np.percentile(gray, 75))\n    mask = gray >= thr\n    if np.count_nonzero(mask) < 10:\n        thr = float(np.mean(gray))\n        mask = gray > thr\n    if np.count_nonzero(mask) == 0:\n        return 0.0\n    flipped = np.fliplr(mask)\n    # Align widths if odd/even\n    if flipped.shape != mask.shape:\n        minw = min(mask.shape[1], flipped.shape[1])\n        mask = mask[:, :minw]\n        flipped = flipped[:, :minw]\n    overlap = np.count_nonzero(mask & flipped)\n    total = np.count_nonzero(mask)\n    return float(overlap) / float(total + 1e-8)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Bottom-center fill: fraction of object pixels in bottom-center patch (distinguishes long garments vs compact bags)'\n    import numpy as np\n    gray = np.mean(image, axis=2) if len(image.shape) == 3 else image.astype(float)\n    h, w = gray.shape[:2]\n    low = float(np.percentile(gray, 10))\n    high = float(np.percentile(gray, 90))\n    thr = low + 0.2 * (high - low)\n    mask = gray > thr\n    if not mask.any():\n        return 0.0\n    r0 = max(0, (3 * h) // 4)\n    r1 = h\n    c0 = w // 3\n    c1 = min(w, 2 * w // 3)\n    patch = mask[r0:r1, c0:c1]\n    if patch.size == 0:\n        return 0.0\n    fill_fraction = float(np.sum(patch) / patch.size)\n    return fill_fraction\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Fraction of bounding-box pixels occupied by foreground (solidness of the object)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    ys, xs = np.where(mask)\n    if ys.size == 0:\n        return 0.0\n    ymin, ymax = int(np.min(ys)), int(np.max(ys))\n    xmin, xmax = int(np.min(xs)), int(np.max(xs))\n    bbox_area = float(max(1, (ymax - ymin + 1)) * max(1, (xmax - xmin + 1)))\n    fill = float(np.count_nonzero(mask[ymin:ymax+1, xmin:xmax+1]))\n    return float(fill / (bbox_area + 1e-8))\n",
    "def feature(image: np.ndarray) -> float:\n    'Normalized entropy of strong gradient orientations (0..1), higher => diverse edge directions'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 2 or w < 2:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    gy, gx = np.gradient(gray.astype(float))\n    mag = np.sqrt(gx * gx + gy * gy)\n    if not np.any(mag):\n        return 0.0\n    thr = np.percentile(mag.flatten(), 60)\n    strong_mask = mag > thr\n    if not np.any(strong_mask):\n        return 0.0\n    ori = np.arctan2(gy, gx)\n    vals = ori[strong_mask].flatten()\n    bins = 16\n    hist, _ = np.histogram(vals, bins=bins, range=(-np.pi, np.pi))\n    p = hist.astype(float) / (np.sum(hist) + 1e-12)\n    p_nonzero = p[p > 0]\n    if p_nonzero.size == 0:\n        return 0.0\n    entropy = -np.sum(p_nonzero * np.log(p_nonzero))\n    # normalize by log(bins)\n    return float(entropy / (np.log(bins) + 1e-12))\n",
    "def feature(image: np.ndarray) -> float:\n    'Bounding-box aspect ratio normalized by image aspect ratio (tall vs wide items)'\n    import numpy as np\n    if image is None:\n        return 1.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 1.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    ys, xs = np.where(mask)\n    if ys.size == 0 or xs.size == 0:\n        return 1.0\n    bh = float(np.max(ys) - np.min(ys) + 1)\n    bw = float(np.max(xs) - np.min(xs) + 1)\n    if bw <= 1e-8:\n        return 1.0\n    img_ratio = float(h) / float(w)\n    bbox_ratio = bh / (bw + 1e-8)\n    return float((bbox_ratio + 1e-8) / (img_ratio + 1e-8))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Std of horizontal centroids computed for three vertical bands normalized by image width'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 3 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    bands = [ (0, h//3), (h//3, 2*h//3), (2*h//3, h) ]\n    centroids = []\n    xs = np.arange(w).astype(float)\n    for a, b in bands:\n        region = mask[a:b, :]\n        if region.size == 0:\n            continue\n        sums = np.sum(region, axis=0)\n        total = np.sum(sums)\n        if total > 0:\n            # compute x centroid for region\n            centroids.append(float(np.sum(xs * sums) / total))\n    if len(centroids) == 0:\n        return 0.0\n    return float(np.std(centroids) / (w + 1e-8))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Count of internal zero segments on the center row within the object bbox (captures strap gaps/hole-like structures)'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    thr = np.percentile(gray, 65)\n    bin_img = (gray > thr).astype(int)\n    ys, xs = np.where(bin_img)\n    if xs.size == 0:\n        return 0.0\n    min_c, max_c = xs.min(), xs.max()\n    min_r, max_r = ys.min(), ys.max()\n    center_row = (min_r + max_r) // 2\n    row_seg = bin_img[center_row, min_c:max_c+1]\n    if row_seg.size == 0:\n        return 0.0\n    # count zero segments inside the object region (between left and right edges)\n    diffs = np.diff(np.concatenate(([1], row_seg, [1])))\n    zero_starts = np.sum(diffs == -1)\n    zero_ends = np.sum(diffs == 1)\n    # number of zero segments equals zero_starts (or zero_ends)\n    return float(zero_starts)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Strength of a vertical central seam: mean horizontal gradient magnitude in the vertical center region normalized by overall'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    mask = gray > 0\n    if np.count_nonzero(mask) == 0:\n        thr = np.mean(gray) if gray.size else 0.0\n        mask = gray > (thr * 0.5)\n    if np.count_nonzero(mask) == 0:\n        return 0.0\n    ys, xs = np.where(mask)\n    min_y, max_y = ys.min(), ys.max()\n    min_x, max_x = xs.min(), xs.max()\n    obj_gray = gray[min_y:max_y+1, min_x:max_x+1]\n    # gradients: gy (vertical), gx (horizontal)\n    gy, gx = np.gradient(obj_gray)\n    gx_abs = np.abs(gx)\n    h, w = obj_gray.shape\n    c1 = max(0, w*2//5)\n    c2 = min(w, w*3//5 + 1)\n    central_mean = float(np.mean(gx_abs[:, c1:c2])) if c2 > c1 else 0.0\n    overall_mean = float(np.mean(gx_abs)) + 1e-6\n    return float(central_mean / overall_mean)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Foreground area divided by its bounding-box area (solidity-like, in [0,1])'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    area = float(np.count_nonzero(mask))\n    if area == 0.0:\n        return 0.0\n    ys, xs = np.where(mask)\n    if ys.size == 0:\n        return 0.0\n    bbox_h = float(ys.max() - ys.min() + 1)\n    bbox_w = float(xs.max() - xs.min() + 1)\n    bbox_area = max(1.0, bbox_h * bbox_w)\n    return float(np.clip(area / bbox_area, 0.0, 1.0))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Ratio of mean vertical gradient magnitude to horizontal gradient magnitude (captures vertical vs horizontal structure)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    # compute gradients\n    try:\n        gy, gx = np.gradient(gray.astype(float))\n    except Exception:\n        return 0.0\n    mag_y = np.mean(np.abs(gy))\n    mag_x = np.mean(np.abs(gx))\n    if mag_x + mag_y <= 1e-9:\n        return 0.0\n    return float(mag_y / (mag_x + 1e-9))\n",
    "def feature(image: np.ndarray) -> float:\n    'Orientation concentration of strong edges (0..1, higher => more coherent orientation)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 2 or w < 2:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    gy, gx = np.gradient(gray.astype(float))\n    mag = np.sqrt(gx * gx + gy * gy)\n    if not np.any(mag):\n        return 0.0\n    thr = np.percentile(mag, 70)\n    strong = mag > thr\n    if not np.any(strong):\n        return 0.0\n    angles = np.arctan2(gy[strong], gx[strong])\n    # resultant vector length as orientation coherence (0..1)\n    c = np.mean(np.cos(angles))\n    s = np.mean(np.sin(angles))\n    R = np.sqrt(c * c + s * s)\n    return float(R)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Bounding-box width to height ratio of the foreground mask (w/h)'\n    import numpy as np\n    if image is None:\n        return 1.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 1.0\n    # grayscale\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = ((gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)).astype(bool)\n    if not np.any(mask):\n        return 1.0\n    rows = np.any(mask, axis=1)\n    cols = np.any(mask, axis=0)\n    r_idx = np.where(rows)[0]\n    c_idx = np.where(cols)[0]\n    if r_idx.size == 0 or c_idx.size == 0:\n        return 1.0\n    bbox_h = float(r_idx[-1] - r_idx[0] + 1)\n    bbox_w = float(c_idx[-1] - c_idx[0] + 1)\n    if bbox_h <= 0:\n        return 1.0\n    return float((bbox_w + 1e-8) / (bbox_h + 1e-8))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Fraction of strong edges located in the bottom third of the image (boots concentrated bottom)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 3 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    gy, gx = np.gradient(gray.astype(float))\n    mag = np.sqrt(gx * gx + gy * gy)\n    if not np.any(mag):\n        return 0.0\n    thr = np.percentile(mag, 70)\n    strong = mag > thr\n    total = np.count_nonzero(strong)\n    if total == 0:\n        return 0.0\n    bottom_start = max(0, (2 * h) // 3)\n    bottom_count = np.count_nonzero(strong[bottom_start:, :])\n    return float(bottom_count / float(total + 1e-8))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Fraction of top 15% rows that are mostly background (helps detect low-placed items like shoes)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = float(np.median(gray))\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    top_rows = max(1, int(max(1, h * 0.15)))\n    top_region = mask[:top_rows, :]\n    bg_frac = 1.0 - (np.count_nonzero(top_region) / float(top_region.size) if top_region.size > 0 else 0.0)\n    return float(bg_frac)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Ratio of intensity std inside the object to outside (contrast measure) - sandals often have similar intensities across straps'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    thr = 0.5 * np.mean(gray) + 0.5 * np.min(gray)\n    mask = gray > thr\n    inside = gray[mask]\n    outside = gray[~mask]\n    if inside.size == 0:\n        return 0.0\n    std_in = float(np.std(inside))\n    std_out = float(np.std(outside)) if outside.size > 0 else 1.0\n    if std_out == 0.0:\n        return float(std_in)\n    return std_in / std_out\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Left-right symmetry score of the object within its bounding box (1 = perfect symmetry, 0 = very asymmetric)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    mx = float(np.max(gray))\n    thr = max(0.35 * float(np.mean(gray)), 0.1 * mx)\n    mask = gray > thr\n    coords = np.argwhere(mask)\n    if coords.size == 0:\n        return 0.0\n    ys = coords[:, 0]; xs = coords[:, 1]\n    miny, maxy = ys.min(), ys.max()\n    minx, maxx = xs.min(), xs.max()\n    # extract bbox region\n    miny, maxy, minx, maxx = int(miny), int(maxy), int(minx), int(maxx)\n    sub = gray[miny:maxy+1, minx:maxx+1]\n    # resize not needed; compute mirrored correlation\n    w = sub.shape[1]\n    mid = w // 2\n    left = sub[:, :mid]\n    right = sub[:, w-mid:][:, ::-1]  # mirror right\n    # pad to same width\n    if left.shape[1] != right.shape[1]:\n        mw = max(left.shape[1], right.shape[1])\n        def pad(a, mw):\n            padw = mw - a.shape[1]\n            if padw <= 0:\n                return a\n            return np.pad(a, ((0,0),(0,padw)), mode='constant', constant_values=0)\n        left = pad(left, mw); right = pad(right, mw)\n    # compute normalized cross-correlation\n    lf = (left - left.mean()) .ravel()\n    rf = (right - right.mean()) .ravel()\n    denom = (np.linalg.norm(lf) * np.linalg.norm(rf))\n    if denom == 0:\n        return 0.0\n    corr = float(np.dot(lf, rf) / denom)\n    # map from [-1,1] to [0,1]\n    return float((corr + 1.0) / 2.0)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Horizontal symmetry score: normalized mean absolute difference between left and flipped right (lower means more symmetric)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    # center crop to avoid border artifacts\n    c = gray[:, :]\n    flipped = np.fliplr(c)\n    diff = np.abs(c - flipped)\n    denom = np.mean(np.abs(c)) + 1e-6\n    score = diff.mean() / denom\n    return float(score)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Fraction of central rows exhibiting multiple short foreground runs (indicative of horizontal straps)'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    nz = gray[gray > 0]\n    thresh = float(np.percentile(nz, 45)) if nz.size > 0 else float(np.mean(gray))\n    mask = gray >= thresh\n    h, w = mask.shape\n    r0, r1 = h//4, 3*h//4\n    if r1 <= r0:\n        return 0.0\n    count_rows = 0\n    strap_like = 0\n    for r in range(r0, r1):\n        row = mask[r, :]\n        # find contiguous runs\n        runs = []\n        in_run = False\n        run_len = 0\n        for v in row:\n            if v:\n                if not in_run:\n                    in_run = True\n                    run_len = 1\n                else:\n                    run_len += 1\n            else:\n                if in_run:\n                    runs.append(run_len)\n                in_run = False\n        if in_run:\n            runs.append(run_len)\n        if len(runs) > 1 and any((rl <= w*0.6) for rl in runs):\n            strap_like += 1\n        count_rows += 1\n    return float(strap_like / count_rows) if count_rows > 0 else 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Skirt flare: (lower-quarter width - upper-quarter width) / upper-quarter width (positive for flared dresses)'\n    import numpy as np\n    eps = 1e-6\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    thr = max(np.mean(gray) * 0.5, np.max(gray) * 0.01)\n    mask = gray > thr\n    if not np.any(mask):\n        return 0.0\n    rows = np.any(mask, axis=1)\n    cols = np.any(mask, axis=0)\n    r_idx = np.where(rows)[0]; c_idx = np.where(cols)[0]\n    if r_idx.size == 0 or c_idx.size == 0:\n        return 0.0\n    top, bottom = r_idx[0], r_idx[-1]\n    height = bottom - top + 1\n    if height < 4:\n        return 0.0\n    q = max(1, height // 4)\n    upper_slice = mask[top:top+q, :]\n    lower_slice = mask[bottom-q+1:bottom+1, :]\n    def slice_width(slc):\n        cols_local = np.where(np.any(slc, axis=0))[0]\n        if cols_local.size == 0:\n            return 0.0\n        return float(cols_local[-1] - cols_local[0] + 1)\n    upper_w = slice_width(upper_slice)\n    lower_w = slice_width(lower_slice)\n    if upper_w < eps:\n        return float((lower_w - upper_w) / (eps))\n    return float((lower_w - upper_w) / upper_w)\n",
    "def feature(image: np.ndarray) -> float:\n    'Relative darkness of the four corner patches compared to center (positive => corners darker)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    ph = max(1, h // 8)\n    pw = max(1, w // 8)\n    corners = []\n    corners.append(gray[0:ph, 0:pw])\n    corners.append(gray[0:ph, w - pw:w])\n    corners.append(gray[h - ph:h, 0:pw])\n    corners.append(gray[h - ph:h, w - pw:w])\n    corner_mean = np.mean([np.mean(c) if c.size > 0 else 0.0 for c in corners])\n    ch = max(1, h // 4)\n    cw = max(1, w // 4)\n    center = gray[ch:3*ch, cw:3*cw]\n    center_mean = float(np.mean(center)) if center.size > 0 else float(np.mean(gray))\n    denom = np.maximum(np.mean(gray) + 1e-8, 1e-8)\n    return float((corner_mean - center_mean) / denom)\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Strength of a vertical central gap (mean drop in intensity in a narrow central column area) - detects open-front coats'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    mx = float(np.max(gray))\n    if mx == 0:\n        return 0.0\n    # take a narrow central column window\n    cw = max(1, w // 12)\n    cx = w // 2\n    left = max(0, cx - cw)\n    right = min(w, cx + cw + 1)\n    center_strip = gray[:, left:right]\n    center_mean_profile = np.mean(center_strip, axis=1)\n    # side strips average (left and right outside center)\n    side_w = max(1, w // 8)\n    left_strip = gray[:, :side_w]\n    right_strip = gray[:, -side_w:]\n    side_profile = 0.5 * (np.mean(left_strip, axis=1) + np.mean(right_strip, axis=1))\n    # compute maximum relative drop in center vs sides\n    diff = side_profile - center_mean_profile\n    # consider rows where side_profile is non-trivial\n    denom = np.mean(side_profile) if np.mean(side_profile) > 0 else mx\n    drop = np.max(diff) / denom\n    return float(max(0.0, drop))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Average horizontal half-width of mask in upper quarter relative to image half-width (sleeve spread)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 4 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = float(np.median(gray))\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    upper_h = max(1, h // 4)\n    rows = mask[:upper_h, :]\n    cx = (w - 1) / 2.0\n    half_widths = []\n    xs = np.arange(w)\n    for r in range(rows.shape[0]):\n        row = rows[r, :]\n        if np.any(row):\n            left = xs[row].min()\n            right = xs[row].max()\n            half_widths.append(max(0.0, min(cx, right - cx, cx - left)))\n    if len(half_widths) == 0:\n        return 0.0\n    avg_half = float(np.mean(half_widths))\n    return float(avg_half / (w / 2.0 + 1e-8))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Compactness measure: perimeter^2 / area for the foreground (larger = less compact)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    area = float(np.count_nonzero(mask))\n    if area < 1e-8:\n        return 0.0\n    m = mask.astype(bool)\n    # pad with False so borders count as edges\n    pm = np.pad(m, ((1, 1), (1, 1)), mode='constant', constant_values=False)\n    up = pm[:-2, 1:-1]\n    down = pm[2:, 1:-1]\n    left = pm[1:-1, :-2]\n    right = pm[1:-1, 2:]\n    interior = up & down & left & right\n    # boundary pixels: mask True but not interior\n    boundary = m & (~interior)\n    perimeter = float(np.count_nonzero(boundary))\n    compactness = (perimeter * perimeter) / area\n    return float(compactness)\n",
    "def feature(image: np.ndarray) -> float:\n    'Left-right symmetry score of the mask (1.0 = perfectly symmetric)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 50)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    m = mask.astype(bool)\n    flipped = np.fliplr(m)\n    area = np.count_nonzero(m)\n    if area == 0:\n        return 0.0\n    diff = np.count_nonzero(np.logical_xor(m, flipped))\n    score = 1.0 - float(diff) / float(area)\n    return float(max(0.0, min(1.0, score)))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Fraction of object mask area located in the bottom third of the image'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    total = np.count_nonzero(mask)\n    if total == 0:\n        return 0.0\n    bottom_start = (2 * h) // 3\n    bottom = np.count_nonzero(mask[bottom_start:, :])\n    return float(bottom) / float(total)\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Vertical symmetry score comparing top and flipped bottom (1.0 = identical)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 2 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    mx = np.max(gray) if np.max(gray) > 0 else 1.0\n    gray = gray / mx\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    ys, xs = np.where(mask)\n    if ys.size == 0:\n        return 0.0\n    miny, maxy = ys.min(), ys.max()\n    minx, maxx = xs.min(), xs.max()\n    crop = gray[miny:maxy+1, minx:maxx+1]\n    ch = crop.shape[0]\n    if ch <= 1:\n        return 0.0\n    mid = ch // 2\n    top = crop[:mid, :]\n    bottom = crop[-mid:, :] if mid > 0 else crop[:mid, :]\n    bottom_flipped = np.flipud(bottom)\n    mh = min(top.shape[0], bottom_flipped.shape[0])\n    if mh == 0 or top.size == 0 or bottom_flipped.size == 0:\n        return 0.0\n    top = top[:mh, :]\n    bottom_flipped = bottom_flipped[:mh, :]\n    diff = np.abs(top - bottom_flipped)\n    mean_diff = float(np.mean(diff))\n    sym = 1.0 - mean_diff\n    if sym < 0.0:\n        sym = 0.0\n    if sym > 1.0:\n        sym = 1.0\n    return float(sym)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Colorfulness: mean pairwise absolute channel differences (0 for grayscale)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    if len(image.shape) != 3 or image.shape[2] < 3:\n        return 0.0\n    img = image.astype(float)\n    r = img[:, :, 0]\n    g = img[:, :, 1]\n    b = img[:, :, 2]\n    val = np.mean(np.abs(r - g) + np.abs(r - b) + np.abs(g - b)) / 3.0\n    # normalize by max possible if values appear to be in [0,255] or [0,1]\n    mx = max(1.0, np.max(img) - np.min(img))\n    return float(val / (mx + 1e-8))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Normalized horizontal span of object pixels in the middle third (captures hip width vs waist)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape\n    thr = np.mean(gray) + 0.15 * np.std(gray)\n    mask = gray > thr\n    if not mask.any():\n        return 0.0\n    r0 = h // 3\n    r1 = min(h, 2 * h // 3)\n    region = mask[r0:r1, :]\n    cols = np.any(region, axis=0)\n    if not cols.any():\n        return 0.0\n    left = int(np.argmax(cols))\n    right = int(w - 1 - np.argmax(cols[::-1]))\n    width = max(0, right - left + 1)\n    return float(width / w)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Average gradient magnitude along the mask boundary normalized by image gradient max'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 2 or w < 2:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    # create mask\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    if not np.any(mask):\n        return 0.0\n    # gradient magnitude\n    gy, gx = np.gradient(gray)\n    grad = np.sqrt(gx * gx + gy * gy)\n    mg = np.max(grad)\n    # morphological erosion via neighbor AND (no wrap)\n    eroded = mask.copy()\n    for dr in (-1, 0, 1):\n        for dc in (-1, 0, 1):\n            if dr == 0 and dc == 0:\n                continue\n            rolled = np.roll(mask, shift=(dr, dc), axis=(0, 1))\n            if dr == -1:\n                rolled[-1, :] = False\n            if dr == 1:\n                rolled[0, :] = False\n            if dc == -1:\n                rolled[:, -1] = False\n            if dc == 1:\n                rolled[:, 0] = False\n            eroded &= rolled\n    boundary = mask & (~eroded)\n    if not np.any(boundary):\n        return 0.0\n    mean_edge = float(np.mean(grad[boundary]))\n    return float(mean_edge / (mg + 1e-8))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Fraction of background (no-mask) pixels in a small top-center patch (neck opening indicator)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 4 or w < 4:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 50)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    top_h = max(1, int(h * 0.20))\n    center_w = max(1, int(w * 0.20))\n    cx0 = max(0, (w // 2) - (center_w // 2))\n    cx1 = min(w, cx0 + center_w)\n    patch = mask[:top_h, cx0:cx1]\n    if patch.size == 0:\n        return 0.0\n    bg_frac = 1.0 - (float(np.count_nonzero(patch)) / float(patch.size))\n    return float(bg_frac)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Edge concentration in a bottom-center triangular region relative to whole-image edge energy'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 3 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    gy, gx = np.gradient(gray.astype(float))\n    grad_mag = np.sqrt(gx * gx + gy * gy)\n    mean_all = float(np.mean(grad_mag)) if grad_mag.size > 0 else 0.0\n    start_row = int(0.7 * h)\n    if start_row >= h:\n        start_row = max(0, h - 1)\n    tri_mask = np.zeros_like(grad_mag, dtype=bool)\n    for r in range(start_row, h):\n        rel = (r - start_row) / max(1.0, (h - 1 - start_row))\n        half_w = int((0.5 - 0.5 * rel) * w)  # narrowing toward top of triangle\n        cx = w // 2\n        left = max(0, cx - half_w)\n        right = min(w, cx + half_w)\n        if left < right:\n            tri_mask[r, left:right] = True\n    if not np.any(tri_mask):\n        return 0.0\n    mean_tri = float(np.mean(grad_mag[tri_mask]))\n    denom = max(1e-8, mean_all)\n    return float(mean_tri / denom)\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Colorfulness metric (Hasler-S\u00fcsstrunk) for RGB images, 0 for grayscale'\n    import numpy as np\n    if image is None:\n        return 0.0\n    if len(image.shape) != 3 or image.shape[2] < 3:\n        return 0.0\n    img = image.astype(float)\n    # Use only first three channels if extras exist\n    r = img[:, :, 0]\n    g = img[:, :, 1]\n    b = img[:, :, 2]\n    rg = r - g\n    yb = 0.5 * (r + g) - b\n    std_rg = np.std(rg)\n    std_yb = np.std(yb)\n    mean_rg = np.mean(rg)\n    mean_yb = np.mean(yb)\n    # Hasler and S\u00fcsstrunk colorfulness measure\n    colorfulness = np.sqrt(std_rg * std_rg + std_yb * std_yb) + 0.3 * np.sqrt(mean_rg * mean_rg + mean_yb * mean_yb)\n    if not np.isfinite(colorfulness):\n        return 0.0\n    return float(colorfulness)\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Edge orientation coherence (1 = all edges share same orientation)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 2 or w < 2:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    gy, gx = np.gradient(gray)\n    mag = np.hypot(gx, gy)\n    if not np.any(mag):\n        return 0.0\n    thresh = np.percentile(mag, 70)\n    strong = mag > thresh\n    if np.count_nonzero(strong) == 0:\n        return 0.0\n    angles = np.arctan2(gy[strong], gx[strong])\n    cos_sum = float(np.sum(np.cos(angles)))\n    sin_sum = float(np.sum(np.sin(angles)))\n    n = float(angles.size)\n    r = np.hypot(cos_sum, sin_sum) / (n + 1e-8)\n    # r in [0,1], higher means more coherent orientation\n    return float(r)\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Contrast between sleeve-end patches (left+right) and the center-mid patch (positive = sleeves brighter than center)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    thr = np.percentile(gray, 50)\n    mask = gray > thr\n    if np.count_nonzero(mask) == 0:\n        mask = gray > np.percentile(gray, 30)\n    if np.count_nonzero(mask) == 0:\n        # fall back to global simple contrast\n        return float((np.mean(gray[:, :w//5]) + np.mean(gray[:, -w//5:]))/2 - np.mean(gray[:, w//2-2:w//2+2]))\n    ys, xs = np.where(mask)\n    left, right = xs.min(), xs.max()\n    top, bottom = ys.min(), ys.max()\n    bw = max(1, right - left + 1)\n    bh = max(1, bottom - top + 1)\n    mid_row = top + bh // 2\n    # sleeve patches: small squares at far left and far right at mid_row\n    patch_h = max(1, bh // 8)\n    patch_w = max(1, bw // 8)\n    left_c = left + patch_w // 2\n    right_c = right - patch_w // 2\n    lr0 = max(0, mid_row - patch_h // 2)\n    lr1 = min(h, mid_row + patch_h // 2 + 1)\n    lc0 = max(0, left_c - patch_w // 2)\n    lc1 = min(w, left_c + patch_w // 2 + 1)\n    rc0 = max(0, right_c - patch_w // 2)\n    rc1 = min(w, right_c + patch_w // 2 + 1)\n    center_c = (left + right) // 2\n    cc0 = max(0, center_c - patch_w // 2)\n    cc1 = min(w, center_c + patch_w // 2 + 1)\n    left_patch = gray[lr0:lr1, lc0:lc1]\n    right_patch = gray[lr0:lr1, rc0:rc1]\n    center_patch = gray[lr0:lr1, cc0:cc1]\n    if left_patch.size == 0 or right_patch.size == 0 or center_patch.size == 0:\n        return 0.0\n    sleeves_mean = (np.mean(left_patch) + np.mean(right_patch)) / 2.0\n    center_mean = np.mean(center_patch)\n    denom = (np.std(gray) + 1e-6)\n    feat = (sleeves_mean - center_mean) / denom\n    return float(feat)\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Top-neck indicator: ratio of mean mask width in top 1/6 to next 1/6 (small = narrow neck)'\n    import numpy as np\n    if image is None:\n        return 1.0\n    h, w = image.shape[:2]\n    if h < 6 or w == 0:\n        return 1.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    top_h = max(1, h // 6)\n    next_h = max(1, h // 6)\n    top_region = mask[:top_h, :]\n    next_region = mask[top_h:top_h + next_h, :]\n    def mean_frac(region):\n        if region.size == 0:\n            return 0.0\n        widths = np.count_nonzero(region, axis=1).astype(float)\n        if widths.size == 0:\n            return 0.0\n        return float(np.mean(widths) / (float(w) + 1e-8))\n    top_w = mean_frac(top_region)\n    next_w = mean_frac(next_region)\n    return float((top_w + 1e-8) / (next_w + 1e-8))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Fraction of rows that contain two or more disjoint mask segments (indicates pant-leg or sandal separation)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    import numpy as np\n    h, w = image.shape[:2]\n    if h == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    multi_seg_rows = 0\n    for r in range(h):\n        row = mask[r, :].astype(int)\n        if np.any(row):\n            pad = np.concatenate(([0], row, [0]))\n            d = np.diff(pad)\n            starts = np.where(d == 1)[0]\n            ends = np.where(d == -1)[0]\n            seg_count = max(0, len(starts))\n            if seg_count >= 2:\n                multi_seg_rows += 1\n    return float(multi_seg_rows) / float(h)\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Normalized vertical position (-1..1) of the row with maximum mask coverage (peak row location)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = float(np.median(gray))\n    mask = ((gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)).astype(np.uint8)\n    row_counts = np.count_nonzero(mask, axis=1)\n    if np.all(row_counts == 0):\n        return 0.0\n    peak_row = float(np.argmax(row_counts))\n    center = (h - 1) / 2.0\n    norm = (peak_row - center) / max(1.0, h / 2.0)\n    return float(np.clip(norm, -1.0, 1.0))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Localized high-frequency edge density in the central upper area (sneaker laces produce localized dense edges)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape\n    # central upper box: top 40%, middle 50% columns\n    r0 = 0\n    r1 = max(1, int(0.4 * h))\n    c0 = max(0, int(0.25 * w))\n    c1 = min(w, int(0.75 * w))\n    patch = gray[r0:r1, c0:c1]\n    if patch.size == 0:\n        return 0.0\n    gy, gx = np.gradient(patch)\n    mag = np.sqrt(gx * gx + gy * gy)\n    # high-frequency measure: standard deviation of gradient magnitude\n    hf = float(np.std(mag))\n    # normalize by patch mean intensity scale\n    norm = (np.mean(patch) + 1e-8)\n    return hf / norm\n",
    "def feature(image: np.ndarray) -> float:\n    'Left-right symmetry score over the central vertical half (1.0 = perfect symmetry)'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    mn, mx = float(np.min(gray)), float(np.max(gray))\n    ptp = mx - mn\n    if ptp <= 1e-8:\n        return 1.0\n    norm = (gray - mn) / ptp\n    # focus on central vertical half to ignore borders\n    c1 = w // 4\n    c2 = w - c1\n    region = norm[:, c1:c2]\n    # mirror right half to left and compute normalized absolute difference\n    mid = region.shape[1] // 2\n    left = region[:, :mid]\n    right = region[:, -mid:][:, ::-1] if mid > 0 else region[:, :mid]\n    if left.size == 0 or right.size == 0:\n        return 1.0\n    diff = np.abs(left - right)\n    denom = np.sum(np.abs(left) + np.abs(right)) + 1e-8\n    score = 1.0 - (np.sum(diff) / denom)\n    return float(np.clip(score, 0.0, 1.0))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Hem left-right imbalance: absolute difference between left and right foreground centroid x positions in the bottom quarter (normalized by bbox width)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(np.float32), axis=2)\n    else:\n        gray = image.astype(np.float32)\n    mask = gray > np.percentile(gray, 65)\n    ys, xs = np.where(mask)\n    if ys.size == 0:\n        return 0.0\n    r0, r1 = ys.min(), ys.max()+1\n    c0, c1 = xs.min(), xs.max()+1\n    bbox_mask = mask[r0:r1, c0:c1]\n    h, w = bbox_mask.shape\n    if h < 2:\n        return 0.0\n    bottom_start = int(h*3/4)\n    bottom_mask = bbox_mask[bottom_start:, :]\n    if np.sum(bottom_mask) == 0:\n        return 0.0\n    cols = np.arange(c0, c1)\n    # compute left and right halves centroids in bottom region\n    left_half = bottom_mask[:, :w//2]\n    right_half = bottom_mask[:, w//2:]\n    left_cols = np.arange(0, left_half.shape[1])\n    right_cols = np.arange(w//2, w)\n    left_count = left_half.sum()\n    right_count = right_half.sum()\n    if left_count == 0 or right_count == 0:\n        # imbalance is maximal\n        return float(1.0)\n    left_centroid = np.sum((left_cols) * left_half.sum(axis=0)) / left_count\n    right_centroid = np.sum((right_cols) * right_half.sum(axis=0)) / right_count\n    # map centroids to same coordinate origin and take difference normalized by w\n    left_centroid_global = (left_centroid) / max(1.0, w)\n    right_centroid_global = (right_centroid) / max(1.0, w)\n    return float(abs(left_centroid_global - right_centroid_global))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Principal-axis elongation of the mask: ratio of largest to smallest eigenvalue of pixel covariance'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    ys, xs = np.where(mask)\n    n = ys.size\n    if n <= 1:\n        return 0.0\n    # coordinates centered\n    cy = np.mean(ys)\n    cx = np.mean(xs)\n    dy = ys - cy\n    dx = xs - cx\n    cov_yy = np.mean(dy * dy)\n    cov_xx = np.mean(dx * dx)\n    cov_xy = np.mean(dx * dy)\n    cov = np.array([[cov_yy, cov_xy], [cov_xy, cov_xx]], dtype=float)\n    # eigenvalues\n    vals = np.linalg.eigvalsh(cov)  # sorted ascending\n    small = float(max(vals[0], 1e-12))\n    large = float(max(vals[1], small))\n    ratio = large / small\n    return float(ratio)\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Contrast of a narrow top-center patch versus its left/right top-side neighbors (center_mean - sides_mean normalized by overall std)'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    h, w = gray.shape[:2]\n    # define small top strip (top 12% of height)\n    th = max(1, h // 8)\n    left = max(0, w // 6)\n    right = min(w, w - left)\n    center_w = max(1, w // 6)\n    cstart = max(left, (w // 2) - center_w // 2)\n    cend = min(right, cstart + center_w)\n    center_patch = gray[0:th, cstart:cend]\n    left_patch = gray[0:th, left:left + center_w]\n    right_patch = gray[0:th, right - center_w:right]\n    if center_patch.size == 0:\n        return 0.0\n    center_mean = float(np.mean(center_patch))\n    sides_mean = float(np.mean(np.concatenate([left_patch.flatten(), right_patch.flatten()]))) if (left_patch.size + right_patch.size) > 0 else 0.0\n    std_all = float(np.std(gray))\n    denom = std_all if std_all > 1e-6 else 1.0\n    return float((center_mean - sides_mean) / denom)\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Median contiguous mask run-length along rows (estimate of stroke/thickness), normalized by width'\n    import numpy as np\n    if image is None:\n        return 0.0\n    import numpy as np\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    run_lengths = []\n    for r in range(h):\n        row = mask[r, :].astype(int)\n        if np.any(row):\n            # find run lengths of contiguous ones\n            padded = np.concatenate([[0], row, [0]])\n            diffs = np.diff(padded)\n            starts = np.where(diffs == 1)[0]\n            ends = np.where(diffs == -1)[0]\n            lengths = (ends - starts).tolist()\n            run_lengths.extend(lengths)\n    if len(run_lengths) == 0:\n        return 0.0\n    med = float(np.median(np.array(run_lengths)))\n    return float(med / float(w + 1e-8))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Approximate solidity: object pixel count divided by vertical-column envelope area (proxy for convex hull solidity)'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    t = np.mean(gray) + 0.15 * (np.max(gray) - np.min(gray))\n    if t <= np.min(gray):\n        t = np.min(gray) + 1e-6\n    mask = gray > t\n    ys, xs = np.where(mask)\n    if ys.size == 0:\n        return 0.0\n    r0, r1 = ys.min(), ys.max()\n    c0, c1 = xs.min(), xs.max()\n    region = mask[r0:r1+1, c0:c1+1]\n    object_area = float(np.sum(region))\n    # approximate convex envelope by filling between topmost and bottommost foreground in each column\n    col_envelope_area = 0\n    for j in range(region.shape[1]):\n        col = region[:, j]\n        ys_col = np.where(col)[0]\n        if ys_col.size > 0:\n            col_envelope_area += float(ys_col.max() - ys_col.min() + 1)\n    if col_envelope_area <= 0:\n        return 0.0\n    return float(object_area / col_envelope_area)\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Vertical centroid of the foreground mask normalized by image height (0 = top, 1 = bottom)'\n    import numpy as np\n    if image is None:\n        return 0.5\n    h, w = image.shape[:2]\n    if h == 0:\n        return 0.5\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 50)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    ys = np.where(mask)[0]\n    if ys.size == 0:\n        return 0.5\n    centroid = float(np.mean(ys))\n    return float(centroid / float(max(1, h - 1)))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Mean number of mask segments across a shoulder band (~10-20% height), indicates sleeve separation'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 3 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 50)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    center_row = int(max(0, min(h - 1, int(0.15 * h))))\n    band =  max(1, h // 50)  # small band\n    start = max(0, center_row - band)\n    end = min(h, center_row + band + 1)\n    seg_counts = []\n    for r in range(start, end):\n        row = mask[r, :].astype(np.int8)\n        if np.all(row == 0):\n            seg_counts.append(0.0)\n            continue\n        dif = np.diff(np.concatenate(([0], row)))\n        starts = np.count_nonzero(dif == 1)\n        seg_counts.append(float(starts))\n    if len(seg_counts) == 0:\n        return 0.0\n    return float(np.mean(seg_counts))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Elongation ratio from PCA of object coordinates (major eigenvalue / minor eigenvalue), higher = more elongated vertically'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    h, w = gray.shape[:2]\n    maxv = float(np.max(gray)) if np.size(gray) else 0.0\n    if maxv <= 0:\n        return 0.0\n    thresh = maxv * 0.10\n    mask = gray > thresh\n    ys, xs = np.where(mask)\n    if ys.size < 3:\n        return 0.0\n    coords = np.vstack([ys.astype(float), xs.astype(float)])\n    cov = np.cov(coords)\n    # cov should be 2x2; handle degenerate\n    if cov.shape != (2, 2):\n        return 0.0\n    vals = np.linalg.eigvalsh(cov)\n    vals = np.maximum(vals, 1e-9)\n    ratio = float(vals[-1] / vals[0])\n    return ratio\n",
    "def feature(image: np.ndarray) -> float:\n    'Longest horizontal contiguous run of object pixels in the center row, normalized by width'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(np.float32)\n    else:\n        gray = image.astype(np.float32)\n    h, w = gray.shape[:2]\n    center_row = h // 2\n    thr = np.mean(gray) + 0.25 * (np.max(gray) - np.min(gray))\n    mask = gray > thr\n    if mask.shape[0] <= center_row:\n        center = mask[-1, :]\n    else:\n        center = mask[center_row, :]\n    if np.count_nonzero(center) == 0:\n        # fallback: use nearest row with pixels\n        rows = np.any(mask, axis=1)\n        if not np.any(rows):\n            return 0.0\n        row_idx = np.where(rows)[0][len(np.where(rows)[0]) // 2]\n        center = mask[row_idx, :]\n    # find longest run of True in center\n    longest = 0\n    current = 0\n    for v in center:\n        if v:\n            current += 1\n            if current > longest:\n                longest = current\n        else:\n            current = 0\n    return float(longest / float(w))\n",
    "def feature(image: np.ndarray) -> float:\n    'Left-right symmetry score based on column sums (1.0 = perfectly symmetric, 0.0 = maximally asymmetric)'\n    h, w = image.shape[:2]\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    if gray.max() > 0:\n        gray /= gray.max()\n    thr = np.percentile(gray, 80)\n    mask = (gray > thr).astype(float)\n    if mask.sum() == 0:\n        thr = np.mean(gray)\n        mask = (gray > thr).astype(float)\n    if mask.sum() == 0:\n        return 0.0\n    col_sum = np.sum(mask, axis=0)\n    # compare left half to mirrored right half\n    mid = w // 2\n    left = col_sum[:mid]\n    right = col_sum[w - mid:][::-1] if mid > 0 else np.array([])\n    if left.size == 0 or right.size == 0:\n        return 0.0\n    # align lengths\n    L = min(left.size, right.size)\n    diff = np.sum(np.abs(left[:L] - right[:L]))\n    total = np.sum(left[:L] + right[:L]) + 1e-9\n    symmetry = 1.0 - (diff / total)\n    return float(max(0.0, min(1.0, symmetry)))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Area to edge-pixel ratio (compactness): object pixel count divided by number of strong edge pixels'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    gy, gx = np.gradient(gray)\n    grad = np.hypot(gx, gy)\n    thr = np.mean(grad) + 0.7 * np.std(grad)\n    edges = grad > thr\n    # binary object (simple threshold)\n    obj_thr = np.mean(gray) + 0.05 * np.std(gray)\n    obj = gray > obj_thr\n    area = float(np.count_nonzero(obj))\n    edge_count = float(np.count_nonzero(edges))\n    if edge_count < 1e-6:\n        return float(area)\n    return float(area / edge_count)\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Standard deviation of gradient magnitude normalized by mean intensity (texture roughness)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 2 or w < 2:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    gy, gx = np.gradient(gray.astype(float))\n    mag = np.sqrt(gx * gx + gy * gy)\n    if not np.any(mag):\n        return 0.0\n    std_mag = float(np.std(mag))\n    denom = (np.mean(gray) + 1e-8)\n    return float(std_mag / denom)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Left-right symmetry of the foreground mask (Jaccard overlap with horizontal flip)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    # grayscale conversion\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 50)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    if not np.any(mask):\n        return 0.0\n    flipped = np.fliplr(mask)\n    inter = np.count_nonzero(mask & flipped)\n    union = np.count_nonzero(mask | flipped)\n    if union == 0:\n        return 0.0\n    return float(inter / union)\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Ratio of average object width in the top quarter to the bottom quarter (top_width / bottom_width)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    maxv = float(gray.max()) if gray.size else 0.0\n    if maxv <= 0 or h < 4:\n        return 0.0\n    mask = gray > (0.2 * maxv)\n    top_rows = slice(0, max(1, h//4))\n    bottom_rows = slice(max(1, 3*h//4), h)\n    top_widths = np.count_nonzero(mask[top_rows, :], axis=1).astype(float)\n    bottom_widths = np.count_nonzero(mask[bottom_rows, :], axis=1).astype(float)\n    top_mean = float(top_widths.mean()) if top_widths.size else 0.0\n    bottom_mean = float(bottom_widths.mean()) if bottom_widths.size else 0.0\n    return float(top_mean / (bottom_mean + 1e-6))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Toe taper slope: linear slope of object row widths in the bottom portion of the bounding box (negative for narrowing toward tip)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    thr = np.mean(gray) + 0.2 * (np.max(gray) - np.min(gray))\n    mask = gray > thr\n    if np.count_nonzero(mask) == 0:\n        mask = gray > np.mean(gray)\n    if np.count_nonzero(mask) == 0:\n        return 0.0\n    rows, cols = np.where(mask)\n    rmin, rmax = rows.min(), rows.max()\n    heights = rmax - rmin + 1\n    # use bottom 40% of bounding box for taper analysis\n    k = max(2, int(np.ceil(0.4 * heights)))\n    start = max(rmin, rmax - k + 1)\n    y = []\n    x = []\n    for r in range(start, rmax + 1):\n        row = mask[r, :]\n        if np.any(row):\n            c = np.where(row)[0]\n            width = c.max() - c.min() + 1\n            y.append(r - start)  # independent variable (distance from bottom sample start)\n            x.append(width)\n    if len(x) < 2:\n        return 0.0\n    # slope of width vs row (rows increasing upward), normalize by image width\n    slope = np.polyfit(y, x, 1)[0]\n    w = gray.shape[1]\n    return float(slope / max(1.0, w))\n",
    "def feature(image: np.ndarray) -> float:\n    'Mask compactness: mask area divided by bounding-box area (0..1, 1 = full rectangle)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    ys, xs = np.where(mask)\n    area = float(ys.size)\n    if area == 0:\n        return 0.0\n    miny, maxy = int(np.min(ys)), int(np.max(ys))\n    minx, maxx = int(np.min(xs)), int(np.max(xs))\n    bbox_h = max(1, maxy - miny + 1)\n    bbox_w = max(1, maxx - minx + 1)\n    bbox_area = float(bbox_h * bbox_w)\n    if bbox_area <= 0:\n        return 0.0\n    return float(area / bbox_area)\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Mean gradient magnitude in the upper-central region normalized by global image std (captures laces/textured uppers)'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape\n    std = gray.std() if gray.std() > 1e-6 else 1.0\n    span = gray.max() - gray.min()\n    thr = np.mean(gray) + 0.15 * span\n    mask = gray > thr\n    if np.count_nonzero(mask) < 10:\n        thr = np.percentile(gray, 70)\n        mask = gray > thr\n    if np.count_nonzero(mask) == 0:\n        return 0.0\n    rows = np.where(mask.any(axis=1))[0]\n    cols = np.where(mask.any(axis=0))[0]\n    if rows.size == 0 or cols.size == 0:\n        return 0.0\n    top, bottom = rows[0], rows[-1]\n    left, right = cols[0], cols[-1]\n    bh = bottom - top + 1\n    bw = right - left + 1\n    # upper-central rectangle: top 10%-50% vertically and center half horizontally\n    r0 = top + int(0.10 * bh)\n    r1 = top + int(0.50 * bh)\n    c0 = left + int(0.25 * bw)\n    c1 = left + int(0.75 * bw)\n    r0 = max(top, min(r0, bottom))\n    r1 = max(r0+1, min(r1, bottom))\n    c0 = max(left, min(c0, right))\n    c1 = max(c0+1, min(c1, right))\n    region = gray[r0:r1, c0:c1]\n    if region.size == 0:\n        return 0.0\n    gy, gx = np.gradient(region)\n    grad = np.sqrt(gx**2 + gy**2)\n    return float(np.mean(grad) / std)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Bounding-box height fraction: bounding box height relative to image height'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    ys = np.where(mask)[0]\n    if ys.size == 0:\n        return 0.0\n    bbox_h = float(ys.max() - ys.min() + 1)\n    return float(bbox_h / float(h))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Mean gradient magnitude inside the foreground mask normalized by image diagonal'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 2 or w < 2:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    gy, gx = np.gradient(gray.astype(float))\n    mag = np.sqrt(gx * gx + gy * gy)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    if not np.any(mask):\n        return 0.0\n    mean_mag = float(np.mean(mag[mask]))\n    diag = np.sqrt(float(h * h + w * w))\n    return float(mean_mag / (diag + 1e-8))\n",
    "def feature(image: np.ndarray) -> float:\n    'Fraction of mask pixels that lie in the bottom quarter of the image (useful for shoes/boots)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 50)\n    mask = gray < thr if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else gray > thr\n    total = np.count_nonzero(mask)\n    if total == 0:\n        return 0.0\n    bottom_region = mask[int(0.75*h):h, :]\n    bottom_count = np.count_nonzero(bottom_region)\n    return float(bottom_count) / float(total)\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Ratio of top corner mass (sum in top-left and top-right squares) to top-center mass (helps indicate shoulder bulk)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    th = max(1, h // 6)\n    tw = max(1, w // 6)\n    top_left = gray[0:th, 0:tw].sum()\n    top_right = gray[0:th, w-tw:w].sum()\n    top_center = gray[0:th, max(0, w//2 - tw//2):min(w, w//2 + tw//2)].sum() + 1e-8\n    ratio = (top_left + top_right) / top_center\n    return float(ratio)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Median vertical run length of foreground per column normalized by image height (long runs -> pants)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    col_means = []\n    for x in range(w):\n        col = mask[:, x].astype(int)\n        if np.all(col == 0):\n            continue\n        # find run lengths\n        padded = np.concatenate(([0], col, [0]))\n        diff = np.diff(padded)\n        starts = np.where(diff == 1)[0]\n        ends = np.where(diff == -1)[0]\n        runs = (ends - starts).astype(float)\n        if runs.size > 0:\n            col_means.append(np.mean(runs))\n    if len(col_means) == 0:\n        return 0.0\n    med = float(np.median(np.array(col_means)))\n    return float(med / float(h))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Left-right symmetry score (normalized L1 difference between left and mirrored right), lower = more symmetric'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    # center crop to reduce empty borders\n    margin_h = max(1, h // 10)\n    margin_w = max(1, w // 10)\n    sub = gray[margin_h:h - margin_h, margin_w:w - margin_w]\n    if sub.size == 0:\n        sub = gray\n    # resize conceptually by flipping half\n    half = w // 2 - margin_w\n    if half <= 1:\n        left = sub\n        right = np.fliplr(sub)\n    else:\n        left = sub[:, :sub.shape[1] // 2]\n        right = np.fliplr(sub[:, sub.shape[1] - left.shape[1]:sub.shape[1]])\n    # pad to same shape if needed\n    min_h = min(left.shape[0], right.shape[0])\n    min_w = min(left.shape[1], right.shape[1])\n    left = left[:min_h, :min_w]\n    right = right[:min_h, :min_w]\n    denom = np.sum(np.abs(left)) + np.sum(np.abs(right)) + 1e-8\n    score = np.sum(np.abs(left - right)) / denom\n    return float(score)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Average per-row transition count normalized by image width (complexity across rows)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w <= 1:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    # compute transitions per row\n    diffs = np.abs(np.diff(mask.astype(np.int8), axis=1))\n    transitions_per_row = np.sum(diffs, axis=1).astype(float)\n    # normalize by width\n    avg_trans = float(np.mean(transitions_per_row) / float(w))\n    return float(avg_trans)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Normalized horizontal centroid offset (positive => object more to the right)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 50)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    total = np.count_nonzero(mask)\n    if total == 0:\n        return 0.0\n    xs = np.arange(w).reshape(1, w)\n    cx = float(np.sum(mask * xs) / float(total))\n    center_x = (w - 1) / 2.0\n    return float((cx - center_x) / max(1.0, w / 2.0))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Fraction of object pixels that lie in the bottom half of the image (coats tend to have larger values)'\n    import numpy as np\n    gray = np.mean(image, axis=2) if len(image.shape) == 3 else image.astype(float)\n    h, w = gray.shape[:2]\n    vmin, vmax = float(np.min(gray)), float(np.max(gray))\n    if vmax == vmin:\n        return 0.0\n    mn, md = float(np.mean(gray)), float(np.median(gray))\n    fg_brighter = mn > md\n    rng = vmax - vmin\n    if fg_brighter:\n        thresh = md + 0.04 * rng\n        mask = gray > thresh\n    else:\n        thresh = md - 0.04 * rng\n        mask = gray < thresh\n    mask = mask.astype(np.uint8)\n    total = mask.sum()\n    if total == 0:\n        return 0.0\n    bottom = mask[h // 2 :, :].sum()\n    return float(bottom / total)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Bottom indentation depth: average center bottom y higher than side bottoms (normalized)'\n    import numpy as np\n    gray = np.mean(image, axis=2) if len(image.shape) == 3 else image.astype(float)\n    h, w = gray.shape[:2]\n    thr = np.percentile(gray.flatten(), 5)\n    mask = gray > thr\n    if not mask.any():\n        return 0.0\n    bottom_y = np.full(w, h, dtype=int)\n    for col in range(w):\n        rows = np.where(mask[:, col])[0]\n        if rows.size:\n            bottom_y[col] = rows[-1]\n    left_cols = slice(0, max(1, w // 10))\n    right_cols = slice(max(0, w - w // 10), w)\n    center_cols = slice(max(0, w // 3), min(w, 2 * w // 3))\n    left_mean = np.mean(bottom_y[left_cols]) if np.any(bottom_y[left_cols] < h) else h\n    right_mean = np.mean(bottom_y[right_cols]) if np.any(bottom_y[right_cols] < h) else h\n    center_mean = np.mean(bottom_y[center_cols]) if np.any(bottom_y[center_cols] < h) else h\n    edge_mean = (left_mean + right_mean) / 2.0\n    depth = edge_mean - center_mean\n    return float(depth / max(1.0, h))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Left-right symmetry score of intensity (1 = perfect symmetry, 0 = totally asymmetric)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w < 2:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    mid = w // 2\n    left = gray[:, :mid]\n    right = gray[:, -mid:]\n    # flip right horizontally to compare\n    right_flip = np.fliplr(right)\n    # If widths differ (odd width), crop to smallest\n    minw = min(left.shape[1], right_flip.shape[1])\n    left = left[:, :minw]\n    right_flip = right_flip[:, :minw]\n    num = np.sum(np.abs(left - right_flip))\n    den = np.sum(np.abs(left) + np.abs(right_flip)) + 1e-8\n    # similarity in [0,1]\n    sim = 1.0 - (num / den)\n    return float(max(0.0, min(1.0, sim)))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Fractional horizontal span of object pixels in the bottom quarter (width/total_width)'\n    import numpy as np\n    gray = np.mean(image, axis=2) if len(image.shape) == 3 else image.astype(float)\n    h, w = gray.shape[:2]\n    if h < 4 or np.all(gray == 0):\n        return 0.0\n    th = np.percentile(gray, 75)\n    mask = gray > th\n    bottom_q = mask[3*h//4:, :]\n    if not bottom_q.any():\n        return 0.0\n    cols_with_pixels = np.where(bottom_q.any(axis=0))[0]\n    span = cols_with_pixels.max() - cols_with_pixels.min() + 1 if cols_with_pixels.size else 0\n    return float(span / max(1, w))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Fraction of object pixels in the outer lateral bands of the upper quarter (captures sleeve prominence)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    try:\n        thresh = np.percentile(gray, 75)\n    except Exception:\n        thresh = np.mean(gray)\n    mask = (gray >= thresh)\n    if not np.any(mask):\n        mask = gray > np.mean(gray)\n        if not np.any(mask):\n            return 0.0\n    rows = np.any(mask, axis=1)\n    cols = np.any(mask, axis=0)\n    if not np.any(rows) or not np.any(cols):\n        return 0.0\n    r0, r1 = np.where(rows)[0][[0, -1]]\n    c0, c1 = np.where(cols)[0][[0, -1]]\n    bh, bw = r1 - r0 + 1, c1 - c0 + 1\n    upper_h = max(1, bh // 4)\n    crop = mask[r0:r0+upper_h, c0:c1+1]\n    if crop.size == 0:\n        return 0.0\n    band_w = max(1, bw // 6)  # outer band width\n    left_band = crop[:, :band_w]\n    right_band = crop[:, -band_w:]\n    outer = left_band.sum() + right_band.sum()\n    total = crop.sum()\n    if total == 0:\n        return 0.0\n    return float(outer / total)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Normalized mean absolute horizontal symmetry error for the top 25% rows (lower is more symmetric)'\n    try:\n        import numpy as _np\n        gray = _np.mean(image, axis=2) if len(image.shape) == 3 else image.astype(_np.float32)\n        h, w = gray.shape[:2]\n        rows = max(1, h // 4)\n        top = gray[:rows, :]\n        # normalize intensities to 0..1 range for comparison robustness\n        mn, mx = float(_np.min(top)), float(_np.max(top))\n        if mx - mn > 0:\n            norm = (top - mn) / (mx - mn)\n        else:\n            norm = top - mn\n        flipped = _np.fliplr(norm)\n        # crop to same width (they are same)\n        diff = _np.abs(norm - flipped)\n        return float(_np.mean(diff))\n    except Exception:\n        return 1.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Depth of the valley between shoulder peaks in the top quarter horizontal projection (normalized)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    top_h = max(1, h // 4)\n    top = gray[:top_h, :]\n    thr = np.mean(gray) + 0.15 * (np.max(gray) - np.mean(gray))\n    proj = np.sum(top > thr, axis=0).astype(float)  # horizontal projection in top quarter\n    if w < 3 or np.sum(proj) == 0:\n        return 0.0\n    # find two highest peaks (shoulders) separated by at least 10% width\n    peaks_idx = np.argsort(proj)[-min(4, w):][::-1]\n    peaks = sorted(peaks_idx)\n    if len(peaks) < 2:\n        return 0.0\n    # choose two peaks farthest apart\n    best_pair = (peaks[0], peaks[-1])\n    left_p, right_p = best_pair\n    if right_p == left_p:\n        return 0.0\n    valley = float(np.min(proj[left_p:right_p+1]))\n    peak_mean = (float(proj[left_p]) + float(proj[right_p])) / 2.0 + 1e-9\n    depth = (peak_mean - valley) / peak_mean\n    return float(np.clip(depth, 0.0, 1.0))\n",
    "def feature(image: np.ndarray) -> float:\n    'Simple colorfulness score: sum of absolute differences between RGB channel means (0 for grayscale)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    if len(image.shape) != 3:\n        return 0.0\n    h, w, c = image.shape\n    if c < 3 or h == 0 or w == 0:\n        return 0.0\n    arr = image.astype(float)\n    r_mean = float(np.mean(arr[:, :, 0]))\n    g_mean = float(np.mean(arr[:, :, 1]))\n    b_mean = float(np.mean(arr[:, :, 2]))\n    score = abs(r_mean - g_mean) + abs(r_mean - b_mean) + abs(g_mean - b_mean)\n    # normalize by dynamic range\n    denom = float(np.max(arr) - np.min(arr) + 1e-8)\n    return float(score / denom)\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Relative vertical offset between outer sleeve tops and central shoulder top (positive = sleeves lower); normalized by bbox height'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    mn, mx = gray.min(), gray.max()\n    denom = (mx - mn) if mx != mn else 1.0\n    norm = (gray - mn) / denom\n    mask = norm > 0.12\n    if not mask.any():\n        return 0.0\n    rows = np.any(mask, axis=1); cols = np.any(mask, axis=0)\n    r = np.where(rows)[0]; c = np.where(cols)[0]\n    if r.size == 0 or c.size == 0:\n        return 0.0\n    top, bottom = r[0], r[-1]\n    left, right = c[0], c[-1]\n    bbox_h = bottom - top + 1\n    # consider upper quarter rows\n    upper_end = min(bottom, top + max(1, bbox_h // 3))\n    upper = mask[top:upper_end+1, left:right+1]\n    if upper.size == 0:\n        return 0.0\n    # find highest object pixel per column\n    col_tops = []\n    for j in range(upper.shape[1]):\n        col = upper[:, j]\n        ys = np.where(col)[0]\n        if ys.size:\n            col_tops.append(int(ys[0]))\n    if len(col_tops) == 0:\n        return 0.0\n    # columns near left and right edges correspond to sleeves\n    n = len(col_tops)\n    left_avg = np.mean(col_tops[:max(1, n//6)])\n    right_avg = np.mean(col_tops[-max(1, n//6):])\n    center_idx = n // 2\n    center_avg = np.mean(col_tops[max(0, center_idx - n//12): min(n, center_idx + n//12 + 1)])\n    # convert to image coordinates (relative to top)\n    left_y = top + left_avg\n    right_y = top + right_avg\n    center_y = top + center_avg\n    sleeve_drop = max(0.0, ((left_y + right_y) / 2.0) - center_y)\n    return float(sleeve_drop) / float(bbox_h)\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Average number of foreground/background horizontal transitions per row in the top half normalized by width'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 2 or w < 2:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 50)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    top = mask[:max(1, h // 2), :]\n    rows = top.shape[0]\n    if rows == 0:\n        return 0.0\n    trans = 0.0\n    for r in range(rows):\n        row = top[r, :].astype(np.uint8)\n        trans += float(np.count_nonzero(row[:-1] != row[1:]))\n    avg_trans = trans / float(rows)\n    return float(avg_trans / float(w))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Left-right vertical symmetry score (1.0 = perfect symmetry)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w < 2:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    # split left and right (drop middle column if odd)\n    mid = w // 2\n    if w % 2 == 0:\n        left = gray[:, :mid]\n        right = gray[:, mid:]\n    else:\n        left = gray[:, :mid]\n        right = gray[:, mid+1:]\n    # make shapes equal\n    minw = min(left.shape[1], right.shape[1])\n    if minw == 0:\n        return 0.0\n    left = left[:, :minw]\n    right = right[:, :minw]\n    right_flipped = np.fliplr(right)\n    diff = np.abs(left - right_flipped)\n    norm = (np.mean(np.abs(gray)) + 1e-8)\n    score = 1.0 - (np.mean(diff) / norm)\n    return float(np.clip(score, 0.0, 1.0))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Ratio of mid-torso local gradient energy to average of symmetric side boxes (highfreq texture contrast)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    gy, gx = np.gradient(gray)\n    gradmag = np.sqrt(gx**2 + gy**2)\n    thresh = (np.min(gray) + np.mean(gray)) / 2.0\n    mask = gray > thresh\n    if np.count_nonzero(mask) == 0:\n        return 0.0\n    rows, cols = np.where(mask)\n    rmin, rmax = rows.min(), rows.max()\n    cmin, cmax = cols.min(), cols.max()\n    height = rmax - rmin + 1\n    width = cmax - cmin + 1\n    if height <= 0 or width <= 0:\n        return 0.0\n    mid_h = max(1, height // 4)\n    mid_w = max(1, width // 4)\n    mid_box = gradmag[rmin + height//3 : rmin + height//3 + mid_h, cmin + width//3 : cmin + width//3 + mid_w]\n    left_box = gradmag[rmin + height//3 : rmin + height//3 + mid_h, cmin : cmin + mid_w]\n    right_box = gradmag[rmin + height//3 : rmin + height//3 + mid_h, cmax - mid_w + 1 : cmax + 1]\n    mid_mean = np.mean(mid_box) if mid_box.size > 0 else 0.0\n    side_mean = (np.mean(left_box) + np.mean(right_box)) / 2.0 if (left_box.size + right_box.size) > 0 else 0.0\n    eps = 1e-8\n    return float(mid_mean / (side_mean + eps))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Median horizontal run-length of foreground per row normalized by image width'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    runs = []\n    for r in range(h):\n        row = mask[r, :].astype(np.uint8)\n        if not np.any(row):\n            continue\n        padded = np.pad(row, (1, 1), mode='constant', constant_values=0)\n        diff = np.diff(padded.astype(int))\n        starts = np.where(diff == 1)[0]\n        ends = np.where(diff == -1)[0]\n        lengths = (ends - starts).astype(float)\n        if lengths.size:\n            runs.extend(lengths.tolist())\n    if len(runs) == 0:\n        return 0.0\n    med = float(np.median(np.array(runs)))\n    return float(med / (w + 1e-8))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Left-right symmetry score based on mask (1 = perfect symmetry, 0 = no symmetry)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 1 or w < 1:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 50)\n    mask = ((gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)).astype(float)\n    mid = w // 2\n    left = mask[:, :mid]\n    if w % 2 == 0:\n        right = mask[:, mid:]\n    else:\n        right = mask[:, mid + 1:]\n    if left.size == 0 or right.size == 0:\n        return 0.0\n    # flip right horizontally and crop/pad to match\n    right_flipped = np.fliplr(right)\n    # match widths\n    minw = min(left.shape[1], right_flipped.shape[1])\n    left_c = left[:, :minw]\n    right_c = right_flipped[:, :minw]\n    diff = np.abs(left_c - right_c)\n    denom = np.sum(left_c + right_c) + 1e-8\n    score = 1.0 - (np.sum(diff) / denom)\n    return float(max(0.0, min(1.0, score)))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Normalized left-right mass difference (positive => more mass on left)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 50)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    total = float(np.count_nonzero(mask))\n    if total == 0.0:\n        return 0.0\n    mid = w // 2\n    left_count = float(np.count_nonzero(mask[:, :mid]))\n    right_count = float(np.count_nonzero(mask[:, mid:]))\n    return float((left_count - right_count) / (total + 1e-8))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Normalized contrast between mean foreground and mean background intensities (-1..1)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 50)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    if not np.any(mask):\n        return 0.0\n    fg_mean = float(np.mean(gray[mask]))\n    bg = gray[~mask]\n    if bg.size == 0:\n        return 0.0\n    bg_mean = float(np.mean(bg))\n    return float((fg_mean - bg_mean) / (abs(fg_mean) + abs(bg_mean) + 1e-8))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Count of vertical connected row segments of the mask normalized by image height (higher => separated parts)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h <= 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 60)\n    mask = gray < thr if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else gray > thr\n    row_has = np.any(mask, axis=1).astype(int)\n    if row_has.sum() == 0:\n        return 0.0\n    diff = np.diff(np.concatenate(([0], row_has, [0])))\n    starts = np.where(diff == 1)[0]\n    ends = np.where(diff == -1)[0]\n    segments = max(0, len(starts))\n    return float(segments) / max(1.0, float(h))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Fraction of foreground pixels located in the bottom quarter of the image'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    total = float(np.count_nonzero(mask))\n    if total <= 0:\n        return 0.0\n    bottom_start = int(h * 3 // 4)\n    bottom_count = float(np.count_nonzero(mask[bottom_start:h, :]))\n    return float(bottom_count / total)\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Perimeter-to-area ratio of the foreground mask (higher for elongated/complex shapes)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 50)\n    mask = ((gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)).astype(np.uint8)\n    area = float(np.count_nonzero(mask))\n    if area == 0:\n        return 0.0\n    # compute perimeter by counting boundary pixels via xor with shifted masks\n    p = 0\n    # vertical boundaries\n    p += np.count_nonzero(mask[:, :-1] != mask[:, 1:])\n    # horizontal boundaries\n    p += np.count_nonzero(mask[:-1, :] != mask[1:, :])\n    perimeter = float(p)\n    return float(perimeter / (area + 1e-8))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Slope magnitude of the left shoulder edge across the top quarter (normalized by width)'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    mn, mx = float(np.min(gray)), float(np.max(gray))\n    if mx == mn:\n        return 0.0\n    thr = (mx + mn) / 2.0\n    mask = gray > thr\n    if not np.any(mask):\n        return 0.0\n    top_quarter = max(1, h // 4)\n    ys = []\n    xs = []\n    for r in range(0, top_quarter):\n        row = mask[r, :]\n        if np.any(row):\n            left = np.argmax(row)\n            ys.append(r)\n            xs.append(left)\n    if len(xs) < 2:\n        return 0.0\n    # linear fit slope\n    xs = np.array(xs, dtype=float)\n    ys = np.array(ys, dtype=float)\n    A = np.vstack([ys, np.ones_like(ys)]).T\n    m, _ = np.linalg.lstsq(A, xs, rcond=None)[0]\n    # normalize by width (slope in pixels per row normalized)\n    norm = abs(m) / float(w) * top_quarter\n    return float(norm)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Average number of vertical transitions (background<->foreground) per column normalized by height'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h <= 1 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 50)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    transitions = 0.0\n    for c in range(w):\n        col = mask[:, c].astype(int)\n        transitions += float(np.sum(np.abs(np.diff(col))))\n    avg_trans = transitions / float(w + 1e-8)\n    return float(avg_trans / (h + 1e-8))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Left-right mass imbalance in center band (absolute difference normalized by total)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 3 or w < 2:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 50)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    start = int(0.30 * h)\n    end = int(0.70 * h)\n    band = mask[start:end, :]\n    if band.size == 0:\n        return 0.0\n    mid = w // 2\n    left_sum = float(np.count_nonzero(band[:, :mid]))\n    right_sum = float(np.count_nonzero(band[:, mid:]))\n    total = left_sum + right_sum\n    if total <= 0.0:\n        return 0.0\n    return float(abs(left_sum - right_sum) / total)\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Fraction of image occupied by the foreground bounding box (bbox area / image area)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 50)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    ys, xs = np.where(mask)\n    if ys.size == 0:\n        return 0.0\n    ymin, ymax = int(np.min(ys)), int(np.max(ys))\n    xmin, xmax = int(np.min(xs)), int(np.max(xs))\n    bbox_area = float(max(1, (ymax - ymin + 1)) * max(1, (xmax - xmin + 1)))\n    img_area = float(h * w)\n    return float(bbox_area / (img_area + 1e-8))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Fraction of rows that have strong horizontal edge energy (indicates belts, hems, or separations)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 3 or w < 1:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    gy, gx = np.gradient(gray.astype(float))\n    edge_mag = np.abs(gy) + np.abs(gx)\n    # row energy\n    row_energy = np.mean(edge_mag, axis=1)\n    thr = np.percentile(row_energy, 75)\n    strong_rows = np.count_nonzero(row_energy > thr)\n    result = float(strong_rows) / float(h)\n    return float(result)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Average mask width in upper quarter divided by average width in lower quarter'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 4 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    q = max(1, h // 4)\n    upper_rows = mask[:q, :]\n    lower_rows = mask[-q:, :]\n    up_widths = np.sum(upper_rows.astype(float), axis=1)\n    low_widths = np.sum(lower_rows.astype(float), axis=1)\n    up_avg = float(np.mean(up_widths)) if up_widths.size > 0 else 0.0\n    low_avg = float(np.mean(low_widths)) if low_widths.size > 0 else 0.0\n    if low_avg <= 0:\n        return 0.0\n    return float((up_avg + 1e-8) / (low_avg + 1e-8))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Horizontal spread (std) of bottom-quarter object pixels normalized by bounding-box width'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape\n    maxv = float(np.max(gray))\n    if maxv == 0:\n        return 0.0\n    mask = gray > (maxv * 0.05)\n    ys, xs = np.where(mask)\n    if ys.size == 0:\n        return 0.0\n    rmin, rmax = ys.min(), ys.max()\n    cmin, cmax = xs.min(), xs.max()\n    bbox_h = max(1, rmax - rmin + 1)\n    bbox_w = max(1, cmax - cmin + 1)\n    bottom_start = max(rmin, rmax - max(1, bbox_h // 4) + 1)\n    bottom_mask = mask[bottom_start:rmax + 1, cmin:cmax + 1]\n    ys_b, xs_b = np.where(bottom_mask)\n    if xs_b.size == 0:\n        return 0.0\n    # xs_b are relative to cmin; normalize by bbox_w\n    xs_abs = xs_b.astype(float) / float(bbox_w)\n    spread = float(np.std(xs_abs))\n    return float(spread)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Mean absolute horizontal gradient magnitude in the top 12% of the object bbox (collars/handles create strong top edges)'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    low, high = np.percentile(gray, 5), np.percentile(gray, 95)\n    if high - low <= 1e-6:\n        return 0.0\n    thresh = (low + high) / 2.0\n    fg = gray < thresh\n    if not np.any(fg):\n        return 0.0\n    ys, xs = np.where(fg)\n    y0, y1 = ys.min(), ys.max()\n    x0, x1 = xs.min(), xs.max()\n    bh = max(1, y1 - y0 + 1)\n    top_h = max(1, int(bh * 0.12))\n    top_region = gray[y0:y0 + top_h, x0:x1 + 1]\n    # horizontal gradient\n    gx = np.abs(np.gradient(top_region, axis=1))\n    if gx.size == 0:\n        return 0.0\n    return float(np.mean(gx))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Edge contrast ratio: mean gradient magnitude in border vs center (higher => stronger border)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 3 or w < 3:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    gy, gx = np.gradient(gray)\n    grad = np.sqrt(gx * gx + gy * gy)\n    b = int(max(1, round(min(h, w) * 0.12)))\n    top = grad[:b, :]\n    bottom = grad[-b:, :]\n    left = grad[:, :b]\n    right = grad[:, -b:]\n    border_vals = np.concatenate([top.flatten(), bottom.flatten(), left.flatten(), right.flatten()])\n    ch = int(max(1, h // 4))\n    cw = int(max(1, w // 4))\n    center_vals = grad[ch:-ch or None, cw:-cw or None].flatten()\n    mean_border = float(np.mean(border_vals)) if border_vals.size > 0 else 0.0\n    mean_center = float(np.mean(center_vals)) if center_vals.size > 0 else 0.0\n    result = mean_border / (mean_center + 1e-8)\n    return float(result)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Neckline central gap: difference between center-top patch intensity and surrounding upper patch (positive if center is darker)'\n    try:\n        if len(image.shape) == 3:\n            gray = np.mean(image.astype(float), axis=2)\n        else:\n            gray = image.astype(float)\n    except Exception:\n        return 0.0\n    h, w = gray.shape[:2]\n    if h < 3 or w < 3:\n        return float(np.mean(gray))\n    top_h = max(1, h // 6)\n    center_w = max(1, w // 6)\n    center_col_start = w // 2 - center_w // 2\n    center_patch = gray[:top_h, center_col_start:center_col_start + center_w]\n    # surrounding patches: left and right of center (same size), clipped inside image\n    left_patch = gray[:top_h, max(0, center_col_start - center_w):center_col_start]\n    right_patch = gray[:top_h, center_col_start + center_w:center_col_start + 2 * center_w]\n    center_mean = np.mean(center_patch) if center_patch.size else np.mean(gray)\n    surround_means = []\n    if left_patch.size:\n        surround_means.append(np.mean(left_patch))\n    if right_patch.size:\n        surround_means.append(np.mean(right_patch))\n    surround_mean = np.mean(surround_means) if surround_means else np.mean(gray)\n    # If center is darker than surrounds, value positive; normalize by overall intensity range\n    rng = (np.max(gray) - np.min(gray)) if np.max(gray) != np.min(gray) else 1.0\n    val = (surround_mean - center_mean) / rng\n    return float(val)\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Fraction of object pixels inside the bottom-center box (center third columns, bottom third rows); sandals high'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    thresh = np.mean(gray) + 0.1 * np.std(gray)\n    mask = gray > thresh\n    total = mask.sum()\n    if total == 0:\n        return 0.0\n    r0 = max(0, h * 2 // 3)\n    c0 = w // 3\n    c1 = min(w, c0 + w // 3)\n    box = mask[r0:h, c0:c1]\n    return float(box.sum() / total)\n",
    "def feature(image: np.ndarray) -> float:\n    'Ratio of mask area in top third vs bottom third (top_area / bottom_area)'\n    import numpy as np\n    if image is None:\n        return 1.0\n    h, w = image.shape[:2]\n    if h < 3 or w == 0:\n        return 1.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    top_end = max(1, h // 3)\n    bottom_start = h - top_end\n    top_area = float(np.count_nonzero(mask[:top_end, :]))\n    bottom_area = float(np.count_nonzero(mask[bottom_start:, :]))\n    if bottom_area <= 0.0:\n        return float(top_area / (1.0 + 1e-8))\n    return float(top_area / (bottom_area + 1e-8))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Ratio of mask area in left half to right half (1 = symmetric)'\n    import numpy as np\n    if image is None:\n        return 1.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 1.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    mid = w // 2\n    left_area = float(np.count_nonzero(mask[:, :mid]))\n    right_area = float(np.count_nonzero(mask[:, mid:]))\n    if right_area <= 0:\n        if left_area <= 0:\n            return 1.0\n        return float(left_area / (1e-8 + right_area))\n    return float(left_area / (right_area + 1e-8))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Absolute vertical symmetry: normalized correlation between left and mirrored right halves'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w < 2:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    left = gray[:, :w // 2]\n    right = gray[:, w - (w // 2):]\n    if left.size == 0 or right.size == 0:\n        return 0.0\n    # align widths\n    minw = min(left.shape[1], right.shape[1])\n    left = left[:, :minw].ravel()\n    right = np.fliplr(right[:, :minw]).ravel()\n    left_mean = left.mean() if left.size else 0.0\n    right_mean = right.mean() if right.size else 0.0\n    leftc = left - left_mean\n    rightc = right - right_mean\n    denom = np.sqrt(np.sum(leftc * leftc) * np.sum(rightc * rightc)) + 1e-8\n    corr = np.sum(leftc * rightc) / denom\n    return float(abs(corr))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Ratio of average width in the bottom 20% of the bounding box to the width at mid-height (soul/sole prominence)'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    thresh = float(np.percentile(gray, 75)) if gray.size > 0 else 0.0\n    if thresh <= np.min(gray):\n        thresh = float((np.mean(gray) + np.median(gray)) / 2.0)\n    mask = gray > thresh\n    if not np.any(mask):\n        return 0.0\n    rows_any = np.any(mask, axis=1)\n    rmin = int(np.argmax(rows_any))\n    rmax = int(len(rows_any) - 1 - np.argmax(rows_any[::-1]))\n    if rmax <= rmin:\n        return 0.0\n    bb = mask[rmin:rmax+1, :]\n    H = bb.shape[0]\n    # compute row widths\n    widths = np.sum(bb, axis=1).astype(float)\n    if widths.mean() == 0.0:\n        return 0.0\n    bottom_n = max(1, int(np.ceil(0.2 * H)))\n    bottom_mean = float(np.mean(widths[-bottom_n:]))\n    mid_idx = H // 2\n    mid_width = float(widths[mid_idx]) if widths[mid_idx] > 0 else float(np.mean(widths) + 1e-8)\n    return float(bottom_mean / (mid_width + 1e-8))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Mean vertical-gradient magnitude in the upper third (captures horizontal edges like collars), normalized by global mean'\n    import numpy as np\n    img = np.array(image, dtype=float)\n    if img.size == 0:\n        return 0.0\n    if img.ndim == 3:\n        gray = np.mean(img, axis=2)\n    else:\n        gray = img\n    h, w = gray.shape\n    upper = gray[:max(1, h // 3), :]\n    gy, gx = np.gradient(upper)\n    mag = np.abs(gy)\n    mean_upper = float(np.mean(mag))\n    global_mean = float(np.mean(np.abs(np.gradient(gray)[0])) + 1e-9)\n    return float(mean_upper / global_mean)\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Aspect ratio (height/width) of the largest contiguous horizontal span bounding box in the lower half (approx. lower-component aspect)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    mn, mx = gray.min(), gray.max()\n    if mx > mn:\n        gray = (gray - mn) / (mx - mn)\n    thr = gray.mean() + 0.12 * (gray.max() - gray.mean())\n    mask = gray > thr\n    if mask.sum() == 0:\n        mask = gray > gray.mean()\n    lower = mask[h//2:, :]\n    if np.count_nonzero(lower) == 0:\n        return 0.0\n    # find bounding box of foreground in lower half\n    ys, xs = np.where(lower)\n    miny, maxy = ys.min(), ys.max()\n    minx, maxx = xs.min(), xs.max()\n    comp_h = float(maxy - miny + 1)\n    comp_w = float(maxx - minx + 1)\n    if comp_w <= 0:\n        return 0.0\n    return float((comp_h) / (comp_w + 1e-8))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Mean of per-row longest foreground run lengths normalized by image width'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 50)\n    mask = ((gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)).astype(np.uint8)\n    runs = []\n    for r in range(h):\n        row = mask[r]\n        if row.size == 0:\n            runs.append(0)\n            continue\n        max_run = 0\n        cur = 0\n        for v in row:\n            if v:\n                cur += 1\n                if cur > max_run:\n                    max_run = cur\n            else:\n                cur = 0\n        runs.append(max_run)\n    if len(runs) == 0:\n        return 0.0\n    return float(np.mean(runs) / float(w + 1e-8))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Lower-third split score: depth of valley between two strongest column peaks in the lower third (0..1)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 3 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    start = (2 * h) // 3\n    region = mask[start:, :]\n    if region.size == 0:\n        return 0.0\n    col_counts = np.sum(region, axis=0).astype(float)\n    if np.max(col_counts) <= 0:\n        return 0.0\n    # find two highest peaks\n    inds = np.argsort(col_counts)[-2:]\n    if inds.size < 2:\n        return 0.0\n    i1, i2 = int(inds[0]), int(inds[1])\n    if i1 == i2:\n        return 0.0\n    a, b = min(i1, i2), max(i1, i2)\n    valley = float(np.min(col_counts[a:b + 1])) if b >= a else float(np.min(col_counts))\n    peak_mean = 0.5 * (float(col_counts[i1]) + float(col_counts[i2]))\n    score = (peak_mean - valley) / (np.max(col_counts) + 1e-8)\n    score = max(0.0, min(1.0, score))\n    return float(score)\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Fraction of mask pixels located in bottom 25% of image (useful to detect shoes/trousers)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = float(np.median(gray))\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    total = float(np.count_nonzero(mask))\n    if total <= 0.0:\n        return 0.0\n    start = max(0, int(h - max(1, h * 0.25)))\n    bottom = mask[start:, :]\n    bottom_count = float(np.count_nonzero(bottom))\n    return float(bottom_count / total)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Normalized entropy of vertical-gradient magnitudes in the middle third (higher for vertical seams/buttons)'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    gy, gx = np.gradient(gray)\n    vmag = np.abs(gy)\n    r0 = h // 3\n    r1 = min(h, 2 * h // 3)\n    region = vmag[r0:r1, :]\n    flat = region.flatten()\n    if flat.size == 0:\n        return 0.0\n    # histogram-based entropy\n    bins = 16\n    hist, _ = np.histogram(flat, bins=bins, range=(flat.min(), flat.max()+1e-9))\n    probs = hist.astype(float) / (hist.sum() + 1e-9)\n    probs = probs[probs > 0]\n    if probs.size == 0:\n        return 0.0\n    entropy = -np.sum(probs * np.log2(probs))\n    # normalize by max entropy log2(bins)\n    return float(entropy / (np.log2(bins) + 1e-9))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Fraction of middle columns that have a large bottom y jump relative to their neighbors (bottom-edge jaggedness)'\n    import numpy as np\n    gray = np.mean(image, axis=2) if len(image.shape) == 3 else image.astype(np.float32)\n    gray = np.asarray(gray, dtype=np.float32)\n    thr = max(np.percentile(gray, 70), gray.mean() * 0.6)\n    mask = gray > thr\n    if not mask.any():\n        return 0.0\n    rows, cols = np.where(mask)\n    top, bottom = rows.min(), rows.max()\n    left, right = cols.min(), cols.max()\n    bbox = mask[top:bottom+1, left:right+1]\n    h, w = bbox.shape\n    if w < 3:\n        return 0.0\n    # bottommost y per column\n    bottom_y = np.full(w, -1, dtype=np.int32)\n    for c in range(w):\n        col = bbox[:, c]\n        nz = np.where(col)[0]\n        bottom_y[c] = nz[-1] if nz.size else -1\n    # focus middle 50% columns\n    start = w // 4\n    end = w - start\n    col_segment = bottom_y[start:end]\n    if col_segment.size < 3:\n        return 0.0\n    diffs = np.abs(np.diff(col_segment))\n    # consider a large jump relative to typical variation\n    median = np.median(diffs) + 1e-8\n    large_jumps = np.sum(diffs > (median * 2 + 1.0))\n    frac = large_jumps / (diffs.size + 1e-8)\n    return float(frac)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Normalized vertical center of mass of the object (0 top .. 1 bottom) \u2014 dresses typically have lower center of mass'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    h, w = gray.shape[:2]\n    thr = np.mean(gray) + 0.5 * np.std(gray)\n    mask = (gray > thr).astype(np.float32)\n    s = np.sum(mask)\n    if s <= 0:\n        return 0.5\n    ys = np.arange(h).reshape((h, 1))\n    cy = float(np.sum(ys * mask) / s)\n    return float(cy / max(1, h - 1))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Average number of foreground segments per row (how many horizontal pieces across rows)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    m = mask.astype(bool)\n    # create left-shifted version with zero column at left\n    left = np.concatenate([np.zeros((h, 1), dtype=bool), m[:, :-1]], axis=1)\n    starts = m & (~left)\n    segments_per_row = np.sum(starts, axis=1).astype(float)\n    if segments_per_row.size == 0:\n        return 0.0\n    return float(np.mean(segments_per_row))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Bimodality indicator across columns in the bottom quarter: fraction of strong peaks (0..1)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    thr = float(np.percentile(gray, 50))\n    mask = gray > thr\n    if not np.any(mask):\n        return 0.0\n    start_row = int(3 * h / 4)\n    bottom = mask[start_row:h, :]\n    if bottom.size == 0:\n        return 0.0\n    col_counts = bottom.sum(axis=0)\n    if np.max(col_counts) == 0:\n        return 0.0\n    # detect local peaks: a peak if greater than both neighbors and above 25% of max\n    peaks = 0\n    threshold_peak = 0.25 * np.max(col_counts)\n    for i in range(1, w - 1):\n        if col_counts[i] > col_counts[i - 1] and col_counts[i] > col_counts[i + 1] and col_counts[i] >= threshold_peak:\n            peaks += 1\n    # normalize by max possible (~w/2)\n    return float(min(peaks, w) / w)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Bottom hem variability: standard deviation of left/right boundary positions in bottom quarter, normalized by image width'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    h, w = gray.shape[:2]\n    t = (float(np.max(gray)) + float(np.min(gray))) / 2.0\n    if np.max(gray) == np.min(gray):\n        t = float(np.mean(gray))\n    mask = gray > t\n    if np.count_nonzero(mask) == 0:\n        mask = gray > np.mean(gray)\n        if np.count_nonzero(mask) == 0:\n            return 0.0\n    start = max(0, int(3 * h / 4))\n    left_positions = []\n    right_positions = []\n    for r in range(start, h):\n        cols = np.where(mask[r, :])[0]\n        if cols.size:\n            left_positions.append(float(cols[0]))\n            right_positions.append(float(cols[-1]))\n    if not left_positions or not right_positions:\n        return 0.0\n    left_std = float(np.std(left_positions))\n    right_std = float(np.std(right_positions))\n    hem_var = (left_std + right_std) / (2.0 * max(1.0, w))\n    return float(np.clip(hem_var, 0.0, 1.0))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Ratio of mask area in bottom quarter to top quarter (bottom_quarter / (top_quarter+eps))'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 4 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    q = max(1, h // 4)\n    top = mask[:q, :]\n    bottom = mask[h - q:, :]\n    top_area = float(np.count_nonzero(top))\n    bottom_area = float(np.count_nonzero(bottom))\n    return float(bottom_area / (top_area + 1e-8))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Fraction of center columns empty in bottom band (indicator of separated legs/shoes)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 2 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 50)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    bottom_h = max(1, int(round(h * 0.20)))\n    c0, c1 = w // 4, (3 * w) // 4\n    bottom_center = mask[h - bottom_h:h, c0:c1]\n    if bottom_center.size == 0:\n        return 0.0\n    col_empty = np.sum(np.all(bottom_center == 0, axis=0))\n    return float(col_empty / float(max(1, bottom_center.shape[1])))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Mean ratio of foreground width to bbox width across the top half rows (how consistently wide shoulders are)'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    thresh = (np.mean(gray) + np.min(gray)) / 2.0\n    mask = gray > thresh\n    ys, xs = np.where(mask)\n    if ys.size == 0:\n        return 0.0\n    y0, y1 = ys.min(), ys.max()\n    x0, x1 = xs.min(), xs.max()\n    H = max(1, y1 - y0 + 1)\n    W = max(1, x1 - x0 + 1)\n    top = mask[y0:y0 + max(1, H // 2), x0:x1 + 1]\n    ratios = []\n    for row in top:\n        cols = np.where(row)[0]\n        if cols.size == 0:\n            ratios.append(0.0)\n        else:\n            ratios.append((cols[-1] - cols[0] + 1) / float(W))\n    if len(ratios) == 0:\n        return 0.0\n    return float(np.mean(ratios))\n",
    "def feature(image: np.ndarray) -> float:\n    'Vertical centroid of foreground within object bbox normalized by bbox height (higher -> object mass lower down, typical of coats)'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    thr = np.mean(gray) + 0.45 * np.std(gray)\n    mask = gray > thr\n    if not np.any(mask):\n        return 0.0\n    rows = np.any(mask, axis=1)\n    cols = np.any(mask, axis=0)\n    r_idxs = np.where(rows)[0]\n    c_idxs = np.where(cols)[0]\n    if r_idxs.size == 0 or c_idxs.size == 0:\n        return 0.0\n    r0, r1 = r_idxs[0], r_idxs[-1] + 1\n    c0, c1 = c_idxs[0], c_idxs[-1] + 1\n    bb = mask[r0:r1, c0:c1].astype(np.float32)\n    ys, xs = np.mgrid[0:bb.shape[0], 0:bb.shape[1]]\n    total = np.sum(bb)\n    if total == 0:\n        return 0.0\n    cy = np.sum(ys * bb) / total\n    return float(cy / float(bb.shape[0]))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Aspect ratio of the mask bounding box (width / height), 0 if no mask'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 50)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    ys, xs = np.where(mask)\n    if ys.size == 0:\n        return 0.0\n    bbox_w = float(xs.max() - xs.min() + 1)\n    bbox_h = float(ys.max() - ys.min() + 1)\n    if bbox_h <= 0:\n        return 0.0\n    return float(bbox_w / (bbox_h + 1e-8))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Mean horizontal-gradient magnitude (|dx|) inside the object normalized by overall gradient magnitude (captures vertical edges/straps)'\n    import numpy as np\n    img = np.asarray(image).astype(float)\n    if len(img.shape) == 3:\n        gray = np.mean(img, axis=2)\n    else:\n        gray = img\n    gy, gx = np.gradient(gray)\n    mag = np.hypot(gy, gx)\n    mx, mn = np.max(gray), np.min(gray)\n    thr = np.mean(gray) + 0.15 * (mx - mn)\n    mask = gray > thr\n    if np.count_nonzero(mask) == 0:\n        thr = mn + 0.05 * (mx - mn)\n        mask = gray > thr\n        if np.count_nonzero(mask) == 0:\n            return 0.0\n    mean_dx = np.mean(np.abs(gx[mask])) if np.count_nonzero(mask) else 0.0\n    mean_mag = np.mean(mag[mask]) if np.count_nonzero(mask) else 0.0\n    if mean_mag < 1e-8:\n        return float(mean_dx)\n    return float(mean_dx / (mean_mag + 1e-8))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Central column density: fraction of object pixels that lie within central 20% columns (higher for narrow centered garments like dresses)'\n    import numpy as np\n    gray = np.mean(image, axis=2) if len(image.shape) == 3 else image.astype(float)\n    h, w = gray.shape[:2]\n    thresh = gray.mean() + 0.5 * gray.std() if (gray.std() > 0) else gray.mean() + 1e-6\n    mask = gray > thresh\n    total = float(mask.sum())\n    if total == 0:\n        return 0.0\n    cwidth = max(1, int(round(0.2 * w)))\n    left = max(0, w//2 - cwidth//2)\n    right = min(w, left + cwidth)\n    center_count = float(mask[:, left:right].sum())\n    return float(center_count / total)\n",
    "def feature(image: np.ndarray) -> float:\n    'Contrast of a narrow vertical center strip relative to its immediate flanks (captures button/zipper lines)'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    eps = 1e-8\n    center_w = max(1, w // 12)\n    c0 = w // 2 - center_w // 2\n    c1 = c0 + center_w\n    left0 = max(0, c0 - center_w)\n    right1 = min(w, c1 + center_w)\n    center_strip = gray[:, c0:c1]\n    left_strip = gray[:, left0:c0] if left0 < c0 else gray[:, c0:c1]\n    right_strip = gray[:, c1:right1] if c1 < right1 else gray[:, c0:c1]\n    center_mean = np.mean(center_strip) if center_strip.size else 0.0\n    flank_mean = np.mean(np.concatenate([left_strip.flatten(), right_strip.flatten()])) if (left_strip.size + right_strip.size) else 0.0\n    # we expect a darker center for button line (center < flanks), so return positive when center is darker\n    contrast = (flank_mean - center_mean) / (abs(flank_mean) + eps)\n    return float(contrast)\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Entropy of gradient orientations (0..1, higher => more varied edge directions)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 2 or w < 2:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    gy, gx = np.gradient(gray.astype(float))\n    ang = np.arctan2(gy, gx)  # -pi..pi\n    ang = ang.flatten()\n    # focus on locations with some gradient magnitude\n    mag = np.sqrt(gx * gx + gy * gy).flatten()\n    strong_mask = mag > np.percentile(mag, 50) if ang.size > 0 else np.array([], dtype=bool)\n    if ang.size == 0 or not np.any(strong_mask):\n        return 0.0\n    ang_sel = ang[strong_mask]\n    bins = 12\n    hist, _ = np.histogram(ang_sel, bins=bins, range=(-np.pi, np.pi))\n    p = hist.astype(float) / (np.sum(hist) + 1e-8)\n    # entropy normalized by log(bins)\n    nz = p[p > 0]\n    ent = -np.sum(nz * np.log(nz + 1e-12))\n    norm_ent = ent / (np.log(bins) + 1e-12)\n    if not np.isfinite(norm_ent):\n        return 0.0\n    return float(max(0.0, min(1.0, norm_ent)))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Vertical center of mass of the object normalized by image height (0 at top, 1 at bottom)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    thr = np.mean(gray) + 0.25 * np.std(gray)\n    mask = gray > thr\n    if np.count_nonzero(mask) < 4:\n        mask = gray > np.percentile(gray, 75)\n    if np.count_nonzero(mask) == 0:\n        return 0.5\n    ys, xs = np.where(mask)\n    com_y = np.mean(ys)\n    return float(com_y / max(1.0, (h - 1)))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Bounding box height-to-width aspect ratio of the foreground mask'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 50)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    rows = np.any(mask, axis=1)\n    cols = np.any(mask, axis=0)\n    if not np.any(rows) or not np.any(cols):\n        return 0.0\n    r_indices = np.where(rows)[0]\n    c_indices = np.where(cols)[0]\n    top, bottom = int(r_indices[0]), int(r_indices[-1])\n    left, right = int(c_indices[0]), int(c_indices[-1])\n    bh = float(bottom - top + 1)\n    bw = float(right - left + 1)\n    return float(bh / (bw + 1e-8))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Mask area divided by its bounding box area (fill ratio, 0..1)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    area = float(np.count_nonzero(mask))\n    if area == 0:\n        return 0.0\n    ys, xs = np.where(mask)\n    miny, maxy = ys.min(), ys.max()\n    minx, maxx = xs.min(), xs.max()\n    bbox_area = float((maxy - miny + 1) * (maxx - minx + 1))\n    if bbox_area <= 0:\n        return 0.0\n    return float(area / bbox_area)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Ratio of mean object width in top half to mean width in bottom half'\n    import numpy as np\n    if image is None:\n        return 1.0\n    h, w = image.shape[:2]\n    if h < 2 or w == 0:\n        return 1.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = gray < thr if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else gray > thr\n    top = mask[:h//2, :]\n    bot = mask[h//2:, :]\n    def mean_row_width(region):\n        if region.size == 0:\n            return 0.0\n        widths = np.count_nonzero(region, axis=1).astype(float)\n        if widths.size == 0:\n            return 0.0\n        return float(np.mean(widths)) / float(w)\n    top_w = mean_row_width(top)\n    bot_w = mean_row_width(bot)\n    return float(top_w / (bot_w + 1e-8))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Average absolute red-green color difference normalized by mean brightness'\n    import numpy as np\n    if image is None:\n        return 0.0\n    if len(image.shape) != 3:\n        return 0.0\n    arr = image.astype(float)\n    h, w, c = arr.shape\n    if c < 2 or h == 0 or w == 0:\n        return 0.0\n    r = arr[:, :, 0]\n    g = arr[:, :, 1]\n    diff = np.abs(r - g)\n    mean_brightness = np.mean((r + g + (arr[:, :, 2] if c > 2 else g)) / 3.0) + 1e-8\n    return float(np.mean(diff) / mean_brightness)\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Bounding-box width-to-height ratio of the foreground mask (width/height)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    ys, xs = np.where(mask)\n    if ys.size == 0:\n        return 0.0\n    miny, maxy = int(np.min(ys)), int(np.max(ys))\n    minx, maxx = int(np.min(xs)), int(np.max(xs))\n    bw = float(maxx - minx + 1)\n    bh = float(maxy - miny + 1)\n    if bh <= 1e-8:\n        return 0.0\n    return float(bw / bh)\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Count of connected foreground components (small integer returned as float)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    visited = np.zeros_like(mask, dtype=bool)\n    comps = 0\n    for y in range(h):\n        for x in range(w):\n            if mask[y, x] and not visited[y, x]:\n                comps += 1\n                # flood fill\n                stack = [(y, x)]\n                visited[y, x] = True\n                while stack:\n                    cy, cx = stack.pop()\n                    if cy > 0 and mask[cy - 1, cx] and not visited[cy - 1, cx]:\n                        visited[cy - 1, cx] = True\n                        stack.append((cy - 1, cx))\n                    if cy + 1 < h and mask[cy + 1, cx] and not visited[cy + 1, cx]:\n                        visited[cy + 1, cx] = True\n                        stack.append((cy + 1, cx))\n                    if cx > 0 and mask[cy, cx - 1] and not visited[cy, cx - 1]:\n                        visited[cy, cx - 1] = True\n                        stack.append((cy, cx - 1))\n                    if cx + 1 < w and mask[cy, cx + 1] and not visited[cy, cx + 1]:\n                        visited[cy, cx + 1] = True\n                        stack.append((cy, cx + 1))\n                # safety cap\n                if comps > 1000:\n                    break\n        if comps > 1000:\n            break\n    return float(comps)\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Slope of object width across the lower half (positive if width increases downward), normalized by image width'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    gray = gray.astype(float)\n    eps = 1e-8\n    thresh = np.mean(gray) - 0.5 * np.std(gray)\n    fg = gray < thresh\n    if not np.any(fg):\n        return 0.0\n    rows, cols = np.where(fg)\n    r0, r1 = rows.min(), rows.max()\n    c0, c1 = cols.min(), cols.max()\n    mid = r0 + (r1 - r0) // 2\n    ys = []\n    ws = []\n    for r in range(mid, r1+1):\n        row_cols = np.where(fg[r, c0:c1+1])[0]\n        ys.append(r - mid)\n        ws.append(row_cols.size)\n    ys = np.array(ys, dtype=float)\n    ws = np.array(ws, dtype=float)\n    if ys.size < 2:\n        return 0.0\n    # linear fit\n    A = np.vstack([ys, np.ones_like(ys)]).T\n    try:\n        m, _ = np.linalg.lstsq(A, ws, rcond=None)[0]\n    except Exception:\n        return 0.0\n    # normalize slope by bounding width\n    norm_slope = m / (c1 - c0 + eps)\n    return float(norm_slope)\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Strength of a vertical dark/light line near the center (useful to detect buttons or seams)'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    if w < 3:\n        return 0.0\n    center = w // 2\n    col = gray[:, center].astype(float)\n    leftcol = gray[:, max(0, center-1)].astype(float)\n    rightcol = gray[:, min(w-1, center+1)].astype(float)\n    # vertical contrast: center darker or lighter than neighbors consistently\n    contrast = (2 * col) - (leftcol + rightcol)\n    # measure mean absolute normalized contrast\n    denom = np.maximum(np.abs(leftcol) + np.abs(rightcol) + 1e-8, 1e-8)\n    score = np.mean(np.abs(contrast) / denom)\n    return float(score)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Count of holes inside the main bounding box (enclosed background components)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    ys, xs = np.where(mask)\n    if ys.size == 0:\n        return 0.0\n    ymin, ymax = int(np.min(ys)), int(np.max(ys))\n    xmin, xmax = int(np.min(xs)), int(np.max(xs))\n    crop = mask[ymin:ymax+1, xmin:xmax+1]\n    ch, cw = crop.shape\n    bg = ~crop\n    visited = np.zeros_like(bg, dtype=bool)\n    # flood fill from border background to mark exterior background\n    stack = []\n    for x in range(cw):\n        if bg[0, x] and not visited[0, x]:\n            stack.append((0, x)); visited[0, x] = True\n        if bg[ch-1, x] and not visited[ch-1, x]:\n            stack.append((ch-1, x)); visited[ch-1, x] = True\n    for y in range(ch):\n        if bg[y, 0] and not visited[y, 0]:\n            stack.append((y, 0)); visited[y, 0] = True\n        if bg[y, cw-1] and not visited[y, cw-1]:\n            stack.append((y, cw-1)); visited[y, cw-1] = True\n    while stack:\n        cy, cx = stack.pop()\n        for ny, nx in ((cy-1, cx), (cy+1, cx), (cy, cx-1), (cy, cx+1)):\n            if 0 <= ny < ch and 0 <= nx < cw and bg[ny, nx] and not visited[ny, nx]:\n                visited[ny, nx] = True\n                stack.append((ny, nx))\n    # remaining bg pixels that are not visited are holes\n    holes_mask = bg & (~visited)\n    if not np.any(holes_mask):\n        return 0.0\n    # count connected components among holes\n    visited_h = np.zeros_like(holes_mask, dtype=bool)\n    holes = 0\n    for y in range(ch):\n        for x in range(cw):\n            if holes_mask[y, x] and not visited_h[y, x]:\n                holes += 1\n                stack = [(y, x)]\n                visited_h[y, x] = True\n                while stack:\n                    cy, cx = stack.pop()\n                    for ny, nx in ((cy-1, cx), (cy+1, cx), (cy, cx-1), (cy, cx+1)):\n                        if 0 <= ny < ch and 0 <= nx < cw and holes_mask[ny, nx] and not visited_h[ny, nx]:\n                            visited_h[ny, nx] = True\n                            stack.append((ny, nx))\n    return float(holes)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Maximum normalized lateral mass in left or right extreme of the upper quarter (sleeve/spread indicator)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    norm = (gray - gray.min()) / (gray.max() - gray.min() + 1e-9)\n    mask = norm > 0.15\n    if not mask.any():\n        return 0.0\n    upper_rows = slice(0, max(1, h // 4))\n    upper_mask = mask[upper_rows, :]\n    left_block = upper_mask[:, :max(1, w // 4)]\n    right_block = upper_mask[:, -max(1, w // 4):]\n    upper_sum = upper_mask.sum() + 1e-9\n    left_prop = left_block.sum() / upper_sum\n    right_prop = right_block.sum() / upper_sum\n    return float(max(left_prop, right_prop))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Contrast of small upper-left and upper-right triangular regions (lapel-like dark triangles) vs the top-center strip (positive if corners darker)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    if h < 6 or w < 6:\n        return 0.0\n    nz_rows = np.where(np.any(gray > 0, axis=1))[0]\n    nz_cols = np.where(np.any(gray > 0, axis=0))[0]\n    if nz_rows.size == 0 or nz_cols.size == 0:\n        return 0.0\n    r0, r1 = nz_rows[0], min(h, nz_rows[0] + max(3, h // 8))\n    c0, c1 = nz_cols[0], nz_cols[-1] + 1\n    bbox = gray[r0:r1, c0:c1]\n    bh, bw = bbox.shape\n    tri_w = max(1, bw // 6)\n    tri_h = max(1, bh // 2)\n    # left triangle (approx as rectangle + diagonal mask)\n    left_blk = bbox[0:tri_h, 0:tri_w]\n    right_blk = bbox[0:tri_h, max(0, bw - tri_w):bw]\n    center_strip = bbox[0:tri_h, max(0, bw//2 - tri_w//2):min(bw, bw//2 + tri_w//2)]\n    left_mean = float(np.mean(left_blk)) if left_blk.size else 0.0\n    right_mean = float(np.mean(right_blk)) if right_blk.size else 0.0\n    center_mean = float(np.mean(center_strip)) if center_strip.size else 0.0\n    corners_mean = (left_mean + right_mean) / 2.0\n    denom = (np.std(bbox) + 1e-6)\n    return float((corners_mean - center_mean) / denom)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Normalized vertical centroid of foreground pixels (0 = top, 1 = bottom)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    h, w = gray.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    thr = np.mean(gray) + 0.15 * (np.max(gray) - np.min(gray))\n    fg = (gray > thr)\n    if np.count_nonzero(fg) == 0:\n        fg = (gray > np.percentile(gray, 75))\n    ys, xs = np.where(fg)\n    if ys.size == 0:\n        return 0.0\n    centroid_y = ys.mean()\n    return float(centroid_y / (h - 1))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Foreground bounding box width/height aspect ratio (normalized)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    # grayscale\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    coords = np.argwhere(mask)\n    if coords.size == 0:\n        return 0.0\n    ys, xs = coords[:, 0], coords[:, 1]\n    miny, maxy = int(np.min(ys)), int(np.max(ys))\n    minx, maxx = int(np.min(xs)), int(np.max(xs))\n    box_h = max(1, maxy - miny + 1)\n    box_w = max(1, maxx - minx + 1)\n    aspect = float(box_w) / float(box_h)\n    # normalize by image aspect to keep values comparable\n    img_aspect = float(w) / float(max(1, h))\n    return float(aspect / (img_aspect + 1e-8))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Approximate compactness: perimeter^2 divided by area for the mask (higher => more complex)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    area = float(np.count_nonzero(mask))\n    if area <= 0.0:\n        return 0.0\n    # neighbors without wrap-around\n    up = np.zeros_like(mask)\n    up[:-1, :] = mask[1:, :]\n    down = np.zeros_like(mask)\n    down[1:, :] = mask[:-1, :]\n    left = np.zeros_like(mask)\n    left[:, :-1] = mask[:, 1:]\n    right = np.zeros_like(mask)\n    right[:, 1:] = mask[:, :-1]\n    interior = up & down & left & right\n    boundary = mask & (~interior)\n    perimeter = float(np.count_nonzero(boundary))\n    return float((perimeter * perimeter) / (area + 1e-8))\n",
    "def feature(image: np.ndarray) -> float:\n    'Normalized count of empty horizontal gaps (rows with zero mask) inside the object vertical extent'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 3 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    ys, _ = np.where(mask)\n    if ys.size == 0:\n        return 0.0\n    miny, maxy = int(np.min(ys)), int(np.max(ys))\n    vertical_slice = mask[miny:maxy+1, :]\n    row_sums = np.sum(vertical_slice, axis=1)\n    # rows that are empty inside bbox\n    empty = (row_sums == 0)\n    # count contiguous empty runs\n    runs = 0\n    in_run = False\n    for v in empty:\n        if v and not in_run:\n            runs += 1\n            in_run = True\n        elif not v:\n            in_run = False\n    return float(runs) / float(max(1, (maxy - miny + 1)))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Fraction of pixels in the bottom 10% of rows that belong to the mask'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    rows = max(1, h // 10)\n    bottom = mask[h - rows:h, :]\n    if bottom.size == 0:\n        return 0.0\n    return float(np.count_nonzero(bottom) / float(bottom.size))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Bounding box width divided by height (aspect ratio), larger => wider objects like bags'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    ys, xs = np.where(mask)\n    if ys.size == 0:\n        return 0.0\n    miny, maxy = ys.min(), ys.max()\n    minx, maxx = xs.min(), xs.max()\n    bbox_h = float(maxy - miny + 1)\n    bbox_w = float(maxx - minx + 1)\n    if bbox_h <= 0:\n        return 0.0\n    return float(bbox_w / bbox_h)\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Vertical centroid of the foreground mask normalized by image height (0=top,1=bottom)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    ys, xs = np.where(mask)\n    if ys.size == 0:\n        return 0.0\n    cy = float(np.mean(ys))\n    return float(cy / (h + 1e-8))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Center-region local texture energy (std deviation) normalized by global std \u2014 pullover knit texture often higher'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    ch0, ch1 = h//3, w//3\n    center = gray[ch0:2*ch0, ch1:2*ch1]\n    if center.size == 0:\n        return 0.0\n    center_std = float(np.std(center))\n    global_std = float(np.std(gray))\n    if global_std <= 1e-9:\n        return float(center_std)\n    return float(center_std / global_std)\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Vertical symmetry difference: fraction of object pixels that do not match the horizontally flipped object (0 symmetric -> 1 asymmetric)'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    thr = (np.max(gray) + np.mean(gray)) / 2.0\n    mask = gray > thr\n    if np.count_nonzero(mask) == 0:\n        mask = gray > np.mean(gray)\n        if np.count_nonzero(mask) == 0:\n            return 0.0\n    flipped = np.fliplr(mask)\n    # pad or crop if shapes mismatch (shouldn't happen) - ensure same size\n    if flipped.shape != mask.shape:\n        mn_h = min(flipped.shape[0], mask.shape[0])\n        mn_w = min(flipped.shape[1], mask.shape[1])\n        mask = mask[:mn_h, :mn_w]\n        flipped = flipped[:mn_h, :mn_w]\n    total = float(np.count_nonzero(mask))\n    if total == 0.0:\n        return 0.0\n    diff = float(np.count_nonzero(mask ^ flipped))\n    return float(diff / total)\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Mean horizontal edge strength in the top half of the object bbox (measures shoulder/neckline edge contrast)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    rows_fg = np.any(gray > np.percentile(gray.flatten(), 70), axis=1)\n    cols_fg = np.any(gray > np.percentile(gray.flatten(), 70), axis=0)\n    if not rows_fg.any() or not cols_fg.any():\n        return 0.0\n    r0, r1 = np.where(rows_fg)[0][0], np.where(rows_fg)[0][-1] + 1\n    c0, c1 = np.where(cols_fg)[0][0], np.where(cols_fg)[0][-1] + 1\n    crop = gray[r0:r1, c0:c1].astype(float)\n    h, w = crop.shape\n    top_h = max(1, h//2)\n    top = crop[:top_h, :]\n    # horizontal gradient magnitude\n    grad = np.abs(np.diff(top, axis=1))\n    return float(np.mean(grad))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Relative darkness of a small top-center patch compared to its immediate lower band (captures neck/cleavage notch)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    h, w = gray.shape\n    # define top center box\n    th = max(1, h // 12)\n    left = w // 3\n    right = max(left + 1, 2 * w // 3)\n    top_box = gray[0:th, left:right]\n    below_box = gray[th: min(h, 3*th), left:right]\n    if top_box.size == 0 or below_box.size == 0:\n        return 0.0\n    top_mean = float(np.mean(top_box))\n    below_mean = float(np.mean(below_box))\n    # normalize by overall dynamic range\n    dr = float(np.max(gray) - np.min(gray)) + 1e-6\n    # positive means the top is darker than immediately below (a notch/neck)\n    return float((below_mean - top_mean) / dr)\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Mean vertical run length of foreground pixels per column normalized by image height'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    run_lengths = []\n    for col in range(w):\n        col_vals = mask[:, col].astype(int)\n        if np.all(col_vals == 0):\n            continue\n        padded = np.concatenate(([0], col_vals, [0]))\n        diffs = np.diff(padded)\n        starts = np.where(diffs == 1)[0]\n        ends = np.where(diffs == -1)[0]\n        lengths = (ends - starts).tolist()\n        run_lengths.extend(lengths)\n    if len(run_lengths) == 0:\n        return 0.0\n    mean_run = float(np.mean(run_lengths))\n    return float(mean_run / max(1.0, float(h)))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Relative horizontal extent of sleeves: combined max horizontal span on left and right in upper-middle region normalized by bbox width'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    thr = np.mean(gray) + 0.45 * np.std(gray)\n    mask = gray > thr\n    if not np.any(mask):\n        return 0.0\n    rows = np.any(mask, axis=1)\n    cols = np.any(mask, axis=0)\n    r_idxs = np.where(rows)[0]\n    c_idxs = np.where(cols)[0]\n    if r_idxs.size == 0 or c_idxs.size == 0:\n        return 0.0\n    r0, r1 = r_idxs[0], r_idxs[-1] + 1\n    c0, c1 = c_idxs[0], c_idxs[-1] + 1\n    bbox = mask[r0:r1, c0:c1]\n    bh, bw = bbox.shape\n    top = max(0, bh // 8)\n    upper_mid_h0 = top\n    upper_mid_h1 = max(top + 1, bh // 2)\n    region = bbox[upper_mid_h0:upper_mid_h1, :]\n    if region.size == 0:\n        return 0.0\n    # left max span: find longest contiguous run of True in left half rows' union projection\n    left_half = region[:, :bw//2]\n    right_half = region[:, bw - bw//2:]\n    def max_span(a):\n        # project to columns: any foreground in column\n        proj = np.any(a, axis=0).astype(np.int8)\n        if proj.sum() == 0:\n            return 0\n        # find longest run of ones\n        runs = np.diff(np.concatenate(([0], proj, [0])))\n        starts = np.where(runs == 1)[0]\n        ends = np.where(runs == -1)[0]\n        maxlen = np.max(ends - starts) if starts.size>0 else 0\n        return int(maxlen)\n    ls = max_span(left_half)\n    rs = max_span(right_half)\n    total_span = ls + rs\n    return float(total_span) / float(bw) if bw > 0 else 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Vertical button-line score: longest contiguous run of darker-than-torso pixels along center columns (normalized), suggesting buttons or openings'\n    import numpy as np\n    gray = np.mean(image, axis=2) if len(image.shape) == 3 else image.astype(float)\n    h, w = gray.shape[:2]\n    mx, mn = float(np.max(gray)), float(np.min(gray))\n    mean = float(np.mean(gray))\n    thresh = mean + 0.12 * (mx - mean) if mx > mean else mean * 0.5\n    mask = gray > thresh\n    if not np.any(mask):\n        return 0.0\n    rows = np.where(mask.any(axis=1))[0]\n    if len(rows) == 0:\n        return 0.0\n    r0, r1 = rows[0], rows[-1]\n    # torso region mean intensity\n    torso_rows = range(max(r0, r0 + int(0.25*(r1-r0+1))), min(h, r0 + int(0.75*(r1-r0+1))))\n    torso_vals = gray[list(torso_rows), :]\n    torso_mean = float(np.mean(torso_vals)) if torso_vals.size else mean\n    center_cols = list(range(max(0, w//2 - max(1,w//20)), min(w, w//2 + max(1,w//20))))\n    col_profile = np.min(gray[r0:r1+1][:, center_cols], axis=1) if center_cols else gray[r0:r1+1, w//2]\n    # detect rows where center pixels are darker than torso mean by a margin\n    dark_mask = col_profile < (torso_mean - 0.12 * (mx - mn + 1e-9))\n    # longest contiguous run\n    if not np.any(dark_mask):\n        return 0.0\n    # compute longest stretch\n    max_run = 0\n    cur = 0\n    for v in dark_mask:\n        if v:\n            cur += 1\n            if cur > max_run:\n                max_run = cur\n        else:\n            cur = 0\n    norm = float(max_run / (r1 - r0 + 1 + 1e-9))\n    return norm\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Left-right symmetry score of intensity (1.0 means perfectly symmetric)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    mid = w // 2\n    left = gray[:, :mid]\n    right = gray[:, w - mid:]\n    if left.size == 0 or right.size == 0:\n        return 0.0\n    # flip right to compare\n    right_flipped = np.fliplr(right)\n    # crop to same width if unequal\n    minw = min(left.shape[1], right_flipped.shape[1])\n    left = left[:, :minw]\n    right_flipped = right_flipped[:, :minw]\n    diff = np.abs(left - right_flipped)\n    rng = np.max(gray) - np.min(gray)\n    rng = rng if rng > 1e-8 else 1.0\n    score = 1.0 - (np.mean(diff) / rng)\n    return float(max(0.0, min(1.0, score)))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Coefficient of variation of horizontal widths across rows (std/mean of row widths)'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    h, w = gray.shape[:2]\n    if h < 1 or w < 1:\n        return 0.0\n    thr = float(np.percentile(gray, 75))\n    mask = (gray > thr)\n    # widths per row = count of True in that row\n    widths = mask.sum(axis=1).astype(float)\n    mean_w = widths.mean()\n    std_w = widths.std()\n    if mean_w <= 1e-9:\n        return 0.0\n    return float(std_w / (mean_w + 1e-9))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Top vs bottom mean brightness contrast normalized by overall mean (top25 - bottom25) / mean'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 4 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    top_h = max(1, h // 4)\n    bottom_h = max(1, h // 4)\n    top_mean = float(np.mean(gray[:top_h, :]))\n    bottom_mean = float(np.mean(gray[h - bottom_h:, :]))\n    denom = float(np.mean(gray)) + 1e-8\n    result = (top_mean - bottom_mean) / denom\n    return float(result)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Ratio of the minimum width in the middle third to the maximum width (low for thin-strapped sandals)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    arr = np.array(image)\n    if len(arr.shape) == 3:\n        gray = np.mean(arr, axis=2)\n    else:\n        gray = arr\n    mx = gray.max() if gray.size else 0.0\n    if mx <= 0:\n        return 0.0\n    mask = gray > (mx * 0.2)\n    if not mask.any():\n        return 0.0\n    ys, xs = np.where(mask)\n    top, bottom = ys.min(), ys.max()\n    left, right = xs.min(), xs.max()\n    h = bottom - top + 1\n    if h <= 0:\n        return 0.0\n    m1 = top + h // 3\n    m2 = top + 2 * h // 3\n    widths = []\n    for r in range(m1, m2+1):\n        row = mask[r, left:right+1]\n        if row.any():\n            idx = np.where(row)[0]\n            widths.append(idx[-1] - idx[0] + 1)\n    if not widths:\n        return 0.0\n    min_w = float(np.min(widths))\n    # compute max width across whole bbox\n    all_widths = []\n    for r in range(top, bottom+1):\n        row = mask[r, left:right+1]\n        if row.any():\n            idx = np.where(row)[0]\n            all_widths.append(idx[-1] - idx[0] + 1)\n    max_w = float(np.max(all_widths)) if all_widths else 0.0\n    if max_w == 0:\n        return 0.0\n    return float(min_w / max_w)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Ratio of principal eigenvalues of mask coordinates (elongation measure, near1 if very elongated)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 50)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    ys, xs = np.where(mask)\n    if ys.size < 2:\n        return 0.0\n    coords = np.vstack([ys.astype(float), xs.astype(float)])\n    cov = np.cov(coords)\n    if cov.shape != (2, 2):\n        return 0.0\n    eig = np.linalg.eigvals(cov)\n    eig = np.sort(np.real(eig))[::-1]\n    if eig[1] <= 0:\n        return 0.0\n    ratio = float(eig[0] / (eig[1] + 1e-8))\n    # normalize to a bounded scale with log\n    return float(np.log1p(ratio))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Strength of a central vertical dark (or bright) line relative to its immediate neighbors (buttons/zip indicator)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    if w < 3:\n        return 0.0\n    center_w = max(1, w // 10)\n    start = max(0, w//2 - center_w)\n    end = min(w, w//2 + center_w)\n    center_cols = gray[:, start:end]\n    side_left = gray[:, max(0, start - center_w):start]\n    side_right = gray[:, end:min(w, end + center_w)]\n    center_mean = float(np.mean(center_cols)) if center_cols.size else 0.0\n    side_mean = float(np.mean(np.concatenate([side_left.flatten(), side_right.flatten()]))) if (side_left.size + side_right.size) else center_mean\n    denom = max(1e-6, float(np.max(gray) - np.min(gray)))\n    # we want magnitude of center contrast (positive if center darker when values larger -> depends on image convention)\n    return float((side_mean - center_mean) / denom)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Ratio of corner-like pixels to strong-edge pixels (cornerness), 0 if no strong edges'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 2 or w < 2:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    gy, gx = np.gradient(gray.astype(float))\n    grad_mag = np.sqrt(gx * gx + gy * gy)\n    if not np.any(grad_mag):\n        return 0.0\n    thresh = np.percentile(grad_mag, 65)\n    strong = grad_mag > thresh\n    if not np.any(strong):\n        return 0.0\n    # corner-like when both |gx| and |gy| are large relative to grad_mag\n    corner_mask = strong & (np.abs(gx) > 0.4 * grad_mag) & (np.abs(gy) > 0.4 * grad_mag)\n    return float(np.count_nonzero(corner_mask) / (np.count_nonzero(strong) + 1e-8))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Fraction of empty pixels in the top 15% of the object bounding box (open-top sandals vs closed boots)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape\n    if h == 0 or w == 0:\n        return 0.0\n    thr = np.mean(gray) + 0.25 * np.std(gray)\n    mask = gray > thr\n    if not np.any(mask):\n        mask = gray > np.percentile(gray, 80)\n    if not np.any(mask):\n        return 1.0\n    rows = np.where(np.any(mask, axis=1))[0]\n    cols = np.where(np.any(mask, axis=0))[0]\n    if rows.size == 0 or cols.size == 0:\n        return 1.0\n    rmin, rmax = rows[0], rows[-1]\n    cmin, cmax = cols[0], cols[-1]\n    bh = rmax - rmin + 1\n    top_h = max(1, bh * 15 // 100)\n    top_region = mask[rmin:rmin + top_h, cmin:cmax + 1]\n    if top_region.size == 0:\n        return 1.0\n    filled = np.count_nonzero(top_region)\n    empty_frac = 1.0 - float(filled) / float(top_region.size)\n    return float(empty_frac)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Mean absolute Laplacian energy (high values => more high-frequency texture)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 3 or w < 3:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    # pad with edge to avoid wrap-around artifacts\n    pad = np.pad(gray, 1, mode='edge').astype(float)\n    center = pad[1:-1, 1:-1]\n    up = pad[0:-2, 1:-1]\n    down = pad[2:, 1:-1]\n    left = pad[1:-1, 0:-2]\n    right = pad[1:-1, 2:]\n    lap = up + down + left + right - 4.0 * center\n    energy = float(np.mean(np.abs(lap)))\n    return float(energy)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Std deviation of the bottom edge heights across columns (low = flat bottom like coats, higher = curved)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    mean, mx = np.mean(gray), np.max(gray)\n    thr = mean + 0.15 * (mx - mean)\n    mask = gray > thr\n    if not np.any(mask):\n        thr = np.percentile(gray, 90)\n        mask = gray > thr\n    if not np.any(mask):\n        return 0.0\n    cols_any = np.any(mask, axis=0)\n    if not np.any(cols_any):\n        return 0.0\n    cmin = int(np.argmax(cols_any))\n    cmax = int(len(cols_any) - np.argmax(cols_any[::-1]) - 1)\n    heights = []\n    for col in range(cmin, cmax+1):\n        col_mask = mask[:, col]\n        if np.any(col_mask):\n            last = len(col_mask) - np.argmax(col_mask[::-1]) - 1\n            heights.append(last)\n    if len(heights) < 2:\n        return 0.0\n    return float(np.std(heights))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Overall foreground pixel density (fraction of image pixels that belong to foreground)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    total_pixels = float(h * w)\n    if total_pixels <= 0.0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    fg_count = float(np.count_nonzero(mask))\n    return float(fg_count / total_pixels)\n",
    "def feature(image: np.ndarray) -> float:\n    'Density of object pixels in the bottom quarter of its bounding box (useful to detect sole/flat objects)'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.mean(gray) + 0.2 * (np.max(gray) - np.min(gray))\n    mask = gray > thr\n    if not np.any(mask):\n        return 0.0\n    rows = np.any(mask, axis=1)\n    cols = np.any(mask, axis=0)\n    minr, maxr = np.where(rows)[0][0], np.where(rows)[0][-1]\n    minc, maxc = np.where(cols)[0][0], np.where(cols)[0][-1]\n    bbox_h = maxr - minr + 1\n    slice_h = max(1, bbox_h // 4)\n    bottom_slice = mask[maxr - slice_h + 1:maxr + 1, minc:maxc + 1]\n    return float(np.sum(bottom_slice) / (np.sum(mask) + 1e-9))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Fraction of mask pixels with high absolute Laplacian response (corner/edge density within mask)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 3 or w < 3:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = ((gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)).astype(bool)\n    if not np.any(mask):\n        return 0.0\n    # compute 4-neighbor Laplacian: 4*center - up - down - left - right\n    padded = np.pad(gray, ((1, 1), (1, 1)), mode='edge').astype(float)\n    center = padded[1:-1, 1:-1]\n    up = padded[0:-2, 1:-1]\n    down = padded[2:, 1:-1]\n    left = padded[1:-1, 0:-2]\n    right = padded[1:-1, 2:]\n    lap = (4.0 * center - up - down - left - right)\n    abs_lap = np.abs(lap)\n    thresh = np.percentile(abs_lap, 90) if np.any(abs_lap) else 1e-8\n    strong = abs_lap >= thresh\n    denom = float(np.count_nonzero(mask)) + 1e-8\n    return float(np.count_nonzero(strong & mask) / denom)\n",
    "def feature(image: np.ndarray) -> float:\n    'Upper-lapel diagonal energy: sum of diagonal gradient magnitudes in upper-left and upper-right shoulder boxes normalized by area'\n    import numpy as np\n    gray = np.mean(image, axis=2) if len(image.shape) == 3 else image.astype(float)\n    h, w = gray.shape[:2]\n    # gradients\n    gy, gx = np.gradient(gray.astype(float))\n    diag1 = gx + gy\n    diag2 = gx - gy\n    # bounding shoulder boxes: top 20% height, left and right 25% width of image\n    th = max(1, int(0.2 * h))\n    lw = max(1, int(0.25 * w))\n    left_box = slice(0, th), slice(0, lw)\n    right_box = slice(0, th), slice(w - lw, w)\n    left_energy = np.mean(np.abs(diag1[left_box]) + np.abs(diag2[left_box]))\n    right_energy = np.mean(np.abs(diag1[right_box]) + np.abs(diag2[right_box]))\n    # return average shoulder diagonal energy normalized\n    return float((left_energy + right_energy) / 2.0)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Left/right bias of mass in the upper half (positive => more mass on left, normalized -1..1)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 2 or w < 2:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 50)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    upper = mask[:max(1, h // 2), :]\n    total = float(np.count_nonzero(upper))\n    if total == 0.0:\n        return 0.0\n    left = float(np.count_nonzero(upper[:, :max(1, w // 2)]))\n    right = float(np.count_nonzero(upper[:, max(1, w // 2):]))\n    bias = (left - right) / (total + 1e-12)\n    # clamp to [-1,1]\n    if bias > 1.0:\n        bias = 1.0\n    if bias < -1.0:\n        bias = -1.0\n    return float(bias)\n",
    "def feature(image: np.ndarray) -> float:\n    'Number of contiguous top-region foreground groups (columns with first-foreground within top 30%) normalized by width'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    top_cut = max(1, int(0.30 * h))\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 50)\n    mask = ((gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr))\n    first_y = np.full(w, h, dtype=int)\n    for c in range(w):\n        col = mask[:, c]\n        ys = np.nonzero(col)[0]\n        if ys.size:\n            first_y[c] = int(ys[0])\n    cols_top = (first_y < top_cut).astype(int)\n    if cols_top.size == 0:\n        return 0.0\n    transitions = np.diff(np.concatenate(([0], cols_top, [0])))\n    groups = int(np.sum(transitions == 1))\n    return float(groups / float(w + 1e-8))\n",
    "def feature(image: np.ndarray) -> float:\n    'Colorfulness metric (Hasler-S\u00fcsstrunk style) computed from RGB channels (0 for grayscale input)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    if len(image.shape) != 3 or image.shape[2] != 3:\n        return 0.0\n    R = image[:, :, 0].astype(float)\n    G = image[:, :, 1].astype(float)\n    B = image[:, :, 2].astype(float)\n    rg = R - G\n    yb = 0.5 * (R + G) - B\n    std_rg = np.std(rg)\n    std_yb = np.std(yb)\n    mean_rg = np.mean(np.abs(rg))\n    mean_yb = np.mean(np.abs(yb))\n    colorfulness = np.sqrt(std_rg ** 2 + std_yb ** 2) + 0.3 * np.sqrt(mean_rg ** 2 + mean_yb ** 2)\n    return float(colorfulness)\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Mask compactness: area / (perimeter^2) approximated from mask gradients (higher => compact blob)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = float(np.median(gray))\n    mask = ((gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)).astype(float)\n    area = float(np.count_nonzero(mask))\n    if area <= 0.0:\n        return 0.0\n    gy, gx = np.gradient(mask)\n    edge = np.sqrt(gx * gx + gy * gy)\n    perim = float(np.count_nonzero(edge > 1e-6))\n    perim = max(perim, 1.0)\n    compactness = area / ((perim ** 2) + 1e-8)\n    # normalize by image area scale to keep values comparable\n    return float(compactness * (h * w) / (h * w + 1e-8))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Upper third sleeve protrusion score: ratio of side pixel mass in the upper third to central pixel mass (higher if sleeves present)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    h, w = gray.shape[:2]\n    maxv = float(np.max(gray)) if np.size(gray) else 0.0\n    if maxv <= 0:\n        return 0.0\n    thresh = maxv * 0.10\n    mask = gray > thresh\n    upper_h = max(1, h // 3)\n    central_half = max(1, int(np.ceil(w * 0.10)))\n    center = w // 2\n    c0 = max(0, center - central_half)\n    c1 = min(w, center + central_half)\n    upper_region = mask[0:upper_h, :]\n    central_region = upper_region[:, c0:c1]\n    central_count = np.count_nonzero(central_region)\n    side_count = np.count_nonzero(upper_region) - central_count\n    # add 1 to denominator to avoid div0 and keep scale reasonable\n    score = float(side_count / float(central_count + 1))\n    return score\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Color difference between upper and lower halves (RGB L2 distance normalized)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0:\n        return 0.0\n    if len(image.shape) != 3 or image.shape[2] < 3:\n        return 0.0\n    top = image[: max(1, h // 2), :, :].astype(float)\n    bot = image[h // 2 :, :, :].astype(float)\n    top_mean = np.mean(top.reshape(-1, 3), axis=0) if top.size else np.array([0.0, 0.0, 0.0])\n    bot_mean = np.mean(bot.reshape(-1, 3), axis=0) if bot.size else np.array([0.0, 0.0, 0.0])\n    diff = np.linalg.norm(top_mean - bot_mean)\n    denom = (np.mean(image.astype(float)) + 1e-8)\n    return float(diff / denom)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Normalized top edge jaggedness: sum of absolute vertical changes of top contour divided by image height'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 1 or w < 1:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = gray < thr if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else gray > thr\n    top_idx = np.full((w,), float(h - 1), dtype=float)\n    any_in_col = np.any(mask, axis=0)\n    if np.any(any_in_col):\n        cols = np.where(any_in_col)[0]\n        for c in cols:\n            col = mask[:, c]\n            top_idx[c] = float(np.argmax(col))\n    diffs = np.abs(np.diff(top_idx))\n    sum_diff = float(np.sum(diffs))\n    return float(sum_diff / max(1.0, float(h)))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Average gradient magnitude along the mask boundary (higher = stronger edges at outline)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 2 or w < 2:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = ((gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)).astype(bool)\n    if not np.any(mask):\n        return 0.0\n    gy, gx = np.gradient(gray.astype(float))\n    grad_mag = np.sqrt(gx * gx + gy * gy)\n    # find boundary pixels (4-neighborhood)\n    pad = np.pad(mask, ((1,1),(1,1)), mode='constant', constant_values=False)\n    boundary = np.zeros_like(mask, dtype=bool)\n    for dy, dx in ((-1,0),(1,0),(0,-1),(0,1)):\n        neighbor = pad[1+dy:1+dy+h, 1+dx:1+dx+w]\n        boundary |= (mask & ~neighbor)\n    bcount = np.count_nonzero(boundary)\n    if bcount == 0:\n        return 0.0\n    avg_grad = float(np.sum(grad_mag[boundary]) / (bcount + 1e-8))\n    return float(avg_grad)\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Average absolute Laplacian magnitude inside mask (texture/roughness indicator)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 3 or w < 3:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    if not np.any(mask):\n        return 0.0\n    gy, gx = np.gradient(gray.astype(float))\n    gxx, _ = np.gradient(gx)\n    _, gyy = np.gradient(gy)\n    lap = np.abs(gxx + gyy)\n    val = np.mean(lap[mask])\n    return float(val / (np.mean(np.abs(gray)) + 1e-8))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Ratio of vertical-edge magnitude in middle third to total edge magnitude (focus on seams/vertical structure)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    if h < 3 or w == 0:\n        return 0.0\n    gy, gx = np.gradient(gray)\n    vert_mag = np.abs(gx)  # vertical edges are changes in x direction\n    total = np.sum(np.abs(gy)) + np.sum(np.abs(gx))\n    if total == 0:\n        return 0.0\n    mid_start = h//3\n    mid_end = max(mid_start+1, 2*h//3)\n    mid_vert = np.sum(vert_mag[mid_start:mid_end, :])\n    return float(mid_vert / float(total))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Average horizontal contiguous run length of object pixels across the central 40% of rows normalized by bounding-box width'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    if gray.size == 0:\n        return 0.0\n    thr = np.percentile(gray, 75)\n    bw = gray > thr\n    if not np.any(bw):\n        thr = np.mean(gray)\n        bw = gray > thr\n    if not np.any(bw):\n        return 0.0\n    rows = np.any(bw, axis=1)\n    cols = np.any(bw, axis=0)\n    rmin, rmax = np.argmax(rows), bw.shape[0] - np.argmax(rows[::-1]) - 1\n    cmin, cmax = np.argmax(cols), bw.shape[1] - np.argmax(cols[::-1]) - 1\n    sub = bw[rmin:rmax+1, cmin:cmax+1].astype(np.uint8)\n    H, W = sub.shape\n    if H == 0 or W == 0:\n        return 0.0\n    r1 = H * 3 // 10\n    r2 = H * 7 // 10\n    r1 = max(0, r1); r2 = min(H, r2)\n    if r2 <= r1:\n        return 0.0\n    run_lengths = []\n    for i in range(r1, r2):\n        row = sub[i, :]\n        j = 0\n        while j < W:\n            if row[j]:\n                start = j\n                while j < W and row[j]:\n                    j += 1\n                run_lengths.append(j - start)\n            else:\n                j += 1\n    if len(run_lengths) == 0:\n        return 0.0\n    return float(np.mean(run_lengths) / max(W, 1))\n",
    "def feature(image: np.ndarray) -> float:\n    'Aspect ratio (height / width) of the bounding box of the foreground mask'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 50)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    ys, xs = np.where(mask)\n    if ys.size == 0 or xs.size == 0:\n        return 0.0\n    ymin, ymax = int(np.min(ys)), int(np.max(ys))\n    xmin, xmax = int(np.min(xs)), int(np.max(xs))\n    box_h = float(ymax - ymin + 1)\n    box_w = float(xmax - xmin + 1)\n    return float(box_h / (box_w + 1e-8))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Central mass fraction: fraction of object pixels located inside the central vertical third (helps separate bags or narrow tops)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    mi, ma = float(np.min(gray)), float(np.max(gray))\n    if ma - mi < 1e-6:\n        return 0.0\n    med = float(np.median(gray))\n    if float(np.mean(gray)) > med:\n        thr = med + 0.08 * (ma - mi)\n        mask = gray > thr\n    else:\n        thr = med - 0.08 * (ma - mi)\n        mask = gray < thr\n    if mask.sum() == 0:\n        mask = gray != med\n        if mask.sum() == 0:\n            return 0.0\n    c1 = w // 3\n    c2 = 2 * w // 3\n    central = np.count_nonzero(mask[:, c1:c2])\n    total = np.count_nonzero(mask)\n    if total == 0:\n        return 0.0\n    return float(central / total)\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Ratio of mean edge magnitude in top third to bottom third (top_mean / bottom_mean)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 3 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    gy, gx = np.gradient(gray.astype(float))\n    grad = np.sqrt(gx * gx + gy * gy)\n    top = grad[:max(1, h // 3), :]\n    bottom = grad[max(0, h - h // 3):, :]\n    top_mean = float(np.mean(top)) if top.size else 0.0\n    bottom_mean = float(np.mean(bottom)) if bottom.size else 0.0\n    return float(top_mean / (bottom_mean + 1e-8))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Maximum contiguous vertical run of mask pixels in any column normalized by image height'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    max_run = 0\n    # iterate columns (images small enough for loop)\n    for c in range(w):\n        col = mask[:, c]\n        curr = 0\n        local_max = 0\n        # iterate rows in column\n        for v in col:\n            if v:\n                curr += 1\n                if curr > local_max:\n                    local_max = curr\n            else:\n                curr = 0\n        if local_max > max_run:\n            max_run = local_max\n    return float(max_run / (h + 1e-8))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Left-right mass balance: absolute normalized difference between left and right mask mass'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    mid = w // 2\n    left = np.count_nonzero(mask[:, :mid])\n    right = np.count_nonzero(mask[:, mid:])\n    total = left + right\n    if total == 0:\n        return 0.0\n    return float(abs(left - right) / float(total))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Colorfulness metric (Hasler-S\u00fcsstrunk) normalized to [0, ~1] for RGB, 0 for grayscale'\n    import numpy as np\n    if image is None:\n        return 0.0\n    if len(image.shape) != 3 or image.shape[2] < 3:\n        return 0.0\n    # use only first three channels as RGB\n    img = image[:, :, :3].astype(float)\n    R = img[:, :, 0]\n    G = img[:, :, 1]\n    B = img[:, :, 2]\n    rg = R - G\n    yb = 0.5 * (R + G) - B\n    std_rg = float(np.std(rg))\n    std_yb = float(np.std(yb))\n    mean_rg = float(np.mean(rg))\n    mean_yb = float(np.mean(yb))\n    raw = np.sqrt(std_rg * std_rg + std_yb * std_yb) + 0.3 * np.sqrt(mean_rg * mean_rg + mean_yb * mean_yb)\n    # normalize roughly by 255\n    return float(raw / 255.0)\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Normalized left-right mass difference inside bbox: (left_area - right_area) / total_area (captures pose/orientation)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    mu, sd = float(np.mean(gray)), float(np.std(gray))\n    thresh = mu + 0.25 * sd if sd > 1e-6 else mu * 0.5\n    bw = gray > thresh\n    ys, xs = np.where(bw)\n    if ys.size == 0:\n        return 0.0\n    r0, r1 = ys.min(), ys.max()\n    c0, c1 = xs.min(), xs.max()\n    region = bw[r0:r1+1, c0:c1+1].astype(np.uint8)\n    h, w = region.shape\n    mid = w // 2\n    left_area = float(np.count_nonzero(region[:, :mid]))\n    right_area = float(np.count_nonzero(region[:, mid:]))\n    total = left_area + right_area\n    if total == 0.0:\n        return 0.0\n    return (left_area - right_area) / total\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Fraction of rows where the mask covers >=80% of image width (indicates wide/continuous garments)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    row_counts = np.count_nonzero(mask, axis=1).astype(float)\n    wide_rows = np.count_nonzero(row_counts >= 0.8 * float(w))\n    return float(wide_rows) / float(h)\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Edge-to-area ratio: count of strong gradient pixels divided by object area (higher for textured/complex outlines)'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    gx, gy = np.gradient(gray)\n    grad = np.hypot(gx, gy)\n    # threshold edges relative to grad distribution\n    edge_thr = np.percentile(grad, 85)\n    edges = grad > edge_thr\n    # object mask to restrict to relevant region\n    mask_thr = np.mean(gray) + 0.25 * (np.max(gray) - np.min(gray))\n    mask = gray > mask_thr\n    edge_count = np.sum(edges & mask)\n    area = np.sum(mask)\n    if area == 0:\n        return 0.0\n    return float(edge_count / area)\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Top-bottom (vertical) symmetry of the foreground mask (1.0 = symmetric)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 50)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    total = np.count_nonzero(mask)\n    if total == 0:\n        return 0.0\n    flipped = np.flipud(mask)\n    overlap = np.count_nonzero(mask & flipped)\n    return float(overlap / (total + 1e-8))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Ratio of width at the bottom 10% of the bounding box to width at the top 10% (toe vs ankle/heel width)'\n    gray = np.mean(image, axis=2) if len(image.shape) == 3 else image.astype(np.float64)\n    gray = np.nan_to_num(gray.astype(np.float64))\n    if gray.size == 0:\n        return 0.0\n    if gray.max() != 0:\n        gray = gray / gray.max()\n    h, w = gray.shape[:2]\n    thr = np.percentile(gray, 70)\n    pad = max(1, min(h, w) // 12)\n    center = gray[pad:h-pad, pad:w-pad] if h>2*pad and w>2*pad else gray\n    border = np.concatenate([gray[:pad, :].ravel(), gray[-pad:, :].ravel(), gray[:, :pad].ravel(), gray[:, -pad:].ravel()]) if pad < min(h, w)//2 else gray.ravel()\n    center_mean = center.mean()\n    border_mean = border.mean()\n    mask = (gray < thr) if center_mean < border_mean else (gray > thr)\n    coords = np.argwhere(mask)\n    if coords.size == 0:\n        return 0.0\n    rmin, cmin = coords.min(axis=0)\n    rmax, cmax = coords.max(axis=0)\n    bh = max(1, rmax - rmin + 1)\n    bw = max(1, cmax - cmin + 1)\n    bbox = mask[rmin:rmax+1, cmin:cmax+1]\n    top_h = max(1, int(np.ceil(0.1 * bh)))\n    bottom_h = top_h\n    top_slice = bbox[0:top_h, :]\n    bottom_slice = bbox[-bottom_h:, :]\n    top_width = float((top_slice.sum(axis=0) > 0).sum())\n    bottom_width = float((bottom_slice.sum(axis=0) > 0).sum())\n    if top_width <= 0.0:\n        return float(bottom_width)\n    return float(bottom_width / top_width)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Slope of object width vs vertical position (positive slope = object widens downward), normalized by bbox width'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape\n    thr = np.mean(gray) + 0.25 * np.std(gray)\n    mask = gray > thr\n    if not np.any(mask):\n        mask = gray > np.mean(gray)\n    rows = np.any(mask, axis=1)\n    cols = np.any(mask, axis=0)\n    if not np.any(rows) or not np.any(cols):\n        return 0.0\n    r0, r1 = np.where(rows)[0][0], np.where(rows)[0][-1]\n    c0, c1 = np.where(cols)[0][0], np.where(cols)[0][-1]\n    bh = max(1, r1 - r0 + 1)\n    bw = max(1, c1 - c0 + 1)\n    widths = []\n    ys = []\n    for rr in range(r0, r1 + 1):\n        cols_idx = np.where(mask[rr, c0:c1+1])[0]\n        if cols_idx.size==0:\n            continue\n        widths.append(cols_idx.max() - cols_idx.min() + 1)\n        ys.append(rr - r0)\n    if len(widths) < 2:\n        return 0.0\n    ys = np.array(ys, dtype=float) / float(bh)  # normalized y in [0,1]\n    widths = np.array(widths, dtype=float) / float(bw)  # normalized widths\n    # linear fit\n    try:\n        p = np.polyfit(ys, widths, 1)\n        slope = p[0]\n    except Exception:\n        slope = 0.0\n    return float(slope)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Number of prominent peaks in the row-width profile within the upper half (detects separated shoulders/sleeves)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 6:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 50)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    upper = mask[:max(1, h // 2), :]\n    row_widths = np.sum(upper, axis=1).astype(float)\n    if row_widths.size < 3 or np.all(row_widths == 0):\n        return 0.0\n    # smooth with small moving average\n    kernel = np.ones(3) / 3.0\n    smooth = np.convolve(row_widths, kernel, mode='same')\n    # threshold peaks by being local max and above percentile\n    thr_val = np.percentile(smooth, 70)\n    peaks = 0\n    for i in range(1, smooth.size - 1):\n        if smooth[i] > smooth[i-1] and smooth[i] > smooth[i+1] and smooth[i] > thr_val:\n            peaks += 1\n    return float(peaks)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Variance of foreground widths across the upper half of the object bounding box (sleeves cause high variance)'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    low, high = np.percentile(gray, 10), np.percentile(gray, 90)\n    if high - low <= 1e-6:\n        return 0.0\n    thresh = (low + high) / 2.0\n    fg = gray < thresh\n    if not np.any(fg):\n        return 0.0\n    ys, xs = np.where(fg)\n    y0, y1 = ys.min(), ys.max()\n    x0, x1 = xs.min(), xs.max()\n    bh = max(1, y1 - y0 + 1)\n    upper_end = y0 + max(1, bh // 2)\n    widths = []\n    for r in range(y0, upper_end):\n        row = fg[r, x0:x1+1]\n        widths.append(np.count_nonzero(row))\n    if len(widths) == 0:\n        return 0.0\n    return float(np.var(widths))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Skewness of foreground row widths (third standardized moment), 0 if undefined'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    row_widths = np.sum(mask, axis=1).astype(float)\n    if row_widths.size == 0:\n        return 0.0\n    mu = np.mean(row_widths)\n    sigma = np.std(row_widths)\n    if sigma < 1e-8:\n        return 0.0\n    skew = np.mean(((row_widths - mu) ** 3)) / (sigma ** 3)\n    return float(skew)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Average horizontal extension of object beyond the central torso region in the upper third (captures sleeves)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    maxv = gray.max()\n    if maxv == 0:\n        return 0.0\n    mask = gray > (maxv * 0.1)\n    top_h = max(1, h//3)\n    center_col = w//2\n    # compute leftmost and rightmost x for each top row\n    left_excess = []\n    right_excess = []\n    # define a central torso half-width as the width around center where torso likely is: use median span near center rows\n    torso_rows = mask[h//3:h//3 + max(1, h//6), :]\n    if torso_rows.size == 0:\n        torso_half = max(1, w//6)\n    else:\n        torso_cols = torso_rows.any(axis=0)\n        # find continuous region around center\n        left_indices = np.where(torso_cols[:center_col])[0]\n        right_indices = np.where(torso_cols[center_col:])[0] + center_col\n        if left_indices.size and right_indices.size:\n            torso_left = left_indices.max()\n            torso_right = right_indices.min()\n            torso_half = max(1, int((center_col - torso_left + torso_right - center_col) / 2))\n        else:\n            torso_half = max(1, w//6)\n    for r in range(top_h):\n        cols = np.where(mask[r, :])[0]\n        if cols.size:\n            left = cols.min()\n            right = cols.max()\n            left_excess.append(max(0, (center_col - torso_half) - left))\n            right_excess.append(max(0, right - (center_col + torso_half)))\n    if not left_excess and not right_excess:\n        return 0.0\n    avg_excess = (np.mean(left_excess) if left_excess else 0.0) + (np.mean(right_excess) if right_excess else 0.0)\n    avg_excess = avg_excess / 2.0\n    return float(avg_excess / float(w))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Mean absolute Laplacian magnitude in the center region (texture/edge curvature)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 3 or w < 3:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    # center region\n    ch0, ch1 = h // 4, w // 4\n    center = gray[ch0:3 * ch0 if 3 * ch0 <= h else h, ch1:3 * ch1 if 3 * ch1 <= w else w]\n    if center.size == 0:\n        center = gray\n    # compute 2D Laplacian via convolution with kernel [[0,1,0],[1,-4,1],[0,1,0]]\n    C = center.astype(float)\n    lap = np.zeros_like(C)\n    lap[1:-1, 1:-1] = (C[0:-2, 1:-1] + C[2:, 1:-1] + C[1:-1, 0:-2] + C[1:-1, 2:] - 4.0 * C[1:-1, 1:-1])\n    # border handling: approximate with simple differences\n    if C.shape[0] >= 2:\n        lap[0, :] = C[1, :] - C[0, :]\n        lap[-1, :] = C[-2, :] - C[-1, :]\n    if C.shape[1] >= 2:\n        lap[:, 0] = C[:, 1] - C[:, 0]\n        lap[:, -1] = C[:, -2] - C[:, -1]\n    mag = np.mean(np.abs(lap))\n    return float(mag)\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Vertical centroid position of the object (mean row index of object pixels) normalized by image height (0 = top, 1 = bottom)'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    h, w = gray.shape[:2]\n    if h == 0:\n        return 0.5\n    thresh = np.mean(gray) + 0.25 * np.std(gray)\n    binary = gray > thresh\n    ys, xs = np.where(binary)\n    if ys.size == 0:\n        return 0.5\n    centroid_y = np.mean(ys)\n    return float(centroid_y / max(1.0, h - 1))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Foreground fill ratio inside its bounding box (mask area / bbox area)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 50)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    ys, xs = np.where(mask)\n    if ys.size == 0:\n        return 0.0\n    area = float(ys.size)\n    ymin, ymax = int(np.min(ys)), int(np.max(ys))\n    xmin, xmax = int(np.min(xs)), int(np.max(xs))\n    bbox_area = float(max(1, (ymax - ymin + 1)) * max(1, (xmax - xmin + 1)))\n    return float(area / (bbox_area + 1e-8))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Estimated number of vertical blobs by counting peaks in the vertical projection (integer-valued)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    vproj = np.sum(mask.astype(float), axis=1)\n    if vproj.size == 0:\n        return 0.0\n    vmax = np.max(vproj)\n    if vmax <= 0:\n        return 0.0\n    seg_mask = vproj > (0.12 * vmax)  # threshold to ignore light noise\n    pad = np.concatenate(([0], seg_mask.astype(int), [0]))\n    d = np.diff(pad)\n    starts = np.where(d == 1)[0]\n    ends = np.where(d == -1)[0]\n    count = starts.size\n    return float(count)\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Fractional distance from top to first foreground row (0 = touching top)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = gray < thr if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else gray > thr\n    rows_any = np.any(mask, axis=1)\n    if not np.any(rows_any):\n        return 0.0\n    first = int(np.argmax(rows_any))\n    return float(first / float(max(1, h - 1)))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Aspect ratio (width / height) of the foreground bounding box'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    ys, xs = np.where(mask)\n    if ys.size == 0:\n        return 0.0\n    miny, maxy = int(np.min(ys)), int(np.max(ys))\n    minx, maxx = int(np.min(xs)), int(np.max(xs))\n    bbox_h = float(max(1, maxy - miny + 1))\n    bbox_w = float(max(1, maxx - minx + 1))\n    return float(bbox_w / bbox_h)\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Color channel spread: (max channel mean - min channel mean) normalized by overall mean (0 for grayscale)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    if len(image.shape) != 3:\n        return 0.0\n    # compute per-channel mean\n    ch_means = [float(np.mean(image[:, :, i])) for i in range(image.shape[2])]\n    mn = min(ch_means)\n    mx = max(ch_means)\n    overall = float(np.mean(ch_means)) + 1e-8\n    return float((mx - mn) / overall)\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Vertical symmetry score (mean absolute difference between top half and flipped bottom)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 2 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    mid = h // 2\n    top = gray[:mid, :]\n    bottom = gray[h - mid:, :]\n    # flip bottom vertically to compare with top\n    bottom_flip = np.flipud(bottom)\n    # align widths if needed\n    if top.shape[0] == 0 or bottom_flip.shape[0] == 0:\n        return 0.0\n    m = min(top.shape[0], bottom_flip.shape[0])\n    top = top[:m, :]\n    bottom_flip = bottom_flip[:m, :]\n    diff = np.abs(top - bottom_flip)\n    return float(np.mean(diff))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Fraction of object pixels that lie in the lower half of the image'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    total = np.count_nonzero(mask)\n    if total == 0:\n        return 0.0\n    lower = mask[h//2:, :]\n    lower_count = np.count_nonzero(lower)\n    return float(lower_count / (total + 1e-8))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Ratio of average object width in the top quarter of its bbox to the middle quarter (shoulder width indicator)'\n    import numpy as np\n    gray = np.mean(image, axis=2) if len(image.shape) == 3 else image.astype(float)\n    gray = gray.astype(float)\n    h, w = gray.shape\n    dr = float(gray.max() - gray.min())\n    thr = float(np.mean(gray) + 0.15 * dr) if dr > 0 else float(np.mean(gray))\n    mask = (gray > thr)\n    rows = np.where(np.any(mask, axis=1))[0]\n    if rows.size == 0:\n        return 1.0\n    top_row, bot_row = int(rows[0]), int(rows[-1])\n    bbox_h = max(1, bot_row - top_row + 1)\n    # define quarters within bounding box\n    q = bbox_h // 4\n    top_slice = mask[top_row: top_row + max(1, q), :]\n    mid_slice = mask[top_row + max(1, q): top_row + max(1, 2 * q), :]\n    def avg_width(slice_mask):\n        widths = []\n        for row in slice_mask:\n            cols = np.where(row)[0]\n            if cols.size:\n                widths.append(float(cols[-1] - cols[0] + 1))\n        return float(np.mean(widths)) if len(widths) else 0.0\n    top_w = avg_width(top_slice)\n    mid_w = avg_width(mid_slice)\n    if mid_w <= 1e-6:\n        return float(top_w)\n    return float(top_w / (mid_w + 1e-9))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Approximate perimeter-to-area ratio of the object inside its bounding box (higher for strapty sandals)'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    thr = max((np.mean(gray) + np.min(gray)) * 0.5, np.min(gray) + 1e-6)\n    binary = (gray > thr).astype(np.int32)\n    coords = np.where(binary)\n    if coords[0].size == 0:\n        return 0.0\n    r0, r1 = coords[0].min(), coords[0].max()\n    c0, c1 = coords[1].min(), coords[1].max()\n    crop = binary[r0:r1+1, c0:c1+1]\n    area = np.sum(crop)\n    if area == 0:\n        return 0.0\n    # approximate perimeter via XOR with shifted versions\n    vert_change = np.abs(crop - np.roll(crop, 1, axis=0))\n    horiz_change = np.abs(crop - np.roll(crop, 1, axis=1))\n    edges = ((vert_change + horiz_change) > 0).astype(np.int32)\n    perimeter = np.sum(edges)\n    ratio = perimeter / float(area)\n    return float(ratio)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Vertical occupancy fraction: bounding box height divided by image height (how tall the object is in frame)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    maxv = float(np.max(gray))\n    th = maxv * 0.08\n    mask = gray > th\n    if mask.sum() == 0:\n        th = float(np.mean(gray))\n        mask = gray > th\n    if mask.sum() == 0:\n        mask = gray > np.min(gray)\n    ys, xs = np.where(mask)\n    if ys.size == 0:\n        return 0.0\n    r0, r1 = int(ys.min()), int(ys.max())\n    h = gray.shape[0]\n    return float((r1 - r0 + 1) / max(1.0, float(h)))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Ratio of mask mass in top half to bottom half (1 => equal)'\n    import numpy as np\n    if image is None:\n        return 1.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 1.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    mid = h // 2\n    top_mass = float(np.count_nonzero(mask[:mid, :]))\n    bot_mass = float(np.count_nonzero(mask[mid:, :]))\n    return float((top_mass + 1e-8) / (bot_mass + 1e-8))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Count of 4-connected foreground components (small components included)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 50)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    mask = mask.astype(np.uint8)\n    visited = np.zeros_like(mask, dtype=np.uint8)\n    comps = 0\n    for y in range(h):\n        for x in range(w):\n            if mask[y, x] and not visited[y, x]:\n                comps += 1\n                # flood fill stack\n                stack = [(y, x)]\n                visited[y, x] = 1\n                while stack:\n                    cy, cx = stack.pop()\n                    # neighbors 4-connected\n                    if cy > 0 and mask[cy - 1, cx] and not visited[cy - 1, cx]:\n                        visited[cy - 1, cx] = 1; stack.append((cy - 1, cx))\n                    if cy + 1 < h and mask[cy + 1, cx] and not visited[cy + 1, cx]:\n                        visited[cy + 1, cx] = 1; stack.append((cy + 1, cx))\n                    if cx > 0 and mask[cy, cx - 1] and not visited[cy, cx - 1]:\n                        visited[cy, cx - 1] = 1; stack.append((cy, cx - 1))\n                    if cx + 1 < w and mask[cy, cx + 1] and not visited[cy, cx + 1]:\n                        visited[cy, cx + 1] = 1; stack.append((cy, cx + 1))\n    return float(comps)\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Average number of contiguous foreground segments per row (normalized by width)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    seg_counts = []\n    for r in range(h):\n        row = mask[r]\n        idx = np.where(row)[0]\n        if idx.size == 0:\n            continue\n        splits = np.where(np.diff(idx) > 1)[0]\n        nseg = 1 + splits.size\n        seg_counts.append(float(nseg))\n    if len(seg_counts) == 0:\n        return 0.0\n    avg_segs = float(np.mean(seg_counts))\n    return float(avg_segs / float(max(1, w)))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Left-right symmetry of the mask measured as intersection-over-union with flipped mask'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 50)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    if not np.any(mask):\n        return 0.0\n    flipped = np.fliplr(mask)\n    inter = np.count_nonzero(mask & flipped)\n    union = np.count_nonzero(mask | flipped)\n    if union == 0:\n        return 0.0\n    return float(inter / float(union))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Horizontal centroid shift between top and bottom halves (abs delta x / width)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 2 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    top = mask[:h // 2, :]\n    bot = mask[h // 2:, :]\n    xs = np.arange(w).astype(float)\n    def centroid_x(m):\n        if not np.any(m):\n            return None\n        cols = np.sum(m, axis=0)\n        total = float(np.sum(cols))\n        if total <= 0:\n            return None\n        return float(np.sum(xs * cols) / total)\n    cx_top = centroid_x(top)\n    cx_bot = centroid_x(bot)\n    if cx_top is None or cx_bot is None:\n        return 0.0\n    return float(abs(cx_top - cx_bot) / (w + 1e-8))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Average red bias magnitude (|R-G| + |R-B|) normalized by 510, 0 for grayscale images'\n    import numpy as np\n    if image is None:\n        return 0.0\n    if len(image.shape) != 3 or image.shape[2] != 3:\n        return 0.0\n    img = image.astype(float)\n    R = img[:, :, 0]\n    G = img[:, :, 1]\n    B = img[:, :, 2]\n    bias = np.mean(np.abs(R - G) + np.abs(R - B))\n    # max possible per pixel is 510 (255+255)\n    return float(bias / (510.0 + 1e-8))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Fraction of object pixels that lie in the top third of the bounding box (0..1)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    thr = float(np.percentile(gray, 50))\n    mask = gray > thr\n    if not np.any(mask):\n        return 0.0\n    rows = np.any(mask, axis=1)\n    cols = np.any(mask, axis=0)\n    rmin, rmax = int(np.argmax(rows)), len(rows) - int(np.argmax(rows[::-1])) - 1\n    cmin, cmax = int(np.argmax(cols)), len(cols) - int(np.argmax(cols[::-1])) - 1\n    bbox = mask[rmin:rmax+1, cmin:cmax+1]\n    bh = bbox.shape[0]\n    top_third = bbox[0:max(1, bh // 3), :]\n    total = float(np.sum(bbox))\n    if total <= 0:\n        return 0.0\n    top_count = float(np.sum(top_third))\n    return float(top_count / total)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Top-to-bottom mask area ratio: fraction of mask pixels in top third vs bottom third'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 3 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    top_end = max(1, h // 3)\n    bot_start = max(0, h - h // 3)\n    top_area = float(np.count_nonzero(mask[:top_end, :]))\n    bot_area = float(np.count_nonzero(mask[bot_start:, :]))\n    if bot_area <= 0:\n        return float(top_area / (1e-8 + bot_area))\n    return float(top_area / (bot_area + 1e-8))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Relative mass of pixels in the bottom half vs top half of the bounding box (coats tend to have heavier lower halves)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    mx = float(np.max(gray))\n    thr = max(0.4 * float(np.mean(gray)), 0.12 * mx)\n    mask = gray > thr\n    coords = np.argwhere(mask)\n    if coords.size == 0:\n        return 0.0\n    ys = coords[:, 0]\n    miny, maxy = ys.min(), ys.max()\n    mid = (miny + maxy) // 2\n    top_count = np.sum(ys <= mid)\n    bottom_count = np.sum(ys > mid)\n    if top_count == 0:\n        return float(bottom_count)\n    return float(bottom_count / top_count)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Upper-corner diagonal edge prominence ratio (lapel-like diagonal edges detection)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    gray = np.mean(image, axis=2) if len(image.shape) == 3 else image.astype(float)\n    h, w = gray.shape[:2]\n    if h < 3 or w < 3:\n        return 0.0\n    # diagonal differences\n    d1 = np.abs(gray[:-1, :-1] - gray[1:, 1:])\n    d2 = np.abs(gray[:-1, 1:] - gray[1:, :-1])\n    # upper-left and upper-right quadrants\n    mid_h, mid_w = max(1, h//3), max(1, w//3)\n    ul = d1[:mid_h, :mid_w].sum() + d2[:mid_h, :mid_w].sum()\n    ur = d1[:mid_h, -mid_w:].sum() + d2[:mid_h, -mid_w:].sum()\n    total_edge = (np.abs(np.gradient(gray)[0]).sum() + np.abs(np.gradient(gray)[1]).sum()) + 1e-6\n    score = (ul + ur) / total_edge\n    return float(score)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Central neck-gap score: fraction of background pixels in a top-centered box (higher for round-neck shirts/tops)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    rng = gray.max() - gray.min()\n    thr = np.mean(gray) + (0.12 * rng if rng > 0 else 0.0)\n    mask = gray > thr\n    # top center box: top 20% height, center 30% width\n    top_h = max(1, h * 20 // 100)\n    cw = max(1, w * 30 // 100)\n    cstart = max(0, (w - cw) // 2)\n    box = mask[:top_h, cstart:cstart+cw]\n    total = box.size\n    if total == 0:\n        return 0.0\n    bg = total - np.count_nonzero(box)\n    return float(bg / float(total))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Variance of row-wise object widths in the bottom half normalized by image width (captures flaring/irregular bottom)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    maxv = gray.max()\n    if maxv == 0:\n        return 0.0\n    mask = gray > (maxv * 0.1)\n    lower = mask[h//2:, :]\n    if lower.size == 0:\n        return 0.0\n    widths = lower.sum(axis=1).astype(float)\n    if widths.size <= 1:\n        return 0.0\n    var = float(np.var(widths)) / float(w*w)\n    return var\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Ratio of mean mask width in bottom quarter to mean mask width in top quarter (clothing part indicator)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 4 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    top_end = max(1, h // 4)\n    bot_start = max(0, h - max(1, h // 4))\n    top_rows = mask[:top_end, :]\n    bot_rows = mask[bot_start:, :]\n    def mean_width(region):\n        if region.size == 0:\n            return 0.0\n        widths = np.count_nonzero(region, axis=1).astype(float) / max(1.0, w)\n        if widths.size == 0:\n            return 0.0\n        return float(np.mean(widths))\n    top_w = mean_width(top_rows)\n    bot_w = mean_width(bot_rows)\n    return float(bot_w / (top_w + 1e-8))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Fraction of object pixels appearing in the bottom 20% of the object bounding box'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    mean, std = float(np.mean(gray)), float(np.std(gray))\n    thresh = mean + 0.5 * std\n    mask = gray > thresh\n    if np.count_nonzero(mask) == 0:\n        thresh = float(np.max(gray)) * 0.5\n        mask = gray > thresh\n    if np.count_nonzero(mask) == 0:\n        return 0.0\n    rows, cols = np.where(mask)\n    rmin, rmax = rows.min(), rows.max()\n    cmin, cmax = cols.min(), cols.max()\n    bbox = mask[rmin:rmax+1, cmin:cmax+1]\n    h = bbox.shape[0]\n    bot_h = max(1, int(np.ceil(0.2 * h)))\n    bot_region = bbox[-bot_h:, :]\n    bot_count = np.count_nonzero(bot_region)\n    total_count = np.count_nonzero(bbox)\n    return float(bot_count / (total_count + 1e-6))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Standard deviation of bottom-edge x positions across columns (normalized by image width) - measures skirt scallopiness'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    thr = np.mean(gray) + 0.15 * (np.max(gray) - np.min(gray))\n    mask = gray > thr\n    if not mask.any():\n        mask = gray > np.mean(gray)\n        if not mask.any():\n            return 0.0\n    bottom_y = np.full(w, -1, dtype=int)\n    for col in range(w):\n        rows = np.where(mask[:, col])[0]\n        if rows.size:\n            bottom_y[col] = rows.max()\n    valid = bottom_y >= 0\n    if not np.any(valid):\n        return 0.0\n    std = float(np.std(bottom_y[valid]))\n    return float(std / (h + 1e-8))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Left-right symmetry score computed on central vertical band (1.0 = perfect symmetry)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w < 2:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    # use central vertical band to avoid background edges\n    col0 = w // 8\n    col1 = w - col0\n    band = gray[:, col0:col1]\n    mh, mw = band.shape\n    if mw < 2:\n        return 0.0\n    half = mw // 2\n    left = band[:, :half]\n    right = band[:, -half:]\n    # flip right horizontally to compare\n    right_flipped = np.fliplr(right)\n    # if shapes differ (odd width) crop to min\n    minw = min(left.shape[1], right_flipped.shape[1])\n    left = left[:, :minw]\n    right_flipped = right_flipped[:, :minw]\n    denom = np.mean(np.abs(band)) + 1e-8\n    diff = np.mean(np.abs(left - right_flipped))\n    score = 1.0 - (diff / denom)\n    return float(max(0.0, min(1.0, score)))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Principal axis orientation of the mask (0=horizontal, 1=vertical)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 50)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    ys, xs = np.where(mask)\n    if ys.size < 3:\n        return 0.0\n    # compute covariance of coordinates (x,y)\n    cx = np.mean(xs.astype(float))\n    cy = np.mean(ys.astype(float))\n    xs0 = xs.astype(float) - cx\n    ys0 = ys.astype(float) - cy\n    cov_xx = np.mean(xs0 * xs0)\n    cov_yy = np.mean(ys0 * ys0)\n    cov_xy = np.mean(xs0 * ys0)\n    # principal eigenvector angle\n    theta = 0.5 * np.arctan2(2 * cov_xy, (cov_xx - cov_yy) + 1e-12)\n    # angle of major axis (perpendicular if needed) -> map absolute angle to [0, pi/2]\n    ang = np.abs(theta)\n    if ang > np.pi/2:\n        ang = np.pi - ang\n    # map 0..pi/2 to 0..1 where 1 means vertical (pi/2)\n    return float(ang / (np.pi/2 + 1e-12))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Mean absolute horizontal gradient in the upper half normalized by mean absolute gradient of the whole image (capturing collars/straps)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    gray = gray.astype(float)\n    h, w = gray.shape[:2]\n    if h < 2:\n        return 0.0\n    gx = np.abs(np.gradient(gray, axis=1))\n    whole_mean = np.mean(gx)\n    upper_mean = np.mean(gx[:max(1, h // 2), :])\n    if whole_mean == 0:\n        return float(upper_mean)\n    return float(upper_mean / (whole_mean + 1e-8))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Vertical texture: standard deviation of vertical gradient magnitude inside object mask (higher => more seams/buttons)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    gy = np.abs(np.gradient(gray, axis=0))\n    mask = gray > np.mean(gray)\n    if np.count_nonzero(mask) == 0:\n        mask = gray > (np.min(gray) + 0.5 * (np.max(gray) - np.min(gray)))\n    vals = gy[mask]\n    if vals.size == 0:\n        return 0.0\n    return float(np.std(vals))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Standard deviation of the left-side object edge column positions in the upper half (lower value => straighter side); normalized by width'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    upper_h = max(1, h // 2)\n    edge_cols = []\n    for r in range(upper_h):\n        row = gray[r, :]\n        nz = np.where(row > 0)[0]\n        if nz.size:\n            edge_cols.append(float(nz[0]))\n    if not edge_cols:\n        return 1.0  # return high value when no edge found (no object)\n    std = float(np.std(edge_cols))\n    return float(std / (w + 1e-6))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Ratio of summed absolute vertical gradients to horizontal gradients within foreground (vertical/horizontal texture)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    gx, gy = np.gradient(gray)\n    abs_gx = np.abs(gx)\n    abs_gy = np.abs(gy)\n    thresh = np.mean(gray) + 0.25 * np.std(gray)\n    fg = gray > thresh\n    if fg.sum() == 0:\n        fg = gray > np.mean(gray)\n    sum_v = float(np.sum(abs_gy[fg]))\n    sum_h = float(np.sum(abs_gx[fg]))\n    return float((sum_v + 1e-6) / (sum_h + 1e-6))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Relative edge density of the side vertical strips versus the center (higher if lapels/strong side edges exist)'\n    import numpy as np\n    gray = np.mean(image, axis=2) if len(image.shape) == 3 else image.astype(float)\n    thr = np.mean(gray) * 0.5\n    mask = gray > thr\n    if np.count_nonzero(mask) < 10:\n        mask = gray > (np.max(gray) * 0.05)\n    ys, xs = np.where(mask)\n    if ys.size == 0:\n        return 0.0\n    ymin, ymax = ys.min(), ys.max()\n    xmin, xmax = xs.min(), xs.max()\n    bbox = gray[ymin:ymax+1, xmin:xmax+1].astype(float)\n    bh, bw = bbox.shape\n    gy, gx = np.gradient(bbox)\n    mag = np.sqrt(gy * gy + gx * gx)\n    strip_w = max(1, bw // 6)\n    left = mag[:, :strip_w]\n    right = mag[:, bw - strip_w:]\n    center = mag[:, (bw // 2) - strip_w:(bw // 2) + strip_w]\n    left_mean = np.mean(left) if left.size > 0 else 0.0\n    right_mean = np.mean(right) if right.size > 0 else 0.0\n    center_mean = np.mean(center) if center.size > 0 else 1e-6\n    side_mean = (left_mean + right_mean) / 2.0\n    return float((side_mean + 1e-6) / (center_mean + 1e-6))\n",
    "def feature(image: np.ndarray) -> float:\n    'Upper-third sleeve protrusion score: average horizontal protrusion of left and right upper-third edges from the image center (normalized)'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    h, w = gray.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    upper_h = max(1, h // 3)\n    region = gray[:upper_h, :]\n    thresh = np.mean(region) + 0.25 * np.std(region)\n    bin_reg = region > thresh\n    center = w / 2.0\n    left_mins = []\n    right_maxs = []\n    for r in range(bin_reg.shape[0]):\n        row = bin_reg[r]\n        ones = np.where(row)[0]\n        if ones.size:\n            left_mins.append(ones.min())\n            right_maxs.append(ones.max())\n    if not left_mins or not right_maxs:\n        return 0.0\n    mean_left = np.mean(left_mins)\n    mean_right = np.mean(right_maxs)\n    protrusion = (center - mean_left) + (mean_right - center)\n    return float(protrusion / max(1.0, w))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Variance of the image Laplacian approximation (higher -> more texture / sharpness)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 2 or w < 2:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    # approximate Laplacian with second derivatives\n    gy, gx = np.gradient(gray.astype(float))\n    gyy, _ = np.gradient(gy)\n    _, gxx = np.gradient(gx)\n    lap = gxx + gyy\n    return float(np.var(lap))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Absolute top-half left-vs-right mass asymmetry (normalized): captures lapels or asymmetric collars'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    top_h = max(1, h // 4)\n    left_sum = float(np.sum(gray[0:top_h, 0:w // 2] > 0))\n    right_sum = float(np.sum(gray[0:top_h, w // 2:w] > 0))\n    denom = left_sum + right_sum + 1e-9\n    return abs(left_sum - right_sum) / denom\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Background fraction in a small top-center box (detect neckline/neck hole)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    thr_h = max(1, h * 10 // 100)\n    thr_w = max(1, w * 20 // 100)\n    center_c = w // 2\n    left = max(0, center_c - thr_w // 2)\n    right = min(w, left + thr_w)\n    region = mask[:thr_h, left:right]\n    if region.size == 0:\n        return 0.0\n    bg_frac = 1.0 - float(np.mean(region.astype(float)))\n    return float(bg_frac)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Ratio of object area in the top quarter vs bottom quarter of the bounding box (top_area / (bottom_area+eps))'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    thr = float(np.mean(gray) + 0.12 * (np.std(gray) + 1e-9))\n    mask = gray > thr\n    ys, xs = np.nonzero(mask)\n    if ys.size == 0:\n        return 0.0\n    minr, maxr = int(ys.min()), int(ys.max())\n    minc, maxc = int(xs.min()), int(xs.max())\n    bh = maxr - minr + 1\n    if bh <= 1:\n        return 0.0\n    top_cut = minr + bh // 4\n    bottom_cut = maxr - bh // 4\n    top_area = float(np.count_nonzero(mask[minr:top_cut+1, minc:maxc+1]))\n    bottom_area = float(np.count_nonzero(mask[bottom_cut:maxr+1, minc:maxc+1]))\n    return float(top_area / (bottom_area + 1e-9))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Top-profile curvature around the center: quadratic fit coefficient of object top contour (positive = U-shaped dip)'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    if gray.size == 0:\n        return 0.0\n    try:\n        if np.mean(gray) < 0.5 * (np.max(gray) + np.min(gray)):\n            mask = gray < np.percentile(gray, 90)\n        else:\n            mask = gray > np.percentile(gray, 10)\n    except Exception:\n        mask = gray < np.mean(gray)\n    if np.count_nonzero(mask) == 0:\n        return 0.0\n    rows, cols = np.where(mask)\n    r0, r1 = rows.min(), rows.max()\n    c0, c1 = cols.min(), cols.max()\n    # compute topmost (minimal row) per column in bbox\n    top_profile = []\n    xs = []\n    for c in range(c0, c1+1):\n        col = mask[r0:r1+1, c]\n        ys = np.where(col)[0]\n        if ys.size > 0:\n            top_profile.append(r0 + int(ys.min()))\n            xs.append(c - c0)\n    if len(xs) < 5:\n        return 0.0\n    xs = np.array(xs)\n    ys = np.array(top_profile)\n    # focus on central region (middle 50% of columns) to reduce noise\n    total_w = c1 - c0 + 1\n    left_cut = int(0.25 * total_w)\n    right_cut = int(0.75 * total_w)\n    sel = (xs >= left_cut) & (xs <= right_cut)\n    if np.sum(sel) < 5:\n        sel = np.ones_like(xs, dtype=bool)\n    xs_sel = xs[sel].astype(float)\n    ys_sel = ys[sel].astype(float)\n    # center data for numerical stability\n    xs_cent = xs_sel - xs_sel.mean()\n    try:\n        coeffs = np.polyfit(xs_cent, ys_sel, 2)\n    except Exception:\n        return 0.0\n    # coeffs[0] is quadratic curvature; scale by image height for normalization\n    curvature = coeffs[0] * (total_w ** 2) / (r1 - r0 + 1 + 1e-6)\n    return float(curvature)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Measure of how much the object widens toward the bottom: (width at 80% - width at 40%) normalized by image width'\n    import numpy as np\n    if image is None:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    thr = np.mean(gray) + 0.4 * np.std(gray)\n    mask = gray > thr\n    if mask.sum() < 0.01 * h * w:\n        thr = np.percentile(gray, 50)\n        mask = gray > thr\n    rows, cols = np.where(mask)\n    if rows.size == 0:\n        return 0.0\n    # compute row-wise widths as counts per row within bounding box\n    r0, r1 = rows.min(), rows.max() + 1\n    sub = mask[r0:r1, :]\n    widths = sub.sum(axis=1).astype(float)\n    if widths.size < 2:\n        return 0.0\n    # pick indices relative to sub\n    idx40 = int(0.4 * (widths.size - 1))\n    idx80 = int(0.8 * (widths.size - 1))\n    w40 = np.mean(widths[max(0, idx40-1):min(widths.size, idx40+2)]) if widths.size>2 else widths[idx40]\n    w80 = np.mean(widths[max(0, idx80-1):min(widths.size, idx80+2)]) if widths.size>2 else widths[idx80]\n    result = float((w80 - w40) / (w + 1e-9))\n    return result\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Collar/neck edge strength: mean absolute horizontal gradient in a top-center band normalized by global gradient'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    # gradients: gy (row), gx (col)\n    gy, gx = np.gradient(gray.astype(float))\n    abs_gx = np.abs(gx)\n    top_rows = max(1, h // 4)\n    center_cols_start = max(0, w // 4)\n    center_cols_end = min(w, 3 * w // 4)\n    band = abs_gx[:top_rows, center_cols_start:center_cols_end]\n    global_mean = np.mean(abs_gx) + 1e-8\n    band_mean = np.mean(band) if band.size else 0.0\n    return float(band_mean / global_mean)\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Ratio of high-frequency energy in the top half to the bottom half (laplacian energy ratio)'\n    import numpy as np\n    if image is None:\n        return 1.0\n    h, w = image.shape[:2]\n    if h < 3 or w < 3:\n        return 1.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    # compute Laplacian (same kernel used in other features)\n    pad = np.pad(gray, 1, mode='edge').astype(float)\n    center = pad[1:-1, 1:-1]\n    up = pad[0:-2, 1:-1]\n    down = pad[2:, 1:-1]\n    left = pad[1:-1, 0:-2]\n    right = pad[1:-1, 2:]\n    lap = up + down + left + right - 4.0 * center\n    mid = h // 2\n    top_energy = float(np.mean(np.abs(lap[0:mid, :]))) if mid > 0 else 0.0\n    bot_energy = float(np.mean(np.abs(lap[mid:, :]))) if h - mid > 0 else 0.0\n    return float((top_energy + 1e-8) / (bot_energy + 1e-8))\n",
    "def feature(image: np.ndarray) -> float:\n    'Vertical symmetry score: normalized mean absolute difference between top half and flipped bottom half (lower = more symmetric vertically)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    h = gray.shape[0]\n    half = h // 2\n    top = gray[:half, :]\n    bottom = gray[-half:, :]\n    # ensure same shape\n    if top.shape != bottom.shape:\n        m = min(top.shape[0], bottom.shape[0])\n        top = top[:m, :]\n        bottom = bottom[-m:, :]\n    if top.size == 0:\n        return 0.0\n    diff = np.abs(top - np.flipud(bottom))\n    denom = np.mean(np.abs(gray)) + 1e-9\n    return float(np.mean(diff) / denom)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Normalized contrast between center region and image border (positive => center brighter)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    ch0 = h // 4\n    cw0 = w // 4\n    center = gray[ch0:h - ch0, cw0:w - cw0]\n    # border: union of edges 10% wide\n    bh = max(1, h // 10)\n    bw = max(1, w // 10)\n    top = gray[:bh, :]\n    bottom = gray[-bh:, :]\n    left = gray[:, :bw]\n    right = gray[:, -bw:]\n    border_concat = np.concatenate([top.flatten(), bottom.flatten(), left.flatten(), right.flatten()])\n    if center.size == 0 or border_concat.size == 0:\n        return 0.0\n    center_mean = float(np.mean(center))\n    border_mean = float(np.mean(border_concat))\n    denom = abs(border_mean) + 1e-8\n    return float((center_mean - border_mean) / denom)\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Mean absolute vertical-gradient energy (|dI/dx|) inside the central third columns (captures zipper/button vertical line)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    # compute horizontal derivative (change across columns)\n    gx = np.abs(np.gradient(gray, axis=1))\n    c1 = w // 3\n    c2 = w - c1\n    center_slice = gx[:, c1:c2]\n    if center_slice.size == 0:\n        return 0.0\n    return float(np.mean(center_slice))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Count of contiguous mask column groups in the bottom 25% (clipped to 5)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    start = max(0, h - max(1, h // 4))\n    band = mask[start:h, :]\n    # collapse to columns that have any mask\n    col_has = np.any(band, axis=0).astype(int)\n    if col_has.sum() == 0:\n        return 0.0\n    # count contiguous groups\n    diff = np.diff(np.concatenate(([0], col_has, [0])))\n    starts = np.where(diff == 1)[0]\n    ends = np.where(diff == -1)[0]\n    groups = max(0, len(starts))\n    return float(min(groups, 5))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Number of foreground segments in the central vertical column (counts separated vertical blobs)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    col = w // 2\n    col_mask = mask[:, col] if col >= 0 and col < w else np.zeros((h,), dtype=bool)\n    if col_mask.size == 0:\n        return 0.0\n    # count rising edges from 0->1\n    padded = np.concatenate([[0], col_mask.astype(int), [0]])\n    transitions = np.diff(padded)\n    starts = np.count_nonzero(transitions == 1)\n    return float(starts)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Mask fill fraction: mask area divided by bounding-box area (compactness)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    total = float(np.count_nonzero(mask))\n    if total == 0:\n        return 0.0\n    ys, xs = np.where(mask)\n    miny, maxy = int(np.min(ys)), int(np.max(ys))\n    minx, maxx = int(np.min(xs)), int(np.max(xs))\n    bbox_area = float((maxy - miny + 1) * (maxx - minx + 1))\n    if bbox_area <= 1e-8:\n        return 0.0\n    return float(total / bbox_area)\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Maximum vertical contiguous foreground run length across columns normalized by image height'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    max_run = 0\n    for col in range(w):\n        col_mask = mask[:, col]\n        if col_mask.size == 0:\n            continue\n        # find longest run of True in this column\n        run = 0\n        best = 0\n        for v in col_mask:\n            if v:\n                run += 1\n            else:\n                if run > best:\n                    best = run\n                run = 0\n        if run > best:\n            best = run\n        if best > max_run:\n            max_run = best\n    return float(max_run / float(max(1, h)))\n",
    "def feature(image: np.ndarray) -> float:\n    'High-frequency energy ratio: fraction of gradient energy above median level'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 2 or w < 2:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    gy, gx = np.gradient(gray)\n    grad_sq = gx * gx + gy * gy\n    median = np.median(grad_sq)\n    total = np.sum(grad_sq)\n    if total <= 0:\n        return 0.0\n    high_energy = np.sum(grad_sq[grad_sq > median])\n    return float(high_energy / (total + 1e-12))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Mean color channel range (mean of per-pixel (max-min) across RGB channels), 0 if grayscale'\n    import numpy as np\n    if image is None:\n        return 0.0\n    if len(image.shape) != 3 or image.shape[2] < 3:\n        return 0.0\n    img = image.astype(float)\n    # per-pixel channel range\n    ch_max = np.max(img, axis=2)\n    ch_min = np.min(img, axis=2)\n    rng = ch_max - ch_min\n    mx = np.max(img)\n    denom = mx if mx > 0 else 1.0\n    mean_rng = float(np.mean(rng) / denom)\n    return float(mean_rng)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Rectangularity-like score: mean row width scaled by bbox width and penalized by width variability'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    ys, xs = np.where(mask)\n    if ys.size == 0:\n        return 0.0\n    miny, maxy = int(np.min(ys)), int(np.max(ys))\n    minx, maxx = int(np.min(xs)), int(np.max(xs))\n    bbox_w = float(maxx - minx + 1)\n    row_widths = np.sum(mask, axis=1).astype(float)\n    valid = row_widths[row_widths > 0]\n    if valid.size == 0 or bbox_w <= 0:\n        return 0.0\n    mean_rw = float(np.mean(valid))\n    std_rw = float(np.std(valid))\n    cv = std_rw / (mean_rw + 1e-8)\n    stability = max(0.0, 1.0 - cv)  # high when widths are consistent\n    rect_score = (mean_rw / (bbox_w + 1e-8)) * stability\n    return float(rect_score)\n",
    "def feature(image: np.ndarray) -> float:\n    'Longest vertical continuous run in center columns divided by image height (0..1)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 50)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    if not np.any(mask):\n        return 0.0\n    # use center 3 columns (or fewer if narrow)\n    center_col = w // 2\n    cols = [center_col]\n    if w > 2:\n        cols = [max(0, center_col - 1), center_col, min(w - 1, center_col + 1)]\n    col_mask = np.any(mask[:, cols], axis=1).astype(int)\n    if col_mask.sum() == 0:\n        return 0.0\n    # compute longest run of consecutive ones\n    dif = np.diff(np.concatenate(([0], col_mask, [0])))\n    starts = np.where(dif == 1)[0]\n    ends = np.where(dif == -1)[0]\n    runs = ends - starts\n    longest = float(np.max(runs)) if runs.size > 0 else 0.0\n    return float(longest / float(h))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Longest vertical run of mask (consecutive rows with mask) normalized by image height'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = ((gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)).astype(bool)\n    rows_has = np.any(mask, axis=1).astype(int)\n    if rows_has.sum() == 0:\n        return 0.0\n    max_run = 0\n    cur = 0\n    for v in rows_has:\n        if v:\n            cur += 1\n            if cur > max_run:\n                max_run = cur\n        else:\n            cur = 0\n    return float(max_run / (h + 1e-8))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Average absolute shoulder contour slope in the top half (normalized by image width)'\n    import numpy as np\n    gray = np.mean(image, axis=2) if len(image.shape) == 3 else image.astype(float)\n    if np.nanmax(gray) == np.nanmin(gray):\n        return 0.0\n    thresh = np.nanmin(gray) + 0.2 * (np.nanmax(gray) - np.nanmin(gray))\n    mask = gray > thresh\n    rows = np.where(mask.any(axis=1))[0]\n    cols = np.where(mask.any(axis=0))[0]\n    if rows.size == 0 or cols.size == 0:\n        return 0.0\n    r0, r1 = rows[0], rows[-1] + 1\n    bh = r1 - r0\n    top_end = r0 + max(1, bh // 2)\n    left_edges = []\n    right_edges = []\n    for rr in range(r0, top_end):\n        cols_on = np.where(mask[rr])[0]\n        if cols_on.size:\n            left_edges.append(cols_on[0])\n            right_edges.append(cols_on[-1])\n    if len(left_edges) < 2 or len(right_edges) < 2:\n        return 0.0\n    # fit simple slope (delta col / delta row)\n    ys = np.arange(len(left_edges))\n    # compute slopes via linear fit\n    try:\n        left_slope = np.polyfit(ys, left_edges, 1)[0]\n        right_slope = np.polyfit(ys, right_edges, 1)[0]\n    except Exception:\n        left_slope = (left_edges[-1] - left_edges[0]) / (len(left_edges)-1)\n        right_slope = (right_edges[-1] - right_edges[0]) / (len(right_edges)-1)\n    avg_abs_slope = (abs(left_slope) + abs(right_slope)) / 2.0\n    return float(avg_abs_slope / max(1.0, gray.shape[1]))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Center versus border texture contrast: ratio of mean gradient magnitude in center to border'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 4 or w < 4:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    # normalize\n    mx = np.max(gray)\n    if mx > 0:\n        gray = gray / mx\n    gy, gx = np.gradient(gray)\n    grad = np.sqrt(gx * gx + gy * gy)\n    ch, cw = h // 4, w // 4\n    center = grad[ch:3*ch, cw:3*cw]\n    # border = full minus a slightly smaller inside region\n    border_mask = np.ones_like(grad, dtype=bool)\n    border_mask[ch:3*ch, cw:3*cw] = False\n    border = grad[border_mask]\n    if center.size == 0 or border.size == 0:\n        return 0.0\n    mean_center = float(np.mean(center))\n    mean_border = float(np.mean(border))\n    return float((mean_center + 1e-8) / (mean_border + 1e-8))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Left-right imbalance score: absolute difference of mask area between left and right thirds (0..1)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w < 3:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 50)\n    mask = ((gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)).astype(bool)\n    third = max(1, w // 3)\n    left = float(np.count_nonzero(mask[:, :third]))\n    mid = float(np.count_nonzero(mask[:, third:2 * third]))\n    right = float(np.count_nonzero(mask[:, 2 * third:]))\n    total = left + mid + right\n    if total <= 0:\n        return 0.0\n    imbalance = abs(left - right) / total\n    return float(min(1.0, imbalance))\n",
    "def feature(image: np.ndarray) -> float:\n    'Number of connected foreground components (capped) normalized by image area'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 50)\n    mask = ((gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)).astype(bool)\n    visited = np.zeros_like(mask, dtype=bool)\n    comps = 0\n    max_comps = 50\n    for y in range(h):\n        for x in range(w):\n            if mask[y, x] and not visited[y, x]:\n                comps += 1\n                if comps >= max_comps:\n                    break\n                # flood fill\n                stack = [(y, x)]\n                visited[y, x] = True\n                while stack:\n                    cy, cx = stack.pop()\n                    if cy > 0 and mask[cy - 1, cx] and not visited[cy - 1, cx]:\n                        visited[cy - 1, cx] = True\n                        stack.append((cy - 1, cx))\n                    if cy + 1 < h and mask[cy + 1, cx] and not visited[cy + 1, cx]:\n                        visited[cy + 1, cx] = True\n                        stack.append((cy + 1, cx))\n                    if cx > 0 and mask[cy, cx - 1] and not visited[cy, cx - 1]:\n                        visited[cy, cx - 1] = True\n                        stack.append((cy, cx - 1))\n                    if cx + 1 < w and mask[cy, cx + 1] and not visited[cy, cx + 1]:\n                        visited[cy, cx + 1] = True\n                        stack.append((cy, cx + 1))\n        if comps >= max_comps:\n            break\n    area = float(max(1, h * w))\n    return float(min(max_comps, comps) / area)\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Mean saturation of pixels in RGB image (0-1), 0 for grayscale'\n    import numpy as np\n    if image is None:\n        return 0.0\n    if len(image.shape) != 3 or image.shape[2] < 3:\n        return 0.0\n    img = image[:, :, :3].astype(float)\n    mx = np.max(img, axis=2)\n    mn = np.min(img, axis=2)\n    # avoid division by zero\n    sat = np.zeros_like(mx, dtype=float)\n    nz = mx > 1e-8\n    sat[nz] = (mx[nz] - mn[nz]) / (mx[nz] + 1e-8)\n    return float(np.mean(sat))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Ratio between the second and first tallest column peaks in the bottom third (leg separation indicator)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 50)\n    mask = ((gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)).astype(np.uint8)\n    start = int(h * (2.0 / 3.0))\n    bottom = mask[start:, :]\n    if bottom.size == 0:\n        return 0.0\n    col_sums = np.sum(bottom, axis=0).astype(float)\n    if np.all(col_sums == 0):\n        return 0.0\n    sorted_vals = np.sort(col_sums)[::-1]\n    first = float(sorted_vals[0])\n    second = float(sorted_vals[1]) if sorted_vals.size > 1 else 0.0\n    return float(second / (first + 1e-8))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Variance of the central vertical intensity profile (detects button lines or center seams)'\n    try:\n        import numpy as np\n        h, w = image.shape[:2]\n        gray = image if len(image.shape) == 2 else np.mean(image, axis=2)\n        c1 = w // 3\n        c2 = 2 * w // 3\n        r1 = h // 4\n        r2 = 3 * h // 4\n        band = gray[r1:r2, c1:c2]\n        if band.size == 0:\n            return 0.0\n        # compute mean intensity per column and return its variance normalized\n        col_means = np.mean(band, axis=0)\n        res = float(np.var(col_means)) / (np.mean(gray) + 1e-8)\n        if not np.isfinite(res):\n            return 0.0\n        return res\n    except Exception:\n        return 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Bounding-box aspect ratio (width / height) of the dominant mask region'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    # grayscale\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 50)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    ys, xs = np.where(mask)\n    if ys.size == 0:\n        return 0.0\n    ymin, ymax = int(ys.min()), int(ys.max())\n    xmin, xmax = int(xs.min()), int(xs.max())\n    bw = float(xmax - xmin + 1)\n    bh = float(ymax - ymin + 1)\n    if bh <= 1e-8:\n        return 0.0\n    result = bw / bh\n    return float(result)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Average number of vertical transitions per column in the binary mask (normalized)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 2 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    # compute transitions per column\n    trans = np.sum(mask[:-1, :] != mask[1:, :], axis=0).astype(float)\n    avg_trans = float(np.mean(trans)) if trans.size > 0 else 0.0\n    return float(avg_trans / (h + 1e-8))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Perimeter^2 / area compactness of the mask (higher => more elongated or complex boundary)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    area = float(np.count_nonzero(mask))\n    if area == 0:\n        return 0.0\n    # perimeter estimate: mask pixels that have any 4-neighbor as background\n    m = mask.astype(int)\n    up = np.pad(m, ((1, 0), (0, 0)), mode='constant')[:-1, :]\n    down = np.pad(m, ((0, 1), (0, 0)), mode='constant')[1:, :]\n    left = np.pad(m, ((0, 0), (1, 0)), mode='constant')[:, :-1]\n    right = np.pad(m, ((0, 0), (0, 1)), mode='constant')[:, 1:]\n    neighbors = up + down + left + right\n    boundary = np.logical_and(m == 1, neighbors < 4)\n    perimeter = float(np.count_nonzero(boundary))\n    compactness = (perimeter ** 2) / (area + 1e-8)\n    return float(compactness)\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Bounding-box aspect ratio (height divided by width) of the detected foreground'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 60)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    if not np.any(mask):\n        return 0.0\n    ys, xs = np.where(mask)\n    miny, maxy = ys.min(), ys.max()\n    minx, maxx = xs.min(), xs.max()\n    bbox_h = float(maxy - miny + 1)\n    bbox_w = float(maxx - minx + 1)\n    if bbox_w <= 1e-8:\n        return float(bbox_h / (bbox_w + 1e-8))\n    return float(bbox_h / bbox_w)\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Vertical projection peakiness: max row coverage divided by mean row coverage (>=1)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    row_counts = np.count_nonzero(mask, axis=1).astype(float)\n    if row_counts.size == 0:\n        return 0.0\n    mean_rc = float(np.mean(row_counts)) + 1e-8\n    max_rc = float(np.max(row_counts))\n    return float(max_rc / mean_rc)\n",
    "def feature(image: np.ndarray) -> float:\n    'Dominant edge orientation (circular mean) normalized to [-1,1] where 0 is horizontal'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 2 or w < 2:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    gy, gx = np.gradient(gray.astype(float))\n    mag = np.sqrt(gx * gx + gy * gy)\n    if not np.any(mag):\n        return 0.0\n    # consider only strong edges to avoid noise\n    thr = np.percentile(mag, 60)\n    mask = mag > thr\n    if np.count_nonzero(mask) == 0:\n        mask = mag > (np.mean(mag) * 0.5)\n    ang = np.arctan2(gy, gx)  # [-pi, pi]\n    vals = ang[mask]\n    mags = mag[mask]\n    # circular mean via complex representation\n    comp = np.sum(mags * np.exp(1j * vals))\n    if comp == 0:\n        return 0.0\n    mean_ang = np.angle(comp)  # [-pi, pi]\n    # normalize: 0 -> horizontal, +-pi/2 -> vertical. Map to [-1,1] by dividing by pi/2\n    return float(max(-1.0, min(1.0, mean_ang / (np.pi / 2.0))))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Object width at the bottom 10% rows (fraction of image width occupied by any object pixel)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    thr = (np.mean(gray) + np.min(gray)) * 0.5\n    mask = gray > thr\n    if np.count_nonzero(mask) == 0:\n        return 0.0\n    start = max(0, h - max(1, h // 10))\n    band = mask[start:h, :]\n    if band.size == 0:\n        return 0.0\n    cols_with = np.any(band, axis=0)\n    width_at_bottom = float(np.count_nonzero(cols_with))\n    return width_at_bottom / float(w)\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Proportion of pixels with strong vertical gradient (high |d/dx|) relative to local contrast'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 2 or w < 2:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    mx = np.max(np.abs(gray))\n    if mx > 0:\n        gray = gray / mx\n    gy, gx = np.gradient(gray)\n    magx = np.abs(gx)\n    if magx.size == 0:\n        return 0.0\n    thr = np.percentile(magx.flatten(), 85)\n    if thr <= 0:\n        return 0.0\n    strong = magx > thr\n    return float(np.count_nonzero(strong)) / float(h * w)\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Largest continuous vertical background gap in the upper center strip (normalized by height)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    c1 = w // 3\n    c2 = max(c1+1, 2*w // 3)\n    strip = mask[:int(h*0.45), c1:c2]\n    if strip.size == 0:\n        return 0.0\n    # background rows where strip row sum is small\n    row_sums = np.sum(strip.astype(int), axis=1)\n    width = strip.shape[1]\n    bg = row_sums <= max(1, width // 10)\n    # find max consecutive True in bg\n    max_gap = 0\n    cur = 0\n    for v in bg:\n        if v:\n            cur += 1\n            if cur > max_gap:\n                max_gap = cur\n        else:\n            cur = 0\n    return float(max_gap / float(h + 1e-8))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Horizontal centroid offset of the foreground (-0.5 left .. 0.5 right)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 50)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    ys, xs = np.where(mask)\n    if xs.size == 0:\n        return 0.0\n    centroid_x = float(np.mean(xs))\n    offset = (centroid_x - (w - 1) / 2.0) / float(w)\n    return float(np.clip(offset, -0.5, 0.5))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Bottom contour irregularity: normalized standard deviation of the bottommost object row across columns (higher = jagged/skirt edges)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    h, w = gray.shape[:2]\n    maxv = float(np.max(gray)) if np.size(gray) else 0.0\n    if maxv <= 0:\n        return 0.0\n    thresh = maxv * 0.10\n    mask = gray > thresh\n    bottom_positions = []\n    for c in range(w):\n        rows = np.where(mask[:, c])[0]\n        if rows.size:\n            bottom_positions.append(int(np.max(rows)))\n    if len(bottom_positions) <= 1:\n        return 0.0\n    std_bottom = float(np.std(bottom_positions))\n    return float(std_bottom / float(max(1, h)))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Fraction of foreground mass located in the bottom 20% of the image'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    bottom_h = max(1, int(h * 0.20))\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    total = float(np.count_nonzero(mask))\n    if total == 0.0:\n        return 0.0\n    bottom_count = float(np.count_nonzero(mask[-bottom_h:, :]))\n    return float(bottom_count / total)\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Mean horizontal-edge strength in the upper half (captures sleeve/shoulder horizontal edges)'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    h, w = gray.shape\n    # compute gradient (gy, gx)\n    gy, gx = np.gradient(gray)\n    upper_gy = np.abs(gy[:max(1, h // 2), :])\n    mean_upper_horizontal_edge = float(np.mean(upper_gy))\n    overall = float(np.mean(np.abs(gy))) if np.mean(np.abs(gy)) > 1e-8 else 1.0\n    return float(mean_upper_horizontal_edge / overall)\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Vertical asymmetry: normalized left-right pixel difference (0 = perfectly symmetric, larger -> more asymmetric)'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    thr = np.percentile(gray, 75)\n    mask = gray > thr\n    if np.count_nonzero(mask) == 0:\n        thr = gray.mean()\n        mask = gray > thr\n    total = float(np.count_nonzero(mask))\n    if total == 0.0:\n        return 0.0\n    left = mask[:, :w//2]\n    right = mask[:, (w+1)//2:]\n    # flip right for comparison\n    right_flipped = np.fliplr(right) if right.size else np.zeros_like(left)\n    # pad to same shape\n    min_cols = min(left.shape[1], right_flipped.shape[1])\n    if min_cols == 0:\n        diff = np.count_nonzero(mask)\n    else:\n        diff = np.sum(np.abs(left[:, :min_cols].astype(int) - right_flipped[:, :min_cols].astype(int)))\n        # add unmatched columns\n        if left.shape[1] > min_cols:\n            diff += np.count_nonzero(left[:, min_cols:])\n        if right_flipped.shape[1] > min_cols:\n            diff += np.count_nonzero(right_flipped[:, min_cols:])\n    asym = float(diff) / total\n    return asym\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Fraction of object pixels present in the bottom quarter center region (middle third columns), useful to separate bags from tops'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    gray = gray.astype(float)\n    if np.nanmax(gray) == np.nanmin(gray):\n        return 0.0\n    thr = np.percentile(gray, 70)\n    mask = (gray > thr).astype(int)\n    rows, cols = np.where(mask)\n    if rows.size == 0:\n        return 0.0\n    top, bottom = rows.min(), rows.max()\n    left, right = cols.min(), cols.max()\n    h = bottom - top + 1\n    w = right - left + 1\n    b0 = bottom - max(0, int(0.25 * h)) + 1\n    c0 = left + w // 3\n    c1 = left + (2 * w) // 3\n    b0 = max(top, b0)\n    b0 = min(b0, bottom)\n    c1 = min(c1, mask.shape[1]-1)\n    region_count = np.sum(mask[b0:bottom+1, c0:c1+1])\n    total = np.sum(mask)\n    return float(region_count / (total + 1e-9))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Average strength of vertical edges in a narrow center strip (strong center seam/opening -> higher)'\n    import numpy as np\n    gray = np.mean(image, axis=2) if len(image.shape) == 3 else image.astype(float)\n    h, w = gray.shape[:2]\n    if w < 3 or h < 3:\n        return 0.0\n    gy, gx = np.gradient(gray)\n    center_w = max(1, w // 8)\n    c0 = max(0, w // 2 - center_w)\n    c1 = min(w, w // 2 + center_w)\n    gx_strip = gx[:, c0:c1]\n    mean_abs_gx_strip = float(np.mean(np.abs(gx_strip)))\n    mean_abs_gx_all = float(np.mean(np.abs(gx))) + 1e-8\n    return float(mean_abs_gx_strip / mean_abs_gx_all)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Convexity deficit approximated row-wise: 1 - (object_area / rowwise-hull-area) (higher when object has big gaps/indentations)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    mu, sd = np.mean(gray), np.std(gray)\n    thresh = mu + 0.25 * sd\n    if thresh <= np.min(gray):\n        thresh = 0.5 * (np.max(gray) + np.min(gray))\n    mask = gray > thresh\n    if not np.any(mask):\n        mask = gray > np.percentile(gray, 90)\n    if not np.any(mask):\n        return 0.0\n    ys, xs = np.where(mask)\n    minr, maxr = ys.min(), ys.max()\n    minc, maxc = xs.min(), xs.max()\n    bbox = mask[minr:maxr+1, minc:maxc+1].astype(np.bool_)\n    h, w = bbox.shape\n    object_area = float(np.sum(bbox))\n    hull_area = 0\n    for r in range(h):\n        row = bbox[r, :]\n        if np.any(row):\n            left = np.argmax(row)\n            right = w - 1 - np.argmax(row[::-1])\n            hull_area += (right - left + 1)\n    if hull_area <= 0:\n        return 0.0\n    deficit = 1.0 - (object_area / (hull_area + 1e-9))\n    return float(deficit)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Bottom contour straightness: normalized stddev of bottommost foreground row per column (lower = straighter hem)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    mu, sigma = np.mean(gray), np.std(gray)\n    eps = 1e-9\n    if sigma < 1e-6:\n        return 0.0\n    # choose foreground mask as dominant central sign\n    dark_mask = gray < (mu - 0.25 * sigma)\n    light_mask = gray > (mu + 0.25 * sigma)\n    center_area = gray[h//4:3*h//4, w//4:3*w//4]\n    if np.sum(center_area < (mu - 0.25 * sigma)) >= np.sum(center_area > (mu + 0.25 * sigma)):\n        mask = dark_mask\n    else:\n        mask = light_mask\n    bottom_idx = np.full(w, h, dtype=float)\n    for col in range(w):\n        col_mask = mask[:, col]\n        ys = np.where(col_mask)[0]\n        if ys.size > 0:\n            bottom_idx[col] = ys.max()\n    # focus on central columns to avoid noisy edges\n    left = w//10\n    right = max(left+1, w - w//10)\n    central = bottom_idx[left:right]\n    if central.size == 0:\n        return 0.0\n    std_norm = float(np.std(central) / (h + eps))\n    return std_norm\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Colorfulness metric for RGB images (0 for grayscale)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    if len(image.shape) != 3 or image.shape[2] < 3:\n        return 0.0\n    img = image.astype(float)\n    r = img[:, :, 0].flatten()\n    g = img[:, :, 1].flatten()\n    b = img[:, :, 2].flatten()\n    rg = r - g\n    yb = 0.5 * (r + g) - b\n    std_rg = np.std(rg)\n    std_yb = np.std(yb)\n    mean_rg = np.mean(rg)\n    mean_yb = np.mean(yb)\n    colorfulness = np.sqrt(std_rg * std_rg + std_yb * std_yb) + 0.3 * np.sqrt(mean_rg * mean_rg + mean_yb * mean_yb)\n    return float(colorfulness)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Overall fill fraction: foreground pixel count divided by its bounding-box area'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    mn, mx = float(np.min(gray)), float(np.max(gray))\n    thr = float(np.mean(gray)) + 0.15 * (mx - mn) if mx > mn else float(np.mean(gray))\n    fg = gray > thr\n    if not np.any(fg):\n        return 0.0\n    rows_any = np.any(fg, axis=1)\n    cols_any = np.any(fg, axis=0)\n    top = int(np.argmax(rows_any))\n    bottom = fg.shape[0] - 1 - int(np.argmax(rows_any[::-1]))\n    left = int(np.argmax(cols_any))\n    right = fg.shape[1] - 1 - int(np.argmax(cols_any[::-1]))\n    bbox_h = max(1, bottom - top + 1)\n    bbox_w = max(1, right - left + 1)\n    bbox_area = bbox_h * bbox_w\n    fill = np.count_nonzero(fg[top:bottom+1, left:right+1])\n    result = float(fill / bbox_area)\n    return result\n",
    "def feature(image: np.ndarray) -> float:\n    'Horizontal spread (std) of foreground x-coordinates in the top quarter normalized by image width'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = gray < thr if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else gray > thr\n    top_end = max(1, h // 4)\n    region = mask[:top_end, :]\n    if np.count_nonzero(region) == 0:\n        return 0.0\n    xs, ys = np.where(region)\n    if xs.size == 0:\n        return 0.0\n    std_x = float(np.std(ys.astype(float)))\n    return float(std_x / max(1.0, w))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Mean absolute second derivative (curvature) of the left and right object contours across rows, normalized by bbox width'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    thr = np.mean(gray)\n    mask = gray > thr\n    if mask.sum() < 0.01 * h * w:\n        mask = gray < thr\n    if mask.sum() == 0:\n        thr = np.percentile(gray, 50)\n        mask = gray > thr\n    if mask.sum() == 0:\n        return 0.0\n    rows, cols = np.where(mask)\n    r0, r1 = rows.min(), rows.max()\n    c0, c1 = cols.min(), cols.max()\n    sub = mask[r0:r1 + 1, c0:c1 + 1]\n    bh, bw = sub.shape\n    if bh <= 2 or bw <= 1:\n        return 0.0\n    left = np.full(bh, np.nan)\n    right = np.full(bh, np.nan)\n    for i in range(bh):\n        row = sub[i]\n        if np.any(row):\n            cols_any = np.where(row)[0]\n            left[i] = cols_any[0]\n            right[i] = cols_any[-1]\n    # interpolate NaNs\n    def interp(arr):\n        idx = np.arange(len(arr))\n        good = ~np.isnan(arr)\n        if good.sum() == 0:\n            return np.zeros_like(arr)\n        arr[~good] = np.interp(idx[~good], idx[good], arr[good])\n        return arr\n    left = interp(left)\n    right = interp(right)\n    # second discrete derivative\n    left_sec = np.abs(np.diff(left, n=2)) if len(left) >= 3 else np.array([0.0])\n    right_sec = np.abs(np.diff(right, n=2)) if len(right) >= 3 else np.array([0.0])\n    all_sec = np.concatenate([left_sec, right_sec])\n    mean_curv = float(np.mean(all_sec)) if all_sec.size > 0 else 0.0\n    return float(mean_curv / max(1.0, bw))\n",
    "def feature(image: np.ndarray) -> float:\n    'Upper-third lateral protrusion score: mean horizontal distance of upper-third object pixels from image center (normalized)'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    h, w = gray.shape\n    thr = np.mean(gray) + 0.15 * np.std(gray)\n    mask = gray > thr\n    if np.count_nonzero(mask) == 0:\n        thr2 = np.max(gray) * 0.1\n        mask = gray > thr2\n        if np.count_nonzero(mask) == 0:\n            return 0.0\n    upper_mask = mask[:max(1, h // 3), :]\n    ys, xs = np.nonzero(upper_mask)\n    if xs.size == 0:\n        return 0.0\n    center_x = w / 2.0\n    mean_dist = np.mean(np.abs(xs - center_x)) / (w / 2.0)  # normalized to [0,1+]\n    return float(mean_dist)\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Estimated number of lateral peaks in the lower half (useful to detect two shoes)'\n    import numpy as np\n    gray = np.mean(image, axis=2) if len(image.shape) == 3 else image.astype(float)\n    h, w = gray.shape[:2]\n    if h < 2 or np.all(gray == 0):\n        return 0.0\n    # project onto columns using lower half\n    proj = gray[h//2:, :].sum(axis=0)\n    if proj.sum() == 0:\n        return 0.0\n    # smooth and find local maxima above dynamic threshold\n    kernel = np.ones(3) / 3.0\n    smooth = np.convolve(proj, kernel, mode='same')\n    mean_s = smooth.mean()\n    std_s = smooth.std()\n    thresh = mean_s + 0.3 * std_s\n    peaks = 0\n    for i in range(1, len(smooth)-1):\n        if smooth[i] > smooth[i-1] and smooth[i] > smooth[i+1] and smooth[i] > thresh:\n            peaks += 1\n    return float(peaks)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Mean absolute second derivative (curvature) of the bottom contour across columns normalized by width (higher => more toe/sole curvature)'\n    h, w = image.shape[:2]\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(np.float64)\n    else:\n        gray = image.astype(np.float64)\n    denom = (gray.max() - gray.min()) + 1e-9\n    norm = (gray - gray.min()) / denom\n    mask = norm > 0.2\n    contour = np.full(w, np.nan, dtype=np.float64)\n    for c in range(w):\n        rows = np.where(mask[:, c])[0]\n        if rows.size:\n            contour[c] = float(rows.max())\n    valid = ~np.isnan(contour)\n    if valid.sum() < 3:\n        return 0.0\n    cont = contour[valid]\n    # second discrete derivative\n    sec = np.abs(np.diff(cont, n=2))\n    mean_sec = float(np.mean(sec)) / float(h)\n    return mean_sec\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Perimeter-to-area ratio of the foreground mask (higher => more elongated/complex)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = ((gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)).astype(bool)\n    area = float(np.count_nonzero(mask))\n    if area == 0.0:\n        return 0.0\n    # perimeter approx: count mask pixels that have at least one 4-neighbor background\n    perim = 0\n    for y in range(h):\n        for x in range(w):\n            if not mask[y, x]:\n                continue\n            if y == 0 or x == 0 or y == h - 1 or x == w - 1:\n                perim += 1\n                continue\n            if not (mask[y - 1, x] and mask[y + 1, x] and mask[y, x - 1] and mask[y, x + 1]):\n                perim += 1\n    return float(perim / (area + 1e-8))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Normalized width of the zero-gap around the center column in the bottom quarter (wide gap -> likely trousers)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    eps = 1e-8\n    thr = np.percentile(gray, 50) + 0.05 * (np.max(gray) - np.min(gray))\n    mask = gray > thr\n    if mask.sum() == 0:\n        return 0.0\n    bottom = mask[(3*h)//4:, :]\n    if bottom.size == 0:\n        return 0.0\n    col_nonzero = bottom.sum(axis=0) > 0\n    center = w // 2\n    # if center column occupied, gap is zero\n    if col_nonzero[center]:\n        return 0.0\n    # expand left and right from center while columns are empty\n    left = center\n    while left >= 0 and not col_nonzero[left]:\n        left -= 1\n    right = center\n    while right < w and not col_nonzero[right]:\n        right += 1\n    gap_width = (right - left - 1)\n    return float(gap_width / (w + eps))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Number of connected foreground components (4-connected) in the mask'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = ((gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)).astype(bool)\n    visited = np.zeros_like(mask, dtype=bool)\n    comp_count = 0\n    # simple stack-based flood-fill\n    for y in range(h):\n        for x in range(w):\n            if mask[y, x] and not visited[y, x]:\n                comp_count += 1\n                stack = [(y, x)]\n                visited[y, x] = True\n                while stack:\n                    cy, cx = stack.pop()\n                    # neighbors 4-connectivity\n                    if cy > 0 and mask[cy - 1, cx] and not visited[cy - 1, cx]:\n                        visited[cy - 1, cx] = True\n                        stack.append((cy - 1, cx))\n                    if cy + 1 < h and mask[cy + 1, cx] and not visited[cy + 1, cx]:\n                        visited[cy + 1, cx] = True\n                        stack.append((cy + 1, cx))\n                    if cx > 0 and mask[cy, cx - 1] and not visited[cy, cx - 1]:\n                        visited[cy, cx - 1] = True\n                        stack.append((cy, cx - 1))\n                    if cx + 1 < w and mask[cy, cx + 1] and not visited[cy, cx + 1]:\n                        visited[cy, cx + 1] = True\n                        stack.append((cy, cx + 1))\n    return float(comp_count)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Normalized vertical separation between top-third and bottom-third mask centroids'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 3 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    top_end = max(1, h // 3)\n    bot_start = h - top_end\n    top_mask = mask[:top_end, :]\n    bot_mask = mask[bot_start:, :]\n    if np.count_nonzero(top_mask) == 0 or np.count_nonzero(bot_mask) == 0:\n        return 0.0\n    top_ys, _ = np.where(top_mask)\n    bot_ys, _ = np.where(bot_mask)\n    # top region y coordinates are relative; convert to image coordinates\n    top_centroid = (np.mean(top_ys) + 0.0)  # relative to top region\n    bot_centroid = (np.mean(bot_ys) + bot_start)\n    # normalize by image height\n    sep = (bot_centroid - top_centroid) / float(h + 1e-8)\n    return float(sep)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Normalized horizontal centroid offset of the mask (-1 left .. +1 right)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = ((gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)).astype(bool)\n    if not np.any(mask):\n        return 0.0\n    xs = np.arange(w)[None, :]\n    mass = mask.astype(float)\n    total = float(np.sum(mass)) + 1e-8\n    centroid_x = float(np.sum(xs * mass) / total)\n    norm = (centroid_x / float(w) - 0.5) * 2.0\n    return float(max(-1.0, min(1.0, norm)))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Edge density in the central square region: fraction of strong gradient pixels in center'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 3 or w < 3:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    gy, gx = np.gradient(gray.astype(float))\n    mag = np.sqrt(gx * gx + gy * gy)\n    thr = np.percentile(mag, 75) if np.any(mag) else 0.0\n    strong = mag > thr\n    ch0, ch1 = h // 4, w // 4\n    center = strong[ch0:3*ch0 if 3*ch0 <= h else h, ch1:3*ch1 if 3*ch1 <= w else w]\n    if center.size == 0:\n        return 0.0\n    return float(np.count_nonzero(center) / (center.size + 1e-8))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Maximum lateral protrusion relative to object centroid: max(left_extent, right_extent) normalized by bbox width'\n    try:\n        if len(image.shape) == 3:\n            gray = np.mean(image, axis=2)\n        else:\n            gray = image.astype(float)\n    except Exception:\n        return 0.0\n    h, w = gray.shape[:2]\n    rng = float(gray.max() - gray.min())\n    thr = float(gray.mean()) + max(0.05 * rng, 1e-6)\n    mask = gray > thr\n    if not np.any(mask):\n        return 0.0\n    rows_any = np.where(mask.any(axis=1))[0]\n    cols_any = np.where(mask.any(axis=0))[0]\n    if rows_any.size == 0 or cols_any.size == 0:\n        return 0.0\n    top, bottom = rows_any[0], rows_any[-1]\n    left, right = cols_any[0], cols_any[-1]\n    bbox_w = float(right - left + 1)\n    # centroid column\n    col_sums = np.sum(mask, axis=0)\n    if col_sums.sum() == 0:\n        centroid_col = (left + right) / 2.0\n    else:\n        centroid_col = float(np.sum(np.arange(w) * col_sums) / col_sums.sum())\n    left_ext = centroid_col - left\n    right_ext = right - centroid_col\n    max_ext = max(left_ext, right_ext)\n    if bbox_w <= 0:\n        return 0.0\n    return float(max_ext / bbox_w)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Fraction of columns along the bottom row of the bounding box where the object touches the very bottom (contact fraction)'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    thresh = float(np.percentile(gray, 50)) if gray.size > 0 else 0.0\n    mask = gray > thresh\n    if not np.any(mask):\n        return 0.0\n    ys, xs = np.where(mask)\n    top, left, bottom, right = int(ys.min()), int(xs.min()), int(ys.max()), int(xs.max())\n    bottom_row = mask[bottom, left:right+1]\n    width = bottom_row.size\n    if width == 0:\n        return 0.0\n    contact_frac = float(np.count_nonzero(bottom_row) / width)\n    return contact_frac\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Maximum horizontal band contrast: max abs(band_mean - global_mean) over 10%-height bands'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    global_mean = float(np.mean(gray))\n    band_h = max(1, h // 10)\n    maxdiff = 0.0\n    for start in range(0, h - band_h + 1, max(1, band_h // 2)):\n        band = gray[start:start + band_h, :]\n        diff = abs(float(np.mean(band)) - global_mean)\n        if diff > maxdiff:\n            maxdiff = diff\n    denom = (np.std(gray) + 1e-8)\n    return float(maxdiff / denom)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Normalized vertical centroid of the main mask (0=top,1=bottom), 0.5 if undefined'\n    import numpy as np\n    if image is None:\n        return 0.5\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.5\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = gray < thr if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else gray > thr\n    ys, xs = np.where(mask)\n    if ys.size == 0:\n        return 0.5\n    centroid_y = float(np.mean(ys)) / float(h)\n    return float(np.clip(centroid_y, 0.0, 1.0))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Relative strength of vertical gradient in a narrow central vertical strip vs total gradient (detects button placket or seams)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    lo, hi = np.min(gray), np.max(gray)\n    if hi - lo < 1e-6:\n        return 0.0\n    thresh = lo + (hi - lo) * 0.03\n    mask = gray > thresh\n    if not mask.any():\n        return 0.0\n    h, w = gray.shape[:2]\n    # bounding box to restrict noise\n    rows = np.where(mask.any(axis=1))[0]\n    cols = np.where(mask.any(axis=0))[0]\n    if rows.size == 0 or cols.size == 0:\n        return 0.0\n    r0, r1 = rows[0], rows[-1] + 1\n    c0, c1 = cols[0], cols[-1] + 1\n    sub = gray[r0:r1, c0:c1]\n    gy, gx = np.gradient(sub)\n    mag = np.abs(gy)  # vertical gradient emphasis\n    H, W = sub.shape\n    center_c = W // 2\n    halfw = max(1, W // 10)\n    left = max(0, center_c - halfw)\n    right = min(W, center_c + halfw)\n    center_mag = np.sum(mag[:, left:right])\n    total_mag = np.sum(mag) + 1e-9\n    return float(center_mag / total_mag)\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Width of the object in the top quarter divided by bounding-box width (narrow top -> small value, wide shoulders -> larger)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    maxv, minv = np.max(gray), np.min(gray)\n    if maxv == minv:\n        return 0.0\n    thresh = gray.mean() + 0.2 * (maxv - gray.mean())\n    mask = gray > thresh\n    if mask.sum() == 0:\n        mask = gray > (minv + 0.5 * (maxv - minv))\n    if mask.sum() == 0:\n        return 0.0\n    rows, cols = np.where(mask)\n    top = int(rows.min())\n    bottom = int(rows.max())\n    left = int(cols.min())\n    right = int(cols.max())\n    bbox_width = max(1, right - left + 1)\n    top_h = max(1, (bottom - top + 1) // 4)\n    top_slice = slice(top, min(top + top_h, h))\n    cols_with_any = np.any(mask[top_slice, :], axis=0)\n    top_width = int(np.sum(cols_with_any))\n    return float(top_width / float(bbox_width))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Ratio of foreground widths at chest (~30% height) to hips (~60% height)'\n    import numpy as np\n    if image is None:\n        return 1.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 1.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    def row_width_at(frac):\n        row = int(min(h - 1, max(0, int(frac * h))))\n        band = max(1, int(h * 0.02))\n        start = max(0, row - band)\n        end = min(h, row + band + 1)\n        widths = np.sum(mask[start:end, :].astype(float), axis=1)\n        if widths.size == 0:\n            return 0.0\n        return float(np.mean(widths))\n    chest = row_width_at(0.30)\n    hips = row_width_at(0.60)\n    if hips <= 1e-8:\n        return float(chest)\n    return float(chest / hips)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Average vertical run length: mean of largest contiguous mask segment height per column (normalized by image height)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    max_runs = []\n    for x in range(w):\n        col = mask[:, x]\n        if not np.any(col):\n            max_runs.append(0.0)\n            continue\n        # compute lengths of contiguous True runs\n        diffs = np.diff(np.concatenate(([0], col.view(np.int8), [0])))\n        starts = np.where(diffs == 1)[0]\n        ends = np.where(diffs == -1)[0]\n        lengths = ends - starts\n        if lengths.size == 0:\n            max_runs.append(0.0)\n        else:\n            max_runs.append(float(np.max(lengths)))\n    if len(max_runs) == 0:\n        return 0.0\n    mean_run = float(np.mean(max_runs))\n    return float(mean_run / (h + 1e-8))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Ratio of mean mask width in the top 12% rows to mean mask width in the bottom 12% rows'\n    import numpy as np\n    if image is None:\n        return 1.0\n    h, w = image.shape[:2]\n    if h < 4 or w == 0:\n        return 1.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    band = max(1, int(h * 0.12))\n    top = mask[:band, :]\n    bottom = mask[-band:, :]\n    top_widths = np.sum(top, axis=1).astype(float)\n    bottom_widths = np.sum(bottom, axis=1).astype(float)\n    if top_widths.size == 0 or bottom_widths.size == 0:\n        return 1.0\n    mean_top = float(np.mean(top_widths)) + 1e-8\n    mean_bottom = float(np.mean(bottom_widths)) + 1e-8\n    return float(mean_top / mean_bottom)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Fill ratio: mask area divided by its bounding-box area (1.0 = full bbox)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 50)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    total = np.count_nonzero(mask)\n    if total == 0:\n        return 0.0\n    ys, xs = np.where(mask)\n    y0, y1 = ys.min(), ys.max()\n    x0, x1 = xs.min(), xs.max()\n    bbox_area = float((y1 - y0 + 1) * (x1 - x0 + 1))\n    if bbox_area <= 0.0:\n        return 0.0\n    return float(total / bbox_area)\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Fraction of foreground pixels that lie within a narrow border (touching image edges)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    total = np.count_nonzero(mask)\n    if total == 0:\n        return 0.0\n    mh = max(1, h * 5 // 100)\n    mw = max(1, w * 5 // 100)\n    border_mask = np.zeros_like(mask, dtype=bool)\n    border_mask[:mh, :] = True\n    border_mask[h - mh:, :] = True\n    border_mask[:, :mw] = True\n    border_mask[:, w - mw:] = True\n    touching = np.count_nonzero(mask & border_mask)\n    return float(touching / (total + 1e-8))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Number of connected foreground components (useful for separate shoes or bag + garment)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    mask = mask.astype(bool)\n    if not np.any(mask):\n        return 0.0\n    visited = np.zeros_like(mask, dtype=bool)\n    comps = 0\n    # scan and flood-fill\n    for y in range(h):\n        for x in range(w):\n            if mask[y, x] and not visited[y, x]:\n                comps += 1\n                stack = [(y, x)]\n                visited[y, x] = True\n                while stack:\n                    cy, cx = stack.pop()\n                    for ny, nx in ((cy-1, cx), (cy+1, cx), (cy, cx-1), (cy, cx+1)):\n                        if 0 <= ny < h and 0 <= nx < w and mask[ny, nx] and not visited[ny, nx]:\n                            visited[ny, nx] = True\n                            stack.append((ny, nx))\n    return float(comps)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Compactness relative to a circle: mask area divided by area of circle with radius = mean distance to centroid'\n    import numpy as np, math\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    ys, xs = np.where(mask)\n    if ys.size == 0:\n        return 0.0\n    yc = float(np.mean(ys))\n    xc = float(np.mean(xs))\n    dists = np.sqrt((ys - yc) ** 2 + (xs - xc) ** 2)\n    mean_r = float(np.mean(dists))\n    if mean_r <= 1e-6:\n        return float(1.0)  # extremely compact (single point)\n    circle_area = math.pi * (mean_r ** 2)\n    area = float(ys.size)\n    return float(area / (circle_area + 1e-12))\n",
    "def feature(image: np.ndarray) -> float:\n    'Fraction of background pixels inside the object bounding box (higher may indicate sandals or holes)'\n    import numpy as np\n    gray = np.mean(image, axis=2) if len(image.shape) == 3 else image.astype(float)\n    h, w = gray.shape[:2]\n    if np.all(gray == 0):\n        return 0.0\n    th = np.percentile(gray, 70)\n    mask = gray > th\n    rows = np.where(mask.any(axis=1))[0]\n    cols = np.where(mask.any(axis=0))[0]\n    if rows.size == 0 or cols.size == 0:\n        return 0.0\n    r0, r1 = rows.min(), rows.max()\n    c0, c1 = cols.min(), cols.max()\n    bbox = gray[r0:r1+1, c0:c1+1]\n    inner_bg = (bbox <= th).sum()\n    area = bbox.size\n    return float(inner_bg / max(1, area))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Fraction of mask pixels located in the bottom third of the image'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = gray < thr if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else gray > thr\n    total = np.count_nonzero(mask)\n    if total == 0:\n        return 0.0\n    start = (2 * h) // 3\n    bottom_count = int(np.count_nonzero(mask[start:h, :]))\n    return float(bottom_count) / float(total)\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Dominant object orientation angle normalized to [-1,1] (negative = leaning left)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = gray < thr if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else gray > thr\n    ys, xs = np.where(mask)\n    if ys.size < 3:\n        return 0.0\n    coords = np.vstack((xs.astype(float), ys.astype(float)))\n    cov = np.cov(coords)\n    if cov.shape != (2, 2):\n        return 0.0\n    eigvals, eigvecs = np.linalg.eigh(cov)\n    # take eigenvector of largest eigenvalue\n    idx = int(np.argmax(eigvals))\n    vec = eigvecs[:, idx]\n    angle = np.arctan2(vec[1], vec[0])  # radians between -pi and pi\n    # convert to degrees and normalize to [-1,1] by dividing by 90 degrees\n    angle_deg = angle * (180.0 / np.pi)\n    # map to [-90,90]\n    if angle_deg > 90:\n        angle_deg -= 180\n    if angle_deg < -90:\n        angle_deg += 180\n    return float(angle_deg / 90.0)\n",
    "def feature(image: np.ndarray) -> float:\n    'Normalized count of significant vertical gaps in the mask projection (detects leg separation)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if w < 3:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 50)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    col_sum = np.sum(mask, axis=0).astype(float)\n    if np.max(col_sum) <= 0:\n        return 0.0\n    # smooth projection\n    k = min(7, max(1, w // 20))\n    kernel = np.ones(k) / float(k)\n    smooth = np.convolve(col_sum, kernel, mode='same')\n    gap_thresh = 0.35 * np.max(smooth)\n    low = smooth < gap_thresh\n    # count runs of consecutive low columns\n    if not np.any(low):\n        return 0.0\n    diffs = np.diff(low.astype(int))\n    starts = np.count_nonzero(diffs == 1)\n    # if sequence starts low, add one\n    if low[0]:\n        starts += 1\n    # normalize by image width\n    return float(starts / (w + 1e-8))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Left-right symmetry score (0 = very asymmetric, 1 = perfectly symmetric) computed on mask'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.mean(gray) + 0.2 * (np.max(gray) - np.min(gray))\n    mask = (gray > thr).astype(float)\n    if not np.any(mask):\n        return 0.0\n    # crop to bounding box\n    rows = np.any(mask, axis=1)\n    cols = np.any(mask, axis=0)\n    minr, maxr = np.where(rows)[0][0], np.where(rows)[0][-1]\n    minc, maxc = np.where(cols)[0][0], np.where(cols)[0][-1]\n    crop = mask[minr:maxr + 1, minc:maxc + 1]\n    h, w = crop.shape\n    # reflect right half onto left for comparison\n    mid = w // 2\n    left = crop[:, :mid]\n    right = crop[:, w - mid:w][:, ::-1]\n    # pad smaller side if needed\n    if left.shape[1] != right.shape[1]:\n        m = max(left.shape[1], right.shape[1])\n        L = np.zeros((h, m)); R = np.zeros((h, m))\n        L[:, :left.shape[1]] = left\n        R[:, :right.shape[1]] = right\n    else:\n        L, R = left, right\n    # similarity measure\n    sim = 1.0 - (np.sum(np.abs(L - R)) / (np.sum(L + R) + 1e-9))\n    return float(max(0.0, min(1.0, sim)))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Mean local width variation in the upper third (higher = more sleeve/neck complexity)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 3 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = ((gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)).astype(np.uint8)\n    top_h = max(1, h // 3)\n    row_widths = np.sum(mask[:top_h, :], axis=1).astype(float)\n    if row_widths.size <= 1:\n        return 0.0\n    # mean absolute diff normalized by image width\n    mad = np.mean(np.abs(np.diff(row_widths))) / float(w + 1e-8)\n    return float(mad)\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Horizontal (left-right) symmetry score normalized by image mean (0 = identical)'\n    import numpy as np\n    if image is None:\n        return 1.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 1.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    mid = w // 2\n    left = gray[:, :mid]\n    right = gray[:, w - mid:w]\n    if left.size == 0 or right.size == 0:\n        return 1.0\n    right_flipped = np.fliplr(right)\n    if left.shape != right_flipped.shape:\n        mnw = min(left.shape[1], right_flipped.shape[1])\n        left = left[:, :mnw]\n        right_flipped = right_flipped[:, :mnw]\n    diff = np.abs(left - right_flipped)\n    denom = np.maximum(np.mean(gray) + 1e-8, 1e-8)\n    return float(np.mean(diff) / denom)\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Mean saturation (approx) for RGB: (max-min)/max per pixel, 0 for grayscale'\n    import numpy as np\n    if image is None:\n        return 0.0\n    if len(image.shape) != 3 or image.shape[2] < 3:\n        return 0.0\n    img = image.astype(float)\n    r = img[:, :, 0]\n    g = img[:, :, 1]\n    b = img[:, :, 2]\n    mx = np.maximum(np.maximum(r, g), b)\n    mn = np.minimum(np.minimum(r, g), b)\n    # saturation approximately (max-min)/ (max + eps)\n    sat = (mx - mn) / (mx + 1e-8)\n    sat = np.clip(sat, 0.0, 1.0)\n    return float(np.mean(sat))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Fraction of object mass located in the bottom 25% of the image (0..1)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape\n    thr = float(np.mean(gray) * 0.6 + np.min(gray) * 0.4)\n    mask = gray > thr\n    if not mask.any():\n        mask = gray >= np.max(gray)\n    bottom_start = int(0.75 * h)\n    total = float(np.count_nonzero(mask))\n    if total == 0:\n        return 0.0\n    bottom_count = float(np.count_nonzero(mask[bottom_start: h, :]))\n    return bottom_count / total\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Normalized standard deviation of the top contour (row index of first object pixel per column) measuring top irregularity'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 2 or w < 1:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = gray < thr if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else gray > thr\n    # for each column find topmost mask pixel; if none, set to h-1\n    top_idx = np.full((w,), h - 1, dtype=float)\n    any_in_col = np.any(mask, axis=0)\n    if np.any(any_in_col):\n        cols = np.where(any_in_col)[0]\n        # use argmax on inverted boolean per column to get first True\n        for c in cols:\n            col = mask[:, c]\n            top_idx[c] = float(np.argmax(col))\n    std_top = float(np.std(top_idx))\n    return float(std_top / max(1.0, h))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Normalized distance between the two largest column-peak centers in the bottom quarter (0..1), 0 if fewer than two peaks'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    gray = gray.astype(float)\n    if gray.size == 0:\n        return 0.0\n    rng = np.max(gray) - np.min(gray)\n    thr = np.mean(gray) + 0.18 * rng if rng > 0 else np.mean(gray)\n    mask = gray > thr\n    ys, xs = np.where(mask)\n    if ys.size == 0:\n        return 0.0\n    y0, y1, x0, x1 = ys.min(), ys.max(), xs.min(), xs.max()\n    h = y1 - y0 + 1\n    qh = max(1, h // 4)\n    bottom = mask[y1-qh+1:y1+1, x0:x1+1] if qh > 0 else mask[y1:y1+1, x0:x1+1]\n    if bottom.size == 0:\n        return 0.0\n    colsum = bottom.sum(axis=0).astype(float)\n    if colsum.size < 2:\n        return 0.0\n    # threshold peaks at 40% of max\n    peak_thr = max(1e-6, 0.4 * colsum.max())\n    is_peak = colsum > peak_thr\n    # find contiguous peak regions and compute their centroids (weighted by colsum)\n    peaks = []\n    start = None\n    for i, val in enumerate(is_peak):\n        if val and start is None:\n            start = i\n        elif not val and start is not None:\n            region = np.arange(start, i)\n            weights = colsum[region]\n            if weights.sum() > 0:\n                centroid = float((region * weights).sum() / weights.sum())\n                peaks.append(centroid)\n            start = None\n    if start is not None:\n        region = np.arange(start, is_peak.size)\n        weights = colsum[region]\n        if weights.sum() > 0:\n            centroid = float((region * weights).sum() / weights.sum())\n            peaks.append(centroid)\n    if len(peaks) < 2:\n        return 0.0\n    # take two largest peaks by peak mass\n    peak_masses = []\n    for c in peaks:\n        idx = int(round(c))\n        idx = max(0, min(idx, colsum.size-1))\n        mass = colsum[max(0, idx-1):min(colsum.size, idx+2)].sum()\n        peak_masses.append((mass, c))\n    peak_masses.sort(reverse=True, key=lambda x: x[0])\n    d = abs(peak_masses[0][1] - peak_masses[1][1])\n    norm = float(d / max(1.0, (x1 - x0 + 1)))\n    return norm\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Fraction of strong edge pixels that are horizontally aligned (indicates many horizontal straps/edges)'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    # gradients\n    try:\n        gy, gx = np.gradient(gray.astype(float))\n    except Exception:\n        return 0.0\n    mag = np.hypot(gx, gy)\n    thr = np.percentile(mag, 75) if mag.size > 0 else 0.0\n    strong = mag >= thr\n    if np.count_nonzero(strong) == 0:\n        return 0.0\n    # horizontal edges produce large vertical gradient (gy)\n    horness = np.abs(gy) / (np.abs(gx) + np.abs(gy) + 1e-9)\n    return float(np.mean(horness[strong]))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Absolute normalized shoulder slope estimate from left boundary between top and mid rows'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 6 or w < 3:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    rows = np.arange(h)\n    # define top band and middle band\n    top_idx = rows < int(max(1, h * 0.2))\n    mid_idx = (rows >= int(max(1, h * 0.4))) & (rows < int(max(1, h * 0.6)))\n    def mean_left(idx_mask):\n        ys = np.where(idx_mask)[0]\n        xs_left = []\n        for r in ys:\n            row = mask[r, :]\n            nz = np.where(row)[0]\n            if nz.size > 0:\n                xs_left.append(float(nz[0]))\n        return float(np.mean(xs_left)) if len(xs_left) > 0 else np.nan\n    left_top = mean_left(top_idx)\n    left_mid = mean_left(mid_idx)\n    if np.isnan(left_top) or np.isnan(left_mid):\n        return 0.0\n    slope = (left_mid - left_top) / (max(1.0, h * 0.2))\n    return float(abs(slope) / (w + 1e-8))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Horizontal centroid offset: absolute distance of object centroid from image center, normalized by width (smaller for centered dresses)'\n    import numpy as np\n    gray = np.mean(image, axis=2) if len(image.shape) == 3 else image.astype(float)\n    h, w = gray.shape[:2]\n    thr = np.percentile(gray, 60)\n    mask = gray > thr\n    if mask.sum() == 0:\n        thr = gray.max() * 0.1\n        mask = gray > thr\n        if mask.sum() == 0:\n            return 1.0\n    coords = np.argwhere(mask)\n    if coords.size == 0:\n        return 1.0\n    cx = coords[:,1].mean()\n    return float(abs(cx - (w/2.0)) / (w + 1e-9))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Average per-column object height (top-to-bottom run) normalized by image height (taller vertical fill -> higher)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    mn, mx = float(np.min(gray)), float(np.max(gray))\n    if mx > mn:\n        norm = (gray - mn) / (mx - mn)\n    else:\n        norm = np.zeros_like(gray)\n    thr = float(np.percentile(norm, 75))\n    mask = norm > thr\n    if np.count_nonzero(mask) == 0:\n        mask = norm > float(np.percentile(norm, 50))\n    heights = []\n    for c in range(w):\n        col = mask[:, c]\n        rows = np.where(col)[0]\n        if rows.size == 0:\n            continue\n        heights.append(float(rows[-1] - rows[0] + 1))\n    if len(heights) == 0:\n        return 0.0\n    return float(np.mean(heights) / float(h))\n",
    "def feature(image: np.ndarray) -> float:\n    'Relative width at mid-height of the bbox divided by width at top quarter (detects sleeve protrusion at mid)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    img = np.array(image)\n    if img.size == 0:\n        return 0.0\n    gray = np.mean(img, axis=2) if img.ndim == 3 else img\n    h, w = gray.shape[:2]\n    thr = np.mean(gray)\n    mask = (gray > thr) if np.count_nonzero(gray > thr) <= np.count_nonzero(gray < thr) else (gray < thr)\n    ys = np.where(mask.any(axis=1))[0]\n    xs = np.where(mask.any(axis=0))[0]\n    if ys.size == 0 or xs.size == 0:\n        return 0.0\n    y0, y1 = ys[0], ys[-1]\n    x0, x1 = xs[0], xs[-1]\n    bh = max(1, y1 - y0 + 1)\n    # row indices for top quarter and mid\n    top_row = y0 + max(0, bh // 8)\n    mid_row = y0 + bh // 2\n    def row_width(row):\n        row_mask = mask[row:row+1, x0:x1+1].reshape(-1)\n        if not row_mask.any():\n            return 0\n        runs = np.where(row_mask)[0]\n        # width = last - first +1\n        return float(runs[-1] - runs[0] + 1)\n    w_top = row_width(top_row) + 1e-6\n    w_mid = row_width(mid_row)\n    return float(w_mid / w_top)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Bottom-vs-middle width difference: (bottom_width - mid_width) normalized by image width (positive => flare at bottom)'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    h, w = gray.shape\n    thr = np.mean(gray) + 0.15 * np.std(gray)\n    mask = gray > thr\n    if np.count_nonzero(mask) == 0:\n        thr2 = np.max(gray) * 0.1\n        mask = gray > thr2\n        if np.count_nonzero(mask) == 0:\n            return 0.0\n    def row_width_at(y):\n        row = mask[y, :]\n        cols = np.where(row)[0]\n        if cols.size == 0:\n            return 0.0\n        return float(cols[-1] - cols[0] + 1)\n    bottom_row = min(h - 1, int(0.9 * h))\n    mid_row = min(h - 1, int(0.5 * h))\n    bottom_w = row_width_at(bottom_row)\n    mid_w = row_width_at(mid_row)\n    return float((bottom_w - mid_w) / float(w))\n",
    "def feature(image: np.ndarray) -> float:\n    'Left-right symmetry score of foreground intensities (1 highly symmetric, 0 asymmetric)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 2 or w < 2:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    center = w // 2\n    left = gray[:, :center]\n    right = gray[:, w - center:] if center > 0 else np.zeros_like(left)\n    left_mask = mask[:, :center]\n    right_mask = mask[:, w - center:]\n    if left.size == 0 or right.size == 0:\n        return 0.0\n    # flip right to align with left\n    right_flip = np.fliplr(right)\n    right_mask_flip = np.fliplr(right_mask)\n    overlap = (left_mask | right_mask_flip)\n    if not np.any(overlap):\n        return 0.0\n    diff = np.abs(left - right_flip)\n    mean_diff = float(np.mean(diff[overlap]))\n    mean_int = float(np.mean(np.abs(gray[mask])) if np.any(mask) else np.mean(np.abs(gray)) + 1e-8)\n    score = 1.0 - (mean_diff / (mean_int + 1e-8))\n    if not np.isfinite(score):\n        return 0.0\n    return float(max(0.0, min(1.0, score)))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Mean (blue - red) channel value normalized (RGB images), 0 for grayscale'\n    import numpy as np\n    if image is None:\n        return 0.0\n    if len(image.shape) != 3 or image.shape[2] < 3:\n        return 0.0\n    img = image.astype(float)\n    b = img[:, :, 2]\n    r = img[:, :, 0]\n    diff = b - r\n    # normalize by maximum absolute channel range to keep in reasonable scale\n    norm = np.maximum(1.0, np.max(np.abs(diff)))\n    return float(np.mean(diff) / norm)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Central vertical dark-streak score: average deviation of center-column intensity below local neighborhood (buttons/seams)'\n    import numpy as np\n    h, w = image.shape[:2]\n    img = image.astype(float)\n    gray = (img - img.min()) / (img.max() - img.min() + 1e-8)\n    c = w // 2\n    r0, r1 = h // 4, 3 * h // 4\n    center = gray[r0:r1, c]\n    # neighborhood average (3 columns centered)\n    nb0 = max(0, c - 1)\n    nb1 = min(w, c + 2)\n    neigh = np.mean(gray[r0:r1, nb0:nb1], axis=1)\n    diff = neigh - center  # positive when center is darker than neighborhood\n    score = np.mean(np.clip(diff, 0, None))\n    # normalize by local intensity scale\n    denom = np.mean(np.abs(neigh) + 1e-8)\n    return float(score / (denom + 1e-8))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Average gradient magnitude in the bottom quarter normalized by global mean gradient'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    gy, gx = np.gradient(gray)\n    grad = np.sqrt(gx * gx + gy * gy)\n    bottom_start = (3 * h) // 4\n    bottom = grad[bottom_start:h, :]\n    if bottom.size == 0:\n        return 0.0\n    bottom_mean = float(np.mean(bottom))\n    global_mean = float(np.mean(grad)) + 1e-8\n    return float(bottom_mean / global_mean)\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Estimated number of separate horizontal blobs in the lower half (useful for two-shoe blobs)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 2 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 60)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    half = h // 2\n    region = mask[half:, :]\n    if region.size == 0:\n        return 0.0\n    # column projection\n    col_proj = np.count_nonzero(region, axis=0) > 0\n    # count connected True segments in projection\n    if not np.any(col_proj):\n        return 0.0\n    diffs = np.diff(col_proj.astype(int))\n    starts = np.count_nonzero(diffs == 1) + (1 if col_proj[0] else 0)\n    # limit to reasonable max\n    return float(min(10, starts))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Aspect ratio (width/height) of the tight bounding box around the mask'\n    import numpy as np\n    if image is None:\n        return 1.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 1.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    ys, xs = np.where(mask)\n    if ys.size == 0:\n        return 1.0\n    miny, maxy = int(np.min(ys)), int(np.max(ys))\n    minx, maxx = int(np.min(xs)), int(np.max(xs))\n    box_h = max(1, maxy - miny + 1)\n    box_w = max(1, maxx - minx + 1)\n    # normalize by image aspect to keep values around 1 for average shapes\n    img_ratio = (w / (h + 1e-8))\n    ratio = (box_w / float(box_h + 1e-8)) / (img_ratio + 1e-8)\n    return float(ratio)\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Approximate shape elongation: ratio of smaller to larger PCA eigenvalue of mask coordinates (0..1)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    ys, xs = np.where(mask)\n    if ys.size < 2:\n        return 0.0\n    coords = np.stack([ys.astype(float), xs.astype(float)], axis=1)\n    cov = np.cov(coords, rowvar=False)\n    # handle degenerate cov\n    try:\n        eig = np.linalg.eigvalsh(cov)\n    except Exception:\n        return 0.0\n    eig = np.maximum(eig, 0.0)\n    if eig[1] <= 0:\n        return 0.0\n    ratio = eig[0] / (eig[1] + 1e-8)\n    return float(ratio)\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Mean Euclidean distance from object centroid to foreground pixels normalized by sqrt(area) (compactness measure)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    mean, mx = np.mean(gray), np.max(gray)\n    thresh = mean + 0.15 * (mx - mean)\n    mask = gray > thresh\n    if np.count_nonzero(mask) == 0:\n        mask = gray > mean\n    ys, xs = np.where(mask)\n    area = ys.size\n    if area == 0:\n        return 0.0\n    cy, cx = ys.mean(), xs.mean()\n    dists = np.sqrt((ys - cy)**2 + (xs - cx)**2)\n    norm = np.sqrt(area) + 1e-6\n    return float(dists.mean() / norm)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Bounding-box area ratio: bbox area divided by image area (smaller for small objects)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    # grayscale conversion\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    ys, xs = np.where(mask)\n    if ys.size == 0:\n        return 0.0\n    ymin, ymax = int(np.min(ys)), int(np.max(ys))\n    xmin, xmax = int(np.min(xs)), int(np.max(xs))\n    bbox_area = float((ymax - ymin + 1) * (xmax - xmin + 1))\n    img_area = float(h * w)\n    return float(bbox_area / (img_area + 1e-8))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Normalized vertical centroid of the foreground (0=top, 1=bottom)'\n    import numpy as np\n    if image is None:\n        return 0.5\n    h, w = image.shape[:2]\n    if h == 0:\n        return 0.5\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    ys = np.where(mask)[0]\n    if ys.size == 0:\n        return 0.5\n    y_mean = float(np.mean(ys))\n    return float(y_mean / max(1.0, (h - 1)))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Vertical centroid (mean row index of mask) normalized by image height (0=top,1=bottom)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    ys, xs = np.where(mask)\n    if ys.size == 0:\n        return 0.0\n    mean_y = float(np.mean(ys))\n    return float(mean_y / float(h))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Average foreground width in the shoulder band (rows ~8%..22% of height) normalized by image width'\n    import numpy as np\n    if image is None:\n        return 0.5\n    h, w = image.shape[:2]\n    if h < 5 or w == 0:\n        return 0.5\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    start = int(max(0, h * 0.08))\n    end = int(min(h, h * 0.22))\n    if end <= start:\n        return 0.5\n    widths = []\n    for r in range(start, end):\n        cols = np.where(mask[r, :])[0]\n        if cols.size > 0:\n            widths.append(float(cols[-1] - cols[0] + 1))\n    if len(widths) == 0:\n        return 0.0\n    avg_w = float(np.mean(widths))\n    result = avg_w / float(w + 1e-8)\n    return float(result)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Average foreground width around shoulder row (20% height) normalized by image width'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    row = int(min(h - 1, max(0, int(0.20 * h))))\n    band = max(1, int(0.02 * h))\n    start = max(0, row - band)\n    end = min(h, row + band + 1)\n    widths = np.count_nonzero(mask[start:end, :], axis=1).astype(float)\n    if widths.size == 0:\n        return 0.0\n    mean_width = float(np.mean(widths))\n    return float(mean_width / max(1.0, float(w)))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Normalized variability (std) of the top edge profile across columns (topmost filled row per column)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    gmin, gmax = gray.min(), gray.max()\n    if gmax > gmin:\n        gray = (gray - gmin) / (gmax - gmin)\n    mask = gray > (np.mean(gray) + 0.15 * (gray.max() - np.mean(gray)))\n    if mask.sum() == 0:\n        mask = gray > np.mean(gray)\n    if mask.sum() == 0:\n        return 0.0\n    rows, cols = np.where(mask)\n    rmin, rmax = rows.min(), rows.max()\n    cmin, cmax = cols.min(), cols.max()\n    sub = mask[rmin:rmax+1, cmin:cmax+1]\n    h, w = sub.shape\n    top_positions = np.full(w, h, dtype=float)\n    for j in range(w):\n        col = sub[:, j]\n        idx = np.where(col)[0]\n        if idx.size > 0:\n            top_positions[j] = idx[0]\n    valid = top_positions < h\n    if valid.sum() == 0:\n        return 0.0\n    std_top = float(np.std(top_positions[valid]))\n    return float(std_top / max(1.0, h))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Ratio of left-right asymmetry in upper half to asymmetry in lower half (bag on one side detection)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 2 or w < 2:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 50)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    mid = w // 2\n    upper = mask[:h//2, :]\n    lower = mask[h//2:, :]\n    left_upper = float(np.count_nonzero(upper[:, :mid]))\n    right_upper = float(np.count_nonzero(upper[:, mid:]))\n    left_lower = float(np.count_nonzero(lower[:, :mid]))\n    right_lower = float(np.count_nonzero(lower[:, mid:]))\n    up_diff = abs(left_upper - right_upper)\n    low_diff = abs(left_lower - right_lower)\n    return float(up_diff / (low_diff + 1e-8))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Normalized standard deviation of object width across rows (high for sandals with alternating straps, low for uniform sneakers)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    thresh = float(np.mean(gray))\n    bin_img = (gray > thresh).astype(np.uint8)\n    widths = np.sum(bin_img, axis=1).astype(float)  # width per row\n    mean_w = widths.mean() if widths.size > 0 else 0.0\n    if mean_w <= 1e-9:\n        return 0.0\n    std_w = widths.std()\n    return float(std_w / (mean_w + 1e-9))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Left-right upper-third asymmetry: normalized absolute difference in pixel counts between left and right upper third (0 symmetric, 1 maximally asymmetric)'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    h, w = gray.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    thresh = np.mean(gray)\n    mask = gray > thresh\n    top_h = max(1, h // 3)\n    upper = mask[:top_h, :]\n    left_count = upper[:, :w//2].sum()\n    right_count = upper[:, w//2:].sum()\n    denom = left_count + right_count + 1e-6\n    return float(abs(left_count - right_count) / denom)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Fraction of foreground pixels located in bottom 25% of image'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    bottom_start = max(0, int(0.75 * h))\n    total_fg = np.count_nonzero(mask)\n    if total_fg == 0:\n        return 0.0\n    bottom_fg = np.count_nonzero(mask[bottom_start:h, :])\n    return float(bottom_fg / float(total_fg))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Median of topmost object pixel per column normalized by bbox height (higher indicates tall toe/forefoot)'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    thr = np.percentile(gray, 60)\n    bin_img = (gray > thr).astype(int)\n    ys, xs = np.where(bin_img)\n    if ys.size == 0:\n        return 0.0\n    min_r, max_r = ys.min(), ys.max()\n    min_c, max_c = xs.min(), xs.max()\n    bbox_h = max_r - min_r + 1\n    if bbox_h <= 0:\n        return 0.0\n    top_positions = []\n    for col in range(min_c, max_c + 1):\n        col_idxs = np.where(bin_img[min_r:max_r+1, col] > 0)[0]\n        if col_idxs.size > 0:\n            top_positions.append(col_idxs.min())\n    if len(top_positions) == 0:\n        return 0.0\n    med_top = float(np.median(top_positions))\n    # normalize: 0 means top at bbox top, 1 means top at bbox bottom\n    return med_top / float(max(1, bbox_h - 1))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Normalized red-minus-blue channel mean (positive => red bias, negative => blue bias), 0 for grayscale'\n    import numpy as np\n    if image is None:\n        return 0.0\n    if len(image.shape) != 3 or image.shape[2] < 3:\n        return 0.0\n    img = image.astype(float)\n    r = float(np.mean(img[:, :, 0]))\n    g = float(np.mean(img[:, :, 1]))\n    b = float(np.mean(img[:, :, 2]))\n    denom = (r + g + b) + 1e-8\n    return float((r - b) / denom)\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Fraction of edge magnitude inside mask that is more vertical than horizontal (masked orientation)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 2 or w < 2:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    gy, gx = np.gradient(gray.astype(float))\n    mag = np.sqrt(gx * gx + gy * gy)\n    # restrict to mask and to reasonably strong edges\n    mag_masked = mag * mask\n    if np.sum(mag_masked) <= 0:\n        return 0.0\n    vert_dom = np.abs(gx) > np.abs(gy)\n    vert_mag = np.sum(mag_masked * vert_dom)\n    total_mag = np.sum(mag_masked)\n    return float(vert_mag / (total_mag + 1e-12))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Normalized high-frequency gradient energy in bottom quarter (shoes/textures)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 4 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    # normalize intensities\n    mx = float(np.max(gray))\n    if mx > 0:\n        gray = gray / mx\n    bottom_h = max(1, h // 4)\n    region = gray[h - bottom_h:, :]\n    gy, gx = np.gradient(region)\n    energy = float(np.sum(np.abs(gx)) + np.sum(np.abs(gy)))\n    # normalize by region area\n    area = float(region.size)\n    return float(energy / (area + 1e-8))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Normalized vertical centroid of the mask (0=top, 1=bottom)'\n    import numpy as np\n    if image is None:\n        return 0.5\n    h, w = image.shape[:2]\n    if h == 0:\n        return 0.5\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    if not np.any(mask):\n        return 0.5\n    ys = np.arange(h)[:, None]\n    mass = mask.astype(float)\n    total = float(np.sum(mass)) + 1e-8\n    centroid_y = float(np.sum(ys * mass) / total)\n    return float(centroid_y / float(h))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Relative density difference between lateral sleeve regions and central upper band (positive when sleeves are more filled)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    if h < 4 or w < 4:\n        return 0.0\n    maxv, minv = np.max(gray), np.min(gray)\n    if maxv == minv:\n        return 0.0\n    thresh = gray.mean() + 0.2 * (maxv - gray.mean())\n    mask = gray > thresh\n    if mask.sum() == 0:\n        mask = gray > (minv + 0.5 * (maxv - minv))\n    top_band_h = max(1, h // 4)\n    left_box = mask[0:top_band_h, 0:max(1, w // 4)]\n    center_box = mask[0:top_band_h, max(0, w // 4):min(w, w * 3 // 4)]\n    right_box = mask[0:top_band_h, max(0, w * 3 // 4):w]\n    left_density = left_box.sum() / (left_box.size + 1e-8)\n    right_density = right_box.sum() / (right_box.size + 1e-8)\n    center_density = center_box.sum() / (center_box.size + 1e-8)\n    lateral = (left_density + right_density) / 2.0\n    # normalized difference between lateral and center densities in range roughly [-1,1]\n    denom = lateral + center_density + 1e-8\n    return float((lateral - center_density) / denom)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Mask fill ratio: area of object mask divided by its bounding-box area (1.0 if undefined)'\n    import numpy as np\n    if image is None:\n        return 1.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 1.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = gray < thr if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else gray > thr\n    if not np.any(mask):\n        return 1.0\n    rows = np.where(np.any(mask, axis=1))[0]\n    cols = np.where(np.any(mask, axis=0))[0]\n    if rows.size == 0 or cols.size == 0:\n        return 1.0\n    bbox_h = float(rows[-1] - rows[0] + 1)\n    bbox_w = float(cols[-1] - cols[0] + 1)\n    bbox_area = bbox_h * bbox_w\n    if bbox_area <= 0:\n        return 1.0\n    area = float(np.count_nonzero(mask))\n    return float(area / bbox_area)\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Ratio of mask pixels in upper half to lower half of image'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    upper = np.count_nonzero(mask[:h//2, :])\n    lower = np.count_nonzero(mask[h//2:, :])\n    return float(upper / (lower + 1e-8))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Standard deviation of object width per row within central band (captures waist/torso shape variability)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    p10, p90 = np.percentile(gray, 10), np.percentile(gray, 90)\n    thr = 0.5 * (p10 + p90)\n    mask = gray > thr\n    if np.count_nonzero(mask) == 0:\n        thr = np.median(gray)\n        mask = gray > thr\n        if np.count_nonzero(mask) == 0:\n            return 0.0\n    rows_any = np.any(mask, axis=1)\n    if not rows_any.any():\n        return 0.0\n    top = int(np.argmax(rows_any))\n    bottom = int(mask.shape[0] - 1 - np.argmax(rows_any[::-1]))\n    if bottom <= top:\n        return 0.0\n    mid_top = top + (bottom - top) // 4\n    mid_bottom = top + 3 * (bottom - top) // 4\n    widths = []\n    for r in range(mid_top, mid_bottom+1):\n        cols = np.where(mask[r, :])[0]\n        if cols.size == 0:\n            continue\n        widths.append(float(cols[-1] - cols[0] + 1))\n    if len(widths) == 0:\n        return 0.0\n    return float(np.std(widths) / (w + 1e-6))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Difference in mean edge magnitude between the upper third and lower third (collars/shoulder details produce more edges up top)'\n    import numpy as np\n    gray = np.mean(image, axis=2) if len(image.shape) == 3 else image.astype(float)\n    h, w = gray.shape[:2]\n    g0, g1 = np.gradient(gray.astype(float))\n    grad = np.hypot(g0, g1)\n    upper = grad[0:max(1, h//3), :]\n    lower = grad[max(1, 2*h//3):h, :]\n    upper_mean = np.mean(upper) if upper.size else 0.0\n    lower_mean = np.mean(lower) if lower.size else 0.0\n    overall_std = np.std(grad) if np.std(grad) > 0 else 1.0\n    return float((upper_mean - lower_mean) / (overall_std + 1e-8))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Relative change in horizontal span between top quarter and middle quarter of the object (shoulder vs body taper)'\n    import numpy as np\n    gray = np.mean(image, axis=2) if len(image.shape) == 3 else image.astype(float)\n    h, w = gray.shape[:2]\n    thresh = np.percentile(gray, 60)\n    mask = gray > thresh\n    if mask.sum() == 0:\n        mask = gray > np.mean(gray)\n    ys, xs = np.where(mask)\n    if ys.size == 0:\n        return 0.0\n    miny, maxy = ys.min(), ys.max()\n    minx, maxx = xs.min(), xs.max()\n    bbox_mask = mask[miny:maxy+1, minx:maxx+1]\n    bh = bbox_mask.shape[0]\n    q = max(1, bh // 4)\n    top_rows = bbox_mask[0:q, :]\n    mid_rows = bbox_mask[q:2*q, :] if 2*q <= bh else bbox_mask[q:bh, :]\n    def horiz_span(rows):\n        cols = np.where(np.any(rows, axis=0))[0]\n        return (cols.max() - cols.min() + 1) if cols.size else 0\n    span_top = horiz_span(top_rows)\n    span_mid = horiz_span(mid_rows)\n    bbox_w = max(1, bbox_mask.shape[1])\n    return float((span_mid - span_top) / bbox_w)\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Sum of normalized maximal horizontal extents of foreground from center in the top quarter (measures sleeve protrusion/shoulder spread)'\n    import numpy as np\n    h, w = image.shape[:2]\n    gray = np.mean(image, axis=2) if image.ndim == 3 else image.astype(float)\n    # threshold for foreground\n    thr = np.percentile(gray, 75)\n    mask = gray > thr\n    if not mask.any():\n        return 0.0\n    top_rows = slice(0, max(1, h // 4))\n    rows = np.any(mask[top_rows, :], axis=1)\n    if not rows.any():\n        return 0.0\n    top_mask = mask[top_rows, :]\n    cx = w // 2\n    # find leftmost and rightmost foreground in top area\n    cols = np.where(np.any(top_mask, axis=0))[0]\n    if cols.size == 0:\n        return 0.0\n    leftmost = cols[0]\n    rightmost = cols[-1]\n    left_extent = max(0, cx - leftmost)\n    right_extent = max(0, rightmost - cx)\n    return float((left_extent + right_extent) / max(1.0, w))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Fraction of center-region pixels whose intensity deviates from global mean by more than one global std'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    # convert to grayscale\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    gmean = np.mean(gray)\n    gstd = np.std(gray)\n    if gstd == 0:\n        return 0.0\n    ch = max(1, h // 4)\n    cw = max(1, w // 4)\n    center = gray[ch:3*ch, cw:3*cw]\n    if center.size == 0:\n        return 0.0\n    mask = np.abs(center - gmean) > gstd\n    return float(np.count_nonzero(mask)) / float(center.size)\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Fraction of mask pixels that touch the bottom image row (useful for boots/trousers)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    area = float(np.count_nonzero(mask))\n    if area == 0:\n        return 0.0\n    bottom_count = float(np.count_nonzero(mask[h - 1, :]))\n    return float(bottom_count / (area + 1e-8))\n",
    "def feature(image: np.ndarray) -> float:\n    'Central top deficit: how much lower the top contour is in the center compared to shoulders (positive for deeper neckline)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    maxv, minv = np.max(gray), np.min(gray)\n    if maxv == minv:\n        return 0.0\n    thresh = gray.mean() + 0.2 * (maxv - gray.mean())\n    mask = gray > thresh\n    if mask.sum() == 0:\n        mask = gray > (minv + 0.5 * (maxv - minv))\n    if mask.sum() == 0:\n        return 0.0\n    # top contour: first row index per column with object (or h if none)\n    top_contour = np.full(w, h, dtype=int)\n    for col in range(w):\n        col_inds = np.where(mask[:, col])[0]\n        if col_inds.size:\n            top_contour[col] = int(col_inds.min())\n    c = w // 2\n    left_col = max(0, w // 4)\n    right_col = min(w - 1, 3 * w // 4)\n    center_val = float(top_contour[c])\n    side_avg = float((top_contour[left_col] + top_contour[right_col]) / 2.0)\n    # positive when center is lower (larger index) than shoulders\n    return float(max(0.0, (center_val - side_avg)) / float(h + 1e-8))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Ratio of mean mask width in upper quarter to mean mask width in lower quarter'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 4 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    q = max(1, h // 4)\n    top_rows = mask[:q, :]\n    bottom_rows = mask[-q:, :]\n    top_widths = np.sum(top_rows, axis=1).astype(float)\n    bottom_widths = np.sum(bottom_rows, axis=1).astype(float)\n    top_mean = float(np.mean(top_widths)) if top_widths.size > 0 else 0.0\n    bottom_mean = float(np.mean(bottom_widths)) if bottom_widths.size > 0 else 0.0\n    return float(top_mean / (bottom_mean + 1e-8))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Left-right symmetry score: 1 - normalized L1 difference between halves (higher => more symmetric)'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    # threshold\n    mask = None\n    for p in (60, 50, 40, 30):\n        thresh = float(np.percentile(gray, p))\n        m = gray > thresh\n        if 0 < np.count_nonzero(m) < h * w:\n            mask = m\n            break\n    if mask is None:\n        mask = gray > np.mean(gray)\n    if np.count_nonzero(mask) == 0:\n        return 0.0\n    # crop to bounding box\n    ys, xs = np.nonzero(mask)\n    top, bottom = int(np.min(ys)), int(np.max(ys))\n    left, right = int(np.min(xs)), int(np.max(xs))\n    crop = mask[top:bottom + 1, left:right + 1].astype(float)\n    ch, cw = crop.shape\n    mid = cw // 2\n    left_half = crop[:, :mid]\n    right_half = crop[:, -mid:] if mid > 0 else crop[:, :mid]\n    # flip right half horizontally to align\n    if right_half.size == 0 or left_half.size == 0:\n        return 0.0\n    right_flipped = np.fliplr(right_half)\n    # make same shape by cropping/padding\n    min_cols = min(left_half.shape[1], right_flipped.shape[1])\n    left_trim = left_half[:, :min_cols]\n    right_trim = right_flipped[:, :min_cols]\n    diff = np.abs(left_trim - right_trim)\n    denom = np.sum(left_trim + right_trim) + 1e-6\n    symmetry = 1.0 - (np.sum(diff) / denom)\n    return float(max(0.0, min(1.0, symmetry)))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Inter-channel mean difference normalized: std of channel means divided by their mean (0 for grayscale)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    if len(image.shape) != 3 or image.shape[2] != 3:\n        return 0.0\n    img = image.astype(float)\n    r_mean = float(np.mean(img[:, :, 0]))\n    g_mean = float(np.mean(img[:, :, 1]))\n    b_mean = float(np.mean(img[:, :, 2]))\n    means = np.array([r_mean, g_mean, b_mean])\n    mean_of_means = float(np.mean(means))\n    if mean_of_means <= 0:\n        return 0.0\n    std_means = float(np.std(means))\n    return float(std_means / (mean_of_means + 1e-12))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Count of distinct vertical blobs (contiguous column groups above threshold)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    # column sums of mask\n    thr = np.percentile(gray, 55)\n    mask = gray < thr if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else gray > thr\n    col_sums = np.sum(mask.astype(int), axis=0).astype(float)\n    if col_sums.size == 0:\n        return 0.0\n    # threshold columns by a fraction of max to get prominent columns\n    maxv = np.max(col_sums)\n    if maxv <= 0:\n        return 0.0\n    strong = col_sums > (0.25 * maxv)\n    # count contiguous True groups\n    # pad to catch edges\n    padded = np.concatenate([[0], strong.astype(int), [0]])\n    diffs = np.diff(padded)\n    starts = np.where(diffs == 1)[0]\n    ends = np.where(diffs == -1)[0]\n    count = max(0, len(starts))\n    return float(count)\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Relative narrowness at the top: width of object at the top 15% of bbox divided by bbox width (ankle boots often narrow at top)'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    thr = max(np.mean(gray), np.percentile(gray, 75))\n    mask = gray > thr\n    if not np.any(mask):\n        return 0.0\n    rows = np.any(mask, axis=1)\n    cols = np.any(mask, axis=0)\n    rmin, rmax = np.where(rows)[0][[0, -1]]\n    cmin, cmax = np.where(cols)[0][[0, -1]]\n    bbox_h = rmax - rmin + 1\n    top_band_h = max(1, int(np.ceil(0.15 * bbox_h)))\n    top_region = mask[rmin:rmin + top_band_h, cmin:cmax+1]\n    # width occupied in top region: count columns with any True\n    if top_region.size == 0:\n        return 0.0\n    col_any = np.any(top_region, axis=0)\n    top_width = float(np.count_nonzero(col_any))\n    bbox_width = float(cmax - cmin + 1)\n    return float(top_width / (bbox_width + 1e-9))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Left-right symmetry similarity (1.0 = perfect symmetry, 0.0 = very asymmetric)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    flipped = np.fliplr(gray)\n    diff = np.abs(gray - flipped)\n    denom = np.mean(np.abs(gray)) + 1e-8\n    sim = 1.0 - (np.mean(diff) / denom)\n    if sim < 0.0:\n        sim = 0.0\n    return float(sim)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Mean blue minus red channel normalized by overall brightness (positive => bluish)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    if len(image.shape) != 3 or image.shape[2] != 3:\n        return 0.0\n    img = image.astype(float)\n    R = img[:, :, 0]\n    G = img[:, :, 1]\n    B = img[:, :, 2]\n    meanR = float(np.mean(R))\n    meanB = float(np.mean(B))\n    mean_all = float(np.mean(img))\n    result = (meanB - meanR) / (abs(mean_all) + 1e-8)\n    return float(result)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Fraction of edge pixels dominated by vertical gradient (|gx| > |gy|)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 2 or w < 2:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    gy, gx = np.gradient(gray)\n    mag = np.sqrt(gx * gx + gy * gy)\n    if not np.any(mag):\n        return 0.0\n    mask = mag > np.percentile(mag, 50)\n    if np.count_nonzero(mask) == 0:\n        return 0.0\n    vert_dom = np.count_nonzero((np.abs(gx) > np.abs(gy)) & mask)\n    return float(vert_dom) / float(np.count_nonzero(mask))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Mean per-pixel color channel spread (mean of max(channel)-min(channel)), 0 for grayscale'\n    import numpy as np\n    if image is None:\n        return 0.0\n    if len(image.shape) != 3 or image.shape[2] < 3:\n        return 0.0\n    img = image.astype(float)\n    spread = np.max(img, axis=2) - np.min(img, axis=2)\n    return float(np.mean(spread))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Top narrowness: 5th percentile of row widths in upper half normalized by max row width'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h <= 1 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    row_widths = np.sum(mask, axis=1).astype(float)\n    if row_widths.size == 0:\n        return 0.0\n    top_half = row_widths[:max(1, h // 2)]\n    max_w = np.max(row_widths) + 1e-8\n    p5 = float(np.percentile(top_half, 5)) if top_half.size > 0 else 0.0\n    return float(p5 / max_w)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Color channel dominance (max channel mean - min channel mean) normalized by overall mean; 0 for grayscale'\n    import numpy as np\n    if image is None:\n        return 0.0\n    if len(image.shape) != 3:\n        return 0.0\n    h, w, c = image.shape\n    if c < 3 or h == 0 or w == 0:\n        return 0.0\n    img = image.astype(float)\n    means = [float(np.mean(img[:, :, i])) for i in range(3)]\n    mx = max(means)\n    mn = min(means)\n    denom = float(np.mean(means)) + 1e-8\n    return float((mx - mn) / denom)\n",
    "def feature(image: np.ndarray) -> float:\n    'Normalized vertical centroid of the detected foreground mask (0 top -> 1 bottom)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 50)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    ys, xs = np.where(mask)\n    if ys.size == 0:\n        return 0.0\n    centroid_y = float(np.mean(ys))\n    return float(centroid_y / (h + 1e-8))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Average horizontal protrusion of mask edges in upper quarter relative to torso center'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 4 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = ((gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)).astype(int)\n    top_h = max(1, h // 4)\n    center_x = w // 2\n    protrusions = []\n    for r in range(top_h):\n        row = mask[r, :]\n        if np.any(row):\n            left = np.argmax(row) if row[0] == 1 else np.where(row == 1)[0][0]\n            right = w - 1 - (np.argmax(row[::-1]) if row[-1] == 1 else np.where(row == 1)[0][-1])\n            # distances from center\n            left_dist = max(0, center_x - left)\n            right_dist = max(0, right - center_x)\n            protrusions.append((left_dist + right_dist) / 2.0)\n    if len(protrusions) == 0:\n        return 0.0\n    avg = float(np.mean(protrusions))\n    return float(avg / max(1.0, float(w)))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Side occupancy ratio: normalized absolute difference between left-third and right-third object pixel counts'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    if w < 3:\n        return 0.0\n    mx = gray.max() if gray.max() != 0 else 1.0\n    norm = gray / mx\n    thr = np.mean(norm) + 0.25 * np.std(norm)\n    mask = norm > thr\n    t = w // 3\n    left_count = np.count_nonzero(mask[:, :t])\n    right_count = np.count_nonzero(mask[:, 2 * t:])\n    total = np.count_nonzero(mask)\n    if total == 0:\n        return 0.0\n    ratio = abs(left_count - right_count) / float(total)\n    return float(ratio)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Normalized vertical standard deviation of mask pixels (spread of object vertically)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    ys, xs = np.where(mask)\n    if ys.size == 0:\n        return 0.0\n    stdy = float(np.std(ys.astype(float)))\n    return float(stdy / float(max(1.0, h)))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Ratio of mean absolute horizontal gradient to vertical gradient inside bounding box (edge orientation anisotropy)'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(np.float32)\n    else:\n        gray = image.astype(np.float32)\n    mx = gray.max() if gray.size else 0.0\n    if mx > 1.0:\n        gray = gray / mx\n    thr = np.mean(gray) + 0.12 * (np.max(gray) - np.min(gray))\n    mask = gray > thr\n    if not mask.any():\n        thr = np.mean(gray)\n        mask = gray > thr\n    if not mask.any():\n        mask = gray > np.min(gray)\n    rows, cols = np.where(mask)\n    if rows.size == 0:\n        return 1.0\n    r0, r1 = rows.min(), rows.max()\n    c0, c1 = cols.min(), cols.max()\n    region = gray[r0:r1+1, c0:c1+1]\n    if region.size == 0:\n        return 1.0\n    gy, gx = np.gradient(region.astype(np.float32))\n    magx = np.mean(np.abs(gx))\n    magy = np.mean(np.abs(gy))\n    eps = 1e-8\n    return float((magx + eps) / (magy + eps))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Fraction of object pixels that lie in the bottom third and within the central 40% horizontally'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(np.float32)\n    else:\n        gray = image.astype(np.float32)\n    h, w = gray.shape[:2]\n    thr = np.mean(gray) + 0.25 * (np.max(gray) - np.min(gray))\n    mask = gray > thr\n    if np.count_nonzero(mask) == 0:\n        thr = np.mean(gray)\n        mask = gray > thr\n        if np.count_nonzero(mask) == 0:\n            return 0.0\n    total = float(np.count_nonzero(mask))\n    bstart = max(0, h - h // 3)\n    center_left = int(w * 0.3)\n    center_right = int(w * 0.7)\n    bottom_center_region = mask[bstart:h, center_left:center_right]\n    focused = float(np.count_nonzero(bottom_center_region))\n    return float(focused / (total + 1e-8))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Perimeter-to-area ratio of mask using 4-neighborhood (higher => thinner/complex shape)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    area = np.count_nonzero(mask)\n    if area == 0:\n        return 0.0\n    # 4-neighbor shifts\n    up = np.roll(mask, -1, axis=0)\n    down = np.roll(mask, 1, axis=0)\n    left = np.roll(mask, -1, axis=1)\n    right = np.roll(mask, 1, axis=1)\n    # boundary handling: rolled pixels wrap; remove wrap effect by zeroing edges\n    up[-1, :] = False\n    down[0, :] = False\n    left[:, -1] = False\n    right[:, 0] = False\n    # perimeter pixels: mask pixel that has at least one neighbor False\n    neighbors_all = up & down & left & right\n    perimeter_pixels = np.count_nonzero(mask & (~neighbors_all))\n    return float(perimeter_pixels / float(area))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Ratio of mean width in top 15% rows to mean width in bottom 15% rows (top/bottom)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    thresh = np.mean(gray) + 0.1 * np.std(gray)\n    mask = gray > thresh\n    top_h = max(1, h // 7)  # ~14%\n    bottom_start = max(0, h - top_h)\n    def mean_width(rows_slice):\n        widths = []\n        for r in range(rows_slice.start, rows_slice.stop):\n            cols = np.where(mask[r])[0]\n            if cols.size:\n                widths.append(cols[-1] - cols[0] + 1)\n        if not widths:\n            return 0.0\n        return float(np.mean(widths))\n    top_mean = mean_width(range(0, top_h))\n    bottom_mean = mean_width(range(bottom_start, h))\n    return float((top_mean + 1e-6) / (bottom_mean + 1e-6))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Aspect ratio (height / width) of the foreground bounding box (>=0)'\n    import numpy as np\n    if image is None:\n        return 1.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 1.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 50)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    ys, xs = np.where(mask)\n    if ys.size == 0:\n        return 1.0\n    ymin, ymax = int(np.min(ys)), int(np.max(ys))\n    xmin, xmax = int(np.min(xs)), int(np.max(xs))\n    bbox_h = float(max(1, ymax - ymin + 1))\n    bbox_w = float(max(1, xmax - xmin + 1))\n    return float(bbox_h / (bbox_w + 1e-8))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Waist constriction index: minimum horizontal width in the central third divided by maximum width (low for tapered garments)'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    thr = np.mean(gray) + 0.1 * (np.max(gray) - np.min(gray))\n    fg = gray > thr\n    coords = np.argwhere(fg)\n    if coords.size == 0:\n        return 0.0\n    r0, c0 = coords.min(axis=0)\n    r1, c1 = coords.max(axis=0) + 1\n    box = fg[r0:r1, c0:c1]\n    bh, bw = box.shape\n    if bh <= 2:\n        return 1.0\n    # compute width per row\n    widths = []\n    for rr in range(bh):\n        row = box[rr, :]\n        cols = np.where(row)[0]\n        if cols.size == 0:\n            widths.append(0.0)\n        else:\n            widths.append(float(cols.max() - cols.min() + 1))\n    widths = np.array(widths)\n    mid_start = bh // 3\n    mid_end = bh - mid_start\n    if mid_end <= mid_start:\n        return 1.0\n    mid_widths = widths[mid_start:mid_end]\n    max_w = float(np.max(widths)) if widths.size > 0 else 0.0\n    min_mid = float(np.min(mid_widths)) if mid_widths.size > 0 else max_w\n    eps = 1e-6\n    return float(min_mid / (max_w + eps))\n",
    "def feature(image: np.ndarray) -> float:\n    'Relative darkness (contrast) of a small top-center strip vs its immediate top-side strips'\n    try:\n        import numpy as np\n        h, w = image.shape[:2]\n        gray = np.mean(image, axis=2) if image.ndim == 3 else image.astype(float)\n        th = max(1, h // 12)\n        cw = max(1, w // 8)\n        center_start = max(0, w // 2 - cw // 2)\n        center_end = min(w, center_start + cw)\n        left_start = max(0, center_start - cw)\n        left_end = center_start\n        right_start = center_end\n        right_end = min(w, center_end + cw)\n        top_strip = gray[:th, :]\n        center_mean = float(np.mean(top_strip[:, center_start:center_end])) if center_end > center_start else float(np.mean(top_strip))\n        left_mean = float(np.mean(top_strip[:, left_start:left_end])) if left_end > left_start else center_mean\n        right_mean = float(np.mean(top_strip[:, right_start:right_end])) if right_end > right_start else center_mean\n        side_mean = 0.5 * (left_mean + right_mean)\n        denom = (abs(side_mean) + 1e-6)\n        # positive if center is darker than sides\n        return float((side_mean - center_mean) / denom)\n    except Exception:\n        return 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Entropy of gradient magnitudes in the central square region (measures texture/edges)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 3 or w < 3:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    ch = max(1, h // 4)\n    cw = max(1, w // 4)\n    r0 = h // 2 - ch\n    c0 = w // 2 - cw\n    center = gray[max(0, r0):min(h, r0 + 2*ch), max(0, c0):min(w, c0 + 2*cw)]\n    if center.size == 0:\n        return 0.0\n    gy, gx = np.gradient(center.astype(float))\n    mag = np.sqrt(gx * gx + gy * gy).flatten()\n    if mag.size == 0 or np.all(mag == 0):\n        return 0.0\n    hist, _ = np.histogram(mag, bins=16, range=(mag.min(), mag.max()))\n    p = hist.astype(float) / (np.sum(hist) + 1e-12)\n    p_non = p[p > 0]\n    ent = -float(np.sum(p_non * np.log(p_non)))\n    # normalize by log(bins)\n    return float(ent / (np.log(max(2, p.size)) + 1e-12))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Top indentation depth: average top edge y at center minus average of side top y, normalized by bounding-box height (positive for V-neck or deep collar)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    lo, hi = np.min(gray), np.max(gray)\n    if hi - lo < 1e-6:\n        return 0.0\n    thresh = lo + (hi - lo) * 0.03\n    mask = gray > thresh\n    if not mask.any():\n        return 0.0\n    rows = np.where(mask.any(axis=1))[0]\n    cols = np.where(mask.any(axis=0))[0]\n    if rows.size == 0 or cols.size == 0:\n        return 0.0\n    r0, r1 = rows[0], rows[-1] + 1\n    c0, c1 = cols[0], cols[-1] + 1\n    bbox = mask[r0:r1, c0:c1]\n    H, W = bbox.shape\n    # topmost y per column within bbox (relative to bbox)\n    top_y = np.full(W, H, dtype=float)\n    for j in range(W):\n        col = bbox[:, j]\n        nz = np.where(col)[0]\n        if nz.size:\n            top_y[j] = nz[0]\n    # split into left, center, right thirds\n    t = W // 3\n    left_avg = np.mean(top_y[:max(1, t)])\n    right_avg = np.mean(top_y[max(1, 2*t):]) if W > 2*t else np.mean(top_y[-max(1, t):])\n    center_avg = np.mean(top_y[t:2*t]) if W > 2*t else np.mean(top_y)\n    side_avg = np.mean([left_avg, right_avg])\n    depth = (center_avg - side_avg)  # center deeper -> positive (lower y -> smaller number but center_avg smaller than sides -> negative?), we want positive when center is lower (larger y)\n    # Since top_y measured from top of bbox increases downward, deeper center => center_avg > side_avg, so depth positive.\n    norm = float(H) if H > 0 else 1.0\n    return float(depth / (norm + 1e-9))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Estimated sleeve length indicator: fraction of vertical extent reached by object in left/right quarter (average of left and right normalized to bbox height)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    lo, hi = np.min(gray), np.max(gray)\n    if hi - lo < 1e-6:\n        return 0.0\n    thresh = lo + (hi - lo) * 0.03\n    mask = gray > thresh\n    if not mask.any():\n        return 0.0\n    rows = np.where(mask.any(axis=1))[0]\n    cols = np.where(mask.any(axis=0))[0]\n    if rows.size == 0 or cols.size == 0:\n        return 0.0\n    r0, r1 = rows[0], rows[-1] + 1\n    c0, c1 = cols[0], cols[-1] + 1\n    H, W = r1 - r0, c1 - c0\n    sub = mask[r0:r1, c0:c1]\n    left_slice = sub[:, :max(1, W//4)]\n    right_slice = sub[:, max(1, 3*W//4):]\n    def reach_fraction(slice_):\n        if slice_.size == 0:\n            return 0.0\n        # find lowest (max row index) object pixel in slice\n        nz = np.argwhere(slice_)\n        if nz.size == 0:\n            return 0.0\n        maxrow = nz[:,0].max()\n        return float((maxrow + 1) / float(H))\n    lf = reach_fraction(left_slice)\n    rf = reach_fraction(right_slice)\n    return float((lf + rf) / 2.0)\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Standard deviation of mean mask widths across vertical quartiles normalized by mean width'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    quart = max(1, h // 4)\n    means = []\n    for i in range(4):\n        start = i * quart\n        end = h if i == 3 else (i + 1) * quart\n        region = mask[start:end, :]\n        if region.size == 0:\n            means.append(0.0)\n        else:\n            means.append(float(np.mean(np.sum(region.astype(float), axis=1))))\n    means = np.array(means)\n    mean_all = float(np.mean(means)) + 1e-8\n    return float(np.std(means) / mean_all)\n",
    "def feature(image: np.ndarray) -> float:\n    'Bounding-box fill ratio: mask area divided by bounding-box area (1 = full)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 50)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    ys, xs = np.where(mask)\n    if ys.size == 0:\n        return 0.0\n    y0, y1 = ys.min(), ys.max()\n    x0, x1 = xs.min(), xs.max()\n    bbox_area = float((y1 - y0 + 1) * (x1 - x0 + 1))\n    mask_area = float(ys.size)\n    result = mask_area / (bbox_area + 1e-8)\n    return float(result)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Mean longest vertical run per column (normalized by height): captures strong vertical continuous strokes (higher -> more vertical length)'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    thr = np.percentile(gray, 75)\n    mask = gray > thr\n    if np.count_nonzero(mask) == 0:\n        thr = gray.mean()\n        mask = gray > thr\n    if np.count_nonzero(mask) == 0:\n        return 0.0\n    longest_runs = []\n    for c in range(w):\n        col = mask[:, c].astype(int)\n        if col.sum() == 0:\n            longest_runs.append(0)\n            continue\n        # find runs\n        max_run = 0\n        run = 0\n        for val in col:\n            if val:\n                run += 1\n            else:\n                if run > max_run:\n                    max_run = run\n                run = 0\n        if run > max_run:\n            max_run = run\n        longest_runs.append(max_run)\n    mean_longest = float(np.mean(longest_runs))\n    return mean_longest / max(1.0, h)\n",
    "def feature(image: np.ndarray) -> float:\n    'Fill ratio of mask within its bounding box (mask_area / bbox_area), ranges 0..1'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 50)\n    mask = gray < thr if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else gray > thr\n    ys, xs = np.where(mask)\n    if ys.size == 0:\n        return 0.0\n    y0, y1 = ys.min(), ys.max()\n    x0, x1 = xs.min(), xs.max()\n    bbox_area = float((y1 - y0 + 1) * (x1 - x0 + 1))\n    mask_area = float(ys.size)\n    if bbox_area <= 0:\n        return 0.0\n    return float(mask_area / bbox_area)\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Average center third bottom y minus linear-fit baseline (signed curvature in lower hem; positive if center is higher)'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    h, w = gray.shape\n    thr = np.mean(gray)\n    mask = gray > thr\n    if not np.any(mask):\n        return 0.0\n    ys = []\n    xs = []\n    # for each column inside bbox compute bottom-most nonzero y\n    cols = np.where(np.sum(mask, axis=0) > 0)[0]\n    if cols.size == 0:\n        return 0.0\n    for c in cols:\n        rows = np.where(mask[:, c])[0]\n        if rows.size > 0:\n            ys.append(rows.max())\n            xs.append(c)\n    xs = np.array(xs, dtype=np.float64)\n    ys = np.array(ys, dtype=np.float64)\n    if xs.size < 2:\n        return 0.0\n    # linear fit\n    A = np.vstack([xs, np.ones_like(xs)]).T\n    m, b = np.linalg.lstsq(A, ys, rcond=None)[0]\n    # center third columns\n    c1 = w // 3\n    c2 = 2 * w // 3\n    mask_center = (xs >= c1) & (xs <= c2)\n    if not np.any(mask_center):\n        return 0.0\n    deviations = ys[mask_center] - (m * xs[mask_center] + b)\n    # return mean deviation normalized by height\n    return float(np.mean(deviations) / float(h + 1e-9))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Mean vertical gradient magnitude in a narrow central vertical strip (captures seams/zipper lines)'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    cx = w // 2\n    strip_w = max(2, w // 10)\n    c0 = max(0, cx - strip_w)\n    c1 = min(w, cx + strip_w + 1)\n    strip = gray[:, c0:c1]\n    gy, gx = np.gradient(strip.astype(float))\n    mag = np.hypot(gx, gy)\n    return float(np.mean(mag))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Aggregate vertical gradient magnitude in the central third (captures buttons/zipper/central seam)'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    gray = gray.astype(np.float32)\n    h, w = gray.shape[:2]\n    vmin, vmax = float(np.min(gray)), float(np.max(gray))\n    th = float(np.percentile(gray, 50))\n    if vmax - vmin > 1e-8:\n        th = max(th, vmin + 0.12 * (vmax - vmin))\n    # crop to bounding box to focus on object\n    mask = gray > th\n    if np.count_nonzero(mask) == 0:\n        return 0.0\n    ys, xs = np.nonzero(mask)\n    r0, r1 = int(ys.min()), int(ys.max())\n    c0, c1 = int(xs.min()), int(xs.max())\n    bw = c1 - c0 + 1\n    cstart = c0 + bw // 3\n    cend = c0 + max(1, (2 * bw) // 3)\n    region = gray[r0:r1 + 1, cstart:cend]\n    if region.size == 0:\n        return 0.0\n    # vertical gradient (change along columns)\n    gy, gx = np.gradient(region)\n    mag = np.abs(gx)  # gradient across columns (vertical seam)\n    # normalize by region area and intensity range\n    res = float(np.sum(mag) / (region.size + 1e-6))\n    # scale relative to global intensity span to reduce sensitivity to absolute range\n    denom = (vmax - vmin) if (vmax - vmin) > 1e-6 else 1.0\n    return float(res / denom)\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Normalized vertical centroid of object pixels (0.0 top, 1.0 bottom)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    if h == 0:\n        return 0.0\n    thr = float(np.mean(gray) + 0.12 * (np.std(gray) + 1e-9))\n    mask = gray > thr\n    ys, xs = np.nonzero(mask)\n    if ys.size == 0:\n        return 0.0\n    centroid_y = float(np.mean(ys))\n    return float(centroid_y / max(1.0, h - 1.0))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Ratio of object horizontal span in the bottom quarter to the top quarter of the bounding box (bottom_width / top_width)'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    maxv, minv = float(np.max(gray)), float(np.min(gray))\n    thr = max(np.percentile(gray, 80), minv + 0.12 * (maxv - minv))\n    mask = gray >= thr\n    ys, xs = np.where(mask)\n    if ys.size == 0:\n        return 1.0\n    miny, maxy = ys.min(), ys.max()\n    minx, maxx = xs.min(), xs.max()\n    bbox_h = max(1, maxy - miny + 1)\n    bbox_w = max(1, maxx - minx + 1)\n    top_q_h = max(1, int(round(bbox_h * 0.25)))\n    bottom_q_h = max(1, int(round(bbox_h * 0.25)))\n    top_region = mask[miny:miny + top_q_h, minx:maxx+1]\n    bottom_region = mask[maxy - bottom_q_h + 1:maxy+1, minx:maxx+1]\n    def span_width(region):\n        if region.size == 0:\n            return 0\n        cols = np.any(region, axis=0)\n        if not cols.any():\n            return 0\n        col_idxs = np.where(cols)[0]\n        return float(col_idxs[-1] - col_idxs[0] + 1)\n    top_w = span_width(top_region)\n    bottom_w = span_width(bottom_region)\n    if top_w <= 0:\n        return float(bottom_w / max(1.0, bbox_w))\n    return float(bottom_w / top_w)\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Proportion of background pixels inside the central third of the object bounding box (holes/open areas)'\n    try:\n        if len(image.shape) == 3:\n            gray = np.mean(image, axis=2)\n        else:\n            gray = image.astype(float)\n    except Exception:\n        gray = np.array(image, dtype=float)\n    h, w = gray.shape[:2]\n    thr = np.mean(gray) + 0.5 * np.std(gray)\n    mask = gray > thr\n    if np.sum(mask) == 0:\n        return 0.0\n    ys, xs = np.where(mask)\n    y0, y1 = int(np.min(ys)), int(np.max(ys))\n    x0, x1 = int(np.min(xs)), int(np.max(xs))\n    # small bbox check\n    if x1 < x0 or y1 < y0:\n        return 0.0\n    # center third of bbox\n    cy0 = y0 + (y1 - y0) // 3\n    cy1 = y0 + 2 * (y1 - y0) // 3 + 1\n    cx0 = x0 + (x1 - x0) // 3\n    cx1 = x0 + 2 * (x1 - x0) // 3 + 1\n    cx0, cx1 = max(0, cx0), min(w, cx1)\n    cy0, cy1 = max(0, cy0), min(h, cy1)\n    region = mask[cy0:cy1, cx0:cx1]\n    if region.size == 0:\n        return 0.0\n    hole_fraction = 1.0 - (np.sum(region) / float(region.size))\n    return float(hole_fraction)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Ratio of texture (std dev) in central torso area to the average texture of symmetric side boxes (higher if torso has distinct texture like buttons/pockets)'\n    import numpy as np\n    h, w = image.shape[:2]\n    gray = np.mean(image, axis=2) if image.ndim == 3 else image.astype(float)\n    # define boxes: central box middle half height center 40% width; side boxes same size shifted left/right\n    hh = max(1, h // 2)\n    hw = max(1, w * 4 // 10)\n    r0 = max(0, h//4)\n    c0 = max(0, (w - hw)//2)\n    center_box = gray[r0:r0+hh, c0:c0+hw]\n    left_box = gray[r0:r0+hh, max(0, c0 - hw):c0]\n    right_box = gray[r0:r0+hh, c0+hw: min(w, c0+2*hw)]\n    if center_box.size == 0:\n        return 0.0\n    central_std = float(np.std(center_box))\n    side_stds = []\n    if left_box.size:\n        side_stds.append(np.std(left_box))\n    if right_box.size:\n        side_stds.append(np.std(right_box))\n    side_mean = float(np.mean(side_stds)) if side_stds else central_std + 1e-6\n    return float(central_std / max(1e-6, side_mean))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Left-right symmetry score: normalized mean absolute difference between left half and mirrored right half (lower is more symmetric)'\n    if image is None:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    h, w = gray.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    # crop to full rows and split\n    mid = w // 2\n    left = gray[:, :mid]\n    right = gray[:, w - mid:][:, ::-1]  # mirrored right side, align sizes\n    # if widths differ, pad smaller with zeros\n    if left.shape[1] != right.shape[1]:\n        minw = min(left.shape[1], right.shape[1])\n        left = left[:, :minw]\n        right = right[:, :minw]\n    diff = np.abs(left - right)\n    denom = np.mean(gray) if np.mean(gray) != 0 else 1.0\n    score = np.mean(diff) / denom\n    return float(score)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Horizontal offset of the object centroid relative to image center (abs fraction of half-width, larger => off-center)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    p60 = np.percentile(gray, 60)\n    p40 = np.percentile(gray, 40)\n    mask = (gray >= p60) if (gray >= p60).sum() >= (gray <= p40).sum() else (gray <= p40)\n    if mask.sum() == 0:\n        return 0.0\n    ys, xs = np.where(mask)\n    cx = float(xs.mean())\n    img_cx = gray.shape[1] / 2.0\n    half_width = gray.shape[1] / 2.0\n    offset = abs(cx - img_cx) / (half_width + 1e-6)\n    return float(offset)\n",
    "def feature(image: np.ndarray) -> float:\n    'Fraction of foreground pixels located in the bottom quarter of the image'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 50)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    total = float(np.count_nonzero(mask))\n    if total <= 0.0:\n        return 0.0\n    bottom_start = max(0, int(0.75 * h))\n    bottom_mask = mask[bottom_start:, :]\n    bottom_count = float(np.count_nonzero(bottom_mask))\n    return float(bottom_count / total)\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Left-right symmetry of the mask: 1.0 = perfectly symmetric, 0.0 = fully asymmetric'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    if not np.any(mask):\n        return 0.0\n    # mirror left onto right and compute normalized overlap\n    mid = w // 2\n    left = mask[:, :mid]\n    if w % 2 == 0:\n        right = mask[:, mid:][:, ::-1]\n    else:\n        right = mask[:, mid+1:][:, ::-1]\n    # align sizes\n    min_c = min(left.shape[1], right.shape[1])\n    left = left[:, :min_c]\n    right = right[:, :min_c]\n    if min_c == 0:\n        return 0.0\n    overlap = np.count_nonzero(left & right)\n    total = max(1, np.count_nonzero(left | right))\n    return float(overlap / float(total))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Global texture roughness estimated by mean absolute image Laplacian'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 3 or w < 3:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    gray = gray.astype(float)\n    # normalize to reduce scale sensitivity\n    mx = np.max(np.abs(gray))\n    if mx > 0:\n        gray = gray / mx\n    gy, gx = np.gradient(gray)\n    gyy, gyx = np.gradient(gy)\n    gxy, gxx = np.gradient(gx)\n    lap = gxx + gyy\n    rough = float(np.mean(np.abs(lap)))\n    return float(rough)\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Foreground solidity: mask area divided by its bounding-box area (0..1)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 50)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    coords = np.argwhere(mask)\n    if coords.size == 0:\n        return 0.0\n    area = float(coords.shape[0])\n    ys, xs = coords[:, 0], coords[:, 1]\n    bbox_h = float(max(1, ys.max() - ys.min() + 1))\n    bbox_w = float(max(1, xs.max() - xs.min() + 1))\n    bbox_area = bbox_h * bbox_w\n    solidity = area / (bbox_area + 1e-8)\n    if not np.isfinite(solidity):\n        return 0.0\n    return float(max(0.0, min(1.0, solidity)))\n",
    "def feature(image: np.ndarray) -> float:\n    'Bounding box area fraction of the foreground mask'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    total = float(max(1, h * w))\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 50)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    ys, xs = np.where(mask)\n    if ys.size == 0 or xs.size == 0:\n        return 0.0\n    ymin, ymax = int(np.min(ys)), int(np.max(ys))\n    xmin, xmax = int(np.min(xs)), int(np.max(xs))\n    box_area = float((ymax - ymin + 1) * (xmax - xmin + 1))\n    frac = box_area / total\n    return float(frac)\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Upper-sleeve extent: average horizontal extension of object in upper third outside central torso region'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    if h < 3 or w == 0:\n        return 0.0\n    mn, mx = float(gray.min()), float(gray.max())\n    norm = (gray - mn) / (mx - mn) if mx > mn else (gray - mn)\n    thresh = float(np.percentile(norm, 60))\n    mask = norm > thresh\n    upper = mask[:h//3, :]\n    if upper.size == 0:\n        return 0.0\n    # define central torso zone as middle 40% of width\n    cw1 = int(w * 0.3)\n    cw2 = int(w * 0.7)\n    left_zone = upper[:, :cw1]\n    right_zone = upper[:, cw2:]\n    # compute average fraction of columns in left/right zone that contain object pixels (extent)\n    left_extent = np.count_nonzero(np.any(left_zone, axis=0)) / max(1, left_zone.shape[1])\n    right_extent = np.count_nonzero(np.any(right_zone, axis=0)) / max(1, right_zone.shape[1])\n    return float((left_extent + right_extent) / 2.0)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Number of connected components in the bottom quarter of the mask (useful to detect two shoes)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    start = max(0, h - max(1, h // 4))\n    sub = mask[start:, :].astype(np.uint8)\n    sh, sw = sub.shape\n    if sh == 0 or sw == 0:\n        return 0.0\n    visited = np.zeros_like(sub, dtype=bool)\n    comps = 0\n    for i in range(sh):\n        for j in range(sw):\n            if sub[i, j] and not visited[i, j]:\n                comps += 1\n                # flood fill (4-connectivity)\n                stack = [(i, j)]\n                visited[i, j] = True\n                while stack:\n                    y, x = stack.pop()\n                    if y > 0 and sub[y - 1, x] and not visited[y - 1, x]:\n                        visited[y - 1, x] = True\n                        stack.append((y - 1, x))\n                    if y + 1 < sh and sub[y + 1, x] and not visited[y + 1, x]:\n                        visited[y + 1, x] = True\n                        stack.append((y + 1, x))\n                    if x > 0 and sub[y, x - 1] and not visited[y, x - 1]:\n                        visited[y, x - 1] = True\n                        stack.append((y, x - 1))\n                    if x + 1 < sw and sub[y, x + 1] and not visited[y, x + 1]:\n                        visited[y, x + 1] = True\n                        stack.append((y, x + 1))\n    return float(comps)\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Bounding-box aspect ratio (height / width) of the mask'\n    import numpy as np\n    if image is None:\n        return 1.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 1.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    ys, xs = np.where(mask)\n    if ys.size == 0:\n        return 1.0\n    ymin, ymax = int(np.min(ys)), int(np.max(ys))\n    xmin, xmax = int(np.min(xs)), int(np.max(xs))\n    bw = float(xmax - xmin + 1)\n    bh = float(ymax - ymin + 1)\n    if bw <= 0:\n        return 1.0\n    return float(bh / (bw + 1e-8))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Maximum continuous vertical run of object pixels in any column, normalized by image height'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 50)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    max_run = 0\n    for c in range(w):\n        col = mask[:, c]\n        # scan for longest True run\n        cur = 0\n        best = 0\n        for val in col:\n            if val:\n                cur += 1\n                if cur > best:\n                    best = cur\n            else:\n                cur = 0\n        if best > max_run:\n            max_run = best\n    if h <= 0:\n        return 0.0\n    return float(max_run / (h + 1e-8))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Number of prominent peaks in the horizontal projection (columns) of the object normalized by image width'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    h, w = gray.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    thr = np.mean(gray) + 0.15 * (np.max(gray) - np.min(gray))\n    fg = (gray > thr)\n    if np.count_nonzero(fg) == 0:\n        fg = (gray > np.percentile(gray, 75))\n    proj = fg.sum(axis=0).astype(float)\n    if proj.max() == 0:\n        return 0.0\n    # smooth projection with simple kernel\n    kernel = np.array([1.0, 2.0, 1.0])\n    smooth = np.convolve(proj, kernel, mode='same')\n    # count local maxima that are substantial\n    thresh = 0.4 * smooth.max()\n    peaks = 0\n    for i in range(1, w-1):\n        if smooth[i] > smooth[i-1] and smooth[i] > smooth[i+1] and smooth[i] >= thresh:\n            peaks += 1\n    return float(peaks) / max(1.0, float(w))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Count of connected mask components with size >=1% image area, normalized by image area'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    area_thresh = max(1, int(0.01 * h * w))\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    visited = np.zeros_like(mask, dtype=bool)\n    comps = 0\n    for r in range(h):\n        for c in range(w):\n            if mask[r, c] and not visited[r, c]:\n                # BFS\n                stack = [(r, c)]\n                visited[r, c] = True\n                cnt = 0\n                while stack:\n                    y, x = stack.pop()\n                    cnt += 1\n                    if y > 0 and mask[y - 1, x] and not visited[y - 1, x]:\n                        visited[y - 1, x] = True\n                        stack.append((y - 1, x))\n                    if y + 1 < h and mask[y + 1, x] and not visited[y + 1, x]:\n                        visited[y + 1, x] = True\n                        stack.append((y + 1, x))\n                    if x > 0 and mask[y, x - 1] and not visited[y, x - 1]:\n                        visited[y, x - 1] = True\n                        stack.append((y, x - 1))\n                    if x + 1 < w and mask[y, x + 1] and not visited[y, x + 1]:\n                        visited[y, x + 1] = True\n                        stack.append((y, x + 1))\n                if cnt >= area_thresh:\n                    comps += 1\n    return float(comps) / float(max(1.0, h * w))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Compactness of mask: perimeter^2 / area (lower = more compact). 0 if undefined'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 1 or w < 1:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 50)\n    mask = ((gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)).astype(bool)\n    area = float(np.count_nonzero(mask))\n    if area <= 0.0:\n        return 0.0\n    # perimeter: count mask pixels with at least one 4-neighbor background\n    perim = 0\n    # pad to avoid bounds checks\n    padded = np.pad(mask, pad_width=1, mode='constant', constant_values=False)\n    for y in range(1, h + 1):\n        row = padded[y]\n        up = padded[y - 1]\n        down = padded[y + 1]\n        left = np.roll(row, 1)\n        right = np.roll(row, -1)\n        # compute where mask is True and any neighbor is False\n        neighbors_and = up & down & left & right\n        border = row & (~neighbors_and)\n        perim += int(np.count_nonzero(border))\n    if perim <= 0:\n        return 0.0\n    compact = (perim * perim) / (area + 1e-8)\n    return float(compact)\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Fill ratio: fraction of pixels inside the object bounding box that are object pixels (0..1)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    thr = (np.mean(gray) + np.min(gray)) * 0.5\n    mask = gray > thr\n    if np.count_nonzero(mask) == 0:\n        return 0.0\n    rows = np.any(mask, axis=1)\n    cols = np.any(mask, axis=0)\n    r_inds = np.where(rows)[0]\n    c_inds = np.where(cols)[0]\n    if r_inds.size == 0 or c_inds.size == 0:\n        return 0.0\n    r0, r1 = r_inds[0], r_inds[-1]\n    c0, c1 = c_inds[0], c_inds[-1]\n    bbox_area = float((r1 - r0 + 1) * (c1 - c0 + 1))\n    obj_area = float(np.count_nonzero(mask[r0:r1+1, c0:c1+1]))\n    if bbox_area <= 0:\n        return 0.0\n    return obj_area / bbox_area\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Average number of vertical mask transitions per column in the upper 35% (captures sleeves/shoulder gaps)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 4 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    top_h = max(1, int(0.35 * h))\n    region = mask[:top_h, :]\n    if region.size == 0:\n        return 0.0\n    # count transitions along each column\n    diffs = np.abs(np.diff(region.astype(int), axis=0))\n    trans_per_col = np.sum(diffs, axis=0).astype(float)\n    # normalize by max possible transitions (top_h-1)\n    max_trans = float(max(1, top_h - 1))\n    avg_trans = float(np.mean(trans_per_col) / max_trans)\n    return float(max(0.0, min(1.0, avg_trans)))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Fraction of high-gradient pixels in the bottom quarter (edge activity near feet/shoes)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 2 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    gy, gx = np.gradient(gray.astype(float))\n    grad = np.sqrt(gx*gx + gy*gy)\n    thresh = np.percentile(grad, 60) if np.any(grad) else 0.0\n    strong = grad > thresh\n    bottom = strong[3*h//4:, :]\n    denom = float(bottom.size) + 1e-8\n    return float(np.count_nonzero(bottom) / denom)\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Central vertical gradient prominence: mean vertical gradient in the central third columns divided by overall mean gradient'\n    import numpy as np\n    if image is None:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    gy = np.abs(np.gradient(gray, axis=0))\n    gx = np.abs(np.gradient(gray, axis=1))\n    grad_mag = np.sqrt(gy**2 + gx**2)\n    h, w = gray.shape[:2]\n    c0, c1 = w//3, (2*w)//3\n    central = grad_mag[:, c0:c1]\n    overall_mean = float(np.mean(grad_mag)) + 1e-9\n    central_mean = float(np.mean(central))\n    return float(central_mean / overall_mean)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Average gradient magnitude in the top-center region (captures collars and neck openings)'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    th = max(1, h // 8)\n    tw = max(1, w // 3)\n    r0 = 0\n    r1 = th\n    c0 = max(0, w//2 - tw//2)\n    c1 = min(w, c0 + tw)\n    region = gray[r0:r1, c0:c1]\n    if region.size == 0:\n        return 0.0\n    gy, gx = np.gradient(region.astype(float))\n    mag = np.sqrt(gx**2 + gy**2)\n    # normalize by overall image gradient magnitude\n    gy_all, gx_all = np.gradient(gray.astype(float))\n    mag_all = np.sqrt(gx_all**2 + gy_all**2)\n    denom = np.mean(mag_all) + 1e-8\n    return float(np.mean(mag) / denom)\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Fraction of strong Harris-like corner responses inside the mask'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 3 or w < 3:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    gy, gx = np.gradient(gray.astype(float))\n    Ix2 = gx * gx\n    Iy2 = gy * gy\n    Ixy = gx * gy\n    # local 3x3 sum via padding and slicing\n    pIx2 = np.pad(Ix2, 1, mode='constant', constant_values=0.0)\n    pIy2 = np.pad(Iy2, 1, mode='constant', constant_values=0.0)\n    pIxy = np.pad(Ixy, 1, mode='constant', constant_values=0.0)\n    def local_sum(p):\n        return (p[:-2, :-2] + p[:-2, 1:-1] + p[:-2, 2:] +\n                p[1:-1, :-2] + p[1:-1, 1:-1] + p[1:-1, 2:] +\n                p[2:, :-2] + p[2:, 1:-1] + p[2:, 2:])\n    Sxx = local_sum(pIx2)\n    Syy = local_sum(pIy2)\n    Sxy = local_sum(pIxy)\n    # Harris response\n    k = 0.04\n    det = (Sxx * Syy) - (Sxy * Sxy)\n    trace = (Sxx + Syy)\n    R = det - k * (trace * trace)\n    # threshold strong corners at 90th percentile of positive responses\n    posR = R.copy()\n    posR[posR < 0] = 0.0\n    if not np.any(posR):\n        return 0.0\n    thrR = np.percentile(posR, 90)\n    strong = posR > thrR\n    thr_mask = np.percentile(gray, 55)\n    mask = (gray < thr_mask) if np.count_nonzero(gray < thr_mask) >= np.count_nonzero(gray > thr_mask) else (gray > thr_mask)\n    inside_strong = np.count_nonzero(strong & mask)\n    mask_area = np.count_nonzero(mask)\n    if mask_area == 0:\n        return 0.0\n    return float(inside_strong / (mask_area + 1e-8))\n",
    "def feature(image: np.ndarray) -> float:\n    'Normalized vertical centroid of the foreground mask (0=top,1=bottom)'\n    import numpy as np\n    if image is None:\n        return 0.5\n    h, w = image.shape[:2]\n    if h == 0:\n        return 0.5\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 50)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    ys, xs = np.where(mask)\n    if ys.size == 0:\n        return 0.5\n    centroid_y = float(np.mean(ys)) / float(max(1, h - 1))\n    return float(centroid_y)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Mean absolute second difference of side boundary x-positions (left and right) across rows (measures edge smoothness / curvature)'\n    import numpy as np\n    gray = np.mean(image, axis=2) if len(image.shape) == 3 else image.astype(float)\n    h, w = gray.shape[:2]\n    thr = gray.mean() + 0.12 * (gray.max() - gray.mean())\n    mask = gray > thr\n    if np.count_nonzero(mask) == 0:\n        thr = gray.mean()\n        mask = gray > thr\n    if np.count_nonzero(mask) == 0:\n        return 0.0\n    left = np.full(h, np.nan)\n    right = np.full(h, np.nan)\n    for r in range(h):\n        cols = np.where(mask[r, :])[0]\n        if cols.size > 0:\n            left[r] = cols.min()\n            right[r] = cols.max()\n    def sec_diff(arr):\n        vals = arr[~np.isnan(arr)]\n        if vals.size < 3:\n            return 0.0\n        d2 = np.abs(np.diff(vals, n=2))\n        return np.mean(d2) / max(1.0, w)\n    left_score = sec_diff(left)\n    right_score = sec_diff(right)\n    return float((left_score + right_score) / 2.0)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Normalized vertical centroid offset (positive = object lower than image center)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = gray < thr if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else gray > thr\n    total = np.count_nonzero(mask)\n    if total == 0:\n        return 0.0\n    ys = np.arange(h).reshape(h, 1)\n    cy = float(np.sum(mask * ys) / total)\n    center_y = (h - 1) / 2.0\n    offset = (cy - center_y) / max(1.0, h / 2.0)\n    return float(offset)\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Ratio of mean object width in the top quartile of the bounding box to the bottom quartile (top_width / bottom_width)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    thr = np.mean(gray) + 0.2 * (np.max(gray) - np.min(gray))\n    mask = gray > thr\n    if np.count_nonzero(mask) == 0:\n        mask = gray > np.mean(gray)\n    if np.count_nonzero(mask) == 0:\n        return 0.0\n    rows, cols = np.where(mask)\n    rmin, rmax = rows.min(), rows.max()\n    if rmax - rmin < 3:\n        return 1.0\n    heights = rmax - rmin + 1\n    top_slice = slice(rmin, rmin + heights // 4)\n    bottom_slice = slice(rmax - heights // 4 + 1, rmax + 1)\n    def mean_width(slice_rows):\n        widths = []\n        for r in range(slice_rows.start, slice_rows.stop):\n            row = mask[r, :]\n            if np.any(row):\n                c = np.where(row)[0]\n                widths.append(c.max() - c.min() + 1)\n        return np.mean(widths) if widths else 0.0\n    top_w = mean_width(top_slice)\n    bottom_w = mean_width(bottom_slice)\n    if bottom_w == 0:\n        return float(top_w)\n    return float(top_w / bottom_w)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Approximate hole fraction: zero pixels inside bounding-box that are enclosed horizontally and vertically'\n    import numpy as np\n    if image is None:\n        return 0.0\n    import numpy as _np\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = _np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = _np.percentile(gray, 55)\n    mask = (gray < thr) if _np.count_nonzero(gray < thr) >= _np.count_nonzero(gray > thr) else (gray > thr)\n    ys, xs = _np.where(mask)\n    if ys.size == 0:\n        return 0.0\n    miny, maxy = int(_np.min(ys)), int(_np.max(ys))\n    minx, maxx = int(_np.min(xs)), int(_np.max(xs))\n    bbox_h = maxy - miny + 1\n    bbox_w = maxx - minx + 1\n    if bbox_h <= 0 or bbox_w <= 0:\n        return 0.0\n    sub = mask[miny:maxy + 1, minx:maxx + 1]\n    bh, bw = sub.shape\n    holes = 0\n    # for each zero pixel check if there is mask on both sides in row and column\n    for r in range(bh):\n        row = sub[r, :]\n        left_cum = _np.maximum.accumulate(row.astype(int))\n        right_cum = _np.maximum.accumulate(row[::-1].astype(int))[::-1]\n        for c in range(bw):\n            if not row[c]:\n                left_exists = left_cum[c - 1] if c - 1 >= 0 else 0\n                right_exists = right_cum[c + 1] if c + 1 < bw else 0\n                if not left_exists or not right_exists:\n                    continue\n                col = sub[:, c]\n                up_exists = _np.any(col[:r]) if r - 1 >= 0 else False\n                down_exists = _np.any(col[r + 1:]) if r + 1 < bh else False\n                if up_exists and down_exists:\n                    holes += 1\n    bbox_area = float(bh * bw)\n    return float(holes / (bbox_area + 1e-8))\n",
    "def feature(image: np.ndarray) -> float:\n    'Ratio of mask mass in top third to bottom third (top_third / bottom_third)'\n    import numpy as np\n    if image is None:\n        return 1.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 1.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    t = max(1, h // 3)\n    top_mass = float(np.count_nonzero(mask[:t, :]))\n    bot_mass = float(np.count_nonzero(mask[h - t:, :]))\n    return float((top_mass + 1e-8) / (bot_mass + 1e-8))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Median number of mask segments per row within bottom third (helps identify separate shoes)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 3 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 50)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    start = (2 * h) // 3\n    counts = []\n    for r in range(start, h):\n        row = mask[r, :].astype(np.int8)\n        if np.all(row == 0):\n            continue\n        dif = np.diff(np.concatenate(([0], row)))\n        starts = np.count_nonzero(dif == 1)\n        counts.append(float(starts))\n    if len(counts) == 0:\n        return 0.0\n    med = float(np.median(np.array(counts)))\n    # normalize by 2 (0..2 typical for two shoes)\n    return float(med / 2.0)\n",
    "def feature(image: np.ndarray) -> float:\n    'Foreground bounding-box aspect ratio (height / width) computed from a simple intensity mask'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    ys, xs = np.where(mask)\n    if ys.size == 0 or xs.size == 0:\n        return 0.0\n    bbox_h = float(ys.max() - ys.min() + 1)\n    bbox_w = float(xs.max() - xs.min() + 1)\n    if bbox_w <= 1e-8:\n        return 0.0\n    return float(bbox_h / bbox_w)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Fraction of rows in the top third that are densely occupied (>50% of bounding width) (captures shoulder/torso presence)'\n    import numpy as np\n    img = np.array(image, copy=False)\n    h, w = img.shape[:2]\n    if h < 3:\n        return 0.0\n    t = float(np.mean(img) + 0.1 * np.std(img))\n    bw = (img > t).astype(np.uint8)\n    coords = np.argwhere(bw)\n    if coords.size == 0:\n        return 0.0\n    rmin, cmin = coords.min(axis=0)\n    rmax, cmax = coords.max(axis=0)\n    top_third_end = rmin + max(1, (rmax - rmin + 1) // 3)\n    top_region = bw[rmin:top_third_end+1, cmin:cmax+1]\n    if top_region.size == 0:\n        return 0.0\n    region_width = max(1, cmax - cmin + 1)\n    dense_rows = 0\n    for row in top_region:\n        if np.count_nonzero(row) >= 0.5 * region_width:\n            dense_rows += 1\n    return float(dense_rows / float(top_region.shape[0]))\n",
    "def feature(image: np.ndarray) -> float:\n    'Bounding-box aspect ratio of the detected foreground (height / width)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    ys, xs = np.where(mask)\n    if ys.size == 0:\n        return 0.0\n    ymin, ymax = int(np.min(ys)), int(np.max(ys))\n    xmin, xmax = int(np.min(xs)), int(np.max(xs))\n    bbox_h = float(max(1, (ymax - ymin + 1)))\n    bbox_w = float(max(1, (xmax - xmin + 1)))\n    return float(bbox_h / (bbox_w + 1e-8))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Count of internal vertical gaps inside object mask (empty horizontal bands within bbox)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 3 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    ys, xs = np.where(mask)\n    if ys.size == 0:\n        return 0.0\n    miny, maxy = ys.min(), ys.max()\n    band = mask[miny:maxy+1, :]\n    row_sums = np.sum(band.astype(int), axis=1)\n    zero_rows = (row_sums == 0)\n    # count contiguous zero segments longer than 1% of image height (but at least 1)\n    min_len = max(1, h // 100)\n    count = 0\n    i = 0\n    L = zero_rows.size\n    while i < L:\n        if zero_rows[i]:\n            j = i\n            while j < L and zero_rows[j]:\n                j += 1\n            if (j - i) >= min_len:\n                count += 1\n            i = j\n        else:\n            i += 1\n    return float(count)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Solidity-like measure: foreground area divided by its bounding-box area (0..1+)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 50)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    area = float(np.count_nonzero(mask))\n    if area == 0.0:\n        return 0.0\n    ys, xs = np.where(mask)\n    miny, maxy = int(np.min(ys)), int(np.max(ys))\n    minx, maxx = int(np.min(xs)), int(np.max(xs))\n    bbox_area = float(max(1, (maxy - miny + 1)) * max(1, (maxx - minx + 1)))\n    return float(area / (bbox_area + 1e-12))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Fraction of mask pixels that lie within a central circle (radius = min(h,w)/4)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    cy = (h - 1) / 2.0\n    cx = (w - 1) / 2.0\n    rr = min(h, w) / 4.0\n    ys = np.arange(h).astype(float)[:, None]\n    xs = np.arange(w).astype(float)[None, :]\n    dist2 = (ys - cy) ** 2 + (xs - cx) ** 2\n    circle = dist2 <= (rr * rr + 1e-8)\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    total = np.count_nonzero(mask)\n    if total == 0:\n        return 0.0\n    inside = np.count_nonzero(mask & circle)\n    return float(inside / (total + 1e-8))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Inner-torso vs outer-side intensity contrast (central cloth vs sleeves/background)'\n    import numpy as np\n    gray = np.mean(image, axis=2) if len(image.shape) == 3 else image.astype(float)\n    h, w = gray.shape[:2]\n    r0, r1 = h // 3, min(h, 2 * h // 3)\n    inner_c0, inner_c1 = w // 3, 2 * w // 3\n    side_width = max(1, w // 8)\n    left_side = gray[r0:r1, 0:side_width]\n    right_side = gray[r0:r1, w - side_width:w]\n    inner = gray[r0:r1, inner_c0:inner_c1]\n    if inner.size == 0:\n        return 0.0\n    side_mean = np.mean(np.concatenate([left_side.flatten(), right_side.flatten()])) if (left_side.size + right_side.size) > 0 else np.mean(inner)\n    inner_mean = np.mean(inner)\n    return float((inner_mean - side_mean) / (np.std(gray) + 1e-6))\n",
    "def feature(image: np.ndarray) -> float:\n    'Longest continuous vertical presence through the center columns: measures overlapped fronts or long vertical features'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    med = np.median(gray)\n    mask = (gray > med) if (np.count_nonzero(gray > med) < np.count_nonzero(gray < med)) else (gray < med)\n    if not np.any(mask):\n        return 0.0\n    rows = np.any(mask, axis=1)\n    cols = np.any(mask, axis=0)\n    r0 = int(np.argmax(rows))\n    r1 = int(h - np.argmax(rows[::-1]))\n    c0 = int(np.argmax(cols))\n    c1 = int(w - np.argmax(cols[::-1]))\n    if r1 <= r0 or c1 <= c0:\n        return 0.0\n    bbox_h = r1 - r0\n    bbox_w = c1 - c0\n    center_col = c0 + bbox_w // 2\n    half_width = max(1, bbox_w // 20)\n    center_cols = slice(max(c0, center_col - half_width), min(c1, center_col + half_width + 1))\n    vertical_presence = np.any(mask[r0:r1, center_cols], axis=1)\n    if vertical_presence.size == 0:\n        return 0.0\n    # longest contiguous True run\n    arr = vertical_presence.astype(int)\n    diffs = np.diff(np.concatenate(([0], arr, [0])))\n    starts = np.where(diffs == 1)[0]\n    ends = np.where(diffs == -1)[0]\n    if starts.size == 0:\n        return 0.0\n    runs = ends - starts\n    longest = float(np.max(runs))\n    return float(longest / (bbox_h + 1e-6))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Waist constriction index: (min width / max width) within the central vertical band (lower means pronounced waist)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    if h < 3 or w < 2:\n        return 1.0\n    thr = (np.nanmax(gray) + np.nanmin(gray)) / 2.0\n    mask = gray > thr\n    start = h // 3\n    end = max(start + 1, (2 * h) // 3)\n    widths = []\n    for r in range(start, end):\n        cols = np.where(mask[r])[0]\n        if cols.size:\n            widths.append(float(cols[-1] - cols[0] + 1))\n    if len(widths) == 0:\n        return 1.0\n    minw = float(np.min(widths))\n    maxw = float(np.max(widths))\n    if maxw <= 1e-6:\n        return 1.0\n    return float(minw / (maxw + 1e-12))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Ratio of foreground fraction in top 40% vs bottom 40% of the image'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 2 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    top_h = max(1, h * 40 // 100)\n    bottom_h = top_h\n    top_count = float(np.count_nonzero(mask[:top_h, :]))\n    bottom_count = float(np.count_nonzero(mask[-bottom_h:, :]))\n    # return ratio top / bottom (balanced)\n    return float((top_count + 1e-8) / (bottom_count + 1e-8))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Edge density inside the mask: fraction of mask pixels with strong gradient'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 2 or w < 2:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    gy, gx = np.gradient(gray)\n    grad = np.sqrt(gx * gx + gy * gy)\n    edge_thr = np.percentile(grad, 70) if np.any(grad) else 0.0\n    strong = grad > edge_thr\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    mask_area = float(np.count_nonzero(mask))\n    if mask_area <= 0.0:\n        return 0.0\n    count = float(np.count_nonzero(strong & mask))\n    return float(count / (mask_area + 1e-8))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Absolute horizontal centroid offset normalized by half-width (0=centered, >0 off-center)'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    thr = 0.5 * (np.max(gray) + np.median(gray))\n    mask1 = gray > thr\n    mask2 = gray < thr\n    def bbox_area(m):\n        ys, xs = np.where(m)\n        return float((ys.max() - ys.min() + 1) * (xs.max() - xs.min() + 1)) if ys.size else h*w+1\n    mask = mask1 if bbox_area(mask1) <= bbox_area(mask2) else mask2\n    ys, xs = np.where(mask)\n    if xs.size == 0:\n        return 0.0\n    cx = float(np.mean(xs))\n    offset = abs(cx - (w - 1) / 2.0)\n    return float(offset / max(1.0, (w - 1) / 2.0))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Colorfulness proxy: mean of absolute channel differences normalized by mean intensity'\n    import numpy as np\n    if image is None:\n        return 0.0\n    if len(image.shape) != 3:\n        # grayscale has no colorfulness\n        return 0.0\n    h, w, c = image.shape\n    if c < 3 or h == 0 or w == 0:\n        return 0.0\n    img = image.astype(float)\n    r = img[:, :, 0]\n    g = img[:, :, 1]\n    b = img[:, :, 2]\n    diff_rg = np.abs(r - g)\n    diff_rb = np.abs(r - b)\n    val = np.mean(diff_rg + diff_rb)\n    denom = np.mean((r + g + b) / 3.0) + 1e-8\n    return float(val / denom)\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Slope of the object width profile (linear fit of row widths vs row index), normalized by image height (positive => flares outward)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    h, w = gray.shape[:2]\n    val_min, val_max = np.min(gray), np.max(gray)\n    if val_max == val_min or h < 3:\n        return 0.0\n    thr = val_min + 0.1 * (val_max - val_min)\n    mask = gray > thr\n    widths = []\n    rows = []\n    for r in range(h):\n        cols = np.where(mask[r])[0]\n        if cols.size > 0:\n            widths.append(cols.max() - cols.min() + 1)\n            rows.append(r)\n    if len(widths) < 2:\n        return 0.0\n    try:\n        p = np.polyfit(rows, widths, 1)\n        slope = p[0]\n    except Exception:\n        slope = 0.0\n    # normalize slope by width per height unit: divide by w and multiply by h to get comparable\n    return float((slope / w) * h)\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Normalized collar gap depth at center column: distance from top to first object pixel (smaller = object reaches top quickly)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    if h == 0 or w == 0:\n        return 1.0\n    bg_h, bg_w = max(1, h // 10), max(1, w // 10)\n    bg = np.mean(gray[:bg_h, :bg_w])\n    gm = np.mean(gray)\n    thresh = (bg + gm) / 2.0\n    object_is_darker = gm < bg\n    if object_is_darker:\n        mask = gray < thresh\n    else:\n        mask = gray > thresh\n    center_col = w // 2\n    col_mask = mask[:, center_col]\n    hits = np.where(col_mask)[0]\n    if hits.size == 0:\n        return 1.0\n    first = float(hits[0])\n    return float(first / max(1.0, h))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Relative sleeve extension: how much side regions extend downward compared to central body (normalized)'\n    import numpy as np\n    img = np.asarray(image)\n    if img.size == 0:\n        return 0.0\n    if img.ndim == 3:\n        gray = np.mean(img, axis=2)\n    else:\n        gray = img.astype(float)\n    h, w = gray.shape\n    thr = max(np.mean(gray) * 0.5, np.max(gray) * 0.05)\n    mask = gray > thr\n    if not mask.any():\n        return 0.0\n    ys, xs = np.where(mask)\n    r0, r1 = ys.min(), ys.max()\n    c0, c1 = xs.min(), xs.max()\n    bh, bw = r1 - r0 + 1, c1 - c0 + 1\n    # define regions\n    left_region = mask[r0:r1+1, c0:c0 + max(1, bw//4)]\n    right_region = mask[r0:r1+1, c1 - max(1, bw//4)+1:c1+1]\n    center_region = mask[r0:r1+1, c0 + bw//4 : c1 - bw//4 + 1]\n    def bottom_extent(region, r0_local):\n        # return lowest y index (relative) that has any nonzero, else top\n        ys_local = np.where(region.any(axis=1))[0]\n        return int(ys_local.max()) if ys_local.size else 0\n    left_bottom = bottom_extent(left_region, r0)\n    right_bottom = bottom_extent(right_region, r0)\n    center_bottom = bottom_extent(center_region, r0)\n    avg_side = (left_bottom + right_bottom) / 2.0\n    # normalized by bounding-box height\n    ratio = (avg_side - center_bottom) / (bh + 1e-9)\n    return float(max(0.0, ratio))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Perimeter-to-area compactness: perimeter / area (higher => more complex outline)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 50)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    area = float(np.count_nonzero(mask))\n    if area <= 0.0:\n        return 0.0\n    # compute 4-neighbor boundary via padding to avoid wrap\n    pad = np.pad(mask, 1, mode='constant', constant_values=False)\n    center = pad[1:-1, 1:-1]\n    up = pad[0:-2, 1:-1]\n    down = pad[2:, 1:-1]\n    left = pad[1:-1, 0:-2]\n    right = pad[1:-1, 2:]\n    neighbor_all = up & down & left & right\n    boundary = center & (~neighbor_all)\n    perimeter = float(np.count_nonzero(boundary))\n    return float(perimeter / (area + 1e-8))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Normalized standard deviation of horizontal span (width of object per row) in the bottom quarter (flare/hem variability)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    mx = gray.max() if gray.size else 0.0\n    thresh = mx * 0.05 if mx > 0 else 0.0\n    mask = gray > thresh\n    if not mask.any():\n        return 0.0\n    rows = np.any(mask, axis=1)\n    cols = np.any(mask, axis=0)\n    rmin, rmax = np.argmax(rows), len(rows) - 1 - np.argmax(rows[::-1])\n    cmin, cmax = np.argmax(cols), len(cols) - 1 - np.argmax(cols[::-1])\n    h = rmax - rmin + 1\n    w = cmax - cmin + 1\n    if h <= 0 or w <= 0:\n        return 0.0\n    bottom_h = max(1, int(h * 0.25))\n    r0 = max(rmin, rmax - bottom_h + 1)\n    spans = []\n    for r in range(r0, rmax + 1):\n        row = mask[r, cmin:cmax+1]\n        if not row.any():\n            continue\n        left = np.argmax(row)\n        right = len(row) - 1 - np.argmax(row[::-1])\n        spans.append(right - left + 1)\n    if len(spans) == 0:\n        return 0.0\n    spans = np.array(spans, dtype=float)\n    mean = spans.mean()\n    std = spans.std()\n    denom = mean if mean > 1e-6 else 1.0\n    return float(std / denom)\n",
    "def feature(image: np.ndarray) -> float:\n    'Vertical centroid of the mask normalized to [0..1] (0=top,1=bottom)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h <= 0 or w <= 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 50)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    ys, xs = np.where(mask)\n    if ys.size == 0:\n        return 0.0\n    centroid_y = float(np.mean(ys))\n    return float(centroid_y / max(1.0, float(h - 1)))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Mean normalized red-minus-blue channel difference (RGB only), grayscale -> 0'\n    import numpy as np\n    if image is None:\n        return 0.0\n    if len(image.shape) != 3 or image.shape[2] < 3:\n        return 0.0\n    img = image.astype(float)\n    r = np.mean(img[:, :, 0])\n    g = np.mean(img[:, :, 1])\n    b = np.mean(img[:, :, 2])\n    denom = (np.mean(img) + 1e-8)\n    return float((r - b) / denom)\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Mean color saturation (HSV-style) for RGB images, 0 for grayscale'\n    import numpy as np\n    if image is None:\n        return 0.0\n    if len(image.shape) != 3 or image.shape[2] < 3:\n        return 0.0\n    img = image.astype(float)\n    r = img[:, :, 0]\n    g = img[:, :, 1]\n    b = img[:, :, 2]\n    mx = np.maximum(np.maximum(r, g), b)\n    mn = np.minimum(np.minimum(r, g), b)\n    diff = mx - mn\n    # saturation per pixel\n    sat = np.where(mx > 0, diff / (mx + 1e-8), 0.0)\n    return float(np.mean(sat))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Normalized red-vs-green bias: (meanR - meanG) / meanIntensity in [-1,1]'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) != 3 or image.shape[2] != 3:\n        # grayscale: no red/green bias\n        return 0.0\n    R = np.mean(image[:, :, 0].astype(float))\n    G = np.mean(image[:, :, 1].astype(float))\n    I = np.mean(np.mean(image.astype(float), axis=2)) + 1e-8\n    val = (R - G) / I\n    # clamp to [-1,1] for stability\n    val = max(-1.0, min(1.0, val))\n    return float(val)\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Minimum relative width in the upper third of the object bbox: min_width / max_width (0..1)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    thr = float(np.percentile(gray, 50))\n    mask = gray > thr\n    if not np.any(mask):\n        return 0.0\n    rows = np.any(mask, axis=1)\n    cols = np.any(mask, axis=0)\n    rmin, rmax = int(np.argmax(rows)), len(rows) - int(np.argmax(rows[::-1])) - 1\n    cmin, cmax = int(np.argmax(cols)), len(cols) - int(np.argmax(cols[::-1])) - 1\n    if rmax < rmin or cmax < cmin:\n        return 0.0\n    bbox = mask[rmin:rmax+1, cmin:cmax+1]\n    bh = bbox.shape[0]\n    upper_third = bbox[0:max(1, bh // 3), :]\n    if upper_third.size == 0:\n        return 0.0\n    widths = upper_third.sum(axis=1)\n    max_w = float(widths.max()) if widths.size > 0 else 0.0\n    min_w = float(widths.min()) if widths.size > 0 else 0.0\n    if max_w <= 0:\n        return 0.0\n    return float(min_w / max_w)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Relative mass of upper-left and upper-right (sleeve-like) regions vs upper-center'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 3 or w < 3:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 50)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    upper_h = max(1, h // 3)\n    third_w = max(1, w // 3)\n    left = float(np.count_nonzero(mask[:upper_h, :third_w]))\n    right = float(np.count_nonzero(mask[:upper_h, -third_w:]))\n    center = float(np.count_nonzero(mask[:upper_h, third_w:-third_w]))\n    denom = (center + 1e-8)\n    return float((left + right) / denom)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Normalized vertical centroid (y-coordinate of mass) - low values = top-heavy, high values = bottom-heavy'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    img = gray - gray.min()\n    total = img.sum()\n    if total <= 0:\n        return float(h / 2.0)\n    # compute weighted y centroid\n    ys = np.arange(h).reshape((h, 1))\n    centroid_y = float((img * ys).sum() / total)\n    # normalize to [0,1]\n    return float(centroid_y / (h - 1 + 1e-8))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Fraction of rows that contain any foreground pixel (vertical coverage)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 50)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    rows_with = np.count_nonzero(np.any(mask, axis=1))\n    return float(rows_with / float(h + 1e-8))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Average variation of left/right edge column positions across rows (slope magnitude normalized by height)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.mean(gray) + 0.25 * np.std(gray)\n    thr = max(thr, np.percentile(gray, 50) * 0.5, np.max(gray) * 0.05)\n    mask = gray > thr\n    if not np.any(mask):\n        return 0.0\n    ys, xs = np.where(mask)\n    ymin, ymax = ys.min(), ys.max()\n    xmin, xmax = xs.min(), xs.max()\n    rows = []\n    left_cols = []\n    right_cols = []\n    for r in range(ymin, ymax+1):\n        row = mask[r, xmin:xmax+1]\n        if not np.any(row):\n            continue\n        idx = np.where(row)[0]\n        left_cols.append(float(xmin + idx[0]))\n        right_cols.append(float(xmin + idx[-1]))\n        rows.append(float(r - ymin))\n    if len(rows) < 2:\n        return 0.0\n    # linear fit slope for left and right\n    try:\n        lp = np.polyfit(rows, left_cols, 1)\n        rp = np.polyfit(rows, right_cols, 1)\n        left_slope = abs(lp[0])\n        right_slope = abs(rp[0])\n    except Exception:\n        return 0.0\n    avg_slope = 0.5 * (left_slope + right_slope)\n    h = max(1.0, ymax - ymin + 1)\n    return float(avg_slope / h)\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Fraction of foreground mask mass located in bottom 20% of image rows'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    total = float(np.count_nonzero(mask))\n    if total == 0:\n        return 0.0\n    cut = max(1, int(0.8 * h))\n    bottom_mass = float(np.count_nonzero(mask[cut:, :]))\n    return float(bottom_mass / total)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Mean gradient magnitude in the central torso region normalized by global mean gradient (detects lapels and seams)'\n    import numpy as np\n    h, w = image.shape[:2]\n    gray = np.mean(image, axis=2) if image.ndim == 3 else image.astype(float)\n    # central torso: middle 50% height, center 50% width\n    rh0 = h // 4\n    rh1 = h - rh0\n    cw0 = w // 4\n    cw1 = w - cw0\n    region = gray[rh0:rh1, cw0:cw1]\n    if region.size == 0:\n        return 0.0\n    gy, gx = np.gradient(region)\n    mag = np.sqrt(gy**2 + gx**2)\n    global_gy, global_gx = np.gradient(gray)\n    global_mag = np.sqrt(global_gy**2 + global_gx**2)\n    denom = max(1e-6, np.mean(global_mag))\n    return float(np.mean(mag) / denom)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Ratio of median object width in the bottom quarter to the top quarter (shape tapering indicator)'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    h, w = gray.shape[:2]\n    thresh = (np.mean(gray) + np.min(gray)) / 2.0\n    mask = gray > thresh\n    def median_width(row_indices):\n        widths = []\n        for r in row_indices:\n            cols = np.where(mask[r, :])[0]\n            if cols.size > 0:\n                widths.append(cols[-1] - cols[0] + 1)\n        if len(widths) == 0:\n            return 0.0\n        return float(np.median(widths))\n    top_rows = range(0, max(1, h // 4))\n    bottom_rows = range(max(0, 3 * h // 4), h)\n    top_m = median_width(top_rows)\n    bot_m = median_width(bottom_rows)\n    if top_m <= 0:\n        return float(bot_m)  # fallback absolute bottom width\n    return float(bot_m / top_m)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Normalized variance in the central region (low for uniform textures like many bags); returns variance_ratio'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    cy0, cx0 = h // 4, w // 4\n    cy1, cx1 = 3 * h // 4, 3 * w // 4\n    if cy1 <= cy0 or cx1 <= cx0:\n        return 0.0\n    center = gray[cy0:cy1, cx0:cx1]\n    global_var = np.var(gray)\n    center_var = np.var(center)\n    if global_var <= 1e-9:\n        return float(center_var)\n    return float(center_var / global_var)\n",
    "def feature(image: np.ndarray) -> float:\n    'Normalized position of the first object pixel from top (how high object starts)'\n    import numpy as np\n    if image is None:\n        return 1.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 1.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    ys = np.where(np.any(mask, axis=1))[0]\n    if ys.size == 0:\n        return 1.0\n    first = float(ys[0]) / float(h)\n    return float(np.clip(first, 0.0, 1.0))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Left-right symmetry of the foreground mask (IoU with horizontally flipped mask)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = float(np.median(gray)) if np.any(gray >= 0) else 0.0\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    if not np.any(mask):\n        return 0.0\n    flipped = np.fliplr(mask)\n    inter = np.count_nonzero(mask & flipped)\n    union = np.count_nonzero(mask | flipped)\n    if union == 0:\n        return 0.0\n    return float(inter / union)\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Average number of foreground/background transitions per column (vertical segmentation)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 2 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 50)\n    mask = ((gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)).astype(np.uint8)\n    # transitions along each column\n    diffs = np.abs(np.diff(mask, axis=0))\n    transitions_per_col = np.sum(diffs, axis=0).astype(float)\n    return float(np.mean(transitions_per_col))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Fraction of edge pixels whose gradient is more vertical than horizontal (orientation count)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 2 or w < 2:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    gy, gx = np.gradient(gray.astype(float))\n    grad_mag = np.sqrt(gx * gx + gy * gy)\n    strong = grad_mag > (np.percentile(grad_mag, 60) if np.any(grad_mag) else 0.0)\n    if not np.any(strong):\n        return 0.0\n    vert_dom = np.abs(gx) > np.abs(gy)\n    count = np.count_nonzero(strong & vert_dom)\n    total = np.count_nonzero(strong)\n    return float(count / (total + 1e-8))\n",
    "def feature(image: np.ndarray) -> float:\n    'Mean gradient magnitude of the gray image (texture/edge strength)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 2 or w < 2:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    gy, gx = np.gradient(gray.astype(float))\n    grad = np.sqrt(gx * gx + gy * gy)\n    mean_grad = float(np.mean(grad))\n    return float(mean_grad)\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Relative sleeve/side extension: density in left+right quarters of upper half vs central upper half'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 4 or w < 4:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    top = mask[:max(1, h // 2), :]\n    if top.size == 0:\n        return 0.0\n    left = top[:, :max(1, w // 4)]\n    center = top[:, max(1, w // 4):max(1, (3 * w) // 4)]\n    right = top[:, max(1, (3 * w) // 4):]\n    left_density = float(np.mean(left.astype(float)))\n    right_density = float(np.mean(right.astype(float)))\n    center_density = float(np.mean(center.astype(float)))\n    score = (left_density + right_density) / (center_density + 1e-8)\n    return float(score)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Average angle (radians) of the left and right upper-quarter centroids relative to top-center (captures sleeve tilt)'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    top_h = max(1, h // 3)\n    thr = float(np.percentile(gray, 60))\n    mask = (gray[:top_h, :] > thr)\n    if not mask.any():\n        return 0.0\n    left_mask = mask[:, :w // 2]\n    right_mask = mask[:, w // 2:]\n    def centroid(m, x_offset=0):\n        ys, xs = np.where(m)\n        if ys.size == 0:\n            return None\n        return (ys.mean(), xs.mean() + x_offset)\n    lc = centroid(left_mask, x_offset=0)\n    rc = centroid(right_mask, x_offset=w // 2)\n    top_center = (0.0, w / 2.0)\n    angles = []\n    for c in (lc, rc):\n        if c is None:\n            continue\n        dy = c[0] - top_center[0]\n        dx = c[1] - top_center[1]\n        angles.append(float(np.arctan2(dy, dx)))\n    if len(angles) == 0:\n        return 0.0\n    return float(np.mean(np.abs(angles)))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Ratio of top-half edge energy to bottom-half edge energy (helps separate tops vs bottoms)'\n    import numpy as np\n    import numpy as _np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 2 or w < 2:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = _np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    gy, gx = _np.gradient(gray)\n    grad_mag = _np.sqrt(gx * gx + gy * gy)\n    mid = h // 2\n    top_energy = float(_np.sum(grad_mag[:mid, :]))\n    bottom_energy = float(_np.sum(grad_mag[mid:, :]))\n    if bottom_energy <= 0:\n        return float(top_energy / (bottom_energy + 1e-8))\n    return float(top_energy / bottom_energy)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Longest vertical zero-run fraction in the central column of the object bounding box (neck/handle gap detector)'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    thr = np.mean(gray) + 0.45 * np.std(gray)\n    mask = gray > thr\n    if mask.sum() == 0:\n        mask = gray > np.percentile(gray.flatten(), 92)\n    if mask.sum() == 0:\n        if gray.max() == 0:\n            return 0.0\n        mask = gray > (0.08 * gray.max())\n    ys, xs = np.where(mask)\n    if ys.size == 0:\n        return 0.0\n    y0, y1 = int(ys.min()), int(ys.max()) + 1\n    x0, x1 = int(xs.min()), int(xs.max()) + 1\n    cx = (x0 + x1) // 2\n    col = mask[y0:y1, cx]\n    # find longest run of zeros in col\n    max_run = 0\n    cur = 0\n    for v in col:\n        if not v:\n            cur += 1\n            if cur > max_run:\n                max_run = cur\n        else:\n            cur = 0\n    return float(max_run / max(1, (y1 - y0)))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Aspect ratio (width / height) of the mask bounding box (1.0 if undefined)'\n    import numpy as np\n    if image is None:\n        return 1.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 1.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    ys, xs = np.where(mask)\n    if ys.size == 0:\n        return 1.0\n    miny, maxy = int(np.min(ys)), int(np.max(ys))\n    minx, maxx = int(np.min(xs)), int(np.max(xs))\n    bbox_h = maxy - miny + 1\n    bbox_w = maxx - minx + 1\n    if bbox_h <= 0:\n        return 1.0\n    return float(bbox_w / float(bbox_h + 1e-8))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Foreground bounding-box aspect ratio (height / width) estimated from thresholded mask'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    # grayscale\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    ys, xs = np.where(mask)\n    if ys.size == 0:\n        return 0.0\n    bbox_h = float(ys.max() - ys.min() + 1)\n    bbox_w = float(xs.max() - xs.min() + 1)\n    if bbox_w < 1e-8:\n        return 0.0\n    return float(bbox_h / bbox_w)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Top-bottom similarity: normalized correlation between top half and vertically flipped bottom half'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 2 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    top = gray[:h // 2, :]\n    bottom = gray[h - (h // 2):, :]\n    if top.size == 0 or bottom.size == 0:\n        return 0.0\n    # align heights\n    minh = min(top.shape[0], bottom.shape[0])\n    top = top[:minh, :].ravel()\n    bottom = np.flipud(bottom[:minh, :]) .ravel()\n    if top.size == 0 or bottom.size == 0:\n        return 0.0\n    tmean = top.mean()\n    bmean = bottom.mean()\n    tc = top - tmean\n    bc = bottom - bmean\n    denom = np.sqrt(np.sum(tc * tc) * np.sum(bc * bc)) + 1e-8\n    corr = np.sum(tc * bc) / denom\n    return float(abs(corr))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Mean vertical-edge strength in a narrow central vertical strip normalized by global edge strength (captures buttons/seams)'\n    import numpy as np\n    gray = np.mean(image, axis=2) if len(image.shape) == 3 else image.astype(float)\n    h, w = gray.shape[:2]\n    gy, gx = np.gradient(gray.astype(float))\n    grad_mag = np.sqrt(gx**2 + gy**2)\n    center_w = max(1, w // 8)\n    cstart = max(0, w//2 - center_w//2)\n    cend = min(w, cstart + center_w)\n    center_vert_edges = np.abs(gx[:, cstart:cend])\n    global_edges = np.abs(gx)\n    cen_mean = float(np.mean(center_vert_edges)) if center_vert_edges.size else 0.0\n    glob_mean = float(np.mean(global_edges)) if global_edges.size else 1e-6\n    return float(cen_mean / (glob_mean + 1e-9))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Maximum vertical continuous span of mask in any column normalized by image height'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 60)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    if not np.any(mask):\n        return 0.0\n    max_span = 0\n    for c in range(w):\n        col = mask[:, c].astype(int)\n        if np.all(col == 0):\n            continue\n        padded = np.concatenate([[0], col, [0]])\n        diff = np.diff(padded)\n        starts = np.where(diff == 1)[0]\n        ends = np.where(diff == -1)[0]\n        if starts.size and ends.size:\n            spans = ends - starts\n            local_max = int(np.max(spans))\n            if local_max > max_span:\n                max_span = local_max\n    return float(max_span) / float(max(1, h))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Relative vertical edge energy concentrated in the central vertical strip (higher if placket/seam present)'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    try:\n        thresh = float(np.percentile(gray, 70))\n    except Exception:\n        thresh = float(np.mean(gray))\n    fg = gray < thresh\n    rows = np.any(fg, axis=1)\n    cols = np.any(fg, axis=0)\n    if not rows.any() or not cols.any():\n        return 0.0\n    r0, r1 = np.where(rows)[0][0], np.where(rows)[0][-1] + 1\n    c0, c1 = np.where(cols)[0][0], np.where(cols)[0][-1] + 1\n    crop = gray[r0:r1, c0:c1].astype(float)\n    ch, cw = crop.shape\n    # horizontal derivative approx\n    gx = np.abs(np.diff(crop, axis=1))\n    gx = np.pad(gx, ((0,0),(0,1)), mode='constant')\n    band = max(1, cw // 10)\n    center = cw // 2\n    left_b = max(0, center - band)\n    right_b = min(cw, center + band)\n    center_energy = np.mean(gx[:, left_b:right_b]) if gx[:, left_b:right_b].size > 0 else 0.0\n    total_energy = np.mean(gx) + 1e-8\n    return float(center_energy / total_energy)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Maximum vertical gap proportion in the central column of the object bbox (captures open mid sections)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    mu, sd = float(np.mean(gray)), float(np.std(gray))\n    thresh = mu + 0.25 * sd if sd > 1e-6 else mu * 0.5\n    bw = (gray > thresh).astype(np.uint8)\n    ys, xs = np.where(bw)\n    if ys.size == 0:\n        return 0.0\n    r0, r1 = ys.min(), ys.max()\n    c0, c1 = xs.min(), xs.max()\n    w = c1 - c0 + 1\n    midc = c0 + w // 2\n    col = bw[r0:r1+1, midc]\n    # find largest zero run within first and last one\n    ones = np.where(col)[0]\n    if ones.size == 0:\n        return 1.0\n    start, end = ones[0], ones[-1]\n    segment = col[start:end+1]\n    # lengths of zero runs\n    padded = np.concatenate(([1], segment, [1]))\n    zeros_runs = np.where((padded[:-1] == 1) & (padded[1:] == 0))[0]  # not used directly\n    # compute zero run lengths\n    diffs = np.diff(padded)\n    # easier: iterate\n    max_zero = 0\n    cur = 0\n    for v in segment:\n        if v == 0:\n            cur += 1\n            if cur > max_zero:\n                max_zero = cur\n        else:\n            cur = 0\n    height = len(segment)\n    if height == 0:\n        return 0.0\n    return float(max_zero) / float(height)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Bounding-box aspect ratio of dominant mask (width / height), returns 0 for no mask'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 50)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    ys, xs = np.where(mask)\n    if ys.size == 0:\n        return 0.0\n    y0, y1 = int(ys.min()), int(ys.max())\n    x0, x1 = int(xs.min()), int(xs.max())\n    height = max(1, y1 - y0 + 1)\n    width = max(1, x1 - x0 + 1)\n    ratio = float(width) / float(height)\n    return float(ratio)\n",
    "def feature(image: np.ndarray) -> float:\n    'Relative side protrusion at mid-height: width at mid slice divided by max(width at top, width at bottom)'\n    import numpy as np\n    gray = np.mean(image, axis=2) if len(image.shape) == 3 else image.astype(float)\n    h, w = gray.shape[:2]\n    if h < 3 or np.all(gray == 0):\n        return 0.0\n    th = np.percentile(gray, 70)\n    mask = gray > th\n    def slice_width(r0, r1):\n        slice_mask = mask[r0:r1, :]\n        if not slice_mask.any():\n            return 0\n        cols = np.where(slice_mask.any(axis=0))[0]\n        return cols.max() - cols.min() + 1 if cols.size else 0\n    top_w = slice_width(0, h//4)\n    mid_w = slice_width(h//3, 2*h//3)\n    bot_w = slice_width(3*h//4, h)\n    denom = max(top_w, bot_w, 1)\n    return float(mid_w / denom)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Mean absolute horizontal gradient in the bottom quarter of the object bbox normalized by mean absolute gradient in the bbox (higher when there are strong edges near the sole)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if np.nanmax(gray) == np.nanmin(gray):\n        return 0.0\n    thresh = np.mean(gray) * 0.7 + np.min(gray) * 0.3\n    mask = gray > thresh\n    pts = np.argwhere(mask)\n    if pts.size == 0:\n        return 0.0\n    ymin, xmin = pts.min(axis=0)\n    ymax, xmax = pts.max(axis=0)\n    sub = gray[ymin:ymax + 1, xmin:xmax + 1]\n    if sub.size == 0:\n        return 0.0\n    # horizontal gradient\n    gx = np.abs(np.gradient(sub, axis=1))\n    mean_all = float(np.mean(gx)) + 1e-9\n    bottom_rows = max(1, gx.shape[0] // 4)\n    mean_bottom = float(np.mean(gx[-bottom_rows:, :]))\n    return float(mean_bottom) / float(mean_all)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Normalized standard deviation of object width per row (rows with object only)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    h, w = gray.shape\n    m = gray.max()\n    if m <= 0:\n        return 0.0\n    mask = gray > (m * 0.1)\n    widths = []\n    for r in range(h):\n        row = mask[r, :]\n        if row.any():\n            cols = np.where(row)[0]\n            widths.append(float(cols.max() - cols.min() + 1))\n    if len(widths) <= 1:\n        return 0.0\n    widths = np.array(widths)\n    mean_w = widths.mean()\n    if mean_w <= 0:\n        return 0.0\n    return float(widths.std() / mean_w)\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Fraction of background in a small top-center patch (proxy for neck/opening)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 4 or w < 4:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    # top center box\n    box_h = max(1, h // 8)\n    box_w = max(1, w // 6)\n    r0 = 0\n    r1 = min(h, box_h)\n    c0 = max(0, (w // 2) - box_w // 2)\n    c1 = min(w, c0 + box_w)\n    patch = mask[r0:r1, c0:c1]\n    if patch.size == 0:\n        return 0.0\n    # fraction of background pixels in the patch (True=foreground)\n    bg_frac = 1.0 - (float(np.count_nonzero(patch)) / float(patch.size))\n    return float(bg_frac)\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Normalized vertical centroid of the object (0 top, 1 bottom) - dresses often have lower centroids'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    h, w = gray.shape[:2]\n    maxv = float(np.max(gray)) if np.size(gray) else 0.0\n    if maxv <= 0:\n        return 0.0\n    thresh = maxv * 0.10\n    mask = gray > thresh\n    ys, xs = np.where(mask)\n    if ys.size == 0:\n        return 0.0\n    centroid_row = np.mean(ys)\n    if h <= 1:\n        return 0.0\n    return float(centroid_row / float(h - 1))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Hollowness: fraction of empty pixels inside the mask bounding box (1.0 = empty box)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 50)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    ys, xs = np.where(mask)\n    if ys.size == 0:\n        return 0.0\n    ymin, ymax = int(np.min(ys)), int(np.max(ys))\n    xmin, xmax = int(np.min(xs)), int(np.max(xs))\n    box = mask[ymin:ymax+1, xmin:xmax+1]\n    if box.size == 0:\n        return 0.0\n    empty = float(box.size - np.count_nonzero(box))\n    return float(empty / (box.size + 1e-8))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Mask compactness: fraction of bounding-box area occupied by foreground (0..1)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 60)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    if not np.any(mask):\n        return 0.0\n    ys, xs = np.where(mask)\n    miny, maxy = ys.min(), ys.max()\n    minx, maxx = xs.min(), xs.max()\n    bbox_area = float((maxy - miny + 1) * (maxx - minx + 1))\n    mask_area = float(np.count_nonzero(mask))\n    if bbox_area <= 0:\n        return 0.0\n    compactness = mask_area / (bbox_area + 1e-8)\n    return float(max(0.0, min(1.0, compactness)))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Absolute horizontal centroid offset from image center (0=centered, 1=edge)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    xs = np.where(mask)[1]\n    if xs.size == 0:\n        return 0.0\n    x_cent = float(np.mean(xs))\n    center = (w - 1) / 2.0\n    return float(abs(x_cent - center) / (max(1.0, center) + 1e-8))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Edge density inside the central box (fraction of pixels with strong gradient)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 3 or w < 3:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    gy, gx = np.gradient(gray)\n    mag = np.sqrt(gx * gx + gy * gy)\n    if not np.any(mag):\n        return 0.0\n    # center box (middle 50% area)\n    r0 = h // 4\n    r1 = h - r0\n    c0 = w // 4\n    c1 = w - c0\n    center_mag = mag[r0:r1, c0:c1]\n    if center_mag.size == 0:\n        return 0.0\n    thr = np.percentile(center_mag, 70)\n    strong = float(np.count_nonzero(center_mag > thr))\n    return float(strong / (center_mag.size + 1e-8))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Left-right symmetry score of object pixels (1.0 = perfectly symmetric)'\n    import numpy as np\n    h, w = image.shape[:2]\n    img = image.astype(float)\n    gray = (img - img.min()) / (img.max() - img.min() + 1e-8)\n    mask = gray > 0.12\n    if not np.any(mask):\n        return 0.0\n    # compare object intensities mirrored\n    left = gray[:, :w // 2]\n    right = gray[:, (w - w // 2):][:, ::-1]  # mirrored right to align with left\n    # pad to same shape\n    min_c = min(left.shape[1], right.shape[1])\n    left = left[:, :min_c]\n    right = right[:, :min_c]\n    diff = np.abs(left - right)\n    # weight by object presence to avoid background dominating\n    mask_left = mask[:, :left.shape[1]]\n    mask_right = mask[:, (w - right.shape[1]):][:, ::-1]\n    obj_mask = (mask_left | mask_right)\n    if not np.any(obj_mask):\n        return 1.0\n    score = 1.0 - (np.sum(diff * obj_mask) / (np.sum(obj_mask) + 1e-8))\n    return float(np.clip(score, 0.0, 1.0))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Bounding-box aspect ratio of the detected foreground (height/width)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    # grayscale\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    ys, xs = np.where(mask)\n    if ys.size == 0:\n        return 0.0\n    miny, maxy = ys.min(), ys.max()\n    minx, maxx = xs.min(), xs.max()\n    bb_h = maxy - miny + 1\n    bb_w = maxx - minx + 1\n    if bb_w <= 0:\n        return 0.0\n    return float(bb_h / (bb_w + 1e-8))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Center texture minus corner texture (std in center region minus mean corner std) normalized'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 4 or w < 4:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    ch0, cw0 = h // 4, w // 4\n    center = gray[ch0:3*ch0, cw0:3*cw0]\n    if center.size == 0:\n        return 0.0\n    center_std = float(np.std(center))\n    # four corner patches\n    patch_h, patch_w = max(1, h // 8), max(1, w // 8)\n    corners = []\n    corners.append(gray[0:patch_h, 0:patch_w])\n    corners.append(gray[0:patch_h, -patch_w:])\n    corners.append(gray[-patch_h:, 0:patch_w])\n    corners.append(gray[-patch_h:, -patch_w:])\n    corner_stds = [float(np.std(p)) if p.size else 0.0 for p in corners]\n    mean_corner_std = float(np.mean(corner_stds))\n    denom = float(np.std(gray) + 1e-8)\n    return float((center_std - mean_corner_std) / denom)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Vertical center-of-mass normalized to image height (0 = top, 1 = bottom)'\n    import numpy as np\n    gray = np.mean(image, axis=2) if len(image.shape) == 3 else image.astype(float)\n    h, w = gray.shape[:2]\n    thresh = np.percentile(gray, 60)\n    mask = gray > thresh\n    if mask.sum() == 0:\n        mask = gray > np.mean(gray)\n    ys, xs = np.where(mask)\n    if ys.size == 0:\n        return 0.5\n    com_y = np.mean(ys)\n    return float(com_y / (h - 1))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Fractional occupancy at the central column of the bottom quarter (low for trousers with a central leg gap)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    if gray.size == 0:\n        return 0.0\n    lo, hi = float(np.min(gray)), float(np.max(gray))\n    if hi == lo:\n        return 0.0\n    thr = (lo + hi) / 2.0\n    mask = gray > thr\n    ys, xs = np.where(mask)\n    if ys.size == 0:\n        return 0.0\n    top, bottom = ys.min(), ys.max() + 1\n    left, right = xs.min(), xs.max() + 1\n    h = bottom - top\n    if h <= 1:\n        return 0.0\n    qh = max(1, h // 4)\n    bottom_region = mask[bottom - qh: bottom, left:right]\n    if bottom_region.size == 0:\n        return 0.0\n    # column occupancy counts\n    col_counts = bottom_region.sum(axis=0).astype(float)\n    if col_counts.size == 0:\n        return 0.0\n    center_idx = col_counts.size // 2\n    center_val = float(col_counts[center_idx])\n    max_val = float(col_counts.max()) if col_counts.max() > 0 else 1.0\n    # normalized occupancy at center (0..1). For central gap, this will be small.\n    return float(center_val / max_val)\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Estimated number of enclosed background cavities (holes) inside the object bounding box normalized by object area'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape\n    if h == 0 or w == 0:\n        return 0.0\n    thr = np.mean(gray) + 0.25 * np.std(gray)\n    mask = gray > thr\n    if not np.any(mask):\n        mask = gray > np.percentile(gray, 80)\n    if not np.any(mask):\n        return 0.0\n    rows = np.where(np.any(mask, axis=1))[0]\n    cols = np.where(np.any(mask, axis=0))[0]\n    if rows.size == 0 or cols.size == 0:\n        return 0.0\n    rmin, rmax = rows[0], rows[-1]\n    cmin, cmax = cols[0], cols[-1]\n    sub = mask[rmin:rmax + 1, cmin:cmax + 1]\n    ih, iw = sub.shape\n    if ih == 0 or iw == 0:\n        return 0.0\n    # Inverted subregion: background inside bbox\n    inv = ~sub\n    visited = np.zeros_like(inv, dtype=bool)\n    holes = 0\n    # 4-connected neighbors\n    for i in range(ih):\n        for j in range(iw):\n            if inv[i, j] and not visited[i, j]:\n                # BFS/DFS component\n                stack = [(i, j)]\n                visited[i, j] = True\n                touches_border = False\n                while stack:\n                    y, x = stack.pop()\n                    if y == 0 or y == ih - 1 or x == 0 or x == iw - 1:\n                        touches_border = True\n                    for dy, dx in ((1, 0), (-1, 0), (0, 1), (0, -1)):\n                        ny, nx = y + dy, x + dx\n                        if 0 <= ny < ih and 0 <= nx < iw and inv[ny, nx] and not visited[ny, nx]:\n                            visited[ny, nx] = True\n                            stack.append((ny, nx))\n                if not touches_border:\n                    holes += 1\n    area = float(np.count_nonzero(sub))\n    return float(holes) / (area + 1e-9)\n",
    "def feature(image: np.ndarray) -> float:\n    'Shape compactness: mask area divided by squared perimeter (higher => more compact)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    area = float(np.count_nonzero(mask))\n    if area == 0.0:\n        return 0.0\n    m = mask.astype(np.int32)\n    dx = np.abs(np.diff(m, axis=1))\n    dy = np.abs(np.diff(m, axis=0))\n    perimeter = float(np.sum(dx) + np.sum(dy))\n    compact = area / (perimeter * perimeter + 1e-8)\n    return float(compact)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Fraction of mask pixels that touch the image border area (margin fraction)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    if not np.any(mask):\n        return 0.0\n    m = max(1, int(0.03 * min(h, w)))\n    border_mask = np.zeros_like(mask, dtype=bool)\n    border_mask[:m, :] = True\n    border_mask[-m:, :] = True\n    border_mask[:, :m] = True\n    border_mask[:, -m:] = True\n    touch = np.count_nonzero(mask & border_mask)\n    total = np.count_nonzero(mask)\n    return float(touch / (total + 1e-8))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Average longest horizontal run of mask pixels per row normalized by image width'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h <= 0 or w <= 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = ((gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)).astype(np.uint8)\n    longest = []\n    for y in range(h):\n        row = mask[y, :]\n        max_run = 0\n        run = 0\n        for v in row:\n            if v:\n                run += 1\n                if run > max_run:\n                    max_run = run\n            else:\n                run = 0\n        longest.append(max_run)\n    if len(longest) == 0:\n        return 0.0\n    mean_long = float(np.mean(longest))\n    return float(mean_long / (w + 1e-8))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Bounding-box aspect ratio of the foreground mask (width / height)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 50)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    coords = np.argwhere(mask)\n    if coords.size == 0:\n        return 0.0\n    ys, xs = coords[:, 0], coords[:, 1]\n    bbox_h = float(max(1, ys.max() - ys.min() + 1))\n    bbox_w = float(max(1, xs.max() - xs.min() + 1))\n    return float(bbox_w / (bbox_h + 1e-8))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Mean gradient magnitude around object boundary (edge sharpness)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 2 or w < 2:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    if not np.any(mask):\n        return 0.0\n    # approximate boundary as mask pixels with any 4-neighbor background\n    pad = np.pad(mask.astype(np.uint8), ((1, 1), (1, 1)), mode='constant', constant_values=0)\n    center = pad[1:-1, 1:-1].astype(bool)\n    up = pad[:-2, 1:-1].astype(bool)\n    down = pad[2:, 1:-1].astype(bool)\n    left = pad[1:-1, :-2].astype(bool)\n    right = pad[1:-1, 2:].astype(bool)\n    neighbor_sum = up + down + left + right\n    boundary = center & (neighbor_sum < 4)\n    if not np.any(boundary):\n        # fallback: use mask border region via dilation of boundary\n        boundary = mask\n    gy, gx = np.gradient(gray)\n    grad_mag = np.sqrt(gx * gx + gy * gy)\n    vals = grad_mag[boundary]\n    if vals.size == 0:\n        return 0.0\n    # normalize by mean intensity to be scale-invariant\n    denom = (np.mean(gray) + 1e-8)\n    return float(np.mean(vals) / denom)\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Aspect ratio (width / height) of the image to capture tall vs wide items'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0:\n        return 0.0\n    return float(w) / float(h)\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Vertical symmetry score (1.0 = perfectly symmetric, 0.0 = very asymmetric)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w < 2:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = ((gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)).astype(float)\n    mid = w // 2\n    left = mask[:, :mid]\n    right = mask[:, w - mid:] if mid > 0 else mask[:, :]\n    # flip right horizontally to compare\n    right_flipped = np.fliplr(right) if right.size != 0 else right\n    # trim to same width\n    minw = min(left.shape[1] if left.size else 0, right_flipped.shape[1] if right_flipped.size else 0)\n    if minw == 0:\n        return 0.0\n    left_crop = left[:, :minw]\n    right_crop = right_flipped[:, :minw]\n    diff = np.abs(left_crop - right_crop)\n    mean_diff = float(np.mean(diff))\n    # normalize to [0,1], invert so 1 = symmetric\n    score = 1.0 - (mean_diff / (1.0 + 1e-8))\n    return float(max(0.0, min(1.0, score)))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Slope of the left silhouette in the lower half (rows vs left-edge x), negative -> edge moves left as go down; magnitude indicates flare'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    maxv = gray.max()\n    if maxv == 0:\n        return 0.0\n    mask = gray > (maxv * 0.1)\n    rows = range(h//2, h)\n    ys = []\n    xs = []\n    for r in rows:\n        row_idx = np.where(mask[r, :])[0]\n        if row_idx.size:\n            xs.append(row_idx.min())\n            ys.append(r)\n    if len(xs) < 2:\n        return 0.0\n    # fit line x = a*y + b\n    a, b = np.polyfit(ys, xs, 1)\n    # normalize slope by image height to be scale-invariant\n    slope_norm = float(a * h / float(w))\n    return float(slope_norm)\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Normalized horizontal center of mass of the foreground mask (0=left, 1=right)'\n    import numpy as np\n    if image is None:\n        return 0.5\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.5\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    ys, xs = np.where(mask)\n    if xs.size == 0:\n        return 0.5\n    center_x = np.mean(xs)\n    return float(center_x / max(1.0, (w - 1)))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Mean number of contiguous mask segments per row in the lower 40% (detects two-leg gap)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = ((gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)).astype(np.uint8)\n    start_row = int(h * 0.6)\n    rows = mask[start_row:, :]\n    if rows.size == 0:\n        return 0.0\n    seg_counts = []\n    for r in range(rows.shape[0]):\n        row = rows[r, :]\n        # count transitions from 0->1\n        prev = 0\n        seg = 0\n        for v in row:\n            if v and not prev:\n                seg += 1\n            prev = v\n        seg_counts.append(seg)\n    if len(seg_counts) == 0:\n        return 0.0\n    return float(np.mean(seg_counts))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Fraction of object pixels located in the bottom 20% of its bounding box (hem emphasis)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.copy()\n    mx = float(np.max(gray))\n    if mx <= 0:\n        return 0.0\n    mask = gray > (mx * 0.1)\n    if not np.any(mask):\n        return 0.0\n    rows = np.any(mask, axis=1)\n    cols = np.any(mask, axis=0)\n    r_idx = np.where(rows)[0]\n    c_idx = np.where(cols)[0]\n    if r_idx.size == 0 or c_idx.size == 0:\n        return 0.0\n    r0, r1 = r_idx[0], r_idx[-1] + 1\n    c0, c1 = c_idx[0], c_idx[-1] + 1\n    bbox = mask[r0:r1, c0:c1]\n    H = bbox.shape[0]\n    if H == 0:\n        return 0.0\n    bottom_rows = max(1, H // 5)\n    bottom_region = bbox[-bottom_rows:, :]\n    total_pixels = float(np.count_nonzero(bbox))\n    if total_pixels == 0:\n        return 0.0\n    bottom_pixels = float(np.count_nonzero(bottom_region))\n    return float(bottom_pixels / total_pixels)\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Entropy of edge orientation histogram (0..1), higher = more varied edge directions'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 2 or w < 2:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    gy, gx = np.gradient(gray)\n    mag = np.sqrt(gx * gx + gy * gy)\n    if not np.any(mag):\n        return 0.0\n    # focus on strong edges\n    thr = np.percentile(mag, 60)\n    mask = mag > thr\n    if not np.any(mask):\n        return 0.0\n    angles = np.arctan2(gy[mask], gx[mask])  # range -pi..pi\n    bins = 8\n    hist, _ = np.histogram(angles, bins=bins, range=(-np.pi, np.pi))\n    p = hist.astype(float) / (np.sum(hist) + 1e-8)\n    p_nonzero = p[p > 0]\n    ent = -np.sum(p_nonzero * np.log(p_nonzero))\n    # normalize by log(bins)\n    ent_norm = ent / (np.log(max(2, bins)) + 1e-12)\n    return float(max(0.0, min(1.0, ent_norm)))\n",
    "def feature(image: np.ndarray) -> float:\n    'Lower-edge roughness: perimeter-like transitions in mask normalized by object area (measures hem irregularity)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    h, w = gray.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    mean_val = float(np.mean(gray))\n    mask = (gray > mean_val) if np.sum(gray > mean_val) >= np.sum(gray < mean_val) else (gray < mean_val)\n    area = float(np.sum(mask))\n    if area <= 0:\n        return 0.0\n    # perimeter approximated by sum of transitions in both axes\n    vert_trans = np.sum(np.abs(np.diff(mask.astype(np.int32), axis=0)))\n    hor_trans = np.sum(np.abs(np.diff(mask.astype(np.int32), axis=1)))\n    perimeter = float(vert_trans + hor_trans)\n    # normalize by area\n    return float(perimeter / max(1.0, area))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Top-center opening fraction: fraction of unmasked pixels within top 10% center columns (neck/gap indicator)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 50)\n    mask = ((gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)).astype(np.uint8)\n    top_h = max(1, int(h * 0.10))\n    center_w = max(1, int(w * 0.30))\n    cx0 = max(0, (w - center_w) // 2)\n    cx1 = min(w, cx0 + center_w)\n    top_center = mask[:top_h, cx0:cx1]\n    total = float(top_center.size)\n    if total <= 0.0:\n        return 0.0\n    unmasked = float(np.count_nonzero(top_center == 0))\n    result = unmasked / (total + 1e-8)\n    return float(result)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Number of contiguous mask segments in the central column strip (captures separated parts)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    c0 = max(0, w // 2 - max(1, w // 20))\n    c1 = min(w, w // 2 + max(1, w // 20))\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    col = np.any(mask[:, c0:c1], axis=1).astype(np.uint8)\n    if col.size == 0:\n        return 0.0\n    # count rising edges (0->1) to get number of segments\n    diffs = np.diff(np.concatenate(([0], col, [0])))\n    segments = np.sum(diffs == 1)\n    return float(segments)\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Density of strong edges in the bottom 20% of the image (useful for shoe/boot detection)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 3 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    gy, gx = np.gradient(gray.astype(float))\n    grad = np.sqrt(gx * gx + gy * gy)\n    thresh = np.percentile(grad, 70) if np.any(grad) else 0.0\n    strong = grad > thresh\n    bottom_h = max(1, h * 20 // 100)\n    bottom_region = strong[-bottom_h:, :]\n    density = float(np.count_nonzero(bottom_region)) / float(bottom_region.size + 1e-8)\n    return float(density)\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Aspect ratio (width / height) of the foreground bounding box'\n    import numpy as np\n    if image is None:\n        return 1.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 1.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.mean(gray) if np.any(gray >= 0) else 0.0\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    ys, xs = np.where(mask)\n    if xs.size == 0 or ys.size == 0:\n        return 1.0\n    xmin, xmax = int(np.min(xs)), int(np.max(xs))\n    ymin, ymax = int(np.min(ys)), int(np.max(ys))\n    bw = float(xmax - xmin + 1)\n    bh = float(ymax - ymin + 1)\n    if bh <= 1e-8:\n        return float(bw)\n    return float(bw / bh)\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Hole area fraction inside the foreground bounding box (0 = no holes)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 50)\n    mask = ((gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)).astype(bool)\n    coords = np.argwhere(mask)\n    if coords.size == 0:\n        return 0.0\n    ys, xs = coords[:, 0], coords[:, 1]\n    miny, maxy = int(ys.min()), int(ys.max())\n    minx, maxx = int(xs.min()), int(xs.max())\n    # bounding box region\n    sub = mask[miny:maxy+1, minx:maxx+1]\n    bh, bw = sub.shape\n    bbox_area = float(bh * bw)\n    if bbox_area <= 0:\n        return 0.0\n    # flood-fill background from bbox borders to identify external background\n    bg = ~sub\n    visited = np.zeros_like(bg, dtype=bool)\n    stack = []\n    # add border background positions\n    for i in range(bw):\n        if bg[0, i]:\n            stack.append((0, i))\n            visited[0, i] = True\n        if bg[bh-1, i]:\n            stack.append((bh-1, i))\n            visited[bh-1, i] = True\n    for j in range(bh):\n        if bg[j, 0] and not visited[j, 0]:\n            stack.append((j, 0)); visited[j, 0] = True\n        if bg[j, bw-1] and not visited[j, bw-1]:\n            stack.append((j, bw-1)); visited[j, bw-1] = True\n    while stack:\n        y, x = stack.pop()\n        for ny, nx in ((y-1,x),(y+1,x),(y,x-1),(y,x+1)):\n            if 0 <= ny < bh and 0 <= nx < bw and bg[ny, nx] and not visited[ny, nx]:\n                visited[ny, nx] = True\n                stack.append((ny, nx))\n    external_bg = np.count_nonzero(visited)\n    total_bg = np.count_nonzero(bg)\n    hole_pixels = total_bg - external_bg\n    return float(hole_pixels / (bbox_area + 1e-8))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Mask height normalized by image height (tallness of the item)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    ys, xs = np.where(mask)\n    if ys.size == 0:\n        return 0.0\n    mask_height = float(np.max(ys) - np.min(ys) + 1)\n    return float(mask_height / (h + 1e-8))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Vertical centroid of the foreground mask (0=top, 1=bottom)'\n    import numpy as np\n    if image is None:\n        return 0.5\n    h, w = image.shape[:2]\n    if h == 0:\n        return 0.5\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 50)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    ys, xs = np.where(mask)\n    if ys.size == 0:\n        return 0.5\n    centroid_y = float(np.mean(ys)) / float(h)\n    return float(np.clip(centroid_y, 0.0, 1.0))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Waist concavity measure: ratio of mid-width to average of top and bottom widths (<<1 means narrow waist)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.mean(gray) + 0.25 * np.std(gray)\n    thr = max(thr, np.percentile(gray, 50) * 0.5, np.max(gray) * 0.05)\n    mask = gray > thr\n    if not np.any(mask):\n        return 1.0\n    ys, xs = np.where(mask)\n    ymin, ymax = ys.min(), ys.max()\n    xmin, xmax = xs.min(), xs.max()\n    bbox_h = max(1, ymax - ymin + 1)\n    def width_at_frac(f):\n        r = ymin + int(f * (bbox_h - 1))\n        row = mask[r, xmin:xmax+1]\n        if not np.any(row):\n            return 0.0\n        idx = np.where(row)[0]\n        return float(idx[-1] - idx[0] + 1)\n    w_top = width_at_frac(0.1)\n    w_mid = width_at_frac(0.5)\n    w_bot = width_at_frac(0.9)\n    denom = max(1e-6, 0.5 * (w_top + w_bot))\n    return float(w_mid / denom)\n",
    "def feature(image: np.ndarray) -> float:\n    'Normalized horizontal offset of mask centroid (0=center, 1=far edge)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 50)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    ys, xs = np.where(mask)\n    if xs.size == 0:\n        return 0.0\n    cx = float(np.mean(xs))\n    center = float(w - 1) / 2.0\n    dist = abs(cx - center)\n    return float(dist / (center + 1e-8))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Ratio of object mass in top side strips vs top center region (short-sleeve vs long-sleeve indicator)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    thresh = (float(np.nanmax(gray)) + float(np.nanmin(gray))) / 2.0\n    mask = gray > thresh\n    top_h = max(1, h // 4)\n    top_region = mask[:top_h, :]\n    left_strip = top_region[:, :max(1, w // 4)]\n    right_strip = top_region[:, -max(1, w // 4):]\n    center_strip = top_region[:, max(1, w // 4):-max(1, w // 4)] if w > 2*(w//4) else top_region\n    side_mass = float(np.count_nonzero(left_strip) + np.count_nonzero(right_strip))\n    center_mass = float(np.count_nonzero(center_strip))\n    denom = max(1.0, center_mass)\n    return float(side_mass / denom)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Fraction of empty (background) pixels in the top 30% of the object bounding box (boots often fill top area)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    mn, mx = float(np.min(gray)), float(np.max(gray))\n    if mx - mn < 1e-6:\n        return 1.0\n    thr = (mn + mx) / 2.0\n    mask = gray > thr\n    if not mask.any():\n        return 1.0\n    rows = np.any(mask, axis=1)\n    cols = np.any(mask, axis=0)\n    r_inds = np.where(rows)[0]\n    c_inds = np.where(cols)[0]\n    if r_inds.size == 0:\n        return 1.0\n    r0, r1 = r_inds[0], r_inds[-1]\n    h = r1 - r0 + 1\n    top_end = r0 + max(1, int(np.ceil(0.3 * h)))\n    top_slice = mask[r0:top_end, c_inds[0]:c_inds[-1]+1]\n    if top_slice.size == 0:\n        return 1.0\n    empty = top_slice.size - top_slice.sum()\n    return float(empty) / float(top_slice.size)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Slope of row-wise mask widths across the middle third (positive => widening toward bottom)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 3 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    start = h // 3\n    end = min(h, 2 * (h // 3) + (h % 3))\n    rows = np.arange(start, end).astype(float)\n    if rows.size < 2:\n        return 0.0\n    widths = np.sum(mask[start:end, :].astype(float), axis=1)\n    if np.all(widths == 0):\n        return 0.0\n    # linear fit\n    try:\n        coeffs = np.polyfit(rows, widths, 1)\n        slope = float(coeffs[0])\n    except Exception:\n        slope = 0.0\n    # normalize by image width so scale is comparable across sizes\n    return float(slope / (w + 1e-8))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Upper-arm protrusion index: mean foreground run count in upper band divided by center band'\n    import numpy as np\n    if image is None:\n        return 1.0\n    h, w = image.shape[:2]\n    if h == 0:\n        return 1.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    def runs_in_row(row):\n        row_bits = row.astype(np.int8)\n        if row_bits.size == 0:\n            return 0\n        diffs = np.diff(np.concatenate(([0], row_bits, [0])))\n        starts = np.count_nonzero(diffs == 1)\n        return int(starts)\n    upper_end = max(1, int(0.25 * h))\n    center_start = max(0, int(0.4 * h))\n    center_end = min(h, int(0.6 * h))\n    upper_runs = [runs_in_row(mask[r, :]) for r in range(0, upper_end)]\n    center_runs = [runs_in_row(mask[r, :]) for r in range(center_start, center_end)]\n    if len(upper_runs) == 0:\n        return 1.0\n    upper_mean = float(np.mean(upper_runs))\n    center_mean = float(np.mean(center_runs)) if len(center_runs) else 0.0\n    return float(upper_mean / (center_mean + 1e-8))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Number of horizontal peaks in the column-sum projection of the mask, normalized by image width'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    col_sum = np.count_nonzero(mask, axis=0).astype(float)\n    if col_sum.size == 0:\n        return 0.0\n    # smooth a little with 3-wide median to reduce noise\n    padded = np.pad(col_sum, (1, 1), mode='edge')\n    smooth = (padded[:-2] + padded[1:-1] + padded[2:]) / 3.0\n    # find local maxima\n    diffs = np.diff(smooth)\n    signs = np.sign(diffs)\n    # count sign changes from positive to negative => peak\n    peaks = 0\n    for i in range(1, signs.size):\n        if signs[i - 1] > 0 and signs[i] < 0:\n            peaks += 1\n    return float(peaks / max(1.0, float(w)))\n",
    "def feature(image: np.ndarray) -> float:\n    'Fraction of mask pixels located in the bottom third of the image'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    if not np.any(mask):\n        return 0.0\n    bottom_start = int(2 * h / 3)\n    bottom_mask = mask[bottom_start:, :]\n    bottom_count = float(np.count_nonzero(bottom_mask))\n    total_count = float(np.count_nonzero(mask))\n    return float(bottom_count / (total_count + 1e-8))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Central vertical seam relative strength: central vertical mean minus side vertical mean normalized (positive if strong center)'\n    try:\n        import numpy as np\n        gray = np.mean(image, axis=2) if len(image.shape) == 3 else image.astype(float)\n        h, w = gray.shape[:2]\n        cs = max(1, w // 12)\n        cx = w // 2\n        central = gray[:, max(0, cx - cs // 2): min(w, cx + (cs - cs//2))]\n        left = gray[:, 0: max(1, w // 6)]\n        right = gray[:, max(0, w - max(1, w // 6)): w]\n        central_mean = float(np.mean(central)) if central.size else 0.0\n        side_mean = float(np.mean(np.hstack([left.flatten(), right.flatten()]))) if (left.size or right.size) else 1.0\n        return float((central_mean - side_mean) / (abs(side_mean) + 1e-6))\n    except Exception:\n        return 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Solidity-like measure: ratio of object area to its bounding-box area (thin straps => low)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape\n    if h == 0 or w == 0:\n        return 0.0\n    thr = np.mean(gray) + 0.25 * np.std(gray)\n    mask = gray > thr\n    if not np.any(mask):\n        mask = gray > np.percentile(gray, 80)\n    if not np.any(mask):\n        return 0.0\n    rows = np.where(np.any(mask, axis=1))[0]\n    cols = np.where(np.any(mask, axis=0))[0]\n    if rows.size == 0 or cols.size == 0:\n        return 0.0\n    rmin, rmax = rows[0], rows[-1]\n    cmin, cmax = cols[0], cols[-1]\n    bbox_area = float((rmax - rmin + 1) * (cmax - cmin + 1))\n    area = float(np.count_nonzero(mask))\n    if bbox_area <= 0:\n        return 0.0\n    return float(area / bbox_area)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Perimeter-to-area ratio estimate using 4-neighbor edge count divided by object area (higher for more detailed edges)'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    th = np.mean(gray) + 0.25 * np.std(gray)\n    mask = (gray > th).astype(np.uint8)\n    if np.count_nonzero(mask) == 0:\n        mask = (gray > np.percentile(gray, 75)).astype(np.uint8)\n    area = float(np.count_nonzero(mask))\n    if area == 0.0:\n        return 0.0\n    # perimeter: count mask pixels that have at least one 4-neighbor background\n    up = np.zeros_like(mask); up[1:, :] = mask[:-1, :]\n    down = np.zeros_like(mask); down[:-1, :] = mask[1:, :]\n    left = np.zeros_like(mask); left[:, 1:] = mask[:, :-1]\n    right = np.zeros_like(mask); right[:, :-1] = mask[:, 1:]\n    neighbor_sum = up + down + left + right\n    edge_pixels = np.count_nonzero((mask == 1) & (neighbor_sum < 4))\n    return float(edge_pixels) / (area + 1e-9)\n",
    "def feature(image: np.ndarray) -> float:\n    'Mask fill ratio: mask area divided by its bounding-box area (compactness inside bbox)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = float(np.median(gray))\n    mask = ((gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)).astype(np.uint8)\n    ys, xs = np.where(mask)\n    if ys.size == 0:\n        return 0.0\n    ymin, ymax = int(np.min(ys)), int(np.max(ys))\n    xmin, xmax = int(np.min(xs)), int(np.max(xs))\n    bbox_area = float(max(1, ymax - ymin + 1) * max(1, xmax - xmin + 1))\n    mask_area = float(np.count_nonzero(mask))\n    return float(mask_area / (bbox_area + 1e-8))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Central neck-gap presence: longest vertical run of background in center column region within top quarter, normalized by height'\n    import numpy as np\n    gray = np.mean(image, axis=2) if len(image.shape) == 3 else image.astype(float)\n    h, w = gray.shape[:2]\n    thr = (np.max(gray) + np.min(gray)) / 2.0\n    mask = gray > thr\n    top_h = max(1, h // 4)\n    center_col = w // 2\n    # examine a small horizontal window around center to be robust\n    half_window = max(1, w // 10)\n    c0 = max(0, center_col - half_window)\n    c1 = min(w, center_col + half_window + 1)\n    sub = ~mask[:top_h, c0:c1]  # True where background\n    if sub.size == 0:\n        return 0.0\n    # find longest vertical contiguous run anywhere in this sub (per column then take max)\n    longest = 0\n    for j in range(sub.shape[1]):\n        col = sub[:, j]\n        # compute longest True run\n        max_run = 0\n        run = 0\n        for v in col:\n            if v:\n                run += 1\n                if run > max_run:\n                    max_run = run\n            else:\n                run = 0\n        if max_run > longest:\n            longest = max_run\n    return float(longest) / float(max(1, h))\n",
    "def feature(image: np.ndarray) -> float:\n    'Mask compactness: area / (perimeter^2) (higher = more compact)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    mask = mask.astype(bool)\n    area = float(np.count_nonzero(mask))\n    if area == 0:\n        return 0.0\n    # interior pixels are those with all 4-neighbors also True\n    interior = mask.copy()\n    interior &= np.roll(mask, 1, axis=0)\n    interior &= np.roll(mask, -1, axis=0)\n    interior &= np.roll(mask, 1, axis=1)\n    interior &= np.roll(mask, -1, axis=1)\n    boundary = mask & (~interior)\n    perimeter = float(np.count_nonzero(boundary))\n    if perimeter <= 0:\n        return float(area / (1e-8))\n    compact = area / ((perimeter * perimeter) + 1e-8)\n    return float(compact)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Vertical symmetry score (1 = perfect mirror across vertical axis)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    # create horizontally flipped version\n    flipped = np.fliplr(gray)\n    diff = np.abs(gray - flipped)\n    mean_diff = float(np.mean(diff))\n    mean_intensity = float(np.mean(gray)) + 1e-8\n    score = 1.0 - (mean_diff / mean_intensity)\n    # clamp to [0,1]\n    score = max(0.0, min(1.0, score))\n    return float(score)\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Fill ratio: mask area divided by tight bounding box area (0..1, smaller means hollow/complex silhouette)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    ys, xs = np.where(mask)\n    if ys.size == 0:\n        return 0.0\n    miny, maxy = int(np.min(ys)), int(np.max(ys))\n    minx, maxx = int(np.min(xs)), int(np.max(xs))\n    box_h = max(1, maxy - miny + 1)\n    box_w = max(1, maxx - minx + 1)\n    bbox_area = float(box_h * box_w)\n    mask_area = float(np.count_nonzero(mask))\n    return float(mask_area / (bbox_area + 1e-8))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Mean absolute vertical gradient along central vertical axis normalized by global intensity std (captures buttons/placket vertical details)'\n    import numpy as np\n    h, w = image.shape[:2]\n    gray = np.mean(image, axis=2) if image.ndim == 3 else image.astype(float)\n    center_col = w // 2\n    col_vals = gray[:, center_col].astype(float)\n    if col_vals.size <= 1:\n        return 0.0\n    grad = np.abs(np.diff(col_vals))\n    denom = float(np.std(gray)) + 1e-9\n    return float(np.mean(grad) / denom)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Ratio of bottom-quarter object width to middle-quarter object width (tapering or hip width indication)'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    thresh = np.mean(gray) + 0.25 * np.std(gray)\n    mask = gray > thresh\n    if np.count_nonzero(mask) == 0:\n        mask = gray > np.mean(gray)\n    rows = np.any(mask, axis=1)\n    if not rows.any():\n        return 1.0\n    r_indices = np.where(rows)[0]\n    rmin, rmax = r_indices[0], r_indices[-1]\n    total_h = rmax - rmin + 1\n    if total_h <= 0:\n        return 1.0\n    # middle quarter and bottom quarter rows\n    mid_start = rmin + total_h // 3\n    mid_end = rmin + 2 * total_h // 3\n    bot_start = rmin + 2 * total_h // 3\n    bot_end = rmax\n    def avg_width(rs, re):\n        widths = []\n        for r in range(rs, min(re + 1, mask.shape[0])):\n            cols = np.where(mask[r, :])[0]\n            if cols.size:\n                widths.append(cols[-1] - cols[0] + 1)\n        if not widths:\n            return 0.0\n        return float(np.mean(widths))\n    mid_w = avg_width(mid_start, mid_end)\n    bot_w = avg_width(bot_start, bot_end)\n    if mid_w <= 1e-6:\n        return float(bot_w)\n    return float(bot_w / mid_w)\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Fraction of total gradient energy concentrated in the lower 40% of the image'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 2 or w < 2:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    gy, gx = np.gradient(gray.astype(float))\n    grad_energy = gx * gx + gy * gy\n    lower_h = max(1, int(h * 0.40))\n    lower_region = grad_energy[h - lower_h:, :]\n    total_energy = float(np.sum(grad_energy)) + 1e-8\n    lower_energy = float(np.sum(lower_region))\n    return float(lower_energy / total_energy)\n",
    "def feature(image: np.ndarray) -> float:\n    'Upper-to-lower mass ratio: fraction of object pixels located in the upper half of the image'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    thr = 0.5 * np.mean(gray) + 0.5 * np.min(gray)\n    bin_img = gray > thr\n    upper = bin_img[:h // 2, :]\n    total = bin_img\n    total_count = float(np.count_nonzero(total))\n    if total_count == 0:\n        return 0.0\n    upper_count = float(np.count_nonzero(upper))\n    return float(upper_count / total_count)\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Entropy of strong-edge gradient orientations (0..1 normalized)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 2 or w < 2:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    gy, gx = np.gradient(gray.astype(float))\n    mag = np.sqrt(gx * gx + gy * gy)\n    if not np.any(mag):\n        return 0.0\n    thr = np.percentile(mag, 70)\n    mask = mag > thr\n    if not np.any(mask):\n        return 0.0\n    angles = np.arctan2(gy[mask], gx[mask])  # -pi..pi\n    nbins = 12\n    hist, _ = np.histogram(angles, bins=nbins, range=(-np.pi, np.pi))\n    probs = hist.astype(float) / (np.sum(hist) + 1e-8)\n    probs = probs[probs > 0]\n    import math\n    ent = -float(np.sum(probs * np.log(probs + 1e-12)))\n    # normalize by log(nbins)\n    ent_norm = ent / (math.log(nbins) + 1e-12)\n    return float(max(0.0, min(1.0, ent_norm)))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Average normalized y-position of the bottommost object pixel in the left and right outer 20% columns (indicates sleeve length)'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    h, w = gray.shape\n    if h == 0 or w == 0:\n        return 0.0\n    mx = float(np.max(gray))\n    thr = float(np.mean(gray)) + 0.08 * (mx - float(np.mean(gray)))\n    mask = gray > thr\n    if np.count_nonzero(mask) == 0:\n        mask = gray > float(np.mean(gray))\n    if np.count_nonzero(mask) == 0:\n        return 0.0\n    left_cols = range(0, max(1, w // 5))\n    right_cols = range(w - max(1, w // 5), w)\n    bottom_ys = []\n    for cols in (left_cols, right_cols):\n        ys = []\n        for c in cols:\n            col = mask[:, c]\n            nz = np.where(col)[0]\n            if nz.size:\n                ys.append(int(nz.max()))\n        if len(ys):\n            bottom_ys.append(float(np.mean(ys)) / max(1.0, h - 1.0))\n    if not bottom_ys:\n        return 0.0\n    return float(np.mean(bottom_ys))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Average horizontal span of non-background pixels near mid-height normalized by image width (indicates sleeve extension)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    if np.all(gray == 0) or h < 3:\n        return 0.0\n    mid = h // 2\n    band = max(1, h // 8)\n    region = gray[mid - band: mid + band + 1, :]\n    nonzero = (region > 0)\n    if nonzero.size == 0:\n        return 0.0\n    # per-row span\n    spans = []\n    for row in range(nonzero.shape[0]):\n        cols = np.where(nonzero[row, :])[0]\n        if cols.size:\n            spans.append(float(cols[-1] - cols[0] + 1))\n    if not spans:\n        return 0.0\n    avg_span = float(np.mean(spans))\n    return float(avg_span / float(w))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Color uniformity measure for RGB: 1 = perfectly uniform color, 0 = maximally varied'\n    import numpy as np\n    if image is None:\n        return 0.0\n    if len(image.shape) != 3 or image.shape[2] < 3:\n        return 0.0\n    img = image.astype(float)\n    # per-pixel color spread\n    pix_std = np.std(img, axis=2)\n    mean_pix_std = float(np.mean(pix_std))\n    dyn = float(np.max(img) - np.min(img))\n    if dyn <= 1e-8:\n        return 1.0\n    uniformity = 1.0 - (mean_pix_std / (dyn + 1e-8))\n    return float(max(0.0, min(1.0, uniformity)))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Bounding box height-to-width ratio of the foreground mask (taller -> larger)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    # grayscale\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask_dark = gray < thr\n    mask_bright = gray > thr\n    mask = mask_dark if np.count_nonzero(mask_dark) >= np.count_nonzero(mask_bright) else mask_bright\n    ys, xs = np.where(mask)\n    if ys.size == 0:\n        return 0.0\n    miny, maxy = int(ys.min()), int(ys.max())\n    minx, maxx = int(xs.min()), int(xs.max())\n    bbox_h = maxy - miny + 1\n    bbox_w = maxx - minx + 1\n    if bbox_w <= 0:\n        return 0.0\n    return float(bbox_h / float(bbox_w))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Relative darkness of a small top-center strip vs top-side strips (lower means darker center - collar/opening)'\n    import numpy as np\n    gray = np.mean(image, axis=2) if len(image.shape) == 3 else image.astype(float)\n    h, w = gray.shape[:2]\n    top_h = max(1, h // 8)\n    center_w = max(1, w // 6)\n    cx = w // 2\n    # regions\n    center = gray[0:top_h, max(0, cx - center_w):min(w, cx + center_w)]\n    left = gray[0:top_h, 0:max(1, w // 4)]\n    right = gray[0:top_h, max(0, w - w // 4):w]\n    mc = np.mean(center) if center.size else 0.0\n    mlr = (np.mean(left) + np.mean(right)) / 2.0 if (left.size and right.size) else (np.mean(gray[0:top_h, :]) if gray[0:top_h, :].size else 1.0)\n    denom = (mlr + 1e-6)\n    return float(mc / denom)\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Approximate color saturation: mean pairwise absolute differences of RGB channels (0 for grayscale)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    if len(image.shape) != 3 or image.shape[2] < 3:\n        return 0.0\n    img = image.astype(float)\n    r = img[:, :, 0]\n    g = img[:, :, 1]\n    b = img[:, :, 2]\n    diff = (np.abs(r - g) + np.abs(g - b) + np.abs(b - r)) / 3.0\n    return float(np.mean(diff))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Normalized vertical centroid position of the object (0.0 top, 1.0 bottom)'\n    import numpy as np\n    img = np.asarray(image)\n    if img.size == 0:\n        return 0.0\n    if img.ndim == 3:\n        gray = np.mean(img, axis=2)\n    else:\n        gray = img\n    thr = max(np.percentile(gray, 70), np.mean(gray) * 0.5)\n    mask = gray > thr\n    if np.count_nonzero(mask) < 3:\n        mask = gray != gray.min()\n    ys, xs = np.nonzero(mask)\n    if ys.size == 0:\n        return 0.0\n    centroid_y = float(np.mean(ys))\n    h = gray.shape[0]\n    return float(centroid_y / max(1.0, h - 1))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Difference between mean corner intensity (bottom corners) and image center intensity'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    # grayscale\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    # regions\n    bw = max(1, w // 6)\n    bh = max(1, h // 6)\n    bl = gray[h - bh:h, 0:bw]\n    br = gray[h - bh:h, w - bw:w]\n    cx0 = h // 2 - bh // 2\n    cy0 = w // 2 - bw // 2\n    center = gray[max(0, cx0):min(h, cx0 + bh), max(0, cy0):min(w, cy0 + bw)]\n    if center.size == 0:\n        center_mean = np.mean(gray)\n    else:\n        center_mean = np.mean(center)\n    corner_mean = 0.0\n    cnt = 0\n    if bl.size > 0:\n        corner_mean += np.mean(bl); cnt += 1\n    if br.size > 0:\n        corner_mean += np.mean(br); cnt += 1\n    if cnt == 0:\n        return 0.0\n    corner_mean /= cnt\n    # positive if corners brighter than center\n    return float(corner_mean - center_mean)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Fill ratio: proportion of mask pixels inside the object bounding box (higher -> more compact like bags)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    maxv = float(gray.max()) if gray.size else 0.0\n    if maxv <= 0:\n        return 0.0\n    mask = gray > (0.2 * maxv)\n    coords = np.argwhere(mask)\n    if coords.size == 0:\n        return 0.0\n    rmin, cmin = coords.min(axis=0)\n    rmax, cmax = coords.max(axis=0)\n    bbox_area = float((rmax - rmin + 1) * (cmax - cmin + 1))\n    mask_area = float(mask.sum())\n    return float(mask_area / (bbox_area + 1e-9))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Mask fill ratio: fraction of bounding-box area that is occupied by the mask (0..1)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = ((gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)).astype(bool)\n    if not np.any(mask):\n        return 0.0\n    rows = np.any(mask, axis=1)\n    cols = np.any(mask, axis=0)\n    r_idx = np.where(rows)[0]\n    c_idx = np.where(cols)[0]\n    if r_idx.size == 0 or c_idx.size == 0:\n        return 0.0\n    bbox_h = int(r_idx[-1] - r_idx[0] + 1)\n    bbox_w = int(c_idx[-1] - c_idx[0] + 1)\n    bbox_area = float(bbox_h * bbox_w) + 1e-8\n    mask_area = float(np.count_nonzero(mask))\n    return float(mask_area / bbox_area)\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Fraction of strict local bright maxima (pixels > all 8 neighbors and > 95th percentile)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 3 or w < 3:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 95)\n    inner = gray[1:-1, 1:-1]\n    if inner.size == 0:\n        return 0.0\n    n = 0\n    # neighbors\n    n1 = gray[:-2, :-2]\n    n2 = gray[:-2, 1:-1]\n    n3 = gray[:-2, 2:]\n    n4 = gray[1:-1, :-2]\n    n5 = gray[1:-1, 2:]\n    n6 = gray[2:, :-2]\n    n7 = gray[2:, 1:-1]\n    n8 = gray[2:, 2:]\n    cond = (inner > n1) & (inner > n2) & (inner > n3) & (inner > n4) & (inner > n5) & (inner > n6) & (inner > n7) & (inner > n8) & (inner > thr)\n    count = float(np.count_nonzero(cond))\n    total_possible = float(inner.size)\n    return float(count / (total_possible + 1e-8))\n",
    "def feature(image: np.ndarray) -> float:\n    'Mean downward vertical edge strength in a small top-center box (strong for collars/neck openings)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    top_h = max(1, h // 8)\n    cw = max(1, w // 4)\n    top_center = gray[0:top_h, w//2 - cw//2:w//2 + (cw - cw//2)]\n    # vertical gradient (positive = increasing downward). We want strong negative -> top edge\n    _, gy = np.gradient(top_center)\n    neg_edges = np.abs(np.minimum(gy, 0.0))\n    overall_grad = np.mean(np.abs(np.gradient(gray)[0])) + 1e-6\n    return float(np.mean(neg_edges) / (overall_grad + 1e-6))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Ratio of foreground density in top 30% to bottom 30% of the image'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 3:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 50)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    top_h = max(1, int(h * 0.3))\n    bot_h = max(1, int(h * 0.3))\n    top_count = float(np.count_nonzero(mask[:top_h, :]))\n    bot_count = float(np.count_nonzero(mask[h - bot_h:, :]))\n    return float((top_count + 1e-8) / (bot_count + 1e-8))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Upper-third vertical-gradient prominence: max vertical gradient magnitude in upper third normalized by overall max (captures sleeve/arm-edge contrast)'\n    try:\n        if len(image.shape) == 3:\n            gray = np.mean(image.astype(float), axis=2)\n        else:\n            gray = image.astype(float)\n    except Exception:\n        return 0.0\n    gray = gray.astype(float)\n    h, w = gray.shape[:2]\n    if h < 2 or w == 0:\n        return 0.0\n    # compute vertical gradients\n    gy, gx = np.gradient(gray)\n    mag_v = np.abs(gy)\n    top_h = max(1, h // 3)\n    top_mag_v = mag_v[:top_h, :]\n    max_top = np.max(top_mag_v) if top_mag_v.size else 0.0\n    max_all = np.max(mag_v) if mag_v.size else 1.0\n    denom = max_all if max_all != 0 else 1.0\n    return float(max_top / denom)\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Longest contiguous mask run in the center column (normalized by height) indicating continuous garment'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = ((gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)).astype(int)\n    center_col = mask[:, w // 2] if w > 0 else mask[:, 0]\n    if center_col.size == 0:\n        return 0.0\n    padded = np.concatenate([[0], center_col, [0]])\n    diffs = np.diff(padded)\n    starts = np.where(diffs == 1)[0]\n    ends = np.where(diffs == -1)[0]\n    if starts.size == 0:\n        return 0.0\n    lengths = ends - starts\n    longest = float(np.max(lengths))\n    return float(longest / float(h))\n",
    "def feature(image: np.ndarray) -> float:\n    'Waist narrowness index: 1 - (min width in middle third / max row width) (higher => narrow waist)'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    mn, mx = float(np.min(gray)), float(np.max(gray))\n    if mx - mn < 1e-6:\n        return 0.0\n    thr = np.mean(gray) + 0.25 * np.std(gray)\n    mask = gray > thr\n    if np.count_nonzero(mask) < 5:\n        thr = np.mean(gray)\n        mask = gray > thr\n    # compute row widths\n    widths = np.zeros(h, dtype=int)\n    for r in range(h):\n        cols = np.where(mask[r, :])[0]\n        if cols.size > 0:\n            widths[r] = int(cols[-1] - cols[0] + 1)\n    max_width = int(widths.max())\n    if max_width == 0:\n        return 0.0\n    start, end = h // 3, (2 * h) // 3\n    mid_widths = widths[start:end]\n    mid_nonzero = mid_widths[mid_widths > 0]\n    if mid_nonzero.size == 0:\n        min_mid = 0\n    else:\n        min_mid = int(mid_nonzero.min())\n    ratio = float(min_mid) / float(max_width)\n    return float(1.0 - ratio)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Vertical centroid of the detected foreground normalized to [0,1] (0=top,1=bottom)'\n    import numpy as np\n    if image is None:\n        return 0.5\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.5\n    # grayscale\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 50)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    ys, xs = np.where(mask)\n    if ys.size == 0:\n        return 0.5\n    centroid_y = float(np.mean(ys))\n    return float(centroid_y / float(max(1, h - 1)))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Ratio of top-half object pixels to bottom-half pixels within the bounding box (top_area / bottom_area)'\n    import numpy as np\n    gray = np.mean(image, axis=2) if len(image.shape) == 3 else image.astype(float)\n    if gray.size == 0:\n        return 0.0\n    thresh = np.mean(gray) + 0.5 * np.std(gray)\n    mask = gray > thresh\n    if not mask.any():\n        mask = gray > np.percentile(gray, 75)\n    ys, xs = np.where(mask)\n    if ys.size == 0:\n        return 0.0\n    y0, y1 = ys.min(), ys.max()\n    x0, x1 = xs.min(), xs.max()\n    crop = mask[y0:y1+1, x0:x1+1]\n    h = crop.shape[0]\n    if h == 0:\n        return 0.0\n    top = crop[:h//2, :].sum()\n    bottom = crop[h//2:, :].sum()\n    eps = 1e-6\n    return float(float(top) / (float(bottom) + eps))\n",
    "def feature(image: np.ndarray) -> float:\n    'Normalized vertical centroid of the foreground (0=top,1=bottom)'\n    import numpy as np\n    if image is None:\n        return 0.5\n    h, w = image.shape[:2]\n    if h == 0:\n        return 0.5\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    ys, xs = np.where(mask)\n    if ys.size == 0:\n        return 0.5\n    cy = float(np.mean(ys)) / float(max(1, h - 1))\n    return float(np.clip(cy, 0.0, 1.0))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Ratio of average mask width in bottom 10% to average width in middle 40-60%'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 5 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    bottom_h = max(1, h * 10 // 100)\n    bottom = mask[-bottom_h:, :]\n    mid_start = max(0, h * 40 // 100)\n    mid_end = min(h, h * 60 // 100)\n    mid = mask[mid_start:mid_end, :]\n    if bottom.size == 0 or mid.size == 0:\n        return 0.0\n    bottom_widths = np.sum(bottom.astype(float), axis=1)\n    mid_widths = np.sum(mid.astype(float), axis=1)\n    bottom_avg = float(np.mean(bottom_widths)) if bottom_widths.size > 0 else 0.0\n    mid_avg = float(np.mean(mid_widths)) if mid_widths.size > 0 else 0.0\n    if mid_avg <= 1e-8:\n        return 0.0\n    return float((bottom_avg + 1e-8) / (mid_avg + 1e-8))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Colorfulness metric based on rg and yb channels (Hasler-S\u00fcsstrunk style)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h_w = image.shape[:2]\n    if h_w[0] == 0 or h_w[1] == 0:\n        return 0.0\n    if len(image.shape) == 3 and image.shape[2] >= 3:\n        img = image.astype(float)\n        R = img[:, :, 0]\n        G = img[:, :, 1]\n        B = img[:, :, 2]\n        rg = R - G\n        yb = 0.5 * (R + G) - B\n        std_rg = float(np.std(rg))\n        std_yb = float(np.std(yb))\n        mean_rg = float(np.mean(rg))\n        mean_yb = float(np.mean(yb))\n        colorfulness = np.sqrt(std_rg * std_rg + std_yb * std_yb) + 0.3 * np.sqrt(mean_rg * mean_rg + mean_yb * mean_yb)\n        return float(colorfulness)\n    else:\n        # grayscale: colorfulness is zero\n        return 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Bottom fling/flare ratio: width near bottom of object divided by width near upper-middle (values >1 indicate flare)'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    h, w = gray.shape[:2]\n    mn, mx = float(np.min(gray)), float(np.max(gray))\n    if mx <= mn:\n        return 1.0\n    mask = gray > (mn + 0.2 * (mx - mn))\n    ys, xs = np.where(mask)\n    if ys.size == 0:\n        return 1.0\n    top, bottom = int(np.min(ys)), int(np.max(ys))\n    bh = max(1, bottom - top + 1)\n    row_upper = top + int(0.35 * bh)\n    row_lower = top + int(0.85 * bh)\n    def width_at_row(r):\n        if r < 0 or r >= h:\n            return 0.0\n        rm = mask[r, :]\n        if not np.any(rm):\n            return 0.0\n        c = np.where(rm)[0]\n        return float(c[-1] - c[0] + 1)\n    wu = width_at_row(min(h-1, row_upper))\n    wl = width_at_row(min(h-1, row_lower))\n    denom = wu if wu > 0 else 1.0\n    return float(wl / denom)\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Ratio of shoulder span measured at 10% down from top vs at 30% down (captures broad shoulders of coats)'\n    import numpy as np\n    gray = np.mean(image, axis=2) if len(image.shape) == 3 else image.astype(float)\n    h, w = gray.shape[:2]\n    if h < 6 or w < 6:\n        return 0.0\n    vmin, vmax = float(np.min(gray)), float(np.max(gray))\n    if vmax == vmin:\n        return 0.0\n    thresh = vmin + 0.25 * (vmax - vmin)\n    fg = gray > thresh\n    # find bounding box\n    rows = np.where(np.any(fg, axis=1))[0]\n    cols = np.where(np.any(fg, axis=0))[0]\n    if rows.size == 0 or cols.size == 0:\n        return 0.0\n    top = int(rows[0]); bottom = int(rows[-1])\n    # compute spans at two depths\n    def horizontal_span_at(rel_frac):\n        r = int(top + rel_frac * max(1, (bottom - top)))\n        if r < 0 or r >= h:\n            return 0\n        cols_on = np.where(fg[r, :])[0]\n        if cols_on.size == 0:\n            return 0\n        return int(cols_on[-1]) - int(cols_on[0]) + 1\n    span1 = horizontal_span_at(0.10)\n    span2 = horizontal_span_at(0.30)\n    if span2 == 0:\n        return float(span1)\n    return float(span1) / float(span2)\n",
    "def feature(image: np.ndarray) -> float:\n    'Left-right symmetry of the foreground mask (1.0 = perfectly symmetric)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    # grayscale conversion\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    if not np.any(mask):\n        return 0.0\n    flipped = np.fliplr(mask)\n    # align sizes if odd widths (should be same)\n    diff = np.logical_xor(mask, flipped)\n    score = 1.0 - (np.mean(diff.astype(float)))\n    return float(score)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Bottom-to-middle width ratio: width of object in bottom 10% of rows divided by width at middle band (higher => flared/dress-like)'\n    try:\n        if len(image.shape) == 3:\n            gray = np.mean(image, axis=2)\n        else:\n            gray = image.astype(float)\n        h, w = gray.shape[:2]\n        meanv = float(np.mean(gray))\n        mask = (gray < meanv)\n        if np.count_nonzero(mask) < 4:\n            mask = (gray < float(np.percentile(gray, 50)))\n        bottom_h = max(1, h // 10)\n        bottom_region = mask[-bottom_h:, :]\n        mid_h = max(1, h // 20)\n        mid_r = h // 2\n        mid_region = mask[max(0, mid_r - mid_h):min(h, mid_r + mid_h), :]\n        width_bottom = int(np.count_nonzero(np.any(bottom_region, axis=0)))\n        width_mid = int(np.count_nonzero(np.any(mid_region, axis=0)))\n        if width_mid == 0:\n            return float(width_bottom)\n        return float(width_bottom / (width_mid + 1e-9))\n    except Exception:\n        return 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Ratio of average mask width near top (10%) to average width near bottom (90%)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 4 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = ((gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)).astype(np.uint8)\n    def avg_width_at_frac(frac, band=2):\n        row = int(min(h - 1, max(0, int(frac * h))))\n        start = max(0, row - band)\n        end = min(h, row + band + 1)\n        widths = np.sum(mask[start:end, :].astype(float), axis=1)\n        if widths.size == 0:\n            return 0.0\n        return float(np.mean(widths))\n    top_w = avg_width_at_frac(0.10)\n    bot_w = avg_width_at_frac(0.90)\n    if bot_w <= 1e-8:\n        return float(top_w / (bot_w + 1e-8))\n    return float(top_w / bot_w)\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Ratio of object pixel area in bottom quarter to the middle half (bottom_area / middle_area); >1 indicates a flared skirt'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    h, w = gray.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    thresh = np.mean(gray) + 0.25 * np.std(gray)\n    binary = gray > thresh\n    bottom_start = (3 * h) // 4\n    middle_start = h // 4\n    middle_end = (3 * h) // 4\n    bottom_area = float(np.sum(binary[bottom_start:h, :]))\n    middle_area = float(np.sum(binary[middle_start:middle_end, :]))\n    if middle_area < 1e-6:\n        return float(bottom_area / (middle_area + 1.0))  # avoid div by zero, give sensible ratio\n    return float(bottom_area / middle_area)\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Relative brightness of left+right upper corners compared to center upper region (sleeve indicator)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    if h < 4 or w < 4:\n        return 0.0\n    uh = max(1, h//4)\n    side_w = max(1, w//6)\n    center_w = max(1, w//3)\n    left_corner = gray[0:uh, 0:side_w].mean() if np.any(gray) else 0.0\n    right_corner = gray[0:uh, w-side_w:w].mean() if np.any(gray) else 0.0\n    center_upper = gray[0:uh, (w//2 - center_w//2):(w//2 + center_w//2)].mean() if np.any(gray) else 0.0\n    return float((left_corner + right_corner) / (center_upper + 1e-9))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Elongation measured as sqrt(eigenvalue_ratio) of object pixel coordinates (higher = more elongated)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    thresh = max(1e-6, np.percentile(gray, 5))\n    mask = gray > thresh\n    ys, xs = np.where(mask)\n    if ys.size < 3:\n        return 0.0\n    coords = np.vstack([ys.astype(float), xs.astype(float)])\n    # center coordinates\n    coords -= coords.mean(axis=1, keepdims=True)\n    cov = np.cov(coords)\n    # numerical safety\n    try:\n        vals = np.linalg.eigvalsh(cov)\n    except Exception:\n        return 0.0\n    vals = np.sort(vals)\n    small = max(1e-9, vals[0])\n    ratio = float(vals[-1] / small)\n    # return sqrt ratio to compress scale a bit\n    return float(np.sqrt(ratio))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Left-right symmetry of the foreground mask (1.0 = perfect symmetry)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 50)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    if not np.any(mask):\n        return 0.0\n    # align halves (if odd width, ignore middle column)\n    mid = w // 2\n    left = mask[:, :mid]\n    right = mask[:, w - mid:][:, ::-1]\n    # compute Jaccard-like overlap\n    inter = np.count_nonzero(left & right)\n    union = np.count_nonzero(left | right)\n    if union == 0:\n        return 1.0\n    return float(inter / union)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Fill ratio: area of object mask divided by its bounding box area (bags often fill bbox more evenly than shoes)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    maxv = float(np.max(gray))\n    th = maxv * 0.08\n    mask = gray > th\n    if mask.sum() == 0:\n        th = float(np.mean(gray))\n        mask = gray > th\n    if mask.sum() == 0:\n        mask = gray > np.min(gray)\n    ys, xs = np.where(mask)\n    if ys.size == 0:\n        return 0.0\n    r0, r1 = int(ys.min()), int(ys.max())\n    c0, c1 = int(xs.min()), int(xs.max())\n    bbox_area = float((r1 - r0 + 1) * (c1 - c0 + 1))\n    if bbox_area <= 0:\n        return 0.0\n    obj_area = float(np.count_nonzero(mask[r0:r1+1, c0:c1+1]))\n    return float(obj_area / bbox_area)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Top-edge horizontal gradient density: fraction of strong horizontal edges in the top 12% rows'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 3 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    top_h = max(1, int(h * 0.12))\n    gy, gx = np.gradient(gray.astype(float))\n    # horizontal gradient magnitude (changes left-right)\n    horiz = np.abs(gx)\n    band = horiz[:top_h, :]\n    if band.size == 0:\n        return 0.0\n    thr = np.percentile(band, 80)\n    strong = float(np.count_nonzero(band > thr))\n    result = strong / float(band.size)\n    return float(result)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Bottom-half left/right area balance: min(bottom-left,bottom-right)/max(...), near 1 = balanced'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.copy()\n    h, w = gray.shape[:2]\n    rng = float(gray.max() - gray.min()) if gray.max() != gray.min() else 1.0\n    thresh = float(np.mean(gray) + 0.15 * rng)\n    mask = gray > thresh\n    if np.count_nonzero(mask) == 0:\n        mask = gray < (np.mean(gray) - 0.15 * rng)\n    if np.count_nonzero(mask) == 0:\n        return 0.0\n    ys = np.where(np.any(mask, axis=1))[0]\n    if ys.size == 0:\n        return 0.0\n    top, bottom = ys[0], ys[-1]\n    mid = (top + bottom) // 2\n    bottom_region = mask[mid:bottom+1, :]\n    if bottom_region.size == 0:\n        return 0.0\n    left_area = float(np.count_nonzero(bottom_region[:, :w//2]))\n    right_area = float(np.count_nonzero(bottom_region[:, w//2:]))\n    if left_area == 0 and right_area == 0:\n        return 0.0\n    mn = min(left_area, right_area) + 1e-9\n    mx = max(left_area, right_area) + 1e-9\n    return float(mn / mx)\n",
    "def feature(image: np.ndarray) -> float:\n    'Fraction of background (opening) in the top quarter of the object bbox (high for open sandals)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(np.float32)\n    else:\n        gray = image.astype(np.float32)\n    mn, mx = float(np.min(gray)), float(np.max(gray))\n    if mx > mn:\n        gray = (gray - mn) / (mx - mn)\n    else:\n        gray = gray * 0.0\n    fg = gray > 0.2\n    ys, xs = np.where(fg)\n    if ys.size == 0:\n        return 0.0\n    rmin, rmax = int(ys.min()), int(ys.max())\n    cmin, cmax = int(xs.min()), int(xs.max())\n    h = rmax - rmin + 1\n    top_h = max(1, h // 4)\n    top_region = fg[rmin:rmin+top_h, cmin:cmax+1]\n    top_area = float(top_region.size)\n    top_bg_frac = float((top_area - np.count_nonzero(top_region)) / top_area)\n    return top_bg_frac\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Colorfulness metric for RGB images (0 for grayscale)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    if len(image.shape) != 3 or image.shape[2] != 3:\n        return 0.0\n    # use simple Hasler & S\u00fcsstrunk measure\n    R = image[:, :, 0].astype(float)\n    G = image[:, :, 1].astype(float)\n    B = image[:, :, 2].astype(float)\n    rg = R - G\n    yb = 0.5 * (R + G) - B\n    std_rg = float(np.std(rg))\n    std_yb = float(np.std(yb))\n    mean_rg = float(np.mean(np.abs(rg)))\n    mean_yb = float(np.mean(np.abs(yb)))\n    colorfulness = np.sqrt(std_rg * std_rg + std_yb * std_yb) + 0.3 * (mean_rg + mean_yb)\n    return float(colorfulness)\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Ratio of mask area in top half to bottom half (top_area / (bottom_area+eps))'\n    import numpy as np\n    if image is None:\n        return 1.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 1.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    half = h // 2\n    top_area = float(np.count_nonzero(mask[:half, :]))\n    bot_area = float(np.count_nonzero(mask[half:, :]))\n    return float(top_area / (bot_area + 1e-8))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Average per-pixel color saturation (approx) for RGB images, 0 for grayscale'\n    import numpy as np\n    if image is None:\n        return 0.0\n    if len(image.shape) != 3 or image.shape[2] < 3:\n        return 0.0\n    img = image.astype(float)\n    mx = np.max(img, axis=2)\n    mn = np.min(img, axis=2)\n    denom = mx + 1e-8\n    sat = (mx - mn) / denom\n    return float(np.mean(sat))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Top neckline depth: how deep the top center dips inward relative to shoulder tops (positive => deeper neckline)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    thr = np.mean(gray) + 0.15 * np.std(gray)\n    mask = gray > thr\n    if np.count_nonzero(mask) == 0:\n        thr = np.median(gray)\n        mask = gray > thr\n        if np.count_nonzero(mask) == 0:\n            return 0.0\n    # topmost object row per column\n    top_rows = np.full(w, h, dtype=int)\n    for x in range(w):\n        ys = np.where(mask[:, x])[0]\n        top_rows[x] = ys[0] if ys.size > 0 else h\n    # consider center zone and shoulder zones\n    center_zone = slice(int(0.4*w), int(0.6*w))\n    left_shoulder_zone = slice(int(0.05*w), int(0.25*w))\n    right_shoulder_zone = slice(int(0.75*w), int(0.95*w))\n    center_min = np.min(top_rows[center_zone]) if np.any(top_rows[center_zone] < h) else h\n    shoulder_avg = []\n    for s in (left_shoulder_zone, right_shoulder_zone):\n        vals = top_rows[s]\n        vals = vals[vals < h]\n        if vals.size > 0:\n            shoulder_avg.append(np.mean(vals))\n    if len(shoulder_avg) == 0 or center_min == h:\n        return 0.0\n    shoulder_mean = float(np.mean(shoulder_avg))\n    depth = shoulder_mean - center_min  # positive if center dips down relative to shoulders\n    # normalize by height\n    val = depth / float(h) if h > 0 else 0.0\n    return float(val)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Sleeve separation score: how much side mass exceeds center mass in the middle half (positive = distinct sleeves)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    top, bottom = h // 4, 3 * h // 4\n    region = gray[top:bottom, :]\n    thresh = np.mean(region) + 0.2 * np.std(region)\n    mask = (region > thresh).astype(float)\n    if np.sum(mask) < 1e-6:\n        return 0.0\n    # column sums\n    col_sum = np.sum(mask, axis=0)\n    left = col_sum[:w//3].mean() if w//3 > 0 else 0.0\n    center = col_sum[w//3:2*w//3].mean() if (2*w//3 - w//3) > 0 else 0.0\n    right = col_sum[2*w//3:].mean() if w - 2*w//3 > 0 else 0.0\n    score = ((left + right) / 2.0) - center\n    # normalize by maximum possible (height of region)\n    norm = region.shape[0] + 1e-8\n    return float(score / norm)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Aspect ratio of the mask bounding box (height / width)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    ys, xs = np.where(mask)\n    if ys.size == 0:\n        return 0.0\n    ymin, ymax = int(np.min(ys)), int(np.max(ys))\n    xmin, xmax = int(np.min(xs)), int(np.max(xs))\n    box_h = float(max(1, ymax - ymin + 1))\n    box_w = float(max(1, xmax - xmin + 1))\n    return float(box_h / (box_w + 1e-8))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Average object width in the upper quarter normalized by image width (captures sleeve/shoulder breadth)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    thr = float(np.mean(gray)) + 0.2 * (float(np.max(gray)) - float(np.mean(gray)))\n    mask = gray > thr\n    rows = max(1, h // 4)\n    widths = []\n    for r in range(0, rows):\n        row = mask[r, :]\n        if row.any():\n            cols = np.where(row)[0]\n            widths.append((cols[-1] - cols[0] + 1))\n    if not widths:\n        return 0.0\n    avg_width = float(np.mean(widths))\n    return float(avg_width / float(w))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Bounding-box aspect ratio of detected mask normalized by image aspect'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    ys, xs = np.where(mask)\n    if ys.size == 0:\n        return 0.0\n    ymin, ymax = int(np.min(ys)), int(np.max(ys))\n    xmin, xmax = int(np.min(xs)), int(np.max(xs))\n    bb_h = float(max(1, ymax - ymin + 1))\n    bb_w = float(max(1, xmax - xmin + 1))\n    img_aspect = float(h) / float(max(1, w))\n    aspect = bb_h / (bb_w + 1e-8)\n    return float(aspect / (img_aspect + 1e-8))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Foreground elongation: (lambda1 - lambda2)/(lambda1 + lambda2) from 2D covariance of mask coords'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 2 or w < 2:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    pts = np.argwhere(mask).astype(float)\n    if pts.size == 0:\n        return 0.0\n    # coordinates: rows (y) and cols (x)\n    mean = np.mean(pts, axis=0)\n    centered = pts - mean\n    cov = np.dot(centered.T, centered) / float(max(1, centered.shape[0]))\n    # 2x2 covariance; compute eigenvalues analytically for stability\n    a = cov[0, 0]; b = cov[0, 1]; c = cov[1, 1]\n    trace = a + c\n    det = a * c - b * b\n    disc = max(0.0, trace * trace / 4.0 - det)\n    sqrt_disc = np.sqrt(disc)\n    lambda1 = max(1e-8, trace / 2.0 + sqrt_disc)\n    lambda2 = max(1e-8, trace / 2.0 - sqrt_disc)\n    elong = (lambda1 - lambda2) / (lambda1 + lambda2 + 1e-12)\n    return float(elong)\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Height of the continuous object \"sole\" near the bottom center: vertical run length at center columns normalized by image height'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    thr = np.mean(gray)\n    mask = gray > thr\n    if np.count_nonzero(mask) == 0:\n        thr = 0.5 * (np.max(gray) + np.min(gray))\n        mask = gray > thr\n    if np.count_nonzero(mask) == 0:\n        return 0.0\n    rows, cols = np.where(mask)\n    top, bottom = rows.min(), rows.max()\n    left, right = cols.min(), cols.max()\n    center = (left + right) // 2\n    col_slice = mask[top:bottom+1, max(0, center-1):min(w, center+2)]\n    if col_slice.size == 0:\n        return 0.0\n    # start from bottom of bbox, count continuous True rows upward where at least one center column pixel is True\n    v = col_slice[:, :].any(axis=1)\n    # reverse to start at bottom\n    v_rev = v[::-1]\n    run = 0\n    for val in v_rev:\n        if val:\n            run += 1\n        else:\n            if run > 0:\n                break\n    return float(run / h)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Approximate perimeter-to-area ratio of the foreground mask (higher = more complex / thin shapes)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 50)\n    mask = ((gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)).astype(np.uint8)\n    area = float(np.count_nonzero(mask))\n    if area == 0.0:\n        return 0.0\n    # perimeter estimate: mask pixels that have any 4-neighbor background\n    up = np.zeros_like(mask); up[1:, :] = mask[:-1, :]\n    down = np.zeros_like(mask); down[:-1, :] = mask[1:, :]\n    left = np.zeros_like(mask); left[:, 1:] = mask[:, :-1]\n    right = np.zeros_like(mask); right[:, :-1] = mask[:, 1:]\n    neighbor_sum = up + down + left + right\n    boundary = np.logical_and(mask == 1, neighbor_sum < 4)\n    perimeter = float(np.count_nonzero(boundary))\n    return float(perimeter / (area + 1e-8))\n",
    "def feature(image: np.ndarray) -> float:\n    'Ratio of width at 25% down from top to width at 50% (mid); captures tapering profile'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    thr = (np.nanmax(gray) + np.nanmin(gray)) / 2.0\n    mask = gray > thr\n    if mask.sum() == 0:\n        mask = gray > gray.mean()\n    if mask.sum() == 0:\n        mask = gray > (np.max(gray) * 0.01)\n    rows = np.any(mask, axis=1)\n    cols = np.any(mask, axis=0)\n    if not rows.any() or not cols.any():\n        return 1.0\n    r0, r1 = np.where(rows)[0][0], np.where(rows)[0][-1] + 1\n    c0, c1 = np.where(cols)[0][0], np.where(cols)[0][-1] + 1\n    bh = r1 - r0\n    y25 = r0 + int(0.25 * bh)\n    y50 = r0 + int(0.50 * bh)\n    def row_max_run(row_arr):\n        arr = row_arr.astype(int)\n        if arr.sum() == 0:\n            return 0\n        diffs = np.diff(np.concatenate(([0], arr, [0])))\n        starts = np.where(diffs == 1)[0]\n        ends = np.where(diffs == -1)[0]\n        runs = ends - starts\n        return int(np.max(runs)) if runs.size else int(arr.sum())\n    w25 = row_max_run(mask[y25, c0:c1])\n    w50 = row_max_run(mask[y50, c0:c1])\n    if w50 == 0:\n        return float(w25)\n    return float(w25 / w50)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Absolute normalized left-right mass imbalance: |left_mass - right_mass| / total_mass (0..1)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape\n    thr = float(np.mean(gray) * 0.6 + np.min(gray) * 0.4)\n    mask = gray > thr\n    if not mask.any():\n        mask = gray >= np.max(gray)\n    left = np.count_nonzero(mask[:, :w // 2])\n    right = np.count_nonzero(mask[:, w // 2:])\n    total = left + right\n    if total == 0:\n        return 0.0\n    imbalance = abs(left - right) / float(total)\n    return float(imbalance)\n",
    "def feature(image: np.ndarray) -> float:\n    'Left-right horizontal symmetry score (1 - normalized difference) where 1 = perfect symmetry'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    left = gray[:, :w // 2]\n    right = gray[:, (w + 1) // 2:]\n    # mirror right to compare\n    if right.shape[1] != left.shape[1]:\n        # pad the smaller side\n        if right.shape[1] < left.shape[1]:\n            pad = left.shape[1] - right.shape[1]\n            right = np.pad(right, ((0, 0), (pad, 0)), mode='constant', constant_values=0)\n        else:\n            pad = right.shape[1] - left.shape[1]\n            left = np.pad(left, ((0, 0), (pad, 0)), mode='constant', constant_values=0)\n    right_flipped = np.fliplr(right)\n    diff = np.abs(left - right_flipped)\n    score = 1.0 - (np.mean(diff) / max(1e-6, np.mean(np.abs(gray))))\n    return float(max(0.0, min(1.0, score)))\n",
    "def feature(image: np.ndarray) -> float:\n    'Normalized distance between upper-half and lower-half centroids (0..1)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 2 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    if not np.any(mask):\n        return 0.0\n    mid = h // 2\n    top_mask = mask[:mid, :]\n    bottom_mask = mask[mid:, :]\n    def centroid(m, offset_y=0):\n        ys, xs = np.where(m)\n        if ys.size == 0:\n            return None\n        return (np.mean(xs).item(), np.mean(ys).item() + offset_y)\n    ctop = centroid(top_mask, offset_y=0)\n    cbottom = centroid(bottom_mask, offset_y=mid)\n    if ctop is None or cbottom is None:\n        return 0.0\n    dx = ctop[0] - cbottom[0]\n    dy = ctop[1] - cbottom[1]\n    dist = np.sqrt(dx*dx + dy*dy)\n    return float(dist / (float(h) + 1e-8))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Slope of object horizontal width across the top quarter (negative if shoulders taper quickly) normalized by bounding-box width'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape\n    mn, mx = float(np.min(gray)), float(np.max(gray))\n    if mx - mn < 1e-6:\n        return 0.0\n    thr = mn + 0.20 * (mx - mn)\n    mask = gray > thr\n    if not mask.any():\n        return 0.0\n    rows, cols = np.where(mask)\n    r0, r1 = rows.min(), rows.max() + 1\n    c0, c1 = cols.min(), cols.max() + 1\n    bh = max(1, r1 - r0)\n    # sample at up to five rows between top and top+1/4 of bbox\n    sample_count = 5\n    heights = []\n    widths = []\n    for i in range(sample_count):\n        rr = r0 + int((i / (sample_count - 1)) * max(0, (bh // 4)))\n        row_mask = mask[rr, c0:c1]\n        widths.append(float(row_mask.sum()))\n        heights.append(float(rr - r0))\n    if len(widths) < 2:\n        return 0.0\n    # linear fit slope of width vs height\n    heights = np.array(heights)\n    widths = np.array(widths)\n    # avoid degenerate\n    if np.ptp(heights) < 1e-6:\n        return 0.0\n    m = np.cov(heights, widths)[0, 1] / (np.var(heights) + 1e-9)\n    # normalize by bbox width\n    norm = float(max(1.0, (c1 - c0)))\n    return float(m / norm)\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Normalized L1 left-right symmetry score for the top half of the object (lower = more symmetric)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    mean, mx = np.mean(gray), np.max(gray)\n    thr = mean + 0.15 * (mx - mean)\n    mask = gray > thr\n    if not np.any(mask):\n        thr = np.percentile(gray, 90)\n        mask = gray > thr\n    if not np.any(mask):\n        return 1.0\n    rows_any = np.any(mask, axis=1)\n    rmin = int(np.argmax(rows_any))\n    rmax = int(len(rows_any) - np.argmax(rows_any[::-1]) - 1)\n    if rmax <= rmin:\n        return 1.0\n    bbox = mask[rmin:rmax+1, :]\n    top_half = bbox[:max(1, bbox.shape[0]//2), :]\n    # center column in bounding box coordinates\n    c = top_half.shape[1] // 2\n    left = top_half[:, :c]\n    right = top_half[:, -c:] if c > 0 else np.zeros_like(left)\n    # flip right horizontally\n    if right.size == 0 or left.size == 0:\n        return 1.0\n    right_flipped = np.fliplr(right)\n    # pad smaller to match\n    if left.shape != right_flipped.shape:\n        minr = min(left.shape[0], right_flipped.shape[0])\n        minc = min(left.shape[1], right_flipped.shape[1])\n        left = left[:minr, :minc]\n        right_flipped = right_flipped[:minr, :minc]\n    diff = np.abs(left.astype(float) - right_flipped.astype(float))\n    score = diff.sum() / (left.size + 1e-9)\n    # normalize by average occupancy\n    norm = (np.mean(top_half.astype(float)) + 1e-9)\n    return float(score / norm)\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Perimeter-to-area compactness of the mask (higher => more complex / spiky shape)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 50)\n    mask = ((gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)).astype(np.uint8)\n    area = float(np.count_nonzero(mask))\n    if area <= 0.0:\n        return 0.0\n    # perimeter approximation via 4-neighbor boundary pixels\n    up = np.zeros_like(mask); up[1:, :] = mask[:-1, :]\n    down = np.zeros_like(mask); down[:-1, :] = mask[1:, :]\n    left = np.zeros_like(mask); left[:, 1:] = mask[:, :-1]\n    right = np.zeros_like(mask); right[:, :-1] = mask[:, 1:]\n    boundary = mask & ((up == 0) | (down == 0) | (left == 0) | (right == 0))\n    perimeter = float(np.count_nonzero(boundary))\n    result = (perimeter * perimeter) / (area + 1e-8)\n    return float(result)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Relative concentration of foreground in the top-center strip (useful to detect bag handles)'\n    import numpy as np\n    gray = np.mean(image, axis=2) if len(image.shape) == 3 else image.astype(float)\n    h, w = gray.shape[:2]\n    thr = (np.max(gray) + np.min(gray)) / 2.0\n    mask = gray > thr\n    top_h = max(1, h // 6)\n    top_strip = mask[:top_h, :]\n    if top_strip.size == 0:\n        return 0.0\n    # center third horizontally\n    c1, c2 = w//3, 2*w//3\n    center_top = top_strip[:, c1:c2]\n    # return fraction of top-strip foreground that lies in center region\n    top_fg = np.sum(top_strip)\n    center_fg = np.sum(center_top)\n    if top_fg == 0:\n        return 0.0\n    return float(center_fg / top_fg)\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Vertical symmetry score: normalized mean absolute difference between top and flipped bottom (higher = more asymmetric)'\n    import numpy as np\n    eps = 1e-8\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(np.float32)\n    else:\n        gray = image.astype(np.float32)\n    mn, mx = float(np.min(gray)), float(np.max(gray))\n    if mx > mn:\n        gray = (gray - mn) / (mx - mn)\n    else:\n        gray = gray * 0.0\n    fg = gray > 0.2\n    ys, xs = np.where(fg)\n    if ys.size == 0:\n        return 0.0\n    rmin, rmax = int(ys.min()), int(ys.max())\n    cmin, cmax = int(xs.min()), int(xs.max())\n    region = gray[rmin:rmax+1, cmin:cmax+1]\n    H = region.shape[0]\n    if H < 2:\n        return 0.0\n    mid = H // 2\n    top = region[:mid, :]\n    bottom = region[-mid:, :] if mid > 0 else region[:mid, :]\n    # make same shape\n    if top.shape != bottom.shape:\n        minr = min(top.shape[0], bottom.shape[0])\n        top = top[:minr, :]\n        bottom = bottom[-minr:, :]\n    bottom_flipped = np.flipud(bottom)\n    diff = np.abs(top - bottom_flipped)\n    norm = float(np.mean(np.abs(top)) + eps)\n    score = float(np.mean(diff) / norm)\n    return score\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Proportion of mask pixels located in the bottom 20% of the image'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 50)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    total = float(np.count_nonzero(mask))\n    if total <= 0:\n        return 0.0\n    bottom_start = max(0, int(h * 0.8))\n    bottom_mask = mask[bottom_start:, :]\n    bottom_count = float(np.count_nonzero(bottom_mask))\n    return float(bottom_count / (total + 1e-8))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Major/minor axis ratio of mask point cloud (eigenvalue ratio of covariance)'\n    import numpy as np\n    if image is None:\n        return 1.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 1.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    ys, xs = np.where(mask)\n    if ys.size <= 1:\n        return 1.0\n    coords = np.vstack([xs.astype(float), ys.astype(float)])\n    cov = np.cov(coords)\n    # handle degenerate covariance\n    try:\n        vals = np.linalg.eigvalsh(cov)\n    except Exception:\n        return 1.0\n    vals = np.sort(vals)\n    small = max(vals[0], 1e-8)\n    large = max(vals[-1], small)\n    return float(large / small)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Relative top width: number of occupied columns in the top 10% of the bbox divided by bbox width (detects handles/straps)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    if gray.size == 0:\n        return 0.0\n    thr = 0.5 * (np.nanmax(gray) + np.nanmin(gray))\n    binary = gray > thr\n    ys, xs = np.where(binary)\n    if ys.size == 0:\n        return 0.0\n    ymin, ymax = ys.min(), ys.max()\n    xmin, xmax = xs.min(), xs.max()\n    bbox = binary[ymin:ymax+1, xmin:xmax+1]\n    bh, bw = bbox.shape\n    if bw == 0:\n        return 0.0\n    top_rows = max(1, int(np.ceil(0.10 * bh)))\n    top_slice = bbox[:top_rows, :]\n    nonempty_top_cols = np.sum(np.any(top_slice, axis=0))\n    return float(nonempty_top_cols / (bw + 1e-6))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Average horizontal distance from centerline to object edge in shoulder rows (larger -> narrower torso/long sleeves), normalized by bbox width'\n    import numpy as np\n    eps = 1e-8\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    thr = np.mean(gray) + 0.5 * np.std(gray)\n    mask = gray > thr\n    if not np.any(mask):\n        mask = gray > np.mean(gray)\n    if not np.any(mask):\n        return 0.0\n    ys, xs = np.where(mask)\n    top, bottom = ys.min(), ys.max()\n    left, right = xs.min(), xs.max()\n    bbox_h = bottom - top + 1\n    bbox_w = max(1, right - left + 1)\n    center_col = left + bbox_w // 2\n    # shoulder region: rows between top+5% and top+25% of bbox\n    r0 = top + max(0, int(0.05 * bbox_h))\n    r1 = top + max(1, int(0.25 * bbox_h))\n    dists = []\n    for r in range(r0, min(r1, bottom+1)):\n        row = mask[r, left:right+1]\n        if not np.any(row):\n            continue\n        cols = np.where(row)[0] + left\n        # distance from center to nearest object pixel on left and right\n        left_edges = cols[cols <= center_col]\n        right_edges = cols[cols >= center_col]\n        left_dist = center_col - left_edges.max() if left_edges.size>0 else bbox_w/2\n        right_dist = right_edges.min() - center_col if right_edges.size>0 else bbox_w/2\n        dists.append(min(left_dist, right_dist))\n    if len(dists) == 0:\n        return 0.0\n    avg = float(np.mean(dists))\n    return float(avg / (bbox_w + eps))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Ratio of average foreground width in the top quarter of the bbox to the average width at mid-height (shoulder/waist width ratio)'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    t = 0.6 * np.mean(gray) + 0.4 * np.min(gray)\n    mask = gray > t\n    if np.count_nonzero(mask) == 0:\n        return 0.0\n    rows, cols = np.nonzero(mask)\n    r0, r1 = rows.min(), rows.max()\n    c0, c1 = cols.min(), cols.max()\n    bh = r1 - r0 + 1\n    bw = c1 - c0 + 1\n    if bh <= 3 or bw <= 1:\n        return 0.0\n    top_h = max(1, bh // 4)\n    mid_start = r0 + bh // 3\n    mid_end = r0 + (bh * 2) // 3\n    # compute row-wise widths\n    def avg_width(rstart, rend):\n        widths = []\n        for r in range(rstart, min(rend + 1, r1 + 1)):\n            row = mask[r, c0:c1+1]\n            nz = np.nonzero(row)[0]\n            if nz.size > 0:\n                widths.append(float(nz.max() - nz.min() + 1))\n        return float(np.mean(widths)) if len(widths) > 0 else 0.0\n    top_w = avg_width(r0, r0 + top_h - 1)\n    mid_w = avg_width(mid_start, mid_end)\n    if mid_w <= 1e-6:\n        return float(top_w)\n    return float(top_w / mid_w)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Relative variability (std/mean) of horizontal widths across upper half rows (higher => irregular top)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 2 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    upper = mask[:max(1, h // 2), :]\n    if upper.size == 0:\n        return 0.0\n    widths = np.count_nonzero(upper, axis=1).astype(float) / max(1.0, w)\n    mean_w = float(np.mean(widths))\n    std_w = float(np.std(widths))\n    return float(std_w / (mean_w + 1e-8))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Average maximal consecutive vertical run-length of foreground per column (normalized by image height)'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    thresh = float(np.percentile(gray, 50)) if gray.size > 0 else 0.0\n    mask = gray > thresh\n    if not np.any(mask):\n        return 0.0\n    h, w = mask.shape\n    run_lengths = []\n    for c in range(w):\n        col = mask[:, c]\n        max_run = 0\n        run = 0\n        for v in col:\n            if v:\n                run += 1\n            else:\n                if run > max_run:\n                    max_run = run\n                run = 0\n        if run > max_run:\n            max_run = run\n        if max_run > 0:\n            run_lengths.append(max_run)\n    if len(run_lengths) == 0:\n        return 0.0\n    avg_run = float(np.mean(run_lengths))\n    return float(avg_run / max(1, h))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Global fill fraction inside the tight bounding box of the object (object area / bbox area)'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    thresh = np.percentile(gray, 50)\n    binary = gray > thresh\n    ys, xs = np.nonzero(binary)\n    if ys.size == 0:\n        return 0.0\n    y0, y1 = ys.min(), ys.max()\n    x0, x1 = xs.min(), xs.max()\n    bbox = binary[y0:y1+1, x0:x1+1]\n    area = np.count_nonzero(bbox)\n    bbox_area = bbox.size\n    return float(area / (bbox_area + 1e-9))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Contrast between interior of foreground bounding box and its immediate border (border_mean - inner_mean) normalized'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = gray < thr if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else gray > thr\n    rows_any = np.any(mask, axis=1)\n    cols_any = np.any(mask, axis=0)\n    if not np.any(rows_any) or not np.any(cols_any):\n        return 0.0\n    rmin = int(np.argmax(rows_any))\n    rmax = int(len(rows_any) - 1 - np.argmax(rows_any[::-1]))\n    cmin = int(np.argmax(cols_any))\n    cmax = int(len(cols_any) - 1 - np.argmax(cols_any[::-1]))\n    # inner box\n    rmin, rmax = max(0, rmin), min(h - 1, rmax)\n    cmin, cmax = max(0, cmin), min(w - 1, cmax)\n    if rmax < rmin or cmax < cmin:\n        return 0.0\n    inner = gray[rmin:rmax + 1, cmin:cmax + 1]\n    # border box: expand by 5% of dims\n    pad_r = max(1, (rmax - rmin + 1) // 20)\n    pad_c = max(1, (cmax - cmin + 1) // 20)\n    ormin = max(0, rmin - pad_r)\n    ormax = min(h - 1, rmax + pad_r)\n    ocmin = max(0, cmin - pad_c)\n    ocmax = min(w - 1, cmax + pad_c)\n    outer = gray[ormin:ormax + 1, ocmin:ocmax + 1]\n    # border region is outer minus inner\n    if outer.size == 0 or inner.size == 0:\n        return 0.0\n    # compute means\n    inner_mean = float(np.mean(inner))\n    outer_mean = float(np.mean(outer))\n    border_mean = (outer_mean * outer.size - inner_mean * inner.size) / max(1.0, float(outer.size - inner.size))\n    denom = (abs(border_mean) + 1e-8)\n    return float((border_mean - inner_mean) / denom)\n",
    "def feature(image: np.ndarray) -> float:\n    'Number of horizontal connected components (contiguous column groups with foreground)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    cols_any = np.any(mask, axis=0)\n    if cols_any.size == 0 or not np.any(cols_any):\n        return 0.0\n    # count rising edges 0->1 in columns\n    padded = np.concatenate([[False], cols_any.astype(bool)])\n    transitions = np.diff(padded.astype(int))\n    comps = np.count_nonzero(transitions == 1)\n    return float(comps)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Bounding-box aspect ratio of the detected foreground mask (width / height)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 50)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    ys, xs = np.where(mask)\n    if ys.size == 0:\n        return 0.0\n    miny, maxy = int(ys.min()), int(ys.max())\n    minx, maxx = int(xs.min()), int(xs.max())\n    bw = maxx - minx + 1\n    bh = maxy - miny + 1\n    if bh <= 0:\n        return 0.0\n    return float(bw / float(bh))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Estimated sole thickness: number of contiguous foreground rows at the bottom before a large width drop'\n    import numpy as np\n    h, w = image.shape[:2]\n    gray = np.mean(image, axis=2) if image.ndim == 3 else image.astype(float)\n    thr = max(np.percentile(gray, 70), np.mean(gray) * 0.4, 1e-6)\n    fg = gray > thr\n    # compute row widths\n    row_widths = np.sum(fg, axis=1)\n    if np.max(row_widths) == 0:\n        return 0.0\n    bottom = h - 1\n    # find bottom-most row that has any foreground\n    while bottom >= 0 and row_widths[bottom] == 0:\n        bottom -= 1\n    if bottom < 0:\n        return 0.0\n    max_width = np.max(row_widths)\n    # count continuous rows upwards from bottom while row_width >= 0.5 * max_width\n    thickness = 0\n    for r in range(bottom, -1, -1):\n        if row_widths[r] >= 0.5 * max_width and row_widths[r] > 0:\n            thickness += 1\n        else:\n            break\n    return float(thickness)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Normalized object width estimate from horizontal projection of a simple intensity-based mask (0..1)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    gmin, gmax = np.min(gray), np.max(gray)\n    rng = gmax - gmin\n    # threshold relative to range\n    thr = gmin + 0.15 * (rng if rng > 0 else 1.0)\n    mask = gray < thr  # assume object darker than background; if not, still informative\n    col_counts = np.sum(mask, axis=0)\n    # consider a column part of object if it has at least 10% of rows marked\n    col_thresh = max(1, int(0.10 * h))\n    cols_obj = np.count_nonzero(col_counts >= col_thresh)\n    return float(cols_obj) / float(w)\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Row index (normalized 0..1) with maximal horizontal edge energy (where object has strongest horizontal edges)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    gy, gx = np.gradient(gray.astype(float))\n    # horizontal edges correspond to vertical gradient (gy) magnitude\n    row_energy = np.sum(np.abs(gy), axis=1)\n    if np.all(row_energy == 0):\n        return 0.0\n    peak_row = int(np.argmax(row_energy))\n    return float(peak_row) / float(max(1, h - 1))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Normalized entropy of the column-sum distribution across the whole object bounding box (0..1), higher indicates more complex horizontal silhouette'\n    import numpy as np\n    gray = np.mean(image, axis=2) if len(image.shape) == 3 else image.astype(float)\n    mn, mx = float(np.min(gray)), float(np.max(gray))\n    if mx == mn:\n        return 0.0\n    thr = 0.5 * (mn + mx)\n    bin_img = (gray > thr).astype(np.uint8)\n    ys, xs = np.where(bin_img)\n    if ys.size == 0:\n        return 0.0\n    top, bottom = ys.min(), ys.max()\n    left, right = xs.min(), xs.max()\n    region = bin_img[top:bottom+1, left:right+1]\n    if region.size == 0:\n        return 0.0\n    col_sums = region.sum(axis=0).astype(float)\n    total = col_sums.sum()\n    if total <= 0:\n        return 0.0\n    p = col_sums / total\n    # avoid log(0)\n    p_nonzero = p[p > 0]\n    entropy = -np.sum(p_nonzero * np.log(p_nonzero))\n    # normalize by log(ncols)\n    denom = np.log(max(2, p.size))\n    normalized = entropy / denom\n    return float(normalized)\n",
    "def feature(image: np.ndarray) -> float:\n    'Count of connected mask components (flood fill) normalized by image area'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    visited = np.zeros_like(mask, dtype=bool)\n    comps = 0\n    for y in range(h):\n        for x in range(w):\n            if mask[y, x] and not visited[y, x]:\n                comps += 1\n                # flood fill stack\n                stack = [(y, x)]\n                visited[y, x] = True\n                while stack:\n                    yy, xx = stack.pop()\n                    if yy > 0 and mask[yy - 1, xx] and not visited[yy - 1, xx]:\n                        visited[yy - 1, xx] = True\n                        stack.append((yy - 1, xx))\n                    if yy + 1 < h and mask[yy + 1, xx] and not visited[yy + 1, xx]:\n                        visited[yy + 1, xx] = True\n                        stack.append((yy + 1, xx))\n                    if xx > 0 and mask[yy, xx - 1] and not visited[yy, xx - 1]:\n                        visited[yy, xx - 1] = True\n                        stack.append((yy, xx - 1))\n                    if xx + 1 < w and mask[yy, xx + 1] and not visited[yy, xx + 1]:\n                        visited[yy, xx + 1] = True\n                        stack.append((yy, xx + 1))\n    area = float(h * w)\n    return float(comps / (area + 1e-8))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Flatness of the top contour measured by std deviation of top-most nonzero row per column normalized by bbox height (lower => flatter top)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    mx = float(np.max(gray))\n    if mx <= 0:\n        return 0.0\n    thresh = max(mx * 0.05, np.percentile(gray, 1.0))\n    mask = gray > thresh\n    if not np.any(mask):\n        return 0.0\n    ys, xs = np.where(mask)\n    r0, r1 = ys.min(), ys.max()\n    c0, c1 = xs.min(), xs.max()\n    bbox = mask[r0:r1 + 1, c0:c1 + 1]\n    h = bbox.shape[0]\n    top_rows = []\n    for col in range(bbox.shape[1]):\n        col_idxs = np.where(bbox[:, col])[0]\n        if col_idxs.size > 0:\n            top_rows.append(int(col_idxs.min()))\n    if len(top_rows) == 0:\n        return 0.0\n    std_top = float(np.std(top_rows))\n    return float(std_top) / float(h + 1e-8)\n",
    "def feature(image: np.ndarray) -> float:\n    'Normalized texture contrast: std of intensities in a center box divided by global std (pullover knitiness vs smooth shirts)'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    h, w = gray.shape\n    if h == 0 or w == 0:\n        return 0.0\n    ch1, ch2 = h // 3, w // 3\n    center = gray[ch1: h - ch1, ch2: w - ch2]\n    if center.size == 0:\n        return 0.0\n    std_center = float(np.std(center))\n    std_global = float(np.std(gray)) + 1e-8\n    return std_center / std_global\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Left-right symmetry of the foreground mask (1.0 = perfectly symmetric)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    # convert to gray\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 50)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    area = np.count_nonzero(mask)\n    if area == 0:\n        return 0.0\n    flipped = np.fliplr(mask)\n    overlap = np.count_nonzero(mask & flipped)\n    # normalize by average area to be robust to slight cropping\n    denom = float(area + np.count_nonzero(flipped)) / 2.0 + 1e-8\n    return float(overlap / denom)\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Colorfulness metric for RGB images (0 for grayscale)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    if len(image.shape) != 3 or image.shape[2] < 3:\n        return 0.0\n    img = image.astype(float)\n    R = img[:, :, 0]\n    G = img[:, :, 1]\n    B = img[:, :, 2]\n    # Hasler & Suesstrunk colorfulness measure\n    rg = R - G\n    yb = 0.5 * (R + G) - B\n    std_rg = float(np.std(rg))\n    std_yb = float(np.std(yb))\n    mean_rg = float(np.mean(np.abs(rg)))\n    mean_yb = float(np.mean(np.abs(yb)))\n    colorfulness = np.sqrt(std_rg ** 2 + std_yb ** 2) + 0.3 * (mean_rg + mean_yb)\n    # normalize by pixel value range if likely 0-255\n    denom = 255.0 if img.max() > 50 else (img.max() + 1e-8)\n    return float(colorfulness / (denom + 1e-8))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Fill ratio of the object within its bounding box (object_area / bbox_area)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    thresh = 0.5 * np.mean(gray) + 0.5 * np.min(gray)\n    mask = gray > thresh\n    ys, xs = np.nonzero(mask)\n    if ys.size == 0:\n        return 0.0\n    r0, r1 = int(np.min(ys)), int(np.max(ys))\n    c0, c1 = int(np.min(xs)), int(np.max(xs))\n    bbox_area = max(1, (r1 - r0 + 1) * (c1 - c0 + 1))\n    area = np.count_nonzero(mask)\n    return float(area / bbox_area)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Depth of a central vertical gap in the lower half (normalized): (sides - middle)/sides, useful for trousers'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    if h < 4 or w < 3:\n        return 0.0\n    lower = gray[h//2:, :]\n    col_sum = lower.sum(axis=0)\n    if col_sum.size == 0:\n        return 0.0\n    third = max(1, w//3)\n    left_avg = float(col_sum[0:third].mean())\n    right_avg = float(col_sum[w-third:w].mean())\n    middle_min = float(col_sum[third:w-third].min()) if w - 2*third > 0 else float(col_sum.min())\n    side_mean = (left_avg + right_avg) / 2.0\n    if side_mean <= 0:\n        return 0.0\n    gap = (side_mean - middle_min) / (side_mean + 1e-9)\n    return float(max(0.0, gap))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Top-edge roughness: std dev of topmost object row indices across the central half of columns (normalized)'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    h, w = gray.shape[:2]\n    thresh = (np.mean(gray) + np.min(gray)) / 2.0\n    mask = gray > thresh\n    c1, c2 = w // 4, max(w // 4 + 1, 3 * w // 4)\n    top_rows = []\n    for c in range(c1, c2):\n        col = mask[:, c]\n        idxs = np.where(col)[0]\n        top_rows.append(int(idxs[0]) if idxs.size > 0 else h)\n    if len(top_rows) == 0:\n        return 0.0\n    top_rows = np.array(top_rows)\n    valid = top_rows < h\n    if not valid.any():\n        return 0.0\n    std = float(np.std(top_rows[valid]))\n    return float(std / max(1.0, h))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Ratio of bottom-quarter median width to maximum row width (toe width relative to max)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(np.float32)\n    else:\n        gray = image.astype(np.float32)\n    mn, mx = float(np.min(gray)), float(np.max(gray))\n    if mx > mn:\n        gray = (gray - mn) / (mx - mn)\n    else:\n        gray = gray * 0.0\n    fg = gray > 0.2\n    ys, xs = np.where(fg)\n    if ys.size == 0:\n        return 0.0\n    rmin, rmax = int(ys.min()), int(ys.max())\n    cmin, cmax = int(xs.min()), int(xs.max())\n    region = fg[rmin:rmax+1, cmin:cmax+1]\n    H = region.shape[0]\n    row_widths = np.sum(region, axis=1).astype(np.float32)\n    if row_widths.size == 0:\n        return 0.0\n    max_w = float(row_widths.max())\n    bottom_slice = max(1, H // 10)\n    bottom_med = float(np.median(row_widths[-bottom_slice:]))\n    if max_w <= 0.0:\n        return 0.0\n    return float(bottom_med / max_w)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Count of pronounced peaks across columns in the lower half (2 peaks often => trousers)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    import numpy as np\n    h, w = image.shape[:2]\n    if h < 4 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = ((gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)).astype(np.uint8)\n    lower = mask[h // 2:, :]\n    if lower.size == 0:\n        return 0.0\n    col_sums = np.sum(lower, axis=0).astype(float)\n    maxv = float(np.max(col_sums)) if col_sums.size else 0.0\n    if maxv <= 0:\n        return 0.0\n    # normalized profile\n    prof = col_sums / (maxv + 1e-8)\n    # find local maxima above threshold\n    thresh = 0.25\n    peaks = 0\n    for i in range(1, prof.size - 1):\n        if prof[i] > prof[i - 1] and prof[i] > prof[i + 1] and prof[i] > thresh:\n            peaks += 1\n    return float(peaks)\n",
    "def feature(image: np.ndarray) -> float:\n    'Mean intensity difference between top quarter and bottom quarter (top - bottom)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 4:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    top = gray[:h // 4, :]\n    bottom = gray[3 * h // 4:, :]\n    if top.size == 0 or bottom.size == 0:\n        return 0.0\n    top_mean = float(np.mean(top))\n    bottom_mean = float(np.mean(bottom))\n    # normalize by overall brightness range\n    rng = float(np.max(gray) - np.min(gray) + 1e-8)\n    return float((top_mean - bottom_mean) / rng)\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Vertical centroid of the mask relative to image center (positive if lower than center)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 50)\n    mask = gray < thr if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else gray > thr\n    ys, xs = np.where(mask)\n    if ys.size == 0:\n        return 0.0\n    y_cent = float(np.mean(ys))\n    # normalized to [-0.5, 0.5]\n    return float((y_cent / float(h)) - 0.5)\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Perceived colorfulness metric (0 for grayscale images)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    if len(image.shape) != 3 or image.shape[2] < 3:\n        return 0.0\n    img = image.astype(float)\n    R = img[:, :, 0]\n    G = img[:, :, 1]\n    B = img[:, :, 2]\n    rg = R - G\n    yb = 0.5 * (R + G) - B\n    std_rg = np.std(rg)\n    std_yb = np.std(yb)\n    mean_rg = np.mean(rg)\n    mean_yb = np.mean(yb)\n    colorfulness = np.sqrt(std_rg ** 2 + std_yb ** 2) + 0.3 * np.sqrt(mean_rg ** 2 + mean_yb ** 2)\n    return float(colorfulness)\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Vertical symmetry score: normalized mean absolute difference between top and mirrored bottom half (0 = identical)'\n    import numpy as np\n    if image is None:\n        return 1.0\n    h, w = image.shape[:2]\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    mid = h // 2\n    top = gray[:mid, :]\n    bottom = gray[h - mid:h, :]\n    if top.size == 0 or bottom.size == 0:\n        return 1.0\n    bottom_flipped = np.flipud(bottom)\n    if top.shape != bottom_flipped.shape:\n        mnh = min(top.shape[0], bottom_flipped.shape[0])\n        top = top[:mnh, :]\n        bottom_flipped = bottom_flipped[:mnh, :]\n    diff = np.abs(top - bottom_flipped)\n    denom = np.maximum(np.mean(gray) + 1e-8, 1e-8)\n    return float(np.mean(diff) / denom)\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Mean color saturation inside foreground mask for RGB images (0 for grayscale)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    if len(image.shape) != 3 or image.shape[2] < 3:\n        return 0.0\n    h, w, c = image.shape\n    if h == 0 or w == 0:\n        return 0.0\n    img = image.astype(float)\n    mx = np.max(img, axis=2)\n    mn = np.min(img, axis=2)\n    sat = (mx - mn) / (mx + 1e-8)\n    gray = np.mean(img, axis=2)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    if not np.any(mask):\n        return 0.0\n    mean_sat = float(np.mean(sat[mask]))\n    return float(mean_sat)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Absolute left-right imbalance in the bottom half of the object normalized by the bottom mass (asymmetric heels/straps)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape\n    if h == 0:\n        return 0.0\n    thr = np.mean(gray) + 0.25 * np.std(gray)\n    mask = gray > thr\n    if not np.any(mask):\n        mask = gray > np.percentile(gray, 80)\n    if not np.any(mask):\n        return 0.0\n    # focus on bottom half of bounding box\n    rows = np.where(np.any(mask, axis=1))[0]\n    cols = np.where(np.any(mask, axis=0))[0]\n    if rows.size == 0 or cols.size == 0:\n        return 0.0\n    rmin, rmax = rows[0], rows[-1]\n    cmin, cmax = cols[0], cols[-1]\n    bh = rmax - rmin + 1\n    bottom_start = rmin + bh // 2\n    bottom_region = mask[bottom_start:rmax + 1, cmin:cmax + 1]\n    if bottom_region.size == 0:\n        return 0.0\n    mid = bottom_region.shape[1] // 2\n    left = float(np.count_nonzero(bottom_region[:, :mid]))\n    right = float(np.count_nonzero(bottom_region[:, mid:]))\n    denom = left + right + 1e-9\n    return float(abs(left - right) / denom)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Mean per-channel standard deviation (colorfulness); returns 0 for grayscale'\n    import numpy as np\n    if image is None:\n        return 0.0\n    if len(image.shape) != 3:\n        return 0.0\n    img = image.astype(float)\n    # compute std across spatial dims for each channel\n    channel_stds = [float(np.std(img[:, :, c])) for c in range(img.shape[2])]\n    if len(channel_stds) == 0:\n        return 0.0\n    return float(np.mean(channel_stds))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Fraction of the foreground mask pixels located in the bottom 15% of the image (shoe indicator)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 60)\n    mask = gray < thr if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else gray > thr\n    total = np.count_nonzero(mask)\n    if total == 0:\n        return 0.0\n    bottom_h = max(1, h * 15 // 100)\n    bottom_mask = mask[-bottom_h:, :]\n    bottom_count = np.count_nonzero(bottom_mask)\n    return float(bottom_count / float(total))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Vertical centroid of object (0.0 top, 1.0 bottom), useful to tell tops vs trousers vs dresses'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    rng = float(np.max(gray) - np.min(gray))\n    thr = float(np.mean(gray) + 0.05 * rng)\n    mask = (gray > thr).astype(float)\n    total = mask.sum()\n    if total <= 0:\n        return 0.5\n    rows = np.arange(h).reshape((h, 1))\n    weighted = (mask.sum(axis=1) * rows.flatten()).sum()\n    centroid = float(weighted / (total + 1e-8))\n    return float(centroid / max(1.0, h-1))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Left-right mirror symmetry score of the foreground mask (1.0 = perfect symmetry)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if w == 0 or h == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = ((gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)).astype(bool)\n    if not np.any(mask):\n        return 0.0\n    flipped = np.fliplr(mask)\n    # align centers; compute overlap\n    overlap = np.count_nonzero(mask & flipped)\n    area = float(np.count_nonzero(mask))\n    return float(overlap / (area + 1e-8))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Fill ratio of the object inside its bounding box: object area divided by bbox area (dense garments vs open coats)'\n    import numpy as np\n    gray = np.mean(image, axis=2) if len(image.shape) == 3 else image.astype(float)\n    h, w = gray.shape[:2]\n    cs = max(1, min(h, w) // 12)\n    bg = np.median([np.mean(gray[0:cs,0:cs]), np.mean(gray[0:cs,-cs:]), np.mean(gray[-cs:,0:cs]), np.mean(gray[-cs:,-cs:])])\n    thr = bg + max(8.0, 0.07 * (gray.max() - bg))\n    mask = gray > thr\n    if mask.sum() == 0:\n        thr = np.percentile(gray, 70)\n        mask = gray > thr\n    if mask.sum() == 0:\n        return 0.0\n    rows, cols = np.where(mask)\n    top, bottom = rows.min(), rows.max()\n    left, right = cols.min(), cols.max()\n    bbox_area = (bottom - top + 1) * (right - left + 1)\n    if bbox_area <= 0:\n        return 0.0\n    return float(mask.sum() / (bbox_area + 1e-9))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Texture roughness: variance of image Laplacian inside mask (higher = more textured)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 2 or w < 2:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    # compute Laplacian via second derivatives\n    gy, gx = np.gradient(gray)\n    gxx = np.gradient(gx, axis=1)\n    gyy = np.gradient(gy, axis=0)\n    lap = gxx + gyy\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    if np.any(mask):\n        vals = lap[mask]\n    else:\n        vals = lap.flatten()\n    if vals.size == 0:\n        return 0.0\n    return float(np.var(vals))\n",
    "def feature(image: np.ndarray) -> float:\n    'Median number of vertical connected segments per column (approx. component count)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 2 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 50)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    counts = []\n    for c in range(w):\n        col = mask[:, c].astype(np.int8)\n        if np.all(col == 0):\n            continue\n        # count rising edges (0->1)\n        dif = np.diff(np.concatenate(([0], col)))\n        starts = np.count_nonzero(dif == 1)\n        counts.append(float(starts))\n    if len(counts) == 0:\n        return 0.0\n    med = float(np.median(np.array(counts)))\n    # normalize by possible maximum segments (h/2)\n    return float(med / max(1.0, float(h) / 2.0))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Fraction of object pixels that lie in the bottom third and within central 40% horizontally (central skirt mass)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape\n    thr = np.percentile(gray, 65)\n    mask = gray > thr\n    total = np.count_nonzero(mask)\n    if total == 0:\n        return 0.0\n    row0 = max(0, (2*h)//3)\n    col0 = max(0, int(w*0.3))\n    col1 = min(w, int(w*0.7))\n    region_count = np.count_nonzero(mask[row0:h, col0:col1])\n    return float(region_count / float(total))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Bottom-flatness score: 1.0 if bottom contour is perfectly flat, 0 if very jagged (based on std of bottom row positions)'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    thr = (np.max(gray) + np.min(gray)) * 0.5\n    mask = (gray > thr).astype(np.uint8)\n    ys, xs = np.where(mask)\n    if ys.size == 0:\n        return 0.0\n    y0, y1 = ys.min(), ys.max()\n    x0, x1 = xs.min(), xs.max()\n    crop = mask[y0:y1+1, x0:x1+1]\n    h, w = crop.shape\n    bottoms = np.full(w, -1, dtype=np.int32)\n    for col in range(w):\n        col_inds = np.where(crop[:, col] > 0)[0]\n        if col_inds.size > 0:\n            bottoms[col] = col_inds.max()\n    valid = bottoms >= 0\n    if not np.any(valid):\n        return 0.0\n    std_bottoms = float(np.std(bottoms[valid]))\n    std_norm = std_bottoms / max(1.0, float(h))\n    flatness = 1.0 - std_norm\n    return float(max(0.0, min(1.0, flatness)))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Left-right symmetry score (mean absolute difference between left and mirrored right, normalized)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    # crop to even width for simpler mirroring\n    mid = w // 2\n    left = gray[:, :mid]\n    right = gray[:, w - mid:]\n    if left.size == 0 or right.size == 0:\n        return 0.0\n    right_flipped = np.fliplr(right)\n    # resize if shapes mismatch (when w is odd)\n    if left.shape != right_flipped.shape:\n        min_c = min(left.shape[1], right_flipped.shape[1])\n        left = left[:, :min_c]\n        right_flipped = right_flipped[:, :min_c]\n    diff = np.abs(left - right_flipped)\n    denom = np.mean(np.abs(gray)) + 1e-8\n    return float(np.mean(diff) / denom)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Ratio of nonzero pixels in the topmost non-empty row to the maximum row width (small for narrow handles)'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    thr = max(np.mean(gray) * 0.55, np.max(gray) * 0.02)\n    mask = gray > thr\n    if not np.any(mask):\n        return 0.0\n    row_counts = np.count_nonzero(mask, axis=1)\n    # find topmost nonempty row\n    nz_rows = np.where(row_counts > 0)[0]\n    if nz_rows.size == 0:\n        return 0.0\n    top_row = nz_rows[0]\n    top_count = float(row_counts[top_row])\n    max_count = float(np.max(row_counts))\n    return float(top_count / (max_count + 1e-12))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Aspect ratio of the foreground bounding box (width / height)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    ys, xs = np.where(mask)\n    if ys.size == 0:\n        return 0.0\n    miny, maxy = int(np.min(ys)), int(np.max(ys))\n    minx, maxx = int(np.min(xs)), int(np.max(xs))\n    bbox_h = float(max(1, maxy - miny + 1))\n    bbox_w = float(max(1, maxx - minx + 1))\n    return float(bbox_w / bbox_h)\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Ratio of average object width in bottom third to average width in middle third (shape narrowing or widening)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    mn, mx = gray.min(), gray.max()\n    if mx > mn:\n        gray = (gray - mn) / (mx - mn)\n    thr = gray.mean() + 0.12 * (gray.max() - gray.mean())\n    mask = gray > thr\n    if mask.sum() == 0:\n        mask = gray > gray.mean()\n    def avg_width(rows):\n        widths = []\n        for r in rows:\n            row = mask[r]\n            cols = np.where(row)[0]\n            if cols.size == 0:\n                continue\n            widths.append(float(cols[-1] - cols[0] + 1))\n        if len(widths) == 0:\n            return 0.0\n        return float(np.mean(widths))\n    bottom_rows = range((2*h)//3, h)\n    mid_rows = range(h//3, (2*h)//3)\n    bottom_w = avg_width(bottom_rows)\n    mid_w = avg_width(mid_rows)\n    eps = 1e-6\n    return float(bottom_w / (mid_w + eps))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Estimated principal axis angle of the object (abs normalized, 0=horizontal, 1=vertical)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    thr = (np.mean(gray) + np.min(gray)) * 0.5\n    mask = (gray > thr)\n    ys, xs = np.nonzero(mask)\n    if ys.size < 2:\n        return 0.0\n    coords = np.vstack([ys - ys.mean(), xs - xs.mean()])\n    cov = np.cov(coords)\n    vals, vecs = np.linalg.eigh(cov)\n    principal = vecs[:, np.argmax(vals)]\n    # angle between principal vector and horizontal axis (cols direction)\n    angle = abs(np.arctan2(principal[0], principal[1]))  # radians\n    # normalize: 0..pi/2 -> 0..1\n    return float(angle / (np.pi / 2.0))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Ratio of foreground fraction in top quarter vs bottom quarter (top_frac / bottom_frac)'\n    import numpy as np\n    if image is None:\n        return 1.0\n    h, w = image.shape[:2]\n    if h < 4 or w == 0:\n        return 1.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    top_h = max(1, h // 4)\n    top = mask[0:top_h, :]\n    bottom = mask[h - top_h:h, :]\n    top_frac = float(np.count_nonzero(top)) / float(top.size) if top.size > 0 else 0.0\n    bottom_frac = float(np.count_nonzero(bottom)) / float(bottom.size) if bottom.size > 0 else 0.0\n    return float(top_frac / (bottom_frac + 1e-8))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Skirt flare score: (bottom-quarter width - middle-quarter width) / max(1, middle-quarter width) (positive indicates flare)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape\n    thr = np.mean(gray) + 0.12 * np.std(gray)\n    mask = gray > thr\n    if not mask.any():\n        return 0.0\n    # bottom quarter\n    b0 = max(0, 3 * h // 4)\n    bottom_cols = np.any(mask[b0:, :], axis=0)\n    bottom_w = int(np.sum(bottom_cols))\n    # middle quarter\n    m0 = h // 4\n    m1 = 3 * h // 4\n    mid_cols = np.any(mask[m0:m1, :], axis=0)\n    mid_w = int(np.sum(mid_cols))\n    return float((bottom_w - mid_w) / float(max(1, mid_w)))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Fill ratio: mask area divided by its bounding-box area (1.0 if perfectly filled)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 60)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    if not np.any(mask):\n        return 0.0\n    rows = np.where(np.any(mask, axis=1))[0]\n    cols = np.where(np.any(mask, axis=0))[0]\n    if rows.size == 0 or cols.size == 0:\n        return 0.0\n    bbox_area = float((rows[-1] - rows[0] + 1) * (cols[-1] - cols[0] + 1))\n    if bbox_area <= 0.0:\n        return 0.0\n    area = float(np.count_nonzero(mask))\n    return float(area / bbox_area)\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Laplacian variance inside the foreground (texture energy indicator)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 3 or w < 3:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 50)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    # compute approximate Laplacian via gradients\n    gy, gx = np.gradient(gray.astype(float))\n    gxx = np.gradient(gx, axis=1)\n    gyy = np.gradient(gy, axis=0)\n    lap = gxx + gyy\n    lap_fg = lap[mask]\n    if lap_fg.size == 0:\n        return 0.0\n    # use variance (higher for textured objects like shoes)\n    return float(np.var(lap_fg))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Standard deviation of top edge (topmost foreground row per column) in the central columns normalized by image height (measures top-edge variability)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    mx = float(np.max(gray)); mean = float(np.mean(gray))\n    thr = mean + 0.2 * (mx - mean)\n    if mx == float(np.min(gray)):\n        return 0.0\n    mask = gray > thr\n    if mask.sum() == 0:\n        mask = gray >= mean\n    if mask.sum() == 0:\n        return 0.0\n    c0 = max(0, w // 4); c1 = min(w, 3 * w // 4)\n    top_positions = []\n    for c in range(c0, c1):\n        col = mask[:, c]\n        ys = np.where(col)[0]\n        if ys.size:\n            top_positions.append(float(ys.min()))\n        else:\n            top_positions.append(float(h))  # treat missing as bottom (large)\n    if len(top_positions) == 0:\n        return 0.0\n    std = float(np.std(np.array(top_positions)))\n    return float(std / (h + 1e-9))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Normalized vertical centroid of the main mask (0=top, 1=bottom)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    ys = np.where(mask)[0]\n    if ys.size == 0:\n        return 0.0\n    y_cent = float(np.mean(ys))\n    eps = 1e-8\n    return float(y_cent / (max(1.0, h - 1) + eps))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Left-right vertical symmetry of object intensities normalized by object mean (lower = more symmetric)'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    h, w = gray.shape[:2]\n    mn, mx = float(np.min(gray)), float(np.max(gray))\n    if mx <= mn:\n        return 0.0\n    mask = gray > (mn + 0.2 * (mx - mn))\n    ys, xs = np.where(mask)\n    if ys.size == 0:\n        return 0.0\n    # crop to bounding box to focus on object\n    top, bottom, left, right = int(np.min(ys)), int(np.max(ys)), int(np.min(xs)), int(np.max(xs))\n    crop = gray[top:bottom+1, left:right+1]\n    cw = crop.shape[1]\n    # create mirrored version and compute difference\n    flipped = np.fliplr(crop)\n    diff = np.abs(crop - flipped)\n    # only consider pixels that belong to either side (use mask on crop area)\n    crop_mask = mask[top:bottom+1, left:right+1].astype(float)\n    if np.sum(crop_mask) < 1e-6:\n        return 0.0\n    # weight diff by mask to ignore background\n    weighted_diff = diff * crop_mask\n    mean_diff = float(np.sum(weighted_diff) / np.sum(crop_mask))\n    mean_obj = float(np.sum(crop * crop_mask) / np.sum(crop_mask))\n    denom = mean_obj if mean_obj > 1e-6 else 1.0\n    return float(mean_diff / denom)\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Top-minus-bottom foreground fraction based on simple threshold mask (positive => more top)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    area = np.count_nonzero(mask)\n    if area == 0:\n        return 0.0\n    top_area = np.count_nonzero(mask[:h//2, :])\n    bottom_area = np.count_nonzero(mask[h//2:, :])\n    top_frac = float(top_area) / (area + 1e-8)\n    bottom_frac = float(bottom_area) / (area + 1e-8)\n    return float(top_frac - bottom_frac)\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Vertical contrast between a small top-center strip and the immediate strip below (negative if top is darker)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    if h < 3 or w == 0:\n        return 0.0\n    c0, c1 = max(0, w // 2 - max(1, w // 10)), min(w, w // 2 + max(1, w // 10))\n    top_rows = max(1, h // 12)\n    top_strip = gray[0:top_rows, c0:c1]\n    below_strip = gray[top_rows:top_rows + top_rows, c0:c1] if top_rows + top_rows <= h else gray[top_rows:h, c0:c1]\n    mean_top = np.mean(top_strip) if top_strip.size else 0.0\n    mean_below = np.mean(below_strip) if below_strip.size else 0.0\n    # return difference normalized by overall std to be scale-invariant\n    denom = np.std(gray) + 1e-6\n    return float((mean_below - mean_top) / denom)\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Edge density in the central vertical band (fraction of strong edges)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 2 or w < 2:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    gy, gx = np.gradient(gray)\n    mag = np.sqrt(gx * gx + gy * gy)\n    if not np.any(mag):\n        return 0.0\n    thr = np.percentile(mag, 70)\n    strong = mag > thr\n    # central vertical band ~20% width\n    left = max(0, int(w * 0.4))\n    right = min(w, int(w * 0.6) + 1)\n    band = strong[:, left:right]\n    if band.size == 0:\n        return 0.0\n    return float(np.count_nonzero(band) / float(band.size))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Horizontal edge strength in top-center region (captures collars or necklines)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 5 or w < 5:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    gy, gx = np.gradient(gray.astype(float))\n    # horizontal edges produce large gy\n    top_end = max(1, h // 6)\n    c0 = max(0, w // 5)\n    c1 = min(w, (4 * w) // 5)\n    region = gy[0:top_end, c0:c1]\n    strength = float(np.sum(np.abs(region)))\n    # normalize by mask area if exists\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    norm = float(np.count_nonzero(mask)) + 1e-8\n    return float(strength / norm)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Mask solidity: foreground area divided by its bounding-box area (0..1)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    total = np.count_nonzero(mask)\n    if total == 0:\n        return 0.0\n    ys, xs = np.where(mask)\n    ymin, ymax = int(np.min(ys)), int(np.max(ys))\n    xmin, xmax = int(np.min(xs)), int(np.max(xs))\n    bw = float(xmax - xmin + 1)\n    bh = float(ymax - ymin + 1)\n    bbox_area = bw * bh\n    if bbox_area <= 0:\n        return 0.0\n    return float(total / (bbox_area + 1e-8))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Mean radial distance of mask pixels to mask centroid normalized by image diagonal'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    ys, xs = np.where(mask)\n    if ys.size == 0:\n        return 0.0\n    cy = float(np.mean(ys))\n    cx = float(np.mean(xs))\n    d = np.sqrt((ys - cy)**2 + (xs - cx)**2)\n    mean_d = float(np.mean(d))\n    diag = np.sqrt(float(h*h + w*w))\n    return float(mean_d / (diag + 1e-8))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Fraction of foreground mass located in the lower third of the image'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 3 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 50)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    total = float(np.count_nonzero(mask))\n    if total <= 0.0:\n        return 0.0\n    lower_start = (2 * h) // 3\n    lower_mass = float(np.count_nonzero(mask[lower_start:, :]))\n    return float(lower_mass / total)\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Ratio of foreground mass in the top third of the image (0..1)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 50)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    if not np.any(mask):\n        return 0.0\n    top_cut = max(1, h // 3)\n    top_area = np.count_nonzero(mask[:top_cut, :])\n    total_area = np.count_nonzero(mask)\n    return float(top_area / float(total_area + 1e-12))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Neck opening index: width near top (10%) divided by width a bit lower (22%) (lower => neck cut)'\n    import numpy as np\n    if image is None:\n        return 1.0\n    h, w = image.shape[:2]\n    if h < 6 or w == 0:\n        return 1.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    def width_at(frac):\n        row = int(min(h - 1, max(0, int(frac * h))))\n        band = max(1, int(h * 0.01))\n        start = max(0, row - band)\n        end = min(h, row + band + 1)\n        widths = np.sum(mask[start:end, :].astype(float), axis=1)\n        if widths.size == 0:\n            return 0.0\n        return float(np.mean(widths))\n    top_w = width_at(0.10)\n    lower_w = width_at(0.22)\n    result = top_w / (lower_w + 1e-8)\n    return float(result)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Absolute normalized area difference between left and right halves (captures asymmetry in heel vs toe or side silhouettes)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    h, w = gray.shape[:2]\n    thresh = (np.mean(gray) + np.min(gray)) / 2.0\n    binary = gray > thresh\n    area = float(np.sum(binary))\n    if area <= 0.0:\n        return 0.0\n    mid = w // 2\n    left_area = float(np.sum(binary[:, :mid]))\n    right_area = float(np.sum(binary[:, mid:]))\n    return abs(left_area - right_area) / area\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Horizontal offset of mask centroid from image center normalized by width (signed)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w <= 1:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 50)\n    mask = ((gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)).astype(bool)\n    ys, xs = np.where(mask)\n    if xs.size == 0:\n        return 0.0\n    centroid_x = float(np.mean(xs))\n    center_x = float((w - 1) / 2.0)\n    return float((centroid_x - center_x) / max(1.0, float(w - 1)))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Mean color saturation (RGB) approximated by (max-min)/max per pixel; 0 for grayscale'\n    import numpy as np\n    if image is None:\n        return 0.0\n    if len(image.shape) != 3 or image.shape[2] != 3:\n        return 0.0\n    img = image.astype(float)\n    mx = np.max(img, axis=2)\n    mn = np.min(img, axis=2)\n    # avoid division by zero where mx==0\n    sat = (mx - mn) / (mx + 1e-8)\n    return float(np.mean(sat))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Mean left-right symmetry of the image (0 = identical, larger = more asymmetric)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    # grayscale\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    # normalize\n    mx = np.max(gray) if gray.size else 0.0\n    if mx > 0:\n        gray = gray / mx\n    mid = w // 2\n    left = gray[:, :mid]\n    right = gray[:, w - mid:]\n    # mirror right to align with left\n    right_mirror = np.fliplr(right)\n    # resize to same if odd width\n    if left.shape[1] != right_mirror.shape[1]:\n        m = min(left.shape[1], right_mirror.shape[1])\n        left = left[:, :m]\n        right_mirror = right_mirror[:, :m]\n    if left.size == 0:\n        return 0.0\n    diff = np.abs(left - right_mirror)\n    score = np.mean(diff)\n    return float(score)\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Vertical spread of the mask: standard deviation of mask row indices normalized by image height'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = gray < thr if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else gray > thr\n    ys, xs = np.where(mask)\n    if ys.size == 0:\n        return 0.0\n    std_y = float(np.std(ys.astype(float)))\n    return float(std_y / max(1.0, float(h)))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Approximate solidity: mask area divided by per-row filled spans (1==solid)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 50)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    area = float(np.count_nonzero(mask))\n    if area <= 0:\n        return 0.0\n    filled = 0.0\n    for r in range(h):\n        row = mask[r, :]\n        if not np.any(row):\n            continue\n        xs = np.where(row)[0]\n        span = float(xs[-1] - xs[0] + 1)\n        filled += span\n    if filled <= 0:\n        return 0.0\n    solidity = float(area / (filled + 1e-8))\n    return float(solidity)\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Normalized vertical centroid position of foreground (0=top, 1=bottom)'\n    import numpy as np\n    if image is None:\n        return 0.5\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.5\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 50)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    ys, xs = np.nonzero(mask)\n    if ys.size == 0:\n        return 0.5\n    cy = float(np.mean(ys))\n    return float(cy / float(h - 1 + 1e-8))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Bottom-edge straightness: inverse of variance of bottom-most nonzero y across columns (straighter hem -> lower variance)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    mx = float(np.max(gray))\n    thr = max(0.25 * float(np.mean(gray)), 0.08 * mx)\n    mask = gray > thr\n    # for each column, find bottom-most nonzero row (highest index)\n    bottoms = []\n    for c in range(w):\n        col = mask[:, c]\n        nz = np.where(col)[0]\n        if nz.size:\n            bottoms.append(nz.max())\n    if len(bottoms) == 0:\n        return 0.0\n    var = float(np.var(bottoms))\n    # normalize by image height squared\n    norm = (h ** 2) if h > 0 else 1.0\n    straightness = 1.0 - min(1.0, var / norm)\n    return float(straightness)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Skewness of horizontal row widths inside bounding box (third standardized moment of row widths)'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.mean(gray) - 0.25 * np.std(gray)\n    mask = gray < thr\n    if mask.sum() == 0:\n        thr = np.mean(gray)\n        mask = gray < thr\n    if mask.sum() == 0:\n        mask = gray < np.percentile(gray, 50)\n    ys, xs = np.where(mask)\n    if ys.size == 0:\n        return 0.0\n    y0, y1 = ys.min(), ys.max()\n    x0, x1 = xs.min(), xs.max()\n    widths = []\n    for yy in range(y0, y1 + 1):\n        row_x = np.where(mask[yy, x0:x1 + 1])[0]\n        if row_x.size:\n            widths.append(float(row_x.max() - row_x.min() + 1))\n    widths = np.array(widths, dtype=float)\n    if widths.size < 3:\n        return 0.0\n    mu = widths.mean()\n    std = widths.std()\n    if std < 1e-6:\n        return 0.0\n    skew = np.mean((widths - mu) ** 3) / (std ** 3 + 1e-12)\n    return float(skew)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Absolute normalized difference between left and right foreground counts in the bottom quarter (captures heel offsets)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    thr = np.percentile(gray, 70)\n    if thr >= gray.max():\n        thr = (gray.max() + gray.min()) / 2.0\n    mask = gray > thr\n    if not mask.any():\n        mask = gray > gray.mean()\n        if not mask.any():\n            return 0.0\n    rows, cols = np.where(mask)\n    rmin, rmax = rows.min(), rows.max()\n    cmin, cmax = cols.min(), cols.max()\n    bbox_h = rmax - rmin + 1\n    bottom_h = max(1, int(np.ceil(0.25 * bbox_h)))\n    start_row = max(rmin, rmax - bottom_h + 1)\n    bottom_mask = mask[start_row:rmax+1, cmin:cmax+1]\n    mid_col = (cmax - cmin + 1) // 2\n    left_count = np.count_nonzero(bottom_mask[:, :mid_col])\n    right_count = np.count_nonzero(bottom_mask[:, mid_col:])\n    total = left_count + right_count\n    if total == 0:\n        return 0.0\n    return float(abs(left_count - right_count) / (total + 1e-9))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Length of contiguous object pixels in the center column from center downwards normalized by height (measures skirt-like central extension)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    h, w = gray.shape[:2]\n    cx = w // 2\n    rng = float(np.max(gray) - np.min(gray))\n    if rng < 1e-6 or cx < 0 or cx >= w:\n        return 0.0\n    thresh = float(np.mean(gray) + 0.10 * rng)\n    mask = gray > thresh\n    center_col = mask[:, cx]\n    start = h // 2\n    length = 0\n    for r in range(start, h):\n        if center_col[r]:\n            length += 1\n        elif length > 0:\n            break\n    return float(length) / float(h)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Waist-like constriction: min row mask width divided by max row mask width (0..1)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 50)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    row_counts = np.count_nonzero(mask, axis=1).astype(float)\n    if row_counts.size == 0:\n        return 0.0\n    max_w = float(np.max(row_counts))\n    min_w = float(np.min(row_counts))\n    if max_w <= 0:\n        return 0.0\n    return float((min_w + 1e-8) / (max_w + 1e-8))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Fraction of object mass located in the bottom 25% of the image (useful for shoes)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = gray < thr if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else gray > thr\n    total = np.count_nonzero(mask)\n    if total == 0:\n        return 0.0\n    cutoff = max(0, h - max(1, h // 4))\n    bottom_mask = mask[cutoff:, :]\n    bottom_count = np.count_nonzero(bottom_mask)\n    return float(bottom_count) / float(total)\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Normalized variance of per-row foreground widths inside object bbox (sandals show more irregular row widths)'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    thresh = np.percentile(gray, 50)\n    binary = gray > thresh\n    ys, xs = np.nonzero(binary)\n    if ys.size == 0:\n        return 0.0\n    y0, y1 = ys.min(), ys.max()\n    x0, x1 = xs.min(), xs.max()\n    roi = binary[y0:y1+1, x0:x1+1]\n    row_widths = np.sum(roi, axis=1).astype(float)\n    if row_widths.size == 0:\n        return 0.0\n    mean_w = np.mean(row_widths)\n    var_w = np.var(row_widths)\n    return float(var_w / (mean_w + 1e-6))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Colorfulness metric based on rg and yb opponent channels (Hasler-Suesstrunk)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    if len(image.shape) != 3 or image.shape[2] < 3:\n        return 0.0\n    img = image.astype(float)\n    R = img[:, :, 0]\n    G = img[:, :, 1]\n    B = img[:, :, 2]\n    rg = R - G\n    yb = 0.5 * (R + G) - B\n    std_rg = float(np.std(rg))\n    std_yb = float(np.std(yb))\n    mean_rg = float(np.mean(rg))\n    mean_yb = float(np.mean(yb))\n    # Hasler and Suesstrunk colorfulness formula\n    colorfulness = np.sqrt(std_rg**2 + std_yb**2) + 0.3 * np.sqrt(mean_rg**2 + mean_yb**2)\n    return float(colorfulness)\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Upper component split frequency: fraction of rows in the upper third that contain more than one separate object segment (detects sleeves/arm gaps)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    h, w = gray.shape[:2]\n    if h < 3 or w < 3:\n        return 0.0\n    vmax, vmin = float(np.max(gray)), float(np.min(gray))\n    if vmax == vmin:\n        return 0.0\n    thr = (vmax + vmin) / 2.0\n    binar = (gray > thr).astype(np.uint8)\n    rows_any = np.any(binar, axis=1)\n    if not np.any(rows_any):\n        return 0.0\n    rmin = int(np.argmax(rows_any))\n    rmax = int(len(rows_any) - 1 - np.argmax(rows_any[::-1]))\n    crop = binar[rmin:rmax+1, :]\n    ch = crop.shape[0]\n    if ch <= 0:\n        return 0.0\n    up_third = max(1, ch // 3)\n    counts = 0\n    total = 0\n    for r in range(0, up_third):\n        row = crop[r, :]\n        # count contiguous runs\n        if not np.any(row):\n            continue\n        runs = 0\n        in_run = False\n        for val in row:\n            if val and not in_run:\n                runs += 1\n                in_run = True\n            elif not val:\n                in_run = False\n        total += 1\n        if runs > 1:\n            counts += 1\n    if total == 0:\n        return 0.0\n    return float(counts / total)\n",
    "def feature(image: np.ndarray) -> float:\n    'Ratio of vertical to horizontal edge energy within a central vertical strip (high if placket/buttons produce vertical edges)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    # central vertical band\n    bw = max(1, w // 8)\n    cs = max(0, w // 2 - bw // 2)\n    band = gray[:, cs:cs + bw]\n    if band.size == 0:\n        return 0.0\n    gy, gx = np.gradient(band)\n    sum_vert = np.sum(np.abs(gx))\n    sum_horz = np.sum(np.abs(gy))\n    ratio = float(sum_vert / (sum_horz + 1e-8))\n    return ratio\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Mean gradient magnitude normalized by image contrast (objects with many edges score higher)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    gx, gy = np.gradient(gray.astype(float))\n    mag = np.sqrt(gx * gx + gy * gy)\n    mean_mag = float(np.mean(mag))\n    contrast = float(gray.max() - gray.min()) + 1e-6\n    return float(mean_mag / contrast)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Compactness estimate: (perimeter^2) / area (high for irregular shoe outlines)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    gmin, gmax = float(gray.min()), float(gray.max())\n    if gmax - gmin < 1e-8:\n        return 0.0\n    mask = ((gray - gmin) / (gmax - gmin)) > 0.2\n    area = float(np.count_nonzero(mask))\n    if area <= 0.0:\n        return 0.0\n    # edge pixels: mask AND having at least one neighbor that is background\n    m = mask.astype(bool)\n    up = np.roll(m, 1, axis=0)\n    down = np.roll(m, -1, axis=0)\n    left = np.roll(m, 1, axis=1)\n    right = np.roll(m, -1, axis=1)\n    neighbor_all = up & down & left & right\n    # boundary where any neighbor differs (exclude rolled wrap-around by masking edges)\n    edge = m & (~(np.pad(m[1:-1,1:-1], ((1,1),(1,1)), mode='constant', constant_values=False)[m.shape[0]*0:m.shape[0]*0+0:1] if False else (up==m) ) )\n    # simpler robust edge calculation:\n    edge = m & ((~up) | (~down) | (~left) | (~right))\n    # zero-out wrapped edges (roll creates wrap) by forcing first/last rows/cols correct\n    edge[0, :] = m[0, :] & ((~m[1, :]) | (~m[0, :]) | (~np.roll(m[0, :],1)) | (~np.roll(m[0, :],-1)))\n    edge[-1, :] = m[-1, :] & ((~m[-2, :]) | (~m[-1, :]) | (~np.roll(m[-1, :],1)) | (~np.roll(m[-1, :],-1)))\n    edge[:, 0] = m[:, 0] & ((~m[:, 1]) | (~m[:, 0]) | (~np.roll(m[:, 0],1)) | (~np.roll(m[:, 0],-1)))\n    edge[:, -1] = m[:, -1] & ((~m[:, -2]) | (~m[:, -1]) | (~np.roll(m[:, -1],1)) | (~np.roll(m[:, -1],-1)))\n    perimeter = float(np.count_nonzero(edge))\n    return float((perimeter * perimeter) / (area + 1e-8))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Fraction of rows in the top half of the object bounding box that show two or more separate object segments (indicative of sleeves)'\n    import numpy as np\n    gray = np.mean(image, axis=2) if len(image.shape) == 3 else image.astype(float)\n    h, w = gray.shape[:2]\n    cs = max(1, min(h, w) // 12)\n    bg = np.median([np.mean(gray[0:cs,0:cs]), np.mean(gray[0:cs,-cs:]), np.mean(gray[-cs:,0:cs]), np.mean(gray[-cs:,-cs:])])\n    thr = bg + max(8.0, 0.07 * (gray.max() - bg))\n    mask = gray > thr\n    if mask.sum() == 0:\n        thr = np.percentile(gray, 70)\n        mask = gray > thr\n    if mask.sum() == 0:\n        return 0.0\n    rows, cols = np.where(mask)\n    top, bottom = rows.min(), rows.max()\n    left, right = cols.min(), cols.max()\n    height = max(1, bottom - top + 1)\n    top_half_end = top + height // 2\n    top_rows = mask[top:top_half_end+1, left:right+1]\n    if top_rows.size == 0:\n        return 0.0\n    multi_count = 0\n    total = top_rows.shape[0]\n    for r in range(top_rows.shape[0]):\n        row = top_rows[r, :].astype(int)\n        # count runs of 1s\n        if row.sum() == 0:\n            continue\n        transitions = np.diff(np.concatenate(([0], row, [0])))\n        runs = np.sum(transitions == 1)\n        if runs >= 2:\n            multi_count += 1\n    return float(multi_count / (total + 1e-9))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Standard deviation of the bottom hem vertical positions across central columns (lower = straighter hem)'\n    import numpy as np\n    gray = np.mean(image, axis=2) if len(image.shape) == 3 else image.astype(float)\n    thr = np.mean(gray) + 0.25 * (np.max(gray) - np.mean(gray))\n    mask = gray > thr\n    if mask.sum() == 0:\n        thr = np.percentile(gray.flatten(), 50)\n        mask = gray > thr\n    if mask.sum() == 0:\n        return 0.0\n    ys, xs = np.where(mask)\n    minr, maxr = ys.min(), ys.max()\n    minc, maxc = xs.min(), xs.max()\n    bbox = mask[minr:maxr+1, minc:maxc+1]\n    h, w = bbox.shape\n    if w <= 2:\n        return 0.0\n    # consider central 50% of columns\n    cstart = w//4\n    cend = w - cstart\n    bottoms = []\n    for col in range(cstart, cend):\n        col_pixels = np.where(bbox[:, col])[0]\n        if col_pixels.size > 0:\n            bottoms.append(col_pixels.max())\n    if len(bottoms) == 0:\n        return 0.0\n    std = np.std(bottoms)\n    # normalize by height\n    return float(std / (h + 1e-9))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Mean per-pixel RGB saturation (max-min) inside the foreground mask (0 for grayscale images)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    if len(image.shape) != 3 or image.shape[2] < 3:\n        return 0.0\n    h, w, c = image.shape\n    img = image.astype(float)\n    gray = np.mean(img, axis=2)\n    thr = np.percentile(gray, 55)\n    mask = gray < thr if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else gray > thr\n    if not np.any(mask):\n        return 0.0\n    R = img[:, :, 0]\n    G = img[:, :, 1]\n    B = img[:, :, 2]\n    sat = np.maximum.reduce([R, G, B]) - np.minimum.reduce([R, G, B])\n    mean_sat = float(np.sum(sat * mask) / np.count_nonzero(mask))\n    denom = max(1.0, float(np.max(img) - np.min(img)))\n    return float(mean_sat / denom)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Left-right symmetry score: normalized mean absolute difference between mask and its mirror (0 = perfect symmetry)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape\n    thr = np.mean(gray) + 0.15 * np.std(gray)\n    mask = (gray > thr).astype(np.uint8)\n    if mask.sum() == 0:\n        return 1.0\n    half = w // 2\n    left = mask[:, :half]\n    right = mask[:, w - half:][:, ::-1]\n    # if odd width, ignore center column\n    minw = min(left.shape[1], right.shape[1])\n    if minw == 0:\n        return 1.0\n    diff = np.abs(left[:, :minw] - right[:, :minw]).sum()\n    normalized = diff / float(mask.sum())\n    return float(normalized)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Mean horizontal edge strength in a small top-center region normalized by local intensity (detects sharp collars)'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    median = np.percentile(gray, 50)\n    mask = gray < median\n    if mask.sum() < (h * w * 0.01):\n        mask = gray > median\n    if mask.sum() == 0:\n        return 0.0\n    rows = np.any(mask, axis=1)\n    cols = np.any(mask, axis=0)\n    r0, r1 = np.where(rows)[0][0], np.where(rows)[0][-1] + 1\n    c0, c1 = np.where(cols)[0][0], np.where(cols)[0][-1] + 1\n    bh, bw = r1 - r0, c1 - c0\n    # Top-center small box\n    th = max(1, bh // 6)\n    tw = max(1, bw // 4)\n    rc0 = r0\n    cc0 = c0 + (bw // 2) - (tw // 2)\n    rc1 = min(r1, rc0 + th)\n    cc1 = min(c1, cc0 + tw)\n    region = gray[rc0:rc1, cc0:cc1]\n    if region.size == 0:\n        return 0.0\n    # horizontal gradient\n    gx = np.abs(np.diff(region, axis=1))\n    mean_edge = float(np.mean(gx)) if gx.size > 0 else 0.0\n    mean_int = float(np.mean(region)) + 1e-6\n    score = mean_edge / mean_int\n    return float(score)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Fraction of image occupied by the foreground mask'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    total = h * w\n    if total == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    area = float(np.count_nonzero(mask))\n    return float(area / float(total))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Mean color saturation (approx) for RGB images, 0.0 for grayscale'\n    import numpy as np\n    if image is None:\n        return 0.0\n    if len(image.shape) != 3 or image.shape[2] < 3:\n        return 0.0\n    img = image.astype(float)\n    R = img[:, :, 0]\n    G = img[:, :, 1]\n    B = img[:, :, 2]\n    mx = np.maximum(np.maximum(R, G), B)\n    mn = np.minimum(np.minimum(R, G), B)\n    denom = mx + 1e-8\n    sat = (mx - mn) / denom\n    return float(np.mean(sat))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Coefficient of variation of object width measured at 25%, 50% and 75% heights (captures sleeve/torso shape changes)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    mu, sigma = np.mean(gray), np.std(gray)\n    if sigma < 1e-6:\n        return 0.0\n    dark_mask = gray < (mu - 0.25 * sigma)\n    light_mask = gray > (mu + 0.25 * sigma)\n    center_area = gray[h//4:3*h//4, w//4:3*w//4]\n    if np.sum(center_area < (mu - 0.25 * sigma)) >= np.sum(center_area > (mu + 0.25 * sigma)):\n        mask = dark_mask\n    else:\n        mask = light_mask\n    heights = [max(0, h*25//100), max(0, h*50//100), max(0, h*75//100)]\n    widths = []\n    for hh in heights:\n        row = mask[hh, :] if hh < h else mask[-1, :]\n        cols = np.where(row)[0]\n        if cols.size == 0:\n            widths.append(0.0)\n        else:\n            widths.append(float(cols.max() - cols.min() + 1))\n    widths = np.array(widths)\n    mean_w = np.mean(widths) + 1e-9\n    cv = float(np.std(widths) / mean_w)\n    return cv\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Perimeter-to-area ratio of the main mask (higher = thinner/more complex shapes)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = ((gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)).astype(np.uint8)\n    area = float(np.count_nonzero(mask))\n    if area <= 0:\n        return 0.0\n    # 4-neighbor boundary detection\n    padded = np.pad(mask, ((1, 1), (1, 1)), mode='constant', constant_values=0)\n    center = padded[1:-1, 1:-1]\n    up = padded[0:-2, 1:-1]\n    down = padded[2:, 1:-1]\n    left = padded[1:-1, 0:-2]\n    right = padded[1:-1, 2:]\n    boundary = (center & (~up | ~down | ~left | ~right)).astype(np.uint8)\n    perimeter = float(np.count_nonzero(boundary))\n    return float(perimeter / (area + 1e-8))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Central intensity ridge: prominence of a bright/dark vertical strip at the image center compared to flanks (buttons or seam)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    center = w // 2\n    core_w = max(1, int(round(w * 0.05)))\n    flank_w = max(1, int(round(w * 0.10)))\n    core = gray[:, max(0, center-core_w):min(w, center+core_w+1)]\n    left = gray[:, max(0, center-core_w-flank_w):max(0, center-core_w)]\n    right = gray[:, min(w, center+core_w+1):min(w, center+core_w+1+flank_w)]\n    core_mean = float(np.mean(core)) if core.size else 0.0\n    flank_mean = float(np.mean(np.concatenate([left.flatten(), right.flatten()])) ) if (left.size+right.size)>0 else 0.0\n    denom = float(np.std(gray) + 1e-8)\n    return float((core_mean - flank_mean) / denom)\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Average per-pixel saturation (HSV-like) across image (0..1), 0 for grayscale uniform'\n    import numpy as np\n    if image is None:\n        return 0.0\n    if len(image.shape) != 3:\n        return 0.0\n    arr = image.astype(float)\n    h, w, c = arr.shape\n    if c < 3 or h == 0 or w == 0:\n        return 0.0\n    r = arr[:, :, 0]\n    g = arr[:, :, 1]\n    b = arr[:, :, 2]\n    mx = np.maximum(np.maximum(r, g), b)\n    mn = np.minimum(np.minimum(r, g), b)\n    diff = mx - mn\n    # saturation definition relative to max (avoid division by zero)\n    sat = diff / (mx + 1e-8)\n    # mask invalid where mx is zero -> sat ~ 0\n    sat = np.clip(sat, 0.0, 1.0)\n    return float(np.mean(sat))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Maximum vertical continuous foreground run length normalized by image height'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 1 or w < 1:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = ((gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)).astype(bool)\n    if not np.any(mask):\n        return 0.0\n    max_run = 0\n    for col in range(w):\n        col_vals = mask[:, col]\n        cur = 0\n        for v in col_vals:\n            if v:\n                cur += 1\n                if cur > max_run:\n                    max_run = cur\n            else:\n                cur = 0\n    return float(max_run / max(1.0, float(h)))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Fraction of rows that contain strong horizontal edges (useful to detect straps, soles, or hems)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 2 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    mx = np.max(gray)\n    if mx > 0:\n        gray = gray / mx\n    gy, gx = np.gradient(gray)\n    row_strength = np.sum(np.abs(gy), axis=1)\n    med = np.median(row_strength)\n    thresh = med * 1.5 + 1e-8\n    strong_rows = np.count_nonzero(row_strength > thresh)\n    return float(strong_rows) / float(h)\n",
    "def feature(image: np.ndarray) -> float:\n    'Average left-right symmetry score: mean over rows of normalized abs(distance from row center-of-mass to image center) (lower means more symmetric)'\n    import numpy as np\n    gray = np.mean(image, axis=2) if len(image.shape) == 3 else image.astype(float)\n    h, w = gray.shape[:2]\n    thr = gray.mean() + 0.12 * (gray.max() - gray.mean())\n    mask = gray > thr\n    if np.count_nonzero(mask) == 0:\n        thr = gray.mean()\n        mask = gray > thr\n    if np.count_nonzero(mask) == 0:\n        return 1.0\n    cols = np.arange(w)\n    center = (w - 1) / 2.0\n    diffs = []\n    for r in range(h):\n        cols_present = cols[mask[r, :]]\n        if cols_present.size == 0:\n            continue\n        com = cols_present.mean()\n        diffs.append(abs(com - center) / max(1.0, center))\n    if len(diffs) == 0:\n        return 1.0\n    return float(np.mean(diffs))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Mask extent: fraction of bounding box area filled by mask (compactness)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    ys, xs = np.where(mask)\n    if ys.size == 0:\n        return 0.0\n    miny, maxy = ys.min(), ys.max()\n    minx, maxx = xs.min(), xs.max()\n    bbox_area = float((maxy - miny + 1) * (maxx - minx + 1))\n    mask_area = float(ys.size)\n    return float(mask_area / (bbox_area + 1e-8))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Horizontal symmetry score: normalized L1 difference between left half and mirrored right half of the object region'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    thr = (np.mean(gray) + np.median(gray)) / 2.0\n    mask_high = gray > thr\n    mask_low = gray < thr\n    mask = mask_high if mask_high.sum() < mask_low.sum() else mask_low\n    ys, xs = np.nonzero(mask)\n    if ys.size == 0:\n        # fallback to global symmetry of intensities\n        left = gray[:, :w//2]\n        right = gray[:, (w+1)//2:]\n        right_flipped = np.fliplr(right)\n        # pad to same width\n        minw = min(left.shape[1], right_flipped.shape[1])\n        if minw == 0:\n            return 0.0\n        diff = np.abs(left[:, :minw] - right_flipped[:, :minw]).sum()\n        norm = (np.abs(left[:, :minw]) + np.abs(right_flipped[:, :minw])).sum() + 1e-8\n        return float(diff / norm)\n    # crop to bounding box and compare halves within bbox\n    rmin, rmax = int(ys.min()), int(ys.max())\n    cmin, cmax = int(xs.min()), int(xs.max())\n    box = gray[rmin:rmax+1, cmin:cmax+1]\n    bh, bw = box.shape\n    if bw < 2:\n        return 0.0\n    left = box[:, :bw//2]\n    right = box[:, bw - (bw//2):]\n    right_flipped = np.fliplr(right)\n    minw = min(left.shape[1], right_flipped.shape[1])\n    if minw == 0:\n        return 0.0\n    diff = np.abs(left[:, :minw] - right_flipped[:, :minw]).sum()\n    norm = (np.abs(left[:, :minw]) + np.abs(right_flipped[:, :minw])).sum() + 1e-8\n    return float(diff / norm)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Normalized vertical center of mass of foreground mask (0=top, 1=bottom)'\n    import numpy as np\n    if image is None:\n        return 0.5\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.5\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 50)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    ys, xs = np.where(mask)\n    if ys.size == 0:\n        return 0.5\n    center_y = float(np.mean(ys))\n    return float(center_y / max(1.0, (h - 1)))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Mask fill ratio: mask area divided by its bounding-box area (solidity approximation)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    area = float(np.count_nonzero(mask))\n    if area == 0.0:\n        return 0.0\n    ys, xs = np.where(mask)\n    ymin, ymax = int(np.min(ys)), int(np.max(ys))\n    xmin, xmax = int(np.min(xs)), int(np.max(xs))\n    bbox_area = float((ymax - ymin + 1) * (xmax - xmin + 1))\n    if bbox_area <= 0:\n        return 0.0\n    return float(area / (bbox_area + 1e-8))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Normalized vertical centroid of the foreground mask (0=top,1=bottom)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 50)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    ys, xs = np.where(mask)\n    if ys.size == 0:\n        return 0.0\n    centroid_y = float(np.mean(ys))\n    return float(centroid_y / float(max(1, h - 1)))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Mean intensity contrast between foreground mask and background (abs difference, normalized)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    mx = np.max(gray)\n    if mx <= 0:\n        mx = 1.0\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    fg = gray[mask]\n    bg = gray[~mask]\n    if fg.size == 0 or bg.size == 0:\n        return 0.0\n    contrast = abs(float(np.mean(fg) - np.mean(bg))) / float(mx)\n    return float(contrast)\n",
    "def feature(image: np.ndarray) -> float:\n    'Normalized left-right symmetry of the image intensity (1.0 = perfectly symmetric)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    # compare mirrored halves using the smaller half width\n    left_w = w // 2\n    right_w = w - left_w\n    min_w = min(left_w, right_w)\n    if min_w <= 0:\n        return 1.0\n    left = gray[:, :min_w]\n    right = gray[:, -min_w:]\n    right_flipped = np.fliplr(right)\n    diff = np.abs(left - right_flipped)\n    denom = float(np.max(gray) - np.min(gray))\n    if denom <= 1e-8:\n        return 1.0\n    score = 1.0 - float(np.mean(diff) / denom)\n    if score != score:\n        return 0.0\n    return float(max(0.0, min(1.0, score)))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Fraction of image occupied by a simple foreground mask (area / image area)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    # grayscale convert\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 50)\n    mask_dark = gray < thr\n    mask_bright = gray > thr\n    mask = mask_dark if np.count_nonzero(mask_dark) >= np.count_nonzero(mask_bright) else mask_bright\n    area = float(np.count_nonzero(mask))\n    return float(area / float(h * w))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Average longest vertical contiguous run length per column normalized by image height (dresses have long vertical runs)'\n    import numpy as np\n    gray = np.mean(image, axis=2) if len(image.shape) == 3 else image.astype(float)\n    h, w = gray.shape[:2]\n    thr = np.mean(gray) + 0.25 * np.std(gray)\n    mask = gray > thr\n    if np.count_nonzero(mask) == 0:\n        thr = np.percentile(gray, 75)\n        mask = gray > thr\n    run_lengths = []\n    for c in range(w):\n        col = mask[:, c]\n        max_run = 0\n        cur = 0\n        for v in col:\n            if v:\n                cur += 1\n            else:\n                if cur > max_run:\n                    max_run = cur\n                cur = 0\n        if cur > max_run:\n            max_run = cur\n        run_lengths.append(max_run)\n    if len(run_lengths) == 0:\n        return 0.0\n    avg_run = float(np.mean(run_lengths))\n    return float(avg_run / max(1.0, h))\n",
    "def feature(image: np.ndarray) -> float:\n    'Ratio of mask area in lower third to upper third (high for shoes, low for tops/dresses)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 50)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    top_end = h // 3\n    low_start = (2 * h) // 3\n    top_area = float(np.count_nonzero(mask[:top_end, :]))\n    low_area = float(np.count_nonzero(mask[low_start:, :]))\n    return float(low_area / (top_area + 1e-8))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Aspect ratio (width/height) of the main mask bounding box (1.0 square)'\n    import numpy as np\n    if image is None:\n        return 1.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 1.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    ys, xs = np.where(mask)\n    if ys.size == 0:\n        return 1.0\n    miny, maxy = int(np.min(ys)), int(np.max(ys))\n    minx, maxx = int(np.min(xs)), int(np.max(xs))\n    bbox_h = max(1, maxy - miny + 1)\n    bbox_w = max(1, maxx - minx + 1)\n    return float(bbox_w / float(bbox_h))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Vertical centroid (center of mass) of the foreground mask normalized to [0,1]'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h <= 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 60)\n    mask = gray < thr if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else gray > thr\n    if np.count_nonzero(mask) == 0:\n        return 0.0\n    rows = np.arange(h).astype(float)\n    row_sums = np.sum(mask, axis=1).astype(float)\n    total = np.sum(row_sums)\n    if total <= 0:\n        return 0.0\n    v_cent = float(np.sum(rows * row_sums) / total)\n    return float(v_cent / max(1.0, h - 1))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Row-fill solidity: object area divided by filled row spans (lower when lots of gaps/straps)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    thr = float(np.mean(gray) + 0.15 * (float(np.max(gray)) - float(np.min(gray))))\n    mask = gray > thr\n    if not np.any(mask):\n        return 0.0\n    ys, xs = np.nonzero(mask)\n    ymin, ymax = ys.min(), ys.max()\n    xmin, xmax = xs.min(), xs.max()\n    sub = mask[ymin:ymax+1, xmin:xmax+1]\n    area = float(np.sum(sub))\n    filled = 0.0\n    for r in range(sub.shape[0]):\n        cols = np.where(sub[r])[0]\n        if cols.size:\n            filled += float(cols.max() - cols.min() + 1)\n    if filled <= 0.0:\n        return 0.0\n    return float(area / filled)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Count of vertical projection peaks of the object (number of separated vertical blobs or segments)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    thresh = np.mean(gray) + 0.1 * np.std(gray)\n    mask = (gray > thresh).astype(int)\n    proj = mask.sum(axis=1).astype(float)  # pixels per row\n    if proj.sum() == 0:\n        return 0.0\n    # smooth mildly\n    kernel = np.array([1.0, 1.0, 1.0])\n    smooth = np.convolve(proj, kernel / kernel.sum(), mode='same')\n    meanv = smooth.mean()\n    peaks = 0\n    for i in range(1, h - 1):\n        if smooth[i] > smooth[i - 1] and smooth[i] > smooth[i + 1] and smooth[i] > meanv * 0.5:\n            peaks += 1\n    return float(peaks)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Mean absolute left-right difference normalized by mean intensity (lower -> more symmetric)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    if w < 2:\n        return 0.0\n    left = gray[:, :w//2]\n    right = np.fliplr(gray[:, (w - w//2):])\n    # pad smaller side if needed\n    if left.shape[1] != right.shape[1]:\n        m = max(left.shape[1], right.shape[1])\n        def pad(a, m):\n            padw = m - a.shape[1]\n            if padw <= 0:\n                return a\n            return np.pad(a, ((0,0),(0,padw)), mode='constant', constant_values=0)\n        left = pad(left, m); right = pad(right, m)\n    diff = np.abs(left - right)\n    mean_diff = float(diff.mean())\n    mean_int = float(gray.mean()) + 1e-9\n    return float(mean_diff / mean_int)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Relative darkness of sleeve-end patches (lower-left/right) compared to center-bottom patch - shirts often have distinct cuffs'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    eps = 1e-8\n    thr = max(gray.mean() * 0.45, gray.min() + 1e-6)\n    mask = gray > thr\n    if np.count_nonzero(mask) < 10:\n        mask = gray > gray.mean() * 0.5\n    ys, xs = np.where(mask)\n    if ys.size == 0:\n        return 1.0\n    minr, maxr = ys.min(), ys.max()\n    minc, maxc = xs.min(), xs.max()\n    bh = maxr - minr + 1\n    bw = maxc - minc + 1\n    # define regions in lower quarter of bounding box\n    lr = minr + int(0.66 * bh)\n    rr = maxr\n    lc0 = minc\n    lc1 = minc + max(1, bw//5)\n    rc0 = maxc - max(1, bw//5) + 1\n    rc1 = maxc + 1\n    center_c0 = minc + bw//2 - max(1, bw//8)\n    center_c1 = minc + bw//2 + max(1, bw//8)\n    left_patch = gray[lr:rr+1, lc0:lc1]\n    right_patch = gray[lr:rr+1, rc0:rc1]\n    center_patch = gray[lr:rr+1, center_c0:center_c1]\n    left_mean = np.mean(left_patch) if left_patch.size else np.mean(gray)\n    right_mean = np.mean(right_patch) if right_patch.size else np.mean(gray)\n    center_mean = np.mean(center_patch) if center_patch.size else np.mean(gray)\n    sleeve_mean = (left_mean + right_mean) / 2.0\n    return float((sleeve_mean + eps) / (center_mean + eps))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Ratio of shoulder (top-quarter) width to center width (captures broad shoulders vs narrow center)'\n    import numpy as np\n    gray = np.mean(image, axis=2) if len(image.shape) == 3 else image.astype(float)\n    h, w = gray.shape[:2]\n    mn, mx = float(np.min(gray)), float(np.max(gray))\n    thr = (mn + mx) / 2.0\n    mask = gray > thr\n    if not mask.any():\n        return 0.0\n    top_row = max(0, h // 4)\n    center_row = h // 2\n    def row_span(r):\n        row = mask[max(0, r-1):min(h, r+2), :].any(axis=0)\n        cols = np.where(row)[0]\n        return float((cols[-1] - cols[0] + 1)) if cols.size > 0 else 0.0\n    shoulder_w = row_span(top_row)\n    center_w = row_span(center_row)\n    return float(shoulder_w / (center_w + 1e-8))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Perimeter-to-area proxy: strong-edge count divided by foreground area'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 2 or w < 2:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    gy, gx = np.gradient(gray.astype(float))\n    grad = np.sqrt(gx * gx + gy * gy)\n    thr = np.percentile(grad, 70) if np.any(grad) else 0.0\n    edges = grad > thr\n    thr2 = np.percentile(gray, 55)\n    mask = (gray < thr2) if np.count_nonzero(gray < thr2) >= np.count_nonzero(gray > thr2) else (gray > thr2)\n    area = float(np.count_nonzero(mask))\n    if area <= 0.0:\n        return 0.0\n    edge_count = float(np.count_nonzero(edges & mask))\n    return float(edge_count / (area + 1e-8))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Normalized foreground bounding-box aspect ratio (relative to image aspect)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h <= 1 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    ys, xs = np.where(mask)\n    if ys.size == 0:\n        return 0.0\n    miny, maxy = int(np.min(ys)), int(np.max(ys))\n    minx, maxx = int(np.min(xs)), int(np.max(xs))\n    bbox_h = max(1, maxy - miny + 1)\n    bbox_w = max(1, maxx - minx + 1)\n    img_aspect = float(w) / float(h)\n    bbox_aspect = float(bbox_w) / float(bbox_h)\n    # normalized so that 1.0 means bbox aspect equals image aspect\n    return float(bbox_aspect / (img_aspect + 1e-8))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Texture strength inside mask: std of gradient magnitude within mask normalized by mean'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 2 or w < 2:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    gy, gx = np.gradient(gray.astype(float))\n    grad_mag = np.sqrt(gx * gx + gy * gy)\n    thr = np.percentile(gray, 50)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    masked = grad_mag[mask]\n    if masked.size == 0:\n        return 0.0\n    std = float(np.std(masked))\n    mean = float(np.mean(masked))\n    return float(std / (mean + 1e-8))\n",
    "def feature(image: np.ndarray) -> float:\n    'Top-vs-bottom center fill difference in the central box: (top_fill - bottom_fill) normalized by center area'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    if h < 4 or w < 4:\n        return 0.0\n    # center box\n    r0, r1 = h//4, 3*h//4\n    c0, c1 = w//4, 3*w//4\n    center = gray[r0:r1, c0:c1]\n    thr = np.mean(center) + 0.45 * np.std(center)\n    mask = center > thr\n    mid = (r1 - r0) // 2\n    top_half = mask[:mid, :]\n    bottom_half = mask[mid:, :]\n    top_count = np.count_nonzero(top_half)\n    bottom_count = np.count_nonzero(bottom_half)\n    denom = max(1.0, top_count + bottom_count)\n    return float((top_count - bottom_count) / denom)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Average normalized contiguous object run length per row in the middle third (long runs for dresses)'\n    import numpy as np\n    img = np.array(image, copy=False)\n    h, w = img.shape[:2]\n    t = float(np.mean(img) + 0.1 * np.std(img))\n    bw = (img > t).astype(np.uint8)\n    r0 = h // 3\n    r1 = (2 * h) // 3\n    if r1 <= r0:\n        return 0.0\n    middle = bw[r0:r1, :]\n    if middle.size == 0 or np.count_nonzero(middle) == 0:\n        return 0.0\n    runs = []\n    for row in middle:\n        # find contiguous runs of ones\n        dif = np.diff(np.concatenate(([0], row, [0])))\n        starts = np.where(dif == 1)[0]\n        ends = np.where(dif == -1)[0]\n        if starts.size:\n            runs.extend((ends - starts).tolist())\n    if len(runs) == 0:\n        return 0.0\n    avg_run = float(np.mean(runs))\n    return float(avg_run / max(1.0, w))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Ratio of mean gradient magnitude in center region to border regions (center / border)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 3 or w < 3:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    gy, gx = np.gradient(gray.astype(float))\n    grad = np.sqrt(gx * gx + gy * gy)\n    ch0, ch1 = h // 4, w // 4\n    center = grad[ch0:h - ch0, ch1:w - ch1]\n    border_mask = np.ones_like(grad, dtype=bool)\n    border_mask[ch0:h - ch0, ch1:w - ch1] = False\n    border = grad[border_mask]\n    center_mean = float(np.mean(center)) if center.size > 0 else 0.0\n    border_mean = float(np.mean(border)) if border.size > 0 else 1e-8\n    return float(center_mean / (border_mean + 1e-8))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Mean absolute horizontal gradient in the middle third of the image (captures seams/sleeve edges)'\n    import numpy as np\n    gray = np.mean(image, axis=2) if len(image.shape) == 3 else image.astype(float)\n    h, w = gray.shape\n    gy, gx = np.gradient(gray.astype(float))\n    r0, r1 = h // 3, max(h // 3 + 1, (2 * h) // 3)\n    band = np.abs(gx[r0:r1, :])\n    if band.size == 0:\n        return 0.0\n    return float(np.mean(band))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Elongation: ratio of major to minor eigenvalues of mask coordinate covariance (1.0 if undefined)'\n    import numpy as np\n    if image is None:\n        return 1.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 1.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = gray < thr if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else gray > thr\n    ys, xs = np.where(mask)\n    if ys.size < 3:\n        return 1.0\n    coords = np.vstack((xs.astype(float), ys.astype(float)))\n    cov = np.cov(coords)\n    # handle degenerate case\n    if cov.shape != (2, 2):\n        return 1.0\n    eig = np.linalg.eigvalsh(cov)\n    eig = np.sort(eig)[::-1]\n    if eig[1] <= 0:\n        return float(eig[0] / (eig[1] + 1e-8))\n    return float(eig[0] / eig[1])\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Mean absolute red-green channel contrast normalized by overall intensity (0 if grayscale)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    if len(image.shape) != 3 or image.shape[2] < 3:\n        return 0.0\n    # safe float conversion\n    r = image[:, :, 0].astype(float)\n    g = image[:, :, 1].astype(float)\n    diff = np.abs(r - g)\n    denom = np.mean(np.abs(np.mean(image.astype(float), axis=2))) + 1e-8\n    result = np.mean(diff) / denom\n    return float(result)\n",
    "def feature(image: np.ndarray) -> float:\n    'Horizontal symmetry score (1 = perfect mirror across horizontal axis)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    flipped = np.flipud(gray)\n    diff = np.abs(gray - flipped)\n    mean_diff = float(np.mean(diff))\n    mean_intensity = float(np.mean(gray)) + 1e-8\n    score = 1.0 - (mean_diff / mean_intensity)\n    score = max(0.0, min(1.0, score))\n    return float(score)\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Difference between mean mask width in bottom 15% and top 15% normalized by image width'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 4 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    band = max(1, h // 7)\n    top_widths = np.sum(mask[0:band, :].astype(float), axis=1)\n    bottom_widths = np.sum(mask[h - band:h, :].astype(float), axis=1)\n    mean_top = float(np.mean(top_widths)) if top_widths.size > 0 else 0.0\n    mean_bottom = float(np.mean(bottom_widths)) if bottom_widths.size > 0 else 0.0\n    diff = mean_bottom - mean_top\n    return float(diff / max(1.0, float(w)))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Relative darkness concentration in bottom 15% rows (ratio: bottom dark fraction / overall dark fraction)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 50)\n    overall_dark = np.count_nonzero(gray < thr)\n    bottom_h = max(1, int(0.15 * h))\n    bottom = gray[h - bottom_h:h, :]\n    bottom_dark = np.count_nonzero(bottom < thr)\n    if overall_dark <= 0:\n        return float(bottom_dark / float(h * w))\n    return float((bottom_dark / float(bottom.size)) / (overall_dark / float(gray.size)))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Fraction of center columns that are empty in the top band (indicates neck/opening)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 3 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 50)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    top_band_h = max(1, int(round(h * 0.12)))\n    c0, c1 = w // 4, (3 * w) // 4\n    top_center = mask[:top_band_h, c0:c1]\n    if top_center.size == 0:\n        return 0.0\n    # columns in center that have no foreground in the top band\n    col_empty = np.sum(np.all(top_center == 0, axis=0))\n    return float(col_empty / float(max(1, top_center.shape[1])))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Central vertical dark-line score: how much darker the center column is compared to side columns (positive = darker center)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    if w == 0:\n        return 0.0\n    col_means = np.mean(gray, axis=0)\n    center = w // 2\n    bw = max(1, w // 20)\n    center_mean = float(np.mean(col_means[max(0, center - bw):min(w, center + bw)]))\n    side_mean = float(np.mean(np.concatenate([col_means[:max(0, center - bw)], col_means[min(w, center + bw):]]))) if w - (2*bw) > 0 else float(np.mean(col_means))\n    eps = 1e-8\n    # Positive if center is darker (lower mean) than sides\n    return float((side_mean - center_mean) / (abs(side_mean) + eps))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Largest horizontal background gap in the top 12% center region normalized by image width'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 3 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 50)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    top_h = max(1, int(0.12 * h))\n    center_w = max(1, int(0.30 * w))\n    cx0 = max(0, (w // 2) - (center_w // 2))\n    cx1 = min(w, cx0 + center_w)\n    patch = mask[:top_h, cx0:cx1]\n    if patch.size == 0:\n        return 0.0\n    max_gap = 0\n    for r in range(patch.shape[0]):\n        row = ~patch[r, :]\n        curr = 0\n        for v in row:\n            if v:\n                curr += 1\n                if curr > max_gap:\n                    max_gap = curr\n            else:\n                curr = 0\n    return float(max_gap / (w + 1e-8))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Vertical centroid of object pixels relative to image height (captures where mass concentrates)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    if h == 0 or w == 0:\n        return 0.5\n    bg_h, bg_w = max(1, h // 10), max(1, w // 10)\n    bg = np.mean(gray[:bg_h, :bg_w])\n    gm = np.mean(gray)\n    thresh = (bg + gm) / 2.0\n    object_is_darker = gm < bg\n    if object_is_darker:\n        mask = gray < thresh\n    else:\n        mask = gray > thresh\n    ys, xs = np.where(mask)\n    if ys.size == 0:\n        return 0.5\n    centroid_y = float(np.mean(ys))\n    return float(centroid_y / max(1.0, h))\n",
    "def feature(image: np.ndarray) -> float:\n    'Average number of foreground runs per column (vertical segments) - measures straps/holes/complexity'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 2 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    runs = []\n    for col in range(w):\n        col_mask = mask[:, col].astype(np.uint8)\n        if col_mask.size == 0:\n            runs.append(0)\n            continue\n        # transitions from 0->1 indicate new run\n        trans = np.count_nonzero((col_mask[:-1] == 0) & (col_mask[1:] == 1))\n        # if column starts with foreground, count that run too\n        if col_mask[0]:\n            trans += 1\n        runs.append(trans)\n    if len(runs) == 0:\n        return 0.0\n    return float(np.mean(runs))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Approximate number of connected components in the foreground mask (downsampled)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = ((gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)).astype(bool)\n    if not np.any(mask):\n        return 0.0\n    # downsample to speed up large images\n    max_side = max(h, w)\n    stride = int(max(1, max_side // 64))\n    m = mask[::stride, ::stride]\n    H, W = m.shape\n    visited = np.zeros_like(m, dtype=bool)\n    comps = 0\n    for i in range(H):\n        for j in range(W):\n            if m[i, j] and not visited[i, j]:\n                comps += 1\n                # BFS/DFS\n                stack = [(i, j)]\n                visited[i, j] = True\n                while stack:\n                    y, x = stack.pop()\n                    if y > 0 and m[y - 1, x] and not visited[y - 1, x]:\n                        visited[y - 1, x] = True\n                        stack.append((y - 1, x))\n                    if y + 1 < H and m[y + 1, x] and not visited[y + 1, x]:\n                        visited[y + 1, x] = True\n                        stack.append((y + 1, x))\n                    if x > 0 and m[y, x - 1] and not visited[y, x - 1]:\n                        visited[y, x - 1] = True\n                        stack.append((y, x - 1))\n                    if x + 1 < W and m[y, x + 1] and not visited[y, x + 1]:\n                        visited[y, x + 1] = True\n                        stack.append((y, x + 1))\n    # cap to avoid huge values\n    return float(min(comps, 100))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Vertical coverage ratio: fraction of image rows that contain any object pixels'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    thr = np.mean(gray) + 0.4 * np.std(gray)\n    mask = gray > thr\n    if mask.sum() == 0:\n        mask = gray > np.percentile(gray.flatten(), 90)\n    if mask.sum() == 0:\n        if gray.max() == 0:\n            return 0.0\n        mask = gray > (0.08 * gray.max())\n    rows_with = np.count_nonzero(mask.any(axis=1))\n    return float(rows_with / max(1, h))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Perimeter-to-area ratio of the object mask (thin/strappy objects have higher ratio)'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    thr = np.mean(gray)\n    mask = (gray > thr).astype(np.uint8)\n    h, w = mask.shape[:2]\n    area = float(np.count_nonzero(mask))\n    if area <= 0.0:\n        return 0.0\n    # boundary pixels: mask pixel with any 4-neighbor background\n    boundary = 0\n    for r in range(h):\n        for c in range(w):\n            if mask[r, c]:\n                if r == 0 or r == h - 1 or c == 0 or c == w - 1:\n                    boundary += 1\n                else:\n                    if not (mask[r - 1, c] and mask[r + 1, c] and mask[r, c - 1] and mask[r, c + 1]):\n                        boundary += 1\n    return float(boundary / area)\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Ratio of horizontal-edge energy to vertical-edge energy in the top half (higher -> more horizontal edges)'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    top_h = max(1, h // 2)\n    region = gray[:top_h, :]\n    gy, gx = np.gradient(region)\n    hor = np.sum(np.abs(gy))\n    ver = np.sum(np.abs(gx))\n    return float(hor / (ver + 1e-9))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Center-region fill fraction: proportion of center box occupied (sneakers more fully filled in the center than sandals)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    ch0, ch1 = h//3, 2*h//3\n    cw0, cw1 = w//3, 2*w//3\n    center = gray[ch0:ch1, cw0:cw1]\n    if center.size == 0:\n        return 0.0\n    thresh = float(np.mean(gray))\n    center_bin = (center > thresh).astype(np.uint8)\n    fill_frac = np.count_nonzero(center_bin) / float(center_bin.size)\n    return float(fill_frac)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Ratio of average mask width in top quarter to bottom quarter (sleeve vs pant indicator)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 4 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = gray < thr if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else gray > thr\n    top_end = max(1, h // 4)\n    bot_start = max(0, h - top_end)\n    top_rows = mask[:top_end, :]\n    bot_rows = mask[bot_start:h, :]\n    def avg_width(region):\n        if region.size == 0:\n            return 0.0\n        widths = np.count_nonzero(region, axis=1).astype(float)\n        if widths.size == 0:\n            return 0.0\n        return float(np.mean(widths)) / float(w + 1e-8)\n    top_w = avg_width(top_rows)\n    bot_w = avg_width(bot_rows)\n    return float(top_w / (bot_w + 1e-8))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Vertical symmetry: 1.0 means top-bottom mirror, 0.0 very asymmetric'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 2 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 50)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    top = gray[:h // 2, :]\n    bottom = gray[h - h // 2:, :]\n    bottom_flipped = np.flipud(bottom)\n    # align shapes\n    if top.shape != bottom_flipped.shape:\n        mh = min(top.shape[0], bottom_flipped.shape[0])\n        top = top[:mh, :]\n        bottom_flipped = bottom_flipped[:mh, :]\n    diff = np.mean(np.abs(top - bottom_flipped)) if top.size else 0.0\n    norm = (np.mean(np.abs(gray)) + 1e-8)\n    score = 1.0 - float(diff / norm)\n    return float(max(0.0, min(1.0, score)))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Fraction of mask pixels touching the bottom band (bottom 10% rows)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    total = float(np.count_nonzero(mask))\n    if total == 0.0:\n        return 0.0\n    band = max(1, int(round(h * 0.10)))\n    bottom_count = float(np.count_nonzero(mask[-band:, :]))\n    result = bottom_count / total\n    return float(result)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Left-right symmetry score based on mean absolute difference between mirrored halves (1 symmetric, -1 worst)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 1 or w < 2:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    half = w // 2\n    left = gray[:, :half]\n    right = gray[:, w - half:]\n    # flip left to compare with right\n    left_flip = left[:, ::-1]\n    if left_flip.shape != right.shape:\n        # pad smaller to match\n        minr = min(left_flip.shape[1], right.shape[1])\n        left_flip = left_flip[:, :minr]\n        right = right[:, :minr]\n    diff = np.abs(left_flip - right)\n    denom = (np.mean(np.abs(left_flip)) + np.mean(np.abs(right))) / 2.0 + 1e-8\n    sim = 1.0 - (np.mean(diff) / denom)\n    # clamp between -1 and 1\n    sim = max(-1.0, min(1.0, float(sim)))\n    return float(sim)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Mean (blue - red) inside mask for RGB images, 0.0 for grayscale (color bias in foreground)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    if len(image.shape) != 3 or image.shape[2] < 3:\n        return 0.0\n    h, w, c = image.shape\n    if h == 0 or w == 0:\n        return 0.0\n    # convert to float and channels\n    img = image.astype(float)\n    blue = img[:, :, 2]\n    red = img[:, :, 0]\n    gray = np.mean(img, axis=2)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    if not np.any(mask):\n        return 0.0\n    diff = blue - red\n    mean_diff = float(np.mean(diff[mask]))\n    return float(mean_diff)\n",
    "def feature(image: np.ndarray) -> float:\n    'Normalized left-right symmetry of the main foreground mask (1 = perfectly symmetric)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    total = np.count_nonzero(mask)\n    if total == 0:\n        return 0.0\n    half = w // 2\n    left = mask[:, :half].astype(float)\n    right = mask[:, w - half:].astype(float)\n    # flip right to compare with left (align widths)\n    right_flipped = np.fliplr(right)\n    # if widths differ pad the smaller\n    if left.shape[1] != right_flipped.shape[1]:\n        minw = min(left.shape[1], right_flipped.shape[1])\n        left = left[:, :minw]\n        right_flipped = right_flipped[:, :minw]\n    diff = np.sum(np.abs(left - right_flipped))\n    diff_norm = float(diff) / (total + 1e-8)\n    sym = 1.0 - min(diff_norm, 1.0)\n    return float(sym)\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Maximum contiguous object run length in a top slice row normalized by bounding-box width (captures narrow straps/openings)'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    mn, mx = float(np.min(gray)), float(np.max(gray))\n    if mx - mn <= 1e-9:\n        return 0.0\n    thresh = mn + 0.2 * (mx - mn)\n    mask = gray > thresh\n    if not mask.any():\n        return 0.0\n    rows = np.where(mask.any(axis=1))[0]\n    cols = np.where(mask.any(axis=0))[0]\n    if rows.size == 0 or cols.size == 0:\n        return 0.0\n    top, bottom = rows[0], rows[-1]\n    left, right = cols[0], cols[-1]\n    bbox_h = bottom - top + 1\n    # choose a row near the top of the object (10% down into bbox)\n    probe_row = top + max(0, int(round(bbox_h * 0.1)))\n    probe_row = min(probe_row, mask.shape[0] - 1)\n    row_seg = mask[probe_row, left:(right + 1)].astype(np.uint8)\n    if row_seg.size == 0:\n        return 0.0\n    # find max contiguous run\n    max_run = 0\n    cur = 0\n    for v in row_seg:\n        if v:\n            cur += 1\n            if cur > max_run:\n                max_run = cur\n        else:\n            cur = 0\n    bbox_w = max(1.0, right - left + 1)\n    return float(max_run / bbox_w)\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Ratio of object area to its bounding-box area (how blocky/rectangular the silhouette is)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.mean(gray) + 0.15 * (np.max(gray) - np.min(gray))\n    mask = gray > thr\n    if not mask.any():\n        mask = gray > np.mean(gray)\n        if not mask.any():\n            return 0.0\n    rows, cols = np.where(mask)\n    if rows.size == 0:\n        return 0.0\n    top, bottom = rows.min(), rows.max()\n    left, right = cols.min(), cols.max()\n    bbox_area = float((bottom - top + 1) * (right - left + 1))\n    area = float(np.count_nonzero(mask))\n    return float(area / (bbox_area + 1e-8))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Central vertical streakiness: sum of absolute vertical gradients along center column (normalized)'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape\n    mid = w // 2\n    # handle narrow images by averaging over a few center columns\n    cols = [mid]\n    if w >= 3:\n        cols = [mid - 1, mid, mid + 1]\n    cols = [c for c in cols if 0 <= c < w]\n    colvals = np.mean(gray[:, cols], axis=1) if len(cols) > 1 else gray[:, cols[0]]\n    vgrad = np.abs(np.diff(colvals.astype(float)))\n    score = float(vgrad.sum()) / float(max(1.0, h))\n    return float(score)\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Ratio of summed vertical-edge magnitude to horizontal-edge magnitude in the lower half (captures sole/side edges)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    if h < 2 or w < 2:\n        return 0.0\n    gy, gx = np.gradient(gray)\n    lower_half = slice(h // 2, h)\n    abs_gx = np.abs(gx[lower_half, :]).sum()\n    abs_gy = np.abs(gy[lower_half, :]).sum()\n    denom = float(abs_gy) + 1e-8\n    return float(abs_gx / denom)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Vertical symmetry score of the central object region (1.0 = perfect symmetry)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    mid = w // 2\n    if mid == 0:\n        return 0.0\n    # use central half area to avoid border noise\n    left = gray[:, max(0, w//4):max(0, w//4)+mid]\n    right = gray[:, w - (left.shape[1]):w]\n    if left.size == 0 or right.size == 0:\n        return 0.0\n    right_flipped = np.fliplr(right)\n    diff = np.mean(np.abs(left - right_flipped))\n    denom = np.maximum(np.mean(gray), 1e-8)\n    score = 1.0 - (diff / denom)\n    return float(np.clip(score, 0.0, 1.0))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Fraction of connected foreground components that are small (small blobs / total blobs)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    visited = np.zeros_like(mask, dtype=bool)\n    comps = 0\n    small = 0\n    area_thresh = max(1, int(0.01 * h * w))\n    for y in range(h):\n        for x in range(w):\n            if mask[y, x] and not visited[y, x]:\n                comps += 1\n                # BFS\n                stack = [(y, x)]\n                visited[y, x] = True\n                cnt = 0\n                while stack:\n                    yy, xx = stack.pop()\n                    cnt += 1\n                    for dy in (-1, 0, 1):\n                        for dx in (-1, 0, 1):\n                            ny, nx = yy + dy, xx + dx\n                            if ny < 0 or ny >= h or nx < 0 or nx >= w:\n                                continue\n                            if not visited[ny, nx] and mask[ny, nx]:\n                                visited[ny, nx] = True\n                                stack.append((ny, nx))\n                if cnt <= area_thresh:\n                    small += 1\n    if comps == 0:\n        return 0.0\n    return float(small / float(comps))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Vertical symmetry score: normalized pixel-wise mirroring difference (lower = more symmetric)'\n    if image is None:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    h, w = gray.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    # use a soft binary to emphasize object\n    thresh = 0.5 * np.percentile(gray, 75) + 0.5 * np.mean(gray)\n    bw = (gray > thresh).astype(np.float32)\n    # crop to bounding box\n    coords = np.argwhere(bw)\n    if coords.size == 0:\n        return 0.0\n    ys, xs = coords[:, 0], coords[:, 1]\n    top, bottom = ys.min(), ys.max()\n    left, right = xs.min(), xs.max()\n    patch = bw[top:bottom + 1, left:right + 1]\n    ph, pw = patch.shape\n    if pw <= 1:\n        return 0.0\n    # compute left-right mirrored difference\n    mid = pw // 2\n    left_part = patch[:, :mid]\n    right_part = np.fliplr(patch[:, pw - mid:pw])\n    # align sizes\n    min_w = min(left_part.shape[1], right_part.shape[1])\n    if min_w == 0:\n        return 0.0\n    diff = np.abs(left_part[:, :min_w] - right_part[:, :min_w])\n    score = float(np.sum(diff) / (np.sum(patch) + 1e-9))\n    return float(score)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Ratio of bottom quarter mask area to middle half mask area (compactness at bottom)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = gray < thr if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else gray > thr\n    total = np.count_nonzero(mask)\n    if total == 0:\n        return 0.0\n    bottom = mask[int(0.75*h):h, :]\n    mid = mask[int(0.25*h):int(0.75*h), :]\n    bottom_count = np.count_nonzero(bottom)\n    mid_count = np.count_nonzero(mid)\n    return float((bottom_count + 1.0) / (mid_count + 1.0))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Ratio of maximum row-wise object width to mean row-wise width (higher when skirt/dress flares out)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(np.float32)\n    else:\n        gray = image.astype(np.float32)\n    h, w = gray.shape[:2]\n    mn, mx = np.min(gray), np.max(gray)\n    if mx - mn < 1e-6:\n        binary = gray > mx * 0.5\n    else:\n        thr = float(np.percentile(gray, 50))\n        binary = gray > thr\n    widths = []\n    for r in range(h):\n        row = binary[r, :]\n        if np.any(row):\n            cols = np.where(row)[0]\n            widths.append(float(cols[-1] - cols[0] + 1))\n        else:\n            widths.append(0.0)\n    widths = np.array(widths, dtype=np.float32)\n    mean_w = float(np.mean(widths))\n    max_w = float(np.max(widths))\n    if mean_w <= 1e-6:\n        return 0.0\n    return float(max_w / mean_w)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Fraction of columns that contain a long vertical strong edge streak (indicative of straps/long seams)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 3 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    gy, gx = np.gradient(gray.astype(float))\n    vert_mag = np.abs(gx)\n    if not np.any(vert_mag):\n        return 0.0\n    thr = np.percentile(vert_mag, 70)\n    strong = vert_mag > thr\n    min_run = max(1, int(h * 0.35))\n    col_count = 0\n    for c in range(w):\n        col = strong[:, c].astype(int)\n        if not np.any(col):\n            continue\n        # compute longest run of 1s in column\n        pad = np.concatenate(([0], col, [0]))\n        diff = np.diff(pad)\n        starts = np.where(diff == 1)[0]\n        ends = np.where(diff == -1)[0]\n        lengths = ends - starts\n        if lengths.size > 0 and np.max(lengths) >= min_run:\n            col_count += 1\n    return float(col_count / float(w + 1e-8))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Left-right symmetry of the foreground mask (1.0 = perfectly symmetric)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    # grayscale\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 50)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    if not np.any(mask):\n        return 0.0\n    # split and mirror right half\n    mid = w // 2\n    left = mask[:, :mid].astype(float)\n    right = mask[:, w - mid:w].astype(float)[:, ::-1]\n    # pad smaller to same shape\n    if left.shape[1] != right.shape[1]:\n        mn = min(left.shape[1], right.shape[1])\n        left = left[:, :mn]\n        right = right[:, :mn]\n    diff = np.abs(left - right)\n    norm = float(np.sum(mask.astype(float))) + 1e-8\n    score = 1.0 - float(np.sum(diff)) / norm\n    return float(np.clip(score, 0.0, 1.0))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Count of significant local minima in per-row mask widths (normalized by image height)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 3 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    row_widths = np.sum(mask, axis=1).astype(float)\n    # smooth widths\n    k = 5\n    kernel = np.ones(k) / float(k)\n    smooth = np.convolve(row_widths, kernel, mode='same')\n    med = np.median(smooth) if smooth.size > 0 else 0.0\n    minima = 0\n    for i in range(1, h - 1):\n        if smooth[i] < smooth[i - 1] and smooth[i] < smooth[i + 1] and smooth[i] < max(1e-6, 0.9 * med):\n            minima += 1\n    return float(minima / max(1.0, float(h)))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Mask fill ratio: mask pixel count divided by its bounding-box area (solidity-like)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 50)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    ys, xs = np.where(mask)\n    if ys.size == 0:\n        return 0.0\n    miny, maxy = int(np.min(ys)), int(np.max(ys))\n    minx, maxx = int(np.min(xs)), int(np.max(xs))\n    bbox_h = max(1, maxy - miny + 1)\n    bbox_w = max(1, maxx - minx + 1)\n    bbox_area = float(bbox_h * bbox_w)\n    mask_area = float(np.count_nonzero(mask))\n    return float(mask_area / (bbox_area + 1e-8))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Count of vertical mask runs (separate vertical strokes) normalized by width'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 50)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    if not np.any(mask):\n        return 0.0\n    cols_any = np.any(mask, axis=0).astype(int)\n    # count runs of consecutive True columns\n    prev = 0\n    runs = 0\n    for v in cols_any:\n        if v == 1 and prev == 0:\n            runs += 1\n        prev = v\n    result = float(runs) / float(w + 1e-8)\n    return float(result)\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Width/height aspect ratio of the mask bounding box (>=0, 1.0 if undefined)'\n    import numpy as np\n    if image is None:\n        return 1.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 1.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    ys, xs = np.where(mask)\n    if ys.size == 0:\n        return 1.0\n    miny, maxy = ys.min(), ys.max()\n    minx, maxx = xs.min(), xs.max()\n    bw = float(maxx - minx + 1)\n    bh = float(maxy - miny + 1)\n    if bh <= 0:\n        return 1.0\n    return float(bw / (bh + 1e-8))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Left-right mirror symmetry score of the object mask (1.0 = perfectly symmetric, 0.0 = very asymmetric)'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    gray = gray.astype(float)\n    if np.nanmax(gray) == np.nanmin(gray):\n        return 0.0\n    thr = np.percentile(gray, 70)\n    mask = (gray > thr).astype(int)\n    rows, cols = np.where(mask)\n    if rows.size == 0:\n        return 0.0\n    left, right = cols.min(), cols.max()\n    # restrict to bbox for symmetry calculation\n    bbox = mask[:, left:right+1]\n    # flip horizontally and compare\n    flipped = np.fliplr(bbox)\n    diff = np.sum(np.abs(bbox - flipped))\n    total = np.sum(bbox) + 1e-9\n    sym = 1.0 - (diff / (2.0 * total))  # normalized to roughly [ - , 1]\n    return float(max(0.0, min(1.0, sym)))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Vertical centroid position normalized (0.0 = top, 1.0 = bottom) of mask mass'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    ys, xs = np.where(mask)\n    if ys.size == 0:\n        return 0.0\n    yc = float(np.mean(ys))\n    return float(yc / float(h))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Torso-to-top width ratio: average horizontal width in mid-band divided by width in top quarter (helps identify long body shapes)'\n    import numpy as np\n    img = np.asarray(image)\n    if img.size == 0:\n        return 0.0\n    if img.ndim == 3:\n        gray = np.mean(img, axis=2)\n    else:\n        gray = image.astype(float)\n    thr = max(np.mean(gray) * 0.5, np.max(gray) * 0.05)\n    mask = gray > thr\n    if not mask.any():\n        return 0.0\n    ys, xs = np.where(mask)\n    r0, r1 = ys.min(), ys.max()\n    c0, c1 = xs.min(), xs.max()\n    bh = r1 - r0 + 1\n    # mid band rows\n    mid_top = r0 + bh//3\n    mid_bottom = r0 + 2*bh//3\n    top_bottom = r0 + max(1, bh//4)\n    def mean_width(r_start, r_end):\n        widths = []\n        for rr in range(r_start, min(r_end+1, gray.shape[0])):\n            row = mask[rr, c0:c1+1]\n            if row.any():\n                left = np.argmax(row)\n                right = row.size - 1 - np.argmax(row[::-1])\n                widths.append((right - left + 1))\n        return float(np.mean(widths)) if widths else 0.0\n    mid_w = mean_width(mid_top, mid_bottom)\n    top_w = mean_width(r0, top_bottom)\n    if top_w <= 1e-9:\n        return float(mid_w)\n    return float(mid_w / top_w)\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Normalized vertical centroid of the object within its bounding box (higher = lower centroid)'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    thresh = np.mean(gray) + 0.25 * np.std(gray)\n    mask = (gray > thresh).astype(float)\n    rows, cols = np.where(mask > 0)\n    if rows.size == 0:\n        return 0.0\n    top, bottom = rows.min(), rows.max()\n    left, right = cols.min(), cols.max()\n    sub = mask[top:bottom+1, left:right+1]\n    # compute centroid weighted by mask (binary)\n    ys = np.arange(top, bottom+1)\n    if sub.sum() == 0:\n        return 0.0\n    col_sums = sub.sum(axis=1)  # sums per row\n    centroid_y = (ys * col_sums).sum() / (col_sums.sum() + 1e-9)\n    return float((centroid_y - top) / max(1.0, (bottom - top)))\n",
    "def feature(image: np.ndarray) -> float:\n    'Normalized left-right L1 symmetry inside the object bbox (lower -> more symmetric)'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    thr = np.mean(gray) + 0.5 * np.std(gray)\n    mask = gray > thr\n    if not np.any(mask):\n        return 0.0\n    rows = np.any(mask, axis=1)\n    cols = np.any(mask, axis=0)\n    r_idxs = np.where(rows)[0]\n    c_idxs = np.where(cols)[0]\n    if r_idxs.size == 0 or c_idxs.size == 0:\n        return 0.0\n    r0, r1 = r_idxs[0], r_idxs[-1] + 1\n    c0, c1 = c_idxs[0], c_idxs[-1] + 1\n    bb = gray[r0:r1, c0:c1]\n    # resize to even width slice by mirroring center if necessary\n    bw = bb.shape[1]\n    mid = bw // 2\n    left = bb[:, :mid]\n    right = bb[:, -mid:]\n    if left.size == 0 or right.size == 0:\n        return 0.0\n    right_flipped = np.fliplr(right)\n    diff = np.abs(left - right_flipped[:, :left.shape[1]])\n    norm = np.mean(np.abs(bb)) + 1e-8\n    score = np.mean(diff) / norm\n    return float(score)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Average number of internal background segments per row inside object bbox (holes)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    if not np.any(mask):\n        return 0.0\n    rows = np.where(np.any(mask, axis=1))[0]\n    if rows.size == 0:\n        return 0.0\n    r0, r1 = rows[0], rows[-1]\n    counts = []\n    for r in range(r0, r1 + 1):\n        row = mask[r, :].astype(int)\n        if not np.any(row):\n            counts.append(0)\n            continue\n        # identify zero-runs that are strictly inside ones (surrounded)\n        pad = np.concatenate(([0], row, [0]))\n        diff = np.diff(pad)\n        starts = np.where(diff == -1)[0]  # zero run starts in pad indexing\n        ends = np.where(diff == 1)[0]     # zero run ends\n        # convert to original indexing and count those with ones on both sides\n        cnt = 0\n        for s, e in zip(starts, ends):\n            left_idx = s - 1\n            right_idx = e - 1\n            if left_idx >= 0 and right_idx < w and left_idx < right_idx:\n                if row[left_idx] == 1 and row[right_idx] == 1:\n                    cnt += 1\n        counts.append(cnt)\n    if len(counts) == 0:\n        return 0.0\n    return float(np.mean(counts))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Normalized count of prominent peaks in the vertical projection (number of separated vertical components)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if w < 3 or h == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    col_counts = np.sum(mask, axis=0).astype(float)\n    if np.all(col_counts == 0):\n        return 0.0\n    # simple smoothing\n    kern = np.array([1.0, 1.0, 1.0]) / 3.0\n    smooth = np.convolve(col_counts, kern, mode='same')\n    meanv = float(np.mean(smooth)); stdv = float(np.std(smooth))\n    peaks = 0\n    for i in range(1, w - 1):\n        if smooth[i] > smooth[i - 1] and smooth[i] > smooth[i + 1] and smooth[i] > (meanv + 0.5 * stdv):\n            peaks += 1\n    return float(peaks) / float(w)\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Principal axis elongation: ratio of minor to major eigenvalue of foreground pixel covariance (0..1)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 90) * 0.5\n    mask = gray > thr\n    if np.count_nonzero(mask) == 0:\n        thr = np.mean(gray)\n        mask = gray > thr\n    coords = np.column_stack(np.nonzero(mask))\n    if coords.shape[0] < 3:\n        return 0.0\n    # center coordinates and compute covariance\n    coords = coords.astype(float)\n    coords -= coords.mean(axis=0, keepdims=True)\n    cov = np.cov(coords, rowvar=False)\n    # handle degenerate cov\n    try:\n        eig = np.linalg.eigvalsh(cov)\n    except Exception:\n        eig = np.array([0.0, 0.0])\n    eig = np.sort(eig)\n    major = eig[-1]\n    minor = eig[0]\n    if major <= 0:\n        return 0.0\n    ratio = float(minor / (major + 1e-9))\n    return float(np.clip(ratio, 0.0, 1.0))\n",
    "def feature(image: np.ndarray) -> float:\n    'Number of connected components in binary mask (4-neighborhood), capped for performance'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    visited = np.zeros_like(mask, dtype=bool)\n    comps = 0\n    area = np.count_nonzero(mask)\n    if area == 0:\n        return 0.0\n    # cap: if too many pixels, limit complexity by sampling grid\n    cap_pixels = 20000\n    if area > cap_pixels:\n        # approximate by scanning a downsampled grid\n        stride = int(np.ceil(np.sqrt(area / cap_pixels)))\n    else:\n        stride = 1\n    for y in range(0, h, stride):\n        for x in range(0, w, stride):\n            if not visited[y, x] and mask[y, x]:\n                comps += 1\n                # flood fill stack\n                stack = [(y, x)]\n                while stack:\n                    cy, cx = stack.pop()\n                    if cy < 0 or cy >= h or cx < 0 or cx >= w:\n                        continue\n                    if visited[cy, cx] or not mask[cy, cx]:\n                        continue\n                    visited[cy, cx] = True\n                    # 4-neighbors\n                    stack.append((cy-1, cx))\n                    stack.append((cy+1, cx))\n                    stack.append((cy, cx-1))\n                    stack.append((cy, cx+1))\n    return float(comps)\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Asymmetry of vertical edge energy between left and right image quarters (0 symmetric, 1 very asymmetric)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 2 or w < 4:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    gy, gx = np.gradient(gray.astype(float))\n    vert_edges = np.abs(gx)\n    q = max(1, w // 4)\n    left_sum = float(np.sum(vert_edges[:, :q]))\n    right_sum = float(np.sum(vert_edges[:, -q:]))\n    total = left_sum + right_sum + 1e-8\n    asym = abs(left_sum - right_sum) / total\n    return float(asym)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Normalized horizontal offset of binary mask centroid from image center (negative = left, positive = right)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask1 = gray < thr\n    mask2 = gray > thr\n    mask = mask1 if np.count_nonzero(mask1) >= np.count_nonzero(mask2) else mask2\n    total = np.count_nonzero(mask)\n    if total == 0:\n        return 0.0\n    ys = np.arange(h).reshape(h, 1)\n    xs = np.arange(w).reshape(1, w)\n    cx = float(np.sum(mask * xs) / total)\n    center_x = (w - 1) / 2.0\n    offset = (cx - center_x) / max(1.0, w / 2.0)\n    return float(offset)\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Relative horizontal span of object in the middle band compared to top band (sleeve extension vs shoulder width)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    mean, mx = np.mean(gray), np.max(gray)\n    thr = mean + 0.15 * (mx - mean)\n    mask = gray > thr\n    if not np.any(mask):\n        thr = np.percentile(gray, 90)\n        mask = gray > thr\n    if not np.any(mask):\n        return 0.0\n    rows_any = np.any(mask, axis=1)\n    rmin = int(np.argmax(rows_any))\n    rmax = int(len(rows_any) - np.argmax(rows_any[::-1]) - 1)\n    if rmax <= rmin:\n        return 0.0\n    bbox_h = rmax - rmin + 1\n    top_band = mask[rmin:rmin + max(1, bbox_h//4), :]\n    mid_band = mask[rmin + bbox_h//3 : rmin + bbox_h//3 + max(1, bbox_h//4), :]\n    def span_fraction(band):\n        cols = np.any(band, axis=0)\n        if not np.any(cols):\n            return 0.0\n        left = int(np.argmax(cols))\n        right = int(len(cols) - np.argmax(cols[::-1]) - 1)\n        return float((right - left + 1) / w)\n    top_span = span_fraction(top_band)\n    mid_span = span_fraction(mid_band)\n    if top_span <= 0:\n        return float(mid_span)\n    return float(mid_span / (top_span + 1e-9))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Fraction of adjacent columns where the top mask boundary is nearly horizontal (flat top indicator)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 60)\n    mask = gray < thr if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else gray > thr\n    top_rows = np.full((w,), h, dtype=int)\n    for c in range(w):\n        col = mask[:, c]\n        nz = np.nonzero(col)[0]\n        if nz.size > 0:\n            top_rows[c] = int(nz[0])\n    valid = (top_rows < h)\n    if np.count_nonzero(valid) <= 1:\n        return 0.0\n    # consider adjacent valid column pairs\n    counts = 0\n    pairs = 0\n    for c in range(w - 1):\n        if valid[c] and valid[c + 1]:\n            pairs += 1\n            if abs(int(top_rows[c]) - int(top_rows[c + 1])) <= 1:\n                counts += 1\n    if pairs == 0:\n        return 0.0\n    return float(counts / float(pairs))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Mean intensity of a narrow central vertical strip relative to object mean (detects open coat center)'\n    import numpy as np\n    gray = np.mean(image, axis=2) if len(image.shape) == 3 else image.astype(float)\n    h, w = gray.shape[:2]\n    thresh = np.percentile(gray, 60)\n    mask = gray > thresh\n    if mask.sum() == 0:\n        mask = gray > np.mean(gray)\n    ys, xs = np.where(mask)\n    if ys.size == 0:\n        return 1.0\n    miny, maxy = ys.min(), ys.max()\n    minx, maxx = xs.min(), xs.max()\n    bbox = gray[miny:maxy+1, minx:maxx+1]\n    bw = bbox.shape[1]\n    strip_w = max(1, bw // 8)\n    cx = bw // 2\n    center_strip = bbox[:, max(0, cx - strip_w):min(bw, cx + strip_w)]\n    mean_center = np.mean(center_strip) if center_strip.size else 0.0\n    mean_obj = np.mean(bbox) if bbox.size else 1.0\n    return float(mean_center / (mean_obj + 1e-6))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Asymmetry of average intensities between top-left and top-right quarters (helps detect collars/one-sided features)'\n    import numpy as np\n    gray = np.mean(image, axis=2) if len(image.shape) == 3 else image.astype(float)\n    h, w = gray.shape[:2]\n    th, tw = max(1, h // 4), max(1, w // 4)\n    tl = gray[0:th, 0:tw]\n    tr = gray[0:th, max(0, w - tw):w]\n    if tl.size == 0 or tr.size == 0:\n        return 0.0\n    ml = np.mean(tl)\n    mr = np.mean(tr)\n    return float(abs(ml - mr) / (max(ml, mr) + 1e-6))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Minimum object width in the middle third divided by maximum width in the top third (waist narrowness)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.copy()\n    mx = float(np.max(gray))\n    if mx <= 0:\n        return 0.0\n    mask = gray > (mx * 0.1)\n    if not np.any(mask):\n        return 0.0\n    rows = np.any(mask, axis=1)\n    cols = np.any(mask, axis=0)\n    r_idx = np.where(rows)[0]\n    c_idx = np.where(cols)[0]\n    if r_idx.size == 0 or c_idx.size == 0:\n        return 0.0\n    r0, r1 = r_idx[0], r_idx[-1] + 1\n    c0, c1 = c_idx[0], c_idx[-1] + 1\n    bbox = mask[r0:r1, c0:c1]\n    H = bbox.shape[0]\n    if H < 3:\n        return 0.0\n    top_third = bbox[:max(1, H//3), :]\n    mid_third = bbox[H//3:2*H//3, :]\n    # compute per-row widths\n    top_row_widths = np.count_nonzero(np.any(top_third, axis=1))\n    # for middle, find minimal row span (width of True columns for each row) then take min normalized\n    row_col_counts_mid = [np.count_nonzero(row) for row in mid_third]\n    if len(row_col_counts_mid) == 0:\n        mid_min = 0.0\n    else:\n        mid_min = float(min(row_col_counts_mid))\n    top_max = float(max(1, top_row_widths))\n    eps = 1e-6\n    return float(mid_min / (top_max + eps))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Difference between edge energy in top-center and top-corners normalized by total edge energy'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    # simple Sobel-like gradient via np.gradient\n    gy, gx = np.gradient(gray)\n    edge = np.abs(gx) + np.abs(gy)\n    total_edge = np.sum(edge) + 1e-9\n    # define regions\n    top_h = max(1, h // 6)\n    corner_w = max(1, w // 6)\n    center_w = max(1, w // 3)\n    top_center = edge[0:top_h, (w // 2 - center_w // 2):(w // 2 + center_w // 2)]\n    top_left = edge[0:top_h, 0:corner_w]\n    top_right = edge[0:top_h, w - corner_w:w]\n    center_energy = np.sum(top_center)\n    corner_energy = np.sum(top_left) + np.sum(top_right)\n    # larger positive value means center more edged (e.g., handles), negative means corners stronger (e.g., collars)\n    return float((center_energy - corner_energy) / total_edge)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Left-right symmetry score (1.0 = perfectly symmetric, 0.0 = very asymmetric)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if w < 2:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    # crop to central vertical band to avoid border noise\n    cx = w // 2\n    bw = max(1, w // 2)\n    left = gray[:, max(0, cx - bw):cx]\n    right = gray[:, cx:min(w, cx + bw)]\n    # mirror right to compare\n    if left.size == 0 or right.size == 0:\n        return 0.0\n    # make same shape by trimming larger\n    min_c = min(left.shape[1], right.shape[1])\n    left = left[:, :min_c]\n    right = right[:, :min_c]\n    right_mirror = np.fliplr(right)\n    diff = np.abs(left - right_mirror)\n    denom = np.mean(np.abs(gray)) + 1e-8\n    score = 1.0 - (np.mean(diff) / denom)\n    # clamp to [0,1]\n    score = max(0.0, min(1.0, float(score)))\n    return float(score)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Count of distinct horizontal peaks in the mask row profile (normalized by height)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 3 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    row_sums = np.sum(mask.astype(float), axis=1)\n    # simple smoothing kernel\n    kernel = np.array([1.0, 1.0, 1.0])\n    smooth = np.convolve(row_sums, kernel, mode='same') / np.sum(kernel)\n    meanv = float(np.mean(smooth))\n    peaks = 0\n    for i in range(1, h - 1):\n        if smooth[i] > smooth[i - 1] and smooth[i] > smooth[i + 1] and smooth[i] > meanv * 0.8:\n            peaks += 1\n    return float(peaks / float(max(1, h)))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Horizontal centroid variation across rows: std of per-row x-centroids normalized by image width'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h <= 1 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    xs = np.arange(w).astype(float)\n    centroids = []\n    for r in range(h):\n        row = mask[r, :]\n        total = np.sum(row)\n        if total > 0:\n            centroids.append(float(np.sum(xs * row) / total))\n    if len(centroids) == 0:\n        return 0.0\n    centroids = np.array(centroids)\n    std_cent = float(np.std(centroids))\n    return float(std_cent / (w + 1e-8))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Number of contiguous mask segments in the central column (0..n), useful for leg separation'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    center_col = w // 2\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 50)\n    mask = ((gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)).astype(np.uint8)\n    col = mask[:, center_col]\n    if col.size == 0:\n        return 0.0\n    # count transitions from 0->1\n    dif = np.diff(np.concatenate([[0], col, [0]]))\n    starts = np.count_nonzero(dif == 1)\n    return float(starts)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Difference in mean intensity between bottom and top halves within a narrow central vertical strip (normalized)'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    mn, mx = float(gray.min()), float(gray.max())\n    grayn = (gray - mn) / (mx - mn + 1e-12)\n    mask = grayn > 0.2\n    if not mask.any():\n        return 0.0\n    rows = np.any(mask, axis=1); cols = np.any(mask, axis=0)\n    rmin = int(np.argmax(rows)); rmax = h - int(np.argmax(rows[::-1])) - 1\n    cmin = int(np.argmax(cols)); cmax = w - int(np.argmax(cols[::-1])) - 1\n    if rmax <= rmin or cmax <= cmin:\n        return 0.0\n    bbox_h = rmax - rmin + 1\n    bbox_w = cmax - cmin + 1\n    center = cmin + bbox_w // 2\n    half_width = max(1, int(max(1, bbox_w * 0.075)))\n    c0 = max(cmin, center - half_width)\n    c1 = min(cmax + 1, center + half_width + 1)\n    mid = rmin + bbox_h // 2\n    top_strip = grayn[rmin:mid, c0:c1]\n    bot_strip = grayn[mid:rmax+1, c0:c1]\n    if top_strip.size == 0 or bot_strip.size == 0:\n        return 0.0\n    top_mean = float(np.mean(top_strip))\n    bot_mean = float(np.mean(bot_strip))\n    obj_mean = float(np.mean(grayn[mask])) if mask.any() else 1.0\n    return float((bot_mean - top_mean) / (obj_mean + 1e-9))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Shape elongation from PCA (ratio of principal axis to minor axis)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    coords = np.argwhere(mask)\n    if coords.shape[0] < 3:\n        return 0.0\n    # compute covariance and SVD for stable principal values\n    centered = coords.astype(float) - np.mean(coords.astype(float), axis=0)\n    try:\n        u, s, vt = np.linalg.svd(centered, full_matrices=False)\n    except Exception:\n        # fallback to covariance eigenvals\n        cov = np.cov(centered.T)\n        evals = np.linalg.eigvalsh(cov)\n        s = np.sqrt(np.maximum(evals, 0.0))\n    # s contains singular values; s[0] >= s[1]\n    if s.size < 2 or s[1] <= 0:\n        return float(s[0] / (1e-8 + 1.0))\n    ratio = float(s[0] / (s[1] + 1e-8))\n    return float(ratio)\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Relative texture: coefficient of variation (std/mean) of intensities inside mask'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 60)\n    mask = ((gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)).astype(bool)\n    vals = gray[mask]\n    if vals.size == 0:\n        return 0.0\n    mean = float(np.mean(vals))\n    std = float(np.std(vals))\n    return float(std / (abs(mean) + 1e-8))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Mean Euclidean distance of mask pixels to their centroid normalized by image diagonal'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = gray < thr if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else gray > thr\n    ys, xs = np.where(mask)\n    if ys.size == 0:\n        return 0.0\n    cx = float(np.mean(xs))\n    cy = float(np.mean(ys))\n    d = np.sqrt((xs - cx) ** 2 + (ys - cy) ** 2)\n    mean_d = float(np.mean(d))\n    diag = np.sqrt(float(h * h + w * w))\n    return float(mean_d / (diag + 1e-8))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Number of connected components in the thresholded mask (small components ignored), returned as a float'\n    import numpy as np\n    from collections import deque\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    vis = np.zeros_like(mask, dtype=bool)\n    comps = 0\n    min_area = max(1, (h * w) // 200)  # ignore tiny specks\n    for y in range(h):\n        for x in range(w):\n            if mask[y, x] and not vis[y, x]:\n                # BFS flood fill\n                comps += 1\n                area = 0\n                dq = deque()\n                dq.append((y, x))\n                vis[y, x] = True\n                while dq:\n                    yy, xx = dq.popleft()\n                    area += 1\n                    # 4-neighbors\n                    if yy > 0 and mask[yy - 1, xx] and not vis[yy - 1, xx]:\n                        vis[yy - 1, xx] = True\n                        dq.append((yy - 1, xx))\n                    if yy + 1 < h and mask[yy + 1, xx] and not vis[yy + 1, xx]:\n                        vis[yy + 1, xx] = True\n                        dq.append((yy + 1, xx))\n                    if xx > 0 and mask[yy, xx - 1] and not vis[yy, xx - 1]:\n                        vis[yy, xx - 1] = True\n                        dq.append((yy, xx - 1))\n                    if xx + 1 < w and mask[yy, xx + 1] and not vis[yy, xx + 1]:\n                        vis[yy, xx + 1] = True\n                        dq.append((yy, xx + 1))\n                # if component too small, subtract it from count\n                if area < min_area:\n                    comps -= 1\n    return float(max(0, comps))\n",
    "def feature(image: np.ndarray) -> float:\n    'Fraction of empty pixels in the top 20% of the foreground bounding box (top gap ratio)'\n    import numpy as np\n    if image is None:\n        return 1.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 1.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 50)\n    mask = ((gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)).astype(bool)\n    coords = np.argwhere(mask)\n    if coords.size == 0:\n        return 1.0\n    ys, xs = coords[:, 0], coords[:, 1]\n    miny, maxy = int(ys.min()), int(ys.max())\n    minx, maxx = int(xs.min()), int(xs.max())\n    sub = mask[miny:maxy+1, minx:maxx+1]\n    bh = sub.shape[0]\n    top_band = max(1, int(bh * 0.2))\n    top_region = sub[0:top_band, :]\n    empty = float(np.count_nonzero(~top_region))\n    total = float(top_region.size)\n    return float(empty / (total + 1e-8))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Mean horizontal run-length of mask segments (averaged over all segments) normalized by image width'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    seg_lengths = []\n    for r in range(h):\n        row = mask[r, :].astype(int)\n        if np.any(row):\n            pad = np.concatenate(([0], row, [0]))\n            d = np.diff(pad)\n            starts = np.where(d == 1)[0]\n            ends = np.where(d == -1)[0]\n            if starts.size > 0:\n                seg_lengths.extend((ends - starts).tolist())\n    if len(seg_lengths) == 0:\n        return 0.0\n    mean_len = float(np.mean(seg_lengths))\n    return float(mean_len / (w + 1e-8))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Mean color saturation (approx) for RGB images, 0 for grayscale'\n    import numpy as np\n    if image is None:\n        return 0.0\n    if len(image.shape) != 3 or image.shape[2] < 3:\n        return 0.0\n    # compute per-pixel saturation = (max-min)/(max+eps)\n    img = image.astype(float)\n    mx = np.max(img, axis=2)\n    mn = np.min(img, axis=2)\n    denom = np.maximum(mx, 1e-8)\n    sat = (mx - mn) / denom\n    return float(np.mean(sat))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Strength of a vertical dark seam near center in the upper half: center intensity vs side intensities (higher -> darker center)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    top_h = max(1, h // 2)\n    strip_w = max(1, w // 20)\n    c = w // 2\n    center_strip = gray[0:top_h, max(0, c - strip_w):min(w, c + strip_w)]\n    left_strip = gray[0:top_h, max(0, c - 4 * strip_w):max(0, c - 2 * strip_w)]\n    right_strip = gray[0:top_h, min(w, c + 2 * strip_w):min(w, c + 4 * strip_w)]\n    # compute means, be robust to empty slices\n    def safe_mean(a):\n        if a.size == 0:\n            return 0.0\n        return float(np.mean(a))\n    mc = safe_mean(center_strip)\n    ml = safe_mean(left_strip)\n    mr = safe_mean(right_strip)\n    side_mean = (ml + mr) / 2.0\n    # if center is darker than sides, measure relative darkness\n    denom = (side_mean + 1e-9)\n    return float((side_mean - mc) / denom)\n",
    "def feature(image: np.ndarray) -> float:\n    'Density of strong edges in the lower quarter of the image (edges per pixel)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 2 or w < 2:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    gy, gx = np.gradient(gray.astype(float))\n    mag = np.sqrt(gx*gx + gy*gy)\n    if not np.any(mag):\n        return 0.0\n    thr = np.percentile(mag, 70)\n    strong = mag > thr\n    start_row = int(3 * h / 4)\n    lower_strong = np.count_nonzero(strong[start_row:, :])\n    lower_area = float(max(1, (h - start_row) * w))\n    return float(lower_strong / lower_area)\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Mask fill ratio: area of object mask divided by bounding box area'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    ys, xs = np.where(mask)\n    if ys.size == 0:\n        return 0.0\n    y0, y1 = ys.min(), ys.max()\n    x0, x1 = xs.min(), xs.max()\n    bbox_area = float((y1 - y0 + 1) * (x1 - x0 + 1))\n    if bbox_area <= 0:\n        return 0.0\n    mask_area = float(ys.size)\n    return float(mask_area / bbox_area)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Contrast between the central torso strip and the lower third (mean_intensity_center - mean_intensity_bottom) normalized by overall std'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    overall_std = float(np.std(gray))\n    if overall_std < 1e-6:\n        overall_std = 1.0\n    low, high = np.percentile(gray, 5), np.percentile(gray, 95)\n    if high - low <= 1e-6:\n        return 0.0\n    thresh = (low + high) / 2.0\n    fg = gray < thresh\n    if not np.any(fg):\n        return 0.0\n    ys, xs = np.where(fg)\n    y0, y1 = ys.min(), ys.max()\n    x0, x1 = xs.min(), xs.max()\n    bh = max(1, y1 - y0 + 1)\n    # central torso strip: middle 30% of bbox height\n    mid0 = y0 + bh // 2 - max(1, bh // 10)\n    mid1 = y0 + bh // 2 + max(1, bh // 10) + 1\n    bot0 = y1 - max(1, bh // 3) + 1\n    bot1 = y1 + 1\n    mid_region = gray[max(y0, mid0):min(y1 + 1, mid1), x0:x1 + 1]\n    bot_region = gray[bot0:bot1, x0:x1 + 1]\n    if mid_region.size == 0 or bot_region.size == 0:\n        return 0.0\n    diff = float(np.mean(mid_region) - np.mean(bot_region))\n    return diff / overall_std\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Mean number of contiguous object runs per row in the bottom third (higher if split/legs/boots appear)'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    for p in (70, 60, 50):\n        thr = np.percentile(gray, p)\n        mask = gray > thr\n        if np.count_nonzero(mask) > 0:\n            break\n    bottom_start = max(0, (2 * h) // 3)\n    bottom = mask[bottom_start:, :]\n    if bottom.size == 0:\n        return 0.0\n    runs_per_row = []\n    for r in range(bottom.shape[0]):\n        row = bottom[r, :].astype(int)\n        if row.sum() == 0:\n            runs_per_row.append(0)\n            continue\n        dif = np.diff(row)\n        starts = np.sum(dif == 1) + (1 if row[0] == 1 else 0)\n        runs_per_row.append(float(starts))\n    return float(np.mean(runs_per_row))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Waist pinch index: normalized change between width at 25% and 55% heights (positive => narrower at waist)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 4 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = ((gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)).astype(int)\n    def row_width(r):\n        row = mask[r, :]\n        return float(np.count_nonzero(row))\n    r1 = min(h - 1, max(0, int(0.25 * h)))\n    r2 = min(h - 1, max(0, int(0.55 * h)))\n    w1 = row_width(r1)\n    w2 = row_width(r2)\n    denom = max(1.0, max(w1, w2))\n    # positive if w2 < w1 (narrower at waist)\n    return float((w1 - w2) / denom)\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Mean green minus blue channel inside the object mask (RGB only), normalized to [-1,1]'\n    import numpy as np\n    if image is None:\n        return 0.0\n    if len(image.shape) != 3 or image.shape[2] < 3:\n        return 0.0\n    h, w, c = image.shape\n    img = image.astype(float)\n    gray = np.mean(img, axis=2)\n    thr = np.percentile(gray, 55)\n    mask = gray < thr if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else gray > thr\n    total = np.count_nonzero(mask)\n    if total == 0:\n        return 0.0\n    g = img[:, :, 1]\n    b = img[:, :, 2]\n    diff = g - b\n    mean_diff = float(np.sum(diff * mask) / total)\n    # normalize by possible dynamic range\n    denom = np.maximum(1.0, np.max(img) - np.min(img))\n    return float(mean_diff / denom)\n",
    "def feature(image: np.ndarray) -> float:\n    'Fraction of object pixels located in the bottom quarter of its bounding box (helps separate bags with bottom mass)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    gray = np.mean(image, axis=2) if len(image.shape) == 3 else image.astype(float)\n    p75 = np.percentile(gray, 75)\n    mask = gray > p75\n    if mask.sum() == 0:\n        mask = gray > np.mean(gray)\n    total = mask.sum()\n    if total == 0:\n        return 0.0\n    rows = np.where(np.any(mask, axis=1))[0]\n    cols = np.where(np.any(mask, axis=0))[0]\n    if rows.size == 0 or cols.size == 0:\n        return 0.0\n    minr, maxr = rows[0], rows[-1]\n    minc, maxc = cols[0], cols[-1]\n    hbox = maxr - minr + 1\n    cut = minr + int(3 * hbox / 4)\n    bottom_mask = mask[cut:maxr+1, minc:maxc+1]\n    bottom_count = bottom_mask.sum()\n    return float(bottom_count) / float(total)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Waist narrowness: 1 - (min row width / max row width) within central vertical band (higher = narrower waist)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 3 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    top = max(0, h * 30 // 100)\n    bottom = min(h, h * 70 // 100)\n    band = mask[top:bottom, :]\n    if band.size == 0:\n        return 0.0\n    row_counts = np.sum(band, axis=1).astype(float)\n    if row_counts.size == 0:\n        return 0.0\n    maxw = float(np.max(row_counts))\n    minw = float(np.min(row_counts))\n    if maxw <= 1e-8:\n        return 0.0\n    narrowness = 1.0 - (minw / (maxw + 1e-8))\n    return float(max(0.0, min(1.0, narrowness)))\n",
    "def feature(image: np.ndarray) -> float:\n    'Absolute horizontal symmetry: normalized correlation between top and mirrored bottom halves'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 2 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    top = gray[:h // 2, :]\n    bot = gray[h - (h // 2):, :]\n    if top.size == 0 or bot.size == 0:\n        return 0.0\n    minh = min(top.shape[0], bot.shape[0])\n    top = top[:minh, :].ravel()\n    bot = np.flipud(bot[:minh, :]).ravel()\n    top_mean = top.mean() if top.size else 0.0\n    bot_mean = bot.mean() if bot.size else 0.0\n    topc = top - top_mean\n    botc = bot - bot_mean\n    denom = np.sqrt(np.sum(topc * topc) * np.sum(botc * botc)) + 1e-8\n    corr = np.sum(topc * botc) / denom\n    return float(abs(corr))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Ratio of average mask row-width in top quarter to bottom quarter (higher => wider at top)'\n    import numpy as np\n    if image is None:\n        return 1.0\n    h, w = image.shape[:2]\n    if h < 4 or w == 0:\n        return 1.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 60)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    q = max(1, h // 4)\n    top = mask[:q, :]\n    bottom = mask[h - q:h, :]\n    top_mean = float(np.mean(np.count_nonzero(top, axis=1)) / max(1.0, w))\n    bottom_mean = float(np.mean(np.count_nonzero(bottom, axis=1)) / max(1.0, w))\n    return float(top_mean / (bottom_mean + 1e-8))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Foreground-background mean intensity contrast (background - foreground) normalized'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 50)\n    mask_fg = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    fg_vals = gray[mask_fg]\n    bg_vals = gray[~mask_fg]\n    if fg_vals.size == 0 or bg_vals.size == 0:\n        return 0.0\n    mean_fg = float(np.mean(fg_vals))\n    mean_bg = float(np.mean(bg_vals))\n    denom = float(np.std(gray) + 1e-8)\n    return float((mean_bg - mean_fg) / denom)\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Variance of horizontal widths across the top half of the object (normalized by image width)'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    thr = np.mean(gray) + 0.45 * np.std(gray)\n    mask = gray > thr\n    if mask.sum() == 0:\n        mask = gray > np.percentile(gray.flatten(), 90)\n    if mask.sum() == 0:\n        if gray.max() == 0:\n            return 0.0\n        mask = gray > (0.1 * gray.max())\n    top_h = max(1, h // 2)\n    widths = []\n    for r in range(0, top_h):\n        row = mask[r, :]\n        if row.any():\n            left = int(np.argmax(row))\n            right = int(w - np.argmax(row[::-1]))\n            widths.append(right - left)\n    if len(widths) == 0:\n        return 0.0\n    var = float(np.var(widths))\n    return float(var / max(1.0, w))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Fraction of object pixels located in the upper half of the image (0..1)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    thr = np.mean(gray) + 0.05 * (np.max(gray) - np.min(gray))\n    mask = gray > thr\n    total = np.count_nonzero(mask)\n    if total == 0:\n        return 0.0\n    upper = np.count_nonzero(mask[:h//2, :])\n    return float(upper) / float(total)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Normalized standard deviation of object widths across the lower half (width variability near sole/heel)'\n    import numpy as np\n    gray = np.mean(image, axis=2) if len(image.shape) == 3 else image.astype(np.float64)\n    if gray.size == 0:\n        return 0.0\n    thresh = (float(np.max(gray)) + float(np.min(gray))) / 2.0\n    mask = gray > thresh\n    ys, xs = np.where(mask)\n    if ys.size == 0:\n        return 0.0\n    top, bottom = int(ys.min()), int(ys.max())\n    left, right = int(xs.min()), int(xs.max())\n    mid = top + (bottom - top) // 2\n    widths = []\n    for r in range(mid, bottom+1):\n        row = mask[r, left:right+1]\n        if np.any(row):\n            cols = np.where(row)[0]\n            widths.append(float(cols.max() - cols.min() + 1))\n    if len(widths) == 0:\n        return 0.0\n    mean_w = float(np.mean(widths))\n    result = float(np.std(widths) / (mean_w + 1e-9))\n    return result\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Difference between the width at the very bottom row and the width 30% up from the bottom, normalized by bbox width (toe protrusion indicator)'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    m = gray.mean(); s = gray.std()\n    pad = max(1, min(h, w) // 20)\n    border = np.concatenate([\n        gray[:pad, :].ravel(), gray[-pad:, :].ravel(),\n        gray[:, :pad].ravel(), gray[:, -pad:].ravel()\n    ]) if pad > 0 else np.array([m])\n    border_mean = border.mean() if border.size else m\n    if border_mean > m:\n        mask = (gray < (m - 0.08 * (s + 1e-6))).astype(bool)\n    else:\n        mask = (gray > (m + 0.08 * (s + 1e-6))).astype(bool)\n    if not mask.any():\n        return 0.0\n    rows_any = np.any(mask, axis=1); cols_any = np.any(mask, axis=0)\n    rmin, rmax = int(np.where(rows_any)[0][0]), int(np.where(rows_any)[0][-1])\n    cmin, cmax = int(np.where(cols_any)[0][0]), int(np.where(cols_any)[0][-1])\n    bbox_w = max(1, cmax - cmin + 1)\n    bb_h = max(1, rmax - rmin + 1)\n    # bottom row within bbox\n    bottom_row = rmax\n    row_up = rmax - max(1, int(0.3 * bb_h))\n    bottom_width = np.count_nonzero(mask[bottom_row, cmin:cmax+1])\n    up_width = np.count_nonzero(mask[row_up, cmin:cmax+1])\n    diff = float(bottom_width - up_width)\n    return diff / float(bbox_w)\n",
    "def feature(image: np.ndarray) -> float:\n    'Left-right symmetry score (1 - normalized L1 difference between halves)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if w < 2 or h == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    mid = w // 2\n    left = gray[:, :mid]\n    right = gray[:, w - mid:w]\n    if left.size == 0 or right.size == 0:\n        return 0.0\n    # flip right horizontally to compare\n    right_flipped = np.fliplr(right)\n    # resize if different sizes (when w odd)\n    if left.shape != right_flipped.shape:\n        min_w = min(left.shape[1], right_flipped.shape[1])\n        left = left[:, :min_w]\n        right_flipped = right_flipped[:, :min_w]\n    diff = np.abs(left - right_flipped)\n    # normalized by mean intensity to be scale-invariant\n    denom = (np.mean(np.abs(left)) + np.mean(np.abs(right_flipped))) / 2.0 + 1e-8\n    score = 1.0 - (np.mean(diff) / denom)\n    return float(score)\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Count of local column peaks in the bottom quarter (useful for two-shoe peaks)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 4 or w < 3:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 60)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    start = 3 * h // 4\n    region = mask[start:, :]\n    if region.size == 0:\n        return 0.0\n    col_proj = np.count_nonzero(region, axis=0).astype(float)\n    if col_proj.sum() == 0:\n        return 0.0\n    # simple smoothing\n    kernel = np.array([1, 2, 1], dtype=float)\n    sm = np.convolve(col_proj, kernel, mode='same')\n    # find local maxima: element greater than immediate neighbors and above small threshold\n    peaks = 0\n    th = max(1.0, np.percentile(sm, 50) * 0.5)\n    for i in range(1, sm.size - 1):\n        if sm[i] > sm[i - 1] and sm[i] > sm[i + 1] and sm[i] >= th:\n            peaks += 1\n    return float(min(peaks, 10))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Global mean gradient magnitude (texture/edge energy) normalized by image dynamic range'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 2 or w < 2:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    gy, gx = np.gradient(gray.astype(float))\n    grad = np.sqrt(gx * gx + gy * gy)\n    mean_grad = float(np.mean(grad))\n    dyn = float(np.max(gray) - np.min(gray))\n    return float(mean_grad / (dyn + 1e-8))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Dominant color channel ratio: strongest channel mean divided by mean of other two (RGB only)'\n    import numpy as np\n    if image is None:\n        return 1.0\n    if len(image.shape) != 3 or image.shape[2] < 3:\n        return 1.0\n    r = image[:, :, 0].astype(float)\n    g = image[:, :, 1].astype(float)\n    b = image[:, :, 2].astype(float)\n    mr = float(np.mean(r))\n    mg = float(np.mean(g))\n    mb = float(np.mean(b))\n    mx = max(mr, mg, mb)\n    others = (mr + mg + mb - mx)\n    return float(mx / (others / 2.0 + 1e-8))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Ratio of edge density in lower half to upper half ( >1 means more edges lower )'\n    import numpy as np\n    if image is None:\n        return 1.0\n    h, w = image.shape[:2]\n    if h < 2 or w < 2:\n        return 1.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    gy, gx = np.gradient(gray.astype(float))\n    grad_mag = np.sqrt(gx * gx + gy * gy)\n    thresh = np.percentile(grad_mag, 60) if np.any(grad_mag) else 0.0\n    strong = grad_mag > thresh\n    mid = h // 2\n    upper_count = np.count_nonzero(strong[:mid, :])\n    lower_count = np.count_nonzero(strong[mid:, :])\n    upper_area = float(max(1, mid * w))\n    lower_area = float(max(1, (h - mid) * w))\n    upper_density = upper_count / upper_area\n    lower_density = lower_count / lower_area\n    return float((lower_density + 1e-8) / (upper_density + 1e-8))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Foreground area divided by bounding box area (proxy for convexity / compactness)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    ys, xs = np.where(mask)\n    if ys.size == 0:\n        return 0.0\n    area = float(ys.size)\n    miny, maxy = int(np.min(ys)), int(np.max(ys))\n    minx, maxx = int(np.min(xs)), int(np.max(xs))\n    bbox_area = float(max(1, maxy - miny + 1) * max(1, maxx - minx + 1))\n    return float(area / bbox_area)\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Linear slope of horizontal span across vertical bands (positive slope => flaring outward toward bottom)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    thr = np.mean(gray) + 0.15 * (np.max(gray) - np.min(gray))\n    mask = gray > thr\n    if not mask.any():\n        mask = gray > np.mean(gray)\n        if not mask.any():\n            return 0.0\n    bands = 5\n    ys = np.linspace(0, h, bands+1, dtype=int)\n    centers = []\n    spans = []\n    for i in range(bands):\n        region = mask[ys[i]:ys[i+1], :]\n        cols = np.any(region, axis=0)\n        if not cols.any():\n            spans.append(0.0)\n        else:\n            left = np.argmax(cols)\n            right = len(cols) - 1 - np.argmax(cols[::-1])\n            spans.append(float(right - left + 1))\n        centers.append((ys[i] + ys[i+1]) / 2.0)\n    centers = np.array(centers)\n    spans = np.array(spans)\n    # simple linear fit slope of span vs center\n    if np.all(spans == spans[0]):\n        return 0.0\n    A = np.vstack([centers, np.ones_like(centers)]).T\n    slope, _ = np.linalg.lstsq(A, spans, rcond=None)[0]\n    # normalize slope by image width\n    return float(slope / (w + 1e-8))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Normalized variance of horizontal widths across rows (higher -> more tapering/flare)'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    h, w = gray.shape[:2]\n    p75 = float(np.percentile(gray, 75))\n    thr = p75 if p75 > gray.min() else float(np.mean(gray))\n    mask = gray > thr\n    widths = []\n    for r in range(h):\n        row = mask[r, :]\n        if row.any():\n            cols = np.where(row)[0]\n            widths.append(float(cols[-1] - cols[0] + 1))\n    if len(widths) <= 1:\n        return 0.0\n    var = float(np.var(widths))\n    # normalize by squared width to keep feature roughly scale-invariant\n    return float(var / (float(w) ** 2 + 1e-8))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Fraction of background pixels inside a small top-center window (estimates neck/collar opening presence)'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    h, w = gray.shape\n    # define small top-center region\n    rh = max(1, h // 8)\n    rw = max(1, w // 6)\n    r0 = 0\n    c0 = max(0, (w // 2) - (rw // 2))\n    window = gray[r0:r0 + rh, c0:c0 + rw]\n    if window.size == 0:\n        return 0.0\n    # background = relatively dark compared to window\n    thr = np.mean(gray) * 0.5\n    bg_mask = window <= thr\n    return float(np.count_nonzero(bg_mask) / window.size)\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Boundary complexity: fraction of mask pixels that lie on a 4-neighborhood boundary'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 2 or w < 2:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = gray < thr if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else gray > thr\n    area = np.count_nonzero(mask)\n    if area == 0:\n        return 0.0\n    p = np.pad(mask, ((1, 1), (1, 1)), mode='constant', constant_values=False)\n    center = p[1:-1, 1:-1]\n    up = p[:-2, 1:-1]\n    down = p[2:, 1:-1]\n    left = p[1:-1, :-2]\n    right = p[1:-1, 2:]\n    interior = center & up & down & left & right\n    boundary = center & (~interior)\n    bcount = np.count_nonzero(boundary)\n    return float(bcount / float(area + 1e-8))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Coefficient of variation of mask width per row (std / mean of row widths)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    row_widths = np.sum(mask, axis=1).astype(float)\n    if row_widths.size == 0:\n        return 0.0\n    mean_w = float(np.mean(row_widths))\n    std_w = float(np.std(row_widths))\n    if mean_w <= 1e-8:\n        return 0.0\n    return float(std_w / mean_w)\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Perimeter-to-area ratio of the foreground mask (higher => more complex outline)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    area = float(np.count_nonzero(mask))\n    if area == 0.0:\n        return 0.0\n    # pad mask to avoid wrap-around from np.roll\n    pad = np.pad(mask, ((1, 1), (1, 1)), mode='constant', constant_values=False)\n    inner = pad[1:-1, 1:-1]\n    up = pad[:-2, 1:-1]\n    down = pad[2:, 1:-1]\n    left = pad[1:-1, :-2]\n    right = pad[1:-1, 2:]\n    boundary = inner & (~up | ~down | ~left | ~right)\n    perimeter = float(np.count_nonzero(boundary))\n    return float(perimeter / (area + 1e-12))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Envelope solidity approximation: object area divided by vertical envelope area computed from per-column min/max (compactness-like)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    thr = np.mean(gray)\n    mask = gray > thr\n    if np.count_nonzero(mask) == 0:\n        thr = np.percentile(gray, 75)\n        mask = gray > thr\n    total_area = float(np.count_nonzero(mask))\n    if total_area == 0:\n        return 0.0\n    # compute envelope area: for each column, max_y - min_y +1 where pixels exist\n    envelope = 0\n    for c in range(w):\n        rows = np.where(mask[:, c])[0]\n        if rows.size > 0:\n            envelope += (rows.max() - rows.min() + 1)\n    envelope = max(envelope, 1.0)\n    solidity_approx = total_area / envelope\n    return float(solidity_approx)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Upper-half left-edge curvature: std of leftmost object column per row (normalized by width) to detect armhole indent'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    t = (np.mean(gray) + np.percentile(gray, 75)) / 2.0\n    mask = gray > t\n    if not np.any(mask):\n        return 0.0\n    rows, cols = np.where(mask)\n    top, bottom = rows.min(), rows.max()\n    left, right = cols.min(), cols.max()\n    w = max(1, right - left + 1)\n    # consider upper half rows of bbox\n    mid = top + max(1, (bottom - top + 1) // 2)\n    left_positions = []\n    for r in range(top, mid + 1):\n        row = mask[r, left:right+1]\n        nz = np.where(row)[0]\n        if nz.size > 0:\n            left_positions.append(nz[0])\n    if len(left_positions) < 2:\n        return 0.0\n    return float(np.std(left_positions) / w)\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Bottom-edge flatness: 1 - normalized stddev of bottom-most object row per column (higher => flatter bottom)'\n    try:\n        if len(image.shape) == 3:\n            gray = np.mean(image, axis=2)\n        else:\n            gray = image\n        h, w = gray.shape[:2]\n        if h == 0 or w == 0:\n            return 0.0\n        thr = np.mean(gray) + 0.2 * np.std(gray)\n        mask = gray > thr\n        bottom_indices = np.full(w, h - 1, dtype=float)\n        has_any = mask.any()\n        if not has_any:\n            return 0.0\n        for col in range(w):\n            col_mask = mask[:, col]\n            if col_mask.any():\n                # last True index\n                bottom_indices[col] = np.where(col_mask)[0][-1]\n            else:\n                bottom_indices[col] = h - 1\n        std_norm = float(np.std(bottom_indices) / (h + 1e-8))\n        flat_score = 1.0 - std_norm\n        return float(max(0.0, min(1.0, flat_score)))\n    except Exception:\n        return 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Mean mask width in top 20% divided by mean mask width in bottom 20% (>1 if top wider)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 4 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    top_h = max(1, int(h * 0.20))\n    bot_h = max(1, int(h * 0.20))\n    top_rows = mask[:top_h, :]\n    bot_rows = mask[-bot_h:, :]\n    top_widths = np.sum(top_rows, axis=1).astype(float)\n    bot_widths = np.sum(bot_rows, axis=1).astype(float)\n    top_mean = float(np.mean(top_widths)) if top_widths.size else 0.0\n    bot_mean = float(np.mean(bot_widths)) if bot_widths.size else 0.0\n    if bot_mean <= 1e-8:\n        return float(top_mean / (float(w) + 1e-8))\n    result = top_mean / (bot_mean + 1e-8)\n    return float(result)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Ratio of vertical edge energy in upper quarter to lower quarter (detect top vs bottom detail)'\n    import numpy as np\n    if image is None:\n        return 1.0\n    h, w = image.shape[:2]\n    if h < 4 or w < 2:\n        return 1.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    gy, gx = np.gradient(gray)\n    vert = np.abs(gx)\n    q = max(1, h // 4)\n    top_sum = float(np.sum(vert[:q, :]))\n    bottom_sum = float(np.sum(vert[-q:, :]))\n    return float((top_sum + 1e-8) / (bottom_sum + 1e-8))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Ratio of foreground mass in upper side quarters to the upper center (high when shoulders/lapels are wider than center)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    img = np.array(image, dtype=float)\n    if img.size == 0:\n        return 0.0\n    if img.ndim == 3:\n        gray = np.mean(img, axis=2)\n    else:\n        gray = img\n    h, w = gray.shape[:2]\n    top_h = max(1, h // 4)\n    top_region = gray[:top_h, :]\n    # adaptive foreground threshold\n    vmax, vmin = gray.max(), gray.min()\n    if vmax == vmin:\n        mask = top_region > vmin\n    else:\n        thresh = np.percentile(gray, 60)\n        mask = top_region > thresh\n    left_side = mask[:, :w // 3].sum()\n    right_side = mask[:, 2 * (w // 3):].sum()\n    center = mask[:, w // 3:2 * (w // 3)].sum()\n    eps = 1e-6\n    side = left_side + right_side\n    return float(side / (center + eps))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Fraction of columns that are empty in the top 10% of rows (top neckline / collar gap)'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(np.float32)\n    else:\n        gray = image.astype(np.float32)\n    h, w = gray.shape[:2]\n    top_rows = max(1, h // 10)\n    thr = np.mean(gray) + 0.25 * (np.max(gray) - np.min(gray))\n    mask = gray > thr\n    if mask.shape[0] < top_rows:\n        top = mask\n    else:\n        top = mask[0:top_rows, :]\n    if top.size == 0:\n        return 0.0\n    empty_cols = np.sum(~np.any(top, axis=0))\n    result = float(empty_cols) / float(w)\n    return result\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Bottom-to-top width ratio of the object bounding box (bottom_width / top_width)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    mean, std = np.mean(gray), np.std(gray)\n    mask = gray > (mean + 0.25 * std)\n    if not np.any(mask):\n        return 0.0\n    ys, xs = np.where(mask)\n    y0, y1 = ys.min(), ys.max()\n    x0, x1 = xs.min(), xs.max()\n    bh = y1 - y0 + 1\n    bw = x1 - x0 + 1\n    def horizontal_span_at_frac(frac):\n        row = y0 + int(frac * (bh - 1))\n        band = max(1, bh // 20)\n        rows = range(max(y0, row - band), min(y1 + 1, row + band + 1))\n        spans = []\n        for r in rows:\n            pts = np.where(mask[r, x0:x1 + 1])[0]\n            if pts.size > 0:\n                spans.append(pts.max() - pts.min() + 1)\n        if len(spans) == 0:\n            return 0\n        return float(np.mean(spans))\n    top_w = horizontal_span_at_frac(0.15)\n    bottom_w = horizontal_span_at_frac(0.85)\n    if top_w < 1e-6:\n        return float(bottom_w + 1e-6)\n    return float(bottom_w / top_w)\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Vertical edge density ratio in a central vertical strip vs whole image (detects open-front coats with strong central vertical edges)'\n    import numpy as np\n    gray = np.mean(image, axis=2) if len(image.shape) == 3 else image.astype(float)\n    h, w = gray.shape[:2]\n    gx = np.abs(np.gradient(gray, axis=1))\n    # central strip width\n    sw = max(1, w // 6)\n    c0 = w // 2 - sw // 2\n    c1 = c0 + sw\n    center_strip = gx[:, c0:c1]\n    center_mean = float(np.mean(center_strip))\n    global_mean = float(np.mean(gx)) + 1e-9\n    return float(center_mean / global_mean)\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Mean mask width top-quarter divided by mean mask width bottom-quarter'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 4 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    tq = max(1, h // 4)\n    top = mask[:tq, :]\n    bottom = mask[-tq:, :]\n    top_widths = np.sum(top, axis=1).astype(float)\n    bot_widths = np.sum(bottom, axis=1).astype(float)\n    mean_top = float(np.mean(top_widths)) if top_widths.size > 0 else 0.0\n    mean_bot = float(np.mean(bot_widths)) if bot_widths.size > 0 else 0.0\n    if mean_bot <= 1e-8:\n        return float(mean_top / (1e-8 + mean_bot))\n    return float(mean_top / mean_bot)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Number of prominent peaks in horizontal projection (columns) - trousers often show two peaks'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    maxv = float(gray.max()) if gray.size else 0.0\n    if maxv <= 0 or w < 3:\n        return 0.0\n    col_sum = gray.sum(axis=0)\n    # simple smoothing\n    kernel = np.array([1., 2., 1.])\n    smooth = np.convolve(col_sum, kernel/kernel.sum(), mode='same')\n    threshold = 0.4 * smooth.max() if smooth.size else 0.0\n    peaks = 0\n    for i in range(1, w-1):\n        if smooth[i] > threshold and smooth[i] > smooth[i-1] and smooth[i] > smooth[i+1]:\n            peaks += 1\n    return float(peaks)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Vertical normalized centroid of foreground (0=top,1=bottom)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    ys, xs = np.nonzero(mask)\n    if ys.size == 0:\n        # fallback to intensity centroid\n        ys_all = np.arange(h).reshape(h, 1) * np.ones((1, w))\n        total = np.sum(gray) + 1e-8\n        return float(np.sum(ys_all * gray) / (total * float(h)))\n    cy = float(np.mean(ys))\n    return float(cy / float(h - 1 + 1e-8))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Mean per-pixel color channel std (color saturation proxy), normalized to [0,1] (0 for grayscale)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    if len(image.shape) != 3 or image.shape[2] < 3:\n        return 0.0\n    img = image[:, :, :3].astype(float)\n    per_pixel_std = np.std(img, axis=2)\n    mean_std = float(np.mean(per_pixel_std))\n    return float(mean_std / 255.0)\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Simple colorfulness score based on channel differences (0 for grayscale)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    if len(image.shape) != 3 or image.shape[2] < 3:\n        return 0.0\n    # use float conversions\n    r = image[:, :, 0].astype(float)\n    g = image[:, :, 1].astype(float)\n    b = image[:, :, 2].astype(float)\n    rg = r - g\n    yb = 0.5 * (r + g) - b\n    sigma_rg = float(np.std(rg))\n    sigma_yb = float(np.std(yb))\n    mean_rg = float(np.mean(np.abs(rg)))\n    mean_yb = float(np.mean(np.abs(yb)))\n    # Hasler-Suesstrunk inspired metric\n    score = np.sqrt(sigma_rg * sigma_rg + sigma_yb * sigma_yb) + 0.3 * np.sqrt(mean_rg * mean_rg + mean_yb * mean_yb)\n    return float(score)\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Ratio of diagonal gradient energy to axis-aligned energy in the central bbox area (high for diagonal seams/lapels)'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    try:\n        thresh = float(np.percentile(gray, 70))\n    except Exception:\n        thresh = float(np.mean(gray))\n    fg = gray < thresh\n    rows = np.any(fg, axis=1)\n    cols = np.any(fg, axis=0)\n    if not rows.any() or not cols.any():\n        return 1.0\n    r0, r1 = np.where(rows)[0][0], np.where(rows)[0][-1] + 1\n    c0, c1 = np.where(cols)[0][0], np.where(cols)[0][-1] + 1\n    crop = gray[r0:r1, c0:c1].astype(float)\n    ch, cw = crop.shape\n    # central subregion\n    pad_h = max(1, ch // 6)\n    pad_w = max(1, cw // 6)\n    sub = crop[pad_h:ch-pad_h or None, pad_w:cw-pad_w or None]\n    if sub.size == 0:\n        sub = crop\n    # axis-aligned gradients\n    gx = np.abs(np.diff(sub, axis=1))\n    gx = np.pad(gx, ((0,0),(0,1)), mode='constant')\n    gy = np.abs(np.diff(sub, axis=0))\n    gy = np.pad(gy, ((0,1),(0,0)), mode='constant')\n    axis_energy = float(np.mean(gx) + np.mean(gy) + 1e-8)\n    # diagonal approximations\n    d1 = np.abs(sub - np.roll(sub, 1, axis=0) - np.roll(sub, 1, axis=1) + np.roll(np.roll(sub,1,axis=0),1,axis=1))\n    d2 = np.abs(sub - np.roll(sub, 1, axis=0) + np.roll(sub, 1, axis=1) - np.roll(np.roll(sub,1,axis=0),1,axis=1))\n    diag_energy = float((np.mean(d1) + np.mean(d2)) / 2.0 + 1e-8)\n    return float(diag_energy / axis_energy)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Inter-channel mean difference magnitude (RGB colorfulness proxy), 0 for grayscale'\n    import numpy as np\n    if image is None:\n        return 0.0\n    if len(image.shape) != 3 or image.shape[2] < 3:\n        return 0.0\n    # compute absolute differences between channel means\n    r_mean = float(np.mean(image[:, :, 0].astype(float)))\n    g_mean = float(np.mean(image[:, :, 1].astype(float)))\n    b_mean = float(np.mean(image[:, :, 2].astype(float)))\n    val = np.abs(r_mean - g_mean) + np.abs(r_mean - b_mean) + np.abs(g_mean - b_mean)\n    denom = max((r_mean + g_mean + b_mean) / 3.0, 1e-8)\n    return float(val / denom)\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Left-versus-right mask imbalance: (left_frac - right_frac) in [-1,1]'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    left = np.count_nonzero(mask[:, :w//3])\n    right = np.count_nonzero(mask[:, -w//3:]) if w//3 > 0 else 0\n    total = left + right + 1e-8\n    val = (left - right) / total\n    # clamp\n    if val < -1.0:\n        val = -1.0\n    if val > 1.0:\n        val = 1.0\n    return float(val)\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Fraction of image pixels belonging to the foreground mask (mask area / image area)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    total = float(max(1, h * w))\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 50)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    area = float(np.count_nonzero(mask))\n    return float(area / total)\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Vertical symmetry score: 1 - normalized mean absolute difference between left half and mirrored right half (1 = perfect symmetry)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    mid = w // 2\n    left = gray[:, :mid]\n    right = np.fliplr(gray[:, w - mid: w]) if mid > 0 else np.zeros_like(left)\n    # Resize to same shape if needed\n    if left.shape != right.shape:\n        # crop/pad to min cols\n        minc = min(left.shape[1], right.shape[1])\n        left = left[:, :minc]\n        right = right[:, :minc]\n    diff = np.abs(left - right)\n    norm = np.mean(diff) / (np.max(gray) - np.min(gray) + 1e-6)\n    score = 1.0 - float(np.clip(norm, 0.0, 1.0))\n    return float(score)\n",
    "def feature(image: np.ndarray) -> float:\n    'Mean absolute vertical gradient in a central vertical strip (detects central seam/opening like a coat)'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    h, w = gray.shape\n    # central vertical strip width\n    strip_w = max(1, w // 6)\n    cx = w // 2\n    c0 = max(0, cx - strip_w // 2)\n    c1 = min(w, c0 + strip_w)\n    region = gray[:, c0:c1]\n    # vertical gradient\n    gy = np.abs(np.gradient(region, axis=0))\n    # average gradient magnitude\n    return float(np.mean(gy)) if gy.size > 0 else 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Mean vertical-edge strength across a small top-center band (strong horizontal step at collar/neck shows up as vertical gradient magnitude)'\n    import numpy as np\n    gray = np.mean(image, axis=2) if len(image.shape) == 3 else image.astype(float)\n    h, w = gray.shape[:2]\n    # small top-center band: top 15% height and center 40% width\n    rh = max(1, h * 15 // 100)\n    cw = max(1, w * 40 // 100)\n    r0 = 0\n    c0 = max(0, (w - cw) // 2)\n    band = gray[r0:rh, c0:c0+cw]\n    if band.size == 0:\n        return 0.0\n    gy = np.gradient(band, axis=0)\n    # vertical gradient magnitude averaged (absolute), normalized\n    mag = np.mean(np.abs(gy))\n    # normalize by overall image contrast\n    norm = (np.std(gray) + 1e-8)\n    return float(mag / norm)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Ratio of width at the bottom 10% to the width at mid-height (captures flared soles vs narrow straps)'\n    import numpy as np\n    maxv = float(np.max(image)) if image.size else 0.0\n    thr = maxv * 0.10\n    mask = (image > thr)\n    if not np.any(mask):\n        return 0.0\n    ys, xs = np.where(mask)\n    r0, r1 = ys.min(), ys.max()\n    c0, c1 = xs.min(), xs.max()\n    h = r1 - r0 + 1\n    region = mask[r0:r1+1, c0:c1+1]\n    bottom_row_start = max(0, region.shape[0] - max(1, region.shape[0] // 10))\n    bottom_slice = region[bottom_row_start:, :]\n    mid_row = region[region.shape[0] // 2, :]\n    bottom_width = float((bottom_slice.any(axis=0)).sum())\n    mid_width = float(mid_row.any())\n    # mid_row.any() returns bool; correct: need count of True in mid_row\n    mid_width = float((mid_row > 0).sum())\n    if mid_width == 0:\n        return float(bottom_width)\n    return float(bottom_width / mid_width)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Contour roughness: border pixel count divided by mask area (higher -> more complex outline)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = ((gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)).astype(int)\n    area = float(np.count_nonzero(mask))\n    if area == 0:\n        return 0.0\n    # approximate border by differences with shifted masks\n    vert_diff = np.abs(mask[1:, :] - mask[:-1, :])\n    hor_diff = np.abs(mask[:, 1:] - mask[:, :-1])\n    border_count = float(np.sum(vert_diff) + np.sum(hor_diff))\n    return float(border_count / (area + 1e-8))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Normalized standard deviation of row-wise horizontal spans (higher for flared shapes like dresses)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    rng = float(np.max(gray) - np.min(gray))\n    thr = float(np.mean(gray) + 0.05 * rng)\n    mask = gray > thr\n    spans = []\n    for r in range(h):\n        cols = np.where(mask[r, :])[0]\n        if cols.size:\n            spans.append(float(cols[-1] - cols[0] + 1))\n    if len(spans) <= 1:\n        return 0.0\n    s = float(np.std(spans))\n    m = float(np.mean(spans)) + 1e-8\n    return float(s / m)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Normalized variance of horizontal object widths across the bounding box (captures how much the silhouette changes vertically)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    thr = (np.nanmax(gray) + np.nanmin(gray)) / 2.0\n    mask = gray > thr\n    if mask.sum() == 0:\n        mask = gray > gray.mean()\n    if mask.sum() == 0:\n        mask = gray > (np.max(gray) * 0.01)\n    rows = np.any(mask, axis=1)\n    cols = np.any(mask, axis=0)\n    if not rows.any() or not cols.any():\n        return 0.0\n    r0, r1 = np.where(rows)[0][0], np.where(rows)[0][-1] + 1\n    c0, c1 = np.where(cols)[0][0], np.where(cols)[0][-1] + 1\n    bw = max(1, c1 - c0)\n    widths = []\n    for r in range(r0, r1):\n        row = mask[r, c0:c1].astype(int)\n        widths.append(np.sum(row))\n    if len(widths) <= 1:\n        return 0.0\n    var = float(np.var(widths))\n    # normalize by bbox width squared to make scale-invariant\n    return float(var / (bw * bw + 1e-9))\n",
    "def feature(image: np.ndarray) -> float:\n    'Average gradient magnitude inside the object region (edge/texture density) normalized by object area'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    thr = np.percentile(gray, 50)\n    mask = gray > thr\n    if not mask.any():\n        mask = gray != gray.min()\n        if not mask.any():\n            return 0.0\n    # compute gradients on normalized gray\n    imgf = gray.astype(float)\n    gx, gy = np.gradient(imgf)\n    grad = np.hypot(gx, gy)\n    if mask.sum() == 0:\n        return 0.0\n    val = np.mean(grad[mask])\n    # normalize by overall image gradient mean to be scale-invariant\n    base = max(1e-6, np.mean(grad))\n    return float(val / base)\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Relative mass deficit in the bottom-center third compared to bottom-side thirds (useful to detect leg gaps or skirt fullness)'\n    try:\n        if len(image.shape) == 3:\n            gray = np.mean(image, axis=2).astype(float)\n        else:\n            gray = image.astype(float)\n    except Exception:\n        return 0.0\n    h, w = gray.shape[:2]\n    thr = float(np.percentile(gray, 50))\n    mask = gray > thr\n    if not mask.any():\n        return 0.0\n    rows, cols = np.where(mask)\n    top, bottom = rows.min(), rows.max()\n    left, right = cols.min(), cols.max()\n    bbox_h = max(1, bottom - top + 1)\n    bbox_w = max(1, right - left + 1)\n    bottom_start = bottom - bbox_h // 2 + 1\n    bottom_slice = mask[max(bottom_start, 0):bottom + 1, left:right + 1]\n    if bottom_slice.size == 0:\n        return 0.0\n    third = max(1, bottom_slice.shape[1] // 3)\n    left_mass = bottom_slice[:, :third].sum()\n    center_mass = bottom_slice[:, third:third*2].sum() if bottom_slice.shape[1] >= 3*third else bottom_slice[:, third:third+third].sum()\n    right_mass = bottom_slice[:, -third:].sum()\n    sides = float(left_mass + right_mass)\n    center = float(center_mass)\n    denom = float(sides + center) + 1e-6\n    return float((sides - center) / denom)\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Gradient orientation entropy (0..1): how varied edge directions are inside the image'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 2 or w < 2:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    gy, gx = np.gradient(gray.astype(float))\n    mag = np.sqrt(gx * gx + gy * gy)\n    if not np.any(mag):\n        return 0.0\n    # take only reasonably strong gradients to focus on edges\n    thresh = np.percentile(mag, 60)\n    mask = mag > thresh\n    if not np.any(mask):\n        mask = mag > 0\n    angles = np.arctan2(gy[mask], gx[mask])\n    # map to [0, pi) because orientations symmetric\n    angles = np.mod(angles, np.pi)\n    bins = 8\n    hist, _ = np.histogram(angles, bins=bins, range=(0.0, np.pi))\n    hist = hist.astype(float)\n    s = np.sum(hist)\n    if s <= 0:\n        return 0.0\n    p = hist / s\n    p = np.where(p > 0, p, 1e-12)\n    ent = -np.sum(p * np.log(p))\n    max_ent = np.log(bins)\n    return float(ent / (max_ent + 1e-12))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Normalized variability of gradient magnitude (std / mean) as a texture indicator'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 2 or w < 2:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    gy, gx = np.gradient(gray.astype(float))\n    grad = np.sqrt(gx * gx + gy * gy)\n    mean_g = float(np.mean(grad))\n    std_g = float(np.std(grad))\n    if mean_g <= 1e-8:\n        return 0.0\n    return float(std_g / (mean_g + 1e-8))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Normalized average length of background gaps in center columns near the top (neckline-like gaps)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 4 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 50)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    top_rows = max(1, int(0.35 * h))\n    center_cols = slice(max(0, w//2 - max(1, w//10)), min(w, w//2 + max(1, w//10)))\n    region = mask[:top_rows, center_cols]\n    if region.size == 0:\n        return 0.0\n    # for each center column, measure longest consecutive zeros (background) that lies between mask segments\n    bg_gaps = []\n    for c in range(region.shape[1]):\n        col = region[:, c].astype(int)\n        if np.all(col == 0):\n            bg_gaps.append(region.shape[0])\n            continue\n        diffs = np.diff(np.concatenate(([0], col, [0])))\n        starts = np.where(diffs == 1)[0]\n        ends = np.where(diffs == -1)[0]\n        # background segments are between mask segments: find zero stretches between ones\n        zero_runs = []\n        prev_end = None\n        for s, e in zip(starts, ends):\n            if prev_end is None:\n                prev_end = e\n                continue\n            # gap between prev_end and next start\n            gap = s - prev_end\n            if gap > 0:\n                zero_runs.append(gap)\n            prev_end = e\n        if zero_runs:\n            bg_gaps.append(max(zero_runs))\n        else:\n            bg_gaps.append(0)\n    if len(bg_gaps) == 0:\n        return 0.0\n    avg_gap = float(np.mean(bg_gaps))\n    return float(avg_gap / float(top_rows))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Normalized vertical centroid of the main foreground mask (0 top -> 1 bottom)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0:\n        return 0.0\n    # grayscale\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 50)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    mask = mask.astype(bool)\n    if not np.any(mask):\n        return 0.0\n    rows = np.arange(h, dtype=float)\n    y_mean = float(np.sum(rows[:, None] * mask) / (np.count_nonzero(mask) + 1e-8))\n    return float(y_mean / max(1.0, h - 1))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Number of distinct foreground segments across columns in the bottom region (shoe blobs count)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 2 or w < 2:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    bottom_h = max(1, int(h * 0.15))\n    bottom = mask[h - bottom_h:, :]\n    col_sum = np.sum(bottom, axis=0).astype(float)\n    if np.max(col_sum) <= 0:\n        return 0.0\n    cutoff = max(1.0, 0.3 * np.max(col_sum))\n    active = col_sum >= cutoff\n    # count connected segments in active columns\n    segs = np.sum(np.diff(np.concatenate(([0], active.astype(np.int32), [0]))) == 1)\n    return float(segs)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Foreground solidity: mask area divided by bounding-box area (1 = fills bbox)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 50)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    ys, xs = np.where(mask)\n    if xs.size == 0 or ys.size == 0:\n        return 0.0\n    area = float(xs.size)\n    xmin, xmax = int(np.min(xs)), int(np.max(xs))\n    ymin, ymax = int(np.min(ys)), int(np.max(ys))\n    bbox_area = float((xmax - xmin + 1) * (ymax - ymin + 1))\n    if bbox_area <= 1e-8:\n        return 0.0\n    return float(area / bbox_area)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Colorfulness metric for RGB images, 0 for grayscale inputs'\n    import numpy as np\n    if image is None:\n        return 0.0\n    if len(image.shape) != 3 or image.shape[2] < 3:\n        return 0.0\n    # simple Hasler & Suesstrunk inspired metric\n    r = image[:, :, 0].astype(float)\n    g = image[:, :, 1].astype(float)\n    b = image[:, :, 2].astype(float)\n    rg = r - g\n    yb = 0.5 * (r + g) - b\n    std_rg = float(np.std(rg))\n    std_yb = float(np.std(yb))\n    mean_rg = float(np.mean(rg))\n    mean_yb = float(np.mean(yb))\n    # colorfulness\n    score = np.sqrt(std_rg ** 2 + std_yb ** 2) + 0.3 * np.sqrt(mean_rg ** 2 + mean_yb ** 2)\n    # normalize roughly by dynamic range\n    denom = float(np.max(image) - np.min(image) + 1e-8)\n    return float(score / denom)\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Relative texture contrast between outer border ring and center region (coats may have higher border texture)'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    # define center and border regions\n    cy0, cy1 = h//4, 3*h//4\n    cx0, cx1 = w//4, 3*w//4\n    center = gray[cy0:cy1, cx0:cx1]\n    if center.size == 0:\n        return 0.0\n    border_mask = np.ones_like(gray, dtype=bool)\n    border_mask[cy0:cy1, cx0:cx1] = False\n    border = gray[border_mask]\n    if border.size == 0:\n        return 0.0\n    center_std = np.std(center)\n    border_std = np.std(border)\n    denom = (center_std + 1e-8)\n    result = (border_std - center_std) / denom\n    return float(result)\n",
    "def feature(image: np.ndarray) -> float:\n    'Number of distinct peaks in the vertical projection (columns) of the object \u2014 straps produce multiple peaks'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape\n    if h == 0 or w <= 2:\n        return 0.0\n    thr = np.mean(gray) + 0.25 * np.std(gray)\n    mask = gray > thr\n    if not np.any(mask):\n        mask = gray > np.percentile(gray, 80)\n    col_sums = np.sum(mask, axis=0).astype(float)\n    if np.max(col_sums) == 0:\n        return 0.0\n    # simple smoothing kernel [1,2,1]\n    padded = np.pad(col_sums, (1, 1), mode='constant', constant_values=0)\n    smooth = (padded[:-2] + 2 * padded[1:-1] + padded[2:]) / 4.0\n    # peak if greater than neighbors and significant relative to max\n    maxv = smooth.max()\n    threshold = max(1.0, 0.3 * maxv)\n    peaks = 0\n    for i in range(1, w - 1):\n        if smooth[i] > smooth[i - 1] and smooth[i] > smooth[i + 1] and smooth[i] >= threshold:\n            peaks += 1\n    return float(peaks)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Average horizontal extension from image center at shoulder rows (sleeve/shoulder score)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 5 or w < 3:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    start = max(0, int(h * 10 // 100))\n    end = max(start + 1, int(h * 25 // 100))\n    center_col = w // 2\n    exts = []\n    for row in range(start, min(end, h)):\n        row_mask = mask[row, :]\n        if np.any(row_mask[:center_col]):\n            left_idx = np.where(row_mask[:center_col])[0][0]\n            left_ext = center_col - left_idx\n        else:\n            left_ext = 0\n        if np.any(row_mask[center_col:]):\n            right_idx = np.where(row_mask[center_col:])[0][-1]  # index relative to center_col\n            right_ext = right_idx + 1\n        else:\n            right_ext = 0\n        exts.append(left_ext + right_ext)\n    if len(exts) == 0:\n        return 0.0\n    avg_ext = float(np.mean(exts))\n    return float(avg_ext / max(1.0, float(w)))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Collar edge score: normalized sum of horizontal gradient magnitudes in the upper-central region (higher for collars)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    upper_h = max(1, h // 4)\n    center_w = max(3, w // 3)\n    start = max(0, w // 2 - center_w // 2)\n    region = gray[0:upper_h, start:start + center_w]\n    # horizontal gradient\n    gy, gx = np.gradient(region)\n    score = np.sum(np.abs(gx))\n    # normalize by area and overall gradient\n    total_grad = np.sum(np.abs(np.gradient(gray)[1])) + 1e-6\n    norm = score / (region.size + 1e-6) / (total_grad / (gray.size) + 1e-6)\n    return float(norm)\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Row index (normalized 0..1) where the object attains its maximum horizontal span (peak width position)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    maxv = gray.max()\n    if maxv == 0:\n        return 0.5\n    mask = gray > (maxv * 0.1)\n    row_widths = mask.sum(axis=1).astype(float)\n    if row_widths.size == 0 or row_widths.max() == 0:\n        return 0.5\n    peak_row = int(np.argmax(row_widths))\n    return float(peak_row) / float(h)\n",
    "def feature(image: np.ndarray) -> float:\n    'Ratio of bottom-third object area to top-third object area (bottom_area / top_area) - highlights dresses with large lower areas'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    if h == 0:\n        return 0.0\n    mx, mn = float(gray.max()), float(gray.min())\n    if mx == mn:\n        return 0.0\n    thr = (mx + mn) / 2.0\n    mask = gray > thr\n    third = max(1, h // 3)\n    top_area = float(np.count_nonzero(mask[:third, :]))\n    bottom_area = float(np.count_nonzero(mask[-third:, :]))\n    if top_area == 0:\n        return float(bottom_area)  # large value if bottom exists but top doesn't\n    return float(bottom_area / (top_area + 1e-9))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Ratio of foreground pixels in the upper third of the object bbox to those in the lower two-thirds (higher when more mass at top)'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    try:\n        thresh = float(np.percentile(gray, 70))\n    except Exception:\n        thresh = float(np.mean(gray))\n    fg = (gray < thresh).astype(float)\n    rows = np.any(fg, axis=1)\n    cols = np.any(fg, axis=0)\n    if not rows.any() or not cols.any():\n        return 0.0\n    r0, r1 = np.where(rows)[0][0], np.where(rows)[0][-1] + 1\n    c0, c1 = np.where(cols)[0][0], np.where(cols)[0][-1] + 1\n    crop = fg[r0:r1, c0:c1]\n    ch = crop.shape[0]\n    upper_end = r0 + max(1, ch // 3)\n    upper = fg[r0:upper_end, c0:c1]\n    lower = fg[upper_end:r1, c0:c1]\n    up_sum = float(np.sum(upper))\n    low_sum = float(np.sum(lower)) + 1e-8\n    return float(up_sum / low_sum)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Count of prominent peaks in the column-sum profile (approx number of vertical components)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 50)\n    mask = gray < thr if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else gray > thr\n    colsum = np.sum(mask.astype(float), axis=0)\n    if np.all(colsum == 0):\n        return 0.0\n    # Smooth small noise\n    kernel = np.array([1.0, 1.0, 1.0])\n    smooth = np.convolve(colsum, kernel / kernel.sum(), mode='same')\n    peak_thresh = 0.25 * (np.max(smooth) if np.max(smooth) > 0 else 1.0)\n    peaks = 0\n    for i in range(1, w - 1):\n        if smooth[i] > smooth[i - 1] and smooth[i] > smooth[i + 1] and smooth[i] >= peak_thresh:\n            peaks += 1\n    # endpoints as possible peaks\n    if w >= 1 and smooth[0] > smooth[1] and smooth[0] >= peak_thresh:\n        peaks += 1\n    if w >= 2 and smooth[-1] > smooth[-2] and smooth[-1] >= peak_thresh:\n        peaks += 1\n    return float(peaks)\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Density of small background pixels flanked by foreground horizontally (captures gaps between straps)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(np.float32)\n    else:\n        gray = image.astype(np.float32)\n    mn, mx = float(np.min(gray)), float(np.max(gray))\n    if mx > mn:\n        gray = (gray - mn) / (mx - mn)\n    else:\n        gray = gray * 0.0\n    fg = gray > 0.2\n    ys, xs = np.where(fg)\n    if ys.size == 0:\n        return 0.0\n    rmin, rmax = int(ys.min()), int(ys.max())\n    cmin, cmax = int(xs.min()), int(xs.max())\n    region = fg[rmin:rmax+1, cmin:cmax+1]\n    H, W = region.shape\n    if H == 0 or W == 0:\n        return 0.0\n    padded = np.pad(region, ((0,0),(1,1)), mode='constant', constant_values=False)\n    gap_count = 0\n    total = H * W\n    for r in range(H):\n        row = padded[r]\n        # a background pixel that is directly flanked by foreground left and right\n        middle = row[1:-1]\n        left = row[:-2]\n        right = row[2:]\n        flanked = (~middle) & left & right\n        gap_count += int(np.count_nonzero(flanked))\n    return float(gap_count / float(total))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Ratio of mask area in top third to bottom third (top_area / (bottom_area+eps))'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 3 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    top_end = h // 3\n    bottom_start = (2 * h) // 3\n    top_count = float(np.count_nonzero(mask[0:top_end, :]))\n    bottom_count = float(np.count_nonzero(mask[bottom_start:h, :])) + 1e-8\n    return float(top_count / bottom_count)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Approximate perimeter normalized by sqrt(area): count of strong gradient pixels divided by sqrt(foreground area)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    img = np.mean(image, axis=2) if len(image.shape) == 3 else image.astype(float)\n    gy, gx = np.gradient(img.astype(float))\n    grad = np.hypot(gx, gy)\n    gthr = 0.25 * grad.max() if grad.max() > 0 else 1e-6\n    perimeter = float(np.count_nonzero(grad > gthr))\n    thr = (np.min(img) + np.mean(img)) * 0.5\n    area = float(np.count_nonzero(img > thr))\n    return float(perimeter / (np.sqrt(area) + 1e-6))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Ratio of mean gradient magnitude inside mask to mean outside (texture contrast)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 2 or w < 2:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    gy, gx = np.gradient(gray.astype(float))\n    grad = np.sqrt(gx * gx + gy * gy)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    inside = grad[mask]\n    outside = grad[~mask]\n    if inside.size == 0 or outside.size == 0:\n        return 0.0\n    mean_in = float(np.mean(inside))\n    mean_out = float(np.mean(outside))\n    return float(mean_in / (mean_out + 1e-8))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Normalized standard deviation of per-row foreground widths within the object bounding box (profile spread / peakiness)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    mean = float(np.mean(gray))\n    thresh = mean * 0.6 if mean > 0 else np.percentile(gray.flatten(), 75)\n    fg = gray > thresh\n    ys, xs = np.where(fg)\n    if xs.size == 0:\n        return 0.0\n    minr, maxr = ys.min(), ys.max()\n    widths = []\n    for r in range(minr, maxr+1):\n        cols = np.where(fg[r, :])[0]\n        if cols.size:\n            widths.append(float(cols.max() - cols.min() + 1))\n    if not widths:\n        return 0.0\n    stdw = float(np.std(widths))\n    return float(stdw / (w + 1e-6))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Proportion of foreground fill in the central torso box (center third rows and center half cols) - torso fill ratio'\n    import numpy as np\n    gray = np.mean(image, axis=2) if len(image.shape) == 3 else image.astype(np.float32)\n    h, w = gray.shape\n    thresh = np.percentile(gray, 60)\n    mask = gray < thresh\n    if not np.any(mask):\n        return 0.0\n    rows, cols = np.where(mask)\n    r0, r1 = rows.min(), rows.max()\n    c0, c1 = cols.min(), cols.max()\n    bh = r1 - r0 + 1\n    bw = c1 - c0 + 1\n    if bh <= 0 or bw <= 0:\n        return 0.0\n    r_start = r0 + bh // 3\n    r_end = r0 + 2 * bh // 3 + 1\n    c_start = c0 + bw // 4\n    c_end = c0 + 3 * bw // 4 + 1\n    r_start = max(0, min(r_start, h - 1))\n    r_end = max(r_start + 1, min(r_end, h))\n    c_start = max(0, min(c_start, w - 1))\n    c_end = max(c_start + 1, min(c_end, w))\n    region = mask[r_start:r_end, c_start:c_end]\n    if region.size == 0:\n        return 0.0\n    fill = float(np.sum(region)) / region.size\n    return fill\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Colorfulness metric for RGB images (0 for grayscale) using rg/yb stats'\n    import numpy as np\n    if image is None:\n        return 0.0\n    if len(image.shape) != 3 or image.shape[2] < 3:\n        return 0.0\n    # operate on float channels\n    img = image.astype(float)\n    R = img[:, :, 0]\n    G = img[:, :, 1]\n    B = img[:, :, 2]\n    rg = R - G\n    yb = 0.5 * (R + G) - B\n    std_rg = float(np.std(rg))\n    std_yb = float(np.std(yb))\n    mean_rg = float(np.mean(rg))\n    mean_yb = float(np.mean(yb))\n    colorfulness = np.sqrt(std_rg * std_rg + std_yb * std_yb) + 0.3 * (abs(mean_rg) + abs(mean_yb))\n    return float(colorfulness)\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Ratio of gradient (edge) energy in a central vertical stripe to the sides (higher for central seams/buttons)'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    h, w = gray.shape[:2]\n    gx, gy = np.gradient(gray.astype(np.float32))\n    grad = np.sqrt(gx * gx + gy * gy)\n    mn, mx = float(np.min(gray)), float(np.max(gray))\n    gnorm = (gray - mn) / (mx - mn + 1e-8)  # used for bounding box\n    mask = gnorm > 0.2\n    coords = np.argwhere(mask)\n    if coords.size == 0:\n        # fallback to global center stripe\n        c0, c1 = w // 2 - max(1, w // 20), w // 2 + max(1, w // 20)\n        center_energy = np.sum(grad[:, c0:c1])\n        side_energy = np.sum(grad) - center_energy + 1e-8\n        return float(center_energy / (side_energy + 1e-8))\n    rmin, cmin = coords.min(axis=0)\n    rmax, cmax = coords.max(axis=0)\n    bw = cmax - cmin + 1\n    center_width = max(1, bw // 8)\n    c0 = cmin + bw // 2 - center_width\n    c1 = cmin + bw // 2 + center_width + 1\n    c0 = max(0, c0); c1 = min(w, c1)\n    center_energy = np.sum(grad[rmin:rmax+1, c0:c1])\n    total_energy = np.sum(grad[rmin:rmax+1, cmin:cmax+1]) + 1e-8\n    side_energy = total_energy - center_energy + 1e-8\n    result = float(center_energy / side_energy)\n    return result\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Horizontal left-right asymmetry score of the mask (0 = perfectly symmetric)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    flipped = mask[:, ::-1]\n    diff = np.abs(mask.astype(float) - flipped.astype(float))\n    diff_sum = float(np.sum(diff))\n    # normalize by image area to keep in [0,1]\n    return float(diff_sum / float(h * w + 1e-8))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Vertical centroid offset of foreground (0=center, positive => top-heavy)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    ys = np.where(mask)[0]\n    if ys.size == 0:\n        return 0.0\n    cy = float(np.mean(ys)) / float(h)\n    # return 0 if centered, positive when centroid is above center (top-heavy)\n    return float(0.5 - cy)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Estimated count of internal vertical background gaps in the central band (holes or necklines) normalized by band height and width'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(np.float32)\n    else:\n        gray = image.astype(np.float32)\n    h, w = gray.shape[:2]\n    if h < 4 or w < 4:\n        return 0.0\n    mn, mx = np.min(gray), np.max(gray)\n    if mx - mn < 1e-6:\n        binary = gray > mx * 0.5\n    else:\n        thr = float(np.percentile(gray, 50))\n        binary = gray > thr\n    center = w // 2\n    span = max(1, w // 8)\n    cols = list(range(max(0, center - span), min(w, center + span + 1)))\n    hole_count = 0\n    band_height = 0\n    for c in cols:\n        col = binary[:, c].astype(np.int8)\n        inds = np.where(col)[0]\n        if inds.size >= 2:\n            first, last = int(inds[0]), int(inds[-1])\n            holes = int(np.count_nonzero(col[first:last+1] == 0))\n            hole_count += holes\n            band_height += (last - first + 1)\n    denom = max(1.0, band_height)\n    return float(hole_count / denom)\n",
    "def feature(image: np.ndarray) -> float:\n    'Approximate object eccentricity estimated from the foreground point cloud eigenvalues (minor/major axis ratio)'\n    h, w = image.shape[:2]\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(np.float64)\n    else:\n        gray = image.astype(np.float64)\n    denom = (gray.max() - gray.min()) + 1e-9\n    norm = (gray - gray.min()) / denom\n    mask_idx = np.argwhere(norm > 0.2)\n    if mask_idx.shape[0] < 3:\n        return 0.0\n    # mask_idx rows are (row, col); convert to float columns first\n    pts = mask_idx.astype(np.float64)\n    # center data\n    pts_mean = pts.mean(axis=0)\n    pts_centered = pts - pts_mean\n    cov = np.dot(pts_centered.T, pts_centered) / (pts_centered.shape[0] - 1 + 1e-9)\n    try:\n        eigs = np.linalg.eigvalsh(cov)\n        eigs = np.sort(eigs)\n        minor = float(eigs[0])\n        major = float(eigs[-1]) + 1e-9\n        ratio = minor / major\n        return float(ratio)\n    except Exception:\n        return 0.0\n",
    "def feature(image: np.ndarray) -> float:\n    'Width fraction of the topmost contiguous nonzero horizontal band in the top quarter (shoulder span indicator)'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    h, w = gray.shape\n    if h == 0 or w == 0:\n        return 0.0\n    mx = float(np.max(gray))\n    thr = float(np.mean(gray)) + 0.08 * (mx - float(np.mean(gray)))\n    mask = gray > thr\n    if np.count_nonzero(mask) == 0:\n        mask = gray > float(np.mean(gray))\n    if np.count_nonzero(mask) == 0:\n        return 0.0\n    top_rows = mask[0: max(1, h // 4), :]\n    # for each column check if there is any foreground in top_rows\n    col_any = np.any(top_rows, axis=0).astype(np.int8)\n    if col_any.sum() == 0:\n        return 0.0\n    # find longest contiguous run of ones\n    arr = col_any\n    padded = np.concatenate(([0], arr, [0]))\n    diffs = np.diff(padded)\n    starts = np.where(diffs == 1)[0]\n    ends = np.where(diffs == -1)[0]\n    lengths = ends - starts\n    max_len = int(lengths.max()) if lengths.size else 0\n    return float(max_len) / float(w)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Left-right symmetry of the foreground mask measured as IoU with its mirror (1=perfect)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    flipped = np.fliplr(mask)\n    inter = np.count_nonzero(mask & flipped)\n    union = np.count_nonzero(mask | flipped)\n    if union == 0:\n        return 0.0\n    return float(inter / float(union))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Ratio of vertical gradient energy to horizontal gradient energy (detects vertical seams/edges typical of coats)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    gx, gy = np.gradient(gray)\n    vx = np.sum(np.abs(gx))\n    vy = np.sum(np.abs(gy))\n    eps = 1e-6\n    return float(vy / (vx + eps))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Average side curvature: mean absolute deviation of left/right edge x positions from a straight line fit (normalized by image width)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    thr = np.mean(gray) + 0.1 * np.std(gray)\n    mask = gray > thr\n    if not np.any(mask):\n        return 0.0\n    h, w = mask.shape\n    rows = np.any(mask, axis=1)\n    rmin, rmax = np.argmax(rows), len(rows) - 1 - np.argmax(rows[::-1])\n    if rmax < rmin:\n        return 0.0\n    left_x = []\n    right_x = []\n    ys = []\n    for r in range(rmin, rmax+1):\n        cols = np.where(mask[r, :])[0]\n        if cols.size == 0:\n            continue\n        left_x.append(float(cols[0]))\n        right_x.append(float(cols[-1]))\n        ys.append(float(r - rmin))\n    if len(ys) < 2:\n        return 0.0\n    ys = np.array(ys)\n    left_x = np.array(left_x)\n    right_x = np.array(right_x)\n    # linear fit lines for edges\n    try:\n        pL = np.polyfit(ys, left_x, 1)\n        pR = np.polyfit(ys, right_x, 1)\n    except Exception:\n        return 0.0\n    predL = np.polyval(pL, ys)\n    predR = np.polyval(pR, ys)\n    devL = np.mean(np.abs(left_x - predL))\n    devR = np.mean(np.abs(right_x - predR))\n    dev = (devL + devR) / 2.0\n    if w <= 0:\n        return 0.0\n    return float(dev / float(w))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Ratio of mask area in top 40% versus bottom 40% (top_area / bottom_area, clipped)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    # grayscale\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 50)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    top_h = max(1, (40 * h) // 100)\n    bot_start = max(0, h - top_h)\n    top_area = float(np.count_nonzero(mask[:top_h, :]))\n    bot_area = float(np.count_nonzero(mask[bot_start:, :]))\n    if bot_area <= 1e-8:\n        return float(min(10.0, top_area))  # avoid div by zero, saturate\n    return float(top_area / bot_area)\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Normalized vertical centroid (row index of object center divided by image height)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    thr = np.mean(gray) + 0.2 * (np.max(gray) - np.min(gray))\n    mask = gray > thr\n    if np.count_nonzero(mask) == 0:\n        mask = gray > np.mean(gray)\n    if np.count_nonzero(mask) == 0:\n        return 0.0\n    rows, cols = np.where(mask)\n    centroid_row = np.mean(rows)\n    h = gray.shape[0]\n    return float(centroid_row / max(1, h - 1))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Perimeter complexity: count of edge transitions normalized by object area (higher -> more jagged/complex outline)'\n    import numpy as np\n    img = image.astype(float)\n    img = (img - img.min()) / (img.max() - img.min() + 1e-8)\n    thr = img.mean() + 0.1 * img.std()\n    mask = (img > thr).astype(np.int32)\n    h, w = mask.shape[:2]\n    area = mask.sum()\n    if area == 0:\n        return 0.0\n    # transitions in vertical and horizontal directions\n    vert = np.abs(np.diff(mask, axis=0)).sum()\n    hor = np.abs(np.diff(mask, axis=1)).sum()\n    perimeter_approx = float(vert + hor)\n    return float(perimeter_approx / (area + 1e-8))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Normalized vertical centroid of the foreground mask (0 = top, 1 = bottom)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    ys, xs = np.where(mask)\n    if ys.size == 0:\n        return 0.0\n    cy = float(np.mean(ys)) / float(h)\n    return float(min(1.0, max(0.0, cy)))\n",
    "def feature(image: np.ndarray) -> float:\n    'Ratio of torso width at 40% image height to width at 60% height (values <1 indicate tapering downwards)'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    thr = np.mean(gray)\n    mask = gray > thr\n    if np.count_nonzero(mask) < max(1, h * w * 0.01):\n        mask = gray < thr\n    def avg_row_width(row):\n        rows = range(max(0, row-1), min(h, row+2))\n        widths = []\n        for r in rows:\n            rowmask = mask[r, :]\n            widths.append(np.count_nonzero(rowmask))\n        return float(np.mean(widths))\n    r40 = int(h * 0.4)\n    r60 = int(h * 0.6)\n    w40 = avg_row_width(r40)\n    w60 = avg_row_width(r60)\n    if w60 <= 0.0:\n        return float(w40 / (w60 + 1.0))\n    return float(w40 / w60)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Ratio of mean mask width in bottom 15% rows to mean mask width in top 15% rows'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 4:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 50)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    k = max(1, int(round(0.15 * h)))\n    top_rows = mask[:k, :]\n    bot_rows = mask[-k:, :]\n    top_mean = float(np.mean(np.sum(top_rows, axis=1))) if top_rows.size > 0 else 0.0\n    bot_mean = float(np.mean(np.sum(bot_rows, axis=1))) if bot_rows.size > 0 else 0.0\n    if top_mean <= 1e-8:\n        return float(bot_mean / (top_mean + 1e-8))  # will be large if top_mean ~0\n    return float(bot_mean / top_mean)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Fill ratio of the central torso vertical band (middle 40% width): fraction of pixels present (1.0 = fully filled)'\n    import numpy as np\n    gray = np.mean(image, axis=2) if len(image.shape) == 3 else image.astype(np.float32)\n    gray = np.asarray(gray, dtype=np.float32)\n    thr = max(np.percentile(gray, 70), gray.mean() * 0.6)\n    mask = gray > thr\n    if not mask.any():\n        return 0.0\n    rows, cols = np.where(mask)\n    top, bottom = rows.min(), rows.max()\n    left, right = cols.min(), cols.max()\n    h = bottom - top + 1\n    w = right - left + 1\n    if h <= 0 or w <= 0:\n        return 0.0\n    cx = left + w // 2\n    band_w = max(1, int(round(w * 0.4)))\n    start = max(left, cx - band_w // 2)\n    end = min(right + 1, start + band_w)\n    band = mask[top:bottom+1, start:end]\n    fill_ratio = band.sum() / (band.size + 1e-8)\n    return float(fill_ratio)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Normalized horizontal span of object pixels at middle height (captures sleeve/widest mid-span)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    bg_h, bg_w = max(1, h // 10), max(1, w // 10)\n    bg = np.mean(gray[:bg_h, :bg_w])\n    gm = np.mean(gray)\n    thresh = (bg + gm) / 2.0\n    object_is_darker = gm < bg\n    if object_is_darker:\n        mask = gray < thresh\n    else:\n        mask = gray > thresh\n    r0 = max(0, h // 3)\n    r1 = min(h, 2 * h // 3)\n    band = mask[r0:r1, :]\n    cols = np.any(band, axis=0)\n    if not np.any(cols):\n        return 0.0\n    left = int(np.argmax(cols))\n    right = int(w - 1 - np.argmax(cols[::-1]))\n    span = max(0, right - left + 1)\n    return float(span / max(1, w))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Fraction of columns that contain strong vertical edges (indicates vertical structure like trousers)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    # normalize\n    mx = np.max(gray)\n    if mx > 0:\n        gray = gray / mx\n    gy, gx = np.gradient(gray)\n    vert_edges = np.abs(gx)\n    col_sums = np.sum(vert_edges, axis=0)\n    # threshold relative to median\n    med = np.median(col_sums)\n    thresh = med * 1.5 + 1e-8\n    strong_cols = np.count_nonzero(col_sums > thresh)\n    return float(strong_cols) / float(w)\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Magnitude-weighted average edge orientation in the center region mapped as cos(2*theta) (1=horizontal, -1=vertical)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 2 or w < 2:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    ch = max(1, h // 4)\n    cw = max(1, w // 4)\n    center = gray[ch:3*ch, cw:3*cw]\n    if center.size == 0:\n        return 0.0\n    gy, gx = np.gradient(center)\n    mag = np.sqrt(gx * gx + gy * gy)\n    if not np.any(mag):\n        return 0.0\n    angles = np.arctan2(gy, gx)\n    # cos(2*theta) discriminates horizontal vs vertical\n    val = np.sum(np.cos(2.0 * angles) * mag) / (np.sum(mag) + 1e-8)\n    return float(val)\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Normalized contrast: absolute difference between mean inside-mask and outside-mask intensities'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    inside = gray[mask]\n    outside = gray[~mask]\n    if inside.size == 0 or outside.size == 0:\n        return 0.0\n    mean_in = float(np.mean(inside))\n    mean_out = float(np.mean(outside))\n    denom = (np.mean(gray) + 1e-8)\n    return float(abs(mean_in - mean_out) / denom)\n",
    "def feature(image: np.ndarray) -> float:\n    'Mean gradient magnitude in the bottom half (edge density near the floor)'\n    import numpy as np\n    gray = np.mean(image, axis=2) if len(image.shape) == 3 else image.astype(float)\n    h, w = gray.shape[:2]\n    if h < 2 or w < 2 or np.all(gray == 0):\n        return 0.0\n    bottom = gray[h//2:, :]\n    gy, gx = np.gradient(bottom)\n    grad = np.sqrt(gy**2 + gx**2)\n    return float(np.mean(grad))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Minimum horizontal foreground width among top 15% rows of bbox, normalized by bbox width (small for narrow neck openings)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 50)\n    mask = gray < thr\n    rows, cols = np.where(mask)\n    if rows.size == 0:\n        return 0.0\n    r0, r1 = rows.min(), rows.max()\n    c0, c1 = cols.min(), cols.max()\n    h = r1 - r0 + 1\n    w = c1 - c0 + 1\n    top_h = max(1, int(round(0.15 * h)))\n    widths = []\n    for r in range(r0, r0 + top_h):\n        row = mask[r, c0:c1 + 1]\n        widths.append(float(np.count_nonzero(row)))\n    if len(widths) == 0:\n        return 0.0\n    minw = float(np.min(widths))\n    return float(minw / max(1.0, w))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Relative center texture: standard deviation of a small center patch divided by global image standard deviation'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    cx, cy = w // 2, h // 2\n    pw, ph = max(3, w // 6), max(3, h // 6)\n    x0 = max(0, cx - pw // 2)\n    y0 = max(0, cy - ph // 2)\n    patch = gray[y0:y0 + ph, x0:x0 + pw]\n    if patch.size == 0:\n        return 0.0\n    local_std = float(np.std(patch))\n    global_std = float(np.std(gray)) + 1e-6\n    return float(local_std / global_std)\n",
    "def feature(image: np.ndarray) -> float:\n    'Kurtosis of foreground width per row (measures peakedness of vertical profile)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    row_widths = np.sum(mask, axis=1).astype(float)\n    if row_widths.size == 0:\n        return 0.0\n    mu = np.mean(row_widths)\n    sigma = np.std(row_widths)\n    if sigma < 1e-8:\n        return 0.0\n    kurt = np.mean(((row_widths - mu) ** 4)) / (sigma ** 4) - 3.0\n    return float(kurt)\n",
    "def feature(image: np.ndarray) -> float:\n    'Horizontal flip Jaccard overlap: left-right shape symmetry (higher = more symmetric)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 50)\n    mask_dark = gray < thr\n    mask_bright = gray > thr\n    mask = mask_dark if np.count_nonzero(mask_dark) >= np.count_nonzero(mask_bright) else mask_bright\n    if not np.any(mask):\n        return 0.0\n    flipped = np.fliplr(mask)\n    inter = np.count_nonzero(mask & flipped)\n    union = np.count_nonzero(mask | flipped)\n    if union == 0:\n        return 0.0\n    return float(inter / union)\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Waist indentation: relative depth of the narrowest width in the middle third compared to average of top and bottom thirds (normalized by width)'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    h, w = gray.shape[:2]\n    thr = (np.max(gray) + np.mean(gray)) / 2.0\n    mask = gray > thr\n    if np.count_nonzero(mask) == 0:\n        mask = gray > np.mean(gray)\n        if np.count_nonzero(mask) == 0:\n            return 0.0\n    widths = np.zeros(h, dtype=float)\n    for r in range(h):\n        cols = np.where(mask[r, :])[0]\n        if cols.size > 0:\n            widths[r] = float(cols.max() - cols.min() + 1)\n        else:\n            widths[r] = 0.0\n    top_slice = max(1, h // 6)\n    bottom_slice = h - top_slice\n    middle_start = h // 3\n    middle_end = (2 * h) // 3\n    top_avg = float(np.mean(widths[:top_slice])) if top_slice > 0 else 0.0\n    bottom_avg = float(np.mean(widths[bottom_slice:])) if bottom_slice < h else 0.0\n    middle_min = float(np.min(widths[middle_start:middle_end])) if middle_end > middle_start else 0.0\n    baseline = (top_avg + bottom_avg) / 2.0\n    if w <= 0:\n        return 0.0\n    return float(max(0.0, (baseline - middle_min)) / w)\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Upper-side sleeve protrusion: normalized sum of side pixel counts in upper third (captures sleeves)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    rng = gray.max() - gray.min()\n    thr = np.mean(gray) + (0.12 * rng if rng > 0 else 0.0)\n    mask = gray > thr\n    upper_h = max(1, h // 3)\n    left_zone = mask[:upper_h, :max(1, w//4)]\n    right_zone = mask[:upper_h, w - max(1, w//4):]\n    side_count = float(np.count_nonzero(left_zone) + np.count_nonzero(right_zone))\n    # normalize by area of the two side zones\n    denom = float(left_zone.size + right_zone.size)\n    return float(side_count / (denom + 1e-6))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Ratio of vertical spread to horizontal spread of the foreground (std_y / std_x)'\n    import numpy as np\n    if image is None:\n        return 1.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 1.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    ys, xs = np.nonzero(mask)\n    if ys.size == 0:\n        return 1.0\n    std_y = float(np.std(ys))\n    std_x = float(np.std(xs))\n    if std_x <= 1e-8:\n        return float(1e3)  # very tall thin object\n    return float(std_y / std_x)\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Horizontal centroid offset of the foreground from image center (-1..1)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = float(np.median(gray))\n    mask = ((gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)).astype(np.uint8)\n    ys, xs = np.where(mask)\n    if xs.size == 0:\n        return 0.0\n    cx = float(np.mean(xs))\n    center = (w - 1) / 2.0\n    norm = (cx - center) / max(1.0, w / 2.0)\n    return float(np.clip(norm, -1.0, 1.0))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Bounding-box aspect ratio (height/width) of the main object mask'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    # grayscale\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    # threshold to get mask\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    if not np.any(mask):\n        return 0.0\n    rows = np.where(np.any(mask, axis=1))[0]\n    cols = np.where(np.any(mask, axis=0))[0]\n    if rows.size == 0 or cols.size == 0:\n        return 0.0\n    bbox_h = float(rows[-1] - rows[0] + 1)\n    bbox_w = float(cols[-1] - cols[0] + 1)\n    if bbox_w <= 0:\n        return 0.0\n    return float(bbox_h / (bbox_w + 1e-8))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Density of mask pixels in the central box (central 50% region)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 2 or w < 2:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = gray < thr if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else gray > thr\n    r0, r1 = h // 4, h - h // 4\n    c0, c1 = w // 4, w - w // 4\n    center_region = mask[r0:r1, c0:c1]\n    if center_region.size == 0:\n        return 0.0\n    density = float(np.count_nonzero(center_region)) / float(center_region.size)\n    return float(density)\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Fill ratio: fraction of pixels inside the object bounding box that are foreground (0..1)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape\n    thr = float(np.mean(gray) * 0.6 + np.min(gray) * 0.4)\n    mask = gray > thr\n    if not mask.any():\n        mask = gray >= np.max(gray)\n    rows = np.any(mask, axis=1)\n    cols = np.any(mask, axis=0)\n    if not rows.any() or not cols.any():\n        return 0.0\n    rmin, rmax = int(np.argmax(rows)), int(h - 1 - np.argmax(rows[::-1]))\n    cmin, cmax = int(np.argmax(cols)), int(w - 1 - np.argmax(cols[::-1]))\n    bbox_area = float((rmax - rmin + 1) * (cmax - cmin + 1))\n    if bbox_area <= 0:\n        return 0.0\n    mask_area = float(np.count_nonzero(mask[rmin:rmax + 1, cmin:cmax + 1]))\n    return mask_area / bbox_area\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Colorfulness measure for RGB images (0 for grayscale), higher = more colorful'\n    import numpy as np\n    if image is None:\n        return 0.0\n    if len(image.shape) != 3 or image.shape[2] != 3:\n        return 0.0\n    img = image.astype(float)\n    R = img[:, :, 0]\n    G = img[:, :, 1]\n    B = img[:, :, 2]\n    rg = R - G\n    yb = 0.5 * (R + G) - B\n    std_rg = float(np.std(rg))\n    std_yb = float(np.std(yb))\n    mean_rg = float(np.mean(rg))\n    mean_yb = float(np.mean(yb))\n    colorfulness = np.sqrt(std_rg**2 + std_yb**2) + 0.3 * np.sqrt(mean_rg**2 + mean_yb**2)\n    return float(colorfulness)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Fraction of columns that contain two or more foreground segments (indicates holes/complex shape)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    cols_with_gap = 0\n    for c in range(w):\n        col = mask[:, c].astype(bool)\n        if col.size == 0:\n            continue\n        padded = np.concatenate(([False], col, [False]))\n        transitions = np.count_nonzero((~padded[:-1]) & padded[1:])\n        if transitions >= 2:\n            cols_with_gap += 1\n    return float(cols_with_gap / float(w))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Ratio of average foreground width at mid-torso rows to average width at very top rows (sleeve/shoulder extension index)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    mean = float(np.mean(gray))\n    thresh = mean * 0.6 if mean > 0 else np.percentile(gray.flatten(), 75)\n    fg = gray > thresh\n    # helper to compute average width over a band of rows\n    def avg_width(r0, r1):\n        widths = []\n        for r in range(r0, min(h, r1)):\n            cols = np.where(fg[r, :])[0]\n            if cols.size:\n                widths.append(float(cols.max() - cols.min() + 1))\n        return float(np.mean(widths)) if widths else 0.0\n    top_band = avg_width(0, max(1, h//8))\n    mid_band = avg_width(max(0, h//4), max(1, h//2))\n    eps = 1e-6\n    return float((mid_band + eps) / (top_band + eps))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Mean horizontal contiguous run length in the central region normalized by bounding-box width (measures spread of object across rows)'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.copy()\n    gray = gray.astype(float)\n    thr = np.mean(gray) + 0.5 * np.std(gray)\n    mask = gray > thr\n    if mask.sum() == 0:\n        mask = gray > np.percentile(gray, 75)\n    ys, xs = np.where(mask)\n    if ys.size == 0:\n        return 0.0\n    y0, y1 = ys.min(), ys.max()\n    x0, x1 = xs.min(), xs.max()\n    sub = mask[y0:y1 + 1, x0:x1 + 1]\n    h, w = sub.shape\n    top = int(max(0, h * 0.33))\n    bottom = int(min(h, h * 0.66))\n    region = sub[top:bottom, :] if bottom > top else sub\n    if region.size == 0:\n        return 0.0\n    mean_runs = []\n    for r in range(region.shape[0]):\n        row = region[r, :].astype(np.int8)\n        if row.sum() == 0:\n            mean_runs.append(0)\n            continue\n        dif = np.diff(np.concatenate(([0], row, [0])))\n        starts = np.where(dif == 1)[0]\n        ends = np.where(dif == -1)[0]\n        lengths = (ends - starts).tolist()\n        if lengths:\n            mean_runs.append(np.mean(lengths))\n        else:\n            mean_runs.append(0)\n    avg_run = float(np.mean(mean_runs))\n    return float(avg_run / float(w))\n",
    "def feature(image: np.ndarray) -> float:\n    'Waist indentation: 1 - (minimum width in middle third / maximum width) (higher = more indentation)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    thr = np.mean(gray)\n    mask = gray > thr\n    if not np.any(mask):\n        return 0.0\n    ys, xs = np.where(mask)\n    minr, maxr = ys.min(), ys.max()\n    minc, maxc = xs.min(), xs.max()\n    bh = maxr - minr + 1\n    widths = []\n    for r in range(minr, maxr+1):\n        cols = np.where(mask[r, minc:maxc+1])[0]\n        if cols.size:\n            widths.append(cols.max() - cols.min() + 1)\n        else:\n            widths.append(0)\n    if len(widths) == 0:\n        return 0.0\n    max_w = max(widths) + 1e-8\n    mid_start = minr + bh // 3\n    mid_end = minr + 2 * (bh // 3)\n    mid_rows = widths[mid_start-minr:mid_end-minr+1] if mid_end-minr+1 > 0 else widths\n    min_mid_w = min(mid_rows) if mid_rows else 0.0\n    indentation = 1.0 - (min_mid_w / max_w)\n    return float(indentation)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Mean absolute second derivative (curvature) of the bottom boundary across columns (higher => wavy/curved hem)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    gray = np.mean(image, axis=2) if len(image.shape) == 3 else image.astype(float)\n    h, w = gray.shape[:2]\n    thr = float(np.mean(gray) * 0.5 + np.min(gray) * 0.5)\n    mask = gray > thr\n    bottom_y = np.full((w,), -1.0)\n    for col in range(w):\n        col_inds = np.where(mask[:, col])[0]\n        bottom_y[col] = float(col_inds.max()) if col_inds.size > 0 else float(h)\n    # smooth and compute second derivative\n    if w < 3:\n        return 0.0\n    # replace any h entries (no object) by nearest neighbor interpolation\n    invalid = bottom_y >= h\n    if np.any(invalid):\n        good_idx = np.where(~invalid)[0]\n        if good_idx.size == 0:\n            return 0.0\n        bottom_y[invalid] = np.interp(np.where(invalid)[0], good_idx, bottom_y[good_idx])\n    d1 = np.gradient(bottom_y)\n    d2 = np.gradient(d1)\n    mean_abs_d2 = float(np.mean(np.abs(d2)))\n    # normalize by image height to be scale invariant\n    return float(mean_abs_d2 / max(1.0, h))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Normalized top-bottom asymmetry: mean absolute difference between image and its vertical flip'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    flipped = np.flipud(gray)\n    diff = np.abs(gray - flipped)\n    denom = np.mean(np.abs(gray)) + 1e-8\n    return float(np.mean(diff) / denom)\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Fraction of foreground pixels located in the top quarter of the image'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 4 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 50)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    area = float(np.count_nonzero(mask))\n    if area == 0.0:\n        return 0.0\n    top = mask[:max(1, h // 4), :]\n    top_count = float(np.count_nonzero(top))\n    return float(top_count / (area + 1e-12))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Vertical centroid of mask (normalized 0.0 top to 1.0 bottom)'\n    import numpy as np\n    if image is None:\n        return 0.5\n    h, w = image.shape[:2]\n    if h == 0:\n        return 0.5\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    ys, xs = np.where(mask)\n    if ys.size == 0:\n        return 0.5\n    centroid_y = float(np.mean(ys))\n    return float(centroid_y / max(1.0, float(h - 1)))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Dominant color channel ratio (mean max channel / mean min channel), 1.0 for grayscale'\n    import numpy as np\n    if image is None:\n        return 1.0\n    if len(image.shape) != 3 or image.shape[2] < 3:\n        return 1.0\n    h, w, c = image.shape\n    if h == 0 or w == 0:\n        return 1.0\n    r = np.mean(image[:, :, 0].astype(float))\n    g = np.mean(image[:, :, 1].astype(float))\n    b = np.mean(image[:, :, 2].astype(float))\n    mx = max(r, g, b)\n    mn = min(r, g, b)\n    if mn <= 1e-8:\n        return float(mx / (mn + 1e-8))\n    return float(mx / mn)\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Compactness approx: perimeter^2 / area using 4-neighborhood perimeter estimate'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 50)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    area = float(np.count_nonzero(mask))\n    if area <= 0:\n        return 0.0\n    # perimeter: mask pixels that have at least one 4-neighbor background\n    up = np.zeros_like(mask); up[1:, :] = mask[:-1, :]\n    down = np.zeros_like(mask); down[:-1, :] = mask[1:, :]\n    left = np.zeros_like(mask); left[:, 1:] = mask[:, :-1]\n    right = np.zeros_like(mask); right[:, :-1] = mask[:, 1:]\n    neighbor_all = up & down & left & right\n    border_pixels = mask & (~neighbor_all)\n    perimeter = float(np.count_nonzero(border_pixels))\n    return float((perimeter * perimeter) / (area + 1e-8))\n",
    "def feature(image: np.ndarray) -> float:\n    'Absolute normalized difference between the object width at top 10% and bottom 10% of bbox (higher for tapering or straps)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    thr = 0.6 * np.mean(gray) + 0.4 * np.min(gray)\n    mask = gray > thr\n    ys, xs = np.where(mask)\n    if ys.size == 0:\n        return 0.0\n    r0, r1 = ys.min(), ys.max()\n    bbox_h = r1 - r0 + 1\n    top_h = max(1, int(np.ceil(0.10 * bbox_h)))\n    bottom_h = top_h\n    top_slice = mask[r0:r0+top_h, :]\n    bottom_slice = mask[r1-bottom_h+1:r1+1, :]\n    top_width = np.count_nonzero(top_slice.sum(axis=0) > 0)\n    bottom_width = np.count_nonzero(bottom_slice.sum(axis=0) > 0)\n    denom = float(max(1, top_width + bottom_width))\n    return float(abs(top_width - bottom_width)) / denom\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Fraction of mask pixels that touch the image border (0..1)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    total = np.count_nonzero(mask)\n    if total == 0:\n        return 0.0\n    # border pixels: top row, bottom row, left col, right col (avoid double counting corners by boolean OR)\n    border_mask = np.zeros_like(mask, dtype=bool)\n    border_mask[0, :] = mask[0, :]\n    border_mask[-1, :] = mask[-1, :]\n    border_mask[:, 0] = border_mask[:, 0] | mask[:, 0]\n    border_mask[:, -1] = border_mask[:, -1] | mask[:, -1]\n    border_count = np.count_nonzero(border_mask)\n    return float(border_count) / float(total)\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Ratio of average horizontal width in the middle half to the bottom quarter (detects dresses/flared bottoms vs straight hems)'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    mask = (gray > 0)\n    if not np.any(mask):\n        return 0.0\n    ys, xs = np.where(mask)\n    top, bottom = int(ys.min()), int(ys.max())\n    left, right = int(xs.min()), int(xs.max())\n    bw = right - left + 1\n    bh = bottom - top + 1\n    # middle half\n    mid_top = top + bh // 4\n    mid_bottom = top + 3 * bh // 4\n    mid_crop = mask[mid_top:mid_bottom+1, left:right+1]\n    # bottom quarter\n    bot_top = max(top, bottom - max(1, bh // 4) + 1)\n    bot_crop = mask[bot_top:bottom+1, left:right+1]\n    def horiz_width(arr):\n        if arr.size == 0:\n            return 0\n        cols_present = np.any(arr, axis=0)\n        return int(np.count_nonzero(cols_present))\n    mid_width = horiz_width(mid_crop)\n    bot_width = horiz_width(bot_crop)\n    eps = 1e-6\n    ratio = float(mid_width / (bot_width + eps))\n    return ratio\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Colorfulness metric (Has value 0 for grayscale images)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    if len(image.shape) != 3 or image.shape[2] < 3:\n        return 0.0\n    img = image.astype(float)\n    R = img[:, :, 0]\n    G = img[:, :, 1]\n    B = img[:, :, 2]\n    rg = R - G\n    yb = 0.5 * (R + G) - B\n    std_rg = float(np.std(rg))\n    std_yb = float(np.std(yb))\n    mean_rg = float(np.mean(rg))\n    mean_yb = float(np.mean(yb))\n    colorfulness = np.sqrt(std_rg * std_rg + std_yb * std_yb) + 0.3 * np.sqrt(mean_rg * mean_rg + mean_yb * mean_yb)\n    return float(colorfulness)\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Perimeter-to-area ratio of the binary mask (higher = more edge/complex shape)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    area = float(np.count_nonzero(mask))\n    if area == 0.0:\n        return 0.0\n    # boundary pixels where a neighbor is background\n    up = np.zeros_like(mask); up[1:, :] = mask[:-1, :]\n    down = np.zeros_like(mask); down[:-1, :] = mask[1:, :]\n    left = np.zeros_like(mask); left[:, 1:] = mask[:, :-1]\n    right = np.zeros_like(mask); right[:, :-1] = mask[:, 1:]\n    edge = mask & (~up | ~down | ~left | ~right)\n    perimeter = float(np.count_nonzero(edge))\n    return float(perimeter / (area + 1e-8))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Normalized valley depth between two major bottom-half peaks (0.0=no valley, 1.0=deep valley) indicating leg separation'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    rng = float(np.max(gray) - np.min(gray))\n    thr = float(np.mean(gray) + 0.05 * rng)\n    mask = (gray > thr).astype(int)\n    bottom = mask[h//2:, :]\n    if bottom.sum() == 0:\n        return 0.0\n    col_sum = bottom.sum(axis=0).astype(float)\n    # smooth a little\n    col_s = np.convolve(col_sum, np.ones(5)/5.0, mode='same')\n    if np.max(col_s) <= 0:\n        return 0.0\n    # find two largest peaks\n    idx_sorted = np.argsort(col_s)[::-1]\n    peak_idxs = [int(i) for i in idx_sorted[:2] if col_s[i] > 0.15 * np.max(col_s)]\n    if len(peak_idxs) < 2:\n        return 0.0\n    a, b = sorted(peak_idxs)\n    valley = float(np.min(col_s[a:b+1]))\n    peak_val = float(min(col_s[a], col_s[b]))\n    depth = (peak_val - valley) / (peak_val + 1e-8)\n    return float(max(0.0, min(1.0, depth)))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Mean gradient magnitude (edge strength) normalized by image size (sneakers often have more texture/edges than sandals)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    gy, gx = np.gradient(gray)\n    mag = np.sqrt(gx**2 + gy**2)\n    mean_mag = float(np.mean(mag))\n    # normalize by dynamic range to be robust to contrast\n    dyn = float(np.max(gray) - np.min(gray))\n    norm = mean_mag / (dyn + 1e-9)\n    return float(norm)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Vertical centroid of the foreground mask normalized by image height (0 top .. 1 bottom)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 50)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    ys = np.where(mask)[0]\n    if ys.size == 0:\n        return 0.0\n    cy = float(np.mean(ys))\n    return float(cy / float(h))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Longest contiguous vertical background run in a small top-center box normalized by box height (measures neck opening depth)'\n    import numpy as np\n    h, w = image.shape[:2]\n    gray = np.mean(image, axis=2) if image.ndim == 3 else image.astype(float)\n    # top-center box: top 20% height, center 30% width\n    bh = max(1, h // 5)\n    bw = max(1, w * 3 // 10)\n    cx = w // 2\n    box = gray[0:bh, max(0, cx - bw//2): min(w, cx + (bw+1)//2)]\n    if box.size == 0:\n        return 0.0\n    thr = np.percentile(gray, 75)\n    mask_box = box > thr\n    # background in this box\n    bg = ~mask_box\n    # for each column find max run of True (background) vertically\n    max_runs = 0\n    for c in range(bg.shape[1]):\n        col = bg[:, c]\n        # compute longest run of True\n        if not col.any():\n            continue\n        # find run lengths by differences\n        padded = np.concatenate(([0], col.astype(int), [0]))\n        dif = np.diff(padded)\n        starts = np.where(dif == 1)[0]\n        ends = np.where(dif == -1)[0]\n        if starts.size:\n            runs = (ends - starts)\n            max_runs = max(max_runs, runs.max())\n    return float(max_runs / max(1.0, box.shape[0]))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Horizontal symmetry score of the object crop (1.0 = perfectly symmetric)'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    h, w = gray.shape[:2]\n    try:\n        thr = float(np.percentile(gray, 60))\n    except Exception:\n        thr = float(np.mean(gray))\n    mask = (gray > thr).astype(np.float32)\n    if not np.any(mask):\n        return 0.0\n    rows = np.any(mask, axis=1)\n    cols = np.any(mask, axis=0)\n    rmin = int(np.argmax(rows))\n    rmax = int(h - 1 - np.argmax(rows[::-1]))\n    cmin = int(np.argmax(cols))\n    cmax = int(w - 1 - np.argmax(cols[::-1]))\n    if rmax < rmin or cmax < cmin:\n        return 0.0\n    crop = mask[rmin:rmax+1, cmin:cmax+1]\n    # resize not available; compare left and mirrored right by cropping to same width\n    ch, cw = crop.shape\n    half = cw // 2\n    left = crop[:, :half]\n    right = crop[:, cw-half:][:, ::-1] if half > 0 else crop[:, :0]\n    if left.size == 0 or right.size == 0:\n        # degenerate -> treat as symmetric if single column\n        return 1.0 if cw <= 1 else 0.0\n    # align sizes if cw is odd\n    minw = min(left.shape[1], right.shape[1])\n    left = left[:, :minw]\n    right = right[:, :minw]\n    diff = np.mean(np.abs(left - right))\n    score = 1.0 - float(diff)  # bigger is more symmetric\n    return float(max(0.0, min(1.0, score)))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Central vertical dark-line score: side mean minus center mean (detect button placket)'\n    import numpy as np\n    gray = np.mean(image, axis=2) if len(image.shape) == 3 else image.astype(float)\n    h, w = gray.shape[:2]\n    r0, r1 = h // 6, h // 2\n    center_w = max(1, w // 12)\n    center_c = w // 2\n    center_strip = gray[r0:r1, max(0, center_c - center_w):min(w, center_c + center_w)]\n    side_left = gray[r0:r1, max(0, c0:=w//8):max(0, w//8 + center_w)]\n    side_right = gray[r0:r1, min(w, w - w//8 - center_w):min(w, w - w//8)]\n    # fallback if sides too small\n    if center_strip.size == 0:\n        return 0.0\n    side_mean = np.mean(np.concatenate([side_left.flatten(), side_right.flatten()])) if (side_left.size + side_right.size) > 0 else np.mean(center_strip)\n    center_mean = np.mean(center_strip)\n    return float((side_mean - center_mean) / (np.std(gray) + 1e-6))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Horizontal centroid offset magnitude (0=centered, up to 0.5 = strong side bias)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 50)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    ys, xs = np.where(mask)\n    if xs.size == 0:\n        return 0.0\n    centroid_x = float(np.mean(xs))\n    offset = (centroid_x - (w - 1) / 2.0) / float(max(1, w))\n    result = abs(offset)\n    return float(result)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Mean horizontal centroid shift between upper and lower halves normalized by bbox width (bags often centered, tops may shift due to sleeves)'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.mean(gray)\n    mask = gray > thr\n    if not np.any(mask):\n        thr2 = np.percentile(gray, 75)\n        mask = gray > thr2\n        if not np.any(mask):\n            return 0.0\n    ys, xs = np.where(mask)\n    y0, y1 = ys.min(), ys.max()\n    bbox = mask[y0:y1+1, :]\n    h, w = bbox.shape\n    if h < 2:\n        return 0.0\n    top = bbox[:h//2, :]\n    bottom = bbox[h//2:, :]\n    def centroid_x(mat):\n        rows, cols = np.where(mat)\n        if rows.size == 0:\n            return float(w / 2)\n        return float(np.mean(cols))\n    cx_top = centroid_x(top)\n    cx_bottom = centroid_x(bottom)\n    return float(abs(cx_top - cx_bottom) / max(1.0, w))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Ratio of corner bottom mass (sum of pixels in left+right bottom quarters) to center-bottom mass (indicates leg-like or corner-heavy shapes)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    thr = gray.mean() * 0.5\n    mask = gray > thr if np.count_nonzero(gray) > 0 else gray > 0\n    if mask.sum() == 0:\n        return 0.0\n    ys, xs = np.where(mask)\n    r0, r1 = ys.min(), ys.max()\n    c0, c1 = xs.min(), xs.max()\n    h = r1 - r0 + 1\n    w = c1 - c0 + 1\n    bh = max(1, h // 4)\n    bw = max(1, w // 4)\n    sub = gray[r1-bh+1:r1+1, c0:c1+1]\n    if sub.size == 0:\n        return 0.0\n    left_corner = sub[:, :bw].sum()\n    right_corner = sub[:, -bw:].sum()\n    center_box = sub[:, (w//2 - bw//2):(w//2 + bw//2 + 1)].sum()\n    denom = center_box + 1e-6\n    return float((left_corner + right_corner) / denom)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Object extent: ratio of object area to its bounding-box area (compactness within bounding box)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    thr = np.mean(gray) + 0.2 * (np.max(gray) - np.min(gray))\n    mask = gray > thr\n    if np.count_nonzero(mask) == 0:\n        mask = gray > np.mean(gray)\n    if np.count_nonzero(mask) == 0:\n        return 0.0\n    rows, cols = np.where(mask)\n    rmin, rmax = rows.min(), rows.max()\n    cmin, cmax = cols.min(), cols.max()\n    area = np.count_nonzero(mask)\n    bbox_area = (rmax - rmin + 1) * (cmax - cmin + 1)\n    if bbox_area == 0:\n        return 0.0\n    return float(area / bbox_area)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Standard deviation of gradient magnitude (texture variability), normalized'\n    import numpy as np\n    if image is None:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    if gray.size == 0:\n        return 0.0\n    gy, gx = np.gradient(gray)\n    grad = np.sqrt(gx * gx + gy * gy)\n    mx = np.max(grad)\n    if mx > 0:\n        grad = grad / mx\n    return float(np.std(grad))\n",
    "def feature(image: np.ndarray) -> float:\n    'Torso width consistency: relative standard deviation of object row-wise widths between 20%-80% height (lower = more uniform)'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    if h < 4 or w < 4:\n        return 0.0\n    thresh = max(1e-6, np.mean(gray) * 0.5)\n    mask = (gray > thresh).astype(np.uint8)\n    if np.sum(mask) == 0:\n        return 0.0\n    r0 = max(0, int(0.2 * h))\n    r1 = min(h, int(0.8 * h))\n    widths = []\n    for r in range(r0, r1):\n        cols = np.where(mask[r, :])[0]\n        if cols.size > 0:\n            widths.append(cols[-1] - cols[0] + 1)\n    if len(widths) == 0:\n        return 0.0\n    widths = np.array(widths, dtype=float)\n    mean_w = widths.mean()\n    std_w = widths.std()\n    rel_std = std_w / (mean_w + 1e-6)\n    return float(rel_std)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Ratio of Laplacian variance in bottom 20% to top 20% (shoe texture vs upper garment texture)'\n    import numpy as np\n    if image is None:\n        return 1.0\n    h, w = image.shape[:2]\n    if h < 6 or w < 3:\n        return 1.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    gy, gx = np.gradient(gray.astype(float))\n    gxx = np.gradient(gx, axis=1)\n    gyy = np.gradient(gy, axis=0)\n    lap = gxx + gyy\n    band = max(1, h // 5)\n    top_lap = lap[:band, :].flatten()\n    bottom_lap = lap[h - band:, :].flatten()\n    if top_lap.size == 0 or bottom_lap.size == 0:\n        return 1.0\n    var_top = float(np.var(top_lap))\n    var_bottom = float(np.var(bottom_lap))\n    result = (var_bottom + 1e-8) / (var_top + 1e-8)\n    return float(result)\n",
    "def feature(image: np.ndarray) -> float:\n    'Average absolute diagonal edge strength (45\u00b0 and -45\u00b0) in the lower-side quarters (detects pocket/diagonal seams)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape\n    m = gray.mean(); s = gray.std()\n    thr = m + 0.1 * s\n    mask = gray > thr\n    if mask.sum() < 0.01 * h * w:\n        mask = gray > np.percentile(gray, 60)\n    ys = np.where(mask.any(axis=1))[0]\n    if ys.size == 0:\n        return 0.0\n    y0, y1 = ys[0], ys[-1]\n    bh = y1 - y0 + 1\n    bot0 = max(y0, y1 - bh // 3)\n    left_box = gray[bot0:y1, 0:w//2]\n    right_box = gray[bot0:y1, w//2:w]\n    def diag_strength(block):\n        if block.shape[0] < 2 or block.shape[1] < 2:\n            return 0.0\n        a = np.abs(block[:-1, :-1] - block[1:, 1:])  # \\ diagonal\n        b = np.abs(block[:-1, 1:] - block[1:, :-1])  # / diagonal\n        return float((np.mean(a) + np.mean(b)) / 2.0)\n    ls = diag_strength(left_box)\n    rs = diag_strength(right_box)\n    return float((ls + rs) / 2.0)\n",
    "def feature(image: np.ndarray) -> float:\n    'Fraction of background pixels inside the object bounding box (approximate hole/handle gap detection)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 65)\n    mask = gray > thr\n    if np.count_nonzero(mask) == 0:\n        thr = np.percentile(gray, 45)\n        mask = gray > thr\n        if np.count_nonzero(mask) == 0:\n            return 0.0\n    rows = np.any(mask, axis=1)\n    cols = np.any(mask, axis=0)\n    if not rows.any() or not cols.any():\n        return 0.0\n    y0, y1 = np.where(rows)[0][[0, -1]]\n    x0, x1 = np.where(cols)[0][[0, -1]]\n    box_area = float((y1 - y0 + 1) * (x1 - x0 + 1))\n    if box_area <= 0:\n        return 0.0\n    inside_mask = mask[y0:y1+1, x0:x1+1]\n    hole_frac = 1.0 - (inside_mask.sum() / box_area)\n    return float(hole_frac)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Number of connected foreground components (simple 4-neighbor flood fill), clipped to 20'\n    import numpy as np\n    from collections import deque\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = ((gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)).astype(bool)\n    visited = np.zeros_like(mask, dtype=bool)\n    comps = 0\n    for r in range(h):\n        for c in range(w):\n            if mask[r, c] and not visited[r, c]:\n                comps += 1\n                # flood fill\n                dq = deque()\n                dq.append((r, c))\n                visited[r, c] = True\n                while dq:\n                    yr, yc = dq.popleft()\n                    # 4-neighbors\n                    if yr > 0 and mask[yr - 1, yc] and not visited[yr - 1, yc]:\n                        visited[yr - 1, yc] = True\n                        dq.append((yr - 1, yc))\n                    if yr + 1 < h and mask[yr + 1, yc] and not visited[yr + 1, yc]:\n                        visited[yr + 1, yc] = True\n                        dq.append((yr + 1, yc))\n                    if yc > 0 and mask[yr, yc - 1] and not visited[yr, yc - 1]:\n                        visited[yr, yc - 1] = True\n                        dq.append((yr, yc - 1))\n                    if yc + 1 < w and mask[yr, yc + 1] and not visited[yr, yc + 1]:\n                        visited[yr, yc + 1] = True\n                        dq.append((yr, yc + 1))\n                if comps >= 20:\n                    # clip for stability\n                    return float(20.0)\n    return float(float(comps))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Fraction of image rows that contain foreground (vertical coverage fraction)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 50)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    rows_with = np.count_nonzero(np.any(mask, axis=1))\n    return float(rows_with / float(h))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Upper lateral extension score: proportion of foreground pixels that extend beyond the core torso in the top quarter on left or right (captures sleeves or shoulder breadth)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    if gray.size == 0:\n        return 0.0\n    lo, hi = float(np.min(gray)), float(np.max(gray))\n    if hi == lo:\n        return 0.0\n    thr = (lo + hi) / 2.0\n    mask = gray > thr\n    ys, xs = np.where(mask)\n    if ys.size == 0:\n        return 0.0\n    top, bottom = ys.min(), ys.max() + 1\n    left, right = xs.min(), xs.max() + 1\n    h = bottom - top\n    w = right - left\n    if h <= 2 or w <= 2:\n        return 0.0\n    qh = max(1, h // 4)\n    top_region = mask[top: top + qh, left:right]\n    # find central core columns in top region (columns appearing in >50% of top rows)\n    col_presence = (top_region.sum(axis=0) >= (0.5 * top_region.shape[0])).astype(float)\n    core_cols = np.where(col_presence)[0]\n    if core_cols.size == 0:\n        return 0.0\n    core_left, core_right = core_cols.min(), core_cols.max()\n    # count pixels in top region that lie outside this core (left or right extensions)\n    outside = top_region.copy()\n    outside[:, core_left:core_right+1] = False\n    ext_count = float(outside.sum())\n    total = float(top_region.sum()) if top_region.sum() > 0 else 1.0\n    return float(ext_count / total)\n",
    "def feature(image: np.ndarray) -> float:\n    'Median number of horizontal mask segments per row (normalized by width)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 50)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    counts = []\n    for r in range(h):\n        row = mask[r, :].astype(np.int8)\n        if np.all(row == 0):\n            continue\n        dif = np.diff(np.concatenate(([0], row)))\n        starts = np.count_nonzero(dif == 1)\n        if starts > 0:\n            counts.append(float(starts))\n    if len(counts) == 0:\n        return 0.0\n    med = float(np.median(np.array(counts)))\n    # normalize by possible maximum segments (~w/2)\n    return float(med / max(1.0, float(w) / 2.0))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Fraction of foreground located in the central vertical band (centeredness)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    total = float(np.count_nonzero(mask))\n    if total == 0:\n        return 0.0\n    left = w // 4\n    right = w - left\n    center_frac = float(np.count_nonzero(mask[:, left:right])) / float(total)\n    return float(center_frac)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Normalized vertical centroid (y-coordinate) of foreground pixels, between 0 (top) and 1 (bottom)'\n    if image is None:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    h, w = gray.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    thresh = np.mean(gray) + 0.1 * (np.max(gray) - np.min(gray))\n    binary = (gray > thresh).astype(np.float32)\n    total = np.sum(binary)\n    if total == 0:\n        return 0.0\n    rows = np.arange(h)[:, None]\n    centroid_y = np.sum(rows * binary) / total  # row index weighted by occupancy\n    return float(centroid_y / max(1.0, h - 1))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Neckline darkness contrast: mean intensity of a small center-top strip minus side-top strips (positive if center is darker)'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    if h < 4 or w < 4:\n        return 0.0\n    # strips: top 8% rows, center 20% columns vs side 20% columns\n    top_rows = max(1, h // 12)\n    cw = max(1, w // 5)\n    center_c = w // 2\n    center_slice = (slice(0, top_rows), slice(max(0, center_c-cw//2), min(w, center_c+cw//2+1)))\n    left_slice = (slice(0, top_rows), slice(0, cw))\n    right_slice = (slice(0, top_rows), slice(max(0, w-cw), w))\n    center_mean = np.mean(gray[center_slice]) if gray[center_slice].size else np.mean(gray)\n    sides_mean = np.mean(np.concatenate([gray[left_slice].flatten(), gray[right_slice].flatten()])) if (gray[left_slice].size + gray[right_slice].size) > 0 else np.mean(gray)\n    # darker center => sides_mean - center_mean positive, we return that normalized by overall intensity range\n    denom = (np.max(gray) - np.min(gray) + 1e-6)\n    contrast = (sides_mean - center_mean) / denom\n    return float(contrast)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Normalized top-third mass: fraction of object pixels in the top third of the image'\n    import numpy as np\n    img = np.asarray(image)\n    if img.size == 0:\n        return 0.0\n    if img.ndim == 3:\n        gray = np.mean(img, axis=2)\n    else:\n        gray = img\n    thresh = float(np.percentile(gray.flatten(), 70))\n    mask = gray > thresh\n    total = float(np.count_nonzero(mask))\n    if total == 0.0:\n        return 0.0\n    h = gray.shape[0]\n    top_end = max(1, h // 3)\n    top_count = float(np.count_nonzero(mask[:top_end, :]))\n    return top_count / total\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Mean inter-channel color variance (colorfulness); 0 for grayscale'\n    import numpy as np\n    if image is None:\n        return 0.0\n    if len(image.shape) != 3 or image.shape[2] < 3:\n        return 0.0\n    # use float channels\n    im = image.astype(float)\n    r, g, b = im[:, :, 0], im[:, :, 1], im[:, :, 2]\n    diff_sum = np.mean(np.abs(r - g) + np.abs(r - b) + np.abs(g - b))\n    rng = np.max(im) - np.min(im)\n    rng = rng if rng > 1e-8 else 1.0\n    return float(diff_sum / rng)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Vertical central-line response: summed absolute difference between center column and its neighbors (detects narrow bright/dark button strips or seams)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    if w < 3 or h < 1:\n        return 0.0\n    c = w // 2\n    center_col = gray[:, c]\n    left_col = gray[:, max(0, c - 1)]\n    right_col = gray[:, min(w - 1, c + 1)]\n    diff = np.abs(center_col - left_col) + np.abs(center_col - right_col)\n    denom = np.sum(np.abs(gray)) + 1e-8\n    return float(np.sum(diff) / denom)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Ratio of mean foreground width in bottom 25% rows to top 25% rows (helps separate shoes/pants vs tops)'\n    import numpy as np\n    if image is None:\n        return 1.0\n    h, w = image.shape[:2]\n    if h < 4 or w == 0:\n        return 1.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 50)\n    mask = ((gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)).astype(np.uint8)\n    band = max(1, h // 4)\n    top_band = mask[:band, :]\n    bottom_band = mask[h - band:, :]\n    top_widths = np.sum(top_band, axis=1).astype(float)\n    bottom_widths = np.sum(bottom_band, axis=1).astype(float)\n    top_mean = float(np.mean(top_widths)) + 1e-8\n    bottom_mean = float(np.mean(bottom_widths)) + 1e-8\n    return float(bottom_mean / top_mean)\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Row index (fraction of bbox height) of the row with maximum horizontal span of object pixels (where the garment is widest)'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    h, w = gray.shape\n    thr = np.mean(gray)\n    mask = gray > thr\n    if not np.any(mask):\n        return 0.0\n    # find bbox rows with any pixels\n    rows = np.where(np.sum(mask, axis=1) > 0)[0]\n    if rows.size == 0:\n        return 0.0\n    spans = np.sum(mask[rows, :], axis=1)\n    max_idx = np.argmax(spans)\n    max_row = rows[max_idx]\n    top = rows.min()\n    bottom = rows.max()\n    height = bottom - top + 1 if bottom > top else 1\n    return float((max_row - top) / float(height))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Normalized inter-channel color variation (0 for grayscale)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    if len(image.shape) != 3 or image.shape[2] < 3:\n        return 0.0\n    img = image.astype(float)\n    ch_std = np.std(img, axis=(0, 1))\n    mean_chan_std = float(np.mean(ch_std))\n    intensity = np.mean(img, axis=2)\n    overall_std = float(np.std(intensity))\n    return float(mean_chan_std / (overall_std + 1e-8))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Ratio of bottom-quarter object width to top-quarter object width ( >1 if bottom wider; useful to separate dresses from trousers)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    if gray.size == 0:\n        return 0.0\n    lo, hi = float(np.min(gray)), float(np.max(gray))\n    if hi == lo:\n        return 0.0\n    thr = (lo + hi) / 2.0\n    mask = gray > thr\n    ys, xs = np.where(mask)\n    if ys.size == 0:\n        return 0.0\n    top, bottom = ys.min(), ys.max() + 1\n    left, right = xs.min(), xs.max() + 1\n    h = bottom - top\n    if h <= 2:\n        return 0.0\n    # top and bottom quarters\n    qh = max(1, h // 4)\n    top_region = mask[top: top + qh, left:right]\n    bottom_region = mask[bottom - qh: bottom, left:right]\n    def width_of_region(region):\n        ys2, xs2 = np.where(region)\n        if ys2.size == 0:\n            return 0.0\n        return float(xs2.max() - xs2.min() + 1)\n    top_w = width_of_region(top_region)\n    bottom_w = width_of_region(bottom_region)\n    if top_w <= 0:\n        return float(bottom_w)  # avoid division by zero\n    return float(bottom_w / top_w)\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Mean absolute Laplacian-like second-derivative normalized by mean gradient (texture measure)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 3 or w < 3:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    gy, gx = np.gradient(gray)\n    gxx = np.gradient(gx, axis=1)\n    gyy = np.gradient(gy, axis=0)\n    lap = gxx + gyy\n    mean_abs_lap = float(np.mean(np.abs(lap)))\n    mean_grad = float(np.mean(np.sqrt(gx*gx + gy*gy)))\n    return float(mean_abs_lap / (mean_grad + 1e-8))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Standard deviation of bottom silhouette residuals after linear fit (normalized by bbox height) to detect curved hems'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    mn, mx = gray.min(), gray.max()\n    if mx <= mn:\n        return 0.0\n    thresh = np.mean(gray) + 0.12 * (mx - mn)\n    mask = gray > thresh\n    if not np.any(mask):\n        return 0.0\n    ys, xs = np.nonzero(mask)\n    left, right = xs.min(), xs.max()\n    top, bottom = ys.min(), ys.max()\n    cols = right - left + 1\n    bottoms = np.full(cols, fill_value=-5, dtype=int)\n    for c in range(left, right + 1):\n        col_idx = np.where(mask[:, c])[0]\n        if col_idx.size:\n            bottoms[c-left] = col_idx[-1]\n    valid = bottoms >= 0\n    if valid.sum() < 3:\n        return 0.0\n    xs_coords = np.where(valid)[0].astype(float)\n    ys_coords = bottoms[valid].astype(float)\n    try:\n        p = np.polyfit(xs_coords, ys_coords, 1)\n        fitted = np.polyval(p, xs_coords)\n        resid = ys_coords - fitted\n        bbox_h = max(1.0, bottom - top + 1.0)\n        return float(np.std(resid) / bbox_h)\n    except Exception:\n        return float(np.std(ys_coords) / max(1.0, bottom - top + 1.0))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Vertical variance of central column occupancy (counts variation of object presence along vertical center, high for shirts with gaps/buttons)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape\n    mn, mx = float(np.min(gray)), float(np.max(gray))\n    if mx - mn < 1e-6:\n        return 0.0\n    thr = mn + 0.20 * (mx - mn)\n    mask = (gray > thr).astype(float)\n    # central column (or average of 3 columns)\n    c = w // 2\n    cols = [c]\n    if w > 2:\n        cols = [max(0, c - 1), c, min(w - 1, c + 1)]\n    strip = mask[:, cols].mean(axis=1)  # occupancy fraction per row\n    var = float(np.var(strip))\n    # normalize by max possible variance (0.25 for binary occupancy) but keep numeric stable\n    return float(var / (0.25 + 1e-9))\n",
    "def feature(image: np.ndarray) -> float:\n    'Vertical offset between full-foreground centroid and lower-half centroid normalized by height (positive if lower mass is lower)'\n    import numpy as np\n    h, w = image.shape[:2]\n    gray = np.mean(image, axis=2) if image.ndim == 3 else image.astype(float)\n    thr = max(np.percentile(gray, 70), np.mean(gray) * 0.4, 1e-6)\n    fg = (gray > thr).astype(float)\n    total = fg.sum()\n    if total == 0:\n        return 0.0\n    ys, xs = np.nonzero(fg)\n    full_centroid_y = ys.mean()\n    # lower half mask\n    lower_mask = np.zeros_like(fg)\n    lower_mask[h//2:, :] = 1\n    lower_fg = fg * lower_mask\n    lower_total = lower_fg.sum()\n    if lower_total == 0:\n        # if no mass in lower half, return normalized distance to bottom\n        return float((full_centroid_y - 0) / max(1, h))\n    lys, lxs = np.nonzero(lower_fg)\n    lower_centroid_y = lys.mean()\n    # positive if lower centroid is lower (greater y)\n    return float((lower_centroid_y - full_centroid_y) / max(1, h))\n",
    "def feature(image: np.ndarray) -> float:\n    'Width at one-third height divided by maximum width across rows (captures where object bulges)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    maxv = float(gray.max()) if gray.size else 0.0\n    if maxv <= 0 or h < 3:\n        return 0.0\n    mask = gray > (0.2 * maxv)\n    widths = np.count_nonzero(mask, axis=1).astype(float)\n    max_width = float(widths.max()) if widths.size else 0.0\n    row_idx = min(h-1, max(0, h//3))\n    width_at_third = float(widths[row_idx]) if widths.size else 0.0\n    if max_width <= 0:\n        return 0.0\n    return float(width_at_third / max_width)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Mean horizontal offset of mask row centroids from image center (0=centered)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 50)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    center_x = (w - 1) / 2.0\n    offsets = []\n    for y in range(h):\n        row = mask[y, :]\n        if np.any(row):\n            xs = np.where(row)[0].astype(float)\n            cx = float(np.mean(xs))\n            offsets.append(abs((cx - center_x) / max(1.0, w / 2.0)))\n    if len(offsets) == 0:\n        return 0.0\n    mean_offset = float(np.mean(offsets))\n    # clamp to [0,1]\n    mean_offset = max(0.0, min(1.0, mean_offset))\n    return float(mean_offset)\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Fraction of foreground area that lies in the bottom band of the image (bottom 15%)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    total = np.count_nonzero(mask)\n    if total == 0:\n        return 0.0\n    band_h = max(1, int(max(1, h * 0.15)))\n    bottom = mask[h - band_h :, :]\n    bottom_count = np.count_nonzero(bottom)\n    return float(bottom_count / float(total))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Bounding-box height-to-width aspect ratio of the main object (larger for coats/pullovers)'\n    import numpy as np\n    gray = np.mean(image, axis=2) if len(image.shape) == 3 else image.astype(float)\n    h, w = gray.shape[:2]\n    if np.all(gray == 0):\n        return 0.0\n    th = np.percentile(gray, 70)\n    mask = gray > th\n    rows = np.where(mask.any(axis=1))[0]\n    cols = np.where(mask.any(axis=0))[0]\n    if rows.size == 0 or cols.size == 0:\n        return 0.0\n    bbox_h = rows.max() - rows.min() + 1\n    bbox_w = cols.max() - cols.min() + 1\n    return float(bbox_h / max(1, bbox_w))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Count of prominent vertical peaks in the vertical profile (number of wide regions along height)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = gray < thr if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else gray > thr\n    row_widths = np.sum(mask, axis=1).astype(float)\n    if row_widths.size == 0:\n        return 0.0\n    maxw = np.max(row_widths)\n    if maxw <= 1e-8:\n        return 0.0\n    peak_thr = max(1.0, 0.5 * maxw)\n    above = row_widths >= peak_thr\n    # Count rising edges (0->1)\n    diffs = np.diff(above.astype(int))\n    peaks = int(np.sum(diffs == 1))\n    # if starts above threshold, count that as a peak\n    if above.size > 0 and above[0]:\n        peaks += 1\n    return float(peaks)\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Fraction of image area covered by mask (global mask area / image area)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    area_img = float(max(1, h * w))\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask_dark = gray < thr\n    mask_bright = gray > thr\n    mask = mask_dark if np.count_nonzero(mask_dark) >= np.count_nonzero(mask_bright) else mask_bright\n    mask_area = float(np.count_nonzero(mask))\n    return float(mask_area / area_img)\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Fill ratio: fraction of mask pixels inside its bounding box (object solidity-like)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    thr = float(np.percentile(gray, 50))\n    mask = gray > thr\n    if not np.any(mask):\n        return 0.0\n    rows = np.any(mask, axis=1)\n    cols = np.any(mask, axis=0)\n    rmin, rmax = int(np.argmax(rows)), len(rows) - int(np.argmax(rows[::-1])) - 1\n    cmin, cmax = int(np.argmax(cols)), len(cols) - int(np.argmax(cols[::-1])) - 1\n    if rmax < rmin or cmax < cmin:\n        return 0.0\n    bbox = mask[rmin:rmax+1, cmin:cmax+1]\n    area = float(np.sum(bbox))\n    bbox_area = float(bbox.size)\n    return float(area / (bbox_area + 1e-9))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Maximum continuous horizontal run of object pixels within the bottom 25% of rows normalized by image width'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    h, w = gray.shape[:2]\n    mn, mx = float(gray.min()), float(gray.max())\n    rng = mx - mn + 1e-9\n    norm = (gray - mn) / rng\n    thr = np.percentile(norm, 60)\n    mask = mask = norm > thr\n    if mask.sum() == 0:\n        return 0.0\n    start_row = max(0, int(np.floor(0.75 * h)))\n    bottom_slice = mask[start_row:, :]\n    max_run = 0\n    # for each row compute longest run\n    for row in bottom_slice:\n        # find runs of True\n        run = 0\n        row_max = 0\n        for v in row:\n            if v:\n                run += 1\n            else:\n                if run > row_max:\n                    row_max = run\n                run = 0\n        if run > row_max:\n            row_max = run\n        if row_max > max_run:\n            max_run = row_max\n    return float(max_run / max(1, w))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Fraction of detected foreground mass located in the top 30% of image rows'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    # grayscale conversion\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 50)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    total = float(np.count_nonzero(mask))\n    if total == 0.0:\n        return 0.0\n    cut = max(1, int(0.3 * h))\n    top_mass = float(np.count_nonzero(mask[:cut, :]))\n    return float(top_mass / total)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Approximate fill fraction: object area divided by its bounding-box area (higher for bags)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    thresh = np.mean(gray) + 0.1 * np.std(gray)\n    mask = gray > thresh\n    if not mask.any():\n        return 0.0\n    rows, cols = np.where(mask)\n    minr, maxr = rows.min(), rows.max()\n    minc, maxc = cols.min(), cols.max()\n    bbox_area = max(1, (maxr - minr + 1) * (maxc - minc + 1))\n    area = mask.sum()\n    return float(area / bbox_area)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Approximate solidity: largest component area divided by its bounding-box area'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 50)\n    mask = ((gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)).astype(bool)\n    visited = np.zeros_like(mask, dtype=bool)\n    max_area = 0\n    max_bbox_area = 1\n    for y in range(h):\n        for x in range(w):\n            if mask[y, x] and not visited[y, x]:\n                # flood fill\n                stack = [(y, x)]\n                visited[y, x] = True\n                area = 0\n                miny, maxy = y, y\n                minx, maxx = x, x\n                while stack:\n                    yy, xx = stack.pop()\n                    area += 1\n                    if yy < miny: miny = yy\n                    if yy > maxy: maxy = yy\n                    if xx < minx: minx = xx\n                    if xx > maxx: maxx = xx\n                    if yy > 0 and mask[yy - 1, xx] and not visited[yy - 1, xx]:\n                        visited[yy - 1, xx] = True\n                        stack.append((yy - 1, xx))\n                    if yy + 1 < h and mask[yy + 1, xx] and not visited[yy + 1, xx]:\n                        visited[yy + 1, xx] = True\n                        stack.append((yy + 1, xx))\n                    if xx > 0 and mask[yy, xx - 1] and not visited[yy, xx - 1]:\n                        visited[yy, xx - 1] = True\n                        stack.append((yy, xx - 1))\n                    if xx + 1 < w and mask[yy, xx + 1] and not visited[yy, xx + 1]:\n                        visited[yy, xx + 1] = True\n                        stack.append((yy, xx + 1))\n                bbox_area = (maxy - miny + 1) * (maxx - minx + 1)\n                if area > max_area:\n                    max_area = area\n                    max_bbox_area = max(1, bbox_area)\n    if max_area == 0:\n        return 0.0\n    return float(max_area / float(max_bbox_area))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Depth of top-center concavity: difference between side top and center top normalized by height'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    rng = float(np.max(gray) - np.min(gray)) if np.max(gray) != np.min(gray) else 1.0\n    thr = float(np.mean(gray) + 0.10 * rng)\n    mask = gray > thr\n    if np.count_nonzero(mask) == 0:\n        thr = float(np.percentile(gray, 50))\n        mask = gray > thr\n    if np.count_nonzero(mask) == 0:\n        return 0.0\n    # topmost object row per column (inf if no pixel)\n    top_rows = np.where(np.any(mask, axis=0), np.argmax(mask, axis=0), h)\n    # center third vs side thirds\n    c1 = w // 3\n    c2 = 2 * w // 3\n    side_mean = float(np.mean(np.minimum(top_rows[:c1], h)))\n    side_mean2 = float(np.mean(np.minimum(top_rows[c2:], h)))\n    side_avg = float((side_mean + side_mean2) / 2.0)\n    center_min = float(np.min(top_rows[c1:c2])) if c2 > c1 else float(np.min(top_rows))\n    depth = max(0.0, side_avg - center_min)\n    return float(depth / max(h - 1, 1))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Width of the central background gap in the top region (normalized) \u2014 captures necklines or top openings'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(np.float32)\n    else:\n        gray = image.astype(np.float32)\n    h, w = gray.shape[:2]\n    if h < 5 or w < 5:\n        return 0.0\n    mn, mx = np.min(gray), np.max(gray)\n    if mx - mn < 1e-6:\n        binary = gray > mx * 0.5\n    else:\n        thr = float(np.percentile(gray, 50))\n        binary = gray > thr\n    top_h = max(1, h // 5)\n    top_region = binary[0:top_h, :]\n    # compute fraction of object presence per column in top region\n    proj = np.mean(top_region.astype(np.float32), axis=0)\n    bg_frac = 1.0 - proj\n    center = w // 2\n    # expand from center while background fraction is dominant (>0.5)\n    left = center\n    while left > 0 and bg_frac[left] > 0.5:\n        left -= 1\n    right = center\n    while right < w - 1 and bg_frac[right] > 0.5:\n        right += 1\n    width = right - left + 1\n    return float(max(0.0, min(1.0, width / float(w))))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Fraction of empty (background) columns in the top 20% rows within the object horizontal span (identifies open tops/straps)'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    h, w = gray.shape[:2]\n    thr = np.percentile(gray, 50)\n    mask = gray > thr\n    if mask.sum() > 0.6 * h * w:\n        mask = ~mask\n    if mask.sum() == 0:\n        return 0.0\n    # bounding horizontal span of object\n    cols = np.any(mask, axis=0)\n    if not cols.any():\n        return 0.0\n    left = int(np.argmax(cols))\n    right = int(w - np.argmax(cols[::-1]))\n    top_h = max(1, int(h * 0.2))\n    top_region = mask[0:top_h, left:right]\n    # count columns in top region that are entirely background\n    empty_cols = 0\n    for c in range(top_region.shape[1]):\n        if not top_region[:, c].any():\n            empty_cols += 1\n    return float(empty_cols / max(1, top_region.shape[1]))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Length of top empty run in central columns (normalized by height) indicating neckline/opening'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h <= 1 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 50)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    c0 = max(0, int(w * 0.4))\n    c1 = min(w, int(w * 0.6) + 1)\n    center_cols = mask[:, c0:c1] if c1 > c0 else mask\n    if center_cols.size == 0:\n        return 0.0\n    # find number of rows from top that are fully empty in the center region\n    emptiness_per_row = np.all(center_cols == 0, axis=1)\n    # count consecutive True from top\n    top_empty = 0\n    for val in emptiness_per_row:\n        if val:\n            top_empty += 1\n        else:\n            break\n    return float(top_empty / float(h))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Relative prominence of protrusions in the top quarter (mean of top-row widths / mean middle-row widths)'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    if h < 4:\n        return 0.0\n    m = np.mean(gray)\n    mask = (gray < m)\n    if np.count_nonzero(mask) < (h * w / 10):\n        mask = (gray > m)\n    if np.count_nonzero(mask) == 0:\n        return 0.0\n    # compute width per row\n    widths = np.sum(mask, axis=1)\n    top_rows = widths[:max(1, h//4)]\n    mid_start, mid_end = h//3, 2*h//3\n    mid_rows = widths[mid_start:mid_end] if mid_end > mid_start else widths[top_rows.size:top_rows.size+1]\n    mean_top = np.mean(top_rows) if top_rows.size>0 else 0.0\n    mean_mid = np.mean(mid_rows) if mid_rows.size>0 else 0.0\n    return float((mean_top + 1e-8) / (mean_mid + 1e-8))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Compactness (4*pi*area / perimeter^2) of the mask, higher is more compact'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    area = float(np.count_nonzero(mask))\n    if area == 0.0:\n        return 0.0\n    # estimate perimeter by counting boundary pixels (4-neighbor)\n    pad = np.pad(mask.astype(np.uint8), ((1, 1), (1, 1)), mode='constant', constant_values=0)\n    center = pad[1:-1, 1:-1].astype(bool)\n    up = pad[:-2, 1:-1].astype(bool)\n    down = pad[2:, 1:-1].astype(bool)\n    left = pad[1:-1, :-2].astype(bool)\n    right = pad[1:-1, 2:].astype(bool)\n    neighbor_sum = up + down + left + right\n    boundary = center & (neighbor_sum < 4)\n    perimeter = float(np.count_nonzero(boundary))\n    if perimeter <= 1e-8:\n        return 0.0\n    compact = (4.0 * np.pi * area) / (perimeter * perimeter + 1e-8)\n    return float(compact)\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Fractional solidity of top-center small box vs average of top-side boxes (positive if center more filled)'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    thr = np.mean(gray) + 0.45 * np.std(gray)\n    mask = gray > thr\n    if mask.sum() == 0:\n        mask = gray > np.percentile(gray.flatten(), 88)\n    if mask.sum() == 0:\n        if gray.max() == 0:\n            return 0.0\n        mask = gray > (0.12 * gray.max())\n    box_h = max(1, int(h * 0.12))\n    box_w = max(1, int(w * 0.20))\n    cy = max(0, int(h * 0.08))\n    cx = w // 2\n    # center box\n    c0r, c1r = cy, min(h, cy + box_h)\n    c0c, c1c = max(0, cx - box_w // 2), min(w, cx + (box_w - box_w // 2))\n    center_fill = mask[c0r:c1r, c0c:c1c].sum() / float(max(1, (c1r - c0r) * (c1c - c0c)))\n    # left box\n    l0c, l1c = max(0, cx - int(1.5 * box_w)), max(0, cx - int(0.5 * box_w))\n    left_fill = mask[c0r:c1r, l0c:l1c].sum() / float(max(1, (c1r - c0r) * max(1, (l1c - l0c))))\n    # right box\n    r0c, r1c = min(w, cx + int(0.5 * box_w)), min(w, cx + int(1.5 * box_w))\n    right_fill = mask[c0r:c1r, r0c:r1c].sum() / float(max(1, (c1r - c0r) * max(1, (r1c - r0c))))\n    side_avg = float((left_fill + right_fill) / 2.0)\n    return float(center_fill - side_avg)\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Fraction of empty columns in the central vertical strip (higher => vertical gap between parts)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    c0 = max(0, w // 4)\n    c1 = min(w, 3 * w // 4)\n    if c1 <= c0:\n        return 0.0\n    center = mask[:, c0:c1]\n    empty_cols = np.sum(np.all(center == 0, axis=0))\n    return float(empty_cols) / float((c1 - c0))\n",
    "def feature(image: np.ndarray) -> float:\n    'Approximate mean color saturation inside the mask (0..1), 0 for grayscale images'\n    import numpy as np\n    if image is None:\n        return 0.0\n    if len(image.shape) != 3:\n        return 0.0\n    h, w, c = image.shape\n    if h == 0 or w == 0 or c < 3:\n        return 0.0\n    rgb = image.astype(float)\n    # approximate saturation by (max-min)/(max+eps) per pixel\n    mx = np.max(rgb, axis=2)\n    mn = np.min(rgb, axis=2)\n    sat = (mx - mn) / (mx + 1e-8)\n    gray = np.mean(rgb, axis=2)\n    thr = np.percentile(gray, 50)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    if not np.any(mask):\n        return 0.0\n    mean_sat = float(np.mean(sat[mask]))\n    return float(np.clip(mean_sat, 0.0, 1.0))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Mean Euclidean distance of foreground pixels to image center normalized to [0,1]'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    cy, cx = (h - 1) / 2.0, (w - 1) / 2.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 50)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    ys, xs = np.where(mask)\n    if ys.size == 0:\n        return 0.0\n    dists = np.sqrt((ys - cy) ** 2 + (xs - cx) ** 2)\n    mean_dist = float(np.mean(dists))\n    max_possible = np.sqrt(cx ** 2 + cy ** 2) + 1e-8\n    return float(mean_dist / max_possible)\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Vertical symmetry score: mean abs difference between top and vertically flipped bottom (normalized)'\n    import numpy as np\n    if image is None:\n        return 1.0\n    h, w = image.shape[:2]\n    if h < 2 or w == 0:\n        return 1.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    mid = h // 2\n    top = gray[:mid, :]\n    bot = gray[h - mid:, :]\n    if top.size == 0 or bot.size == 0:\n        return 1.0\n    bot_flipped = np.flipud(bot)\n    if top.shape != bot_flipped.shape:\n        mh = min(top.shape[0], bot_flipped.shape[0])\n        top = top[:mh, :]\n        bot_flipped = bot_flipped[:mh, :]\n    diff = np.abs(top - bot_flipped)\n    denom = np.maximum(np.mean(gray) + 1e-8, 1e-8)\n    return float(np.mean(diff) / denom)\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'RGB colorfulness: normalized sum of channel std deviations (0 for grayscale)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    if len(image.shape) != 3 or image.shape[2] < 3:\n        return 0.0\n    h, w, c = image.shape\n    if h == 0 or w == 0:\n        return 0.0\n    chans_std = np.std(image.astype(float).reshape(-1, c), axis=0)\n    mean_intensity = float(np.mean(image))\n    denom = mean_intensity + 1e-8\n    score = float(np.sum(chans_std) / denom)\n    return float(score)\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Ratio of top 10% width to bottom 10% width of the object (top_width / bottom_width)'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    mask = None\n    for p in (60, 50, 40, 30):\n        thresh = float(np.percentile(gray, p))\n        m = gray > thresh\n        if 0 < np.count_nonzero(m) < h * w:\n            mask = m\n            break\n    if mask is None:\n        mask = gray > np.mean(gray)\n    if np.count_nonzero(mask) == 0:\n        return 0.0\n    ys = np.where(np.any(mask, axis=1))[0]\n    if ys.size == 0:\n        return 0.0\n    top, bottom = ys[0], ys[-1]\n    bbox_h = bottom - top + 1\n    band_h = max(1, int(np.ceil(0.10 * bbox_h)))\n    top_rows = slice(top, min(top + band_h, bottom + 1))\n    bottom_rows = slice(max(top, bottom - band_h + 1), bottom + 1)\n    top_width = float(np.max(np.sum(mask[top_rows, :], axis=1))) if np.any(mask[top_rows, :]) else 0.0\n    bottom_width = float(np.max(np.sum(mask[bottom_rows, :], axis=1))) if np.any(mask[bottom_rows, :]) else 0.0\n    return float((top_width / (bottom_width + 1e-6)))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Horizontal centroid offset within bounding box (abs distance from center). Shoes often centered; bags may be off-center'\n    import numpy as np\n    if image is None:\n        return 0.0\n    gray = np.mean(image, axis=2) if len(image.shape) == 3 else image.astype(np.float32)\n    if np.nanstd(gray) == 0 and np.max(gray) == 0:\n        return 0.0\n    thresh = np.percentile(gray, 70)\n    mask = gray > thresh\n    ys, xs = np.where(mask)\n    if xs.size == 0:\n        return 0.0\n    c0, c1 = xs.min(), xs.max()\n    bbox_w = max(1, c1 - c0 + 1)\n    centroid_x = xs.mean()\n    result = float(abs((centroid_x - c0) / bbox_w - 0.5))\n    return result\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Upper-vs-lower vertical edge ratio: mean vertical gradient magnitude in upper half divided by lower half (captures shoulder/neck edges)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    if h < 2 or w < 2:\n        return 0.0\n    grayf = gray.astype(float)\n    gy, gx = np.gradient(grayf)\n    vert_mag = np.abs(gy)\n    upper = vert_mag[:h//2, :]\n    lower = vert_mag[h//2:, :]\n    up_mean = np.mean(upper) if upper.size > 0 else 0.0\n    low_mean = np.mean(lower) if lower.size > 0 else 0.0\n    ratio = up_mean / (low_mean + 1e-9)\n    return float(ratio)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Absolute hem slope: normalized difference between mean bottommost object row in left and right halves (0=perfectly level)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    mn, mx = float(np.min(gray)), float(np.max(gray))\n    if mx == mn:\n        return 0.0\n    thr = (mn + mx) / 2.0\n    bw = gray > thr\n    if not np.any(bw):\n        return 0.0\n    h, w = bw.shape\n    mid = w // 2\n    left = bw[:, :mid]\n    right = bw[:, mid:]\n    def mean_bottom_row(col_slice):\n        # for each column find bottommost True; compute mean row index\n        cols = col_slice.shape[1]\n        if cols == 0:\n            return float(h)\n        bottoms = []\n        for ci in range(cols):\n            col = col_slice[:, ci]\n            ys = np.where(col)[0]\n            if ys.size:\n                bottoms.append(float(ys.max()))\n            else:\n                bottoms.append(float(h))\n        return float(np.mean(bottoms))\n    l_bot = mean_bottom_row(left)\n    r_bot = mean_bottom_row(right)\n    # normalize by height\n    return float(abs(l_bot - r_bot) / max(1.0, float(h)))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Ratio of mean intensity in the top quarter of the mask to the bottom quarter (top/bottom)'\n    import numpy as np\n    if image is None:\n        return 1.0\n    h, w = image.shape[:2]\n    if h < 4:\n        return 1.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 50)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    ys = np.where(mask)[0]\n    if ys.size == 0:\n        return 1.0\n    top_row = 0\n    bottom_row = h - 1\n    top_band_end = min(h, int(round(h * 0.25)))\n    bottom_band_start = max(0, h - int(round(h * 0.25)))\n    top_mask = mask[top_row:top_band_end, :]\n    bottom_mask = mask[bottom_band_start:bottom_row + 1, :]\n    if np.count_nonzero(top_mask) == 0 or np.count_nonzero(bottom_mask) == 0:\n        return 1.0\n    top_mean = np.mean(gray[top_row:top_band_end, :][top_mask])\n    bottom_mean = np.mean(gray[bottom_band_start:bottom_row + 1, :][bottom_mask])\n    return float((top_mean + 1e-8) / (bottom_mean + 1e-8))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Bottom edge flatness: 1.0 is perfectly flat horizontal bottom, lower values indicate jagged or curved hem'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(np.float32)\n    else:\n        gray = image.astype(np.float32)\n    h, w = gray.shape[:2]\n    gmin, gmax, gmean = float(np.min(gray)), float(np.max(gray)), float(np.mean(gray))\n    thr = gmean + 0.15 * (gmax - gmean)\n    mask = gray > thr\n    if np.count_nonzero(mask) < 6:\n        thr = float(np.percentile(gray, 50)); mask = gray > thr\n    if np.count_nonzero(mask) == 0:\n        return 0.0\n    rows, cols = np.where(mask)\n    r0, r1 = rows.min(), rows.max()\n    c0, c1 = cols.min(), cols.max()\n    bottom_positions = []\n    for c in range(c0, c1 + 1):\n        col_rows = np.where(mask[:, c])[0]\n        if col_rows.size:\n            bottom_positions.append(int(col_rows.max()))\n    if len(bottom_positions) == 0:\n        return 0.0\n    std_pos = float(np.std(bottom_positions))\n    norm = std_pos / max(1.0, (r1 - r0 + 1))\n    flatness = 1.0 - min(1.0, norm)  # 1 = flat, 0 = very uneven\n    return float(flatness)\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Mean width of object segments per row (normalized by image width): silhouette slenderness'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = gray < thr if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else gray > thr\n    widths = []\n    for r in range(h):\n        row = mask[r, :].astype(int)\n        if np.any(row):\n            pad = np.concatenate(([0], row, [0]))\n            diff = np.diff(pad)\n            starts = np.where(diff == 1)[0]\n            ends = np.where(diff == -1)[0]\n            seg_lengths = ends - starts\n            if seg_lengths.size > 0:\n                widths.append(np.mean(seg_lengths))\n    if len(widths) == 0:\n        return 0.0\n    mean_width = float(np.mean(widths))\n    return float(mean_width / max(1.0, float(w)))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Perimeter-to-area ratio estimated from the object mask (high for thin/strap-like objects such as sandals)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    thr = (np.max(gray) + np.min(gray)) / 2.0\n    mask = gray > thr\n    if mask.sum() == 0:\n        thr = np.mean(gray)\n        mask = gray > thr\n    area = np.count_nonzero(mask)\n    if area == 0:\n        return 0.0\n    # perimeter estimate: count mask pixels that have any 4-neighbor background\n    padded = np.pad(mask.astype(np.uint8), pad_width=1, mode='constant', constant_values=0)\n    perim = 0\n    # shifts\n    up = padded[:-2,1:-1]\n    down = padded[2:,1:-1]\n    left = padded[1:-1,:-2]\n    right = padded[1:-1,2:]\n    center = padded[1:-1,1:-1]\n    # a center pixel contributes to perimeter if any neighbor is 0\n    neighbors_and = up & down & left & right\n    # perimeter pixels are center pixels where neighbors_and is False but center is True\n    perim_mask = (center.astype(bool)) & (~neighbors_and.astype(bool))\n    perim = np.count_nonzero(perim_mask)\n    return float(perim / float(area))\n",
    "def feature(image: np.ndarray) -> float:\n    'Fill ratio of the object within its bounding box: object_area / (bbox_height*bbox_width) (compactness measure)'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    thr = (np.max(gray) + np.mean(gray)) / 2.0\n    mask = gray > thr\n    if np.count_nonzero(mask) == 0:\n        mask = gray > np.mean(gray)\n        if np.count_nonzero(mask) == 0:\n            return 0.0\n    ys, xs = np.where(mask)\n    y0, y1 = ys.min(), ys.max()\n    x0, x1 = xs.min(), xs.max()\n    bbox_area = float(max(1, (y1 - y0 + 1)) * max(1, (x1 - x0 + 1)))\n    object_area = float(np.count_nonzero(mask))\n    return float(object_area / bbox_area)\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Mean inter-channel standard deviation normalized by mean intensity (0 for grayscale)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    if len(image.shape) != 3 or image.shape[2] < 3:\n        return 0.0\n    # for RGB images compute per-pixel std across channels then average\n    img = image.astype(float)\n    per_pixel_std = np.std(img, axis=2)\n    mean_std = float(np.mean(per_pixel_std))\n    mean_intensity = float(np.mean(np.mean(img, axis=2)))\n    return float(mean_std / (mean_intensity + 1e-8))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Fraction of strong edges that are diagonal (near 45 degrees)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 2 or w < 2:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    gy, gx = np.gradient(gray.astype(float))\n    mag = np.sqrt(gx * gx + gy * gy)\n    if not np.any(mag):\n        return 0.0\n    thresh = np.percentile(mag, 70)\n    strong = mag > thresh\n    if not np.any(strong):\n        return 0.0\n    # diagonal if abs(|gx|-|gy|) small relative to max\n    diff = np.abs(np.abs(gx) - np.abs(gy))\n    denom = np.maximum(np.abs(gx) + np.abs(gy), 1e-8)\n    diag = (diff / denom) < 0.25\n    count_diag = np.count_nonzero(strong & diag)\n    total = np.count_nonzero(strong)\n    return float(count_diag / (total + 1e-8))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Compactness estimate: area / (perimeter^2) for the foreground mask'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    area = float(np.count_nonzero(mask))\n    if area == 0.0:\n        return 0.0\n    # vertical transitions\n    vert = 0\n    if h > 1:\n        vert = np.count_nonzero(mask[:-1, :] != mask[1:, :])\n    # horizontal transitions\n    hor = 0\n    if w > 1:\n        hor = np.count_nonzero(mask[:, :-1] != mask[:, 1:])\n    perimeter = float(vert + hor)\n    if perimeter <= 1e-8:\n        return float(area)  # very compact (or single pixel)\n    compact = area / ((perimeter + 1e-8) ** 2)\n    return float(compact)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Fractional horizontal span occupied in the top quarter of the object bounding box (shoulder width indicator)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    mx = float(np.max(gray))\n    thr = max(0.45 * float(np.mean(gray)), 0.15 * mx)\n    mask = gray > thr\n    coords = np.argwhere(mask)\n    if coords.size == 0:\n        return 0.0\n    ys = coords[:, 0]; xs = coords[:, 1]\n    miny, maxy = ys.min(), ys.max()\n    minx, maxx = xs.min(), xs.max()\n    h = maxy - miny + 1\n    top_q_end = int(miny + max(1, h // 4))\n    top_coords = coords[coords[:, 0] <= top_q_end]\n    if top_coords.size == 0:\n        return 0.0\n    top_minx, top_maxx = top_coords[:, 1].min(), top_coords[:, 1].max()\n    bbox_width = maxx - minx + 1\n    if bbox_width <= 0:\n        return 0.0\n    span = (top_maxx - top_minx + 1) / float(bbox_width)\n    return float(span)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Principal axis orientation of foreground normalized (1.0 = vertical, 0.0 = horizontal)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 2 or w < 2:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    ys, xs = np.where(mask)\n    if ys.size < 2:\n        return 0.0\n    cx = np.mean(xs)\n    cy = np.mean(ys)\n    X = np.vstack([(xs - cx), (ys - cy)])\n    cov = np.cov(X)\n    # guard numerical issues\n    try:\n        vals, vecs = np.linalg.eigh(cov)\n    except Exception:\n        return 0.0\n    # largest eigenvector\n    idx = np.argmax(vals)\n    vx, vy = vecs[:, idx]\n    angle = abs(np.arctan2(vy, vx))\n    # map to [0, pi/2]\n    angle = min(angle, np.pi - angle)\n    score = angle / (np.pi / 2.0)\n    return float(score)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Vertical extent ratio: height of object bounding box divided by image height (pullover larger, sandals smaller)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    h, w = gray.shape[:2]\n    # threshold using percentile to be robust\n    p = np.percentile(gray, 60)\n    mask = gray > p\n    if not np.any(mask):\n        # fallback to any nonzero pixels\n        mask = gray > 0\n    if not np.any(mask):\n        return 0.0\n    rows = np.any(mask, axis=1)\n    cols = np.any(mask, axis=0)\n    rmin = int(np.argmax(rows))\n    rmax = h - int(np.argmax(rows[::-1])) - 1\n    bbox_height = max(0, rmax - rmin + 1)\n    return float(bbox_height / max(1, h))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Perimeter-to-area ratio of the mask (higher => more complex/elongated boundary)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 2 or w < 2:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = gray < thr if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else gray > thr\n    area = float(np.count_nonzero(mask))\n    if area <= 0:\n        return 0.0\n    # erosion via neighbor AND (same as other features)\n    eroded = mask.copy()\n    for dr in (-1, 0, 1):\n        for dc in (-1, 0, 1):\n            if dr == 0 and dc == 0:\n                continue\n            rolled = np.roll(mask, shift=(dr, dc), axis=(0, 1))\n            if dr == -1:\n                rolled[-1, :] = False\n            if dr == 1:\n                rolled[0, :] = False\n            if dc == -1:\n                rolled[:, -1] = False\n            if dc == 1:\n                rolled[:, 0] = False\n            eroded &= rolled\n    boundary = mask & (~eroded)\n    perim = float(np.count_nonzero(boundary))\n    return float(perim / (area + 1e-8))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Mask fill ratio: fraction of bounding-box area occupied by mask (0..1)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    ys, xs = np.where(mask)\n    if ys.size == 0:\n        return 0.0\n    miny, maxy = ys.min(), ys.max()\n    minx, maxx = xs.min(), xs.max()\n    bbox_area = float((maxy - miny + 1) * (maxx - minx + 1))\n    mask_area = float(np.count_nonzero(mask))\n    if bbox_area <= 0:\n        return 0.0\n    return float(mask_area / (bbox_area + 1e-8))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Ratio of vertical edge energy to horizontal edge energy (higher => more vertical structure)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 2 or w < 2:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    # normalize\n    mx = np.max(gray)\n    if mx > 0:\n        gray = gray / mx\n    gy, gx = np.gradient(gray)\n    vert_energy = np.sum(np.abs(gx))\n    horz_energy = np.sum(np.abs(gy))\n    return float(vert_energy / (horz_energy + 1e-8))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Normalized top-versus-bottom mean intensity difference (top - bottom)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 2 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    t = max(1, h * 25 // 100)\n    top_mean = float(np.mean(gray[:t, :])) if t > 0 else 0.0\n    bottom_mean = float(np.mean(gray[-t:, :])) if t > 0 else 0.0\n    denom = (np.std(gray) + 1e-8)\n    diff = (top_mean - bottom_mean) / denom\n    return float(diff)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Absolute left-vs-right object pixel imbalance normalized by total (0 = perfectly symmetric, 1 = all on one side)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(np.float32)\n    else:\n        gray = image.astype(np.float32)\n    h, w = gray.shape[:2]\n    mn, mx = np.min(gray), np.max(gray)\n    if mx - mn < 1e-6:\n        binary = gray > mx * 0.5\n    else:\n        thr = float(np.percentile(gray, 50))\n        binary = gray > thr\n    left_sum = float(np.count_nonzero(binary[:, :w//2]))\n    right_sum = float(np.count_nonzero(binary[:, w//2:]))\n    total = left_sum + right_sum\n    if total <= 0.0:\n        return 0.0\n    return float(abs(left_sum - right_sum) / total)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Compactness: ratio of object pixel count to its bounding-box area (dense garment vs sparse / open coat)'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    h, w = gray.shape\n    if h == 0 or w == 0:\n        return 0.0\n    mx = float(np.max(gray))\n    thr = float(np.mean(gray)) + 0.08 * (mx - float(np.mean(gray)))\n    mask = gray > thr\n    if np.count_nonzero(mask) == 0:\n        mask = gray > float(np.mean(gray))\n    nz = np.where(mask)\n    if nz[0].size == 0:\n        return 0.0\n    r0, r1 = int(nz[0].min()), int(nz[0].max())\n    c0, c1 = int(nz[1].min()), int(nz[1].max())\n    bbox_area = float((r1 - r0 + 1) * (c1 - c0 + 1))\n    if bbox_area <= 0.0:\n        return 0.0\n    pixel_count = float(np.count_nonzero(mask))\n    return pixel_count / bbox_area\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Contrast of a narrow center-top region (possible collar) vs its side neighborhoods (positive if center brighter)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    gray = np.mean(image, axis=2) if image.ndim == 3 else image.astype(float)\n    h, w = gray.shape[:2]\n    center_col = w // 2\n    band_h = max(1, int(0.12 * h))\n    band_w = max(1, int(0.24 * w))\n    top = 0\n    center_box = gray[top:top + band_h, max(0, center_col - band_w//2):min(w, center_col + band_w//2)]\n    left_box = gray[top:top + band_h, max(0, center_col - band_w - band_w//2):max(0, center_col - band_w//2)]\n    right_box = gray[top:top + band_h, min(w, center_col + band_w//2):min(w, center_col + band_w + band_w//2)]\n    def safe_mean(a):\n        return float(np.mean(a)) if a.size else 0.0\n    center_mean = safe_mean(center_box)\n    side_mean = 0.5 * (safe_mean(left_box) + safe_mean(right_box)) if (left_box.size or right_box.size) else safe_mean(center_box)\n    return float(center_mean - side_mean)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Upper-third neck indentation score: 1 - (min width / max width) in upper third (larger => deeper neck cut)'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    thr = (np.mean(gray) + np.median(gray)) / 2.0\n    mask = gray > thr\n    if np.count_nonzero(mask) == 0:\n        return 0.0\n    if np.count_nonzero(mask) > 0.9 * h * w:\n        mask = ~mask\n    upper_h = max(1, h // 3)\n    widths = []\n    for row in mask[:upper_h, :]:\n        idx = np.where(row)[0]\n        if idx.size:\n            widths.append(idx[-1] - idx[0] + 1)\n    if not widths:\n        return 0.0\n    minw = float(np.min(widths))\n    maxw = float(np.max(widths)) if np.max(widths) > 0 else 1.0\n    return float(1.0 - (minw / maxw))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Ratio of strong-edge density in top third vs bottom third (useful for tops vs shoes)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 3 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    gy, gx = np.gradient(gray.astype(float))\n    grad = np.sqrt(gx * gx + gy * gy)\n    thr = np.percentile(grad, 65) if np.any(grad) else 0.0\n    edges = grad > thr\n    top_h = h // 3\n    top_edges = np.count_nonzero(edges[:top_h, :])\n    bottom_edges = np.count_nonzero(edges[-top_h:, :])\n    top_pixels = float(top_h * w)\n    bottom_pixels = float(top_h * w)\n    top_density = float(top_edges) / (top_pixels + 1e-8)\n    bottom_density = float(bottom_edges) / (bottom_pixels + 1e-8)\n    return float(top_density / (bottom_density + 1e-8))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Normalized offset (0..~1) of intensity centroid (weighted toward darker pixels) from image center'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    # weight darker pixels more (assume object may be darker); shift to [0,1]\n    gmin, gmax = np.min(gray), np.max(gray)\n    rng = gmax - gmin\n    if rng <= 0:\n        return 0.0\n    norm = (gray - gmin) / rng\n    weights = 1.0 - norm\n    total = np.sum(weights)\n    if total <= 0:\n        return 0.0\n    ys = np.arange(h).reshape(h, 1)\n    xs = np.arange(w).reshape(1, w)\n    cx = float(np.sum(weights * xs) / total)\n    cy = float(np.sum(weights * ys) / total)\n    # geometric center\n    gx_center = (w - 1) / 2.0\n    gy_center = (h - 1) / 2.0\n    dx = (cx - gx_center) / max(1.0, w / 2.0)\n    dy = (cy - gy_center) / max(1.0, h / 2.0)\n    dist = np.sqrt(dx * dx + dy * dy)\n    return float(dist)\n",
    "def feature(image: np.ndarray) -> float:\n    'Normalized contrast between object interior and background (mask contrast)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    inside = gray[mask]\n    outside = gray[~mask]\n    if inside.size == 0 or outside.size == 0:\n        return 0.0\n    contrast = np.abs(np.mean(outside) - np.mean(inside))\n    denom = np.maximum(np.mean(gray) + 1e-8, 1e-8)\n    return float(contrast / denom)\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Fraction of mask pixels located in the bottom third of the image'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    total = np.count_nonzero(mask)\n    if total == 0:\n        return 0.0\n    start = (2 * h) // 3\n    bottom_mask = mask[start:, :]\n    bottom_count = np.count_nonzero(bottom_mask)\n    return float(bottom_count / (total + 1e-8))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Absolute left-right mask area imbalance (0 = balanced, 1 = all on one side)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 50)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    if not np.any(mask):\n        return 0.0\n    mid = w // 2\n    left_area = float(np.count_nonzero(mask[:, :mid]))\n    right_area = float(np.count_nonzero(mask[:, mid:]))\n    total = left_area + right_area + 1e-8\n    imbalance = abs(left_area - right_area) / total\n    return float(np.clip(imbalance, 0.0, 1.0))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Number of contiguous horizontal mask segments in upper 40% (useful for sleeves) normalized'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    top_h = max(1, (40 * h) // 100)\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask_top = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    mask_top = mask_top[:top_h, :]\n    col_any = np.any(mask_top, axis=0).astype(int)\n    if col_any.size == 0:\n        return 0.0\n    # count rises from 0 to 1\n    transitions = np.sum((col_any[1:] == 1) & (col_any[:-1] == 0))\n    # if first column is 1, that starts a segment\n    if col_any[0] == 1:\n        transitions += 1\n    return float(transitions / 10.0)  # scaled down to keep values moderate\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Standard deviation of the bottom contour (bottom-most object row per column) normalized by bbox height (irregular soles have higher values)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if np.nanmax(gray) == np.nanmin(gray):\n        return 0.0\n    thresh = np.mean(gray) * 0.7 + np.min(gray) * 0.3\n    mask = gray > thresh\n    pts = np.argwhere(mask)\n    if pts.size == 0:\n        return 0.0\n    ymin, xmin = pts.min(axis=0)\n    ymax, xmax = pts.max(axis=0)\n    bw = xmax - xmin + 1\n    bh = ymax - ymin + 1\n    if bw <= 1 or bh <= 0:\n        return 0.0\n    bottom = np.full(bw, ymin, dtype=float)\n    for i, c in enumerate(range(xmin, xmax + 1)):\n        rows = np.where(mask[:, c])[0]\n        bottom[i] = rows.max() if rows.size > 0 else ymin\n    std = float(np.std(bottom))\n    return std / float(bh)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Compactness estimate: mask area divided by perimeter (higher means more compact/filled)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    area = float(np.count_nonzero(mask))\n    if area == 0.0:\n        return 0.0\n    # compute perimeter by checking 4-neighborhood with padding\n    pad = np.pad(mask.astype(bool), pad_width=1, mode='constant', constant_values=False)\n    center = pad[1:-1, 1:-1]\n    up = pad[:-2, 1:-1]\n    down = pad[2:, 1:-1]\n    left = pad[1:-1, :-2]\n    right = pad[1:-1, 2:]\n    interior = center & up & down & left & right\n    perimeter_count = float(np.count_nonzero(center & (~interior)))\n    if perimeter_count <= 0.0:\n        return float(area)\n    return float(area / (perimeter_count + 1e-8))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Collar presence score: darkness contrast in a small top-center patch vs adjacent band (higher indicates a likely collar)'\n    import numpy as np\n    gray = np.mean(image, axis=2) if len(image.shape) == 3 else image.astype(float)\n    h, w = gray.shape[:2]\n    # normalize\n    mn, mx = float(np.min(gray)), float(np.max(gray))\n    if mx > mn:\n        g = (gray - mn) / (mx - mn)\n    else:\n        g = np.zeros_like(gray, dtype=float)\n    # define patches\n    ch = max(1, h // 8)\n    cw = max(1, w // 6)\n    center_col = w // 2\n    top_row = max(0, h // 12)\n    collar_patch = g[top_row:top_row+ch, center_col-cw:center_col+cw]\n    band_patch = g[top_row+ch:top_row+3*ch, center_col-2*cw:center_col+2*cw]\n    if collar_patch.size == 0 or band_patch.size == 0:\n        return 0.0\n    # collar in many clothing items is darker (lower value) than surrounding\n    score = np.mean(band_patch) - np.mean(collar_patch)\n    return float(score)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Normalized mean intensity in a small top-center patch divided by global mean (capturing darker collar/neck regions)'\n    import numpy as np\n    if image is None or image.size == 0:\n        return 0.0\n    gray = np.mean(image, axis=2) if len(image.shape) == 3 else image.astype(float)\n    gray = np.nan_to_num(gray)\n    global_mean = float(np.mean(gray)) if gray.size else 0.0\n    if global_mean == 0:\n        global_mean = 1.0\n    h, w = gray.shape[:2]\n    ph = max(1, h // 6)\n    pw = max(1, w // 3)\n    start_r = max(0, h // 20)\n    start_c = max(0, (w - pw) // 2)\n    patch = gray[start_r:start_r + ph, start_c:start_c + pw]\n    if patch.size == 0:\n        return 1.0\n    patch_mean = float(np.mean(patch))\n    return float(patch_mean / global_mean)\n",
    "def feature(image: np.ndarray) -> float:\n    'Left/right mass ratio (min(left,right)/max(left,right)) normalized to [0,1], 1 = perfectly balanced'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.mean(gray) + 0.2 * (np.max(gray) - np.mean(gray))\n    mask = gray > thr\n    if np.count_nonzero(mask) == 0:\n        mask = gray > np.percentile(gray, 90)\n    if np.count_nonzero(mask) == 0:\n        return 1.0\n    ys, xs = np.where(mask)\n    ymin, ymax = ys.min(), ys.max()\n    xmin, xmax = xs.min(), xs.max()\n    bbox = mask[ymin:ymax+1, xmin:xmax+1].astype(float)\n    w = bbox.shape[1]\n    mid = w // 2\n    left_mass = np.sum(bbox[:, :mid])\n    right_mass = np.sum(bbox[:, mid:])\n    if left_mass + right_mass == 0:\n        return 1.0\n    if left_mass == 0 or right_mass == 0:\n        return 0.0\n    ratio = min(left_mass, right_mass) / max(left_mass, right_mass)\n    return float(ratio)\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Left-right symmetry score of the object mask within the bounding box (lower = more symmetric)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    p5, p95 = np.percentile(gray, (5, 95))\n    if p95 - p5 <= 1e-6:\n        thr = np.mean(gray)\n        mask_high = gray > thr\n        mask_low = gray < thr\n    else:\n        thr_high = p5 + 0.15 * (p95 - p5)\n        thr_low = p95 - 0.15 * (p95 - p5)\n        mask_high = gray > thr_high\n        mask_low = gray < thr_low\n    mask = mask_high if np.sum(mask_high) >= np.sum(mask_low) else mask_low\n    if mask.sum() == 0:\n        return 0.0\n    cols = np.any(mask, axis=0)\n    if not cols.any():\n        return 0.0\n    left = int(np.where(cols)[0][0]); right = int(np.where(cols)[0][-1])\n    bbox = mask[:, left:right+1].astype(float)\n    bw = bbox.shape[1]\n    if bw <= 1:\n        return 0.0\n    # mirror right half to left and compute mean absolute difference\n    mid = bw // 2\n    left_part = bbox[:, :mid]\n    right_part = np.fliplr(bbox[:, bw-mid:]) if mid > 0 else np.zeros_like(left_part)\n    if left_part.size == 0 or right_part.size == 0:\n        # fallback: compare global halves by simple split\n        mid2 = bw // 2\n        a = bbox[:, :mid2]\n        b = np.fliplr(bbox[:, bw-mid2:])\n        if a.size == 0 or b.size == 0:\n            return 0.0\n        diff = np.mean(np.abs(a - b))\n    else:\n        # crop to same shape\n        min_cols = min(left_part.shape[1], right_part.shape[1])\n        diff = np.mean(np.abs(left_part[:, :min_cols] - right_part[:, :min_cols]))\n    return float(diff)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Relative darkness/brightness gap in a small top-center patch vs its surrounding (indicative of neck/strap openings)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 4 or w < 4:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    cx, cy = w // 2, h // 8\n    inner_w = max(2, w // 5)\n    inner_h = max(2, h // 8)\n    out_w = min(w, max(3, int(1.6 * inner_w)))\n    out_h = min(h, max(3, int(1.6 * inner_h)))\n    ix0 = max(0, cx - inner_w // 2); ix1 = min(w, cx + (inner_w + 1) // 2)\n    iy0 = max(0, cy - inner_h // 2); iy1 = min(h, cy + (inner_h + 1) // 2)\n    ox0 = max(0, cx - out_w // 2); ox1 = min(w, cx + (out_w + 1) // 2)\n    oy0 = max(0, cy - out_h // 2); oy1 = min(h, cy + (out_h + 1) // 2)\n    inner = gray[iy0:iy1, ix0:ix1]\n    outer = gray[oy0:oy1, ox0:ox1]\n    if inner.size == 0 or outer.size == 0:\n        return 0.0\n    inner_mean = float(np.mean(inner))\n    outer_mean = float(np.mean(outer))\n    # positive when inner is brighter than surrounding (gap), normalized\n    contrast = (inner_mean - outer_mean) / (abs(outer_mean) + 1e-8)\n    return float(contrast)\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Left-right asymmetry: normalized absolute difference in foreground pixel count between halves'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    h, w = gray.shape[:2]\n    if w < 2:\n        return 0.0\n    thr = float(np.percentile(gray, 75))\n    mask = (gray > thr).astype(float)\n    left = mask[:, :w//2].sum()\n    right = mask[:, w//2:].sum()\n    total = left + right + 1e-9\n    return float(abs(left - right) / total)\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Ratio of mask width near the top (10%) to width near the bottom (85%) of the image'\n    import numpy as np\n    if image is None:\n        return 1.0\n    h, w = image.shape[:2]\n    if h < 4 or w == 0:\n        return 1.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    def avg_width_at_frac(frac):\n        row = int(min(h - 1, max(0, int(frac * h))))\n        band = max(1, h // 60)\n        start = max(0, row - band)\n        end = min(h, row + band + 1)\n        widths = np.sum(mask[start:end, :].astype(float), axis=1)\n        if widths.size == 0:\n            return 1.0\n        return float(np.mean(widths)) + 1e-8\n    top_w = avg_width_at_frac(0.10)\n    bot_w = avg_width_at_frac(0.85)\n    return float(top_w / (bot_w + 1e-8))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Fraction of columns with deep top boundary dips (columns where top mask row >> mean top)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    top_rows = np.full((w,), h, dtype=int)\n    for col in range(w):\n        col_mask = mask[:, col]\n        ys = np.where(col_mask)[0]\n        if ys.size > 0:\n            top_rows[col] = int(ys[0])\n    if np.all(top_rows == h):\n        return 0.0\n    mean_top = float(np.mean(top_rows[top_rows < h])) if np.any(top_rows < h) else float(h)\n    threshold = mean_top + max(1, int(0.05 * h))\n    dips = np.count_nonzero(top_rows > threshold)\n    return float(dips / float(w + 1e-8))\n",
    "def feature(image: np.ndarray) -> float:\n    'Ratio of maximum foreground row width to mean foreground row width (captures skirt/flare)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    row_widths = np.sum(mask, axis=1).astype(float)\n    if row_widths.size == 0:\n        return 0.0\n    mean_w = float(np.mean(row_widths[row_widths > 0])) if np.any(row_widths > 0) else 0.0\n    max_w = float(np.max(row_widths)) if row_widths.size > 0 else 0.0\n    if mean_w <= 1e-8:\n        return 0.0\n    return float(max_w / (mean_w + 1e-8))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Fraction of the bottom 12% of image rows occupied by foreground (bottom occupancy)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    box_h = max(1, int(h * 0.12))\n    bottom = mask[h - box_h:h, :]\n    occupied = float(np.count_nonzero(bottom))\n    area = float(box_h * w)\n    return float(occupied / (area + 1e-8))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Aspect ratio (width/height) of the mask bounding box (1.0 if undefined)'\n    import numpy as np\n    if image is None:\n        return 1.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 1.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 60)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    if not np.any(mask):\n        return 1.0\n    rows = np.where(np.any(mask, axis=1))[0]\n    cols = np.where(np.any(mask, axis=0))[0]\n    if rows.size == 0 or cols.size == 0:\n        return 1.0\n    bbox_h = float(rows[-1] - rows[0] + 1)\n    bbox_w = float(cols[-1] - cols[0] + 1)\n    if bbox_h <= 0:\n        return 1.0\n    return float(bbox_w / bbox_h)\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Bottom-edge flatness: how straight the object bottom boundary is (higher for flat-soled shoes)'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    thr = np.mean(gray)\n    mask = gray > thr\n    bottom_rows = []\n    for c in range(w):\n        col = mask[:, c]\n        idx = np.where(col)[0]\n        if idx.size:\n            bottom_rows.append(int(idx.max()))\n    if len(bottom_rows) < 3:\n        return 0.0\n    std = float(np.std(bottom_rows))\n    # normalize by image height and invert so flatter -> closer to 1\n    norm = std / max(1.0, float(h))\n    score = 1.0 - norm\n    return float(max(0.0, min(1.0, score)))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Upper-shoulder width at first occupied row within the top quarter normalized by max object width (shirts often have wide shoulders)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    h, w = gray.shape[:2]\n    rng = float(np.max(gray) - np.min(gray))\n    if rng < 1e-6:\n        return 0.0\n    thresh = float(np.mean(gray) + 0.12 * rng)\n    mask = gray > thresh\n    max_w = 0\n    for r in range(h):\n        cols = np.where(mask[r])[0]\n        if cols.size:\n            max_w = max(max_w, int(cols[-1] - cols[0] + 1))\n    top_limit = max(1, h // 4)\n    shoulder_width = 0\n    for r in range(top_limit):\n        cols = np.where(mask[r])[0]\n        if cols.size:\n            shoulder_width = int(cols[-1] - cols[0] + 1)\n            break\n    if max_w <= 0:\n        return 0.0\n    return float(shoulder_width) / float(max_w)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Left-right foreground imbalance: absolute difference in mask mass between halves normalized by total'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    half = w // 2\n    left_sum = float(np.count_nonzero(mask[:, :half]))\n    right_sum = float(np.count_nonzero(mask[:, half:]))\n    total = left_sum + right_sum + 1e-8\n    result = abs(left_sum - right_sum) / total\n    return float(result)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Standard deviation of horizontal widths across rows in the bottom quarter of the object bounding box (normalized)'\n    import numpy as np\n    gray = np.mean(image, axis=2) if len(image.shape) == 3 else image.astype(float)\n    h, w = gray.shape[:2]\n    thresh = np.percentile(gray, 60)\n    mask = gray > thresh\n    if mask.sum() == 0:\n        mask = gray > np.mean(gray)\n    ys, xs = np.where(mask)\n    if ys.size == 0:\n        return 0.0\n    miny, maxy = ys.min(), ys.max()\n    minx, maxx = xs.min(), xs.max()\n    bbox_mask = mask[miny:maxy+1, minx:maxx+1]\n    bh = bbox_mask.shape[0]\n    start_row = max(0, int(bh * 3 / 4))\n    widths = []\n    for r in range(start_row, bh):\n        row = bbox_mask[r, :]\n        cols = np.where(row)[0]\n        if cols.size:\n            widths.append(cols.max() - cols.min() + 1)\n    if not widths:\n        return 0.0\n    stdw = np.std(widths)\n    bbox_w = (maxx - minx + 1)\n    return float(stdw / (bbox_w + 1e-6))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Length of longest vertical contiguous run in center column, normalized by image height'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    thr = float(np.percentile(gray, 50))\n    mask = gray > thr\n    if not np.any(mask):\n        return 0.0\n    center_col = mask[:, w // 2]\n    # find longest run of True in center_col\n    max_run = 0\n    cur = 0\n    for val in center_col:\n        if val:\n            cur += 1\n            if cur > max_run:\n                max_run = cur\n        else:\n            cur = 0\n    return float(max_run / max(1, h))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Normalized row index of the topmost object pixel (0=top, 1=bottom) estimated from a simple mask'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    # grayscale\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    # adaptive threshold: use 60th percentile\n    thr = np.percentile(gray, 60)\n    mask_dark = gray < thr\n    mask_bright = gray > thr\n    mask = mask_dark if np.count_nonzero(mask_dark) >= np.count_nonzero(mask_bright) else mask_bright\n    if np.count_nonzero(mask) == 0:\n        return 0.0\n    # find topmost row that contains any mask pixel\n    rows = np.any(mask, axis=1)\n    top_idx = int(np.argmax(rows)) if np.any(rows) else h - 1\n    # normalize to [0,1]\n    return float(top_idx / max(1, h - 1))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Count of strong peaks in grayscale histogram within mask (normalized to 0..1)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 50)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    vals = gray[mask]\n    if vals.size == 0:\n        return 0.0\n    # histogram\n    bins = 16\n    hist, edges = np.histogram(vals.flatten(), bins=bins, range=(vals.min(), vals.max()))\n    if hist.max() == 0:\n        return 0.0\n    # peaks are bins with value >= 30% of max and greater than neighbors\n    thr_peak = 0.3 * hist.max()\n    peaks = 0\n    for i in range(bins):\n        if hist[i] >= thr_peak:\n            left = hist[i - 1] if i - 1 >= 0 else -1\n            right = hist[i + 1] if i + 1 < bins else -1\n            if hist[i] >= left and hist[i] >= right:\n                peaks += 1\n    # normalize peaks to [0,1]\n    return float(np.clip(peaks / float(bins), 0.0, 1.0))\n",
    "def feature(image: np.ndarray) -> float:\n    'Mask compactness approximated as (perimeter^2) / area using 4-neighborhood boundary'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = ((gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)).astype(np.bool_)\n    area = float(np.count_nonzero(mask))\n    if area <= 0.0:\n        return 0.0\n    padded = np.pad(mask, pad_width=1, mode='constant', constant_values=False)\n    up = padded[:-2, 1:-1]\n    down = padded[2:, 1:-1]\n    left = padded[1:-1, :-2]\n    right = padded[1:-1, 2:]\n    neighbor_count = (up.astype(int) + down.astype(int) + left.astype(int) + right.astype(int))\n    boundary = (mask & (neighbor_count < 4))\n    perimeter = float(np.count_nonzero(boundary))\n    compactness = (perimeter * perimeter) / (area + 1e-8)\n    return float(compactness)\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Estimated count of bright \"button-like\" peaks along the central vertical axis in the upper-middle region (normalized by image height)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    if h < 4 or w < 1:\n        return 0.0\n    col = w // 2\n    start = max(0, h // 6)\n    end = min(h, h // 2 + 1)\n    col_vals = gray[start:end, col]\n    global_mean = gray.mean() if gray.size else 0.0\n    global_std = gray.std() if gray.size else 0.0\n    threshold = global_mean + 0.6 * (global_std + 1e-6)\n    peaks = 0\n    for i in range(1, col_vals.size - 1):\n        val = col_vals[i]\n        if val > threshold and val > col_vals[i-1] and val > col_vals[i+1]:\n            # also require local lateral contrast\n            left = gray[start + i, max(0, col - 1)]\n            right = gray[start + i, min(w - 1, col + 1)]\n            if val > left + 1e-6 and val > right + 1e-6:\n                peaks += 1\n    return float(peaks) / float(max(1, h))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Average fraction of empty (background) pixels inside the foreground bounding box per row'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 50)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    ys, xs = np.where(mask)\n    if xs.size == 0 or ys.size == 0:\n        return 0.0\n    ymin, ymax = int(np.min(ys)), int(np.max(ys))\n    xmin, xmax = int(np.min(xs)), int(np.max(xs))\n    bbox = mask[ymin:ymax+1, xmin:xmax+1]\n    if bbox.size == 0:\n        return 0.0\n    row_empty_frac = np.mean(np.sum(~bbox, axis=1).astype(float) / float(max(1, bbox.shape[1])))\n    return float(row_empty_frac)\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Mean color saturation (RGB only) computed as mean((max-min)/max) across pixels; grayscale -> 0'\n    import numpy as np\n    if image is None:\n        return 0.0\n    if len(image.shape) != 3 or image.shape[2] < 3:\n        return 0.0\n    # compute per-pixel saturation\n    img = image.astype(float)\n    r = img[:, :, 0]\n    g = img[:, :, 1]\n    b = img[:, :, 2]\n    mx = np.maximum(np.maximum(r, g), b)\n    mn = np.minimum(np.minimum(r, g), b)\n    sat = np.zeros_like(mx, dtype=float)\n    nonzero = mx > 1e-8\n    sat[nonzero] = (mx[nonzero] - mn[nonzero]) / (mx[nonzero] + 1e-12)\n    return float(np.mean(sat))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Average of longest vertical foreground runs per column in bottom half, normalized by half-height'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 2 or w == 0:\n        return 0.0\n    bh_start = h // 2\n    bh = h - bh_start\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 50)\n    mask = ((gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)).astype(np.uint8)\n    if bh <= 0:\n        return 0.0\n    col_runs = []\n    bottom = mask[bh_start:, :]\n    for c in range(w):\n        col = bottom[:, c]\n        max_run = 0\n        cur = 0\n        for v in col:\n            if v:\n                cur += 1\n                if cur > max_run:\n                    max_run = cur\n            else:\n                cur = 0\n        col_runs.append(max_run)\n    if len(col_runs) == 0:\n        return 0.0\n    return float(np.mean(col_runs) / float(bh + 1e-8))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Fraction of mask pixels located in the bottom quartile of the image'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = ((gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)).astype(bool)\n    if not np.any(mask):\n        return 0.0\n    cut = max(1, h - h // 4)\n    bottom_mask = mask[cut:h, :]\n    return float(np.count_nonzero(bottom_mask) / (np.count_nonzero(mask) + 1e-8))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Shoulder protrusion score: average lateral protrusion of mask edges in the upper 20% rows'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 4 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 50)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    top_h = max(1, h * 20 // 100)\n    rows = mask[:top_h, :]\n    if rows.size == 0:\n        return 0.0\n    xs = np.arange(w)\n    left_idx = np.full(rows.shape[0], w, dtype=int)\n    right_idx = np.full(rows.shape[0], -1, dtype=int)\n    for i in range(rows.shape[0]):\n        cols = np.where(rows[i, :])[0]\n        if cols.size > 0:\n            left_idx[i] = int(cols[0])\n            right_idx[i] = int(cols[-1])\n    valid = (right_idx >= 0)\n    if not np.any(valid):\n        return 0.0\n    center = w / 2.0\n    protrusion = ((center - left_idx[valid]) + (right_idx[valid] - center)) / 2.0\n    norm = w / 2.0\n    score = np.mean(protrusion / (norm + 1e-8))\n    return float(score)\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Ratio of object horizontal width in top quarter to width in bottom quarter (top_width / bottom_width)'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    h, w = gray.shape\n    thr = np.mean(gray) + 0.15 * np.std(gray)\n    mask = gray > thr\n    if np.count_nonzero(mask) == 0:\n        thr2 = np.max(gray) * 0.1\n        mask = gray > thr2\n        if np.count_nonzero(mask) == 0:\n            return 0.0\n    top_rows = slice(0, max(1, h // 4))\n    bottom_rows = slice(max(0, 3 * h // 4), h)\n    def horiz_span(mask_slice):\n        rows = mask_slice\n        # find leftmost and rightmost object pixel in those rows\n        cols = np.any(rows, axis=0)\n        if not cols.any():\n            return 0.0\n        left = np.argmax(cols)\n        right = w - 1 - np.argmax(cols[::-1])\n        return float(right - left + 1)\n    top_width = horiz_span(mask[top_rows, :])\n    bottom_width = horiz_span(mask[bottom_rows, :])\n    if bottom_width <= 0:\n        return float(top_width)\n    return float(top_width / bottom_width)\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Width fraction at mid-height: length of contiguous object segment at mid row divided by image width'\n    try:\n        if len(image.shape) == 3:\n            gray = np.mean(image.astype(float), axis=2)\n        else:\n            gray = image.astype(float)\n    except Exception:\n        return 0.0\n    h, w = gray.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    thr = (np.mean(gray) + np.min(gray)) / 2.0\n    mask = (gray > thr)\n    mid = h // 2\n    row = mask[mid, :]\n    if not row.any():\n        # try a small neighborhood average if exact mid row empty\n        neighborhood = mask[max(0, mid - 1):min(h, mid + 2), :]\n        proj = np.any(neighborhood, axis=0)\n        row = proj\n    # find longest contiguous True segment\n    if not row.any():\n        return 0.0\n    # convert to integer array and detect runs\n    arr = row.astype(int)\n    diffs = np.diff(np.concatenate(([0], arr, [0])))\n    starts = np.where(diffs == 1)[0]\n    ends = np.where(diffs == -1)[0]\n    lengths = ends - starts\n    maxlen = np.max(lengths) if lengths.size else 0\n    return float(maxlen / float(w))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Normalized left-right mask asymmetry (0 symmetric -> higher = more asymmetric)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if w == 0 or h == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    mid = w // 2\n    left_sum = float(np.count_nonzero(mask[:, :mid]))\n    right_sum = float(np.count_nonzero(mask[:, w - mid:]))\n    total = left_sum + right_sum\n    if total <= 1e-8:\n        return 0.0\n    diff = abs(left_sum - right_sum)\n    return float(diff / total)\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Row index (normalized) of maximum horizontal span (row with most object pixels)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    thr = float(np.percentile(gray, 50))\n    mask = gray > thr\n    if not np.any(mask):\n        return 0.0\n    row_counts = mask.sum(axis=1)\n    max_row = int(np.argmax(row_counts))\n    return float(max_row / max(1, h - 1))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Color contrast between estimated foreground and background (RGB L2 normalized)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) != 3 or image.shape[2] < 3:\n        return 0.0\n    img = image.astype(float)\n    gray = np.mean(img, axis=2)\n    thr = np.percentile(gray, 50)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    fg = img[mask]\n    bg = img[~mask]\n    if fg.size == 0 or bg.size == 0:\n        return 0.0\n    fg_mean = np.mean(fg.reshape(-1, 3), axis=0)\n    bg_mean = np.mean(bg.reshape(-1, 3), axis=0)\n    diff = np.linalg.norm(fg_mean - bg_mean)\n    denom = (np.mean(gray) + 1e-8)\n    return float(diff / denom)\n",
    "def feature(image: np.ndarray) -> float:\n    'Ratio of minimum to maximum horizontal width measured at top/middle/bottom thirds (low value -> strongly tapered shapes like boots or heels)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    thr = np.mean(gray) + 0.15 * (np.std(gray) + 1e-8)\n    border = np.concatenate([gray[0:2, :].ravel(), gray[-2:, :].ravel(), gray[:, 0:2].ravel(), gray[:, -2:].ravel()])\n    center = gray[h//4:3*h//4, w//4:3*w//4] if h>=4 and w>=4 else gray\n    if np.mean(center) < np.mean(border):\n        mask = (gray < thr).astype(int)\n    else:\n        mask = (gray > thr).astype(int)\n    thirds = [slice(0, h//3), slice(h//3, 2*h//3), slice(2*h//3, h)]\n    widths = []\n    for s in thirds:\n        rows = np.any(mask[s, :], axis=1)\n        if not rows.any():\n            widths.append(0)\n            continue\n        # compute mean width across this slice\n        wvals = []\n        for r in np.where(rows)[0] + (s.start or 0):\n            cols = np.where(mask[r, :])[0]\n            if cols.size:\n                wvals.append(cols[-1] - cols[0] + 1)\n        widths.append(np.mean(wvals) if len(wvals) else 0)\n    widths = np.array(widths)\n    max_w = widths.max()\n    min_w = widths.min()\n    if max_w <= 0:\n        return 0.0\n    return float(min_w / (max_w + 1e-10))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Constriction index: min width in middle third divided by average of top and bottom widths (low => large waist constriction)'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    mn, mx = float(gray.min()), float(gray.max())\n    gray = np.zeros_like(gray) if mx == mn else (gray - mn) / (mx - mn)\n    thr = gray.mean() + 0.15 * gray.std()\n    mask = gray > thr\n    if not mask.any():\n        return 0.0\n    def row_width(region_rows):\n        cols = np.where(mask[region_rows, :].any(axis=0))[0]\n        return 0 if cols.size == 0 else cols[-1] - cols[0] + 1\n    top_rows = range(0, max(1, h // 6))\n    mid_start = max(0, h // 3)\n    mid_end = min(h, mid_start + max(1, h // 3))\n    bot_start = max(0, h - h // 6 - 1)\n    top_w = row_width(top_rows)\n    mid_widths = [ (np.where(mask[r,:])[0].max() - np.where(mask[r,:])[0].min() + 1) if np.any(mask[r,:]) else 0 for r in range(mid_start, mid_end) ]\n    mid_min = min(mid_widths) if mid_widths else 0\n    bot_w = row_width(range(bot_start, h))\n    denom = ((top_w + bot_w) / 2.0) + 1e-6\n    result = float(mid_min / denom)\n    return result\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Absolute horizontal centroid offset: distance from object centroid to image center (in columns) normalized by image width'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    thr = np.mean(gray) + 0.2 * (np.max(gray) - np.min(gray))\n    mask = gray > thr\n    if np.count_nonzero(mask) == 0:\n        mask = gray > np.mean(gray)\n    if np.count_nonzero(mask) == 0:\n        return 0.0\n    rows, cols = np.where(mask)\n    centroid_col = np.mean(cols)\n    w = gray.shape[1]\n    center_col = (w - 1) / 2.0\n    return float(abs(centroid_col - center_col) / max(1.0, w - 1))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Left-right symmetry: IoU between mask and horizontally flipped mask (0..1)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    flipped = np.fliplr(mask)\n    inter = np.count_nonzero(mask & flipped)\n    union = np.count_nonzero(mask | flipped)\n    if union == 0:\n        return 0.0\n    return float(inter / float(union))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Ratio of average object horizontal span in the second top decile to the top decile (taper at shoulder/top)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    mn, mx = float(np.min(gray)), float(np.max(gray))\n    if mx > mn:\n        gray = (gray - mn) / (mx - mn)\n    thr = np.mean(gray) + 0.5 * np.std(gray)\n    if thr <= np.min(gray) + 1e-9:\n        thr = np.min(gray) + (np.max(gray) - np.min(gray)) * 0.1\n    mask = gray > thr\n    if not np.any(mask):\n        return 0.0\n    ys, xs = np.nonzero(mask)\n    y0, y1 = np.min(ys), np.max(ys)\n    bh = max(1, y1 - y0 + 1)\n    top_h = max(1, int(round(bh * 0.10)))\n    # top decile rows\n    rtop0, rtop1 = y0, min(y1, y0 + top_h - 1)\n    rnext0, rnext1 = min(y1, rtop1 + 1), min(y1, rtop1 + top_h)\n    def avg_width(r0, r1):\n        widths = []\n        for r in range(r0, r1+1):\n            cols = np.where(mask[r, :])[0]\n            if cols.size:\n                widths.append(cols[-1] - cols[0] + 1)\n        return np.mean(widths) if widths else 0.0\n    w_top = avg_width(rtop0, rtop1)\n    w_next = avg_width(rnext0, rnext1)\n    if w_top <= 0:\n        return 0.0\n    return float(w_next / (w_top + 1e-9))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Average horizontal width in bottom half divided by average width in top half (skirt presence if >1)'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    thr = max(np.mean(gray) * 0.5, np.max(gray) * 0.05)\n    mask = gray > thr\n    if not mask.any():\n        return 0.0\n    widths = []\n    for r in range(h):\n        cols = np.nonzero(mask[r, :])[0]\n        widths.append(cols.size)\n    widths = np.array(widths, dtype=float)\n    top_avg = widths[:h//2].mean() if (h//2) > 0 else 0.0\n    bot_avg = widths[h//2:].mean() if (h - h//2) > 0 else 0.0\n    return float((bot_avg + 1e-6) / max(1e-6, top_avg))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Diagonal (45\u00b0) edge energy concentrated in the top corner/shoulder areas (high for lapels/collar diagonals)'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.copy()\n    h, w = gray.shape[:2]\n    gy, gx = np.gradient(gray)\n    # approximate diagonal energy as |gx + gy|\n    diag = np.abs(gx + gy)\n    # top-left and top-right boxes\n    th = max(1, h // 6)\n    tw = max(1, w // 4)\n    tl = diag[0:th, 0:tw]\n    tr = diag[0:th, w-tw:w]\n    energy = float(np.mean(np.concatenate([tl.flatten(), tr.flatten()]))) if tl.size+tr.size>0 else 0.0\n    # normalize by global gradient energy\n    global_e = float(np.mean(np.abs(gx) + np.abs(gy))) + 1e-6\n    return float(energy / global_e)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Mask fill ratio: area(mask) divided by bounding-box area (0..1)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 50)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    if not np.any(mask):\n        return 0.0\n    rows = np.where(np.any(mask, axis=1))[0]\n    cols = np.where(np.any(mask, axis=0))[0]\n    if rows.size == 0 or cols.size == 0:\n        return 0.0\n    bbox_h = float(rows[-1] - rows[0] + 1)\n    bbox_w = float(cols[-1] - cols[0] + 1)\n    bbox_area = max(1.0, bbox_h * bbox_w)\n    mask_area = float(np.count_nonzero(mask))\n    return float(np.clip(mask_area / bbox_area, 0.0, 1.0))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Count of prominent vertical peaks in the binarized column-sum profile (normalized)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w < 3:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 50)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    col_sums = np.sum(mask.astype(float), axis=0)\n    if np.all(col_sums == 0):\n        return 0.0\n    # local maxima detection\n    peaks = 0\n    maxval = float(np.max(col_sums))\n    thresh = max(1.0, 0.2 * maxval)\n    for i in range(1, col_sums.size - 1):\n        if col_sums[i] > col_sums[i - 1] and col_sums[i] > col_sums[i + 1] and col_sums[i] >= thresh:\n            peaks += 1\n    # normalize by possible peaks (image width)\n    norm = float(peaks) / float(max(1, w // 10))\n    return float(norm)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Mid-frequency energy in row-profile FFT (detects horizontal banding)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 4:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    row_profile = np.mean(gray, axis=1)\n    row_profile = row_profile - np.mean(row_profile)\n    spec = np.abs(np.fft.rfft(row_profile))\n    total = np.sum(spec) + 1e-8\n    n = spec.size\n    lo = 2\n    hi = min(6, n - 1)\n    if hi < lo:\n        return 0.0\n    mid_energy = np.sum(spec[lo:hi + 1])\n    return float(mid_energy / total)\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Mean gradient magnitude inside the object mask (texture/edge richness; sneakers often have stronger internal gradients than simple sandals)'\n    import numpy as np\n    gray = np.mean(image, axis=2) if image.ndim == 3 else image.astype(float)\n    gray = gray.astype(float)\n    thr = float(np.percentile(gray.flatten(), 75))\n    if thr <= gray.min():\n        thr = float(gray.mean())\n    mask = gray > thr\n    if not mask.any():\n        return 0.0\n    # compute gradients\n    gy, gx = np.gradient(gray)\n    gradmag = np.sqrt(gx*gx + gy*gy)\n    mean_grad = np.sum(gradmag * mask) / (mask.sum() + 1e-9)\n    # normalize by global gradient mean to reduce lighting sensitivity\n    global_mean = gradmag.mean() + 1e-9\n    return float(mean_grad / global_mean)\n",
    "def feature(image: np.ndarray) -> float:\n    'Ratio of mean mask width in the top 15% rows to bottom 15% rows'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 4 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    band = max(1, int(0.15 * h))\n    top_rw = np.sum(mask[:band, :], axis=1).astype(float)\n    bottom_rw = np.sum(mask[h - band:, :], axis=1).astype(float)\n    top_mean = float(np.mean(top_rw)) if top_rw.size > 0 else 0.0\n    bottom_mean = float(np.mean(bottom_rw)) if bottom_rw.size > 0 else 0.0\n    return float(top_mean / (bottom_mean + 1e-8))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Normalized count of foreground/background transitions along the middle row (higher when sleeves or side gaps exist)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(np.float32)\n    else:\n        gray = image.astype(np.float32)\n    h, w = gray.shape[:2]\n    if w < 2 or h < 1:\n        return 0.0\n    mn, mx = np.min(gray), np.max(gray)\n    if mx - mn < 1e-6:\n        binary = gray > mx * 0.5\n    else:\n        thr = float(np.percentile(gray, 50))\n        binary = gray > thr\n    row = binary[h//2, :].astype(np.int8)\n    transitions = int(np.count_nonzero(row[1:] != row[:-1]))\n    return float(transitions / max(1, w - 1))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Proportion of foreground pixels located within the central box (center 50% by height and width)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    total = float(np.count_nonzero(mask))\n    if total <= 0.0:\n        return 0.0\n    r0, r1 = h // 4, (3 * h) // 4\n    c0, c1 = w // 4, (3 * w) // 4\n    center_count = float(np.count_nonzero(mask[r0:r1, c0:c1]))\n    return float(center_count / total)\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Mean color saturation (RGB) measured as (max-min)/max per pixel, 0 for grayscale images'\n    import numpy as np\n    if image is None:\n        return 0.0\n    if len(image.shape) != 3 or image.shape[2] != 3:\n        return 0.0\n    img = image.astype(float)\n    r = img[:, :, 0]\n    g = img[:, :, 1]\n    b = img[:, :, 2]\n    mx = np.maximum(np.maximum(r, g), b)\n    mn = np.minimum(np.minimum(r, g), b)\n    sat = (mx - mn) / (mx + 1e-8)\n    # where max is zero set saturation to zero\n    sat = np.where(mx <= 1e-8, 0.0, sat)\n    result = float(np.mean(sat))\n    return float(result)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Normalized width of the object at the top quarter (top narrowness/straps detection) relative to its bounding-box width'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    thr = np.mean(gray) + 0.12*(np.max(gray)-np.min(gray))\n    mask = gray > thr\n    if np.count_nonzero(mask) < 5:\n        mask = gray > np.mean(gray)\n    coords = np.argwhere(mask)\n    if coords.size == 0:\n        return 0.0\n    rmin, cmin = coords.min(axis=0)\n    rmax, cmax = coords.max(axis=0)\n    bbox_w = float(cmax - cmin + 1)\n    top_slice = mask[rmin: rmin + max(1, (rmax - rmin)//4), cmin:cmax+1]\n    if top_slice.size == 0:\n        return 0.0\n    widths = []\n    for r in range(top_slice.shape[0]):\n        cols = np.where(top_slice[r])[0]\n        if cols.size:\n            widths.append(cols.max() - cols.min() + 1)\n    if len(widths) == 0:\n        return 0.0\n    return float(np.mean(widths)) / (bbox_w + 1e-6)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Bounding-box width-to-height aspect ratio of the foreground mask'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 50)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    ys, xs = np.where(mask)\n    if ys.size == 0:\n        return 0.0\n    miny, maxy = int(np.min(ys)), int(np.max(ys))\n    minx, maxx = int(np.min(xs)), int(np.max(xs))\n    bbox_h = max(1, maxy - miny + 1)\n    bbox_w = max(1, maxx - minx + 1)\n    return float(bbox_w / bbox_h)\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Average vertical widening rate (slope of width vs row) in the lower half normalized by image width (positive -> flare)'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    h, w = gray.shape[:2]\n    maxv = float(np.max(gray))\n    if maxv <= 0:\n        return 0.0\n    mask = gray > (maxv * 0.1)\n    lower = mask[h//2:, :]\n    rows = []\n    widths = []\n    for i, r in enumerate(range(h//2, h)):\n        row = lower[i, :]\n        if np.any(row):\n            cols = np.where(row)[0]\n            left = cols[0]\n            right = cols[-1]\n            widths.append(float(right - left + 1))\n            rows.append(float(r))\n    if len(rows) < 2:\n        return 0.0\n    # linear slope of widths vs row\n    try:\n        p = np.polyfit(rows, widths, 1)\n        slope = float(p[0])\n    except Exception:\n        slope = 0.0\n    # normalize by image width\n    return slope / float(max(1.0, w))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Ratio of average mask width in top 15% to bottom 15% rows (top/bottom width ratio)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 4 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = float(np.median(gray))\n    mask = ((gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)).astype(np.uint8)\n    top_h = max(1, int(h * 0.15))\n    bot_h = max(1, int(h * 0.15))\n    def avg_width(rows):\n        widths = []\n        xs = np.arange(w)\n        for r in range(rows.shape[0]):\n            row = rows[r, :]\n            if np.any(row):\n                left = xs[row].min()\n                right = xs[row].max()\n                widths.append(float(right - left + 1))\n        return float(np.mean(widths)) if len(widths) > 0 else 0.0\n    top_w = avg_width(mask[:top_h, :])\n    bottom_w = avg_width(mask[-bot_h:, :])\n    return float(top_w / (bottom_w + 1e-8))\n",
    "def feature(image: np.ndarray) -> float:\n    'Ratio of edge density (gradient magnitude above median) in upper third to lower third (collars increase upper density)'\n    import numpy as np\n    img = np.array(image, dtype=float)\n    if img.size == 0:\n        return 0.0\n    if img.ndim == 3:\n        gray = np.mean(img, axis=2)\n    else:\n        gray = img\n    h, w = gray.shape\n    gy, gx = np.gradient(gray)\n    mag = np.sqrt(gy * gy + gx * gx)\n    med = np.median(mag)\n    upper = mag[:max(1, h // 3), :]\n    lower = mag[max(1, 2 * h // 3):, :]\n    up_density = np.sum(upper > med) / max(1.0, upper.size)\n    low_density = np.sum(lower > med) / max(1.0, lower.size)\n    return float((up_density + 1e-6) / max(1e-6, low_density))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Fraction of strong gradient pixels inside the bottom 25% band (edge density near ground)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 4 or w < 2:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    gy, gx = np.gradient(gray.astype(float))\n    grad = np.sqrt(gx * gx + gy * gy)\n    band_start = int(max(0, np.floor(h * 0.75)))\n    bottom_band = grad[band_start:, :]\n    if bottom_band.size == 0:\n        return 0.0\n    thresh = np.percentile(grad, 70) if np.any(grad) else 0.0\n    strong = bottom_band > thresh\n    return float(np.count_nonzero(strong) / (bottom_band.size + 1e-8))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Fraction of foreground pixels located in the bottom quarter of the image'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 4 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 50)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    area = float(np.count_nonzero(mask))\n    if area == 0.0:\n        return 0.0\n    bottom = mask[(3 * h) // 4:, :]\n    bottom_count = float(np.count_nonzero(bottom))\n    return float(bottom_count / (area + 1e-12))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Normalized left-right asymmetry: mean absolute difference between image and its mirror'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    flipped = np.fliplr(gray)\n    diff = np.abs(gray - flipped)\n    denom = np.mean(np.abs(gray)) + 1e-8\n    return float(np.mean(diff) / denom)\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Edge complexity: sum of gradient magnitudes within object mask normalized by object area'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    # gradients\n    try:\n        gy, gx = np.gradient(gray)\n    except Exception:\n        gy = np.zeros_like(gray)\n        gx = np.zeros_like(gray)\n    grad = np.hypot(gx, gy)\n    maxv, minv = float(np.max(gray)), float(np.min(gray))\n    thr = max(np.percentile(gray, 80), minv + 0.1 * (maxv - minv))\n    mask = gray >= thr\n    area = np.count_nonzero(mask)\n    if area == 0:\n        return 0.0\n    edge_sum = float(np.sum(grad[mask]))\n    # normalize by sqrt(area) to be scale-consistent\n    norm = max(1.0, np.sqrt(area))\n    return float(edge_sum / norm)\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Relative darkness of a narrow central vertical strip in the upper half vs flanking strips (higher => center darker)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    # mask\n    p60 = np.percentile(gray, 60)\n    p40 = np.percentile(gray, 40)\n    mask = (gray >= p60) if (gray >= p60).sum() >= (gray <= p40).sum() else (gray <= p40)\n    if mask.sum() == 0:\n        return 0.0\n    ys, xs = np.where(mask)\n    y0, y1 = ys.min(), ys.max()\n    x0, x1 = xs.min(), xs.max()\n    h = max(1, y1 - y0 + 1)\n    w = max(1, x1 - x0 + 1)\n    up_h = y0 + h // 2\n    # define strips within upper half of bbox\n    center_w = max(1, w // 10)\n    cx0 = x0 + w // 2 - center_w // 2\n    cx1 = cx0 + center_w\n    left0 = x0\n    left1 = x0 + max(1, w // 6)\n    right1 = x1 + 1\n    right0 = x1 + 1 - max(1, w // 6)\n    center_strip = gray[y0:up_h, max(0, cx0):min(gray.shape[1], cx1)]\n    left_strip = gray[y0:up_h, left0:left1]\n    right_strip = gray[y0:up_h, right0:right1]\n    # compute means and form a ratio side_mean / center_mean\n    c_mean = np.mean(center_strip) if center_strip.size else np.mean(gray)\n    side_mean = np.mean(np.concatenate([left_strip.flatten(), right_strip.flatten()])) if (left_strip.size + right_strip.size) else np.mean(gray)\n    # If center is darker, side_mean/center_mean > 1 for bright images; invert appropriately to yield higher when center darker\n    # Use difference normalized\n    denom = (side_mean + c_mean) / 2.0 + 1e-6\n    score = float((side_mean - c_mean) / denom)\n    return score\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Normalized vertical center of mass of the foreground mask (0=top, 1=bottom)'\n    import numpy as np\n    if image is None:\n        return 0.5\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.5\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    ys, xs = np.where(mask)\n    if ys.size == 0:\n        return 0.5\n    center_y = np.mean(ys)\n    return float(center_y / max(1.0, (h - 1)))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Count of prominent vertical peaks in horizontal projection (useful for leg separation) as a float'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    col_sums = np.sum(mask.astype(float), axis=0)\n    if np.max(col_sums) <= 0:\n        return 0.0\n    peak_thr = 0.25 * np.max(col_sums)\n    peaks = col_sums > peak_thr\n    # count rising edges = number of contiguous peak runs\n    if not np.any(peaks):\n        return 0.0\n    diffs = np.diff(peaks.astype(int))\n    rising = np.count_nonzero(diffs == 1)\n    # if first column starts with a peak, include it\n    if peaks[0]:\n        rising += 1\n    return float(rising)\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Bounding-box solidity: object pixel area divided by its bounding-box area (compactness)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    thr = np.mean(gray)\n    mask = gray > thr\n    if not np.any(mask):\n        return 0.0\n    ys, xs = np.where(mask)\n    minr, maxr = ys.min(), ys.max()\n    minc, maxc = xs.min(), xs.max()\n    bbox_area = float((maxr - minr + 1) * (maxc - minc + 1))\n    obj_area = float(mask.sum())\n    solidity = obj_area / (bbox_area + 1e-8)\n    return float(solidity)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Fraction of object pixels located in the lower half of the image (higher for sandals)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    thresh = np.mean(gray) + 0.1 * np.std(gray)\n    mask = gray > thresh\n    total = mask.sum()\n    if total == 0:\n        return 0.0\n    lower_mask = mask[h//2:, :]\n    return float(lower_mask.sum() / total)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Normalized vertical centroid (row index of centroid of foreground divided by image height)'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    nz = gray[gray > 0]\n    thresh = float(np.percentile(nz, 40)) if nz.size > 0 else float(np.mean(gray))\n    mask = (gray >= thresh).astype(float)\n    h, w = mask.shape\n    total = mask.sum()\n    if total <= 0:\n        return 0.0\n    rows = np.arange(h)[:, None]\n    centroid_r = (rows * mask).sum() / total\n    return float(centroid_r / max(1, h - 1))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Median number of horizontal mask segments per row (estimates separate blobs/shoes)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = float(np.median(gray))\n    mask = ((gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)).astype(np.uint8)\n    seg_counts = []\n    for r in range(h):\n        row = mask[r, :]\n        if np.any(row):\n            padded = np.concatenate(([0], row, [0])).astype(np.uint8)\n            segs = int(np.sum((padded[1:] == 1) & (padded[:-1] == 0)))\n            seg_counts.append(segs)\n    if len(seg_counts) == 0:\n        return 0.0\n    return float(np.median(np.array(seg_counts, dtype=float)))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Fraction of object pixels in lateral sleeve regions within upper-mid band (captures sleeve prominence)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    bg_h, bg_w = max(1, h // 10), max(1, w // 10)\n    bg = np.mean(gray[:bg_h, :bg_w])\n    gm = np.mean(gray)\n    thresh = (bg + gm) / 2.0\n    object_is_darker = gm < bg\n    if object_is_darker:\n        mask = gray < thresh\n    else:\n        mask = gray > thresh\n    r0 = max(0, h // 4)\n    r1 = max(r0 + 1, h // 2)\n    band = mask[r0:r1, :]\n    if band.size == 0:\n        return 0.0\n    left_region = band[:, :max(1, w // 3)]\n    center_region = band[:, max(1, w // 3):max(1, 2 * w // 3)]\n    right_region = band[:, max(1, 2 * w // 3):]\n    sleeve_pixels = np.count_nonzero(left_region) + np.count_nonzero(right_region)\n    total_pixels = np.count_nonzero(band)\n    if total_pixels == 0:\n        return 0.0\n    return float(sleeve_pixels / total_pixels)\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Ratio of object horizontal span at the bottom 10% of the bbox to the span at mid-height (flared dresses >1)'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    mask = gray > 0\n    if np.count_nonzero(mask) < 5:\n        thr = np.mean(gray)\n        mask = gray > thr * 0.5\n    if np.count_nonzero(mask) == 0:\n        return 0.0\n    rows_any = np.any(mask, axis=1)\n    cols_any = np.any(mask, axis=0)\n    r_idxs = np.where(rows_any)[0]\n    c_idxs = np.where(cols_any)[0]\n    if r_idxs.size == 0 or c_idxs.size == 0:\n        return 0.0\n    rmin, rmax = r_idxs[0], r_idxs[-1]\n    cmin, cmax = c_idxs[0], c_idxs[-1]\n    bbox_h = rmax - rmin + 1\n    bottom_h = max(1, int(np.ceil(bbox_h * 0.10)))\n    bottom_rows = range(rmax - bottom_h + 1, rmax + 1)\n    # compute horizontal span per considered row\n    def row_span(r):\n        row = mask[r, cmin:cmax+1]\n        cols = np.where(row)[0]\n        if cols.size == 0:\n            return 0\n        return int(cols[-1] - cols[0] + 1)\n    bottom_spans = [row_span(r) for r in bottom_rows]\n    bottom_span = float(np.median(bottom_spans)) if bottom_spans else 0.0\n    mid_row = (rmin + rmax) // 2\n    mid_span = float(row_span(mid_row))\n    eps = 1e-6\n    if mid_span < eps:\n        return float(bottom_span)\n    return float(bottom_span / (mid_span + eps))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Standard deviation of object horizontal widths across rows normalized by image width (higher for garments with sleeves)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    thresh = np.mean(gray) + 0.1 * np.std(gray)\n    mask = gray > thresh\n    widths = []\n    for r in range(h):\n        cols = np.where(mask[r])[0]\n        if cols.size:\n            widths.append(cols[-1] - cols[0] + 1)\n    if not widths:\n        return 0.0\n    stdw = float(np.std(widths))\n    return float(stdw / max(1.0, w))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Waist narrowing: ratio of horizontal width at 35% height to width at 55% height (values <1 indicate narrowing at waist)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    if h < 4:\n        return 1.0\n    thr = max(np.mean(gray) * 0.5, np.max(gray) * 0.05, 1e-8)\n    mask = gray > thr\n    if not mask.any():\n        return 1.0\n    def width_at_row(row):\n        row = int(min(max(0, row), h-1))\n        cols = np.where(mask[row, :])[0]\n        if cols.size == 0:\n            return 0.0\n        return float(cols[-1] - cols[0] + 1)\n    r1 = int(h * 0.35)\n    r2 = int(h * 0.55)\n    w1 = width_at_row(r1)\n    w2 = width_at_row(r2) + 1e-8\n    return float(w1 / w2)\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Top-center concavity: how much the top profile dips near the center relative to shoulder columns (positive = center lower)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    p60 = np.percentile(gray, 60)\n    p40 = np.percentile(gray, 40)\n    mask = (gray >= p60) if (gray >= p60).sum() >= (gray <= p40).sum() else (gray <= p40)\n    if mask.sum() == 0:\n        return 0.0\n    ys, xs = np.where(mask)\n    y0, y1 = ys.min(), ys.max()\n    x0, x1 = xs.min(), xs.max()\n    W = max(1, x1 - x0 + 1)\n    top_profile = np.full(W, y1+1, dtype=float)\n    sub = mask[y0:y1+1, x0:x1+1]\n    for col in range(W):\n        col_pixels = sub[:, col]\n        ys_col = np.where(col_pixels)[0]\n        if ys_col.size > 0:\n            top_profile[col] = y0 + ys_col.min()\n    # consider center window and shoulder windows\n    center = W // 2\n    halfw = max(1, W // 8)\n    center_val = np.min(top_profile[max(0, center - halfw):min(W, center + halfw+1)])\n    left_shoulder = np.min(top_profile[max(0, center - 3*halfw):max(0, center - halfw)])\n    right_shoulder = np.min(top_profile[min(W-1, center + halfw+1):min(W, center + 3*halfw+1)])\n    shoulder_mean = np.mean([v for v in (left_shoulder, right_shoulder) if np.isfinite(v)])\n    if not np.isfinite(shoulder_mean):\n        return 0.0\n    # positive if center is lower (bigger y)\n    concavity = float((center_val - shoulder_mean) / (y1 - y0 + 1.0 + 1e-6))\n    return concavity\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Left-right symmetry score: 1.0 = perfectly symmetric, 0.0 = very asymmetric'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    h, w = gray.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    thr = np.mean(gray) + 0.15 * (np.max(gray) - np.min(gray))\n    fg = (gray > thr).astype(float)\n    if np.count_nonzero(fg) == 0:\n        fg = (gray > np.percentile(gray, 75)).astype(float)\n    # split left and right halves, mirror right to compare to left\n    mid = w // 2\n    left = fg[:, :mid]\n    right = fg[:, w - mid:][:, ::-1]  # mirrored right region\n    if left.size == 0 or right.size == 0:\n        return 0.0\n    # pad smaller to match\n    if left.shape != right.shape:\n        mh = min(left.shape[0], right.shape[0])\n        left = left[:mh, :min(left.shape[1], right.shape[1])]\n        right = right[:mh, :min(right.shape[1], left.shape[1])]\n    diff = np.abs(left - right).sum()\n    norm = (left + right).sum()\n    if norm <= 1e-6:\n        return 0.0\n    score = 1.0 - (diff / norm)\n    return float(max(0.0, min(1.0, score)))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Edge density inside the object bounding box (edge pixels / bbox area)'\n    import numpy as np\n    gray = np.mean(image, axis=2) if len(image.shape) == 3 else image.astype(float)\n    h, w = gray.shape[:2]\n    thresh = np.percentile(gray, 60)\n    mask = gray > thresh\n    if mask.sum() == 0:\n        mask = gray > np.mean(gray)\n    ys, xs = np.where(mask)\n    if ys.size == 0:\n        return 0.0\n    miny, maxy = ys.min(), ys.max()\n    minx, maxx = xs.min(), xs.max()\n    bbox = gray[miny:maxy+1, minx:maxx+1].astype(float)\n    gy, gx = np.gradient(bbox)\n    mag = np.hypot(gx, gy)\n    if mag.size == 0:\n        return 0.0\n    edge_thresh = np.percentile(mag, 75)\n    edges = mag > edge_thresh\n    bbox_area = bbox.size + 1e-6\n    return float(np.count_nonzero(edges) / bbox_area)\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Ratio of mean mask width in upper shoulder rows to mean width in torso rows (shoulder/torso width)'\n    import numpy as np\n    if image is None:\n        return 1.0\n    h, w = image.shape[:2]\n    if h < 4 or w == 0:\n        return 1.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    shoulder_top = 1\n    shoulder_bottom = max(1, int(h * 0.20))\n    torso_top = max(shoulder_bottom + 1, int(h * 0.25))\n    torso_bottom = max(torso_top + 1, int(h * 0.50))\n    shoulder_rows = mask[shoulder_top:shoulder_bottom, :]\n    torso_rows = mask[torso_top:torso_bottom, :]\n    if shoulder_rows.size == 0 or torso_rows.size == 0:\n        return 1.0\n    shoulder_widths = np.sum(shoulder_rows, axis=1).astype(float)\n    torso_widths = np.sum(torso_rows, axis=1).astype(float)\n    if np.mean(torso_widths) <= 1e-8:\n        return 1.0\n    ratio = float(np.mean(shoulder_widths) / (np.mean(torso_widths) + 1e-8))\n    return float(ratio)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Normalized absolute left-right mass difference in the lower half (trousers are usually symmetric -> low)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    if h < 2 or w < 2:\n        return 0.0\n    lower = gray[h//2:, :]\n    left = lower[:, :w//2].sum()\n    right = lower[:, (w - w//2):].sum()\n    total = left + right + 1e-9\n    return float(abs(left - right) / total)\n",
    "def feature(image: np.ndarray) -> float:\n    'Fraction of columns with object contact in the top 10% rows (indicates straps/tall top contact)'\n    try:\n        if len(image.shape) == 3:\n            gray = np.mean(image.astype(float), axis=2)\n        else:\n            gray = image.astype(float)\n    except Exception:\n        return 0.0\n    h, w = gray.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    top_rows = max(1, h // 10)\n    thr = (np.mean(gray) + np.min(gray)) / 2.0\n    top_mask = (gray[:top_rows, :] > thr)\n    col_contact = np.any(top_mask, axis=0)\n    frac = np.sum(col_contact) / float(w)\n    return float(frac)\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Bottom region left-right imbalance: absolute normalized difference between left and right bottom counts (0 = balanced)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    h, w = gray.shape[:2]\n    bottom_h = max(1, int(round(h * 0.2)))\n    thr = np.mean(gray)\n    mask = gray > thr\n    bottom = mask[h - bottom_h:h, :]\n    left_count = np.sum(bottom[:, : (w // 2)])\n    right_count = np.sum(bottom[:, (w // 2):])\n    total = left_count + right_count\n    if total == 0:\n        return 0.0\n    imbalance = abs(left_count - right_count) / float(total)\n    return float(imbalance)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Normalized top-vs-bottom mask imbalance: (top-bottom)/(top+bottom) in [-1,1]'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 50)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    if not np.any(mask):\n        return 0.0\n    mid = h // 2\n    top = float(np.count_nonzero(mask[:mid, :]))\n    bot = float(np.count_nonzero(mask[mid:, :]))\n    imbalance = (top - bot) / (top + bot + 1e-8)\n    return float(imbalance)\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Height-to-width aspect ratio of the mask bounding box (tall vs wide)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 50)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    ys, xs = np.where(mask)\n    if ys.size == 0:\n        return 0.0\n    miny, maxy = int(np.min(ys)), int(np.max(ys))\n    minx, maxx = int(np.min(xs)), int(np.max(xs))\n    height = float(maxy - miny + 1)\n    width = float(maxx - minx + 1)\n    return float((height + 1e-8) / (width + 1e-8))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Normalized bounding-box area of the foreground mask (0..1)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    idx = np.where(mask)\n    if idx[0].size == 0:\n        return 0.0\n    r0, r1 = int(np.min(idx[0])), int(np.max(idx[0]))\n    c0, c1 = int(np.min(idx[1])), int(np.max(idx[1]))\n    bbox_area = float((r1 - r0 + 1) * (c1 - c0 + 1))\n    img_area = float(max(1, h * w))\n    return float(bbox_area / img_area)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Normalized vertical centroid of the main mask (0 = top, 1 = bottom)'\n    import numpy as np\n    if image is None:\n        return 0.5\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.5\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    ys, xs = np.where(mask)\n    if ys.size == 0:\n        return 0.5\n    cy = float(np.mean(ys))\n    return float(cy / float(h + 1e-8))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Fraction of bottom-half object pixels connected to the bottom edge (higher => contiguous skirt/boot area)'\n    import numpy as np\n    from collections import deque\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    thr = float(np.mean(gray)) + 0.2 * (float(np.max(gray)) - float(np.mean(gray)))\n    mask = (gray > thr)\n    bottom_mask = mask[h//2:, :]\n    total_bottom = bottom_mask.sum()\n    if total_bottom == 0:\n        return 0.0\n    visited = np.zeros_like(mask, dtype=bool)\n    q = deque()\n    # enqueue all mask pixels on the bottom row(s)\n    for c in range(w):\n        if mask[h-1, c]:\n            visited[h-1, c] = True\n            q.append((h-1, c))\n    connected = 0\n    while q:\n        r, c = q.popleft()\n        if r >= h//2:\n            connected += 1\n        for dr, dc in ((1,0),(-1,0),(0,1),(0,-1)):\n            nr, nc = r+dr, c+dc\n            if 0 <= nr < h and 0 <= nc < w and (not visited[nr, nc]) and mask[nr, nc]:\n                visited[nr, nc] = True\n                q.append((nr, nc))\n    # connected bottom-area pixels divided by total bottom mask pixels\n    return float(connected / float(total_bottom))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Shoulder-to-hip mask width ratio (width at ~18% height divided by width at ~45% height)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 5 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    def row_width(row_index):\n        row = mask[min(h - 1, max(0, row_index)), :]\n        return float(np.count_nonzero(row))\n    shoulder_row = int(0.18 * h)\n    hip_row = int(0.45 * h)\n    shoulder_w = row_width(shoulder_row)\n    hip_w = row_width(hip_row)\n    if hip_w <= 1e-8:\n        return 0.0\n    return float((shoulder_w / hip_w))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Contrast between small top-corner shoulder patches and the top-center patch (detects collar flaps)'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    if h < 3 or w < 3:\n        return 0.0\n    top_h = max(1, h // 12)\n    strip_w = max(1, w // 12)\n    center = w // 2\n    # center top box\n    c0 = max(0, center - strip_w)\n    c1 = min(w, center + strip_w + 1)\n    center_box = gray[:top_h, c0:c1]\n    # left and right shoulder boxes\n    l0 = max(0, w // 8)\n    left_box = gray[:top_h, l0:l0 + strip_w]\n    r0 = max(0, w - (w // 8) - strip_w)\n    right_box = gray[:top_h, r0:r0 + strip_w]\n    center_mean = float(np.mean(center_box)) if center_box.size > 0 else 0.0\n    side_means = []\n    if left_box.size > 0:\n        side_means.append(np.mean(left_box))\n    if right_box.size > 0:\n        side_means.append(np.mean(right_box))\n    side_mean = float(np.mean(side_means)) if side_means else 0.0\n    eps = 1e-8\n    return float((side_mean - center_mean) / (np.mean(gray) + eps))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Mean gradient magnitude inside the object bounding box normalized by image contrast (texture/laces vs smooth)'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.mean(gray) + 0.2 * (np.max(gray) - np.min(gray))\n    mask = gray > thr\n    if not np.any(mask):\n        return 0.0\n    rows = np.any(mask, axis=1)\n    cols = np.any(mask, axis=0)\n    minr, maxr = np.where(rows)[0][0], np.where(rows)[0][-1]\n    minc, maxc = np.where(cols)[0][0], np.where(cols)[0][-1]\n    crop = gray[minr:maxr + 1, minc:maxc + 1]\n    # gradient magnitude\n    gy, gx = np.gradient(crop.astype(float))\n    grad_mag = np.sqrt(gx * gx + gy * gy)\n    # compute mean gradient only on object pixels\n    crop_mask = mask[minr:maxr + 1, minc:maxc + 1]\n    if np.sum(crop_mask) == 0:\n        return 0.0\n    mean_grad = np.mean(grad_mag[crop_mask])\n    contrast = (np.max(gray) - np.min(gray)) + 1e-9\n    return float(mean_grad / contrast)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Standard deviation of intensities in a narrow central vertical strip normalized by image std (detects button lines or texture)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape\n    global_std = float(np.std(gray))\n    mn, mx = float(np.min(gray)), float(np.max(gray))\n    if mx - mn < 1e-6 or global_std < 1e-9:\n        return 0.0\n    # central strip width 5% of image or at least 1\n    bw = max(1, w // 20)\n    c0 = (w - bw) // 2\n    strip = gray[:, c0:c0 + bw]\n    strip_std = float(np.std(strip))\n    return float(strip_std / (global_std + 1e-9))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Vertical top-bottom symmetry score of the foreground (1.0 = perfectly symmetric)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 2 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 50)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    top = mask[:h//2, :]\n    bottom = mask[h - (h//2):, :]\n    # flip bottom vertically to compare\n    bottom_flipped = np.flipud(bottom)\n    # crop to minimal overlapping height if sizes differ\n    mh = min(top.shape[0], bottom_flipped.shape[0])\n    if mh == 0:\n        return 0.0\n    top_c = top[:mh, :]\n    bot_c = bottom_flipped[:mh, :]\n    intersection = float(np.count_nonzero(top_c & bot_c))\n    union = float(np.count_nonzero(top_c | bot_c)) + 1e-8\n    score = intersection / union\n    return float(score)\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Columnar vertical stroke score in the top region: fraction of bbox columns with a long vertical run near the top (possible handles)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 50)\n    mask = (gray > thr).astype(np.uint8)\n    if not np.any(mask):\n        return 0.0\n    ys, xs = np.nonzero(mask)\n    rmin, rmax = ys.min(), ys.max()\n    cmin, cmax = xs.min(), xs.max()\n    bbox_h = rmax - rmin + 1\n    bbox_w = cmax - cmin + 1\n    if bbox_w <= 0 or bbox_h <= 0:\n        return 0.0\n    top_h = max(1, bbox_h // 5)\n    top_region = mask[rmin:rmin + top_h, cmin:cmax + 1]\n    count = 0\n    for col in range(top_region.shape[1]):\n        col_data = top_region[:, col]\n        # longest run of ones in this column\n        max_run = 0\n        run = 0\n        for v in col_data:\n            if v:\n                run += 1\n                if run > max_run:\n                    max_run = run\n            else:\n                run = 0\n        if max_run >= 0.6 * top_h:\n            count += 1\n    return float(count / bbox_w)\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Approximate perimeter-to-area ratio: number of edge foreground pixels divided by foreground area'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    thr = np.percentile(gray, 50)\n    fg = (gray > thr).astype(np.uint8)\n    area = np.count_nonzero(fg)\n    if area == 0:\n        return 0.0\n    h, w = fg.shape\n    # count foreground pixels that have at least one 4-neighbor background\n    pad = np.pad(fg, 1, mode='constant', constant_values=0)\n    edges = 0\n    for dy, dx in ((1,0),(-1,0),(0,1),(0,-1)):\n        neighbor = pad[1+dy:1+dy+h, 1+dx:1+dx+w]\n        edges += (fg & (neighbor == 0))\n    # any pixel with any zero neighbor contributes as an edge pixel (count once)\n    edge_pixels = np.count_nonzero(edges > 0)\n    return float(edge_pixels / float(area))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Vertical symmetry score (1.0 = perfectly symmetric, 0.0 = very asymmetric)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w < 2:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    # use mask to focus on foreground symmetry if possible\n    thr = np.percentile(gray, 50)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    half = w // 2\n    left = gray[:, :half]\n    right = gray[:, w - half:]\n    mask_l = mask[:, :half]\n    mask_r = mask[:, w - half:]\n    # flip right horizontally\n    right_flipped = np.fliplr(right)\n    mask_r_flipped = np.fliplr(mask_r)\n    # overlap where both masked (foreground on both sides)\n    overlap = mask_l & mask_r_flipped\n    if np.count_nonzero(overlap) < 10:\n        # fallback to full-image symmetry if foreground overlap too small\n        left_full = gray[:, :half]\n        right_full = np.fliplr(gray[:, w - half:])\n        diff = np.abs(left_full - right_full)\n        denom = (np.max(gray) - np.min(gray) + 1e-8)\n        if denom <= 1e-8:\n            return 1.0\n        score = 1.0 - float(np.mean(diff) / denom)\n        return float(max(0.0, min(1.0, score)))\n    diff = np.abs(left - right_flipped)\n    score = 1.0 - float(np.mean(diff[overlap]) / (np.max(gray) - np.min(gray) + 1e-8))\n    return float(max(0.0, min(1.0, score)))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Average width of the object in the bottom 20% of rows divided by bounding-box width (0..1)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape\n    thr = float(np.mean(gray) * 0.6 + np.min(gray) * 0.4)\n    mask = gray > thr\n    if not mask.any():\n        mask = gray >= np.max(gray)\n    rows = np.any(mask, axis=1)\n    if not rows.any():\n        return 0.0\n    top = int(np.argmax(rows))\n    bottom = int(h - 1 - np.argmax(rows[::-1]))\n    bbox_w = float(np.count_nonzero(np.any(mask[top:bottom + 1, :], axis=0)))\n    if bbox_w <= 0:\n        return 0.0\n    start = max(0, int(0.8 * h))\n    widths = []\n    for r in range(start, h):\n        cols = np.nonzero(mask[r, :])[0]\n        if cols.size > 0:\n            widths.append(float(cols.max() - cols.min() + 1))\n    if len(widths) == 0:\n        avg_width = 0.0\n    else:\n        avg_width = float(np.mean(widths))\n    return avg_width / bbox_w\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Lower-half width variability: normalized standard deviation of object widths per row in the lower half (flared skirts increase variability)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    rng = gray.max() - gray.min()\n    thr = np.mean(gray) + (0.12 * rng if rng > 0 else 0.0)\n    mask = gray > thr\n    start_row = h // 2\n    widths = []\n    for r in range(start_row, h):\n        row = mask[r, :]\n        if row.any():\n            cols = np.where(row)[0]\n            widths.append(float(cols[-1] - cols[0] + 1))\n    if not widths:\n        return 0.0\n    return float(np.std(widths) / max(1.0, w))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Fraction of mask pixels that touch the image border (0..1)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    total = np.count_nonzero(mask)\n    if total == 0:\n        return 0.0\n    border = np.zeros_like(mask, dtype=bool)\n    border[0, :] = mask[0, :]\n    border[-1, :] = mask[-1, :]\n    border[:, 0] = border[:, 0] | mask[:, 0]\n    border[:, -1] = border[:, -1] | mask[:, -1]\n    border_count = np.count_nonzero(border)\n    return float(border_count) / float(total)\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Vertical center-line edge energy: mean absolute horizontal gradient magnitude in a central vertical strip (high for shirts/plackets)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    if h < 3 or w < 3:\n        return 0.0\n    gy, gx = np.gradient(gray)\n    # central vertical strip\n    half = max(1, w // 20)\n    c = w // 2\n    strip = gx[:, max(0, c-half):min(w, c+half)]\n    val = float(np.mean(np.abs(strip)))\n    return val\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Normalized vertical centroid position (y coordinate of center of mass divided by image height)'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(np.float32)\n    else:\n        gray = image.astype(np.float32)\n    thr = np.mean(gray) + 0.25 * (np.max(gray) - np.min(gray))\n    mask = gray > thr\n    if np.count_nonzero(mask) == 0:\n        thr = np.mean(gray)\n        mask = gray > thr\n        if np.count_nonzero(mask) == 0:\n            return 0.5\n    ys, xs = np.where(mask)\n    centroid_y = float(np.mean(ys))\n    h = gray.shape[0]\n    return float(centroid_y / float(h))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Mean color saturation for RGB images (0 for grayscale) using (max-min)/max per-pixel'\n    import numpy as np\n    if image is None:\n        return 0.0\n    if len(image.shape) != 3 or image.shape[2] < 3:\n        return 0.0\n    img = image.astype(float)\n    r = img[:, :, 0]\n    g = img[:, :, 1]\n    b = img[:, :, 2]\n    mx = np.maximum(np.maximum(r, g), b)\n    mn = np.minimum(np.minimum(r, g), b)\n    denom = mx.copy()\n    denom[denom == 0] = 1.0\n    sat = (mx - mn) / denom\n    return float(np.mean(sat))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Mean horizontal symmetry (left vs flipped right) restricted to the bottom quarter of the object bbox (shoe toe/heel asymmetry)'\n    if image is None:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    thr = 0.5 * (np.mean(gray) + np.min(gray))\n    mask = gray > thr\n    ys, xs = np.where(mask)\n    if ys.size == 0:\n        return 1.0\n    r0, r1 = np.min(ys), np.max(ys)\n    c0, c1 = np.min(xs), np.max(xs)\n    bbox_h = r1 - r0 + 1\n    bottom_h = max(1, int(round(bbox_h * 0.25)))\n    sub = mask[r1 - bottom_h + 1:r1 + 1, c0:c1 + 1].astype(float)\n    if sub.size == 0:\n        return 1.0\n    # pad to symmetric width if odd\n    hh, ww = sub.shape\n    mid = ww // 2\n    left = sub[:, :mid]\n    right = sub[:, ww - mid:ww]\n    if left.size == 0 or right.size == 0:\n        return 1.0\n    diff = np.mean(np.abs(left - np.fliplr(right)))\n    # normalize by mean fill to avoid tiny values dominating\n    denom = max(1e-6, np.mean(sub))\n    return float(diff / denom)\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Ratio of mean gradient magnitude in upper third to lower third (edge density contrast)'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    gray = gray.astype(float)\n    h, w = gray.shape[:2]\n    # compute gradient magnitude\n    gy, gx = np.gradient(gray)\n    mag = np.hypot(gx, gy)\n    upper_h = max(1, h // 3)\n    lower_start = max(0, h - upper_h)\n    upper_mean = float(np.mean(mag[:upper_h, :]))\n    lower_mean = float(np.mean(mag[lower_start:, :]))\n    eps = 1e-8\n    return float(upper_mean / (lower_mean + eps))\n",
    "def feature(image: np.ndarray) -> float:\n    'Sum of absolute differences of mean RGB in left vs right halves normalized by global mean (0 if grayscale)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    if len(image.shape) != 3:\n        return 0.0\n    h, w, c = image.shape\n    if h == 0 or w == 0:\n        return 0.0\n    left = image[:, :w // 2, :].astype(float)\n    right = image[:, w - w // 2:, :].astype(float)\n    left_mean = np.mean(left, axis=(0, 1))\n    right_mean = np.mean(right, axis=(0, 1))\n    diff = np.abs(left_mean - right_mean)\n    denom = np.maximum(np.mean(image.astype(float)), 1e-8)\n    return float(np.sum(diff) / denom)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Fraction of image pixels belonging to the foreground mask (0..1)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 50)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    area = float(np.count_nonzero(mask))\n    return float(area / float(h * w + 1e-12))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Fraction of foreground pixels that lie in the bottom 15% of the image (shoe/boot indicator)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 50)\n    mask = ((gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)).astype(np.uint8)\n    total = float(np.count_nonzero(mask))\n    if total == 0:\n        return 0.0\n    bottom_h = max(1, int(np.ceil(0.15 * h)))\n    bottom_mask = mask[h - bottom_h:, :]\n    bottom_count = float(np.count_nonzero(bottom_mask))\n    return float(bottom_count / (total + 1e-8))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Aspect ratio (width / height) of the mask bounding box (0 if no mask)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 60)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    ys, xs = np.where(mask)\n    if ys.size == 0:\n        return 0.0\n    ymin, ymax = ys.min(), ys.max()\n    xmin, xmax = xs.min(), xs.max()\n    box_w = float(xmax - xmin + 1)\n    box_h = float(ymax - ymin + 1)\n    if box_h <= 1e-8:\n        return 0.0\n    return float(box_w / box_h)\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Ratio of mean absolute vertical gradient to mean absolute horizontal gradient in the upper third center region (captures vertical structure near shoulders)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(np.float32)\n    else:\n        gray = image.astype(np.float32)\n    h, w = gray.shape[:2]\n    if h < 3 or w < 3:\n        return 0.0\n    top_h = max(1, h // 3)\n    c0 = w // 4\n    c1 = max(c0 + 1, 3 * w // 4)\n    region = gray[0:top_h, c0:c1]\n    gy, gx = np.gradient(region.astype(np.float32))\n    vy = float(np.mean(np.abs(gy)))\n    vx = float(np.mean(np.abs(gx)))\n    if vx < 1e-6:\n        return float(vy / (vx + 1e-6))\n    return float(vy / vx)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Mask edge density: approximate perimeter (edge pixels) divided by mask area'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    mask_i = mask.astype(np.int32)\n    # horizontal transitions\n    dx = np.abs(np.diff(mask_i, axis=1))\n    dy = np.abs(np.diff(mask_i, axis=0))\n    edge_count = int(np.sum(dx) + np.sum(dy))\n    area = int(np.count_nonzero(mask_i))\n    if area == 0:\n        return 0.0\n    return float(edge_count / (area + 1e-8))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Texture contrast in the central torso region measured as normalized standard deviation (texture richness)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape\n    maxv = float(gray.max())\n    if maxv <= 0:\n        return 0.0\n    r1, r2 = h // 4, 3 * h // 4\n    c1, c2 = w // 4, 3 * w // 4\n    torso = gray[r1:r2, c1:c2].flatten()\n    if torso.size == 0:\n        return 0.0\n    return float(np.std(torso) / maxv)\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Number of connected foreground components in the bottom quarter (small integer)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask_full = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    start_row = (3 * h) // 4\n    mask = np.zeros_like(mask_full, dtype=bool)\n    mask[start_row:, :] = mask_full[start_row:, :]\n    visited = np.zeros_like(mask, dtype=bool)\n    comps = 0\n    for y in range(start_row, h):\n        for x in range(w):\n            if mask[y, x] and not visited[y, x]:\n                comps += 1\n                # flood fill limited to bottom area\n                stack = [(y, x)]\n                visited[y, x] = True\n                while stack:\n                    cy, cx = stack.pop()\n                    if cy > start_row and mask[cy - 1, cx] and not visited[cy - 1, cx]:\n                        visited[cy - 1, cx] = True\n                        stack.append((cy - 1, cx))\n                    if cy + 1 < h and mask[cy + 1, cx] and not visited[cy + 1, cx]:\n                        visited[cy + 1, cx] = True\n                        stack.append((cy + 1, cx))\n                    if cx > 0 and mask[cy, cx - 1] and not visited[cy, cx - 1]:\n                        visited[cy, cx - 1] = True\n                        stack.append((cy, cx - 1))\n                    if cx + 1 < w and mask[cy, cx + 1] and not visited[cy, cx + 1]:\n                        visited[cy, cx + 1] = True\n                        stack.append((cy, cx + 1))\n                if comps > 50:\n                    break\n        if comps > 50:\n            break\n    return float(comps)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Maximum horizontal centroid displacement from image center (normalized by width)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h <= 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    xs = np.arange(w).astype(float)\n    centroids = []\n    for r in range(h):\n        row = mask[r, :]\n        total = float(np.sum(row))\n        if total > 0.0:\n            centroids.append(float(np.sum(xs * row) / total))\n    if len(centroids) == 0:\n        return 0.0\n    centroids = np.array(centroids)\n    center = float(w) / 2.0\n    max_dev = float(np.max(np.abs(centroids - center)))\n    return float(max_dev / (w + 1e-8))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Center vs border edge energy: average gradient magnitude in center region divided by border region'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 3 or w < 3:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    gy, gx = np.gradient(gray.astype(float))\n    grad = np.sqrt(gx * gx + gy * gy)\n    # define center as middle 50% both axes\n    r0, r1 = h // 4, (3 * h) // 4\n    c0, c1 = w // 4, (3 * w) // 4\n    center = grad[r0:r1, c0:c1]\n    # border is outside that center\n    border_mask = np.ones_like(grad, dtype=bool)\n    border_mask[r0:r1, c0:c1] = False\n    border = grad[border_mask]\n    if center.size == 0 or border.size == 0:\n        return 0.0\n    cen_mean = float(np.mean(center))\n    bor_mean = float(np.mean(border)) + 1e-8\n    return float(cen_mean / bor_mean)\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Center-column intensity variability: standard deviation along the middle third of center column (captures button dot patterns)'\n    import numpy as np\n    import numpy as _np\n    eps = 1e-8\n    if len(image.shape) == 3:\n        gray = _np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    if h < 4 or w < 1:\n        return 0.0\n    center = w // 2\n    start = h // 3\n    end = min(h, start + max(1, h // 3))\n    column_segment = gray[start:end, center]\n    if column_segment.size == 0:\n        return 0.0\n    std_seg = float(_np.std(column_segment))\n    # normalize by overall intensity range\n    denom = (gray.max() - gray.min()) + eps\n    return float(std_seg / denom)\n",
    "def feature(image: np.ndarray) -> float:\n    'Mask compactness measured by isoperimetric ratio 4*pi*area / (perimeter^2) (0..~1)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    area = float(np.count_nonzero(mask))\n    if area == 0.0:\n        return 0.0\n    # approximate perimeter: mask pixels that have any 4-neighbor background\n    # pad to simplify edges\n    m = mask.astype(np.uint8)\n    pad = np.pad(m, ((1, 1), (1, 1)), mode='constant', constant_values=0)\n    perim = 0\n    perim += np.sum((pad[1:-1, 1:-1] == 1) & (pad[0:-2, 1:-1] == 0))\n    perim += np.sum((pad[1:-1, 1:-1] == 1) & (pad[2:, 1:-1] == 0))\n    perim += np.sum((pad[1:-1, 1:-1] == 1) & (pad[1:-1, 0:-2] == 0))\n    perim += np.sum((pad[1:-1, 1:-1] == 1) & (pad[1:-1, 2:] == 0))\n    perim = float(perim)\n    if perim <= 0.0:\n        return 0.0\n    iso = (4.0 * np.pi * area) / (perim * perim + 1e-12)\n    return float(iso)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Fraction of image rows that contain a strong horizontal edge concentration'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 3 or w < 3:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    gy, gx = np.gradient(gray.astype(float))\n    # gy corresponds to changes along rows => horizontal edges\n    row_edge_strength = np.mean(np.abs(gy), axis=1)\n    thresh = np.percentile(row_edge_strength, 70) if np.any(row_edge_strength) else 0.0\n    strong_rows = np.count_nonzero(row_edge_strength > thresh)\n    return float(strong_rows / float(h))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Fraction of strong vertical-gradient pixels in a central vertical band (captures zippers/seams length)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    gy, gx = np.gradient(gray.astype(float))\n    vert = np.abs(gx)  # horizontal derivative corresponds to vertical edges; vertical seam => strong gx\n    # central band\n    bw = max(1, w // 10)\n    cx = w // 2\n    band = vert[:, max(0, cx - bw):min(w, cx + bw)]\n    if band.size == 0:\n        return 0.0\n    # strong if > median + 0.75*IQR in band\n    med = np.median(band)\n    q1 = np.percentile(band, 25); q3 = np.percentile(band, 75)\n    iqr = max(1e-9, q3 - q1)\n    thr = med + 0.75 * iqr\n    strong = band > thr\n    # fraction of rows that contain at least one strong pixel (indicates vertical continuity)\n    rows_with_strong = np.sum(np.any(strong, axis=1))\n    frac = float(rows_with_strong / max(1, h))\n    return float(frac)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Compactness: perimeter^2 divided by area (higher = more outline relative to area)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 50)\n    mask = ((gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)).astype(bool)\n    area = float(np.count_nonzero(mask))\n    if area <= 0:\n        return 0.0\n    # perimeter approximated by counting mask pixels that have at least one 4-neighbor background\n    perim = 0\n    # pad to avoid bounds checks\n    pad = np.pad(mask, ((1, 1), (1, 1)), mode='constant', constant_values=False)\n    for dy, dx in ((-1,0),(1,0),(0,-1),(0,1)):\n        perim += np.sum(mask & ~pad[1+dy:1+dy+h,1+dx:1+dx+w])\n    # each border pixel counted at least once; perim is number of perimeter edges; make nonzero\n    perim = float(max(1, perim))\n    compact = (perim * perim) / (area + 1e-8)\n    return float(compact)\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Maximum horizontal contiguous mask span normalized by image width (max silhouette width)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    max_span = 0\n    for r in range(h):\n        row = mask[r, :].astype(int)\n        if np.any(row):\n            pad = np.concatenate(([0], row, [0]))\n            diff = np.diff(pad)\n            starts = np.where(diff == 1)[0]\n            ends = np.where(diff == -1)[0]\n            if ends.size > 0:\n                spans = ends - starts\n                max_span = max(max_span, int(np.max(spans)))\n    return float(max_span / float(w))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Ratio of low-frequency (block-averaged) variance to total image variance: higher means larger smooth regions (coats often large patches)'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    gray = gray.astype(float)\n    h, w = gray.shape\n    eps = 1e-8\n    # global variance\n    total_var = np.var(gray)\n    # block pooling to 8x8 (or as close as possible)\n    bh = max(1, h // 8)\n    bw = max(1, w // 8)\n    # crop to integer multiple\n    nh = (h // bh) * bh\n    nw = (w // bw) * bw\n    if nh == 0 or nw == 0:\n        return 0.0\n    cropped = gray[:nh, :nw]\n    pooled = cropped.reshape(nh // bh, bh, nw // bw, bw).mean(axis=(1,3))\n    pooled_var = np.var(pooled)\n    return float(pooled_var / (total_var + eps))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Coefficient of variation (std/mean) of per-column longest foreground run lengths'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = ((gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)).astype(bool)\n    if not np.any(mask):\n        return 0.0\n    max_runs = np.zeros(w, dtype=float)\n    for col in range(w):\n        col_vals = mask[:, col]\n        max_run = 0\n        cur = 0\n        for v in col_vals:\n            if v:\n                cur += 1\n                if cur > max_run:\n                    max_run = cur\n            else:\n                cur = 0\n        max_runs[col] = float(max_run)\n    mean_r = float(np.mean(max_runs))\n    std_r = float(np.std(max_runs))\n    if mean_r <= 1e-8:\n        return 0.0\n    return float(std_r / (mean_r + 1e-8))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Normalized vertical span of the main foreground (bounding box height / image height)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 50)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    ys, xs = np.where(mask)\n    if ys.size == 0:\n        return 0.0\n    span = float(np.max(ys) - np.min(ys) + 1)\n    return float(span / float(h))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Std of per-row mask widths in bottom 25% normalized by image width'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 2 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    bottom_start = max(0, h - max(1, h * 25 // 100))\n    bottom = mask[bottom_start:, :]\n    if bottom.size == 0:\n        return 0.0\n    widths = np.sum(bottom.astype(float), axis=1)\n    if widths.size == 0:\n        return 0.0\n    std_width = float(np.std(widths))\n    return float(std_width / (w + 1e-8))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Vertical centroid offset: (centroid_y - lower_half_centroid_y) normalized by bbox height (positive if lower mass is lower)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape\n    if h == 0 or w == 0:\n        return 0.0\n    thr = np.percentile(gray, 86)\n    mask = gray > thr\n    if mask.sum() < 6:\n        thr = np.mean(gray)\n        mask = gray > thr\n    if mask.sum() == 0:\n        return 0.0\n    rows, cols = np.where(mask)\n    top, bot = int(rows.min()), int(rows.max())\n    left, right = int(cols.min()), int(cols.max())\n    sub = mask[top:bot+1, left:right+1].astype(float)\n    H = sub.shape[0]\n    if H == 0:\n        return 0.0\n    ys, xs = np.where(sub > 0)\n    if ys.size == 0:\n        return 0.0\n    full_centroid = ys.mean()\n    lower_half = sub[H//2:, :]\n    ys2, xs2 = np.where(lower_half > 0)\n    if ys2.size == 0:\n        lower_centroid = full_centroid\n    else:\n        lower_centroid = (ys2.mean() + H//2)\n    # positive if lower mass has larger y (lower)\n    offset = (full_centroid - lower_centroid) / float(H + 1e-9)\n    return float(offset)\n",
    "def feature(image: np.ndarray) -> float:\n    'Ratio of width at 10% down from top to width at 30% down from top (captures any necking near top)'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    thr = np.mean(gray) + 0.08 * (np.max(gray) - np.min(gray) + 1e-9)\n    mask = gray > thr\n    if not np.any(mask):\n        return 1.0\n    ys, xs = np.where(mask)\n    top, bottom = ys.min(), ys.max()\n    left, right = xs.min(), xs.max()\n    bh = bottom - top + 1\n    if bh < 3:\n        return 1.0\n    def mean_width_at_frac(frac):\n        row = top + int(frac * (bh - 1))\n        band = mask[max(top, row - 1):min(bottom + 1, row + 2), left:right + 1]\n        cols = np.any(band, axis=0)\n        return float(np.count_nonzero(cols))\n    w10 = mean_width_at_frac(0.10)\n    w30 = mean_width_at_frac(0.30)\n    return float((w10 + 1e-6) / (w30 + 1e-6))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Aspect ratio (width / height) of the bounding box of the simple foreground mask'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 60)\n    mask = gray < thr if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else gray > thr\n    rows = np.any(mask, axis=1)\n    cols = np.any(mask, axis=0)\n    if not np.any(rows) or not np.any(cols):\n        return 0.0\n    rmin = int(np.argmax(rows))\n    rmax = int(len(rows) - 1 - np.argmax(rows[::-1]))\n    cmin = int(np.argmax(cols))\n    cmax = int(len(cols) - 1 - np.argmax(cols[::-1]))\n    bbox_h = max(1, rmax - rmin + 1)\n    bbox_w = max(1, cmax - cmin + 1)\n    return float(bbox_w / float(bbox_h + 1e-8))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Neckline notch depth: normalized drop at image center top vs shoulders (0..1)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 3 or w < 3:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = gray < thr if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else gray > thr\n    top_idx = np.full((w,), float(h - 1), dtype=float)\n    any_in_col = np.any(mask, axis=0)\n    if not np.any(any_in_col):\n        return 0.0\n    cols = np.where(any_in_col)[0]\n    for c in cols:\n        col = mask[:, c]\n        top_idx[c] = float(np.argmax(col))\n    center = w // 2\n    quarter = max(1, w // 8)\n    center_min = float(np.min(top_idx[max(0, center - quarter):min(w, center + quarter + 1)]))\n    left_shoulder = float(np.mean(top_idx[:max(1, w // 4)]))\n    right_shoulder = float(np.mean(top_idx[max(0, 3 * w // 4):]))\n    shoulder_avg = float((left_shoulder + right_shoulder) / 2.0)\n    depth = shoulder_avg - center_min\n    if depth <= 0:\n        return 0.0\n    return float(min(1.0, depth / (max(1.0, float(h)) * 0.5)))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Difference between bottom-quarter width and mid-third width (positive if flared at bottom)'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(np.float32)\n    else:\n        gray = image.astype(np.float32)\n    h, w = gray.shape[:2]\n    thr = np.mean(gray) + 0.25 * (np.max(gray) - np.min(gray))\n    mask = gray > thr\n    if np.count_nonzero(mask) == 0:\n        thr = np.mean(gray)\n        mask = gray > thr\n        if np.count_nonzero(mask) == 0:\n            return 0.0\n    # bottom quarter\n    bstart = max(0, h - h // 4)\n    bottom_region = mask[bstart:h, :]\n    bottom_cols = np.where(np.any(bottom_region, axis=0))[0]\n    bottom_width = float(bottom_cols.size)\n    # mid third\n    mstart = h // 3\n    mend = min(h, 2 * h // 3)\n    mid_region = mask[mstart:mend, :]\n    mid_cols = np.where(np.any(mid_region, axis=0))[0]\n    mid_width = float(mid_cols.size) if mid_cols.size > 0 else 0.0\n    result = float((bottom_width - mid_width) / float(w))\n    return result\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Normalized bottom flare: (mean width in bottom 90-98% rows minus mean width at mid 45-55%) / max(widths) (positive => flare)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    if h < 4 or w < 1:\n        return 0.0\n    thr = (np.max(gray) + np.min(gray)) / 2.0\n    mask_fore = gray > thr\n    if np.sum(mask_fore) > np.sum(~mask_fore):\n        mask = ~mask_fore\n    else:\n        mask = mask_fore\n    def mean_width(row_start, row_end):\n        widths = []\n        for r in range(row_start, min(row_end, h)):\n            cols = np.where(mask[r])[0]\n            if cols.size == 0:\n                continue\n            widths.append(cols.max() - cols.min() + 1)\n        return float(np.mean(widths)) if len(widths) > 0 else 0.0\n    bottom_mean = mean_width(int(0.90*h), h)\n    mid_mean = mean_width(int(0.45*h), int(0.55*h))\n    denom = max(1.0, max(bottom_mean, mid_mean))\n    return float((bottom_mean - mid_mean) / denom)\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Vertical symmetry score: normalized mean absolute difference between top and vertically flipped bottom (lower values mean more vertically symmetric)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    rng = float(np.max(gray) - np.min(gray))\n    if rng == 0:\n        return 0.0\n    thresh = float(np.mean(gray) + 0.15 * rng)\n    mask = gray >= thresh\n    if np.count_nonzero(mask) == 0:\n        mask = gray > np.min(gray)\n    rows = np.any(mask, axis=1)\n    cols = np.any(mask, axis=0)\n    if not np.any(rows) or not np.any(cols):\n        return 1.0\n    r0, r1 = np.argmax(rows), len(rows) - 1 - np.argmax(rows[::-1])\n    c0, c1 = np.argmax(cols), len(cols) - 1 - np.argmax(cols[::-1])\n    region = gray[r0:r1+1, c0:c1+1].astype(float)\n    h = region.shape[0]\n    if h < 2:\n        return 1.0\n    mid = h // 2\n    top = region[:mid, :]\n    bottom = region[-mid:, :]\n    bottom_flipped = bottom[::-1, :]\n    # ensure same shape\n    if top.shape != bottom_flipped.shape:\n        minr = min(top.shape[0], bottom_flipped.shape[0])\n        top = top[:minr, :]\n        bottom_flipped = bottom_flipped[:minr, :]\n    diff = np.abs(top - bottom_flipped)\n    score = np.mean(diff) / (rng + 1e-8)\n    return float(score)\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Mean chroma (max - min across RGB channels) normalized by image dynamic range (0 for grayscale)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    if len(image.shape) != 3 or image.shape[2] < 3:\n        return 0.0\n    img = image.astype(float)\n    maxc = np.max(img, axis=2)\n    minc = np.min(img, axis=2)\n    chroma = maxc - minc\n    mean_chroma = float(np.mean(chroma))\n    denom = float(np.maximum(1.0, np.max(img) - np.min(img)))\n    return float(mean_chroma / denom)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Average normalized horizontal width of the object in the middle half (body width proxy)'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    thresh = np.mean(gray) + 0.25 * np.std(gray)\n    mask = gray > thresh\n    if np.count_nonzero(mask) == 0:\n        mask = gray > np.mean(gray)\n    rows = np.any(mask, axis=1)\n    if not rows.any():\n        return 0.0\n    r_indices = np.where(rows)[0]\n    rmin, rmax = r_indices[0], r_indices[-1]\n    mid_start = rmin + (rmax - rmin) // 4\n    mid_end = rmax - (rmax - rmin) // 4\n    widths = []\n    for r in range(mid_start, mid_end + 1):\n        cols = np.where(mask[r, :])[0]\n        if cols.size:\n            widths.append(cols[-1] - cols[0] + 1)\n    if not widths:\n        return 0.0\n    bbox_width = max(1, np.max(widths))\n    return float(np.mean(widths) / bbox_width)\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Vertical symmetry score computed on the binary mask (1.0 = perfect symmetry)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    mid = w // 2\n    left = mask[:, :mid].astype(float)\n    right = mask[:, w - left.shape[1]:].astype(float)\n    # flip right to align\n    right_flipped = right[:, ::-1]\n    total = np.sum(left) + np.sum(right_flipped) + 1e-8\n    diff = np.sum(np.abs(left - right_flipped))\n    score = 1.0 - (diff / total)\n    return float(score)\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Fraction of object pixels located in the bottom 30% of the object bounding box (helps detect low-profile shoes)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    mn, mx = float(np.min(gray)), float(np.max(gray))\n    if mx - mn < 1e-6:\n        return 0.0\n    thr = (mn + mx) / 2.0\n    mask = gray > thr\n    if not mask.any():\n        return 0.0\n    rows = np.any(mask, axis=1)\n    cols = np.any(mask, axis=0)\n    r_inds = np.where(rows)[0]\n    c_inds = np.where(cols)[0]\n    if r_inds.size == 0 or c_inds.size == 0:\n        return 0.0\n    r0, r1 = r_inds[0], r_inds[-1]\n    h = r1 - r0 + 1\n    bottom_start = r1 - max(0, int(np.ceil(0.3 * h))) + 1\n    bottom_slice = mask[bottom_start:r1+1, c_inds[0]:c_inds[-1]+1]\n    if bottom_slice.size == 0:\n        return 0.0\n    return float(bottom_slice.sum()) / float(mask.sum())\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Relative mid-frequency vertical pattern energy (detects stripes) from column profile FFT'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if w < 4:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    col_profile = np.mean(gray, axis=0)\n    col_profile = col_profile - np.mean(col_profile)\n    # real FFT\n    spec = np.abs(np.fft.rfft(col_profile))\n    total = np.sum(spec) + 1e-8\n    # exclude DC (freq 0) and very high freqs; look at mid-range (2..min(6, len-1))\n    n = spec.size\n    lo = 2\n    hi = min(6, n - 1)\n    if hi < lo:\n        return 0.0\n    mid_energy = np.sum(spec[lo:hi + 1])\n    result = mid_energy / total\n    return float(result)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Fraction of foreground mask pixels located in the top 50% of image rows'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    # grayscale conversion\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 50)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    total = float(np.count_nonzero(mask))\n    if total <= 0.0:\n        return 0.0\n    top_cut = max(1, h // 2)\n    top_mass = float(np.count_nonzero(mask[:top_cut, :]))\n    return float(top_mass / total)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Relative top-edge gradient prominence: mean vertical gradient magnitude in top band / full image'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 2 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    gy, gx = np.gradient(gray.astype(float))\n    grad_mag = np.sqrt(gx * gx + gy * gy)\n    top_h = max(1, int(0.12 * h))\n    top_band = grad_mag[:top_h, :]\n    mean_top = float(np.mean(top_band)) if top_band.size > 0 else 0.0\n    mean_all = float(np.mean(grad_mag)) if grad_mag.size > 0 else 1.0\n    denom = max(1e-8, mean_all)\n    return float(mean_top / denom)\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Aspect ratio (width / height) of the mask bounding box (1.0 if undefined)'\n    import numpy as np\n    if image is None:\n        return 1.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 1.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    idx = np.where(mask)\n    if idx[0].size == 0:\n        return 1.0\n    r0, r1 = int(np.min(idx[0])), int(np.max(idx[0]))\n    c0, c1 = int(np.min(idx[1])), int(np.max(idx[1]))\n    bbox_h = float(max(1, r1 - r0 + 1))\n    bbox_w = float(max(1, c1 - c0 + 1))\n    return float(bbox_w / bbox_h)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Depth of the top-center indentation relative to top-sides (positive if center is more indented \u2014 V-neck or open coat)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape\n    mn, mx = float(np.min(gray)), float(np.max(gray))\n    if mx - mn < 1e-6:\n        return 0.0\n    thr = mn + 0.20 * (mx - mn)\n    mask = gray > thr\n    if not mask.any():\n        return 0.0\n    rows, cols = np.where(mask)\n    r0, r1 = rows.min(), rows.max() + 1\n    c0, c1 = cols.min(), cols.max() + 1\n    # compute topmost object row per column in top quarter of bounding box\n    top_limit = r0 + max(1, (r1 - r0) // 4)\n    col_top_positions = []\n    for col in range(c0, c1):\n        col_mask = mask[r0:top_limit, col]\n        if col_mask.any():\n            toppos = r0 + np.argmax(col_mask)\n        else:\n            toppos = top_limit  # no object in that column -> deep indentation\n        col_top_positions.append(toppos)\n    col_top_positions = np.array(col_top_positions, dtype=float)\n    bw = c1 - c0\n    left_mean = col_top_positions[:max(1, bw // 6)].mean()\n    center_start = max(0, (bw // 2) - max(1, bw // 12))\n    center_end = min(bw, center_start + max(1, bw // 6))\n    center_mean = col_top_positions[center_start:center_end].mean()\n    right_mean = col_top_positions[-max(1, bw // 6):].mean()\n    side_mean = float((left_mean + right_mean) / 2.0)\n    # positive if center is lower (indented) than sides\n    return float((center_mean - side_mean) / float(max(1.0, h)))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Normalized vertical centroid of the mask (0=top, 1=bottom)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 50)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    ys, xs = np.where(mask)\n    if ys.size == 0:\n        return 0.5\n    centroid_y = float(np.mean(ys))\n    result = centroid_y / float(max(1, h - 1))\n    return float(result)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Row-wise width variation: coefficient of variation (std/mean) of foreground widths per row inside the bounding box'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.mean(gray) + 0.2 * (np.max(gray) - np.mean(gray))\n    mask = gray > thr\n    if np.count_nonzero(mask) == 0:\n        mask = gray > np.percentile(gray, 90)\n    if np.count_nonzero(mask) == 0:\n        return 0.0\n    ys, xs = np.where(mask)\n    ymin, ymax = ys.min(), ys.max()\n    xmin, xmax = xs.min(), xs.max()\n    bbox = mask[ymin:ymax+1, xmin:xmax+1].astype(float)\n    row_widths = np.sum(bbox, axis=1)\n    mean_w = np.mean(row_widths)\n    std_w = np.std(row_widths)\n    if mean_w == 0:\n        return 0.0\n    cov = std_w / mean_w\n    return float(cov)\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Ratio of horizontal-dominant edge pixels to vertical-dominant edge pixels'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 2 or w < 2:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    gy, gx = np.gradient(gray.astype(float))\n    grad_mag = np.sqrt(gx * gx + gy * gy)\n    thresh = np.percentile(grad_mag, 60) if np.any(grad_mag) else 0.0\n    strong = grad_mag > thresh\n    if not np.any(strong):\n        return 0.0\n    horiz = np.count_nonzero(strong & (np.abs(gy) > np.abs(gx)))\n    vert = np.count_nonzero(strong & (np.abs(gx) >= np.abs(gy)))\n    return float(horiz / (vert + 1e-8))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Foreground solidity: mask area divided by its bounding-box area (0..1)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    area = float(np.count_nonzero(mask))\n    if area == 0:\n        return 0.0\n    ys, xs = np.where(mask)\n    miny, maxy = int(np.min(ys)), int(np.max(ys))\n    minx, maxx = int(np.min(xs)), int(np.max(xs))\n    bbox_area = float(max(1, (maxy - miny + 1)) * max(1, (maxx - minx + 1)))\n    return float(area / (bbox_area + 1e-8))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Top-heaviness index: 1.0 if mass concentrated at top, 0.0 if at bottom (based on mask centroid)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 50)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    ys, xs = np.where(mask)\n    if ys.size == 0:\n        return 0.0\n    center_y = float(np.mean(ys))\n    # top-heavy => center_y small => index close to 1\n    idx = 1.0 - (center_y / float(max(1, h - 1)))\n    return float(idx)\n",
    "def feature(image: np.ndarray) -> float:\n    'Mean per-pixel color saturation (max-min across RGB channels), 0 for grayscale'\n    import numpy as np\n    if image is None:\n        return 0.0\n    if len(image.shape) != 3 or image.shape[2] < 3:\n        return 0.0\n    img = image.astype(float)\n    mx = np.max(img, axis=2)\n    mn = np.min(img, axis=2)\n    sat = mx - mn\n    # normalize by dynamic range if possible\n    denom = np.maximum(1.0, np.max(sat))\n    return float(np.mean(sat) / denom)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Normalized vertical entropy of the mask projection (0 concentrated -> 1 spread)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 2:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 50)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    row_sums = np.sum(mask, axis=1).astype(float)\n    total = float(np.sum(row_sums))\n    if total <= 0:\n        return 0.0\n    p = row_sums / total\n    p_nonzero = p[p > 0]\n    entropy = -float(np.sum(p_nonzero * np.log(p_nonzero)))\n    # normalize by log(number of rows)\n    denom = float(np.log(max(2, p.size)))\n    return float(entropy / (denom + 1e-8))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Median thickness of the object from the bottom of the bbox upwards per column (estimates sole/base thickness)'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    thresh = np.percentile(gray, 50)\n    binary = gray > thresh\n    ys, xs = np.nonzero(binary)\n    if ys.size == 0:\n        return 0.0\n    y0, y1 = ys.min(), ys.max()\n    x0, x1 = xs.min(), xs.max()\n    bbox = binary[y0:y1+1, x0:x1+1]\n    h, w = bbox.shape\n    thicknesses = []\n    # for each column in bbox, count consecutive foreground from bottom upward\n    for col in range(w):\n        col_data = bbox[:, col]\n        # start from bottom (index h-1) and count consecutive ones\n        count = 0\n        r = h - 1\n        while r >= 0 and col_data[r]:\n            count += 1\n            r -= 1\n        thicknesses.append(count)\n    if not thicknesses:\n        return 0.0\n    median_thick = float(np.median(thicknesses))\n    return float(median_thick / (h + 1e-6))\n",
    "def feature(image: np.ndarray) -> float:\n    'Mean number of foreground runs per column (captures multi-part silhouettes like sleeves)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    runs = []\n    for c in range(w):\n        col = mask[:, c]\n        run_count = 0\n        in_run = False\n        for v in col:\n            if v and not in_run:\n                run_count += 1\n                in_run = True\n            elif not v:\n                in_run = False\n        runs.append(run_count)\n    if len(runs) == 0:\n        return 0.0\n    return float(np.mean(runs))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Fraction of mask pixels located in the bottom left + right corner boxes (shoe indicator)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 2 or w < 2:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    total = np.count_nonzero(mask)\n    if total == 0:\n        return 0.0\n    box_h = max(1, int(h * 0.15))\n    box_w = max(1, int(w * 0.2))\n    bottom_start = h - box_h\n    left_box = mask[bottom_start:h, 0:box_w]\n    right_box = mask[bottom_start:h, w - box_w:w]\n    count = float(np.count_nonzero(left_box) + np.count_nonzero(right_box))\n    return float(count / (total + 1e-8))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Ratio of mass in top 30% of image to mass in bottom 30% (higher => top-heavy)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 3:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    top_cut = int(max(1, np.round(h * 0.3)))\n    bottom_start = int(max(1, np.round(h * 0.7)))\n    top_mass = float(np.count_nonzero(mask[:top_cut, :]))\n    bottom_mass = float(np.count_nonzero(mask[bottom_start:, :]))\n    return float(top_mass / (bottom_mass + 1e-8))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Vertical symmetry score (1.0 = perfectly symmetric, 0.0 = fully asymmetric) based on mask'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    # flip horizontally\n    flip = np.fliplr(mask)\n    # center alignment if odd width, compare overlapping region\n    min_w = min(mask.shape[1], flip.shape[1])\n    left = mask[:, :min_w]\n    right = flip[:, :min_w]\n    if left.size == 0:\n        return 0.0\n    diff = np.count_nonzero(left != right)\n    total = left.size\n    return float(1.0 - (diff / float(total)))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Average number of foreground segments per row within the object bbox (higher if multiple disconnected parts)'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    thr = np.mean(gray) + 0.45 * np.std(gray)\n    mask = gray > thr\n    if not np.any(mask):\n        return 0.0\n    rows = np.any(mask, axis=1)\n    cols = np.any(mask, axis=0)\n    r_idxs = np.where(rows)[0]\n    c_idxs = np.where(cols)[0]\n    if r_idxs.size == 0 or c_idxs.size == 0:\n        return 0.0\n    r0, r1 = r_idxs[0], r_idxs[-1] + 1\n    c0, c1 = c_idxs[0], c_idxs[-1] + 1\n    bb = mask[r0:r1, c0:c1]\n    seg_counts = []\n    for row in bb:\n        # count transitions from 0->1 segments\n        transitions = np.diff(row.astype(np.int8))\n        starts = np.count_nonzero(transitions == 1)\n        # if row starts with a foreground pixel\n        if row[0]:\n            starts += 1\n        seg_counts.append(starts)\n    return float(np.mean(seg_counts)) if len(seg_counts) > 0 else 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Corner occupancy: fraction of mask pixels located within 10% image margin corners'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    total = float(np.count_nonzero(mask))\n    if total <= 0:\n        return 0.0\n    mh = max(1, int(0.10 * h))\n    mw = max(1, int(0.10 * w))\n    corners = 0\n    corners += np.count_nonzero(mask[:mh, :mw])\n    corners += np.count_nonzero(mask[:mh, w - mw: w])\n    corners += np.count_nonzero(mask[h - mh: h, :mw])\n    corners += np.count_nonzero(mask[h - mh: h, w - mw: w])\n    return float(corners / total)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Ratio of shoulder (upper quarter) horizontal span to mid-body (middle third) horizontal span'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    if h < 4:\n        return 0.0\n    thr = np.mean(gray) + 0.15 * (np.max(gray) - np.min(gray))\n    mask = gray > thr\n    if not mask.any():\n        mask = gray > np.mean(gray)\n        if not mask.any():\n            return 0.0\n    upper = mask[0:h//4, :]\n    middle = mask[h//3:2*h//3, :]\n    def span(region):\n        cols = np.any(region, axis=0)\n        if not cols.any():\n            return 0.0\n        left = np.argmax(cols)\n        right = len(cols) - 1 - np.argmax(cols[::-1])\n        return float(right - left + 1)\n    up_span = span(upper)\n    mid_span = span(middle)\n    return float(up_span / (mid_span + 1e-8))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Mean saturation in the central region (RGB only), 0 for grayscale'\n    import numpy as np\n    if image is None:\n        return 0.0\n    if len(image.shape) != 3 or image.shape[2] < 3:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    img = image.astype(float)\n    R = img[:, :, 0]\n    G = img[:, :, 1]\n    B = img[:, :, 2]\n    maxc = np.maximum(np.maximum(R, G), B)\n    minc = np.minimum(np.minimum(R, G), B)\n    sat = (maxc - minc) / (maxc + 1e-8)\n    ch = h // 4\n    cw = w // 4\n    center = sat[ch: h - ch if h - ch > ch else h, cw: w - cw if w - cw > cw else w]\n    if center.size == 0:\n        return 0.0\n    return float(np.mean(center))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Rectangularity of the central torso region: mask area fraction within its bounding rectangle (higher = more boxy/rectangular)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    mask = gray > 0\n    if not np.any(mask):\n        return 0.0\n    rows = np.any(mask, axis=1)\n    cols = np.any(mask, axis=0)\n    rmin, rmax = np.argmax(rows), len(rows) - 1 - np.argmax(rows[::-1])\n    cmin, cmax = np.argmax(cols), len(cols) - 1 - np.argmax(cols[::-1])\n    bh = max(1, rmax - rmin + 1)\n    bw = max(1, cmax - cmin + 1)\n    # central torso rectangle: middle 60% height and 70% width\n    th = max(1, bh * 60 // 100)\n    tw = max(1, bw * 70 // 100)\n    r1 = rmin + (bh - th)//2\n    c1 = cmin + (bw - tw)//2\n    central = mask[r1:r1+th, c1:c1+tw]\n    if central.size == 0:\n        return 0.0\n    area = np.sum(central)\n    rect_area = central.size\n    return float(area / (rect_area + 1e-9))\n",
    "def feature(image: np.ndarray) -> float:\n    'Colorfulness metric (higher for vivid colored items), 0 for grayscale inputs'\n    import numpy as np\n    if image is None:\n        return 0.0\n    if len(image.shape) != 3 or image.shape[2] != 3:\n        return 0.0\n    img = image.astype(float)\n    R = img[:, :, 0]\n    G = img[:, :, 1]\n    B = img[:, :, 2]\n    rg = R - G\n    yb = 0.5 * (R + G) - B\n    std_rg = float(np.std(rg))\n    std_yb = float(np.std(yb))\n    mean_rg = float(np.mean(rg))\n    mean_yb = float(np.mean(yb))\n    # Has been used in literature: colorfulness = sqrt(std^2 + mean^2) summed\n    col = np.sqrt(std_rg * std_rg + mean_rg * mean_rg) + np.sqrt(std_yb * std_yb + mean_yb * mean_yb)\n    # Normalize roughly by 255\n    return float(col / (255.0 + 1e-8))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Count of small horizontal segments in the upper torso area (possible pockets/buttons)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 4 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    top_start = max(0, int(h * 0.10))\n    top_end = max(top_start + 1, int(h * 0.40))\n    region = mask[top_start:top_end, :]\n    if region.size == 0:\n        return 0.0\n    seg_count = 0\n    min_len = max(1, w // 30)\n    max_len = max(1, w // 3)\n    for row in region:\n        row_i = row.astype(int)\n        if not np.any(row_i):\n            continue\n        pad = np.concatenate(([0], row_i, [0]))\n        diff = np.diff(pad)\n        starts = np.where(diff == 1)[0]\n        ends = np.where(diff == -1)[0]\n        lengths = ends - starts\n        seg_count += int(np.sum((lengths >= min_len) & (lengths <= max_len)))\n    norm = float(max(1.0, (top_end - top_start)))\n    return float(seg_count / norm)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Waist indentation: how much the narrowest mid-body row is indented relative to average body width (higher -> more hourglass)'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    thr = np.percentile(gray, 75)\n    mask = gray > thr\n    if np.count_nonzero(mask) == 0:\n        thr = gray.mean()\n        mask = gray > thr\n    mid_top = max(0, h//3)\n    mid_bottom = min(h, (2*h)//3)\n    widths = []\n    for r in range(mid_top, mid_bottom):\n        cols = np.where(mask[r, :])[0]\n        if cols.size:\n            widths.append(cols.max() - cols.min() + 1)\n    if not widths:\n        return 0.0\n    mean_w = float(np.mean(widths))\n    min_w = float(np.min(widths))\n    if mean_w <= 0:\n        return 0.0\n    indentation = 1.0 - (min_w / mean_w)\n    return float(indentation)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Central strip occupancy: fraction of object pixels that lie within the central 20% vertical strip (high for shirts/dresses, low for trousers with separated legs)'\n    import numpy as np\n    gray = np.mean(image, axis=2) if len(image.shape) == 3 else image.astype(float)\n    h, w = gray.shape[:2]\n    thr = np.mean(gray) + 0.12 * (np.max(gray) - np.min(gray))\n    mask = gray > thr\n    total = float(np.count_nonzero(mask))\n    if total == 0:\n        return 0.0\n    cs = max(1, int(0.2 * w))\n    c0 = max(0, (w - cs) // 2)\n    c1 = min(w, c0 + cs)\n    center_count = float(np.count_nonzero(mask[:, c0:c1]))\n    return float(center_count / total)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Average number of foreground segments per column (useful to detect two-legged pants)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 2 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = ((gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)).astype(np.uint8)\n    seg_counts = []\n    for col in range(w):\n        colv = mask[:, col]\n        if colv.size == 0:\n            seg_counts.append(0)\n            continue\n        # count transitions from 0->1 as segment starts\n        starts = np.sum((colv == 1) & (np.concatenate(([0], colv[:-1])) == 0))\n        seg_counts.append(int(starts))\n    if len(seg_counts) == 0:\n        return 0.0\n    return float(np.mean(seg_counts))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Fraction of mask pixels located in the bottom 20% of the image (shoe/trouser indicator)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    total_mask = float(np.count_nonzero(mask))\n    if total_mask == 0:\n        return 0.0\n    bottom_h = max(1, int(0.20 * h))\n    bottom_mask = mask[h - bottom_h:, :]\n    bottom_count = float(np.count_nonzero(bottom_mask))\n    return float(bottom_count / (total_mask + 1e-8))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Count of dark vertical streaks in the center region (indicative of buttons/openings), normalized by bbox height'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    m, med, s = np.mean(gray), np.median(gray), np.std(gray)\n    thr = 0.5*(m + med)\n    fg = gray >= thr if m > med else gray <= thr\n    rows_any = np.any(fg, axis=1)\n    cols_any = np.any(fg, axis=0)\n    if not np.any(rows_any) or not np.any(cols_any):\n        return 0.0\n    r0 = np.argmax(rows_any)\n    r1 = len(rows_any) - 1 - np.argmax(rows_any[::-1])\n    c0 = np.argmax(cols_any)\n    c1 = len(cols_any) - 1 - np.argmax(cols_any[::-1])\n    # define torso central region (center 30% width, middle 60% height)\n    w = c1 - c0 + 1\n    h = r1 - r0 + 1\n    cc0 = c0 + int(0.35 * w)\n    cc1 = c0 + int(0.65 * w)\n    rr0 = r0 + int(0.2 * h)\n    rr1 = r0 + int(0.8 * h)\n    rr0 = min(rr0, r1)\n    rr1 = max(rr1, rr0)\n    # detect darker-than-local torso pixels (buttons/darker line)\n    torso = gray[rr0:rr1+1, cc0:cc1+1]\n    if torso.size == 0:\n        return 0.0\n    local_mean = np.mean(torso)\n    local_std = np.std(torso) + 1e-6\n    dark_mask = torso < (local_mean - 0.25 * local_std)\n    # count vertical runs per column and average\n    counts = []\n    for col in range(dark_mask.shape[1]):\n        col_vec = dark_mask[:, col].astype(int)\n        # count 0->1 transitions\n        transitions = np.sum((col_vec[1:] > col_vec[:-1]) & (col_vec[1:] == 1))\n        counts.append(transitions)\n    avg_counts = float(np.mean(counts)) if counts else 0.0\n    return float(avg_counts / max(1.0, h))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Horizontal symmetry of the foreground mask (1.0 = perfectly symmetric)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    # grayscale for mask\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 50)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    total = np.count_nonzero(mask)\n    if total == 0:\n        return 0.0\n    flipped = np.fliplr(mask)\n    overlap = np.count_nonzero(mask & flipped)\n    return float(overlap / float(total + 1e-8))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Number of connected components in binary mask (4-neighbor), normalized by image height'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    visited = np.zeros_like(mask, dtype=bool)\n    comps = 0\n    # iterate\n    for yi in range(h):\n        row = mask[yi]\n        for xi in range(w):\n            if row[xi] and not visited[yi, xi]:\n                comps += 1\n                # flood fill stack\n                stack = [(yi, xi)]\n                visited[yi, xi] = True\n                while stack:\n                    y, x = stack.pop()\n                    # 4-neighbors\n                    if y > 0 and mask[y - 1, x] and not visited[y - 1, x]:\n                        visited[y - 1, x] = True\n                        stack.append((y - 1, x))\n                    if y + 1 < h and mask[y + 1, x] and not visited[y + 1, x]:\n                        visited[y + 1, x] = True\n                        stack.append((y + 1, x))\n                    if x > 0 and mask[y, x - 1] and not visited[y, x - 1]:\n                        visited[y, x - 1] = True\n                        stack.append((y, x - 1))\n                    if x + 1 < w and mask[y, x + 1] and not visited[y, x + 1]:\n                        visited[y, x + 1] = True\n                        stack.append((y, x + 1))\n    return float(comps / max(1.0, float(h)))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Left-right symmetry score of the main object (1.0 = perfectly symmetric)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    if not np.any(mask):\n        return 0.0\n    flipped = np.fliplr(gray)\n    flipped_mask = np.fliplr(mask)\n    common = mask & flipped_mask\n    if not np.any(common):\n        # fall back to compare within mask union\n        common = mask | flipped_mask\n    diff = np.abs(gray - flipped)\n    # measure normalized mean absolute difference over the chosen region\n    denom = (np.mean(np.abs(gray[common])) + 1e-8)\n    score = 1.0 - (np.mean(diff[common]) / denom)\n    return float(max(0.0, min(1.0, score)))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Difference in width between middle-third and upper-third (positive if middle is wider than upper, captures mid-body narrowing or flaring)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    if h < 6:\n        return 0.0\n    thr = np.mean(gray) + 0.15 * (np.max(gray) - np.min(gray))\n    mask = gray > thr\n    if not mask.any():\n        mask = gray > np.mean(gray)\n        if not mask.any():\n            return 0.0\n    upper = mask[0:h//3, :]\n    middle = mask[h//3:2*h//3, :]\n    def span(region):\n        cols = np.any(region, axis=0)\n        if not cols.any():\n            return 0.0\n        left = np.argmax(cols)\n        right = len(cols) - 1 - np.argmax(cols[::-1])\n        return float(right - left + 1)\n    up_span = span(upper)\n    mid_span = span(middle)\n    return float((mid_span - up_span) / (w + 1e-8))\n",
    "def feature(image: np.ndarray) -> float:\n    'Width of the object at mid-height normalized by its bounding-box width (captures narrow straps vs broad bodies)'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.mean(gray) + 0.2 * (np.max(gray) - np.min(gray))\n    mask = gray > thr\n    if not np.any(mask):\n        return 0.0\n    rows = np.any(mask, axis=1)\n    cols = np.any(mask, axis=0)\n    minr, maxr = np.where(rows)[0][0], np.where(rows)[0][-1]\n    minc, maxc = np.where(cols)[0][0], np.where(cols)[0][-1]\n    mid_row = (minr + maxr) // 2\n    row_slice = mask[mid_row, minc:maxc + 1]\n    if np.sum(row_slice) == 0:\n        return 0.0\n    # contiguous run length of ones (largest connected horizontal run)\n    runs = np.where(np.concatenate(([0], row_slice.astype(int), [0])) == 1)[0]\n    if runs.size == 0:\n        run_len = 0\n    else:\n        # runs contains start and end indices pairs\n        runs_idx = np.where(np.diff(np.concatenate(([0], row_slice.astype(int), [0]))) == 1)[0]\n        ends = np.where(np.diff(np.concatenate(([0], row_slice.astype(int), [0]))) == -1)[0]\n        run_lengths = ends - runs_idx\n        run_len = np.max(run_lengths) if run_lengths.size else 0\n    bbox_w = max(1, maxc - minc + 1)\n    return float(run_len / bbox_w)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Left-right vertical symmetry inside the object bounding box (lower = more symmetric); normalized difference'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    med = float(np.median(gray))\n    mask = (gray > med) if float(np.mean(gray)) > med else (gray < med)\n    inds = np.argwhere(mask)\n    if inds.size == 0:\n        return 0.0\n    rmin, cmin = inds.min(0)\n    rmax, cmax = inds.max(0)\n    # crop bounding box\n    crop = gray[rmin:rmax+1, cmin:cmax+1].astype(float)\n    ch, cw = crop.shape\n    if cw < 2:\n        return 0.0\n    half = cw // 2\n    left = crop[:, :half]\n    right = crop[:, cw-half:][:, ::-1]  # mirror right to compare\n    # pad smaller side\n    if left.shape[1] != right.shape[1]:\n        minw = min(left.shape[1], right.shape[1])\n        left = left[:, :minw]\n        right = right[:, :minw]\n    # normalized mean absolute difference\n    denom = np.mean(np.abs(crop)) + 1e-6\n    mad = np.mean(np.abs(left - right))\n    return float(mad / denom)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Fraction of rows in the upper 25% that show two opposing mask segments separated by a central gap'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = ((gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)).astype(np.uint8)\n    end_row = max(1, int(h * 0.25))\n    rows = mask[:end_row, :]\n    if rows.size == 0:\n        return 0.0\n    count = 0\n    for r in range(rows.shape[0]):\n        row = rows[r, :]\n        # find segments (start,end) indices\n        segs = []\n        in_seg = False\n        start = 0\n        for i, v in enumerate(row):\n            if v and not in_seg:\n                in_seg = True\n                start = i\n            if not v and in_seg:\n                in_seg = False\n                segs.append((start, i - 1))\n        if in_seg:\n            segs.append((start, row.size - 1))\n        if len(segs) >= 2:\n            # check if there is a central large gap between left-most and right-most\n            left_end = segs[0][1]\n            right_start = segs[-1][0]\n            gap = right_start - left_end\n            if gap >= max(2, int(0.12 * w)):  # sizable gap\n                count += 1\n    return float(count / (rows.shape[0] + 1e-8))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Average number of foreground/background transitions per column in the upper half (higher for sandals with straps)'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    h, w = gray.shape[:2]\n    thr = np.percentile(gray, 50)\n    mask = gray > thr\n    if mask.sum() > 0.6 * h * w:\n        mask = ~mask\n    upper = mask[0:max(1, h//2), :]\n    if upper.size == 0:\n        return 0.0\n    transitions = 0\n    for c in range(upper.shape[1]):\n        col = upper[:, c].astype(int)\n        transitions += np.count_nonzero(col[1:] != col[:-1])\n    # normalize by number of rows and columns\n    norm = float(upper.shape[0] * upper.shape[1])\n    return float(transitions / max(1.0, norm))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Normalized vertical centroid of the binary mask (0=top,1=bottom)'\n    import numpy as np\n    if image is None:\n        return 0.5\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.5\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 50)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    if not np.any(mask):\n        return 0.5\n    ys = np.arange(h).reshape(h, 1)\n    cy = float(np.sum(ys * mask) / (np.sum(mask) + 1e-8))\n    return float(cy / max(1.0, h - 1))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Top-center background fraction in the upper region (open collar/V opening indicator)'\n    import numpy as np\n    gray = np.mean(image, axis=2) if len(image.shape) == 3 else image.astype(float)\n    h, w = gray.shape[:2]\n    top_h = max(1, h // 6)\n    c0, c1 = w // 3, 2 * w // 3\n    region = gray[0:top_h, c0:c1]\n    if region.size == 0:\n        return 0.0\n    # adaptive background threshold: low percentile\n    thr = np.percentile(gray.flatten(), 8)\n    background_pixels = np.sum(region <= thr)\n    return float(background_pixels / region.size)\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Bounding-box aspect ratio (width / height) of the foreground mask'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    # convert to grayscale if needed\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 50)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    if not np.any(mask):\n        return 0.0\n    rows = np.where(np.any(mask, axis=1))[0]\n    cols = np.where(np.any(mask, axis=0))[0]\n    if rows.size == 0 or cols.size == 0:\n        return 0.0\n    bbox_h = float(rows[-1] - rows[0] + 1)\n    bbox_w = float(cols[-1] - cols[0] + 1)\n    if bbox_h <= 1e-8:\n        return 0.0\n    return float(bbox_w / (bbox_h + 1e-8))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Vertical symmetry score: normalized mean absolute difference between top half and flipped bottom half (0..1, lower = more symmetric)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape\n    # use continuous intensity for symmetry\n    half = h // 2\n    top = gray[0:half, :]\n    bottom = gray[h - half:h, :]\n    if top.size == 0 or bottom.size == 0:\n        return 0.0\n    bottom_flipped = np.flipud(bottom)\n    # make sizes equal if odd\n    if top.shape != bottom_flipped.shape:\n        min_r = min(top.shape[0], bottom_flipped.shape[0])\n        top = top[:min_r, :]\n        bottom_flipped = bottom_flipped[:min_r, :]\n    diff = np.mean(np.abs(top - bottom_flipped))\n    # normalize by intensity range\n    denom = max(1e-6, np.max(gray) - np.min(gray))\n    return float(diff / denom)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Relative neck-drop score: relative increase in width just below the top 10% (detects neck openings)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    gray = np.mean(image, axis=2) if len(image.shape) == 3 else image.astype(float)\n    h, w = gray.shape[:2]\n    if h < 4 or w == 0:\n        return 0.0\n    thr = np.mean(gray) + 0.2 * (np.max(gray) - np.mean(gray)) if np.max(gray) > np.min(gray) else np.mean(gray) + 1e-6\n    mask = gray >= thr\n    widths = np.sum(mask, axis=1).astype(float)\n    top_n = max(1, int(np.ceil(0.10 * h)))\n    below_n = max(1, int(np.ceil(0.15 * h)))\n    mean_top = float(np.mean(widths[:top_n])) if top_n > 0 else 0.0\n    mean_below = float(np.mean(widths[top_n:top_n + below_n])) if below_n > 0 else 0.0\n    denom = max(1.0, mean_below)\n    drop = (mean_below - mean_top) / denom\n    return float(drop)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Shoulder-to-mid width ratio: mean object width in top region divided by mean width in mid region (detects broad shoulders/sleeves)'\n    import numpy as np\n    gray = np.mean(image, axis=2) if len(image.shape) == 3 else image.astype(float)\n    h, w = gray.shape[:2]\n    low = float(np.percentile(gray, 10))\n    high = float(np.percentile(gray, 90))\n    thr = low + 0.2 * (high - low)\n    mask = gray > thr\n    if not mask.any():\n        return 0.0\n    # bounding rows where object exists\n    rows_any = np.any(mask, axis=1)\n    if not rows_any.any():\n        return 0.0\n    rmin = int(np.argmax(rows_any))\n    rmax = int(len(rows_any) - 1 - np.argmax(rows_any[::-1]))\n    bbox_h = max(1, rmax - rmin + 1)\n    # top region: first 12% of bbox height\n    top_n = max(1, int(round(bbox_h * 0.12)))\n    mid_center = rmin + bbox_h // 2\n    mid_n = max(1, int(round(bbox_h * 0.20)))\n    # helper to compute mean width in a set of rows\n    def mean_width(row_start, row_end):\n        widths = []\n        for r in range(row_start, min(row_end, h)):\n            cols = np.where(mask[r, :])[0]\n            if cols.size:\n                widths.append(cols.max() - cols.min() + 1)\n        return float(np.mean(widths)) if widths else 0.0\n    top_width = mean_width(rmin, rmin + top_n)\n    mid_width = mean_width(max(rmin, mid_center - mid_n//2), min(rmax+1, mid_center + mid_n//2))\n    eps = 1e-6\n    return float(top_width / (mid_width + eps))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Concentration of vertical-edge strength in the central vertical band (higher if edges near neck/midline)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    # compute absolute column-wise gradient (vertical edges)\n    vert_grad = np.abs(np.diff(gray.astype(float), axis=1))\n    # aggregate total gradient and central-band gradient (central 20% columns of original image)\n    total = float(np.sum(vert_grad))\n    c1 = max(0, w//2 - max(1, w//10))\n    c2 = min(w-1, w//2 + max(1, w//10))  # note vert_grad has shape (h, w-1)\n    # adjust indices because vert_grad has one fewer column\n    c1g = max(0, c1)\n    c2g = min(vert_grad.shape[1], c2)\n    center_sum = float(np.sum(vert_grad[:, c1g:c2g]))\n    if total <= 1e-9:\n        return 0.0\n    return float(center_sum / total)\n",
    "def feature(image: np.ndarray) -> float:\n    'Average longest vertical run of mask pixels per column normalized by image height'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h <= 0 or w <= 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = ((gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)).astype(np.uint8)\n    longest = []\n    # iterate over columns (usually small)\n    for x in range(w):\n        col = mask[:, x]\n        max_run = 0\n        run = 0\n        for v in col:\n            if v:\n                run += 1\n                if run > max_run:\n                    max_run = run\n            else:\n                run = 0\n        longest.append(max_run)\n    if len(longest) == 0:\n        return 0.0\n    mean_long = float(np.mean(longest))\n    return float(mean_long / (h + 1e-8))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Left-right symmetry score of the mask (0..1 where 1 is perfectly symmetric)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 50)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    area = float(np.count_nonzero(mask))\n    if area == 0.0:\n        return 0.0\n    # mirror left-right and compute overlap fraction\n    mirror = np.fliplr(mask)\n    overlap = float(np.count_nonzero(mask & mirror))\n    return float(overlap / (area + 1e-12))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Normalized mean vertical-edge fraction inside detected foreground (vertical vs total gradient inside mask)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 2 or w < 2:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    if not np.any(mask):\n        return 0.0\n    gy, gx = np.gradient(gray)\n    vert = np.abs(gy)\n    horz = np.abs(gx)\n    vert_sum = float(np.sum(vert[mask]))\n    horz_sum = float(np.sum(horz[mask]))\n    total = vert_sum + horz_sum\n    if total <= 0:\n        return 0.0\n    return float(vert_sum / (total + 1e-12))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Mean color saturation (HSV-style) for RGB images, 0 for grayscale'\n    import numpy as np\n    if image is None:\n        return 0.0\n    if len(image.shape) != 3 or image.shape[2] < 3:\n        return 0.0\n    rgb = image.astype(float)\n    # use channel order as provided (assume R,G,B)\n    mx = np.max(rgb, axis=2)\n    mn = np.min(rgb, axis=2)\n    sat = np.where(mx > 0, (mx - mn) / (mx + 1e-8), 0.0)\n    # clip and average\n    return float(np.mean(sat))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Mean color saturation (approx) for RGB images, 0 for grayscale'\n    import numpy as np\n    if image is None:\n        return 0.0\n    if len(image.shape) != 3 or image.shape[2] < 3:\n        return 0.0\n    img = image.astype(float)\n    r = img[:, :, 0]\n    g = img[:, :, 1]\n    b = img[:, :, 2]\n    vmax = np.maximum(np.maximum(r, g), b)\n    vmin = np.minimum(np.minimum(r, g), b)\n    # saturation approximation = (vmax - vmin) / (vmax + eps)\n    sat = (vmax - vmin) / (vmax + 1e-8)\n    # ignore NaNs/infs\n    sat_mean = float(np.nanmean(sat))\n    return float(max(0.0, min(1.0, sat_mean)))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Fraction of mask pixels located in bottom 20% of the image (shoe indicator)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 50)\n    mask = ((gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)).astype(bool)\n    total = float(np.count_nonzero(mask))\n    if total <= 0:\n        return 0.0\n    bottom_h = max(1, (20 * h) // 100)\n    bottom_area = float(np.count_nonzero(mask[h - bottom_h:, :]))\n    return float(bottom_area / total)\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Upper vertical gradient energy: mean absolute vertical gradient in the upper third (captures collar/edge and texture differences)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    mh = max(1, h // 3)\n    upper = gray[0:mh, :]\n    # normalize upper region\n    mn, mx = float(np.min(upper)), float(np.max(upper))\n    if mx > mn:\n        upper_n = (upper - mn) / (mx - mn)\n    else:\n        upper_n = upper - mn\n    gy = np.abs(np.gradient(upper_n, axis=0))\n    result = float(np.mean(gy))\n    return float(result)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Normalized difference between mean intensity of top and bottom quarters'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 2 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    q = max(1, h // 4)\n    top_mean = np.mean(gray[:q, :]) if gray[:q, :].size else 0.0\n    bot_mean = np.mean(gray[-q:, :]) if gray[-q:, :].size else 0.0\n    denom = np.mean(gray) + 1e-8\n    return float((top_mean - bot_mean) / denom)\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Top-center empty area ratio: fraction of the top-center small box that is background (useful to detect neck holes)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    mx = float(np.max(gray))\n    thr = max(0.3 * float(np.mean(gray)), 0.08 * mx)\n    mask = gray > thr\n    coords = np.argwhere(mask)\n    if coords.size == 0:\n        # if nothing detected, top-center is all background -> return 1.0\n        return 1.0\n    ys = coords[:,0]; xs = coords[:,1]\n    miny, maxy = int(ys.min()), int(ys.max())\n    minx, maxx = int(xs.min()), int(xs.max())\n    bbox_h = max(1, maxy - miny + 1)\n    bbox_w = max(1, maxx - minx + 1)\n    # define a small top-center box (20% height, 30% width of bbox)\n    box_h = max(1, int(bbox_h * 0.2))\n    box_w = max(1, int(bbox_w * 0.3))\n    start_row = miny\n    start_col = minx + (bbox_w - box_w) // 2\n    end_row = min(start_row + box_h, h)\n    end_col = min(start_col + box_w, w)\n    sub = mask[start_row:end_row, start_col:end_col]\n    total = sub.size\n    if total == 0:\n        return 0.0\n    bg = total - np.count_nonzero(sub)\n    return float(bg / total)\n",
    "def feature(image: np.ndarray) -> float:\n    'Average horizontal distance from center to the outermost object pixel at an upper-mid row (sleeve extension measure), normalized by width'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    mask = gray > 0\n    if not np.any(mask):\n        return 0.0\n    coords = np.argwhere(mask)\n    y0, x0 = coords.min(axis=0)\n    y1, x1 = coords.max(axis=0)\n    height = max(1, y1 - y0 + 1)\n    sample_y = int(round(y0 + 0.35 * height))\n    sample_y = max(0, min(h - 1, sample_y))\n    # average over small vertical window in case of noise\n    win = 3\n    ys = range(max(0, sample_y - win), min(h, sample_y + win + 1))\n    dists = []\n    center_x = (x0 + x1) / 2.0\n    for yy in ys:\n        row = mask[yy, :]\n        cols = np.where(row)[0]\n        if cols.size == 0:\n            continue\n        left = cols.min()\n        right = cols.max()\n        dists.append((center_x - left) / max(1.0, w))\n        dists.append((right - center_x) / max(1.0, w))\n    if len(dists) == 0:\n        return 0.0\n    return float(np.mean(dists))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Number of holes in the mask (background components fully enclosed) normalized by mask area'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = gray < thr if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else gray > thr\n    area = np.count_nonzero(mask)\n    if area == 0:\n        return 0.0\n    ys, xs = np.where(mask)\n    miny, maxy = ys.min(), ys.max()\n    minx, maxx = xs.min(), xs.max()\n    # extract bbox and inverted (background) inside bbox\n    sub = mask[miny:maxy + 1, minx:maxx + 1]\n    inv = ~sub\n    sh, sw = inv.shape\n    # flood fill background components in inv; mark those touching border\n    visited = np.zeros_like(inv, dtype=bool)\n    holes = 0\n    for yi in range(sh):\n        for xi in range(sw):\n            if inv[yi, xi] and not visited[yi, xi]:\n                # new component\n                stack = [(yi, xi)]\n                visited[yi, xi] = True\n                touches_border = False\n                comp_size = 0\n                while stack:\n                    y, x = stack.pop()\n                    comp_size += 1\n                    if y == 0 or y == sh - 1 or x == 0 or x == sw - 1:\n                        touches_border = True\n                    # neighbors\n                    if y > 0 and inv[y - 1, x] and not visited[y - 1, x]:\n                        visited[y - 1, x] = True\n                        stack.append((y - 1, x))\n                    if y + 1 < sh and inv[y + 1, x] and not visited[y + 1, x]:\n                        visited[y + 1, x] = True\n                        stack.append((y + 1, x))\n                    if x > 0 and inv[y, x - 1] and not visited[y, x - 1]:\n                        visited[y, x - 1] = True\n                        stack.append((y, x - 1))\n                    if x + 1 < sw and inv[y, x + 1] and not visited[y, x + 1]:\n                        visited[y, x + 1] = True\n                        stack.append((y, x + 1))\n                if not touches_border and comp_size > 0:\n                    holes += 1\n    return float(holes / (area + 1e-8))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Median horizontal mask width (pixels) normalized by image width'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = ((gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)).astype(bool)\n    row_widths = np.sum(mask.astype(float), axis=1)\n    if row_widths.size == 0:\n        return 0.0\n    med = float(np.median(row_widths))\n    return float(med / (w + 1e-8))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Inverse fraction of object pixels that lie in a narrow central vertical band (high for strap-like sparse centers)'\n    try:\n        if len(image.shape) == 3:\n            gray = np.mean(image, axis=2)\n        else:\n            gray = image.astype(float)\n        h, w = gray.shape[:2]\n        rng = float(np.max(gray) - np.min(gray)) if np.max(gray) != np.min(gray) else 1.0\n        thresh = np.mean(gray) + 0.12 * rng\n        mask = (gray > thresh).astype(float)\n        total = float(np.sum(mask))\n        if total <= 0.0:\n            return 0.0\n        left = int(max(0, np.floor(w * 0.4)))\n        right = int(min(w, np.ceil(w * 0.6)))\n        central = float(np.sum(mask[:, left:right]))\n        frac = central / total\n        return float(1.0 - frac)\n    except Exception:\n        return 0.0\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Object solidity: ratio of object area to its bounding-box area (smaller for thin/strappy objects like some sandals)'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.mean(gray) + 0.2 * (np.max(gray) - np.min(gray))\n    mask = gray > thr\n    if not np.any(mask):\n        return 0.0\n    rows = np.any(mask, axis=1)\n    cols = np.any(mask, axis=0)\n    minr, maxr = np.where(rows)[0][0], np.where(rows)[0][-1]\n    minc, maxc = np.where(cols)[0][0], np.where(cols)[0][-1]\n    area = np.sum(mask)\n    bbox_area = (maxr - minr + 1) * (maxc - minc + 1)\n    return float(area / (bbox_area + 1e-9))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Presence and separation of two bright/bulk peaks near the bottom quarter (shoe pair score)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    import numpy as np\n    h, w = image.shape[:2]\n    if h < 4 or w < 4:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    bottom_h = max(1, h // 4)\n    cols = np.sum(mask[h - bottom_h:, :].astype(float), axis=0)\n    if np.all(cols == 0):\n        return 0.0\n    # smooth and find local peaks\n    kernel = np.ones(5) / 5.0\n    smooth = np.convolve(cols, kernel, mode='same')\n    meanv = float(np.mean(smooth))\n    peaks = []\n    for i in range(1, w - 1):\n        if smooth[i] > smooth[i - 1] and smooth[i] > smooth[i + 1] and smooth[i] > meanv * 0.5:\n            peaks.append((smooth[i], i))\n    if len(peaks) < 2:\n        return 0.0\n    peaks_sorted = sorted(peaks, reverse=True)[:2]\n    d = abs(peaks_sorted[0][1] - peaks_sorted[1][1])\n    return float(d) / float(w)\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Ratio of average gradient magnitude inside the foreground mask to outside it'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 2 or w < 2:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    gy, gx = np.gradient(gray.astype(float))\n    grad = np.sqrt(gx * gx + gy * gy)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    inside = grad[mask]\n    outside = grad[~mask]\n    mean_in = float(np.mean(inside)) if inside.size > 0 else 0.0\n    mean_out = float(np.mean(outside)) if outside.size > 0 else 0.0\n    return float(mean_in / (mean_out + 1e-8))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Average downward extent of object on left and right quarters (sleeve length proxy) normalized by bbox height'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    mn, mx = float(np.min(gray)), float(np.max(gray))\n    norm = (gray - mn) / (mx - mn + 1e-9)\n    thresh = np.percentile(gray, 60)\n    mask = norm > (thresh - mn) / (mx - mn + 1e-9)\n    h, w = gray.shape\n    if np.count_nonzero(mask) == 0:\n        return 0.0\n    rows = np.any(mask, axis=1)\n    cols = np.any(mask, axis=0)\n    rmin = int(np.argmax(rows))\n    rmax = int(len(rows) - 1 - np.argmax(rows[::-1]))\n    cmin = int(np.argmax(cols))\n    cmax = int(len(cols) - 1 - np.argmax(cols[::-1]))\n    bh = max(1, rmax - rmin + 1)\n    bw = max(1, cmax - cmin + 1)\n    bbox = mask[rmin:rmax+1, cmin:cmax+1]\n    # define quarters\n    left_w = max(1, bw // 4)\n    right_w = left_w\n    left_region = bbox[:, :left_w]\n    right_region = bbox[:, -right_w:]\n    # for each region compute average of bottom-most object row index (relative to bbox top)\n    def avg_bottom_depth(region):\n        if region.size == 0 or np.count_nonzero(region) == 0:\n            return 0.0\n        # for each column, find max row index where True\n        cols_local = region.shape[1]\n        bottom_rows = []\n        for col in range(cols_local):\n            colvals = region[:, col]\n            true_idx = np.where(colvals)[0]\n            if true_idx.size > 0:\n                bottom_rows.append(true_idx[-1])\n        if len(bottom_rows) == 0:\n            return 0.0\n        return float(np.mean(bottom_rows)) / float(max(1, region.shape[0]-1))\n    left_depth = avg_bottom_depth(left_region)\n    right_depth = avg_bottom_depth(right_region)\n    return float(np.clip(0.5 * (left_depth + right_depth), 0.0, 1.0))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Normalized horizontal centroid offset: abs(cx - center_x) / width'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    thr = np.percentile(gray, 55)\n    mask = (gray < thr) if np.count_nonzero(gray < thr) >= np.count_nonzero(gray > thr) else (gray > thr)\n    ys, xs = np.where(mask)\n    if xs.size == 0:\n        return 0.0\n    cx = float(np.mean(xs))\n    return float(abs(cx - (w / 2.0)) / (w + 1e-8))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Vertical slope of row mean intensity (positive = intensity increases downward) normalized by intensity range'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 2 or w == 0:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    row_mean = np.mean(gray, axis=1)\n    ys = np.arange(len(row_mean))\n    # fit linear slope\n    try:\n        p = np.polyfit(ys, row_mean, 1)\n        slope = float(p[0])\n    except Exception:\n        slope = 0.0\n    rng = float(np.max(row_mean) - np.min(row_mean)) + 1e-8\n    # normalize by height to keep values comparable\n    return float((slope / rng) * float(h))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Fraction of object pixels appearing in the top 30% of the object bounding box'\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image.astype(float)\n    mean, std = float(np.mean(gray)), float(np.std(gray))\n    thresh = mean + 0.5 * std\n    mask = gray > thresh\n    if np.count_nonzero(mask) == 0:\n        thresh = float(np.max(gray)) * 0.5\n        mask = gray > thresh\n    if np.count_nonzero(mask) == 0:\n        return 0.0\n    rows, cols = np.where(mask)\n    rmin, rmax = rows.min(), rows.max()\n    cmin, cmax = cols.min(), cols.max()\n    bbox = mask[rmin:rmax+1, cmin:cmax+1]\n    h = bbox.shape[0]\n    top_h = max(1, int(np.ceil(0.3 * h)))\n    top_region = bbox[:top_h, :]\n    top_count = np.count_nonzero(top_region)\n    total_count = np.count_nonzero(bbox)\n    return float(top_count / (total_count + 1e-6))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Top-edge flatness: 1 - normalized std of topmost foreground row per column (higher -> flatter straight top)'\n    import numpy as np\n    try:\n        if len(image.shape) == 3:\n            gray = np.mean(image, axis=2).astype(float)\n        else:\n            gray = image.astype(float)\n    except Exception:\n        return 0.0\n    h, w = gray.shape[:2]\n    if h < 4 or w < 4:\n        return 0.0\n    thresh = np.percentile(gray, 50)\n    mask = gray > thresh\n    # for each column find first foreground row (topmost), mark as h if none\n    top_rows = np.full((w,), h, dtype=float)\n    for col in range(w):\n        col_idxs = np.nonzero(mask[:, col])[0]\n        if col_idxs.size:\n            top_rows[col] = float(col_idxs[0])\n    # consider only columns that have foreground somewhere\n    valid = top_rows < h\n    if not valid.any():\n        return 0.0\n    std = float(np.std(top_rows[valid]))\n    # normalize by image height\n    norm_std = std / max(1.0, h)\n    score = 1.0 - np.clip(norm_std, 0.0, 1.0)\n    return float(score)\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Normalized mean gradient magnitude (edge energy normalized by mean intensity)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    h, w = image.shape[:2]\n    if h < 2 or w < 2:\n        return 0.0\n    if len(image.shape) == 3:\n        gray = np.mean(image.astype(float), axis=2)\n    else:\n        gray = image.astype(float)\n    mx = np.max(gray)\n    if mx > 0:\n        gray = gray / mx\n    gy, gx = np.gradient(gray)\n    mag = np.sqrt(gx * gx + gy * gy)\n    mean_mag = float(np.mean(mag))\n    mean_intensity = float(np.mean(gray))\n    return float(mean_mag / (mean_intensity + 1e-8))\n\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Mean gradient magnitude inside the lower quarter of the object bounding box (edge density near sole)'\n    import numpy as np\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2).astype(float)\n    else:\n        gray = image.astype(float)\n    h, w = gray.shape[:2]\n    if h == 0 or w == 0:\n        return 0.0\n    thr = 0.6 * np.mean(gray) + 0.4 * np.min(gray)\n    mask = gray > thr\n    ys, xs = np.where(mask)\n    if ys.size == 0:\n        return 0.0\n    r0, r1 = ys.min(), ys.max()\n    bbox_h = r1 - r0 + 1\n    lower_h = max(1, bbox_h // 4)\n    lower_start = r1 - lower_h + 1\n    region_mask = mask[lower_start:r1+1, :]\n    if region_mask.sum() == 0:\n        return 0.0\n    gy, gx = np.gradient(gray)\n    grad = np.hypot(gx, gy)\n    region_grad = grad[lower_start:r1+1, :] * region_mask\n    # return mean gradient magnitude over masked region\n    total = region_mask.sum()\n    return float(region_grad.sum() / (total + 1e-9))\n\n",
    "def feature(image: np.ndarray) -> float:\n    'Colorfulness measure for RGB images (0 for grayscale images)'\n    import numpy as np\n    if image is None:\n        return 0.0\n    if len(image.shape) != 3 or image.shape[2] < 3:\n        return 0.0\n    # use Hasler & S\u00fcsstrunk colorfulness metric\n    img = image.astype(float)\n    R, G, B = img[:, :, 0], img[:, :, 1], img[:, :, 2]\n    rg = R - G\n    yb = 0.5 * (R + G) - B\n    std_rg = float(np.std(rg))\n    std_yb = float(np.std(yb))\n    mean_rg = float(np.mean(rg))\n    mean_yb = float(np.mean(yb))\n    colorfulness = std_rg + std_yb + 0.3 * (abs(mean_rg) + abs(mean_yb))\n    if not np.isfinite(colorfulness):\n        return 0.0\n    return float(colorfulness)\n\n"
  ]
}