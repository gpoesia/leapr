[
  "def feature(image: np.ndarray) -> float:\n    \"Ratio of bright pixels in top half vs bottom half of image\"\n    h, w = image.shape[:2]\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    top_half = gray[:h//2, :]\n    bottom_half = gray[h//2:, :]\n    top_bright = np.count_nonzero(top_half > 128)\n    bottom_bright = np.count_nonzero(bottom_half > 128)\n    if bottom_bright == 0:\n        return float(top_bright)\n    return float(top_bright / bottom_bright)\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Standard deviation of pixel intensities in image edges\"\n    h, w = image.shape[:2]\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    edge_pixels = np.concatenate([\n        gray[0, :], gray[-1, :], gray[:, 0], gray[:, -1]\n    ])\n    return float(np.std(edge_pixels))\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Ratio of pixels in center quarter vs outer regions\"\n    h, w = image.shape[:2]\n    center_h_start, center_h_end = h//4, 3*h//4\n    center_w_start, center_w_end = w//4, 3*w//4\n    \n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    \n    center_mean = np.mean(gray[center_h_start:center_h_end, center_w_start:center_w_end])\n    total_mean = np.mean(gray)\n    \n    if total_mean == 0:\n        return 0.0\n    return float(center_mean / total_mean)\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Count of pixels with intensity in middle range 64-192\"\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    middle_range_pixels = np.count_nonzero((gray >= 64) & (gray <= 192))\n    total_pixels = gray.size\n    return float(middle_range_pixels / total_pixels)\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Horizontal gradient magnitude in center row\"\n    h, w = image.shape[:2]\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    center_row = gray[h//2, :]\n    if len(center_row) < 2:\n        return 0.0\n    gradient = np.abs(np.gradient(center_row))\n    return float(np.mean(gradient))\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Difference between 90th and 10th percentile intensities\"\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    p90 = np.percentile(gray, 90)\n    p10 = np.percentile(gray, 10)\n    return float(p90 - p10)\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Average red channel intensity relative to blue channel intensity\"\n    if len(image.shape) == 3:\n        red_mean = np.mean(image[:, :, 0])\n        blue_mean = np.mean(image[:, :, 2])\n        if blue_mean == 0:\n            return float(red_mean)\n        return float(red_mean / blue_mean)\n    else:\n        return 1.0\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Variance of pixel intensities in each quadrant averaged\"\n    h, w = image.shape[:2]\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    q1 = gray[:h//2, :w//2]\n    q2 = gray[:h//2, w//2:]\n    q3 = gray[h//2:, :w//2]\n    q4 = gray[h//2:, w//2:]\n    variances = [np.var(q) for q in [q1, q2, q3, q4]]\n    return float(np.mean(variances))\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Ratio of pixels darker than 50 in corners vs center\"\n    h, w = image.shape[:2]\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    corner_size = min(h//4, w//4)\n    corners = np.concatenate([\n        gray[:corner_size, :corner_size].flatten(),\n        gray[:corner_size, -corner_size:].flatten(),\n        gray[-corner_size:, :corner_size].flatten(),\n        gray[-corner_size:, -corner_size:].flatten()\n    ])\n    center = gray[h//4:3*h//4, w//4:3*w//4]\n    corner_dark = np.count_nonzero(corners < 50)\n    center_dark = np.count_nonzero(center < 50)\n    if center_dark == 0:\n        return float(corner_dark)\n    return float(corner_dark / center_dark)\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Maximum vertical gradient magnitude in any column\"\n    h, w = image.shape[:2]\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    if h < 2:\n        return 0.0\n    vertical_gradients = np.abs(np.gradient(gray, axis=0))\n    max_gradients_per_col = np.max(vertical_gradients, axis=0)\n    return float(np.max(max_gradients_per_col))\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Symmetry measure between left and right halves of image\"\n    h, w = image.shape[:2]\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    left_half = gray[:, :w//2]\n    right_half = gray[:, w//2:w//2+left_half.shape[1]]\n    right_flipped = np.fliplr(right_half)\n    if left_half.shape != right_flipped.shape:\n        return 0.0\n    diff = np.abs(left_half - right_flipped)\n    return float(1.0 / (1.0 + np.mean(diff)))\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Average magnitude of horizontal edges in the middle third of image\"\n    h, w = image.shape[:2]\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    middle_third = gray[h//3:2*h//3, :]\n    if middle_third.shape[1] < 2:\n        return 0.0\n    horizontal_grad = np.abs(np.gradient(middle_third, axis=1))\n    return float(np.mean(horizontal_grad))\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Ratio of green to red channel average intensities\"\n    if len(image.shape) == 3:\n        green_mean = np.mean(image[:, :, 1])\n        red_mean = np.mean(image[:, :, 0])\n        if red_mean == 0:\n            return float(green_mean)\n        return float(green_mean / red_mean)\n    else:\n        return 1.0\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Fraction of pixels in brightest 25 percent that are in center region\"\n    h, w = image.shape[:2]\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    threshold = np.percentile(gray, 75)\n    bright_mask = gray > threshold\n    center_region = bright_mask[h//4:3*h//4, w//4:3*w//4]\n    total_bright = np.count_nonzero(bright_mask)\n    center_bright = np.count_nonzero(center_region)\n    if total_bright == 0:\n        return 0.0\n    return float(center_bright / total_bright)\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Maximum difference between adjacent pixels in any row\"\n    h, w = image.shape[:2]\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    if w < 2:\n        return 0.0\n    max_diff = 0.0\n    for row in range(h):\n        row_diffs = np.abs(np.diff(gray[row, :]))\n        max_diff = max(max_diff, np.max(row_diffs))\n    return float(max_diff)\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Standard deviation of mean intensities across all rows\"\n    h, w = image.shape[:2]\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    row_means = np.mean(gray, axis=1)\n    return float(np.std(row_means))\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Concentration of dark pixels in corners vs edges\"\n    h, w = image.shape[:2]\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    corner_size = min(h//6, w//6)\n    corners = np.concatenate([\n        gray[:corner_size, :corner_size].flatten(),\n        gray[:corner_size, -corner_size:].flatten(),\n        gray[-corner_size:, :corner_size].flatten(),\n        gray[-corner_size:, -corner_size:].flatten()\n    ])\n    edges = np.concatenate([gray[0, :], gray[-1, :], gray[:, 0], gray[:, -1]])\n    corner_dark = np.count_nonzero(corners < 100)\n    edge_dark = np.count_nonzero(edges < 100)\n    if edge_dark == 0:\n        return float(corner_dark)\n    return float(corner_dark / edge_dark)\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Ratio of blue channel intensity in top third vs bottom third\"\n    if len(image.shape) == 3:\n        h = image.shape[0]\n        top_blue = np.mean(image[:h//3, :, 2])\n        bottom_blue = np.mean(image[2*h//3:, :, 2])\n        if bottom_blue == 0:\n            return float(top_blue)\n        return float(top_blue / bottom_blue)\n    else:\n        return 1.0\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Vertical gradient magnitude in center column\"\n    h, w = image.shape[:2]\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    center_col = gray[:, w//2]\n    if len(center_col) < 2:\n        return 0.0\n    gradient = np.abs(np.gradient(center_col))\n    return float(np.mean(gradient))\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Fraction of pixels with intensity above 75th percentile in corners\"\n    h, w = image.shape[:2]\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    threshold = np.percentile(gray, 75)\n    corner_size = min(h//5, w//5)\n    corners = np.concatenate([\n        gray[:corner_size, :corner_size].flatten(),\n        gray[:corner_size, -corner_size:].flatten(),\n        gray[-corner_size:, :corner_size].flatten(),\n        gray[-corner_size:, -corner_size:].flatten()\n    ])\n    bright_corners = np.count_nonzero(corners > threshold)\n    return float(bright_corners / len(corners)) if len(corners) > 0 else 0.0\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Standard deviation of column-wise mean intensities\"\n    h, w = image.shape[:2]\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    col_means = np.mean(gray, axis=0)\n    return float(np.std(col_means))\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Ratio of green channel variance to overall variance\"\n    if len(image.shape) == 3:\n        green_var = np.var(image[:, :, 1])\n        overall_var = np.var(image)\n        if overall_var == 0:\n            return 0.0\n        return float(green_var / overall_var)\n    else:\n        return 1.0\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Average intensity difference between adjacent horizontal pixels\"\n    h, w = image.shape[:2]\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    if w < 2:\n        return 0.0\n    diff = np.abs(gray[:, 1:] - gray[:, :-1])\n    return float(np.mean(diff))\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Ratio of maximum to minimum pixel intensity across all channels\"\n    max_val = float(np.max(image))\n    min_val = float(np.min(image))\n    if min_val == 0:\n        return max_val\n    return float(max_val / min_val)\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Average intensity in corner regions relative to center\"\n    h, w = image.shape[:2]\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    corner_size = min(h, w) // 8\n    corners = [gray[:corner_size, :corner_size], gray[:corner_size, -corner_size:], \n               gray[-corner_size:, :corner_size], gray[-corner_size:, -corner_size:]]\n    corner_mean = np.mean([np.mean(corner) for corner in corners])\n    center_mean = np.mean(gray[h//4:3*h//4, w//4:3*w//4])\n    if center_mean == 0:\n        return float(corner_mean)\n    return float(corner_mean / center_mean)\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Count of pixels above 75th percentile intensity\"\n    threshold = np.percentile(image, 75)\n    bright_pixels = np.count_nonzero(image > threshold)\n    total_pixels = image.size\n    return float(bright_pixels / total_pixels)\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Variance of diagonal pixel intensities from top-left to bottom-right\"\n    h, w = image.shape[:2]\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    diag_length = min(h, w)\n    diagonal = [gray[i, i] for i in range(diag_length)]\n    return float(np.var(diagonal))\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Ratio of left half to right half average intensity\"\n    h, w = image.shape[:2]\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    left_mean = np.mean(gray[:, :w//2])\n    right_mean = np.mean(gray[:, w//2:])\n    if right_mean == 0:\n        return float(left_mean)\n    return float(left_mean / right_mean)\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Standard deviation of green channel minus red channel difference\"\n    if len(image.shape) == 3:\n        green_red_diff = image[:, :, 1].astype(float) - image[:, :, 0].astype(float)\n        return float(np.std(green_red_diff))\n    else:\n        return 0.0\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Average absolute difference between center pixel and its 8 neighbors\"\n    h, w = image.shape[:2]\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    if h < 3 or w < 3:\n        return 0.0\n    center_y, center_x = h // 2, w // 2\n    center_val = gray[center_y, center_x]\n    neighbors = []\n    for dy in [-1, 0, 1]:\n        for dx in [-1, 0, 1]:\n            if dy == 0 and dx == 0:\n                continue\n            neighbors.append(gray[center_y + dy, center_x + dx])\n    diffs = [abs(center_val - neighbor) for neighbor in neighbors]\n    return float(np.mean(diffs))\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Ratio of maximum to minimum pixel intensity values\"\n    max_val = float(np.max(image))\n    min_val = float(np.min(image))\n    if min_val == 0:\n        return max_val\n    return max_val / min_val\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Average intensity in top half minus average intensity in bottom half\"\n    h = image.shape[0]\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    top_half = np.mean(gray[:h//2, :])\n    bottom_half = np.mean(gray[h//2:, :])\n    return float(top_half - bottom_half)\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Percentage of pixels above the 90th percentile intensity\"\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    threshold = np.percentile(gray, 90)\n    bright_pixels = np.count_nonzero(gray > threshold)\n    total_pixels = gray.size\n    return float(bright_pixels / total_pixels)\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Ratio of red to green channel intensities\"\n    if len(image.shape) == 3:\n        red_mean = np.mean(image[:, :, 0])\n        green_mean = np.mean(image[:, :, 1])\n        if green_mean == 0:\n            return float(red_mean)\n        return float(red_mean / green_mean)\n    else:\n        return 1.0\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Average absolute difference between center pixel and surrounding pixels\"\n    h, w = image.shape[:2]\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    if h < 3 or w < 3:\n        return 0.0\n    center = gray[1:-1, 1:-1]\n    neighbors = (gray[:-2, :-2] + gray[:-2, 1:-1] + gray[:-2, 2:] + \n                gray[1:-1, :-2] + gray[1:-1, 2:] + \n                gray[2:, :-2] + gray[2:, 1:-1] + gray[2:, 2:]) / 8\n    diff = np.abs(center - neighbors)\n    return float(np.mean(diff))\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Ratio of edge pixels to total pixels using vertical gradient\"\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    grad_y = np.abs(np.gradient(gray, axis=0))\n    edge_pixels = np.count_nonzero(grad_y > np.mean(grad_y))\n    total_pixels = gray.size\n    return float(edge_pixels / total_pixels)\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Density of dark pixels in the bottom half of the image\"\n    h, w = image.shape[:2]\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    bottom_half = gray[h//2:, :]\n    dark_pixels = np.count_nonzero(bottom_half < np.mean(bottom_half))\n    return float(dark_pixels / bottom_half.size)\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Average intensity of the four corner regions\"\n    h, w = image.shape[:2]\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    corner_size = min(h, w) // 8\n    if corner_size == 0:\n        return float(np.mean(gray))\n    corners = [gray[:corner_size, :corner_size], gray[:corner_size, -corner_size:],\n               gray[-corner_size:, :corner_size], gray[-corner_size:, -corner_size:]]\n    corner_means = [np.mean(corner) for corner in corners]\n    return float(np.mean(corner_means))\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Ratio of bright pixels in top quarter to bottom quarter\"\n    h = image.shape[0]\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    threshold = np.percentile(gray, 75)\n    top_quarter = gray[:h//4, :]\n    bottom_quarter = gray[3*h//4:, :]\n    top_bright = np.count_nonzero(top_quarter > threshold)\n    bottom_bright = np.count_nonzero(bottom_quarter > threshold)\n    if bottom_bright == 0:\n        return float(top_bright)\n    return float(top_bright / bottom_bright)\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Variance of column-wise mean intensities\"\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    column_means = np.mean(gray, axis=0)\n    return float(np.var(column_means))\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Ratio of green to blue channel maximum values\"\n    if len(image.shape) == 3:\n        green_max = np.max(image[:, :, 1])\n        blue_max = np.max(image[:, :, 2])\n        if blue_max == 0:\n            return float(green_max)\n        return float(green_max / blue_max)\n    else:\n        return 1.0\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Average intensity of pixels along the main diagonal\"\n    h, w = image.shape[:2]\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    min_dim = min(h, w)\n    if min_dim == 0:\n        return 0.0\n    diagonal_pixels = gray[range(min_dim), range(min_dim)]\n    return float(np.mean(diagonal_pixels))\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Standard deviation of row-wise maximum values\"\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    row_maxes = np.max(gray, axis=1)\n    return float(np.std(row_maxes))\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Average intensity of pixels along the main diagonal\"\n    h, w = image.shape[:2]\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    min_dim = min(h, w)\n    diagonal_pixels = [gray[i, i] for i in range(min_dim)]\n    return float(np.mean(diagonal_pixels))\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Variance of column-wise mean intensities\"\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    col_means = np.mean(gray, axis=0)\n    return float(np.var(col_means))\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Ratio of bright pixels (>200) in top half vs bottom half\"\n    h, w = image.shape[:2]\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    top_bright = np.count_nonzero(gray[:h//2, :] > 200)\n    bottom_bright = np.count_nonzero(gray[h//2:, :] > 200)\n    if bottom_bright == 0:\n        return float(top_bright)\n    return float(top_bright / bottom_bright)\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Standard deviation of horizontal gradient magnitude\"\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    grad_x = np.abs(np.gradient(gray, axis=1))\n    return float(np.std(grad_x))\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Skewness of pixel intensity distribution\"\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    flat_pixels = gray.flatten()\n    mean_val = np.mean(flat_pixels)\n    std_val = np.std(flat_pixels)\n    if std_val == 0:\n        return 0.0\n    skewness = np.mean(((flat_pixels - mean_val) / std_val) ** 3)\n    return float(skewness)\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Average distance of non-zero pixels from image center\"\n    h, w = image.shape[:2]\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    center_y, center_x = h // 2, w // 2\n    y_coords, x_coords = np.where(gray > 0)\n    if len(y_coords) == 0:\n        return 0.0\n    distances = np.sqrt((y_coords - center_y)**2 + (x_coords - center_x)**2)\n    return float(np.mean(distances))\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Ratio of unique pixel values to total pixels\"\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    unique_vals = len(np.unique(gray))\n    total_pixels = gray.size\n    return float(unique_vals / total_pixels)\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Maximum difference between adjacent vertical pixels\"\n    h, w = image.shape[:2]\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    if h < 2:\n        return 0.0\n    diff = np.abs(gray[1:, :] - gray[:-1, :])\n    return float(np.max(diff))\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Average intensity in corner regions versus center region\"\n    h, w = image.shape[:2]\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    corner_size = min(h, w) // 4\n    if corner_size == 0:\n        return 0.0\n    corners = np.concatenate([\n        gray[:corner_size, :corner_size].flatten(),\n        gray[:corner_size, -corner_size:].flatten(),\n        gray[-corner_size:, :corner_size].flatten(),\n        gray[-corner_size:, -corner_size:].flatten()\n    ])\n    center = gray[h//4:3*h//4, w//4:3*w//4]\n    if center.size == 0:\n        return 0.0\n    return float(np.mean(corners) - np.mean(center))\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Ratio of high intensity pixels to total pixels\"\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    threshold = np.percentile(gray, 75)\n    high_intensity_pixels = np.count_nonzero(gray > threshold)\n    return float(high_intensity_pixels / gray.size)\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Standard deviation of diagonal pixel differences\"\n    h, w = image.shape[:2]\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    if h < 2 or w < 2:\n        return 0.0\n    diag1 = np.abs(gray[:-1, :-1] - gray[1:, 1:])\n    diag2 = np.abs(gray[:-1, 1:] - gray[1:, :-1])\n    all_diag_diffs = np.concatenate([diag1.flatten(), diag2.flatten()])\n    return float(np.std(all_diag_diffs))\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Average blue channel intensity relative to green channel intensity\"\n    if len(image.shape) == 3:\n        blue_mean = np.mean(image[:, :, 2])\n        green_mean = np.mean(image[:, :, 1])\n        if green_mean == 0:\n            return float(blue_mean)\n        return float(blue_mean / green_mean)\n    else:\n        return 1.0\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Horizontal symmetry measure comparing left and right halves\"\n    h, w = image.shape[:2]\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    if w < 2:\n        return 0.0\n    left_half = gray[:, :w//2]\n    right_half = np.fliplr(gray[:, -w//2:])\n    min_width = min(left_half.shape[1], right_half.shape[1])\n    left_crop = left_half[:, :min_width]\n    right_crop = right_half[:, :min_width]\n    diff = np.mean(np.abs(left_crop - right_crop))\n    return float(diff)\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Entropy measure based on intensity distribution\"\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    hist, _ = np.histogram(gray.flatten(), bins=32, range=(0, 255))\n    hist = hist + 1e-10\n    prob = hist / np.sum(hist)\n    entropy = -np.sum(prob * np.log2(prob))\n    return float(entropy)\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Ratio of high contrast regions to total image area\"\n    h, w = image.shape[:2]\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    if h < 2 or w < 2:\n        return 0.0\n    local_std = np.zeros_like(gray)\n    for i in range(1, h-1):\n        for j in range(1, w-1):\n            local_std[i, j] = np.std(gray[i-1:i+2, j-1:j+2])\n    high_contrast = np.count_nonzero(local_std > np.mean(local_std))\n    return float(high_contrast / gray.size)\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Average intensity in top third minus bottom third of image\"\n    h, w = image.shape[:2]\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    top_third = gray[:h//3, :]\n    bottom_third = gray[-h//3:, :]\n    top_mean = np.mean(top_third)\n    bottom_mean = np.mean(bottom_third)\n    return float(top_mean - bottom_mean)\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Proportion of pixels in middle intensity range (25th to 75th percentile)\"\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    p25 = np.percentile(gray, 25)\n    p75 = np.percentile(gray, 75)\n    middle_pixels = np.count_nonzero((gray >= p25) & (gray <= p75))\n    return float(middle_pixels / gray.size)\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Maximum intensity difference between any two corner regions\"\n    h, w = image.shape[:2]\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    corner_size = min(h//6, w//6, 5)\n    if corner_size < 1:\n        return 0.0\n    tl = np.mean(gray[:corner_size, :corner_size])\n    tr = np.mean(gray[:corner_size, -corner_size:])\n    bl = np.mean(gray[-corner_size:, :corner_size])\n    br = np.mean(gray[-corner_size:, -corner_size:])\n    corners = [tl, tr, bl, br]\n    return float(max(corners) - min(corners))\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Average diagonal gradient magnitude\"\n    h, w = image.shape[:2]\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    if h < 2 or w < 2:\n        return 0.0\n    diag1 = np.abs(gray[1:, 1:] - gray[:-1, :-1])\n    diag2 = np.abs(gray[1:, :-1] - gray[:-1, 1:])\n    return float((np.mean(diag1) + np.mean(diag2)) / 2)\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Variance of pixel intensities in the top quarter of the image\"\n    h, w = image.shape[:2]\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    top_quarter = gray[:h//4, :]\n    return float(np.var(top_quarter))\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Ratio of bottom half average intensity to top half average intensity\"\n    h, w = image.shape[:2]\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    top_half = np.mean(gray[:h//2, :])\n    bottom_half = np.mean(gray[h//2:, :])\n    if top_half == 0:\n        return float(bottom_half)\n    return float(bottom_half / top_half)\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Maximum intensity difference between any two color channels\"\n    if len(image.shape) == 3:\n        r_mean = np.mean(image[:, :, 0])\n        g_mean = np.mean(image[:, :, 1])\n        b_mean = np.mean(image[:, :, 2])\n        diffs = [abs(r_mean - g_mean), abs(r_mean - b_mean), abs(g_mean - b_mean)]\n        return float(max(diffs))\n    else:\n        return 0.0\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Percentage of pixels in the darkest 25th percentile\"\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    threshold = np.percentile(gray, 25)\n    dark_pixels = np.count_nonzero(gray <= threshold)\n    total_pixels = gray.size\n    return float(dark_pixels / total_pixels)\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Average intensity in corner regions compared to center region\"\n    h, w = image.shape[:2]\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    corner_size = min(h//4, w//4)\n    if corner_size == 0:\n        return 0.0\n    corners = [gray[:corner_size, :corner_size], gray[:corner_size, -corner_size:],\n               gray[-corner_size:, :corner_size], gray[-corner_size:, -corner_size:]]\n    corner_avg = np.mean([np.mean(corner) for corner in corners])\n    center = gray[h//4:3*h//4, w//4:3*w//4]\n    center_avg = np.mean(center) if center.size > 0 else 0\n    if center_avg == 0:\n        return float(corner_avg)\n    return float(corner_avg / center_avg)\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Diagonal gradient magnitude from top-left to bottom-right\"\n    h, w = image.shape[:2]\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    if h < 2 or w < 2:\n        return 0.0\n    diagonal = np.array([gray[i, i] for i in range(min(h, w))])\n    if len(diagonal) < 2:\n        return 0.0\n    gradient = np.abs(np.gradient(diagonal))\n    return float(np.mean(gradient))\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Ratio of high intensity pixels in center vs corners\"\n    h, w = image.shape[:2]\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    center_region = gray[h//4:3*h//4, w//4:3*w//4]\n    corner_size = min(h//8, w//8)\n    corners = np.concatenate([\n        gray[:corner_size, :corner_size].flatten(),\n        gray[:corner_size, -corner_size:].flatten(),\n        gray[-corner_size:, :corner_size].flatten(),\n        gray[-corner_size:, -corner_size:].flatten()\n    ])\n    center_bright = np.count_nonzero(center_region > 150)\n    corner_bright = np.count_nonzero(corners > 150)\n    if corner_bright == 0:\n        return float(center_bright)\n    return float(center_bright / corner_bright)\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Standard deviation of green channel divided by red channel standard deviation\"\n    if len(image.shape) == 3:\n        red_std = np.std(image[:, :, 0])\n        green_std = np.std(image[:, :, 1])\n        if red_std == 0:\n            return float(green_std)\n        return float(green_std / red_std)\n    else:\n        return 1.0\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Average intensity of pixels along the four borders\"\n    h, w = image.shape[:2]\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    border_pixels = np.concatenate([\n        gray[0, :].flatten(),\n        gray[-1, :].flatten(),\n        gray[:, 0].flatten(),\n        gray[:, -1].flatten()\n    ])\n    return float(np.mean(border_pixels))\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Ratio of pixels above median intensity to total pixels\"\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    median_val = np.median(gray)\n    above_median = np.count_nonzero(gray > median_val)\n    total_pixels = gray.size\n    return float(above_median / total_pixels)\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Maximum intensity difference between quadrants of the image\"\n    h, w = image.shape[:2]\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    q1 = np.mean(gray[:h//2, :w//2])\n    q2 = np.mean(gray[:h//2, w//2:])\n    q3 = np.mean(gray[h//2:, :w//2])\n    q4 = np.mean(gray[h//2:, w//2:])\n    quadrants = [q1, q2, q3, q4]\n    return float(max(quadrants) - min(quadrants))\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Average intensity gradient magnitude in horizontal direction\"\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    if gray.shape[1] < 2:\n        return 0.0\n    grad_x = np.abs(np.gradient(gray, axis=1))\n    return float(np.mean(grad_x))\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Ratio of edge pixels in left half versus right half of image\"\n    h, w = image.shape[:2]\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    if w < 4 or h < 2:\n        return 1.0\n    grad_x = np.abs(np.gradient(gray, axis=1))\n    grad_y = np.abs(np.gradient(gray, axis=0))\n    edges = grad_x + grad_y\n    edge_threshold = np.percentile(edges, 80)\n    left_edges = np.count_nonzero(edges[:, :w//2] > edge_threshold)\n    right_edges = np.count_nonzero(edges[:, w//2:] > edge_threshold)\n    if right_edges == 0:\n        return float(left_edges)\n    return float(left_edges / right_edges)\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Standard deviation of pixel intensities in corner regions\"\n    h, w = image.shape[:2]\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    corner_size = min(h//4, w//4)\n    if corner_size < 1:\n        return 0.0\n    corners = [\n        gray[:corner_size, :corner_size],\n        gray[:corner_size, -corner_size:],\n        gray[-corner_size:, :corner_size], \n        gray[-corner_size:, -corner_size:]\n    ]\n    corner_stds = [np.std(corner) for corner in corners]\n    return float(np.mean(corner_stds))\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Ratio of dark pixels in center circle versus outer regions\"\n    h, w = image.shape[:2]\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    center_y, center_x = h // 2, w // 2\n    radius = min(h, w) // 4\n    y, x = np.ogrid[:h, :w]\n    mask = (x - center_x) ** 2 + (y - center_y) ** 2 <= radius ** 2\n    dark_threshold = np.percentile(gray, 25)\n    center_dark = np.count_nonzero((gray < dark_threshold) & mask)\n    outer_dark = np.count_nonzero((gray < dark_threshold) & ~mask)\n    if outer_dark == 0:\n        return float(center_dark)\n    return float(center_dark / outer_dark)\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Maximum intensity difference between any two adjacent pixels\"\n    h, w = image.shape[:2]\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    if h < 2 or w < 2:\n        return 0.0\n    diff_h = np.abs(gray[1:, :] - gray[:-1, :])\n    diff_w = np.abs(gray[:, 1:] - gray[:, :-1])\n    max_diff = max(np.max(diff_h), np.max(diff_w))\n    return float(max_diff)\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Standard deviation of pixel intensities in the top half vs bottom half\"\n    h, w = image.shape[:2]\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    top_half = gray[:h//2, :]\n    bottom_half = gray[h//2:, :]\n    top_std = np.std(top_half)\n    bottom_std = np.std(bottom_half)\n    if bottom_std == 0:\n        return float(top_std)\n    return float(top_std / bottom_std)\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Percentage of pixels above the 90th percentile intensity\"\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    threshold = np.percentile(gray, 90)\n    high_intensity_pixels = np.sum(gray > threshold)\n    total_pixels = gray.size\n    return float(high_intensity_pixels / total_pixels)\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Average intensity difference between left and right halves\"\n    h, w = image.shape[:2]\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    left_half = gray[:, :w//2]\n    right_half = gray[:, w//2:]\n    left_mean = np.mean(left_half)\n    right_mean = np.mean(right_half)\n    return float(abs(left_mean - right_mean))\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Ratio of corner regions average intensity to center region\"\n    h, w = image.shape[:2]\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    corner_size = min(h//4, w//4)\n    if corner_size == 0:\n        return 1.0\n    corners = [gray[:corner_size, :corner_size], gray[:corner_size, -corner_size:],\n               gray[-corner_size:, :corner_size], gray[-corner_size:, -corner_size:]]\n    corner_mean = np.mean([np.mean(corner) for corner in corners])\n    center = gray[h//4:3*h//4, w//4:3*w//4]\n    center_mean = np.mean(center)\n    if center_mean == 0:\n        return float(corner_mean)\n    return float(corner_mean / center_mean)\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Vertical gradient magnitude at image edges\"\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    h, w = gray.shape\n    if h < 2:\n        return 0.0\n    left_edge = gray[:, :w//8] if w >= 8 else gray[:, :1]\n    right_edge = gray[:, -w//8:] if w >= 8 else gray[:, -1:]\n    left_grad = np.mean(np.abs(np.gradient(left_edge, axis=0)))\n    right_grad = np.mean(np.abs(np.gradient(right_edge, axis=0)))\n    return float((left_grad + right_grad) / 2)\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Ratio of high frequency content in vertical vs horizontal gradients\"\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    if gray.shape[0] < 2 or gray.shape[1] < 2:\n        return 1.0\n    grad_y = np.abs(np.gradient(gray, axis=0))\n    grad_x = np.abs(np.gradient(gray, axis=1))\n    vertical_energy = np.sum(grad_y)\n    horizontal_energy = np.sum(grad_x)\n    if horizontal_energy == 0:\n        return float(vertical_energy)\n    return float(vertical_energy / horizontal_energy)\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Average intensity in corners relative to center region\"\n    h, w = image.shape[:2]\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    corner_size = min(h, w) // 6\n    if corner_size == 0:\n        return 1.0\n    corners = np.concatenate([\n        gray[:corner_size, :corner_size].flatten(),\n        gray[:corner_size, -corner_size:].flatten(),\n        gray[-corner_size:, :corner_size].flatten(),\n        gray[-corner_size:, -corner_size:].flatten()\n    ])\n    center_region = gray[h//4:3*h//4, w//4:3*w//4]\n    corner_mean = np.mean(corners)\n    center_mean = np.mean(center_region)\n    if center_mean == 0:\n        return float(corner_mean)\n    return float(corner_mean / center_mean)\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Variance of intensity values in top half of image\"\n    h, w = image.shape[:2]\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    top_half = gray[:h//2, :]\n    return float(np.var(top_half))\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Maximum intensity difference between any two adjacent pixels\"\n    h, w = image.shape[:2]\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    if h < 2 and w < 2:\n        return 0.0\n    max_diff = 0.0\n    if w > 1:\n        horizontal_diffs = np.abs(gray[:, 1:] - gray[:, :-1])\n        max_diff = max(max_diff, np.max(horizontal_diffs))\n    if h > 1:\n        vertical_diffs = np.abs(gray[1:, :] - gray[:-1, :])\n        max_diff = max(max_diff, np.max(vertical_diffs))\n    return float(max_diff)\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Fraction of pixels that are darker than the median intensity\"\n    median_intensity = np.median(image)\n    dark_pixels = np.count_nonzero(image < median_intensity)\n    total_pixels = image.size\n    return float(dark_pixels / total_pixels)\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Ratio of maximum to minimum intensity in each quadrant, averaged\"\n    h, w = image.shape[:2]\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    mid_h, mid_w = h // 2, w // 2\n    quadrants = [\n        gray[:mid_h, :mid_w], gray[:mid_h, mid_w:],\n        gray[mid_h:, :mid_w], gray[mid_h:, mid_w:]\n    ]\n    ratios = []\n    for quad in quadrants:\n        if quad.size > 0:\n            min_val = np.min(quad)\n            max_val = np.max(quad)\n            if min_val > 0:\n                ratios.append(max_val / min_val)\n    return float(np.mean(ratios)) if ratios else 1.0\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Standard deviation of row-wise average intensities\"\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    if gray.shape[0] == 0:\n        return 0.0\n    row_means = np.mean(gray, axis=1)\n    return float(np.std(row_means))\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Proportion of pixels within 20% of the median intensity\"\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    median_val = np.median(gray)\n    threshold = median_val * 0.2\n    close_pixels = np.count_nonzero(np.abs(gray - median_val) <= threshold)\n    total_pixels = gray.size\n    return float(close_pixels / total_pixels) if total_pixels > 0 else 0.0\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Ratio of 75th to 25th percentile intensity values\"\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    if gray.size == 0:\n        return 1.0\n    p25 = np.percentile(gray, 25)\n    p75 = np.percentile(gray, 75)\n    if p25 == 0:\n        return float(p75)\n    return float(p75 / p25)\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Average intensity of pixels along the main diagonal\"\n    h, w = image.shape[:2]\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    if h == 0 or w == 0:\n        return 0.0\n    diag_length = min(h, w)\n    diagonal_pixels = gray[np.arange(diag_length), np.arange(diag_length)]\n    return float(np.mean(diagonal_pixels))\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Coefficient of variation of column-wise average intensities\"\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    if gray.shape[1] == 0:\n        return 0.0\n    col_means = np.mean(gray, axis=0)\n    mean_val = np.mean(col_means)\n    if mean_val == 0:\n        return 0.0\n    return float(np.std(col_means) / mean_val)\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Ratio of bright pixels in top half vs bottom half of image\"\n    h, w = image.shape[:2]\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    threshold = np.mean(gray) + np.std(gray)\n    top_bright = np.sum(gray[:h//2, :] > threshold)\n    bottom_bright = np.sum(gray[h//2:, :] > threshold)\n    if bottom_bright == 0:\n        return float(top_bright)\n    return float(top_bright / bottom_bright)\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Average intensity of the four corner regions\"\n    h, w = image.shape[:2]\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    corner_size = min(h//4, w//4, 5)\n    if corner_size <= 0:\n        return float(np.mean(gray))\n    tl = np.mean(gray[:corner_size, :corner_size])\n    tr = np.mean(gray[:corner_size, -corner_size:])\n    bl = np.mean(gray[-corner_size:, :corner_size])\n    br = np.mean(gray[-corner_size:, -corner_size:])\n    return float((tl + tr + bl + br) / 4)\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Concentration of high intensity pixels in center vs edges\"\n    h, w = image.shape[:2]\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    center_h, center_w = h//4, w//4\n    center = gray[center_h:3*center_h, center_w:3*center_w]\n    threshold = np.percentile(gray, 75)\n    center_bright = np.sum(center > threshold)\n    total_bright = np.sum(gray > threshold)\n    if total_bright == 0:\n        return 0.0\n    return float(center_bright / total_bright)\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Ratio of maximum to minimum pixel intensities in each channel averaged\"\n    if len(image.shape) == 3:\n        ratios = []\n        for c in range(3):\n            channel = image[:, :, c]\n            min_val = np.min(channel)\n            max_val = np.max(channel)\n            if min_val == 0:\n                ratios.append(max_val)\n            else:\n                ratios.append(max_val / min_val)\n        return float(np.mean(ratios))\n    else:\n        min_val = np.min(image)\n        max_val = np.max(image)\n        if min_val == 0:\n            return float(max_val)\n        return float(max_val / min_val)\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Average absolute difference between pixels and image median\"\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    median_val = np.median(gray)\n    abs_diff = np.abs(gray - median_val)\n    return float(np.mean(abs_diff))\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Ratio of bright pixels (top 25%) to total pixels\"\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    threshold = np.percentile(gray, 75)\n    bright_pixels = np.sum(gray > threshold)\n    total_pixels = gray.size\n    return float(bright_pixels / total_pixels)\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Average green channel intensity relative to red channel intensity\"\n    if len(image.shape) == 3:\n        green_mean = np.mean(image[:, :, 1])\n        red_mean = np.mean(image[:, :, 0])\n        if red_mean == 0:\n            return float(green_mean)\n        return float(green_mean / red_mean)\n    else:\n        return 1.0\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Variance of pixel intensities in the top quarter of the image\"\n    h, w = image.shape[:2]\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    top_quarter = gray[:h//4, :]\n    return float(np.var(top_quarter))\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Ratio of edge pixels to total pixels using simple threshold\"\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    h, w = gray.shape\n    if h < 2 or w < 2:\n        return 0.0\n    grad_mag = np.sqrt(np.gradient(gray, axis=0)**2 + np.gradient(gray, axis=1)**2)\n    edge_threshold = np.mean(grad_mag) + np.std(grad_mag)\n    edge_pixels = np.sum(grad_mag > edge_threshold)\n    return float(edge_pixels / gray.size)\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Average intensity difference between left and right halves\"\n    h, w = image.shape[:2]\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    left_half = gray[:, :w//2]\n    right_half = gray[:, w//2:]\n    left_mean = np.mean(left_half)\n    right_mean = np.mean(right_half)\n    return float(abs(left_mean - right_mean))\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Fraction of pixels darker than the median intensity\"\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    median_val = np.median(gray)\n    dark_pixels = np.sum(gray < median_val)\n    return float(dark_pixels / gray.size)\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Range of pixel intensities normalized by maximum possible range\"\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    pixel_range = np.max(gray) - np.min(gray)\n    max_possible_range = 255.0\n    return float(pixel_range / max_possible_range)\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Ratio of bright pixels in corners vs center region\"\n    h, w = image.shape[:2]\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    threshold = np.mean(gray) + np.std(gray)\n    corner_size = min(h//4, w//4)\n    if corner_size < 1:\n        return 0.5\n    corners = np.concatenate([\n        gray[:corner_size, :corner_size].flatten(),\n        gray[:corner_size, -corner_size:].flatten(),\n        gray[-corner_size:, :corner_size].flatten(),\n        gray[-corner_size:, -corner_size:].flatten()\n    ])\n    center = gray[h//4:3*h//4, w//4:3*w//4]\n    corner_bright = np.mean(corners > threshold)\n    center_bright = np.mean(center > threshold) if center.size > 0 else 0\n    if center_bright == 0:\n        return float(corner_bright)\n    return float(corner_bright / center_bright)\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Variance of column-wise average intensities\"\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    col_means = np.mean(gray, axis=0)\n    return float(np.var(col_means))\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Ratio of pixels above 75th percentile to pixels below 25th percentile\"\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    p75 = np.percentile(gray, 75)\n    p25 = np.percentile(gray, 25)\n    high_count = np.sum(gray > p75)\n    low_count = np.sum(gray < p25)\n    if low_count == 0:\n        return float(high_count)\n    return float(high_count / low_count)\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Average magnitude of second-order vertical gradients\"\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    if gray.shape[0] < 3:\n        return 0.0\n    first_grad = np.gradient(gray, axis=0)\n    second_grad = np.gradient(first_grad, axis=0)\n    return float(np.mean(np.abs(second_grad)))\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Difference between maximum and minimum row averages\"\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    row_means = np.mean(gray, axis=1)\n    return float(np.max(row_means) - np.min(row_means))\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Fraction of pixels that are local maxima in 3x3 neighborhoods\"\n    h, w = image.shape[:2]\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    if h < 3 or w < 3:\n        return 0.0\n    local_max_count = 0\n    for i in range(1, h-1):\n        for j in range(1, w-1):\n            neighborhood = gray[i-1:i+2, j-1:j+2]\n            if gray[i, j] == np.max(neighborhood):\n                local_max_count += 1\n    return float(local_max_count / ((h-2) * (w-2)))\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Ratio of pixels in top half vs bottom half of image\"\n    h, w = image.shape[:2]\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    top_half = np.mean(gray[:h//2, :])\n    bottom_half = np.mean(gray[h//2:, :])\n    if bottom_half == 0:\n        return float(top_half)\n    return float(top_half / bottom_half)\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Standard deviation of pixel intensities in each quadrant\"\n    h, w = image.shape[:2]\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    quad1 = np.std(gray[:h//2, :w//2])\n    quad2 = np.std(gray[:h//2, w//2:])\n    quad3 = np.std(gray[h//2:, :w//2])\n    quad4 = np.std(gray[h//2:, w//2:])\n    return float(np.mean([quad1, quad2, quad3, quad4]))\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Fraction of edge pixels with high gradient magnitude\"\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    if gray.shape[0] < 2 or gray.shape[1] < 2:\n        return 0.0\n    grad_y, grad_x = np.gradient(gray)\n    gradient_mag = np.sqrt(grad_x**2 + grad_y**2)\n    edge_threshold = np.percentile(gradient_mag, 90)\n    high_edge_pixels = np.count_nonzero(gradient_mag > edge_threshold)\n    return float(high_edge_pixels / gradient_mag.size)\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Skewness of pixel intensity distribution\"\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    pixels = gray.flatten()\n    mean_val = np.mean(pixels)\n    std_val = np.std(pixels)\n    if std_val == 0:\n        return 0.0\n    skewness = np.mean(((pixels - mean_val) / std_val) ** 3)\n    return float(skewness)\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Ratio of darkest to brightest 10 percent of pixels\"\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    dark_threshold = np.percentile(gray, 10)\n    bright_threshold = np.percentile(gray, 90)\n    if bright_threshold == 0:\n        return float(dark_threshold)\n    return float(dark_threshold / bright_threshold)\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Average distance from center for high intensity pixels\"\n    h, w = image.shape[:2]\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    center_y, center_x = h // 2, w // 2\n    threshold = np.percentile(gray, 80)\n    high_pixels = np.where(gray > threshold)\n    if len(high_pixels[0]) == 0:\n        return 0.0\n    distances = np.sqrt((high_pixels[0] - center_y)**2 + (high_pixels[1] - center_x)**2)\n    return float(np.mean(distances))\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Ratio of edge pixels in top half vs bottom half of image\"\n    h, w = image.shape[:2]\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    if h < 3 or w < 3:\n        return 1.0\n    grad_y = np.abs(np.gradient(gray, axis=0))\n    grad_x = np.abs(np.gradient(gray, axis=1))\n    edges = grad_x + grad_y\n    edge_threshold = np.percentile(edges, 80)\n    top_edges = np.sum(edges[:h//2, :] > edge_threshold)\n    bottom_edges = np.sum(edges[h//2:, :] > edge_threshold)\n    if bottom_edges == 0:\n        return float(top_edges)\n    return float(top_edges / bottom_edges)\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Average intensity variance in non-overlapping 8x8 blocks\"\n    h, w = image.shape[:2]\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    block_size = 8\n    if h < block_size or w < block_size:\n        return float(np.var(gray))\n    variances = []\n    for i in range(0, h - block_size + 1, block_size):\n        for j in range(0, w - block_size + 1, block_size):\n            block = gray[i:i+block_size, j:j+block_size]\n            variances.append(np.var(block))\n    return float(np.mean(variances))\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Ratio of green channel to red plus blue channels\"\n    if len(image.shape) == 3:\n        green_mean = np.mean(image[:, :, 1])\n        red_blue_mean = (np.mean(image[:, :, 0]) + np.mean(image[:, :, 2])) / 2\n        if red_blue_mean == 0:\n            return float(green_mean)\n        return float(green_mean / red_blue_mean)\n    else:\n        return 1.0\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Concentration of pixels in middle intensity range (25th to 75th percentile)\"\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    p25 = np.percentile(gray, 25)\n    p75 = np.percentile(gray, 75)\n    middle_range_pixels = np.count_nonzero((gray >= p25) & (gray <= p75))\n    return float(middle_range_pixels / gray.size)\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Maximum intensity difference between any two adjacent pixels\"\n    h, w = image.shape[:2]\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    if h < 2 or w < 2:\n        return 0.0\n    horizontal_diff = np.abs(gray[:, 1:] - gray[:, :-1])\n    vertical_diff = np.abs(gray[1:, :] - gray[:-1, :])\n    max_h_diff = np.max(horizontal_diff)\n    max_v_diff = np.max(vertical_diff)\n    return float(max(max_h_diff, max_v_diff))\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Variance of pixel intensities in the top quarter of the image\"\n    h, w = image.shape[:2]\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    top_quarter = gray[:h//4, :]\n    if top_quarter.size == 0:\n        return 0.0\n    return float(np.var(top_quarter))\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Number of pixels above 80th percentile intensity threshold\"\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    threshold = np.percentile(gray, 80)\n    bright_pixels = np.sum(gray > threshold)\n    return float(bright_pixels / gray.size)\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Average green channel intensity relative to red channel intensity\"\n    if len(image.shape) == 3:\n        green_mean = np.mean(image[:, :, 1])\n        red_mean = np.mean(image[:, :, 0])\n        if red_mean == 0:\n            return float(green_mean)\n        return float(green_mean / red_mean)\n    else:\n        return 1.0\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Ratio of bottom half to top half average intensity\"\n    h, w = image.shape[:2]\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    top_mean = np.mean(gray[:h//2, :])\n    bottom_mean = np.mean(gray[h//2:, :])\n    if top_mean == 0:\n        return float(bottom_mean)\n    return float(bottom_mean / top_mean)\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Standard deviation of horizontal gradients across all rows\"\n    h, w = image.shape[:2]\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    if w < 2:\n        return 0.0\n    horizontal_grads = np.gradient(gray, axis=1)\n    return float(np.std(horizontal_grads))\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Average intensity in corner regions relative to center region\"\n    h, w = image.shape[:2]\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    corner_size = min(h//4, w//4)\n    if corner_size == 0:\n        return 1.0\n    corners = [gray[:corner_size, :corner_size], gray[:corner_size, -corner_size:],\n               gray[-corner_size:, :corner_size], gray[-corner_size:, -corner_size:]]\n    corner_mean = np.mean([np.mean(corner) for corner in corners])\n    center = gray[h//4:3*h//4, w//4:3*w//4]\n    center_mean = np.mean(center) if center.size > 0 else 1.0\n    if center_mean == 0:\n        return float(corner_mean)\n    return float(corner_mean / center_mean)\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Ratio of bright pixels in top half vs bottom half of image\"\n    h, w = image.shape[:2]\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    top_bright = np.count_nonzero(gray[:h//2, :] > 200)\n    bottom_bright = np.count_nonzero(gray[h//2:, :] > 200)\n    if bottom_bright == 0:\n        return float(top_bright)\n    return float(top_bright / bottom_bright)\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Average pixel intensity in circular center region vs outer region\"\n    h, w = image.shape[:2]\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    center_y, center_x = h // 2, w // 2\n    radius = min(h, w) // 4\n    y, x = np.ogrid[:h, :w]\n    mask = (x - center_x)**2 + (y - center_y)**2 <= radius**2\n    if np.count_nonzero(mask) == 0:\n        return 0.0\n    center_mean = np.mean(gray[mask])\n    outer_mean = np.mean(gray[~mask])\n    if outer_mean == 0:\n        return float(center_mean)\n    return float(center_mean / outer_mean)\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Percentage of pixels with dominant red channel\"\n    if len(image.shape) == 3:\n        red_dom = (image[:, :, 0] > image[:, :, 1]) & (image[:, :, 0] > image[:, :, 2])\n        return float(np.count_nonzero(red_dom) / image.size * 3)\n    else:\n        return 0.0\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Average absolute difference between adjacent diagonal pixels\"\n    h, w = image.shape[:2]\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    if h < 2 or w < 2:\n        return 0.0\n    diag_diff = np.abs(gray[1:, 1:] - gray[:-1, :-1])\n    return float(np.mean(diag_diff))\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Ratio of edge pixels in left vs right half of image\"\n    h, w = image.shape[:2]\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    if h < 2 or w < 2:\n        return 1.0\n    grad_mag = np.sqrt(np.gradient(gray, axis=0)**2 + np.gradient(gray, axis=1)**2)\n    edge_thresh = np.percentile(grad_mag, 75)\n    left_edges = np.count_nonzero(grad_mag[:, :w//2] > edge_thresh)\n    right_edges = np.count_nonzero(grad_mag[:, w//2:] > edge_thresh)\n    if right_edges == 0:\n        return float(left_edges)\n    return float(left_edges / right_edges)\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Variance of pixel intensities along the main diagonal\"\n    h, w = image.shape[:2]\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    diag_len = min(h, w)\n    diagonal = gray[np.arange(diag_len), np.arange(diag_len)]\n    return float(np.var(diagonal))\n",
  "def feature(image: np.ndarray) -> float:\n    \"Ratio of top half average intensity to bottom half average intensity\"\n    h, w = image.shape[:2]\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    mid_h = h // 2\n    top_half = np.mean(gray[:mid_h, :])\n    bottom_half = np.mean(gray[mid_h:, :])\n    if bottom_half == 0:\n        return float(top_half)\n    return float(top_half / bottom_half)\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Standard deviation of column-wise intensity averages\"\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    col_means = np.mean(gray, axis=0)\n    return float(np.std(col_means))\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Fraction of pixels brighter than the median intensity\"\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    median_val = np.median(gray)\n    bright_pixels = np.count_nonzero(gray > median_val)\n    total_pixels = gray.size\n    return float(bright_pixels / total_pixels)\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Average absolute difference between center region and overall image mean\"\n    h, w = image.shape[:2]\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    overall_mean = np.mean(gray)\n    center_region = gray[h//4:3*h//4, w//4:3*w//4]\n    if center_region.size == 0:\n        return 0.0\n    center_mean = np.mean(center_region)\n    return float(abs(center_mean - overall_mean))\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Ratio of diagonal gradient magnitude to horizontal gradient magnitude\"\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    if gray.shape[0] < 2 or gray.shape[1] < 2:\n        return 1.0\n    h, w = gray.shape\n    diag1 = np.abs(gray[1:, 1:] - gray[:-1, :-1])\n    diag2 = np.abs(gray[1:, :-1] - gray[:-1, 1:])\n    diagonal_energy = np.sum(diag1) + np.sum(diag2)\n    horizontal_grad = np.abs(gray[:, 1:] - gray[:, :-1])\n    horizontal_energy = np.sum(horizontal_grad)\n    if horizontal_energy == 0:\n        return float(diagonal_energy)\n    return float(diagonal_energy / horizontal_energy)\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Percentage of pixels in the darkest 25th percentile\"\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    threshold = np.percentile(gray, 25)\n    dark_pixels = np.count_nonzero(gray <= threshold)\n    total_pixels = gray.size\n    return float(dark_pixels / total_pixels)\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Ratio of high intensity pixels in center vs edges of image\"\n    h, w = image.shape[:2]\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    threshold = np.percentile(gray, 75)\n    center_h, center_w = h//4, w//4\n    center = gray[center_h:3*center_h, center_w:3*center_w]\n    edge_mask = np.ones_like(gray, dtype=bool)\n    edge_mask[center_h:3*center_h, center_w:3*center_w] = False\n    center_high = np.sum(center > threshold)\n    edge_high = np.sum(gray[edge_mask] > threshold)\n    if edge_high == 0:\n        return float(center_high)\n    return float(center_high / edge_high)\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Standard deviation of pixel intensities in vertical strips\"\n    h, w = image.shape[:2]\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    if w < 3:\n        return float(np.std(gray))\n    strip_width = max(1, w // 5)\n    strip_stds = []\n    for i in range(0, w, strip_width):\n        strip = gray[:, i:min(i+strip_width, w)]\n        strip_stds.append(np.std(strip))\n    return float(np.mean(strip_stds))\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Ratio of pixels above mean in left vs right half\"\n    h, w = image.shape[:2]\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    mean_val = np.mean(gray)\n    left_above = np.sum(gray[:, :w//2] > mean_val)\n    right_above = np.sum(gray[:, w//2:] > mean_val)\n    if right_above == 0:\n        return float(left_above)\n    return float(left_above / right_above)\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Average of absolute differences between each pixel and image mean\"\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    mean_val = np.mean(gray)\n    abs_diffs = np.abs(gray - mean_val)\n    return float(np.mean(abs_diffs))\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Ratio of horizontal to vertical edge energy using Sobel-like filters\"\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    h, w = gray.shape\n    if h < 3 or w < 3:\n        return 1.0\n    horizontal_edges = np.abs(gray[:-2, :] - gray[2:, :])\n    vertical_edges = np.abs(gray[:, :-2] - gray[:, 2:])\n    h_energy = np.sum(horizontal_edges)\n    v_energy = np.sum(vertical_edges)\n    if v_energy == 0:\n        return float(h_energy)\n    return float(h_energy / v_energy)\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Percentage of pixels in the darkest quartile of intensity\"\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    threshold = np.percentile(gray, 25)\n    dark_pixels = np.sum(gray <= threshold)\n    total_pixels = gray.size\n    return float(dark_pixels / total_pixels)\n",
  "def feature(image: np.ndarray) -> float:\n    \"Ratio of edge pixels concentrated in center vs outer regions\"\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    h, w = gray.shape\n    if h < 3 or w < 3:\n        return 1.0\n    edges = np.abs(np.gradient(gray, axis=0)) + np.abs(np.gradient(gray, axis=1))\n    edge_threshold = np.percentile(edges, 75)\n    center_edges = np.count_nonzero(edges[h//4:3*h//4, w//4:3*w//4] > edge_threshold)\n    outer_edges = np.count_nonzero(edges > edge_threshold) - center_edges\n    if outer_edges == 0:\n        return float(center_edges)\n    return float(center_edges / outer_edges)\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Average intensity difference between adjacent horizontal pixel pairs\"\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    h, w = gray.shape\n    if w < 2:\n        return 0.0\n    horizontal_diffs = np.abs(gray[:, 1:] - gray[:, :-1])\n    return float(np.mean(horizontal_diffs))\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Ratio of pixels in corners vs center cross pattern\"\n    h, w = image.shape[:2]\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    corner_size = min(h//4, w//4)\n    if corner_size == 0:\n        return 1.0\n    corners = (gray[:corner_size, :corner_size].sum() + \n              gray[:corner_size, -corner_size:].sum() +\n              gray[-corner_size:, :corner_size].sum() + \n              gray[-corner_size:, -corner_size:].sum())\n    cross = (gray[h//4:3*h//4, w//2-w//8:w//2+w//8].sum() +\n             gray[h//2-h//8:h//2+h//8, w//4:3*w//4].sum())\n    if cross == 0:\n        return float(corners)\n    return float(corners / cross)\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Standard deviation of pixel intensities along the main diagonal\"\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    h, w = gray.shape\n    diag_len = min(h, w)\n    if diag_len == 0:\n        return 0.0\n    diagonal_pixels = np.array([gray[i, i] for i in range(diag_len)])\n    return float(np.std(diagonal_pixels))\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Percentage of pixels that are local maxima in 3x3 neighborhoods\"\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    h, w = gray.shape\n    if h < 3 or w < 3:\n        return 0.0\n    local_maxima = 0\n    for i in range(1, h-1):\n        for j in range(1, w-1):\n            neighborhood = gray[i-1:i+2, j-1:j+2]\n            if gray[i, j] == np.max(neighborhood):\n                local_maxima += 1\n    return float(local_maxima / ((h-2) * (w-2)))\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Average intensity difference between corner regions and center region\"\n    h, w = image.shape[:2]\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    if h < 4 or w < 4:\n        return 0.0\n    corner_size = min(h//4, w//4)\n    corners = [gray[:corner_size, :corner_size], \n               gray[:corner_size, -corner_size:],\n               gray[-corner_size:, :corner_size], \n               gray[-corner_size:, -corner_size:]]\n    corner_mean = np.mean([np.mean(corner) for corner in corners])\n    center = gray[h//4:3*h//4, w//4:3*w//4]\n    center_mean = np.mean(center)\n    return float(abs(corner_mean - center_mean))\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Average intensity of the brightest 5% of pixels\"\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    flat = gray.flatten()\n    threshold = np.percentile(flat, 95)\n    bright_pixels = flat[flat >= threshold]\n    if len(bright_pixels) == 0:\n        return float(np.max(gray))\n    return float(np.mean(bright_pixels))\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Ratio of average intensity in left half versus right half of image\"\n    h, w = image.shape[:2]\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    mid_w = w // 2\n    left_mean = np.mean(gray[:, :mid_w])\n    right_mean = np.mean(gray[:, mid_w:])\n    if right_mean == 0:\n        return float(left_mean)\n    return float(left_mean / right_mean)\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Standard deviation of local patch variances using 3x3 neighborhoods\"\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    h, w = gray.shape\n    if h < 3 or w < 3:\n        return float(np.std(gray))\n    patch_vars = []\n    for i in range(1, h-1):\n        for j in range(1, w-1):\n            patch = gray[i-1:i+2, j-1:j+2]\n            patch_vars.append(np.var(patch))\n    return float(np.std(patch_vars))\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Average intensity of pixels in the top third of the image\"\n    h, w = image.shape[:2]\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    top_third = gray[:h//3, :]\n    return float(np.mean(top_third))\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Ratio of pixels above 75th percentile in corners vs center\"\n    h, w = image.shape[:2]\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    threshold = np.percentile(gray, 75)\n    corner_size = min(h//4, w//4)\n    corners = np.concatenate([\n        gray[:corner_size, :corner_size].flatten(),\n        gray[:corner_size, -corner_size:].flatten(),\n        gray[-corner_size:, :corner_size].flatten(),\n        gray[-corner_size:, -corner_size:].flatten()\n    ])\n    center_h, center_w = h//4, w//4\n    center = gray[center_h:3*center_h, center_w:3*center_w]\n    corner_bright = np.sum(corners > threshold)\n    center_bright = np.sum(center > threshold)\n    if center_bright == 0:\n        return float(corner_bright)\n    return float(corner_bright / center_bright)\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Maximum difference between any two color channels\"\n    if len(image.shape) == 3:\n        r_mean = np.mean(image[:, :, 0])\n        g_mean = np.mean(image[:, :, 1])\n        b_mean = np.mean(image[:, :, 2])\n        return float(max(abs(r_mean - g_mean), abs(r_mean - b_mean), abs(g_mean - b_mean)))\n    else:\n        return 0.0\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Ratio of dark pixels (below 25th percentile) to bright pixels (above 75th percentile)\"\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    p25 = np.percentile(gray, 25)\n    p75 = np.percentile(gray, 75)\n    dark_pixels = np.sum(gray < p25)\n    bright_pixels = np.sum(gray > p75)\n    if bright_pixels == 0:\n        return float(dark_pixels)\n    return float(dark_pixels / bright_pixels)\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Average intensity difference between adjacent vertical pixel pairs\"\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    if gray.shape[0] < 2:\n        return 0.0\n    vertical_diffs = np.abs(gray[1:, :] - gray[:-1, :])\n    return float(np.mean(vertical_diffs))\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Intensity range (max - min) in the central quarter of the image\"\n    h, w = image.shape[:2]\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    center_h, center_w = h//4, w//4\n    center_region = gray[center_h:3*center_h, center_w:3*center_w]\n    if center_region.size == 0:\n        center_region = gray\n    return float(np.max(center_region) - np.min(center_region))\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Standard deviation of pixel intensities in corner regions vs center region\"\n    h, w = image.shape[:2]\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    if h < 4 or w < 4:\n        return 1.0\n    corner_size = min(h//4, w//4)\n    corners = [gray[:corner_size, :corner_size], gray[:corner_size, -corner_size:], \n               gray[-corner_size:, :corner_size], gray[-corner_size:, -corner_size:]]\n    corner_std = np.mean([np.std(corner) for corner in corners])\n    center = gray[h//4:3*h//4, w//4:3*w//4]\n    center_std = np.std(center)\n    if center_std == 0:\n        return float(corner_std)\n    return float(corner_std / center_std)\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Fraction of pixels that are darker than the median intensity\"\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    if gray.size == 0:\n        return 0.0\n    median_val = np.median(gray)\n    dark_pixels = np.count_nonzero(gray < median_val)\n    total_pixels = gray.size\n    return float(dark_pixels / total_pixels)\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Ratio of maximum to minimum color channel variance\"\n    if len(image.shape) == 3:\n        r_var = np.var(image[:, :, 0])\n        g_var = np.var(image[:, :, 1])\n        b_var = np.var(image[:, :, 2])\n        max_var = max(r_var, g_var, b_var)\n        min_var = min(r_var, g_var, b_var)\n        if min_var == 0:\n            return float(max_var)\n        return float(max_var / min_var)\n    else:\n        return 1.0\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Average intensity difference between adjacent pixel pairs in scan-line order\"\n    h, w = image.shape[:2]\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    if h < 1 or w < 2:\n        return 0.0\n    horizontal_diffs = np.abs(gray[:, 1:] - gray[:, :-1])\n    return float(np.mean(horizontal_diffs))\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Concentration of high-intensity pixels in circular center region\"\n    h, w = image.shape[:2]\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    center_y, center_x = h // 2, w // 2\n    radius = min(h, w) // 4\n    y_coords, x_coords = np.ogrid[:h, :w]\n    mask = (y_coords - center_y)**2 + (x_coords - center_x)**2 <= radius**2\n    if np.sum(mask) == 0:\n        return 0.0\n    center_bright = np.count_nonzero((gray > 180) & mask)\n    total_center = np.sum(mask)\n    return float(center_bright / total_center)\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Ratio of top half to bottom half average intensity\"\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    h, w = gray.shape\n    if h < 2:\n        return 1.0\n    top_half = np.mean(gray[:h//2, :])\n    bottom_half = np.mean(gray[h//2:, :])\n    if bottom_half == 0:\n        return float(top_half)\n    return float(top_half / bottom_half)\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Standard deviation of pixel intensities in corner regions\"\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    h, w = gray.shape\n    if h < 4 or w < 4:\n        return 0.0\n    corner_size = min(h//4, w//4)\n    if corner_size < 1:\n        return 0.0\n    corners = []\n    corners.append(gray[:corner_size, :corner_size])\n    corners.append(gray[:corner_size, -corner_size:])\n    corners.append(gray[-corner_size:, :corner_size])\n    corners.append(gray[-corner_size:, -corner_size:])\n    corner_stds = [np.std(corner) for corner in corners]\n    return float(np.mean(corner_stds))\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Fraction of pixels below 20th percentile intensity\"\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    if gray.size == 0:\n        return 0.0\n    threshold = np.percentile(gray, 20)\n    low_pixels = np.sum(gray < threshold)\n    return float(low_pixels / gray.size)\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Ratio of left half to right half average intensity\"\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    h, w = gray.shape\n    if w < 2:\n        return 1.0\n    left_half = np.mean(gray[:, :w//2])\n    right_half = np.mean(gray[:, w//2:])\n    if right_half == 0:\n        return float(left_half)\n    return float(left_half / right_half)\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Contrast between center region and border region\"\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    h, w = gray.shape\n    if h < 6 or w < 6:\n        return 0.0\n    center_margin = min(h//4, w//4)\n    center = gray[center_margin:-center_margin, center_margin:-center_margin]\n    border = np.concatenate([\n        gray[:center_margin, :].flatten(),\n        gray[-center_margin:, :].flatten(),\n        gray[:, :center_margin].flatten(),\n        gray[:, -center_margin:].flatten()\n    ])\n    if border.size == 0:\n        return 0.0\n    return float(abs(np.mean(center) - np.mean(border)))\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Ratio of maximum to minimum pixel intensity plus 1\"\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    if gray.size == 0:\n        return 1.0\n    max_val = np.max(gray)\n    min_val = np.min(gray)\n    return float(max_val / (min_val + 1))\n",
  "def feature(image: np.ndarray) -> float:\n    \"Variance of pixel intensities in corner regions vs center region\"\n    h, w = image.shape[:2]\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    corner_size = min(h, w) // 4\n    corners = np.concatenate([\n        gray[:corner_size, :corner_size].flatten(),\n        gray[:corner_size, -corner_size:].flatten(),\n        gray[-corner_size:, :corner_size].flatten(),\n        gray[-corner_size:, -corner_size:].flatten()\n    ])\n    center = gray[h//4:3*h//4, w//4:3*w//4]\n    corner_var = np.var(corners) if len(corners) > 0 else 0\n    center_var = np.var(center) if center.size > 0 else 0\n    if center_var == 0:\n        return float(corner_var)\n    return float(corner_var / center_var)\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Ratio of pixels in highest intensity quartile to lowest intensity quartile\"\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    q25, q75 = np.percentile(gray, [25, 75])\n    low_count = np.count_nonzero(gray <= q25)\n    high_count = np.count_nonzero(gray >= q75)\n    if low_count == 0:\n        return float(high_count)\n    return float(high_count / low_count)\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Average intensity difference between adjacent horizontal pixel pairs\"\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    if gray.shape[1] < 2:\n        return 0.0\n    horizontal_diffs = np.abs(gray[:, 1:] - gray[:, :-1])\n    return float(np.mean(horizontal_diffs))\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Ratio of non-zero pixels in left half vs right half of image\"\n    h, w = image.shape[:2]\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    left_nonzero = np.count_nonzero(gray[:, :w//2])\n    right_nonzero = np.count_nonzero(gray[:, w//2:])\n    if right_nonzero == 0:\n        return float(left_nonzero)\n    return float(left_nonzero / right_nonzero)\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Standard deviation of row-wise mean intensities\"\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    row_means = np.mean(gray, axis=1)\n    return float(np.std(row_means))\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Ratio of maximum to minimum pixel intensity in the image\"\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    max_val = np.max(gray)\n    min_val = np.min(gray)\n    if min_val == 0:\n        return float(max_val)\n    return float(max_val / min_val)\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Percentage of pixels in the top third of the image that are brighter than average\"\n    h, w = image.shape[:2]\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    if h < 3:\n        return 0.0\n    top_third = gray[:h//3, :]\n    avg_brightness = np.mean(gray)\n    bright_pixels = np.count_nonzero(top_third > avg_brightness)\n    return float(bright_pixels / top_third.size)\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Average color saturation computed as max minus min RGB values per pixel\"\n    if len(image.shape) == 3:\n        max_rgb = np.max(image, axis=2)\n        min_rgb = np.min(image, axis=2)\n        saturation = max_rgb - min_rgb\n        return float(np.mean(saturation))\n    else:\n        return 0.0\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Ratio of pixels in bottom half that are darker than pixels in top half\"\n    h, w = image.shape[:2]\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    if h < 2:\n        return 1.0\n    top_half = gray[:h//2, :]\n    bottom_half = gray[h//2:, :]\n    top_mean = np.mean(top_half)\n    dark_bottom_pixels = np.count_nonzero(bottom_half < top_mean)\n    return float(dark_bottom_pixels / bottom_half.size)\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Standard deviation of pixel intensities in the outer border region\"\n    h, w = image.shape[:2]\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    border_width = min(h, w) // 8\n    if border_width == 0:\n        return float(np.std(gray))\n    border_mask = np.ones((h, w), dtype=bool)\n    border_mask[border_width:h-border_width, border_width:w-border_width] = False\n    border_pixels = gray[border_mask]\n    return float(np.std(border_pixels))\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Ratio of circular regions with high variance to total circular regions\"\n    h, w = image.shape[:2]\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    radius = min(h, w) // 8\n    if radius < 2:\n        return 0.0\n    y, x = np.ogrid[:h, :w]\n    high_var_regions = 0\n    total_regions = 0\n    for cy in range(radius, h-radius, radius):\n        for cx in range(radius, w-radius, radius):\n            mask = (x - cx)**2 + (y - cy)**2 <= radius**2\n            region_pixels = gray[mask]\n            if len(region_pixels) > 0:\n                total_regions += 1\n                if np.var(region_pixels) > np.var(gray) / 2:\n                    high_var_regions += 1\n    return float(high_var_regions / max(total_regions, 1))\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Variance of pixel intensities across color channels\"\n    if len(image.shape) == 3:\n        channel_means = [np.mean(image[:, :, i]) for i in range(3)]\n        return float(np.var(channel_means))\n    else:\n        return 0.0\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Ratio of dark pixels in left half vs right half of image\"\n    h, w = image.shape[:2]\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    left_half = gray[:, :w//2]\n    right_half = gray[:, w//2:]\n    left_dark = np.sum(left_half < 80)\n    right_dark = np.sum(right_half < 80)\n    if right_dark == 0:\n        return float(left_dark)\n    return float(left_dark / right_dark)\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Skewness of pixel intensity distribution\"\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    pixels = gray.flatten()\n    mean_val = np.mean(pixels)\n    std_val = np.std(pixels)\n    if std_val == 0:\n        return 0.0\n    skew = np.mean(((pixels - mean_val) / std_val) ** 3)\n    return float(skew)\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Ratio of maximum to minimum pixel intensity in each quadrant\"\n    h, w = image.shape[:2]\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    quadrants = [\n        gray[:h//2, :w//2],\n        gray[:h//2, w//2:],\n        gray[h//2:, :w//2],\n        gray[h//2:, w//2:]\n    ]\n    ratios = []\n    for quad in quadrants:\n        max_val = np.max(quad)\n        min_val = np.min(quad)\n        if min_val == 0:\n            ratios.append(max_val)\n        else:\n            ratios.append(max_val / min_val)\n    return float(np.mean(ratios))\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Correlation between adjacent horizontal pixel pairs\"\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    h, w = gray.shape\n    if w < 2:\n        return 0.0\n    left_pixels = gray[:, :-1].flatten()\n    right_pixels = gray[:, 1:].flatten()\n    if np.std(left_pixels) == 0 or np.std(right_pixels) == 0:\n        return 0.0\n    correlation = np.corrcoef(left_pixels, right_pixels)[0, 1]\n    return float(correlation) if not np.isnan(correlation) else 0.0\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Average green channel intensity relative to red channel intensity\"\n    if len(image.shape) == 3:\n        green_mean = np.mean(image[:, :, 1])\n        red_mean = np.mean(image[:, :, 0])\n        if red_mean == 0:\n            return float(green_mean)\n        return float(green_mean / red_mean)\n    else:\n        return 1.0\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Ratio of bright pixels in bottom half vs top half of image\"\n    h, w = image.shape[:2]\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    top_half = gray[:h//2, :]\n    bottom_half = gray[h//2:, :]\n    top_bright = np.sum(top_half > 128)\n    bottom_bright = np.sum(bottom_half > 128)\n    if top_bright == 0:\n        return float(bottom_bright)\n    return float(bottom_bright / top_bright)\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Circular symmetry measure using radial intensity profile\"\n    h, w = image.shape[:2]\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    center_y, center_x = h // 2, w // 2\n    max_radius = min(center_y, center_x)\n    if max_radius < 2:\n        return 0.0\n    inner_circle = gray[center_y-max_radius//3:center_y+max_radius//3, center_x-max_radius//3:center_x+max_radius//3]\n    outer_ring = gray[center_y-max_radius:center_y+max_radius, center_x-max_radius:center_x+max_radius]\n    inner_mean = np.mean(inner_circle) if inner_circle.size > 0 else 0\n    outer_mean = np.mean(outer_ring) if outer_ring.size > 0 else 0\n    if outer_mean == 0:\n        return float(inner_mean)\n    return float(inner_mean / outer_mean)\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Average green channel intensity relative to red channel intensity\"\n    if len(image.shape) == 3:\n        green_mean = np.mean(image[:, :, 1])\n        red_mean = np.mean(image[:, :, 0])\n        if red_mean == 0:\n            return float(green_mean)\n        return float(green_mean / red_mean)\n    else:\n        return 1.0\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Texture complexity measured by local standard deviation\"\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    h, w = gray.shape\n    if h < 4 or w < 4:\n        return float(np.std(gray))\n    complexity = 0.0\n    count = 0\n    for i in range(0, h-2, 2):\n        for j in range(0, w-2, 2):\n            patch = gray[i:i+3, j:j+3]\n            complexity += np.std(patch)\n            count += 1\n    if count == 0:\n        return 0.0\n    return float(complexity / count)\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Standard deviation of pixel intensities in the top half vs bottom half\"\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    h, w = gray.shape\n    top_half = gray[:h//2, :]\n    bottom_half = gray[h//2:, :]\n    top_std = np.std(top_half)\n    bottom_std = np.std(bottom_half)\n    if bottom_std == 0:\n        return float(top_std)\n    return float(top_std / bottom_std)\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Fraction of pixels that are local maxima in 3x3 neighborhoods\"\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    h, w = gray.shape\n    if h < 3 or w < 3:\n        return 0.0\n    local_maxima = 0\n    for i in range(1, h-1):\n        for j in range(1, w-1):\n            center = gray[i, j]\n            neighborhood = gray[i-1:i+2, j-1:j+2]\n            if center >= np.max(neighborhood):\n                local_maxima += 1\n    return float(local_maxima / ((h-2) * (w-2)))\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Average intensity difference between center and edge regions\"\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    h, w = gray.shape\n    center_region = gray[h//4:3*h//4, w//4:3*w//4]\n    edge_mask = np.ones_like(gray, dtype=bool)\n    edge_mask[h//4:3*h//4, w//4:3*w//4] = False\n    edge_region = gray[edge_mask]\n    if len(edge_region) == 0 or len(center_region.flatten()) == 0:\n        return 0.0\n    return float(abs(np.mean(center_region) - np.mean(edge_region)))\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Ratio of pixels in darkest 10% to pixels in brightest 10%\"\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    dark_threshold = np.percentile(gray, 10)\n    bright_threshold = np.percentile(gray, 90)\n    dark_pixels = np.sum(gray <= dark_threshold)\n    bright_pixels = np.sum(gray >= bright_threshold)\n    if bright_pixels == 0:\n        return float(dark_pixels)\n    return float(dark_pixels / bright_pixels)\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Average absolute curvature of horizontal intensity profiles\"\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    h, w = gray.shape\n    if w < 3:\n        return 0.0\n    total_curvature = 0.0\n    for i in range(h):\n        row = gray[i, :]\n        if len(row) >= 3:\n            second_diff = row[2:] - 2*row[1:-1] + row[:-2]\n            total_curvature += np.sum(np.abs(second_diff))\n    return float(total_curvature / h)\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Average intensity difference between center and edge regions\"\n    h, w = image.shape[:2]\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    if h < 4 or w < 4:\n        return 0.0\n    center = gray[h//4:3*h//4, w//4:3*w//4]\n    edge_width = min(h//8, w//8, 5)\n    edges = np.concatenate([\n        gray[:edge_width, :].flatten(),\n        gray[-edge_width:, :].flatten(),\n        gray[:, :edge_width].flatten(),\n        gray[:, -edge_width:].flatten()\n    ])\n    center_mean = np.mean(center) if center.size > 0 else 0\n    edge_mean = np.mean(edges) if edges.size > 0 else 0\n    return float(abs(center_mean - edge_mean))\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Ratio of pixels in darkest quartile to brightest quartile\"\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    q25 = np.percentile(gray, 25)\n    q75 = np.percentile(gray, 75)\n    dark_pixels = np.count_nonzero(gray <= q25)\n    bright_pixels = np.count_nonzero(gray >= q75)\n    if bright_pixels == 0:\n        return float(dark_pixels)\n    return float(dark_pixels / bright_pixels)\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Maximum color channel difference for RGB images\"\n    if len(image.shape) == 3:\n        r_mean = np.mean(image[:, :, 0])\n        g_mean = np.mean(image[:, :, 1])\n        b_mean = np.mean(image[:, :, 2])\n        max_diff = max(abs(r_mean - g_mean), abs(g_mean - b_mean), abs(r_mean - b_mean))\n        return float(max_diff)\n    else:\n        return 0.0\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Variance of intensity values in a 3x3 grid of image regions\"\n    h, w = image.shape[:2]\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    if h < 3 or w < 3:\n        return float(np.var(gray))\n    region_means = []\n    for i in range(3):\n        for j in range(3):\n            start_h, end_h = i * h // 3, (i + 1) * h // 3\n            start_w, end_w = j * w // 3, (j + 1) * w // 3\n            region = gray[start_h:end_h, start_w:end_w]\n            if region.size > 0:\n                region_means.append(np.mean(region))\n    return float(np.var(region_means)) if len(region_means) > 0 else 0.0\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Texture roughness measured by local variance in 3x3 neighborhoods\"\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    h, w = gray.shape\n    if h < 3 or w < 3:\n        return 0.0\n    variances = []\n    for i in range(h-2):\n        for j in range(w-2):\n            patch = gray[i:i+3, j:j+3]\n            variances.append(np.var(patch))\n    return float(np.mean(variances))\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Concentration of high-intensity pixels in center vs edges\"\n    h, w = image.shape[:2]\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    center_h, center_w = h // 4, w // 4\n    center = gray[center_h:3*center_h, center_w:3*center_w]\n    edge_mask = np.ones_like(gray, dtype=bool)\n    edge_mask[center_h:3*center_h, center_w:3*center_w] = False\n    edges = gray[edge_mask]\n    if len(edges) == 0:\n        return 1.0\n    center_bright = np.mean(center > np.percentile(gray, 80))\n    edge_bright = np.mean(edges > np.percentile(gray, 80))\n    if edge_bright == 0:\n        return float(center_bright * 10)\n    return float(center_bright / edge_bright)\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Skewness of pixel intensity distribution\"\n    intensities = image.flatten()\n    if len(intensities) == 0:\n        return 0.0\n    mean_val = np.mean(intensities)\n    std_val = np.std(intensities)\n    if std_val == 0:\n        return 0.0\n    skewness = np.mean(((intensities - mean_val) / std_val) ** 3)\n    return float(skewness)\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Ratio of pixels in darkest quartile to brightest quartile\"\n    intensities = image.flatten()\n    q25 = np.percentile(intensities, 25)\n    q75 = np.percentile(intensities, 75)\n    dark_pixels = np.sum(intensities <= q25)\n    bright_pixels = np.sum(intensities >= q75)\n    if bright_pixels == 0:\n        return float(dark_pixels)\n    return float(dark_pixels / bright_pixels)\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Circular symmetry around image center\"\n    h, w = image.shape[:2]\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    center_y, center_x = h // 2, w // 2\n    max_radius = min(center_y, center_x)\n    if max_radius < 2:\n        return 0.0\n    angles = np.linspace(0, 2*np.pi, 8)\n    radius = max_radius // 2\n    values = []\n    for angle in angles:\n        y = int(center_y + radius * np.sin(angle))\n        x = int(center_x + radius * np.cos(angle))\n        if 0 <= y < h and 0 <= x < w:\n            values.append(gray[y, x])\n    if len(values) == 0:\n        return 0.0\n    return float(1.0 / (1.0 + np.std(values)))\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Standard deviation of pixel intensities in bottom half of image\"\n    h, w = image.shape[:2]\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    bottom_half = gray[h//2:, :]\n    return float(np.std(bottom_half))\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Ratio of maximum to minimum pixel intensity\"\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    max_val = np.max(gray)\n    min_val = np.min(gray)\n    if min_val == 0:\n        return float(max_val)\n    return float(max_val / min_val)\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Percentage of pixels in darkest quartile (below 25th percentile)\"\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    threshold = np.percentile(gray, 25)\n    dark_pixels = np.sum(gray <= threshold)\n    total_pixels = gray.size\n    return float(dark_pixels / total_pixels)\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Average absolute difference between adjacent pixels horizontally\"\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    h, w = gray.shape\n    if w < 2:\n        return 0.0\n    horizontal_diffs = np.abs(gray[:, 1:] - gray[:, :-1])\n    return float(np.mean(horizontal_diffs))\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Ratio of corner region intensity to center region intensity\"\n    h, w = image.shape[:2]\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    if h < 4 or w < 4:\n        return 1.0\n    corner_size = min(h//4, w//4)\n    corners = [gray[:corner_size, :corner_size], gray[:corner_size, -corner_size:],\n               gray[-corner_size:, :corner_size], gray[-corner_size:, -corner_size:]]\n    corner_mean = np.mean([np.mean(corner) for corner in corners])\n    center = gray[h//4:3*h//4, w//4:3*w//4]\n    center_mean = np.mean(center)\n    if center_mean == 0:\n        return float(corner_mean)\n    return float(corner_mean / center_mean)\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Variance of pixel intensities across all channels\"\n    if len(image.shape) == 3:\n        all_pixels = image.flatten()\n    else:\n        all_pixels = image.flatten()\n    return float(np.var(all_pixels))\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Ratio of bright pixels (>75th percentile) in top vs bottom half\"\n    h, w = image.shape[:2]\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    threshold = np.percentile(gray, 75)\n    top_bright = np.sum(gray[:h//2, :] > threshold)\n    bottom_bright = np.sum(gray[h//2:, :] > threshold)\n    if bottom_bright == 0:\n        return float(top_bright)\n    return float(top_bright / bottom_bright)\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Average pixel intensity in the top third of the image\"\n    h, w = image.shape[:2]\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    top_third = gray[:h//3, :]\n    return float(np.mean(top_third))\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Ratio of green to red channel mean intensity\"\n    if len(image.shape) == 3:\n        green_mean = np.mean(image[:, :, 1])\n        red_mean = np.mean(image[:, :, 0])\n        if red_mean == 0:\n            return float(green_mean)\n        return float(green_mean / red_mean)\n    else:\n        return 1.0\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Standard deviation of pixel intensities in center quarter of image\"\n    h, w = image.shape[:2]\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    center_h, center_w = h // 4, w // 4\n    center_region = gray[center_h:3*center_h, center_w:3*center_w]\n    return float(np.std(center_region))\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Proportion of pixels above median intensity\"\n    intensities = image.flatten()\n    median_val = np.median(intensities)\n    above_median = np.sum(intensities > median_val)\n    total_pixels = len(intensities)\n    return float(above_median / total_pixels)\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Maximum difference between adjacent horizontal pixels\"\n    h, w = image.shape[:2]\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    if w < 2:\n        return 0.0\n    horizontal_diffs = np.abs(gray[:, :-1] - gray[:, 1:])\n    return float(np.max(horizontal_diffs))\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Ratio of bottom half mean intensity to top half mean intensity\"\n    h, w = image.shape[:2]\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    top_half = gray[:h//2, :]\n    bottom_half = gray[h//2:, :]\n    top_mean = np.mean(top_half)\n    bottom_mean = np.mean(bottom_half)\n    if top_mean == 0:\n        return float(bottom_mean)\n    return float(bottom_mean / top_mean)\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Count of pixels with intensity exactly at the mode value\"\n    intensities = image.flatten().astype(int)\n    if len(intensities) == 0:\n        return 0.0\n    hist, bins = np.histogram(intensities, bins=256, range=(0, 255))\n    mode_value = np.argmax(hist)\n    mode_count = hist[mode_value]\n    return float(mode_count)\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Ratio of top half brightness to bottom half brightness\"\n    h, w = image.shape[:2]\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    mid_h = h // 2\n    top_mean = np.mean(gray[:mid_h, :])\n    bottom_mean = np.mean(gray[mid_h:, :])\n    if bottom_mean == 0:\n        return float(top_mean)\n    return float(top_mean / bottom_mean)\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Percentage of pixels above the 90th percentile intensity\"\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    threshold = np.percentile(gray, 90)\n    bright_pixels = np.count_nonzero(gray > threshold)\n    total_pixels = gray.size\n    return float(bright_pixels / total_pixels)\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Variance of row-wise intensity means\"\n    h, w = image.shape[:2]\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    row_means = np.mean(gray, axis=1)\n    return float(np.var(row_means))\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Ratio of center region brightness to border region brightness\"\n    h, w = image.shape[:2]\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    border_width = max(1, min(h, w) // 8)\n    center = gray[border_width:-border_width, border_width:-border_width]\n    border = gray.copy()\n    if center.size > 0:\n        border[border_width:-border_width, border_width:-border_width] = 0\n    center_mean = np.mean(center) if center.size > 0 else 0\n    border_mean = np.mean(border[border > 0]) if np.any(border > 0) else 1\n    return float(center_mean / border_mean)\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Maximum difference between red and green channels\"\n    if len(image.shape) == 3:\n        red_green_diff = np.abs(image[:, :, 0] - image[:, :, 1])\n        return float(np.max(red_green_diff))\n    else:\n        return 0.0\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Average intensity of pixels in four quadrants standard deviation\"\n    h, w = image.shape[:2]\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    mid_h, mid_w = h // 2, w // 2\n    q1 = np.mean(gray[:mid_h, :mid_w])\n    q2 = np.mean(gray[:mid_h, mid_w:])\n    q3 = np.mean(gray[mid_h:, :mid_w])\n    q4 = np.mean(gray[mid_h:, mid_w:])\n    quadrant_means = np.array([q1, q2, q3, q4])\n    return float(np.std(quadrant_means))\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Ratio of warm colors (red+yellow) to cool colors (blue+green) in RGB channels\"\n    if len(image.shape) == 3:\n        red = np.mean(image[:, :, 0])\n        green = np.mean(image[:, :, 1])\n        blue = np.mean(image[:, :, 2])\n        warm = red + (red + green) / 2\n        cool = blue + green\n        if cool == 0:\n            return float(warm)\n        return float(warm / cool)\n    else:\n        return 1.0\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Standard deviation of pixel intensities in corner regions vs center\"\n    h, w = image.shape[:2]\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    corner_size = min(h, w) // 4\n    if corner_size < 1:\n        return 0.0\n    corners = np.concatenate([\n        gray[:corner_size, :corner_size].flatten(),\n        gray[:corner_size, -corner_size:].flatten(),\n        gray[-corner_size:, :corner_size].flatten(),\n        gray[-corner_size:, -corner_size:].flatten()\n    ])\n    center = gray[h//4:3*h//4, w//4:3*w//4]\n    corner_std = np.std(corners) if len(corners) > 0 else 0.0\n    center_std = np.std(center) if center.size > 0 else 0.0\n    if center_std == 0:\n        return float(corner_std)\n    return float(corner_std / center_std)\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Fraction of pixels that are significantly darker than their 8-connected neighbors\"\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    h, w = gray.shape\n    if h < 3 or w < 3:\n        return 0.0\n    inner = gray[1:-1, 1:-1]\n    neighbors_sum = (gray[:-2, :-2] + gray[:-2, 1:-1] + gray[:-2, 2:] +\n                    gray[1:-1, :-2] + gray[1:-1, 2:] +\n                    gray[2:, :-2] + gray[2:, 1:-1] + gray[2:, 2:])\n    neighbors_avg = neighbors_sum / 8\n    darker_pixels = np.sum(inner < (neighbors_avg - 20))\n    total_pixels = inner.size\n    return float(darker_pixels / total_pixels)\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Average intensity difference between top and bottom halves of the image\"\n    h, w = image.shape[:2]\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    if h < 2:\n        return 0.0\n    top_half = np.mean(gray[:h//2, :])\n    bottom_half = np.mean(gray[h//2:, :])\n    return float(abs(top_half - bottom_half))\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Ratio of pixels in corners to center region\"\n    h, w = image.shape[:2]\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    if h < 6 or w < 6:\n        return 1.0\n    corner_size = min(h//4, w//4)\n    corners = np.concatenate([\n        gray[:corner_size, :corner_size].flatten(),\n        gray[:corner_size, -corner_size:].flatten(),\n        gray[-corner_size:, :corner_size].flatten(),\n        gray[-corner_size:, -corner_size:].flatten()\n    ])\n    center = gray[h//4:3*h//4, w//4:3*w//4]\n    corner_mean = np.mean(corners)\n    center_mean = np.mean(center)\n    if center_mean == 0:\n        return float(corner_mean)\n    return float(corner_mean / center_mean)\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Variance of local neighborhood standard deviations\"\n    h, w = image.shape[:2]\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    if h < 3 or w < 3:\n        return 0.0\n    local_stds = []\n    for i in range(0, h-2, 2):\n        for j in range(0, w-2, 2):\n            patch = gray[i:i+3, j:j+3]\n            local_stds.append(np.std(patch))\n    return float(np.var(local_stds)) if local_stds else 0.0\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Maximum color channel difference at any pixel location\"\n    if len(image.shape) != 3:\n        return 0.0\n    r, g, b = image[:,:,0], image[:,:,1], image[:,:,2]\n    max_diff = np.maximum(np.maximum(np.abs(r-g), np.abs(g-b)), np.abs(r-b))\n    return float(np.max(max_diff))\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Ratio of top half to bottom half average intensity\"\n    h, w = image.shape[:2]\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    if h < 2:\n        return 1.0\n    top_half = np.mean(gray[:h//2, :])\n    bottom_half = np.mean(gray[h//2:, :])\n    if bottom_half == 0:\n        return float(top_half)\n    return float(top_half / bottom_half)\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Variance of row-wise mean intensities\"\n    h, w = image.shape[:2]\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    if h < 1:\n        return 0.0\n    row_means = [np.mean(gray[i, :]) for i in range(h)]\n    return float(np.var(row_means))\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Ratio of corner regions average intensity to center region\"\n    h, w = image.shape[:2]\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    if h < 4 or w < 4:\n        return 1.0\n    corner_size = min(h//4, w//4)\n    corners = [gray[:corner_size, :corner_size], gray[:corner_size, -corner_size:],\n               gray[-corner_size:, :corner_size], gray[-corner_size:, -corner_size:]]\n    corner_mean = np.mean([np.mean(corner) for corner in corners])\n    center = gray[h//4:3*h//4, w//4:3*w//4]\n    center_mean = np.mean(center) if center.size > 0 else 1.0\n    if center_mean == 0:\n        return float(corner_mean)\n    return float(corner_mean / center_mean)\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Maximum intensity difference between adjacent rows\"\n    h, w = image.shape[:2]\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    if h < 2:\n        return 0.0\n    max_diff = 0.0\n    for i in range(h-1):\n        diff = np.abs(np.mean(gray[i, :]) - np.mean(gray[i+1, :]))\n        max_diff = max(max_diff, diff)\n    return float(max_diff)\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Fraction of pixels in middle intensity range (25th to 75th percentile)\"\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    if gray.size == 0:\n        return 0.0\n    p25 = np.percentile(gray, 25)\n    p75 = np.percentile(gray, 75)\n    middle_pixels = np.count_nonzero((gray >= p25) & (gray <= p75))\n    return float(middle_pixels / gray.size)\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Ratio of pixels in upper half vs lower half of image brightness\"\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    h, w = gray.shape\n    upper_half = gray[:h//2, :]\n    lower_half = gray[h//2:, :]\n    upper_mean = np.mean(upper_half)\n    lower_mean = np.mean(lower_half)\n    if lower_mean == 0:\n        return float(upper_mean)\n    return float(upper_mean / lower_mean)\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Proportion of pixels that are darker than the median intensity\"\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    median_val = np.median(gray)\n    dark_pixels = np.sum(gray < median_val)\n    total_pixels = gray.size\n    return float(dark_pixels / total_pixels)\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Maximum intensity difference between any two adjacent pixels\"\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    h, w = gray.shape\n    if h < 2 or w < 2:\n        return 0.0\n    horizontal_diffs = np.abs(gray[:, 1:] - gray[:, :-1])\n    vertical_diffs = np.abs(gray[1:, :] - gray[:-1, :])\n    max_diff = max(np.max(horizontal_diffs), np.max(vertical_diffs))\n    return float(max_diff)\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Average distance of pixels from image center weighted by intensity\"\n    h, w = image.shape[:2]\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    center_y, center_x = h // 2, w // 2\n    y_coords, x_coords = np.meshgrid(range(h), range(w), indexing='ij')\n    distances = np.sqrt((y_coords - center_y)**2 + (x_coords - center_x)**2)\n    weighted_distances = distances * gray\n    total_intensity = np.sum(gray)\n    if total_intensity == 0:\n        return float(np.mean(distances))\n    return float(np.sum(weighted_distances) / total_intensity)\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Ratio of pixels in corners vs center square region\"\n    h, w = image.shape[:2]\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    corner_size = min(h, w) // 4\n    corners = np.concatenate([\n        gray[:corner_size, :corner_size].flatten(),\n        gray[:corner_size, -corner_size:].flatten(),\n        gray[-corner_size:, :corner_size].flatten(),\n        gray[-corner_size:, -corner_size:].flatten()\n    ])\n    center = gray[h//4:3*h//4, w//4:3*w//4]\n    corner_mean = np.mean(corners)\n    center_mean = np.mean(center) if center.size > 0 else 1.0\n    if center_mean == 0:\n        return float(corner_mean)\n    return float(corner_mean / center_mean)\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Average intensity of the top quarter of the image\"\n    h, w = image.shape[:2]\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    top_quarter = gray[:h//4, :]\n    return float(np.mean(top_quarter)) if top_quarter.size > 0 else 0.0\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Percentage of pixels above the 75th percentile intensity\"\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    threshold = np.percentile(gray, 75)\n    bright_pixels = np.sum(gray > threshold)\n    total_pixels = gray.size\n    return float(bright_pixels / total_pixels) if total_pixels > 0 else 0.0\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Ratio of green to red channel variance\"\n    if len(image.shape) == 3:\n        green_var = np.var(image[:, :, 1])\n        red_var = np.var(image[:, :, 0])\n        if red_var == 0:\n            return float(green_var)\n        return float(green_var / red_var)\n    else:\n        return 1.0\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Average intensity difference between left and right halves\"\n    h, w = image.shape[:2]\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    if w < 2:\n        return 0.0\n    left_half = gray[:, :w//2]\n    right_half = gray[:, w//2:]\n    left_mean = np.mean(left_half)\n    right_mean = np.mean(right_half)\n    return float(abs(left_mean - right_mean))\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Standard deviation of pixel intensities in the four corner regions\"\n    h, w = image.shape[:2]\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    corner_size = min(h//4, w//4, 10)\n    if corner_size < 1:\n        return 0.0\n    corners = [\n        gray[:corner_size, :corner_size],\n        gray[:corner_size, -corner_size:],\n        gray[-corner_size:, :corner_size],\n        gray[-corner_size:, -corner_size:]\n    ]\n    corner_means = [np.mean(corner) for corner in corners]\n    return float(np.std(corner_means))\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Ratio of pixels in the darkest 20% to brightest 20%\"\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    dark_threshold = np.percentile(gray, 20)\n    bright_threshold = np.percentile(gray, 80)\n    dark_pixels = np.sum(gray <= dark_threshold)\n    bright_pixels = np.sum(gray >= bright_threshold)\n    if bright_pixels == 0:\n        return float(dark_pixels)\n    return float(dark_pixels / bright_pixels)\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Average absolute difference between adjacent pixels horizontally\"\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    h, w = gray.shape\n    if w < 2:\n        return 0.0\n    horizontal_diffs = np.abs(gray[:, 1:] - gray[:, :-1])\n    return float(np.mean(horizontal_diffs))\n",
  "def feature(image: np.ndarray) -> float:\n    \"Variance of intensity differences between adjacent pixels\"\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    h, w = gray.shape\n    if h < 2 or w < 2:\n        return 0.0\n    right_diff = np.abs(gray[:, 1:] - gray[:, :-1])\n    down_diff = np.abs(gray[1:, :] - gray[:-1, :])\n    all_diffs = np.concatenate([right_diff.flatten(), down_diff.flatten()])\n    return float(np.var(all_diffs))\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Ratio of pixels in darkest quartile to brightest quartile\"\n    intensities = image.flatten()\n    q25 = np.percentile(intensities, 25)\n    q75 = np.percentile(intensities, 75)\n    dark_count = np.sum(intensities <= q25)\n    bright_count = np.sum(intensities >= q75)\n    if bright_count == 0:\n        return float(dark_count)\n    return float(dark_count / bright_count)\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Average intensity difference between top and bottom halves\"\n    h, w = image.shape[:2]\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    top_half = gray[:h//2, :]\n    bottom_half = gray[h//2:, :]\n    top_mean = np.mean(top_half)\n    bottom_mean = np.mean(bottom_half)\n    return float(abs(top_mean - bottom_mean))\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Skewness of pixel intensity distribution\"\n    intensities = image.flatten()\n    mean_val = np.mean(intensities)\n    std_val = np.std(intensities)\n    if std_val == 0:\n        return 0.0\n    skew = np.mean(((intensities - mean_val) / std_val) ** 3)\n    return float(skew)\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Ratio of maximum to minimum pixel intensities in each color channel\"\n    if len(image.shape) == 3:\n        channel_ratios = []\n        for c in range(3):\n            channel = image[:, :, c]\n            min_val = np.min(channel)\n            max_val = np.max(channel)\n            if min_val == 0:\n                channel_ratios.append(max_val)\n            else:\n                channel_ratios.append(max_val / min_val)\n        return float(np.mean(channel_ratios))\n    else:\n        min_val = np.min(image)\n        max_val = np.max(image)\n        if min_val == 0:\n            return float(max_val)\n        return float(max_val / min_val)\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Standard deviation of row-wise mean intensities\"\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    row_means = np.mean(gray, axis=1)\n    return float(np.std(row_means))\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Ratio of green channel to red channel intensity\"\n    if len(image.shape) == 3:\n        green_mean = np.mean(image[:, :, 1])\n        red_mean = np.mean(image[:, :, 0])\n        if red_mean == 0:\n            return float(green_mean)\n        return float(green_mean / red_mean)\n    else:\n        return 1.0\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Standard deviation of intensities in the top half versus bottom half\"\n    h, w = image.shape[:2]\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    top_half = gray[:h//2, :]\n    bottom_half = gray[h//2:, :]\n    top_std = np.std(top_half)\n    bottom_std = np.std(bottom_half)\n    if bottom_std == 0:\n        return float(top_std)\n    return float(top_std / bottom_std)\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Proportion of pixels above the 90th percentile intensity\"\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    threshold = np.percentile(gray, 90)\n    high_intensity_pixels = np.sum(gray > threshold)\n    total_pixels = gray.size\n    return float(high_intensity_pixels / total_pixels)\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Average intensity difference between adjacent pixels horizontally\"\n    h, w = image.shape[:2]\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    if w < 2:\n        return 0.0\n    horizontal_diff = np.abs(gray[:, 1:] - gray[:, :-1])\n    return float(np.mean(horizontal_diff))\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Ratio of corner region intensity to center region intensity\"\n    h, w = image.shape[:2]\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    corner_size = min(h//4, w//4)\n    if corner_size == 0:\n        return 1.0\n    corners = np.concatenate([\n        gray[:corner_size, :corner_size].flatten(),\n        gray[:corner_size, -corner_size:].flatten(),\n        gray[-corner_size:, :corner_size].flatten(),\n        gray[-corner_size:, -corner_size:].flatten()\n    ])\n    center = gray[h//4:3*h//4, w//4:3*w//4]\n    corner_mean = np.mean(corners)\n    center_mean = np.mean(center)\n    if center_mean == 0:\n        return float(corner_mean)\n    return float(corner_mean / center_mean)\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Skewness of pixel intensity distribution\"\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    pixels = gray.flatten()\n    mean_val = np.mean(pixels)\n    std_val = np.std(pixels)\n    if std_val == 0:\n        return 0.0\n    skewness = np.mean(((pixels - mean_val) / std_val) ** 3)\n    return float(skewness)\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Variance of pixel intensities in the top half versus bottom half\"\n    h, w = image.shape[:2]\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    if h < 2:\n        return 0.0\n    top_half = gray[:h//2, :]\n    bottom_half = gray[h//2:, :]\n    top_var = np.var(top_half)\n    bottom_var = np.var(bottom_half)\n    if bottom_var == 0:\n        return float(top_var)\n    return float(top_var / bottom_var)\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Average distance from center pixel to edge pixels\"\n    h, w = image.shape[:2]\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    if h < 3 or w < 3:\n        return 0.0\n    center_val = gray[h//2, w//2]\n    edge_pixels = np.concatenate([gray[0, :], gray[-1, :], gray[:, 0], gray[:, -1]])\n    distances = np.abs(edge_pixels - center_val)\n    return float(np.mean(distances))\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Fraction of pixels in the upper quartile of intensity\"\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    if gray.size == 0:\n        return 0.0\n    threshold = np.percentile(gray, 75)\n    high_pixels = np.sum(gray >= threshold)\n    return float(high_pixels / gray.size)\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Ratio of intensity standard deviation in left vs right half\"\n    h, w = image.shape[:2]\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    if w < 2:\n        return 1.0\n    left_half = gray[:, :w//2]\n    right_half = gray[:, w//2:]\n    left_std = np.std(left_half)\n    right_std = np.std(right_half)\n    if right_std == 0:\n        return float(left_std)\n    return float(left_std / right_std)\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Intensity weighted center of mass distance from image center\"\n    h, w = image.shape[:2]\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    if gray.size == 0:\n        return 0.0\n    y_indices, x_indices = np.meshgrid(np.arange(h), np.arange(w), indexing='ij')\n    total_intensity = np.sum(gray)\n    if total_intensity == 0:\n        return 0.0\n    com_y = np.sum(y_indices * gray) / total_intensity\n    com_x = np.sum(x_indices * gray) / total_intensity\n    center_y, center_x = h / 2, w / 2\n    distance = np.sqrt((com_y - center_y)**2 + (com_x - center_x)**2)\n    return float(distance / max(h, w))\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Ratio of edge density in top half vs bottom half of image\"\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    h, w = gray.shape\n    if h < 2:\n        return 1.0\n    top_half = gray[:h//2, :]\n    bottom_half = gray[h//2:, :]\n    top_edges = np.sum(np.abs(np.gradient(top_half, axis=0))) + np.sum(np.abs(np.gradient(top_half, axis=1)))\n    bottom_edges = np.sum(np.abs(np.gradient(bottom_half, axis=0))) + np.sum(np.abs(np.gradient(bottom_half, axis=1)))\n    if bottom_edges == 0:\n        return float(top_edges)\n    return float(top_edges / bottom_edges)\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Standard deviation of pixel intensities in central circular region\"\n    h, w = image.shape[:2]\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    center_y, center_x = h // 2, w // 2\n    radius = min(h, w) // 4\n    y, x = np.ogrid[:h, :w]\n    mask = (x - center_x)**2 + (y - center_y)**2 <= radius**2\n    central_pixels = gray[mask]\n    return float(np.std(central_pixels)) if len(central_pixels) > 0 else 0.0\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Ratio of maximum to minimum pixel intensity in each RGB channel averaged\"\n    if len(image.shape) == 3:\n        ratios = []\n        for c in range(3):\n            channel = image[:, :, c]\n            min_val = np.min(channel)\n            max_val = np.max(channel)\n            if min_val == 0:\n                ratios.append(max_val)\n            else:\n                ratios.append(max_val / min_val)\n        return float(np.mean(ratios))\n    else:\n        min_val = np.min(image)\n        max_val = np.max(image)\n        if min_val == 0:\n            return float(max_val)\n        return float(max_val / min_val)\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Proportion of pixels that are locally maximum in 3x3 neighborhood\"\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    h, w = gray.shape\n    if h < 3 or w < 3:\n        return 0.0\n    local_maxima = 0\n    total_pixels = (h - 2) * (w - 2)\n    for i in range(1, h - 1):\n        for j in range(1, w - 1):\n            neighborhood = gray[i-1:i+2, j-1:j+2]\n            if gray[i, j] == np.max(neighborhood):\n                local_maxima += 1\n    return float(local_maxima / total_pixels) if total_pixels > 0 else 0.0\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Proportion of pixels in the top half that are brighter than the bottom half average\"\n    h, w = image.shape[:2]\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    if h < 2:\n        return 0.5\n    top_half = gray[:h//2, :]\n    bottom_half = gray[h//2:, :]\n    bottom_avg = np.mean(bottom_half)\n    bright_pixels = np.sum(top_half > bottom_avg)\n    return float(bright_pixels / (top_half.size))\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Standard deviation of pixel intensities in the center quarter of the image\"\n    h, w = image.shape[:2]\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    center_h_start, center_h_end = h//4, 3*h//4\n    center_w_start, center_w_end = w//4, 3*w//4\n    center_region = gray[center_h_start:center_h_end, center_w_start:center_w_end]\n    if center_region.size == 0:\n        return 0.0\n    return float(np.std(center_region))\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Ratio of corner brightness to center brightness\"\n    h, w = image.shape[:2]\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    corner_size = min(h//8, w//8, 5)\n    if corner_size == 0:\n        return 1.0\n    corners = [\n        gray[:corner_size, :corner_size],\n        gray[:corner_size, -corner_size:],\n        gray[-corner_size:, :corner_size],\n        gray[-corner_size:, -corner_size:]\n    ]\n    corner_brightness = np.mean([np.mean(corner) for corner in corners])\n    center_h, center_w = h//4, w//4\n    center_brightness = np.mean(gray[center_h:3*center_h, center_w:3*center_w])\n    if center_brightness == 0:\n        return float(corner_brightness)\n    return float(corner_brightness / center_brightness)\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Fraction of image area covered by pixels darker than the median\"\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    median_val = np.median(gray)\n    dark_pixels = np.sum(gray < median_val)\n    return float(dark_pixels / gray.size)\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Average absolute difference between adjacent pixels in the vertical direction\"\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    if gray.shape[0] < 2:\n        return 0.0\n    vertical_diffs = np.abs(gray[1:, :] - gray[:-1, :])\n    return float(np.mean(vertical_diffs))\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Concentration of high intensity pixels in center quarter of image\"\n    h, w = image.shape[:2]\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    center_h, center_w = h // 4, w // 4\n    center = gray[center_h:3*center_h, center_w:3*center_w]\n    threshold = np.percentile(gray, 80)\n    center_bright = np.count_nonzero(center >= threshold)\n    total_bright = np.count_nonzero(gray >= threshold)\n    if total_bright == 0:\n        return 0.0\n    return float(center_bright / total_bright)\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Symmetry measure between left and right halves of image\"\n    h, w = image.shape[:2]\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    left_half = gray[:, :w//2]\n    right_half = np.fliplr(gray[:, w//2:])\n    min_width = min(left_half.shape[1], right_half.shape[1])\n    left_crop = left_half[:, :min_width]\n    right_crop = right_half[:, :min_width]\n    diff = np.abs(left_crop - right_crop)\n    return float(1.0 / (1.0 + np.mean(diff)))\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Ratio of edge pixels in outer ring to total edge pixels\"\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    h, w = gray.shape\n    if h < 4 or w < 4:\n        return 0.0\n    edges = np.abs(np.gradient(gray)[0]) + np.abs(np.gradient(gray)[1])\n    edge_threshold = np.percentile(edges, 75)\n    total_edges = np.count_nonzero(edges >= edge_threshold)\n    border_thickness = min(h, w) // 8\n    outer_edges = edges.copy()\n    outer_edges[border_thickness:-border_thickness, border_thickness:-border_thickness] = 0\n    outer_edge_count = np.count_nonzero(outer_edges >= edge_threshold)\n    if total_edges == 0:\n        return 0.0\n    return float(outer_edge_count / total_edges)\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Standard deviation of local patch variances across the image\"\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    h, w = gray.shape\n    patch_size = min(h, w) // 8\n    if patch_size < 2:\n        return 0.0\n    variances = []\n    for i in range(0, h - patch_size + 1, patch_size):\n        for j in range(0, w - patch_size + 1, patch_size):\n            patch = gray[i:i+patch_size, j:j+patch_size]\n            variances.append(np.var(patch))\n    return float(np.std(variances))\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Average intensity difference between top and bottom halves of image\"\n    h, w = image.shape[:2]\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    if h < 2:\n        return 0.0\n    top_half = np.mean(gray[:h//2, :])\n    bottom_half = np.mean(gray[h//2:, :])\n    return float(abs(top_half - bottom_half))\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Ratio of pixels above 90th percentile to pixels below 10th percentile\"\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    flat = gray.flatten()\n    p90 = np.percentile(flat, 90)\n    p10 = np.percentile(flat, 10)\n    high_count = np.count_nonzero(flat >= p90)\n    low_count = np.count_nonzero(flat <= p10)\n    if low_count == 0:\n        return float(high_count)\n    return float(high_count / low_count)\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Maximum local intensity variation in 5x5 neighborhoods\"\n    h, w = image.shape[:2]\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    if h < 5 or w < 5:\n        return 0.0\n    max_var = 0.0\n    for i in range(0, h-4, 2):\n        for j in range(0, w-4, 2):\n            patch = gray[i:i+5, j:j+5]\n            var = np.var(patch)\n            max_var = max(max_var, var)\n    return float(max_var)\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Average distance from center for high intensity pixels\"\n    h, w = image.shape[:2]\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    threshold = np.mean(gray) + np.std(gray)\n    center_y, center_x = h // 2, w // 2\n    distances = []\n    for i in range(h):\n        for j in range(w):\n            if gray[i, j] > threshold:\n                dist = np.sqrt((i - center_y)**2 + (j - center_x)**2)\n                distances.append(dist)\n    if len(distances) == 0:\n        return 0.0\n    return float(np.mean(distances))\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Skewness of pixel intensity distribution\"\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    flat = gray.flatten()\n    mean_val = np.mean(flat)\n    std_val = np.std(flat)\n    if std_val == 0:\n        return 0.0\n    skewness = np.mean(((flat - mean_val) / std_val) ** 3)\n    return float(skewness)\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Average intensity difference between top and bottom halves of image\"\n    h, w = image.shape[:2]\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    top_half = np.mean(gray[:h//2, :])\n    bottom_half = np.mean(gray[h//2:, :])\n    return float(abs(top_half - bottom_half))\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Ratio of corner brightness to center brightness\"\n    h, w = image.shape[:2]\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    corner_size = min(h, w) // 8\n    if corner_size < 1:\n        corner_size = 1\n    corners = gray[:corner_size, :corner_size].mean() + gray[:corner_size, -corner_size:].mean() + gray[-corner_size:, :corner_size].mean() + gray[-corner_size:, -corner_size:].mean()\n    center = gray[h//4:3*h//4, w//4:3*w//4].mean()\n    if center == 0:\n        return float(corners)\n    return float(corners / (4 * center))\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Percentage of pixels with very low intensity (below 10th percentile)\"\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    threshold = np.percentile(gray, 10)\n    dark_pixels = np.count_nonzero(gray < threshold)\n    total_pixels = gray.size\n    return float(dark_pixels / total_pixels)\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Maximum intensity difference between adjacent horizontal pixels\"\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    if gray.shape[1] < 2:\n        return 0.0\n    horizontal_diffs = np.abs(gray[:, 1:] - gray[:, :-1])\n    return float(np.max(horizontal_diffs))\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Ratio of green channel mean to overall RGB mean\"\n    if len(image.shape) == 3:\n        green_mean = np.mean(image[:, :, 1])\n        overall_mean = np.mean(image)\n        if overall_mean == 0:\n            return float(green_mean)\n        return float(green_mean / overall_mean)\n    else:\n        return 1.0\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Coefficient of variation (std/mean) of pixel intensities\"\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    mean_val = np.mean(gray)\n    std_val = np.std(gray)\n    if mean_val == 0:\n        return float(std_val)\n    return float(std_val / mean_val)\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Skewness approximation using mean and median difference\"\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    mean_val = np.mean(gray)\n    median_val = np.median(gray)\n    std_val = np.std(gray)\n    if std_val == 0:\n        return 0.0\n    return float((mean_val - median_val) / std_val)\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Standard deviation of pixel intensities in the center quarter of the image\"\n    h, w = image.shape[:2]\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    center_h, center_w = h // 4, w // 4\n    center_region = gray[center_h:center_h + h//2, center_w:center_w + w//2]\n    return float(np.std(center_region)) if center_region.size > 0 else 0.0\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Ratio of edge pixels to total pixels using simple edge detection\"\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    h, w = gray.shape\n    if h < 2 or w < 2:\n        return 0.0\n    edges = np.abs(gray[:-1, :-1] - gray[1:, 1:]) + np.abs(gray[:-1, 1:] - gray[1:, :-1])\n    edge_pixels = np.sum(edges > np.mean(edges))\n    return float(edge_pixels / (h * w)) if h * w > 0 else 0.0\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Maximum intensity difference between adjacent pixels\"\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    h, w = gray.shape\n    if h < 2 or w < 2:\n        return 0.0\n    horizontal_diff = np.abs(gray[:, 1:] - gray[:, :-1])\n    vertical_diff = np.abs(gray[1:, :] - gray[:-1, :])\n    max_h_diff = np.max(horizontal_diff) if horizontal_diff.size > 0 else 0.0\n    max_v_diff = np.max(vertical_diff) if vertical_diff.size > 0 else 0.0\n    return float(max(max_h_diff, max_v_diff))\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Average intensity in corner regions versus center region\"\n    h, w = image.shape[:2]\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    corner_size = min(h, w) // 6\n    if corner_size == 0:\n        return 1.0\n    corners = [gray[:corner_size, :corner_size], gray[:corner_size, -corner_size:],\n               gray[-corner_size:, :corner_size], gray[-corner_size:, -corner_size:]]\n    corner_mean = np.mean([np.mean(corner) for corner in corners])\n    center_mean = np.mean(gray[h//4:3*h//4, w//4:3*w//4])\n    if center_mean == 0:\n        return float(corner_mean)\n    return float(corner_mean / center_mean)\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Ratio of high intensity pixels to low intensity pixels\"\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    threshold = np.mean(gray)\n    high_pixels = np.sum(gray > threshold)\n    low_pixels = np.sum(gray <= threshold)\n    if low_pixels == 0:\n        return float(high_pixels)\n    return float(high_pixels / low_pixels)\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Concentration of intensity in the central circular region\"\n    h, w = image.shape[:2]\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    center_y, center_x = h // 2, w // 2\n    radius = min(h, w) // 4\n    y, x = np.ogrid[:h, :w]\n    mask = (y - center_y)**2 + (x - center_x)**2 <= radius**2\n    if np.sum(mask) == 0:\n        return 0.0\n    central_mean = np.mean(gray[mask])\n    total_mean = np.mean(gray)\n    if total_mean == 0:\n        return float(central_mean)\n    return float(central_mean / total_mean)\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Variance of pixel intensities in top third of image\"\n    h, w = image.shape[:2]\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    top_region = gray[:h//3, :]\n    return float(np.var(top_region))\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Ratio of maximum pixel intensity to 90th percentile intensity\"\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    max_val = np.max(gray)\n    percentile_90 = np.percentile(gray, 90)\n    if percentile_90 == 0:\n        return float(max_val)\n    return float(max_val / percentile_90)\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Average absolute difference between adjacent pixels horizontally\"\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    h, w = gray.shape\n    if w < 2:\n        return 0.0\n    horizontal_diffs = np.abs(gray[:, 1:] - gray[:, :-1])\n    return float(np.mean(horizontal_diffs))\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Skewness measure: ratio of pixels above mean to total pixels\"\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    mean_val = np.mean(gray)\n    above_mean = np.sum(gray > mean_val)\n    total_pixels = gray.size\n    return float(above_mean / total_pixels)\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Ratio of bright pixels (top 25%) to dark pixels (bottom 25%)\"\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    bright_threshold = np.percentile(gray, 75)\n    dark_threshold = np.percentile(gray, 25)\n    bright_count = np.count_nonzero(gray >= bright_threshold)\n    dark_count = np.count_nonzero(gray <= dark_threshold)\n    if dark_count == 0:\n        return float(bright_count)\n    return float(bright_count / dark_count)\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Average intensity difference between center and corners\"\n    h, w = image.shape[:2]\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    if h < 3 or w < 3:\n        return 0.0\n    center_val = gray[h//2, w//2]\n    corners = [gray[0,0], gray[0,w-1], gray[h-1,0], gray[h-1,w-1]]\n    corner_avg = np.mean(corners)\n    return float(abs(center_val - corner_avg))\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Ratio of pixels above mean intensity in top half vs bottom half\"\n    h, w = image.shape[:2]\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    overall_mean = np.mean(gray)\n    top_half = gray[:h//2, :]\n    bottom_half = gray[h//2:, :]\n    top_above_mean = np.count_nonzero(top_half >= overall_mean)\n    bottom_above_mean = np.count_nonzero(bottom_half >= overall_mean)\n    if bottom_above_mean == 0:\n        return float(top_above_mean)\n    return float(top_above_mean / bottom_above_mean)\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Variance of pixel intensities in a circular central region\"\n    h, w = image.shape[:2]\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    center_y, center_x = h//2, w//2\n    radius = min(h, w) // 4\n    y_coords, x_coords = np.ogrid[:h, :w]\n    mask = (x_coords - center_x)**2 + (y_coords - center_y)**2 <= radius**2\n    if np.count_nonzero(mask) == 0:\n        return 0.0\n    center_pixels = gray[mask]\n    return float(np.var(center_pixels))\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Contrast between top and bottom halves of image\"\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    h, w = gray.shape\n    if h < 2:\n        return 0.0\n    top_half = gray[:h//2, :]\n    bottom_half = gray[h//2:, :]\n    top_std = np.std(top_half)\n    bottom_std = np.std(bottom_half)\n    return float(abs(top_std - bottom_std))\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Fraction of pixels in the darkest 10 percent\"\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    if gray.size == 0:\n        return 0.0\n    threshold = np.percentile(gray, 10)\n    dark_pixels = np.count_nonzero(gray <= threshold)\n    return float(dark_pixels / gray.size)\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Ratio of corner region intensity to center region intensity\"\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    h, w = gray.shape\n    if h < 4 or w < 4:\n        return 1.0\n    corner_size = min(h//4, w//4)\n    corners = np.concatenate([\n        gray[:corner_size, :corner_size].flatten(),\n        gray[:corner_size, -corner_size:].flatten(),\n        gray[-corner_size:, :corner_size].flatten(),\n        gray[-corner_size:, -corner_size:].flatten()\n    ])\n    center = gray[h//4:3*h//4, w//4:3*w//4]\n    corner_mean = np.mean(corners)\n    center_mean = np.mean(center)\n    if center_mean == 0:\n        return float(corner_mean)\n    return float(corner_mean / center_mean)\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Maximum pixel intensity in the image\"\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    return float(np.max(gray))\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Variance of pixel intensities along the main diagonal\"\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    h, w = gray.shape\n    if h == 0 or w == 0:\n        return 0.0\n    diagonal_length = min(h, w)\n    diagonal_pixels = np.array([gray[i, i] for i in range(diagonal_length)])\n    if diagonal_pixels.size == 0:\n        return 0.0\n    return float(np.var(diagonal_pixels))\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Variance of pixel intensities in corner regions compared to center\"\n    h, w = image.shape[:2]\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    corner_size = min(h//4, w//4)\n    if corner_size < 1:\n        return 0.0\n    corners = [gray[:corner_size, :corner_size], gray[:corner_size, -corner_size:], \n               gray[-corner_size:, :corner_size], gray[-corner_size:, -corner_size:]]\n    corner_var = np.mean([np.var(corner) for corner in corners])\n    center = gray[h//4:3*h//4, w//4:3*w//4]\n    center_var = np.var(center) if center.size > 0 else 0.0\n    return float(corner_var / (center_var + 1e-8))\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Dominant color channel based on maximum average intensity\"\n    if len(image.shape) == 3:\n        r_mean = np.mean(image[:, :, 0])\n        g_mean = np.mean(image[:, :, 1])\n        b_mean = np.mean(image[:, :, 2])\n        max_channel = max(r_mean, g_mean, b_mean)\n        if max_channel == r_mean:\n            return 0.0\n        elif max_channel == g_mean:\n            return 1.0\n        else:\n            return 2.0\n    else:\n        return 0.0\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Average intensity difference between adjacent horizontal pixel pairs\"\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    h, w = gray.shape\n    if w < 2:\n        return 0.0\n    horizontal_diffs = np.abs(gray[:, :-1] - gray[:, 1:])\n    return float(np.mean(horizontal_diffs))\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Ratio of pixels with intensity above median in top half vs bottom half\"\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    h, w = gray.shape\n    median_val = np.median(gray)\n    mid_h = h // 2\n    top_half = gray[:mid_h, :]\n    bottom_half = gray[mid_h:, :]\n    top_above_median = np.sum(top_half > median_val)\n    bottom_above_median = np.sum(bottom_half > median_val)\n    if bottom_above_median == 0:\n        return float(top_above_median)\n    return float(top_above_median / bottom_above_median)\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Standard deviation of row-wise mean intensities\"\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    row_means = np.mean(gray, axis=1)\n    return float(np.std(row_means))\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Ratio of average intensity in top half to bottom half of image\"\n    h, w = image.shape[:2]\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    top_half = gray[:h//2, :]\n    bottom_half = gray[h//2:, :]\n    top_mean = np.mean(top_half) if top_half.size > 0 else 0.0\n    bottom_mean = np.mean(bottom_half) if bottom_half.size > 0 else 0.0\n    if bottom_mean == 0:\n        return float(top_mean)\n    return float(top_mean / bottom_mean)\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Fraction of pixels that are significantly darker than the mean\"\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    mean_intensity = np.mean(gray)\n    threshold = mean_intensity - np.std(gray)\n    dark_pixels = np.sum(gray < threshold)\n    return float(dark_pixels / gray.size)\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Maximum intensity difference between adjacent pixels\"\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    h, w = gray.shape\n    if h < 2 or w < 2:\n        return 0.0\n    horiz_diff = np.abs(gray[:, 1:] - gray[:, :-1])\n    vert_diff = np.abs(gray[1:, :] - gray[:-1, :])\n    max_horiz = np.max(horiz_diff) if horiz_diff.size > 0 else 0.0\n    max_vert = np.max(vert_diff) if vert_diff.size > 0 else 0.0\n    return float(max(max_horiz, max_vert))\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Average intensity of pixels along the main diagonal\"\n    h, w = image.shape[:2]\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    min_dim = min(h, w)\n    if min_dim == 0:\n        return 0.0\n    diagonal_pixels = gray[np.arange(min_dim), np.arange(min_dim)]\n    return float(np.mean(diagonal_pixels))\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Ratio of green channel variance to red channel variance\"\n    if len(image.shape) == 3:\n        red_var = np.var(image[:, :, 0])\n        green_var = np.var(image[:, :, 1])\n        if red_var == 0:\n            return float(green_var)\n        return float(green_var / red_var)\n    else:\n        return 1.0\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Contrast measure as ratio of 95th to 5th percentile intensities\"\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    p95 = np.percentile(gray, 95)\n    p5 = np.percentile(gray, 5)\n    if p5 == 0:\n        return float(p95)\n    return float(p95 / p5)\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Measure of color homogeneity by counting similar adjacent pixels\"\n    h, w = image.shape[:2]\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    if h < 2 or w < 2:\n        return 0.0\n    threshold = 10\n    similar_count = 0\n    total_pairs = 0\n    for i in range(h-1):\n        for j in range(w-1):\n            if abs(gray[i,j] - gray[i+1,j]) < threshold:\n                similar_count += 1\n            if abs(gray[i,j] - gray[i,j+1]) < threshold:\n                similar_count += 1\n            total_pairs += 2\n    if total_pairs == 0:\n        return 0.0\n    return float(similar_count / total_pairs)\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Ratio of top half average intensity to bottom half average intensity\"\n    h, w = image.shape[:2]\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    if h < 2:\n        return 1.0\n    top_half = gray[:h//2, :]\n    bottom_half = gray[h//2:, :]\n    top_avg = np.mean(top_half)\n    bottom_avg = np.mean(bottom_half)\n    if bottom_avg == 0:\n        return float(top_avg)\n    return float(top_avg / bottom_avg)\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Skewness measure based on third moment of intensity distribution\"\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    flat = gray.flatten()\n    mean_val = np.mean(flat)\n    std_val = np.std(flat)\n    if std_val == 0:\n        return 0.0\n    skew = np.mean(((flat - mean_val) / std_val) ** 3)\n    return float(skew)\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Circular pattern detection by comparing center pixel to surrounding ring\"\n    h, w = image.shape[:2]\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    if h < 5 or w < 5:\n        return 0.0\n    center_y, center_x = h // 2, w // 2\n    center_val = gray[center_y, center_x]\n    ring_sum = 0\n    ring_count = 0\n    for dy in [-2, -1, 0, 1, 2]:\n        for dx in [-2, -1, 0, 1, 2]:\n            if abs(dy) + abs(dx) == 2:\n                y, x = center_y + dy, center_x + dx\n                if 0 <= y < h and 0 <= x < w:\n                    ring_sum += gray[y, x]\n                    ring_count += 1\n    if ring_count == 0:\n        return 0.0\n    ring_avg = ring_sum / ring_count\n    return float(abs(center_val - ring_avg))\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Variance of pixel intensities in corner regions versus center region\"\n    h, w = image.shape[:2]\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    if h < 4 or w < 4:\n        return 0.0\n    corner_size = min(h//4, w//4, 10)\n    corners = [\n        gray[:corner_size, :corner_size],\n        gray[:corner_size, -corner_size:],\n        gray[-corner_size:, :corner_size],\n        gray[-corner_size:, -corner_size:]\n    ]\n    corner_var = np.mean([np.var(corner) for corner in corners])\n    center_region = gray[h//4:3*h//4, w//4:3*w//4]\n    center_var = np.var(center_region) if center_region.size > 0 else 0.0\n    if center_var == 0:\n        return float(corner_var)\n    return float(corner_var / center_var)\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Proportion of pixels in the darkest 25% of intensity range\"\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    min_val, max_val = np.min(gray), np.max(gray)\n    if max_val == min_val:\n        return 1.0\n    threshold = min_val + 0.25 * (max_val - min_val)\n    dark_pixels = np.sum(gray <= threshold)\n    total_pixels = gray.size\n    return float(dark_pixels / total_pixels)\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Symmetry score between left and right halves of the image\"\n    h, w = image.shape[:2]\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    if w < 2:\n        return 1.0\n    mid = w // 2\n    left_half = gray[:, :mid]\n    right_half = np.fliplr(gray[:, -mid:])\n    min_width = min(left_half.shape[1], right_half.shape[1])\n    left_crop = left_half[:, :min_width]\n    right_crop = right_half[:, :min_width]\n    if left_crop.size == 0:\n        return 1.0\n    diff = np.mean(np.abs(left_crop - right_crop))\n    max_possible_diff = np.max(gray) - np.min(gray)\n    if max_possible_diff == 0:\n        return 1.0\n    return float(1.0 - diff / max_possible_diff)\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Ratio of bright pixels in top half versus bottom half of image\"\n    h, w = image.shape[:2]\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    if h < 2:\n        return 1.0\n    mid_h = h // 2\n    threshold = np.percentile(gray, 75)\n    top_bright = np.sum(gray[:mid_h] > threshold)\n    bottom_bright = np.sum(gray[mid_h:] > threshold)\n    if bottom_bright == 0:\n        return float(top_bright)\n    return float(top_bright / bottom_bright)\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Maximum color channel difference between red and green channels\"\n    if len(image.shape) == 3:\n        red_channel = image[:, :, 0]\n        green_channel = image[:, :, 1]\n        max_diff = np.max(np.abs(red_channel - green_channel))\n        return float(max_diff)\n    else:\n        return 0.0\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Concentration of high intensity pixels in top half versus bottom half\"\n    h, w = image.shape[:2]\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    threshold = np.percentile(gray, 80)\n    top_half = gray[:h//2, :]\n    bottom_half = gray[h//2:, :]\n    top_bright = np.count_nonzero(top_half > threshold)\n    bottom_bright = np.count_nonzero(bottom_half > threshold)\n    total_bright = top_bright + bottom_bright\n    if total_bright == 0:\n        return 0.5\n    return float(top_bright / total_bright)\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Variance of pixel intensities in corner regions compared to center\"\n    h, w = image.shape[:2]\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    corner_size = min(h, w) // 4\n    if corner_size == 0:\n        return 0.0\n    corners = [\n        gray[:corner_size, :corner_size],\n        gray[:corner_size, -corner_size:],\n        gray[-corner_size:, :corner_size],\n        gray[-corner_size:, -corner_size:]\n    ]\n    corner_var = np.mean([np.var(corner) for corner in corners if corner.size > 0])\n    center = gray[h//4:3*h//4, w//4:3*w//4]\n    center_var = np.var(center) if center.size > 0 else 0\n    if center_var == 0:\n        return float(corner_var)\n    return float(corner_var / center_var)\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Ratio of pixels above average in left half versus right half\"\n    h, w = image.shape[:2]\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    avg_intensity = np.mean(gray)\n    left_half = gray[:, :w//2]\n    right_half = gray[:, w//2:]\n    left_above_avg = np.count_nonzero(left_half > avg_intensity)\n    right_above_avg = np.count_nonzero(right_half > avg_intensity)\n    total_above_avg = left_above_avg + right_above_avg\n    if total_above_avg == 0:\n        return 0.5\n    return float(left_above_avg / total_above_avg)\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Smoothness measure using second derivative approximation\"\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    h, w = gray.shape\n    if h < 3 or w < 3:\n        return 0.0\n    second_deriv_x = gray[:, 2:] - 2*gray[:, 1:-1] + gray[:, :-2]\n    second_deriv_y = gray[2:, :] - 2*gray[1:-1, :] + gray[:-2, :]\n    smoothness = np.mean(np.abs(second_deriv_x)) + np.mean(np.abs(second_deriv_y))\n    return float(smoothness)\n",
  "def feature(image: np.ndarray) -> float:\n    \"Ratio of pixels in top half vs bottom half of image above mean intensity\"\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    h, w = gray.shape\n    mean_intensity = np.mean(gray)\n    top_half = gray[:h//2, :]\n    bottom_half = gray[h//2:, :]\n    top_bright = np.count_nonzero(top_half > mean_intensity)\n    bottom_bright = np.count_nonzero(bottom_half > mean_intensity)\n    if bottom_bright == 0:\n        return float(top_bright)\n    return float(top_bright / bottom_bright)\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Standard deviation of pixel intensities in left vs right halves\"\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    h, w = gray.shape\n    left_half = gray[:, :w//2]\n    right_half = gray[:, w//2:]\n    left_std = np.std(left_half)\n    right_std = np.std(right_half)\n    if right_std == 0:\n        return float(left_std)\n    return float(left_std / right_std)\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Concentration of high intensity pixels in central vertical strip\"\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    h, w = gray.shape\n    strip_width = w // 4\n    central_strip = gray[:, w//2-strip_width:w//2+strip_width]\n    threshold = np.percentile(gray, 80)\n    central_high = np.count_nonzero(central_strip > threshold)\n    total_high = np.count_nonzero(gray > threshold)\n    if total_high == 0:\n        return 0.0\n    return float(central_high / total_high)\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Average difference between adjacent pixel intensities in horizontal direction\"\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    h, w = gray.shape\n    if w < 2:\n        return 0.0\n    horizontal_diffs = np.abs(gray[:, 1:] - gray[:, :-1])\n    return float(np.mean(horizontal_diffs))\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Ratio of maximum to minimum pixel intensity in each quadrant, averaged\"\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    h, w = gray.shape\n    mid_h, mid_w = h//2, w//2\n    quadrants = [gray[:mid_h, :mid_w], gray[:mid_h, mid_w:], \n                 gray[mid_h:, :mid_w], gray[mid_h:, mid_w:]]\n    ratios = []\n    for quad in quadrants:\n        if quad.size > 0:\n            min_val = np.min(quad)\n            max_val = np.max(quad)\n            if min_val == 0:\n                ratios.append(max_val)\n            else:\n                ratios.append(max_val / min_val)\n    return float(np.mean(ratios) if ratios else 0.0)\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Average intensity of the bottom half relative to top half of image\"\n    h, w = image.shape[:2]\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    if h < 2:\n        return 1.0\n    top_half = np.mean(gray[:h//2, :])\n    bottom_half = np.mean(gray[h//2:, :])\n    if top_half == 0:\n        return float(bottom_half)\n    return float(bottom_half / top_half)\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Fraction of pixels above the 75th percentile intensity\"\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    if gray.size == 0:\n        return 0.0\n    threshold = np.percentile(gray, 75)\n    bright_pixels = np.sum(gray > threshold)\n    return float(bright_pixels / gray.size)\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Asymmetry measure between left and right halves of image\"\n    h, w = image.shape[:2]\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    if w < 2:\n        return 0.0\n    left_half = gray[:, :w//2]\n    right_half = gray[:, w//2:]\n    min_width = min(left_half.shape[1], right_half.shape[1])\n    left_crop = left_half[:, :min_width]\n    right_crop = right_half[:, :min_width]\n    diff = np.mean(np.abs(left_crop - np.fliplr(right_crop)))\n    return float(diff)\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Ratio of pixels in darkest 25% to brightest 25%\"\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    if gray.size == 0:\n        return 1.0\n    dark_threshold = np.percentile(gray, 25)\n    bright_threshold = np.percentile(gray, 75)\n    dark_count = np.sum(gray <= dark_threshold)\n    bright_count = np.sum(gray >= bright_threshold)\n    if bright_count == 0:\n        return float(dark_count)\n    return float(dark_count / bright_count)\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Average intensity difference between adjacent pixels in center region\"\n    h, w = image.shape[:2]\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    center_h_start, center_w_start = h//4, w//4\n    center_h_end, center_w_end = 3*h//4, 3*w//4\n    center = gray[center_h_start:center_h_end, center_w_start:center_w_end]\n    if center.shape[0] < 2 or center.shape[1] < 2:\n        return 0.0\n    h_diff = np.mean(np.abs(center[1:, :] - center[:-1, :]))\n    v_diff = np.mean(np.abs(center[:, 1:] - center[:, :-1]))\n    return float((h_diff + v_diff) / 2)\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Ratio of bright pixels (>200) to total pixels\"\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    bright_pixels = np.sum(gray > 200)\n    total_pixels = gray.size\n    if total_pixels == 0:\n        return 0.0\n    return float(bright_pixels / total_pixels)\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Average intensity difference between left and right halves\"\n    h, w = image.shape[:2]\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    left_half = gray[:, :w//2]\n    right_half = gray[:, w//2:]\n    left_mean = np.mean(left_half)\n    right_mean = np.mean(right_half)\n    return float(abs(left_mean - right_mean))\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Fraction of pixels in the middle intensity range (80-180)\"\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    middle_range = np.sum((gray >= 80) & (gray <= 180))\n    total_pixels = gray.size\n    if total_pixels == 0:\n        return 0.0\n    return float(middle_range / total_pixels)\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Maximum intensity value in the bottom quarter of the image\"\n    h, w = image.shape[:2]\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    bottom_quarter = gray[3*h//4:, :]\n    if bottom_quarter.size == 0:\n        return 0.0\n    return float(np.max(bottom_quarter))\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Skewness approximation using mean minus median\"\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    flat_image = gray.flatten()\n    if flat_image.size == 0:\n        return 0.0\n    mean_val = np.mean(flat_image)\n    median_val = np.median(flat_image)\n    return float(mean_val - median_val)\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Ratio of corner region intensity to center region intensity\"\n    h, w = image.shape[:2]\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    corner_size = min(h//4, w//4)\n    if corner_size == 0:\n        return 1.0\n    corners = np.concatenate([\n        gray[:corner_size, :corner_size].flatten(),\n        gray[:corner_size, -corner_size:].flatten(),\n        gray[-corner_size:, :corner_size].flatten(),\n        gray[-corner_size:, -corner_size:].flatten()\n    ])\n    center = gray[h//4:3*h//4, w//4:3*w//4]\n    corner_mean = np.mean(corners)\n    center_mean = np.mean(center)\n    if center_mean == 0:\n        return float(corner_mean)\n    return float(corner_mean / center_mean)\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Proportion of pixels in the upper half of the image that are brighter than average\"\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    h, w = gray.shape\n    if h < 2:\n        return 0.0\n    upper_half = gray[:h//2, :]\n    overall_mean = np.mean(gray)\n    bright_pixels = np.sum(upper_half > overall_mean)\n    total_pixels = upper_half.size\n    return float(bright_pixels / total_pixels) if total_pixels > 0 else 0.0\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Average intensity difference between center and edge regions\"\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    h, w = gray.shape\n    if h < 6 or w < 6:\n        return 0.0\n    center = gray[h//4:3*h//4, w//4:3*w//4]\n    edge_top = gray[:h//4, :]\n    edge_bottom = gray[3*h//4:, :]\n    edge_left = gray[h//4:3*h//4, :w//4]\n    edge_right = gray[h//4:3*h//4, 3*w//4:]\n    center_mean = np.mean(center)\n    edge_mean = np.mean([np.mean(edge_top), np.mean(edge_bottom), np.mean(edge_left), np.mean(edge_right)])\n    return float(abs(center_mean - edge_mean))\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Ratio of pixels in the darkest 25% to brightest 25% intensity range\"\n    intensities = image.flatten()\n    if len(intensities) == 0:\n        return 1.0\n    q25 = np.percentile(intensities, 25)\n    q75 = np.percentile(intensities, 75)\n    dark_pixels = np.sum(intensities <= q25)\n    bright_pixels = np.sum(intensities >= q75)\n    if bright_pixels == 0:\n        return float(dark_pixels)\n    return float(dark_pixels / bright_pixels)\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Maximum local contrast in 3x3 neighborhoods\"\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    h, w = gray.shape\n    if h < 3 or w < 3:\n        return 0.0\n    max_contrast = 0.0\n    for i in range(h-2):\n        for j in range(w-2):\n            patch = gray[i:i+3, j:j+3]\n            contrast = np.max(patch) - np.min(patch)\n            max_contrast = max(max_contrast, contrast)\n    return float(max_contrast)\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Color saturation measured as standard deviation across RGB channels per pixel\"\n    if len(image.shape) != 3:\n        return 0.0\n    h, w, c = image.shape\n    if c < 3:\n        return 0.0\n    saturation_sum = 0.0\n    for i in range(h):\n        for j in range(w):\n            pixel_std = np.std(image[i, j, :3])\n            saturation_sum += pixel_std\n    total_pixels = h * w\n    return float(saturation_sum / total_pixels) if total_pixels > 0 else 0.0\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Ratio of top half brightness to bottom half brightness\"\n    h, w = image.shape[:2]\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    top_half = gray[:h//2, :]\n    bottom_half = gray[h//2:, :]\n    top_mean = np.mean(top_half)\n    bottom_mean = np.mean(bottom_half)\n    if bottom_mean == 0:\n        return float(top_mean)\n    return float(top_mean / bottom_mean)\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Percentage of pixels above 75th percentile intensity\"\n    threshold = np.percentile(image, 75)\n    bright_pixels = np.sum(image > threshold)\n    total_pixels = image.size\n    return float(bright_pixels / total_pixels) if total_pixels > 0 else 0.0\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Standard deviation of pixel intensities in the center quarter region\"\n    h, w = image.shape[:2]\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    center_y1, center_y2 = 3*h//8, 5*h//8\n    center_x1, center_x2 = 3*w//8, 5*w//8\n    center_region = gray[center_y1:center_y2, center_x1:center_x2]\n    return float(np.std(center_region)) if center_region.size > 0 else 0.0\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Difference between maximum and minimum row-wise intensity averages\"\n    h, w = image.shape[:2]\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    row_means = np.mean(gray, axis=1)\n    return float(np.max(row_means) - np.min(row_means))\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Ratio of left half to right half average intensity\"\n    h, w = image.shape[:2]\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    left_half = gray[:, :w//2]\n    right_half = gray[:, w//2:]\n    left_mean = np.mean(left_half)\n    right_mean = np.mean(right_half)\n    if right_mean == 0:\n        return float(left_mean)\n    return float(left_mean / right_mean)\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Percentage of pixels in middle intensity range (25th to 75th percentile)\"\n    p25 = np.percentile(image, 25)\n    p75 = np.percentile(image, 75)\n    middle_pixels = np.sum((image >= p25) & (image <= p75))\n    total_pixels = image.size\n    return float(middle_pixels / total_pixels) if total_pixels > 0 else 0.0\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Average absolute difference between adjacent pixels horizontally\"\n    h, w = image.shape[:2]\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    if w < 2:\n        return 0.0\n    horizontal_diffs = np.abs(gray[:, 1:] - gray[:, :-1])\n    return float(np.mean(horizontal_diffs))\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Variance of pixel intensities in the four corner regions\"\n    h, w = image.shape[:2]\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    if h < 4 or w < 4:\n        return 0.0\n    corner_size = min(h//4, w//4)\n    if corner_size == 0:\n        return 0.0\n    tl = gray[:corner_size, :corner_size]\n    tr = gray[:corner_size, -corner_size:]\n    bl = gray[-corner_size:, :corner_size]\n    br = gray[-corner_size:, -corner_size:]\n    variances = [np.var(corner) for corner in [tl, tr, bl, br]]\n    return float(np.mean(variances))\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Proportion of pixels above the 90th percentile threshold\"\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    if gray.size == 0:\n        return 0.0\n    threshold = np.percentile(gray, 90)\n    bright_pixels = np.count_nonzero(gray > threshold)\n    return float(bright_pixels / gray.size)\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Ratio of intensity variance in center vs border regions\"\n    h, w = image.shape[:2]\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    if h < 6 or w < 6:\n        return 1.0\n    center = gray[h//4:3*h//4, w//4:3*w//4]\n    border = np.concatenate([\n        gray[:h//4, :].flatten(),\n        gray[3*h//4:, :].flatten(),\n        gray[h//4:3*h//4, :w//4].flatten(),\n        gray[h//4:3*h//4, 3*w//4:].flatten()\n    ])\n    center_var = np.var(center)\n    border_var = np.var(border)\n    if border_var == 0:\n        return float(center_var)\n    return float(center_var / border_var)\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Maximum pixel intensity difference between top and bottom halves\"\n    h, w = image.shape[:2]\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    if h < 2:\n        return 0.0\n    top_half = gray[:h//2, :]\n    bottom_half = gray[h//2:, :]\n    top_max = np.max(top_half) if top_half.size > 0 else 0\n    bottom_max = np.max(bottom_half) if bottom_half.size > 0 else 0\n    return float(abs(top_max - bottom_max))\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Standard deviation of row-wise mean intensities\"\n    h, w = image.shape[:2]\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    if h == 0:\n        return 0.0\n    row_means = np.mean(gray, axis=1)\n    return float(np.std(row_means))\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Ratio of green channel variance to red channel variance\"\n    if len(image.shape) == 3:\n        green_var = np.var(image[:, :, 1])\n        red_var = np.var(image[:, :, 0])\n        if red_var == 0:\n            return float(green_var)\n        return float(green_var / red_var)\n    else:\n        return 1.0\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Average intensity difference between center and border regions\"\n    h, w = image.shape[:2]\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    center_region = gray[h//4:3*h//4, w//4:3*w//4]\n    border_thickness = min(h, w) // 10 + 1\n    border_region = np.concatenate([\n        gray[:border_thickness, :].flatten(),\n        gray[-border_thickness:, :].flatten(),\n        gray[:, :border_thickness].flatten(),\n        gray[:, -border_thickness:].flatten()\n    ])\n    center_mean = np.mean(center_region) if center_region.size > 0 else 0\n    border_mean = np.mean(border_region) if border_region.size > 0 else 0\n    return float(abs(center_mean - border_mean))\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Proportion of pixels within one standard deviation of the mean\"\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    mean_intensity = np.mean(gray)\n    std_intensity = np.std(gray)\n    within_std = np.sum(np.abs(gray - mean_intensity) <= std_intensity)\n    return float(within_std / gray.size) if gray.size > 0 else 0.0\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Maximum intensity difference in any 3x3 local neighborhood\"\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    h, w = gray.shape\n    if h < 3 or w < 3:\n        return 0.0\n    max_local_diff = 0.0\n    for i in range(h-2):\n        for j in range(w-2):\n            local_patch = gray[i:i+3, j:j+3]\n            local_diff = np.max(local_patch) - np.min(local_patch)\n            max_local_diff = max(max_local_diff, local_diff)\n    return float(max_local_diff)\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Ratio of left half average intensity to right half average intensity\"\n    h, w = image.shape[:2]\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    left_half = gray[:, :w//2]\n    right_half = gray[:, w//2:]\n    left_mean = np.mean(left_half)\n    right_mean = np.mean(right_half)\n    if right_mean == 0:\n        return float(left_mean)\n    return float(left_mean / right_mean)\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Average squared difference from median intensity\"\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    median_intensity = np.median(gray)\n    squared_diffs = (gray - median_intensity) ** 2\n    return float(np.mean(squared_diffs))\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Ratio of bright pixels (above 75th percentile) to total pixels\"\n    threshold = np.percentile(image, 75)\n    bright_pixels = np.count_nonzero(image >= threshold)\n    total_pixels = image.size\n    return float(bright_pixels / total_pixels)\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Average intensity difference between center and edge regions\"\n    h, w = image.shape[:2]\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    center = gray[h//4:3*h//4, w//4:3*w//4]\n    edge_mask = np.ones_like(gray, dtype=bool)\n    edge_mask[h//4:3*h//4, w//4:3*w//4] = False\n    edge_region = gray[edge_mask]\n    if len(edge_region) == 0 or center.size == 0:\n        return 0.0\n    return float(np.mean(center) - np.mean(edge_region))\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Entropy-like measure based on intensity histogram\"\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    hist, _ = np.histogram(gray.flatten(), bins=16, range=(0, 256))\n    hist = hist + 1e-10\n    probs = hist / np.sum(hist)\n    entropy = -np.sum(probs * np.log2(probs))\n    return float(entropy)\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Standard deviation of pixel intensities in circular center region\"\n    h, w = image.shape[:2]\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    center_y, center_x = h // 2, w // 2\n    radius = min(h, w) // 4\n    y, x = np.ogrid[:h, :w]\n    mask = (x - center_x)**2 + (y - center_y)**2 <= radius**2\n    if np.count_nonzero(mask) == 0:\n        return 0.0\n    center_pixels = gray[mask]\n    return float(np.std(center_pixels))\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Ratio of pixels in upper quartile to pixels in lower quartile intensity\"\n    flat = image.flatten()\n    q25 = np.percentile(flat, 25)\n    q75 = np.percentile(flat, 75)\n    lower = np.count_nonzero(flat <= q25)\n    upper = np.count_nonzero(flat >= q75)\n    if lower == 0:\n        return float(upper)\n    return float(upper / lower)\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Maximum local intensity variation in 3x3 neighborhoods\"\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    h, w = gray.shape\n    if h < 3 or w < 3:\n        return 0.0\n    max_variation = 0.0\n    for i in range(1, h-1):\n        for j in range(1, w-1):\n            neighborhood = gray[i-1:i+2, j-1:j+2]\n            variation = np.max(neighborhood) - np.min(neighborhood)\n            max_variation = max(max_variation, variation)\n    return float(max_variation)\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Ratio of bright pixels in center circle vs outer ring\"\n    h, w = image.shape[:2]\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    if h < 4 or w < 4:\n        return 1.0\n    cy, cx = h//2, w//2\n    radius = min(h, w) // 4\n    y, x = np.ogrid[:h, :w]\n    center_mask = (y - cy)**2 + (x - cx)**2 <= radius**2\n    outer_mask = ((y - cy)**2 + (x - cx)**2 > radius**2) & ((y - cy)**2 + (x - cx)**2 <= (2*radius)**2)\n    threshold = np.percentile(gray, 60)\n    center_bright = np.count_nonzero(gray[center_mask] > threshold)\n    outer_bright = np.count_nonzero(gray[outer_mask] > threshold)\n    if outer_bright == 0:\n        return float(center_bright)\n    return float(center_bright / outer_bright)\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Variance of pixel intensities in the middle horizontal stripe\"\n    h, w = image.shape[:2]\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    if h < 6:\n        return 0.0\n    stripe = gray[h//3:2*h//3, :]\n    return float(np.var(stripe))\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Ratio of maximum to minimum pixel intensity in each quadrant averaged\"\n    h, w = image.shape[:2]\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    if h < 2 or w < 2:\n        return 1.0\n    mid_h, mid_w = h//2, w//2\n    quadrants = [\n        gray[:mid_h, :mid_w],\n        gray[:mid_h, mid_w:],\n        gray[mid_h:, :mid_w],\n        gray[mid_h:, mid_w:]\n    ]\n    ratios = []\n    for quad in quadrants:\n        if quad.size > 0:\n            min_val = np.min(quad)\n            max_val = np.max(quad)\n            if min_val == 0:\n                ratios.append(max_val)\n            else:\n                ratios.append(max_val / min_val)\n    return float(np.mean(ratios)) if ratios else 1.0\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Fraction of pixels in upper half that are darker than lower half average\"\n    h, w = image.shape[:2]\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    if h < 2:\n        return 0.0\n    upper_half = gray[:h//2, :]\n    lower_half = gray[h//2:, :]\n    lower_mean = np.mean(lower_half)\n    dark_pixels = np.count_nonzero(upper_half < lower_mean)\n    total_pixels = upper_half.size\n    return float(dark_pixels / total_pixels) if total_pixels > 0 else 0.0\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Ratio of corner region intensity to center region intensity\"\n    h, w = image.shape[:2]\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    if h < 4 or w < 4:\n        return 1.0\n    corner_size = min(h//4, w//4)\n    corners = (gray[:corner_size, :corner_size].sum() + \n              gray[:corner_size, -corner_size:].sum() + \n              gray[-corner_size:, :corner_size].sum() + \n              gray[-corner_size:, -corner_size:].sum())\n    center = gray[h//4:3*h//4, w//4:3*w//4]\n    center_mean = np.mean(center) * center.size\n    if center_mean == 0:\n        return float(corners)\n    return float(corners / center_mean)\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Variance of row-wise intensity means\"\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    h, w = gray.shape\n    if h < 2:\n        return 0.0\n    row_means = [np.mean(gray[i, :]) for i in range(h)]\n    return float(np.var(row_means))\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Ratio of pixels above 75th percentile to pixels below 25th percentile\"\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    flat = gray.flatten()\n    if len(flat) == 0:\n        return 1.0\n    p25 = np.percentile(flat, 25)\n    p75 = np.percentile(flat, 75)\n    high_count = np.sum(flat > p75)\n    low_count = np.sum(flat < p25)\n    if low_count == 0:\n        return float(high_count)\n    return float(high_count / low_count)\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Average magnitude of second-order vertical gradients\"\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    h, w = gray.shape\n    if h < 3:\n        return 0.0\n    second_grad = gray[2:, :] - 2*gray[1:-1, :] + gray[:-2, :]\n    return float(np.mean(np.abs(second_grad)))\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Ratio of maximum to minimum column-wise intensity sums\"\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    h, w = gray.shape\n    if w < 1:\n        return 1.0\n    col_sums = np.sum(gray, axis=0)\n    max_sum = np.max(col_sums)\n    min_sum = np.min(col_sums)\n    if min_sum == 0:\n        return float(max_sum)\n    return float(max_sum / min_sum)\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Average intensity difference between center and edge regions\"\n    h, w = image.shape[:2]\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    center = gray[h//4:3*h//4, w//4:3*w//4]\n    edge_thickness = min(h//8, w//8, 5)\n    edges = np.concatenate([\n        gray[:edge_thickness, :].flatten(),\n        gray[-edge_thickness:, :].flatten(),\n        gray[:, :edge_thickness].flatten(),\n        gray[:, -edge_thickness:].flatten()\n    ])\n    center_mean = np.mean(center) if center.size > 0 else 0\n    edge_mean = np.mean(edges) if edges.size > 0 else 0\n    return float(abs(center_mean - edge_mean))\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Proportion of pixels that are locally maximum in 3x3 neighborhood\"\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    h, w = gray.shape\n    if h < 3 or w < 3:\n        return 0.0\n    local_max_count = 0\n    total_interior = (h-2) * (w-2)\n    for i in range(1, h-1):\n        for j in range(1, w-1):\n            center = gray[i, j]\n            neighborhood = gray[i-1:i+2, j-1:j+2]\n            if center >= np.max(neighborhood):\n                local_max_count += 1\n    return float(local_max_count / total_interior) if total_interior > 0 else 0.0\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Ratio of red channel variance to blue channel variance\"\n    if len(image.shape) == 3:\n        red_var = np.var(image[:, :, 0])\n        blue_var = np.var(image[:, :, 2])\n        if blue_var == 0:\n            return float(red_var)\n        return float(red_var / blue_var)\n    else:\n        return 1.0\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Average magnitude of second-order horizontal differences\"\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    h, w = gray.shape\n    if w < 3:\n        return 0.0\n    first_diff = gray[:, 1:] - gray[:, :-1]\n    second_diff = first_diff[:, 1:] - first_diff[:, :-1]\n    return float(np.mean(np.abs(second_diff)))\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Fraction of image area covered by high-intensity regions above 75th percentile\"\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    if gray.size == 0:\n        return 0.0\n    threshold = np.percentile(gray, 75)\n    bright_pixels = np.count_nonzero(gray > threshold)\n    return float(bright_pixels / gray.size)\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Variance of pixel intensities in corner regions vs center region\"\n    h, w = image.shape[:2]\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    if h < 6 or w < 6:\n        return 0.0\n    corner_size = min(h//4, w//4)\n    corners = [gray[:corner_size, :corner_size], gray[:corner_size, -corner_size:], \n               gray[-corner_size:, :corner_size], gray[-corner_size:, -corner_size:]]\n    corner_var = np.mean([np.var(corner) for corner in corners])\n    center = gray[h//3:2*h//3, w//3:2*w//3]\n    center_var = np.var(center)\n    if center_var == 0:\n        return float(corner_var)\n    return float(corner_var / center_var)\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Ratio of green channel dominance over red and blue channels\"\n    if len(image.shape) != 3:\n        return 0.0\n    green = image[:, :, 1]\n    red = image[:, :, 0]\n    blue = image[:, :, 2]\n    green_dominant = np.sum((green > red) & (green > blue))\n    total_pixels = green.size\n    return float(green_dominant / total_pixels)\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Average intensity weighted by distance from image center\"\n    h, w = image.shape[:2]\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    center_h, center_w = h // 2, w // 2\n    total_weighted = 0.0\n    total_weight = 0.0\n    for i in range(h):\n        for j in range(w):\n            distance = np.sqrt((i - center_h)**2 + (j - center_w)**2)\n            weight = distance + 1\n            total_weighted += gray[i, j] * weight\n            total_weight += weight\n    if total_weight == 0:\n        return 0.0\n    return float(total_weighted / total_weight)\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Ratio of green channel dominance in bright regions\"\n    if len(image.shape) == 3:\n        brightness = np.mean(image, axis=2)\n        bright_mask = brightness > np.percentile(brightness, 75)\n        if np.sum(bright_mask) == 0:\n            return 1.0\n        green_in_bright = np.mean(image[:,:,1][bright_mask])\n        total_in_bright = np.mean(brightness[bright_mask])\n        if total_in_bright == 0:\n            return 1.0\n        return float(green_in_bright / total_in_bright)\n    else:\n        return 1.0\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Concentration of pixel values around the median\"\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    median_val = np.median(gray)\n    tolerance = np.std(gray) * 0.5\n    near_median = np.count_nonzero(np.abs(gray - median_val) <= tolerance)\n    return float(near_median / gray.size)\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Average distance from center for pixels above 80th percentile intensity\"\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    h, w = gray.shape\n    threshold = np.percentile(gray, 80)\n    bright_pixels = gray > threshold\n    if np.sum(bright_pixels) == 0:\n        return 0.0\n    center_y, center_x = h / 2, w / 2\n    y_coords, x_coords = np.where(bright_pixels)\n    distances = np.sqrt((y_coords - center_y)**2 + (x_coords - center_x)**2)\n    return float(np.mean(distances))\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Difference between top and bottom half average intensities\"\n    h, w = image.shape[:2]\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    top_half = gray[:h//2, :]\n    bottom_half = gray[h//2:, :]\n    return float(np.mean(bottom_half) - np.mean(top_half))\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Variance of column-wise minimum values\"\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    col_mins = np.min(gray, axis=0)\n    return float(np.var(col_mins))\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Ratio of pixels in darkest quartile to brightest quartile\"\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    q25 = np.percentile(gray, 25)\n    q75 = np.percentile(gray, 75)\n    dark_count = np.count_nonzero(gray <= q25)\n    bright_count = np.count_nonzero(gray >= q75)\n    if bright_count == 0:\n        return float(dark_count)\n    return float(dark_count / bright_count)\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Ratio of edge pixels in top half vs bottom half of image\"\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    h, w = gray.shape\n    if h < 2:\n        return 1.0\n    grad_mag = np.sqrt(np.gradient(gray, axis=0)**2 + np.gradient(gray, axis=1)**2)\n    edge_thresh = np.percentile(grad_mag, 80)\n    top_edges = np.sum(grad_mag[:h//2] > edge_thresh)\n    bottom_edges = np.sum(grad_mag[h//2:] > edge_thresh)\n    if bottom_edges == 0:\n        return float(top_edges)\n    return float(top_edges / bottom_edges)\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Average intensity difference between adjacent horizontal pixel pairs\"\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    h, w = gray.shape\n    if w < 2:\n        return 0.0\n    diff_sum = 0.0\n    count = 0\n    for i in range(h):\n        for j in range(w-1):\n            diff_sum += abs(gray[i, j] - gray[i, j+1])\n            count += 1\n    return float(diff_sum / count) if count > 0 else 0.0\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Concentration of high intensity pixels in center vs edges\"\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    h, w = gray.shape\n    thresh = np.percentile(gray, 75)\n    center_h_start, center_h_end = h//3, 2*h//3\n    center_w_start, center_w_end = w//3, 2*w//3\n    center_bright = np.sum(gray[center_h_start:center_h_end, center_w_start:center_w_end] > thresh)\n    edge_mask = np.ones_like(gray, dtype=bool)\n    edge_mask[center_h_start:center_h_end, center_w_start:center_w_end] = False\n    edge_bright = np.sum(gray[edge_mask] > thresh)\n    if edge_bright == 0:\n        return float(center_bright)\n    return float(center_bright / edge_bright)\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Symmetry score between left and right halves of image\"\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    h, w = gray.shape\n    if w < 2:\n        return 1.0\n    left_half = gray[:, :w//2]\n    right_half = gray[:, w//2:]\n    min_w = min(left_half.shape[1], right_half.shape[1])\n    left_crop = left_half[:, :min_w]\n    right_crop = np.fliplr(right_half[:, -min_w:])\n    diff = np.mean(np.abs(left_crop - right_crop))\n    max_val = max(np.max(gray), 1.0)\n    return float(1.0 - diff / max_val)\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Average intensity difference between top and bottom halves of image\"\n    h, w = image.shape[:2]\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    if h < 2:\n        return 0.0\n    top_half = gray[:h//2, :]\n    bottom_half = gray[h//2:, :]\n    top_mean = np.mean(top_half)\n    bottom_mean = np.mean(bottom_half)\n    return float(abs(top_mean - bottom_mean))\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Compactness measure using ratio of mean to standard deviation\"\n    intensities = image.flatten()\n    if len(intensities) == 0:\n        return 0.0\n    mean_val = np.mean(intensities)\n    std_val = np.std(intensities)\n    if std_val == 0:\n        return float(mean_val)\n    return float(mean_val / std_val)\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Average absolute difference between adjacent pixels in all directions\"\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    h, w = gray.shape\n    if h < 2 or w < 2:\n        return 0.0\n    diff_h = np.abs(gray[1:, :] - gray[:-1, :])\n    diff_w = np.abs(gray[:, 1:] - gray[:, :-1])\n    total_diff = np.sum(diff_h) + np.sum(diff_w)\n    total_comparisons = (h-1)*w + h*(w-1)\n    return float(total_diff / total_comparisons)\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Ratio of pixels in corners versus center regions\"\n    h, w = image.shape[:2]\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    if h < 4 or w < 4:\n        return 1.0\n    corner_size = min(h//4, w//4)\n    corners = np.concatenate([\n        gray[:corner_size, :corner_size].flatten(),\n        gray[:corner_size, -corner_size:].flatten(),\n        gray[-corner_size:, :corner_size].flatten(),\n        gray[-corner_size:, -corner_size:].flatten()\n    ])\n    center = gray[h//4:3*h//4, w//4:3*w//4]\n    corner_mean = np.mean(corners)\n    center_mean = np.mean(center)\n    if center_mean == 0:\n        return float(corner_mean)\n    return float(corner_mean / center_mean)\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Standard deviation of pixel intensities in the top half vs bottom half\"\n    h, w = image.shape[:2]\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    if h < 2:\n        return 0.0\n    top_half = gray[:h//2, :]\n    bottom_half = gray[h//2:, :]\n    top_std = np.std(top_half)\n    bottom_std = np.std(bottom_half)\n    if bottom_std == 0:\n        return float(top_std)\n    return float(top_std / bottom_std)\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Fraction of pixels that are significantly brighter than their neighbors\"\n    h, w = image.shape[:2]\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    if h < 3 or w < 3:\n        return 0.0\n    center = gray[1:-1, 1:-1]\n    neighbors = (gray[:-2, 1:-1] + gray[2:, 1:-1] + gray[1:-1, :-2] + gray[1:-1, 2:]) / 4\n    bright_pixels = np.sum(center > neighbors + 10)\n    total_pixels = center.size\n    return float(bright_pixels / total_pixels)\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Ratio of variance in left half to variance in right half\"\n    h, w = image.shape[:2]\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    if w < 2:\n        return 1.0\n    left_half = gray[:, :w//2]\n    right_half = gray[:, w//2:]\n    left_var = np.var(left_half)\n    right_var = np.var(right_half)\n    if right_var == 0:\n        return float(left_var)\n    return float(left_var / right_var)\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Average intensity difference between adjacent horizontal pixels\"\n    h, w = image.shape[:2]\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    if w < 2:\n        return 0.0\n    horizontal_diffs = np.abs(gray[:, 1:] - gray[:, :-1])\n    return float(np.mean(horizontal_diffs))\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Concentration of high-intensity pixels in center quadrant\"\n    h, w = image.shape[:2]\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    center_h_start, center_h_end = h//4, 3*h//4\n    center_w_start, center_w_end = w//4, 3*w//4\n    center_region = gray[center_h_start:center_h_end, center_w_start:center_w_end]\n    threshold = np.percentile(gray, 80)\n    center_bright = np.sum(center_region > threshold)\n    total_bright = np.sum(gray > threshold)\n    if total_bright == 0:\n        return 0.0\n    return float(center_bright / total_bright)\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Ratio of bright pixels in top half vs bottom half of image\"\n    h, w = image.shape[:2]\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    threshold = np.mean(gray) + np.std(gray)\n    top_bright = np.sum(gray[:h//2, :] > threshold)\n    bottom_bright = np.sum(gray[h//2:, :] > threshold)\n    if bottom_bright == 0:\n        return float(top_bright)\n    return float(top_bright / bottom_bright)\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Ratio of edge pixels in central region vs peripheral region\"\n    h, w = image.shape[:2]\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    if h < 3 or w < 3:\n        return 1.0\n    edges = np.abs(gray[1:, 1:] - gray[:-1, :-1]) + np.abs(gray[1:, :-1] - gray[:-1, 1:])\n    edge_threshold = np.mean(edges)\n    center_edges = np.sum(edges[h//4:3*h//4-1, w//4:3*w//4-1] > edge_threshold)\n    total_edges = np.sum(edges > edge_threshold)\n    if total_edges - center_edges == 0:\n        return float(center_edges)\n    return float(center_edges / (total_edges - center_edges))\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Variance of pixel intensities in the four quadrants\"\n    h, w = image.shape[:2]\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    q1 = np.mean(gray[:h//2, :w//2])\n    q2 = np.mean(gray[:h//2, w//2:])\n    q3 = np.mean(gray[h//2:, :w//2])\n    q4 = np.mean(gray[h//2:, w//2:])\n    return float(np.var([q1, q2, q3, q4]))\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Standard deviation of red channel values\"\n    if len(image.shape) == 3:\n        return float(np.std(image[:, :, 0]))\n    else:\n        return float(np.std(image))\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Fraction of pixels in the brightest 10% of the image\"\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    threshold = np.percentile(gray, 90)\n    bright_pixels = np.count_nonzero(gray >= threshold)\n    return float(bright_pixels / gray.size)\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Average intensity difference between center and border regions\"\n    h, w = image.shape[:2]\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    center = gray[h//4:3*h//4, w//4:3*w//4]\n    border_top = gray[:h//4, :]\n    border_bottom = gray[3*h//4:, :]\n    border_left = gray[h//4:3*h//4, :w//4]\n    border_right = gray[h//4:3*h//4, 3*w//4:]\n    center_mean = np.mean(center) if center.size > 0 else 0.0\n    border_pixels = np.concatenate([border_top.flatten(), border_bottom.flatten(), \n                                   border_left.flatten(), border_right.flatten()])\n    border_mean = np.mean(border_pixels) if border_pixels.size > 0 else 0.0\n    return float(abs(center_mean - border_mean))\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Ratio of pixels above median intensity to pixels below median intensity\"\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    median = np.median(gray)\n    above_median = np.count_nonzero(gray > median)\n    below_median = np.count_nonzero(gray < median)\n    if below_median == 0:\n        return float(above_median)\n    return float(above_median / below_median)\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Maximum intensity difference along image columns\"\n    h, w = image.shape[:2]\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    col_means = np.mean(gray, axis=0)\n    return float(np.max(col_means) - np.min(col_means))\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Correlation between red and green channels\"\n    if len(image.shape) == 3:\n        red = image[:, :, 0].flatten()\n        green = image[:, :, 1].flatten()\n        correlation_matrix = np.corrcoef(red, green)\n        return float(correlation_matrix[0, 1]) if not np.isnan(correlation_matrix[0, 1]) else 0.0\n    else:\n        return 1.0\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Ratio of pixels in the highest intensity quartile to lowest intensity quartile\"\n    flat = image.flatten()\n    q75 = np.percentile(flat, 75)\n    q25 = np.percentile(flat, 25)\n    high_pixels = np.sum(flat >= q75)\n    low_pixels = np.sum(flat <= q25)\n    if low_pixels == 0:\n        return float(high_pixels)\n    return float(high_pixels / low_pixels)\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Average intensity difference between center circle and outer ring regions\"\n    h, w = image.shape[:2]\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    center_y, center_x = h // 2, w // 2\n    radius_inner = min(h, w) // 6\n    radius_outer = min(h, w) // 3\n    y, x = np.ogrid[:h, :w]\n    dist_from_center = np.sqrt((y - center_y)**2 + (x - center_x)**2)\n    inner_mask = dist_from_center <= radius_inner\n    outer_mask = (dist_from_center > radius_inner) & (dist_from_center <= radius_outer)\n    if np.sum(inner_mask) == 0 or np.sum(outer_mask) == 0:\n        return 0.0\n    inner_mean = np.mean(gray[inner_mask])\n    outer_mean = np.mean(gray[outer_mask])\n    return float(abs(inner_mean - outer_mean))\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Skewness of pixel intensity distribution\"\n    flat = image.flatten()\n    mean_val = np.mean(flat)\n    std_val = np.std(flat)\n    if std_val == 0:\n        return 0.0\n    skewness = np.mean(((flat - mean_val) / std_val) ** 3)\n    return float(skewness)\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Ratio of green channel dominance over red and blue channels\"\n    if len(image.shape) == 3:\n        r_mean = np.mean(image[:, :, 0])\n        g_mean = np.mean(image[:, :, 1])\n        b_mean = np.mean(image[:, :, 2])\n        green_dominance = np.sum((image[:, :, 1] > image[:, :, 0]) & (image[:, :, 1] > image[:, :, 2]))\n        total_pixels = image.shape[0] * image.shape[1]\n        return float(green_dominance / total_pixels)\n    else:\n        return 0.0\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Coefficient of variation of row-wise intensity means\"\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    row_means = np.mean(gray, axis=1)\n    mean_of_means = np.mean(row_means)\n    if mean_of_means == 0:\n        return 0.0\n    return float(np.std(row_means) / mean_of_means)\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Ratio of top half brightness to bottom half brightness\"\n    h, w = image.shape[:2]\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    if h < 2:\n        return 1.0\n    top_half = np.mean(gray[:h//2, :])\n    bottom_half = np.mean(gray[h//2:, :])\n    if bottom_half == 0:\n        return float(top_half)\n    return float(top_half / bottom_half)\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Percentage of pixels in the brightest 20 percent\"\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    if gray.size == 0:\n        return 0.0\n    threshold = np.percentile(gray, 80)\n    bright_pixels = np.sum(gray >= threshold)\n    return float(bright_pixels / gray.size)\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Maximum color channel difference at any pixel\"\n    if len(image.shape) != 3:\n        return 0.0\n    r, g, b = image[:,:,0], image[:,:,1], image[:,:,2]\n    max_diff = np.max([np.abs(r-g), np.abs(r-b), np.abs(g-b)])\n    return float(max_diff)\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Ratio of edge pixels to total pixels using simple threshold\"\n    h, w = image.shape[:2]\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    if h < 3 or w < 3:\n        return 0.0\n    edges = np.abs(gray[1:-1, 1:-1] - gray[:-2, :-2]) + np.abs(gray[1:-1, 1:-1] - gray[2:, 2:])\n    edge_pixels = np.sum(edges > np.std(gray))\n    return float(edge_pixels / gray.size)\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Concentration of dark pixels in center versus edges\"\n    h, w = image.shape[:2]\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    if h < 4 or w < 4:\n        return 1.0\n    center = gray[h//4:3*h//4, w//4:3*w//4]\n    threshold = np.percentile(gray, 25)\n    dark_center = np.sum(center < threshold) / center.size\n    dark_edges = (np.sum(gray < threshold) - np.sum(center < threshold)) / (gray.size - center.size)\n    if dark_edges == 0:\n        return float(dark_center * 100)\n    return float(dark_center / dark_edges)\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Standard deviation of row-wise intensity averages\"\n    h, w = image.shape[:2]\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    if h < 2:\n        return 0.0\n    row_means = np.mean(gray, axis=1)\n    return float(np.std(row_means))\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Average intensity difference between left and right halves of image\"\n    h, w = image.shape[:2]\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    left_half = gray[:, :w//2]\n    right_half = gray[:, w//2:]\n    left_mean = np.mean(left_half) if left_half.size > 0 else 0.0\n    right_mean = np.mean(right_half) if right_half.size > 0 else 0.0\n    return float(abs(left_mean - right_mean))\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Ratio of pixels above median intensity to total pixels\"\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    if gray.size == 0:\n        return 0.0\n    median_val = np.median(gray)\n    above_median = np.sum(gray > median_val)\n    return float(above_median / gray.size)\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Maximum intensity difference between adjacent pixels\"\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    if gray.shape[0] < 2 or gray.shape[1] < 2:\n        return 0.0\n    h_diff = np.abs(gray[1:, :] - gray[:-1, :])\n    v_diff = np.abs(gray[:, 1:] - gray[:, :-1])\n    max_h = np.max(h_diff) if h_diff.size > 0 else 0.0\n    max_v = np.max(v_diff) if v_diff.size > 0 else 0.0\n    return float(max(max_h, max_v))\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Variance of row-wise intensity averages\"\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    if gray.shape[0] == 0:\n        return 0.0\n    row_means = np.mean(gray, axis=1)\n    return float(np.var(row_means))\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Ratio of green channel to red channel standard deviation\"\n    if len(image.shape) == 3:\n        red_std = np.std(image[:, :, 0])\n        green_std = np.std(image[:, :, 1])\n        if red_std == 0:\n            return float(green_std)\n        return float(green_std / red_std)\n    else:\n        return 1.0\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Ratio of pixels in top half vs bottom half above median intensity\"\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    h, w = gray.shape\n    median_val = np.median(gray)\n    top_half = gray[:h//2, :]\n    bottom_half = gray[h//2:, :]\n    top_bright = np.count_nonzero(top_half > median_val)\n    bottom_bright = np.count_nonzero(bottom_half > median_val)\n    if bottom_bright == 0:\n        return float(top_bright)\n    return float(top_bright / bottom_bright)\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Standard deviation of pixel intensities in the central 50% region\"\n    h, w = image.shape[:2]\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    start_h, end_h = h//4, 3*h//4\n    start_w, end_w = w//4, 3*w//4\n    center_region = gray[start_h:end_h, start_w:end_w]\n    return float(np.std(center_region))\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Ratio of edge pixels to total pixels using simple threshold method\"\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    h, w = gray.shape\n    if h < 2 or w < 2:\n        return 0.0\n    grad_x = np.abs(gray[:, 1:] - gray[:, :-1])\n    grad_y = np.abs(gray[1:, :] - gray[:-1, :])\n    edge_threshold = np.std(gray) * 0.5\n    edge_pixels = np.count_nonzero(grad_x > edge_threshold) + np.count_nonzero(grad_y > edge_threshold)\n    total_pixels = h * w\n    return float(edge_pixels / total_pixels)\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Average absolute difference between adjacent pixels in main diagonal\"\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    h, w = gray.shape\n    diagonal_size = min(h, w)\n    if diagonal_size < 2:\n        return 0.0\n    diagonal_pixels = np.array([gray[i, i] for i in range(diagonal_size)])\n    differences = np.abs(diagonal_pixels[1:] - diagonal_pixels[:-1])\n    return float(np.mean(differences))\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Fraction of image area where red channel dominates other channels\"\n    if len(image.shape) == 3:\n        red = image[:, :, 0]\n        green = image[:, :, 1]\n        blue = image[:, :, 2]\n        red_dominant = (red >= green) & (red >= blue)\n        return float(np.mean(red_dominant))\n    else:\n        return 0.0\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Intensity range difference between left and right halves of image\"\n    h, w = image.shape[:2]\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    left_half = gray[:, :w//2]\n    right_half = gray[:, w//2:]\n    left_range = np.max(left_half) - np.min(left_half)\n    right_range = np.max(right_half) - np.min(right_half)\n    return float(abs(left_range - right_range))\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Ratio of pixels in top 10% intensity to bottom 10% intensity\"\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    top_thresh = np.percentile(gray, 90)\n    bottom_thresh = np.percentile(gray, 10)\n    top_pixels = np.sum(gray >= top_thresh)\n    bottom_pixels = np.sum(gray <= bottom_thresh)\n    if bottom_pixels == 0:\n        return float(top_pixels)\n    return float(top_pixels / bottom_pixels)\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Average intensity difference between center and border regions\"\n    h, w = image.shape[:2]\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    border_width = min(h, w) // 8\n    center = gray[border_width:h-border_width, border_width:w-border_width]\n    border = np.concatenate([gray[:border_width, :].flatten(), \n                            gray[-border_width:, :].flatten(),\n                            gray[:, :border_width].flatten(),\n                            gray[:, -border_width:].flatten()])\n    if center.size == 0 or border.size == 0:\n        return 0.0\n    return float(np.mean(center) - np.mean(border))\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Circular symmetry measure based on radial intensity variance\"\n    h, w = image.shape[:2]\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    center_y, center_x = h // 2, w // 2\n    max_radius = min(center_y, center_x)\n    if max_radius < 2:\n        return 0.0\n    y_coords, x_coords = np.ogrid[:h, :w]\n    distances = np.sqrt((y_coords - center_y)**2 + (x_coords - center_x)**2)\n    ring_intensities = []\n    for r in range(1, max_radius, max(1, max_radius // 8)):\n        mask = (distances >= r-1) & (distances < r+1)\n        if np.any(mask):\n            ring_intensities.append(np.mean(gray[mask]))\n    if len(ring_intensities) < 2:\n        return 0.0\n    return float(np.std(ring_intensities))\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Texture measure based on local intensity standard deviation\"\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    h, w = gray.shape\n    if h < 3 or w < 3:\n        return 0.0\n    kernel_size = 3\n    texture_values = []\n    for i in range(0, h-kernel_size+1, kernel_size):\n        for j in range(0, w-kernel_size+1, kernel_size):\n            patch = gray[i:i+kernel_size, j:j+kernel_size]\n            texture_values.append(np.std(patch))\n    return float(np.mean(texture_values))\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Ratio of bright pixels in top half to bottom half of image\"\n    h, w = image.shape[:2]\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    threshold = np.mean(gray)\n    top_bright = np.sum(gray[:h//2, :] > threshold)\n    bottom_bright = np.sum(gray[h//2:, :] > threshold)\n    if bottom_bright == 0:\n        return float(top_bright)\n    return float(top_bright / bottom_bright)\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Concentration of pixels around median intensity value\"\n    if len(image.shape) == 3:\n        flat = image.flatten()\n    else:\n        flat = image.flatten()\n    if flat.size == 0:\n        return 0.0\n    median_val = np.median(flat)\n    within_range = np.sum(np.abs(flat - median_val) < 20)\n    return float(within_range / flat.size)\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Difference between maximum and minimum row-wise average intensities\"\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    if gray.shape[0] == 0:\n        return 0.0\n    row_means = np.mean(gray, axis=1)\n    return float(np.max(row_means) - np.min(row_means))\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Circular symmetry measure from center to edges\"\n    h, w = image.shape[:2]\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    center_y, center_x = h // 2, w // 2\n    if center_y == 0 or center_x == 0:\n        return 0.0\n    radius = min(center_y, center_x)\n    if radius < 2:\n        return 0.0\n    inner_circle = gray[center_y-radius//2:center_y+radius//2, center_x-radius//2:center_x+radius//2]\n    outer_ring = gray[center_y-radius:center_y+radius, center_x-radius:center_x+radius]\n    inner_mean = np.mean(inner_circle) if inner_circle.size > 0 else 0\n    outer_mean = np.mean(outer_ring) if outer_ring.size > 0 else 0\n    if outer_mean == 0:\n        return float(inner_mean)\n    return float(inner_mean / outer_mean)\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Standard deviation of column-wise intensity means\"\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    if gray.shape[1] == 0:\n        return 0.0\n    col_means = np.mean(gray, axis=0)\n    return float(np.std(col_means))\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Ratio of pixels above 75th percentile to pixels below 25th percentile\"\n    if len(image.shape) == 3:\n        flat = image.flatten()\n    else:\n        flat = image.flatten()\n    if flat.size == 0:\n        return 1.0\n    p25 = np.percentile(flat, 25)\n    p75 = np.percentile(flat, 75)\n    low_count = np.sum(flat < p25)\n    high_count = np.sum(flat > p75)\n    if low_count == 0:\n        return float(high_count)\n    return float(high_count / low_count)\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Ratio of bright pixels in top half vs bottom half of image\"\n    h, w = image.shape[:2]\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    threshold = np.percentile(gray, 75)\n    top_bright = np.count_nonzero(gray[:h//2, :] > threshold)\n    bottom_bright = np.count_nonzero(gray[h//2:, :] > threshold)\n    if bottom_bright == 0:\n        return float(top_bright)\n    return float(top_bright / bottom_bright)\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Standard deviation of pixel intensities in the four corner regions\"\n    h, w = image.shape[:2]\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    corner_size = min(h//4, w//4)\n    if corner_size == 0:\n        return 0.0\n    corners = [\n        gray[:corner_size, :corner_size],\n        gray[:corner_size, -corner_size:],\n        gray[-corner_size:, :corner_size],\n        gray[-corner_size:, -corner_size:]\n    ]\n    corner_stds = [np.std(corner) for corner in corners]\n    return float(np.mean(corner_stds))\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Proportion of pixels with red channel stronger than blue channel\"\n    if len(image.shape) == 3:\n        red = image[:, :, 0]\n        blue = image[:, :, 2]\n        red_dominant = np.count_nonzero(red > blue)\n        total_pixels = red.size\n        return float(red_dominant / total_pixels)\n    else:\n        return 0.5\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Maximum intensity difference between adjacent rows\"\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    if gray.shape[0] < 2:\n        return 0.0\n    row_means = np.mean(gray, axis=1)\n    row_diffs = np.abs(row_means[1:] - row_means[:-1])\n    return float(np.max(row_diffs))\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Asymmetry between upper-left and lower-right diagonal regions\"\n    h, w = image.shape[:2]\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    if h < 2 or w < 2:\n        return 0.0\n    upper_left = gray[:h//2, :w//2]\n    lower_right = gray[h//2:, w//2:]\n    ul_mean = np.mean(upper_left)\n    lr_mean = np.mean(lower_right)\n    return float(abs(ul_mean - lr_mean))\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Ratio of green channel intensity to red channel intensity\"\n    if len(image.shape) == 3:\n        green_mean = np.mean(image[:, :, 1])\n        red_mean = np.mean(image[:, :, 0])\n        if red_mean == 0:\n            return float(green_mean)\n        return float(green_mean / red_mean)\n    else:\n        return 1.0\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Maximum pixel intensity difference between adjacent pixels\"\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    h, w = gray.shape\n    if h < 2 or w < 2:\n        return 0.0\n    right_diff = np.max(np.abs(gray[:, 1:] - gray[:, :-1]))\n    down_diff = np.max(np.abs(gray[1:, :] - gray[:-1, :]))\n    return float(max(right_diff, down_diff))\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Proportion of image area occupied by very dark pixels (below 10th percentile)\"\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    threshold = np.percentile(gray, 10)\n    dark_pixels = np.count_nonzero(gray <= threshold)\n    return float(dark_pixels / gray.size)\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Average intensity in image border region relative to center\"\n    h, w = image.shape[:2]\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    if h < 6 or w < 6:\n        return 1.0\n    border_width = min(h//6, w//6)\n    border_mask = np.ones((h, w), dtype=bool)\n    border_mask[border_width:h-border_width, border_width:w-border_width] = False\n    center_region = gray[h//4:3*h//4, w//4:3*w//4]\n    border_mean = np.mean(gray[border_mask])\n    center_mean = np.mean(center_region)\n    if center_mean == 0:\n        return float(border_mean)\n    return float(border_mean / center_mean)\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Skewness measure using difference between mean and median intensities\"\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    flat = gray.flatten()\n    mean_val = np.mean(flat)\n    median_val = np.median(flat)\n    std_val = np.std(flat)\n    if std_val == 0:\n        return 0.0\n    return float((mean_val - median_val) / std_val)\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Uniformity of pixel distribution measured by inverse of entropy approximation\"\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    hist, _ = np.histogram(gray.flatten(), bins=16, range=(0, 256))\n    hist = hist / np.sum(hist)\n    hist = hist[hist > 0]\n    if len(hist) == 0:\n        return 0.0\n    entropy = -np.sum(hist * np.log2(hist))\n    return float(1.0 / (1.0 + entropy))\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Ratio of pixels in top half vs bottom half that exceed median intensity\"\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    h, w = gray.shape\n    median_val = np.median(gray)\n    top_half = gray[:h//2, :]\n    bottom_half = gray[h//2:, :]\n    top_bright = np.count_nonzero(top_half > median_val)\n    bottom_bright = np.count_nonzero(bottom_half > median_val)\n    if bottom_bright == 0:\n        return float(top_bright)\n    return float(top_bright / bottom_bright)\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Standard deviation of pixel intensities in corner regions\"\n    h, w = image.shape[:2]\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    corner_size = min(h//4, w//4)\n    if corner_size == 0:\n        return 0.0\n    corners = [\n        gray[:corner_size, :corner_size],\n        gray[:corner_size, -corner_size:],\n        gray[-corner_size:, :corner_size],\n        gray[-corner_size:, -corner_size:]\n    ]\n    corner_stds = [np.std(corner) for corner in corners]\n    return float(np.mean(corner_stds))\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Proportion of pixels where intensity increases from left to right\"\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    h, w = gray.shape\n    if w < 2:\n        return 0.5\n    left_right_diff = gray[:, 1:] - gray[:, :-1]\n    increasing_pixels = np.count_nonzero(left_right_diff > 0)\n    total_comparisons = (w - 1) * h\n    return float(increasing_pixels / total_comparisons)\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Average distance from center for pixels above 90th percentile brightness\"\n    h, w = image.shape[:2]\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    center_y, center_x = h // 2, w // 2\n    threshold = np.percentile(gray, 90)\n    bright_positions = np.where(gray > threshold)\n    if len(bright_positions[0]) == 0:\n        return float(max(h, w))\n    distances = np.sqrt((bright_positions[0] - center_y)**2 + (bright_positions[1] - center_x)**2)\n    return float(np.mean(distances))\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Standard deviation of pixel intensities in the bottom quarter of the image\"\n    h, w = image.shape[:2]\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    if h < 4:\n        return 0.0\n    bottom_quarter = gray[3*h//4:, :]\n    return float(np.std(bottom_quarter))\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Ratio of maximum pixel value to mean pixel value\"\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    mean_val = np.mean(gray)\n    max_val = np.max(gray)\n    if mean_val == 0:\n        return float(max_val)\n    return float(max_val / mean_val)\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Proportion of pixels in corners that are darker than image center\"\n    h, w = image.shape[:2]\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    if h < 4 or w < 4:\n        return 0.5\n    center_val = gray[h//2, w//2]\n    corner_size = min(h//4, w//4)\n    corners = np.concatenate([\n        gray[:corner_size, :corner_size].flatten(),\n        gray[:corner_size, -corner_size:].flatten(),\n        gray[-corner_size:, :corner_size].flatten(),\n        gray[-corner_size:, -corner_size:].flatten()\n    ])\n    darker_corners = np.count_nonzero(corners < center_val)\n    return float(darker_corners / len(corners))\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Average intensity difference between left and right halves of image\"\n    h, w = image.shape[:2]\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    if w < 2:\n        return 0.0\n    left_half = gray[:, :w//2]\n    right_half = gray[:, w//2:]\n    left_mean = np.mean(left_half)\n    right_mean = np.mean(right_half)\n    return float(abs(left_mean - right_mean))\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Fraction of pixels with intensity above the 75th percentile\"\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    if gray.size == 0:\n        return 0.0\n    threshold = np.percentile(gray, 75)\n    high_intensity = np.count_nonzero(gray > threshold)\n    return float(high_intensity / gray.size)\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Average red channel intensity minus average green channel intensity\"\n    if len(image.shape) == 3:\n        red_mean = np.mean(image[:, :, 0])\n        green_mean = np.mean(image[:, :, 1])\n        return float(red_mean - green_mean)\n    else:\n        return 0.0\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Ratio of variance in center region to variance in border region\"\n    h, w = image.shape[:2]\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    if h < 4 or w < 4:\n        return 1.0\n    center = gray[h//4:3*h//4, w//4:3*w//4]\n    border = np.concatenate([gray[:h//4, :].flatten(), gray[3*h//4:, :].flatten(), \n                           gray[h//4:3*h//4, :w//4].flatten(), gray[h//4:3*h//4, 3*w//4:].flatten()])\n    center_var = np.var(center)\n    border_var = np.var(border)\n    if border_var == 0:\n        return float(center_var)\n    return float(center_var / border_var)\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Proportion of image pixels that are darker than the median intensity\"\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    median_intensity = np.median(gray)\n    dark_pixels = np.count_nonzero(gray < median_intensity)\n    total_pixels = gray.size\n    return float(dark_pixels / total_pixels)\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Ratio of pixels in top 10 percent brightness to bottom 10 percent\"\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    p90 = np.percentile(gray, 90)\n    p10 = np.percentile(gray, 10)\n    bright_pixels = np.count_nonzero(gray >= p90)\n    dark_pixels = np.count_nonzero(gray <= p10)\n    if dark_pixels == 0:\n        return float(bright_pixels)\n    return float(bright_pixels / dark_pixels)\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Circular symmetry measure around image center\"\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    h, w = gray.shape\n    center_y, center_x = h // 2, w // 2\n    radius = min(center_y, center_x) // 2\n    if radius < 1:\n        return 0.0\n    angles = np.linspace(0, 2*np.pi, 8, endpoint=False)\n    intensities = []\n    for angle in angles:\n        y = int(center_y + radius * np.sin(angle))\n        x = int(center_x + radius * np.cos(angle))\n        if 0 <= y < h and 0 <= x < w:\n            intensities.append(gray[y, x])\n    return float(np.std(intensities)) if len(intensities) > 0 else 0.0\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Ratio of bright pixels in top half versus bottom half of image\"\n    h, w = image.shape[:2]\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    if h < 2:\n        return 1.0\n    top_half = gray[:h//2, :]\n    bottom_half = gray[h//2:, :]\n    threshold = np.mean(gray)\n    top_bright = np.count_nonzero(top_half > threshold)\n    bottom_bright = np.count_nonzero(bottom_half > threshold)\n    if bottom_bright == 0:\n        return float(top_bright)\n    return float(top_bright / bottom_bright)\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Variance of pixel intensities in the four corner regions\"\n    h, w = image.shape[:2]\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    if h < 4 or w < 4:\n        return 0.0\n    corner_size = min(h//4, w//4)\n    tl = gray[:corner_size, :corner_size]\n    tr = gray[:corner_size, -corner_size:]\n    bl = gray[-corner_size:, :corner_size]\n    br = gray[-corner_size:, -corner_size:]\n    corner_means = [np.mean(tl), np.mean(tr), np.mean(bl), np.mean(br)]\n    return float(np.var(corner_means))\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Concentration of dark pixels in center region\"\n    h, w = image.shape[:2]\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    if h < 4 or w < 4:\n        return 0.0\n    center_h, center_w = h//4, w//4\n    center = gray[center_h:3*center_h, center_w:3*center_w]\n    threshold = np.percentile(gray, 25)\n    dark_center = np.count_nonzero(center < threshold)\n    total_center = center.size\n    return float(dark_center / total_center if total_center > 0 else 0.0)\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Average absolute difference between adjacent horizontal pixel pairs\"\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    h, w = gray.shape\n    if w < 2:\n        return 0.0\n    diffs = np.abs(gray[:, 1:] - gray[:, :-1])\n    return float(np.mean(diffs))\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Ratio of green channel dominance over red and blue channels\"\n    if len(image.shape) == 3:\n        r_pixels = np.count_nonzero((image[:,:,1] > image[:,:,0]) & (image[:,:,1] > image[:,:,2]))\n        total_pixels = image.shape[0] * image.shape[1]\n        return float(r_pixels / total_pixels if total_pixels > 0 else 0.0)\n    else:\n        return 0.0\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Average intensity difference between top and bottom halves of image\"\n    h, w = image.shape[:2]\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    if h < 2:\n        return 0.0\n    top_half = np.mean(gray[:h//2, :])\n    bottom_half = np.mean(gray[h//2:, :])\n    return float(abs(top_half - bottom_half))\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Proportion of pixels in the brightest quartile that are in corners\"\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    h, w = gray.shape\n    if h < 4 or w < 4:\n        return 0.0\n    threshold = np.percentile(gray, 75)\n    bright_pixels = gray > threshold\n    corner_size = min(h//4, w//4)\n    corners = (bright_pixels[:corner_size, :corner_size] | \n               bright_pixels[:corner_size, -corner_size:] |\n               bright_pixels[-corner_size:, :corner_size] |\n               bright_pixels[-corner_size:, -corner_size:])\n    corner_bright = np.sum(corners)\n    total_bright = np.sum(bright_pixels)\n    if total_bright == 0:\n        return 0.0\n    return float(corner_bright / total_bright)\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Standard deviation of row-wise mean intensities\"\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    row_means = np.mean(gray, axis=1)\n    return float(np.std(row_means))\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Ratio of green channel to red channel average intensity\"\n    if len(image.shape) == 3:\n        red_mean = np.mean(image[:, :, 0])\n        green_mean = np.mean(image[:, :, 1])\n        if red_mean == 0:\n            return float(green_mean)\n        return float(green_mean / red_mean)\n    else:\n        return 1.0\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Asymmetry between left and right halves using absolute difference\"\n    h, w = image.shape[:2]\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    if w < 2:\n        return 0.0\n    left_half = gray[:, :w//2]\n    right_half = np.fliplr(gray[:, w//2:])\n    min_width = min(left_half.shape[1], right_half.shape[1])\n    left_crop = left_half[:, :min_width]\n    right_crop = right_half[:, :min_width]\n    return float(np.mean(np.abs(left_crop - right_crop)))\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Variance in pixel intensity across color channels\"\n    if len(image.shape) == 3:\n        r_var = np.var(image[:, :, 0])\n        g_var = np.var(image[:, :, 1])\n        b_var = np.var(image[:, :, 2])\n        return float(np.mean([r_var, g_var, b_var]))\n    else:\n        return float(np.var(image))\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Proportion of pixels in the center region above mean intensity\"\n    h, w = image.shape[:2]\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    center = gray[h//4:3*h//4, w//4:3*w//4]\n    if center.size == 0:\n        return 0.0\n    mean_intensity = np.mean(gray)\n    above_mean = np.count_nonzero(center > mean_intensity)\n    return float(above_mean / center.size)\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Ratio of corner pixels to edge pixels intensity\"\n    h, w = image.shape[:2]\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    if h < 4 or w < 4:\n        return 1.0\n    corners = gray[0, 0] + gray[0, -1] + gray[-1, 0] + gray[-1, -1]\n    edge_sum = np.sum(gray[0, :]) + np.sum(gray[-1, :]) + np.sum(gray[:, 0]) + np.sum(gray[:, -1])\n    if edge_sum == 0:\n        return float(corners)\n    return float(corners / edge_sum * (h + w - 4))\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Standard deviation of pixel intensities in top third of image\"\n    h, w = image.shape[:2]\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    top_third = gray[:h//3, :]\n    if top_third.size == 0:\n        return 0.0\n    return float(np.std(top_third))\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Ratio of bright pixels in center to bright pixels in edges\"\n    h, w = image.shape[:2]\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    bright_threshold = np.percentile(gray, 75)\n    center = gray[h//4:3*h//4, w//4:3*w//4]\n    edge_mask = np.ones_like(gray, dtype=bool)\n    edge_mask[h//4:3*h//4, w//4:3*w//4] = False\n    edges = gray[edge_mask]\n    center_bright = np.count_nonzero(center > bright_threshold) if center.size > 0 else 0\n    edge_bright = np.count_nonzero(edges > bright_threshold) if edges.size > 0 else 0\n    if edge_bright == 0:\n        return float(center_bright)\n    return float(center_bright / edge_bright)\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Proportion of image area occupied by connected bright regions\"\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    threshold = np.percentile(gray, 85)\n    bright_pixels = gray > threshold\n    return float(np.sum(bright_pixels) / gray.size)\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Difference between left half and right half average intensities\"\n    h, w = image.shape[:2]\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    if w < 2:\n        return 0.0\n    left_half = gray[:, :w//2]\n    right_half = gray[:, w//2:]\n    return float(np.mean(left_half) - np.mean(right_half))\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Standard deviation of pixel intensities in circular center region\"\n    h, w = image.shape[:2]\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    center_y, center_x = h // 2, w // 2\n    radius = min(h, w) // 4\n    y, x = np.ogrid[:h, :w]\n    mask = (y - center_y) ** 2 + (x - center_x) ** 2 <= radius ** 2\n    if np.sum(mask) == 0:\n        return float(np.std(gray))\n    return float(np.std(gray[mask]))\n\n",
  "def feature(image: np.ndarray) -> float:\n    \"Ratio of dark pixels in top third to bottom third of image\"\n    h, w = image.shape[:2]\n    if len(image.shape) == 3:\n        gray = np.mean(image, axis=2)\n    else:\n        gray = image\n    if h < 3:\n        return 1.0\n    threshold = np.percentile(gray, 25)\n    top_third = gray[:h//3, :]\n    bottom_third = gray[2*h//3:, :]\n    top_dark = np.sum(top_third < threshold)\n    bottom_dark = np.sum(bottom_third < threshold)\n    if bottom_dark == 0:\n        return float(top_dark)\n    return float(top_dark / bottom_dark)\n\n"
]